<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2002-2019, the original author or authors.
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
   7  * https://opensource.org/licenses/BSD-3-Clause
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 
  11 import java.io.Flushable;
  12 import java.io.IOError;
  13 import java.io.IOException;
  14 import java.io.InputStream;
  15 import java.io.InterruptedIOException;
  16 import java.time.Instant;
  17 import java.util.*;
  18 import java.util.Map.Entry;
  19 import java.util.concurrent.atomic.AtomicBoolean;
  20 import java.util.concurrent.locks.Lock;
  21 import java.util.concurrent.locks.ReentrantLock;
  22 import java.util.function.*;
  23 import java.util.regex.Matcher;
  24 import java.util.regex.Pattern;
  25 import java.util.stream.Collectors;
  26 import java.util.stream.Stream;
  27 import java.util.stream.StreamSupport;
  28 
  29 import jdk.internal.org.jline.keymap.BindingReader;
  30 import jdk.internal.org.jline.keymap.KeyMap;
  31 import jdk.internal.org.jline.reader.*;
  32 import jdk.internal.org.jline.reader.Parser.ParseContext;
  33 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  34 import jdk.internal.org.jline.terminal.*;
  35 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  36 import jdk.internal.org.jline.terminal.Terminal.Signal;
  37 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
  38 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
  39 import jdk.internal.org.jline.utils.AttributedString;
  40 import jdk.internal.org.jline.utils.AttributedStringBuilder;
  41 import jdk.internal.org.jline.utils.AttributedStyle;
  42 import jdk.internal.org.jline.utils.Curses;
  43 import jdk.internal.org.jline.utils.Display;
  44 import jdk.internal.org.jline.utils.InfoCmp.Capability;
  45 import jdk.internal.org.jline.utils.Levenshtein;
  46 import jdk.internal.org.jline.utils.Log;
  47 import jdk.internal.org.jline.utils.Status;
  48 import jdk.internal.org.jline.utils.WCWidth;
  49 
  50 import static jdk.internal.org.jline.keymap.KeyMap.alt;
  51 import static jdk.internal.org.jline.keymap.KeyMap.ctrl;
  52 import static jdk.internal.org.jline.keymap.KeyMap.del;
  53 import static jdk.internal.org.jline.keymap.KeyMap.esc;
  54 import static jdk.internal.org.jline.keymap.KeyMap.range;
  55 import static jdk.internal.org.jline.keymap.KeyMap.translate;
  56 
  57 /**
  58  * A reader for terminal applications. It supports custom tab-completion,
  59  * saveable command history, and command line editing.
  60  *
  61  * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
  62  * @author &lt;a href=&quot;mailto:jason@planet57.com&quot;&gt;Jason Dillon&lt;/a&gt;
  63  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
  64  */
  65 @SuppressWarnings(&quot;StatementWithEmptyBody&quot;)
  66 public class LineReaderImpl implements LineReader, Flushable
  67 {
  68     public static final char NULL_MASK = 0;
  69 
  70     public static final int TAB_WIDTH = 4;
  71 
  72 
  73     public static final String DEFAULT_WORDCHARS = &quot;*?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;&quot;;
  74     public static final String DEFAULT_REMOVE_SUFFIX_CHARS = &quot; \t\n;&amp;|&quot;;
  75     public static final String DEFAULT_COMMENT_BEGIN = &quot;#&quot;;
  76     public static final String DEFAULT_SEARCH_TERMINATORS = &quot;\033\012&quot;;
  77     public static final String DEFAULT_BELL_STYLE = &quot;&quot;;
  78     public static final int    DEFAULT_LIST_MAX = 100;
  79     public static final int    DEFAULT_ERRORS = 2;
  80     public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;
  81     public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;
  82     public static final String DEFAULT_SECONDARY_PROMPT_PATTERN = &quot;%M&gt; &quot;;
  83     public static final String DEFAULT_OTHERS_GROUP_NAME = &quot;others&quot;;
  84     public static final String DEFAULT_ORIGINAL_GROUP_NAME = &quot;original&quot;;
  85     public static final String DEFAULT_COMPLETION_STYLE_STARTING = &quot;36&quot;;    // cyan
  86     public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = &quot;90&quot;; // dark gray
  87     public static final String DEFAULT_COMPLETION_STYLE_GROUP = &quot;35;1&quot;;     // magenta
  88     public static final String DEFAULT_COMPLETION_STYLE_SELECTION = &quot;7&quot;;    // inverted
  89 
  90     private static final int MIN_ROWS = 3;
  91 
  92     public static final String BRACKETED_PASTE_ON = &quot;\033[?2004h&quot;;
  93     public static final String BRACKETED_PASTE_OFF = &quot;\033[?2004l&quot;;
  94     public static final String BRACKETED_PASTE_BEGIN = &quot;\033[200~&quot;;
  95     public static final String BRACKETED_PASTE_END = &quot;\033[201~&quot;;
  96 
  97     public static final String FOCUS_IN_SEQ = &quot;\033[I&quot;;
  98     public static final String FOCUS_OUT_SEQ = &quot;\033[O&quot;;
  99 
 100     /**
 101      * Possible states in which the current readline operation may be in.
 102      */
 103     protected enum State {
 104         /**
 105          * The user is just typing away
 106          */
 107         NORMAL,
 108         /**
 109          * readLine should exit and return the buffer content
 110          */
 111         DONE,
 112         /**
 113          * readLine should exit and throw an EOFException
 114          */
 115         EOF,
 116         /**
 117          * readLine should exit and throw an UserInterruptException
 118          */
 119         INTERRUPT
 120     }
 121 
 122     protected enum ViMoveMode {
 123         NORMAL,
 124         YANK,
 125         DELETE,
 126         CHANGE
 127     }
 128 
 129     protected enum BellType {
 130         NONE,
 131         AUDIBLE,
 132         VISIBLE
 133     }
 134 
 135     //
 136     // Constructor variables
 137     //
 138 
 139     /** The terminal to use */
 140     protected final Terminal terminal;
 141     /** The application name */
 142     protected final String appName;
 143     /** The terminal keys mapping */
 144     protected final Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps;
 145 
 146     //
 147     // Configuration
 148     //
 149     protected final Map&lt;String, Object&gt; variables;
 150     protected History history = new DefaultHistory();
 151     protected Completer completer = null;
 152     protected Highlighter highlighter = new DefaultHighlighter();
 153     protected Parser parser = new DefaultParser();
 154     protected Expander expander = new DefaultExpander();
 155 
 156     //
 157     // State variables
 158     //
 159 
 160     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 161 
 162     protected final Buffer buf = new BufferImpl();
 163 
 164     protected final Size size = new Size();
 165 
 166     protected AttributedString prompt = AttributedString.EMPTY;
 167     protected AttributedString rightPrompt = AttributedString.EMPTY;
 168 
 169     protected MaskingCallback maskingCallback;
 170 
 171     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 172     protected Buffer historyBuffer = null;
 173     protected CharSequence searchBuffer;
 174     protected StringBuffer searchTerm = null;
 175     protected boolean searchFailing;
 176     protected boolean searchBackward;
 177     protected int searchIndex = -1;
 178 
 179 
 180     // Reading buffers
 181     protected final BindingReader bindingReader;
 182 
 183 
 184     /**
 185      * VI character find
 186      */
 187     protected int findChar;
 188     protected int findDir;
 189     protected int findTailAdd;
 190     /**
 191      * VI history string search
 192      */
 193     private int searchDir;
 194     private String searchString;
 195 
 196     /**
 197      * Region state
 198      */
 199     protected int regionMark;
 200     protected RegionType regionActive;
 201 
 202     private boolean forceChar;
 203     private boolean forceLine;
 204 
 205     /**
 206      * The vi yank buffer
 207      */
 208     protected String yankBuffer = &quot;&quot;;
 209 
 210     protected ViMoveMode viMoveMode = ViMoveMode.NORMAL;
 211 
 212     protected KillRing killRing = new KillRing();
 213 
 214     protected UndoTree&lt;Buffer&gt; undo = new UndoTree&lt;&gt;(this::setBuffer);
 215     protected boolean isUndo;
 216 
 217     /**
 218      * State lock
 219      */
 220     protected final ReentrantLock lock = new ReentrantLock();
 221     /*
 222      * Current internal state of the line reader
 223      */
 224     protected State   state = State.DONE;
 225     protected final AtomicBoolean startedReading = new AtomicBoolean();
 226     protected boolean reading;
 227 
 228     protected Supplier&lt;AttributedString&gt; post;
 229 
 230     protected Map&lt;String, Widget&gt; builtinWidgets;
 231     protected Map&lt;String, Widget&gt; widgets;
 232 
 233     protected int count;
 234     protected int mult;
 235     protected int universal = 4;
 236     protected int repeatCount;
 237     protected boolean isArgDigit;
 238 
 239     protected ParsedLine parsedLine;
 240 
 241     protected boolean skipRedisplay;
 242     protected Display display;
 243 
 244     protected boolean overTyping = false;
 245 
 246     protected String keyMap;
 247 
 248     protected int smallTerminalOffset = 0;
 249 
 250     /*
 251      * accept-and-infer-next-history, accept-and-hold &amp; accept-line-and-down-history
 252      */
 253     protected boolean nextCommandFromHistory = false;
 254     protected int nextHistoryId = -1;
 255 
 256 
 257     public LineReaderImpl(Terminal terminal) throws IOException {
 258         this(terminal, null, null);
 259     }
 260 
 261     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 262         this(terminal, appName, null);
 263     }
 264 
 265     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 266         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 267         this.terminal = terminal;
 268         if (appName == null) {
 269             appName = &quot;JLine&quot;;
 270         }
 271         this.appName = appName;
 272         if (variables != null) {
 273             this.variables = variables;
 274         } else {
 275             this.variables = new HashMap&lt;&gt;();
 276         }
 277         this.keyMaps = defaultKeyMaps();
 278 
 279         builtinWidgets = builtinWidgets();
 280         widgets = new HashMap&lt;&gt;(builtinWidgets);
 281         bindingReader = new BindingReader(terminal.reader());
 282         doDisplay();
 283     }
 284 
 285     public Terminal getTerminal() {
 286         return terminal;
 287     }
 288 
 289     public String getAppName() {
 290         return appName;
 291     }
 292 
 293     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; getKeyMaps() {
 294         return keyMaps;
 295     }
 296 
 297     public KeyMap&lt;Binding&gt; getKeys() {
 298         return keyMaps.get(keyMap);
 299     }
 300 
 301     @Override
 302     public Map&lt;String, Widget&gt; getWidgets() {
 303         return widgets;
 304     }
 305 
 306     @Override
 307     public Map&lt;String, Widget&gt; getBuiltinWidgets() {
 308         return Collections.unmodifiableMap(builtinWidgets);
 309     }
 310 
 311     @Override
 312     public Buffer getBuffer() {
 313         return buf;
 314     }
 315 
 316     @Override
 317     public void runMacro(String macro) {
 318         bindingReader.runMacro(macro);
 319     }
 320 
 321     @Override
 322     public MouseEvent readMouseEvent() {
 323         return terminal.readMouseEvent(bindingReader::readCharacter);
 324     }
 325 
 326     /**
 327      * Set the completer.
 328      *
 329      * @param completer the completer to use
 330      */
 331     public void setCompleter(Completer completer) {
 332         this.completer = completer;
 333     }
 334 
 335     /**
 336      * Returns the completer.
 337      *
 338      * @return the completer
 339      */
 340     public Completer getCompleter() {
 341         return completer;
 342     }
 343 
 344     //
 345     // History
 346     //
 347 
 348     public void setHistory(final History history) {
 349         Objects.requireNonNull(history);
 350         this.history = history;
 351     }
 352 
 353     public History getHistory() {
 354         return history;
 355     }
 356 
 357     //
 358     // Highlighter
 359     //
 360 
 361     public void setHighlighter(Highlighter highlighter) {
 362         this.highlighter = highlighter;
 363     }
 364 
 365     public Highlighter getHighlighter() {
 366         return highlighter;
 367     }
 368 
 369     public Parser getParser() {
 370         return parser;
 371     }
 372 
 373     public void setParser(Parser parser) {
 374         this.parser = parser;
 375     }
 376 
 377     @Override
 378     public Expander getExpander() {
 379         return expander;
 380     }
 381 
 382     public void setExpander(Expander expander) {
 383         this.expander = expander;
 384     }
 385 
 386     //
 387     // Line Reading
 388     //
 389 
 390     /**
 391      * Read the next line and return the contents of the buffer.
 392      *
 393      * @return          A line that is read from the terminal, can never be null.
 394      */
 395     public String readLine() throws UserInterruptException, EndOfFileException {
 396         return readLine(null, null, (MaskingCallback) null, null);
 397     }
 398 
 399     /**
 400      * Read the next line with the specified character mask. If null, then
 401      * characters will be echoed. If 0, then no characters will be echoed.
 402      *
 403      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 404      * @return          A line that is read from the terminal, can never be null.
 405      */
 406     public String readLine(Character mask) throws UserInterruptException, EndOfFileException {
 407         return readLine(null, null, mask, null);
 408     }
 409 
 410     /**
 411      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 412      * (without any trailing newlines).
 413      *
 414      * @param prompt    The prompt to issue to the terminal, may be null.
 415      * @return          A line that is read from the terminal, can never be null.
 416      */
 417     public String readLine(String prompt) throws UserInterruptException, EndOfFileException {
 418         return readLine(prompt, null, (MaskingCallback) null, null);
 419     }
 420 
 421     /**
 422      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 423      * (without any trailing newlines).
 424      *
 425      * @param prompt    The prompt to issue to the terminal, may be null.
 426      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 427      * @return          A line that is read from the terminal, can never be null.
 428      */
 429     public String readLine(String prompt, Character mask) throws UserInterruptException, EndOfFileException {
 430         return readLine(prompt, null, mask, null);
 431     }
 432 
 433     /**
 434      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 435      * (without any trailing newlines).
 436      *
 437      * @param prompt    The prompt to issue to the terminal, may be null.
 438      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 439      * @param buffer    A string that will be set for editing.
 440      * @return          A line that is read from the terminal, can never be null.
 441      */
 442     public String readLine(String prompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 443         return readLine(prompt, null, mask, buffer);
 444     }
 445 
 446     /**
 447      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 448      * (without any trailing newlines).
 449      *
 450      * @param prompt      The prompt to issue to the terminal, may be null.
 451      * @param rightPrompt The prompt to issue to the right of the terminal, may be null.
 452      * @param mask        The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 453      * @param buffer      A string that will be set for editing.
 454      * @return            A line that is read from the terminal, can never be null.
 455      */
 456     public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 457         return readLine(prompt, rightPrompt, mask != null ? new SimpleMaskingCallback(mask) : null, buffer);
 458     }
 459 
 460     /**
 461      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 462      * (without any trailing newlines).
 463      *
 464      * @param prompt          The prompt to issue to the terminal, may be null.
 465      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 466      * @param maskingCallback The callback used to mask parts of the edited line.
 467      * @param buffer          A string that will be set for editing.
 468      * @return                A line that is read from the terminal, can never be null.
 469      */
 470     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 471         // prompt may be null
 472         // maskingCallback may be null
 473         // buffer may be null
 474 
 475         if (!startedReading.compareAndSet(false, true)) {
 476             throw new IllegalStateException();
 477         }
 478 
 479         Thread readLineThread = Thread.currentThread();
 480         SignalHandler previousIntrHandler = null;
 481         SignalHandler previousWinchHandler = null;
 482         SignalHandler previousContHandler = null;
 483         Attributes originalAttributes = null;
 484         boolean dumb = isTerminalDumb();
 485         try {
 486 
 487             this.maskingCallback = maskingCallback;
 488 
 489             /*
 490              * This is the accumulator for VI-mode repeat count. That is, while in
 491              * move mode, if you type 30x it will delete 30 characters. This is
 492              * where the &quot;30&quot; is accumulated until the command is struck.
 493              */
 494             repeatCount = 0;
 495             mult = 1;
 496             regionActive = RegionType.NONE;
 497             regionMark = -1;
 498 
 499             smallTerminalOffset = 0;
 500 
 501             state = State.NORMAL;
 502 
 503             modifiedHistory.clear();
 504 
 505             setPrompt(prompt);
 506             setRightPrompt(rightPrompt);
 507             buf.clear();
 508             if (buffer != null) {
 509                 buf.write(buffer);
 510             }
 511             if (nextCommandFromHistory &amp;&amp; nextHistoryId &gt; 0) {
 512                 if (history.size() &gt; nextHistoryId) {
 513                     history.moveTo(nextHistoryId);
 514                 } else {
 515                     history.moveTo(history.last());
 516                 }
 517                 buf.write(history.current());
 518             } else {
 519                 nextHistoryId = -1;
 520             }
 521             nextCommandFromHistory = false;
 522             undo.clear();
 523             parsedLine = null;
 524             keyMap = MAIN;
 525 
 526             if (history != null) {
 527                 history.attach(this);
 528             }
 529 
 530             try {
 531                 lock.lock();
 532 
 533                 this.reading = true;
 534 
 535                 previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
 536                 previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
 537                 previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
 538                 originalAttributes = terminal.enterRawMode();
 539 
 540                 doDisplay();
 541 
 542                 // Move into application mode
 543                 if (!dumb) {
 544                     terminal.puts(Capability.keypad_xmit);
 545                     if (isSet(Option.AUTO_FRESH_LINE))
 546                         callWidget(FRESH_LINE);
 547                     if (isSet(Option.MOUSE))
 548                         terminal.trackMouse(Terminal.MouseTracking.Normal);
 549                     if (isSet(Option.BRACKETED_PASTE))
 550                         terminal.writer().write(BRACKETED_PASTE_ON);
 551                 } else {
 552                     // For dumb terminals, we need to make sure that CR are ignored
 553                     Attributes attr = new Attributes(originalAttributes);
 554                     attr.setInputFlag(Attributes.InputFlag.IGNCR, true);
 555                     terminal.setAttributes(attr);
 556                 }
 557 
 558                 callWidget(CALLBACK_INIT);
 559 
 560                 undo.newState(buf.copy());
 561 
 562                 // Draw initial prompt
 563                 redrawLine();
 564                 redisplay();
 565             } finally {
 566                 lock.unlock();
 567             }
 568 
 569             while (true) {
 570 
 571                 KeyMap&lt;Binding&gt; local = null;
 572                 if (isInViCmdMode() &amp;&amp; regionActive != RegionType.NONE) {
 573                     local = keyMaps.get(VISUAL);
 574                 }
 575                 Binding o = readBinding(getKeys(), local);
 576                 if (o == null) {
 577                     throw new EndOfFileException();
 578                 }
 579                 Log.trace(&quot;Binding: &quot;, o);
 580                 if (buf.length() == 0 &amp;&amp; getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {
 581                     throw new EndOfFileException();
 582                 }
 583 
 584                 // If this is still false after handling the binding, then
 585                 // we reset our repeatCount to 0.
 586                 isArgDigit = false;
 587                 // Every command that can be repeated a specified number
 588                 // of times, needs to know how many times to repeat, so
 589                 // we figure that out here.
 590                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 591                 // Reset undo/redo flag
 592                 isUndo = false;
 593                 // Reset region after a paste
 594                 if (regionActive == RegionType.PASTE) {
 595                     regionActive = RegionType.NONE;
 596                 }
 597 
 598                 try {
 599                     lock.lock();
 600                     // Get executable widget
 601                     Buffer copy = buf.copy();
 602                     Widget w = getWidget(o);
 603                     if (!w.apply()) {
 604                         beep();
 605                     }
 606                     if (!isUndo &amp;&amp; !copy.toString().equals(buf.toString())) {
 607                         undo.newState(buf.copy());
 608                     }
 609 
 610                     switch (state) {
 611                         case DONE:
 612                             return finishBuffer();
 613                         case EOF:
 614                             throw new EndOfFileException();
 615                         case INTERRUPT:
 616                             throw new UserInterruptException(buf.toString());
 617                     }
 618 
 619                     if (!isArgDigit) {
 620                         /*
 621                          * If the operation performed wasn&#39;t a vi argument
 622                          * digit, then clear out the current repeatCount;
 623                          */
 624                         repeatCount = 0;
 625                         mult = 1;
 626                     }
 627 
 628                     if (!dumb) {
 629                         redisplay();
 630                     }
 631                 } finally {
 632                     lock.unlock();
 633                 }
 634             }
 635         } catch (IOError e) {
 636             if (e.getCause() instanceof InterruptedIOException) {
 637                 throw new UserInterruptException(buf.toString());
 638             } else {
 639                 throw e;
 640             }
 641         }
 642         finally {
 643             try {
 644                 lock.lock();
 645 
 646                 this.reading = false;
 647 
 648                 cleanup();
 649                 if (originalAttributes != null) {
 650                     terminal.setAttributes(originalAttributes);
 651                 }
 652                 if (previousIntrHandler != null) {
 653                     terminal.handle(Signal.INT, previousIntrHandler);
 654                 }
 655                 if (previousWinchHandler != null) {
 656                     terminal.handle(Signal.WINCH, previousWinchHandler);
 657                 }
 658                 if (previousContHandler != null) {
 659                     terminal.handle(Signal.CONT, previousContHandler);
 660                 }
 661             } finally {
 662                 lock.unlock();
 663             }
 664             startedReading.set(false);
 665         }
 666     }
 667 
 668     private boolean isTerminalDumb(){
 669         return Terminal.TYPE_DUMB.equals(terminal.getType())
 670                 || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());
 671     }
 672 
 673     private void doDisplay(){
 674         // Cache terminal size for the duration of the call to readLine()
 675         // It will eventually be updated with WINCH signals
 676         size.copy(terminal.getBufferSize());
 677 
 678         display = new Display(terminal, false);
 679         if (size.getRows() == 0 || size.getColumns() == 0) {
 680             display.resize(1, Integer.MAX_VALUE);
 681         } else {
 682             display.resize(size.getRows(), size.getColumns());
 683         }
 684         if (isSet(Option.DELAY_LINE_WRAP))
 685             display.setDelayLineWrap(true);
 686     }
 687 
 688     @Override
 689     public void printAbove(String str) {
 690         try {
 691             lock.lock();
 692 
 693             boolean reading = this.reading;
 694             if (reading) {
 695                 display.update(Collections.emptyList(), 0);
 696             }
 697             if (str.endsWith(&quot;\n&quot;) || str.endsWith(&quot;\n\033[m&quot;) || str.endsWith(&quot;\n\033[0m&quot;)) {
 698                 terminal.writer().print(str);
 699             } else {
 700                 terminal.writer().println(str);
 701             }
 702             if (reading) {
 703                 redisplay(false);
 704             }
 705             terminal.flush();
 706         } finally {
 707             lock.unlock();
 708         }
 709     }
 710 
 711     @Override
 712     public void printAbove(AttributedString str) {
 713         printAbove(str.toAnsi(terminal));
 714     }
 715 
 716     @Override
 717     public boolean isReading() {
 718         try {
 719             lock.lock();
 720             return reading;
 721         } finally {
 722             lock.unlock();
 723         }
 724     }
 725 
 726     /* Make sure we position the cursor on column 0 */
 727     protected boolean freshLine() {
 728         boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
 729         boolean delayedWrapAtEol = wrapAtEol &amp;&amp; terminal.getBooleanCapability(Capability.eat_newline_glitch);
 730         AttributedStringBuilder sb = new AttributedStringBuilder();
 731         sb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLACK + AttributedStyle.BRIGHT));
 732         sb.append(&quot;~&quot;);
 733         sb.style(AttributedStyle.DEFAULT);
 734         if (!wrapAtEol || delayedWrapAtEol) {
 735             for (int i = 0; i &lt; size.getColumns() - 1; i++) {
 736                 sb.append(&quot; &quot;);
 737             }
 738             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 739             sb.append(&quot; &quot;);
 740             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 741         } else {
 742             // Given the terminal will wrap automatically,
 743             // we need to print one less than needed.
 744             // This means that the last character will not
 745             // be overwritten, and that&#39;s why we&#39;re using
 746             // a clr_eol first if possible.
 747             String el = terminal.getStringCapability(Capability.clr_eol);
 748             if (el != null) {
 749                 Curses.tputs(sb, el);
 750             }
 751             for (int i = 0; i &lt; size.getColumns() - 2; i++) {
 752                 sb.append(&quot; &quot;);
 753             }
 754             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 755             sb.append(&quot; &quot;);
 756             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 757         }
 758         sb.print(terminal);
 759         return true;
 760     }
 761 
 762     @Override
 763     public void callWidget(String name) {
 764         try {
 765             lock.lock();
 766             if (!reading) {
 767                 throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);
 768             }
 769             try {
 770                 Widget w;
 771                 if (name.startsWith(&quot;.&quot;)) {
 772                     w = builtinWidgets.get(name.substring(1));
 773                 } else {
 774                     w = widgets.get(name);
 775                 }
 776                 if (w != null) {
 777                     w.apply();
 778                 }
 779             } catch (Throwable t) {
 780                 Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);
 781             }
 782         } finally {
 783             lock.unlock();
 784         }
 785     }
 786 
 787     /**
 788      * Clear the line and redraw it.
 789      * @return &lt;code&gt;true&lt;/code&gt;
 790      */
 791     public boolean redrawLine() {
 792         display.reset();
 793         return true;
 794     }
 795 
 796     /**
 797      * Write out the specified string to the buffer and the output stream.
 798      * @param str the char sequence to write in the buffer
 799      */
 800     public void putString(final CharSequence str) {
 801         buf.write(str, overTyping);
 802     }
 803 
 804     /**
 805      * Flush the terminal output stream. This is important for printout out single
 806      * characters (like a buf.backspace or keyboard) that we want the terminal to
 807      * handle immediately.
 808      */
 809     public void flush() {
 810         terminal.flush();
 811     }
 812 
 813     public boolean isKeyMap(String name) {
 814         return keyMap.equals(name);
 815     }
 816 
 817     /**
 818      * Read a character from the terminal.
 819      *
 820      * @return the character, or -1 if an EOF is received.
 821      */
 822     public int readCharacter() {
 823         if (lock.isHeldByCurrentThread()) {
 824             try {
 825                 lock.unlock();
 826                 return bindingReader.readCharacter();
 827             } finally {
 828                 lock.lock();
 829             }
 830         } else {
 831             return bindingReader.readCharacter();
 832         }
 833     }
 834 
 835     public int peekCharacter(long timeout) {
 836         return bindingReader.peekCharacter(timeout);
 837     }
 838 
 839     protected &lt;T&gt; T doReadBinding(KeyMap&lt;T&gt; keys, KeyMap&lt;T&gt; local) {
 840         if (lock.isHeldByCurrentThread()) {
 841             try {
 842                 lock.unlock();
 843                 return bindingReader.readBinding(keys, local);
 844             } finally {
 845                 lock.lock();
 846             }
 847         } else {
 848             return bindingReader.readBinding(keys, local);
 849         }
 850     }
 851 
 852     /**
 853      * Read from the input stream and decode an operation from the key map.
 854      *
 855      * The input stream will be read character by character until a matching
 856      * binding can be found.  Characters that can&#39;t possibly be matched to
 857      * any binding will be discarded.
 858      *
 859      * @param keys the KeyMap to use for decoding the input stream
 860      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 861      *         stream has been reached
 862      */
 863     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 864         return readBinding(keys, null);
 865     }
 866 
 867     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
 868         Binding o = doReadBinding(keys, local);
 869         /*
 870          * The kill ring keeps record of whether or not the
 871          * previous command was a yank or a kill. We reset
 872          * that state here if needed.
 873          */
 874         if (o instanceof Reference) {
 875             String ref = ((Reference) o).name();
 876             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 877                 killRing.resetLastYank();
 878             }
 879             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 880                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 881                 killRing.resetLastKill();
 882             }
 883         }
 884         return o;
 885     }
 886 
 887     @Override
 888     public ParsedLine getParsedLine() {
 889         return parsedLine;
 890     }
 891 
 892     public String getLastBinding() {
 893         return bindingReader.getLastBinding();
 894     }
 895 
 896     public String getSearchTerm() {
 897         return searchTerm != null ? searchTerm.toString() : null;
 898     }
 899 
 900     @Override
 901     public RegionType getRegionActive() {
 902         return regionActive;
 903     }
 904 
 905     @Override
 906     public int getRegionMark() {
 907         return regionMark;
 908     }
 909 
 910     //
 911     // Key Bindings
 912     //
 913 
 914     /**
 915      * Sets the current keymap by name. Supported keymaps are &quot;emacs&quot;,
 916      * &quot;viins&quot;, &quot;vicmd&quot;.
 917      * @param name The name of the keymap to switch to
 918      * @return true if the keymap was set, or false if the keymap is
 919      *    not recognized.
 920      */
 921     public boolean setKeyMap(String name) {
 922         KeyMap&lt;Binding&gt; map = keyMaps.get(name);
 923         if (map == null) {
 924             return false;
 925         }
 926         this.keyMap = name;
 927         if (reading) {
 928             callWidget(CALLBACK_KEYMAP);
 929         }
 930         return true;
 931     }
 932 
 933     /**
 934      * Returns the name of the current key mapping.
 935      * @return the name of the key mapping. This will be the canonical name
 936      *   of the current mode of the key map and may not reflect the name that
 937      *   was used with {@link #setKeyMap(String)}.
 938      */
 939     public String getKeyMap() {
 940         return keyMap;
 941     }
 942 
 943     @Override
 944     public LineReader variable(String name, Object value) {
 945         variables.put(name, value);
 946         return this;
 947     }
 948 
 949     @Override
 950     public Map&lt;String, Object&gt; getVariables() {
 951         return variables;
 952     }
 953 
 954     @Override
 955     public Object getVariable(String name) {
 956         return variables.get(name);
 957     }
 958 
 959     @Override
 960     public void setVariable(String name, Object value) {
 961         variables.put(name, value);
 962     }
 963 
 964     @Override
 965     public LineReader option(Option option, boolean value) {
 966         options.put(option, value);
 967         return this;
 968     }
 969 
 970     @Override
 971     public boolean isSet(Option option) {
 972         Boolean b = options.get(option);
 973         return b != null ? b : option.isDef();
 974     }
 975 
 976     @Override
 977     public void setOpt(Option option) {
 978         options.put(option, Boolean.TRUE);
 979     }
 980 
 981     @Override
 982     public void unsetOpt(Option option) {
 983         options.put(option, Boolean.FALSE);
 984     }
 985 
 986 
 987 
 988     //
 989     // Widget implementation
 990     //
 991 
 992     /**
 993      * Clear the buffer and add its contents to the history.
 994      *
 995      * @return the former contents of the buffer.
 996      */
 997     protected String finishBuffer() {
 998         String str = buf.toString();
 999         String historyLine = str;
1000 
1001         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
1002             StringBuilder sb = new StringBuilder();
1003             boolean escaped = false;
1004             for (int i = 0; i &lt; str.length(); i++) {
1005                 char ch = str.charAt(i);
1006                 if (escaped) {
1007                     escaped = false;
1008                     if (ch != &#39;\n&#39;) {
1009                         sb.append(ch);
1010                     }
1011                 } else if (parser.isEscapeChar(ch)) {
1012                     escaped = true;
1013                 } else {
1014                     sb.append(ch);
1015                 }
1016             }
1017             str = sb.toString();
1018         }
1019 
1020         if (maskingCallback != null) {
1021             historyLine = maskingCallback.history(historyLine);
1022         }
1023 
1024         // we only add it to the history if the buffer is not empty
1025         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
1026             history.add(Instant.now(), historyLine);
1027         }
1028         return str;
1029     }
1030 
1031     protected void handleSignal(Signal signal) {
1032         if (signal == Signal.WINCH) {
1033             Status status = Status.getStatus(terminal, false);
1034             if (status != null) {
1035                 status.hardReset();
1036             }
1037             size.copy(terminal.getBufferSize());
1038             display.resize(size.getRows(), size.getColumns());
1039             redrawLine();
1040             redisplay();
1041         }
1042         else if (signal == Signal.CONT) {
1043             terminal.enterRawMode();
1044             size.copy(terminal.getBufferSize());
1045             display.resize(size.getRows(), size.getColumns());
1046             terminal.puts(Capability.keypad_xmit);
1047             redrawLine();
1048             redisplay();
1049         }
1050     }
1051 
1052     @SuppressWarnings(&quot;unchecked&quot;)
1053     protected Widget getWidget(Object binding) {
1054         Widget w;
1055         if (binding instanceof Widget) {
1056             w = (Widget) binding;
1057         } else if (binding instanceof Macro) {
1058             String macro = ((Macro) binding).getSequence();
1059             w = () -&gt; {
1060                 bindingReader.runMacro(macro);
1061                 return true;
1062             };
1063         } else if (binding instanceof Reference) {
1064             String name = ((Reference) binding).name();
1065             w = widgets.get(name);
1066             if (w == null) {
1067                 w = () -&gt; {
1068                     post = () -&gt; new AttributedString(&quot;No such widget `&quot; + name + &quot;&#39;&quot;);
1069                     return false;
1070                 };
1071             }
1072         } else {
1073             w = () -&gt; {
1074                 post = () -&gt; new AttributedString(&quot;Unsupported widget&quot;);
1075                 return false;
1076             };
1077         }
1078         return w;
1079     }
1080 
1081     //
1082     // Helper methods
1083     //
1084 
1085     public void setPrompt(final String prompt) {
1086         this.prompt = (prompt == null ? AttributedString.EMPTY
1087                        : expandPromptPattern(prompt, 0, &quot;&quot;, 0));
1088     }
1089 
1090     public void setRightPrompt(final String rightPrompt) {
1091         this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY
1092                             : expandPromptPattern(rightPrompt, 0, &quot;&quot;, 0));
1093     }
1094 
1095     protected void setBuffer(Buffer buffer) {
1096         buf.copyFrom(buffer);
1097     }
1098 
1099     /**
1100      * Set the current buffer&#39;s content to the specified {@link String}. The
1101      * visual terminal will be modified to show the current buffer.
1102      *
1103      * @param buffer the new contents of the buffer.
1104      */
1105     protected void setBuffer(final String buffer) {
1106         buf.clear();
1107         buf.write(buffer);
1108     }
1109 
1110     /**
1111      * This method is calling while doing a delete-to (&quot;d&quot;), change-to (&quot;c&quot;),
1112      * or yank-to (&quot;y&quot;) and it filters out only those movement operations
1113      * that are allowable during those operations. Any operation that isn&#39;t
1114      * allow drops you back into movement mode.
1115      *
1116      * @param op The incoming operation to remap
1117      * @return The remaped operation
1118      */
1119     protected String viDeleteChangeYankToRemap (String op) {
1120         switch (op) {
1121             case SEND_BREAK:
1122             case BACKWARD_CHAR:
1123             case FORWARD_CHAR:
1124             case END_OF_LINE:
1125             case VI_MATCH_BRACKET:
1126             case VI_DIGIT_OR_BEGINNING_OF_LINE:
1127             case NEG_ARGUMENT:
1128             case DIGIT_ARGUMENT:
1129             case VI_BACKWARD_CHAR:
1130             case VI_BACKWARD_WORD:
1131             case VI_FORWARD_CHAR:
1132             case VI_FORWARD_WORD:
1133             case VI_FORWARD_WORD_END:
1134             case VI_FIRST_NON_BLANK:
1135             case VI_GOTO_COLUMN:
1136             case VI_DELETE:
1137             case VI_YANK:
1138             case VI_CHANGE:
1139             case VI_FIND_NEXT_CHAR:
1140             case VI_FIND_NEXT_CHAR_SKIP:
1141             case VI_FIND_PREV_CHAR:
1142             case VI_FIND_PREV_CHAR_SKIP:
1143             case VI_REPEAT_FIND:
1144             case VI_REV_REPEAT_FIND:
1145                 return op;
1146 
1147             default:
1148                 return VI_CMD_MODE;
1149         }
1150     }
1151 
1152     protected int switchCase(int ch) {
1153         if (Character.isUpperCase(ch)) {
1154             return Character.toLowerCase(ch);
1155         } else if (Character.isLowerCase(ch)) {
1156             return Character.toUpperCase(ch);
1157         } else {
1158             return ch;
1159         }
1160     }
1161 
1162     /**
1163      * @return true if line reader is in the middle of doing a change-to
1164      *   delete-to or yank-to.
1165      */
1166     protected boolean isInViMoveOperation() {
1167         return viMoveMode != ViMoveMode.NORMAL;
1168     }
1169 
1170     protected boolean isInViChangeOperation() {
1171         return viMoveMode == ViMoveMode.CHANGE;
1172     }
1173 
1174     protected boolean isInViCmdMode() {
1175         return VICMD.equals(keyMap);
1176     }
1177 
1178 
1179     //
1180     // Movement
1181     //
1182 
1183     protected boolean viForwardChar() {
1184         if (count &lt; 0) {
1185             return callNeg(this::viBackwardChar);
1186         }
1187         int lim = findeol();
1188         if (isInViCmdMode() &amp;&amp; !isInViMoveOperation()) {
1189             lim--;
1190         }
1191         if (buf.cursor() &gt;= lim) {
1192             return false;
1193         }
1194         while (count-- &gt; 0 &amp;&amp; buf.cursor() &lt; lim) {
1195             buf.move(1);
1196         }
1197         return true;
1198     }
1199 
1200     protected boolean viBackwardChar() {
1201         if (count &lt; 0) {
1202             return callNeg(this::viForwardChar);
1203         }
1204         int lim = findbol();
1205         if (buf.cursor() == lim) {
1206             return false;
1207         }
1208         while (count-- &gt; 0 &amp;&amp; buf.cursor() &gt; 0) {
1209             buf.move(-1);
1210             if (buf.currChar() == &#39;\n&#39;) {
1211                 buf.move(1);
1212                 break;
1213             }
1214         }
1215         return true;
1216     }
1217 
1218 
1219     //
1220     // Word movement
1221     //
1222 
1223     protected boolean forwardWord() {
1224         if (count &lt; 0) {
1225             return callNeg(this::backwardWord);
1226         }
1227         while (count-- &gt; 0) {
1228             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1229                 buf.move(1);
1230             }
1231             if (isInViChangeOperation() &amp;&amp; count == 0) {
1232                 break;
1233             }
1234             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1235                 buf.move(1);
1236             }
1237         }
1238         return true;
1239     }
1240 
1241     protected boolean viForwardWord() {
1242         if (count &lt; 0) {
1243             return callNeg(this::backwardWord);
1244         }
1245         while (count-- &gt; 0) {
1246             if (isViAlphaNum(buf.currChar())) {
1247                 while (buf.cursor() &lt; buf.length() &amp;&amp; isViAlphaNum(buf.currChar())) {
1248                     buf.move(1);
1249                 }
1250             } else {
1251                 while (buf.cursor() &lt; buf.length()
1252                         &amp;&amp; !isViAlphaNum(buf.currChar())
1253                         &amp;&amp; !isWhitespace(buf.currChar())) {
1254                     buf.move(1);
1255                 }
1256             }
1257             if (isInViChangeOperation() &amp;&amp; count == 0) {
1258                 return true;
1259             }
1260             int nl = buf.currChar() == &#39;\n&#39; ? 1 : 0;
1261             while (buf.cursor() &lt; buf.length()
1262                     &amp;&amp; nl &lt; 2
1263                     &amp;&amp; isWhitespace(buf.currChar())) {
1264                 buf.move(1);
1265                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1266             }
1267         }
1268         return true;
1269     }
1270 
1271     protected boolean viForwardBlankWord() {
1272         if (count &lt; 0) {
1273             return callNeg(this::viBackwardBlankWord);
1274         }
1275         while (count-- &gt; 0) {
1276             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWhitespace(buf.currChar())) {
1277                 buf.move(1);
1278             }
1279             if (isInViChangeOperation() &amp;&amp; count == 0) {
1280                 return true;
1281             }
1282             int nl = buf.currChar() == &#39;\n&#39; ? 1 : 0;
1283             while (buf.cursor() &lt; buf.length()
1284                     &amp;&amp; nl &lt; 2
1285                     &amp;&amp; isWhitespace(buf.currChar())) {
1286                 buf.move(1);
1287                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1288             }
1289         }
1290         return true;
1291     }
1292 
1293     protected boolean emacsForwardWord() {
1294         if (count &lt; 0) {
1295             return callNeg(this::emacsBackwardWord);
1296         }
1297         while (count-- &gt; 0) {
1298             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1299                 buf.move(1);
1300             }
1301             if (isInViChangeOperation() &amp;&amp; count == 0) {
1302                 return true;
1303             }
1304             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1305                 buf.move(1);
1306             }
1307         }
1308         return true;
1309     }
1310 
1311     protected boolean viForwardBlankWordEnd() {
1312         if (count &lt; 0) {
1313             return false;
1314         }
1315         while (count-- &gt; 0) {
1316             while (buf.cursor() &lt; buf.length()) {
1317                 buf.move(1);
1318                 if (!isWhitespace(buf.currChar())) {
1319                     break;
1320                 }
1321             }
1322             while (buf.cursor() &lt; buf.length()) {
1323                 buf.move(1);
1324                 if (isWhitespace(buf.currChar())) {
1325                     break;
1326                 }
1327             }
1328         }
1329         return true;
1330     }
1331 
1332     protected boolean viForwardWordEnd() {
1333         if (count &lt; 0) {
1334             return callNeg(this::backwardWord);
1335         }
1336         while (count-- &gt; 0) {
1337             while (buf.cursor() &lt; buf.length()) {
1338                 if (!isWhitespace(buf.nextChar())) {
1339                     break;
1340                 }
1341                 buf.move(1);
1342             }
1343             if (buf.cursor() &lt; buf.length()) {
1344                 if (isViAlphaNum(buf.nextChar())) {
1345                     buf.move(1);
1346                     while (buf.cursor() &lt; buf.length() &amp;&amp; isViAlphaNum(buf.nextChar())) {
1347                         buf.move(1);
1348                     }
1349                 } else {
1350                     buf.move(1);
1351                     while (buf.cursor() &lt; buf.length() &amp;&amp; !isViAlphaNum(buf.nextChar()) &amp;&amp; !isWhitespace(buf.nextChar())) {
1352                         buf.move(1);
1353                     }
1354                 }
1355             }
1356         }
1357         if (buf.cursor() &lt; buf.length() &amp;&amp; isInViMoveOperation()) {
1358             buf.move(1);
1359         }
1360         return true;
1361     }
1362 
1363     protected boolean backwardWord() {
1364         if (count &lt; 0) {
1365             return callNeg(this::forwardWord);
1366         }
1367         while (count-- &gt; 0) {
1368             while (buf.cursor() &gt; 0 &amp;&amp; !isWord(buf.atChar(buf.cursor() - 1))) {
1369                 buf.move(-1);
1370             }
1371             while (buf.cursor() &gt; 0 &amp;&amp; isWord(buf.atChar(buf.cursor() - 1))) {
1372                 buf.move(-1);
1373             }
1374         }
1375         return true;
1376     }
1377 
1378     protected boolean viBackwardWord() {
1379         if (count &lt; 0) {
1380             return callNeg(this::backwardWord);
1381         }
1382         while (count-- &gt; 0) {
1383             int nl = 0;
1384             while (buf.cursor() &gt; 0) {
1385                 buf.move(-1);
1386                 if (!isWhitespace(buf.currChar())) {
1387                     break;
1388                 }
1389                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1390                 if (nl == 2) {
1391                     buf.move(1);
1392                     break;
1393                 }
1394             }
1395             if (buf.cursor() &gt; 0) {
1396                 if (isViAlphaNum(buf.currChar())) {
1397                     while (buf.cursor() &gt; 0) {
1398                         if (!isViAlphaNum(buf.prevChar())) {
1399                             break;
1400                         }
1401                         buf.move(-1);
1402                     }
1403                 } else {
1404                     while (buf.cursor() &gt; 0) {
1405                         if (isViAlphaNum(buf.prevChar()) || isWhitespace(buf.prevChar())) {
1406                             break;
1407                         }
1408                         buf.move(-1);
1409                     }
1410                 }
1411             }
1412         }
1413         return true;
1414     }
1415 
1416     protected boolean viBackwardBlankWord() {
1417         if (count &lt; 0) {
1418             return callNeg(this::viForwardBlankWord);
1419         }
1420         while (count-- &gt; 0) {
1421             while (buf.cursor() &gt; 0) {
1422                 buf.move(-1);
1423                 if (!isWhitespace(buf.currChar())) {
1424                     break;
1425                 }
1426             }
1427             while (buf.cursor() &gt; 0) {
1428                 buf.move(-1);
1429                 if (isWhitespace(buf.currChar())) {
1430                     break;
1431                 }
1432             }
1433         }
1434         return true;
1435     }
1436 
1437     protected boolean viBackwardWordEnd() {
1438         if (count &lt; 0) {
1439             return callNeg(this::viForwardWordEnd);
1440         }
1441         while (count-- &gt; 0 &amp;&amp; buf.cursor() &gt; 1) {
1442             int start;
1443             if (isViAlphaNum(buf.currChar())) {
1444                 start = 1;
1445             } else if (!isWhitespace(buf.currChar())) {
1446                 start = 2;
1447             } else {
1448                 start = 0;
1449             }
1450             while (buf.cursor() &gt; 0) {
1451                 boolean same = (start != 1) &amp;&amp; isWhitespace(buf.currChar());
1452                 if (start != 0) {
1453                     same |= isViAlphaNum(buf.currChar());
1454                 }
1455                 if (same == (start == 2)) {
1456                     break;
1457                 }
1458                 buf.move(-1);
1459             }
1460             while (buf.cursor() &gt; 0 &amp;&amp; isWhitespace(buf.currChar())) {
1461                 buf.move(-1);
1462             }
1463         }
1464         return true;
1465     }
1466 
1467     protected boolean viBackwardBlankWordEnd() {
1468         if (count &lt; 0) {
1469             return callNeg(this::viForwardBlankWordEnd);
1470         }
1471         while (count-- &gt; 0) {
1472             while (buf.cursor() &gt; 0 &amp;&amp; !isWhitespace(buf.currChar())) {
1473                 buf.move(-1);
1474             }
1475             while (buf.cursor() &gt; 0 &amp;&amp; isWhitespace(buf.currChar())) {
1476                 buf.move(-1);
1477             }
1478         }
1479         return true;
1480     }
1481 
1482     protected boolean emacsBackwardWord() {
1483         if (count &lt; 0) {
1484             return callNeg(this::emacsForwardWord);
1485         }
1486         while (count-- &gt; 0) {
1487             while (buf.cursor() &gt; 0) {
1488                 buf.move(-1);
1489                 if (isWord(buf.currChar())) {
1490                     break;
1491                 }
1492             }
1493             while (buf.cursor() &gt; 0) {
1494                 buf.move(-1);
1495                 if (!isWord(buf.currChar())) {
1496                     break;
1497                 }
1498             }
1499         }
1500         return true;
1501     }
1502 
1503     protected boolean backwardDeleteWord() {
1504         if (count &lt; 0) {
1505             return callNeg(this::deleteWord);
1506         }
1507         int cursor = buf.cursor();
1508         while (count-- &gt; 0) {
1509             while (cursor &gt; 0 &amp;&amp; !isWord(buf.atChar(cursor - 1))) {
1510                 cursor--;
1511             }
1512             while (cursor &gt; 0 &amp;&amp; isWord(buf.atChar(cursor - 1))) {
1513                 cursor--;
1514             }
1515         }
1516         buf.backspace(buf.cursor() - cursor);
1517         return true;
1518     }
1519 
1520     protected boolean viBackwardKillWord() {
1521         if (count &lt; 0) {
1522             return false;
1523         }
1524         int lim = findbol();
1525         int x = buf.cursor();
1526         while (count-- &gt; 0) {
1527             while (x &gt; lim &amp;&amp; isWhitespace(buf.atChar(x - 1))) {
1528                 x--;
1529             }
1530             if (x &gt; lim) {
1531                 if (isViAlphaNum(buf.atChar(x - 1))) {
1532                     while (x &gt; lim &amp;&amp; isViAlphaNum(buf.atChar(x - 1))) {
1533                         x--;
1534                     }
1535                 } else {
1536                     while (x &gt; lim &amp;&amp; !isViAlphaNum(buf.atChar(x - 1)) &amp;&amp; !isWhitespace(buf.atChar(x - 1))) {
1537                         x--;
1538                     }
1539                 }
1540             }
1541         }
1542         killRing.addBackwards(buf.substring(x, buf.cursor()));
1543         buf.backspace(buf.cursor() - x);
1544         return true;
1545     }
1546 
1547     protected boolean backwardKillWord() {
1548         if (count &lt; 0) {
1549             return callNeg(this::killWord);
1550         }
1551         int x = buf.cursor();
1552         while (count-- &gt; 0) {
1553             while (x &gt; 0 &amp;&amp; !isWord(buf.atChar(x - 1))) {
1554                 x--;
1555             }
1556             while (x &gt; 0 &amp;&amp; isWord(buf.atChar(x - 1))) {
1557                 x--;
1558             }
1559         }
1560         killRing.addBackwards(buf.substring(x, buf.cursor()));
1561         buf.backspace(buf.cursor() - x);
1562         return true;
1563     }
1564 
1565     protected boolean copyPrevWord() {
1566         if (count &lt;= 0) {
1567             return false;
1568         }
1569         int t1, t0 = buf.cursor();
1570         while (true) {
1571             t1 = t0;
1572             while (t0 &gt; 0 &amp;&amp; !isWord(buf.atChar(t0 - 1))) {
1573                 t0--;
1574             }
1575             while (t0 &gt; 0 &amp;&amp; isWord(buf.atChar(t0 - 1))) {
1576                 t0--;
1577             }
1578             if (--count == 0) {
1579                 break;
1580             }
1581             if (t0 == 0) {
1582                 return false;
1583             }
1584         }
1585         buf.write(buf.substring(t0, t1));
1586         return true;
1587     }
1588 
1589     protected boolean upCaseWord() {
1590         int count = Math.abs(this.count);
1591         int cursor = buf.cursor();
1592         while (count-- &gt; 0) {
1593             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1594                 buf.move(1);
1595             }
1596             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1597                 buf.currChar(Character.toUpperCase(buf.currChar()));
1598                 buf.move(1);
1599             }
1600         }
1601         if (this.count &lt; 0) {
1602             buf.cursor(cursor);
1603         }
1604         return true;
1605     }
1606 
1607     protected boolean downCaseWord() {
1608         int count = Math.abs(this.count);
1609         int cursor = buf.cursor();
1610         while (count-- &gt; 0) {
1611             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1612                 buf.move(1);
1613             }
1614             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1615                 buf.currChar(Character.toLowerCase(buf.currChar()));
1616                 buf.move(1);
1617             }
1618         }
1619         if (this.count &lt; 0) {
1620             buf.cursor(cursor);
1621         }
1622         return true;
1623     }
1624 
1625     protected boolean capitalizeWord() {
1626         int count = Math.abs(this.count);
1627         int cursor = buf.cursor();
1628         while (count-- &gt; 0) {
1629             boolean first = true;
1630             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1631                 buf.move(1);
1632             }
1633             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar()) &amp;&amp; !isAlpha(buf.currChar())) {
1634                 buf.move(1);
1635             }
1636             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1637                 buf.currChar(first
1638                         ? Character.toUpperCase(buf.currChar())
1639                         : Character.toLowerCase(buf.currChar()));
1640                 buf.move(1);
1641                 first = false;
1642             }
1643         }
1644         if (this.count &lt; 0) {
1645             buf.cursor(cursor);
1646         }
1647         return true;
1648     }
1649 
1650     protected boolean deleteWord() {
1651         if (count &lt; 0) {
1652             return callNeg(this::backwardDeleteWord);
1653         }
1654         int x = buf.cursor();
1655         while (count-- &gt; 0) {
1656             while (x &lt; buf.length() &amp;&amp; !isWord(buf.atChar(x))) {
1657                 x++;
1658             }
1659             while (x &lt; buf.length() &amp;&amp; isWord(buf.atChar(x))) {
1660                 x++;
1661             }
1662         }
1663         buf.delete(x - buf.cursor());
1664         return true;
1665     }
1666 
1667     protected boolean killWord() {
1668         if (count &lt; 0) {
1669             return callNeg(this::backwardKillWord);
1670         }
1671         int x = buf.cursor();
1672         while (count-- &gt; 0) {
1673             while (x &lt; buf.length() &amp;&amp; !isWord(buf.atChar(x))) {
1674                 x++;
1675             }
1676             while (x &lt; buf.length() &amp;&amp; isWord(buf.atChar(x))) {
1677                 x++;
1678             }
1679         }
1680         killRing.add(buf.substring(buf.cursor(), x));
1681         buf.delete(x - buf.cursor());
1682         return true;
1683     }
1684 
1685     protected boolean transposeWords() {
1686         int lstart = buf.cursor() - 1;
1687         int lend = buf.cursor();
1688         while (buf.atChar(lstart) != 0 &amp;&amp; buf.atChar(lstart) != &#39;\n&#39;) {
1689             lstart--;
1690         }
1691         lstart++;
1692         while (buf.atChar(lend) != 0 &amp;&amp; buf.atChar(lend) != &#39;\n&#39;) {
1693             lend++;
1694         }
1695         if (lend - lstart &lt; 2) {
1696             return false;
1697         }
1698         int words = 0;
1699         boolean inWord = false;
1700         if (!isDelimiter(buf.atChar(lstart))) {
1701             words++;
1702             inWord = true;
1703         }
1704         for (int i = lstart; i &lt; lend; i++) {
1705             if (isDelimiter(buf.atChar(i))) {
1706                 inWord = false;
1707             } else {
1708                 if (!inWord) {
1709                     words++;
1710                 }
1711                 inWord = true;
1712             }
1713         }
1714         if (words &lt; 2) {
1715             return false;
1716         }
1717         // TODO: use isWord instead of isDelimiter
1718         boolean neg = this.count &lt; 0;
1719         for (int count = Math.max(this.count, -this.count); count &gt; 0; --count) {
1720             int sta1, end1, sta2, end2;
1721             // Compute current word boundaries
1722             sta1 = buf.cursor();
1723             while (sta1 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta1 - 1))) {
1724                 sta1--;
1725             }
1726             end1 = sta1;
1727             while (end1 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end1)));
1728             if (neg) {
1729                 end2 = sta1 - 1;
1730                 while (end2 &gt; lstart &amp;&amp; isDelimiter(buf.atChar(end2 - 1))) {
1731                     end2--;
1732                 }
1733                 if (end2 &lt; lstart) {
1734                     // No word before, use the word after
1735                     sta2 = end1;
1736                     while (isDelimiter(buf.atChar(++sta2)));
1737                     end2 = sta2;
1738                     while (end2 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end2)));
1739                 } else {
1740                     sta2 = end2;
1741                     while (sta2 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta2 - 1))) {
1742                         sta2--;
1743                     }
1744                 }
1745             } else {
1746                 sta2 = end1;
1747                 while (sta2 &lt; lend &amp;&amp; isDelimiter(buf.atChar(++sta2)));
1748                 if (sta2 == lend) {
1749                     // No word after, use the word before
1750                     end2 = sta1;
1751                     while (isDelimiter(buf.atChar(end2 - 1))) {
1752                         end2--;
1753                     }
1754                     sta2 = end2;
1755                     while (sta2 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta2 - 1))) {
1756                         sta2--;
1757                     }
1758                 } else {
1759                     end2 = sta2;
1760                     while (end2 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end2))) ;
1761                 }
1762             }
1763             if (sta1 &lt; sta2) {
1764                 String res = buf.substring(0, sta1) + buf.substring(sta2, end2)
1765                         + buf.substring(end1, sta2) + buf.substring(sta1, end1)
1766                         + buf.substring(end2);
1767                 buf.clear();
1768                 buf.write(res);
1769                 buf.cursor(neg ? end1 : end2);
1770             } else {
1771                 String res = buf.substring(0, sta2) + buf.substring(sta1, end1)
1772                         + buf.substring(end2, sta1) + buf.substring(sta2, end2)
1773                         + buf.substring(end1);
1774                 buf.clear();
1775                 buf.write(res);
1776                 buf.cursor(neg ? end2 : end1);
1777             }
1778         }
1779         return true;
1780     }
1781 
1782     private int findbol() {
1783         int x = buf.cursor();
1784         while (x &gt; 0 &amp;&amp; buf.atChar(x - 1) != &#39;\n&#39;) {
1785             x--;
1786         }
1787         return x;
1788     }
1789 
1790     private int findeol() {
1791         int x = buf.cursor();
1792         while (x &lt; buf.length() &amp;&amp; buf.atChar(x) != &#39;\n&#39;) {
1793             x++;
1794         }
1795         return x;
1796     }
1797 
1798     protected boolean insertComment() {
1799         return doInsertComment(false);
1800     }
1801 
1802     protected boolean viInsertComment() {
1803         return doInsertComment(true);
1804     }
1805 
1806     protected boolean doInsertComment(boolean isViMode) {
1807         String comment = getString(COMMENT_BEGIN, DEFAULT_COMMENT_BEGIN);
1808         beginningOfLine();
1809         putString(comment);
1810         if (isViMode) {
1811             setKeyMap(VIINS);
1812         }
1813         return acceptLine();
1814     }
1815 
1816     protected boolean viFindNextChar() {
1817         if ((findChar = vigetkey()) &gt; 0) {
1818             findDir = 1;
1819             findTailAdd = 0;
1820             return vifindchar(false);
1821         }
1822         return false;
1823     }
1824 
1825     protected boolean viFindPrevChar() {
1826         if ((findChar = vigetkey()) &gt; 0) {
1827             findDir = -1;
1828             findTailAdd = 0;
1829             return vifindchar(false);
1830         }
1831         return false;
1832     }
1833 
1834     protected boolean viFindNextCharSkip() {
1835         if ((findChar = vigetkey()) &gt; 0) {
1836             findDir = 1;
1837             findTailAdd = -1;
1838             return vifindchar(false);
1839         }
1840         return false;
1841     }
1842 
1843     protected boolean viFindPrevCharSkip() {
1844         if ((findChar = vigetkey()) &gt; 0) {
1845             findDir = -1;
1846             findTailAdd = 1;
1847             return vifindchar(false);
1848         }
1849         return false;
1850     }
1851 
1852     protected boolean viRepeatFind() {
1853         return vifindchar(true);
1854     }
1855 
1856     protected boolean viRevRepeatFind() {
1857         if (count &lt; 0) {
1858             return callNeg(() -&gt; vifindchar(true));
1859         }
1860         findTailAdd = -findTailAdd;
1861         findDir = -findDir;
1862         boolean ret = vifindchar(true);
1863         findTailAdd = -findTailAdd;
1864         findDir = -findDir;
1865         return ret;
1866     }
1867 
1868     private int vigetkey() {
1869         int ch = readCharacter();
1870         KeyMap&lt;Binding&gt; km = keyMaps.get(MAIN);
1871         if (km != null) {
1872             Binding b = km.getBound(new String(Character.toChars(ch)));
1873             if (b instanceof Reference) {
1874                 String func = ((Reference) b).name();
1875                 if (SEND_BREAK.equals(func)) {
1876                     return -1;
1877                 }
1878             }
1879         }
1880         return ch;
1881     }
1882 
1883     private boolean vifindchar(boolean repeat) {
1884         if (findDir == 0) {
1885             return false;
1886         }
1887         if (count &lt; 0) {
1888             return callNeg(this::viRevRepeatFind);
1889         }
1890         if (repeat &amp;&amp; findTailAdd != 0) {
1891             if (findDir &gt; 0) {
1892                 if (buf.cursor() &lt; buf.length() &amp;&amp; buf.nextChar() == findChar) {
1893                     buf.move(1);
1894                 }
1895             } else {
1896                 if (buf.cursor() &gt; 0 &amp;&amp; buf.prevChar() == findChar) {
1897                     buf.move(-1);
1898                 }
1899             }
1900         }
1901         int cursor = buf.cursor();
1902         while (count-- &gt; 0) {
1903             do {
1904                 buf.move(findDir);
1905             } while (buf.cursor() &gt; 0 &amp;&amp; buf.cursor() &lt; buf.length()
1906                     &amp;&amp; buf.currChar() != findChar
1907                     &amp;&amp; buf.currChar() != &#39;\n&#39;);
1908             if (buf.cursor() &lt;= 0 || buf.cursor() &gt;= buf.length()
1909                     || buf.currChar() == &#39;\n&#39;) {
1910                 buf.cursor(cursor);
1911                 return false;
1912             }
1913         }
1914         if (findTailAdd != 0) {
1915             buf.move(findTailAdd);
1916         }
1917         if (findDir == 1 &amp;&amp; isInViMoveOperation()) {
1918             buf.move(1);
1919         }
1920         return true;
1921     }
1922 
1923     private boolean callNeg(Widget widget) {
1924         this.count = -this.count;
1925         boolean ret = widget.apply();
1926         this.count = -this.count;
1927         return ret;
1928     }
1929 
1930     /**
1931      * Implements vi search (&quot;/&quot; or &quot;?&quot;).
1932      *
1933      * @return &lt;code&gt;true&lt;/code&gt; if the search was successful
1934      */
1935     protected boolean viHistorySearchForward() {
1936         searchDir = 1;
1937         searchIndex = 0;
1938         return getViSearchString() &amp;&amp; viRepeatSearch();
1939     }
1940 
1941     protected boolean viHistorySearchBackward() {
1942         searchDir = -1;
1943         searchIndex = history.size() - 1;
1944         return getViSearchString() &amp;&amp; viRepeatSearch();
1945     }
1946 
1947     protected boolean viRepeatSearch() {
1948         if (searchDir == 0) {
1949             return false;
1950         }
1951         int si = searchDir &lt; 0
1952                 ? searchBackwards(searchString, searchIndex, false)
1953                 : searchForwards(searchString, searchIndex, false);
1954         if (si == -1 || si == history.index()) {
1955             return false;
1956         }
1957         searchIndex = si;
1958 
1959         /*
1960          * Show the match.
1961          */
1962         buf.clear();
1963         history.moveTo(searchIndex);
1964         buf.write(history.get(searchIndex));
1965         if (VICMD.equals(keyMap)) {
1966             buf.move(-1);
1967         }
1968         return true;
1969     }
1970 
1971     protected boolean viRevRepeatSearch() {
1972         boolean ret;
1973         searchDir = -searchDir;
1974         ret = viRepeatSearch();
1975         searchDir = -searchDir;
1976         return ret;
1977     }
1978 
1979     private boolean getViSearchString() {
1980         if (searchDir == 0) {
1981             return false;
1982         }
1983         String searchPrompt = searchDir &lt; 0 ? &quot;?&quot; : &quot;/&quot;;
1984         Buffer searchBuffer = new BufferImpl();
1985 
1986         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MAIN);
1987         if (keyMap == null) {
1988             keyMap = keyMaps.get(SAFE);
1989         }
1990         while (true) {
1991             post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
1992             redisplay();
1993             Binding b = doReadBinding(keyMap, null);
1994             if (b instanceof Reference) {
1995                 String func = ((Reference) b).name();
1996                 switch (func) {
1997                     case SEND_BREAK:
1998                         post = null;
1999                         return false;
2000                     case ACCEPT_LINE:
2001                     case VI_CMD_MODE:
2002                         searchString = searchBuffer.toString();
2003                         post = null;
2004                         return true;
2005                     case MAGIC_SPACE:
2006                         searchBuffer.write(&#39; &#39;);
2007                         break;
2008                     case REDISPLAY:
2009                         redisplay();
2010                         break;
2011                     case CLEAR_SCREEN:
2012                         clearScreen();
2013                         break;
2014                     case SELF_INSERT:
2015                         searchBuffer.write(getLastBinding());
2016                         break;
2017                     case SELF_INSERT_UNMETA:
2018                         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
2019                             String s = getLastBinding().substring(1);
2020                             if (&quot;\r&quot;.equals(s)) {
2021                                 s = &quot;\n&quot;;
2022                             }
2023                             searchBuffer.write(s);
2024                         }
2025                         break;
2026                     case BACKWARD_DELETE_CHAR:
2027                     case VI_BACKWARD_DELETE_CHAR:
2028                         if (searchBuffer.length() &gt; 0) {
2029                             searchBuffer.backspace();
2030                         }
2031                         break;
2032                     case BACKWARD_KILL_WORD:
2033                     case VI_BACKWARD_KILL_WORD:
2034                         if (searchBuffer.length() &gt; 0 &amp;&amp; !isWhitespace(searchBuffer.prevChar())) {
2035                             searchBuffer.backspace();
2036                         }
2037                         if (searchBuffer.length() &gt; 0 &amp;&amp; isWhitespace(searchBuffer.prevChar())) {
2038                             searchBuffer.backspace();
2039                         }
2040                         break;
2041                     case QUOTED_INSERT:
2042                     case VI_QUOTED_INSERT:
2043                         int c = readCharacter();
2044                         if (c &gt;= 0) {
2045                             searchBuffer.write(c);
2046                         } else {
2047                             beep();
2048                         }
2049                         break;
2050                     default:
2051                         beep();
2052                         break;
2053                 }
2054             }
2055         }
2056     }
2057 
2058     protected boolean insertCloseCurly() {
2059         return insertClose(&quot;}&quot;);
2060     }
2061 
2062     protected boolean insertCloseParen() {
2063         return insertClose(&quot;)&quot;);
2064     }
2065 
2066     protected boolean insertCloseSquare() {
2067         return insertClose(&quot;]&quot;);
2068     }
2069 
2070     protected boolean insertClose(String s) {
2071         putString(s);
2072 
2073         long blink = getLong(BLINK_MATCHING_PAREN, DEFAULT_BLINK_MATCHING_PAREN);
2074         if (blink &lt;= 0) {
2075             return true;
2076         }
2077 
2078         int closePosition = buf.cursor();
2079 
2080         buf.move(-1);
2081         doViMatchBracket();
2082         redisplay();
2083 
2084         peekCharacter(blink);
2085 
2086         buf.cursor(closePosition);
2087         return true;
2088     }
2089 
2090     protected boolean viMatchBracket() {
2091         return doViMatchBracket();
2092     }
2093 
2094     protected boolean undefinedKey() {
2095         return false;
2096     }
2097 
2098     /**
2099      * Implements vi style bracket matching (&quot;%&quot; command). The matching
2100      * bracket for the current bracket type that you are sitting on is matched.
2101      *
2102      * @return true if it worked, false if the cursor was not on a bracket
2103      *   character or if there was no matching bracket.
2104      */
2105     protected boolean doViMatchBracket() {
2106         int pos        = buf.cursor();
2107 
2108         if (pos == buf.length()) {
2109             return false;
2110         }
2111 
2112         int type       = getBracketType(buf.atChar(pos));
2113         int move       = (type &lt; 0) ? -1 : 1;
2114         int count      = 1;
2115 
2116         if (type == 0)
2117             return false;
2118 
2119         while (count &gt; 0) {
2120             pos += move;
2121 
2122             // Fell off the start or end.
2123             if (pos &lt; 0 || pos &gt;= buf.length()) {
2124                 return false;
2125             }
2126 
2127             int curType = getBracketType(buf.atChar(pos));
2128             if (curType == type) {
2129                 ++count;
2130             }
2131             else if (curType == -type) {
2132                 --count;
2133             }
2134         }
2135 
2136         /*
2137          * Slight adjustment for delete-to, yank-to, change-to to ensure
2138          * that the matching paren is consumed
2139          */
2140         if (move &gt; 0 &amp;&amp; isInViMoveOperation())
2141             ++pos;
2142 
2143         buf.cursor(pos);
2144         return true;
2145     }
2146 
2147     /**
2148      * Given a character determines what type of bracket it is (paren,
2149      * square, curly, or none).
2150      * @param ch The character to check
2151      * @return 1 is square, 2 curly, 3 parent, or zero for none.  The value
2152      *   will be negated if it is the closing form of the bracket.
2153      */
2154     protected int getBracketType (int ch) {
2155         switch (ch) {
2156             case &#39;[&#39;: return  1;
2157             case &#39;]&#39;: return -1;
2158             case &#39;{&#39;: return  2;
2159             case &#39;}&#39;: return -2;
2160             case &#39;(&#39;: return  3;
2161             case &#39;)&#39;: return -3;
2162             default:
2163                 return 0;
2164         }
2165     }
2166 
2167     /**
2168      * Performs character transpose. The character prior to the cursor and the
2169      * character under the cursor are swapped and the cursor is advanced one.
2170      * Do not cross line breaks.
2171      * @return true
2172      */
2173     protected boolean transposeChars() {
2174         int lstart = buf.cursor() - 1;
2175         int lend = buf.cursor();
2176         while (buf.atChar(lstart) != 0 &amp;&amp; buf.atChar(lstart) != &#39;\n&#39;) {
2177             lstart--;
2178         }
2179         lstart++;
2180         while (buf.atChar(lend) != 0 &amp;&amp; buf.atChar(lend) != &#39;\n&#39;) {
2181             lend++;
2182         }
2183         if (lend - lstart &lt; 2) {
2184             return false;
2185         }
2186         boolean neg = this.count &lt; 0;
2187         for (int count = Math.max(this.count, -this.count); count &gt; 0; --count) {
2188             while (buf.cursor() &lt;= lstart) {
2189                 buf.move(1);
2190             }
2191             while (buf.cursor() &gt;= lend) {
2192                 buf.move(-1);
2193             }
2194             int c = buf.currChar();
2195             buf.currChar(buf.prevChar());
2196             buf.move(-1);
2197             buf.currChar(c);
2198             buf.move(neg ? 0 : 2);
2199         }
2200         return true;
2201     }
2202 
2203     protected boolean undo() {
2204         isUndo = true;
2205         if (undo.canUndo()) {
2206             undo.undo();
2207             return true;
2208         }
2209         return false;
2210     }
2211 
2212     protected boolean redo() {
2213         isUndo = true;
2214         if (undo.canRedo()) {
2215             undo.redo();
2216             return true;
2217         }
2218         return false;
2219     }
2220 
2221     protected boolean sendBreak() {
2222         if (searchTerm == null) {
2223             buf.clear();
2224             println();
2225             redrawLine();
2226 //            state = State.INTERRUPT;
2227             return false;
2228         }
2229         return true;
2230     }
2231 
2232     protected boolean backwardChar() {
2233         return buf.move(-count) != 0;
2234     }
2235 
2236     protected boolean forwardChar() {
2237         return buf.move(count) != 0;
2238     }
2239 
2240     protected boolean viDigitOrBeginningOfLine() {
2241         if (repeatCount &gt; 0) {
2242             return digitArgument();
2243         } else {
2244             return beginningOfLine();
2245         }
2246     }
2247 
2248     protected boolean universalArgument() {
2249         mult *= universal;
2250         isArgDigit = true;
2251         return true;
2252     }
2253 
2254     protected boolean argumentBase() {
2255         if (repeatCount &gt; 0 &amp;&amp; repeatCount &lt; 32) {
2256             universal = repeatCount;
2257             isArgDigit = true;
2258             return true;
2259         } else {
2260             return false;
2261         }
2262     }
2263 
2264     protected boolean negArgument() {
2265         mult *= -1;
2266         isArgDigit = true;
2267         return true;
2268     }
2269 
2270     protected boolean digitArgument() {
2271         String s = getLastBinding();
2272         repeatCount = (repeatCount * 10) + s.charAt(s.length() - 1) - &#39;0&#39;;
2273         isArgDigit = true;
2274         return true;
2275     }
2276 
2277     protected boolean viDelete() {
2278         int cursorStart = buf.cursor();
2279         Binding o = readBinding(getKeys());
2280         if (o instanceof Reference) {
2281             // TODO: be smarter on how to get the vi range
2282             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2283             // This is a weird special case. In vi
2284             // &quot;dd&quot; deletes the current line. So if we
2285             // get a delete-to, followed by a delete-to,
2286             // we delete the line.
2287             if (VI_DELETE.equals(op)) {
2288                 killWholeLine();
2289             } else {
2290                 viMoveMode = ViMoveMode.DELETE;
2291                 Widget widget = widgets.get(op);
2292                 if (widget != null &amp;&amp; !widget.apply()) {
2293                     viMoveMode = ViMoveMode.NORMAL;
2294                     return false;
2295                 }
2296                 viMoveMode = ViMoveMode.NORMAL;
2297             }
2298             return viDeleteTo(cursorStart, buf.cursor());
2299         } else {
2300             pushBackBinding();
2301             return false;
2302         }
2303     }
2304 
2305     protected boolean viYankTo() {
2306         int cursorStart = buf.cursor();
2307         Binding o = readBinding(getKeys());
2308         if (o instanceof Reference) {
2309             // TODO: be smarter on how to get the vi range
2310             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2311             // Similar to delete-to, a &quot;yy&quot; yanks the whole line.
2312             if (VI_YANK.equals(op)) {
2313                 yankBuffer = buf.toString();
2314                 return true;
2315             } else {
2316                 viMoveMode = ViMoveMode.YANK;
2317                 Widget widget = widgets.get(op);
2318                 if (widget != null &amp;&amp; !widget.apply()) {
2319                     return false;
2320                 }
2321                 viMoveMode = ViMoveMode.NORMAL;
2322             }
2323             return viYankTo(cursorStart, buf.cursor());
2324         } else {
2325             pushBackBinding();
2326             return false;
2327         }
2328     }
2329 
2330     protected boolean viYankWholeLine() {
2331         int s, e;
2332         int p = buf.cursor();
2333         while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2334         s = buf.cursor();
2335         for (int i = 0; i &lt; repeatCount; i++) {
2336             while (buf.move(1) == 1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2337         }
2338         e = buf.cursor();
2339         yankBuffer = buf.substring(s, e);
2340         if (!yankBuffer.endsWith(&quot;\n&quot;)) {
2341             yankBuffer += &quot;\n&quot;;
2342         }
2343         buf.cursor(p);
2344         return true;
2345     }
2346 
2347     protected boolean viChange() {
2348         int cursorStart = buf.cursor();
2349         Binding o = readBinding(getKeys());
2350         if (o instanceof Reference) {
2351             // TODO: be smarter on how to get the vi range
2352             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2353             // change whole line
2354             if (VI_CHANGE.equals(op)) {
2355                 killWholeLine();
2356             } else {
2357                 viMoveMode = ViMoveMode.CHANGE;
2358                 Widget widget = widgets.get(op);
2359                 if (widget != null &amp;&amp; !widget.apply()) {
2360                     viMoveMode = ViMoveMode.NORMAL;
2361                     return false;
2362                 }
2363                 viMoveMode = ViMoveMode.NORMAL;
2364             }
2365             boolean res = viChange(cursorStart, buf.cursor());
2366             setKeyMap(VIINS);
2367             return res;
2368         } else {
2369             pushBackBinding();
2370             return false;
2371         }
2372     }
2373 
2374     /*
2375     protected int getViRange(Reference cmd, ViMoveMode mode) {
2376         Buffer buffer = buf.copy();
2377         int oldMark = mark;
2378         int pos = buf.cursor();
2379         String bind = getLastBinding();
2380 
2381         if (visual != 0) {
2382             if (buf.length() == 0) {
2383                 return -1;
2384             }
2385             pos = mark;
2386             v
2387         } else {
2388             viMoveMode = mode;
2389             mark = -1;
2390             Binding b = doReadBinding(getKeys(), keyMaps.get(VIOPP));
2391             if (b == null || new Reference(SEND_BREAK).equals(b)) {
2392                 viMoveMode = ViMoveMode.NORMAL;
2393                 mark = oldMark;
2394                 return -1;
2395             }
2396             if (cmd.equals(b)) {
2397                 doViLineRange();
2398             }
2399             Widget w = getWidget(b);
2400             if (w )
2401             if (b instanceof Reference) {
2402 
2403             }
2404         }
2405 
2406     }
2407     */
2408 
2409     protected void cleanup() {
2410         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
2411             Buffer oldBuffer = buf.copy();
2412             AttributedString oldPrompt = prompt;
2413             buf.clear();
2414             prompt = new AttributedString(&quot;&quot;);
2415             doCleanup(false);
2416             prompt = oldPrompt;
2417             buf.copyFrom(oldBuffer);
2418         } else {
2419             doCleanup(true);
2420         }
2421     }
2422 
2423     protected void doCleanup(boolean nl) {
2424         buf.cursor(buf.length());
2425         post = null;
2426         if (size.getColumns() &gt; 0 || size.getRows() &gt; 0) {
2427             redisplay(false);
2428             if (nl) {
2429                 println();
2430             }
2431             terminal.puts(Capability.keypad_local);
2432             terminal.trackMouse(Terminal.MouseTracking.Off);
2433             if (isSet(Option.BRACKETED_PASTE))
2434                 terminal.writer().write(BRACKETED_PASTE_OFF);
2435             flush();
2436         }
2437         history.moveToEnd();
2438     }
2439 
2440     protected boolean historyIncrementalSearchForward() {
2441         return doSearchHistory(false);
2442     }
2443 
2444     protected boolean historyIncrementalSearchBackward() {
2445         return doSearchHistory(true);
2446     }
2447 
2448     static class Pair&lt;U,V&gt; {
2449         final U u; final V v;
2450         public Pair(U u, V v) {
2451             this.u = u;
2452             this.v = v;
2453         }
2454         public U getU() {
2455             return u;
2456         }
2457         public V getV() {
2458             return v;
2459         }
2460     }
2461 
2462     protected boolean doSearchHistory(boolean backward) {
2463         if (history.isEmpty()) {
2464             return false;
2465         }
2466 
2467         KeyMap&lt;Binding&gt; terminators = new KeyMap&lt;&gt;();
2468         getString(SEARCH_TERMINATORS, DEFAULT_SEARCH_TERMINATORS)
2469                 .codePoints().forEach(c -&gt; bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));
2470 
2471         Buffer originalBuffer = buf.copy();
2472         searchIndex = -1;
2473         searchTerm = new StringBuffer();
2474         searchBackward = backward;
2475         searchFailing = false;
2476         post = () -&gt; new AttributedString((searchFailing ? &quot;failing&quot; + &quot; &quot; : &quot;&quot;)
2477                         + (searchBackward ? &quot;bck-i-search&quot; : &quot;fwd-i-search&quot;)
2478                         + &quot;: &quot; + searchTerm + &quot;_&quot;);
2479 
2480         redisplay();
2481         try {
2482             while (true) {
2483                 int prevSearchIndex = searchIndex;
2484                 Binding operation = readBinding(getKeys(), terminators);
2485                 String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
2486                 boolean next = false;
2487                 switch (ref) {
2488                     case SEND_BREAK:
2489                         beep();
2490                         buf.copyFrom(originalBuffer);
2491                         return true;
2492                     case HISTORY_INCREMENTAL_SEARCH_BACKWARD:
2493                         searchBackward = true;
2494                         next = true;
2495                         break;
2496                     case HISTORY_INCREMENTAL_SEARCH_FORWARD:
2497                         searchBackward = false;
2498                         next = true;
2499                         break;
2500                     case BACKWARD_DELETE_CHAR:
2501                         if (searchTerm.length() &gt; 0) {
2502                             searchTerm.deleteCharAt(searchTerm.length() - 1);
2503                         }
2504                         break;
2505                     case SELF_INSERT:
2506                         searchTerm.append(getLastBinding());
2507                         break;
2508                     default:
2509                         // Set buffer and cursor position to the found string.
2510                         if (searchIndex != -1) {
2511                             history.moveTo(searchIndex);
2512                         }
2513                         pushBackBinding();
2514                         return true;
2515                 }
2516 
2517                 // print the search status
2518                 String pattern = doGetSearchPattern();
2519                 if (pattern.length() == 0) {
2520                     buf.copyFrom(originalBuffer);
2521                     searchFailing = false;
2522                 } else {
2523                     boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2524                     Pattern pat = Pattern.compile(pattern, caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE
2525                                                                            : Pattern.UNICODE_CASE);
2526                     Pair&lt;Integer, Integer&gt; pair = null;
2527                     if (searchBackward) {
2528                         boolean nextOnly = next;
2529                         pair = matches(pat, buf.toString(), searchIndex).stream()
2530                                 .filter(p -&gt; nextOnly ? p.v &lt; buf.cursor() : p.v &lt;= buf.cursor())
2531                                 .max(Comparator.comparing(Pair::getV))
2532                                 .orElse(null);
2533                         if (pair == null) {
2534                             pair = StreamSupport.stream(
2535                                     Spliterators.spliteratorUnknownSize(history.reverseIterator(searchIndex &lt; 0 ? history.last() : searchIndex - 1), Spliterator.ORDERED), false)
2536                                     .flatMap(e -&gt; matches(pat, e.line(), e.index()).stream())
2537                                     .findFirst()
2538                                     .orElse(null);
2539                         }
2540                     } else {
2541                         boolean nextOnly = next;
2542                         pair = matches(pat, buf.toString(), searchIndex).stream()
2543                                 .filter(p -&gt; nextOnly ? p.v &gt; buf.cursor() : p.v &gt;= buf.cursor())
2544                                 .min(Comparator.comparing(Pair::getV))
2545                                 .orElse(null);
2546                         if (pair == null) {
2547                             pair = StreamSupport.stream(
2548                                     Spliterators.spliteratorUnknownSize(history.iterator((searchIndex &lt; 0 ? history.last() : searchIndex) + 1), Spliterator.ORDERED), false)
2549                                     .flatMap(e -&gt; matches(pat, e.line(), e.index()).stream())
2550                                     .findFirst()
2551                                     .orElse(null);
2552                             if (pair == null &amp;&amp; searchIndex &gt;= 0) {
2553                                 pair = matches(pat, originalBuffer.toString(), -1).stream()
2554                                         .min(Comparator.comparing(Pair::getV))
2555                                         .orElse(null);
2556                             }
2557                         }
2558                     }
2559                     if (pair != null) {
2560                         searchIndex = pair.u;
2561                         buf.clear();
2562                         if (searchIndex &gt;= 0) {
2563                             buf.write(history.get(searchIndex));
2564                         } else {
2565                             buf.write(originalBuffer.toString());
2566                         }
2567                         buf.cursor(pair.v);
2568                         searchFailing = false;
2569                     } else {
2570                         searchFailing = true;
2571                         beep();
2572                     }
2573                 }
2574                 redisplay();
2575             }
2576         } catch (IOError e) {
2577             // Ignore Ctrl+C interrupts and just exit the loop
2578             if (!(e.getCause() instanceof InterruptedException)) {
2579                 throw e;
2580             }
2581             return true;
2582         } finally {
2583             searchTerm = null;
2584             searchIndex = -1;
2585             post = null;
2586         }
2587     }
2588 
2589     private List&lt;Pair&lt;Integer, Integer&gt;&gt; matches(Pattern p, String line, int index) {
2590         List&lt;Pair&lt;Integer, Integer&gt;&gt; starts = new ArrayList&lt;&gt;();
2591         Matcher m = p.matcher(line);
2592         while (m.find()) {
2593             starts.add(new Pair&lt;&gt;(index, m.start()));
2594         }
2595         return starts;
2596    }
2597 
2598     private String doGetSearchPattern() {
2599         StringBuilder sb = new StringBuilder();
2600         boolean inQuote = false;
2601         for (int i = 0; i &lt; searchTerm.length(); i++) {
2602             char c = searchTerm.charAt(i);
2603             if (Character.isLowerCase(c)) {
2604                 if (inQuote) {
2605                     sb.append(&quot;\\E&quot;);
2606                     inQuote = false;
2607                 }
2608                 sb.append(&quot;[&quot;).append(Character.toLowerCase(c)).append(Character.toUpperCase(c)).append(&quot;]&quot;);
2609             } else {
2610                 if (!inQuote) {
2611                     sb.append(&quot;\\Q&quot;);
2612                     inQuote = true;
2613                 }
2614                 sb.append(c);
2615             }
2616         }
2617         if (inQuote) {
2618             sb.append(&quot;\\E&quot;);
2619         }
2620         return sb.toString();
2621     }
2622 
2623     private void pushBackBinding() {
2624         pushBackBinding(false);
2625     }
2626 
2627     private void pushBackBinding(boolean skip) {
2628         String s = getLastBinding();
2629         if (s != null) {
2630             bindingReader.runMacro(s);
2631             skipRedisplay = skip;
2632         }
2633     }
2634 
2635     protected boolean historySearchForward() {
2636         if (historyBuffer == null || buf.length() == 0
2637                 || !buf.toString().equals(history.current())) {
2638             historyBuffer = buf.copy();
2639             searchBuffer = getFirstWord();
2640         }
2641         int index = history.index() + 1;
2642 
2643         if (index &lt; history.last() + 1) {
2644             int searchIndex = searchForwards(searchBuffer.toString(), index, true);
2645             if (searchIndex == -1) {
2646                 history.moveToEnd();
2647                 if (!buf.toString().equals(historyBuffer.toString())) {
2648                     setBuffer(historyBuffer.toString());
2649                     historyBuffer = null;
2650                 } else {
2651                     return false;
2652                 }
2653             } else {
2654                 // Maintain cursor position while searching.
2655                 if (history.moveTo(searchIndex)) {
2656                     setBuffer(history.current());
2657                 } else {
2658                     history.moveToEnd();
2659                     setBuffer(historyBuffer.toString());
2660                     return false;
2661                 }
2662             }
2663         } else {
2664             history.moveToEnd();
2665             if (!buf.toString().equals(historyBuffer.toString())) {
2666                 setBuffer(historyBuffer.toString());
2667                 historyBuffer = null;
2668             } else {
2669                 return false;
2670             }
2671         }
2672         return true;
2673     }
2674 
2675     private CharSequence getFirstWord() {
2676         String s = buf.toString();
2677         int i = 0;
2678         while (i &lt; s.length() &amp;&amp; !Character.isWhitespace(s.charAt(i))) {
2679             i++;
2680         }
2681         return s.substring(0, i);
2682     }
2683 
2684     protected boolean historySearchBackward() {
2685         if (historyBuffer == null || buf.length() == 0
2686                 || !buf.toString().equals(history.current())) {
2687             historyBuffer = buf.copy();
2688             searchBuffer = getFirstWord();
2689         }
2690         int searchIndex = searchBackwards(searchBuffer.toString(), history.index(), true);
2691 
2692         if (searchIndex == -1) {
2693             return false;
2694         } else {
2695             // Maintain cursor position while searching.
2696             if (history.moveTo(searchIndex)) {
2697                 setBuffer(history.current());
2698             } else {
2699                 return false;
2700             }
2701         }
2702         return true;
2703     }
2704 
2705     //
2706     // History search
2707     //
2708     /**
2709      * Search backward in history from a given position.
2710      *
2711      * @param searchTerm substring to search for.
2712      * @param startIndex the index from which on to search
2713      * @return index where this substring has been found, or -1 else.
2714      */
2715     public int searchBackwards(String searchTerm, int startIndex) {
2716         return searchBackwards(searchTerm, startIndex, false);
2717     }
2718 
2719     /**
2720      * Search backwards in history from the current position.
2721      *
2722      * @param searchTerm substring to search for.
2723      * @return index where the substring has been found, or -1 else.
2724      */
2725     public int searchBackwards(String searchTerm) {
2726         return searchBackwards(searchTerm, history.index(), false);
2727     }
2728 
2729     public int searchBackwards(String searchTerm, int startIndex, boolean startsWith) {
2730         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2731         if (caseInsensitive) {
2732             searchTerm = searchTerm.toLowerCase();
2733         }
2734         ListIterator&lt;History.Entry&gt; it = history.iterator(startIndex);
2735         while (it.hasPrevious()) {
2736             History.Entry e = it.previous();
2737             String line = e.line();
2738             if (caseInsensitive) {
2739                 line = line.toLowerCase();
2740             }
2741             int idx = line.indexOf(searchTerm);
2742             if ((startsWith &amp;&amp; idx == 0) || (!startsWith &amp;&amp; idx &gt;= 0)) {
2743                 return e.index();
2744             }
2745         }
2746         return -1;
2747     }
2748 
2749     public int searchForwards(String searchTerm, int startIndex, boolean startsWith) {
2750         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2751         if (caseInsensitive) {
2752             searchTerm = searchTerm.toLowerCase();
2753         }
2754         if (startIndex &gt; history.last()) {
2755             startIndex = history.last();
2756         }
2757         ListIterator&lt;History.Entry&gt; it = history.iterator(startIndex);
2758         if (searchIndex != -1 &amp;&amp; it.hasNext()) {
2759             it.next();
2760         }
2761         while (it.hasNext()) {
2762             History.Entry e = it.next();
2763             String line = e.line();
2764             if (caseInsensitive) {
2765                 line = line.toLowerCase();
2766             }
2767             int idx = line.indexOf(searchTerm);
2768             if ((startsWith &amp;&amp; idx == 0) || (!startsWith &amp;&amp; idx &gt;= 0)) {
2769                 return e.index();
2770             }
2771         }
2772         return -1;
2773     }
2774 
2775     /**
2776      * Search forward in history from a given position.
2777      *
2778      * @param searchTerm substring to search for.
2779      * @param startIndex the index from which on to search
2780      * @return index where this substring has been found, or -1 else.
2781      */
2782     public int searchForwards(String searchTerm, int startIndex) {
2783         return searchForwards(searchTerm, startIndex, false);
2784     }
2785     /**
2786      * Search forwards in history from the current position.
2787      *
2788      * @param searchTerm substring to search for.
2789      * @return index where the substring has been found, or -1 else.
2790      */
2791     public int searchForwards(String searchTerm) {
2792         return searchForwards(searchTerm, history.index());
2793     }
2794 
2795     protected boolean quit() {
2796         getBuffer().clear();
2797         return acceptLine();
2798     }
2799 
2800     protected boolean acceptAndHold() {
2801         nextCommandFromHistory = false;
2802         acceptLine();
2803         if (!buf.toString().isEmpty()) {
2804             nextHistoryId = Integer.MAX_VALUE;
2805             nextCommandFromHistory = true;
2806         }
2807         return nextCommandFromHistory;
2808     }
2809 
2810     protected boolean acceptLineAndDownHistory() {
2811         nextCommandFromHistory = false;
2812         acceptLine();
2813         if (nextHistoryId &lt; 0) {
2814             nextHistoryId = history.index();
2815         }
2816         if (history.size() &gt; nextHistoryId + 1) {
2817             nextHistoryId++;
2818             nextCommandFromHistory = true;
2819         }
2820         return nextCommandFromHistory;
2821     }
2822 
2823     protected boolean acceptAndInferNextHistory() {
2824         nextCommandFromHistory = false;
2825         acceptLine();
2826         if (!buf.toString().isEmpty()) {
2827             nextHistoryId = searchBackwards(buf.toString(), history.last());
2828             if (nextHistoryId &gt;= 0 &amp;&amp; history.size() &gt; nextHistoryId + 1) {
2829                 nextHistoryId++;
2830                 nextCommandFromHistory = true;
2831             }
2832         }
2833         return nextCommandFromHistory;
2834     }
2835 
2836     protected boolean acceptLine() {
2837         parsedLine = null;
2838         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2839             try {
2840                 String str = buf.toString();
2841                 String exp = expander.expandHistory(history, str);
2842                 if (!exp.equals(str)) {
2843                     buf.clear();
2844                     buf.write(exp);
2845                     if (isSet(Option.HISTORY_VERIFY)) {
2846                         return true;
2847                     }
2848                 }
2849             } catch (IllegalArgumentException e) {
2850                 // Ignore
2851             }
2852         }
2853         try {
2854             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2855         } catch (EOFError e) {
2856             buf.write(&quot;\n&quot;);
2857             return true;
2858         } catch (SyntaxError e) {
2859             // do nothing
2860         }
2861         callWidget(CALLBACK_FINISH);
2862         state = State.DONE;
2863         return true;
2864     }
2865 
2866     protected boolean selfInsert() {
2867         for (int count = this.count; count &gt; 0; count--) {
2868             putString(getLastBinding());
2869         }
2870         return true;
2871     }
2872 
2873     protected boolean selfInsertUnmeta() {
2874         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
2875             String s = getLastBinding().substring(1);
2876             if (&quot;\r&quot;.equals(s)) {
2877                 s = &quot;\n&quot;;
2878             }
2879             for (int count = this.count; count &gt; 0; count--) {
2880                 putString(s);
2881             }
2882             return true;
2883         } else {
2884             return false;
2885         }
2886     }
2887 
2888     protected boolean overwriteMode() {
2889         overTyping = !overTyping;
2890         return true;
2891     }
2892 
2893 
2894     //
2895     // History Control
2896     //
2897 
2898     protected boolean beginningOfBufferOrHistory() {
2899         if (findbol() != 0) {
2900             buf.cursor(0);
2901             return true;
2902         } else {
2903             return beginningOfHistory();
2904         }
2905     }
2906 
2907     protected boolean beginningOfHistory() {
2908         if (history.moveToFirst()) {
2909             setBuffer(history.current());
2910             return true;
2911         } else {
2912             return false;
2913         }
2914     }
2915 
2916     protected boolean endOfBufferOrHistory() {
2917         if (findeol() != buf.length()) {
2918             buf.cursor(buf.length());
2919             return true;
2920         } else {
2921             return endOfHistory();
2922         }
2923     }
2924 
2925     protected boolean endOfHistory() {
2926         if (history.moveToLast()) {
2927             setBuffer(history.current());
2928             return true;
2929         } else {
2930             return false;
2931         }
2932     }
2933 
2934     protected boolean beginningOfLineHist() {
2935         if (count &lt; 0) {
2936             return callNeg(this::endOfLineHist);
2937         }
2938         while (count-- &gt; 0) {
2939             int bol = findbol();
2940             if (bol != buf.cursor()) {
2941                 buf.cursor(bol);
2942             } else {
2943                 moveHistory(false);
2944                 buf.cursor(0);
2945             }
2946         }
2947         return true;
2948     }
2949 
2950     protected boolean endOfLineHist() {
2951         if (count &lt; 0) {
2952             return callNeg(this::beginningOfLineHist);
2953         }
2954         while (count-- &gt; 0) {
2955             int eol = findeol();
2956             if (eol != buf.cursor()) {
2957                 buf.cursor(eol);
2958             } else {
2959                 moveHistory(true);
2960             }
2961         }
2962         return true;
2963     }
2964 
2965     protected boolean upHistory() {
2966         while (count-- &gt; 0) {
2967             if (!moveHistory(false)) {
2968                 return !isSet(Option.HISTORY_BEEP);
2969             }
2970         }
2971         return true;
2972     }
2973 
2974     protected boolean downHistory() {
2975         while (count-- &gt; 0) {
2976             if (!moveHistory(true)) {
2977                 return !isSet(Option.HISTORY_BEEP);
2978             }
2979         }
2980         return true;
2981     }
2982 
2983     protected boolean viUpLineOrHistory() {
2984         return upLine()
2985                 || upHistory() &amp;&amp; viFirstNonBlank();
2986     }
2987 
2988     protected boolean viDownLineOrHistory() {
2989         return downLine()
2990                 || downHistory() &amp;&amp; viFirstNonBlank();
2991     }
2992 
2993     protected boolean upLine() {
2994         return buf.up();
2995     }
2996 
2997     protected boolean downLine() {
2998         return buf.down();
2999     }
3000 
3001     protected boolean upLineOrHistory() {
3002         return upLine() || upHistory();
3003     }
3004 
3005     protected boolean upLineOrSearch() {
3006         return upLine() || historySearchBackward();
3007     }
3008 
3009     protected boolean downLineOrHistory() {
3010         return downLine() || downHistory();
3011     }
3012 
3013     protected boolean downLineOrSearch() {
3014         return downLine() || historySearchForward();
3015     }
3016 
3017     protected boolean viCmdMode() {
3018         // If we are re-entering move mode from an
3019         // aborted yank-to, delete-to, change-to then
3020         // don&#39;t move the cursor back. The cursor is
3021         // only move on an explicit entry to movement
3022         // mode.
3023         if (state == State.NORMAL) {
3024             buf.move(-1);
3025         }
3026         return setKeyMap(VICMD);
3027     }
3028 
3029     protected boolean viInsert() {
3030         return setKeyMap(VIINS);
3031     }
3032 
3033     protected boolean viAddNext() {
3034         buf.move(1);
3035         return setKeyMap(VIINS);
3036     }
3037 
3038     protected boolean viAddEol() {
3039         return endOfLine() &amp;&amp; setKeyMap(VIINS);
3040     }
3041 
3042     protected boolean emacsEditingMode() {
3043         return setKeyMap(EMACS);
3044     }
3045 
3046     protected boolean viChangeWholeLine() {
3047         return viFirstNonBlank() &amp;&amp; viChangeEol();
3048     }
3049 
3050     protected boolean viChangeEol() {
3051         return viChange(buf.cursor(), buf.length())
3052                 &amp;&amp; setKeyMap(VIINS);
3053     }
3054 
3055     protected boolean viKillEol() {
3056         int eol = findeol();
3057         if (buf.cursor() == eol) {
3058             return false;
3059         }
3060         killRing.add(buf.substring(buf.cursor(), eol));
3061         buf.delete(eol - buf.cursor());
3062         return true;
3063     }
3064 
3065     protected boolean quotedInsert() {
3066         int c = readCharacter();
3067         while (count-- &gt; 0) {
3068             putString(new String(Character.toChars(c)));
3069         }
3070         return true;
3071     }
3072 
3073     protected boolean viJoin() {
3074         if (buf.down()) {
3075             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3076             buf.backspace();
3077             buf.write(&#39; &#39;);
3078             buf.move(-1);
3079             return true;
3080         }
3081         return false;
3082     }
3083 
3084     protected boolean viKillWholeLine() {
3085         return killWholeLine() &amp;&amp; setKeyMap(VIINS);
3086     }
3087 
3088     protected boolean viInsertBol() {
3089         return beginningOfLine() &amp;&amp; setKeyMap(VIINS);
3090     }
3091 
3092     protected boolean backwardDeleteChar() {
3093         if (count &lt; 0) {
3094             return callNeg(this::deleteChar);
3095         }
3096         if (buf.cursor() == 0) {
3097             return false;
3098         }
3099         buf.backspace(count);
3100         return true;
3101     }
3102 
3103     protected boolean viFirstNonBlank() {
3104         beginningOfLine();
3105         while (buf.cursor() &lt; buf.length() &amp;&amp; isWhitespace(buf.currChar())) {
3106             buf.move(1);
3107         }
3108         return true;
3109     }
3110 
3111     protected boolean viBeginningOfLine() {
3112         buf.cursor(findbol());
3113         return true;
3114     }
3115 
3116     protected boolean viEndOfLine() {
3117         if (count &lt; 0) {
3118             return false;
3119         }
3120         while (count-- &gt; 0) {
3121             buf.cursor(findeol() + 1);
3122         }
3123         buf.move(-1);
3124         return true;
3125     }
3126 
3127     protected boolean beginningOfLine() {
3128         while (count-- &gt; 0) {
3129             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3130         }
3131         return true;
3132     }
3133 
3134     protected boolean endOfLine() {
3135         while (count-- &gt; 0) {
3136             while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;) ;
3137         }
3138         return true;
3139     }
3140 
3141     protected boolean deleteChar() {
3142         if (count &lt; 0) {
3143             return callNeg(this::backwardDeleteChar);
3144         }
3145         if (buf.cursor() == buf.length()) {
3146             return false;
3147         }
3148         buf.delete(count);
3149         return true;
3150     }
3151 
3152     /**
3153      * Deletes the previous character from the cursor position
3154      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3155      */
3156     protected boolean viBackwardDeleteChar() {
3157         for (int i = 0; i &lt; count; i++) {
3158             if (!buf.backspace()) {
3159                 return false;
3160             }
3161         }
3162         return true;
3163     }
3164 
3165     /**
3166      * Deletes the character you are sitting on and sucks the rest of
3167      * the line in from the right.
3168      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3169      */
3170     protected boolean viDeleteChar() {
3171         for (int i = 0; i &lt; count; i++) {
3172             if (!buf.delete()) {
3173                 return false;
3174             }
3175         }
3176         return true;
3177     }
3178 
3179     /**
3180      * Switches the case of the current character from upper to lower
3181      * or lower to upper as necessary and advances the cursor one
3182      * position to the right.
3183      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3184      */
3185     protected boolean viSwapCase() {
3186         for (int i = 0; i &lt; count; i++) {
3187             if (buf.cursor() &lt; buf.length()) {
3188                 int ch = buf.atChar(buf.cursor());
3189                 ch = switchCase(ch);
3190                 buf.currChar(ch);
3191                 buf.move(1);
3192             } else {
3193                 return false;
3194             }
3195         }
3196         return true;
3197     }
3198 
3199     /**
3200      * Implements the vi change character command (in move-mode &quot;r&quot;
3201      * followed by the character to change to).
3202      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3203      */
3204     protected boolean viReplaceChars() {
3205         int c = readCharacter();
3206         // EOF, ESC, or CTRL-C aborts.
3207         if (c &lt; 0 || c == &#39;\033&#39; || c == &#39;\003&#39;) {
3208             return true;
3209         }
3210 
3211         for (int i = 0; i &lt; count; i++) {
3212             if (buf.currChar((char) c)) {
3213                 if (i &lt; count - 1) {
3214                     buf.move(1);
3215                 }
3216             } else {
3217                 return false;
3218             }
3219         }
3220         return true;
3221     }
3222 
3223     protected boolean viChange(int startPos, int endPos) {
3224         return doViDeleteOrChange(startPos, endPos, true);
3225     }
3226 
3227     protected boolean viDeleteTo(int startPos, int endPos) {
3228         return doViDeleteOrChange(startPos, endPos, false);
3229     }
3230 
3231     /**
3232      * Performs the vi &quot;delete-to&quot; action, deleting characters between a given
3233      * span of the input line.
3234      * @param startPos The start position
3235      * @param endPos The end position.
3236      * @param isChange If true, then the delete is part of a change operationg
3237      *    (e.g. &quot;c$&quot; is change-to-end-of line, so we first must delete to end
3238      *    of line to start the change
3239      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3240      */
3241     protected boolean doViDeleteOrChange(int startPos, int endPos, boolean isChange) {
3242         if (startPos == endPos) {
3243             return true;
3244         }
3245 
3246         if (endPos &lt; startPos) {
3247             int tmp = endPos;
3248             endPos = startPos;
3249             startPos = tmp;
3250         }
3251 
3252         buf.cursor(startPos);
3253         buf.delete(endPos - startPos);
3254 
3255         // If we are doing a delete operation (e.g. &quot;d$&quot;) then don&#39;t leave the
3256         // cursor dangling off the end. In reality the &quot;isChange&quot; flag is silly
3257         // what is really happening is that if we are in &quot;move-mode&quot; then the
3258         // cursor can&#39;t be moved off the end of the line, but in &quot;edit-mode&quot; it
3259         // is ok, but I have no easy way of knowing which mode we are in.
3260         if (! isChange &amp;&amp; startPos &gt; 0 &amp;&amp; startPos == buf.length()) {
3261             buf.move(-1);
3262         }
3263         return true;
3264     }
3265 
3266     /**
3267      * Implement the &quot;vi&quot; yank-to operation.  This operation allows you
3268      * to yank the contents of the current line based upon a move operation,
3269      * for example &quot;yw&quot; yanks the current word, &quot;3yw&quot; yanks 3 words, etc.
3270      *
3271      * @param startPos The starting position from which to yank
3272      * @param endPos The ending position to which to yank
3273      * @return &lt;code&gt;true&lt;/code&gt; if the yank succeeded
3274      */
3275     protected boolean viYankTo(int startPos, int endPos) {
3276         int cursorPos = startPos;
3277 
3278         if (endPos &lt; startPos) {
3279             int tmp = endPos;
3280             endPos = startPos;
3281             startPos = tmp;
3282         }
3283 
3284         if (startPos == endPos) {
3285             yankBuffer = &quot;&quot;;
3286             return true;
3287         }
3288 
3289         yankBuffer = buf.substring(startPos, endPos);
3290 
3291         /*
3292          * It was a movement command that moved the cursor to find the
3293          * end position, so put the cursor back where it started.
3294          */
3295         buf.cursor(cursorPos);
3296         return true;
3297     }
3298 
3299     protected boolean viOpenLineAbove() {
3300         while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3301         buf.write(&#39;\n&#39;);
3302         buf.move(-1);
3303         return setKeyMap(VIINS);
3304     }
3305 
3306     protected boolean viOpenLineBelow() {
3307         while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;) ;
3308         buf.write(&#39;\n&#39;);
3309         return setKeyMap(VIINS);
3310     }
3311 
3312     /**
3313      * Pasts the yank buffer to the right of the current cursor position
3314      * and moves the cursor to the end of the pasted region.
3315      * @return &lt;code&gt;true&lt;/code&gt;
3316      */
3317     protected boolean viPutAfter() {
3318         if (yankBuffer.indexOf(&#39;\n&#39;) &gt;= 0) {
3319             while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;);
3320             buf.move(1);
3321             putString(yankBuffer);
3322             buf.move(- yankBuffer.length());
3323         } else if (yankBuffer.length () != 0) {
3324             if (buf.cursor() &lt; buf.length()) {
3325                 buf.move(1);
3326             }
3327             for (int i = 0; i &lt; count; i++) {
3328                 putString(yankBuffer);
3329             }
3330             buf.move(-1);
3331         }
3332         return true;
3333     }
3334 
3335     protected boolean viPutBefore() {
3336         if (yankBuffer.indexOf(&#39;\n&#39;) &gt;= 0) {
3337             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;);
3338             putString(yankBuffer);
3339             buf.move(- yankBuffer.length());
3340         } else if (yankBuffer.length () != 0) {
3341             if (buf.cursor() &gt; 0) {
3342                 buf.move(-1);
3343             }
3344             for (int i = 0; i &lt; count; i++) {
3345                 putString(yankBuffer);
3346             }
3347             buf.move(-1);
3348         }
3349         return true;
3350     }
3351 
3352     protected boolean doLowercaseVersion() {
3353         bindingReader.runMacro(getLastBinding().toLowerCase());
3354         return true;
3355     }
3356 
3357     protected boolean setMarkCommand() {
3358         if (count &lt; 0) {
3359             regionActive = RegionType.NONE;
3360             return true;
3361         }
3362         regionMark = buf.cursor();
3363         regionActive = RegionType.CHAR;
3364         return true;
3365     }
3366 
3367     protected boolean exchangePointAndMark() {
3368         if (count == 0) {
3369             regionActive = RegionType.CHAR;
3370             return true;
3371         }
3372         int x = regionMark;
3373         regionMark = buf.cursor();
3374         buf.cursor(x);
3375         if (buf.cursor() &gt; buf.length()) {
3376             buf.cursor(buf.length());
3377         }
3378         if (count &gt; 0) {
3379             regionActive = RegionType.CHAR;
3380         }
3381         return true;
3382     }
3383 
3384     protected boolean visualMode() {
3385         if (isInViMoveOperation()) {
3386             isArgDigit = true;
3387             forceLine = false;
3388             forceChar = true;
3389             return true;
3390         }
3391         if (regionActive == RegionType.NONE) {
3392             regionMark = buf.cursor();
3393             regionActive = RegionType.CHAR;
3394         } else if (regionActive == RegionType.CHAR) {
3395             regionActive = RegionType.NONE;
3396         } else if (regionActive == RegionType.LINE) {
3397             regionActive = RegionType.CHAR;
3398         }
3399         return true;
3400     }
3401 
3402     protected boolean visualLineMode() {
3403         if (isInViMoveOperation()) {
3404             isArgDigit = true;
3405             forceLine = true;
3406             forceChar = false;
3407             return true;
3408         }
3409         if (regionActive == RegionType.NONE) {
3410             regionMark = buf.cursor();
3411             regionActive = RegionType.LINE;
3412         } else if (regionActive == RegionType.CHAR) {
3413             regionActive = RegionType.LINE;
3414         } else if (regionActive == RegionType.LINE) {
3415             regionActive = RegionType.NONE;
3416         }
3417         return true;
3418     }
3419 
3420     protected boolean deactivateRegion() {
3421         regionActive = RegionType.NONE;
3422         return true;
3423     }
3424 
3425     protected boolean whatCursorPosition() {
3426         post = () -&gt; {
3427             AttributedStringBuilder sb = new AttributedStringBuilder();
3428             if (buf.cursor() &lt; buf.length()) {
3429                 int c = buf.currChar();
3430                 sb.append(&quot;Char: &quot;);
3431                 if (c == &#39; &#39;) {
3432                     sb.append(&quot;SPC&quot;);
3433                 } else if (c == &#39;\n&#39;) {
3434                     sb.append(&quot;LFD&quot;);
3435                 } else if (c &lt; 32) {
3436                     sb.append(&#39;^&#39;);
3437                     sb.append((char) (c + &#39;A&#39; - 1));
3438                 } else if (c == 127) {
3439                     sb.append(&quot;^?&quot;);
3440                 } else {
3441                     sb.append((char) c);
3442                 }
3443                 sb.append(&quot; (&quot;);
3444                 sb.append(&quot;0&quot;).append(Integer.toOctalString(c)).append(&quot; &quot;);
3445                 sb.append(Integer.toString(c)).append(&quot; &quot;);
3446                 sb.append(&quot;0x&quot;).append(Integer.toHexString(c)).append(&quot; &quot;);
3447                 sb.append(&quot;)&quot;);
3448             } else {
3449                 sb.append(&quot;EOF&quot;);
3450             }
3451             sb.append(&quot;   &quot;);
3452             sb.append(&quot;point &quot;);
3453             sb.append(Integer.toString(buf.cursor() + 1));
3454             sb.append(&quot; of &quot;);
3455             sb.append(Integer.toString(buf.length() + 1));
3456             sb.append(&quot; (&quot;);
3457             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3458             sb.append(&quot;%)&quot;);
3459             sb.append(&quot;   &quot;);
3460             sb.append(&quot;column &quot;);
3461             sb.append(Integer.toString(buf.cursor() - findbol()));
3462             return sb.toAttributedString();
3463         };
3464         return true;
3465     }
3466 
3467     protected Map&lt;String, Widget&gt; builtinWidgets() {
3468         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
3469         addBuiltinWidget(widgets, ACCEPT_AND_INFER_NEXT_HISTORY, this::acceptAndInferNextHistory);
3470         addBuiltinWidget(widgets, ACCEPT_AND_HOLD, this::acceptAndHold);
3471         addBuiltinWidget(widgets, ACCEPT_LINE, this::acceptLine);
3472         addBuiltinWidget(widgets, ACCEPT_LINE_AND_DOWN_HISTORY, this::acceptLineAndDownHistory);
3473         addBuiltinWidget(widgets, ARGUMENT_BASE, this::argumentBase);
3474         addBuiltinWidget(widgets, BACKWARD_CHAR, this::backwardChar);
3475         addBuiltinWidget(widgets, BACKWARD_DELETE_CHAR, this::backwardDeleteChar);
3476         addBuiltinWidget(widgets, BACKWARD_DELETE_WORD, this::backwardDeleteWord);
3477         addBuiltinWidget(widgets, BACKWARD_KILL_LINE, this::backwardKillLine);
3478         addBuiltinWidget(widgets, BACKWARD_KILL_WORD, this::backwardKillWord);
3479         addBuiltinWidget(widgets, BACKWARD_WORD, this::backwardWord);
3480         addBuiltinWidget(widgets, BEEP, this::beep);
3481         addBuiltinWidget(widgets, BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);
3482         addBuiltinWidget(widgets, BEGINNING_OF_HISTORY, this::beginningOfHistory);
3483         addBuiltinWidget(widgets, BEGINNING_OF_LINE, this::beginningOfLine);
3484         addBuiltinWidget(widgets, BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);
3485         addBuiltinWidget(widgets, CAPITALIZE_WORD, this::capitalizeWord);
3486         addBuiltinWidget(widgets, CLEAR, this::clear);
3487         addBuiltinWidget(widgets, CLEAR_SCREEN, this::clearScreen);
3488         addBuiltinWidget(widgets, COMPLETE_PREFIX, this::completePrefix);
3489         addBuiltinWidget(widgets, COMPLETE_WORD, this::completeWord);
3490         addBuiltinWidget(widgets, COPY_PREV_WORD, this::copyPrevWord);
3491         addBuiltinWidget(widgets, COPY_REGION_AS_KILL, this::copyRegionAsKill);
3492         addBuiltinWidget(widgets, DELETE_CHAR, this::deleteChar);
3493         addBuiltinWidget(widgets, DELETE_CHAR_OR_LIST, this::deleteCharOrList);
3494         addBuiltinWidget(widgets, DELETE_WORD, this::deleteWord);
3495         addBuiltinWidget(widgets, DIGIT_ARGUMENT, this::digitArgument);
3496         addBuiltinWidget(widgets, DO_LOWERCASE_VERSION, this::doLowercaseVersion);
3497         addBuiltinWidget(widgets, DOWN_CASE_WORD, this::downCaseWord);
3498         addBuiltinWidget(widgets, DOWN_LINE, this::downLine);
3499         addBuiltinWidget(widgets, DOWN_LINE_OR_HISTORY, this::downLineOrHistory);
3500         addBuiltinWidget(widgets, DOWN_LINE_OR_SEARCH, this::downLineOrSearch);
3501         addBuiltinWidget(widgets, DOWN_HISTORY, this::downHistory);
3502         addBuiltinWidget(widgets, EMACS_EDITING_MODE, this::emacsEditingMode);
3503         addBuiltinWidget(widgets, EMACS_BACKWARD_WORD, this::emacsBackwardWord);
3504         addBuiltinWidget(widgets, EMACS_FORWARD_WORD, this::emacsForwardWord);
3505         addBuiltinWidget(widgets, END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);
3506         addBuiltinWidget(widgets, END_OF_HISTORY, this::endOfHistory);
3507         addBuiltinWidget(widgets, END_OF_LINE, this::endOfLine);
3508         addBuiltinWidget(widgets, END_OF_LINE_HIST, this::endOfLineHist);
3509         addBuiltinWidget(widgets, EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);
3510         addBuiltinWidget(widgets, EXPAND_HISTORY, this::expandHistory);
3511         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE, this::expandOrComplete);
3512         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);
3513         addBuiltinWidget(widgets, EXPAND_WORD, this::expandWord);
3514         addBuiltinWidget(widgets, FRESH_LINE, this::freshLine);
3515         addBuiltinWidget(widgets, FORWARD_CHAR, this::forwardChar);
3516         addBuiltinWidget(widgets, FORWARD_WORD, this::forwardWord);
3517         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);
3518         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);
3519         addBuiltinWidget(widgets, HISTORY_SEARCH_BACKWARD, this::historySearchBackward);
3520         addBuiltinWidget(widgets, HISTORY_SEARCH_FORWARD, this::historySearchForward);
3521         addBuiltinWidget(widgets, INSERT_CLOSE_CURLY, this::insertCloseCurly);
3522         addBuiltinWidget(widgets, INSERT_CLOSE_PAREN, this::insertCloseParen);
3523         addBuiltinWidget(widgets, INSERT_CLOSE_SQUARE, this::insertCloseSquare);
3524         addBuiltinWidget(widgets, INSERT_COMMENT, this::insertComment);
3525         addBuiltinWidget(widgets, KILL_BUFFER, this::killBuffer);
3526         addBuiltinWidget(widgets, KILL_LINE, this::killLine);
3527         addBuiltinWidget(widgets, KILL_REGION, this::killRegion);
3528         addBuiltinWidget(widgets, KILL_WHOLE_LINE, this::killWholeLine);
3529         addBuiltinWidget(widgets, KILL_WORD, this::killWord);
3530         addBuiltinWidget(widgets, LIST_CHOICES, this::listChoices);
3531         addBuiltinWidget(widgets, MENU_COMPLETE, this::menuComplete);
3532         addBuiltinWidget(widgets, MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);
3533         addBuiltinWidget(widgets, NEG_ARGUMENT, this::negArgument);
3534         addBuiltinWidget(widgets, OVERWRITE_MODE, this::overwriteMode);
3535 //        addBuiltinWidget(widgets, QUIT, this::quit);
3536         addBuiltinWidget(widgets, QUOTED_INSERT, this::quotedInsert);
3537         addBuiltinWidget(widgets, REDISPLAY, this::redisplay);
3538         addBuiltinWidget(widgets, REDRAW_LINE, this::redrawLine);
3539         addBuiltinWidget(widgets, REDO, this::redo);
3540         addBuiltinWidget(widgets, SELF_INSERT, this::selfInsert);
3541         addBuiltinWidget(widgets, SELF_INSERT_UNMETA, this::selfInsertUnmeta);
3542         addBuiltinWidget(widgets, SEND_BREAK, this::sendBreak);
3543         addBuiltinWidget(widgets, SET_MARK_COMMAND, this::setMarkCommand);
3544         addBuiltinWidget(widgets, TRANSPOSE_CHARS, this::transposeChars);
3545         addBuiltinWidget(widgets, TRANSPOSE_WORDS, this::transposeWords);
3546         addBuiltinWidget(widgets, UNDEFINED_KEY, this::undefinedKey);
3547         addBuiltinWidget(widgets, UNIVERSAL_ARGUMENT, this::universalArgument);
3548         addBuiltinWidget(widgets, UNDO, this::undo);
3549         addBuiltinWidget(widgets, UP_CASE_WORD, this::upCaseWord);
3550         addBuiltinWidget(widgets, UP_HISTORY, this::upHistory);
3551         addBuiltinWidget(widgets, UP_LINE, this::upLine);
3552         addBuiltinWidget(widgets, UP_LINE_OR_HISTORY, this::upLineOrHistory);
3553         addBuiltinWidget(widgets, UP_LINE_OR_SEARCH, this::upLineOrSearch);
3554         addBuiltinWidget(widgets, VI_ADD_EOL, this::viAddEol);
3555         addBuiltinWidget(widgets, VI_ADD_NEXT, this::viAddNext);
3556         addBuiltinWidget(widgets, VI_BACKWARD_CHAR, this::viBackwardChar);
3557         addBuiltinWidget(widgets, VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);
3558         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);
3559         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);
3560         addBuiltinWidget(widgets, VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);
3561         addBuiltinWidget(widgets, VI_BACKWARD_WORD, this::viBackwardWord);
3562         addBuiltinWidget(widgets, VI_BACKWARD_WORD_END, this::viBackwardWordEnd);
3563         addBuiltinWidget(widgets, VI_BEGINNING_OF_LINE, this::viBeginningOfLine);
3564         addBuiltinWidget(widgets, VI_CMD_MODE, this::viCmdMode);
3565         addBuiltinWidget(widgets, VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);
3566         addBuiltinWidget(widgets, VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);
3567         addBuiltinWidget(widgets, VI_CHANGE, this::viChange);
3568         addBuiltinWidget(widgets, VI_CHANGE_EOL, this::viChangeEol);
3569         addBuiltinWidget(widgets, VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);
3570         addBuiltinWidget(widgets, VI_DELETE_CHAR, this::viDeleteChar);
3571         addBuiltinWidget(widgets, VI_DELETE, this::viDelete);
3572         addBuiltinWidget(widgets, VI_END_OF_LINE, this::viEndOfLine);
3573         addBuiltinWidget(widgets, VI_KILL_EOL, this::viKillEol);
3574         addBuiltinWidget(widgets, VI_FIRST_NON_BLANK, this::viFirstNonBlank);
3575         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR, this::viFindNextChar);
3576         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);
3577         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR, this::viFindPrevChar);
3578         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);
3579         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);
3580         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);
3581         addBuiltinWidget(widgets, VI_FORWARD_CHAR, this::viForwardChar);
3582         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);
3583         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);
3584         addBuiltinWidget(widgets, VI_FORWARD_WORD_END, this::viForwardWordEnd);
3585         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);
3586         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);
3587         addBuiltinWidget(widgets, VI_INSERT, this::viInsert);
3588         addBuiltinWidget(widgets, VI_INSERT_BOL, this::viInsertBol);
3589         addBuiltinWidget(widgets, VI_INSERT_COMMENT, this::viInsertComment);
3590         addBuiltinWidget(widgets, VI_JOIN, this::viJoin);
3591         addBuiltinWidget(widgets, VI_KILL_LINE, this::viKillWholeLine);
3592         addBuiltinWidget(widgets, VI_MATCH_BRACKET, this::viMatchBracket);
3593         addBuiltinWidget(widgets, VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);
3594         addBuiltinWidget(widgets, VI_OPEN_LINE_BELOW, this::viOpenLineBelow);
3595         addBuiltinWidget(widgets, VI_PUT_AFTER, this::viPutAfter);
3596         addBuiltinWidget(widgets, VI_PUT_BEFORE, this::viPutBefore);
3597         addBuiltinWidget(widgets, VI_REPEAT_FIND, this::viRepeatFind);
3598         addBuiltinWidget(widgets, VI_REPEAT_SEARCH, this::viRepeatSearch);
3599         addBuiltinWidget(widgets, VI_REPLACE_CHARS, this::viReplaceChars);
3600         addBuiltinWidget(widgets, VI_REV_REPEAT_FIND, this::viRevRepeatFind);
3601         addBuiltinWidget(widgets, VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);
3602         addBuiltinWidget(widgets, VI_SWAP_CASE, this::viSwapCase);
3603         addBuiltinWidget(widgets, VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);
3604         addBuiltinWidget(widgets, VI_YANK, this::viYankTo);
3605         addBuiltinWidget(widgets, VI_YANK_WHOLE_LINE, this::viYankWholeLine);
3606         addBuiltinWidget(widgets, VISUAL_LINE_MODE, this::visualLineMode);
3607         addBuiltinWidget(widgets, VISUAL_MODE, this::visualMode);
3608         addBuiltinWidget(widgets, WHAT_CURSOR_POSITION, this::whatCursorPosition);
3609         addBuiltinWidget(widgets, YANK, this::yank);
3610         addBuiltinWidget(widgets, YANK_POP, this::yankPop);
3611         addBuiltinWidget(widgets, MOUSE, this::mouse);
3612         addBuiltinWidget(widgets, BEGIN_PASTE, this::beginPaste);
3613         addBuiltinWidget(widgets, FOCUS_IN, this::focusIn);
3614         addBuiltinWidget(widgets, FOCUS_OUT, this::focusOut);
3615         return widgets;
3616     }
3617 
3618     private void addBuiltinWidget(Map&lt;String, Widget&gt; widgets, String name, Widget widget) {
3619         widgets.put(name, namedWidget(name, widget));
3620     }
3621 
3622     private Widget namedWidget(String name, Widget widget) {
3623         return new Widget() {
3624             @Override
3625             public String toString() {
3626                 return name;
3627             }
3628             @Override
3629             public boolean apply() {
3630                 return widget.apply();
3631             }
3632         };
3633     }
3634 
3635     public boolean redisplay() {
3636         redisplay(true);
3637         return true;
3638     }
3639 
3640     protected void redisplay(boolean flush) {
3641         try {
3642             lock.lock();
3643 
3644             if (skipRedisplay) {
3645                 skipRedisplay = false;
3646                 return;
3647             }
3648 
3649             Status status = Status.getStatus(terminal, false);
3650             if (status != null) {
3651                 status.redraw();
3652             }
3653 
3654             if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {
3655                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
3656 
3657                 sb.append(prompt);
3658                 concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);
3659                 AttributedString full = sb.toAttributedString();
3660 
3661                 sb.setLength(0);
3662                 sb.append(prompt);
3663                 String line = buf.upToCursor();
3664                 if (maskingCallback != null) {
3665                     line = maskingCallback.display(line);
3666                 }
3667 
3668                 concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);
3669                 AttributedString toCursor = sb.toAttributedString();
3670 
3671                 int w = WCWidth.wcwidth(&#39;\u2026&#39;);
3672                 int width = size.getColumns();
3673                 int cursor = toCursor.columnLength();
3674                 int inc = width / 2 + 1;
3675                 while (cursor &lt;= smallTerminalOffset + w) {
3676                     smallTerminalOffset -= inc;
3677                 }
3678                 while (cursor &gt;= smallTerminalOffset + width - w) {
3679                     smallTerminalOffset += inc;
3680                 }
3681                 if (smallTerminalOffset &gt; 0) {
3682                     sb.setLength(0);
3683                     sb.append(&quot;\u2026&quot;);
3684                     sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));
3685                     full = sb.toAttributedString();
3686                 }
3687                 int length = full.columnLength();
3688                 if (length &gt;= smallTerminalOffset + width) {
3689                     sb.setLength(0);
3690                     sb.append(full.columnSubSequence(0, width - w));
3691                     sb.append(&quot;\u2026&quot;);
3692                     full = sb.toAttributedString();
3693                 }
3694 
3695                 display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);
3696                 return;
3697             }
3698 
3699             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
3700             AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);
3701 
3702             List&lt;AttributedString&gt; newLines;
3703             if (size.getColumns() &lt;= 0) {
3704                 newLines = new ArrayList&lt;&gt;();
3705                 newLines.add(full);
3706             } else {
3707                 newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
3708             }
3709 
3710             List&lt;AttributedString&gt; rightPromptLines;
3711             if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {
3712                 rightPromptLines = new ArrayList&lt;&gt;();
3713             } else {
3714                 rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());
3715             }
3716             while (newLines.size() &lt; rightPromptLines.size()) {
3717                 newLines.add(new AttributedString(&quot;&quot;));
3718             }
3719             for (int i = 0; i &lt; rightPromptLines.size(); i++) {
3720                 AttributedString line = rightPromptLines.get(i);
3721                 newLines.set(i, addRightPrompt(line, newLines.get(i)));
3722             }
3723 
3724             int cursorPos = -1;
3725             int cursorNewLinesId = -1;
3726             int cursorColPos = -1;
3727             if (size.getColumns() &gt; 0) {
3728                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
3729                 sb.append(prompt);
3730                 String buffer = buf.upToCursor();
3731                 if (maskingCallback != null) {
3732                     buffer = maskingCallback.display(buffer);
3733                 }
3734                 sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));
3735                 List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
3736                 if (!promptLines.isEmpty()) {
3737                     cursorNewLinesId = promptLines.size() - 1;
3738                     cursorColPos = promptLines.get(promptLines.size() - 1).columnLength();
3739                     cursorPos = size.cursorPos(cursorNewLinesId, cursorColPos);
3740                 }
3741             }
3742 
3743             List&lt;AttributedString&gt; newLinesToDisplay = new ArrayList&lt;&gt;();
3744             int displaySize = size.getRows() - (status != null ? status.size() : 0);
3745             if (newLines.size() &gt; displaySize &amp;&amp; !isTerminalDumb()) {
3746                 StringBuilder sb = new StringBuilder(&quot;&gt;....&quot;);
3747                 // blanks are needed when displaying command completion candidate list
3748                 for (int i = sb.toString().length(); i &lt; size.getColumns(); i++) {
3749                     sb.append(&quot; &quot;);
3750                 }
3751                 AttributedString partialCommandInfo = new AttributedString(sb.toString());
3752                 int lineId = newLines.size() - displaySize + 1;
3753                 int endId = displaySize;
3754                 int startId = 1;
3755                 if (lineId  &gt; cursorNewLinesId) {
3756                     lineId = cursorNewLinesId;
3757                     endId = displaySize - 1;
3758                     startId = 0;
3759                 } else {
3760                     newLinesToDisplay.add(partialCommandInfo);
3761                 }
3762                 int cursorRowPos = 0;
3763                 for (int i = startId; i &lt; endId; i++) {
3764                     if (cursorNewLinesId == lineId) {
3765                         cursorRowPos = i;
3766                     }
3767                     newLinesToDisplay.add(newLines.get(lineId++));
3768                 }
3769                 if (startId == 0) {
3770                     newLinesToDisplay.add(partialCommandInfo);
3771                 }
3772                 cursorPos = size.cursorPos(cursorRowPos, cursorColPos);
3773             } else {
3774                 newLinesToDisplay = newLines;
3775             }
3776             display.update(newLinesToDisplay, cursorPos, flush);
3777         } finally {
3778             lock.unlock();
3779         }
3780     }
3781 
3782     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3783         if (lines.size() &gt; 1) {
3784             for (int i = 0; i &lt; lines.size() - 1; i++) {
3785                 sb.append(lines.get(i));
3786                 sb.style(sb.style().inverse());
3787                 sb.append(&quot;\\n&quot;);
3788                 sb.style(sb.style().inverseOff());
3789             }
3790         }
3791         sb.append(lines.get(lines.size() - 1));
3792     }
3793 
3794     /**
3795      * Compute the full string to be displayed with the left, right and secondary prompts
3796      * @param secondaryPrompts a list to store the secondary prompts
3797      * @return the displayed string including the buffer, left prompts and the help below
3798      */
3799     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
3800         AttributedString attBuf = getHighlightedBuffer(buf.toString());
3801 
3802         AttributedString tNewBuf = insertSecondaryPrompts(attBuf, secondaryPrompts);
3803         AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);
3804         full.append(prompt);
3805         full.append(tNewBuf);
3806         if (post != null) {
3807             full.append(&quot;\n&quot;);
3808             full.append(post.get());
3809         }
3810         return full.toAttributedString();
3811     }
3812 
3813     private AttributedString getHighlightedBuffer(String buffer) {
3814         if (maskingCallback != null) {
3815             buffer = maskingCallback.display(buffer);
3816         }
3817         if (highlighter != null &amp;&amp; !isSet(Option.DISABLE_HIGHLIGHTER)) {
3818             return highlighter.highlight(this, buffer);
3819         }
3820         return new AttributedString(buffer);
3821     }
3822 
3823     private AttributedString expandPromptPattern(String pattern, int padToWidth,
3824                                                  String message, int line) {
3825         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
3826         boolean isHidden = false;
3827         int padPartIndex = -1;
3828         StringBuilder padPartString = null;
3829         StringBuilder sb = new StringBuilder();
3830         // Add &quot;%{&quot; to avoid special case for end of string.
3831         pattern = pattern + &quot;%{&quot;;
3832         int plen = pattern.length();
3833         int padChar = -1;
3834         int padPos = -1;
3835         int cols = 0;
3836         for (int i = 0; i &lt; plen; ) {
3837             char ch = pattern.charAt(i++);
3838             if (ch == &#39;%&#39; &amp;&amp; i &lt; plen) {
3839                 int count = 0;
3840                 boolean countSeen = false;
3841                 decode: while (true) {
3842                     ch = pattern.charAt(i++);
3843                     switch (ch) {
3844                         case &#39;{&#39;:
3845                         case &#39;}&#39;:
3846                             String str = sb.toString();
3847                             AttributedString astr;
3848                             if (!isHidden) {
3849                                 astr = AttributedString.fromAnsi(str);
3850                                 cols += astr.columnLength();
3851                             } else {
3852                                 astr = new AttributedString(str, AttributedStyle.HIDDEN);
3853                             }
3854                             if (padPartIndex == parts.size()) {
3855                                 padPartString = sb;
3856                                 if (i &lt; plen) {
3857                                     sb = new StringBuilder();
3858                                 }
3859                             } else {
3860                                 sb.setLength(0);
3861                             }
3862                             parts.add(astr);
3863                             isHidden = ch == &#39;{&#39;;
3864                             break decode;
3865                         case &#39;%&#39;:
3866                             sb.append(ch);
3867                             break decode;
3868                         case &#39;N&#39;:
3869                             sb.append(getInt(LINE_OFFSET, 0) + line);
3870                             break decode;
3871                         case &#39;M&#39;:
3872                             if (message != null)
3873                                 sb.append(message);
3874                             break decode;
3875                         case &#39;P&#39;:
3876                             if (countSeen &amp;&amp; count &gt;= 0)
3877                                 padToWidth = count;
3878                             if (i &lt; plen) {
3879                                 padChar = pattern.charAt(i++);
3880                                 // FIXME check surrogate
3881                             }
3882                             padPos = sb.length();
3883                             padPartIndex = parts.size();
3884                             break decode;
3885                         case &#39;-&#39;:
3886                         case &#39;0&#39;:
3887                         case &#39;1&#39;:
3888                         case &#39;2&#39;:
3889                         case &#39;3&#39;:
3890                         case &#39;4&#39;:
3891                         case &#39;5&#39;:
3892                         case &#39;6&#39;:
3893                         case &#39;7&#39;:
3894                         case &#39;8&#39;:
3895                         case &#39;9&#39;:
3896                             boolean neg = false;
3897                             if (ch == &#39;-&#39;) {
3898                                 neg = true;
3899                                 ch = pattern.charAt(i++);
3900                             }
3901                             countSeen = true;
3902                             count = 0;
3903                             while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) {
3904                                 count = (count &lt; 0 ? 0 : 10 * count) + (ch - &#39;0&#39;);
3905                                 ch = pattern.charAt(i++);
3906                             }
3907                             if (neg) {
3908                                 count = -count;
3909                             }
3910                             i--;
3911                             break;
3912                         default:
3913                             break decode;
3914                     }
3915                 }
3916             } else
3917                 sb.append(ch);
3918         }
3919         if (padToWidth &gt; cols) {
3920             int padCharCols = WCWidth.wcwidth(padChar);
3921             int padCount = (padToWidth - cols) / padCharCols;
3922             sb = padPartString;
3923             while (--padCount &gt;= 0)
3924                 sb.insert(padPos, (char) padChar); // FIXME if wide
3925             parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));
3926         }
3927         return AttributedString.join(null, parts);
3928     }
3929 
3930     private AttributedString insertSecondaryPrompts(AttributedString str, List&lt;AttributedString&gt; prompts) {
3931         return insertSecondaryPrompts(str, prompts, true);
3932     }
3933 
3934     private AttributedString insertSecondaryPrompts(AttributedString strAtt, List&lt;AttributedString&gt; prompts, boolean computePrompts) {
3935         Objects.requireNonNull(prompts);
3936         List&lt;AttributedString&gt; lines = strAtt.columnSplitLength(Integer.MAX_VALUE);
3937         AttributedStringBuilder sb = new AttributedStringBuilder();
3938         String secondaryPromptPattern = getString(SECONDARY_PROMPT_PATTERN, DEFAULT_SECONDARY_PROMPT_PATTERN);
3939         boolean needsMessage = secondaryPromptPattern.contains(&quot;%M&quot;);
3940         AttributedStringBuilder buf = new AttributedStringBuilder();
3941         int width = 0;
3942         List&lt;String&gt; missings = new ArrayList&lt;&gt;();
3943         if (computePrompts &amp;&amp; secondaryPromptPattern.contains(&quot;%P&quot;)) {
3944             width = prompt.columnLength();
3945             for (int line = 0; line &lt; lines.size() - 1; line++) {
3946                 AttributedString prompt;
3947                 buf.append(lines.get(line)).append(&quot;\n&quot;);
3948                 String missing = &quot;&quot;;
3949                 if (needsMessage) {
3950                     try {
3951                         parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
3952                     } catch (EOFError e) {
3953                         missing = e.getMissing();
3954                     } catch (SyntaxError e) {
3955                         // Ignore
3956                     }
3957                 }
3958                 missings.add(missing);
3959                 prompt = expandPromptPattern(secondaryPromptPattern, 0, missing, line + 1);
3960                 width = Math.max(width, prompt.columnLength());
3961             }
3962             buf.setLength(0);
3963         }
3964         int line = 0;
3965         while (line &lt; lines.size() - 1) {
3966             sb.append(lines.get(line)).append(&quot;\n&quot;);
3967             buf.append(lines.get(line)).append(&quot;\n&quot;);
3968             AttributedString prompt;
3969             if (computePrompts) {
3970                 String missing = &quot;&quot;;
3971                 if (needsMessage) {
3972                     if (missings.isEmpty()) {
3973                         try {
3974                             parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
3975                         } catch (EOFError e) {
3976                             missing = e.getMissing();
3977                         } catch (SyntaxError e) {
3978                             // Ignore
3979                         }
3980                     } else {
3981                         missing = missings.get(line);
3982                     }
3983                 }
3984                 prompt = expandPromptPattern(secondaryPromptPattern, width, missing, line + 1);
3985             } else {
3986                 prompt = prompts.get(line);
3987             }
3988             prompts.add(prompt);
3989             sb.append(prompt);
3990             line++;
3991         }
3992         sb.append(lines.get(line));
3993         buf.append(lines.get(line));
3994         return sb.toAttributedString();
3995     }
3996 
3997     private AttributedString addRightPrompt(AttributedString prompt, AttributedString line) {
3998         int width = prompt.columnLength();
3999         boolean endsWithNl = line.length() &gt; 0
4000             &amp;&amp; line.charAt(line.length() - 1) == &#39;\n&#39;;
4001         // columnLength counts -1 for the final newline; adjust for that
4002         int nb = size.getColumns() - width
4003             - (line.columnLength() + (endsWithNl ? 1 : 0));
4004         if (nb &gt;= 3) {
4005             AttributedStringBuilder sb = new AttributedStringBuilder(size.getColumns());
4006             sb.append(line, 0, endsWithNl ? line.length() - 1 : line.length());
4007             for (int j = 0; j &lt; nb; j++) {
4008                 sb.append(&#39; &#39;);
4009             }
4010             sb.append(prompt);
4011             if (endsWithNl) {
4012                 sb.append(&#39;\n&#39;);
4013             }
4014             line = sb.toAttributedString();
4015         }
4016         return line;
4017     }
4018 
4019     //
4020     // Completion
4021     //
4022 
4023     protected boolean insertTab() {
4024         return isSet(Option.INSERT_TAB)
4025                     &amp;&amp; getLastBinding().equals(&quot;\t&quot;)
4026                     &amp;&amp; buf.toString().matches(&quot;(^|[\\s\\S]*\n)[\r\n\t ]*&quot;);
4027     }
4028 
4029     protected boolean expandHistory() {
4030         String str = buf.toString();
4031         String exp = expander.expandHistory(history, str);
4032         if (!exp.equals(str)) {
4033             buf.clear();
4034             buf.write(exp);
4035             return true;
4036         } else {
4037             return false;
4038         }
4039     }
4040 
4041     protected enum CompletionType {
4042         Expand,
4043         ExpandComplete,
4044         Complete,
4045         List,
4046     }
4047 
4048     protected boolean expandWord() {
4049         if (insertTab()) {
4050             return selfInsert();
4051         } else {
4052             return doComplete(CompletionType.Expand, isSet(Option.MENU_COMPLETE), false);
4053         }
4054     }
4055 
4056     protected boolean expandOrComplete() {
4057         if (insertTab()) {
4058             return selfInsert();
4059         } else {
4060             return doComplete(CompletionType.ExpandComplete, isSet(Option.MENU_COMPLETE), false);
4061         }
4062     }
4063 
4064     protected boolean expandOrCompletePrefix() {
4065         if (insertTab()) {
4066             return selfInsert();
4067         } else {
4068             return doComplete(CompletionType.ExpandComplete, isSet(Option.MENU_COMPLETE), true);
4069         }
4070     }
4071 
4072     protected boolean completeWord() {
4073         if (insertTab()) {
4074             return selfInsert();
4075         } else {
4076             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), false);
4077         }
4078     }
4079 
4080     protected boolean menuComplete() {
4081         if (insertTab()) {
4082             return selfInsert();
4083         } else {
4084             return doComplete(CompletionType.Complete, true, false);
4085         }
4086     }
4087 
4088     protected boolean menuExpandOrComplete() {
4089         if (insertTab()) {
4090             return selfInsert();
4091         } else {
4092             return doComplete(CompletionType.ExpandComplete, true, false);
4093         }
4094     }
4095 
4096     protected boolean completePrefix() {
4097         if (insertTab()) {
4098             return selfInsert();
4099         } else {
4100             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), true);
4101         }
4102     }
4103 
4104     protected boolean listChoices() {
4105         return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
4106     }
4107 
4108     protected boolean deleteCharOrList() {
4109         if (buf.cursor() != buf.length() || buf.length() == 0) {
4110             return deleteChar();
4111         } else {
4112             return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
4113         }
4114     }
4115 
4116     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {
4117         // If completion is disabled, just bail out
4118         if (getBoolean(DISABLE_COMPLETION, false)) {
4119             return true;
4120         }
4121         // Try to expand history first
4122         // If there is actually an expansion, bail out now
4123         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
4124             try {
4125                 if (expandHistory()) {
4126                     return true;
4127                 }
4128             } catch (Exception e) {
4129                 Log.info(&quot;Error while expanding history&quot;, e);
4130                 return false;
4131             }
4132         }
4133 
4134         // Parse the command line
4135         CompletingParsedLine line;
4136         try {
4137             line = wrap(parser.parse(buf.toString(), buf.cursor(), ParseContext.COMPLETE));
4138         } catch (Exception e) {
4139             Log.info(&quot;Error while parsing line&quot;, e);
4140             return false;
4141         }
4142 
4143         // Find completion candidates
4144         List&lt;Candidate&gt; candidates = new ArrayList&lt;&gt;();
4145         try {
4146             if (completer != null) {
4147                 completer.complete(this, line, candidates);
4148             }
4149         } catch (Exception e) {
4150             Log.info(&quot;Error while finding completion candidates&quot;, e);
4151             return false;
4152         }
4153 
4154         if (lst == CompletionType.ExpandComplete || lst == CompletionType.Expand) {
4155             String w = expander.expandVar(line.word());
4156             if (!line.word().equals(w)) {
4157                 if (prefix) {
4158                     buf.backspace(line.wordCursor());
4159                 } else {
4160                     buf.move(line.word().length() - line.wordCursor());
4161                     buf.backspace(line.word().length());
4162                 }
4163                 buf.write(w);
4164                 return true;
4165             }
4166             if (lst == CompletionType.Expand) {
4167                 return false;
4168             } else {
4169                 lst = CompletionType.Complete;
4170             }
4171         }
4172 
4173         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4174         int errors = getInt(ERRORS, DEFAULT_ERRORS);
4175 
4176         // Build a list of sorted candidates
4177         Map&lt;String, List&lt;Candidate&gt;&gt; sortedCandidates = new HashMap&lt;&gt;();
4178         for (Candidate cand : candidates) {
4179             sortedCandidates
4180                     .computeIfAbsent(AttributedString.fromAnsi(cand.value()).toString(), s -&gt; new ArrayList&lt;&gt;())
4181                     .add(cand);
4182         }
4183 
4184         // Find matchers
4185         // TODO: glob completion
4186         List&lt;Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4187                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt;&gt; matchers;
4188         Predicate&lt;String&gt; exact;
4189         if (prefix) {
4190             String wd = line.word();
4191             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4192             String wp = wdi.substring(0, line.wordCursor());
4193             matchers = Arrays.asList(
4194                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wp)),
4195                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wp)),
4196                     typoMatcher(wp, errors, caseInsensitive)
4197             );
4198             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);
4199         } else if (isSet(Option.COMPLETE_IN_WORD)) {
4200             String wd = line.word();
4201             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4202             String wp = wdi.substring(0, line.wordCursor());
4203             String ws = wdi.substring(line.wordCursor());
4204             Pattern p1 = Pattern.compile(Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4205             Pattern p2 = Pattern.compile(&quot;.*&quot; + Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4206             matchers = Arrays.asList(
4207                     simpleMatcher(s -&gt; p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4208                     simpleMatcher(s -&gt; p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4209                     typoMatcher(wdi, errors, caseInsensitive)
4210             );
4211             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4212         } else {
4213             String wd = line.word();
4214             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4215             matchers = Arrays.asList(
4216                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),
4217                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),
4218                     typoMatcher(wdi, errors, caseInsensitive)
4219             );
4220             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4221         }
4222         // Find matching candidates
4223         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4224         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4225                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4226             matching = matcher.apply(sortedCandidates);
4227             if (!matching.isEmpty()) {
4228                 break;
4229             }
4230         }
4231 
4232         // If we have no matches, bail out
4233         if (matching.isEmpty()) {
4234             return false;
4235         }
4236         size.copy(terminal.getSize());
4237         try {
4238             // If we only need to display the list, do it now
4239             if (lst == CompletionType.List) {
4240                 List&lt;Candidate&gt; possible = matching.entrySet().stream()
4241                         .flatMap(e -&gt; e.getValue().stream())
4242                         .collect(Collectors.toList());
4243                 doList(possible, line.word(), false, line::escape);
4244                 return !possible.isEmpty();
4245             }
4246 
4247             // Check if there&#39;s a single possible match
4248             Candidate completion = null;
4249             // If there&#39;s a single possible completion
4250             if (matching.size() == 1) {
4251                 completion = matching.values().stream().flatMap(Collection::stream)
4252                         .findFirst().orElse(null);
4253             }
4254             // Or if RECOGNIZE_EXACT is set, try to find an exact match
4255             else if (isSet(Option.RECOGNIZE_EXACT)) {
4256                 completion = matching.values().stream().flatMap(Collection::stream)
4257                         .filter(Candidate::complete)
4258                         .filter(c -&gt; exact.test(c.value()))
4259                         .findFirst().orElse(null);
4260             }
4261             // Complete and exit
4262             if (completion != null &amp;&amp; !completion.value().isEmpty()) {
4263                 if (prefix) {
4264                     buf.backspace(line.rawWordCursor());
4265                 } else {
4266                     buf.move(line.rawWordLength() - line.rawWordCursor());
4267                     buf.backspace(line.rawWordLength());
4268                 }
4269                 buf.write(line.escape(completion.value(), completion.complete()));
4270                 if (completion.complete()) {
4271                     if (buf.currChar() != &#39; &#39;) {
4272                         buf.write(&quot; &quot;);
4273                     } else {
4274                         buf.move(1);
4275                     }
4276                 }
4277                 if (completion.suffix() != null) {
4278                     redisplay();
4279                     Binding op = readBinding(getKeys());
4280                     if (op != null) {
4281                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);
4282                         String ref = op instanceof Reference ? ((Reference) op).name() : null;
4283                         if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4284                                 || ACCEPT_LINE.equals(ref)) {
4285                             buf.backspace(completion.suffix().length());
4286                             if (getLastBinding().charAt(0) != &#39; &#39;) {
4287                                 buf.write(&#39; &#39;);
4288                             }
4289                         }
4290                         pushBackBinding(true);
4291                     }
4292                 }
4293                 return true;
4294             }
4295 
4296             List&lt;Candidate&gt; possible = matching.entrySet().stream()
4297                     .flatMap(e -&gt; e.getValue().stream())
4298                     .collect(Collectors.toList());
4299 
4300             if (useMenu) {
4301                 buf.move(line.word().length() - line.wordCursor());
4302                 buf.backspace(line.word().length());
4303                 doMenu(possible, line.word(), line::escape);
4304                 return true;
4305             }
4306 
4307             // Find current word and move to end
4308             String current;
4309             if (prefix) {
4310                 current = line.word().substring(0, line.wordCursor());
4311             } else {
4312                 current = line.word();
4313                 buf.move(line.rawWordLength() - line.rawWordCursor());
4314             }
4315             // Now, we need to find the unambiguous completion
4316             // TODO: need to find common suffix
4317             String commonPrefix = null;
4318             for (String key : matching.keySet()) {
4319                 commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);
4320             }
4321             boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);
4322 
4323             if (hasUnambiguous) {
4324                 buf.backspace(line.rawWordLength());
4325                 buf.write(line.escape(commonPrefix, false));
4326                 current = commonPrefix;
4327                 if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))
4328                         || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {
4329                     if (!nextBindingIsComplete()) {
4330                         return true;
4331                     }
4332                 }
4333             }
4334             if (isSet(Option.AUTO_LIST)) {
4335                 if (!doList(possible, current, true, line::escape)) {
4336                     return true;
4337                 }
4338             }
4339             if (isSet(Option.AUTO_MENU)) {
4340                 buf.backspace(current.length());
4341                 doMenu(possible, line.word(), line::escape);
4342             }
4343             return true;
4344         } finally {
4345             size.copy(terminal.getBufferSize());
4346         }
4347     }
4348 
4349     private CompletingParsedLine wrap(ParsedLine line) {
4350         if (line instanceof CompletingParsedLine) {
4351             return (CompletingParsedLine) line;
4352         } else {
4353             return new CompletingParsedLine() {
4354                 public String word() {
4355                     return line.word();
4356                 }
4357                 public int wordCursor() {
4358                     return line.wordCursor();
4359                 }
4360                 public int wordIndex() {
4361                     return line.wordIndex();
4362                 }
4363                 public List&lt;String&gt; words() {
4364                     return line.words();
4365                 }
4366                 public String line() {
4367                     return line.line();
4368                 }
4369                 public int cursor() {
4370                     return line.cursor();
4371                 }
4372                 public CharSequence escape(CharSequence candidate, boolean complete) {
4373                     return candidate;
4374                 }
4375                 public int rawWordCursor() {
4376                     return wordCursor();
4377                 }
4378                 public int rawWordLength() {
4379                     return word().length();
4380                 }
4381             };
4382         }
4383     }
4384 
4385     protected Comparator&lt;Candidate&gt; getCandidateComparator(boolean caseInsensitive, String word) {
4386         String wdi = caseInsensitive ? word.toLowerCase() : word;
4387         ToIntFunction&lt;String&gt; wordDistance = w -&gt; distance(wdi, caseInsensitive ? w.toLowerCase() : w);
4388         return Comparator
4389                 .comparing(Candidate::value, Comparator.comparingInt(wordDistance))
4390                 .thenComparing(Candidate::value, Comparator.comparingInt(String::length))
4391                 .thenComparing(Comparator.naturalOrder());
4392     }
4393 
4394     protected String getOthersGroupName() {
4395         return getString(OTHERS_GROUP_NAME, DEFAULT_OTHERS_GROUP_NAME);
4396     }
4397 
4398     protected String getOriginalGroupName() {
4399         return getString(ORIGINAL_GROUP_NAME, DEFAULT_ORIGINAL_GROUP_NAME);
4400     }
4401 
4402 
4403     protected Comparator&lt;String&gt; getGroupComparator() {
4404         return Comparator.&lt;String&gt;comparingInt(s -&gt; getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)
4405                 .thenComparing(String::toLowerCase, Comparator.naturalOrder());
4406     }
4407 
4408     private void mergeCandidates(List&lt;Candidate&gt; possible) {
4409         // Merge candidates if the have the same key
4410         Map&lt;String, List&lt;Candidate&gt;&gt; keyedCandidates = new HashMap&lt;&gt;();
4411         for (Candidate candidate : possible) {
4412             if (candidate.key() != null) {
4413                 List&lt;Candidate&gt; cands = keyedCandidates.computeIfAbsent(candidate.key(), s -&gt; new ArrayList&lt;&gt;());
4414                 cands.add(candidate);
4415             }
4416         }
4417         if (!keyedCandidates.isEmpty()) {
4418             for (List&lt;Candidate&gt; candidates : keyedCandidates.values()) {
4419                 if (candidates.size() &gt;= 1) {
4420                     possible.removeAll(candidates);
4421                     // Candidates with the same key are supposed to have
4422                     // the same description
4423                     candidates.sort(Comparator.comparing(Candidate::value));
4424                     Candidate first = candidates.get(0);
4425                     String disp = candidates.stream()
4426                             .map(Candidate::displ)
4427                             .collect(Collectors.joining(&quot; &quot;));
4428                     possible.add(new Candidate(first.value(), disp, first.group(),
4429                             first.descr(), first.suffix(), null, first.complete()));
4430                 }
4431             }
4432         }
4433     }
4434 
4435     private Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4436                      Map&lt;String, List&lt;Candidate&gt;&gt;&gt; simpleMatcher(Predicate&lt;String&gt; pred) {
4437         return m -&gt; m.entrySet().stream()
4438                 .filter(e -&gt; pred.test(e.getKey()))
4439                 .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
4440     }
4441 
4442     private Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4443                      Map&lt;String, List&lt;Candidate&gt;&gt;&gt; typoMatcher(String word, int errors, boolean caseInsensitive) {
4444         return m -&gt; {
4445             Map&lt;String, List&lt;Candidate&gt;&gt; map = m.entrySet().stream()
4446                     .filter(e -&gt; distance(word, caseInsensitive ? e.getKey() : e.getKey().toLowerCase()) &lt; errors)
4447                     .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
4448             if (map.size() &gt; 1) {
4449                 map.computeIfAbsent(word, w -&gt; new ArrayList&lt;&gt;())
4450                         .add(new Candidate(word, word, getOriginalGroupName(), null, null, null, false));
4451             }
4452             return map;
4453         };
4454     }
4455 
4456     private int distance(String word, String cand) {
4457         if (word.length() &lt; cand.length()) {
4458             int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));
4459             int d2 = Levenshtein.distance(word, cand);
4460             return Math.min(d1, d2);
4461         } else {
4462             return Levenshtein.distance(word, cand);
4463         }
4464     }
4465 
4466     protected boolean nextBindingIsComplete() {
4467         redisplay();
4468         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4469         Binding operation = readBinding(getKeys(), keyMap);
4470         if (operation instanceof Reference &amp;&amp; MENU_COMPLETE.equals(((Reference) operation).name())) {
4471             return true;
4472         } else {
4473             pushBackBinding();
4474             return false;
4475         }
4476     }
4477 
4478     private class MenuSupport implements Supplier&lt;AttributedString&gt; {
4479         final List&lt;Candidate&gt; possible;
4480         final BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper;
4481         int selection;
4482         int topLine;
4483         String word;
4484         AttributedString computed;
4485         int lines;
4486         int columns;
4487         String completed;
4488 
4489         public MenuSupport(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4490             this.possible = new ArrayList&lt;&gt;();
4491             this.escaper = escaper;
4492             this.selection = -1;
4493             this.topLine = 0;
4494             this.word = &quot;&quot;;
4495             this.completed = completed;
4496             computePost(original, null, possible, completed);
4497             next();
4498         }
4499 
4500         public Candidate completion() {
4501             return possible.get(selection);
4502         }
4503 
4504         public void next() {
4505             selection = (selection + 1) % possible.size();
4506             update();
4507         }
4508 
4509         public void previous() {
4510             selection = (selection + possible.size() - 1) % possible.size();
4511             update();
4512         }
4513 
4514         /**
4515          * Move &#39;step&#39; options along the major axis of the menu.&lt;p&gt;
4516          * ie. if the menu is listing rows first, change row (up/down);
4517          * otherwise move column (left/right)
4518          *
4519          * @param step number of options to move by
4520          */
4521         private void major(int step) {
4522             int axis = isSet(Option.LIST_ROWS_FIRST) ? columns : lines;
4523             int sel = selection + step * axis;
4524             if (sel &lt; 0) {
4525                 int pos = (sel + axis) % axis; // needs +axis as (-1)%x == -1
4526                 int remainders = possible.size() % axis;
4527                 sel = possible.size() - remainders + pos;
4528                 if (sel &gt;= possible.size()) {
4529                     sel -= axis;
4530                 }
4531             } else if (sel &gt;= possible.size()) {
4532                 sel = sel % axis;
4533             }
4534             selection = sel;
4535             update();
4536         }
4537 
4538         /**
4539          * Move &#39;step&#39; options along the minor axis of the menu.&lt;p&gt;
4540          * ie. if the menu is listing rows first, move along the row (left/right);
4541          * otherwise move along the column (up/down)
4542          *
4543          * @param step number of options to move by
4544          */
4545         private void minor(int step) {
4546             int axis = isSet(Option.LIST_ROWS_FIRST) ? columns : lines;
4547             int row = selection % axis;
4548             int options = possible.size();
4549             if (selection - row + axis &gt; options) {
4550                 // selection is the last row/column
4551                 // so there are fewer options than other rows
4552                 axis = options%axis;
4553             }
4554             selection = selection - row + ((axis + row + step) % axis);
4555             update();
4556         }
4557 
4558         public void up() {
4559             if (isSet(Option.LIST_ROWS_FIRST)) {
4560                 major(-1);
4561             } else {
4562                 minor(-1);
4563             }
4564         }
4565 
4566         public void down() {
4567             if (isSet(Option.LIST_ROWS_FIRST)) {
4568                 major(1);
4569             } else {
4570                 minor(1);
4571             }
4572         }
4573 
4574         public void left() {
4575             if (isSet(Option.LIST_ROWS_FIRST)) {
4576                 minor(-1);
4577             } else {
4578                 major(-1);
4579             }
4580         }
4581 
4582         public void right() {
4583             if (isSet(Option.LIST_ROWS_FIRST)) {
4584                 minor(1);
4585             } else {
4586                 major(1);
4587             }
4588         }
4589 
4590         private void update() {
4591             buf.backspace(word.length());
4592             word = escaper.apply(completion().value(), true).toString();
4593             buf.write(word);
4594 
4595             // Compute displayed prompt
4596             PostResult pr = computePost(possible, completion(), null, completed);
4597             AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4598             int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4599             if (pr.lines &gt; size.getRows() - promptLines) {
4600                 int displayed = size.getRows() - promptLines - 1;
4601                 if (pr.selectedLine &gt;= 0) {
4602                     if (pr.selectedLine &lt; topLine) {
4603                         topLine = pr.selectedLine;
4604                     } else if (pr.selectedLine &gt;= topLine + displayed) {
4605                         topLine = pr.selectedLine - displayed + 1;
4606                     }
4607                 }
4608                 AttributedString post = pr.post;
4609                 if (post.length() &gt; 0 &amp;&amp; post.charAt(post.length() - 1) != &#39;\n&#39;) {
4610                     post = new AttributedStringBuilder(post.length() + 1)
4611                             .append(post).append(&quot;\n&quot;).toAttributedString();
4612                 }
4613                 List&lt;AttributedString&gt; lines = post.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
4614                 List&lt;AttributedString&gt; sub = new ArrayList&lt;&gt;(lines.subList(topLine, topLine + displayed));
4615                 sub.add(new AttributedStringBuilder()
4616                         .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))
4617                         .append(&quot;rows &quot;)
4618                         .append(Integer.toString(topLine + 1))
4619                         .append(&quot; to &quot;)
4620                         .append(Integer.toString(topLine + displayed))
4621                         .append(&quot; of &quot;)
4622                         .append(Integer.toString(lines.size()))
4623                         .append(&quot;\n&quot;)
4624                         .style(AttributedStyle.DEFAULT).toAttributedString());
4625                 computed = AttributedString.join(AttributedString.EMPTY, sub);
4626             } else {
4627                 computed = pr.post;
4628             }
4629             lines = pr.lines;
4630             columns = (possible.size() + lines - 1) / lines;
4631         }
4632 
4633         @Override
4634         public AttributedString get() {
4635             return computed;
4636         }
4637 
4638     }
4639 
4640     protected boolean doMenu(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4641         // Reorder candidates according to display order
4642         final List&lt;Candidate&gt; possible = new ArrayList&lt;&gt;();
4643         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4644         original.sort(getCandidateComparator(caseInsensitive, completed));
4645         mergeCandidates(original);
4646         computePost(original, null, possible, completed);
4647 
4648         // Build menu support
4649         MenuSupport menuSupport = new MenuSupport(original, completed, escaper);
4650         post = menuSupport;
4651         redisplay();
4652 
4653         // Loop
4654         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4655         Binding operation;
4656         while ((operation = readBinding(getKeys(), keyMap)) != null) {
4657             String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
4658             switch (ref) {
4659                 case MENU_COMPLETE:
4660                     menuSupport.next();
4661                     break;
4662                 case REVERSE_MENU_COMPLETE:
4663                     menuSupport.previous();
4664                     break;
4665                 case UP_LINE_OR_HISTORY:
4666                 case UP_LINE_OR_SEARCH:
4667                     menuSupport.up();
4668                     break;
4669                 case DOWN_LINE_OR_HISTORY:
4670                 case DOWN_LINE_OR_SEARCH:
4671                     menuSupport.down();
4672                     break;
4673                 case FORWARD_CHAR:
4674                     menuSupport.right();
4675                     break;
4676                 case BACKWARD_CHAR:
4677                     menuSupport.left();
4678                     break;
4679                 case CLEAR_SCREEN:
4680                     clearScreen();
4681                     break;
4682                 default: {
4683                     Candidate completion = menuSupport.completion();
4684                     if (completion.suffix() != null) {
4685                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);
4686                         if (SELF_INSERT.equals(ref)
4687                                 &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4688                                 || BACKWARD_DELETE_CHAR.equals(ref)) {
4689                             buf.backspace(completion.suffix().length());
4690                         }
4691                     }
4692                     if (completion.complete()
4693                             &amp;&amp; getLastBinding().charAt(0) != &#39; &#39;
4694                             &amp;&amp; (SELF_INSERT.equals(ref) || getLastBinding().charAt(0) != &#39; &#39;)) {
4695                         buf.write(&#39; &#39;);
4696                     }
4697                     if (!ACCEPT_LINE.equals(ref)
4698                             &amp;&amp; !(SELF_INSERT.equals(ref)
4699                                 &amp;&amp; completion.suffix() != null
4700                                 &amp;&amp; completion.suffix().startsWith(getLastBinding()))) {
4701                         pushBackBinding(true);
4702                     }
4703                     post = null;
4704                     return true;
4705                 }
4706             }
4707             redisplay();
4708         }
4709         return false;
4710     }
4711 
4712     protected boolean doList(List&lt;Candidate&gt; possible, String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4713         // If we list only and if there&#39;s a big
4714         // number of items, we should ask the user
4715         // for confirmation, display the list
4716         // and redraw the line at the bottom
4717         mergeCandidates(possible);
4718         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4719         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4720         PostResult postResult = computePost(possible, null, null, completed);
4721         int lines = postResult.lines;
4722         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4723         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4724                 || lines &gt;= size.getRows() - promptLines) {
4725             // prompt
4726             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see all &quot; + possible.size()
4727                     + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);
4728             redisplay(true);
4729             int c = readCharacter();
4730             if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {
4731                 post = null;
4732                 return false;
4733             }
4734         }
4735 
4736         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4737         StringBuilder sb = new StringBuilder();
4738         while (true) {
4739             String current = completed + sb.toString();
4740             List&lt;Candidate&gt; cands;
4741             if (sb.length() &gt; 0) {
4742                 cands = possible.stream()
4743                         .filter(c -&gt; caseInsensitive
4744                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
4745                                     : c.value().startsWith(current))
4746                         .sorted(getCandidateComparator(caseInsensitive, current))
4747                         .collect(Collectors.toList());
4748             } else {
4749                 cands = possible.stream()
4750                         .sorted(getCandidateComparator(caseInsensitive, current))
4751                         .collect(Collectors.toList());
4752             }
4753             post = () -&gt; {
4754                 AttributedString t = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4755                 int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4756                 PostResult pr = computePost(cands, null, null, current);
4757                 if (pr.lines &gt;= size.getRows() - pl) {
4758                     post = null;
4759                     int oldCursor = buf.cursor();
4760                     buf.cursor(buf.length());
4761                     redisplay(false);
4762                     buf.cursor(oldCursor);
4763                     println();
4764                     List&lt;AttributedString&gt; ls = postResult.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
4765                     Display d = new Display(terminal, false);
4766                     d.resize(size.getRows(), size.getColumns());
4767                     d.update(ls, -1);
4768                     redrawLine();
4769                     return new AttributedString(&quot;&quot;);
4770                 }
4771                 return pr.post;
4772             };
4773             if (!runLoop) {
4774                 return false;
4775             }
4776             redisplay();
4777             // TODO: use a different keyMap ?
4778             Binding b = doReadBinding(getKeys(), null);
4779             if (b instanceof Reference) {
4780                 String name = ((Reference) b).name();
4781                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
4782                     if (sb.length() == 0) {
4783                         pushBackBinding();
4784                         post = null;
4785                         return false;
4786                     } else {
4787                         sb.setLength(sb.length() - 1);
4788                         buf.backspace();
4789                     }
4790                 } else if (SELF_INSERT.equals(name)) {
4791                     sb.append(getLastBinding());
4792                     buf.write(getLastBinding());
4793                     if (cands.isEmpty()) {
4794                         post = null;
4795                         return false;
4796                     }
4797                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
4798                     if (cands.size() == 1 || sb.length() &gt; 0) {
4799                         post = null;
4800                         pushBackBinding();
4801                     } else if (isSet(Option.AUTO_MENU)) {
4802                         buf.backspace(escaper.apply(current, false).length());
4803                         doMenu(cands, current, escaper);
4804                     }
4805                     return false;
4806                 } else {
4807                     pushBackBinding();
4808                     post = null;
4809                     return false;
4810                 }
4811             } else if (b == null) {
4812                 post = null;
4813                 return false;
4814             }
4815         }
4816     }
4817 
4818     protected static class PostResult {
4819         final AttributedString post;
4820         final int lines;
4821         final int selectedLine;
4822 
4823         public PostResult(AttributedString post, int lines, int selectedLine) {
4824             this.post = post;
4825             this.lines = lines;
4826             this.selectedLine = selectedLine;
4827         }
4828     }
4829 
4830     protected PostResult computePost(List&lt;Candidate&gt; possible, Candidate selection, List&lt;Candidate&gt; ordered, String completed) {
4831         return computePost(possible, selection, ordered, completed, display::wcwidth, size.getColumns(), isSet(Option.AUTO_GROUP), isSet(Option.GROUP), isSet(Option.LIST_ROWS_FIRST));
4832     }
4833 
4834     protected PostResult computePost(List&lt;Candidate&gt; possible, Candidate selection, List&lt;Candidate&gt; ordered, String completed, Function&lt;String, Integer&gt; wcwidth, int width, boolean autoGroup, boolean groupName, boolean rowsFirst) {
4835         List&lt;Object&gt; strings = new ArrayList&lt;&gt;();
4836         if (groupName) {
4837             Comparator&lt;String&gt; groupComparator = getGroupComparator();
4838             Map&lt;String, Map&lt;String, Candidate&gt;&gt; sorted;
4839             sorted = groupComparator != null
4840                         ? new TreeMap&lt;&gt;(groupComparator)
4841                         : new LinkedHashMap&lt;&gt;();
4842             for (Candidate cand : possible) {
4843                 String group = cand.group();
4844                 sorted.computeIfAbsent(group != null ? group : &quot;&quot;, s -&gt; new LinkedHashMap&lt;&gt;())
4845                         .put(cand.value(), cand);
4846             }
4847             for (Map.Entry&lt;String, Map&lt;String, Candidate&gt;&gt; entry : sorted.entrySet()) {
4848                 String group = entry.getKey();
4849                 if (group.isEmpty() &amp;&amp; sorted.size() &gt; 1) {
4850                     group = getOthersGroupName();
4851                 }
4852                 if (!group.isEmpty() &amp;&amp; autoGroup) {
4853                     strings.add(group);
4854                 }
4855                 strings.add(new ArrayList&lt;&gt;(entry.getValue().values()));
4856                 if (ordered != null) {
4857                     ordered.addAll(entry.getValue().values());
4858                 }
4859             }
4860         } else {
4861             Set&lt;String&gt; groups = new LinkedHashSet&lt;&gt;();
4862             TreeMap&lt;String, Candidate&gt; sorted = new TreeMap&lt;&gt;();
4863             for (Candidate cand : possible) {
4864                 String group = cand.group();
4865                 if (group != null) {
4866                     groups.add(group);
4867                 }
4868                 sorted.put(cand.value(), cand);
4869             }
4870             if (autoGroup) {
4871                 strings.addAll(groups);
4872             }
4873             strings.add(new ArrayList&lt;&gt;(sorted.values()));
4874             if (ordered != null) {
4875                 ordered.addAll(sorted.values());
4876             }
4877         }
4878         return toColumns(strings, selection, completed, wcwidth, width, rowsFirst);
4879     }
4880 
4881     private static final String DESC_PREFIX = &quot;(&quot;;
4882     private static final String DESC_SUFFIX = &quot;)&quot;;
4883     private static final int MARGIN_BETWEEN_DISPLAY_AND_DESC = 1;
4884     private static final int MARGIN_BETWEEN_COLUMNS = 3;
4885 
4886     @SuppressWarnings(&quot;unchecked&quot;)
4887     protected PostResult toColumns(List&lt;Object&gt; items, Candidate selection, String completed, Function&lt;String, Integer&gt; wcwidth, int width, boolean rowsFirst) {
4888         int[] out = new int[2];
4889         // TODO: support Option.LIST_PACKED
4890         // Compute column width
4891         int maxWidth = 0;
4892         for (Object item : items) {
4893             if (item instanceof String) {
4894                 int len = wcwidth.apply((String) item);
4895                 maxWidth = Math.max(maxWidth, len);
4896             }
4897             else if (item instanceof List) {
4898                 for (Candidate cand : (List&lt;Candidate&gt;) item) {
4899                     int len = wcwidth.apply(cand.displ());
4900                     if (cand.descr() != null) {
4901                         len += MARGIN_BETWEEN_DISPLAY_AND_DESC;
4902                         len += DESC_PREFIX.length();
4903                         len += wcwidth.apply(cand.descr());
4904                         len += DESC_SUFFIX.length();
4905                     }
4906                     maxWidth = Math.max(maxWidth, len);
4907                 }
4908             }
4909         }
4910         // Build columns
4911         AttributedStringBuilder sb = new AttributedStringBuilder();
4912         for (Object list : items) {
4913             toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, out);
4914         }
4915         if (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) == &#39;\n&#39;) {
4916             sb.setLength(sb.length() - 1);
4917         }
4918         return new PostResult(sb.toAttributedString(), out[0], out[1]);
4919     }
4920 
4921     @SuppressWarnings(&quot;unchecked&quot;)
4922     protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
4923         if (maxWidth &lt;= 0 || width &lt;= 0) {
4924             return;
4925         }
4926         // This is a group
4927         if (items instanceof String) {
4928             sb.style(getCompletionStyleGroup())
4929                     .append((String) items)
4930                     .style(AttributedStyle.DEFAULT)
4931                     .append(&quot;\n&quot;);
4932             out[0]++;
4933         }
4934         // This is a Candidate list
4935         else if (items instanceof List) {
4936             List&lt;Candidate&gt; candidates = (List&lt;Candidate&gt;) items;
4937             maxWidth = Math.min(width, maxWidth);
4938             int c = width / maxWidth;
4939             while (c &gt; 1 &amp;&amp; c * maxWidth + (c - 1) * MARGIN_BETWEEN_COLUMNS &gt;= width) {
4940                 c--;
4941             }
4942             int lines = (candidates.size() + c - 1) / c;
4943             // Try to minimize the number of columns for the given number of rows
4944             // Prevents eg 9 candiates being split 6/3 instead of 5/4.
4945             final int columns = (candidates.size() + lines - 1) / lines;
4946             IntBinaryOperator index;
4947             if (rowsFirst) {
4948                 index = (i, j) -&gt; i * columns + j;
4949             } else {
4950                 index = (i, j) -&gt; j * lines + i;
4951             }
4952             for (int i = 0; i &lt; lines; i++) {
4953                 for (int j = 0; j &lt; columns; j++) {
4954                     int idx = index.applyAsInt(i, j);
4955                     if (idx &lt; candidates.size()) {
4956                         Candidate cand = candidates.get(idx);
4957                         boolean hasRightItem = j &lt; columns - 1 &amp;&amp; index.applyAsInt(i, j + 1) &lt; candidates.size();
4958                         AttributedString left = AttributedString.fromAnsi(cand.displ());
4959                         AttributedString right = AttributedString.fromAnsi(cand.descr());
4960                         int lw = left.columnLength();
4961                         int rw = 0;
4962                         if (right != null) {
4963                             int rem = maxWidth - (lw + MARGIN_BETWEEN_DISPLAY_AND_DESC
4964                                     + DESC_PREFIX.length() + DESC_SUFFIX.length());
4965                             rw = right.columnLength();
4966                             if (rw &gt; rem) {
4967                                 right = AttributedStringBuilder.append(
4968                                             right.columnSubSequence(0, rem - WCWidth.wcwidth(&#39;\u2026&#39;)),
4969                                             &quot;\u2026&quot;);
4970                                 rw = right.columnLength();
4971                             }
4972                             right = AttributedStringBuilder.append(DESC_PREFIX, right, DESC_SUFFIX);
4973                             rw += DESC_PREFIX.length() + DESC_SUFFIX.length();
4974                         }
4975                         if (cand == selection) {
4976                             out[1] = i;
4977                             sb.style(getCompletionStyleSelection());
4978                             if (left.toString().regionMatches(
4979                                     isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {
4980                                 sb.append(left.toString(), 0, completed.length());
4981                                 sb.append(left.toString(), completed.length(), left.length());
4982                             } else {
4983                                 sb.append(left.toString());
4984                             }
4985                             for (int k = 0; k &lt; maxWidth - lw - rw; k++) {
4986                                 sb.append(&#39; &#39;);
4987                             }
4988                             if (right != null) {
4989                                 sb.append(right);
4990                             }
4991                             sb.style(AttributedStyle.DEFAULT);
4992                         } else {
4993                             if (left.toString().regionMatches(
4994                                     isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {
4995                                 sb.style(getCompletionStyleStarting());
4996                                 sb.append(left, 0, completed.length());
4997                                 sb.style(AttributedStyle.DEFAULT);
4998                                 sb.append(left, completed.length(), left.length());
4999                             } else {
5000                                 sb.append(left);
5001                             }
5002                             if (right != null || hasRightItem) {
5003                                 for (int k = 0; k &lt; maxWidth - lw - rw; k++) {
5004                                     sb.append(&#39; &#39;);
5005                                 }
5006                             }
5007                             if (right != null) {
5008                                 sb.style(getCompletionStyleDescription());
5009                                 sb.append(right);
5010                                 sb.style(AttributedStyle.DEFAULT);
5011                             }
5012                         }
5013                         if (hasRightItem) {
5014                             for (int k = 0; k &lt; MARGIN_BETWEEN_COLUMNS; k++) {
5015                                 sb.append(&#39; &#39;);
5016                             }
5017                         }
5018                     }
5019                 }
5020                 sb.append(&#39;\n&#39;);
5021             }
5022             out[0] += lines;
5023         }
5024     }
5025 
5026     private AttributedStyle getCompletionStyleStarting() {
5027         return getCompletionStyle(COMPLETION_STYLE_STARTING, DEFAULT_COMPLETION_STYLE_STARTING);
5028     }
5029 
5030     protected AttributedStyle getCompletionStyleDescription() {
5031         return getCompletionStyle(COMPLETION_STYLE_DESCRIPTION, DEFAULT_COMPLETION_STYLE_DESCRIPTION);
5032     }
5033 
5034     protected AttributedStyle getCompletionStyleGroup() {
5035         return getCompletionStyle(COMPLETION_STYLE_GROUP, DEFAULT_COMPLETION_STYLE_GROUP);
5036     }
5037 
5038     protected AttributedStyle getCompletionStyleSelection() {
5039         return getCompletionStyle(COMPLETION_STYLE_SELECTION, DEFAULT_COMPLETION_STYLE_SELECTION);
5040     }
5041 
5042     protected AttributedStyle getCompletionStyle(String name, String value) {
5043         return buildStyle(getString(name, value));
5044     }
5045 
5046     protected AttributedStyle buildStyle(String str) {
5047         return AttributedString.fromAnsi(&quot;\u001b[&quot; + str + &quot;m &quot;).styleAt(0);
5048     }
5049 
5050     private String getCommonStart(String str1, String str2, boolean caseInsensitive) {
5051         int[] s1 = str1.codePoints().toArray();
5052         int[] s2 = str2.codePoints().toArray();
5053         int len = 0;
5054         while (len &lt; Math.min(s1.length, s2.length)) {
5055             int ch1 = s1[len];
5056             int ch2 = s2[len];
5057             if (ch1 != ch2 &amp;&amp; caseInsensitive) {
5058                 ch1 = Character.toUpperCase(ch1);
5059                 ch2 = Character.toUpperCase(ch2);
5060                 if (ch1 != ch2) {
5061                     ch1 = Character.toLowerCase(ch1);
5062                     ch2 = Character.toLowerCase(ch2);
5063                 }
5064             }
5065             if (ch1 != ch2) {
5066                 break;
5067             }
5068             len++;
5069         }
5070         return new String(s1, 0, len);
5071     }
5072 
5073     /**
5074      * Used in &quot;vi&quot; mode for argumented history move, to move a specific
5075      * number of history entries forward or back.
5076      *
5077      * @param next If true, move forward
5078      * @param count The number of entries to move
5079      * @return true if the move was successful
5080      */
5081     protected boolean moveHistory(final boolean next, int count) {
5082         boolean ok = true;
5083         for (int i = 0; i &lt; count &amp;&amp; (ok = moveHistory(next)); i++) {
5084             /* empty */
5085         }
5086         return ok;
5087     }
5088 
5089     /**
5090      * Move up or down the history tree.
5091      * @param next &lt;code&gt;true&lt;/code&gt; to go to the next, &lt;code&gt;false&lt;/code&gt; for the previous.
5092      * @return &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise
5093      */
5094     protected boolean moveHistory(final boolean next) {
5095         if (!buf.toString().equals(history.current())) {
5096             modifiedHistory.put(history.index(), buf.toString());
5097         }
5098         if (next &amp;&amp; !history.next()) {
5099             return false;
5100         }
5101         else if (!next &amp;&amp; !history.previous()) {
5102             return false;
5103         }
5104 
5105         setBuffer(modifiedHistory.containsKey(history.index())
5106                     ? modifiedHistory.get(history.index())
5107                     : history.current());
5108 
5109         return true;
5110     }
5111 
5112     //
5113     // Printing
5114     //
5115 
5116     /**
5117      * Raw output printing.
5118      * @param str the string to print to the terminal
5119      */
5120     void print(String str) {
5121         terminal.writer().write(str);
5122     }
5123 
5124     void println(String s) {
5125         print(s);
5126         println();
5127     }
5128 
5129     /**
5130      * Output a platform-dependant newline.
5131      */
5132     void println() {
5133         terminal.puts(Capability.carriage_return);
5134         print(&quot;\n&quot;);
5135         redrawLine();
5136     }
5137 
5138 
5139     //
5140     // Actions
5141     //
5142 
5143     protected boolean killBuffer() {
5144         killRing.add(buf.toString());
5145         buf.clear();
5146         return true;
5147     }
5148 
5149     protected boolean killWholeLine() {
5150         if (buf.length() == 0) {
5151             return false;
5152         }
5153         int start;
5154         int end;
5155         if (count &lt; 0) {
5156             end = buf.cursor();
5157             while (buf.atChar(end) != 0 &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
5158                 end++;
5159             }
5160             start = end;
5161             for (int count = -this.count; count &gt; 0; --count) {
5162                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5163                     start--;
5164                 }
5165                 start--;
5166             }
5167         } else {
5168             start = buf.cursor();
5169             while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5170                 start--;
5171             }
5172             end = start;
5173             while (count-- &gt; 0) {
5174                 while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
5175                     end++;
5176                 }
5177                 if (end &lt; buf.length()) {
5178                     end++;
5179                 }
5180             }
5181         }
5182         String killed = buf.substring(start, end);
5183         buf.cursor(start);
5184         buf.delete(end - start);
5185         killRing.add(killed);
5186         return true;
5187     }
5188 
5189     /**
5190      * Kill the buffer ahead of the current cursor position.
5191      *
5192      * @return true if successful
5193      */
5194     public boolean killLine() {
5195         if (count &lt; 0) {
5196             return callNeg(this::backwardKillLine);
5197         }
5198         if (buf.cursor() == buf.length()) {
5199             return false;
5200         }
5201         int cp = buf.cursor();
5202         int len = cp;
5203         while (count-- &gt; 0) {
5204             if (buf.atChar(len) == &#39;\n&#39;) {
5205                 len++;
5206             } else {
5207                 while (buf.atChar(len) != 0 &amp;&amp; buf.atChar(len) != &#39;\n&#39;) {
5208                     len++;
5209                 }
5210             }
5211         }
5212         int num = len - cp;
5213         String killed = buf.substring(cp, cp + num);
5214         buf.delete(num);
5215         killRing.add(killed);
5216         return true;
5217     }
5218 
5219     public boolean backwardKillLine() {
5220         if (count &lt; 0) {
5221             return callNeg(this::killLine);
5222         }
5223         if (buf.cursor() == 0) {
5224             return false;
5225         }
5226         int cp = buf.cursor();
5227         int beg = cp;
5228         while (count-- &gt; 0) {
5229             if (beg == 0) {
5230                 break;
5231             }
5232             if (buf.atChar(beg - 1) == &#39;\n&#39;) {
5233                 beg--;
5234             } else {
5235                 while (beg &gt; 0 &amp;&amp; buf.atChar(beg - 1) != 0 &amp;&amp; buf.atChar(beg - 1) != &#39;\n&#39;) {
5236                     beg--;
5237                 }
5238             }
5239         }
5240         int num = cp - beg;
5241         String killed = buf.substring(cp - beg, cp);
5242         buf.cursor(beg);
5243         buf.delete(num);
5244         killRing.add(killed);
5245         return true;
5246     }
5247 
5248     public boolean killRegion() {
5249         return doCopyKillRegion(true);
5250     }
5251 
5252     public boolean copyRegionAsKill() {
5253         return doCopyKillRegion(false);
5254     }
5255 
5256     private boolean doCopyKillRegion(boolean kill) {
5257         if (regionMark &gt; buf.length()) {
5258             regionMark = buf.length();
5259         }
5260         if (regionActive == RegionType.LINE) {
5261             int start = regionMark;
5262             int end = buf.cursor();
5263             if (start &lt; end) {
5264                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5265                     start--;
5266                 }
5267                 while (end &lt; buf.length() - 1 &amp;&amp; buf.atChar(end + 1) != &#39;\n&#39;) {
5268                     end++;
5269                 }
5270                 if (isInViCmdMode()) {
5271                     end++;
5272                 }
5273                 killRing.add(buf.substring(start, end));
5274                 if (kill) {
5275                     buf.backspace(end - start);
5276                 }
5277             } else {
5278                 while (end &gt; 0 &amp;&amp; buf.atChar(end - 1) != &#39;\n&#39;) {
5279                     end--;
5280                 }
5281                 while (start &lt; buf.length() &amp;&amp; buf.atChar(start) != &#39;\n&#39;) {
5282                     start++;
5283                 }
5284                 if (isInViCmdMode()) {
5285                     start++;
5286                 }
5287                 killRing.addBackwards(buf.substring(end, start));
5288                 if (kill) {
5289                     buf.cursor(end);
5290                     buf.delete(start - end);
5291                 }
5292             }
5293         } else if (regionMark &gt; buf.cursor()) {
5294             if (isInViCmdMode()) {
5295                 regionMark++;
5296             }
5297             killRing.add(buf.substring(buf.cursor(), regionMark));
5298             if (kill) {
5299                 buf.delete(regionMark - buf.cursor());
5300             }
5301         } else {
5302             if (isInViCmdMode()) {
5303                 buf.move(1);
5304             }
5305             killRing.add(buf.substring(regionMark, buf.cursor()));
5306             if (kill) {
5307                 buf.backspace(buf.cursor() - regionMark);
5308             }
5309         }
5310         if (kill) {
5311             regionActive = RegionType.NONE;
5312         }
5313         return true;
5314     }
5315 
5316     public boolean yank() {
5317         String yanked = killRing.yank();
5318         if (yanked == null) {
5319             return false;
5320         } else {
5321             putString(yanked);
5322             return true;
5323         }
5324     }
5325 
5326     public boolean yankPop() {
5327         if (!killRing.lastYank()) {
5328             return false;
5329         }
5330         String current = killRing.yank();
5331         if (current == null) {
5332             // This shouldn&#39;t happen.
5333             return false;
5334         }
5335         buf.backspace(current.length());
5336         String yanked = killRing.yankPop();
5337         if (yanked == null) {
5338             // This shouldn&#39;t happen.
5339             return false;
5340         }
5341 
5342         putString(yanked);
5343         return true;
5344     }
5345 
5346     public boolean mouse() {
5347         MouseEvent event = readMouseEvent();
5348         if (event.getType() == MouseEvent.Type.Released
5349                 &amp;&amp; event.getButton() == MouseEvent.Button.Button1) {
5350             StringBuilder tsb = new StringBuilder();
5351             Cursor cursor = terminal.getCursorPosition(c -&gt; tsb.append((char) c));
5352             bindingReader.runMacro(tsb.toString());
5353 
5354             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
5355             getDisplayedBufferWithPrompts(secondaryPrompts);
5356 
5357             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
5358             sb.append(prompt);
5359             sb.append(insertSecondaryPrompts(new AttributedString(buf.upToCursor()), secondaryPrompts, false));
5360             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
5361 
5362             int currentLine = promptLines.size() - 1;
5363             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5364             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5365             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5366             int adjust = pl1 - pl0;
5367             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5368         }
5369         return true;
5370     }
5371 
5372     public boolean beginPaste() {
5373         final Object SELF_INSERT = new Object();
5374         final Object END_PASTE = new Object();
5375         KeyMap&lt;Object&gt; keyMap = new KeyMap&lt;&gt;();
5376         keyMap.setUnicode(SELF_INSERT);
5377         keyMap.setNomatch(SELF_INSERT);
5378         keyMap.setAmbiguousTimeout(0);
5379         keyMap.bind(END_PASTE, BRACKETED_PASTE_END);
5380         StringBuilder sb = new StringBuilder();
5381         while (true) {
5382             Object b = doReadBinding(keyMap, null);
5383             if (b == END_PASTE) {
5384                 break;
5385             }
5386             String s = getLastBinding();
5387             if (&quot;\r&quot;.equals(s)) {
5388                 s = &quot;\n&quot;;
5389             }
5390             sb.append(s);
5391         }
5392         regionActive = RegionType.PASTE;
5393         regionMark = getBuffer().cursor();
5394         getBuffer().write(sb);
5395         return true;
5396     }
5397 
5398     public boolean focusIn() {
5399         return false;
5400     }
5401 
5402     public boolean focusOut() {
5403         return false;
5404     }
5405 
5406     /**
5407      * Clean the used display
5408      * @return &lt;code&gt;true&lt;/code&gt;
5409      */
5410     public boolean clear() {
5411         display.update(Collections.emptyList(), 0);
5412         return true;
5413     }
5414 
5415     /**
5416      * Clear the screen by issuing the ANSI &quot;clear screen&quot; code.
5417      * @return &lt;code&gt;true&lt;/code&gt;
5418      */
5419     public boolean clearScreen() {
5420         if (terminal.puts(Capability.clear_screen)) {
5421             // ConEMU extended fonts support
5422             if (AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType())
5423                     &amp;&amp; !Boolean.getBoolean(&quot;org.jline.terminal.conemu.disable-activate&quot;)) {
5424                 terminal.writer().write(&quot;\u001b[9999E&quot;);
5425             }
5426             Status status = Status.getStatus(terminal, false);
5427             if (status != null) {
5428                 status.reset();
5429             }
5430             redrawLine();
5431         } else {
5432             println();
5433         }
5434         return true;
5435     }
5436 
5437     /**
5438      * Issue an audible keyboard bell.
5439      * @return &lt;code&gt;true&lt;/code&gt;
5440      */
5441     public boolean beep() {
5442         BellType bell_preference = BellType.AUDIBLE;
5443         switch (getString(BELL_STYLE, DEFAULT_BELL_STYLE).toLowerCase()) {
5444             case &quot;none&quot;:
5445             case &quot;off&quot;:
5446                 bell_preference = BellType.NONE;
5447                 break;
5448             case &quot;audible&quot;:
5449                 bell_preference = BellType.AUDIBLE;
5450                 break;
5451             case &quot;visible&quot;:
5452                 bell_preference = BellType.VISIBLE;
5453                 break;
5454             case &quot;on&quot;:
5455                 bell_preference = getBoolean(PREFER_VISIBLE_BELL, false)
5456                         ? BellType.VISIBLE : BellType.AUDIBLE;
5457                 break;
5458         }
5459         if (bell_preference == BellType.VISIBLE) {
5460             if (terminal.puts(Capability.flash_screen)
5461                     || terminal.puts(Capability.bell)) {
5462                 flush();
5463             }
5464         } else if (bell_preference == BellType.AUDIBLE) {
5465             if (terminal.puts(Capability.bell)) {
5466                 flush();
5467             }
5468         }
5469         return true;
5470     }
5471 
5472     //
5473     // Helpers
5474     //
5475 
5476     /**
5477      * Checks to see if the specified character is a delimiter. We consider a
5478      * character a delimiter if it is anything but a letter or digit.
5479      *
5480      * @param c     The character to test
5481      * @return      True if it is a delimiter
5482      */
5483     protected boolean isDelimiter(int c) {
5484         return !Character.isLetterOrDigit(c);
5485     }
5486 
5487     /**
5488      * Checks to see if a character is a whitespace character. Currently
5489      * this delegates to {@link Character#isWhitespace(char)}, however
5490      * eventually it should be hooked up so that the definition of whitespace
5491      * can be configured, as readline does.
5492      *
5493      * @param c The character to check
5494      * @return true if the character is a whitespace
5495      */
5496     protected boolean isWhitespace(int c) {
5497         return Character.isWhitespace(c);
5498     }
5499 
5500     protected boolean isViAlphaNum(int c) {
5501         return c == &#39;_&#39; || Character.isLetterOrDigit(c);
5502     }
5503 
5504     protected boolean isAlpha(int c) {
5505         return Character.isLetter(c);
5506     }
5507 
5508     protected boolean isWord(int c) {
5509         String wordchars = getString(WORDCHARS, DEFAULT_WORDCHARS);
5510         return Character.isLetterOrDigit(c)
5511                 || (c &lt; 128 &amp;&amp; wordchars.indexOf((char) c) &gt;= 0);
5512     }
5513 
5514     String getString(String name, String def) {
5515         return ReaderUtils.getString(this, name, def);
5516     }
5517 
5518     boolean getBoolean(String name, boolean def) {
5519         return ReaderUtils.getBoolean(this, name, def);
5520     }
5521 
5522     int getInt(String name, int def) {
5523         return ReaderUtils.getInt(this, name, def);
5524     }
5525 
5526     long getLong(String name, long def) {
5527         return ReaderUtils.getLong(this, name, def);
5528     }
5529 
5530     @Override
5531     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; defaultKeyMaps() {
5532         Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps = new HashMap&lt;&gt;();
5533         keyMaps.put(EMACS, emacs());
5534         keyMaps.put(VICMD, viCmd());
5535         keyMaps.put(VIINS, viInsertion());
5536         keyMaps.put(MENU, menu());
5537         keyMaps.put(VIOPP, viOpp());
5538         keyMaps.put(VISUAL, visual());
5539         keyMaps.put(SAFE, safe());
5540         if (getBoolean(BIND_TTY_SPECIAL_CHARS, true)) {
5541             Attributes attr = terminal.getAttributes();
5542             bindConsoleChars(keyMaps.get(EMACS), attr);
5543             bindConsoleChars(keyMaps.get(VIINS), attr);
5544         }
5545         // Put default
5546         for (KeyMap&lt;Binding&gt; keyMap : keyMaps.values()) {
5547             keyMap.setUnicode(new Reference(SELF_INSERT));
5548             keyMap.setAmbiguousTimeout(getLong(AMBIGUOUS_BINDING, DEFAULT_AMBIGUOUS_BINDING));
5549         }
5550         // By default, link main to emacs
5551         keyMaps.put(MAIN, keyMaps.get(EMACS));
5552         return keyMaps;
5553     }
5554 
5555     public KeyMap&lt;Binding&gt; emacs() {
5556         KeyMap&lt;Binding&gt; emacs = new KeyMap&lt;&gt;();
5557         bindKeys(emacs);
5558         bind(emacs, SET_MARK_COMMAND,                       ctrl(&#39;@&#39;));
5559         bind(emacs, BEGINNING_OF_LINE,                      ctrl(&#39;A&#39;));
5560         bind(emacs, BACKWARD_CHAR,                          ctrl(&#39;B&#39;));
5561         bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl(&#39;D&#39;));
5562         bind(emacs, END_OF_LINE,                            ctrl(&#39;E&#39;));
5563         bind(emacs, FORWARD_CHAR,                           ctrl(&#39;F&#39;));
5564         bind(emacs, SEND_BREAK,                             ctrl(&#39;G&#39;));
5565         bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5566         bind(emacs, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5567         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5568         bind(emacs, KILL_LINE,                              ctrl(&#39;K&#39;));
5569         bind(emacs, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5570         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5571         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
5572         bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl(&#39;O&#39;));
5573         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5574         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5575         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5576         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5577         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5578         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5579         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5580         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5581         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5582         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5583         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5584         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5585         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5586         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5587         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5588         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5589         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));
5590         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5591         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5592         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
5593         bind(emacs, INFER_NEXT_HISTORY,                     translate(&quot;^X^N&quot;));
5594         bind(emacs, OVERWRITE_MODE,                         translate(&quot;^X^O&quot;));
5595         bind(emacs, REDO,                                   translate(&quot;^X^R&quot;));
5596         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5597         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5598         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5599         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5600         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5601         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5602         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5603         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5604         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5605         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5606         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5607         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5608         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5609         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
5610         bind(emacs, DIGIT_ARGUMENT,                         range(&quot;\\E0-\\E9&quot;));
5611         bind(emacs, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5612         bind(emacs, LIST_CHOICES,                           alt(&#39;=&#39;));
5613         bind(emacs, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5614         bind(emacs, LIST_CHOICES,                           alt(&#39;?&#39;));
5615         bind(emacs, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
5616         bind(emacs, ACCEPT_AND_HOLD,                        alt(&#39;a&#39;));
5617         bind(emacs, BACKWARD_WORD,                          alt(&#39;b&#39;));
5618         bind(emacs, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5619         bind(emacs, KILL_WORD,                              alt(&#39;d&#39;));
5620         bind(emacs, KILL_WORD,                              translate(&quot;^[[3;5~&quot;)); // ctrl-delete
5621         bind(emacs, FORWARD_WORD,                           alt(&#39;f&#39;));
5622         bind(emacs, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5623         bind(emacs, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5624         bind(emacs, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5625         bind(emacs, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5626         bind(emacs, UP_CASE_WORD,                           alt(&#39;u&#39;));
5627         bind(emacs, YANK_POP,                               alt(&#39;y&#39;));
5628         bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));
5629         bindArrowKeys(emacs);
5630         bind(emacs, FORWARD_WORD,                           translate(&quot;^[[1;5C&quot;)); // ctrl-left
5631         bind(emacs, BACKWARD_WORD,                          translate(&quot;^[[1;5D&quot;)); // ctrl-right
5632         bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));
5633         bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));
5634         bind(emacs, FORWARD_WORD,                           alt(translate(&quot;^[[C&quot;)));
5635         bind(emacs, BACKWARD_WORD,                          alt(translate(&quot;^[[D&quot;)));
5636         return emacs;
5637     }
5638 
5639     public KeyMap&lt;Binding&gt; viInsertion() {
5640         KeyMap&lt;Binding&gt; viins = new KeyMap&lt;&gt;();
5641         bindKeys(viins);
5642         bind(viins, SELF_INSERT,                            range(&quot;^@-^_&quot;));
5643         bind(viins, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5644         bind(viins, SEND_BREAK,                             ctrl(&#39;G&#39;));
5645         bind(viins, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5646         bind(viins, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5647         bind(viins, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5648         bind(viins, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5649         bind(viins, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5650         bind(viins, MENU_COMPLETE,                          ctrl(&#39;N&#39;));
5651         bind(viins, REVERSE_MENU_COMPLETE,                  ctrl(&#39;P&#39;));
5652         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5653         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5654         bind(viins, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5655         bind(viins, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5656         bind(viins, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5657         bind(viins, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5658         bind(viins, YANK,                                   ctrl(&#39;Y&#39;));
5659         bind(viins, VI_CMD_MODE,                            ctrl(&#39;[&#39;));
5660         bind(viins, UNDO,                                   ctrl(&#39;_&#39;));
5661         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
5662         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;X&#39;) + &quot;s&quot;);
5663         bind(viins, SELF_INSERT,                            range(&quot; -~&quot;));
5664         bind(viins, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5665         bind(viins, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5666         bind(viins, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5667         bind(viins, BACKWARD_DELETE_CHAR,                   del());
5668         bindArrowKeys(viins);
5669         return viins;
5670     }
5671 
5672     public KeyMap&lt;Binding&gt; viCmd() {
5673         KeyMap&lt;Binding&gt; vicmd = new KeyMap&lt;&gt;();
5674         bind(vicmd, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5675         bind(vicmd, EMACS_EDITING_MODE,                     ctrl(&#39;E&#39;));
5676         bind(vicmd, SEND_BREAK,                             ctrl(&#39;G&#39;));
5677         bind(vicmd, VI_BACKWARD_CHAR,                       ctrl(&#39;H&#39;));
5678         bind(vicmd, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5679         bind(vicmd, KILL_LINE,                              ctrl(&#39;K&#39;));
5680         bind(vicmd, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5681         bind(vicmd, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5682         bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                ctrl(&#39;N&#39;));
5683         bind(vicmd, VI_UP_LINE_OR_HISTORY,                  ctrl(&#39;P&#39;));
5684         bind(vicmd, QUOTED_INSERT,                          ctrl(&#39;Q&#39;));
5685         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5686         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5687         bind(vicmd, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5688         bind(vicmd, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5689         bind(vicmd, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5690         bind(vicmd, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5691         bind(vicmd, YANK,                                   ctrl(&#39;Y&#39;));
5692         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
5693         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;X&#39;) + &quot;s&quot;);
5694         bind(vicmd, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5695         bind(vicmd, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5696         bind(vicmd, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5697         bind(vicmd, COMPLETE_WORD,                          alt(esc()));
5698         bind(vicmd, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5699         bind(vicmd, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5700 //        bind(vicmd, INSERT_COMMENT,                         alt(&#39;#&#39;));
5701 //        bind(vicmd, INSERT_COMPLETIONS,                     alt(&#39;*&#39;));
5702         bind(vicmd, DIGIT_ARGUMENT,                         alt(&#39;-&#39;));
5703         bind(vicmd, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5704         bind(vicmd, LIST_CHOICES,                           alt(&#39;=&#39;));
5705         bind(vicmd, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5706         bind(vicmd, LIST_CHOICES,                           alt(&#39;?&#39;));
5707         bind(vicmd, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
5708         bind(vicmd, BACKWARD_WORD,                          alt(&#39;b&#39;));
5709         bind(vicmd, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5710         bind(vicmd, KILL_WORD,                              alt(&#39;d&#39;));
5711         bind(vicmd, FORWARD_WORD,                           alt(&#39;f&#39;));
5712         bind(vicmd, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5713         bind(vicmd, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5714         bind(vicmd, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5715         bind(vicmd, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5716         bind(vicmd, UP_CASE_WORD,                           alt(&#39;u&#39;));
5717         bind(vicmd, YANK_POP,                               alt(&#39;y&#39;));
5718         bind(vicmd, BACKWARD_KILL_WORD,                     alt(del()));
5719 
5720         bind(vicmd, FORWARD_CHAR,                           &quot; &quot;);
5721         bind(vicmd, VI_INSERT_COMMENT,                      &quot;#&quot;);
5722         bind(vicmd, END_OF_LINE,                            &quot;$&quot;);
5723         bind(vicmd, VI_MATCH_BRACKET,                       &quot;%&quot;);
5724         bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                &quot;+&quot;);
5725         bind(vicmd, VI_REV_REPEAT_FIND,                     &quot;,&quot;);
5726         bind(vicmd, VI_UP_LINE_OR_HISTORY,                  &quot;-&quot;);
5727         bind(vicmd, VI_REPEAT_CHANGE,                       &quot;.&quot;);
5728         bind(vicmd, VI_HISTORY_SEARCH_BACKWARD,             &quot;/&quot;);
5729         bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE,          &quot;0&quot;);
5730         bind(vicmd, DIGIT_ARGUMENT,                         range(&quot;1-9&quot;));
5731         bind(vicmd, VI_REPEAT_FIND,                         &quot;;&quot;);
5732         bind(vicmd, LIST_CHOICES,                           &quot;=&quot;);
5733         bind(vicmd, VI_HISTORY_SEARCH_FORWARD,              &quot;?&quot;);
5734         bind(vicmd, VI_ADD_EOL,                             &quot;A&quot;);
5735         bind(vicmd, VI_BACKWARD_BLANK_WORD,                 &quot;B&quot;);
5736         bind(vicmd, VI_CHANGE_EOL,                          &quot;C&quot;);
5737         bind(vicmd, VI_KILL_EOL,                            &quot;D&quot;);
5738         bind(vicmd, VI_FORWARD_BLANK_WORD_END,              &quot;E&quot;);
5739         bind(vicmd, VI_FIND_PREV_CHAR,                      &quot;F&quot;);
5740         bind(vicmd, VI_FETCH_HISTORY,                       &quot;G&quot;);
5741         bind(vicmd, VI_INSERT_BOL,                          &quot;I&quot;);
5742         bind(vicmd, VI_JOIN,                                &quot;J&quot;);
5743         bind(vicmd, VI_REV_REPEAT_SEARCH,                   &quot;N&quot;);
5744         bind(vicmd, VI_OPEN_LINE_ABOVE,                     &quot;O&quot;);
5745         bind(vicmd, VI_PUT_BEFORE,                          &quot;P&quot;);
5746         bind(vicmd, VI_REPLACE,                             &quot;R&quot;);
5747         bind(vicmd, VI_KILL_LINE,                           &quot;S&quot;);
5748         bind(vicmd, VI_FIND_PREV_CHAR_SKIP,                 &quot;T&quot;);
5749         bind(vicmd, REDO,                                   &quot;U&quot;);
5750         bind(vicmd, VISUAL_LINE_MODE,                       &quot;V&quot;);
5751         bind(vicmd, VI_FORWARD_BLANK_WORD,                  &quot;W&quot;);
5752         bind(vicmd, VI_BACKWARD_DELETE_CHAR,                &quot;X&quot;);
5753         bind(vicmd, VI_YANK_WHOLE_LINE,                     &quot;Y&quot;);
5754         bind(vicmd, VI_FIRST_NON_BLANK,                     &quot;^&quot;);
5755         bind(vicmd, VI_ADD_NEXT,                            &quot;a&quot;);
5756         bind(vicmd, VI_BACKWARD_WORD,                       &quot;b&quot;);
5757         bind(vicmd, VI_CHANGE,                              &quot;c&quot;);
5758         bind(vicmd, VI_DELETE,                              &quot;d&quot;);
5759         bind(vicmd, VI_FORWARD_WORD_END,                    &quot;e&quot;);
5760         bind(vicmd, VI_FIND_NEXT_CHAR,                      &quot;f&quot;);
5761         bind(vicmd, WHAT_CURSOR_POSITION,                   &quot;ga&quot;);
5762         bind(vicmd, VI_BACKWARD_BLANK_WORD_END,             &quot;gE&quot;);
5763         bind(vicmd, VI_BACKWARD_WORD_END,                   &quot;ge&quot;);
5764         bind(vicmd, VI_BACKWARD_CHAR,                       &quot;h&quot;);
5765         bind(vicmd, VI_INSERT,                              &quot;i&quot;);
5766         bind(vicmd, DOWN_LINE_OR_HISTORY,                   &quot;j&quot;);
5767         bind(vicmd, UP_LINE_OR_HISTORY,                     &quot;k&quot;);
5768         bind(vicmd, VI_FORWARD_CHAR,                        &quot;l&quot;);
5769         bind(vicmd, VI_REPEAT_SEARCH,                       &quot;n&quot;);
5770         bind(vicmd, VI_OPEN_LINE_BELOW,                     &quot;o&quot;);
5771         bind(vicmd, VI_PUT_AFTER,                           &quot;p&quot;);
5772         bind(vicmd, VI_REPLACE_CHARS,                       &quot;r&quot;);
5773         bind(vicmd, VI_SUBSTITUTE,                          &quot;s&quot;);
5774         bind(vicmd, VI_FIND_NEXT_CHAR_SKIP,                 &quot;t&quot;);
5775         bind(vicmd, UNDO,                                   &quot;u&quot;);
5776         bind(vicmd, VISUAL_MODE,                            &quot;v&quot;);
5777         bind(vicmd, VI_FORWARD_WORD,                        &quot;w&quot;);
5778         bind(vicmd, VI_DELETE_CHAR,                         &quot;x&quot;);
5779         bind(vicmd, VI_YANK,                                &quot;y&quot;);
5780         bind(vicmd, VI_GOTO_COLUMN,                         &quot;|&quot;);
5781         bind(vicmd, VI_SWAP_CASE,                           &quot;~&quot;);
5782         bind(vicmd, VI_BACKWARD_CHAR,                       del());
5783 
5784         bindArrowKeys(vicmd);
5785         return vicmd;
5786     }
5787 
5788     public KeyMap&lt;Binding&gt; menu() {
5789         KeyMap&lt;Binding&gt; menu = new KeyMap&lt;&gt;();
5790         bind(menu, MENU_COMPLETE,                     &quot;\t&quot;);
5791         bind(menu, REVERSE_MENU_COMPLETE,             key(Capability.back_tab));
5792         bind(menu, ACCEPT_LINE,                       &quot;\r&quot;, &quot;\n&quot;);
5793         bindArrowKeys(menu);
5794         return menu;
5795     }
5796 
5797     public KeyMap&lt;Binding&gt; safe() {
5798         KeyMap&lt;Binding&gt; safe = new KeyMap&lt;&gt;();
5799         bind(safe, SELF_INSERT,                 range(&quot;^@-^?&quot;));
5800         bind(safe, ACCEPT_LINE,                 &quot;\r&quot;, &quot;\n&quot;);
5801         bind(safe, SEND_BREAK,                  ctrl(&#39;G&#39;));
5802         return safe;
5803     }
5804 
5805     public KeyMap&lt;Binding&gt; visual() {
5806         KeyMap&lt;Binding&gt; visual = new KeyMap&lt;&gt;();
5807         bind(visual, UP_LINE,                   key(Capability.key_up),     &quot;k&quot;);
5808         bind(visual, DOWN_LINE,                 key(Capability.key_down),   &quot;j&quot;);
5809         bind(visual, this::deactivateRegion,    esc());
5810         bind(visual, EXCHANGE_POINT_AND_MARK,   &quot;o&quot;);
5811         bind(visual, PUT_REPLACE_SELECTION,     &quot;p&quot;);
5812         bind(visual, VI_DELETE,                 &quot;x&quot;);
5813         bind(visual, VI_OPER_SWAP_CASE,         &quot;~&quot;);
5814         return visual;
5815     }
5816 
5817     public KeyMap&lt;Binding&gt; viOpp() {
5818         KeyMap&lt;Binding&gt; viOpp = new KeyMap&lt;&gt;();
5819         bind(viOpp, UP_LINE,                    key(Capability.key_up),     &quot;k&quot;);
5820         bind(viOpp, DOWN_LINE,                  key(Capability.key_down),   &quot;j&quot;);
5821         bind(viOpp, VI_CMD_MODE,                esc());
5822         return viOpp;
5823     }
5824 
5825     private void bind(KeyMap&lt;Binding&gt; map, String widget, Iterable&lt;? extends CharSequence&gt; keySeqs) {
5826         map.bind(new Reference(widget), keySeqs);
5827     }
5828 
5829     private void bind(KeyMap&lt;Binding&gt; map, String widget, CharSequence... keySeqs) {
5830         map.bind(new Reference(widget), keySeqs);
5831     }
5832 
5833     private void bind(KeyMap&lt;Binding&gt; map, Widget widget, CharSequence... keySeqs) {
5834         map.bind(widget, keySeqs);
5835     }
5836 
5837     private String key(Capability capability) {
5838         return KeyMap.key(terminal, capability);
5839     }
5840 
5841     private void bindKeys(KeyMap&lt;Binding&gt; emacs) {
5842         Widget beep = namedWidget(&quot;beep&quot;, this::beep);
5843         Stream.of(Capability.values())
5844                 .filter(c -&gt; c.name().startsWith(&quot;key_&quot;))
5845                 .map(this::key)
5846                 .forEach(k -&gt; bind(emacs, beep, k));
5847     }
5848 
5849     private void bindArrowKeys(KeyMap&lt;Binding&gt; map) {
5850         bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));
5851         bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));
5852         bind(map, BACKWARD_CHAR,        key(Capability.key_left));
5853         bind(map, FORWARD_CHAR,         key(Capability.key_right));
5854         bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));
5855         bind(map, END_OF_LINE,          key(Capability.key_end));
5856         bind(map, DELETE_CHAR,          key(Capability.key_dc));
5857         bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));
5858         bind(map, OVERWRITE_MODE,       key(Capability.key_ic));
5859         bind(map, MOUSE,                key(Capability.key_mouse));
5860         bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);
5861         bind(map, FOCUS_IN,             FOCUS_IN_SEQ);
5862         bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);
5863     }
5864 
5865     /**
5866      * Bind special chars defined by the terminal instead of
5867      * the default bindings
5868      */
5869     private void bindConsoleChars(KeyMap&lt;Binding&gt; keyMap, Attributes attr) {
5870         if (attr != null) {
5871             rebind(keyMap, BACKWARD_DELETE_CHAR,
5872                     del(), (char) attr.getControlChar(ControlChar.VERASE));
5873             rebind(keyMap, BACKWARD_KILL_WORD,
5874                     ctrl(&#39;W&#39;),  (char) attr.getControlChar(ControlChar.VWERASE));
5875             rebind(keyMap, KILL_WHOLE_LINE,
5876                     ctrl(&#39;U&#39;), (char) attr.getControlChar(ControlChar.VKILL));
5877             rebind(keyMap, QUOTED_INSERT,
5878                     ctrl(&#39;V&#39;), (char) attr.getControlChar(ControlChar.VLNEXT));
5879         }
5880     }
5881 
5882     private void rebind(KeyMap&lt;Binding&gt; keyMap, String operation, String prevBinding, char newBinding) {
5883         if (newBinding &gt; 0 &amp;&amp; newBinding &lt; 128) {
5884             Reference ref = new Reference(operation);
5885             bind(keyMap, SELF_INSERT, prevBinding);
5886             keyMap.bind(ref, Character.toString(newBinding));
5887         }
5888     }
5889 
5890 
5891 }
    </pre>
  </body>
</html>
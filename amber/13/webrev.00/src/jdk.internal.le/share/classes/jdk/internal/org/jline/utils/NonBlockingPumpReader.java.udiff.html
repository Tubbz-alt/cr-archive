<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/NonBlockingPumpReader.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="NonBlockingInputStream.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NonBlockingReader.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/NonBlockingPumpReader.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -9,134 +9,184 @@</span>
  package jdk.internal.org.jline.utils;
  
  import java.io.IOException;
  import java.io.InterruptedIOException;
  import java.io.Writer;
<span class="udiff-line-modified-removed">- import java.nio.CharBuffer;</span>
<span class="udiff-line-modified-added">+ import java.util.concurrent.TimeUnit;</span>
<span class="udiff-line-added">+ import java.util.concurrent.locks.Condition;</span>
<span class="udiff-line-added">+ import java.util.concurrent.locks.ReentrantLock;</span>
  
  public class NonBlockingPumpReader extends NonBlockingReader {
  
      private static final int DEFAULT_BUFFER_SIZE = 4096;
  
<span class="udiff-line-modified-removed">-     // Read and write buffer are backed by the same array</span>
<span class="udiff-line-modified-removed">-     private final CharBuffer readBuffer;</span>
<span class="udiff-line-modified-removed">-     private final CharBuffer writeBuffer;</span>
<span class="udiff-line-modified-added">+     private final char[] buffer;</span>
<span class="udiff-line-modified-added">+     private int read;</span>
<span class="udiff-line-modified-added">+     private int write;</span>
<span class="udiff-line-added">+     private int count;</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+     /** Main lock guarding all access */</span>
<span class="udiff-line-added">+     final ReentrantLock lock;</span>
<span class="udiff-line-added">+     /** Condition for waiting takes */</span>
<span class="udiff-line-added">+     private final Condition notEmpty;</span>
<span class="udiff-line-added">+     /** Condition for waiting puts */</span>
<span class="udiff-line-added">+     private final Condition notFull;</span>
  
      private final Writer writer;
  
      private boolean closed;
  
      public NonBlockingPumpReader() {
          this(DEFAULT_BUFFER_SIZE);
      }
  
      public NonBlockingPumpReader(int bufferSize) {
<span class="udiff-line-modified-removed">-         char[] buf = new char[bufferSize];</span>
<span class="udiff-line-removed">-         this.readBuffer = CharBuffer.wrap(buf);</span>
<span class="udiff-line-removed">-         this.writeBuffer = CharBuffer.wrap(buf);</span>
<span class="udiff-line-modified-added">+         this.buffer = new char[bufferSize];</span>
          this.writer = new NbpWriter();
<span class="udiff-line-modified-removed">-         // There are no bytes available to read after initialization</span>
<span class="udiff-line-modified-removed">-         readBuffer.limit(0);</span>
<span class="udiff-line-modified-added">+         this.lock = new ReentrantLock();</span>
<span class="udiff-line-modified-added">+         this.notEmpty = lock.newCondition();</span>
<span class="udiff-line-added">+         this.notFull = lock.newCondition();</span>
      }
  
      public Writer getWriter() {
          return this.writer;
      }
  
<span class="udiff-line-removed">-     private int wait(CharBuffer buffer, long timeout) throws InterruptedIOException {</span>
<span class="udiff-line-removed">-         boolean isInfinite = (timeout &lt;= 0L);</span>
<span class="udiff-line-removed">-         long end = 0;</span>
<span class="udiff-line-removed">-         if (!isInfinite) {</span>
<span class="udiff-line-removed">-             end = System.currentTimeMillis() + timeout;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         while (!closed &amp;&amp; !buffer.hasRemaining() &amp;&amp; (isInfinite || timeout &gt; 0L)) {</span>
<span class="udiff-line-removed">-             // Wake up waiting readers/writers</span>
<span class="udiff-line-removed">-             notifyAll();</span>
<span class="udiff-line-removed">-             try {</span>
<span class="udiff-line-removed">-                 wait(timeout);</span>
<span class="udiff-line-removed">-             } catch (InterruptedException e) {</span>
<span class="udiff-line-removed">-                 throw new InterruptedIOException();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-             if (!isInfinite) {</span>
<span class="udiff-line-removed">-                 timeout = end - System.currentTimeMillis();</span>
<span class="udiff-line-removed">-             }</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         return closed</span>
<span class="udiff-line-removed">-                 ? EOF</span>
<span class="udiff-line-removed">-                 : buffer.hasRemaining()</span>
<span class="udiff-line-removed">-                     ? 0</span>
<span class="udiff-line-removed">-                     : READ_EXPIRED;</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
<span class="udiff-line-removed">-     private static boolean rewind(CharBuffer buffer, CharBuffer other) {</span>
<span class="udiff-line-removed">-         // Extend limit of other buffer if there is additional input/output available</span>
<span class="udiff-line-removed">-         if (buffer.position() &gt; other.position()) {</span>
<span class="udiff-line-removed">-             other.limit(buffer.position());</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-         // If we have reached the end of the buffer, rewind and set the new limit</span>
<span class="udiff-line-removed">-         if (buffer.position() == buffer.capacity()) {</span>
<span class="udiff-line-removed">-             buffer.rewind();</span>
<span class="udiff-line-removed">-             buffer.limit(other.position());</span>
<span class="udiff-line-removed">-             return true;</span>
<span class="udiff-line-removed">-         } else {</span>
<span class="udiff-line-removed">-             return false;</span>
<span class="udiff-line-removed">-         }</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-removed">- </span>
      @Override
<span class="udiff-line-modified-removed">-     public synchronized boolean ready() {</span>
<span class="udiff-line-modified-removed">-         return readBuffer.hasRemaining();</span>
<span class="udiff-line-modified-added">+     public boolean ready() {</span>
<span class="udiff-line-modified-added">+         return available() &gt; 0;</span>
      }
  
<span class="udiff-line-modified-removed">-     public synchronized int available() {</span>
<span class="udiff-line-modified-removed">-         int count = readBuffer.remaining();</span>
<span class="udiff-line-modified-removed">-         if (writeBuffer.position() &lt; readBuffer.position()) {</span>
<span class="udiff-line-modified-removed">-             count += writeBuffer.position();</span>
<span class="udiff-line-modified-added">+     public int available() {</span>
<span class="udiff-line-modified-added">+         final ReentrantLock lock = this.lock;</span>
<span class="udiff-line-modified-added">+         lock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-added">+             return count;</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             lock.unlock();</span>
          }
<span class="udiff-line-removed">-         return count;</span>
      }
  
      @Override
<span class="udiff-line-modified-removed">-     protected synchronized int read(long timeout, boolean isPeek) throws IOException {</span>
<span class="udiff-line-modified-removed">-         // Blocks until more input is available or the reader is closed.</span>
<span class="udiff-line-modified-removed">-         int res = wait(readBuffer, timeout);</span>
<span class="udiff-line-modified-removed">-         if (res &gt;= 0) {</span>
<span class="udiff-line-modified-removed">-             res = isPeek ? readBuffer.get(readBuffer.position()) : readBuffer.get();</span>
<span class="udiff-line-modified-added">+     protected int read(long timeout, boolean isPeek) throws IOException {</span>
<span class="udiff-line-modified-added">+         final ReentrantLock lock = this.lock;</span>
<span class="udiff-line-modified-added">+         lock.lock();</span>
<span class="udiff-line-modified-added">+         try {</span>
<span class="udiff-line-modified-added">+             // Blocks until more input is available or the reader is closed.</span>
<span class="udiff-line-added">+             if (!closed &amp;&amp; count == 0) {</span>
<span class="udiff-line-added">+                 try {</span>
<span class="udiff-line-added">+                     notEmpty.await(timeout, TimeUnit.MILLISECONDS);</span>
<span class="udiff-line-added">+                 } catch (InterruptedException e) {</span>
<span class="udiff-line-added">+                     throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             if (closed) {</span>
<span class="udiff-line-added">+                 return EOF;</span>
<span class="udiff-line-added">+             } else if (count == 0) {</span>
<span class="udiff-line-added">+                 return READ_EXPIRED;</span>
<span class="udiff-line-added">+             } else {</span>
<span class="udiff-line-added">+                 if (isPeek) {</span>
<span class="udiff-line-added">+                     return buffer[read];</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     int res = buffer[read];</span>
<span class="udiff-line-added">+                     if (++read == buffer.length) {</span>
<span class="udiff-line-added">+                         read = 0;</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     --count;</span>
<span class="udiff-line-added">+                     notFull.signal();</span>
<span class="udiff-line-added">+                     return res;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             lock.unlock();</span>
          }
<span class="udiff-line-removed">-         rewind(readBuffer, writeBuffer);</span>
<span class="udiff-line-removed">-         return res;</span>
      }
  
<span class="udiff-line-modified-removed">-     synchronized void write(char[] cbuf, int off, int len) throws IOException {</span>
<span class="udiff-line-modified-removed">-         while (len &gt; 0) {</span>
<span class="udiff-line-modified-removed">-             // Blocks until there is new space available for buffering or the</span>
<span class="udiff-line-modified-removed">-             // reader is closed.</span>
<span class="udiff-line-modified-removed">-             if (wait(writeBuffer, 0L) == EOF) {</span>
<span class="udiff-line-modified-removed">-                 throw new ClosedException();</span>
<span class="udiff-line-modified-added">+     @Override</span>
<span class="udiff-line-modified-added">+     public int readBuffered(char[] b) throws IOException {</span>
<span class="udiff-line-modified-added">+         if (b == null) {</span>
<span class="udiff-line-modified-added">+             throw new NullPointerException();</span>
<span class="udiff-line-modified-added">+         } else if (b.length == 0) {</span>
<span class="udiff-line-modified-added">+             return 0;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             final ReentrantLock lock = this.lock;</span>
<span class="udiff-line-added">+             lock.lock();</span>
<span class="udiff-line-added">+             try {</span>
<span class="udiff-line-added">+                 if (!closed &amp;&amp; count == 0) {</span>
<span class="udiff-line-added">+                     try {</span>
<span class="udiff-line-added">+                         notEmpty.await();</span>
<span class="udiff-line-added">+                     } catch (InterruptedException e) {</span>
<span class="udiff-line-added">+                         throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+                 if (closed) {</span>
<span class="udiff-line-added">+                     return EOF;</span>
<span class="udiff-line-added">+                 } else if (count == 0) {</span>
<span class="udiff-line-added">+                     return READ_EXPIRED;</span>
<span class="udiff-line-added">+                 } else {</span>
<span class="udiff-line-added">+                     int r = Math.min(b.length, count);</span>
<span class="udiff-line-added">+                     for (int i = 0; i &lt; r; i++) {</span>
<span class="udiff-line-added">+                         b[i] = buffer[read++];</span>
<span class="udiff-line-added">+                         if (read == buffer.length) {</span>
<span class="udiff-line-added">+                             read = 0;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     count -= r;</span>
<span class="udiff-line-added">+                     notFull.signal();</span>
<span class="udiff-line-added">+                     return r;</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } finally {</span>
<span class="udiff-line-added">+                 lock.unlock();</span>
              }
<span class="udiff-line-removed">-             // Copy as much characters as we can</span>
<span class="udiff-line-removed">-             int count = Math.min(len, writeBuffer.remaining());</span>
<span class="udiff-line-removed">-             writeBuffer.put(cbuf, off, count);</span>
<span class="udiff-line-removed">-             off += count;</span>
<span class="udiff-line-removed">-             len -= count;</span>
<span class="udiff-line-removed">-             // Update buffer states and rewind if necessary</span>
<span class="udiff-line-removed">-             rewind(writeBuffer, readBuffer);</span>
          }
      }
  
<span class="udiff-line-modified-removed">-     synchronized void flush() {</span>
<span class="udiff-line-modified-removed">-         // Avoid waking up readers when there is nothing to read</span>
<span class="udiff-line-modified-removed">-         if (readBuffer.hasRemaining()) {</span>
<span class="udiff-line-modified-removed">-             // Notify readers</span>
<span class="udiff-line-modified-removed">-             notifyAll();</span>
<span class="udiff-line-modified-added">+     void write(char[] cbuf, int off, int len) throws IOException {</span>
<span class="udiff-line-modified-added">+         if (len &gt; 0) {</span>
<span class="udiff-line-modified-added">+             final ReentrantLock lock = this.lock;</span>
<span class="udiff-line-modified-added">+             lock.lock();</span>
<span class="udiff-line-modified-added">+             try {</span>
<span class="udiff-line-added">+                 while (len &gt; 0) {</span>
<span class="udiff-line-added">+                     // Blocks until there is new space available for buffering or the</span>
<span class="udiff-line-added">+                     // reader is closed.</span>
<span class="udiff-line-added">+                     if (!closed &amp;&amp; count == buffer.length) {</span>
<span class="udiff-line-added">+                         try {</span>
<span class="udiff-line-added">+                             notFull.await();</span>
<span class="udiff-line-added">+                         } catch (InterruptedException e) {</span>
<span class="udiff-line-added">+                             throw (IOException) new InterruptedIOException().initCause(e);</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     if (closed) {</span>
<span class="udiff-line-added">+                         throw new IOException(&quot;Closed&quot;);</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     while (len &gt; 0 &amp;&amp; count &lt; buffer.length) {</span>
<span class="udiff-line-added">+                         buffer[write++] = cbuf[off++];</span>
<span class="udiff-line-added">+                         count++;</span>
<span class="udiff-line-added">+                         len--;</span>
<span class="udiff-line-added">+                         if (write == buffer.length) {</span>
<span class="udiff-line-added">+                             write = 0;</span>
<span class="udiff-line-added">+                         }</span>
<span class="udiff-line-added">+                     }</span>
<span class="udiff-line-added">+                     notEmpty.signal();</span>
<span class="udiff-line-added">+                 }</span>
<span class="udiff-line-added">+             } finally {</span>
<span class="udiff-line-added">+                 lock.unlock();</span>
<span class="udiff-line-added">+             }</span>
          }
      }
  
      @Override
<span class="udiff-line-modified-removed">-     public synchronized void close() throws IOException {</span>
<span class="udiff-line-modified-removed">-         this.closed = true;</span>
<span class="udiff-line-modified-removed">-         notifyAll();</span>
<span class="udiff-line-modified-added">+     public void close() throws IOException {</span>
<span class="udiff-line-modified-added">+         final ReentrantLock lock = this.lock;</span>
<span class="udiff-line-modified-added">+         lock.lock();</span>
<span class="udiff-line-added">+         try {</span>
<span class="udiff-line-added">+             this.closed = true;</span>
<span class="udiff-line-added">+             this.notEmpty.signalAll();</span>
<span class="udiff-line-added">+             this.notFull.signalAll();</span>
<span class="udiff-line-added">+         } finally {</span>
<span class="udiff-line-added">+             lock.unlock();</span>
<span class="udiff-line-added">+         }</span>
      }
  
      private class NbpWriter extends Writer {
  
          @Override
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -144,11 +194,10 @@</span>
              NonBlockingPumpReader.this.write(cbuf, off, len);
          }
  
          @Override
          public void flush() throws IOException {
<span class="udiff-line-removed">-             NonBlockingPumpReader.this.flush();</span>
          }
  
          @Override
          public void close() throws IOException {
              NonBlockingPumpReader.this.close();
</pre>
<center><a href="NonBlockingInputStream.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="NonBlockingReader.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
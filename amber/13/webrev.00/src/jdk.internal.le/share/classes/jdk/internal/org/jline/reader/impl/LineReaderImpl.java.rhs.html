<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2002-2020, the original author or authors.</span>
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
   7  * https://opensource.org/licenses/BSD-3-Clause
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 
<a name="2" id="anc2"></a><span class="line-added">  11 import java.io.BufferedReader;</span>
<span class="line-added">  12 import java.io.File;</span>
<span class="line-added">  13 import java.io.FileReader;</span>
<span class="line-added">  14 import java.io.FileWriter;</span>
  15 import java.io.Flushable;
  16 import java.io.IOError;
  17 import java.io.IOException;
  18 import java.io.InputStream;
  19 import java.io.InterruptedIOException;
<a name="3" id="anc3"></a><span class="line-added">  20 import java.lang.reflect.Constructor;</span>
  21 import java.time.Instant;
  22 import java.util.*;
  23 import java.util.Map.Entry;
  24 import java.util.concurrent.atomic.AtomicBoolean;
<a name="4" id="anc4"></a>
  25 import java.util.concurrent.locks.ReentrantLock;
  26 import java.util.function.*;
  27 import java.util.regex.Matcher;
  28 import java.util.regex.Pattern;
  29 import java.util.stream.Collectors;
  30 import java.util.stream.Stream;
  31 import java.util.stream.StreamSupport;
  32 
  33 import jdk.internal.org.jline.keymap.BindingReader;
  34 import jdk.internal.org.jline.keymap.KeyMap;
  35 import jdk.internal.org.jline.reader.*;
  36 import jdk.internal.org.jline.reader.Parser.ParseContext;
  37 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  38 import jdk.internal.org.jline.terminal.*;
  39 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  40 import jdk.internal.org.jline.terminal.Terminal.Signal;
  41 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
  42 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
  43 import jdk.internal.org.jline.utils.AttributedString;
  44 import jdk.internal.org.jline.utils.AttributedStringBuilder;
  45 import jdk.internal.org.jline.utils.AttributedStyle;
  46 import jdk.internal.org.jline.utils.Curses;
  47 import jdk.internal.org.jline.utils.Display;
  48 import jdk.internal.org.jline.utils.InfoCmp.Capability;
  49 import jdk.internal.org.jline.utils.Levenshtein;
  50 import jdk.internal.org.jline.utils.Log;
  51 import jdk.internal.org.jline.utils.Status;
  52 import jdk.internal.org.jline.utils.WCWidth;
  53 
  54 import static jdk.internal.org.jline.keymap.KeyMap.alt;
  55 import static jdk.internal.org.jline.keymap.KeyMap.ctrl;
  56 import static jdk.internal.org.jline.keymap.KeyMap.del;
  57 import static jdk.internal.org.jline.keymap.KeyMap.esc;
  58 import static jdk.internal.org.jline.keymap.KeyMap.range;
  59 import static jdk.internal.org.jline.keymap.KeyMap.translate;
  60 
  61 /**
  62  * A reader for terminal applications. It supports custom tab-completion,
  63  * saveable command history, and command line editing.
  64  *
  65  * @author &lt;a href=&quot;mailto:mwp1@cornell.edu&quot;&gt;Marc Prud&#39;hommeaux&lt;/a&gt;
  66  * @author &lt;a href=&quot;mailto:jason@planet57.com&quot;&gt;Jason Dillon&lt;/a&gt;
  67  * @author &lt;a href=&quot;mailto:gnodet@gmail.com&quot;&gt;Guillaume Nodet&lt;/a&gt;
  68  */
  69 @SuppressWarnings(&quot;StatementWithEmptyBody&quot;)
  70 public class LineReaderImpl implements LineReader, Flushable
  71 {
  72     public static final char NULL_MASK = 0;
  73 
  74     public static final int TAB_WIDTH = 4;
  75 
  76 
  77     public static final String DEFAULT_WORDCHARS = &quot;*?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;&quot;;
  78     public static final String DEFAULT_REMOVE_SUFFIX_CHARS = &quot; \t\n;&amp;|&quot;;
  79     public static final String DEFAULT_COMMENT_BEGIN = &quot;#&quot;;
  80     public static final String DEFAULT_SEARCH_TERMINATORS = &quot;\033\012&quot;;
  81     public static final String DEFAULT_BELL_STYLE = &quot;&quot;;
  82     public static final int    DEFAULT_LIST_MAX = 100;
  83     public static final int    DEFAULT_ERRORS = 2;
  84     public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;
  85     public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;
  86     public static final String DEFAULT_SECONDARY_PROMPT_PATTERN = &quot;%M&gt; &quot;;
  87     public static final String DEFAULT_OTHERS_GROUP_NAME = &quot;others&quot;;
  88     public static final String DEFAULT_ORIGINAL_GROUP_NAME = &quot;original&quot;;
  89     public static final String DEFAULT_COMPLETION_STYLE_STARTING = &quot;36&quot;;    // cyan
  90     public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = &quot;90&quot;; // dark gray
  91     public static final String DEFAULT_COMPLETION_STYLE_GROUP = &quot;35;1&quot;;     // magenta
  92     public static final String DEFAULT_COMPLETION_STYLE_SELECTION = &quot;7&quot;;    // inverted
<a name="5" id="anc5"></a><span class="line-added">  93     public static final int    DEFAULT_INDENTATION = 0;</span>
<span class="line-added">  94     public static final int    DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;</span>
  95 
  96     private static final int MIN_ROWS = 3;
  97 
  98     public static final String BRACKETED_PASTE_ON = &quot;\033[?2004h&quot;;
  99     public static final String BRACKETED_PASTE_OFF = &quot;\033[?2004l&quot;;
 100     public static final String BRACKETED_PASTE_BEGIN = &quot;\033[200~&quot;;
 101     public static final String BRACKETED_PASTE_END = &quot;\033[201~&quot;;
 102 
 103     public static final String FOCUS_IN_SEQ = &quot;\033[I&quot;;
 104     public static final String FOCUS_OUT_SEQ = &quot;\033[O&quot;;
 105 
 106     /**
 107      * Possible states in which the current readline operation may be in.
 108      */
 109     protected enum State {
 110         /**
 111          * The user is just typing away
 112          */
 113         NORMAL,
 114         /**
 115          * readLine should exit and return the buffer content
 116          */
 117         DONE,
<a name="6" id="anc6"></a><span class="line-added"> 118         /**</span>
<span class="line-added"> 119          * readLine should exit and return empty String</span>
<span class="line-added"> 120          */</span>
<span class="line-added"> 121         IGNORE,</span>
 122         /**
 123          * readLine should exit and throw an EOFException
 124          */
 125         EOF,
 126         /**
 127          * readLine should exit and throw an UserInterruptException
 128          */
 129         INTERRUPT
 130     }
 131 
 132     protected enum ViMoveMode {
 133         NORMAL,
 134         YANK,
 135         DELETE,
 136         CHANGE
 137     }
 138 
 139     protected enum BellType {
 140         NONE,
 141         AUDIBLE,
 142         VISIBLE
 143     }
 144 
 145     //
 146     // Constructor variables
 147     //
 148 
 149     /** The terminal to use */
 150     protected final Terminal terminal;
 151     /** The application name */
 152     protected final String appName;
 153     /** The terminal keys mapping */
 154     protected final Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps;
 155 
 156     //
 157     // Configuration
 158     //
 159     protected final Map&lt;String, Object&gt; variables;
 160     protected History history = new DefaultHistory();
 161     protected Completer completer = null;
 162     protected Highlighter highlighter = new DefaultHighlighter();
 163     protected Parser parser = new DefaultParser();
 164     protected Expander expander = new DefaultExpander();
 165 
 166     //
 167     // State variables
 168     //
 169 
 170     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 171 
 172     protected final Buffer buf = new BufferImpl();
<a name="7" id="anc7"></a><span class="line-added"> 173     protected String tailTip = &quot;&quot;;</span>
<span class="line-added"> 174     protected SuggestionType autosuggestion = SuggestionType.NONE;</span>
 175 
 176     protected final Size size = new Size();
 177 
 178     protected AttributedString prompt = AttributedString.EMPTY;
 179     protected AttributedString rightPrompt = AttributedString.EMPTY;
 180 
 181     protected MaskingCallback maskingCallback;
 182 
 183     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 184     protected Buffer historyBuffer = null;
 185     protected CharSequence searchBuffer;
 186     protected StringBuffer searchTerm = null;
 187     protected boolean searchFailing;
 188     protected boolean searchBackward;
 189     protected int searchIndex = -1;
<a name="8" id="anc8"></a><span class="line-added"> 190     protected boolean doAutosuggestion;</span>
 191 
 192 
 193     // Reading buffers
 194     protected final BindingReader bindingReader;
 195 
 196 
 197     /**
 198      * VI character find
 199      */
 200     protected int findChar;
 201     protected int findDir;
 202     protected int findTailAdd;
 203     /**
 204      * VI history string search
 205      */
 206     private int searchDir;
 207     private String searchString;
 208 
 209     /**
 210      * Region state
 211      */
 212     protected int regionMark;
 213     protected RegionType regionActive;
 214 
 215     private boolean forceChar;
 216     private boolean forceLine;
 217 
 218     /**
 219      * The vi yank buffer
 220      */
 221     protected String yankBuffer = &quot;&quot;;
 222 
 223     protected ViMoveMode viMoveMode = ViMoveMode.NORMAL;
 224 
 225     protected KillRing killRing = new KillRing();
 226 
 227     protected UndoTree&lt;Buffer&gt; undo = new UndoTree&lt;&gt;(this::setBuffer);
 228     protected boolean isUndo;
 229 
 230     /**
 231      * State lock
 232      */
 233     protected final ReentrantLock lock = new ReentrantLock();
 234     /*
 235      * Current internal state of the line reader
 236      */
 237     protected State   state = State.DONE;
 238     protected final AtomicBoolean startedReading = new AtomicBoolean();
 239     protected boolean reading;
 240 
 241     protected Supplier&lt;AttributedString&gt; post;
 242 
 243     protected Map&lt;String, Widget&gt; builtinWidgets;
 244     protected Map&lt;String, Widget&gt; widgets;
 245 
 246     protected int count;
 247     protected int mult;
 248     protected int universal = 4;
 249     protected int repeatCount;
 250     protected boolean isArgDigit;
 251 
 252     protected ParsedLine parsedLine;
 253 
 254     protected boolean skipRedisplay;
 255     protected Display display;
 256 
 257     protected boolean overTyping = false;
 258 
 259     protected String keyMap;
 260 
 261     protected int smallTerminalOffset = 0;
<a name="9" id="anc9"></a>
 262     /*
 263      * accept-and-infer-next-history, accept-and-hold &amp; accept-line-and-down-history
 264      */
 265     protected boolean nextCommandFromHistory = false;
 266     protected int nextHistoryId = -1;
 267 
<a name="10" id="anc10"></a><span class="line-added"> 268     /*</span>
<span class="line-added"> 269      * execute commands from commandsBuffer</span>
<span class="line-added"> 270      */</span>
<span class="line-added"> 271     protected List&lt;String&gt; commandsBuffer = new ArrayList&lt;&gt;();</span>
 272 
 273     public LineReaderImpl(Terminal terminal) throws IOException {
 274         this(terminal, null, null);
 275     }
 276 
 277     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 278         this(terminal, appName, null);
 279     }
 280 
 281     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 282         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 283         this.terminal = terminal;
 284         if (appName == null) {
 285             appName = &quot;JLine&quot;;
 286         }
 287         this.appName = appName;
 288         if (variables != null) {
 289             this.variables = variables;
 290         } else {
 291             this.variables = new HashMap&lt;&gt;();
 292         }
 293         this.keyMaps = defaultKeyMaps();
 294 
 295         builtinWidgets = builtinWidgets();
 296         widgets = new HashMap&lt;&gt;(builtinWidgets);
 297         bindingReader = new BindingReader(terminal.reader());
 298         doDisplay();
 299     }
 300 
 301     public Terminal getTerminal() {
 302         return terminal;
 303     }
 304 
 305     public String getAppName() {
 306         return appName;
 307     }
 308 
 309     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; getKeyMaps() {
 310         return keyMaps;
 311     }
 312 
 313     public KeyMap&lt;Binding&gt; getKeys() {
 314         return keyMaps.get(keyMap);
 315     }
 316 
 317     @Override
 318     public Map&lt;String, Widget&gt; getWidgets() {
 319         return widgets;
 320     }
 321 
 322     @Override
 323     public Map&lt;String, Widget&gt; getBuiltinWidgets() {
 324         return Collections.unmodifiableMap(builtinWidgets);
 325     }
 326 
 327     @Override
 328     public Buffer getBuffer() {
 329         return buf;
 330     }
 331 
<a name="11" id="anc11"></a><span class="line-added"> 332     @Override</span>
<span class="line-added"> 333     public void setAutosuggestion(SuggestionType type) {</span>
<span class="line-added"> 334         this.autosuggestion = type;</span>
<span class="line-added"> 335     }</span>
<span class="line-added"> 336 </span>
<span class="line-added"> 337     @Override</span>
<span class="line-added"> 338     public SuggestionType getAutosuggestion() {</span>
<span class="line-added"> 339         return autosuggestion;</span>
<span class="line-added"> 340     }</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342     @Override</span>
<span class="line-added"> 343     public String getTailTip() {</span>
<span class="line-added"> 344         return tailTip;</span>
<span class="line-added"> 345     }</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     @Override</span>
<span class="line-added"> 348     public void setTailTip(String tailTip) {</span>
<span class="line-added"> 349         this.tailTip = tailTip;</span>
<span class="line-added"> 350     }</span>
<span class="line-added"> 351 </span>
 352     @Override
 353     public void runMacro(String macro) {
 354         bindingReader.runMacro(macro);
 355     }
 356 
 357     @Override
 358     public MouseEvent readMouseEvent() {
 359         return terminal.readMouseEvent(bindingReader::readCharacter);
 360     }
 361 
 362     /**
 363      * Set the completer.
 364      *
 365      * @param completer the completer to use
 366      */
 367     public void setCompleter(Completer completer) {
 368         this.completer = completer;
 369     }
 370 
 371     /**
 372      * Returns the completer.
 373      *
 374      * @return the completer
 375      */
 376     public Completer getCompleter() {
 377         return completer;
 378     }
 379 
 380     //
 381     // History
 382     //
 383 
 384     public void setHistory(final History history) {
 385         Objects.requireNonNull(history);
 386         this.history = history;
 387     }
 388 
 389     public History getHistory() {
 390         return history;
 391     }
 392 
 393     //
 394     // Highlighter
 395     //
 396 
 397     public void setHighlighter(Highlighter highlighter) {
 398         this.highlighter = highlighter;
 399     }
 400 
 401     public Highlighter getHighlighter() {
 402         return highlighter;
 403     }
 404 
 405     public Parser getParser() {
 406         return parser;
 407     }
 408 
 409     public void setParser(Parser parser) {
 410         this.parser = parser;
 411     }
 412 
 413     @Override
 414     public Expander getExpander() {
 415         return expander;
 416     }
 417 
 418     public void setExpander(Expander expander) {
 419         this.expander = expander;
 420     }
 421 
 422     //
 423     // Line Reading
 424     //
 425 
 426     /**
 427      * Read the next line and return the contents of the buffer.
 428      *
 429      * @return          A line that is read from the terminal, can never be null.
 430      */
 431     public String readLine() throws UserInterruptException, EndOfFileException {
 432         return readLine(null, null, (MaskingCallback) null, null);
 433     }
 434 
 435     /**
 436      * Read the next line with the specified character mask. If null, then
 437      * characters will be echoed. If 0, then no characters will be echoed.
 438      *
 439      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 440      * @return          A line that is read from the terminal, can never be null.
 441      */
 442     public String readLine(Character mask) throws UserInterruptException, EndOfFileException {
 443         return readLine(null, null, mask, null);
 444     }
 445 
 446     /**
 447      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 448      * (without any trailing newlines).
 449      *
 450      * @param prompt    The prompt to issue to the terminal, may be null.
 451      * @return          A line that is read from the terminal, can never be null.
 452      */
 453     public String readLine(String prompt) throws UserInterruptException, EndOfFileException {
 454         return readLine(prompt, null, (MaskingCallback) null, null);
 455     }
 456 
 457     /**
 458      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 459      * (without any trailing newlines).
 460      *
 461      * @param prompt    The prompt to issue to the terminal, may be null.
 462      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 463      * @return          A line that is read from the terminal, can never be null.
 464      */
 465     public String readLine(String prompt, Character mask) throws UserInterruptException, EndOfFileException {
 466         return readLine(prompt, null, mask, null);
 467     }
 468 
 469     /**
 470      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 471      * (without any trailing newlines).
 472      *
 473      * @param prompt    The prompt to issue to the terminal, may be null.
 474      * @param mask      The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 475      * @param buffer    A string that will be set for editing.
 476      * @return          A line that is read from the terminal, can never be null.
 477      */
 478     public String readLine(String prompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 479         return readLine(prompt, null, mask, buffer);
 480     }
 481 
 482     /**
 483      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 484      * (without any trailing newlines).
 485      *
 486      * @param prompt      The prompt to issue to the terminal, may be null.
 487      * @param rightPrompt The prompt to issue to the right of the terminal, may be null.
 488      * @param mask        The mask character, &lt;code&gt;null&lt;/code&gt; or &lt;code&gt;0&lt;/code&gt;.
 489      * @param buffer      A string that will be set for editing.
 490      * @return            A line that is read from the terminal, can never be null.
 491      */
 492     public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 493         return readLine(prompt, rightPrompt, mask != null ? new SimpleMaskingCallback(mask) : null, buffer);
 494     }
 495 
 496     /**
 497      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 498      * (without any trailing newlines).
 499      *
 500      * @param prompt          The prompt to issue to the terminal, may be null.
 501      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 502      * @param maskingCallback The callback used to mask parts of the edited line.
 503      * @param buffer          A string that will be set for editing.
 504      * @return                A line that is read from the terminal, can never be null.
 505      */
 506     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 507         // prompt may be null
 508         // maskingCallback may be null
 509         // buffer may be null
<a name="12" id="anc12"></a><span class="line-added"> 510         if (!commandsBuffer.isEmpty()) {</span>
<span class="line-added"> 511             String cmd = commandsBuffer.remove(0);</span>
<span class="line-added"> 512             boolean done = false;</span>
<span class="line-added"> 513             do {</span>
<span class="line-added"> 514                 try {</span>
<span class="line-added"> 515                     parser.parse(cmd, cmd.length() + 1, ParseContext.ACCEPT_LINE);</span>
<span class="line-added"> 516                     done = true;</span>
<span class="line-added"> 517                 } catch (EOFError e) {</span>
<span class="line-added"> 518                     if (commandsBuffer.isEmpty()) {</span>
<span class="line-added"> 519                         throw new IllegalArgumentException(&quot;Incompleted command: \n&quot; + cmd);</span>
<span class="line-added"> 520                     }</span>
<span class="line-added"> 521                     cmd += &quot;\n&quot;;</span>
<span class="line-added"> 522                     cmd += commandsBuffer.remove(0);</span>
<span class="line-added"> 523                 } catch (SyntaxError e) {</span>
<span class="line-added"> 524                     done = true;</span>
<span class="line-added"> 525                 } catch (Exception e) {</span>
<span class="line-added"> 526                     commandsBuffer.clear();</span>
<span class="line-added"> 527                     throw new IllegalArgumentException(e.getMessage());</span>
<span class="line-added"> 528                 }</span>
<span class="line-added"> 529             } while (!done);</span>
<span class="line-added"> 530             AttributedStringBuilder sb = new AttributedStringBuilder();</span>
<span class="line-added"> 531             sb.styled(AttributedStyle::bold, cmd);</span>
<span class="line-added"> 532             sb.toAttributedString().println(terminal);</span>
<span class="line-added"> 533             terminal.flush();</span>
<span class="line-added"> 534             return finish(cmd);</span>
<span class="line-added"> 535         }</span>
 536 
 537         if (!startedReading.compareAndSet(false, true)) {
 538             throw new IllegalStateException();
 539         }
 540 
 541         Thread readLineThread = Thread.currentThread();
 542         SignalHandler previousIntrHandler = null;
 543         SignalHandler previousWinchHandler = null;
 544         SignalHandler previousContHandler = null;
 545         Attributes originalAttributes = null;
 546         boolean dumb = isTerminalDumb();
 547         try {
 548 
 549             this.maskingCallback = maskingCallback;
 550 
 551             /*
 552              * This is the accumulator for VI-mode repeat count. That is, while in
 553              * move mode, if you type 30x it will delete 30 characters. This is
 554              * where the &quot;30&quot; is accumulated until the command is struck.
 555              */
 556             repeatCount = 0;
 557             mult = 1;
 558             regionActive = RegionType.NONE;
 559             regionMark = -1;
 560 
 561             smallTerminalOffset = 0;
 562 
 563             state = State.NORMAL;
 564 
 565             modifiedHistory.clear();
 566 
 567             setPrompt(prompt);
 568             setRightPrompt(rightPrompt);
 569             buf.clear();
 570             if (buffer != null) {
 571                 buf.write(buffer);
 572             }
 573             if (nextCommandFromHistory &amp;&amp; nextHistoryId &gt; 0) {
 574                 if (history.size() &gt; nextHistoryId) {
 575                     history.moveTo(nextHistoryId);
 576                 } else {
 577                     history.moveTo(history.last());
 578                 }
 579                 buf.write(history.current());
 580             } else {
 581                 nextHistoryId = -1;
 582             }
 583             nextCommandFromHistory = false;
 584             undo.clear();
 585             parsedLine = null;
 586             keyMap = MAIN;
 587 
 588             if (history != null) {
 589                 history.attach(this);
 590             }
 591 
 592             try {
 593                 lock.lock();
 594 
 595                 this.reading = true;
 596 
 597                 previousIntrHandler = terminal.handle(Signal.INT, signal -&gt; readLineThread.interrupt());
 598                 previousWinchHandler = terminal.handle(Signal.WINCH, this::handleSignal);
 599                 previousContHandler = terminal.handle(Signal.CONT, this::handleSignal);
 600                 originalAttributes = terminal.enterRawMode();
 601 
 602                 doDisplay();
 603 
 604                 // Move into application mode
 605                 if (!dumb) {
 606                     terminal.puts(Capability.keypad_xmit);
 607                     if (isSet(Option.AUTO_FRESH_LINE))
 608                         callWidget(FRESH_LINE);
 609                     if (isSet(Option.MOUSE))
 610                         terminal.trackMouse(Terminal.MouseTracking.Normal);
 611                     if (isSet(Option.BRACKETED_PASTE))
 612                         terminal.writer().write(BRACKETED_PASTE_ON);
 613                 } else {
 614                     // For dumb terminals, we need to make sure that CR are ignored
 615                     Attributes attr = new Attributes(originalAttributes);
 616                     attr.setInputFlag(Attributes.InputFlag.IGNCR, true);
 617                     terminal.setAttributes(attr);
 618                 }
 619 
 620                 callWidget(CALLBACK_INIT);
 621 
 622                 undo.newState(buf.copy());
 623 
 624                 // Draw initial prompt
 625                 redrawLine();
 626                 redisplay();
 627             } finally {
 628                 lock.unlock();
 629             }
 630 
 631             while (true) {
 632 
 633                 KeyMap&lt;Binding&gt; local = null;
 634                 if (isInViCmdMode() &amp;&amp; regionActive != RegionType.NONE) {
 635                     local = keyMaps.get(VISUAL);
 636                 }
 637                 Binding o = readBinding(getKeys(), local);
 638                 if (o == null) {
 639                     throw new EndOfFileException();
 640                 }
 641                 Log.trace(&quot;Binding: &quot;, o);
 642                 if (buf.length() == 0 &amp;&amp; getLastBinding().charAt(0) == originalAttributes.getControlChar(ControlChar.VEOF)) {
 643                     throw new EndOfFileException();
 644                 }
 645 
 646                 // If this is still false after handling the binding, then
 647                 // we reset our repeatCount to 0.
 648                 isArgDigit = false;
 649                 // Every command that can be repeated a specified number
 650                 // of times, needs to know how many times to repeat, so
 651                 // we figure that out here.
 652                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 653                 // Reset undo/redo flag
 654                 isUndo = false;
 655                 // Reset region after a paste
 656                 if (regionActive == RegionType.PASTE) {
 657                     regionActive = RegionType.NONE;
 658                 }
 659 
 660                 try {
 661                     lock.lock();
 662                     // Get executable widget
<a name="13" id="anc13"></a><span class="line-modified"> 663                     Buffer copy = buf.length() &lt;= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE) ? buf.copy() : null;</span>
 664                     Widget w = getWidget(o);
 665                     if (!w.apply()) {
 666                         beep();
 667                     }
<a name="14" id="anc14"></a><span class="line-modified"> 668                     if (!isUndo &amp;&amp; copy != null &amp;&amp; buf.length() &lt;= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)</span>
<span class="line-added"> 669                             &amp;&amp; !copy.toString().equals(buf.toString())) {</span>
 670                         undo.newState(buf.copy());
 671                     }
 672 
 673                     switch (state) {
 674                         case DONE:
 675                             return finishBuffer();
<a name="15" id="anc15"></a><span class="line-added"> 676                         case IGNORE:</span>
<span class="line-added"> 677                             return &quot;&quot;;</span>
 678                         case EOF:
 679                             throw new EndOfFileException();
 680                         case INTERRUPT:
 681                             throw new UserInterruptException(buf.toString());
 682                     }
 683 
 684                     if (!isArgDigit) {
 685                         /*
 686                          * If the operation performed wasn&#39;t a vi argument
 687                          * digit, then clear out the current repeatCount;
 688                          */
 689                         repeatCount = 0;
 690                         mult = 1;
 691                     }
 692 
 693                     if (!dumb) {
 694                         redisplay();
 695                     }
 696                 } finally {
 697                     lock.unlock();
 698                 }
 699             }
 700         } catch (IOError e) {
 701             if (e.getCause() instanceof InterruptedIOException) {
 702                 throw new UserInterruptException(buf.toString());
 703             } else {
 704                 throw e;
 705             }
 706         }
 707         finally {
 708             try {
 709                 lock.lock();
 710 
 711                 this.reading = false;
 712 
 713                 cleanup();
 714                 if (originalAttributes != null) {
 715                     terminal.setAttributes(originalAttributes);
 716                 }
 717                 if (previousIntrHandler != null) {
 718                     terminal.handle(Signal.INT, previousIntrHandler);
 719                 }
 720                 if (previousWinchHandler != null) {
 721                     terminal.handle(Signal.WINCH, previousWinchHandler);
 722                 }
 723                 if (previousContHandler != null) {
 724                     terminal.handle(Signal.CONT, previousContHandler);
 725                 }
 726             } finally {
 727                 lock.unlock();
 728             }
 729             startedReading.set(false);
 730         }
 731     }
 732 
<a name="16" id="anc16"></a><span class="line-modified"> 733     private boolean isTerminalDumb() {</span>
 734         return Terminal.TYPE_DUMB.equals(terminal.getType())
 735                 || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());
 736     }
 737 
<a name="17" id="anc17"></a><span class="line-modified"> 738     private void doDisplay() {</span>
 739         // Cache terminal size for the duration of the call to readLine()
 740         // It will eventually be updated with WINCH signals
 741         size.copy(terminal.getBufferSize());
 742 
 743         display = new Display(terminal, false);
 744         if (size.getRows() == 0 || size.getColumns() == 0) {
 745             display.resize(1, Integer.MAX_VALUE);
 746         } else {
 747             display.resize(size.getRows(), size.getColumns());
 748         }
 749         if (isSet(Option.DELAY_LINE_WRAP))
 750             display.setDelayLineWrap(true);
 751     }
 752 
 753     @Override
 754     public void printAbove(String str) {
 755         try {
 756             lock.lock();
 757 
 758             boolean reading = this.reading;
 759             if (reading) {
 760                 display.update(Collections.emptyList(), 0);
 761             }
 762             if (str.endsWith(&quot;\n&quot;) || str.endsWith(&quot;\n\033[m&quot;) || str.endsWith(&quot;\n\033[0m&quot;)) {
 763                 terminal.writer().print(str);
 764             } else {
 765                 terminal.writer().println(str);
 766             }
 767             if (reading) {
 768                 redisplay(false);
 769             }
 770             terminal.flush();
 771         } finally {
 772             lock.unlock();
 773         }
 774     }
 775 
 776     @Override
 777     public void printAbove(AttributedString str) {
 778         printAbove(str.toAnsi(terminal));
 779     }
 780 
 781     @Override
 782     public boolean isReading() {
 783         try {
 784             lock.lock();
 785             return reading;
 786         } finally {
 787             lock.unlock();
 788         }
 789     }
 790 
 791     /* Make sure we position the cursor on column 0 */
 792     protected boolean freshLine() {
 793         boolean wrapAtEol = terminal.getBooleanCapability(Capability.auto_right_margin);
 794         boolean delayedWrapAtEol = wrapAtEol &amp;&amp; terminal.getBooleanCapability(Capability.eat_newline_glitch);
 795         AttributedStringBuilder sb = new AttributedStringBuilder();
 796         sb.style(AttributedStyle.DEFAULT.foreground(AttributedStyle.BLACK + AttributedStyle.BRIGHT));
 797         sb.append(&quot;~&quot;);
 798         sb.style(AttributedStyle.DEFAULT);
 799         if (!wrapAtEol || delayedWrapAtEol) {
 800             for (int i = 0; i &lt; size.getColumns() - 1; i++) {
 801                 sb.append(&quot; &quot;);
 802             }
 803             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 804             sb.append(&quot; &quot;);
 805             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 806         } else {
 807             // Given the terminal will wrap automatically,
 808             // we need to print one less than needed.
 809             // This means that the last character will not
 810             // be overwritten, and that&#39;s why we&#39;re using
 811             // a clr_eol first if possible.
 812             String el = terminal.getStringCapability(Capability.clr_eol);
 813             if (el != null) {
 814                 Curses.tputs(sb, el);
 815             }
 816             for (int i = 0; i &lt; size.getColumns() - 2; i++) {
 817                 sb.append(&quot; &quot;);
 818             }
 819             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 820             sb.append(&quot; &quot;);
 821             sb.append(KeyMap.key(terminal, Capability.carriage_return));
 822         }
 823         sb.print(terminal);
 824         return true;
 825     }
 826 
 827     @Override
 828     public void callWidget(String name) {
 829         try {
 830             lock.lock();
 831             if (!reading) {
 832                 throw new IllegalStateException(&quot;Widgets can only be called during a `readLine` call&quot;);
 833             }
 834             try {
 835                 Widget w;
 836                 if (name.startsWith(&quot;.&quot;)) {
 837                     w = builtinWidgets.get(name.substring(1));
 838                 } else {
 839                     w = widgets.get(name);
 840                 }
 841                 if (w != null) {
 842                     w.apply();
 843                 }
 844             } catch (Throwable t) {
 845                 Log.debug(&quot;Error executing widget &#39;&quot;, name, &quot;&#39;&quot;, t);
 846             }
 847         } finally {
 848             lock.unlock();
 849         }
 850     }
 851 
 852     /**
 853      * Clear the line and redraw it.
 854      * @return &lt;code&gt;true&lt;/code&gt;
 855      */
 856     public boolean redrawLine() {
 857         display.reset();
 858         return true;
 859     }
 860 
 861     /**
 862      * Write out the specified string to the buffer and the output stream.
 863      * @param str the char sequence to write in the buffer
 864      */
 865     public void putString(final CharSequence str) {
 866         buf.write(str, overTyping);
 867     }
 868 
 869     /**
 870      * Flush the terminal output stream. This is important for printout out single
 871      * characters (like a buf.backspace or keyboard) that we want the terminal to
 872      * handle immediately.
 873      */
 874     public void flush() {
 875         terminal.flush();
 876     }
 877 
 878     public boolean isKeyMap(String name) {
 879         return keyMap.equals(name);
 880     }
 881 
 882     /**
 883      * Read a character from the terminal.
 884      *
 885      * @return the character, or -1 if an EOF is received.
 886      */
 887     public int readCharacter() {
 888         if (lock.isHeldByCurrentThread()) {
 889             try {
 890                 lock.unlock();
 891                 return bindingReader.readCharacter();
 892             } finally {
 893                 lock.lock();
 894             }
 895         } else {
 896             return bindingReader.readCharacter();
 897         }
 898     }
 899 
 900     public int peekCharacter(long timeout) {
 901         return bindingReader.peekCharacter(timeout);
 902     }
 903 
 904     protected &lt;T&gt; T doReadBinding(KeyMap&lt;T&gt; keys, KeyMap&lt;T&gt; local) {
 905         if (lock.isHeldByCurrentThread()) {
 906             try {
 907                 lock.unlock();
 908                 return bindingReader.readBinding(keys, local);
 909             } finally {
 910                 lock.lock();
 911             }
 912         } else {
 913             return bindingReader.readBinding(keys, local);
 914         }
 915     }
 916 
<a name="18" id="anc18"></a><span class="line-added"> 917     protected String doReadStringUntil(String sequence) {</span>
<span class="line-added"> 918         if (lock.isHeldByCurrentThread()) {</span>
<span class="line-added"> 919             try {</span>
<span class="line-added"> 920                 lock.unlock();</span>
<span class="line-added"> 921                 return bindingReader.readStringUntil(sequence);</span>
<span class="line-added"> 922             } finally {</span>
<span class="line-added"> 923                 lock.lock();</span>
<span class="line-added"> 924             }</span>
<span class="line-added"> 925         } else {</span>
<span class="line-added"> 926             return bindingReader.readStringUntil(sequence);</span>
<span class="line-added"> 927         }</span>
<span class="line-added"> 928     }</span>
<span class="line-added"> 929 </span>
 930     /**
 931      * Read from the input stream and decode an operation from the key map.
 932      *
 933      * The input stream will be read character by character until a matching
 934      * binding can be found.  Characters that can&#39;t possibly be matched to
 935      * any binding will be discarded.
 936      *
 937      * @param keys the KeyMap to use for decoding the input stream
 938      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 939      *         stream has been reached
 940      */
 941     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 942         return readBinding(keys, null);
 943     }
 944 
 945     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
 946         Binding o = doReadBinding(keys, local);
 947         /*
 948          * The kill ring keeps record of whether or not the
 949          * previous command was a yank or a kill. We reset
 950          * that state here if needed.
 951          */
 952         if (o instanceof Reference) {
 953             String ref = ((Reference) o).name();
 954             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 955                 killRing.resetLastYank();
 956             }
 957             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 958                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 959                 killRing.resetLastKill();
 960             }
 961         }
 962         return o;
 963     }
 964 
 965     @Override
 966     public ParsedLine getParsedLine() {
 967         return parsedLine;
 968     }
 969 
<a name="19" id="anc19"></a><span class="line-added"> 970     @Override</span>
 971     public String getLastBinding() {
 972         return bindingReader.getLastBinding();
 973     }
 974 
<a name="20" id="anc20"></a><span class="line-added"> 975     @Override</span>
 976     public String getSearchTerm() {
 977         return searchTerm != null ? searchTerm.toString() : null;
 978     }
 979 
 980     @Override
 981     public RegionType getRegionActive() {
 982         return regionActive;
 983     }
 984 
 985     @Override
 986     public int getRegionMark() {
 987         return regionMark;
 988     }
 989 
 990     //
 991     // Key Bindings
 992     //
 993 
 994     /**
 995      * Sets the current keymap by name. Supported keymaps are &quot;emacs&quot;,
 996      * &quot;viins&quot;, &quot;vicmd&quot;.
 997      * @param name The name of the keymap to switch to
 998      * @return true if the keymap was set, or false if the keymap is
 999      *    not recognized.
1000      */
1001     public boolean setKeyMap(String name) {
1002         KeyMap&lt;Binding&gt; map = keyMaps.get(name);
1003         if (map == null) {
1004             return false;
1005         }
1006         this.keyMap = name;
1007         if (reading) {
1008             callWidget(CALLBACK_KEYMAP);
1009         }
1010         return true;
1011     }
1012 
1013     /**
1014      * Returns the name of the current key mapping.
1015      * @return the name of the key mapping. This will be the canonical name
1016      *   of the current mode of the key map and may not reflect the name that
1017      *   was used with {@link #setKeyMap(String)}.
1018      */
1019     public String getKeyMap() {
1020         return keyMap;
1021     }
1022 
1023     @Override
1024     public LineReader variable(String name, Object value) {
1025         variables.put(name, value);
1026         return this;
1027     }
1028 
1029     @Override
1030     public Map&lt;String, Object&gt; getVariables() {
1031         return variables;
1032     }
1033 
1034     @Override
1035     public Object getVariable(String name) {
1036         return variables.get(name);
1037     }
1038 
1039     @Override
1040     public void setVariable(String name, Object value) {
1041         variables.put(name, value);
1042     }
1043 
1044     @Override
1045     public LineReader option(Option option, boolean value) {
1046         options.put(option, value);
1047         return this;
1048     }
1049 
1050     @Override
1051     public boolean isSet(Option option) {
1052         Boolean b = options.get(option);
1053         return b != null ? b : option.isDef();
1054     }
1055 
1056     @Override
1057     public void setOpt(Option option) {
1058         options.put(option, Boolean.TRUE);
1059     }
1060 
1061     @Override
1062     public void unsetOpt(Option option) {
1063         options.put(option, Boolean.FALSE);
1064     }
1065 
<a name="21" id="anc21"></a><span class="line-added">1066     @Override</span>
<span class="line-added">1067     public void addCommandsInBuffer(Collection&lt;String&gt; commands) {</span>
<span class="line-added">1068         commandsBuffer.addAll(commands);</span>
<span class="line-added">1069     }</span>
1070 
<a name="22" id="anc22"></a><span class="line-added">1071     @Override</span>
<span class="line-added">1072     public void editAndAddInBuffer(File file) throws Exception {</span>
<span class="line-added">1073         Constructor&lt;?&gt; ctor = Class.forName(&quot;org.jline.builtins.Nano&quot;).getConstructor(Terminal.class, File.class);</span>
<span class="line-added">1074         Editor editor = (Editor) ctor.newInstance(terminal, new File(file.getParent()));</span>
<span class="line-added">1075         editor.setRestricted(true);</span>
<span class="line-added">1076         editor.open(Arrays.asList(file.getName()));</span>
<span class="line-added">1077         editor.run();</span>
<span class="line-added">1078         BufferedReader br = new BufferedReader(new FileReader(file));</span>
<span class="line-added">1079         String line;</span>
<span class="line-added">1080         commandsBuffer.clear();</span>
<span class="line-added">1081         while ((line = br.readLine()) != null) {</span>
<span class="line-added">1082             commandsBuffer.add(line);</span>
<span class="line-added">1083         }</span>
<span class="line-added">1084         br.close();</span>
<span class="line-added">1085     }</span>
1086 
1087     //
1088     // Widget implementation
1089     //
1090 
1091     /**
1092      * Clear the buffer and add its contents to the history.
1093      *
1094      * @return the former contents of the buffer.
1095      */
1096     protected String finishBuffer() {
<a name="23" id="anc23"></a><span class="line-modified">1097         return finish(buf.toString());</span>
<span class="line-added">1098     }</span>
<span class="line-added">1099 </span>
<span class="line-added">1100     protected String finish(String str) {</span>
1101         String historyLine = str;
1102 
1103         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
1104             StringBuilder sb = new StringBuilder();
1105             boolean escaped = false;
1106             for (int i = 0; i &lt; str.length(); i++) {
1107                 char ch = str.charAt(i);
1108                 if (escaped) {
1109                     escaped = false;
1110                     if (ch != &#39;\n&#39;) {
1111                         sb.append(ch);
1112                     }
1113                 } else if (parser.isEscapeChar(ch)) {
1114                     escaped = true;
1115                 } else {
1116                     sb.append(ch);
1117                 }
1118             }
1119             str = sb.toString();
1120         }
1121 
1122         if (maskingCallback != null) {
1123             historyLine = maskingCallback.history(historyLine);
1124         }
1125 
1126         // we only add it to the history if the buffer is not empty
1127         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
1128             history.add(Instant.now(), historyLine);
1129         }
1130         return str;
1131     }
1132 
1133     protected void handleSignal(Signal signal) {
<a name="24" id="anc24"></a><span class="line-added">1134         doAutosuggestion = false;</span>
1135         if (signal == Signal.WINCH) {
1136             Status status = Status.getStatus(terminal, false);
1137             if (status != null) {
1138                 status.hardReset();
1139             }
1140             size.copy(terminal.getBufferSize());
1141             display.resize(size.getRows(), size.getColumns());
<a name="25" id="anc25"></a><span class="line-modified">1142             // restores prompt but also prevents scrolling in consoleZ, see #492</span>
<span class="line-added">1143             // redrawLine();</span>
1144             redisplay();
1145         }
1146         else if (signal == Signal.CONT) {
1147             terminal.enterRawMode();
1148             size.copy(terminal.getBufferSize());
1149             display.resize(size.getRows(), size.getColumns());
1150             terminal.puts(Capability.keypad_xmit);
1151             redrawLine();
1152             redisplay();
1153         }
1154     }
1155 
1156     @SuppressWarnings(&quot;unchecked&quot;)
1157     protected Widget getWidget(Object binding) {
1158         Widget w;
1159         if (binding instanceof Widget) {
1160             w = (Widget) binding;
1161         } else if (binding instanceof Macro) {
1162             String macro = ((Macro) binding).getSequence();
1163             w = () -&gt; {
1164                 bindingReader.runMacro(macro);
1165                 return true;
1166             };
1167         } else if (binding instanceof Reference) {
1168             String name = ((Reference) binding).name();
1169             w = widgets.get(name);
1170             if (w == null) {
1171                 w = () -&gt; {
1172                     post = () -&gt; new AttributedString(&quot;No such widget `&quot; + name + &quot;&#39;&quot;);
1173                     return false;
1174                 };
1175             }
1176         } else {
1177             w = () -&gt; {
1178                 post = () -&gt; new AttributedString(&quot;Unsupported widget&quot;);
1179                 return false;
1180             };
1181         }
1182         return w;
1183     }
1184 
1185     //
1186     // Helper methods
1187     //
1188 
1189     public void setPrompt(final String prompt) {
1190         this.prompt = (prompt == null ? AttributedString.EMPTY
1191                        : expandPromptPattern(prompt, 0, &quot;&quot;, 0));
1192     }
1193 
1194     public void setRightPrompt(final String rightPrompt) {
1195         this.rightPrompt = (rightPrompt == null ? AttributedString.EMPTY
1196                             : expandPromptPattern(rightPrompt, 0, &quot;&quot;, 0));
1197     }
1198 
1199     protected void setBuffer(Buffer buffer) {
1200         buf.copyFrom(buffer);
1201     }
1202 
1203     /**
1204      * Set the current buffer&#39;s content to the specified {@link String}. The
1205      * visual terminal will be modified to show the current buffer.
1206      *
1207      * @param buffer the new contents of the buffer.
1208      */
1209     protected void setBuffer(final String buffer) {
1210         buf.clear();
1211         buf.write(buffer);
1212     }
1213 
1214     /**
1215      * This method is calling while doing a delete-to (&quot;d&quot;), change-to (&quot;c&quot;),
1216      * or yank-to (&quot;y&quot;) and it filters out only those movement operations
1217      * that are allowable during those operations. Any operation that isn&#39;t
1218      * allow drops you back into movement mode.
1219      *
1220      * @param op The incoming operation to remap
1221      * @return The remaped operation
1222      */
1223     protected String viDeleteChangeYankToRemap (String op) {
1224         switch (op) {
1225             case SEND_BREAK:
1226             case BACKWARD_CHAR:
1227             case FORWARD_CHAR:
1228             case END_OF_LINE:
1229             case VI_MATCH_BRACKET:
1230             case VI_DIGIT_OR_BEGINNING_OF_LINE:
1231             case NEG_ARGUMENT:
1232             case DIGIT_ARGUMENT:
1233             case VI_BACKWARD_CHAR:
1234             case VI_BACKWARD_WORD:
1235             case VI_FORWARD_CHAR:
1236             case VI_FORWARD_WORD:
1237             case VI_FORWARD_WORD_END:
1238             case VI_FIRST_NON_BLANK:
1239             case VI_GOTO_COLUMN:
1240             case VI_DELETE:
1241             case VI_YANK:
1242             case VI_CHANGE:
1243             case VI_FIND_NEXT_CHAR:
1244             case VI_FIND_NEXT_CHAR_SKIP:
1245             case VI_FIND_PREV_CHAR:
1246             case VI_FIND_PREV_CHAR_SKIP:
1247             case VI_REPEAT_FIND:
1248             case VI_REV_REPEAT_FIND:
1249                 return op;
1250 
1251             default:
1252                 return VI_CMD_MODE;
1253         }
1254     }
1255 
1256     protected int switchCase(int ch) {
1257         if (Character.isUpperCase(ch)) {
1258             return Character.toLowerCase(ch);
1259         } else if (Character.isLowerCase(ch)) {
1260             return Character.toUpperCase(ch);
1261         } else {
1262             return ch;
1263         }
1264     }
1265 
1266     /**
1267      * @return true if line reader is in the middle of doing a change-to
1268      *   delete-to or yank-to.
1269      */
1270     protected boolean isInViMoveOperation() {
1271         return viMoveMode != ViMoveMode.NORMAL;
1272     }
1273 
1274     protected boolean isInViChangeOperation() {
1275         return viMoveMode == ViMoveMode.CHANGE;
1276     }
1277 
1278     protected boolean isInViCmdMode() {
1279         return VICMD.equals(keyMap);
1280     }
1281 
1282 
1283     //
1284     // Movement
1285     //
1286 
1287     protected boolean viForwardChar() {
1288         if (count &lt; 0) {
1289             return callNeg(this::viBackwardChar);
1290         }
1291         int lim = findeol();
1292         if (isInViCmdMode() &amp;&amp; !isInViMoveOperation()) {
1293             lim--;
1294         }
1295         if (buf.cursor() &gt;= lim) {
1296             return false;
1297         }
1298         while (count-- &gt; 0 &amp;&amp; buf.cursor() &lt; lim) {
1299             buf.move(1);
1300         }
1301         return true;
1302     }
1303 
1304     protected boolean viBackwardChar() {
1305         if (count &lt; 0) {
1306             return callNeg(this::viForwardChar);
1307         }
1308         int lim = findbol();
1309         if (buf.cursor() == lim) {
1310             return false;
1311         }
1312         while (count-- &gt; 0 &amp;&amp; buf.cursor() &gt; 0) {
1313             buf.move(-1);
1314             if (buf.currChar() == &#39;\n&#39;) {
1315                 buf.move(1);
1316                 break;
1317             }
1318         }
1319         return true;
1320     }
1321 
1322 
1323     //
1324     // Word movement
1325     //
1326 
1327     protected boolean forwardWord() {
1328         if (count &lt; 0) {
1329             return callNeg(this::backwardWord);
1330         }
1331         while (count-- &gt; 0) {
1332             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1333                 buf.move(1);
1334             }
1335             if (isInViChangeOperation() &amp;&amp; count == 0) {
1336                 break;
1337             }
1338             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1339                 buf.move(1);
1340             }
1341         }
1342         return true;
1343     }
1344 
1345     protected boolean viForwardWord() {
1346         if (count &lt; 0) {
1347             return callNeg(this::backwardWord);
1348         }
1349         while (count-- &gt; 0) {
1350             if (isViAlphaNum(buf.currChar())) {
1351                 while (buf.cursor() &lt; buf.length() &amp;&amp; isViAlphaNum(buf.currChar())) {
1352                     buf.move(1);
1353                 }
1354             } else {
1355                 while (buf.cursor() &lt; buf.length()
1356                         &amp;&amp; !isViAlphaNum(buf.currChar())
1357                         &amp;&amp; !isWhitespace(buf.currChar())) {
1358                     buf.move(1);
1359                 }
1360             }
1361             if (isInViChangeOperation() &amp;&amp; count == 0) {
1362                 return true;
1363             }
1364             int nl = buf.currChar() == &#39;\n&#39; ? 1 : 0;
1365             while (buf.cursor() &lt; buf.length()
1366                     &amp;&amp; nl &lt; 2
1367                     &amp;&amp; isWhitespace(buf.currChar())) {
1368                 buf.move(1);
1369                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1370             }
1371         }
1372         return true;
1373     }
1374 
1375     protected boolean viForwardBlankWord() {
1376         if (count &lt; 0) {
1377             return callNeg(this::viBackwardBlankWord);
1378         }
1379         while (count-- &gt; 0) {
1380             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWhitespace(buf.currChar())) {
1381                 buf.move(1);
1382             }
1383             if (isInViChangeOperation() &amp;&amp; count == 0) {
1384                 return true;
1385             }
1386             int nl = buf.currChar() == &#39;\n&#39; ? 1 : 0;
1387             while (buf.cursor() &lt; buf.length()
1388                     &amp;&amp; nl &lt; 2
1389                     &amp;&amp; isWhitespace(buf.currChar())) {
1390                 buf.move(1);
1391                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1392             }
1393         }
1394         return true;
1395     }
1396 
1397     protected boolean emacsForwardWord() {
1398         if (count &lt; 0) {
1399             return callNeg(this::emacsBackwardWord);
1400         }
1401         while (count-- &gt; 0) {
1402             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1403                 buf.move(1);
1404             }
1405             if (isInViChangeOperation() &amp;&amp; count == 0) {
1406                 return true;
1407             }
1408             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1409                 buf.move(1);
1410             }
1411         }
1412         return true;
1413     }
1414 
1415     protected boolean viForwardBlankWordEnd() {
1416         if (count &lt; 0) {
1417             return false;
1418         }
1419         while (count-- &gt; 0) {
1420             while (buf.cursor() &lt; buf.length()) {
1421                 buf.move(1);
1422                 if (!isWhitespace(buf.currChar())) {
1423                     break;
1424                 }
1425             }
1426             while (buf.cursor() &lt; buf.length()) {
1427                 buf.move(1);
1428                 if (isWhitespace(buf.currChar())) {
1429                     break;
1430                 }
1431             }
1432         }
1433         return true;
1434     }
1435 
1436     protected boolean viForwardWordEnd() {
1437         if (count &lt; 0) {
1438             return callNeg(this::backwardWord);
1439         }
1440         while (count-- &gt; 0) {
1441             while (buf.cursor() &lt; buf.length()) {
1442                 if (!isWhitespace(buf.nextChar())) {
1443                     break;
1444                 }
1445                 buf.move(1);
1446             }
1447             if (buf.cursor() &lt; buf.length()) {
1448                 if (isViAlphaNum(buf.nextChar())) {
1449                     buf.move(1);
1450                     while (buf.cursor() &lt; buf.length() &amp;&amp; isViAlphaNum(buf.nextChar())) {
1451                         buf.move(1);
1452                     }
1453                 } else {
1454                     buf.move(1);
1455                     while (buf.cursor() &lt; buf.length() &amp;&amp; !isViAlphaNum(buf.nextChar()) &amp;&amp; !isWhitespace(buf.nextChar())) {
1456                         buf.move(1);
1457                     }
1458                 }
1459             }
1460         }
1461         if (buf.cursor() &lt; buf.length() &amp;&amp; isInViMoveOperation()) {
1462             buf.move(1);
1463         }
1464         return true;
1465     }
1466 
1467     protected boolean backwardWord() {
1468         if (count &lt; 0) {
1469             return callNeg(this::forwardWord);
1470         }
1471         while (count-- &gt; 0) {
1472             while (buf.cursor() &gt; 0 &amp;&amp; !isWord(buf.atChar(buf.cursor() - 1))) {
1473                 buf.move(-1);
1474             }
1475             while (buf.cursor() &gt; 0 &amp;&amp; isWord(buf.atChar(buf.cursor() - 1))) {
1476                 buf.move(-1);
1477             }
1478         }
1479         return true;
1480     }
1481 
1482     protected boolean viBackwardWord() {
1483         if (count &lt; 0) {
1484             return callNeg(this::backwardWord);
1485         }
1486         while (count-- &gt; 0) {
1487             int nl = 0;
1488             while (buf.cursor() &gt; 0) {
1489                 buf.move(-1);
1490                 if (!isWhitespace(buf.currChar())) {
1491                     break;
1492                 }
1493                 nl += buf.currChar() == &#39;\n&#39; ? 1 : 0;
1494                 if (nl == 2) {
1495                     buf.move(1);
1496                     break;
1497                 }
1498             }
1499             if (buf.cursor() &gt; 0) {
1500                 if (isViAlphaNum(buf.currChar())) {
1501                     while (buf.cursor() &gt; 0) {
1502                         if (!isViAlphaNum(buf.prevChar())) {
1503                             break;
1504                         }
1505                         buf.move(-1);
1506                     }
1507                 } else {
1508                     while (buf.cursor() &gt; 0) {
1509                         if (isViAlphaNum(buf.prevChar()) || isWhitespace(buf.prevChar())) {
1510                             break;
1511                         }
1512                         buf.move(-1);
1513                     }
1514                 }
1515             }
1516         }
1517         return true;
1518     }
1519 
1520     protected boolean viBackwardBlankWord() {
1521         if (count &lt; 0) {
1522             return callNeg(this::viForwardBlankWord);
1523         }
1524         while (count-- &gt; 0) {
1525             while (buf.cursor() &gt; 0) {
1526                 buf.move(-1);
1527                 if (!isWhitespace(buf.currChar())) {
1528                     break;
1529                 }
1530             }
1531             while (buf.cursor() &gt; 0) {
1532                 buf.move(-1);
1533                 if (isWhitespace(buf.currChar())) {
1534                     break;
1535                 }
1536             }
1537         }
1538         return true;
1539     }
1540 
1541     protected boolean viBackwardWordEnd() {
1542         if (count &lt; 0) {
1543             return callNeg(this::viForwardWordEnd);
1544         }
1545         while (count-- &gt; 0 &amp;&amp; buf.cursor() &gt; 1) {
1546             int start;
1547             if (isViAlphaNum(buf.currChar())) {
1548                 start = 1;
1549             } else if (!isWhitespace(buf.currChar())) {
1550                 start = 2;
1551             } else {
1552                 start = 0;
1553             }
1554             while (buf.cursor() &gt; 0) {
1555                 boolean same = (start != 1) &amp;&amp; isWhitespace(buf.currChar());
1556                 if (start != 0) {
1557                     same |= isViAlphaNum(buf.currChar());
1558                 }
1559                 if (same == (start == 2)) {
1560                     break;
1561                 }
1562                 buf.move(-1);
1563             }
1564             while (buf.cursor() &gt; 0 &amp;&amp; isWhitespace(buf.currChar())) {
1565                 buf.move(-1);
1566             }
1567         }
1568         return true;
1569     }
1570 
1571     protected boolean viBackwardBlankWordEnd() {
1572         if (count &lt; 0) {
1573             return callNeg(this::viForwardBlankWordEnd);
1574         }
1575         while (count-- &gt; 0) {
1576             while (buf.cursor() &gt; 0 &amp;&amp; !isWhitespace(buf.currChar())) {
1577                 buf.move(-1);
1578             }
1579             while (buf.cursor() &gt; 0 &amp;&amp; isWhitespace(buf.currChar())) {
1580                 buf.move(-1);
1581             }
1582         }
1583         return true;
1584     }
1585 
1586     protected boolean emacsBackwardWord() {
1587         if (count &lt; 0) {
1588             return callNeg(this::emacsForwardWord);
1589         }
1590         while (count-- &gt; 0) {
1591             while (buf.cursor() &gt; 0) {
1592                 buf.move(-1);
1593                 if (isWord(buf.currChar())) {
1594                     break;
1595                 }
1596             }
1597             while (buf.cursor() &gt; 0) {
1598                 buf.move(-1);
1599                 if (!isWord(buf.currChar())) {
1600                     break;
1601                 }
1602             }
1603         }
1604         return true;
1605     }
1606 
1607     protected boolean backwardDeleteWord() {
1608         if (count &lt; 0) {
1609             return callNeg(this::deleteWord);
1610         }
1611         int cursor = buf.cursor();
1612         while (count-- &gt; 0) {
1613             while (cursor &gt; 0 &amp;&amp; !isWord(buf.atChar(cursor - 1))) {
1614                 cursor--;
1615             }
1616             while (cursor &gt; 0 &amp;&amp; isWord(buf.atChar(cursor - 1))) {
1617                 cursor--;
1618             }
1619         }
1620         buf.backspace(buf.cursor() - cursor);
1621         return true;
1622     }
1623 
1624     protected boolean viBackwardKillWord() {
1625         if (count &lt; 0) {
1626             return false;
1627         }
1628         int lim = findbol();
1629         int x = buf.cursor();
1630         while (count-- &gt; 0) {
1631             while (x &gt; lim &amp;&amp; isWhitespace(buf.atChar(x - 1))) {
1632                 x--;
1633             }
1634             if (x &gt; lim) {
1635                 if (isViAlphaNum(buf.atChar(x - 1))) {
1636                     while (x &gt; lim &amp;&amp; isViAlphaNum(buf.atChar(x - 1))) {
1637                         x--;
1638                     }
1639                 } else {
1640                     while (x &gt; lim &amp;&amp; !isViAlphaNum(buf.atChar(x - 1)) &amp;&amp; !isWhitespace(buf.atChar(x - 1))) {
1641                         x--;
1642                     }
1643                 }
1644             }
1645         }
1646         killRing.addBackwards(buf.substring(x, buf.cursor()));
1647         buf.backspace(buf.cursor() - x);
1648         return true;
1649     }
1650 
1651     protected boolean backwardKillWord() {
1652         if (count &lt; 0) {
1653             return callNeg(this::killWord);
1654         }
1655         int x = buf.cursor();
1656         while (count-- &gt; 0) {
1657             while (x &gt; 0 &amp;&amp; !isWord(buf.atChar(x - 1))) {
1658                 x--;
1659             }
1660             while (x &gt; 0 &amp;&amp; isWord(buf.atChar(x - 1))) {
1661                 x--;
1662             }
1663         }
1664         killRing.addBackwards(buf.substring(x, buf.cursor()));
1665         buf.backspace(buf.cursor() - x);
1666         return true;
1667     }
1668 
1669     protected boolean copyPrevWord() {
1670         if (count &lt;= 0) {
1671             return false;
1672         }
1673         int t1, t0 = buf.cursor();
1674         while (true) {
1675             t1 = t0;
1676             while (t0 &gt; 0 &amp;&amp; !isWord(buf.atChar(t0 - 1))) {
1677                 t0--;
1678             }
1679             while (t0 &gt; 0 &amp;&amp; isWord(buf.atChar(t0 - 1))) {
1680                 t0--;
1681             }
1682             if (--count == 0) {
1683                 break;
1684             }
1685             if (t0 == 0) {
1686                 return false;
1687             }
1688         }
1689         buf.write(buf.substring(t0, t1));
1690         return true;
1691     }
1692 
1693     protected boolean upCaseWord() {
1694         int count = Math.abs(this.count);
1695         int cursor = buf.cursor();
1696         while (count-- &gt; 0) {
1697             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1698                 buf.move(1);
1699             }
1700             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1701                 buf.currChar(Character.toUpperCase(buf.currChar()));
1702                 buf.move(1);
1703             }
1704         }
1705         if (this.count &lt; 0) {
1706             buf.cursor(cursor);
1707         }
1708         return true;
1709     }
1710 
1711     protected boolean downCaseWord() {
1712         int count = Math.abs(this.count);
1713         int cursor = buf.cursor();
1714         while (count-- &gt; 0) {
1715             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1716                 buf.move(1);
1717             }
1718             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1719                 buf.currChar(Character.toLowerCase(buf.currChar()));
1720                 buf.move(1);
1721             }
1722         }
1723         if (this.count &lt; 0) {
1724             buf.cursor(cursor);
1725         }
1726         return true;
1727     }
1728 
1729     protected boolean capitalizeWord() {
1730         int count = Math.abs(this.count);
1731         int cursor = buf.cursor();
1732         while (count-- &gt; 0) {
1733             boolean first = true;
1734             while (buf.cursor() &lt; buf.length() &amp;&amp; !isWord(buf.currChar())) {
1735                 buf.move(1);
1736             }
1737             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar()) &amp;&amp; !isAlpha(buf.currChar())) {
1738                 buf.move(1);
1739             }
1740             while (buf.cursor() &lt; buf.length() &amp;&amp; isWord(buf.currChar())) {
1741                 buf.currChar(first
1742                         ? Character.toUpperCase(buf.currChar())
1743                         : Character.toLowerCase(buf.currChar()));
1744                 buf.move(1);
1745                 first = false;
1746             }
1747         }
1748         if (this.count &lt; 0) {
1749             buf.cursor(cursor);
1750         }
1751         return true;
1752     }
1753 
1754     protected boolean deleteWord() {
1755         if (count &lt; 0) {
1756             return callNeg(this::backwardDeleteWord);
1757         }
1758         int x = buf.cursor();
1759         while (count-- &gt; 0) {
1760             while (x &lt; buf.length() &amp;&amp; !isWord(buf.atChar(x))) {
1761                 x++;
1762             }
1763             while (x &lt; buf.length() &amp;&amp; isWord(buf.atChar(x))) {
1764                 x++;
1765             }
1766         }
1767         buf.delete(x - buf.cursor());
1768         return true;
1769     }
1770 
1771     protected boolean killWord() {
1772         if (count &lt; 0) {
1773             return callNeg(this::backwardKillWord);
1774         }
1775         int x = buf.cursor();
1776         while (count-- &gt; 0) {
1777             while (x &lt; buf.length() &amp;&amp; !isWord(buf.atChar(x))) {
1778                 x++;
1779             }
1780             while (x &lt; buf.length() &amp;&amp; isWord(buf.atChar(x))) {
1781                 x++;
1782             }
1783         }
1784         killRing.add(buf.substring(buf.cursor(), x));
1785         buf.delete(x - buf.cursor());
1786         return true;
1787     }
1788 
1789     protected boolean transposeWords() {
1790         int lstart = buf.cursor() - 1;
1791         int lend = buf.cursor();
1792         while (buf.atChar(lstart) != 0 &amp;&amp; buf.atChar(lstart) != &#39;\n&#39;) {
1793             lstart--;
1794         }
1795         lstart++;
1796         while (buf.atChar(lend) != 0 &amp;&amp; buf.atChar(lend) != &#39;\n&#39;) {
1797             lend++;
1798         }
1799         if (lend - lstart &lt; 2) {
1800             return false;
1801         }
1802         int words = 0;
1803         boolean inWord = false;
1804         if (!isDelimiter(buf.atChar(lstart))) {
1805             words++;
1806             inWord = true;
1807         }
1808         for (int i = lstart; i &lt; lend; i++) {
1809             if (isDelimiter(buf.atChar(i))) {
1810                 inWord = false;
1811             } else {
1812                 if (!inWord) {
1813                     words++;
1814                 }
1815                 inWord = true;
1816             }
1817         }
1818         if (words &lt; 2) {
1819             return false;
1820         }
1821         // TODO: use isWord instead of isDelimiter
1822         boolean neg = this.count &lt; 0;
1823         for (int count = Math.max(this.count, -this.count); count &gt; 0; --count) {
1824             int sta1, end1, sta2, end2;
1825             // Compute current word boundaries
1826             sta1 = buf.cursor();
1827             while (sta1 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta1 - 1))) {
1828                 sta1--;
1829             }
1830             end1 = sta1;
1831             while (end1 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end1)));
1832             if (neg) {
1833                 end2 = sta1 - 1;
1834                 while (end2 &gt; lstart &amp;&amp; isDelimiter(buf.atChar(end2 - 1))) {
1835                     end2--;
1836                 }
1837                 if (end2 &lt; lstart) {
1838                     // No word before, use the word after
1839                     sta2 = end1;
1840                     while (isDelimiter(buf.atChar(++sta2)));
1841                     end2 = sta2;
1842                     while (end2 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end2)));
1843                 } else {
1844                     sta2 = end2;
1845                     while (sta2 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta2 - 1))) {
1846                         sta2--;
1847                     }
1848                 }
1849             } else {
1850                 sta2 = end1;
1851                 while (sta2 &lt; lend &amp;&amp; isDelimiter(buf.atChar(++sta2)));
1852                 if (sta2 == lend) {
1853                     // No word after, use the word before
1854                     end2 = sta1;
1855                     while (isDelimiter(buf.atChar(end2 - 1))) {
1856                         end2--;
1857                     }
1858                     sta2 = end2;
1859                     while (sta2 &gt; lstart &amp;&amp; !isDelimiter(buf.atChar(sta2 - 1))) {
1860                         sta2--;
1861                     }
1862                 } else {
1863                     end2 = sta2;
1864                     while (end2 &lt; lend &amp;&amp; !isDelimiter(buf.atChar(++end2))) ;
1865                 }
1866             }
1867             if (sta1 &lt; sta2) {
1868                 String res = buf.substring(0, sta1) + buf.substring(sta2, end2)
1869                         + buf.substring(end1, sta2) + buf.substring(sta1, end1)
1870                         + buf.substring(end2);
1871                 buf.clear();
1872                 buf.write(res);
1873                 buf.cursor(neg ? end1 : end2);
1874             } else {
1875                 String res = buf.substring(0, sta2) + buf.substring(sta1, end1)
1876                         + buf.substring(end2, sta1) + buf.substring(sta2, end2)
1877                         + buf.substring(end1);
1878                 buf.clear();
1879                 buf.write(res);
1880                 buf.cursor(neg ? end2 : end1);
1881             }
1882         }
1883         return true;
1884     }
1885 
1886     private int findbol() {
1887         int x = buf.cursor();
1888         while (x &gt; 0 &amp;&amp; buf.atChar(x - 1) != &#39;\n&#39;) {
1889             x--;
1890         }
1891         return x;
1892     }
1893 
1894     private int findeol() {
1895         int x = buf.cursor();
1896         while (x &lt; buf.length() &amp;&amp; buf.atChar(x) != &#39;\n&#39;) {
1897             x++;
1898         }
1899         return x;
1900     }
1901 
1902     protected boolean insertComment() {
1903         return doInsertComment(false);
1904     }
1905 
1906     protected boolean viInsertComment() {
1907         return doInsertComment(true);
1908     }
1909 
1910     protected boolean doInsertComment(boolean isViMode) {
1911         String comment = getString(COMMENT_BEGIN, DEFAULT_COMMENT_BEGIN);
1912         beginningOfLine();
1913         putString(comment);
1914         if (isViMode) {
1915             setKeyMap(VIINS);
1916         }
1917         return acceptLine();
1918     }
1919 
1920     protected boolean viFindNextChar() {
1921         if ((findChar = vigetkey()) &gt; 0) {
1922             findDir = 1;
1923             findTailAdd = 0;
1924             return vifindchar(false);
1925         }
1926         return false;
1927     }
1928 
1929     protected boolean viFindPrevChar() {
1930         if ((findChar = vigetkey()) &gt; 0) {
1931             findDir = -1;
1932             findTailAdd = 0;
1933             return vifindchar(false);
1934         }
1935         return false;
1936     }
1937 
1938     protected boolean viFindNextCharSkip() {
1939         if ((findChar = vigetkey()) &gt; 0) {
1940             findDir = 1;
1941             findTailAdd = -1;
1942             return vifindchar(false);
1943         }
1944         return false;
1945     }
1946 
1947     protected boolean viFindPrevCharSkip() {
1948         if ((findChar = vigetkey()) &gt; 0) {
1949             findDir = -1;
1950             findTailAdd = 1;
1951             return vifindchar(false);
1952         }
1953         return false;
1954     }
1955 
1956     protected boolean viRepeatFind() {
1957         return vifindchar(true);
1958     }
1959 
1960     protected boolean viRevRepeatFind() {
1961         if (count &lt; 0) {
1962             return callNeg(() -&gt; vifindchar(true));
1963         }
1964         findTailAdd = -findTailAdd;
1965         findDir = -findDir;
1966         boolean ret = vifindchar(true);
1967         findTailAdd = -findTailAdd;
1968         findDir = -findDir;
1969         return ret;
1970     }
1971 
1972     private int vigetkey() {
1973         int ch = readCharacter();
1974         KeyMap&lt;Binding&gt; km = keyMaps.get(MAIN);
1975         if (km != null) {
1976             Binding b = km.getBound(new String(Character.toChars(ch)));
1977             if (b instanceof Reference) {
1978                 String func = ((Reference) b).name();
1979                 if (SEND_BREAK.equals(func)) {
1980                     return -1;
1981                 }
1982             }
1983         }
1984         return ch;
1985     }
1986 
1987     private boolean vifindchar(boolean repeat) {
1988         if (findDir == 0) {
1989             return false;
1990         }
1991         if (count &lt; 0) {
1992             return callNeg(this::viRevRepeatFind);
1993         }
1994         if (repeat &amp;&amp; findTailAdd != 0) {
1995             if (findDir &gt; 0) {
1996                 if (buf.cursor() &lt; buf.length() &amp;&amp; buf.nextChar() == findChar) {
1997                     buf.move(1);
1998                 }
1999             } else {
2000                 if (buf.cursor() &gt; 0 &amp;&amp; buf.prevChar() == findChar) {
2001                     buf.move(-1);
2002                 }
2003             }
2004         }
2005         int cursor = buf.cursor();
2006         while (count-- &gt; 0) {
2007             do {
2008                 buf.move(findDir);
2009             } while (buf.cursor() &gt; 0 &amp;&amp; buf.cursor() &lt; buf.length()
2010                     &amp;&amp; buf.currChar() != findChar
2011                     &amp;&amp; buf.currChar() != &#39;\n&#39;);
2012             if (buf.cursor() &lt;= 0 || buf.cursor() &gt;= buf.length()
2013                     || buf.currChar() == &#39;\n&#39;) {
2014                 buf.cursor(cursor);
2015                 return false;
2016             }
2017         }
2018         if (findTailAdd != 0) {
2019             buf.move(findTailAdd);
2020         }
2021         if (findDir == 1 &amp;&amp; isInViMoveOperation()) {
2022             buf.move(1);
2023         }
2024         return true;
2025     }
2026 
2027     private boolean callNeg(Widget widget) {
2028         this.count = -this.count;
2029         boolean ret = widget.apply();
2030         this.count = -this.count;
2031         return ret;
2032     }
2033 
2034     /**
2035      * Implements vi search (&quot;/&quot; or &quot;?&quot;).
2036      *
2037      * @return &lt;code&gt;true&lt;/code&gt; if the search was successful
2038      */
2039     protected boolean viHistorySearchForward() {
2040         searchDir = 1;
2041         searchIndex = 0;
2042         return getViSearchString() &amp;&amp; viRepeatSearch();
2043     }
2044 
2045     protected boolean viHistorySearchBackward() {
2046         searchDir = -1;
2047         searchIndex = history.size() - 1;
2048         return getViSearchString() &amp;&amp; viRepeatSearch();
2049     }
2050 
2051     protected boolean viRepeatSearch() {
2052         if (searchDir == 0) {
2053             return false;
2054         }
2055         int si = searchDir &lt; 0
2056                 ? searchBackwards(searchString, searchIndex, false)
2057                 : searchForwards(searchString, searchIndex, false);
2058         if (si == -1 || si == history.index()) {
2059             return false;
2060         }
2061         searchIndex = si;
2062 
2063         /*
2064          * Show the match.
2065          */
2066         buf.clear();
2067         history.moveTo(searchIndex);
2068         buf.write(history.get(searchIndex));
2069         if (VICMD.equals(keyMap)) {
2070             buf.move(-1);
2071         }
2072         return true;
2073     }
2074 
2075     protected boolean viRevRepeatSearch() {
2076         boolean ret;
2077         searchDir = -searchDir;
2078         ret = viRepeatSearch();
2079         searchDir = -searchDir;
2080         return ret;
2081     }
2082 
2083     private boolean getViSearchString() {
2084         if (searchDir == 0) {
2085             return false;
2086         }
2087         String searchPrompt = searchDir &lt; 0 ? &quot;?&quot; : &quot;/&quot;;
2088         Buffer searchBuffer = new BufferImpl();
2089 
2090         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MAIN);
2091         if (keyMap == null) {
2092             keyMap = keyMaps.get(SAFE);
2093         }
2094         while (true) {
2095             post = () -&gt; new AttributedString(searchPrompt + searchBuffer.toString() + &quot;_&quot;);
2096             redisplay();
2097             Binding b = doReadBinding(keyMap, null);
2098             if (b instanceof Reference) {
2099                 String func = ((Reference) b).name();
2100                 switch (func) {
2101                     case SEND_BREAK:
2102                         post = null;
2103                         return false;
2104                     case ACCEPT_LINE:
2105                     case VI_CMD_MODE:
2106                         searchString = searchBuffer.toString();
2107                         post = null;
2108                         return true;
2109                     case MAGIC_SPACE:
2110                         searchBuffer.write(&#39; &#39;);
2111                         break;
2112                     case REDISPLAY:
2113                         redisplay();
2114                         break;
2115                     case CLEAR_SCREEN:
2116                         clearScreen();
2117                         break;
2118                     case SELF_INSERT:
2119                         searchBuffer.write(getLastBinding());
2120                         break;
2121                     case SELF_INSERT_UNMETA:
2122                         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
2123                             String s = getLastBinding().substring(1);
2124                             if (&quot;\r&quot;.equals(s)) {
2125                                 s = &quot;\n&quot;;
2126                             }
2127                             searchBuffer.write(s);
2128                         }
2129                         break;
2130                     case BACKWARD_DELETE_CHAR:
2131                     case VI_BACKWARD_DELETE_CHAR:
2132                         if (searchBuffer.length() &gt; 0) {
2133                             searchBuffer.backspace();
2134                         }
2135                         break;
2136                     case BACKWARD_KILL_WORD:
2137                     case VI_BACKWARD_KILL_WORD:
2138                         if (searchBuffer.length() &gt; 0 &amp;&amp; !isWhitespace(searchBuffer.prevChar())) {
2139                             searchBuffer.backspace();
2140                         }
2141                         if (searchBuffer.length() &gt; 0 &amp;&amp; isWhitespace(searchBuffer.prevChar())) {
2142                             searchBuffer.backspace();
2143                         }
2144                         break;
2145                     case QUOTED_INSERT:
2146                     case VI_QUOTED_INSERT:
2147                         int c = readCharacter();
2148                         if (c &gt;= 0) {
2149                             searchBuffer.write(c);
2150                         } else {
2151                             beep();
2152                         }
2153                         break;
2154                     default:
2155                         beep();
2156                         break;
2157                 }
2158             }
2159         }
2160     }
2161 
2162     protected boolean insertCloseCurly() {
2163         return insertClose(&quot;}&quot;);
2164     }
2165 
2166     protected boolean insertCloseParen() {
2167         return insertClose(&quot;)&quot;);
2168     }
2169 
2170     protected boolean insertCloseSquare() {
2171         return insertClose(&quot;]&quot;);
2172     }
2173 
2174     protected boolean insertClose(String s) {
2175         putString(s);
2176 
2177         long blink = getLong(BLINK_MATCHING_PAREN, DEFAULT_BLINK_MATCHING_PAREN);
2178         if (blink &lt;= 0) {
<a name="26" id="anc26"></a><span class="line-added">2179             removeIndentation();</span>
2180             return true;
2181         }
2182 
2183         int closePosition = buf.cursor();
2184 
2185         buf.move(-1);
2186         doViMatchBracket();
2187         redisplay();
2188 
2189         peekCharacter(blink);
<a name="27" id="anc27"></a><span class="line-modified">2190         int blinkPosition = buf.cursor();</span>
2191         buf.cursor(closePosition);
<a name="28" id="anc28"></a><span class="line-added">2192 </span>
<span class="line-added">2193         if (blinkPosition != closePosition - 1) {</span>
<span class="line-added">2194             removeIndentation();</span>
<span class="line-added">2195         }</span>
2196         return true;
2197     }
2198 
<a name="29" id="anc29"></a><span class="line-added">2199     private void removeIndentation() {</span>
<span class="line-added">2200         int indent = getInt(INDENTATION, DEFAULT_INDENTATION);</span>
<span class="line-added">2201         if (indent &gt; 0) {</span>
<span class="line-added">2202             buf.move(-1);</span>
<span class="line-added">2203             for (int i = 0; i &lt; indent; i++) {</span>
<span class="line-added">2204                 buf.move(-1);</span>
<span class="line-added">2205                 if (buf.currChar() == &#39; &#39;) {</span>
<span class="line-added">2206                     buf.delete();</span>
<span class="line-added">2207                 } else {</span>
<span class="line-added">2208                     buf.move(1);</span>
<span class="line-added">2209                     break;</span>
<span class="line-added">2210                 }</span>
<span class="line-added">2211             }</span>
<span class="line-added">2212             buf.move(1);</span>
<span class="line-added">2213         }</span>
<span class="line-added">2214     }</span>
<span class="line-added">2215 </span>
2216     protected boolean viMatchBracket() {
2217         return doViMatchBracket();
2218     }
2219 
2220     protected boolean undefinedKey() {
2221         return false;
2222     }
2223 
2224     /**
2225      * Implements vi style bracket matching (&quot;%&quot; command). The matching
2226      * bracket for the current bracket type that you are sitting on is matched.
2227      *
2228      * @return true if it worked, false if the cursor was not on a bracket
2229      *   character or if there was no matching bracket.
2230      */
2231     protected boolean doViMatchBracket() {
2232         int pos        = buf.cursor();
2233 
2234         if (pos == buf.length()) {
2235             return false;
2236         }
2237 
2238         int type       = getBracketType(buf.atChar(pos));
2239         int move       = (type &lt; 0) ? -1 : 1;
2240         int count      = 1;
2241 
2242         if (type == 0)
2243             return false;
2244 
2245         while (count &gt; 0) {
2246             pos += move;
2247 
2248             // Fell off the start or end.
2249             if (pos &lt; 0 || pos &gt;= buf.length()) {
2250                 return false;
2251             }
2252 
2253             int curType = getBracketType(buf.atChar(pos));
2254             if (curType == type) {
2255                 ++count;
2256             }
2257             else if (curType == -type) {
2258                 --count;
2259             }
2260         }
2261 
2262         /*
2263          * Slight adjustment for delete-to, yank-to, change-to to ensure
2264          * that the matching paren is consumed
2265          */
2266         if (move &gt; 0 &amp;&amp; isInViMoveOperation())
2267             ++pos;
2268 
2269         buf.cursor(pos);
2270         return true;
2271     }
2272 
2273     /**
2274      * Given a character determines what type of bracket it is (paren,
2275      * square, curly, or none).
2276      * @param ch The character to check
2277      * @return 1 is square, 2 curly, 3 parent, or zero for none.  The value
2278      *   will be negated if it is the closing form of the bracket.
2279      */
2280     protected int getBracketType (int ch) {
2281         switch (ch) {
2282             case &#39;[&#39;: return  1;
2283             case &#39;]&#39;: return -1;
2284             case &#39;{&#39;: return  2;
2285             case &#39;}&#39;: return -2;
2286             case &#39;(&#39;: return  3;
2287             case &#39;)&#39;: return -3;
2288             default:
2289                 return 0;
2290         }
2291     }
2292 
2293     /**
2294      * Performs character transpose. The character prior to the cursor and the
2295      * character under the cursor are swapped and the cursor is advanced one.
2296      * Do not cross line breaks.
2297      * @return true
2298      */
2299     protected boolean transposeChars() {
2300         int lstart = buf.cursor() - 1;
2301         int lend = buf.cursor();
2302         while (buf.atChar(lstart) != 0 &amp;&amp; buf.atChar(lstart) != &#39;\n&#39;) {
2303             lstart--;
2304         }
2305         lstart++;
2306         while (buf.atChar(lend) != 0 &amp;&amp; buf.atChar(lend) != &#39;\n&#39;) {
2307             lend++;
2308         }
2309         if (lend - lstart &lt; 2) {
2310             return false;
2311         }
2312         boolean neg = this.count &lt; 0;
2313         for (int count = Math.max(this.count, -this.count); count &gt; 0; --count) {
2314             while (buf.cursor() &lt;= lstart) {
2315                 buf.move(1);
2316             }
2317             while (buf.cursor() &gt;= lend) {
2318                 buf.move(-1);
2319             }
2320             int c = buf.currChar();
2321             buf.currChar(buf.prevChar());
2322             buf.move(-1);
2323             buf.currChar(c);
2324             buf.move(neg ? 0 : 2);
2325         }
2326         return true;
2327     }
2328 
2329     protected boolean undo() {
2330         isUndo = true;
2331         if (undo.canUndo()) {
2332             undo.undo();
2333             return true;
2334         }
2335         return false;
2336     }
2337 
2338     protected boolean redo() {
2339         isUndo = true;
2340         if (undo.canRedo()) {
2341             undo.redo();
2342             return true;
2343         }
2344         return false;
2345     }
2346 
2347     protected boolean sendBreak() {
2348         if (searchTerm == null) {
2349             buf.clear();
2350             println();
2351             redrawLine();
2352 //            state = State.INTERRUPT;
2353             return false;
2354         }
2355         return true;
2356     }
2357 
2358     protected boolean backwardChar() {
2359         return buf.move(-count) != 0;
2360     }
2361 
2362     protected boolean forwardChar() {
2363         return buf.move(count) != 0;
2364     }
2365 
2366     protected boolean viDigitOrBeginningOfLine() {
2367         if (repeatCount &gt; 0) {
2368             return digitArgument();
2369         } else {
2370             return beginningOfLine();
2371         }
2372     }
2373 
2374     protected boolean universalArgument() {
2375         mult *= universal;
2376         isArgDigit = true;
2377         return true;
2378     }
2379 
2380     protected boolean argumentBase() {
2381         if (repeatCount &gt; 0 &amp;&amp; repeatCount &lt; 32) {
2382             universal = repeatCount;
2383             isArgDigit = true;
2384             return true;
2385         } else {
2386             return false;
2387         }
2388     }
2389 
2390     protected boolean negArgument() {
2391         mult *= -1;
2392         isArgDigit = true;
2393         return true;
2394     }
2395 
2396     protected boolean digitArgument() {
2397         String s = getLastBinding();
2398         repeatCount = (repeatCount * 10) + s.charAt(s.length() - 1) - &#39;0&#39;;
2399         isArgDigit = true;
2400         return true;
2401     }
2402 
2403     protected boolean viDelete() {
2404         int cursorStart = buf.cursor();
2405         Binding o = readBinding(getKeys());
2406         if (o instanceof Reference) {
2407             // TODO: be smarter on how to get the vi range
2408             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2409             // This is a weird special case. In vi
2410             // &quot;dd&quot; deletes the current line. So if we
2411             // get a delete-to, followed by a delete-to,
2412             // we delete the line.
2413             if (VI_DELETE.equals(op)) {
2414                 killWholeLine();
2415             } else {
2416                 viMoveMode = ViMoveMode.DELETE;
2417                 Widget widget = widgets.get(op);
2418                 if (widget != null &amp;&amp; !widget.apply()) {
2419                     viMoveMode = ViMoveMode.NORMAL;
2420                     return false;
2421                 }
2422                 viMoveMode = ViMoveMode.NORMAL;
2423             }
2424             return viDeleteTo(cursorStart, buf.cursor());
2425         } else {
2426             pushBackBinding();
2427             return false;
2428         }
2429     }
2430 
2431     protected boolean viYankTo() {
2432         int cursorStart = buf.cursor();
2433         Binding o = readBinding(getKeys());
2434         if (o instanceof Reference) {
2435             // TODO: be smarter on how to get the vi range
2436             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2437             // Similar to delete-to, a &quot;yy&quot; yanks the whole line.
2438             if (VI_YANK.equals(op)) {
2439                 yankBuffer = buf.toString();
2440                 return true;
2441             } else {
2442                 viMoveMode = ViMoveMode.YANK;
2443                 Widget widget = widgets.get(op);
2444                 if (widget != null &amp;&amp; !widget.apply()) {
2445                     return false;
2446                 }
2447                 viMoveMode = ViMoveMode.NORMAL;
2448             }
2449             return viYankTo(cursorStart, buf.cursor());
2450         } else {
2451             pushBackBinding();
2452             return false;
2453         }
2454     }
2455 
2456     protected boolean viYankWholeLine() {
2457         int s, e;
2458         int p = buf.cursor();
2459         while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2460         s = buf.cursor();
2461         for (int i = 0; i &lt; repeatCount; i++) {
2462             while (buf.move(1) == 1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
2463         }
2464         e = buf.cursor();
2465         yankBuffer = buf.substring(s, e);
2466         if (!yankBuffer.endsWith(&quot;\n&quot;)) {
2467             yankBuffer += &quot;\n&quot;;
2468         }
2469         buf.cursor(p);
2470         return true;
2471     }
2472 
2473     protected boolean viChange() {
2474         int cursorStart = buf.cursor();
2475         Binding o = readBinding(getKeys());
2476         if (o instanceof Reference) {
2477             // TODO: be smarter on how to get the vi range
2478             String op = viDeleteChangeYankToRemap(((Reference) o).name());
2479             // change whole line
2480             if (VI_CHANGE.equals(op)) {
2481                 killWholeLine();
2482             } else {
2483                 viMoveMode = ViMoveMode.CHANGE;
2484                 Widget widget = widgets.get(op);
2485                 if (widget != null &amp;&amp; !widget.apply()) {
2486                     viMoveMode = ViMoveMode.NORMAL;
2487                     return false;
2488                 }
2489                 viMoveMode = ViMoveMode.NORMAL;
2490             }
2491             boolean res = viChange(cursorStart, buf.cursor());
2492             setKeyMap(VIINS);
2493             return res;
2494         } else {
2495             pushBackBinding();
2496             return false;
2497         }
2498     }
2499 
2500     /*
2501     protected int getViRange(Reference cmd, ViMoveMode mode) {
2502         Buffer buffer = buf.copy();
2503         int oldMark = mark;
2504         int pos = buf.cursor();
2505         String bind = getLastBinding();
2506 
2507         if (visual != 0) {
2508             if (buf.length() == 0) {
2509                 return -1;
2510             }
2511             pos = mark;
2512             v
2513         } else {
2514             viMoveMode = mode;
2515             mark = -1;
2516             Binding b = doReadBinding(getKeys(), keyMaps.get(VIOPP));
2517             if (b == null || new Reference(SEND_BREAK).equals(b)) {
2518                 viMoveMode = ViMoveMode.NORMAL;
2519                 mark = oldMark;
2520                 return -1;
2521             }
2522             if (cmd.equals(b)) {
2523                 doViLineRange();
2524             }
2525             Widget w = getWidget(b);
2526             if (w )
2527             if (b instanceof Reference) {
2528 
2529             }
2530         }
2531 
2532     }
2533     */
2534 
2535     protected void cleanup() {
2536         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
2537             Buffer oldBuffer = buf.copy();
2538             AttributedString oldPrompt = prompt;
2539             buf.clear();
2540             prompt = new AttributedString(&quot;&quot;);
2541             doCleanup(false);
2542             prompt = oldPrompt;
2543             buf.copyFrom(oldBuffer);
2544         } else {
2545             doCleanup(true);
2546         }
2547     }
2548 
2549     protected void doCleanup(boolean nl) {
2550         buf.cursor(buf.length());
2551         post = null;
2552         if (size.getColumns() &gt; 0 || size.getRows() &gt; 0) {
<a name="30" id="anc30"></a><span class="line-added">2553             doAutosuggestion = false;</span>
2554             redisplay(false);
2555             if (nl) {
2556                 println();
2557             }
2558             terminal.puts(Capability.keypad_local);
2559             terminal.trackMouse(Terminal.MouseTracking.Off);
2560             if (isSet(Option.BRACKETED_PASTE))
2561                 terminal.writer().write(BRACKETED_PASTE_OFF);
2562             flush();
2563         }
2564         history.moveToEnd();
2565     }
2566 
2567     protected boolean historyIncrementalSearchForward() {
2568         return doSearchHistory(false);
2569     }
2570 
2571     protected boolean historyIncrementalSearchBackward() {
2572         return doSearchHistory(true);
2573     }
2574 
2575     static class Pair&lt;U,V&gt; {
2576         final U u; final V v;
2577         public Pair(U u, V v) {
2578             this.u = u;
2579             this.v = v;
2580         }
2581         public U getU() {
2582             return u;
2583         }
2584         public V getV() {
2585             return v;
2586         }
2587     }
2588 
2589     protected boolean doSearchHistory(boolean backward) {
2590         if (history.isEmpty()) {
2591             return false;
2592         }
2593 
2594         KeyMap&lt;Binding&gt; terminators = new KeyMap&lt;&gt;();
2595         getString(SEARCH_TERMINATORS, DEFAULT_SEARCH_TERMINATORS)
2596                 .codePoints().forEach(c -&gt; bind(terminators, ACCEPT_LINE, new String(Character.toChars(c))));
2597 
2598         Buffer originalBuffer = buf.copy();
2599         searchIndex = -1;
2600         searchTerm = new StringBuffer();
2601         searchBackward = backward;
2602         searchFailing = false;
2603         post = () -&gt; new AttributedString((searchFailing ? &quot;failing&quot; + &quot; &quot; : &quot;&quot;)
2604                         + (searchBackward ? &quot;bck-i-search&quot; : &quot;fwd-i-search&quot;)
2605                         + &quot;: &quot; + searchTerm + &quot;_&quot;);
2606 
2607         redisplay();
2608         try {
2609             while (true) {
2610                 int prevSearchIndex = searchIndex;
2611                 Binding operation = readBinding(getKeys(), terminators);
2612                 String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
2613                 boolean next = false;
2614                 switch (ref) {
2615                     case SEND_BREAK:
2616                         beep();
2617                         buf.copyFrom(originalBuffer);
2618                         return true;
2619                     case HISTORY_INCREMENTAL_SEARCH_BACKWARD:
2620                         searchBackward = true;
2621                         next = true;
2622                         break;
2623                     case HISTORY_INCREMENTAL_SEARCH_FORWARD:
2624                         searchBackward = false;
2625                         next = true;
2626                         break;
2627                     case BACKWARD_DELETE_CHAR:
2628                         if (searchTerm.length() &gt; 0) {
2629                             searchTerm.deleteCharAt(searchTerm.length() - 1);
2630                         }
2631                         break;
2632                     case SELF_INSERT:
2633                         searchTerm.append(getLastBinding());
2634                         break;
2635                     default:
2636                         // Set buffer and cursor position to the found string.
2637                         if (searchIndex != -1) {
2638                             history.moveTo(searchIndex);
2639                         }
2640                         pushBackBinding();
2641                         return true;
2642                 }
2643 
2644                 // print the search status
2645                 String pattern = doGetSearchPattern();
2646                 if (pattern.length() == 0) {
2647                     buf.copyFrom(originalBuffer);
2648                     searchFailing = false;
2649                 } else {
2650                     boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2651                     Pattern pat = Pattern.compile(pattern, caseInsensitive ? Pattern.CASE_INSENSITIVE | Pattern.UNICODE_CASE
2652                                                                            : Pattern.UNICODE_CASE);
2653                     Pair&lt;Integer, Integer&gt; pair = null;
2654                     if (searchBackward) {
2655                         boolean nextOnly = next;
2656                         pair = matches(pat, buf.toString(), searchIndex).stream()
2657                                 .filter(p -&gt; nextOnly ? p.v &lt; buf.cursor() : p.v &lt;= buf.cursor())
2658                                 .max(Comparator.comparing(Pair::getV))
2659                                 .orElse(null);
2660                         if (pair == null) {
2661                             pair = StreamSupport.stream(
2662                                     Spliterators.spliteratorUnknownSize(history.reverseIterator(searchIndex &lt; 0 ? history.last() : searchIndex - 1), Spliterator.ORDERED), false)
2663                                     .flatMap(e -&gt; matches(pat, e.line(), e.index()).stream())
2664                                     .findFirst()
2665                                     .orElse(null);
2666                         }
2667                     } else {
2668                         boolean nextOnly = next;
2669                         pair = matches(pat, buf.toString(), searchIndex).stream()
2670                                 .filter(p -&gt; nextOnly ? p.v &gt; buf.cursor() : p.v &gt;= buf.cursor())
2671                                 .min(Comparator.comparing(Pair::getV))
2672                                 .orElse(null);
2673                         if (pair == null) {
2674                             pair = StreamSupport.stream(
2675                                     Spliterators.spliteratorUnknownSize(history.iterator((searchIndex &lt; 0 ? history.last() : searchIndex) + 1), Spliterator.ORDERED), false)
2676                                     .flatMap(e -&gt; matches(pat, e.line(), e.index()).stream())
2677                                     .findFirst()
2678                                     .orElse(null);
2679                             if (pair == null &amp;&amp; searchIndex &gt;= 0) {
2680                                 pair = matches(pat, originalBuffer.toString(), -1).stream()
2681                                         .min(Comparator.comparing(Pair::getV))
2682                                         .orElse(null);
2683                             }
2684                         }
2685                     }
2686                     if (pair != null) {
2687                         searchIndex = pair.u;
2688                         buf.clear();
2689                         if (searchIndex &gt;= 0) {
2690                             buf.write(history.get(searchIndex));
2691                         } else {
2692                             buf.write(originalBuffer.toString());
2693                         }
2694                         buf.cursor(pair.v);
2695                         searchFailing = false;
2696                     } else {
2697                         searchFailing = true;
2698                         beep();
2699                     }
2700                 }
2701                 redisplay();
2702             }
2703         } catch (IOError e) {
2704             // Ignore Ctrl+C interrupts and just exit the loop
2705             if (!(e.getCause() instanceof InterruptedException)) {
2706                 throw e;
2707             }
2708             return true;
2709         } finally {
2710             searchTerm = null;
2711             searchIndex = -1;
2712             post = null;
2713         }
2714     }
2715 
2716     private List&lt;Pair&lt;Integer, Integer&gt;&gt; matches(Pattern p, String line, int index) {
2717         List&lt;Pair&lt;Integer, Integer&gt;&gt; starts = new ArrayList&lt;&gt;();
2718         Matcher m = p.matcher(line);
2719         while (m.find()) {
2720             starts.add(new Pair&lt;&gt;(index, m.start()));
2721         }
2722         return starts;
2723    }
2724 
2725     private String doGetSearchPattern() {
2726         StringBuilder sb = new StringBuilder();
2727         boolean inQuote = false;
2728         for (int i = 0; i &lt; searchTerm.length(); i++) {
2729             char c = searchTerm.charAt(i);
2730             if (Character.isLowerCase(c)) {
2731                 if (inQuote) {
2732                     sb.append(&quot;\\E&quot;);
2733                     inQuote = false;
2734                 }
2735                 sb.append(&quot;[&quot;).append(Character.toLowerCase(c)).append(Character.toUpperCase(c)).append(&quot;]&quot;);
2736             } else {
2737                 if (!inQuote) {
2738                     sb.append(&quot;\\Q&quot;);
2739                     inQuote = true;
2740                 }
2741                 sb.append(c);
2742             }
2743         }
2744         if (inQuote) {
2745             sb.append(&quot;\\E&quot;);
2746         }
2747         return sb.toString();
2748     }
2749 
2750     private void pushBackBinding() {
2751         pushBackBinding(false);
2752     }
2753 
2754     private void pushBackBinding(boolean skip) {
2755         String s = getLastBinding();
2756         if (s != null) {
2757             bindingReader.runMacro(s);
2758             skipRedisplay = skip;
2759         }
2760     }
2761 
2762     protected boolean historySearchForward() {
2763         if (historyBuffer == null || buf.length() == 0
2764                 || !buf.toString().equals(history.current())) {
2765             historyBuffer = buf.copy();
2766             searchBuffer = getFirstWord();
2767         }
2768         int index = history.index() + 1;
2769 
2770         if (index &lt; history.last() + 1) {
2771             int searchIndex = searchForwards(searchBuffer.toString(), index, true);
2772             if (searchIndex == -1) {
2773                 history.moveToEnd();
2774                 if (!buf.toString().equals(historyBuffer.toString())) {
2775                     setBuffer(historyBuffer.toString());
2776                     historyBuffer = null;
2777                 } else {
2778                     return false;
2779                 }
2780             } else {
2781                 // Maintain cursor position while searching.
2782                 if (history.moveTo(searchIndex)) {
2783                     setBuffer(history.current());
2784                 } else {
2785                     history.moveToEnd();
2786                     setBuffer(historyBuffer.toString());
2787                     return false;
2788                 }
2789             }
2790         } else {
2791             history.moveToEnd();
2792             if (!buf.toString().equals(historyBuffer.toString())) {
2793                 setBuffer(historyBuffer.toString());
2794                 historyBuffer = null;
2795             } else {
2796                 return false;
2797             }
2798         }
2799         return true;
2800     }
2801 
2802     private CharSequence getFirstWord() {
2803         String s = buf.toString();
2804         int i = 0;
2805         while (i &lt; s.length() &amp;&amp; !Character.isWhitespace(s.charAt(i))) {
2806             i++;
2807         }
2808         return s.substring(0, i);
2809     }
2810 
2811     protected boolean historySearchBackward() {
2812         if (historyBuffer == null || buf.length() == 0
2813                 || !buf.toString().equals(history.current())) {
2814             historyBuffer = buf.copy();
2815             searchBuffer = getFirstWord();
2816         }
2817         int searchIndex = searchBackwards(searchBuffer.toString(), history.index(), true);
2818 
2819         if (searchIndex == -1) {
2820             return false;
2821         } else {
2822             // Maintain cursor position while searching.
2823             if (history.moveTo(searchIndex)) {
2824                 setBuffer(history.current());
2825             } else {
2826                 return false;
2827             }
2828         }
2829         return true;
2830     }
2831 
2832     //
2833     // History search
2834     //
2835     /**
2836      * Search backward in history from a given position.
2837      *
2838      * @param searchTerm substring to search for.
2839      * @param startIndex the index from which on to search
2840      * @return index where this substring has been found, or -1 else.
2841      */
2842     public int searchBackwards(String searchTerm, int startIndex) {
2843         return searchBackwards(searchTerm, startIndex, false);
2844     }
2845 
2846     /**
2847      * Search backwards in history from the current position.
2848      *
2849      * @param searchTerm substring to search for.
2850      * @return index where the substring has been found, or -1 else.
2851      */
2852     public int searchBackwards(String searchTerm) {
2853         return searchBackwards(searchTerm, history.index(), false);
2854     }
2855 
2856     public int searchBackwards(String searchTerm, int startIndex, boolean startsWith) {
2857         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2858         if (caseInsensitive) {
2859             searchTerm = searchTerm.toLowerCase();
2860         }
2861         ListIterator&lt;History.Entry&gt; it = history.iterator(startIndex);
2862         while (it.hasPrevious()) {
2863             History.Entry e = it.previous();
2864             String line = e.line();
2865             if (caseInsensitive) {
2866                 line = line.toLowerCase();
2867             }
2868             int idx = line.indexOf(searchTerm);
2869             if ((startsWith &amp;&amp; idx == 0) || (!startsWith &amp;&amp; idx &gt;= 0)) {
2870                 return e.index();
2871             }
2872         }
2873         return -1;
2874     }
2875 
2876     public int searchForwards(String searchTerm, int startIndex, boolean startsWith) {
2877         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE_SEARCH);
2878         if (caseInsensitive) {
2879             searchTerm = searchTerm.toLowerCase();
2880         }
2881         if (startIndex &gt; history.last()) {
2882             startIndex = history.last();
2883         }
2884         ListIterator&lt;History.Entry&gt; it = history.iterator(startIndex);
2885         if (searchIndex != -1 &amp;&amp; it.hasNext()) {
2886             it.next();
2887         }
2888         while (it.hasNext()) {
2889             History.Entry e = it.next();
2890             String line = e.line();
2891             if (caseInsensitive) {
2892                 line = line.toLowerCase();
2893             }
2894             int idx = line.indexOf(searchTerm);
2895             if ((startsWith &amp;&amp; idx == 0) || (!startsWith &amp;&amp; idx &gt;= 0)) {
2896                 return e.index();
2897             }
2898         }
2899         return -1;
2900     }
2901 
2902     /**
2903      * Search forward in history from a given position.
2904      *
2905      * @param searchTerm substring to search for.
2906      * @param startIndex the index from which on to search
2907      * @return index where this substring has been found, or -1 else.
2908      */
2909     public int searchForwards(String searchTerm, int startIndex) {
2910         return searchForwards(searchTerm, startIndex, false);
2911     }
2912     /**
2913      * Search forwards in history from the current position.
2914      *
2915      * @param searchTerm substring to search for.
2916      * @return index where the substring has been found, or -1 else.
2917      */
2918     public int searchForwards(String searchTerm) {
2919         return searchForwards(searchTerm, history.index());
2920     }
2921 
2922     protected boolean quit() {
2923         getBuffer().clear();
2924         return acceptLine();
2925     }
2926 
2927     protected boolean acceptAndHold() {
2928         nextCommandFromHistory = false;
2929         acceptLine();
2930         if (!buf.toString().isEmpty()) {
2931             nextHistoryId = Integer.MAX_VALUE;
2932             nextCommandFromHistory = true;
2933         }
2934         return nextCommandFromHistory;
2935     }
2936 
2937     protected boolean acceptLineAndDownHistory() {
2938         nextCommandFromHistory = false;
2939         acceptLine();
2940         if (nextHistoryId &lt; 0) {
2941             nextHistoryId = history.index();
2942         }
2943         if (history.size() &gt; nextHistoryId + 1) {
2944             nextHistoryId++;
2945             nextCommandFromHistory = true;
2946         }
2947         return nextCommandFromHistory;
2948     }
2949 
2950     protected boolean acceptAndInferNextHistory() {
2951         nextCommandFromHistory = false;
2952         acceptLine();
2953         if (!buf.toString().isEmpty()) {
2954             nextHistoryId = searchBackwards(buf.toString(), history.last());
2955             if (nextHistoryId &gt;= 0 &amp;&amp; history.size() &gt; nextHistoryId + 1) {
2956                 nextHistoryId++;
2957                 nextCommandFromHistory = true;
2958             }
2959         }
2960         return nextCommandFromHistory;
2961     }
2962 
2963     protected boolean acceptLine() {
2964         parsedLine = null;
<a name="31" id="anc31"></a><span class="line-added">2965         int curPos = 0;</span>
2966         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2967             try {
2968                 String str = buf.toString();
2969                 String exp = expander.expandHistory(history, str);
2970                 if (!exp.equals(str)) {
2971                     buf.clear();
2972                     buf.write(exp);
2973                     if (isSet(Option.HISTORY_VERIFY)) {
2974                         return true;
2975                     }
2976                 }
2977             } catch (IllegalArgumentException e) {
2978                 // Ignore
2979             }
2980         }
2981         try {
<a name="32" id="anc32"></a><span class="line-added">2982             curPos = buf.cursor();</span>
2983             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2984         } catch (EOFError e) {
<a name="33" id="anc33"></a><span class="line-modified">2985             StringBuilder sb = new StringBuilder(&quot;\n&quot;);</span>
<span class="line-added">2986             indention(e.getOpenBrackets(), sb);</span>
<span class="line-added">2987             int curMove = sb.length();</span>
<span class="line-added">2988             if (isSet(Option.INSERT_BRACKET) &amp;&amp; e.getOpenBrackets() &gt; 1 &amp;&amp; e.getNextClosingBracket() != null) {</span>
<span class="line-added">2989                 sb.append(&#39;\n&#39;);</span>
<span class="line-added">2990                 indention(e.getOpenBrackets() - 1, sb);</span>
<span class="line-added">2991                 sb.append(e.getNextClosingBracket());</span>
<span class="line-added">2992             }</span>
<span class="line-added">2993             buf.write(sb.toString());</span>
<span class="line-added">2994             buf.cursor(curPos + curMove);</span>
2995             return true;
2996         } catch (SyntaxError e) {
2997             // do nothing
2998         }
2999         callWidget(CALLBACK_FINISH);
3000         state = State.DONE;
3001         return true;
3002     }
3003 
<a name="34" id="anc34"></a><span class="line-added">3004     void indention(int nb, StringBuilder sb) {</span>
<span class="line-added">3005         int indent = getInt(INDENTATION, DEFAULT_INDENTATION)*nb;</span>
<span class="line-added">3006         for (int i = 0; i &lt; indent; i++) {</span>
<span class="line-added">3007             sb.append(&#39; &#39;);</span>
<span class="line-added">3008         }</span>
<span class="line-added">3009     }</span>
<span class="line-added">3010 </span>
3011     protected boolean selfInsert() {
3012         for (int count = this.count; count &gt; 0; count--) {
3013             putString(getLastBinding());
3014         }
3015         return true;
3016     }
3017 
3018     protected boolean selfInsertUnmeta() {
3019         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
3020             String s = getLastBinding().substring(1);
3021             if (&quot;\r&quot;.equals(s)) {
3022                 s = &quot;\n&quot;;
3023             }
3024             for (int count = this.count; count &gt; 0; count--) {
3025                 putString(s);
3026             }
3027             return true;
3028         } else {
3029             return false;
3030         }
3031     }
3032 
3033     protected boolean overwriteMode() {
3034         overTyping = !overTyping;
3035         return true;
3036     }
3037 
3038 
3039     //
3040     // History Control
3041     //
3042 
3043     protected boolean beginningOfBufferOrHistory() {
3044         if (findbol() != 0) {
3045             buf.cursor(0);
3046             return true;
3047         } else {
3048             return beginningOfHistory();
3049         }
3050     }
3051 
3052     protected boolean beginningOfHistory() {
3053         if (history.moveToFirst()) {
3054             setBuffer(history.current());
3055             return true;
3056         } else {
3057             return false;
3058         }
3059     }
3060 
3061     protected boolean endOfBufferOrHistory() {
3062         if (findeol() != buf.length()) {
3063             buf.cursor(buf.length());
3064             return true;
3065         } else {
3066             return endOfHistory();
3067         }
3068     }
3069 
3070     protected boolean endOfHistory() {
3071         if (history.moveToLast()) {
3072             setBuffer(history.current());
3073             return true;
3074         } else {
3075             return false;
3076         }
3077     }
3078 
3079     protected boolean beginningOfLineHist() {
3080         if (count &lt; 0) {
3081             return callNeg(this::endOfLineHist);
3082         }
3083         while (count-- &gt; 0) {
3084             int bol = findbol();
3085             if (bol != buf.cursor()) {
3086                 buf.cursor(bol);
3087             } else {
3088                 moveHistory(false);
3089                 buf.cursor(0);
3090             }
3091         }
3092         return true;
3093     }
3094 
3095     protected boolean endOfLineHist() {
3096         if (count &lt; 0) {
3097             return callNeg(this::beginningOfLineHist);
3098         }
3099         while (count-- &gt; 0) {
3100             int eol = findeol();
3101             if (eol != buf.cursor()) {
3102                 buf.cursor(eol);
3103             } else {
3104                 moveHistory(true);
3105             }
3106         }
3107         return true;
3108     }
3109 
3110     protected boolean upHistory() {
3111         while (count-- &gt; 0) {
3112             if (!moveHistory(false)) {
3113                 return !isSet(Option.HISTORY_BEEP);
3114             }
3115         }
3116         return true;
3117     }
3118 
3119     protected boolean downHistory() {
3120         while (count-- &gt; 0) {
3121             if (!moveHistory(true)) {
3122                 return !isSet(Option.HISTORY_BEEP);
3123             }
3124         }
3125         return true;
3126     }
3127 
3128     protected boolean viUpLineOrHistory() {
3129         return upLine()
3130                 || upHistory() &amp;&amp; viFirstNonBlank();
3131     }
3132 
3133     protected boolean viDownLineOrHistory() {
3134         return downLine()
3135                 || downHistory() &amp;&amp; viFirstNonBlank();
3136     }
3137 
3138     protected boolean upLine() {
3139         return buf.up();
3140     }
3141 
3142     protected boolean downLine() {
3143         return buf.down();
3144     }
3145 
3146     protected boolean upLineOrHistory() {
3147         return upLine() || upHistory();
3148     }
3149 
3150     protected boolean upLineOrSearch() {
3151         return upLine() || historySearchBackward();
3152     }
3153 
3154     protected boolean downLineOrHistory() {
3155         return downLine() || downHistory();
3156     }
3157 
3158     protected boolean downLineOrSearch() {
3159         return downLine() || historySearchForward();
3160     }
3161 
3162     protected boolean viCmdMode() {
3163         // If we are re-entering move mode from an
3164         // aborted yank-to, delete-to, change-to then
3165         // don&#39;t move the cursor back. The cursor is
3166         // only move on an explicit entry to movement
3167         // mode.
3168         if (state == State.NORMAL) {
3169             buf.move(-1);
3170         }
3171         return setKeyMap(VICMD);
3172     }
3173 
3174     protected boolean viInsert() {
3175         return setKeyMap(VIINS);
3176     }
3177 
3178     protected boolean viAddNext() {
3179         buf.move(1);
3180         return setKeyMap(VIINS);
3181     }
3182 
3183     protected boolean viAddEol() {
3184         return endOfLine() &amp;&amp; setKeyMap(VIINS);
3185     }
3186 
3187     protected boolean emacsEditingMode() {
3188         return setKeyMap(EMACS);
3189     }
3190 
3191     protected boolean viChangeWholeLine() {
3192         return viFirstNonBlank() &amp;&amp; viChangeEol();
3193     }
3194 
3195     protected boolean viChangeEol() {
3196         return viChange(buf.cursor(), buf.length())
3197                 &amp;&amp; setKeyMap(VIINS);
3198     }
3199 
3200     protected boolean viKillEol() {
3201         int eol = findeol();
3202         if (buf.cursor() == eol) {
3203             return false;
3204         }
3205         killRing.add(buf.substring(buf.cursor(), eol));
3206         buf.delete(eol - buf.cursor());
3207         return true;
3208     }
3209 
3210     protected boolean quotedInsert() {
3211         int c = readCharacter();
3212         while (count-- &gt; 0) {
3213             putString(new String(Character.toChars(c)));
3214         }
3215         return true;
3216     }
3217 
3218     protected boolean viJoin() {
3219         if (buf.down()) {
3220             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3221             buf.backspace();
3222             buf.write(&#39; &#39;);
3223             buf.move(-1);
3224             return true;
3225         }
3226         return false;
3227     }
3228 
3229     protected boolean viKillWholeLine() {
3230         return killWholeLine() &amp;&amp; setKeyMap(VIINS);
3231     }
3232 
3233     protected boolean viInsertBol() {
3234         return beginningOfLine() &amp;&amp; setKeyMap(VIINS);
3235     }
3236 
3237     protected boolean backwardDeleteChar() {
3238         if (count &lt; 0) {
3239             return callNeg(this::deleteChar);
3240         }
3241         if (buf.cursor() == 0) {
3242             return false;
3243         }
3244         buf.backspace(count);
3245         return true;
3246     }
3247 
3248     protected boolean viFirstNonBlank() {
3249         beginningOfLine();
3250         while (buf.cursor() &lt; buf.length() &amp;&amp; isWhitespace(buf.currChar())) {
3251             buf.move(1);
3252         }
3253         return true;
3254     }
3255 
3256     protected boolean viBeginningOfLine() {
3257         buf.cursor(findbol());
3258         return true;
3259     }
3260 
3261     protected boolean viEndOfLine() {
3262         if (count &lt; 0) {
3263             return false;
3264         }
3265         while (count-- &gt; 0) {
3266             buf.cursor(findeol() + 1);
3267         }
3268         buf.move(-1);
3269         return true;
3270     }
3271 
3272     protected boolean beginningOfLine() {
3273         while (count-- &gt; 0) {
3274             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3275         }
3276         return true;
3277     }
3278 
3279     protected boolean endOfLine() {
3280         while (count-- &gt; 0) {
3281             while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;) ;
3282         }
3283         return true;
3284     }
3285 
3286     protected boolean deleteChar() {
3287         if (count &lt; 0) {
3288             return callNeg(this::backwardDeleteChar);
3289         }
3290         if (buf.cursor() == buf.length()) {
3291             return false;
3292         }
3293         buf.delete(count);
3294         return true;
3295     }
3296 
3297     /**
3298      * Deletes the previous character from the cursor position
3299      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3300      */
3301     protected boolean viBackwardDeleteChar() {
3302         for (int i = 0; i &lt; count; i++) {
3303             if (!buf.backspace()) {
3304                 return false;
3305             }
3306         }
3307         return true;
3308     }
3309 
3310     /**
3311      * Deletes the character you are sitting on and sucks the rest of
3312      * the line in from the right.
3313      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3314      */
3315     protected boolean viDeleteChar() {
3316         for (int i = 0; i &lt; count; i++) {
3317             if (!buf.delete()) {
3318                 return false;
3319             }
3320         }
3321         return true;
3322     }
3323 
3324     /**
3325      * Switches the case of the current character from upper to lower
3326      * or lower to upper as necessary and advances the cursor one
3327      * position to the right.
3328      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3329      */
3330     protected boolean viSwapCase() {
3331         for (int i = 0; i &lt; count; i++) {
3332             if (buf.cursor() &lt; buf.length()) {
3333                 int ch = buf.atChar(buf.cursor());
3334                 ch = switchCase(ch);
3335                 buf.currChar(ch);
3336                 buf.move(1);
3337             } else {
3338                 return false;
3339             }
3340         }
3341         return true;
3342     }
3343 
3344     /**
3345      * Implements the vi change character command (in move-mode &quot;r&quot;
3346      * followed by the character to change to).
3347      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3348      */
3349     protected boolean viReplaceChars() {
3350         int c = readCharacter();
3351         // EOF, ESC, or CTRL-C aborts.
3352         if (c &lt; 0 || c == &#39;\033&#39; || c == &#39;\003&#39;) {
3353             return true;
3354         }
3355 
3356         for (int i = 0; i &lt; count; i++) {
3357             if (buf.currChar((char) c)) {
3358                 if (i &lt; count - 1) {
3359                     buf.move(1);
3360                 }
3361             } else {
3362                 return false;
3363             }
3364         }
3365         return true;
3366     }
3367 
3368     protected boolean viChange(int startPos, int endPos) {
3369         return doViDeleteOrChange(startPos, endPos, true);
3370     }
3371 
3372     protected boolean viDeleteTo(int startPos, int endPos) {
3373         return doViDeleteOrChange(startPos, endPos, false);
3374     }
3375 
3376     /**
3377      * Performs the vi &quot;delete-to&quot; action, deleting characters between a given
3378      * span of the input line.
3379      * @param startPos The start position
3380      * @param endPos The end position.
3381      * @param isChange If true, then the delete is part of a change operationg
3382      *    (e.g. &quot;c$&quot; is change-to-end-of line, so we first must delete to end
3383      *    of line to start the change
3384      * @return &lt;code&gt;true&lt;/code&gt; if it succeeded, &lt;code&gt;false&lt;/code&gt; otherwise
3385      */
3386     protected boolean doViDeleteOrChange(int startPos, int endPos, boolean isChange) {
3387         if (startPos == endPos) {
3388             return true;
3389         }
3390 
3391         if (endPos &lt; startPos) {
3392             int tmp = endPos;
3393             endPos = startPos;
3394             startPos = tmp;
3395         }
3396 
3397         buf.cursor(startPos);
3398         buf.delete(endPos - startPos);
3399 
3400         // If we are doing a delete operation (e.g. &quot;d$&quot;) then don&#39;t leave the
3401         // cursor dangling off the end. In reality the &quot;isChange&quot; flag is silly
3402         // what is really happening is that if we are in &quot;move-mode&quot; then the
3403         // cursor can&#39;t be moved off the end of the line, but in &quot;edit-mode&quot; it
3404         // is ok, but I have no easy way of knowing which mode we are in.
3405         if (! isChange &amp;&amp; startPos &gt; 0 &amp;&amp; startPos == buf.length()) {
3406             buf.move(-1);
3407         }
3408         return true;
3409     }
3410 
3411     /**
3412      * Implement the &quot;vi&quot; yank-to operation.  This operation allows you
3413      * to yank the contents of the current line based upon a move operation,
3414      * for example &quot;yw&quot; yanks the current word, &quot;3yw&quot; yanks 3 words, etc.
3415      *
3416      * @param startPos The starting position from which to yank
3417      * @param endPos The ending position to which to yank
3418      * @return &lt;code&gt;true&lt;/code&gt; if the yank succeeded
3419      */
3420     protected boolean viYankTo(int startPos, int endPos) {
3421         int cursorPos = startPos;
3422 
3423         if (endPos &lt; startPos) {
3424             int tmp = endPos;
3425             endPos = startPos;
3426             startPos = tmp;
3427         }
3428 
3429         if (startPos == endPos) {
3430             yankBuffer = &quot;&quot;;
3431             return true;
3432         }
3433 
3434         yankBuffer = buf.substring(startPos, endPos);
3435 
3436         /*
3437          * It was a movement command that moved the cursor to find the
3438          * end position, so put the cursor back where it started.
3439          */
3440         buf.cursor(cursorPos);
3441         return true;
3442     }
3443 
3444     protected boolean viOpenLineAbove() {
3445         while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;) ;
3446         buf.write(&#39;\n&#39;);
3447         buf.move(-1);
3448         return setKeyMap(VIINS);
3449     }
3450 
3451     protected boolean viOpenLineBelow() {
3452         while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;) ;
3453         buf.write(&#39;\n&#39;);
3454         return setKeyMap(VIINS);
3455     }
3456 
3457     /**
3458      * Pasts the yank buffer to the right of the current cursor position
3459      * and moves the cursor to the end of the pasted region.
3460      * @return &lt;code&gt;true&lt;/code&gt;
3461      */
3462     protected boolean viPutAfter() {
3463         if (yankBuffer.indexOf(&#39;\n&#39;) &gt;= 0) {
3464             while (buf.move(1) == 1 &amp;&amp; buf.currChar() != &#39;\n&#39;);
3465             buf.move(1);
3466             putString(yankBuffer);
3467             buf.move(- yankBuffer.length());
3468         } else if (yankBuffer.length () != 0) {
3469             if (buf.cursor() &lt; buf.length()) {
3470                 buf.move(1);
3471             }
3472             for (int i = 0; i &lt; count; i++) {
3473                 putString(yankBuffer);
3474             }
3475             buf.move(-1);
3476         }
3477         return true;
3478     }
3479 
3480     protected boolean viPutBefore() {
3481         if (yankBuffer.indexOf(&#39;\n&#39;) &gt;= 0) {
3482             while (buf.move(-1) == -1 &amp;&amp; buf.prevChar() != &#39;\n&#39;);
3483             putString(yankBuffer);
3484             buf.move(- yankBuffer.length());
3485         } else if (yankBuffer.length () != 0) {
3486             if (buf.cursor() &gt; 0) {
3487                 buf.move(-1);
3488             }
3489             for (int i = 0; i &lt; count; i++) {
3490                 putString(yankBuffer);
3491             }
3492             buf.move(-1);
3493         }
3494         return true;
3495     }
3496 
3497     protected boolean doLowercaseVersion() {
3498         bindingReader.runMacro(getLastBinding().toLowerCase());
3499         return true;
3500     }
3501 
3502     protected boolean setMarkCommand() {
3503         if (count &lt; 0) {
3504             regionActive = RegionType.NONE;
3505             return true;
3506         }
3507         regionMark = buf.cursor();
3508         regionActive = RegionType.CHAR;
3509         return true;
3510     }
3511 
3512     protected boolean exchangePointAndMark() {
3513         if (count == 0) {
3514             regionActive = RegionType.CHAR;
3515             return true;
3516         }
3517         int x = regionMark;
3518         regionMark = buf.cursor();
3519         buf.cursor(x);
3520         if (buf.cursor() &gt; buf.length()) {
3521             buf.cursor(buf.length());
3522         }
3523         if (count &gt; 0) {
3524             regionActive = RegionType.CHAR;
3525         }
3526         return true;
3527     }
3528 
3529     protected boolean visualMode() {
3530         if (isInViMoveOperation()) {
3531             isArgDigit = true;
3532             forceLine = false;
3533             forceChar = true;
3534             return true;
3535         }
3536         if (regionActive == RegionType.NONE) {
3537             regionMark = buf.cursor();
3538             regionActive = RegionType.CHAR;
3539         } else if (regionActive == RegionType.CHAR) {
3540             regionActive = RegionType.NONE;
3541         } else if (regionActive == RegionType.LINE) {
3542             regionActive = RegionType.CHAR;
3543         }
3544         return true;
3545     }
3546 
3547     protected boolean visualLineMode() {
3548         if (isInViMoveOperation()) {
3549             isArgDigit = true;
3550             forceLine = true;
3551             forceChar = false;
3552             return true;
3553         }
3554         if (regionActive == RegionType.NONE) {
3555             regionMark = buf.cursor();
3556             regionActive = RegionType.LINE;
3557         } else if (regionActive == RegionType.CHAR) {
3558             regionActive = RegionType.LINE;
3559         } else if (regionActive == RegionType.LINE) {
3560             regionActive = RegionType.NONE;
3561         }
3562         return true;
3563     }
3564 
3565     protected boolean deactivateRegion() {
3566         regionActive = RegionType.NONE;
3567         return true;
3568     }
3569 
3570     protected boolean whatCursorPosition() {
3571         post = () -&gt; {
3572             AttributedStringBuilder sb = new AttributedStringBuilder();
3573             if (buf.cursor() &lt; buf.length()) {
3574                 int c = buf.currChar();
3575                 sb.append(&quot;Char: &quot;);
3576                 if (c == &#39; &#39;) {
3577                     sb.append(&quot;SPC&quot;);
3578                 } else if (c == &#39;\n&#39;) {
3579                     sb.append(&quot;LFD&quot;);
3580                 } else if (c &lt; 32) {
3581                     sb.append(&#39;^&#39;);
3582                     sb.append((char) (c + &#39;A&#39; - 1));
3583                 } else if (c == 127) {
3584                     sb.append(&quot;^?&quot;);
3585                 } else {
3586                     sb.append((char) c);
3587                 }
3588                 sb.append(&quot; (&quot;);
3589                 sb.append(&quot;0&quot;).append(Integer.toOctalString(c)).append(&quot; &quot;);
3590                 sb.append(Integer.toString(c)).append(&quot; &quot;);
3591                 sb.append(&quot;0x&quot;).append(Integer.toHexString(c)).append(&quot; &quot;);
3592                 sb.append(&quot;)&quot;);
3593             } else {
3594                 sb.append(&quot;EOF&quot;);
3595             }
3596             sb.append(&quot;   &quot;);
3597             sb.append(&quot;point &quot;);
3598             sb.append(Integer.toString(buf.cursor() + 1));
3599             sb.append(&quot; of &quot;);
3600             sb.append(Integer.toString(buf.length() + 1));
3601             sb.append(&quot; (&quot;);
3602             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3603             sb.append(&quot;%)&quot;);
3604             sb.append(&quot;   &quot;);
3605             sb.append(&quot;column &quot;);
3606             sb.append(Integer.toString(buf.cursor() - findbol()));
3607             return sb.toAttributedString();
3608         };
3609         return true;
3610     }
3611 
<a name="35" id="anc35"></a><span class="line-added">3612     protected boolean editAndExecute() {</span>
<span class="line-added">3613         boolean out = true;</span>
<span class="line-added">3614         File file = null;</span>
<span class="line-added">3615         try {</span>
<span class="line-added">3616             file = File.createTempFile(&quot;jline-execute-&quot;, null);</span>
<span class="line-added">3617             FileWriter writer = new FileWriter(file);</span>
<span class="line-added">3618             writer.write(buf.toString());</span>
<span class="line-added">3619             writer.close();</span>
<span class="line-added">3620             editAndAddInBuffer(file);</span>
<span class="line-added">3621         } catch (Exception e) {</span>
<span class="line-added">3622             e.printStackTrace(terminal.writer());</span>
<span class="line-added">3623             out = false;</span>
<span class="line-added">3624         } finally {</span>
<span class="line-added">3625             state = State.IGNORE;</span>
<span class="line-added">3626             if (file != null &amp;&amp; file.exists()) {</span>
<span class="line-added">3627                 file.delete();</span>
<span class="line-added">3628             }</span>
<span class="line-added">3629         }</span>
<span class="line-added">3630         return out;</span>
<span class="line-added">3631     }</span>
<span class="line-added">3632 </span>
3633     protected Map&lt;String, Widget&gt; builtinWidgets() {
3634         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
3635         addBuiltinWidget(widgets, ACCEPT_AND_INFER_NEXT_HISTORY, this::acceptAndInferNextHistory);
3636         addBuiltinWidget(widgets, ACCEPT_AND_HOLD, this::acceptAndHold);
3637         addBuiltinWidget(widgets, ACCEPT_LINE, this::acceptLine);
3638         addBuiltinWidget(widgets, ACCEPT_LINE_AND_DOWN_HISTORY, this::acceptLineAndDownHistory);
3639         addBuiltinWidget(widgets, ARGUMENT_BASE, this::argumentBase);
3640         addBuiltinWidget(widgets, BACKWARD_CHAR, this::backwardChar);
3641         addBuiltinWidget(widgets, BACKWARD_DELETE_CHAR, this::backwardDeleteChar);
3642         addBuiltinWidget(widgets, BACKWARD_DELETE_WORD, this::backwardDeleteWord);
3643         addBuiltinWidget(widgets, BACKWARD_KILL_LINE, this::backwardKillLine);
3644         addBuiltinWidget(widgets, BACKWARD_KILL_WORD, this::backwardKillWord);
3645         addBuiltinWidget(widgets, BACKWARD_WORD, this::backwardWord);
3646         addBuiltinWidget(widgets, BEEP, this::beep);
3647         addBuiltinWidget(widgets, BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);
3648         addBuiltinWidget(widgets, BEGINNING_OF_HISTORY, this::beginningOfHistory);
3649         addBuiltinWidget(widgets, BEGINNING_OF_LINE, this::beginningOfLine);
3650         addBuiltinWidget(widgets, BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);
3651         addBuiltinWidget(widgets, CAPITALIZE_WORD, this::capitalizeWord);
3652         addBuiltinWidget(widgets, CLEAR, this::clear);
3653         addBuiltinWidget(widgets, CLEAR_SCREEN, this::clearScreen);
3654         addBuiltinWidget(widgets, COMPLETE_PREFIX, this::completePrefix);
3655         addBuiltinWidget(widgets, COMPLETE_WORD, this::completeWord);
3656         addBuiltinWidget(widgets, COPY_PREV_WORD, this::copyPrevWord);
3657         addBuiltinWidget(widgets, COPY_REGION_AS_KILL, this::copyRegionAsKill);
3658         addBuiltinWidget(widgets, DELETE_CHAR, this::deleteChar);
3659         addBuiltinWidget(widgets, DELETE_CHAR_OR_LIST, this::deleteCharOrList);
3660         addBuiltinWidget(widgets, DELETE_WORD, this::deleteWord);
3661         addBuiltinWidget(widgets, DIGIT_ARGUMENT, this::digitArgument);
3662         addBuiltinWidget(widgets, DO_LOWERCASE_VERSION, this::doLowercaseVersion);
3663         addBuiltinWidget(widgets, DOWN_CASE_WORD, this::downCaseWord);
3664         addBuiltinWidget(widgets, DOWN_LINE, this::downLine);
3665         addBuiltinWidget(widgets, DOWN_LINE_OR_HISTORY, this::downLineOrHistory);
3666         addBuiltinWidget(widgets, DOWN_LINE_OR_SEARCH, this::downLineOrSearch);
3667         addBuiltinWidget(widgets, DOWN_HISTORY, this::downHistory);
<a name="36" id="anc36"></a><span class="line-added">3668         addBuiltinWidget(widgets, EDIT_AND_EXECUTE_COMMAND, this::editAndExecute);</span>
3669         addBuiltinWidget(widgets, EMACS_EDITING_MODE, this::emacsEditingMode);
3670         addBuiltinWidget(widgets, EMACS_BACKWARD_WORD, this::emacsBackwardWord);
3671         addBuiltinWidget(widgets, EMACS_FORWARD_WORD, this::emacsForwardWord);
3672         addBuiltinWidget(widgets, END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);
3673         addBuiltinWidget(widgets, END_OF_HISTORY, this::endOfHistory);
3674         addBuiltinWidget(widgets, END_OF_LINE, this::endOfLine);
3675         addBuiltinWidget(widgets, END_OF_LINE_HIST, this::endOfLineHist);
3676         addBuiltinWidget(widgets, EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);
3677         addBuiltinWidget(widgets, EXPAND_HISTORY, this::expandHistory);
3678         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE, this::expandOrComplete);
3679         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);
3680         addBuiltinWidget(widgets, EXPAND_WORD, this::expandWord);
3681         addBuiltinWidget(widgets, FRESH_LINE, this::freshLine);
3682         addBuiltinWidget(widgets, FORWARD_CHAR, this::forwardChar);
3683         addBuiltinWidget(widgets, FORWARD_WORD, this::forwardWord);
3684         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);
3685         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);
3686         addBuiltinWidget(widgets, HISTORY_SEARCH_BACKWARD, this::historySearchBackward);
3687         addBuiltinWidget(widgets, HISTORY_SEARCH_FORWARD, this::historySearchForward);
3688         addBuiltinWidget(widgets, INSERT_CLOSE_CURLY, this::insertCloseCurly);
3689         addBuiltinWidget(widgets, INSERT_CLOSE_PAREN, this::insertCloseParen);
3690         addBuiltinWidget(widgets, INSERT_CLOSE_SQUARE, this::insertCloseSquare);
3691         addBuiltinWidget(widgets, INSERT_COMMENT, this::insertComment);
3692         addBuiltinWidget(widgets, KILL_BUFFER, this::killBuffer);
3693         addBuiltinWidget(widgets, KILL_LINE, this::killLine);
3694         addBuiltinWidget(widgets, KILL_REGION, this::killRegion);
3695         addBuiltinWidget(widgets, KILL_WHOLE_LINE, this::killWholeLine);
3696         addBuiltinWidget(widgets, KILL_WORD, this::killWord);
3697         addBuiltinWidget(widgets, LIST_CHOICES, this::listChoices);
3698         addBuiltinWidget(widgets, MENU_COMPLETE, this::menuComplete);
3699         addBuiltinWidget(widgets, MENU_EXPAND_OR_COMPLETE, this::menuExpandOrComplete);
3700         addBuiltinWidget(widgets, NEG_ARGUMENT, this::negArgument);
3701         addBuiltinWidget(widgets, OVERWRITE_MODE, this::overwriteMode);
3702 //        addBuiltinWidget(widgets, QUIT, this::quit);
3703         addBuiltinWidget(widgets, QUOTED_INSERT, this::quotedInsert);
3704         addBuiltinWidget(widgets, REDISPLAY, this::redisplay);
3705         addBuiltinWidget(widgets, REDRAW_LINE, this::redrawLine);
3706         addBuiltinWidget(widgets, REDO, this::redo);
3707         addBuiltinWidget(widgets, SELF_INSERT, this::selfInsert);
3708         addBuiltinWidget(widgets, SELF_INSERT_UNMETA, this::selfInsertUnmeta);
3709         addBuiltinWidget(widgets, SEND_BREAK, this::sendBreak);
3710         addBuiltinWidget(widgets, SET_MARK_COMMAND, this::setMarkCommand);
3711         addBuiltinWidget(widgets, TRANSPOSE_CHARS, this::transposeChars);
3712         addBuiltinWidget(widgets, TRANSPOSE_WORDS, this::transposeWords);
3713         addBuiltinWidget(widgets, UNDEFINED_KEY, this::undefinedKey);
3714         addBuiltinWidget(widgets, UNIVERSAL_ARGUMENT, this::universalArgument);
3715         addBuiltinWidget(widgets, UNDO, this::undo);
3716         addBuiltinWidget(widgets, UP_CASE_WORD, this::upCaseWord);
3717         addBuiltinWidget(widgets, UP_HISTORY, this::upHistory);
3718         addBuiltinWidget(widgets, UP_LINE, this::upLine);
3719         addBuiltinWidget(widgets, UP_LINE_OR_HISTORY, this::upLineOrHistory);
3720         addBuiltinWidget(widgets, UP_LINE_OR_SEARCH, this::upLineOrSearch);
3721         addBuiltinWidget(widgets, VI_ADD_EOL, this::viAddEol);
3722         addBuiltinWidget(widgets, VI_ADD_NEXT, this::viAddNext);
3723         addBuiltinWidget(widgets, VI_BACKWARD_CHAR, this::viBackwardChar);
3724         addBuiltinWidget(widgets, VI_BACKWARD_DELETE_CHAR, this::viBackwardDeleteChar);
3725         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD, this::viBackwardBlankWord);
3726         addBuiltinWidget(widgets, VI_BACKWARD_BLANK_WORD_END, this::viBackwardBlankWordEnd);
3727         addBuiltinWidget(widgets, VI_BACKWARD_KILL_WORD, this::viBackwardKillWord);
3728         addBuiltinWidget(widgets, VI_BACKWARD_WORD, this::viBackwardWord);
3729         addBuiltinWidget(widgets, VI_BACKWARD_WORD_END, this::viBackwardWordEnd);
3730         addBuiltinWidget(widgets, VI_BEGINNING_OF_LINE, this::viBeginningOfLine);
3731         addBuiltinWidget(widgets, VI_CMD_MODE, this::viCmdMode);
3732         addBuiltinWidget(widgets, VI_DIGIT_OR_BEGINNING_OF_LINE, this::viDigitOrBeginningOfLine);
3733         addBuiltinWidget(widgets, VI_DOWN_LINE_OR_HISTORY, this::viDownLineOrHistory);
3734         addBuiltinWidget(widgets, VI_CHANGE, this::viChange);
3735         addBuiltinWidget(widgets, VI_CHANGE_EOL, this::viChangeEol);
3736         addBuiltinWidget(widgets, VI_CHANGE_WHOLE_LINE, this::viChangeWholeLine);
3737         addBuiltinWidget(widgets, VI_DELETE_CHAR, this::viDeleteChar);
3738         addBuiltinWidget(widgets, VI_DELETE, this::viDelete);
3739         addBuiltinWidget(widgets, VI_END_OF_LINE, this::viEndOfLine);
3740         addBuiltinWidget(widgets, VI_KILL_EOL, this::viKillEol);
3741         addBuiltinWidget(widgets, VI_FIRST_NON_BLANK, this::viFirstNonBlank);
3742         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR, this::viFindNextChar);
3743         addBuiltinWidget(widgets, VI_FIND_NEXT_CHAR_SKIP, this::viFindNextCharSkip);
3744         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR, this::viFindPrevChar);
3745         addBuiltinWidget(widgets, VI_FIND_PREV_CHAR_SKIP, this::viFindPrevCharSkip);
3746         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD, this::viForwardBlankWord);
3747         addBuiltinWidget(widgets, VI_FORWARD_BLANK_WORD_END, this::viForwardBlankWordEnd);
3748         addBuiltinWidget(widgets, VI_FORWARD_CHAR, this::viForwardChar);
3749         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);
3750         addBuiltinWidget(widgets, VI_FORWARD_WORD, this::viForwardWord);
3751         addBuiltinWidget(widgets, VI_FORWARD_WORD_END, this::viForwardWordEnd);
3752         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_BACKWARD, this::viHistorySearchBackward);
3753         addBuiltinWidget(widgets, VI_HISTORY_SEARCH_FORWARD, this::viHistorySearchForward);
3754         addBuiltinWidget(widgets, VI_INSERT, this::viInsert);
3755         addBuiltinWidget(widgets, VI_INSERT_BOL, this::viInsertBol);
3756         addBuiltinWidget(widgets, VI_INSERT_COMMENT, this::viInsertComment);
3757         addBuiltinWidget(widgets, VI_JOIN, this::viJoin);
3758         addBuiltinWidget(widgets, VI_KILL_LINE, this::viKillWholeLine);
3759         addBuiltinWidget(widgets, VI_MATCH_BRACKET, this::viMatchBracket);
3760         addBuiltinWidget(widgets, VI_OPEN_LINE_ABOVE, this::viOpenLineAbove);
3761         addBuiltinWidget(widgets, VI_OPEN_LINE_BELOW, this::viOpenLineBelow);
3762         addBuiltinWidget(widgets, VI_PUT_AFTER, this::viPutAfter);
3763         addBuiltinWidget(widgets, VI_PUT_BEFORE, this::viPutBefore);
3764         addBuiltinWidget(widgets, VI_REPEAT_FIND, this::viRepeatFind);
3765         addBuiltinWidget(widgets, VI_REPEAT_SEARCH, this::viRepeatSearch);
3766         addBuiltinWidget(widgets, VI_REPLACE_CHARS, this::viReplaceChars);
3767         addBuiltinWidget(widgets, VI_REV_REPEAT_FIND, this::viRevRepeatFind);
3768         addBuiltinWidget(widgets, VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);
3769         addBuiltinWidget(widgets, VI_SWAP_CASE, this::viSwapCase);
3770         addBuiltinWidget(widgets, VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);
3771         addBuiltinWidget(widgets, VI_YANK, this::viYankTo);
3772         addBuiltinWidget(widgets, VI_YANK_WHOLE_LINE, this::viYankWholeLine);
3773         addBuiltinWidget(widgets, VISUAL_LINE_MODE, this::visualLineMode);
3774         addBuiltinWidget(widgets, VISUAL_MODE, this::visualMode);
3775         addBuiltinWidget(widgets, WHAT_CURSOR_POSITION, this::whatCursorPosition);
3776         addBuiltinWidget(widgets, YANK, this::yank);
3777         addBuiltinWidget(widgets, YANK_POP, this::yankPop);
3778         addBuiltinWidget(widgets, MOUSE, this::mouse);
3779         addBuiltinWidget(widgets, BEGIN_PASTE, this::beginPaste);
3780         addBuiltinWidget(widgets, FOCUS_IN, this::focusIn);
3781         addBuiltinWidget(widgets, FOCUS_OUT, this::focusOut);
3782         return widgets;
3783     }
3784 
3785     private void addBuiltinWidget(Map&lt;String, Widget&gt; widgets, String name, Widget widget) {
<a name="37" id="anc37"></a><span class="line-modified">3786         widgets.put(name, namedWidget(&quot;.&quot; + name, widget));</span>
3787     }
3788 
3789     private Widget namedWidget(String name, Widget widget) {
3790         return new Widget() {
3791             @Override
3792             public String toString() {
3793                 return name;
3794             }
3795             @Override
3796             public boolean apply() {
3797                 return widget.apply();
3798             }
3799         };
3800     }
3801 
3802     public boolean redisplay() {
3803         redisplay(true);
3804         return true;
3805     }
3806 
3807     protected void redisplay(boolean flush) {
3808         try {
3809             lock.lock();
3810 
3811             if (skipRedisplay) {
3812                 skipRedisplay = false;
3813                 return;
3814             }
3815 
3816             Status status = Status.getStatus(terminal, false);
3817             if (status != null) {
3818                 status.redraw();
3819             }
3820 
3821             if (size.getRows() &gt; 0 &amp;&amp; size.getRows() &lt; MIN_ROWS) {
3822                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
3823 
3824                 sb.append(prompt);
3825                 concat(getHighlightedBuffer(buf.toString()).columnSplitLength(Integer.MAX_VALUE), sb);
3826                 AttributedString full = sb.toAttributedString();
3827 
3828                 sb.setLength(0);
3829                 sb.append(prompt);
3830                 String line = buf.upToCursor();
3831                 if (maskingCallback != null) {
3832                     line = maskingCallback.display(line);
3833                 }
3834 
3835                 concat(new AttributedString(line).columnSplitLength(Integer.MAX_VALUE), sb);
3836                 AttributedString toCursor = sb.toAttributedString();
3837 
3838                 int w = WCWidth.wcwidth(&#39;\u2026&#39;);
3839                 int width = size.getColumns();
3840                 int cursor = toCursor.columnLength();
3841                 int inc = width / 2 + 1;
3842                 while (cursor &lt;= smallTerminalOffset + w) {
3843                     smallTerminalOffset -= inc;
3844                 }
3845                 while (cursor &gt;= smallTerminalOffset + width - w) {
3846                     smallTerminalOffset += inc;
3847                 }
3848                 if (smallTerminalOffset &gt; 0) {
3849                     sb.setLength(0);
3850                     sb.append(&quot;\u2026&quot;);
3851                     sb.append(full.columnSubSequence(smallTerminalOffset + w, Integer.MAX_VALUE));
3852                     full = sb.toAttributedString();
3853                 }
3854                 int length = full.columnLength();
3855                 if (length &gt;= smallTerminalOffset + width) {
3856                     sb.setLength(0);
3857                     sb.append(full.columnSubSequence(0, width - w));
3858                     sb.append(&quot;\u2026&quot;);
3859                     full = sb.toAttributedString();
3860                 }
3861 
3862                 display.update(Collections.singletonList(full), cursor - smallTerminalOffset, flush);
3863                 return;
3864             }
3865 
3866             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
3867             AttributedString full = getDisplayedBufferWithPrompts(secondaryPrompts);
3868 
3869             List&lt;AttributedString&gt; newLines;
3870             if (size.getColumns() &lt;= 0) {
3871                 newLines = new ArrayList&lt;&gt;();
3872                 newLines.add(full);
3873             } else {
3874                 newLines = full.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
3875             }
3876 
3877             List&lt;AttributedString&gt; rightPromptLines;
3878             if (rightPrompt.length() == 0 || size.getColumns() &lt;= 0) {
3879                 rightPromptLines = new ArrayList&lt;&gt;();
3880             } else {
3881                 rightPromptLines = rightPrompt.columnSplitLength(size.getColumns());
3882             }
3883             while (newLines.size() &lt; rightPromptLines.size()) {
3884                 newLines.add(new AttributedString(&quot;&quot;));
3885             }
3886             for (int i = 0; i &lt; rightPromptLines.size(); i++) {
3887                 AttributedString line = rightPromptLines.get(i);
3888                 newLines.set(i, addRightPrompt(line, newLines.get(i)));
3889             }
3890 
3891             int cursorPos = -1;
3892             int cursorNewLinesId = -1;
3893             int cursorColPos = -1;
3894             if (size.getColumns() &gt; 0) {
3895                 AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
3896                 sb.append(prompt);
3897                 String buffer = buf.upToCursor();
3898                 if (maskingCallback != null) {
3899                     buffer = maskingCallback.display(buffer);
3900                 }
3901                 sb.append(insertSecondaryPrompts(new AttributedString(buffer), secondaryPrompts, false));
3902                 List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
3903                 if (!promptLines.isEmpty()) {
3904                     cursorNewLinesId = promptLines.size() - 1;
3905                     cursorColPos = promptLines.get(promptLines.size() - 1).columnLength();
3906                     cursorPos = size.cursorPos(cursorNewLinesId, cursorColPos);
3907                 }
3908             }
3909 
3910             List&lt;AttributedString&gt; newLinesToDisplay = new ArrayList&lt;&gt;();
3911             int displaySize = size.getRows() - (status != null ? status.size() : 0);
3912             if (newLines.size() &gt; displaySize &amp;&amp; !isTerminalDumb()) {
3913                 StringBuilder sb = new StringBuilder(&quot;&gt;....&quot;);
3914                 // blanks are needed when displaying command completion candidate list
3915                 for (int i = sb.toString().length(); i &lt; size.getColumns(); i++) {
3916                     sb.append(&quot; &quot;);
3917                 }
3918                 AttributedString partialCommandInfo = new AttributedString(sb.toString());
3919                 int lineId = newLines.size() - displaySize + 1;
3920                 int endId = displaySize;
3921                 int startId = 1;
3922                 if (lineId  &gt; cursorNewLinesId) {
3923                     lineId = cursorNewLinesId;
3924                     endId = displaySize - 1;
3925                     startId = 0;
3926                 } else {
3927                     newLinesToDisplay.add(partialCommandInfo);
3928                 }
3929                 int cursorRowPos = 0;
3930                 for (int i = startId; i &lt; endId; i++) {
3931                     if (cursorNewLinesId == lineId) {
3932                         cursorRowPos = i;
3933                     }
3934                     newLinesToDisplay.add(newLines.get(lineId++));
3935                 }
3936                 if (startId == 0) {
3937                     newLinesToDisplay.add(partialCommandInfo);
3938                 }
3939                 cursorPos = size.cursorPos(cursorRowPos, cursorColPos);
3940             } else {
3941                 newLinesToDisplay = newLines;
3942             }
3943             display.update(newLinesToDisplay, cursorPos, flush);
3944         } finally {
3945             lock.unlock();
3946         }
3947     }
3948 
3949     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3950         if (lines.size() &gt; 1) {
3951             for (int i = 0; i &lt; lines.size() - 1; i++) {
3952                 sb.append(lines.get(i));
3953                 sb.style(sb.style().inverse());
3954                 sb.append(&quot;\\n&quot;);
3955                 sb.style(sb.style().inverseOff());
3956             }
3957         }
3958         sb.append(lines.get(lines.size() - 1));
3959     }
3960 
<a name="38" id="anc38"></a><span class="line-added">3961     private String matchPreviousCommand(String buffer) {</span>
<span class="line-added">3962         if (buffer.length() == 0) {</span>
<span class="line-added">3963             return &quot;&quot;;</span>
<span class="line-added">3964         }</span>
<span class="line-added">3965         History history = getHistory();</span>
<span class="line-added">3966         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">3967         char prev = &#39;0&#39;;</span>
<span class="line-added">3968         for (char c: buffer.toCharArray()) {</span>
<span class="line-added">3969             if ((c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;[&#39; || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39; || c == &#39;^&#39;) &amp;&amp; prev != &#39;\\&#39; ) {</span>
<span class="line-added">3970                 sb.append(&#39;\\&#39;);</span>
<span class="line-added">3971             }</span>
<span class="line-added">3972             sb.append(c);</span>
<span class="line-added">3973             prev = c;</span>
<span class="line-added">3974         }</span>
<span class="line-added">3975         Pattern pattern = Pattern.compile(sb.toString() + &quot;.*&quot;, Pattern.DOTALL);</span>
<span class="line-added">3976         Iterator&lt;History.Entry&gt; iter = history.reverseIterator(history.last());</span>
<span class="line-added">3977         String suggestion = &quot;&quot;;</span>
<span class="line-added">3978         int tot = 0;</span>
<span class="line-added">3979         while (iter.hasNext()) {</span>
<span class="line-added">3980             History.Entry entry = iter.next();</span>
<span class="line-added">3981             Matcher matcher = pattern.matcher(entry.line());</span>
<span class="line-added">3982             if (matcher.matches()) {</span>
<span class="line-added">3983                 suggestion = entry.line().substring(buffer.length());</span>
<span class="line-added">3984                 break;</span>
<span class="line-added">3985             } else if (tot &gt; 200) {</span>
<span class="line-added">3986                 break;</span>
<span class="line-added">3987             }</span>
<span class="line-added">3988             tot++;</span>
<span class="line-added">3989         }</span>
<span class="line-added">3990         return suggestion;</span>
<span class="line-added">3991     }</span>
<span class="line-added">3992 </span>
3993     /**
3994      * Compute the full string to be displayed with the left, right and secondary prompts
3995      * @param secondaryPrompts a list to store the secondary prompts
3996      * @return the displayed string including the buffer, left prompts and the help below
3997      */
3998     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
3999         AttributedString attBuf = getHighlightedBuffer(buf.toString());
4000 
4001         AttributedString tNewBuf = insertSecondaryPrompts(attBuf, secondaryPrompts);
4002         AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);
4003         full.append(prompt);
4004         full.append(tNewBuf);
<a name="39" id="anc39"></a><span class="line-added">4005         if (doAutosuggestion) {</span>
<span class="line-added">4006             String lastBinding = getLastBinding() != null ? getLastBinding() : &quot;&quot;;</span>
<span class="line-added">4007             if (autosuggestion == SuggestionType.HISTORY) {</span>
<span class="line-added">4008                 AttributedStringBuilder sb = new AttributedStringBuilder();</span>
<span class="line-added">4009                 tailTip = matchPreviousCommand(buf.toString());</span>
<span class="line-added">4010                 sb.styled(AttributedStyle::faint, tailTip);</span>
<span class="line-added">4011                 full.append(sb.toAttributedString());</span>
<span class="line-added">4012             } else if (autosuggestion == SuggestionType.COMPLETER) {</span>
<span class="line-added">4013                 if (buf.length() &gt; 0 &amp;&amp; buf.length() == buf.cursor()</span>
<span class="line-added">4014                     &amp;&amp; (!lastBinding.equals(&quot;\t&quot;) || buf.prevChar() == &#39; &#39; || buf.prevChar() == &#39;=&#39;)) {</span>
<span class="line-added">4015                     clearChoices();</span>
<span class="line-added">4016                     listChoices(true);</span>
<span class="line-added">4017                 } else if (!lastBinding.equals(&quot;\t&quot;)) {</span>
<span class="line-added">4018                     clearChoices();</span>
<span class="line-added">4019                 }</span>
<span class="line-added">4020             } else if (autosuggestion == SuggestionType.TAIL_TIP) {</span>
<span class="line-added">4021                 if (buf.length() == buf.cursor()) {</span>
<span class="line-added">4022                     if (!lastBinding.equals(&quot;\t&quot;) || buf.prevChar() == &#39; &#39;) {</span>
<span class="line-added">4023                         clearChoices();</span>
<span class="line-added">4024                     }</span>
<span class="line-added">4025                     AttributedStringBuilder sb = new AttributedStringBuilder();</span>
<span class="line-added">4026                     if (buf.prevChar() != &#39; &#39;) {</span>
<span class="line-added">4027                         if (!tailTip.startsWith(&quot;[&quot;)) {</span>
<span class="line-added">4028                             int idx = tailTip.indexOf(&#39; &#39;);</span>
<span class="line-added">4029                             int idb = buf.toString().lastIndexOf(&#39; &#39;);</span>
<span class="line-added">4030                             int idd = buf.toString().lastIndexOf(&#39;-&#39;);</span>
<span class="line-added">4031                             if (idx &gt; 0 &amp;&amp; ((idb == -1 &amp;&amp; idb == idd) || (idb &gt;= 0 &amp;&amp; idb &gt; idd))) {</span>
<span class="line-added">4032                                 tailTip = tailTip.substring(idx);</span>
<span class="line-added">4033                             } else if (idb &gt;= 0 &amp;&amp; idb &lt; idd) {</span>
<span class="line-added">4034                                 sb.append(&quot; &quot;);</span>
<span class="line-added">4035                             }</span>
<span class="line-added">4036                         } else {</span>
<span class="line-added">4037                             sb.append(&quot; &quot;);</span>
<span class="line-added">4038                         }</span>
<span class="line-added">4039                     }</span>
<span class="line-added">4040                     sb.styled(AttributedStyle::faint, tailTip);</span>
<span class="line-added">4041                     full.append(sb.toAttributedString());</span>
<span class="line-added">4042                 }</span>
<span class="line-added">4043             }</span>
<span class="line-added">4044         }</span>
4045         if (post != null) {
4046             full.append(&quot;\n&quot;);
4047             full.append(post.get());
4048         }
<a name="40" id="anc40"></a><span class="line-added">4049         doAutosuggestion = true;</span>
4050         return full.toAttributedString();
4051     }
4052 
4053     private AttributedString getHighlightedBuffer(String buffer) {
4054         if (maskingCallback != null) {
4055             buffer = maskingCallback.display(buffer);
4056         }
<a name="41" id="anc41"></a><span class="line-modified">4057         if (highlighter != null &amp;&amp; !isSet(Option.DISABLE_HIGHLIGHTER)</span>
<span class="line-added">4058                 &amp;&amp; buffer.length() &lt; getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)) {</span>
4059             return highlighter.highlight(this, buffer);
4060         }
4061         return new AttributedString(buffer);
4062     }
4063 
4064     private AttributedString expandPromptPattern(String pattern, int padToWidth,
4065                                                  String message, int line) {
4066         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
4067         boolean isHidden = false;
4068         int padPartIndex = -1;
4069         StringBuilder padPartString = null;
4070         StringBuilder sb = new StringBuilder();
4071         // Add &quot;%{&quot; to avoid special case for end of string.
4072         pattern = pattern + &quot;%{&quot;;
4073         int plen = pattern.length();
4074         int padChar = -1;
4075         int padPos = -1;
4076         int cols = 0;
4077         for (int i = 0; i &lt; plen; ) {
4078             char ch = pattern.charAt(i++);
4079             if (ch == &#39;%&#39; &amp;&amp; i &lt; plen) {
4080                 int count = 0;
4081                 boolean countSeen = false;
4082                 decode: while (true) {
4083                     ch = pattern.charAt(i++);
4084                     switch (ch) {
4085                         case &#39;{&#39;:
4086                         case &#39;}&#39;:
4087                             String str = sb.toString();
4088                             AttributedString astr;
4089                             if (!isHidden) {
4090                                 astr = AttributedString.fromAnsi(str);
4091                                 cols += astr.columnLength();
4092                             } else {
4093                                 astr = new AttributedString(str, AttributedStyle.HIDDEN);
4094                             }
4095                             if (padPartIndex == parts.size()) {
4096                                 padPartString = sb;
4097                                 if (i &lt; plen) {
4098                                     sb = new StringBuilder();
4099                                 }
4100                             } else {
4101                                 sb.setLength(0);
4102                             }
4103                             parts.add(astr);
4104                             isHidden = ch == &#39;{&#39;;
4105                             break decode;
4106                         case &#39;%&#39;:
4107                             sb.append(ch);
4108                             break decode;
4109                         case &#39;N&#39;:
4110                             sb.append(getInt(LINE_OFFSET, 0) + line);
4111                             break decode;
4112                         case &#39;M&#39;:
4113                             if (message != null)
4114                                 sb.append(message);
4115                             break decode;
4116                         case &#39;P&#39;:
4117                             if (countSeen &amp;&amp; count &gt;= 0)
4118                                 padToWidth = count;
4119                             if (i &lt; plen) {
4120                                 padChar = pattern.charAt(i++);
4121                                 // FIXME check surrogate
4122                             }
4123                             padPos = sb.length();
4124                             padPartIndex = parts.size();
4125                             break decode;
4126                         case &#39;-&#39;:
4127                         case &#39;0&#39;:
4128                         case &#39;1&#39;:
4129                         case &#39;2&#39;:
4130                         case &#39;3&#39;:
4131                         case &#39;4&#39;:
4132                         case &#39;5&#39;:
4133                         case &#39;6&#39;:
4134                         case &#39;7&#39;:
4135                         case &#39;8&#39;:
4136                         case &#39;9&#39;:
4137                             boolean neg = false;
4138                             if (ch == &#39;-&#39;) {
4139                                 neg = true;
4140                                 ch = pattern.charAt(i++);
4141                             }
4142                             countSeen = true;
4143                             count = 0;
4144                             while (ch &gt;= &#39;0&#39; &amp;&amp; ch &lt;= &#39;9&#39;) {
4145                                 count = (count &lt; 0 ? 0 : 10 * count) + (ch - &#39;0&#39;);
4146                                 ch = pattern.charAt(i++);
4147                             }
4148                             if (neg) {
4149                                 count = -count;
4150                             }
4151                             i--;
4152                             break;
4153                         default:
4154                             break decode;
4155                     }
4156                 }
4157             } else
4158                 sb.append(ch);
4159         }
4160         if (padToWidth &gt; cols) {
4161             int padCharCols = WCWidth.wcwidth(padChar);
4162             int padCount = (padToWidth - cols) / padCharCols;
4163             sb = padPartString;
4164             while (--padCount &gt;= 0)
4165                 sb.insert(padPos, (char) padChar); // FIXME if wide
4166             parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));
4167         }
4168         return AttributedString.join(null, parts);
4169     }
4170 
4171     private AttributedString insertSecondaryPrompts(AttributedString str, List&lt;AttributedString&gt; prompts) {
4172         return insertSecondaryPrompts(str, prompts, true);
4173     }
4174 
4175     private AttributedString insertSecondaryPrompts(AttributedString strAtt, List&lt;AttributedString&gt; prompts, boolean computePrompts) {
4176         Objects.requireNonNull(prompts);
4177         List&lt;AttributedString&gt; lines = strAtt.columnSplitLength(Integer.MAX_VALUE);
4178         AttributedStringBuilder sb = new AttributedStringBuilder();
4179         String secondaryPromptPattern = getString(SECONDARY_PROMPT_PATTERN, DEFAULT_SECONDARY_PROMPT_PATTERN);
<a name="42" id="anc42"></a><span class="line-modified">4180         boolean needsMessage = secondaryPromptPattern.contains(&quot;%M&quot;)</span>
<span class="line-added">4181                 &amp;&amp; strAtt.length() &lt; getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE);</span>
4182         AttributedStringBuilder buf = new AttributedStringBuilder();
4183         int width = 0;
4184         List&lt;String&gt; missings = new ArrayList&lt;&gt;();
4185         if (computePrompts &amp;&amp; secondaryPromptPattern.contains(&quot;%P&quot;)) {
4186             width = prompt.columnLength();
4187             for (int line = 0; line &lt; lines.size() - 1; line++) {
4188                 AttributedString prompt;
4189                 buf.append(lines.get(line)).append(&quot;\n&quot;);
4190                 String missing = &quot;&quot;;
4191                 if (needsMessage) {
4192                     try {
4193                         parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
4194                     } catch (EOFError e) {
4195                         missing = e.getMissing();
4196                     } catch (SyntaxError e) {
4197                         // Ignore
4198                     }
4199                 }
4200                 missings.add(missing);
4201                 prompt = expandPromptPattern(secondaryPromptPattern, 0, missing, line + 1);
4202                 width = Math.max(width, prompt.columnLength());
4203             }
4204             buf.setLength(0);
4205         }
4206         int line = 0;
4207         while (line &lt; lines.size() - 1) {
4208             sb.append(lines.get(line)).append(&quot;\n&quot;);
4209             buf.append(lines.get(line)).append(&quot;\n&quot;);
4210             AttributedString prompt;
4211             if (computePrompts) {
4212                 String missing = &quot;&quot;;
4213                 if (needsMessage) {
4214                     if (missings.isEmpty()) {
4215                         try {
4216                             parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
4217                         } catch (EOFError e) {
4218                             missing = e.getMissing();
4219                         } catch (SyntaxError e) {
4220                             // Ignore
4221                         }
4222                     } else {
4223                         missing = missings.get(line);
4224                     }
4225                 }
4226                 prompt = expandPromptPattern(secondaryPromptPattern, width, missing, line + 1);
4227             } else {
4228                 prompt = prompts.get(line);
4229             }
4230             prompts.add(prompt);
4231             sb.append(prompt);
4232             line++;
4233         }
4234         sb.append(lines.get(line));
4235         buf.append(lines.get(line));
4236         return sb.toAttributedString();
4237     }
4238 
4239     private AttributedString addRightPrompt(AttributedString prompt, AttributedString line) {
4240         int width = prompt.columnLength();
4241         boolean endsWithNl = line.length() &gt; 0
4242             &amp;&amp; line.charAt(line.length() - 1) == &#39;\n&#39;;
4243         // columnLength counts -1 for the final newline; adjust for that
4244         int nb = size.getColumns() - width
4245             - (line.columnLength() + (endsWithNl ? 1 : 0));
4246         if (nb &gt;= 3) {
4247             AttributedStringBuilder sb = new AttributedStringBuilder(size.getColumns());
4248             sb.append(line, 0, endsWithNl ? line.length() - 1 : line.length());
4249             for (int j = 0; j &lt; nb; j++) {
4250                 sb.append(&#39; &#39;);
4251             }
4252             sb.append(prompt);
4253             if (endsWithNl) {
4254                 sb.append(&#39;\n&#39;);
4255             }
4256             line = sb.toAttributedString();
4257         }
4258         return line;
4259     }
4260 
4261     //
4262     // Completion
4263     //
4264 
4265     protected boolean insertTab() {
4266         return isSet(Option.INSERT_TAB)
4267                     &amp;&amp; getLastBinding().equals(&quot;\t&quot;)
4268                     &amp;&amp; buf.toString().matches(&quot;(^|[\\s\\S]*\n)[\r\n\t ]*&quot;);
4269     }
4270 
4271     protected boolean expandHistory() {
4272         String str = buf.toString();
4273         String exp = expander.expandHistory(history, str);
4274         if (!exp.equals(str)) {
4275             buf.clear();
4276             buf.write(exp);
4277             return true;
4278         } else {
4279             return false;
4280         }
4281     }
4282 
4283     protected enum CompletionType {
4284         Expand,
4285         ExpandComplete,
4286         Complete,
4287         List,
4288     }
4289 
4290     protected boolean expandWord() {
4291         if (insertTab()) {
4292             return selfInsert();
4293         } else {
4294             return doComplete(CompletionType.Expand, isSet(Option.MENU_COMPLETE), false);
4295         }
4296     }
4297 
4298     protected boolean expandOrComplete() {
4299         if (insertTab()) {
4300             return selfInsert();
4301         } else {
4302             return doComplete(CompletionType.ExpandComplete, isSet(Option.MENU_COMPLETE), false);
4303         }
4304     }
4305 
4306     protected boolean expandOrCompletePrefix() {
4307         if (insertTab()) {
4308             return selfInsert();
4309         } else {
4310             return doComplete(CompletionType.ExpandComplete, isSet(Option.MENU_COMPLETE), true);
4311         }
4312     }
4313 
4314     protected boolean completeWord() {
4315         if (insertTab()) {
4316             return selfInsert();
4317         } else {
4318             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), false);
4319         }
4320     }
4321 
4322     protected boolean menuComplete() {
4323         if (insertTab()) {
4324             return selfInsert();
4325         } else {
4326             return doComplete(CompletionType.Complete, true, false);
4327         }
4328     }
4329 
4330     protected boolean menuExpandOrComplete() {
4331         if (insertTab()) {
4332             return selfInsert();
4333         } else {
4334             return doComplete(CompletionType.ExpandComplete, true, false);
4335         }
4336     }
4337 
4338     protected boolean completePrefix() {
4339         if (insertTab()) {
4340             return selfInsert();
4341         } else {
4342             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), true);
4343         }
4344     }
4345 
4346     protected boolean listChoices() {
<a name="43" id="anc43"></a><span class="line-modified">4347         return listChoices(false);</span>
<span class="line-added">4348     }</span>
<span class="line-added">4349 </span>
<span class="line-added">4350     private boolean listChoices(boolean forSuggestion) {</span>
<span class="line-added">4351         return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false, forSuggestion);</span>
4352     }
4353 
4354     protected boolean deleteCharOrList() {
4355         if (buf.cursor() != buf.length() || buf.length() == 0) {
4356             return deleteChar();
4357         } else {
4358             return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
4359         }
4360     }
4361 
4362     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {
<a name="44" id="anc44"></a><span class="line-added">4363         return doComplete(lst, useMenu, prefix, false);</span>
<span class="line-added">4364     }</span>
<span class="line-added">4365 </span>
<span class="line-added">4366     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix, boolean forSuggestion) {</span>
4367         // If completion is disabled, just bail out
4368         if (getBoolean(DISABLE_COMPLETION, false)) {
4369             return true;
4370         }
4371         // Try to expand history first
4372         // If there is actually an expansion, bail out now
4373         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
4374             try {
4375                 if (expandHistory()) {
4376                     return true;
4377                 }
4378             } catch (Exception e) {
4379                 Log.info(&quot;Error while expanding history&quot;, e);
4380                 return false;
4381             }
4382         }
4383 
4384         // Parse the command line
4385         CompletingParsedLine line;
4386         try {
4387             line = wrap(parser.parse(buf.toString(), buf.cursor(), ParseContext.COMPLETE));
4388         } catch (Exception e) {
4389             Log.info(&quot;Error while parsing line&quot;, e);
4390             return false;
4391         }
4392 
4393         // Find completion candidates
4394         List&lt;Candidate&gt; candidates = new ArrayList&lt;&gt;();
4395         try {
4396             if (completer != null) {
4397                 completer.complete(this, line, candidates);
4398             }
4399         } catch (Exception e) {
4400             Log.info(&quot;Error while finding completion candidates&quot;, e);
4401             return false;
4402         }
4403 
4404         if (lst == CompletionType.ExpandComplete || lst == CompletionType.Expand) {
4405             String w = expander.expandVar(line.word());
4406             if (!line.word().equals(w)) {
4407                 if (prefix) {
4408                     buf.backspace(line.wordCursor());
4409                 } else {
4410                     buf.move(line.word().length() - line.wordCursor());
4411                     buf.backspace(line.word().length());
4412                 }
4413                 buf.write(w);
4414                 return true;
4415             }
4416             if (lst == CompletionType.Expand) {
4417                 return false;
4418             } else {
4419                 lst = CompletionType.Complete;
4420             }
4421         }
4422 
4423         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4424         int errors = getInt(ERRORS, DEFAULT_ERRORS);
4425 
4426         // Build a list of sorted candidates
4427         Map&lt;String, List&lt;Candidate&gt;&gt; sortedCandidates = new HashMap&lt;&gt;();
4428         for (Candidate cand : candidates) {
4429             sortedCandidates
4430                     .computeIfAbsent(AttributedString.fromAnsi(cand.value()).toString(), s -&gt; new ArrayList&lt;&gt;())
4431                     .add(cand);
4432         }
4433 
4434         // Find matchers
4435         // TODO: glob completion
4436         List&lt;Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4437                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt;&gt; matchers;
4438         Predicate&lt;String&gt; exact;
4439         if (prefix) {
4440             String wd = line.word();
4441             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4442             String wp = wdi.substring(0, line.wordCursor());
4443             matchers = Arrays.asList(
4444                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wp)),
4445                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wp)),
4446                     typoMatcher(wp, errors, caseInsensitive)
4447             );
4448             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);
4449         } else if (isSet(Option.COMPLETE_IN_WORD)) {
4450             String wd = line.word();
4451             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4452             String wp = wdi.substring(0, line.wordCursor());
4453             String ws = wdi.substring(line.wordCursor());
4454             Pattern p1 = Pattern.compile(Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4455             Pattern p2 = Pattern.compile(&quot;.*&quot; + Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4456             matchers = Arrays.asList(
4457                     simpleMatcher(s -&gt; p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4458                     simpleMatcher(s -&gt; p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4459                     typoMatcher(wdi, errors, caseInsensitive)
4460             );
4461             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4462         } else {
4463             String wd = line.word();
4464             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
<a name="45" id="anc45"></a><span class="line-modified">4465             if (isSet(Option.EMPTY_WORD_OPTIONS) || wd.length() &gt; 0) {</span>
<span class="line-modified">4466                 matchers = Arrays.asList(</span>
<span class="line-modified">4467                         simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),</span>
<span class="line-modified">4468                         simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),</span>
<span class="line-modified">4469                         typoMatcher(wdi, errors, caseInsensitive)</span>
<span class="line-added">4470                 );</span>
<span class="line-added">4471             } else {</span>
<span class="line-added">4472                 matchers = Arrays.asList(</span>
<span class="line-added">4473                         simpleMatcher(s -&gt; !s.startsWith(&quot;-&quot;))</span>
<span class="line-added">4474                 );</span>
<span class="line-added">4475             }</span>
4476             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4477         }
4478         // Find matching candidates
4479         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4480         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4481                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4482             matching = matcher.apply(sortedCandidates);
4483             if (!matching.isEmpty()) {
4484                 break;
4485             }
4486         }
4487 
4488         // If we have no matches, bail out
4489         if (matching.isEmpty()) {
4490             return false;
4491         }
4492         size.copy(terminal.getSize());
4493         try {
4494             // If we only need to display the list, do it now
4495             if (lst == CompletionType.List) {
4496                 List&lt;Candidate&gt; possible = matching.entrySet().stream()
4497                         .flatMap(e -&gt; e.getValue().stream())
4498                         .collect(Collectors.toList());
<a name="46" id="anc46"></a><span class="line-modified">4499                 doList(possible, line.word(), false, line::escape, forSuggestion);</span>
4500                 return !possible.isEmpty();
4501             }
4502 
4503             // Check if there&#39;s a single possible match
4504             Candidate completion = null;
4505             // If there&#39;s a single possible completion
4506             if (matching.size() == 1) {
4507                 completion = matching.values().stream().flatMap(Collection::stream)
4508                         .findFirst().orElse(null);
4509             }
4510             // Or if RECOGNIZE_EXACT is set, try to find an exact match
4511             else if (isSet(Option.RECOGNIZE_EXACT)) {
4512                 completion = matching.values().stream().flatMap(Collection::stream)
4513                         .filter(Candidate::complete)
4514                         .filter(c -&gt; exact.test(c.value()))
4515                         .findFirst().orElse(null);
4516             }
4517             // Complete and exit
4518             if (completion != null &amp;&amp; !completion.value().isEmpty()) {
4519                 if (prefix) {
4520                     buf.backspace(line.rawWordCursor());
4521                 } else {
4522                     buf.move(line.rawWordLength() - line.rawWordCursor());
4523                     buf.backspace(line.rawWordLength());
4524                 }
4525                 buf.write(line.escape(completion.value(), completion.complete()));
4526                 if (completion.complete()) {
4527                     if (buf.currChar() != &#39; &#39;) {
4528                         buf.write(&quot; &quot;);
4529                     } else {
4530                         buf.move(1);
4531                     }
4532                 }
4533                 if (completion.suffix() != null) {
4534                     redisplay();
4535                     Binding op = readBinding(getKeys());
4536                     if (op != null) {
4537                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);
4538                         String ref = op instanceof Reference ? ((Reference) op).name() : null;
4539                         if (SELF_INSERT.equals(ref) &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4540                                 || ACCEPT_LINE.equals(ref)) {
4541                             buf.backspace(completion.suffix().length());
4542                             if (getLastBinding().charAt(0) != &#39; &#39;) {
4543                                 buf.write(&#39; &#39;);
4544                             }
4545                         }
4546                         pushBackBinding(true);
4547                     }
4548                 }
4549                 return true;
4550             }
4551 
4552             List&lt;Candidate&gt; possible = matching.entrySet().stream()
4553                     .flatMap(e -&gt; e.getValue().stream())
4554                     .collect(Collectors.toList());
4555 
4556             if (useMenu) {
4557                 buf.move(line.word().length() - line.wordCursor());
4558                 buf.backspace(line.word().length());
4559                 doMenu(possible, line.word(), line::escape);
4560                 return true;
4561             }
4562 
4563             // Find current word and move to end
4564             String current;
4565             if (prefix) {
4566                 current = line.word().substring(0, line.wordCursor());
4567             } else {
4568                 current = line.word();
4569                 buf.move(line.rawWordLength() - line.rawWordCursor());
4570             }
4571             // Now, we need to find the unambiguous completion
4572             // TODO: need to find common suffix
4573             String commonPrefix = null;
4574             for (String key : matching.keySet()) {
4575                 commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);
4576             }
4577             boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);
4578 
4579             if (hasUnambiguous) {
4580                 buf.backspace(line.rawWordLength());
4581                 buf.write(line.escape(commonPrefix, false));
<a name="47" id="anc47"></a><span class="line-added">4582                 callWidget(REDISPLAY);</span>
4583                 current = commonPrefix;
4584                 if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))
4585                         || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {
4586                     if (!nextBindingIsComplete()) {
4587                         return true;
4588                     }
4589                 }
4590             }
4591             if (isSet(Option.AUTO_LIST)) {
4592                 if (!doList(possible, current, true, line::escape)) {
4593                     return true;
4594                 }
4595             }
4596             if (isSet(Option.AUTO_MENU)) {
4597                 buf.backspace(current.length());
4598                 doMenu(possible, line.word(), line::escape);
4599             }
4600             return true;
4601         } finally {
4602             size.copy(terminal.getBufferSize());
4603         }
4604     }
4605 
4606     private CompletingParsedLine wrap(ParsedLine line) {
4607         if (line instanceof CompletingParsedLine) {
4608             return (CompletingParsedLine) line;
4609         } else {
4610             return new CompletingParsedLine() {
4611                 public String word() {
4612                     return line.word();
4613                 }
4614                 public int wordCursor() {
4615                     return line.wordCursor();
4616                 }
4617                 public int wordIndex() {
4618                     return line.wordIndex();
4619                 }
4620                 public List&lt;String&gt; words() {
4621                     return line.words();
4622                 }
4623                 public String line() {
4624                     return line.line();
4625                 }
4626                 public int cursor() {
4627                     return line.cursor();
4628                 }
4629                 public CharSequence escape(CharSequence candidate, boolean complete) {
4630                     return candidate;
4631                 }
4632                 public int rawWordCursor() {
4633                     return wordCursor();
4634                 }
4635                 public int rawWordLength() {
4636                     return word().length();
4637                 }
4638             };
4639         }
4640     }
4641 
4642     protected Comparator&lt;Candidate&gt; getCandidateComparator(boolean caseInsensitive, String word) {
4643         String wdi = caseInsensitive ? word.toLowerCase() : word;
4644         ToIntFunction&lt;String&gt; wordDistance = w -&gt; distance(wdi, caseInsensitive ? w.toLowerCase() : w);
4645         return Comparator
4646                 .comparing(Candidate::value, Comparator.comparingInt(wordDistance))
<a name="48" id="anc48"></a>
4647                 .thenComparing(Comparator.naturalOrder());
4648     }
4649 
4650     protected String getOthersGroupName() {
4651         return getString(OTHERS_GROUP_NAME, DEFAULT_OTHERS_GROUP_NAME);
4652     }
4653 
4654     protected String getOriginalGroupName() {
4655         return getString(ORIGINAL_GROUP_NAME, DEFAULT_ORIGINAL_GROUP_NAME);
4656     }
4657 
4658 
4659     protected Comparator&lt;String&gt; getGroupComparator() {
4660         return Comparator.&lt;String&gt;comparingInt(s -&gt; getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)
4661                 .thenComparing(String::toLowerCase, Comparator.naturalOrder());
4662     }
4663 
4664     private void mergeCandidates(List&lt;Candidate&gt; possible) {
4665         // Merge candidates if the have the same key
4666         Map&lt;String, List&lt;Candidate&gt;&gt; keyedCandidates = new HashMap&lt;&gt;();
4667         for (Candidate candidate : possible) {
4668             if (candidate.key() != null) {
4669                 List&lt;Candidate&gt; cands = keyedCandidates.computeIfAbsent(candidate.key(), s -&gt; new ArrayList&lt;&gt;());
4670                 cands.add(candidate);
4671             }
4672         }
4673         if (!keyedCandidates.isEmpty()) {
4674             for (List&lt;Candidate&gt; candidates : keyedCandidates.values()) {
4675                 if (candidates.size() &gt;= 1) {
4676                     possible.removeAll(candidates);
4677                     // Candidates with the same key are supposed to have
4678                     // the same description
4679                     candidates.sort(Comparator.comparing(Candidate::value));
4680                     Candidate first = candidates.get(0);
4681                     String disp = candidates.stream()
4682                             .map(Candidate::displ)
4683                             .collect(Collectors.joining(&quot; &quot;));
4684                     possible.add(new Candidate(first.value(), disp, first.group(),
4685                             first.descr(), first.suffix(), null, first.complete()));
4686                 }
4687             }
4688         }
4689     }
4690 
4691     private Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4692                      Map&lt;String, List&lt;Candidate&gt;&gt;&gt; simpleMatcher(Predicate&lt;String&gt; pred) {
4693         return m -&gt; m.entrySet().stream()
4694                 .filter(e -&gt; pred.test(e.getKey()))
4695                 .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
4696     }
4697 
4698     private Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4699                      Map&lt;String, List&lt;Candidate&gt;&gt;&gt; typoMatcher(String word, int errors, boolean caseInsensitive) {
4700         return m -&gt; {
4701             Map&lt;String, List&lt;Candidate&gt;&gt; map = m.entrySet().stream()
4702                     .filter(e -&gt; distance(word, caseInsensitive ? e.getKey() : e.getKey().toLowerCase()) &lt; errors)
4703                     .collect(Collectors.toMap(Entry::getKey, Entry::getValue));
4704             if (map.size() &gt; 1) {
4705                 map.computeIfAbsent(word, w -&gt; new ArrayList&lt;&gt;())
4706                         .add(new Candidate(word, word, getOriginalGroupName(), null, null, null, false));
4707             }
4708             return map;
4709         };
4710     }
4711 
4712     private int distance(String word, String cand) {
4713         if (word.length() &lt; cand.length()) {
4714             int d1 = Levenshtein.distance(word, cand.substring(0, Math.min(cand.length(), word.length())));
4715             int d2 = Levenshtein.distance(word, cand);
4716             return Math.min(d1, d2);
4717         } else {
4718             return Levenshtein.distance(word, cand);
4719         }
4720     }
4721 
4722     protected boolean nextBindingIsComplete() {
4723         redisplay();
4724         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4725         Binding operation = readBinding(getKeys(), keyMap);
4726         if (operation instanceof Reference &amp;&amp; MENU_COMPLETE.equals(((Reference) operation).name())) {
4727             return true;
4728         } else {
4729             pushBackBinding();
4730             return false;
4731         }
4732     }
4733 
4734     private class MenuSupport implements Supplier&lt;AttributedString&gt; {
4735         final List&lt;Candidate&gt; possible;
4736         final BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper;
4737         int selection;
4738         int topLine;
4739         String word;
4740         AttributedString computed;
4741         int lines;
4742         int columns;
4743         String completed;
4744 
4745         public MenuSupport(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4746             this.possible = new ArrayList&lt;&gt;();
4747             this.escaper = escaper;
4748             this.selection = -1;
4749             this.topLine = 0;
4750             this.word = &quot;&quot;;
4751             this.completed = completed;
4752             computePost(original, null, possible, completed);
4753             next();
4754         }
4755 
4756         public Candidate completion() {
4757             return possible.get(selection);
4758         }
4759 
4760         public void next() {
4761             selection = (selection + 1) % possible.size();
4762             update();
4763         }
4764 
4765         public void previous() {
4766             selection = (selection + possible.size() - 1) % possible.size();
4767             update();
4768         }
4769 
4770         /**
4771          * Move &#39;step&#39; options along the major axis of the menu.&lt;p&gt;
4772          * ie. if the menu is listing rows first, change row (up/down);
4773          * otherwise move column (left/right)
4774          *
4775          * @param step number of options to move by
4776          */
4777         private void major(int step) {
4778             int axis = isSet(Option.LIST_ROWS_FIRST) ? columns : lines;
4779             int sel = selection + step * axis;
4780             if (sel &lt; 0) {
4781                 int pos = (sel + axis) % axis; // needs +axis as (-1)%x == -1
4782                 int remainders = possible.size() % axis;
4783                 sel = possible.size() - remainders + pos;
4784                 if (sel &gt;= possible.size()) {
4785                     sel -= axis;
4786                 }
4787             } else if (sel &gt;= possible.size()) {
4788                 sel = sel % axis;
4789             }
4790             selection = sel;
4791             update();
4792         }
4793 
4794         /**
4795          * Move &#39;step&#39; options along the minor axis of the menu.&lt;p&gt;
4796          * ie. if the menu is listing rows first, move along the row (left/right);
4797          * otherwise move along the column (up/down)
4798          *
4799          * @param step number of options to move by
4800          */
4801         private void minor(int step) {
4802             int axis = isSet(Option.LIST_ROWS_FIRST) ? columns : lines;
4803             int row = selection % axis;
4804             int options = possible.size();
4805             if (selection - row + axis &gt; options) {
4806                 // selection is the last row/column
4807                 // so there are fewer options than other rows
4808                 axis = options%axis;
4809             }
4810             selection = selection - row + ((axis + row + step) % axis);
4811             update();
4812         }
4813 
4814         public void up() {
4815             if (isSet(Option.LIST_ROWS_FIRST)) {
4816                 major(-1);
4817             } else {
4818                 minor(-1);
4819             }
4820         }
4821 
4822         public void down() {
4823             if (isSet(Option.LIST_ROWS_FIRST)) {
4824                 major(1);
4825             } else {
4826                 minor(1);
4827             }
4828         }
4829 
4830         public void left() {
4831             if (isSet(Option.LIST_ROWS_FIRST)) {
4832                 minor(-1);
4833             } else {
4834                 major(-1);
4835             }
4836         }
4837 
4838         public void right() {
4839             if (isSet(Option.LIST_ROWS_FIRST)) {
4840                 minor(1);
4841             } else {
4842                 major(1);
4843             }
4844         }
4845 
4846         private void update() {
4847             buf.backspace(word.length());
4848             word = escaper.apply(completion().value(), true).toString();
4849             buf.write(word);
4850 
4851             // Compute displayed prompt
4852             PostResult pr = computePost(possible, completion(), null, completed);
4853             AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4854             int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
<a name="49" id="anc49"></a><span class="line-modified">4855             Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">4856             int displaySize = size.getRows() - (status != null ? status.size() : 0) - promptLines;</span>
<span class="line-added">4857             if (pr.lines &gt; displaySize) {</span>
<span class="line-added">4858                 int displayed = displaySize - 1;</span>
4859                 if (pr.selectedLine &gt;= 0) {
4860                     if (pr.selectedLine &lt; topLine) {
4861                         topLine = pr.selectedLine;
4862                     } else if (pr.selectedLine &gt;= topLine + displayed) {
4863                         topLine = pr.selectedLine - displayed + 1;
4864                     }
4865                 }
4866                 AttributedString post = pr.post;
4867                 if (post.length() &gt; 0 &amp;&amp; post.charAt(post.length() - 1) != &#39;\n&#39;) {
4868                     post = new AttributedStringBuilder(post.length() + 1)
4869                             .append(post).append(&quot;\n&quot;).toAttributedString();
4870                 }
4871                 List&lt;AttributedString&gt; lines = post.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
4872                 List&lt;AttributedString&gt; sub = new ArrayList&lt;&gt;(lines.subList(topLine, topLine + displayed));
4873                 sub.add(new AttributedStringBuilder()
4874                         .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))
4875                         .append(&quot;rows &quot;)
4876                         .append(Integer.toString(topLine + 1))
4877                         .append(&quot; to &quot;)
4878                         .append(Integer.toString(topLine + displayed))
4879                         .append(&quot; of &quot;)
4880                         .append(Integer.toString(lines.size()))
4881                         .append(&quot;\n&quot;)
4882                         .style(AttributedStyle.DEFAULT).toAttributedString());
4883                 computed = AttributedString.join(AttributedString.EMPTY, sub);
4884             } else {
4885                 computed = pr.post;
4886             }
4887             lines = pr.lines;
4888             columns = (possible.size() + lines - 1) / lines;
4889         }
4890 
4891         @Override
4892         public AttributedString get() {
4893             return computed;
4894         }
4895 
4896     }
4897 
4898     protected boolean doMenu(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4899         // Reorder candidates according to display order
4900         final List&lt;Candidate&gt; possible = new ArrayList&lt;&gt;();
4901         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4902         original.sort(getCandidateComparator(caseInsensitive, completed));
4903         mergeCandidates(original);
4904         computePost(original, null, possible, completed);
4905 
4906         // Build menu support
4907         MenuSupport menuSupport = new MenuSupport(original, completed, escaper);
4908         post = menuSupport;
<a name="50" id="anc50"></a><span class="line-modified">4909         callWidget(REDISPLAY);</span>
4910 
4911         // Loop
4912         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4913         Binding operation;
4914         while ((operation = readBinding(getKeys(), keyMap)) != null) {
4915             String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
4916             switch (ref) {
4917                 case MENU_COMPLETE:
4918                     menuSupport.next();
4919                     break;
4920                 case REVERSE_MENU_COMPLETE:
4921                     menuSupport.previous();
4922                     break;
4923                 case UP_LINE_OR_HISTORY:
4924                 case UP_LINE_OR_SEARCH:
4925                     menuSupport.up();
4926                     break;
4927                 case DOWN_LINE_OR_HISTORY:
4928                 case DOWN_LINE_OR_SEARCH:
4929                     menuSupport.down();
4930                     break;
4931                 case FORWARD_CHAR:
4932                     menuSupport.right();
4933                     break;
4934                 case BACKWARD_CHAR:
4935                     menuSupport.left();
4936                     break;
4937                 case CLEAR_SCREEN:
4938                     clearScreen();
4939                     break;
4940                 default: {
4941                     Candidate completion = menuSupport.completion();
4942                     if (completion.suffix() != null) {
4943                         String chars = getString(REMOVE_SUFFIX_CHARS, DEFAULT_REMOVE_SUFFIX_CHARS);
4944                         if (SELF_INSERT.equals(ref)
4945                                 &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4946                                 || BACKWARD_DELETE_CHAR.equals(ref)) {
4947                             buf.backspace(completion.suffix().length());
4948                         }
4949                     }
4950                     if (completion.complete()
4951                             &amp;&amp; getLastBinding().charAt(0) != &#39; &#39;
4952                             &amp;&amp; (SELF_INSERT.equals(ref) || getLastBinding().charAt(0) != &#39; &#39;)) {
4953                         buf.write(&#39; &#39;);
4954                     }
4955                     if (!ACCEPT_LINE.equals(ref)
4956                             &amp;&amp; !(SELF_INSERT.equals(ref)
4957                                 &amp;&amp; completion.suffix() != null
4958                                 &amp;&amp; completion.suffix().startsWith(getLastBinding()))) {
4959                         pushBackBinding(true);
4960                     }
4961                     post = null;
4962                     return true;
4963                 }
4964             }
<a name="51" id="anc51"></a><span class="line-modified">4965             doAutosuggestion = false;</span>
<span class="line-added">4966             callWidget(REDISPLAY);</span>
4967         }
4968         return false;
4969     }
4970 
<a name="52" id="anc52"></a><span class="line-modified">4971     protected boolean clearChoices() {</span>
<span class="line-added">4972         return doList(new ArrayList&lt;Candidate&gt;(), &quot;&quot;, false, null, false);</span>
<span class="line-added">4973     }</span>
<span class="line-added">4974 </span>
<span class="line-added">4975     protected boolean doList(List&lt;Candidate&gt; possible</span>
<span class="line-added">4976                            , String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {</span>
<span class="line-added">4977         return doList(possible, completed, runLoop, escaper, false);</span>
<span class="line-added">4978     }</span>
<span class="line-added">4979 </span>
<span class="line-added">4980     protected boolean doList(List&lt;Candidate&gt; possible</span>
<span class="line-added">4981                            , String completed</span>
<span class="line-added">4982                            , boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper, boolean forSuggestion) {</span>
4983         // If we list only and if there&#39;s a big
4984         // number of items, we should ask the user
4985         // for confirmation, display the list
4986         // and redraw the line at the bottom
4987         mergeCandidates(possible);
4988         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4989         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4990         PostResult postResult = computePost(possible, null, null, completed);
4991         int lines = postResult.lines;
4992         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4993         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4994                 || lines &gt;= size.getRows() - promptLines) {
<a name="53" id="anc53"></a><span class="line-modified">4995             if (!forSuggestion) {</span>
<span class="line-modified">4996                 // prompt</span>
<span class="line-modified">4997                 post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see all &quot; + possible.size()</span>
<span class="line-modified">4998                         + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);</span>
<span class="line-modified">4999                 redisplay(true);</span>
<span class="line-modified">5000                 int c = readCharacter();</span>
<span class="line-modified">5001                 if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {</span>
<span class="line-added">5002                     post = null;</span>
<span class="line-added">5003                     return false;</span>
<span class="line-added">5004                 }</span>
<span class="line-added">5005             } else {</span>
5006                 return false;
5007             }
5008         }
5009 
5010         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
5011         StringBuilder sb = new StringBuilder();
5012         while (true) {
5013             String current = completed + sb.toString();
5014             List&lt;Candidate&gt; cands;
5015             if (sb.length() &gt; 0) {
5016                 cands = possible.stream()
5017                         .filter(c -&gt; caseInsensitive
5018                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
5019                                     : c.value().startsWith(current))
5020                         .sorted(getCandidateComparator(caseInsensitive, current))
5021                         .collect(Collectors.toList());
5022             } else {
5023                 cands = possible.stream()
5024                         .sorted(getCandidateComparator(caseInsensitive, current))
5025                         .collect(Collectors.toList());
5026             }
5027             post = () -&gt; {
5028                 AttributedString t = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
5029                 int pl = t.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
5030                 PostResult pr = computePost(cands, null, null, current);
5031                 if (pr.lines &gt;= size.getRows() - pl) {
5032                     post = null;
5033                     int oldCursor = buf.cursor();
5034                     buf.cursor(buf.length());
5035                     redisplay(false);
5036                     buf.cursor(oldCursor);
5037                     println();
5038                     List&lt;AttributedString&gt; ls = postResult.post.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
5039                     Display d = new Display(terminal, false);
5040                     d.resize(size.getRows(), size.getColumns());
5041                     d.update(ls, -1);
5042                     redrawLine();
5043                     return new AttributedString(&quot;&quot;);
5044                 }
5045                 return pr.post;
5046             };
5047             if (!runLoop) {
5048                 return false;
5049             }
5050             redisplay();
5051             // TODO: use a different keyMap ?
5052             Binding b = doReadBinding(getKeys(), null);
5053             if (b instanceof Reference) {
5054                 String name = ((Reference) b).name();
5055                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
5056                     if (sb.length() == 0) {
5057                         pushBackBinding();
5058                         post = null;
5059                         return false;
5060                     } else {
5061                         sb.setLength(sb.length() - 1);
5062                         buf.backspace();
5063                     }
5064                 } else if (SELF_INSERT.equals(name)) {
5065                     sb.append(getLastBinding());
<a name="54" id="anc54"></a><span class="line-modified">5066                     callWidget(name);</span>
5067                     if (cands.isEmpty()) {
5068                         post = null;
5069                         return false;
5070                     }
5071                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
5072                     if (cands.size() == 1 || sb.length() &gt; 0) {
5073                         post = null;
5074                         pushBackBinding();
5075                     } else if (isSet(Option.AUTO_MENU)) {
5076                         buf.backspace(escaper.apply(current, false).length());
5077                         doMenu(cands, current, escaper);
5078                     }
5079                     return false;
5080                 } else {
5081                     pushBackBinding();
5082                     post = null;
5083                     return false;
5084                 }
5085             } else if (b == null) {
5086                 post = null;
5087                 return false;
5088             }
5089         }
5090     }
5091 
5092     protected static class PostResult {
5093         final AttributedString post;
5094         final int lines;
5095         final int selectedLine;
5096 
5097         public PostResult(AttributedString post, int lines, int selectedLine) {
5098             this.post = post;
5099             this.lines = lines;
5100             this.selectedLine = selectedLine;
5101         }
5102     }
5103 
5104     protected PostResult computePost(List&lt;Candidate&gt; possible, Candidate selection, List&lt;Candidate&gt; ordered, String completed) {
5105         return computePost(possible, selection, ordered, completed, display::wcwidth, size.getColumns(), isSet(Option.AUTO_GROUP), isSet(Option.GROUP), isSet(Option.LIST_ROWS_FIRST));
5106     }
5107 
5108     protected PostResult computePost(List&lt;Candidate&gt; possible, Candidate selection, List&lt;Candidate&gt; ordered, String completed, Function&lt;String, Integer&gt; wcwidth, int width, boolean autoGroup, boolean groupName, boolean rowsFirst) {
5109         List&lt;Object&gt; strings = new ArrayList&lt;&gt;();
5110         if (groupName) {
5111             Comparator&lt;String&gt; groupComparator = getGroupComparator();
5112             Map&lt;String, Map&lt;String, Candidate&gt;&gt; sorted;
5113             sorted = groupComparator != null
5114                         ? new TreeMap&lt;&gt;(groupComparator)
5115                         : new LinkedHashMap&lt;&gt;();
5116             for (Candidate cand : possible) {
5117                 String group = cand.group();
5118                 sorted.computeIfAbsent(group != null ? group : &quot;&quot;, s -&gt; new LinkedHashMap&lt;&gt;())
5119                         .put(cand.value(), cand);
5120             }
5121             for (Map.Entry&lt;String, Map&lt;String, Candidate&gt;&gt; entry : sorted.entrySet()) {
5122                 String group = entry.getKey();
5123                 if (group.isEmpty() &amp;&amp; sorted.size() &gt; 1) {
5124                     group = getOthersGroupName();
5125                 }
5126                 if (!group.isEmpty() &amp;&amp; autoGroup) {
5127                     strings.add(group);
5128                 }
5129                 strings.add(new ArrayList&lt;&gt;(entry.getValue().values()));
5130                 if (ordered != null) {
5131                     ordered.addAll(entry.getValue().values());
5132                 }
5133             }
5134         } else {
5135             Set&lt;String&gt; groups = new LinkedHashSet&lt;&gt;();
5136             TreeMap&lt;String, Candidate&gt; sorted = new TreeMap&lt;&gt;();
5137             for (Candidate cand : possible) {
5138                 String group = cand.group();
5139                 if (group != null) {
5140                     groups.add(group);
5141                 }
5142                 sorted.put(cand.value(), cand);
5143             }
5144             if (autoGroup) {
5145                 strings.addAll(groups);
5146             }
5147             strings.add(new ArrayList&lt;&gt;(sorted.values()));
5148             if (ordered != null) {
5149                 ordered.addAll(sorted.values());
5150             }
5151         }
5152         return toColumns(strings, selection, completed, wcwidth, width, rowsFirst);
5153     }
5154 
5155     private static final String DESC_PREFIX = &quot;(&quot;;
5156     private static final String DESC_SUFFIX = &quot;)&quot;;
5157     private static final int MARGIN_BETWEEN_DISPLAY_AND_DESC = 1;
5158     private static final int MARGIN_BETWEEN_COLUMNS = 3;
5159 
5160     @SuppressWarnings(&quot;unchecked&quot;)
5161     protected PostResult toColumns(List&lt;Object&gt; items, Candidate selection, String completed, Function&lt;String, Integer&gt; wcwidth, int width, boolean rowsFirst) {
5162         int[] out = new int[2];
5163         // TODO: support Option.LIST_PACKED
5164         // Compute column width
5165         int maxWidth = 0;
5166         for (Object item : items) {
5167             if (item instanceof String) {
5168                 int len = wcwidth.apply((String) item);
5169                 maxWidth = Math.max(maxWidth, len);
5170             }
5171             else if (item instanceof List) {
5172                 for (Candidate cand : (List&lt;Candidate&gt;) item) {
5173                     int len = wcwidth.apply(cand.displ());
5174                     if (cand.descr() != null) {
5175                         len += MARGIN_BETWEEN_DISPLAY_AND_DESC;
5176                         len += DESC_PREFIX.length();
5177                         len += wcwidth.apply(cand.descr());
5178                         len += DESC_SUFFIX.length();
5179                     }
5180                     maxWidth = Math.max(maxWidth, len);
5181                 }
5182             }
5183         }
5184         // Build columns
5185         AttributedStringBuilder sb = new AttributedStringBuilder();
5186         for (Object list : items) {
5187             toColumns(list, width, maxWidth, sb, selection, completed, rowsFirst, out);
5188         }
5189         if (sb.length() &gt; 0 &amp;&amp; sb.charAt(sb.length() - 1) == &#39;\n&#39;) {
5190             sb.setLength(sb.length() - 1);
5191         }
5192         return new PostResult(sb.toAttributedString(), out[0], out[1]);
5193     }
5194 
5195     @SuppressWarnings(&quot;unchecked&quot;)
5196     protected void toColumns(Object items, int width, int maxWidth, AttributedStringBuilder sb, Candidate selection, String completed, boolean rowsFirst, int[] out) {
5197         if (maxWidth &lt;= 0 || width &lt;= 0) {
5198             return;
5199         }
5200         // This is a group
5201         if (items instanceof String) {
5202             sb.style(getCompletionStyleGroup())
5203                     .append((String) items)
5204                     .style(AttributedStyle.DEFAULT)
5205                     .append(&quot;\n&quot;);
5206             out[0]++;
5207         }
5208         // This is a Candidate list
5209         else if (items instanceof List) {
5210             List&lt;Candidate&gt; candidates = (List&lt;Candidate&gt;) items;
5211             maxWidth = Math.min(width, maxWidth);
5212             int c = width / maxWidth;
5213             while (c &gt; 1 &amp;&amp; c * maxWidth + (c - 1) * MARGIN_BETWEEN_COLUMNS &gt;= width) {
5214                 c--;
5215             }
5216             int lines = (candidates.size() + c - 1) / c;
5217             // Try to minimize the number of columns for the given number of rows
5218             // Prevents eg 9 candiates being split 6/3 instead of 5/4.
5219             final int columns = (candidates.size() + lines - 1) / lines;
5220             IntBinaryOperator index;
5221             if (rowsFirst) {
5222                 index = (i, j) -&gt; i * columns + j;
5223             } else {
5224                 index = (i, j) -&gt; j * lines + i;
5225             }
5226             for (int i = 0; i &lt; lines; i++) {
5227                 for (int j = 0; j &lt; columns; j++) {
5228                     int idx = index.applyAsInt(i, j);
5229                     if (idx &lt; candidates.size()) {
5230                         Candidate cand = candidates.get(idx);
5231                         boolean hasRightItem = j &lt; columns - 1 &amp;&amp; index.applyAsInt(i, j + 1) &lt; candidates.size();
5232                         AttributedString left = AttributedString.fromAnsi(cand.displ());
5233                         AttributedString right = AttributedString.fromAnsi(cand.descr());
5234                         int lw = left.columnLength();
5235                         int rw = 0;
5236                         if (right != null) {
5237                             int rem = maxWidth - (lw + MARGIN_BETWEEN_DISPLAY_AND_DESC
5238                                     + DESC_PREFIX.length() + DESC_SUFFIX.length());
5239                             rw = right.columnLength();
5240                             if (rw &gt; rem) {
5241                                 right = AttributedStringBuilder.append(
5242                                             right.columnSubSequence(0, rem - WCWidth.wcwidth(&#39;\u2026&#39;)),
5243                                             &quot;\u2026&quot;);
5244                                 rw = right.columnLength();
5245                             }
5246                             right = AttributedStringBuilder.append(DESC_PREFIX, right, DESC_SUFFIX);
5247                             rw += DESC_PREFIX.length() + DESC_SUFFIX.length();
5248                         }
5249                         if (cand == selection) {
5250                             out[1] = i;
5251                             sb.style(getCompletionStyleSelection());
5252                             if (left.toString().regionMatches(
5253                                     isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {
5254                                 sb.append(left.toString(), 0, completed.length());
5255                                 sb.append(left.toString(), completed.length(), left.length());
5256                             } else {
5257                                 sb.append(left.toString());
5258                             }
5259                             for (int k = 0; k &lt; maxWidth - lw - rw; k++) {
5260                                 sb.append(&#39; &#39;);
5261                             }
5262                             if (right != null) {
5263                                 sb.append(right);
5264                             }
5265                             sb.style(AttributedStyle.DEFAULT);
5266                         } else {
5267                             if (left.toString().regionMatches(
5268                                     isSet(Option.CASE_INSENSITIVE), 0, completed, 0, completed.length())) {
5269                                 sb.style(getCompletionStyleStarting());
5270                                 sb.append(left, 0, completed.length());
5271                                 sb.style(AttributedStyle.DEFAULT);
5272                                 sb.append(left, completed.length(), left.length());
5273                             } else {
5274                                 sb.append(left);
5275                             }
5276                             if (right != null || hasRightItem) {
5277                                 for (int k = 0; k &lt; maxWidth - lw - rw; k++) {
5278                                     sb.append(&#39; &#39;);
5279                                 }
5280                             }
5281                             if (right != null) {
5282                                 sb.style(getCompletionStyleDescription());
5283                                 sb.append(right);
5284                                 sb.style(AttributedStyle.DEFAULT);
5285                             }
5286                         }
5287                         if (hasRightItem) {
5288                             for (int k = 0; k &lt; MARGIN_BETWEEN_COLUMNS; k++) {
5289                                 sb.append(&#39; &#39;);
5290                             }
5291                         }
5292                     }
5293                 }
5294                 sb.append(&#39;\n&#39;);
5295             }
5296             out[0] += lines;
5297         }
5298     }
5299 
5300     private AttributedStyle getCompletionStyleStarting() {
5301         return getCompletionStyle(COMPLETION_STYLE_STARTING, DEFAULT_COMPLETION_STYLE_STARTING);
5302     }
5303 
5304     protected AttributedStyle getCompletionStyleDescription() {
5305         return getCompletionStyle(COMPLETION_STYLE_DESCRIPTION, DEFAULT_COMPLETION_STYLE_DESCRIPTION);
5306     }
5307 
5308     protected AttributedStyle getCompletionStyleGroup() {
5309         return getCompletionStyle(COMPLETION_STYLE_GROUP, DEFAULT_COMPLETION_STYLE_GROUP);
5310     }
5311 
5312     protected AttributedStyle getCompletionStyleSelection() {
5313         return getCompletionStyle(COMPLETION_STYLE_SELECTION, DEFAULT_COMPLETION_STYLE_SELECTION);
5314     }
5315 
5316     protected AttributedStyle getCompletionStyle(String name, String value) {
5317         return buildStyle(getString(name, value));
5318     }
5319 
5320     protected AttributedStyle buildStyle(String str) {
5321         return AttributedString.fromAnsi(&quot;\u001b[&quot; + str + &quot;m &quot;).styleAt(0);
5322     }
5323 
5324     private String getCommonStart(String str1, String str2, boolean caseInsensitive) {
5325         int[] s1 = str1.codePoints().toArray();
5326         int[] s2 = str2.codePoints().toArray();
5327         int len = 0;
5328         while (len &lt; Math.min(s1.length, s2.length)) {
5329             int ch1 = s1[len];
5330             int ch2 = s2[len];
5331             if (ch1 != ch2 &amp;&amp; caseInsensitive) {
5332                 ch1 = Character.toUpperCase(ch1);
5333                 ch2 = Character.toUpperCase(ch2);
5334                 if (ch1 != ch2) {
5335                     ch1 = Character.toLowerCase(ch1);
5336                     ch2 = Character.toLowerCase(ch2);
5337                 }
5338             }
5339             if (ch1 != ch2) {
5340                 break;
5341             }
5342             len++;
5343         }
5344         return new String(s1, 0, len);
5345     }
5346 
5347     /**
5348      * Used in &quot;vi&quot; mode for argumented history move, to move a specific
5349      * number of history entries forward or back.
5350      *
5351      * @param next If true, move forward
5352      * @param count The number of entries to move
5353      * @return true if the move was successful
5354      */
5355     protected boolean moveHistory(final boolean next, int count) {
5356         boolean ok = true;
5357         for (int i = 0; i &lt; count &amp;&amp; (ok = moveHistory(next)); i++) {
5358             /* empty */
5359         }
5360         return ok;
5361     }
5362 
5363     /**
5364      * Move up or down the history tree.
5365      * @param next &lt;code&gt;true&lt;/code&gt; to go to the next, &lt;code&gt;false&lt;/code&gt; for the previous.
5366      * @return &lt;code&gt;true&lt;/code&gt; if successful, &lt;code&gt;false&lt;/code&gt; otherwise
5367      */
5368     protected boolean moveHistory(final boolean next) {
5369         if (!buf.toString().equals(history.current())) {
5370             modifiedHistory.put(history.index(), buf.toString());
5371         }
5372         if (next &amp;&amp; !history.next()) {
5373             return false;
5374         }
5375         else if (!next &amp;&amp; !history.previous()) {
5376             return false;
5377         }
5378 
5379         setBuffer(modifiedHistory.containsKey(history.index())
5380                     ? modifiedHistory.get(history.index())
5381                     : history.current());
5382 
5383         return true;
5384     }
5385 
5386     //
5387     // Printing
5388     //
5389 
5390     /**
5391      * Raw output printing.
5392      * @param str the string to print to the terminal
5393      */
5394     void print(String str) {
5395         terminal.writer().write(str);
5396     }
5397 
5398     void println(String s) {
5399         print(s);
5400         println();
5401     }
5402 
5403     /**
5404      * Output a platform-dependant newline.
5405      */
5406     void println() {
5407         terminal.puts(Capability.carriage_return);
5408         print(&quot;\n&quot;);
5409         redrawLine();
5410     }
5411 
5412 
5413     //
5414     // Actions
5415     //
5416 
5417     protected boolean killBuffer() {
5418         killRing.add(buf.toString());
5419         buf.clear();
5420         return true;
5421     }
5422 
5423     protected boolean killWholeLine() {
5424         if (buf.length() == 0) {
5425             return false;
5426         }
5427         int start;
5428         int end;
5429         if (count &lt; 0) {
5430             end = buf.cursor();
5431             while (buf.atChar(end) != 0 &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
5432                 end++;
5433             }
5434             start = end;
5435             for (int count = -this.count; count &gt; 0; --count) {
5436                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5437                     start--;
5438                 }
5439                 start--;
5440             }
5441         } else {
5442             start = buf.cursor();
5443             while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5444                 start--;
5445             }
5446             end = start;
5447             while (count-- &gt; 0) {
5448                 while (end &lt; buf.length() &amp;&amp; buf.atChar(end) != &#39;\n&#39;) {
5449                     end++;
5450                 }
5451                 if (end &lt; buf.length()) {
5452                     end++;
5453                 }
5454             }
5455         }
5456         String killed = buf.substring(start, end);
5457         buf.cursor(start);
5458         buf.delete(end - start);
5459         killRing.add(killed);
5460         return true;
5461     }
5462 
5463     /**
5464      * Kill the buffer ahead of the current cursor position.
5465      *
5466      * @return true if successful
5467      */
5468     public boolean killLine() {
5469         if (count &lt; 0) {
5470             return callNeg(this::backwardKillLine);
5471         }
5472         if (buf.cursor() == buf.length()) {
5473             return false;
5474         }
5475         int cp = buf.cursor();
5476         int len = cp;
5477         while (count-- &gt; 0) {
5478             if (buf.atChar(len) == &#39;\n&#39;) {
5479                 len++;
5480             } else {
5481                 while (buf.atChar(len) != 0 &amp;&amp; buf.atChar(len) != &#39;\n&#39;) {
5482                     len++;
5483                 }
5484             }
5485         }
5486         int num = len - cp;
5487         String killed = buf.substring(cp, cp + num);
5488         buf.delete(num);
5489         killRing.add(killed);
5490         return true;
5491     }
5492 
5493     public boolean backwardKillLine() {
5494         if (count &lt; 0) {
5495             return callNeg(this::killLine);
5496         }
5497         if (buf.cursor() == 0) {
5498             return false;
5499         }
5500         int cp = buf.cursor();
5501         int beg = cp;
5502         while (count-- &gt; 0) {
5503             if (beg == 0) {
5504                 break;
5505             }
5506             if (buf.atChar(beg - 1) == &#39;\n&#39;) {
5507                 beg--;
5508             } else {
5509                 while (beg &gt; 0 &amp;&amp; buf.atChar(beg - 1) != 0 &amp;&amp; buf.atChar(beg - 1) != &#39;\n&#39;) {
5510                     beg--;
5511                 }
5512             }
5513         }
5514         int num = cp - beg;
5515         String killed = buf.substring(cp - beg, cp);
5516         buf.cursor(beg);
5517         buf.delete(num);
5518         killRing.add(killed);
5519         return true;
5520     }
5521 
5522     public boolean killRegion() {
5523         return doCopyKillRegion(true);
5524     }
5525 
5526     public boolean copyRegionAsKill() {
5527         return doCopyKillRegion(false);
5528     }
5529 
5530     private boolean doCopyKillRegion(boolean kill) {
5531         if (regionMark &gt; buf.length()) {
5532             regionMark = buf.length();
5533         }
5534         if (regionActive == RegionType.LINE) {
5535             int start = regionMark;
5536             int end = buf.cursor();
5537             if (start &lt; end) {
5538                 while (start &gt; 0 &amp;&amp; buf.atChar(start - 1) != &#39;\n&#39;) {
5539                     start--;
5540                 }
5541                 while (end &lt; buf.length() - 1 &amp;&amp; buf.atChar(end + 1) != &#39;\n&#39;) {
5542                     end++;
5543                 }
5544                 if (isInViCmdMode()) {
5545                     end++;
5546                 }
5547                 killRing.add(buf.substring(start, end));
5548                 if (kill) {
5549                     buf.backspace(end - start);
5550                 }
5551             } else {
5552                 while (end &gt; 0 &amp;&amp; buf.atChar(end - 1) != &#39;\n&#39;) {
5553                     end--;
5554                 }
5555                 while (start &lt; buf.length() &amp;&amp; buf.atChar(start) != &#39;\n&#39;) {
5556                     start++;
5557                 }
5558                 if (isInViCmdMode()) {
5559                     start++;
5560                 }
5561                 killRing.addBackwards(buf.substring(end, start));
5562                 if (kill) {
5563                     buf.cursor(end);
5564                     buf.delete(start - end);
5565                 }
5566             }
5567         } else if (regionMark &gt; buf.cursor()) {
5568             if (isInViCmdMode()) {
5569                 regionMark++;
5570             }
5571             killRing.add(buf.substring(buf.cursor(), regionMark));
5572             if (kill) {
5573                 buf.delete(regionMark - buf.cursor());
5574             }
5575         } else {
5576             if (isInViCmdMode()) {
5577                 buf.move(1);
5578             }
5579             killRing.add(buf.substring(regionMark, buf.cursor()));
5580             if (kill) {
5581                 buf.backspace(buf.cursor() - regionMark);
5582             }
5583         }
5584         if (kill) {
5585             regionActive = RegionType.NONE;
5586         }
5587         return true;
5588     }
5589 
5590     public boolean yank() {
5591         String yanked = killRing.yank();
5592         if (yanked == null) {
5593             return false;
5594         } else {
5595             putString(yanked);
5596             return true;
5597         }
5598     }
5599 
5600     public boolean yankPop() {
5601         if (!killRing.lastYank()) {
5602             return false;
5603         }
5604         String current = killRing.yank();
5605         if (current == null) {
5606             // This shouldn&#39;t happen.
5607             return false;
5608         }
5609         buf.backspace(current.length());
5610         String yanked = killRing.yankPop();
5611         if (yanked == null) {
5612             // This shouldn&#39;t happen.
5613             return false;
5614         }
5615 
5616         putString(yanked);
5617         return true;
5618     }
5619 
5620     public boolean mouse() {
5621         MouseEvent event = readMouseEvent();
5622         if (event.getType() == MouseEvent.Type.Released
5623                 &amp;&amp; event.getButton() == MouseEvent.Button.Button1) {
5624             StringBuilder tsb = new StringBuilder();
5625             Cursor cursor = terminal.getCursorPosition(c -&gt; tsb.append((char) c));
5626             bindingReader.runMacro(tsb.toString());
5627 
5628             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
5629             getDisplayedBufferWithPrompts(secondaryPrompts);
5630 
5631             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
5632             sb.append(prompt);
5633             sb.append(insertSecondaryPrompts(new AttributedString(buf.upToCursor()), secondaryPrompts, false));
5634             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
5635 
5636             int currentLine = promptLines.size() - 1;
5637             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5638             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5639             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5640             int adjust = pl1 - pl0;
5641             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5642         }
5643         return true;
5644     }
5645 
5646     public boolean beginPaste() {
<a name="55" id="anc55"></a><span class="line-modified">5647         String str = doReadStringUntil(BRACKETED_PASTE_END);</span>


















5648         regionActive = RegionType.PASTE;
5649         regionMark = getBuffer().cursor();
<a name="56" id="anc56"></a><span class="line-modified">5650         getBuffer().write(str.replace(&#39;\r&#39;, &#39;\n&#39;));</span>
5651         return true;
5652     }
5653 
5654     public boolean focusIn() {
5655         return false;
5656     }
5657 
5658     public boolean focusOut() {
5659         return false;
5660     }
5661 
5662     /**
5663      * Clean the used display
5664      * @return &lt;code&gt;true&lt;/code&gt;
5665      */
5666     public boolean clear() {
5667         display.update(Collections.emptyList(), 0);
5668         return true;
5669     }
5670 
5671     /**
5672      * Clear the screen by issuing the ANSI &quot;clear screen&quot; code.
5673      * @return &lt;code&gt;true&lt;/code&gt;
5674      */
5675     public boolean clearScreen() {
5676         if (terminal.puts(Capability.clear_screen)) {
5677             // ConEMU extended fonts support
5678             if (AbstractWindowsTerminal.TYPE_WINDOWS_CONEMU.equals(terminal.getType())
5679                     &amp;&amp; !Boolean.getBoolean(&quot;org.jline.terminal.conemu.disable-activate&quot;)) {
5680                 terminal.writer().write(&quot;\u001b[9999E&quot;);
5681             }
5682             Status status = Status.getStatus(terminal, false);
5683             if (status != null) {
5684                 status.reset();
5685             }
5686             redrawLine();
5687         } else {
5688             println();
5689         }
5690         return true;
5691     }
5692 
5693     /**
5694      * Issue an audible keyboard bell.
5695      * @return &lt;code&gt;true&lt;/code&gt;
5696      */
5697     public boolean beep() {
5698         BellType bell_preference = BellType.AUDIBLE;
5699         switch (getString(BELL_STYLE, DEFAULT_BELL_STYLE).toLowerCase()) {
5700             case &quot;none&quot;:
5701             case &quot;off&quot;:
5702                 bell_preference = BellType.NONE;
5703                 break;
5704             case &quot;audible&quot;:
5705                 bell_preference = BellType.AUDIBLE;
5706                 break;
5707             case &quot;visible&quot;:
5708                 bell_preference = BellType.VISIBLE;
5709                 break;
5710             case &quot;on&quot;:
5711                 bell_preference = getBoolean(PREFER_VISIBLE_BELL, false)
5712                         ? BellType.VISIBLE : BellType.AUDIBLE;
5713                 break;
5714         }
5715         if (bell_preference == BellType.VISIBLE) {
5716             if (terminal.puts(Capability.flash_screen)
5717                     || terminal.puts(Capability.bell)) {
5718                 flush();
5719             }
5720         } else if (bell_preference == BellType.AUDIBLE) {
5721             if (terminal.puts(Capability.bell)) {
5722                 flush();
5723             }
5724         }
5725         return true;
5726     }
5727 
5728     //
5729     // Helpers
5730     //
5731 
5732     /**
5733      * Checks to see if the specified character is a delimiter. We consider a
5734      * character a delimiter if it is anything but a letter or digit.
5735      *
5736      * @param c     The character to test
5737      * @return      True if it is a delimiter
5738      */
5739     protected boolean isDelimiter(int c) {
5740         return !Character.isLetterOrDigit(c);
5741     }
5742 
5743     /**
5744      * Checks to see if a character is a whitespace character. Currently
5745      * this delegates to {@link Character#isWhitespace(char)}, however
5746      * eventually it should be hooked up so that the definition of whitespace
5747      * can be configured, as readline does.
5748      *
5749      * @param c The character to check
5750      * @return true if the character is a whitespace
5751      */
5752     protected boolean isWhitespace(int c) {
5753         return Character.isWhitespace(c);
5754     }
5755 
5756     protected boolean isViAlphaNum(int c) {
5757         return c == &#39;_&#39; || Character.isLetterOrDigit(c);
5758     }
5759 
5760     protected boolean isAlpha(int c) {
5761         return Character.isLetter(c);
5762     }
5763 
5764     protected boolean isWord(int c) {
5765         String wordchars = getString(WORDCHARS, DEFAULT_WORDCHARS);
5766         return Character.isLetterOrDigit(c)
5767                 || (c &lt; 128 &amp;&amp; wordchars.indexOf((char) c) &gt;= 0);
5768     }
5769 
5770     String getString(String name, String def) {
5771         return ReaderUtils.getString(this, name, def);
5772     }
5773 
5774     boolean getBoolean(String name, boolean def) {
5775         return ReaderUtils.getBoolean(this, name, def);
5776     }
5777 
5778     int getInt(String name, int def) {
5779         return ReaderUtils.getInt(this, name, def);
5780     }
5781 
5782     long getLong(String name, long def) {
5783         return ReaderUtils.getLong(this, name, def);
5784     }
5785 
5786     @Override
5787     public Map&lt;String, KeyMap&lt;Binding&gt;&gt; defaultKeyMaps() {
5788         Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps = new HashMap&lt;&gt;();
5789         keyMaps.put(EMACS, emacs());
5790         keyMaps.put(VICMD, viCmd());
5791         keyMaps.put(VIINS, viInsertion());
5792         keyMaps.put(MENU, menu());
5793         keyMaps.put(VIOPP, viOpp());
5794         keyMaps.put(VISUAL, visual());
5795         keyMaps.put(SAFE, safe());
5796         if (getBoolean(BIND_TTY_SPECIAL_CHARS, true)) {
5797             Attributes attr = terminal.getAttributes();
5798             bindConsoleChars(keyMaps.get(EMACS), attr);
5799             bindConsoleChars(keyMaps.get(VIINS), attr);
5800         }
5801         // Put default
5802         for (KeyMap&lt;Binding&gt; keyMap : keyMaps.values()) {
5803             keyMap.setUnicode(new Reference(SELF_INSERT));
5804             keyMap.setAmbiguousTimeout(getLong(AMBIGUOUS_BINDING, DEFAULT_AMBIGUOUS_BINDING));
5805         }
5806         // By default, link main to emacs
5807         keyMaps.put(MAIN, keyMaps.get(EMACS));
5808         return keyMaps;
5809     }
5810 
5811     public KeyMap&lt;Binding&gt; emacs() {
5812         KeyMap&lt;Binding&gt; emacs = new KeyMap&lt;&gt;();
5813         bindKeys(emacs);
5814         bind(emacs, SET_MARK_COMMAND,                       ctrl(&#39;@&#39;));
5815         bind(emacs, BEGINNING_OF_LINE,                      ctrl(&#39;A&#39;));
5816         bind(emacs, BACKWARD_CHAR,                          ctrl(&#39;B&#39;));
5817         bind(emacs, DELETE_CHAR_OR_LIST,                    ctrl(&#39;D&#39;));
5818         bind(emacs, END_OF_LINE,                            ctrl(&#39;E&#39;));
5819         bind(emacs, FORWARD_CHAR,                           ctrl(&#39;F&#39;));
5820         bind(emacs, SEND_BREAK,                             ctrl(&#39;G&#39;));
5821         bind(emacs, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5822         bind(emacs, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5823         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5824         bind(emacs, KILL_LINE,                              ctrl(&#39;K&#39;));
5825         bind(emacs, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5826         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5827         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
5828         bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl(&#39;O&#39;));
5829         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5830         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5831         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5832         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5833         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5834         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5835         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5836         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5837         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5838         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5839         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5840         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5841         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5842         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5843         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5844         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5845         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));
<a name="57" id="anc57"></a><span class="line-added">5846         bind(emacs, EDIT_AND_EXECUTE_COMMAND,               translate(&quot;^X^E&quot;));</span>
5847         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5848         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5849         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
5850         bind(emacs, INFER_NEXT_HISTORY,                     translate(&quot;^X^N&quot;));
5851         bind(emacs, OVERWRITE_MODE,                         translate(&quot;^X^O&quot;));
5852         bind(emacs, REDO,                                   translate(&quot;^X^R&quot;));
5853         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5854         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5855         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5856         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5857         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5858         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5859         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5860         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5861         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5862         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5863         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5864         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5865         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5866         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
5867         bind(emacs, DIGIT_ARGUMENT,                         range(&quot;\\E0-\\E9&quot;));
5868         bind(emacs, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5869         bind(emacs, LIST_CHOICES,                           alt(&#39;=&#39;));
5870         bind(emacs, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5871         bind(emacs, LIST_CHOICES,                           alt(&#39;?&#39;));
5872         bind(emacs, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
5873         bind(emacs, ACCEPT_AND_HOLD,                        alt(&#39;a&#39;));
5874         bind(emacs, BACKWARD_WORD,                          alt(&#39;b&#39;));
5875         bind(emacs, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5876         bind(emacs, KILL_WORD,                              alt(&#39;d&#39;));
5877         bind(emacs, KILL_WORD,                              translate(&quot;^[[3;5~&quot;)); // ctrl-delete
5878         bind(emacs, FORWARD_WORD,                           alt(&#39;f&#39;));
5879         bind(emacs, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5880         bind(emacs, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5881         bind(emacs, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5882         bind(emacs, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5883         bind(emacs, UP_CASE_WORD,                           alt(&#39;u&#39;));
5884         bind(emacs, YANK_POP,                               alt(&#39;y&#39;));
5885         bind(emacs, BACKWARD_KILL_WORD,                     alt(del()));
5886         bindArrowKeys(emacs);
5887         bind(emacs, FORWARD_WORD,                           translate(&quot;^[[1;5C&quot;)); // ctrl-left
5888         bind(emacs, BACKWARD_WORD,                          translate(&quot;^[[1;5D&quot;)); // ctrl-right
5889         bind(emacs, FORWARD_WORD,                           alt(key(Capability.key_right)));
5890         bind(emacs, BACKWARD_WORD,                          alt(key(Capability.key_left)));
5891         bind(emacs, FORWARD_WORD,                           alt(translate(&quot;^[[C&quot;)));
5892         bind(emacs, BACKWARD_WORD,                          alt(translate(&quot;^[[D&quot;)));
5893         return emacs;
5894     }
5895 
5896     public KeyMap&lt;Binding&gt; viInsertion() {
5897         KeyMap&lt;Binding&gt; viins = new KeyMap&lt;&gt;();
5898         bindKeys(viins);
5899         bind(viins, SELF_INSERT,                            range(&quot;^@-^_&quot;));
5900         bind(viins, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5901         bind(viins, SEND_BREAK,                             ctrl(&#39;G&#39;));
5902         bind(viins, BACKWARD_DELETE_CHAR,                   ctrl(&#39;H&#39;));
5903         bind(viins, EXPAND_OR_COMPLETE,                     ctrl(&#39;I&#39;));
5904         bind(viins, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5905         bind(viins, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5906         bind(viins, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5907         bind(viins, MENU_COMPLETE,                          ctrl(&#39;N&#39;));
5908         bind(viins, REVERSE_MENU_COMPLETE,                  ctrl(&#39;P&#39;));
5909         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5910         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5911         bind(viins, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5912         bind(viins, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5913         bind(viins, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5914         bind(viins, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5915         bind(viins, YANK,                                   ctrl(&#39;Y&#39;));
5916         bind(viins, VI_CMD_MODE,                            ctrl(&#39;[&#39;));
5917         bind(viins, UNDO,                                   ctrl(&#39;_&#39;));
5918         bind(viins, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
5919         bind(viins, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;X&#39;) + &quot;s&quot;);
5920         bind(viins, SELF_INSERT,                            range(&quot; -~&quot;));
5921         bind(viins, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5922         bind(viins, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5923         bind(viins, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5924         bind(viins, BACKWARD_DELETE_CHAR,                   del());
5925         bindArrowKeys(viins);
5926         return viins;
5927     }
5928 
5929     public KeyMap&lt;Binding&gt; viCmd() {
5930         KeyMap&lt;Binding&gt; vicmd = new KeyMap&lt;&gt;();
5931         bind(vicmd, LIST_CHOICES,                           ctrl(&#39;D&#39;));
5932         bind(vicmd, EMACS_EDITING_MODE,                     ctrl(&#39;E&#39;));
5933         bind(vicmd, SEND_BREAK,                             ctrl(&#39;G&#39;));
5934         bind(vicmd, VI_BACKWARD_CHAR,                       ctrl(&#39;H&#39;));
5935         bind(vicmd, ACCEPT_LINE,                            ctrl(&#39;J&#39;));
5936         bind(vicmd, KILL_LINE,                              ctrl(&#39;K&#39;));
5937         bind(vicmd, CLEAR_SCREEN,                           ctrl(&#39;L&#39;));
5938         bind(vicmd, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5939         bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                ctrl(&#39;N&#39;));
5940         bind(vicmd, VI_UP_LINE_OR_HISTORY,                  ctrl(&#39;P&#39;));
5941         bind(vicmd, QUOTED_INSERT,                          ctrl(&#39;Q&#39;));
5942         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5943         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5944         bind(vicmd, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5945         bind(vicmd, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5946         bind(vicmd, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5947         bind(vicmd, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5948         bind(vicmd, YANK,                                   ctrl(&#39;Y&#39;));
5949         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;X&#39;) + &quot;r&quot;);
5950         bind(vicmd, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;X&#39;) + &quot;s&quot;);
5951         bind(vicmd, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5952         bind(vicmd, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5953         bind(vicmd, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5954         bind(vicmd, COMPLETE_WORD,                          alt(esc()));
5955         bind(vicmd, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5956         bind(vicmd, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5957 //        bind(vicmd, INSERT_COMMENT,                         alt(&#39;#&#39;));
5958 //        bind(vicmd, INSERT_COMPLETIONS,                     alt(&#39;*&#39;));
5959         bind(vicmd, DIGIT_ARGUMENT,                         alt(&#39;-&#39;));
5960         bind(vicmd, BEGINNING_OF_HISTORY,                   alt(&#39;&lt;&#39;));
5961         bind(vicmd, LIST_CHOICES,                           alt(&#39;=&#39;));
5962         bind(vicmd, END_OF_HISTORY,                         alt(&#39;&gt;&#39;));
5963         bind(vicmd, LIST_CHOICES,                           alt(&#39;?&#39;));
5964         bind(vicmd, DO_LOWERCASE_VERSION,                   range(&quot;^[A-^[Z&quot;));
5965         bind(vicmd, BACKWARD_WORD,                          alt(&#39;b&#39;));
5966         bind(vicmd, CAPITALIZE_WORD,                        alt(&#39;c&#39;));
5967         bind(vicmd, KILL_WORD,                              alt(&#39;d&#39;));
5968         bind(vicmd, FORWARD_WORD,                           alt(&#39;f&#39;));
5969         bind(vicmd, DOWN_CASE_WORD,                         alt(&#39;l&#39;));
5970         bind(vicmd, HISTORY_SEARCH_FORWARD,                 alt(&#39;n&#39;));
5971         bind(vicmd, HISTORY_SEARCH_BACKWARD,                alt(&#39;p&#39;));
5972         bind(vicmd, TRANSPOSE_WORDS,                        alt(&#39;t&#39;));
5973         bind(vicmd, UP_CASE_WORD,                           alt(&#39;u&#39;));
5974         bind(vicmd, YANK_POP,                               alt(&#39;y&#39;));
5975         bind(vicmd, BACKWARD_KILL_WORD,                     alt(del()));
5976 
5977         bind(vicmd, FORWARD_CHAR,                           &quot; &quot;);
5978         bind(vicmd, VI_INSERT_COMMENT,                      &quot;#&quot;);
5979         bind(vicmd, END_OF_LINE,                            &quot;$&quot;);
5980         bind(vicmd, VI_MATCH_BRACKET,                       &quot;%&quot;);
5981         bind(vicmd, VI_DOWN_LINE_OR_HISTORY,                &quot;+&quot;);
5982         bind(vicmd, VI_REV_REPEAT_FIND,                     &quot;,&quot;);
5983         bind(vicmd, VI_UP_LINE_OR_HISTORY,                  &quot;-&quot;);
5984         bind(vicmd, VI_REPEAT_CHANGE,                       &quot;.&quot;);
5985         bind(vicmd, VI_HISTORY_SEARCH_BACKWARD,             &quot;/&quot;);
5986         bind(vicmd, VI_DIGIT_OR_BEGINNING_OF_LINE,          &quot;0&quot;);
5987         bind(vicmd, DIGIT_ARGUMENT,                         range(&quot;1-9&quot;));
5988         bind(vicmd, VI_REPEAT_FIND,                         &quot;;&quot;);
5989         bind(vicmd, LIST_CHOICES,                           &quot;=&quot;);
5990         bind(vicmd, VI_HISTORY_SEARCH_FORWARD,              &quot;?&quot;);
5991         bind(vicmd, VI_ADD_EOL,                             &quot;A&quot;);
5992         bind(vicmd, VI_BACKWARD_BLANK_WORD,                 &quot;B&quot;);
5993         bind(vicmd, VI_CHANGE_EOL,                          &quot;C&quot;);
5994         bind(vicmd, VI_KILL_EOL,                            &quot;D&quot;);
5995         bind(vicmd, VI_FORWARD_BLANK_WORD_END,              &quot;E&quot;);
5996         bind(vicmd, VI_FIND_PREV_CHAR,                      &quot;F&quot;);
5997         bind(vicmd, VI_FETCH_HISTORY,                       &quot;G&quot;);
5998         bind(vicmd, VI_INSERT_BOL,                          &quot;I&quot;);
5999         bind(vicmd, VI_JOIN,                                &quot;J&quot;);
6000         bind(vicmd, VI_REV_REPEAT_SEARCH,                   &quot;N&quot;);
6001         bind(vicmd, VI_OPEN_LINE_ABOVE,                     &quot;O&quot;);
6002         bind(vicmd, VI_PUT_BEFORE,                          &quot;P&quot;);
6003         bind(vicmd, VI_REPLACE,                             &quot;R&quot;);
6004         bind(vicmd, VI_KILL_LINE,                           &quot;S&quot;);
6005         bind(vicmd, VI_FIND_PREV_CHAR_SKIP,                 &quot;T&quot;);
6006         bind(vicmd, REDO,                                   &quot;U&quot;);
6007         bind(vicmd, VISUAL_LINE_MODE,                       &quot;V&quot;);
6008         bind(vicmd, VI_FORWARD_BLANK_WORD,                  &quot;W&quot;);
6009         bind(vicmd, VI_BACKWARD_DELETE_CHAR,                &quot;X&quot;);
6010         bind(vicmd, VI_YANK_WHOLE_LINE,                     &quot;Y&quot;);
6011         bind(vicmd, VI_FIRST_NON_BLANK,                     &quot;^&quot;);
6012         bind(vicmd, VI_ADD_NEXT,                            &quot;a&quot;);
6013         bind(vicmd, VI_BACKWARD_WORD,                       &quot;b&quot;);
6014         bind(vicmd, VI_CHANGE,                              &quot;c&quot;);
6015         bind(vicmd, VI_DELETE,                              &quot;d&quot;);
6016         bind(vicmd, VI_FORWARD_WORD_END,                    &quot;e&quot;);
6017         bind(vicmd, VI_FIND_NEXT_CHAR,                      &quot;f&quot;);
6018         bind(vicmd, WHAT_CURSOR_POSITION,                   &quot;ga&quot;);
6019         bind(vicmd, VI_BACKWARD_BLANK_WORD_END,             &quot;gE&quot;);
6020         bind(vicmd, VI_BACKWARD_WORD_END,                   &quot;ge&quot;);
6021         bind(vicmd, VI_BACKWARD_CHAR,                       &quot;h&quot;);
6022         bind(vicmd, VI_INSERT,                              &quot;i&quot;);
6023         bind(vicmd, DOWN_LINE_OR_HISTORY,                   &quot;j&quot;);
6024         bind(vicmd, UP_LINE_OR_HISTORY,                     &quot;k&quot;);
6025         bind(vicmd, VI_FORWARD_CHAR,                        &quot;l&quot;);
6026         bind(vicmd, VI_REPEAT_SEARCH,                       &quot;n&quot;);
6027         bind(vicmd, VI_OPEN_LINE_BELOW,                     &quot;o&quot;);
6028         bind(vicmd, VI_PUT_AFTER,                           &quot;p&quot;);
6029         bind(vicmd, VI_REPLACE_CHARS,                       &quot;r&quot;);
6030         bind(vicmd, VI_SUBSTITUTE,                          &quot;s&quot;);
6031         bind(vicmd, VI_FIND_NEXT_CHAR_SKIP,                 &quot;t&quot;);
6032         bind(vicmd, UNDO,                                   &quot;u&quot;);
6033         bind(vicmd, VISUAL_MODE,                            &quot;v&quot;);
6034         bind(vicmd, VI_FORWARD_WORD,                        &quot;w&quot;);
6035         bind(vicmd, VI_DELETE_CHAR,                         &quot;x&quot;);
6036         bind(vicmd, VI_YANK,                                &quot;y&quot;);
6037         bind(vicmd, VI_GOTO_COLUMN,                         &quot;|&quot;);
6038         bind(vicmd, VI_SWAP_CASE,                           &quot;~&quot;);
6039         bind(vicmd, VI_BACKWARD_CHAR,                       del());
6040 
6041         bindArrowKeys(vicmd);
6042         return vicmd;
6043     }
6044 
6045     public KeyMap&lt;Binding&gt; menu() {
6046         KeyMap&lt;Binding&gt; menu = new KeyMap&lt;&gt;();
6047         bind(menu, MENU_COMPLETE,                     &quot;\t&quot;);
6048         bind(menu, REVERSE_MENU_COMPLETE,             key(Capability.back_tab));
6049         bind(menu, ACCEPT_LINE,                       &quot;\r&quot;, &quot;\n&quot;);
6050         bindArrowKeys(menu);
6051         return menu;
6052     }
6053 
6054     public KeyMap&lt;Binding&gt; safe() {
6055         KeyMap&lt;Binding&gt; safe = new KeyMap&lt;&gt;();
6056         bind(safe, SELF_INSERT,                 range(&quot;^@-^?&quot;));
6057         bind(safe, ACCEPT_LINE,                 &quot;\r&quot;, &quot;\n&quot;);
6058         bind(safe, SEND_BREAK,                  ctrl(&#39;G&#39;));
6059         return safe;
6060     }
6061 
6062     public KeyMap&lt;Binding&gt; visual() {
6063         KeyMap&lt;Binding&gt; visual = new KeyMap&lt;&gt;();
6064         bind(visual, UP_LINE,                   key(Capability.key_up),     &quot;k&quot;);
6065         bind(visual, DOWN_LINE,                 key(Capability.key_down),   &quot;j&quot;);
6066         bind(visual, this::deactivateRegion,    esc());
6067         bind(visual, EXCHANGE_POINT_AND_MARK,   &quot;o&quot;);
6068         bind(visual, PUT_REPLACE_SELECTION,     &quot;p&quot;);
6069         bind(visual, VI_DELETE,                 &quot;x&quot;);
6070         bind(visual, VI_OPER_SWAP_CASE,         &quot;~&quot;);
6071         return visual;
6072     }
6073 
6074     public KeyMap&lt;Binding&gt; viOpp() {
6075         KeyMap&lt;Binding&gt; viOpp = new KeyMap&lt;&gt;();
6076         bind(viOpp, UP_LINE,                    key(Capability.key_up),     &quot;k&quot;);
6077         bind(viOpp, DOWN_LINE,                  key(Capability.key_down),   &quot;j&quot;);
6078         bind(viOpp, VI_CMD_MODE,                esc());
6079         return viOpp;
6080     }
6081 
6082     private void bind(KeyMap&lt;Binding&gt; map, String widget, Iterable&lt;? extends CharSequence&gt; keySeqs) {
6083         map.bind(new Reference(widget), keySeqs);
6084     }
6085 
6086     private void bind(KeyMap&lt;Binding&gt; map, String widget, CharSequence... keySeqs) {
6087         map.bind(new Reference(widget), keySeqs);
6088     }
6089 
6090     private void bind(KeyMap&lt;Binding&gt; map, Widget widget, CharSequence... keySeqs) {
6091         map.bind(widget, keySeqs);
6092     }
6093 
6094     private String key(Capability capability) {
6095         return KeyMap.key(terminal, capability);
6096     }
6097 
6098     private void bindKeys(KeyMap&lt;Binding&gt; emacs) {
6099         Widget beep = namedWidget(&quot;beep&quot;, this::beep);
6100         Stream.of(Capability.values())
6101                 .filter(c -&gt; c.name().startsWith(&quot;key_&quot;))
6102                 .map(this::key)
6103                 .forEach(k -&gt; bind(emacs, beep, k));
6104     }
6105 
6106     private void bindArrowKeys(KeyMap&lt;Binding&gt; map) {
6107         bind(map, UP_LINE_OR_SEARCH,    key(Capability.key_up));
6108         bind(map, DOWN_LINE_OR_SEARCH,  key(Capability.key_down));
6109         bind(map, BACKWARD_CHAR,        key(Capability.key_left));
6110         bind(map, FORWARD_CHAR,         key(Capability.key_right));
6111         bind(map, BEGINNING_OF_LINE,    key(Capability.key_home));
6112         bind(map, END_OF_LINE,          key(Capability.key_end));
6113         bind(map, DELETE_CHAR,          key(Capability.key_dc));
6114         bind(map, KILL_WHOLE_LINE,      key(Capability.key_dl));
6115         bind(map, OVERWRITE_MODE,       key(Capability.key_ic));
6116         bind(map, MOUSE,                key(Capability.key_mouse));
6117         bind(map, BEGIN_PASTE,          BRACKETED_PASTE_BEGIN);
6118         bind(map, FOCUS_IN,             FOCUS_IN_SEQ);
6119         bind(map, FOCUS_OUT,            FOCUS_OUT_SEQ);
6120     }
6121 
6122     /**
6123      * Bind special chars defined by the terminal instead of
6124      * the default bindings
6125      */
6126     private void bindConsoleChars(KeyMap&lt;Binding&gt; keyMap, Attributes attr) {
6127         if (attr != null) {
6128             rebind(keyMap, BACKWARD_DELETE_CHAR,
6129                     del(), (char) attr.getControlChar(ControlChar.VERASE));
6130             rebind(keyMap, BACKWARD_KILL_WORD,
6131                     ctrl(&#39;W&#39;),  (char) attr.getControlChar(ControlChar.VWERASE));
6132             rebind(keyMap, KILL_WHOLE_LINE,
6133                     ctrl(&#39;U&#39;), (char) attr.getControlChar(ControlChar.VKILL));
6134             rebind(keyMap, QUOTED_INSERT,
6135                     ctrl(&#39;V&#39;), (char) attr.getControlChar(ControlChar.VLNEXT));
6136         }
6137     }
6138 
6139     private void rebind(KeyMap&lt;Binding&gt; keyMap, String operation, String prevBinding, char newBinding) {
6140         if (newBinding &gt; 0 &amp;&amp; newBinding &lt; 128) {
6141             Reference ref = new Reference(operation);
6142             bind(keyMap, SELF_INSERT, prevBinding);
6143             keyMap.bind(ref, Character.toString(newBinding));
6144         }
6145     }
6146 
<a name="58" id="anc58"></a>
6147 }
<a name="59" id="anc59"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="59" type="hidden" />
</body>
</html>
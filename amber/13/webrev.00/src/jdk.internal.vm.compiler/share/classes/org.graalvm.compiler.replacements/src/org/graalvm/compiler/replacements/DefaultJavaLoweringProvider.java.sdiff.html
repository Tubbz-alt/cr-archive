<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../../../org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/SubstitutionsTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetLowerableMemoryNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/DefaultJavaLoweringProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  90 import org.graalvm.compiler.nodes.calc.SubNode;
  91 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  92 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  93 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  94 import org.graalvm.compiler.nodes.extended.BoxNode;
  95 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  96 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  97 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  98 import org.graalvm.compiler.nodes.extended.GuardingNode;
  99 import org.graalvm.compiler.nodes.extended.JavaReadNode;
 100 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
 101 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 102 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 103 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 104 import org.graalvm.compiler.nodes.extended.MembarNode;
 105 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 106 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 107 import org.graalvm.compiler.nodes.extended.UnboxNode;
 108 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 109 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;

 110 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 111 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 112 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 113 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 114 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 115 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 116 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 117 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 118 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 119 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 120 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 121 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 122 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 123 import org.graalvm.compiler.nodes.java.NewArrayNode;
 124 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 125 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 126 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 127 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 128 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 129 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
</pre>
<hr />
<pre>
 157 import jdk.vm.ci.code.MemoryBarriers;
 158 import jdk.vm.ci.code.TargetDescription;
 159 import jdk.vm.ci.meta.DeoptimizationAction;
 160 import jdk.vm.ci.meta.DeoptimizationReason;
 161 import jdk.vm.ci.meta.JavaConstant;
 162 import jdk.vm.ci.meta.JavaKind;
 163 import jdk.vm.ci.meta.MetaAccessProvider;
 164 import jdk.vm.ci.meta.ResolvedJavaField;
 165 import jdk.vm.ci.meta.ResolvedJavaMethod;
 166 import jdk.vm.ci.meta.ResolvedJavaType;
 167 import jdk.vm.ci.meta.SpeculationLog;
 168 
 169 /**
 170  * VM-independent lowerings for standard Java nodes. VM-specific methods are abstract and must be
 171  * implemented by VM-specific subclasses.
 172  */
 173 public abstract class DefaultJavaLoweringProvider implements LoweringProvider {
 174 
 175     protected final MetaAccessProvider metaAccess;
 176     protected final ForeignCallsProvider foreignCalls;

 177     protected final TargetDescription target;
 178     private final boolean useCompressedOops;
<span class="line-removed"> 179     private final ResolvedJavaType objectArrayType;</span>
 180 
 181     private BoxingSnippets.Templates boxingSnippets;
 182     private ConstantStringIndexOfSnippets.Templates indexOfSnippets;
 183 
<span class="line-modified"> 184     public DefaultJavaLoweringProvider(MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, TargetDescription target, boolean useCompressedOops) {</span>

 185         this.metaAccess = metaAccess;
 186         this.foreignCalls = foreignCalls;

 187         this.target = target;
 188         this.useCompressedOops = useCompressedOops;
<span class="line-removed"> 189         this.objectArrayType = metaAccess.lookupJavaType(Object[].class);</span>
 190     }
 191 
 192     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, Providers providers, SnippetReflectionProvider snippetReflection) {
 193         boxingSnippets = new BoxingSnippets.Templates(options, factories, factory, providers, snippetReflection, target);
 194         indexOfSnippets = new ConstantStringIndexOfSnippets.Templates(options, factories, providers, snippetReflection, target);
 195         providers.getReplacements().registerSnippetTemplateCache(new SnippetCounterNode.SnippetCounterSnippets.Templates(options, factories, providers, snippetReflection, target));
 196     }
 197 
 198     public final TargetDescription getTarget() {
 199         return target;
 200     }
 201 
 202     public MetaAccessProvider getMetaAccess() {
 203         return metaAccess;
 204     }
 205 




 206     @Override
 207     @SuppressWarnings(&quot;try&quot;)
 208     public void lower(Node n, LoweringTool tool) {
 209         assert n instanceof Lowerable;
 210         StructuredGraph graph = (StructuredGraph) n.graph();
 211         try (DebugCloseable context = n.withNodeSourcePosition()) {
 212             if (n instanceof LoadFieldNode) {
 213                 lowerLoadFieldNode((LoadFieldNode) n, tool);
 214             } else if (n instanceof StoreFieldNode) {
 215                 lowerStoreFieldNode((StoreFieldNode) n, tool);
 216             } else if (n instanceof LoadIndexedNode) {
 217                 lowerLoadIndexedNode((LoadIndexedNode) n, tool);
 218             } else if (n instanceof StoreIndexedNode) {
 219                 lowerStoreIndexedNode((StoreIndexedNode) n, tool);
 220             } else if (n instanceof IndexAddressNode) {
 221                 lowerIndexAddressNode((IndexAddressNode) n);
 222             } else if (n instanceof ArrayLengthNode) {
 223                 lowerArrayLengthNode((ArrayLengthNode) n, tool);
 224             } else if (n instanceof LoadHubNode) {
 225                 lowerLoadHubNode((LoadHubNode) n, tool);
</pre>
<hr />
<pre>
 371     }
 372 
 373     protected void lowerVerifyHeap(VerifyHeapNode n) {
 374         GraphUtil.removeFixedWithUnusedInputs(n);
 375     }
 376 
 377     public AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {
 378         ValueNode o = ConstantNode.forIntegerKind(target.wordJavaKind, offset, graph);
 379         return graph.unique(new OffsetAddressNode(object, o));
 380     }
 381 
 382     public AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {
 383         int offset = fieldOffset(field);
 384         if (offset &gt;= 0) {
 385             return createOffsetAddress(graph, object, offset);
 386         } else {
 387             return null;
 388         }
 389     }
 390 
<span class="line-modified"> 391     protected abstract JavaKind getStorageKind(ResolvedJavaField field);</span>
 392 
 393     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 394         assert loadField.getStackKind() != JavaKind.Illegal;
 395         StructuredGraph graph = loadField.graph();
 396         ResolvedJavaField field = loadField.field();
 397         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 398         object = createNullCheckedValue(object, loadField, tool);
 399         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 400 
 401         AddressNode address = createFieldAddress(graph, object, field);
 402         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
 403 
 404         ReadNode memoryRead = null;
 405         if (loadField.isVolatile() &amp;&amp; GraalOptions.LateMembars.getValue(graph.getOptions())) {
<span class="line-modified"> 406             memoryRead = graph.add(new VolatileReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
 407         } else {
<span class="line-modified"> 408             memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, fieldLoadBarrierType(field)));</span>
 409         }
 410         ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
 411         loadField.replaceAtUsages(readValue);
 412         graph.replaceFixed(loadField, memoryRead);
 413 
 414         if (loadField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {
 415             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
 416             graph.addBeforeFixed(memoryRead, preMembar);
 417             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
 418             graph.addAfterFixed(memoryRead, postMembar);
 419         }
 420     }
 421 
 422     protected void lowerStoreFieldNode(StoreFieldNode storeField, LoweringTool tool) {
 423         StructuredGraph graph = storeField.graph();
 424         ResolvedJavaField field = storeField.field();
 425         ValueNode object = storeField.isStatic() ? staticFieldBase(graph, field) : storeField.object();
 426         object = createNullCheckedValue(object, storeField, tool);
 427         ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
 428         AddressNode address = createFieldAddress(graph, object, field);
 429         assert address != null;
 430 
<span class="line-modified"> 431         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, fieldStoreBarrierType(storeField.field()), storeField.isVolatile()));</span>
 432         memoryWrite.setStateAfter(storeField.stateAfter());
 433         graph.replaceFixedWithFixed(storeField, memoryWrite);
 434 
 435         if (storeField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {
 436             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
 437             graph.addBeforeFixed(memoryWrite, preMembar);
 438             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
 439             graph.addAfterFixed(memoryWrite, postMembar);
 440         }
 441     }
 442 
 443     public static final IntegerStamp POSITIVE_ARRAY_INDEX_STAMP = StampFactory.forInteger(32, 0, Integer.MAX_VALUE - 1);
 444 
 445     /**
 446      * Create a PiNode on the index proving that the index is positive. On some platforms this is
 447      * important to allow the index to be used as an int in the address mode.
 448      */
 449     public AddressNode createArrayIndexAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index, GuardingNode boundsCheck) {
 450         ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));
 451         return createArrayAddress(graph, array, elementKind, positiveIndex);
</pre>
<hr />
<pre>
 493         AddressNode address = createArrayIndexAddress(graph, array, elementKind, index, boundsCheck);
 494 
 495         ReadNode memoryRead = graph.add(new ReadNode(address, NamedLocationIdentity.getArrayLocation(elementKind), loadStamp, BarrierType.NONE));
 496         memoryRead.setGuard(boundsCheck);
 497         ValueNode readValue = implicitLoadConvert(graph, elementKind, memoryRead);
 498 
 499         loadIndexed.replaceAtUsages(readValue);
 500         graph.replaceFixed(loadIndexed, memoryRead);
 501     }
 502 
 503     protected void lowerStoreIndexedNode(StoreIndexedNode storeIndexed, LoweringTool tool) {
 504         StructuredGraph graph = storeIndexed.graph();
 505 
 506         ValueNode value = storeIndexed.value();
 507         ValueNode array = storeIndexed.array();
 508 
 509         array = this.createNullCheckedValue(array, storeIndexed, tool);
 510 
 511         GuardingNode boundsCheck = getBoundsCheck(storeIndexed, array, tool);
 512 
<span class="line-modified"> 513         JavaKind elementKind = storeIndexed.elementKind();</span>
 514 
 515         LogicNode condition = null;
<span class="line-modified"> 516         if (storeIndexed.getStoreCheck() == null &amp;&amp; elementKind == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(value)) {</span>
 517             /* Array store check. */
 518             TypeReference arrayType = StampTool.typeReferenceOrNull(array);
 519             if (arrayType != null &amp;&amp; arrayType.isExact()) {
 520                 ResolvedJavaType elementType = arrayType.getType().getComponentType();
 521                 if (!elementType.isJavaLangObject()) {
 522                     TypeReference typeReference = TypeReference.createTrusted(storeIndexed.graph().getAssumptions(), elementType);
 523                     LogicNode typeTest = graph.addOrUniqueWithInputs(InstanceOfNode.create(typeReference, value));
 524                     condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 525                 }
 526             } else {
 527                 /*
 528                  * The guard on the read hub should be the null check of the array that was
 529                  * introduced earlier.
 530                  */
 531                 ValueNode arrayClass = createReadHub(graph, array, tool);
 532                 ValueNode componentHub = createReadArrayComponentHub(graph, arrayClass, storeIndexed);
 533                 LogicNode typeTest = graph.unique(InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), componentHub, value, false));
 534                 condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 535             }
 536         }
 537 
<span class="line-modified"> 538         AddressNode address = createArrayIndexAddress(graph, array, elementKind, storeIndexed.index(), boundsCheck);</span>
<span class="line-modified"> 539         WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(elementKind), implicitStoreConvert(graph, elementKind, value),</span>
<span class="line-modified"> 540                         arrayStoreBarrierType(storeIndexed.elementKind()), false));</span>
 541         memoryWrite.setGuard(boundsCheck);
 542         if (condition != null) {
 543             tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
 544         }
 545         memoryWrite.setStateAfter(storeIndexed.stateAfter());
 546         graph.replaceFixedWithFixed(storeIndexed, memoryWrite);
 547     }
 548 
 549     protected void lowerArrayLengthNode(ArrayLengthNode arrayLengthNode, LoweringTool tool) {
 550         arrayLengthNode.replaceAtUsages(createReadArrayLength(arrayLengthNode.array(), arrayLengthNode, tool));
 551         StructuredGraph graph = arrayLengthNode.graph();
 552         graph.removeFixed(arrayLengthNode);
 553     }
 554 
 555     /**
 556      * Creates a read node that read the array length and is guarded by a null-check.
 557      *
 558      * The created node is placed before {@code before} in the CFG.
 559      */
 560     protected ReadNode createReadArrayLength(ValueNode array, FixedNode before, LoweringTool tool) {
</pre>
<hr />
<pre>
 614         graph.replaceFixed(loadHub, hub);
 615     }
 616 
 617     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 618         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 619         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
 620         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId(), monitorEnter.isBiasable()));
 621         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 622         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 623         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 624     }
 625 
 626     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 627         StructuredGraph graph = cas.graph();
 628         JavaKind valueKind = cas.getValueKind();
 629 
 630         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 631         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 632 
 633         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
<span class="line-modified"> 634         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);</span>
 635         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));
 636         atomicNode.setStateAfter(cas.stateAfter());
 637         graph.replaceFixedWithFixed(cas, atomicNode);
 638     }
 639 
 640     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
 641         StructuredGraph graph = cas.graph();
 642         JavaKind valueKind = cas.getValueKind();
 643 
 644         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 645         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 646 
 647         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
<span class="line-modified"> 648         BarrierType barrierType = guessStoreBarrierType(cas.object(), expectedValue);</span>
 649         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getKilledLocationIdentity(), barrierType));
 650         ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
 651         atomicNode.setStateAfter(cas.stateAfter());
 652         cas.replaceAtUsages(coercedNode);
 653         graph.replaceFixedWithFixed(cas, atomicNode);
 654     }
 655 
 656     protected void lowerAtomicReadAndWriteNode(AtomicReadAndWriteNode n) {
 657         StructuredGraph graph = n.graph();
 658         JavaKind valueKind = n.getValueKind();
 659 
 660         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 661 
 662         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
<span class="line-modified"> 663         BarrierType barrierType = guessStoreBarrierType(n.object(), n.newValue());</span>
 664         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
 665         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));
 666         memoryRead.setStateAfter(n.stateAfter());
 667 
 668         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 669         n.stateAfter().replaceFirstInput(n, memoryRead);
 670         n.replaceAtUsages(readValue);
 671         graph.replaceFixedWithFixed(n, memoryRead);
 672     }
 673 
 674     /**
 675      * @param tool utility for performing the lowering
 676      */
 677     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {
<span class="line-removed"> 678         PlatformConfigurationProvider gc = tool.getProviders().getPlatformConfigurationProvider();</span>
 679         StructuredGraph graph = load.graph();
 680         if (load instanceof GuardedUnsafeLoadNode) {
 681             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 682             GuardingNode guard = guardedLoad.getGuard();
 683             if (guard == null) {
 684                 // can float freely if the guard folded away
<span class="line-modified"> 685                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);</span>
 686                 memoryRead.setForceFixed(false);
 687                 graph.replaceFixedWithFixed(load, memoryRead);
 688             } else {
 689                 // must be guarded, but flows below the guard
<span class="line-modified"> 690                 ReadNode memoryRead = createUnsafeRead(gc, graph, load, guard);</span>
 691                 graph.replaceFixedWithFixed(load, memoryRead);
 692             }
 693         } else {
 694             // never had a guarding condition so it must be fixed, creation of the read will force
 695             // it to be fixed
<span class="line-modified"> 696             ReadNode memoryRead = createUnsafeRead(gc, graph, load, null);</span>
 697             graph.replaceFixedWithFixed(load, memoryRead);
 698         }
 699     }
 700 
 701     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 702         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 703             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 704         } else {
 705             return graph.unique(new OffsetAddressNode(object, offset));
 706         }
 707     }
 708 
<span class="line-modified"> 709     protected ReadNode createUnsafeRead(PlatformConfigurationProvider gc, StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 710         boolean compressible = load.accessKind() == JavaKind.Object;
 711         JavaKind readKind = load.accessKind();
 712         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 713         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
<span class="line-modified"> 714         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, gc.getBarrierSet().readBarrierType(load)));</span>
 715         if (guard == null) {
 716             // An unsafe read must not float otherwise it may float above
 717             // a test guaranteeing the read is safe.
 718             memoryRead.setForceFixed(true);
 719         } else {
 720             memoryRead.setGuard(guard);
 721         }
 722         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 723         load.replaceAtUsages(readValue);
 724         return memoryRead;
 725     }
 726 
 727     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 728         StructuredGraph graph = load.graph();
 729         JavaKind readKind = load.getKind();
 730         assert readKind != JavaKind.Object;
 731         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, false);
 732         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(load.getAddress()));
 733         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));
 734         // An unsafe read must not float otherwise it may float above
</pre>
<hr />
<pre>
 737         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, false), readKind);
 738         load.replaceAtUsages(readValue);
 739         graph.replaceFixedWithFixed(load, memoryRead);
 740     }
 741 
 742     private static ValueNode performBooleanCoercionIfNecessary(ValueNode readValue, JavaKind readKind) {
 743         if (readKind == JavaKind.Boolean) {
 744             StructuredGraph graph = readValue.graph();
 745             IntegerEqualsNode eq = graph.addOrUnique(new IntegerEqualsNode(readValue, ConstantNode.forInt(0, graph)));
 746             return graph.addOrUnique(new ConditionalNode(eq, ConstantNode.forBoolean(false, graph), ConstantNode.forBoolean(true, graph)));
 747         }
 748         return readValue;
 749     }
 750 
 751     protected void lowerUnsafeStoreNode(RawStoreNode store) {
 752         StructuredGraph graph = store.graph();
 753         boolean compressible = store.value().getStackKind() == JavaKind.Object;
 754         JavaKind valueKind = store.accessKind();
 755         ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
 756         AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
<span class="line-modified"> 757         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, unsafeStoreBarrierType(store), false));</span>
 758         write.setStateAfter(store.stateAfter());
 759         graph.replaceFixedWithFixed(store, write);
 760     }
 761 
 762     protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
 763         StructuredGraph graph = store.graph();
 764         assert store.getValue().getStackKind() != JavaKind.Object;
 765         JavaKind valueKind = store.getKind();
 766         ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
 767         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
 768         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, BarrierType.NONE, false));
 769         write.setStateAfter(store.stateAfter());
 770         graph.replaceFixedWithFixed(store, write);
 771     }
 772 
 773     protected void lowerJavaReadNode(JavaReadNode read) {
 774         StructuredGraph graph = read.graph();
 775         JavaKind valueKind = read.getReadKind();
 776         Stamp loadStamp = loadStamp(read.stamp(NodeView.DEFAULT), valueKind, read.isCompressible());
 777 
</pre>
<hr />
<pre>
 798         memoryWrite.setGuard(write.getGuard());
 799     }
 800 
 801     @SuppressWarnings(&quot;try&quot;)
 802     protected void lowerCommitAllocationNode(CommitAllocationNode commit, LoweringTool tool) {
 803         StructuredGraph graph = commit.graph();
 804         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
 805             List&lt;AbstractNewObjectNode&gt; recursiveLowerings = new ArrayList&lt;&gt;();
 806 
 807             ValueNode[] allocations = new ValueNode[commit.getVirtualObjects().size()];
 808             BitSet omittedValues = new BitSet();
 809             int valuePos = 0;
 810             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 811                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 812                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 813                     int entryCount = virtual.entryCount();
 814                     AbstractNewObjectNode newObject;
 815                     if (virtual instanceof VirtualInstanceNode) {
 816                         newObject = graph.add(createNewInstanceFromVirtual(virtual));
 817                     } else {

 818                         newObject = graph.add(createNewArrayFromVirtual(virtual, ConstantNode.forInt(entryCount, graph)));
 819                     }
 820                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects
 821                     newObject.clearEmitMemoryBarrier();
 822 
 823                     recursiveLowerings.add(newObject);
 824                     graph.addBeforeFixed(commit, newObject);
 825                     allocations[objIndex] = newObject;
 826                     for (int i = 0; i &lt; entryCount; i++) {
 827                         ValueNode value = commit.getValues().get(valuePos);
 828                         if (value instanceof VirtualObjectNode) {
 829                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 830                         }
 831                         if (value == null) {
 832                             omittedValues.set(valuePos);
 833                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 834                             // Constant.illegal is always the defaultForKind, so it is skipped
 835                             JavaKind valueKind = value.getStackKind();
<span class="line-modified"> 836                             JavaKind entryKind = virtual.entryKind(i);</span>
 837 
 838                             // Truffle requires some leniency in terms of what can be put where:
<span class="line-modified"> 839                             assert valueKind.getStackKind() == entryKind.getStackKind() ||</span>
 840                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode) ||
 841                                                             (valueKind == JavaKind.Float &amp;&amp; virtual instanceof VirtualArrayNode));
 842                             AddressNode address = null;
 843                             BarrierType barrierType = null;
 844                             if (virtual instanceof VirtualInstanceNode) {
 845                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 846                                 long offset = fieldOffset(field);
 847                                 if (offset &gt;= 0) {
 848                                     address = createOffsetAddress(graph, newObject, offset);
<span class="line-modified"> 849                                     barrierType = fieldInitializationBarrier(entryKind);</span>
 850                                 }
 851                             } else {
<span class="line-modified"> 852                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(entryKind) + i * metaAccess.getArrayIndexScale(entryKind));</span>
<span class="line-modified"> 853                                 barrierType = arrayInitializationBarrier(entryKind);</span>

 854                             }
 855                             if (address != null) {
<span class="line-modified"> 856                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), arrayImplicitStoreConvert(graph, entryKind, value, commit, virtual, valuePos), barrierType, false);</span>
 857                                 graph.addAfterFixed(newObject, graph.add(write));
 858                             }
 859                         }
 860                         valuePos++;
 861                     }
 862                 }
 863             }
 864             valuePos = 0;
 865 
 866             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 867                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 868                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 869                     int entryCount = virtual.entryCount();
 870                     ValueNode newObject = allocations[objIndex];
 871                     for (int i = 0; i &lt; entryCount; i++) {
 872                         if (omittedValues.get(valuePos)) {
 873                             ValueNode value = commit.getValues().get(valuePos);
 874                             assert value instanceof VirtualObjectNode;
 875                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 876                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
 877                                 assert virtual.entryKind(i) == JavaKind.Object &amp;&amp; allocValue.getStackKind() == JavaKind.Object;
 878                                 AddressNode address;
 879                                 BarrierType barrierType;
 880                                 if (virtual instanceof VirtualInstanceNode) {
 881                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
<span class="line-modified"> 882                                     address = createFieldAddress(graph, newObject, virtualInstance.field(i));</span>
<span class="line-modified"> 883                                     barrierType = fieldStoreBarrierType(virtualInstance.field(i));</span>

 884                                 } else {

 885                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
<span class="line-modified"> 886                                     barrierType = arrayStoreBarrierType(virtual.entryKind(i));</span>
 887                                 }
 888                                 if (address != null) {
 889                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);
 890                                     graph.addBeforeFixed(commit, graph.add(write));
 891                                 }
 892                             }
 893                         }
 894                         valuePos++;
 895                     }
 896                 }
 897             }
 898 
 899             finishAllocatedObjects(tool, commit, commit, allocations);
 900             graph.removeFixed(commit);
 901 
 902             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 903                 recursiveLowering.lower(tool);
 904             }
 905         }
 906 
</pre>
<hr />
<pre>
 975     }
 976 
 977     /**
 978      * Insert the required {@link MemoryBarriers#STORE_STORE} barrier for an allocation and also
 979      * include the {@link MemoryBarriers#LOAD_STORE} required for final fields if any final fields
 980      * are being written, as if {@link FinalFieldBarrierNode} were emitted.
 981      */
 982     private static void insertAllocationBarrier(FixedWithNextNode insertAfter, CommitAllocationNode commit, StructuredGraph graph) {
 983         int barrier = MemoryBarriers.STORE_STORE;
 984         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 985             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 986                 if (field.isFinal()) {
 987                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 988                     break outer;
 989                 }
 990             }
 991         }
 992         graph.addAfterFixed(insertAfter, graph.add(new MembarNode(barrier, LocationIdentity.init())));
 993     }
 994 
<span class="line-removed"> 995     /**</span>
<span class="line-removed"> 996      * @param field the field whose barrier type should be returned</span>
<span class="line-removed"> 997      */</span>
<span class="line-removed"> 998     public BarrierType fieldLoadBarrierType(ResolvedJavaField field) {</span>
<span class="line-removed"> 999         return BarrierType.NONE;</span>
<span class="line-removed">1000     }</span>
<span class="line-removed">1001 </span>
<span class="line-removed">1002     public BarrierType fieldStoreBarrierType(ResolvedJavaField field) {</span>
<span class="line-removed">1003         if (getStorageKind(field) == JavaKind.Object) {</span>
<span class="line-removed">1004             return BarrierType.FIELD;</span>
<span class="line-removed">1005         }</span>
<span class="line-removed">1006         return BarrierType.NONE;</span>
<span class="line-removed">1007     }</span>
<span class="line-removed">1008 </span>
<span class="line-removed">1009     public BarrierType arrayStoreBarrierType(JavaKind elementKind) {</span>
<span class="line-removed">1010         if (elementKind == JavaKind.Object) {</span>
<span class="line-removed">1011             return BarrierType.ARRAY;</span>
<span class="line-removed">1012         }</span>
<span class="line-removed">1013         return BarrierType.NONE;</span>
<span class="line-removed">1014     }</span>
<span class="line-removed">1015 </span>
<span class="line-removed">1016     public BarrierType fieldInitializationBarrier(JavaKind entryKind) {</span>
<span class="line-removed">1017         return entryKind == JavaKind.Object ? BarrierType.FIELD : BarrierType.NONE;</span>
<span class="line-removed">1018     }</span>
<span class="line-removed">1019 </span>
<span class="line-removed">1020     public BarrierType arrayInitializationBarrier(JavaKind entryKind) {</span>
<span class="line-removed">1021         return entryKind == JavaKind.Object ? BarrierType.ARRAY : BarrierType.NONE;</span>
<span class="line-removed">1022     }</span>
<span class="line-removed">1023 </span>
<span class="line-removed">1024     private BarrierType unsafeStoreBarrierType(RawStoreNode store) {</span>
<span class="line-removed">1025         if (!store.needsBarrier()) {</span>
<span class="line-removed">1026             return BarrierType.NONE;</span>
<span class="line-removed">1027         }</span>
<span class="line-removed">1028         return guessStoreBarrierType(store.object(), store.value());</span>
<span class="line-removed">1029     }</span>
<span class="line-removed">1030 </span>
<span class="line-removed">1031     private BarrierType guessStoreBarrierType(ValueNode object, ValueNode value) {</span>
<span class="line-removed">1032         if (value.getStackKind() == JavaKind.Object &amp;&amp; object.getStackKind() == JavaKind.Object) {</span>
<span class="line-removed">1033             ResolvedJavaType type = StampTool.typeOrNull(object);</span>
<span class="line-removed">1034             // Array types must use a precise barrier, so if the type is unknown or is a supertype</span>
<span class="line-removed">1035             // of Object[] then treat it as an array.</span>
<span class="line-removed">1036             if (type != null &amp;&amp; type.isArray()) {</span>
<span class="line-removed">1037                 return BarrierType.ARRAY;</span>
<span class="line-removed">1038             } else if (type == null || type.isAssignableFrom(objectArrayType)) {</span>
<span class="line-removed">1039                 return BarrierType.UNKNOWN;</span>
<span class="line-removed">1040             } else {</span>
<span class="line-removed">1041                 return BarrierType.FIELD;</span>
<span class="line-removed">1042             }</span>
<span class="line-removed">1043         }</span>
<span class="line-removed">1044         return BarrierType.NONE;</span>
<span class="line-removed">1045     }</span>
<span class="line-removed">1046 </span>
1047     public abstract int fieldOffset(ResolvedJavaField field);
1048 
1049     public FieldLocationIdentity fieldLocationIdentity(ResolvedJavaField field) {
1050         return new FieldLocationIdentity(field);
1051     }
1052 
1053     public abstract ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField field);
1054 
1055     public abstract int arrayLengthOffset();
1056 
1057     public Stamp loadStamp(Stamp stamp, JavaKind kind) {
1058         return loadStamp(stamp, kind, true);
1059     }
1060 
1061     private boolean useCompressedOops(JavaKind kind, boolean compressible) {
1062         return kind == JavaKind.Object &amp;&amp; compressible &amp;&amp; useCompressedOops;
1063     }
1064 
1065     protected abstract Stamp loadCompressedStamp(ObjectStamp stamp);
1066 
</pre>
</td>
<td>
<hr />
<pre>
  90 import org.graalvm.compiler.nodes.calc.SubNode;
  91 import org.graalvm.compiler.nodes.calc.UnpackEndianHalfNode;
  92 import org.graalvm.compiler.nodes.calc.ZeroExtendNode;
  93 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
  94 import org.graalvm.compiler.nodes.extended.BoxNode;
  95 import org.graalvm.compiler.nodes.extended.FixedValueAnchorNode;
  96 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
  97 import org.graalvm.compiler.nodes.extended.GuardedUnsafeLoadNode;
  98 import org.graalvm.compiler.nodes.extended.GuardingNode;
  99 import org.graalvm.compiler.nodes.extended.JavaReadNode;
 100 import org.graalvm.compiler.nodes.extended.JavaWriteNode;
 101 import org.graalvm.compiler.nodes.extended.LoadArrayComponentHubNode;
 102 import org.graalvm.compiler.nodes.extended.LoadHubNode;
 103 import org.graalvm.compiler.nodes.extended.LoadHubOrNullNode;
 104 import org.graalvm.compiler.nodes.extended.MembarNode;
 105 import org.graalvm.compiler.nodes.extended.RawLoadNode;
 106 import org.graalvm.compiler.nodes.extended.RawStoreNode;
 107 import org.graalvm.compiler.nodes.extended.UnboxNode;
 108 import org.graalvm.compiler.nodes.extended.UnsafeMemoryLoadNode;
 109 import org.graalvm.compiler.nodes.extended.UnsafeMemoryStoreNode;
<span class="line-added"> 110 import org.graalvm.compiler.nodes.gc.BarrierSet;</span>
 111 import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
 112 import org.graalvm.compiler.nodes.java.AccessIndexedNode;
 113 import org.graalvm.compiler.nodes.java.ArrayLengthNode;
 114 import org.graalvm.compiler.nodes.java.AtomicReadAndWriteNode;
 115 import org.graalvm.compiler.nodes.java.FinalFieldBarrierNode;
 116 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
 117 import org.graalvm.compiler.nodes.java.InstanceOfNode;
 118 import org.graalvm.compiler.nodes.java.LoadFieldNode;
 119 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 120 import org.graalvm.compiler.nodes.java.LogicCompareAndSwapNode;
 121 import org.graalvm.compiler.nodes.java.LoweredAtomicReadAndWriteNode;
 122 import org.graalvm.compiler.nodes.java.MonitorEnterNode;
 123 import org.graalvm.compiler.nodes.java.MonitorIdNode;
 124 import org.graalvm.compiler.nodes.java.NewArrayNode;
 125 import org.graalvm.compiler.nodes.java.NewInstanceNode;
 126 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
 127 import org.graalvm.compiler.nodes.java.StoreFieldNode;
 128 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 129 import org.graalvm.compiler.nodes.java.UnsafeCompareAndExchangeNode;
 130 import org.graalvm.compiler.nodes.java.UnsafeCompareAndSwapNode;
</pre>
<hr />
<pre>
 158 import jdk.vm.ci.code.MemoryBarriers;
 159 import jdk.vm.ci.code.TargetDescription;
 160 import jdk.vm.ci.meta.DeoptimizationAction;
 161 import jdk.vm.ci.meta.DeoptimizationReason;
 162 import jdk.vm.ci.meta.JavaConstant;
 163 import jdk.vm.ci.meta.JavaKind;
 164 import jdk.vm.ci.meta.MetaAccessProvider;
 165 import jdk.vm.ci.meta.ResolvedJavaField;
 166 import jdk.vm.ci.meta.ResolvedJavaMethod;
 167 import jdk.vm.ci.meta.ResolvedJavaType;
 168 import jdk.vm.ci.meta.SpeculationLog;
 169 
 170 /**
 171  * VM-independent lowerings for standard Java nodes. VM-specific methods are abstract and must be
 172  * implemented by VM-specific subclasses.
 173  */
 174 public abstract class DefaultJavaLoweringProvider implements LoweringProvider {
 175 
 176     protected final MetaAccessProvider metaAccess;
 177     protected final ForeignCallsProvider foreignCalls;
<span class="line-added"> 178     protected final BarrierSet barrierSet;</span>
 179     protected final TargetDescription target;
 180     private final boolean useCompressedOops;

 181 
 182     private BoxingSnippets.Templates boxingSnippets;
 183     private ConstantStringIndexOfSnippets.Templates indexOfSnippets;
 184 
<span class="line-modified"> 185     public DefaultJavaLoweringProvider(MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, PlatformConfigurationProvider platformConfig, TargetDescription target,</span>
<span class="line-added"> 186                     boolean useCompressedOops) {</span>
 187         this.metaAccess = metaAccess;
 188         this.foreignCalls = foreignCalls;
<span class="line-added"> 189         this.barrierSet = platformConfig.getBarrierSet();</span>
 190         this.target = target;
 191         this.useCompressedOops = useCompressedOops;

 192     }
 193 
 194     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, SnippetCounter.Group.Factory factory, Providers providers, SnippetReflectionProvider snippetReflection) {
 195         boxingSnippets = new BoxingSnippets.Templates(options, factories, factory, providers, snippetReflection, target);
 196         indexOfSnippets = new ConstantStringIndexOfSnippets.Templates(options, factories, providers, snippetReflection, target);
 197         providers.getReplacements().registerSnippetTemplateCache(new SnippetCounterNode.SnippetCounterSnippets.Templates(options, factories, providers, snippetReflection, target));
 198     }
 199 
 200     public final TargetDescription getTarget() {
 201         return target;
 202     }
 203 
 204     public MetaAccessProvider getMetaAccess() {
 205         return metaAccess;
 206     }
 207 
<span class="line-added"> 208     public BarrierSet getBarrierSet() {</span>
<span class="line-added"> 209         return barrierSet;</span>
<span class="line-added"> 210     }</span>
<span class="line-added"> 211 </span>
 212     @Override
 213     @SuppressWarnings(&quot;try&quot;)
 214     public void lower(Node n, LoweringTool tool) {
 215         assert n instanceof Lowerable;
 216         StructuredGraph graph = (StructuredGraph) n.graph();
 217         try (DebugCloseable context = n.withNodeSourcePosition()) {
 218             if (n instanceof LoadFieldNode) {
 219                 lowerLoadFieldNode((LoadFieldNode) n, tool);
 220             } else if (n instanceof StoreFieldNode) {
 221                 lowerStoreFieldNode((StoreFieldNode) n, tool);
 222             } else if (n instanceof LoadIndexedNode) {
 223                 lowerLoadIndexedNode((LoadIndexedNode) n, tool);
 224             } else if (n instanceof StoreIndexedNode) {
 225                 lowerStoreIndexedNode((StoreIndexedNode) n, tool);
 226             } else if (n instanceof IndexAddressNode) {
 227                 lowerIndexAddressNode((IndexAddressNode) n);
 228             } else if (n instanceof ArrayLengthNode) {
 229                 lowerArrayLengthNode((ArrayLengthNode) n, tool);
 230             } else if (n instanceof LoadHubNode) {
 231                 lowerLoadHubNode((LoadHubNode) n, tool);
</pre>
<hr />
<pre>
 377     }
 378 
 379     protected void lowerVerifyHeap(VerifyHeapNode n) {
 380         GraphUtil.removeFixedWithUnusedInputs(n);
 381     }
 382 
 383     public AddressNode createOffsetAddress(StructuredGraph graph, ValueNode object, long offset) {
 384         ValueNode o = ConstantNode.forIntegerKind(target.wordJavaKind, offset, graph);
 385         return graph.unique(new OffsetAddressNode(object, o));
 386     }
 387 
 388     public AddressNode createFieldAddress(StructuredGraph graph, ValueNode object, ResolvedJavaField field) {
 389         int offset = fieldOffset(field);
 390         if (offset &gt;= 0) {
 391             return createOffsetAddress(graph, object, offset);
 392         } else {
 393             return null;
 394         }
 395     }
 396 
<span class="line-modified"> 397     public abstract JavaKind getStorageKind(ResolvedJavaField field);</span>
 398 
 399     protected void lowerLoadFieldNode(LoadFieldNode loadField, LoweringTool tool) {
 400         assert loadField.getStackKind() != JavaKind.Illegal;
 401         StructuredGraph graph = loadField.graph();
 402         ResolvedJavaField field = loadField.field();
 403         ValueNode object = loadField.isStatic() ? staticFieldBase(graph, field) : loadField.object();
 404         object = createNullCheckedValue(object, loadField, tool);
 405         Stamp loadStamp = loadStamp(loadField.stamp(NodeView.DEFAULT), getStorageKind(field));
 406 
 407         AddressNode address = createFieldAddress(graph, object, field);
 408         assert address != null : &quot;Field that is loaded must not be eliminated: &quot; + field.getDeclaringClass().toJavaName(true) + &quot;.&quot; + field.getName();
 409 
 410         ReadNode memoryRead = null;
 411         if (loadField.isVolatile() &amp;&amp; GraalOptions.LateMembars.getValue(graph.getOptions())) {
<span class="line-modified"> 412             memoryRead = graph.add(new VolatileReadNode(address, fieldLocationIdentity(field), loadStamp, barrierSet.fieldLoadBarrierType(field, getStorageKind(field))));</span>
 413         } else {
<span class="line-modified"> 414             memoryRead = graph.add(new ReadNode(address, fieldLocationIdentity(field), loadStamp, barrierSet.fieldLoadBarrierType(field, getStorageKind(field))));</span>
 415         }
 416         ValueNode readValue = implicitLoadConvert(graph, getStorageKind(field), memoryRead);
 417         loadField.replaceAtUsages(readValue);
 418         graph.replaceFixed(loadField, memoryRead);
 419 
 420         if (loadField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {
 421             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_READ));
 422             graph.addBeforeFixed(memoryRead, preMembar);
 423             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_READ));
 424             graph.addAfterFixed(memoryRead, postMembar);
 425         }
 426     }
 427 
 428     protected void lowerStoreFieldNode(StoreFieldNode storeField, LoweringTool tool) {
 429         StructuredGraph graph = storeField.graph();
 430         ResolvedJavaField field = storeField.field();
 431         ValueNode object = storeField.isStatic() ? staticFieldBase(graph, field) : storeField.object();
 432         object = createNullCheckedValue(object, storeField, tool);
 433         ValueNode value = implicitStoreConvert(graph, getStorageKind(storeField.field()), storeField.value());
 434         AddressNode address = createFieldAddress(graph, object, field);
 435         assert address != null;
 436 
<span class="line-modified"> 437         WriteNode memoryWrite = graph.add(new WriteNode(address, fieldLocationIdentity(field), value, barrierSet.fieldStoreBarrierType(field, getStorageKind(field)), storeField.isVolatile()));</span>
 438         memoryWrite.setStateAfter(storeField.stateAfter());
 439         graph.replaceFixedWithFixed(storeField, memoryWrite);
 440 
 441         if (storeField.isVolatile() &amp;&amp; !GraalOptions.LateMembars.getValue(graph.getOptions())) {
 442             MembarNode preMembar = graph.add(new MembarNode(JMM_PRE_VOLATILE_WRITE));
 443             graph.addBeforeFixed(memoryWrite, preMembar);
 444             MembarNode postMembar = graph.add(new MembarNode(JMM_POST_VOLATILE_WRITE));
 445             graph.addAfterFixed(memoryWrite, postMembar);
 446         }
 447     }
 448 
 449     public static final IntegerStamp POSITIVE_ARRAY_INDEX_STAMP = StampFactory.forInteger(32, 0, Integer.MAX_VALUE - 1);
 450 
 451     /**
 452      * Create a PiNode on the index proving that the index is positive. On some platforms this is
 453      * important to allow the index to be used as an int in the address mode.
 454      */
 455     public AddressNode createArrayIndexAddress(StructuredGraph graph, ValueNode array, JavaKind elementKind, ValueNode index, GuardingNode boundsCheck) {
 456         ValueNode positiveIndex = graph.maybeAddOrUnique(PiNode.create(index, POSITIVE_ARRAY_INDEX_STAMP, boundsCheck != null ? boundsCheck.asNode() : null));
 457         return createArrayAddress(graph, array, elementKind, positiveIndex);
</pre>
<hr />
<pre>
 499         AddressNode address = createArrayIndexAddress(graph, array, elementKind, index, boundsCheck);
 500 
 501         ReadNode memoryRead = graph.add(new ReadNode(address, NamedLocationIdentity.getArrayLocation(elementKind), loadStamp, BarrierType.NONE));
 502         memoryRead.setGuard(boundsCheck);
 503         ValueNode readValue = implicitLoadConvert(graph, elementKind, memoryRead);
 504 
 505         loadIndexed.replaceAtUsages(readValue);
 506         graph.replaceFixed(loadIndexed, memoryRead);
 507     }
 508 
 509     protected void lowerStoreIndexedNode(StoreIndexedNode storeIndexed, LoweringTool tool) {
 510         StructuredGraph graph = storeIndexed.graph();
 511 
 512         ValueNode value = storeIndexed.value();
 513         ValueNode array = storeIndexed.array();
 514 
 515         array = this.createNullCheckedValue(array, storeIndexed, tool);
 516 
 517         GuardingNode boundsCheck = getBoundsCheck(storeIndexed, array, tool);
 518 
<span class="line-modified"> 519         JavaKind storageKind = storeIndexed.elementKind();</span>
 520 
 521         LogicNode condition = null;
<span class="line-modified"> 522         if (storeIndexed.getStoreCheck() == null &amp;&amp; storageKind == JavaKind.Object &amp;&amp; !StampTool.isPointerAlwaysNull(value)) {</span>
 523             /* Array store check. */
 524             TypeReference arrayType = StampTool.typeReferenceOrNull(array);
 525             if (arrayType != null &amp;&amp; arrayType.isExact()) {
 526                 ResolvedJavaType elementType = arrayType.getType().getComponentType();
 527                 if (!elementType.isJavaLangObject()) {
 528                     TypeReference typeReference = TypeReference.createTrusted(storeIndexed.graph().getAssumptions(), elementType);
 529                     LogicNode typeTest = graph.addOrUniqueWithInputs(InstanceOfNode.create(typeReference, value));
 530                     condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 531                 }
 532             } else {
 533                 /*
 534                  * The guard on the read hub should be the null check of the array that was
 535                  * introduced earlier.
 536                  */
 537                 ValueNode arrayClass = createReadHub(graph, array, tool);
 538                 ValueNode componentHub = createReadArrayComponentHub(graph, arrayClass, storeIndexed);
 539                 LogicNode typeTest = graph.unique(InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), componentHub, value, false));
 540                 condition = LogicNode.or(graph.unique(IsNullNode.create(value)), typeTest, GraalDirectives.UNLIKELY_PROBABILITY);
 541             }
 542         }
 543 
<span class="line-modified"> 544         AddressNode address = createArrayIndexAddress(graph, array, storageKind, storeIndexed.index(), boundsCheck);</span>
<span class="line-modified"> 545         WriteNode memoryWrite = graph.add(new WriteNode(address, NamedLocationIdentity.getArrayLocation(storageKind), implicitStoreConvert(graph, storageKind, value),</span>
<span class="line-modified"> 546                         barrierSet.arrayStoreBarrierType(storageKind), false));</span>
 547         memoryWrite.setGuard(boundsCheck);
 548         if (condition != null) {
 549             tool.createGuard(storeIndexed, condition, DeoptimizationReason.ArrayStoreException, DeoptimizationAction.InvalidateReprofile);
 550         }
 551         memoryWrite.setStateAfter(storeIndexed.stateAfter());
 552         graph.replaceFixedWithFixed(storeIndexed, memoryWrite);
 553     }
 554 
 555     protected void lowerArrayLengthNode(ArrayLengthNode arrayLengthNode, LoweringTool tool) {
 556         arrayLengthNode.replaceAtUsages(createReadArrayLength(arrayLengthNode.array(), arrayLengthNode, tool));
 557         StructuredGraph graph = arrayLengthNode.graph();
 558         graph.removeFixed(arrayLengthNode);
 559     }
 560 
 561     /**
 562      * Creates a read node that read the array length and is guarded by a null-check.
 563      *
 564      * The created node is placed before {@code before} in the CFG.
 565      */
 566     protected ReadNode createReadArrayLength(ValueNode array, FixedNode before, LoweringTool tool) {
</pre>
<hr />
<pre>
 620         graph.replaceFixed(loadHub, hub);
 621     }
 622 
 623     protected void lowerMonitorEnterNode(MonitorEnterNode monitorEnter, LoweringTool tool, StructuredGraph graph) {
 624         ValueNode object = createNullCheckedValue(monitorEnter.object(), monitorEnter, tool);
 625         ValueNode hub = graph.addOrUnique(LoadHubNode.create(object, tool.getStampProvider(), tool.getMetaAccess(), tool.getConstantReflection()));
 626         RawMonitorEnterNode rawMonitorEnter = graph.add(new RawMonitorEnterNode(object, hub, monitorEnter.getMonitorId(), monitorEnter.isBiasable()));
 627         rawMonitorEnter.setStateBefore(monitorEnter.stateBefore());
 628         rawMonitorEnter.setStateAfter(monitorEnter.stateAfter());
 629         graph.replaceFixedWithFixed(monitorEnter, rawMonitorEnter);
 630     }
 631 
 632     protected void lowerCompareAndSwapNode(UnsafeCompareAndSwapNode cas) {
 633         StructuredGraph graph = cas.graph();
 634         JavaKind valueKind = cas.getValueKind();
 635 
 636         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 637         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 638 
 639         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
<span class="line-modified"> 640         BarrierType barrierType = barrierSet.guessStoreBarrierType(cas.object(), newValue);</span>
 641         LogicCompareAndSwapNode atomicNode = graph.add(new LogicCompareAndSwapNode(address, cas.getKilledLocationIdentity(), expectedValue, newValue, barrierType));
 642         atomicNode.setStateAfter(cas.stateAfter());
 643         graph.replaceFixedWithFixed(cas, atomicNode);
 644     }
 645 
 646     protected void lowerCompareAndExchangeNode(UnsafeCompareAndExchangeNode cas) {
 647         StructuredGraph graph = cas.graph();
 648         JavaKind valueKind = cas.getValueKind();
 649 
 650         ValueNode expectedValue = implicitStoreConvert(graph, valueKind, cas.expected());
 651         ValueNode newValue = implicitStoreConvert(graph, valueKind, cas.newValue());
 652 
 653         AddressNode address = graph.unique(new OffsetAddressNode(cas.object(), cas.offset()));
<span class="line-modified"> 654         BarrierType barrierType = barrierSet.guessStoreBarrierType(cas.object(), newValue);</span>
 655         ValueCompareAndSwapNode atomicNode = graph.add(new ValueCompareAndSwapNode(address, expectedValue, newValue, cas.getKilledLocationIdentity(), barrierType));
 656         ValueNode coercedNode = implicitLoadConvert(graph, valueKind, atomicNode, true);
 657         atomicNode.setStateAfter(cas.stateAfter());
 658         cas.replaceAtUsages(coercedNode);
 659         graph.replaceFixedWithFixed(cas, atomicNode);
 660     }
 661 
 662     protected void lowerAtomicReadAndWriteNode(AtomicReadAndWriteNode n) {
 663         StructuredGraph graph = n.graph();
 664         JavaKind valueKind = n.getValueKind();
 665 
 666         ValueNode newValue = implicitStoreConvert(graph, valueKind, n.newValue());
 667 
 668         AddressNode address = graph.unique(new OffsetAddressNode(n.object(), n.offset()));
<span class="line-modified"> 669         BarrierType barrierType = barrierSet.guessStoreBarrierType(n.object(), newValue);</span>
 670         LIRKind lirAccessKind = LIRKind.fromJavaKind(target.arch, valueKind);
 671         LoweredAtomicReadAndWriteNode memoryRead = graph.add(new LoweredAtomicReadAndWriteNode(address, n.getKilledLocationIdentity(), newValue, lirAccessKind, barrierType));
 672         memoryRead.setStateAfter(n.stateAfter());
 673 
 674         ValueNode readValue = implicitLoadConvert(graph, valueKind, memoryRead);
 675         n.stateAfter().replaceFirstInput(n, memoryRead);
 676         n.replaceAtUsages(readValue);
 677         graph.replaceFixedWithFixed(n, memoryRead);
 678     }
 679 
 680     /**
 681      * @param tool utility for performing the lowering
 682      */
 683     protected void lowerUnsafeLoadNode(RawLoadNode load, LoweringTool tool) {

 684         StructuredGraph graph = load.graph();
 685         if (load instanceof GuardedUnsafeLoadNode) {
 686             GuardedUnsafeLoadNode guardedLoad = (GuardedUnsafeLoadNode) load;
 687             GuardingNode guard = guardedLoad.getGuard();
 688             if (guard == null) {
 689                 // can float freely if the guard folded away
<span class="line-modified"> 690                 ReadNode memoryRead = createUnsafeRead(graph, load, null);</span>
 691                 memoryRead.setForceFixed(false);
 692                 graph.replaceFixedWithFixed(load, memoryRead);
 693             } else {
 694                 // must be guarded, but flows below the guard
<span class="line-modified"> 695                 ReadNode memoryRead = createUnsafeRead(graph, load, guard);</span>
 696                 graph.replaceFixedWithFixed(load, memoryRead);
 697             }
 698         } else {
 699             // never had a guarding condition so it must be fixed, creation of the read will force
 700             // it to be fixed
<span class="line-modified"> 701             ReadNode memoryRead = createUnsafeRead(graph, load, null);</span>
 702             graph.replaceFixedWithFixed(load, memoryRead);
 703         }
 704     }
 705 
 706     protected AddressNode createUnsafeAddress(StructuredGraph graph, ValueNode object, ValueNode offset) {
 707         if (object.isConstant() &amp;&amp; object.asConstant().isDefaultForKind()) {
 708             return graph.addOrUniqueWithInputs(OffsetAddressNode.create(offset));
 709         } else {
 710             return graph.unique(new OffsetAddressNode(object, offset));
 711         }
 712     }
 713 
<span class="line-modified"> 714     protected ReadNode createUnsafeRead(StructuredGraph graph, RawLoadNode load, GuardingNode guard) {</span>
 715         boolean compressible = load.accessKind() == JavaKind.Object;
 716         JavaKind readKind = load.accessKind();
 717         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, compressible);
 718         AddressNode address = createUnsafeAddress(graph, load.object(), load.offset());
<span class="line-modified"> 719         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, barrierSet.readBarrierType(load)));</span>
 720         if (guard == null) {
 721             // An unsafe read must not float otherwise it may float above
 722             // a test guaranteeing the read is safe.
 723             memoryRead.setForceFixed(true);
 724         } else {
 725             memoryRead.setGuard(guard);
 726         }
 727         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, compressible), readKind);
 728         load.replaceAtUsages(readValue);
 729         return memoryRead;
 730     }
 731 
 732     protected void lowerUnsafeMemoryLoadNode(UnsafeMemoryLoadNode load) {
 733         StructuredGraph graph = load.graph();
 734         JavaKind readKind = load.getKind();
 735         assert readKind != JavaKind.Object;
 736         Stamp loadStamp = loadStamp(load.stamp(NodeView.DEFAULT), readKind, false);
 737         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(load.getAddress()));
 738         ReadNode memoryRead = graph.add(new ReadNode(address, load.getLocationIdentity(), loadStamp, BarrierType.NONE));
 739         // An unsafe read must not float otherwise it may float above
</pre>
<hr />
<pre>
 742         ValueNode readValue = performBooleanCoercionIfNecessary(implicitLoadConvert(graph, readKind, memoryRead, false), readKind);
 743         load.replaceAtUsages(readValue);
 744         graph.replaceFixedWithFixed(load, memoryRead);
 745     }
 746 
 747     private static ValueNode performBooleanCoercionIfNecessary(ValueNode readValue, JavaKind readKind) {
 748         if (readKind == JavaKind.Boolean) {
 749             StructuredGraph graph = readValue.graph();
 750             IntegerEqualsNode eq = graph.addOrUnique(new IntegerEqualsNode(readValue, ConstantNode.forInt(0, graph)));
 751             return graph.addOrUnique(new ConditionalNode(eq, ConstantNode.forBoolean(false, graph), ConstantNode.forBoolean(true, graph)));
 752         }
 753         return readValue;
 754     }
 755 
 756     protected void lowerUnsafeStoreNode(RawStoreNode store) {
 757         StructuredGraph graph = store.graph();
 758         boolean compressible = store.value().getStackKind() == JavaKind.Object;
 759         JavaKind valueKind = store.accessKind();
 760         ValueNode value = implicitStoreConvert(graph, valueKind, store.value(), compressible);
 761         AddressNode address = createUnsafeAddress(graph, store.object(), store.offset());
<span class="line-modified"> 762         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, barrierSet.storeBarrierType(store), false));</span>
 763         write.setStateAfter(store.stateAfter());
 764         graph.replaceFixedWithFixed(store, write);
 765     }
 766 
 767     protected void lowerUnsafeMemoryStoreNode(UnsafeMemoryStoreNode store) {
 768         StructuredGraph graph = store.graph();
 769         assert store.getValue().getStackKind() != JavaKind.Object;
 770         JavaKind valueKind = store.getKind();
 771         ValueNode value = implicitStoreConvert(graph, valueKind, store.getValue(), false);
 772         AddressNode address = graph.addOrUniqueWithInputs(OffsetAddressNode.create(store.getAddress()));
 773         WriteNode write = graph.add(new WriteNode(address, store.getKilledLocationIdentity(), value, BarrierType.NONE, false));
 774         write.setStateAfter(store.stateAfter());
 775         graph.replaceFixedWithFixed(store, write);
 776     }
 777 
 778     protected void lowerJavaReadNode(JavaReadNode read) {
 779         StructuredGraph graph = read.graph();
 780         JavaKind valueKind = read.getReadKind();
 781         Stamp loadStamp = loadStamp(read.stamp(NodeView.DEFAULT), valueKind, read.isCompressible());
 782 
</pre>
<hr />
<pre>
 803         memoryWrite.setGuard(write.getGuard());
 804     }
 805 
 806     @SuppressWarnings(&quot;try&quot;)
 807     protected void lowerCommitAllocationNode(CommitAllocationNode commit, LoweringTool tool) {
 808         StructuredGraph graph = commit.graph();
 809         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
 810             List&lt;AbstractNewObjectNode&gt; recursiveLowerings = new ArrayList&lt;&gt;();
 811 
 812             ValueNode[] allocations = new ValueNode[commit.getVirtualObjects().size()];
 813             BitSet omittedValues = new BitSet();
 814             int valuePos = 0;
 815             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 816                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 817                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 818                     int entryCount = virtual.entryCount();
 819                     AbstractNewObjectNode newObject;
 820                     if (virtual instanceof VirtualInstanceNode) {
 821                         newObject = graph.add(createNewInstanceFromVirtual(virtual));
 822                     } else {
<span class="line-added"> 823                         assert virtual instanceof VirtualArrayNode;</span>
 824                         newObject = graph.add(createNewArrayFromVirtual(virtual, ConstantNode.forInt(entryCount, graph)));
 825                     }
 826                     // The final STORE_STORE barrier will be emitted by finishAllocatedObjects
 827                     newObject.clearEmitMemoryBarrier();
 828 
 829                     recursiveLowerings.add(newObject);
 830                     graph.addBeforeFixed(commit, newObject);
 831                     allocations[objIndex] = newObject;
 832                     for (int i = 0; i &lt; entryCount; i++) {
 833                         ValueNode value = commit.getValues().get(valuePos);
 834                         if (value instanceof VirtualObjectNode) {
 835                             value = allocations[commit.getVirtualObjects().indexOf(value)];
 836                         }
 837                         if (value == null) {
 838                             omittedValues.set(valuePos);
 839                         } else if (!(value.isConstant() &amp;&amp; value.asConstant().isDefaultForKind())) {
 840                             // Constant.illegal is always the defaultForKind, so it is skipped
 841                             JavaKind valueKind = value.getStackKind();
<span class="line-modified"> 842                             JavaKind storageKind = virtual.entryKind(i);</span>
 843 
 844                             // Truffle requires some leniency in terms of what can be put where:
<span class="line-modified"> 845                             assert valueKind.getStackKind() == storageKind.getStackKind() ||</span>
 846                                             (valueKind == JavaKind.Long || valueKind == JavaKind.Double || (valueKind == JavaKind.Int &amp;&amp; virtual instanceof VirtualArrayNode) ||
 847                                                             (valueKind == JavaKind.Float &amp;&amp; virtual instanceof VirtualArrayNode));
 848                             AddressNode address = null;
 849                             BarrierType barrierType = null;
 850                             if (virtual instanceof VirtualInstanceNode) {
 851                                 ResolvedJavaField field = ((VirtualInstanceNode) virtual).field(i);
 852                                 long offset = fieldOffset(field);
 853                                 if (offset &gt;= 0) {
 854                                     address = createOffsetAddress(graph, newObject, offset);
<span class="line-modified"> 855                                     barrierType = barrierSet.fieldStoreBarrierType(field, getStorageKind(field));</span>
 856                                 }
 857                             } else {
<span class="line-modified"> 858                                 assert virtual instanceof VirtualArrayNode;</span>
<span class="line-modified"> 859                                 address = createOffsetAddress(graph, newObject, metaAccess.getArrayBaseOffset(storageKind) + i * metaAccess.getArrayIndexScale(storageKind));</span>
<span class="line-added"> 860                                 barrierType = barrierSet.arrayStoreBarrierType(storageKind);</span>
 861                             }
 862                             if (address != null) {
<span class="line-modified"> 863                                 WriteNode write = new WriteNode(address, LocationIdentity.init(), arrayImplicitStoreConvert(graph, storageKind, value, commit, virtual, valuePos), barrierType, false);</span>
 864                                 graph.addAfterFixed(newObject, graph.add(write));
 865                             }
 866                         }
 867                         valuePos++;
 868                     }
 869                 }
 870             }
 871             valuePos = 0;
 872 
 873             for (int objIndex = 0; objIndex &lt; commit.getVirtualObjects().size(); objIndex++) {
 874                 VirtualObjectNode virtual = commit.getVirtualObjects().get(objIndex);
 875                 try (DebugCloseable nsp = graph.withNodeSourcePosition(virtual)) {
 876                     int entryCount = virtual.entryCount();
 877                     ValueNode newObject = allocations[objIndex];
 878                     for (int i = 0; i &lt; entryCount; i++) {
 879                         if (omittedValues.get(valuePos)) {
 880                             ValueNode value = commit.getValues().get(valuePos);
 881                             assert value instanceof VirtualObjectNode;
 882                             ValueNode allocValue = allocations[commit.getVirtualObjects().indexOf(value)];
 883                             if (!(allocValue.isConstant() &amp;&amp; allocValue.asConstant().isDefaultForKind())) {
 884                                 assert virtual.entryKind(i) == JavaKind.Object &amp;&amp; allocValue.getStackKind() == JavaKind.Object;
 885                                 AddressNode address;
 886                                 BarrierType barrierType;
 887                                 if (virtual instanceof VirtualInstanceNode) {
 888                                     VirtualInstanceNode virtualInstance = (VirtualInstanceNode) virtual;
<span class="line-modified"> 889                                     ResolvedJavaField field = virtualInstance.field(i);</span>
<span class="line-modified"> 890                                     address = createFieldAddress(graph, newObject, field);</span>
<span class="line-added"> 891                                     barrierType = barrierSet.fieldStoreBarrierType(field, getStorageKind(field));</span>
 892                                 } else {
<span class="line-added"> 893                                     assert virtual instanceof VirtualArrayNode;</span>
 894                                     address = createArrayAddress(graph, newObject, virtual.entryKind(i), ConstantNode.forInt(i, graph));
<span class="line-modified"> 895                                     barrierType = barrierSet.arrayStoreBarrierType(virtual.entryKind(i));</span>
 896                                 }
 897                                 if (address != null) {
 898                                     WriteNode write = new WriteNode(address, LocationIdentity.init(), implicitStoreConvert(graph, JavaKind.Object, allocValue), barrierType, false);
 899                                     graph.addBeforeFixed(commit, graph.add(write));
 900                                 }
 901                             }
 902                         }
 903                         valuePos++;
 904                     }
 905                 }
 906             }
 907 
 908             finishAllocatedObjects(tool, commit, commit, allocations);
 909             graph.removeFixed(commit);
 910 
 911             for (AbstractNewObjectNode recursiveLowering : recursiveLowerings) {
 912                 recursiveLowering.lower(tool);
 913             }
 914         }
 915 
</pre>
<hr />
<pre>
 984     }
 985 
 986     /**
 987      * Insert the required {@link MemoryBarriers#STORE_STORE} barrier for an allocation and also
 988      * include the {@link MemoryBarriers#LOAD_STORE} required for final fields if any final fields
 989      * are being written, as if {@link FinalFieldBarrierNode} were emitted.
 990      */
 991     private static void insertAllocationBarrier(FixedWithNextNode insertAfter, CommitAllocationNode commit, StructuredGraph graph) {
 992         int barrier = MemoryBarriers.STORE_STORE;
 993         outer: for (VirtualObjectNode vobj : commit.getVirtualObjects()) {
 994             for (ResolvedJavaField field : vobj.type().getInstanceFields(true)) {
 995                 if (field.isFinal()) {
 996                     barrier = barrier | MemoryBarriers.LOAD_STORE;
 997                     break outer;
 998                 }
 999             }
1000         }
1001         graph.addAfterFixed(insertAfter, graph.add(new MembarNode(barrier, LocationIdentity.init())));
1002     }
1003 




















































1004     public abstract int fieldOffset(ResolvedJavaField field);
1005 
1006     public FieldLocationIdentity fieldLocationIdentity(ResolvedJavaField field) {
1007         return new FieldLocationIdentity(field);
1008     }
1009 
1010     public abstract ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField field);
1011 
1012     public abstract int arrayLengthOffset();
1013 
1014     public Stamp loadStamp(Stamp stamp, JavaKind kind) {
1015         return loadStamp(stamp, kind, true);
1016     }
1017 
1018     private boolean useCompressedOops(JavaKind kind, boolean compressible) {
1019         return kind == JavaKind.Object &amp;&amp; compressible &amp;&amp; useCompressedOops;
1020     }
1021 
1022     protected abstract Stamp loadCompressedStamp(ObjectStamp stamp);
1023 
</pre>
</td>
</tr>
</table>
<center><a href="../../../../../../org.graalvm.compiler.replacements.test/src/org/graalvm/compiler/replacements/test/SubstitutionsTest.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="SnippetLowerableMemoryNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
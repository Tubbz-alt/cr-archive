<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/DefaultHotSpotLoweringProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 
 25 package org.graalvm.compiler.hotspot.meta;
 26 
 27 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
 28 import static org.graalvm.compiler.core.common.GraalOptions.AlwaysInlineVTableStubs;
 29 import static org.graalvm.compiler.core.common.GraalOptions.InlineVTableStubs;
 30 import static org.graalvm.compiler.core.common.GraalOptions.OmitHotExceptionStacktrace;
 31 import static org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProviderImpl.OSR_MIGRATION_END;
 32 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_KLASS_LOCATION;
 33 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_MIRROR_HANDLE_LOCATION;
 34 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.CLASS_MIRROR_LOCATION;
 35 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.COMPRESSED_HUB_LOCATION;
 36 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.DISPLACED_MARK_WORD_LOCATION;
 37 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_LOCATION;
 38 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.HUB_WRITE_LOCATION;
 39 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.KLASS_LAYOUT_HELPER_LOCATION;
 40 import static org.graalvm.compiler.hotspot.replacements.HotSpotReplacementsUtil.OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION;
 41 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
 42 
 43 import java.util.EnumMap;
 44 
 45 import org.graalvm.compiler.api.directives.GraalDirectives;
 46 import org.graalvm.compiler.core.common.CompressEncoding;
 47 import org.graalvm.compiler.core.common.GraalOptions;
 48 import org.graalvm.compiler.core.common.spi.ForeignCallDescriptor;
 49 import org.graalvm.compiler.core.common.spi.ForeignCallsProvider;
 50 import org.graalvm.compiler.core.common.type.ObjectStamp;
 51 import org.graalvm.compiler.core.common.type.Stamp;
 52 import org.graalvm.compiler.core.common.type.StampFactory;
 53 import org.graalvm.compiler.core.common.type.StampPair;
 54 import org.graalvm.compiler.debug.DebugCloseable;
 55 import org.graalvm.compiler.debug.DebugHandlersFactory;
 56 import org.graalvm.compiler.debug.GraalError;
 57 import org.graalvm.compiler.graph.Node;
 58 import org.graalvm.compiler.graph.NodeInputList;
 59 import org.graalvm.compiler.hotspot.GraalHotSpotVMConfig;
 60 import org.graalvm.compiler.hotspot.HotSpotGraalRuntimeProvider;
 61 import org.graalvm.compiler.hotspot.nodes.BeginLockScopeNode;
 62 import org.graalvm.compiler.hotspot.nodes.HotSpotCompressionNode;
 63 import org.graalvm.compiler.hotspot.nodes.HotSpotDirectCallTargetNode;
 64 import org.graalvm.compiler.hotspot.nodes.HotSpotIndirectCallTargetNode;
 65 import org.graalvm.compiler.hotspot.nodes.KlassBeingInitializedCheckNode;
 66 import org.graalvm.compiler.hotspot.nodes.aot.InitializeKlassNode;
 67 import org.graalvm.compiler.hotspot.nodes.aot.ResolveConstantNode;
 68 import org.graalvm.compiler.hotspot.nodes.aot.ResolveDynamicConstantNode;
 69 import org.graalvm.compiler.hotspot.nodes.aot.ResolveMethodAndLoadCountersNode;
 70 import org.graalvm.compiler.hotspot.nodes.profiling.ProfileNode;
 71 import org.graalvm.compiler.hotspot.nodes.type.HotSpotNarrowOopStamp;
 72 import org.graalvm.compiler.hotspot.nodes.type.KlassPointerStamp;
 73 import org.graalvm.compiler.hotspot.nodes.type.MethodPointerStamp;
 74 import org.graalvm.compiler.hotspot.replacements.AssertionSnippets;
 75 import org.graalvm.compiler.hotspot.replacements.ClassGetHubNode;
 76 import org.graalvm.compiler.hotspot.replacements.FastNotifyNode;
 77 import org.graalvm.compiler.hotspot.replacements.HashCodeSnippets;
 78 import org.graalvm.compiler.hotspot.replacements.HotSpotAllocationSnippets;
 79 import org.graalvm.compiler.hotspot.replacements.HotSpotG1WriteBarrierSnippets;
 80 import org.graalvm.compiler.hotspot.replacements.HotSpotSerialWriteBarrierSnippets;
 81 import org.graalvm.compiler.hotspot.replacements.HubGetClassNode;
 82 import org.graalvm.compiler.hotspot.replacements.IdentityHashCodeNode;
 83 import org.graalvm.compiler.hotspot.replacements.InstanceOfSnippets;
 84 import org.graalvm.compiler.hotspot.replacements.KlassLayoutHelperNode;
 85 import org.graalvm.compiler.hotspot.replacements.LoadExceptionObjectSnippets;
 86 import org.graalvm.compiler.hotspot.replacements.MonitorSnippets;
 87 import org.graalvm.compiler.hotspot.replacements.ObjectCloneSnippets;
 88 import org.graalvm.compiler.hotspot.replacements.ObjectSnippets;
 89 import org.graalvm.compiler.hotspot.replacements.StringToBytesSnippets;
 90 import org.graalvm.compiler.hotspot.replacements.UnsafeCopyMemoryNode;
 91 import org.graalvm.compiler.hotspot.replacements.UnsafeSnippets;
 92 import org.graalvm.compiler.hotspot.replacements.aot.ResolveConstantSnippets;
 93 import org.graalvm.compiler.hotspot.replacements.arraycopy.HotSpotArraycopySnippets;
 94 import org.graalvm.compiler.hotspot.replacements.profiling.ProfileSnippets;
 95 import org.graalvm.compiler.hotspot.stubs.ForeignCallSnippets;
 96 import org.graalvm.compiler.hotspot.word.KlassPointer;
 97 import org.graalvm.compiler.nodes.AbstractBeginNode;
 98 import org.graalvm.compiler.nodes.AbstractDeoptimizeNode;
 99 import org.graalvm.compiler.nodes.CompressionNode.CompressionOp;
100 import org.graalvm.compiler.nodes.ComputeObjectAddressNode;
101 import org.graalvm.compiler.nodes.ConstantNode;
102 import org.graalvm.compiler.nodes.FixedNode;
103 import org.graalvm.compiler.nodes.GetObjectAddressNode;
104 import org.graalvm.compiler.nodes.Invoke;
105 import org.graalvm.compiler.nodes.LogicNode;
106 import org.graalvm.compiler.nodes.LoweredCallTargetNode;
107 import org.graalvm.compiler.nodes.NodeView;
108 import org.graalvm.compiler.nodes.ParameterNode;
109 import org.graalvm.compiler.nodes.SafepointNode;
110 import org.graalvm.compiler.nodes.StartNode;
111 import org.graalvm.compiler.nodes.StructuredGraph;
112 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
113 import org.graalvm.compiler.nodes.UnwindNode;
114 import org.graalvm.compiler.nodes.ValueNode;
115 import org.graalvm.compiler.nodes.calc.AddNode;
116 import org.graalvm.compiler.nodes.calc.FloatingNode;
117 import org.graalvm.compiler.nodes.calc.IntegerDivRemNode;
118 import org.graalvm.compiler.nodes.calc.IsNullNode;
119 import org.graalvm.compiler.nodes.calc.RemNode;
120 import org.graalvm.compiler.nodes.debug.StringToBytesNode;
121 import org.graalvm.compiler.nodes.debug.VerifyHeapNode;
122 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode;
123 import org.graalvm.compiler.nodes.extended.BytecodeExceptionNode.BytecodeExceptionKind;
124 import org.graalvm.compiler.nodes.extended.ForeignCallNode;
125 import org.graalvm.compiler.nodes.extended.GetClassNode;
126 import org.graalvm.compiler.nodes.extended.LoadHubNode;
127 import org.graalvm.compiler.nodes.extended.LoadMethodNode;
128 import org.graalvm.compiler.nodes.extended.OSRLocalNode;
129 import org.graalvm.compiler.nodes.extended.OSRLockNode;
130 import org.graalvm.compiler.nodes.extended.OSRMonitorEnterNode;
131 import org.graalvm.compiler.nodes.extended.OSRStartNode;
132 import org.graalvm.compiler.nodes.extended.StoreHubNode;
133 import org.graalvm.compiler.nodes.gc.G1ArrayRangePostWriteBarrier;
134 import org.graalvm.compiler.nodes.gc.G1ArrayRangePreWriteBarrier;
135 import org.graalvm.compiler.nodes.gc.G1PostWriteBarrier;
136 import org.graalvm.compiler.nodes.gc.G1PreWriteBarrier;
137 import org.graalvm.compiler.nodes.gc.G1ReferentFieldReadBarrier;
138 import org.graalvm.compiler.nodes.gc.SerialArrayRangeWriteBarrier;
139 import org.graalvm.compiler.nodes.gc.SerialWriteBarrier;
140 import org.graalvm.compiler.nodes.java.ClassIsAssignableFromNode;
141 import org.graalvm.compiler.nodes.java.DynamicNewArrayNode;
142 import org.graalvm.compiler.nodes.java.DynamicNewInstanceNode;
143 import org.graalvm.compiler.nodes.java.InstanceOfDynamicNode;
144 import org.graalvm.compiler.nodes.java.InstanceOfNode;
145 import org.graalvm.compiler.nodes.java.LoadExceptionObjectNode;
146 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
147 import org.graalvm.compiler.nodes.java.MonitorExitNode;
148 import org.graalvm.compiler.nodes.java.MonitorIdNode;
149 import org.graalvm.compiler.nodes.java.NewArrayNode;
150 import org.graalvm.compiler.nodes.java.NewInstanceNode;
151 import org.graalvm.compiler.nodes.java.NewMultiArrayNode;
152 import org.graalvm.compiler.nodes.java.RawMonitorEnterNode;
153 import org.graalvm.compiler.nodes.memory.FloatingReadNode;
154 import org.graalvm.compiler.nodes.memory.OnHeapMemoryAccess.BarrierType;
155 import org.graalvm.compiler.nodes.memory.ReadNode;
156 import org.graalvm.compiler.nodes.memory.WriteNode;
157 import org.graalvm.compiler.nodes.memory.address.AddressNode;
158 import org.graalvm.compiler.nodes.spi.LoweringProvider;
159 import org.graalvm.compiler.nodes.spi.LoweringTool;
160 import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;
161 import org.graalvm.compiler.nodes.spi.StampProvider;
162 import org.graalvm.compiler.nodes.type.StampTool;
163 import org.graalvm.compiler.nodes.util.GraphUtil;
164 import org.graalvm.compiler.options.OptionValues;
165 import org.graalvm.compiler.replacements.DefaultJavaLoweringProvider;
166 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyNode;
167 import org.graalvm.compiler.replacements.arraycopy.ArrayCopySnippets;
168 import org.graalvm.compiler.replacements.arraycopy.ArrayCopyWithDelayedLoweringNode;
169 import org.graalvm.compiler.replacements.nodes.AssertionNode;
170 import org.graalvm.compiler.serviceprovider.JavaVersionUtil;
171 import jdk.internal.vm.compiler.word.LocationIdentity;
172 
173 import jdk.vm.ci.code.TargetDescription;
174 import jdk.vm.ci.hotspot.HotSpotCallingConventionType;
175 import jdk.vm.ci.hotspot.HotSpotConstantReflectionProvider;
176 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
177 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
178 import jdk.vm.ci.meta.JavaConstant;
179 import jdk.vm.ci.meta.JavaKind;
180 import jdk.vm.ci.meta.JavaType;
181 import jdk.vm.ci.meta.MetaAccessProvider;
182 import jdk.vm.ci.meta.ResolvedJavaField;
183 import jdk.vm.ci.meta.ResolvedJavaType;
184 
185 /**
186  * HotSpot implementation of {@link LoweringProvider}.
187  */
188 public abstract class DefaultHotSpotLoweringProvider extends DefaultJavaLoweringProvider implements HotSpotLoweringProvider {
189 
190     protected final HotSpotGraalRuntimeProvider runtime;
191     protected final HotSpotRegistersProvider registers;
192     protected final HotSpotConstantReflectionProvider constantReflection;
193 
194     protected InstanceOfSnippets.Templates instanceofSnippets;
195     protected HotSpotAllocationSnippets.Templates allocationSnippets;
196     protected MonitorSnippets.Templates monitorSnippets;
197     protected HotSpotSerialWriteBarrierSnippets.Templates serialWriteBarrierSnippets;
198     protected HotSpotG1WriteBarrierSnippets.Templates g1WriteBarrierSnippets;
199     protected LoadExceptionObjectSnippets.Templates exceptionObjectSnippets;
200     protected AssertionSnippets.Templates assertionSnippets;
201     protected ArrayCopySnippets.Templates arraycopySnippets;
202     protected StringToBytesSnippets.Templates stringToBytesSnippets;
203     protected HashCodeSnippets.Templates hashCodeSnippets;
204     protected ResolveConstantSnippets.Templates resolveConstantSnippets;
205     protected ProfileSnippets.Templates profileSnippets;
206     protected ObjectSnippets.Templates objectSnippets;
207     protected UnsafeSnippets.Templates unsafeSnippets;
208     protected ObjectCloneSnippets.Templates objectCloneSnippets;
209     protected ForeignCallSnippets.Templates foreignCallSnippets;
210 
211     public DefaultHotSpotLoweringProvider(HotSpotGraalRuntimeProvider runtime, MetaAccessProvider metaAccess, ForeignCallsProvider foreignCalls, HotSpotRegistersProvider registers,
212                     HotSpotConstantReflectionProvider constantReflection, PlatformConfigurationProvider platformConfig, TargetDescription target) {
213         super(metaAccess, foreignCalls, platformConfig, target, runtime.getVMConfig().useCompressedOops);
214         this.runtime = runtime;
215         this.registers = registers;
216         this.constantReflection = constantReflection;
217 
218     }
219 
220     @Override
221     public void initialize(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, HotSpotProviders providers, GraalHotSpotVMConfig config) {
222         super.initialize(options, factories, runtime, providers, providers.getSnippetReflection());
223 
224         assert target == providers.getCodeCache().getTarget();
225         instanceofSnippets = new InstanceOfSnippets.Templates(options, factories, runtime, providers, target);
226         allocationSnippets = new HotSpotAllocationSnippets.Templates(options, factories, runtime, providers, target, config);
227         monitorSnippets = new MonitorSnippets.Templates(options, factories, runtime, providers, target, config.useFastLocking);
228         g1WriteBarrierSnippets = new HotSpotG1WriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
229         serialWriteBarrierSnippets = new HotSpotSerialWriteBarrierSnippets.Templates(options, factories, runtime, providers, target, config);
230         exceptionObjectSnippets = new LoadExceptionObjectSnippets.Templates(options, factories, providers, target);
231         assertionSnippets = new AssertionSnippets.Templates(options, factories, providers, target);
232         arraycopySnippets = new ArrayCopySnippets.Templates(new HotSpotArraycopySnippets(), options, factories, runtime, providers, providers.getSnippetReflection(), target);
233         stringToBytesSnippets = new StringToBytesSnippets.Templates(options, factories, providers, target);
234         hashCodeSnippets = new HashCodeSnippets.Templates(options, factories, providers, target);
235         resolveConstantSnippets = new ResolveConstantSnippets.Templates(options, factories, providers, target);
236         objectCloneSnippets = new ObjectCloneSnippets.Templates(options, factories, providers, target);
237         foreignCallSnippets = new ForeignCallSnippets.Templates(options, factories, providers, target);
238         objectSnippets = new ObjectSnippets.Templates(options, factories, providers, target);
239         unsafeSnippets = new UnsafeSnippets.Templates(options, factories, providers, target);
240         if (JavaVersionUtil.JAVA_SPEC &lt;= 8) {
241             // AOT only introduced in JDK 9
242             profileSnippets = null;
243         } else {
244             profileSnippets = new ProfileSnippets.Templates(options, factories, providers, target);
245         }
246     }
247 
248     public ArrayCopySnippets.Templates getArraycopySnippets() {
249         return arraycopySnippets;
250     }
251 
252     public MonitorSnippets.Templates getMonitorSnippets() {
253         return monitorSnippets;
254     }
255 
256     @Override
257     @SuppressWarnings(&quot;try&quot;)
258     public void lower(Node n, LoweringTool tool) {
259         StructuredGraph graph = (StructuredGraph) n.graph();
260         try (DebugCloseable context = n.withNodeSourcePosition()) {
261             if (n instanceof Invoke) {
262                 lowerInvoke((Invoke) n, tool, graph);
263             } else if (n instanceof LoadMethodNode) {
264                 lowerLoadMethodNode((LoadMethodNode) n);
265             } else if (n instanceof GetClassNode) {
266                 lowerGetClassNode((GetClassNode) n, tool, graph);
267             } else if (n instanceof StoreHubNode) {
268                 lowerStoreHubNode((StoreHubNode) n, graph);
269             } else if (n instanceof OSRStartNode) {
270                 lowerOSRStartNode((OSRStartNode) n);
271             } else if (n instanceof BytecodeExceptionNode) {
272                 lowerBytecodeExceptionNode((BytecodeExceptionNode) n);
273             } else if (n instanceof InstanceOfNode) {
274                 InstanceOfNode instanceOfNode = (InstanceOfNode) n;
275                 if (graph.getGuardsStage().areDeoptsFixed()) {
276                     instanceofSnippets.lower(instanceOfNode, tool);
277                 } else {
278                     if (instanceOfNode.allowsNull()) {
279                         ValueNode object = instanceOfNode.getValue();
280                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(InstanceOfNode.create(instanceOfNode.type(), object, instanceOfNode.profile(), instanceOfNode.getAnchor()));
281                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
282                         instanceOfNode.replaceAndDelete(newNode);
283                     }
284                 }
285             } else if (n instanceof InstanceOfDynamicNode) {
286                 InstanceOfDynamicNode instanceOfDynamicNode = (InstanceOfDynamicNode) n;
287                 if (graph.getGuardsStage().areDeoptsFixed()) {
288                     instanceofSnippets.lower(instanceOfDynamicNode, tool);
289                 } else {
290                     ValueNode mirror = instanceOfDynamicNode.getMirrorOrHub();
291                     if (mirror.stamp(NodeView.DEFAULT).getStackKind() == JavaKind.Object) {
292                         ClassGetHubNode classGetHub = graph.unique(new ClassGetHubNode(mirror));
293                         instanceOfDynamicNode.setMirror(classGetHub);
294                     }
295 
296                     if (instanceOfDynamicNode.allowsNull()) {
297                         ValueNode object = instanceOfDynamicNode.getObject();
298                         LogicNode newTypeCheck = graph.addOrUniqueWithInputs(
299                                         InstanceOfDynamicNode.create(graph.getAssumptions(), tool.getConstantReflection(), instanceOfDynamicNode.getMirrorOrHub(), object, false));
300                         LogicNode newNode = LogicNode.or(graph.unique(IsNullNode.create(object)), newTypeCheck, GraalDirectives.UNLIKELY_PROBABILITY);
301                         instanceOfDynamicNode.replaceAndDelete(newNode);
302                     }
303                 }
304             } else if (n instanceof ClassIsAssignableFromNode) {
305                 if (graph.getGuardsStage().areDeoptsFixed()) {
306                     instanceofSnippets.lower((ClassIsAssignableFromNode) n, tool);
307                 }
308             } else if (n instanceof NewInstanceNode) {
309                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
310                     allocationSnippets.lower((NewInstanceNode) n, tool);
311                 }
312             } else if (n instanceof DynamicNewInstanceNode) {
313                 DynamicNewInstanceNode newInstanceNode = (DynamicNewInstanceNode) n;
314                 if (newInstanceNode.getClassClass() == null) {
315                     JavaConstant classClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(Class.class));
316                     ConstantNode classClass = ConstantNode.forConstant(classClassMirror, tool.getMetaAccess(), graph);
317                     newInstanceNode.setClassClass(classClass);
318                 }
319                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
320                     allocationSnippets.lower(newInstanceNode, tool);
321                 }
322             } else if (n instanceof NewArrayNode) {
323                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
324                     allocationSnippets.lower((NewArrayNode) n, tool);
325                 }
326             } else if (n instanceof DynamicNewArrayNode) {
327                 DynamicNewArrayNode dynamicNewArrayNode = (DynamicNewArrayNode) n;
328                 if (dynamicNewArrayNode.getVoidClass() == null) {
329                     JavaConstant voidClassMirror = constantReflection.asJavaClass(metaAccess.lookupJavaType(void.class));
330                     ConstantNode voidClass = ConstantNode.forConstant(voidClassMirror, tool.getMetaAccess(), graph);
331                     dynamicNewArrayNode.setVoidClass(voidClass);
332                 }
333                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
334                     allocationSnippets.lower(dynamicNewArrayNode, tool);
335                 }
336             } else if (n instanceof VerifyHeapNode) {
337                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
338                     allocationSnippets.lower((VerifyHeapNode) n, tool);
339                 }
340             } else if (n instanceof RawMonitorEnterNode) {
341                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
342                     monitorSnippets.lower((RawMonitorEnterNode) n, registers, tool);
343                 }
344             } else if (n instanceof MonitorExitNode) {
345                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
346                     monitorSnippets.lower((MonitorExitNode) n, registers, tool);
347                 }
348             } else if (n instanceof ArrayCopyNode) {
349                 arraycopySnippets.lower((ArrayCopyNode) n, tool);
350             } else if (n instanceof ArrayCopyWithDelayedLoweringNode) {
351                 arraycopySnippets.lower((ArrayCopyWithDelayedLoweringNode) n, tool);
352             } else if (n instanceof G1PreWriteBarrier) {
353                 g1WriteBarrierSnippets.lower((G1PreWriteBarrier) n, tool);
354             } else if (n instanceof G1PostWriteBarrier) {
355                 g1WriteBarrierSnippets.lower((G1PostWriteBarrier) n, tool);
356             } else if (n instanceof G1ReferentFieldReadBarrier) {
357                 g1WriteBarrierSnippets.lower((G1ReferentFieldReadBarrier) n, tool);
358             } else if (n instanceof SerialWriteBarrier) {
359                 serialWriteBarrierSnippets.lower((SerialWriteBarrier) n, tool);
360             } else if (n instanceof SerialArrayRangeWriteBarrier) {
361                 serialWriteBarrierSnippets.lower((SerialArrayRangeWriteBarrier) n, tool);
362             } else if (n instanceof G1ArrayRangePreWriteBarrier) {
363                 g1WriteBarrierSnippets.lower((G1ArrayRangePreWriteBarrier) n, tool);
364             } else if (n instanceof G1ArrayRangePostWriteBarrier) {
365                 g1WriteBarrierSnippets.lower((G1ArrayRangePostWriteBarrier) n, tool);
366             } else if (n instanceof NewMultiArrayNode) {
367                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
368                     allocationSnippets.lower((NewMultiArrayNode) n, tool);
369                 }
370             } else if (n instanceof LoadExceptionObjectNode) {
371                 exceptionObjectSnippets.lower((LoadExceptionObjectNode) n, registers, tool);
372             } else if (n instanceof AssertionNode) {
373                 assertionSnippets.lower((AssertionNode) n, tool);
374             } else if (n instanceof StringToBytesNode) {
375                 if (graph.getGuardsStage().areDeoptsFixed()) {
376                     stringToBytesSnippets.lower((StringToBytesNode) n, tool);
377                 }
378             } else if (n instanceof IntegerDivRemNode) {
379                 // Nothing to do for division nodes. The HotSpot signal handler catches divisions by
380                 // zero and the MIN_VALUE / -1 cases.
381             } else if (n instanceof AbstractDeoptimizeNode || n instanceof UnwindNode || n instanceof RemNode || n instanceof SafepointNode) {
382                 /* No lowering, we generate LIR directly for these nodes. */
383             } else if (n instanceof ClassGetHubNode) {
384                 lowerClassGetHubNode((ClassGetHubNode) n, tool);
385             } else if (n instanceof HubGetClassNode) {
386                 lowerHubGetClassNode((HubGetClassNode) n, tool);
387             } else if (n instanceof KlassLayoutHelperNode) {
388                 lowerKlassLayoutHelperNode((KlassLayoutHelperNode) n, tool);
389             } else if (n instanceof ComputeObjectAddressNode) {
390                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
391                     lowerComputeObjectAddressNode((ComputeObjectAddressNode) n);
392                 }
393             } else if (n instanceof IdentityHashCodeNode) {
394                 hashCodeSnippets.lower((IdentityHashCodeNode) n, tool);
395             } else if (n instanceof ResolveDynamicConstantNode) {
396                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
397                     resolveConstantSnippets.lower((ResolveDynamicConstantNode) n, tool);
398                 }
399             } else if (n instanceof ResolveConstantNode) {
400                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
401                     resolveConstantSnippets.lower((ResolveConstantNode) n, tool);
402                 }
403             } else if (n instanceof ResolveMethodAndLoadCountersNode) {
404                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
405                     resolveConstantSnippets.lower((ResolveMethodAndLoadCountersNode) n, tool);
406                 }
407             } else if (n instanceof InitializeKlassNode) {
408                 if (graph.getGuardsStage().areFrameStatesAtDeopts()) {
409                     resolveConstantSnippets.lower((InitializeKlassNode) n, tool);
410                 }
411             } else if (n instanceof ProfileNode) {
412                 profileSnippets.lower((ProfileNode) n, tool);
413             } else if (n instanceof KlassBeingInitializedCheckNode) {
414                 allocationSnippets.lower((KlassBeingInitializedCheckNode) n, tool);
415             } else if (n instanceof FastNotifyNode) {
416                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
417                     objectSnippets.lower(n, tool);
418                 }
419             } else if (n instanceof UnsafeCopyMemoryNode) {
420                 if (graph.getGuardsStage() == GuardsStage.AFTER_FSA) {
421                     unsafeSnippets.lower((UnsafeCopyMemoryNode) n, tool);
422                 }
423             } else {
424                 super.lower(n, tool);
425             }
426         }
427 
428     }
429 
430     private static void lowerComputeObjectAddressNode(ComputeObjectAddressNode n) {
431         /*
432          * Lower the node into a ComputeObjectAddress node and an Add but ensure that it&#39;s below any
433          * potential safepoints and above it&#39;s uses.
434          */
435         for (Node use : n.usages().snapshot()) {
436             if (use instanceof FixedNode) {
437                 FixedNode fixed = (FixedNode) use;
438                 StructuredGraph graph = n.graph();
439                 GetObjectAddressNode address = graph.add(new GetObjectAddressNode(n.getObject()));
440                 graph.addBeforeFixed(fixed, address);
441                 AddNode add = graph.addOrUnique(new AddNode(address, n.getOffset()));
442                 use.replaceFirstInput(n, add);
443             } else {
444                 throw GraalError.shouldNotReachHere(&quot;Unexpected floating use of ComputeObjectAddressNode &quot; + n);
445             }
446         }
447         GraphUtil.unlinkFixedNode(n);
448         n.safeDelete();
449     }
450 
451     private void lowerKlassLayoutHelperNode(KlassLayoutHelperNode n, LoweringTool tool) {
452         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
453             return;
454         }
455         StructuredGraph graph = n.graph();
456         assert !n.getHub().isConstant();
457         AddressNode address = createOffsetAddress(graph, n.getHub(), runtime.getVMConfig().klassLayoutHelperOffset);
458         n.replaceAtUsagesAndDelete(graph.unique(new FloatingReadNode(address, KLASS_LAYOUT_HELPER_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE)));
459     }
460 
461     private void lowerHubGetClassNode(HubGetClassNode n, LoweringTool tool) {
462         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
463             return;
464         }
465 
466         ValueNode hub = n.getHub();
467         GraalHotSpotVMConfig vmConfig = runtime.getVMConfig();
468         StructuredGraph graph = n.graph();
469         assert !hub.isConstant() || GraalOptions.ImmutableCode.getValue(graph.getOptions());
470         AddressNode mirrorAddress = createOffsetAddress(graph, hub, vmConfig.classMirrorOffset);
471         FloatingReadNode read = graph.unique(
472                         new FloatingReadNode(mirrorAddress, CLASS_MIRROR_LOCATION, null, vmConfig.classMirrorIsHandle ? StampFactory.forKind(target.wordJavaKind) : n.stamp(NodeView.DEFAULT),
473                                         null, BarrierType.NONE));
474         if (vmConfig.classMirrorIsHandle) {
475             AddressNode address = createOffsetAddress(graph, read, 0);
476             read = graph.unique(new FloatingReadNode(address, CLASS_MIRROR_HANDLE_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
477         }
478         n.replaceAtUsagesAndDelete(read);
479     }
480 
481     private void lowerClassGetHubNode(ClassGetHubNode n, LoweringTool tool) {
482         if (tool.getLoweringStage() == LoweringTool.StandardLoweringStage.HIGH_TIER) {
483             return;
484         }
485 
486         StructuredGraph graph = n.graph();
487         assert !n.getValue().isConstant();
488         AddressNode address = createOffsetAddress(graph, n.getValue(), runtime.getVMConfig().klassOffset);
489         FloatingReadNode read = graph.unique(new FloatingReadNode(address, CLASS_KLASS_LOCATION, null, n.stamp(NodeView.DEFAULT), null, BarrierType.NONE));
490         n.replaceAtUsagesAndDelete(read);
491     }
492 
493     private void lowerInvoke(Invoke invoke, LoweringTool tool, StructuredGraph graph) {
494         if (invoke.callTarget() instanceof MethodCallTargetNode) {
495             MethodCallTargetNode callTarget = (MethodCallTargetNode) invoke.callTarget();
496             NodeInputList&lt;ValueNode&gt; parameters = callTarget.arguments();
497             ValueNode receiver = parameters.isEmpty() ? null : parameters.get(0);
498 
499             if (!callTarget.isStatic()) {
500                 assert receiver != null : &quot;non-static call must have a receiver&quot;;
501                 if (receiver.stamp(NodeView.DEFAULT) instanceof ObjectStamp &amp;&amp; !StampTool.isPointerNonNull(receiver)) {
502                     ValueNode nonNullReceiver = createNullCheckedValue(receiver, invoke.asNode(), tool);
503                     parameters.set(0, nonNullReceiver);
504                     receiver = nonNullReceiver;
505                 }
506             }
507             JavaType[] signature = callTarget.targetMethod().getSignature().toParameterTypes(callTarget.isStatic() ? null : callTarget.targetMethod().getDeclaringClass());
508 
509             LoweredCallTargetNode loweredCallTarget = null;
510             OptionValues options = graph.getOptions();
511             if (InlineVTableStubs.getValue(options) &amp;&amp; callTarget.invokeKind().isIndirect() &amp;&amp; (AlwaysInlineVTableStubs.getValue(options) || invoke.isPolymorphic())) {
512                 HotSpotResolvedJavaMethod hsMethod = (HotSpotResolvedJavaMethod) callTarget.targetMethod();
513                 ResolvedJavaType receiverType = invoke.getReceiverType();
514                 if (hsMethod.isInVirtualMethodTable(receiverType)) {
515                     JavaKind wordKind = runtime.getTarget().wordJavaKind;
516                     ValueNode hub = createReadHub(graph, receiver, tool);
517 
518                     ReadNode metaspaceMethod = createReadVirtualMethod(graph, hub, hsMethod, receiverType);
519                     // We use LocationNode.ANY_LOCATION for the reads that access the
520                     // compiled code entry as HotSpot does not guarantee they are final
521                     // values.
522                     int methodCompiledEntryOffset = runtime.getVMConfig().methodCompiledEntryOffset;
523                     AddressNode address = createOffsetAddress(graph, metaspaceMethod, methodCompiledEntryOffset);
524                     ReadNode compiledEntry = graph.add(new ReadNode(address, any(), StampFactory.forKind(wordKind), BarrierType.NONE));
525 
526                     loweredCallTarget = graph.add(new HotSpotIndirectCallTargetNode(metaspaceMethod, compiledEntry, parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),
527                                     signature, callTarget.targetMethod(),
528                                     HotSpotCallingConventionType.JavaCall, callTarget.invokeKind()));
529 
530                     graph.addBeforeFixed(invoke.asNode(), metaspaceMethod);
531                     graph.addAfterFixed(metaspaceMethod, compiledEntry);
532                 }
533             }
534 
535             if (loweredCallTarget == null) {
536                 loweredCallTarget = graph.add(new HotSpotDirectCallTargetNode(parameters.toArray(new ValueNode[parameters.size()]), callTarget.returnStamp(),
537                                 signature, callTarget.targetMethod(),
538                                 HotSpotCallingConventionType.JavaCall,
539                                 callTarget.invokeKind()));
540             }
541             callTarget.replaceAndDelete(loweredCallTarget);
542         }
543     }
544 
545     private CompressEncoding getOopEncoding() {
546         return runtime.getVMConfig().getOopEncoding();
547     }
548 
549     @Override
550     protected Stamp loadCompressedStamp(ObjectStamp stamp) {
551         return HotSpotNarrowOopStamp.compressed(stamp, getOopEncoding());
552     }
553 
554     @Override
555     protected ValueNode newCompressionNode(CompressionOp op, ValueNode value) {
556         return new HotSpotCompressionNode(op, value, getOopEncoding());
557     }
558 
559     @Override
560     public ValueNode staticFieldBase(StructuredGraph graph, ResolvedJavaField f) {
561         HotSpotResolvedJavaField field = (HotSpotResolvedJavaField) f;
562         JavaConstant base = constantReflection.asJavaClass(field.getDeclaringClass());
563         return ConstantNode.forConstant(base, metaAccess, graph);
564     }
565 
566     @Override
567     protected ValueNode createReadArrayComponentHub(StructuredGraph graph, ValueNode arrayHub, FixedNode anchor) {
568         /*
569          * Anchor the read of the element klass to the cfg, because it is only valid when arrayClass
570          * is an object class, which might not be the case in other parts of the compiled method.
571          */
572         AddressNode address = createOffsetAddress(graph, arrayHub, runtime.getVMConfig().arrayClassElementOffset);
573         return graph.unique(new FloatingReadNode(address, OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION, null, KlassPointerStamp.klassNonNull(), AbstractBeginNode.prevBegin(anchor)));
574     }
575 
576     private void lowerLoadMethodNode(LoadMethodNode loadMethodNode) {
577         StructuredGraph graph = loadMethodNode.graph();
578         HotSpotResolvedJavaMethod method = (HotSpotResolvedJavaMethod) loadMethodNode.getMethod();
579         ReadNode metaspaceMethod = createReadVirtualMethod(graph, loadMethodNode.getHub(), method, loadMethodNode.getReceiverType());
580         graph.replaceFixed(loadMethodNode, metaspaceMethod);
581     }
582 
583     private static void lowerGetClassNode(GetClassNode getClass, LoweringTool tool, StructuredGraph graph) {
584         StampProvider stampProvider = tool.getStampProvider();
585         LoadHubNode hub = graph.unique(new LoadHubNode(stampProvider, getClass.getObject()));
586         HubGetClassNode hubGetClass = graph.unique(new HubGetClassNode(tool.getMetaAccess(), hub));
587         getClass.replaceAtUsagesAndDelete(hubGetClass);
588         hub.lower(tool);
589         hubGetClass.lower(tool);
590     }
591 
592     private void lowerStoreHubNode(StoreHubNode storeHub, StructuredGraph graph) {
593         WriteNode hub = createWriteHub(graph, storeHub.getObject(), storeHub.getValue());
594         graph.replaceFixed(storeHub, hub);
595     }
596 
597     private void lowerOSRStartNode(OSRStartNode osrStart) {
598         StructuredGraph graph = osrStart.graph();
599         if (graph.getGuardsStage() == StructuredGraph.GuardsStage.FIXED_DEOPTS) {
600             StartNode newStart = graph.add(new StartNode());
601             ParameterNode buffer = graph.addWithoutUnique(new ParameterNode(0, StampPair.createSingle(StampFactory.forKind(runtime.getTarget().wordJavaKind))));
602             ForeignCallNode migrationEnd = graph.add(new ForeignCallNode(foreignCalls, OSR_MIGRATION_END, buffer));
603             migrationEnd.setStateAfter(osrStart.stateAfter());
604             newStart.setNext(migrationEnd);
605             FixedNode next = osrStart.next();
606             osrStart.setNext(null);
607             migrationEnd.setNext(next);
608             graph.setStart(newStart);
609 
610             final int wordSize = target.wordSize;
611 
612             // @formatter:off
613             // taken from c2 locals_addr = osr_buf + (max_locals-1)*wordSize)
614             // @formatter:on
615             int localsOffset = (graph.method().getMaxLocals() - 1) * wordSize;
616             for (OSRLocalNode osrLocal : graph.getNodes(OSRLocalNode.TYPE)) {
617                 int size = osrLocal.getStackKind().getSlotCount();
618                 int offset = localsOffset - (osrLocal.index() + size - 1) * wordSize;
619                 AddressNode address = createOffsetAddress(graph, buffer, offset);
620                 ReadNode load = graph.add(new ReadNode(address, any(), osrLocal.stamp(NodeView.DEFAULT), BarrierType.NONE));
621                 osrLocal.replaceAndDelete(load);
622                 graph.addBeforeFixed(migrationEnd, load);
623             }
624 
625             // @formatter:off
626             // taken from c2 monitors_addr = osr_buf + (max_locals+mcnt*2-1)*wordSize);
627             // @formatter:on
628             final int lockCount = osrStart.stateAfter().locksSize();
629             final int locksOffset = (graph.method().getMaxLocals() + lockCount * 2 - 1) * wordSize;
630 
631             // first initialize the lock slots for all enters with the displaced marks read from the
632             // buffer
633             for (OSRMonitorEnterNode osrMonitorEnter : graph.getNodes(OSRMonitorEnterNode.TYPE)) {
634                 MonitorIdNode monitorID = osrMonitorEnter.getMonitorId();
635                 OSRLockNode lock = (OSRLockNode) osrMonitorEnter.object();
636                 final int index = lock.index();
637 
638                 final int offsetDisplacedHeader = locksOffset - ((index * 2) + 1) * wordSize;
639                 final int offsetLockObject = locksOffset - index * 2 * wordSize;
640 
641                 // load the displaced mark from the osr buffer
642                 AddressNode addressDisplacedHeader = createOffsetAddress(graph, buffer, offsetDisplacedHeader);
643                 ReadNode loadDisplacedHeader = graph.add(new ReadNode(addressDisplacedHeader, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
644                 graph.addBeforeFixed(migrationEnd, loadDisplacedHeader);
645 
646                 // we need to initialize the stack slot for the lock
647                 BeginLockScopeNode beginLockScope = graph.add(new BeginLockScopeNode(lock.getStackKind(), monitorID.getLockDepth()));
648                 graph.addBeforeFixed(migrationEnd, beginLockScope);
649 
650                 // write the displaced mark to the correct stack slot
651                 AddressNode addressDisplacedMark = createOffsetAddress(graph, beginLockScope, runtime.getVMConfig().basicLockDisplacedHeaderOffset);
652                 WriteNode writeStackSlot = graph.add(new WriteNode(addressDisplacedMark, DISPLACED_MARK_WORD_LOCATION, loadDisplacedHeader, BarrierType.NONE, false));
653                 graph.addBeforeFixed(migrationEnd, writeStackSlot);
654 
655                 // load the lock object from the osr buffer
656                 AddressNode addressLockObject = createOffsetAddress(graph, buffer, offsetLockObject);
657                 ReadNode loadObject = graph.add(new ReadNode(addressLockObject, any(), lock.stamp(NodeView.DEFAULT), BarrierType.NONE));
658                 lock.replaceAndDelete(loadObject);
659                 graph.addBeforeFixed(migrationEnd, loadObject);
660             }
661 
662             osrStart.replaceAtUsagesAndDelete(newStart);
663         }
664     }
665 
666     static final class Exceptions {
667         protected static final EnumMap&lt;BytecodeExceptionKind, RuntimeException&gt; cachedExceptions;
668 
669         static {
670             cachedExceptions = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
671             cachedExceptions.put(BytecodeExceptionKind.NULL_POINTER, clearStackTrace(new NullPointerException()));
672             cachedExceptions.put(BytecodeExceptionKind.OUT_OF_BOUNDS, clearStackTrace(new ArrayIndexOutOfBoundsException()));
673             cachedExceptions.put(BytecodeExceptionKind.CLASS_CAST, clearStackTrace(new ClassCastException()));
674             cachedExceptions.put(BytecodeExceptionKind.ARRAY_STORE, clearStackTrace(new ArrayStoreException()));
675             cachedExceptions.put(BytecodeExceptionKind.DIVISION_BY_ZERO, clearStackTrace(new ArithmeticException()));
676         }
677 
678         private static RuntimeException clearStackTrace(RuntimeException ex) {
679             ex.setStackTrace(new StackTraceElement[0]);
680             return ex;
681         }
682     }
683 
684     public static final class RuntimeCalls {
685         public static final EnumMap&lt;BytecodeExceptionKind, ForeignCallDescriptor&gt; runtimeCalls;
686 
687         static {
688             runtimeCalls = new EnumMap&lt;&gt;(BytecodeExceptionKind.class);
689             runtimeCalls.put(BytecodeExceptionKind.ARRAY_STORE, new ForeignCallDescriptor(&quot;createArrayStoreException&quot;, ArrayStoreException.class, Object.class));
690             runtimeCalls.put(BytecodeExceptionKind.CLASS_CAST, new ForeignCallDescriptor(&quot;createClassCastException&quot;, ClassCastException.class, Object.class, KlassPointer.class));
691             runtimeCalls.put(BytecodeExceptionKind.NULL_POINTER, new ForeignCallDescriptor(&quot;createNullPointerException&quot;, NullPointerException.class));
692             runtimeCalls.put(BytecodeExceptionKind.OUT_OF_BOUNDS, new ForeignCallDescriptor(&quot;createOutOfBoundsException&quot;, ArrayIndexOutOfBoundsException.class, int.class, int.class));
693             runtimeCalls.put(BytecodeExceptionKind.DIVISION_BY_ZERO, new ForeignCallDescriptor(&quot;createDivisionByZeroException&quot;, ArithmeticException.class));
694             runtimeCalls.put(BytecodeExceptionKind.INTEGER_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createIntegerExactOverflowException&quot;, ArithmeticException.class));
695             runtimeCalls.put(BytecodeExceptionKind.LONG_EXACT_OVERFLOW, new ForeignCallDescriptor(&quot;createLongExactOverflowException&quot;, ArithmeticException.class));
696         }
697     }
698 
699     private void throwCachedException(BytecodeExceptionNode node) {
700         if (IS_IN_NATIVE_IMAGE) {
701             throw new InternalError(&quot;Can&#39;t throw exception from SVM object&quot;);
702         }
703         Throwable exception = Exceptions.cachedExceptions.get(node.getExceptionKind());
704         assert exception != null;
705 
706         StructuredGraph graph = node.graph();
707         FloatingNode exceptionNode = ConstantNode.forConstant(constantReflection.forObject(exception), metaAccess, graph);
708         graph.replaceFixedWithFloating(node, exceptionNode);
709     }
710 
711     private void lowerBytecodeExceptionNode(BytecodeExceptionNode node) {
712         if (OmitHotExceptionStacktrace.getValue(node.getOptions())) {
713             throwCachedException(node);
714             return;
715         }
716 
717         ForeignCallDescriptor descriptor = RuntimeCalls.runtimeCalls.get(node.getExceptionKind());
718         assert descriptor != null;
719 
720         StructuredGraph graph = node.graph();
721         ForeignCallNode foreignCallNode = graph.add(new ForeignCallNode(foreignCalls, descriptor, node.stamp(NodeView.DEFAULT), node.getArguments()));
722         /*
723          * The original BytecodeExceptionNode has a rethrowException FrameState which isn&#39;t suitable
724          * for deopt because the exception to be thrown come from this call so it&#39;s not available in
725          * the debug info. The foreign call needs a stateDuring instead so it can deopt with a
726          * pending exception.
727          */
728         foreignCallNode.setStateAfter(node.createStateDuring());
729         graph.replaceFixedWithFixed(node, foreignCallNode);
730     }
731 
732     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, HotSpotResolvedJavaMethod method, ResolvedJavaType receiverType) {
733         return createReadVirtualMethod(graph, hub, method.vtableEntryOffset(receiverType));
734     }
735 
736     private ReadNode createReadVirtualMethod(StructuredGraph graph, ValueNode hub, int vtableEntryOffset) {
737         assert vtableEntryOffset &gt; 0;
738         // We use LocationNode.ANY_LOCATION for the reads that access the vtable
739         // entry as HotSpot does not guarantee that this is a final value.
740         Stamp methodStamp = MethodPointerStamp.methodNonNull();
741         AddressNode address = createOffsetAddress(graph, hub, vtableEntryOffset);
742         ReadNode metaspaceMethod = graph.add(new ReadNode(address, any(), methodStamp, BarrierType.NONE));
743         return metaspaceMethod;
744     }
745 
746     @Override
747     protected ValueNode createReadHub(StructuredGraph graph, ValueNode object, LoweringTool tool) {
748         if (tool.getLoweringStage() != LoweringTool.StandardLoweringStage.LOW_TIER) {
749             return graph.unique(new LoadHubNode(tool.getStampProvider(), object));
750         }
751         assert !object.isConstant() || object.isNullConstant();
752 
753         KlassPointerStamp hubStamp = KlassPointerStamp.klassNonNull();
754         if (runtime.getVMConfig().useCompressedClassPointers) {
755             hubStamp = hubStamp.compressed(runtime.getVMConfig().getKlassEncoding());
756         }
757 
758         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
759         LocationIdentity hubLocation = runtime.getVMConfig().useCompressedClassPointers ? COMPRESSED_HUB_LOCATION : HUB_LOCATION;
760         FloatingReadNode memoryRead = graph.unique(new FloatingReadNode(address, hubLocation, null, hubStamp, null, BarrierType.NONE));
761         if (runtime.getVMConfig().useCompressedClassPointers) {
762             return HotSpotCompressionNode.uncompress(memoryRead, runtime.getVMConfig().getKlassEncoding());
763         } else {
764             return memoryRead;
765         }
766     }
767 
768     private WriteNode createWriteHub(StructuredGraph graph, ValueNode object, ValueNode value) {
769         assert !object.isConstant() || object.asConstant().isDefaultForKind();
770 
771         ValueNode writeValue = value;
772         if (runtime.getVMConfig().useCompressedClassPointers) {
773             writeValue = HotSpotCompressionNode.compress(value, runtime.getVMConfig().getKlassEncoding());
774         }
775 
776         AddressNode address = createOffsetAddress(graph, object, runtime.getVMConfig().hubOffset);
777         return graph.add(new WriteNode(address, HUB_WRITE_LOCATION, writeValue, BarrierType.NONE, false));
778     }
779 
780     @Override
781     public int fieldOffset(ResolvedJavaField f) {
782         return f.getOffset();
783     }
784 
785     @Override
786     public int arrayLengthOffset() {
787         return runtime.getVMConfig().arrayOopDescLengthOffset();
788     }
789 
790     @Override
791     public final JavaKind getStorageKind(ResolvedJavaField field) {
792         return field.getJavaKind();
793     }
794 
795     @Override
796     public ObjectCloneSnippets.Templates getObjectCloneSnippets() {
797         return objectCloneSnippets;
798     }
799 
800     @Override
801     public ForeignCallSnippets.Templates getForeignCallSnippets() {
802         return foreignCallSnippets;
803     }
804 }
    </pre>
  </body>
</html>
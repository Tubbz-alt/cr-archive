<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
  32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
  33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collections;
  38 import java.util.HashMap;
  39 import java.util.HashSet;
  40 import java.util.List;
  41 import java.util.Map;
  42 import java.util.Objects;
  43 import java.util.Set;
  44 import java.util.concurrent.ConcurrentHashMap;
  45 
  46 import org.graalvm.compiler.api.replacements.Fold;
  47 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  48 import org.graalvm.compiler.api.replacements.Snippet;
  49 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  50 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  51 import org.graalvm.compiler.api.runtime.GraalRuntime;
  52 import org.graalvm.compiler.bytecode.BytecodeProvider;
  53 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  54 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  55 import org.graalvm.compiler.core.common.type.Stamp;
  56 import org.graalvm.compiler.core.common.type.StampPair;
  57 import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  58 import org.graalvm.compiler.debug.DebugContext;
  59 import org.graalvm.compiler.debug.GraalError;
  60 import org.graalvm.compiler.graph.Node;
  61 import org.graalvm.compiler.graph.NodeClass;
  62 import org.graalvm.compiler.graph.NodeMap;
  63 import org.graalvm.compiler.graph.NodeSourcePosition;
  64 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  65 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
  66 import org.graalvm.compiler.java.BytecodeParser;
  67 import org.graalvm.compiler.java.GraphBuilderPhase;
  68 import org.graalvm.compiler.nodeinfo.Verbosity;
  69 import org.graalvm.compiler.nodes.CallTargetNode;
  70 import org.graalvm.compiler.nodes.Cancellable;
  71 import org.graalvm.compiler.nodes.ConstantNode;
  72 import org.graalvm.compiler.nodes.EncodedGraph;
  73 import org.graalvm.compiler.nodes.FrameState;
  74 import org.graalvm.compiler.nodes.FullInfopointNode;
  75 import org.graalvm.compiler.nodes.GraphEncoder;
  76 import org.graalvm.compiler.nodes.ParameterNode;
  77 import org.graalvm.compiler.nodes.ProxyNode;
  78 import org.graalvm.compiler.nodes.StructuredGraph;
  79 import org.graalvm.compiler.nodes.ValueNode;
  80 import org.graalvm.compiler.nodes.cfg.Block;
  81 import org.graalvm.compiler.nodes.graphbuilderconf.GeneratedInvocationPlugin;
  82 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;
  83 import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;
  84 import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;
  85 import org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext;
  86 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugin;
  87 import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;
  88 import org.graalvm.compiler.nodes.graphbuilderconf.MethodSubstitutionPlugin;
  89 import org.graalvm.compiler.nodes.graphbuilderconf.NodePlugin;
  90 import org.graalvm.compiler.nodes.graphbuilderconf.ParameterPlugin;
  91 import org.graalvm.compiler.nodes.java.AccessFieldNode;
  92 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
  93 import org.graalvm.compiler.nodes.virtual.VirtualObjectNode;
  94 import org.graalvm.compiler.options.OptionValues;
  95 import org.graalvm.compiler.phases.OptimisticOptimizations;
  96 import org.graalvm.compiler.phases.schedule.SchedulePhase;
  97 import org.graalvm.compiler.phases.util.Providers;
  98 import org.graalvm.compiler.replacements.ConstantBindingParameterPlugin;
  99 import org.graalvm.compiler.replacements.PEGraphDecoder;
 100 import org.graalvm.compiler.replacements.ReplacementsImpl;
 101 import org.graalvm.compiler.replacements.SnippetCounter;
 102 import org.graalvm.compiler.replacements.SnippetIntegerHistogram;
 103 
 104 import jdk.vm.ci.code.TargetDescription;
 105 import jdk.vm.ci.hotspot.HotSpotJVMCIRuntime;
 106 import jdk.vm.ci.hotspot.HotSpotResolvedJavaField;
 107 import jdk.vm.ci.hotspot.HotSpotResolvedJavaMethod;
 108 import jdk.vm.ci.hotspot.HotSpotResolvedJavaType;
 109 import jdk.vm.ci.hotspot.HotSpotSignature;
 110 import jdk.vm.ci.meta.Constant;
 111 import jdk.vm.ci.meta.ConstantReflectionProvider;
 112 import jdk.vm.ci.meta.JavaConstant;
 113 import jdk.vm.ci.meta.JavaKind;
 114 import jdk.vm.ci.meta.MemoryAccessProvider;
 115 import jdk.vm.ci.meta.MethodHandleAccessProvider;
 116 import jdk.vm.ci.meta.ResolvedJavaField;
 117 import jdk.vm.ci.meta.ResolvedJavaMethod;
 118 import jdk.vm.ci.meta.ResolvedJavaType;
 119 import jdk.vm.ci.meta.UnresolvedJavaField;
 120 import jdk.vm.ci.meta.UnresolvedJavaMethod;
 121 import jdk.vm.ci.meta.UnresolvedJavaType;
 122 
 123 /**
 124  * This class performs graph encoding using {@link GraphEncoder} but also converts JVMCI type and
 125  * method references into a symbolic form that can be resolved at graph decode time using
 126  * {@link SymbolicJVMCIReference}.
 127  */
 128 public class SymbolicSnippetEncoder {
 129 
 130     /**
 131      * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
 132      * substitutions for graph encoding.
 133      */
 134     private final HotSpotSnippetReplacementsImpl snippetReplacements;
 135 
 136     /**
 137      * The set of all snippet methods that have been encoded.
 138      */
 139     private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
 140 
 141     /**
 142      * A mapping from the method substitution method to the original method name. The string key and
 143      * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
 144      */
 145     private final Map&lt;String, String&gt; originalMethods = new ConcurrentHashMap&lt;&gt;();
 146 
 147     private final HotSpotReplacementsImpl originalReplacements;
 148 
 149     /**
 150      * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
 151      * encoding.
 152      */
 153     private int encodedGraphs = 0;
 154 
 155     /**
 156      * All the graphs parsed so far.
 157      */
 158     private Map&lt;String, StructuredGraph&gt; preparedSnippetGraphs = new HashMap&lt;&gt;();
 159 
 160     private Set&lt;MethodSubstitutionPlugin&gt; knownPlugins = new HashSet&lt;&gt;();
 161 
 162     private Set&lt;InvocationPlugin&gt; conditionalPlugins = new HashSet&lt;&gt;();
 163 
 164     private int preparedPlugins = 0;
 165 
 166     /**
 167      * The invocation plugins which were delayed during graph preparation.
 168      */
 169     private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
 170 
 171     void addDelayedInvocationPluginMethod(ResolvedJavaMethod method) {
 172         delayedInvocationPluginMethods.add(method);
 173     }
 174 
 175     Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
 176         return snippetMethods;
 177     }
 178 
 179     protected class SnippetInlineInvokePlugin implements InlineInvokePlugin {
 180 
 181         @Override
 182         public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
 183             if (method.getAnnotation(Fold.class) != null) {
 184                 delayedInvocationPluginMethods.add(method);
 185                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 186             }
 187 
 188             if (snippetReplacements.getIntrinsifyingPlugin(method) != null) {
 189                 delayedInvocationPluginMethods.add(method);
 190                 return InlineInfo.DO_NOT_INLINE_NO_EXCEPTION;
 191             }
 192 
 193             // Force inlining when parsing replacements
 194             return createIntrinsicInlineInfo(method, snippetReplacements.getDefaultReplacementBytecodeProvider());
 195         }
 196 
 197         @Override
 198         public void notifyAfterInline(ResolvedJavaMethod methodToInline) {
 199             assert methodToInline.getAnnotation(Fold.class) == null : methodToInline;
 200         }
 201     }
 202 
 203     public static class SnippetInvocationPlugins extends InvocationPlugins {
 204 
 205         SnippetInvocationPlugins(InvocationPlugins invocationPlugins) {
 206             super(invocationPlugins);
 207         }
 208 
 209         @Override
 210         public InvocationPlugin lookupInvocation(ResolvedJavaMethod method) {
 211             if (method.getAnnotation(Fold.class) != null) {
 212                 return null;
 213             }
 214             return super.lookupInvocation(method);
 215         }
 216     }
 217 
 218     /**
 219      * This plugin disables the snippet counter machinery.
 220      */
 221     private class SnippetCounterPlugin implements NodePlugin {
 222         String snippetCounterName = &#39;L&#39; + SnippetCounter.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 223         String snippetIntegerHistogramName = &#39;L&#39; + SnippetIntegerHistogram.class.getName().replace(&#39;.&#39;, &#39;/&#39;) + &#39;;&#39;;
 224 
 225         @Override
 226         public boolean handleLoadField(GraphBuilderContext b, ValueNode object, ResolvedJavaField field) {
 227             if (field.getName().equals(&quot;group&quot;) &amp;&amp; field.getDeclaringClass().getName().equals(snippetCounterName)) {
 228                 b.addPush(JavaKind.Object, ConstantNode.forConstant(JavaConstant.NULL_POINTER, b.getMetaAccess()));
 229                 return true;
 230             }
 231             if (field.getType().getName().equals(snippetCounterName)) {
 232                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetCounter.DISABLED_COUNTER), b.getMetaAccess()));
 233                 return true;
 234             }
 235 
 236             if (field.getType().getName().equals(snippetIntegerHistogramName)) {
 237                 b.addPush(JavaKind.Object, ConstantNode.forConstant(snippetReplacements.snippetReflection.forObject(SnippetIntegerHistogram.DISABLED_COUNTER), b.getMetaAccess()));
 238                 return true;
 239             }
 240             return false;
 241         }
 242     }
 243 
 244     /**
 245      * Generate a String name for a method including all type information. Used as a symbolic key
 246      * for lookup.
 247      */
 248     private static String methodKey(ResolvedJavaMethod method) {
 249         return method.format(&quot;%H.%n(%P)&quot;);
 250     }
 251 
 252     SymbolicSnippetEncoder(HotSpotReplacementsImpl replacements) {
 253         this.originalReplacements = replacements;
 254         GraphBuilderConfiguration.Plugins plugins = replacements.getGraphBuilderPlugins();
 255         SnippetInvocationPlugins invocationPlugins = new SnippetInvocationPlugins(plugins.getInvocationPlugins());
 256         GraphBuilderConfiguration.Plugins copy = new GraphBuilderConfiguration.Plugins(plugins, invocationPlugins);
 257         copy.clearInlineInvokePlugins();
 258         copy.appendInlineInvokePlugin(new SnippetInlineInvokePlugin());
 259         copy.appendNodePlugin(new SnippetCounterPlugin());
 260         HotSpotProviders providers = (HotSpotProviders) replacements.getProviders().copyWith(new HotSpotSubstrateConstantReflectionProvider(replacements.getProviders().getConstantReflection()));
 261         this.snippetReplacements = new HotSpotSnippetReplacementsImpl(replacements, providers.copyWith(copy));
 262         this.snippetReplacements.setGraphBuilderPlugins(copy);
 263     }
 264 
 265     synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin) {
 266         knownPlugins.add(plugin);
 267     }
 268 
 269     void registerConditionalPlugin(InvocationPlugin plugin) {
 270         conditionalPlugins.add(plugin);
 271     }
 272 
 273     synchronized void checkRegistered(MethodSubstitutionPlugin plugin) {
 274         if (!knownPlugins.contains(plugin)) {
 275             throw new GraalError(&quot;missing plugin should have been registered during construction&quot;);
 276         }
 277     }
 278 
 279     /**
 280      * Compiles the snippet and stores the graph.
 281      */
 282     private synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context, OptionValues options) {
 283         ResolvedJavaMethod method = plugin.getSubstitute(snippetReplacements.getProviders().getMetaAccess());
 284         assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
 285         String originalMethodString = plugin.originalMethodAsString();
 286         StructuredGraph subst = buildGraph(method, original, originalMethodString, null, true, false, context, options);
 287         snippetMethods.add(method);
 288         originalMethods.put(methodKey(method), originalMethodString);
 289         preparedSnippetGraphs.put(plugin.toString() + context, subst);
 290     }
 291 
 292     static class EncodedSnippets {
 293         private byte[] snippetEncoding;
 294         private Object[] snippetObjects;
 295         private NodeClass&lt;?&gt;[] snippetNodeClasses;
 296         private Map&lt;String, Integer&gt; snippetStartOffsets;
 297         private Map&lt;String, String&gt; originalMethods;
 298 
 299         EncodedSnippets(byte[] snippetEncoding, Object[] snippetObjects, NodeClass&lt;?&gt;[] snippetNodeClasses, Map&lt;String, Integer&gt; snippetStartOffsets, Map&lt;String, String&gt; originalMethods) {
 300             this.snippetEncoding = snippetEncoding;
 301             this.snippetObjects = snippetObjects;
 302             this.snippetNodeClasses = snippetNodeClasses;
 303             this.snippetStartOffsets = snippetStartOffsets;
 304             this.originalMethods = originalMethods;
 305         }
 306 
 307         StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements, IntrinsicContext.CompilationContext context,
 308                         StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {
 309             IntrinsicContext.CompilationContext contextToUse = context;
 310             if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {
 311                 contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 312             }
 313             Integer startOffset = snippetStartOffsets.get(plugin.toString() + contextToUse);
 314             if (startOffset == null) {
 315                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin + &quot; with &quot; + contextToUse);
 316             }
 317 
 318             ResolvedJavaType accessingClass = replacements.getProviders().getMetaAccess().lookupJavaType(plugin.getDeclaringClass());
 319             return decodeGraph(original, accessingClass, startOffset, replacements, contextToUse, allowAssumptions, cancellable, options);
 320         }
 321 
 322         @SuppressWarnings(&quot;try&quot;)
 323         private StructuredGraph decodeGraph(ResolvedJavaMethod method,
 324                         ResolvedJavaType accessingClass,
 325                         int startOffset,
 326                         ReplacementsImpl replacements,
 327                         IntrinsicContext.CompilationContext context,
 328                         StructuredGraph.AllowAssumptions allowAssumptions,
 329                         Cancellable cancellable,
 330                         OptionValues options) {
 331             Providers providers = replacements.getProviders();
 332             EncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,
 333                             methodKey(method), accessingClass, method.getDeclaringClass());
 334             try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {
 335                 StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions).cancellable(cancellable).method(method).setIsSubstitution(true).build();
 336                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, null, method, context, encodedGraph);
 337 
 338                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 339 
 340                 assert result.verify();
 341                 return result;
 342             }
 343         }
 344 
 345         StructuredGraph getEncodedSnippet(ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args, StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {
 346             Integer startOffset = null;
 347             if (snippetStartOffsets != null) {
 348                 startOffset = snippetStartOffsets.get(methodKey(method));
 349             }
 350             if (startOffset == null) {
 351                 if (IS_IN_NATIVE_IMAGE) {
 352                     throw GraalError.shouldNotReachHere(&quot;snippet not found: &quot; + method.format(&quot;%H.%n(%p)&quot;));
 353                 } else {
 354                     return null;
 355                 }
 356             }
 357 
 358             SymbolicEncodedGraph encodedGraph = new SymbolicEncodedGraph(snippetEncoding, startOffset, snippetObjects, snippetNodeClasses,
 359                             originalMethods.get(methodKey(method)), method.getDeclaringClass());
 360             return decodeSnippetGraph(encodedGraph, method, replacements, args, allowAssumptions, options);
 361         }
 362 
 363     }
 364 
 365     private static class SubstitutionGraphDecoder extends PEGraphDecoder {
 366         private final ResolvedJavaMethod method;
 367         private final EncodedGraph encodedGraph;
 368         private IntrinsicContext intrinsic;
 369 
 370         SubstitutionGraphDecoder(Providers providers, StructuredGraph result, ReplacementsImpl replacements, ParameterPlugin parameterPlugin, ResolvedJavaMethod method,
 371                         IntrinsicContext.CompilationContext context, EncodedGraph encodedGraph) {
 372             super(providers.getCodeCache().getTarget().arch, result, providers, null,
 373                             replacements.getGraphBuilderPlugins().getInvocationPlugins(), new InlineInvokePlugin[0], parameterPlugin,
 374                             null, null, null, null);
 375             this.method = method;
 376             this.encodedGraph = encodedGraph;
 377             intrinsic = new IntrinsicContext(method, null, replacements.getDefaultReplacementBytecodeProvider(), context, false);
 378         }
 379 
 380         @Override
 381         protected EncodedGraph lookupEncodedGraph(ResolvedJavaMethod lookupMethod,
 382                         MethodSubstitutionPlugin plugin,
 383                         BytecodeProvider intrinsicBytecodeProvider,
 384                         boolean isSubstitution,
 385                         boolean trackNodeSourcePosition) {
 386             if (lookupMethod.equals(method)) {
 387                 return encodedGraph;
 388             } else {
 389                 throw GraalError.shouldNotReachHere(method.format(&quot;%H.%n(%p)&quot;));
 390             }
 391         }
 392 
 393         @Override
 394         protected IntrinsicContext getIntrinsic() {
 395             return intrinsic;
 396         }
 397     }
 398 
 399     private StructuredGraph buildGraph(ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, Object receiver, boolean requireInlining, boolean trackNodeSourcePosition,
 400                     IntrinsicContext.CompilationContext context, OptionValues options) {
 401         assert method.hasBytecodes() : &quot;Snippet must not be abstract or native&quot;;
 402         Object[] args = null;
 403         if (receiver != null) {
 404             args = new Object[method.getSignature().getParameterCount(true)];
 405             args[0] = receiver;
 406         }
 407         // To get dumping out from this context during image building, it&#39;s necessary to pass the
 408         // dumping options directly to the VM, otherwise they aren&#39;t available during initialization
 409         // of the backend. Use this:
 410         //
 411         // -J-Dgraal.Dump=SymbolicSnippetEncoder_:2 -J-Dgraal.PrintGraph=File
 412         // -J-Dgraal.DebugStubsAndSnippets=true
 413         IntrinsicContext.CompilationContext contextToUse = context;
 414         if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {
 415             contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 416         }
 417         try (DebugContext debug = openDebugContext(&quot;SymbolicSnippetEncoder_&quot;, method, options)) {
 418             StructuredGraph graph = snippetReplacements.makeGraph(debug, snippetReplacements.getDefaultReplacementBytecodeProvider(), method, args, original, trackNodeSourcePosition, null,
 419                             contextToUse);
 420 
 421             // Check if all methods which should be inlined are really inlined.
 422             for (MethodCallTargetNode callTarget : graph.getNodes(MethodCallTargetNode.TYPE)) {
 423                 ResolvedJavaMethod callee = callTarget.targetMethod();
 424                 if (requireInlining &amp;&amp; !delayedInvocationPluginMethods.contains(callee) &amp;&amp; !Objects.equals(callee, original)) {
 425                     throw GraalError.shouldNotReachHere(&quot;method &quot; + callee.format(&quot;%H.%n&quot;) + &quot; not inlined in snippet &quot; + method.getName() + &quot; (maybe not final?)&quot;);
 426                 }
 427             }
 428             assert verifySnippetEncodeDecode(debug, method, original, originalMethodString, trackNodeSourcePosition, graph);
 429             debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;After buildGraph&quot;);
 430             return graph;
 431         }
 432     }
 433 
 434     @SuppressWarnings(&quot;try&quot;)
 435     private static StructuredGraph decodeSnippetGraph(SymbolicEncodedGraph encodedGraph, ResolvedJavaMethod method, ReplacementsImpl replacements, Object[] args,
 436                     StructuredGraph.AllowAssumptions allowAssumptions, OptionValues options) {
 437         Providers providers = replacements.getProviders();
 438         ParameterPlugin parameterPlugin = null;
 439         if (args != null) {
 440             parameterPlugin = new ConstantBindingParameterPlugin(args, providers.getMetaAccess(), replacements.snippetReflection);
 441         }
 442 
 443         try (DebugContext debug = replacements.openDebugContext(&quot;SVMSnippet_&quot;, method, options)) {
 444             // @formatter:off
 445             StructuredGraph result = new StructuredGraph.Builder(options, debug, allowAssumptions)
 446                     .method(method)
 447                     .trackNodeSourcePosition(encodedGraph.trackNodeSourcePosition())
 448                     .setIsSubstitution(true)
 449                     .build();
 450             // @formatter:on
 451             try (DebugContext.Scope scope = debug.scope(&quot;DecodeSnippetGraph&quot;, result)) {
 452                 PEGraphDecoder graphDecoder = new SubstitutionGraphDecoder(providers, result, replacements, parameterPlugin, method, INLINE_AFTER_PARSING, encodedGraph);
 453 
 454                 graphDecoder.decode(method, result.isSubstitution(), encodedGraph.trackNodeSourcePosition());
 455                 debug.dump(DebugContext.VERBOSE_LEVEL, result, &quot;After decoding&quot;);
 456 
 457                 assert result.verify();
 458                 return result;
 459             } catch (Throwable t) {
 460                 throw debug.handle(t);
 461             }
 462         }
 463     }
 464 
 465     @SuppressWarnings(&quot;try&quot;)
 466     private boolean verifySnippetEncodeDecode(DebugContext debug, ResolvedJavaMethod method, ResolvedJavaMethod original, String originalMethodString, boolean trackNodeSourcePosition,
 467                     StructuredGraph graph) {
 468         // Verify the encoding and decoding process
 469         EncodedGraph encodedGraph = GraphEncoder.encodeSingleGraph(graph, HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch);
 470 
 471         HotSpotProviders originalProvider = (HotSpotProviders) snippetReplacements.getProviders();
 472 
 473         SnippetReflectionProvider snippetReflection = originalProvider.getSnippetReflection();
 474         SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider constantReflection = new SymbolicSnippetEncoder.HotSpotSubstrateConstantReflectionProvider(
 475                         originalProvider.getConstantReflection());
 476         HotSpotProviders newProviders = new HotSpotProviders(originalProvider.getMetaAccess(), originalProvider.getCodeCache(), constantReflection,
 477                         originalProvider.getConstantFieldProvider(), originalProvider.getForeignCalls(), originalProvider.getLowerer(), null, originalProvider.getSuites(),
 478                         originalProvider.getRegisters(), snippetReflection, originalProvider.getWordTypes(), originalProvider.getGraphBuilderPlugins(),
 479                         originalProvider.getPlatformConfigurationProvider());
 480         HotSpotSnippetReplacementsImpl filteringReplacements = new HotSpotSnippetReplacementsImpl(newProviders, snippetReflection,
 481                         originalProvider.getReplacements().getDefaultReplacementBytecodeProvider(), originalProvider.getCodeCache().getTarget());
 482         filteringReplacements.setGraphBuilderPlugins(originalProvider.getReplacements().getGraphBuilderPlugins());
 483         try (DebugContext.Scope scaope = debug.scope(&quot;VerifySnippetEncodeDecode&quot;, graph)) {
 484             for (int i = 0; i &lt; encodedGraph.getNumObjects(); i++) {
 485                 filterSnippetObject(encodedGraph.getObject(i));
 486             }
 487             StructuredGraph snippet = filteringReplacements.makeGraph(debug, filteringReplacements.getDefaultReplacementBytecodeProvider(), method, null, original,
 488                             trackNodeSourcePosition, null);
 489             SymbolicEncodedGraph symbolicGraph = new SymbolicEncodedGraph(encodedGraph, method.getDeclaringClass(), originalMethodString);
 490             StructuredGraph decodedSnippet = decodeSnippetGraph(symbolicGraph, original != null ? original : method, originalReplacements, null,
 491                             StructuredGraph.AllowAssumptions.ifNonNull(graph.getAssumptions()), graph.getOptions());
 492             String snippetString = getCanonicalGraphString(snippet, true, false);
 493             String decodedSnippetString = getCanonicalGraphString(decodedSnippet, true, false);
 494             if (snippetString.equals(decodedSnippetString)) {
 495                 debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);
 496                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 497             } else {
 498                 debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);
 499                 debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));
 500                 debug.dump(DebugContext.VERBOSE_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);
 501                 debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Encoded snippet graph for %s&quot;, method);
 502                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 503             }
 504         } catch (Throwable t) {
 505             throw debug.handle(t);
 506         }
 507         return true;
 508     }
 509 
 510     /**
 511      * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
 512      */
 513     @SuppressWarnings(&quot;try&quot;)
 514     private synchronized EncodedSnippets maybeEncodeSnippets(OptionValues options) {
 515         Set&lt;MethodSubstitutionPlugin&gt; plugins = this.knownPlugins;
 516         if (preparedPlugins != plugins.size()) {
 517             for (MethodSubstitutionPlugin plugin : plugins) {
 518                 ResolvedJavaMethod original = plugin.getOriginalMethod(originalReplacements.getProviders().getMetaAccess());
 519                 registerMethodSubstitution(plugin, original, INLINE_AFTER_PARSING, options);
 520                 if (!original.isNative()) {
 521                     registerMethodSubstitution(plugin, original, ROOT_COMPILATION_ENCODING, options);
 522                 }
 523             }
 524             preparedPlugins = plugins.size();
 525         }
 526         Map&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;
 527         if (encodedGraphs != graphs.size()) {
 528             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null, options);
 529             try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
 530                 encodedGraphs = graphs.size();
 531                 for (StructuredGraph graph : graphs.values()) {
 532                     for (Node node : graph.getNodes()) {
 533                         node.setNodeSourcePosition(null);
 534                     }
 535                 }
 536                 return encodeSnippets(debug);
 537             }
 538         }
 539         return null;
 540     }
 541 
 542     synchronized void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {
 543         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {
 544             assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
 545             String key = methodKey(method);
 546             if (!preparedSnippetGraphs.containsKey(key)) {
 547                 if (original != null) {
 548                     originalMethods.put(key, methodKey(original));
 549                 }
 550                 StructuredGraph snippet = buildGraph(method, original, null, receiver, true, trackNodeSourcePosition, INLINE_AFTER_PARSING, options);
 551                 snippetMethods.add(method);
 552                 preparedSnippetGraphs.put(key, snippet);
 553             }
 554         }
 555 
 556     }
 557 
 558     private synchronized EncodedSnippets encodeSnippets(DebugContext debug) {
 559         GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
 560         for (StructuredGraph graph : preparedSnippetGraphs.values()) {
 561             encoder.prepare(graph);
 562         }
 563         encoder.finishPrepare();
 564 
 565         byte[] snippetEncoding;
 566         Object[] snippetObjects;
 567         NodeClass&lt;?&gt;[] snippetNodeClasses;
 568         Map&lt;String, Integer&gt; snippetStartOffsets;
 569 
 570         snippetStartOffsets = new HashMap&lt;&gt;();
 571         for (Map.Entry&lt;String, StructuredGraph&gt; entry : preparedSnippetGraphs.entrySet()) {
 572             snippetStartOffsets.put(entry.getKey(), encoder.encode(entry.getValue()));
 573         }
 574         snippetEncoding = encoder.getEncoding();
 575         snippetObjects = encoder.getObjects();
 576         snippetNodeClasses = encoder.getNodeClasses();
 577         for (int i = 0; i &lt; snippetObjects.length; i++) {
 578             Object o = filterSnippetObject(snippetObjects[i]);
 579             debug.log(&quot;snippetObjects[%d] = %s -&gt; %s&quot;, i, o != null ? o.getClass().getSimpleName() : null, o);
 580             snippetObjects[i] = o;
 581         }
 582         debug.log(&quot;Encoded %d snippet preparedSnippetGraphs using %d bytes with %d objects&quot;, snippetStartOffsets.size(), snippetEncoding.length, snippetObjects.length);
 583         return new EncodedSnippets(snippetEncoding, snippetObjects, snippetNodeClasses, snippetStartOffsets, originalMethods);
 584     }
 585 
 586     /**
 587      * Encode any outstanding graphs and return true if any work was done.
 588      */
 589     @SuppressWarnings(&quot;try&quot;)
 590     public boolean encode(OptionValues options) {
 591         EncodedSnippets encodedSnippets = maybeEncodeSnippets(options);
 592         if (encodedSnippets != null) {
 593             HotSpotReplacementsImpl.setEncodedSnippets(encodedSnippets);
 594             return true;
 595         }
 596         return false;
 597     }
 598 
 599     private DebugContext openDebugContext(String idPrefix, ResolvedJavaMethod method, OptionValues options) {
 600         return snippetReplacements.openDebugContext(idPrefix, method, options);
 601     }
 602 
 603     static class SymbolicEncodedGraph extends EncodedGraph {
 604 
 605         private final ResolvedJavaType[] accessingClasses;
 606         private final String originalMethod;
 607 
 608         SymbolicEncodedGraph(byte[] encoding, int startOffset, Object[] objects, NodeClass&lt;?&gt;[] types, String originalMethod, ResolvedJavaType... accessingClasses) {
 609             super(encoding, startOffset, objects, types, null, null, null, false, false);
 610             this.accessingClasses = accessingClasses;
 611             this.originalMethod = originalMethod;
 612         }
 613 
 614         SymbolicEncodedGraph(EncodedGraph encodedGraph, ResolvedJavaType declaringClass, String originalMethod) {
 615             this(encodedGraph.getEncoding(), encodedGraph.getStartOffset(), encodedGraph.getObjects(), encodedGraph.getNodeClasses(),
 616                             originalMethod, declaringClass);
 617         }
 618 
 619         @Override
 620         public Object getObject(int i) {
 621             Object o = objects[i];
 622             Object replacement = null;
 623             if (o instanceof SymbolicJVMCIReference) {
 624                 for (ResolvedJavaType type : accessingClasses) {
 625                     try {
 626                         replacement = ((SymbolicJVMCIReference&lt;?&gt;) o).resolve(type);
 627                         break;
 628                     } catch (NoClassDefFoundError e) {
 629                     }
 630                 }
 631             } else if (o instanceof UnresolvedJavaType) {
 632                 for (ResolvedJavaType type : accessingClasses) {
 633                     try {
 634                         replacement = ((UnresolvedJavaType) o).resolve(type);
 635                         break;
 636                     } catch (NoClassDefFoundError e) {
 637                     }
 638                 }
 639             } else if (o instanceof UnresolvedJavaMethod) {
 640                 throw new InternalError(o.toString());
 641             } else if (o instanceof UnresolvedJavaField) {
 642                 for (ResolvedJavaType type : accessingClasses) {
 643                     try {
 644                         replacement = ((UnresolvedJavaField) o).resolve(type);
 645                         break;
 646                     } catch (NoClassDefFoundError e) {
 647                     }
 648                 }
 649             } else if (o instanceof GraalCapability) {
 650                 replacement = ((GraalCapability) o).resolve(((GraalJVMCICompiler) getRuntime().getCompiler()).getGraalRuntime());
 651             } else {
 652                 return o;
 653             }
 654             if (replacement != null) {
 655                 objects[i] = o = replacement;
 656             } else {
 657                 throw new GraalError(&quot;Can&#39;t resolve &quot; + o);
 658             }
 659             return o;
 660         }
 661 
 662         @Override
 663         public boolean isCallToOriginal(ResolvedJavaMethod callTarget) {
 664             if (originalMethod != null &amp;&amp; originalMethod.equals(methodKey(callTarget))) {
 665                 return true;
 666             }
 667             return super.isCallToOriginal(callTarget);
 668         }
 669     }
 670 
 671     /**
 672      * Symbolic reference to an object which can be retrieved from
 673      * {@link GraalRuntime#getCapability(Class)}.
 674      */
 675     static class GraalCapability {
 676         final Class&lt;?&gt; capabilityClass;
 677 
 678         GraalCapability(Class&lt;?&gt; capabilityClass) {
 679             this.capabilityClass = capabilityClass;
 680         }
 681 
 682         public Object resolve(GraalRuntime runtime) {
 683             Object capability = runtime.getCapability(this.capabilityClass);
 684             if (capability != null) {
 685                 assert capability.getClass() == capabilityClass;
 686                 return capability;
 687             }
 688             throw new InternalError(this.capabilityClass.getName());
 689         }
 690     }
 691 
 692     static class SymbolicResolvedJavaMethod implements SymbolicJVMCIReference&lt;ResolvedJavaMethod&gt; {
 693         final UnresolvedJavaType type;
 694         final String methodName;
 695         final String signature;
 696 
 697         SymbolicResolvedJavaMethod(ResolvedJavaMethod method) {
 698             this.type = UnresolvedJavaType.create(method.getDeclaringClass().getName());
 699             this.methodName = method.getName();
 700             this.signature = method.getSignature().toMethodDescriptor();
 701         }
 702 
 703         @Override
 704         public String toString() {
 705             return &quot;SymbolicResolvedJavaMethod{&quot; +
 706                             &quot;declaringType=&#39;&quot; + type.getName() + &#39;\&#39;&#39; +
 707                             &quot;, methodName=&#39;&quot; + methodName + &#39;\&#39;&#39; +
 708                             &quot;, signature=&#39;&quot; + signature + &#39;\&#39;&#39; +
 709                             &#39;}&#39;;
 710         }
 711 
 712         @Override
 713         public ResolvedJavaMethod resolve(ResolvedJavaType accessingClass) {
 714             ResolvedJavaType resolvedType = type.resolve(accessingClass);
 715             if (resolvedType == null) {
 716                 throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 717             }
 718             for (ResolvedJavaMethod method : methodName.equals(&quot;&lt;init&gt;&quot;) ? resolvedType.getDeclaredConstructors() : resolvedType.getDeclaredMethods()) {
 719                 if (method.getName().equals(methodName) &amp;&amp; method.getSignature().toMethodDescriptor().equals(signature)) {
 720                     return method;
 721                 }
 722             }
 723             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 724         }
 725     }
 726 
 727     static class SymbolicResolvedJavaField implements SymbolicJVMCIReference&lt;ResolvedJavaField&gt; {
 728         final UnresolvedJavaType declaringType;
 729         final String name;
 730         final UnresolvedJavaType signature;
 731         private final boolean isStatic;
 732 
 733         SymbolicResolvedJavaField(ResolvedJavaField field) {
 734             this.declaringType = UnresolvedJavaType.create(field.getDeclaringClass().getName());
 735             this.name = field.getName();
 736             this.signature = UnresolvedJavaType.create(field.getType().getName());
 737             this.isStatic = field.isStatic();
 738         }
 739 
 740         @Override
 741         public ResolvedJavaField resolve(ResolvedJavaType accessingClass) {
 742             ResolvedJavaType resolvedType = declaringType.resolve(accessingClass);
 743             ResolvedJavaType resolvedFieldType = signature.resolve(accessingClass);
 744             ResolvedJavaField[] fields = isStatic ? resolvedType.getStaticFields() : resolvedType.getInstanceFields(true);
 745             for (ResolvedJavaField field : fields) {
 746                 if (field.getName().equals(name)) {
 747                     if (field.getType().equals(resolvedFieldType)) {
 748                         return field;
 749                     }
 750                 }
 751             }
 752             throw new InternalError(&quot;Could not resolve &quot; + this + &quot; in context of &quot; + accessingClass.toJavaName());
 753         }
 754 
 755         @Override
 756         public String toString() {
 757             return &quot;SymbolicResolvedJavaField{&quot; +
 758                             signature.getName() + &#39; &#39; +
 759                             declaringType.getName() + &#39;.&#39; +
 760                             name +
 761                             &#39;}&#39;;
 762         }
 763     }
 764 
 765     static class SymbolicResolvedJavaMethodBytecode implements SymbolicJVMCIReference&lt;ResolvedJavaMethodBytecode&gt; {
 766         SymbolicResolvedJavaMethod method;
 767 
 768         SymbolicResolvedJavaMethodBytecode(ResolvedJavaMethodBytecode bytecode) {
 769             method = new SymbolicResolvedJavaMethod(bytecode.getMethod());
 770         }
 771 
 772         @Override
 773         public ResolvedJavaMethodBytecode resolve(ResolvedJavaType accessingClass) {
 774             return new ResolvedJavaMethodBytecode(method.resolve(accessingClass));
 775         }
 776     }
 777 
 778     static class SymbolicStampPair implements SymbolicJVMCIReference&lt;StampPair&gt; {
 779         Object trustedStamp;
 780         Object uncheckdStamp;
 781 
 782         SymbolicStampPair(StampPair stamp) {
 783             this.trustedStamp = maybeMakeSymbolic(stamp.getTrustedStamp());
 784             this.uncheckdStamp = maybeMakeSymbolic(stamp.getUncheckedStamp());
 785         }
 786 
 787         @Override
 788         public StampPair resolve(ResolvedJavaType accessingClass) {
 789             return StampPair.create(resolveStamp(accessingClass, trustedStamp), resolveStamp(accessingClass, uncheckdStamp));
 790         }
 791     }
 792 
 793     private static Object maybeMakeSymbolic(Stamp trustedStamp) {
 794         if (trustedStamp != null) {
 795             SymbolicJVMCIReference&lt;?&gt; symbolicJVMCIReference = trustedStamp.makeSymbolic();
 796             if (symbolicJVMCIReference != null) {
 797                 return symbolicJVMCIReference;
 798             }
 799         }
 800         return trustedStamp;
 801     }
 802 
 803     private static Stamp resolveStamp(ResolvedJavaType accessingClass, Object stamp) {
 804         if (stamp == null) {
 805             return null;
 806         }
 807         if (stamp instanceof Stamp) {
 808             return (Stamp) stamp;
 809         }
 810         return (Stamp) ((SymbolicJVMCIReference&lt;?&gt;) stamp).resolve(accessingClass);
 811     }
 812 
 813     public static class HotSpotSubstrateConstantReflectionProvider implements ConstantReflectionProvider {
 814 
 815         private final ConstantReflectionProvider constantReflection;
 816 
 817         HotSpotSubstrateConstantReflectionProvider(ConstantReflectionProvider constantReflection) {
 818             this.constantReflection = constantReflection;
 819         }
 820 
 821         HashSet&lt;JavaConstant&gt; safeConstants = new HashSet&lt;&gt;();
 822 
 823         @Override
 824         public Boolean constantEquals(Constant x, Constant y) {
 825             return constantReflection.constantEquals(x, y);
 826         }
 827 
 828         @Override
 829         public Integer readArrayLength(JavaConstant array) {
 830             return constantReflection.readArrayLength(array);
 831         }
 832 
 833         @Override
 834         public JavaConstant readArrayElement(JavaConstant array, int index) {
 835             return constantReflection.readArrayElement(array, index);
 836         }
 837 
 838         @Override
 839         public JavaConstant readFieldValue(ResolvedJavaField field, JavaConstant receiver) {
 840             JavaConstant javaConstant = constantReflection.readFieldValue(field, receiver);
 841             if (!safeConstants.contains(receiver) &amp;&amp;
 842                             !field.getDeclaringClass().getName().contains(&quot;graalvm&quot;) &amp;&amp;
 843                             !field.getDeclaringClass().getName().contains(&quot;jdk/vm/ci/&quot;) &amp;&amp;
 844                             !field.getDeclaringClass().getName().contains(&quot;jdk/internal/vm/compiler&quot;) &amp;&amp;
 845 
 846                             !field.getName().equals(&quot;TYPE&quot;)) {
 847                 // Only permit constant reflection on compiler classes. This is necessary primarily
 848                 // because of the boxing snippets which are compiled as snippets but are really just
 849                 // regular JDK java sources that are being compiled like a snippet. These shouldn&#39;t
 850                 // permit constant folding during graph preparation as that embeds constants from
 851                 // the runtime into a compiler graph.
 852                 return null;
 853             }
 854             if (javaConstant.getJavaKind() == JavaKind.Object) {
 855                 safeConstants.add(javaConstant);
 856             }
 857             return javaConstant;
 858         }
 859 
 860         @Override
 861         public JavaConstant boxPrimitive(JavaConstant source) {
 862             return constantReflection.boxPrimitive(source);
 863         }
 864 
 865         @Override
 866         public JavaConstant unboxPrimitive(JavaConstant source) {
 867             return constantReflection.unboxPrimitive(source);
 868         }
 869 
 870         @Override
 871         public JavaConstant forString(String value) {
 872             return constantReflection.forString(value);
 873         }
 874 
 875         @Override
 876         public ResolvedJavaType asJavaType(Constant constant) {
 877             return constantReflection.asJavaType(constant);
 878         }
 879 
 880         @Override
 881         public MethodHandleAccessProvider getMethodHandleAccess() {
 882             return constantReflection.getMethodHandleAccess();
 883         }
 884 
 885         @Override
 886         public MemoryAccessProvider getMemoryAccessProvider() {
 887             return constantReflection.getMemoryAccessProvider();
 888         }
 889 
 890         @Override
 891         public JavaConstant asJavaClass(ResolvedJavaType type) {
 892             return constantReflection.asJavaClass(type);
 893         }
 894 
 895         @Override
 896         public Constant asObjectHub(ResolvedJavaType type) {
 897             return constantReflection.asObjectHub(type);
 898         }
 899     }
 900 
 901     /**
 902      * Objects embedded in encoded graphs might need to converted into a symbolic form so convert
 903      * the object or pass it through.
 904      */
 905     private static Object filterSnippetObject(Object o) {
 906         if (o instanceof HotSpotResolvedJavaMethod) {
 907             return new SymbolicResolvedJavaMethod((HotSpotResolvedJavaMethod) o);
 908         } else if (o instanceof HotSpotResolvedJavaField) {
 909             return new SymbolicResolvedJavaField((HotSpotResolvedJavaField) o);
 910         } else if (o instanceof HotSpotResolvedJavaType) {
 911             return UnresolvedJavaType.create(((ResolvedJavaType) o).getName());
 912         } else if (o instanceof NodeSourcePosition) {
 913             // Filter these out for now. These can&#39;t easily be handled because these positions
 914             // description snippet methods which might not be available in the runtime.
 915             return null;
 916         } else if (o instanceof HotSpotForeignCallsProvider || o instanceof GraalHotSpotVMConfig) {
 917             return new GraalCapability(o.getClass());
 918         } else if (o instanceof Stamp) {
 919             SymbolicJVMCIReference&lt;?&gt; ref = ((Stamp) o).makeSymbolic();
 920             if (ref != null) {
 921                 return ref;
 922             }
 923             return o;
 924         } else if (o instanceof StampPair) {
 925             if (((StampPair) o).getTrustedStamp() instanceof AbstractObjectStamp) {
 926                 return new SymbolicStampPair((StampPair) o);
 927             }
 928         } else if (o instanceof ResolvedJavaMethodBytecode) {
 929             return new SymbolicResolvedJavaMethodBytecode((ResolvedJavaMethodBytecode) o);
 930         } else if (o instanceof HotSpotSignature) {
 931             throw new GraalError(o.toString());
 932         }
 933         return o;
 934     }
 935 
 936     private static String compareGraphStrings(StructuredGraph expectedGraph, String expectedString, StructuredGraph actualGraph, String actualString) {
 937         if (!expectedString.equals(actualString)) {
 938             String[] expectedLines = expectedString.split(&quot;\n&quot;);
 939             String[] actualLines = actualString.split(&quot;\n&quot;);
 940             int diffIndex = -1;
 941             int limit = Math.min(actualLines.length, expectedLines.length);
 942             String marker = &quot; &lt;&lt;&lt;&quot;;
 943             for (int i = 0; i &lt; limit; i++) {
 944                 if (!expectedLines[i].equals(actualLines[i])) {
 945                     diffIndex = i;
 946                     break;
 947                 }
 948             }
 949             if (diffIndex == -1) {
 950                 // Prefix is the same so add some space after the prefix
 951                 diffIndex = limit;
 952                 if (actualLines.length == limit) {
 953                     actualLines = Arrays.copyOf(actualLines, limit + 1);
 954                     actualLines[diffIndex] = &quot;&quot;;
 955                 } else {
 956                     assert expectedLines.length == limit;
 957                     expectedLines = Arrays.copyOf(expectedLines, limit + 1);
 958                     expectedLines[diffIndex] = &quot;&quot;;
 959                 }
 960             }
 961             // Place a marker next to the first line that differs
 962             expectedLines[diffIndex] = expectedLines[diffIndex] + marker;
 963             actualLines[diffIndex] = actualLines[diffIndex] + marker;
 964             String ediff = String.join(&quot;\n&quot;, expectedLines);
 965             String adiff = String.join(&quot;\n&quot;, actualLines);
 966             return &quot;mismatch in preparedSnippetGraphs:\n========= expected (&quot; + expectedGraph + &quot;) =========\n&quot; + ediff + &quot;\n\n========= actual (&quot; + actualGraph + &quot;) =========\n&quot; + adiff;
 967         } else {
 968             return &quot;mismatch in preparedSnippetGraphs&quot;;
 969         }
 970     }
 971 
 972     private static String getCanonicalGraphString(StructuredGraph graph, boolean excludeVirtual, boolean checkConstants) {
 973         SchedulePhase schedule = new SchedulePhase(SchedulePhase.SchedulingStrategy.EARLIEST);
 974         schedule.apply(graph);
 975         StructuredGraph.ScheduleResult scheduleResult = graph.getLastSchedule();
 976 
 977         NodeMap&lt;Integer&gt; canonicalId = graph.createNodeMap();
 978         int nextId = 0;
 979 
 980         List&lt;String&gt; constantsLines = new ArrayList&lt;&gt;();
 981 
 982         StringBuilder result = new StringBuilder();
 983         for (Block block : scheduleResult.getCFG().getBlocks()) {
 984             result.append(&quot;Block &quot;).append(block).append(&#39; &#39;);
 985             if (block == scheduleResult.getCFG().getStartBlock()) {
 986                 result.append(&quot;* &quot;);
 987             }
 988             result.append(&quot;-&gt; &quot;);
 989             for (Block succ : block.getSuccessors()) {
 990                 result.append(succ).append(&#39; &#39;);
 991             }
 992             result.append(&#39;\n&#39;);
 993             for (Node node : scheduleResult.getBlockToNodesMap().get(block)) {
 994                 if (node instanceof ValueNode &amp;&amp; node.isAlive()) {
 995                     if (!excludeVirtual || !(node instanceof VirtualObjectNode || node instanceof ProxyNode || node instanceof FullInfopointNode || node instanceof ParameterNode)) {
 996                         if (node instanceof ConstantNode) {
 997                             if (checkConstants) {
 998                                 String name = node.toString(Verbosity.Name);
 999                                 if (excludeVirtual) {
1000                                     constantsLines.add(name);
1001                                 } else {
1002                                     constantsLines.add(name + &quot;    (&quot; + filteredUsageCount(node) + &quot;)&quot;);
1003                                 }
1004                             }
1005                         } else {
1006                             int id;
1007                             if (canonicalId.get(node) != null) {
1008                                 id = canonicalId.get(node);
1009                             } else {
1010                                 id = nextId++;
1011                                 canonicalId.set(node, id);
1012                             }
1013                             String name = node.getClass().getSimpleName();
1014                             result.append(&quot;  &quot;).append(id).append(&#39;|&#39;).append(name);
1015                             if (node instanceof AccessFieldNode) {
1016                                 result.append(&#39;#&#39;);
1017                                 result.append(((AccessFieldNode) node).field());
1018                             }
1019                             if (!excludeVirtual) {
1020                                 result.append(&quot;    (&quot;);
1021                                 result.append(filteredUsageCount(node));
1022                                 result.append(&#39;)&#39;);
1023                             }
1024                             result.append(&#39;\n&#39;);
1025                         }
1026                     }
1027                 }
1028             }
1029         }
1030 
1031         StringBuilder constantsLinesResult = new StringBuilder();
1032         if (checkConstants) {
1033             constantsLinesResult.append(constantsLines.size()).append(&quot; constants:\n&quot;);
1034         }
1035         Collections.sort(constantsLines);
1036         for (String s : constantsLines) {
1037             constantsLinesResult.append(s);
1038             constantsLinesResult.append(&#39;\n&#39;);
1039         }
1040 
1041         return constantsLinesResult.toString() + result.toString();
1042     }
1043 
1044     private static int filteredUsageCount(Node node) {
1045         return node.usages().filter(n -&gt; !(n instanceof FrameState)).count();
1046     }
1047 
1048     /**
1049      * This horror show of classes exists solely get {@link HotSpotSnippetBytecodeParser} to be used
1050      * as the parser for these snippets.
1051      */
1052     class HotSpotSnippetReplacementsImpl extends HotSpotReplacementsImpl {
1053         HotSpotSnippetReplacementsImpl(HotSpotReplacementsImpl replacements, Providers providers) {
1054             super(replacements, providers);
1055         }
1056 
1057         HotSpotSnippetReplacementsImpl(Providers providers, SnippetReflectionProvider snippetReflection, BytecodeProvider bytecodeProvider, TargetDescription target) {
1058             super(providers, snippetReflection, bytecodeProvider, target);
1059         }
1060 
1061         @Override
1062         protected GraphMaker createGraphMaker(ResolvedJavaMethod substitute, ResolvedJavaMethod original) {
1063             return new SnippetGraphMaker(this, substitute, original);
1064         }
1065     }
1066 
1067     class SnippetGraphMaker extends ReplacementsImpl.GraphMaker {
1068         SnippetGraphMaker(ReplacementsImpl replacements, ResolvedJavaMethod substitute, ResolvedJavaMethod substitutedMethod) {
1069             super(replacements, substitute, substitutedMethod);
1070         }
1071 
1072         @Override
1073         protected GraphBuilderPhase.Instance createGraphBuilder(Providers providers, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts,
1074                         IntrinsicContext initialIntrinsicContext) {
1075             return new HotSpotSnippetGraphBuilderPhase(providers, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);
1076         }
1077     }
1078 
1079     class HotSpotSnippetGraphBuilderPhase extends GraphBuilderPhase.Instance {
1080         HotSpotSnippetGraphBuilderPhase(Providers theProviders, GraphBuilderConfiguration graphBuilderConfig, OptimisticOptimizations optimisticOpts, IntrinsicContext initialIntrinsicContext) {
1081             super(theProviders, graphBuilderConfig, optimisticOpts, initialIntrinsicContext);
1082         }
1083 
1084         @Override
1085         protected BytecodeParser createBytecodeParser(StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI, IntrinsicContext intrinsicContext) {
1086             return new HotSpotSnippetBytecodeParser(this, graph, parent, method, entryBCI, intrinsicContext);
1087         }
1088     }
1089 
1090     class HotSpotSnippetBytecodeParser extends BytecodeParser {
1091         HotSpotSnippetBytecodeParser(GraphBuilderPhase.Instance graphBuilderInstance, StructuredGraph graph, BytecodeParser parent, ResolvedJavaMethod method, int entryBCI,
1092                         IntrinsicContext intrinsicContext) {
1093             super(graphBuilderInstance, graph, parent, method, entryBCI, intrinsicContext);
1094         }
1095 
1096         @Override
1097         public boolean canDeferPlugin(GeneratedInvocationPlugin plugin) {
1098             // Fold is always deferred but NodeIntrinsics may have to wait if all their arguments
1099             // aren&#39;t constant yet.
1100             return plugin.isGeneratedFromFoldOrNodeIntrinsic();
1101         }
1102 
1103         @Override
1104         protected boolean canInlinePartialIntrinsicExit() {
1105             return false;
1106         }
1107 
1108         @Override
1109         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
1110             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1111                 return false;
1112             }
1113             if (targetMethod.getAnnotation(Fold.class) != null) {
1114                 // Always defer Fold until decode time but NodeIntrinsics may fold if they are able.
1115                 return false;
1116             }
1117             InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
1118             if (conditionalPlugins.contains(plugin)) {
1119                 // Because supporting arbitrary plugins in the context of encoded graphs is complex
1120                 // we disallow it. This limitation can be worked around through the use of method
1121                 // substitutions.
1122                 throw new GraalError(&quot;conditional plugins are unsupported in snippets and method substitutions: &quot; + targetMethod + &quot; &quot; + plugin);
1123             }
1124             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType);
1125         }
1126     }
1127 }
    </pre>
  </body>
</html>
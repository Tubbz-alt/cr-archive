<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HotSpotReplacementsImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="meta/DefaultHotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/SymbolicSnippetEncoder.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
  32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
  33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collections;
<span class="line-removed">  38 import java.util.HashMap;</span>
  39 import java.util.HashSet;
  40 import java.util.List;
<span class="line-removed">  41 import java.util.Map;</span>
  42 import java.util.Objects;
  43 import java.util.Set;
<span class="line-removed">  44 import java.util.concurrent.ConcurrentHashMap;</span>
  45 




  46 import org.graalvm.compiler.api.replacements.Fold;
  47 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  48 import org.graalvm.compiler.api.replacements.Snippet;
  49 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  50 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  51 import org.graalvm.compiler.api.runtime.GraalRuntime;
  52 import org.graalvm.compiler.bytecode.BytecodeProvider;
  53 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  54 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  55 import org.graalvm.compiler.core.common.type.Stamp;
  56 import org.graalvm.compiler.core.common.type.StampPair;
  57 import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  58 import org.graalvm.compiler.debug.DebugContext;
  59 import org.graalvm.compiler.debug.GraalError;
  60 import org.graalvm.compiler.graph.Node;
  61 import org.graalvm.compiler.graph.NodeClass;
  62 import org.graalvm.compiler.graph.NodeMap;
  63 import org.graalvm.compiler.graph.NodeSourcePosition;
  64 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  65 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
</pre>
<hr />
<pre>
 125  * method references into a symbolic form that can be resolved at graph decode time using
 126  * {@link SymbolicJVMCIReference}.
 127  */
 128 public class SymbolicSnippetEncoder {
 129 
 130     /**
 131      * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
 132      * substitutions for graph encoding.
 133      */
 134     private final HotSpotSnippetReplacementsImpl snippetReplacements;
 135 
 136     /**
 137      * The set of all snippet methods that have been encoded.
 138      */
 139     private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
 140 
 141     /**
 142      * A mapping from the method substitution method to the original method name. The string key and
 143      * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
 144      */
<span class="line-modified"> 145     private final Map&lt;String, String&gt; originalMethods = new ConcurrentHashMap&lt;&gt;();</span>
 146 
 147     private final HotSpotReplacementsImpl originalReplacements;
 148 
 149     /**
 150      * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
 151      * encoding.
 152      */
 153     private int encodedGraphs = 0;
 154 
 155     /**
 156      * All the graphs parsed so far.
 157      */
<span class="line-modified"> 158     private Map&lt;String, StructuredGraph&gt; preparedSnippetGraphs = new HashMap&lt;&gt;();</span>
 159 
<span class="line-modified"> 160     private Set&lt;MethodSubstitutionPlugin&gt; knownPlugins = new HashSet&lt;&gt;();</span>
 161 
<span class="line-modified"> 162     private Set&lt;InvocationPlugin&gt; conditionalPlugins = new HashSet&lt;&gt;();</span>
 163 
 164     private int preparedPlugins = 0;
 165 
 166     /**
 167      * The invocation plugins which were delayed during graph preparation.
 168      */
 169     private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
 170 
 171     void addDelayedInvocationPluginMethod(ResolvedJavaMethod method) {
 172         delayedInvocationPluginMethods.add(method);
 173     }
 174 
 175     Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
 176         return snippetMethods;
 177     }
 178 
 179     protected class SnippetInlineInvokePlugin implements InlineInvokePlugin {
 180 
 181         @Override
 182         public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
</pre>
<hr />
<pre>
 272 
 273     synchronized void checkRegistered(MethodSubstitutionPlugin plugin) {
 274         if (!knownPlugins.contains(plugin)) {
 275             throw new GraalError(&quot;missing plugin should have been registered during construction&quot;);
 276         }
 277     }
 278 
 279     /**
 280      * Compiles the snippet and stores the graph.
 281      */
 282     private synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context, OptionValues options) {
 283         ResolvedJavaMethod method = plugin.getSubstitute(snippetReplacements.getProviders().getMetaAccess());
 284         assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
 285         String originalMethodString = plugin.originalMethodAsString();
 286         StructuredGraph subst = buildGraph(method, original, originalMethodString, null, true, false, context, options);
 287         snippetMethods.add(method);
 288         originalMethods.put(methodKey(method), originalMethodString);
 289         preparedSnippetGraphs.put(plugin.toString() + context, subst);
 290     }
 291 
<span class="line-modified"> 292     static class EncodedSnippets {</span>
<span class="line-modified"> 293         private byte[] snippetEncoding;</span>
<span class="line-modified"> 294         private Object[] snippetObjects;</span>
<span class="line-modified"> 295         private NodeClass&lt;?&gt;[] snippetNodeClasses;</span>
<span class="line-modified"> 296         private Map&lt;String, Integer&gt; snippetStartOffsets;</span>
<span class="line-modified"> 297         private Map&lt;String, String&gt; originalMethods;</span>
 298 
<span class="line-modified"> 299         EncodedSnippets(byte[] snippetEncoding, Object[] snippetObjects, NodeClass&lt;?&gt;[] snippetNodeClasses, Map&lt;String, Integer&gt; snippetStartOffsets, Map&lt;String, String&gt; originalMethods) {</span>

 300             this.snippetEncoding = snippetEncoding;
 301             this.snippetObjects = snippetObjects;
 302             this.snippetNodeClasses = snippetNodeClasses;
 303             this.snippetStartOffsets = snippetStartOffsets;
 304             this.originalMethods = originalMethods;
 305         }
 306 
















 307         StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements, IntrinsicContext.CompilationContext context,
 308                         StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {
 309             IntrinsicContext.CompilationContext contextToUse = context;
 310             if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {
 311                 contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 312             }
 313             Integer startOffset = snippetStartOffsets.get(plugin.toString() + contextToUse);
 314             if (startOffset == null) {
 315                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin + &quot; with &quot; + contextToUse);
 316             }
 317 
 318             ResolvedJavaType accessingClass = replacements.getProviders().getMetaAccess().lookupJavaType(plugin.getDeclaringClass());
 319             return decodeGraph(original, accessingClass, startOffset, replacements, contextToUse, allowAssumptions, cancellable, options);
 320         }
 321 
 322         @SuppressWarnings(&quot;try&quot;)
 323         private StructuredGraph decodeGraph(ResolvedJavaMethod method,
 324                         ResolvedJavaType accessingClass,
 325                         int startOffset,
 326                         ReplacementsImpl replacements,
</pre>
<hr />
<pre>
 495                 debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);
 496                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 497             } else {
 498                 debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);
 499                 debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));
 500                 debug.dump(DebugContext.VERBOSE_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);
 501                 debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Encoded snippet graph for %s&quot;, method);
 502                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 503             }
 504         } catch (Throwable t) {
 505             throw debug.handle(t);
 506         }
 507         return true;
 508     }
 509 
 510     /**
 511      * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
 512      */
 513     @SuppressWarnings(&quot;try&quot;)
 514     private synchronized EncodedSnippets maybeEncodeSnippets(OptionValues options) {
<span class="line-modified"> 515         Set&lt;MethodSubstitutionPlugin&gt; plugins = this.knownPlugins;</span>
 516         if (preparedPlugins != plugins.size()) {
 517             for (MethodSubstitutionPlugin plugin : plugins) {
 518                 ResolvedJavaMethod original = plugin.getOriginalMethod(originalReplacements.getProviders().getMetaAccess());
 519                 registerMethodSubstitution(plugin, original, INLINE_AFTER_PARSING, options);
 520                 if (!original.isNative()) {
 521                     registerMethodSubstitution(plugin, original, ROOT_COMPILATION_ENCODING, options);
 522                 }
 523             }
 524             preparedPlugins = plugins.size();
 525         }
<span class="line-modified"> 526         Map&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;</span>
 527         if (encodedGraphs != graphs.size()) {
 528             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null, options);
 529             try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
 530                 encodedGraphs = graphs.size();
<span class="line-modified"> 531                 for (StructuredGraph graph : graphs.values()) {</span>
 532                     for (Node node : graph.getNodes()) {
 533                         node.setNodeSourcePosition(null);
 534                     }
 535                 }
 536                 return encodeSnippets(debug);
 537             }
 538         }
 539         return null;

 540     }
 541 
 542     synchronized void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {
 543         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {
 544             assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
 545             String key = methodKey(method);
 546             if (!preparedSnippetGraphs.containsKey(key)) {
 547                 if (original != null) {
 548                     originalMethods.put(key, methodKey(original));
 549                 }
 550                 StructuredGraph snippet = buildGraph(method, original, null, receiver, true, trackNodeSourcePosition, INLINE_AFTER_PARSING, options);
 551                 snippetMethods.add(method);
 552                 preparedSnippetGraphs.put(key, snippet);
 553             }
 554         }
 555 
 556     }
 557 
 558     private synchronized EncodedSnippets encodeSnippets(DebugContext debug) {
 559         GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
<span class="line-modified"> 560         for (StructuredGraph graph : preparedSnippetGraphs.values()) {</span>
 561             encoder.prepare(graph);
 562         }
 563         encoder.finishPrepare();
 564 
 565         byte[] snippetEncoding;
 566         Object[] snippetObjects;
 567         NodeClass&lt;?&gt;[] snippetNodeClasses;
<span class="line-modified"> 568         Map&lt;String, Integer&gt; snippetStartOffsets;</span>
 569 
<span class="line-modified"> 570         snippetStartOffsets = new HashMap&lt;&gt;();</span>
<span class="line-modified"> 571         for (Map.Entry&lt;String, StructuredGraph&gt; entry : preparedSnippetGraphs.entrySet()) {</span>
<span class="line-modified"> 572             snippetStartOffsets.put(entry.getKey(), encoder.encode(entry.getValue()));</span>

 573         }
 574         snippetEncoding = encoder.getEncoding();
 575         snippetObjects = encoder.getObjects();
 576         snippetNodeClasses = encoder.getNodeClasses();
 577         for (int i = 0; i &lt; snippetObjects.length; i++) {
 578             Object o = filterSnippetObject(snippetObjects[i]);
 579             debug.log(&quot;snippetObjects[%d] = %s -&gt; %s&quot;, i, o != null ? o.getClass().getSimpleName() : null, o);
 580             snippetObjects[i] = o;
 581         }
 582         debug.log(&quot;Encoded %d snippet preparedSnippetGraphs using %d bytes with %d objects&quot;, snippetStartOffsets.size(), snippetEncoding.length, snippetObjects.length);
 583         return new EncodedSnippets(snippetEncoding, snippetObjects, snippetNodeClasses, snippetStartOffsets, originalMethods);
 584     }
 585 
 586     /**
 587      * Encode any outstanding graphs and return true if any work was done.
 588      */
 589     @SuppressWarnings(&quot;try&quot;)
 590     public boolean encode(OptionValues options) {
 591         EncodedSnippets encodedSnippets = maybeEncodeSnippets(options);
 592         if (encodedSnippets != null) {
</pre>
<hr />
<pre>
1098             // Fold is always deferred but NodeIntrinsics may have to wait if all their arguments
1099             // aren&#39;t constant yet.
1100             return plugin.isGeneratedFromFoldOrNodeIntrinsic();
1101         }
1102 
1103         @Override
1104         protected boolean canInlinePartialIntrinsicExit() {
1105             return false;
1106         }
1107 
1108         @Override
1109         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
1110             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1111                 return false;
1112             }
1113             if (targetMethod.getAnnotation(Fold.class) != null) {
1114                 // Always defer Fold until decode time but NodeIntrinsics may fold if they are able.
1115                 return false;
1116             }
1117             InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
<span class="line-modified">1118             if (conditionalPlugins.contains(plugin)) {</span>
1119                 // Because supporting arbitrary plugins in the context of encoded graphs is complex
1120                 // we disallow it. This limitation can be worked around through the use of method
1121                 // substitutions.
1122                 throw new GraalError(&quot;conditional plugins are unsupported in snippets and method substitutions: &quot; + targetMethod + &quot; &quot; + plugin);
1123             }
1124             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType);
1125         }
1126     }
1127 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.hotspot;
  26 
  27 import static jdk.vm.ci.runtime.JVMCI.getRuntime;
  28 import static jdk.vm.ci.services.Services.IS_BUILDING_NATIVE_IMAGE;
  29 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  30 import static org.graalvm.compiler.core.common.GraalOptions.UseEncodedGraphs;
  31 import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createIntrinsicInlineInfo;
  32 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.INLINE_AFTER_PARSING;
  33 import static org.graalvm.compiler.nodes.graphbuilderconf.IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
  34 
  35 import java.util.ArrayList;
  36 import java.util.Arrays;
  37 import java.util.Collections;

  38 import java.util.HashSet;
  39 import java.util.List;

  40 import java.util.Objects;
  41 import java.util.Set;

  42 
<span class="line-added">  43 import jdk.internal.vm.compiler.collections.EconomicMap;</span>
<span class="line-added">  44 import jdk.internal.vm.compiler.collections.EconomicSet;</span>
<span class="line-added">  45 import jdk.internal.vm.compiler.collections.MapCursor;</span>
<span class="line-added">  46 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;</span>
  47 import org.graalvm.compiler.api.replacements.Fold;
  48 import org.graalvm.compiler.api.replacements.MethodSubstitution;
  49 import org.graalvm.compiler.api.replacements.Snippet;
  50 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  51 import org.graalvm.compiler.api.runtime.GraalJVMCICompiler;
  52 import org.graalvm.compiler.api.runtime.GraalRuntime;
  53 import org.graalvm.compiler.bytecode.BytecodeProvider;
  54 import org.graalvm.compiler.bytecode.ResolvedJavaMethodBytecode;
  55 import org.graalvm.compiler.core.common.type.AbstractObjectStamp;
  56 import org.graalvm.compiler.core.common.type.Stamp;
  57 import org.graalvm.compiler.core.common.type.StampPair;
  58 import org.graalvm.compiler.core.common.type.SymbolicJVMCIReference;
  59 import org.graalvm.compiler.debug.DebugContext;
  60 import org.graalvm.compiler.debug.GraalError;
  61 import org.graalvm.compiler.graph.Node;
  62 import org.graalvm.compiler.graph.NodeClass;
  63 import org.graalvm.compiler.graph.NodeMap;
  64 import org.graalvm.compiler.graph.NodeSourcePosition;
  65 import org.graalvm.compiler.hotspot.meta.HotSpotForeignCallsProvider;
  66 import org.graalvm.compiler.hotspot.meta.HotSpotProviders;
</pre>
<hr />
<pre>
 126  * method references into a symbolic form that can be resolved at graph decode time using
 127  * {@link SymbolicJVMCIReference}.
 128  */
 129 public class SymbolicSnippetEncoder {
 130 
 131     /**
 132      * This is a customized HotSpotReplacementsImpl intended only for parsing snippets and method
 133      * substitutions for graph encoding.
 134      */
 135     private final HotSpotSnippetReplacementsImpl snippetReplacements;
 136 
 137     /**
 138      * The set of all snippet methods that have been encoded.
 139      */
 140     private final Set&lt;ResolvedJavaMethod&gt; snippetMethods = Collections.synchronizedSet(new HashSet&lt;&gt;());
 141 
 142     /**
 143      * A mapping from the method substitution method to the original method name. The string key and
 144      * values are produced using {@link #methodKey(ResolvedJavaMethod)}.
 145      */
<span class="line-modified"> 146     private final EconomicMap&lt;String, String&gt; originalMethods = EconomicMap.create();</span>
 147 
 148     private final HotSpotReplacementsImpl originalReplacements;
 149 
 150     /**
 151      * The current count of graphs encoded. Used to detect when new graphs have been enqueued for
 152      * encoding.
 153      */
 154     private int encodedGraphs = 0;
 155 
 156     /**
 157      * All the graphs parsed so far.
 158      */
<span class="line-modified"> 159     private EconomicMap&lt;String, StructuredGraph&gt; preparedSnippetGraphs = EconomicMap.create();</span>
 160 
<span class="line-modified"> 161     private EconomicSet&lt;MethodSubstitutionPlugin&gt; knownPlugins = EconomicSet.create();</span>
 162 
<span class="line-modified"> 163     private EconomicSet&lt;InvocationPlugin&gt; conditionalPlugins = EconomicSet.create();</span>
 164 
 165     private int preparedPlugins = 0;
 166 
 167     /**
 168      * The invocation plugins which were delayed during graph preparation.
 169      */
 170     private Set&lt;ResolvedJavaMethod&gt; delayedInvocationPluginMethods = new HashSet&lt;&gt;();
 171 
 172     void addDelayedInvocationPluginMethod(ResolvedJavaMethod method) {
 173         delayedInvocationPluginMethods.add(method);
 174     }
 175 
 176     Set&lt;ResolvedJavaMethod&gt; getSnippetMethods() {
 177         return snippetMethods;
 178     }
 179 
 180     protected class SnippetInlineInvokePlugin implements InlineInvokePlugin {
 181 
 182         @Override
 183         public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod method, ValueNode[] args) {
</pre>
<hr />
<pre>
 273 
 274     synchronized void checkRegistered(MethodSubstitutionPlugin plugin) {
 275         if (!knownPlugins.contains(plugin)) {
 276             throw new GraalError(&quot;missing plugin should have been registered during construction&quot;);
 277         }
 278     }
 279 
 280     /**
 281      * Compiles the snippet and stores the graph.
 282      */
 283     private synchronized void registerMethodSubstitution(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, IntrinsicContext.CompilationContext context, OptionValues options) {
 284         ResolvedJavaMethod method = plugin.getSubstitute(snippetReplacements.getProviders().getMetaAccess());
 285         assert method.getAnnotation(MethodSubstitution.class) != null : &quot;MethodSubstitution must be annotated with @&quot; + MethodSubstitution.class.getSimpleName();
 286         String originalMethodString = plugin.originalMethodAsString();
 287         StructuredGraph subst = buildGraph(method, original, originalMethodString, null, true, false, context, options);
 288         snippetMethods.add(method);
 289         originalMethods.put(methodKey(method), originalMethodString);
 290         preparedSnippetGraphs.put(plugin.toString() + context, subst);
 291     }
 292 
<span class="line-modified"> 293     public static class EncodedSnippets {</span>
<span class="line-modified"> 294         private final byte[] snippetEncoding;</span>
<span class="line-modified"> 295         private final Object[] snippetObjects;</span>
<span class="line-modified"> 296         private final NodeClass&lt;?&gt;[] snippetNodeClasses;</span>
<span class="line-modified"> 297         private final UnmodifiableEconomicMap&lt;String, Integer&gt; snippetStartOffsets;</span>
<span class="line-modified"> 298         private final UnmodifiableEconomicMap&lt;String, String&gt; originalMethods;</span>
 299 
<span class="line-modified"> 300         EncodedSnippets(byte[] snippetEncoding, Object[] snippetObjects, NodeClass&lt;?&gt;[] snippetNodeClasses, UnmodifiableEconomicMap&lt;String, Integer&gt; snippetStartOffsets,</span>
<span class="line-added"> 301                         UnmodifiableEconomicMap&lt;String, String&gt; originalMethods) {</span>
 302             this.snippetEncoding = snippetEncoding;
 303             this.snippetObjects = snippetObjects;
 304             this.snippetNodeClasses = snippetNodeClasses;
 305             this.snippetStartOffsets = snippetStartOffsets;
 306             this.originalMethods = originalMethods;
 307         }
 308 
<span class="line-added"> 309         public byte[] getSnippetEncoding() {</span>
<span class="line-added"> 310             return snippetEncoding;</span>
<span class="line-added"> 311         }</span>
<span class="line-added"> 312 </span>
<span class="line-added"> 313         public NodeClass&lt;?&gt;[] getSnippetNodeClasses() {</span>
<span class="line-added"> 314             return snippetNodeClasses;</span>
<span class="line-added"> 315         }</span>
<span class="line-added"> 316 </span>
<span class="line-added"> 317         public UnmodifiableEconomicMap&lt;String, Integer&gt; getSnippetStartOffsets() {</span>
<span class="line-added"> 318             return snippetStartOffsets;</span>
<span class="line-added"> 319         }</span>
<span class="line-added"> 320 </span>
<span class="line-added"> 321         public UnmodifiableEconomicMap&lt;String, String&gt; getOriginalMethods() {</span>
<span class="line-added"> 322             return originalMethods;</span>
<span class="line-added"> 323         }</span>
<span class="line-added"> 324 </span>
 325         StructuredGraph getMethodSubstitutionGraph(MethodSubstitutionPlugin plugin, ResolvedJavaMethod original, ReplacementsImpl replacements, IntrinsicContext.CompilationContext context,
 326                         StructuredGraph.AllowAssumptions allowAssumptions, Cancellable cancellable, OptionValues options) {
 327             IntrinsicContext.CompilationContext contextToUse = context;
 328             if (context == IntrinsicContext.CompilationContext.ROOT_COMPILATION) {
 329                 contextToUse = IntrinsicContext.CompilationContext.ROOT_COMPILATION_ENCODING;
 330             }
 331             Integer startOffset = snippetStartOffsets.get(plugin.toString() + contextToUse);
 332             if (startOffset == null) {
 333                 throw GraalError.shouldNotReachHere(&quot;plugin graph not found: &quot; + plugin + &quot; with &quot; + contextToUse);
 334             }
 335 
 336             ResolvedJavaType accessingClass = replacements.getProviders().getMetaAccess().lookupJavaType(plugin.getDeclaringClass());
 337             return decodeGraph(original, accessingClass, startOffset, replacements, contextToUse, allowAssumptions, cancellable, options);
 338         }
 339 
 340         @SuppressWarnings(&quot;try&quot;)
 341         private StructuredGraph decodeGraph(ResolvedJavaMethod method,
 342                         ResolvedJavaType accessingClass,
 343                         int startOffset,
 344                         ReplacementsImpl replacements,
</pre>
<hr />
<pre>
 513                 debug.log(&quot;Snippet decode for %s produces exactly same graph&quot;, method);
 514                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 515             } else {
 516                 debug.log(&quot;Snippet decode for %s produces different graph&quot;, method);
 517                 debug.log(&quot;%s&quot;, compareGraphStrings(snippet, snippetString, decodedSnippet, decodedSnippetString));
 518                 debug.dump(DebugContext.VERBOSE_LEVEL, snippet, &quot;Snippet graph for %s&quot;, method);
 519                 debug.dump(DebugContext.VERBOSE_LEVEL, graph, &quot;Encoded snippet graph for %s&quot;, method);
 520                 debug.dump(DebugContext.VERBOSE_LEVEL, decodedSnippet, &quot;Decoded snippet graph for %s&quot;, method);
 521             }
 522         } catch (Throwable t) {
 523             throw debug.handle(t);
 524         }
 525         return true;
 526     }
 527 
 528     /**
 529      * If there are new graphs waiting to be encoded, reencode all the graphs and return the result.
 530      */
 531     @SuppressWarnings(&quot;try&quot;)
 532     private synchronized EncodedSnippets maybeEncodeSnippets(OptionValues options) {
<span class="line-modified"> 533         EconomicSet&lt;MethodSubstitutionPlugin&gt; plugins = this.knownPlugins;</span>
 534         if (preparedPlugins != plugins.size()) {
 535             for (MethodSubstitutionPlugin plugin : plugins) {
 536                 ResolvedJavaMethod original = plugin.getOriginalMethod(originalReplacements.getProviders().getMetaAccess());
 537                 registerMethodSubstitution(plugin, original, INLINE_AFTER_PARSING, options);
 538                 if (!original.isNative()) {
 539                     registerMethodSubstitution(plugin, original, ROOT_COMPILATION_ENCODING, options);
 540                 }
 541             }
 542             preparedPlugins = plugins.size();
 543         }
<span class="line-modified"> 544         EconomicMap&lt;String, StructuredGraph&gt; graphs = this.preparedSnippetGraphs;</span>
 545         if (encodedGraphs != graphs.size()) {
 546             DebugContext debug = openDebugContext(&quot;SnippetEncoder&quot;, null, options);
 547             try (DebugContext.Scope scope = debug.scope(&quot;SnippetSupportEncode&quot;)) {
 548                 encodedGraphs = graphs.size();
<span class="line-modified"> 549                 for (StructuredGraph graph : graphs.getValues()) {</span>
 550                     for (Node node : graph.getNodes()) {
 551                         node.setNodeSourcePosition(null);
 552                     }
 553                 }
 554                 return encodeSnippets(debug);
 555             }
 556         }
 557         return null;
<span class="line-added"> 558 </span>
 559     }
 560 
 561     synchronized void registerSnippet(ResolvedJavaMethod method, ResolvedJavaMethod original, Object receiver, boolean trackNodeSourcePosition, OptionValues options) {
 562         if (IS_BUILDING_NATIVE_IMAGE || UseEncodedGraphs.getValue(options)) {
 563             assert method.getAnnotation(Snippet.class) != null : &quot;Snippet must be annotated with @&quot; + Snippet.class.getSimpleName();
 564             String key = methodKey(method);
 565             if (!preparedSnippetGraphs.containsKey(key)) {
 566                 if (original != null) {
 567                     originalMethods.put(key, methodKey(original));
 568                 }
 569                 StructuredGraph snippet = buildGraph(method, original, null, receiver, true, trackNodeSourcePosition, INLINE_AFTER_PARSING, options);
 570                 snippetMethods.add(method);
 571                 preparedSnippetGraphs.put(key, snippet);
 572             }
 573         }
 574 
 575     }
 576 
 577     private synchronized EncodedSnippets encodeSnippets(DebugContext debug) {
 578         GraphEncoder encoder = new GraphEncoder(HotSpotJVMCIRuntime.runtime().getHostJVMCIBackend().getTarget().arch, debug);
<span class="line-modified"> 579         for (StructuredGraph graph : preparedSnippetGraphs.getValues()) {</span>
 580             encoder.prepare(graph);
 581         }
 582         encoder.finishPrepare();
 583 
 584         byte[] snippetEncoding;
 585         Object[] snippetObjects;
 586         NodeClass&lt;?&gt;[] snippetNodeClasses;
<span class="line-modified"> 587         EconomicMap&lt;String, Integer&gt; snippetStartOffsets;</span>
 588 
<span class="line-modified"> 589         snippetStartOffsets = EconomicMap.create();</span>
<span class="line-modified"> 590         MapCursor&lt;String, StructuredGraph&gt; cursor = preparedSnippetGraphs.getEntries();</span>
<span class="line-modified"> 591         while (cursor.advance()) {</span>
<span class="line-added"> 592             snippetStartOffsets.put(cursor.getKey(), encoder.encode(cursor.getValue()));</span>
 593         }
 594         snippetEncoding = encoder.getEncoding();
 595         snippetObjects = encoder.getObjects();
 596         snippetNodeClasses = encoder.getNodeClasses();
 597         for (int i = 0; i &lt; snippetObjects.length; i++) {
 598             Object o = filterSnippetObject(snippetObjects[i]);
 599             debug.log(&quot;snippetObjects[%d] = %s -&gt; %s&quot;, i, o != null ? o.getClass().getSimpleName() : null, o);
 600             snippetObjects[i] = o;
 601         }
 602         debug.log(&quot;Encoded %d snippet preparedSnippetGraphs using %d bytes with %d objects&quot;, snippetStartOffsets.size(), snippetEncoding.length, snippetObjects.length);
 603         return new EncodedSnippets(snippetEncoding, snippetObjects, snippetNodeClasses, snippetStartOffsets, originalMethods);
 604     }
 605 
 606     /**
 607      * Encode any outstanding graphs and return true if any work was done.
 608      */
 609     @SuppressWarnings(&quot;try&quot;)
 610     public boolean encode(OptionValues options) {
 611         EncodedSnippets encodedSnippets = maybeEncodeSnippets(options);
 612         if (encodedSnippets != null) {
</pre>
<hr />
<pre>
1118             // Fold is always deferred but NodeIntrinsics may have to wait if all their arguments
1119             // aren&#39;t constant yet.
1120             return plugin.isGeneratedFromFoldOrNodeIntrinsic();
1121         }
1122 
1123         @Override
1124         protected boolean canInlinePartialIntrinsicExit() {
1125             return false;
1126         }
1127 
1128         @Override
1129         protected boolean tryInvocationPlugin(CallTargetNode.InvokeKind invokeKind, ValueNode[] args, ResolvedJavaMethod targetMethod, JavaKind resultType) {
1130             if (intrinsicContext != null &amp;&amp; intrinsicContext.isCallToOriginal(targetMethod)) {
1131                 return false;
1132             }
1133             if (targetMethod.getAnnotation(Fold.class) != null) {
1134                 // Always defer Fold until decode time but NodeIntrinsics may fold if they are able.
1135                 return false;
1136             }
1137             InvocationPlugin plugin = graphBuilderConfig.getPlugins().getInvocationPlugins().lookupInvocation(targetMethod);
<span class="line-modified">1138             if (plugin != null &amp;&amp; conditionalPlugins.contains(plugin)) {</span>
1139                 // Because supporting arbitrary plugins in the context of encoded graphs is complex
1140                 // we disallow it. This limitation can be worked around through the use of method
1141                 // substitutions.
1142                 throw new GraalError(&quot;conditional plugins are unsupported in snippets and method substitutions: &quot; + targetMethod + &quot; &quot; + plugin);
1143             }
1144             return super.tryInvocationPlugin(invokeKind, args, targetMethod, resultType);
1145         }
1146     }
1147 }
</pre>
</td>
</tr>
</table>
<center><a href="HotSpotReplacementsImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="meta/DefaultHotSpotLoweringProvider.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jconsole/share/classes/module-info.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  77  * &lt;p&gt;
  78  * This table generates all the data structures it needs for each
  79  * type, as its own view, and will present some form of this to the
  80  * doclet as and when required to.
  81  *
  82  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  83  * If you write code that depends on this, you do so at your own risk.
  84  * This code and its internal interfaces are subject to change or
  85  * deletion without notice.&lt;/b&gt;
  86  *
  87  */
  88 
  89 public class VisibleMemberTable {
  90 
  91     public enum Kind {
  92         INNER_CLASSES,
  93         ENUM_CONSTANTS,
  94         FIELDS,
  95         CONSTRUCTORS,
  96         METHODS,
<span class="line-removed">  97         ANNOTATION_TYPE_FIELDS,</span>
  98         ANNOTATION_TYPE_MEMBER_OPTIONAL,
  99         ANNOTATION_TYPE_MEMBER_REQUIRED,
 100         PROPERTIES;
 101 
 102         public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
 103         public static final EnumSet&lt;Kind&gt; detailSet = EnumSet.range(ENUM_CONSTANTS, METHODS);
 104     }
 105 
 106     final TypeElement te;
 107     final TypeElement parent;
 108 
 109     final BaseConfiguration config;
 110     final BaseOptions options;
 111     final Utils utils;
 112     final VisibleMemberCache mcache;
 113 
 114     private List&lt;VisibleMemberTable&gt; allSuperclasses;
 115     private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
 116     private List&lt;VisibleMemberTable&gt; parents;
 117 
<span class="line-removed"> 118 </span>
<span class="line-removed"> 119     private Map&lt;Kind, List&lt;Element&gt;&gt; extraMembers = new EnumMap&lt;&gt;(Kind.class);</span>
 120     private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
 121     private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
 122 
 123     // Keeps track of method overrides
 124     Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
 125             = new LinkedHashMap&lt;&gt;();
 126 
 127     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
 128                                  VisibleMemberCache mcache) {
 129         config = configuration;
 130         utils = configuration.utils;
 131         options = configuration.getOptions();
 132         te = typeElement;
 133         parent = utils.getSuperClass(te);
 134         this.mcache = mcache;
 135         allSuperclasses = new ArrayList&lt;&gt;();
 136         allSuperinterfaces = new ArrayList&lt;&gt;();
 137         parents = new ArrayList&lt;&gt;();
 138     }
 139 
 140     private synchronized void ensureInitialized() {
 141         if (visibleMembers != null)
 142             return;
 143 
 144         visibleMembers = new EnumMap&lt;&gt;(Kind.class);
 145         for (Kind kind : Kind.values()) {
 146             visibleMembers.put(kind, new ArrayList&lt;&gt;());
 147         }
 148         computeParents();
 149         computeVisibleMembers();
 150     }
 151 
<span class="line-removed"> 152     List&lt;? extends Element&gt; getExtraMembers(Kind kind) {</span>
<span class="line-removed"> 153         ensureInitialized();</span>
<span class="line-removed"> 154         return visibleMembers.getOrDefault(kind, Collections.emptyList());</span>
<span class="line-removed"> 155     }</span>
<span class="line-removed"> 156 </span>
 157     List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
 158         ensureInitialized();
 159         return allSuperclasses;
 160     }
 161 
 162     List&lt;VisibleMemberTable&gt; getAllSuperinterfaces() {
 163         ensureInitialized();
 164         return allSuperinterfaces;
 165     }
 166 
 167     /**
 168      * Returns a list of all visible enclosed members of a type element,
 169      * and inherited members.
 170      * &lt;p&gt;
 171      * Notes:
 172      * a. The list may or may not contain simple overridden methods.
 173      * A simple overridden method is one that overrides a super method
 174      * with no specification changes as indicated by the existence of a
 175      * sole &amp;commat;inheritDoc or devoid of any API comments.
 176      * &lt;p&gt;
</pre>
<hr />
<pre>
 270      * order C, B, A, j.l.O. The super-interfaces however are
 271      * alpha sorted and appended to the resulting set.
 272      *
 273      * @return the list of visible classes in this map.
 274      */
 275     public Set&lt;TypeElement&gt; getVisibleTypeElements() {
 276         ensureInitialized();
 277         Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;();
 278 
 279         // Add this type element first.
 280         result.add(te);
 281 
 282         // Add the super classes.
 283         allSuperclasses.stream()
 284                 .map(vmt -&gt; vmt.te)
 285                 .forEach(result::add);
 286 
 287         // ... and finally the sorted super interfaces.
 288         allSuperinterfaces.stream()
 289                 .map(vmt -&gt; vmt.te)
<span class="line-modified"> 290                 .sorted(utils.makeGeneralPurposeComparator())</span>
 291                 .forEach(result::add);
 292 
 293         return result;
 294     }
 295 
 296     /**
 297      * Returns true if this table contains visible members.
 298      *
 299      * @return true if visible members are present.
 300      */
 301     public boolean hasVisibleMembers() {
 302         for (Kind kind : Kind.values()) {
 303             if (hasVisibleMembers(kind))
 304                 return true;
 305         }
 306         return false;
 307     }
 308 
 309     /**
 310      * Returns true if this table contains visible members of
</pre>
<hr />
<pre>
 335      * @return the getter or null if absent
 336      */
 337     public ExecutableElement getPropertyGetter(ExecutableElement propertyMethod) {
 338         ensureInitialized();
 339         PropertyMembers pm =  propertyMap.get(propertyMethod);
 340         return pm == null ? null : pm.getter;
 341     }
 342 
 343     /**
 344      * Returns the setter method associated with the property method.
 345      * @param propertyMethod the identifying property method
 346      * @return the setter or null if absent
 347      */
 348     public ExecutableElement getPropertySetter(ExecutableElement propertyMethod) {
 349         ensureInitialized();
 350         PropertyMembers pm =  propertyMap.get(propertyMethod);
 351         return pm == null ? null : pm.setter;
 352     }
 353 
 354     private void computeParents() {





 355         for (TypeMirror intfType : te.getInterfaces()) {
 356             TypeElement intfc = utils.asTypeElement(intfType);
 357             if (intfc != null) {
 358                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
 359                 allSuperinterfaces.add(vmt);
 360                 parents.add(vmt);
 361                 allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 362             }
 363         }
 364 
 365         if (parent != null) {
 366             VisibleMemberTable vmt = mcache.getVisibleMemberTable(parent);
 367             allSuperclasses.add(vmt);
 368             allSuperclasses.addAll(vmt.getAllSuperclasses());
 369             // Add direct super interfaces of a super class, if any.
 370             allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 371             parents.add(vmt);
 372         }
 373     }
 374 
 375     private void computeVisibleMembers() {
 376 
 377         // Note: these have some baggage, and are redundant,
 378         // allow this to be GC&#39;ed.
 379         LocalMemberTable lmt = new LocalMemberTable();
 380 
 381         for (Kind k : Kind.values()) {
<span class="line-removed"> 382             computeLeafMembers(lmt, k);</span>
 383             computeVisibleMembers(lmt, k);
 384         }
 385         // All members have been computed, compute properties.
 386         computeVisibleProperties(lmt);
 387     }
 388 
<span class="line-removed"> 389     private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {</span>
<span class="line-removed"> 390         List&lt;Element&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line-removed"> 391         if (utils.isUndocumentedEnclosure(te)) {</span>
<span class="line-removed"> 392             list.addAll(lmt.getOrderedMembers(kind));</span>
<span class="line-removed"> 393         }</span>
<span class="line-removed"> 394         parents.forEach(pvmt -&gt; list.addAll(pvmt.getExtraMembers(kind)));</span>
<span class="line-removed"> 395         extraMembers.put(kind, Collections.unmodifiableList(list));</span>
<span class="line-removed"> 396     }</span>
 397 
 398     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
 399         switch (kind) {
 400             case FIELDS: case INNER_CLASSES:
 401                 computeVisibleFieldsAndInnerClasses(lmt, kind);
 402                 return;
 403 
 404             case METHODS:
 405                 computeVisibleMethods(lmt);
 406                 return;
 407 
 408             // Defer properties related computations for later.
 409             case PROPERTIES:
 410                 return;
 411 
 412             default:
 413                 List&lt;Element&gt; list = lmt.getOrderedMembers(kind).stream()
 414                         .filter(this::mustDocument)
 415                         .collect(Collectors.toList());
 416                 visibleMembers.put(kind, Collections.unmodifiableList(list));
</pre>
<hr />
<pre>
 436 
 437         return true;
 438     }
 439 
 440     private boolean isMemberHidden(Element inheritedMember, Kind kind, LocalMemberTable lmt) {
 441         Elements elementUtils = config.docEnv.getElementUtils();
 442         switch(kind) {
 443             default:
 444                 List&lt;Element&gt; list = lmt.getMembers(inheritedMember, kind);
 445                 if (list.isEmpty())
 446                     return false;
 447                 return elementUtils.hides(list.get(0), inheritedMember);
 448             case METHODS: case CONSTRUCTORS: // Handled elsewhere.
 449                 throw new IllegalArgumentException(&quot;incorrect kind&quot;);
 450         }
 451     }
 452 
 453     private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
 454         Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 455         for (VisibleMemberTable pvmt : parents) {
<span class="line-removed"> 456             result.addAll(pvmt.getExtraMembers(kind));</span>
 457             result.addAll(pvmt.getAllVisibleMembers(kind));
 458         }
 459 
 460         // Filter out members in the inherited list that are hidden
 461         // by this type or should not be inherited at all.
 462         List&lt;Element&gt; list = result.stream()
 463                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))
 464                 .collect(Collectors.toList());
 465 
 466         // Prefix local results first
 467         list.addAll(0, lmt.getOrderedMembers(kind));
 468 
 469         // Filter out elements that should not be documented
 470         list = list.stream()
 471                 .filter(this::mustDocument)
 472                 .collect(Collectors.toList());
 473 
 474         visibleMembers.put(kind, Collections.unmodifiableList(list));
 475     }
 476 
 477     private void computeVisibleMethods(LocalMemberTable lmt) {
 478         Set&lt;Element&gt; inheritedMethods = new LinkedHashSet&lt;&gt;();
 479         Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; overriddenByTable = new HashMap&lt;&gt;();
 480         for (VisibleMemberTable pvmt : parents) {
 481             // Merge the lineage overrides into local table
 482             pvmt.overriddenMethodTable.entrySet().forEach(e -&gt; {
 483                 OverridingMethodInfo p = e.getValue();
 484                 if (!p.simpleOverride) { // consider only real overrides
 485                     List&lt;ExecutableElement&gt; list = overriddenByTable.computeIfAbsent(p.overrider,
 486                             k -&gt; new ArrayList&lt;&gt;());
 487                     list.add(e.getKey());
 488                 }
 489             });
 490             inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));
<span class="line-removed"> 491 </span>
<span class="line-removed"> 492             // Copy the extra members (if any) from the lineage.</span>
<span class="line-removed"> 493             if (!utils.shouldDocument(pvmt.te)) {</span>
<span class="line-removed"> 494                 List&lt;? extends Element&gt; extraMethods = pvmt.getExtraMembers(Kind.METHODS);</span>
<span class="line-removed"> 495 </span>
<span class="line-removed"> 496                 if (lmt.getOrderedMembers(Kind.METHODS).isEmpty()) {</span>
<span class="line-removed"> 497                     inheritedMethods.addAll(extraMethods);</span>
<span class="line-removed"> 498                     continue;</span>
<span class="line-removed"> 499                 }</span>
<span class="line-removed"> 500 </span>
<span class="line-removed"> 501                 // Check if an extra-method ought to percolate through.</span>
<span class="line-removed"> 502                 for (Element extraMethod : extraMethods) {</span>
<span class="line-removed"> 503                     boolean found = false;</span>
<span class="line-removed"> 504 </span>
<span class="line-removed"> 505                     List&lt;Element&gt; lmethods = lmt.getMembers(extraMethod, Kind.METHODS);</span>
<span class="line-removed"> 506                     for (Element lmethod : lmethods) {</span>
<span class="line-removed"> 507                         ExecutableElement method = (ExecutableElement)lmethod;</span>
<span class="line-removed"> 508                         found = utils.elementUtils.overrides(method,</span>
<span class="line-removed"> 509                                 (ExecutableElement)extraMethod, te);</span>
<span class="line-removed"> 510                         if (found)</span>
<span class="line-removed"> 511                             break;</span>
<span class="line-removed"> 512                     }</span>
<span class="line-removed"> 513                     if (!found)</span>
<span class="line-removed"> 514                         inheritedMethods.add(extraMethod);</span>
<span class="line-removed"> 515                 }</span>
<span class="line-removed"> 516             }</span>
 517         }
 518 
 519         // Filter out inherited methods that:
 520         // a. cannot override (private instance members)
 521         // b. are overridden and should not be visible in this type
 522         // c. are hidden in the type being considered
 523         // see allowInheritedMethods, which performs the above actions
 524         List&lt;Element&gt; list = inheritedMethods.stream()
 525                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))
 526                 .collect(Collectors.toList());
 527 
 528         // Filter out the local methods, that do not override or simply
 529         // overrides a super method, or those methods that should not
 530         // be visible.
 531         Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
 532             OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
 533             return p == null || !p.simpleOverride;
 534         };
<span class="line-modified"> 535         List&lt;Element&gt; mlist = lmt.getOrderedMembers(Kind.METHODS);</span>
<span class="line-modified"> 536         List&lt;Element&gt; llist = mlist.stream()</span>
 537                 .map(m -&gt; (ExecutableElement)m)
 538                 .filter(isVisible)
 539                 .collect(Collectors.toList());
 540 
<span class="line-modified"> 541         // Merge the above lists, making sure the local methods precede</span>
<span class="line-modified"> 542         // the others</span>
<span class="line-removed"> 543         list.addAll(0, llist);</span>
 544 
 545         // Final filtration of elements
 546         list = list.stream()
 547                 .filter(this::mustDocument)
 548                 .collect(Collectors.toList());
 549 
 550         visibleMembers.put(Kind.METHODS, Collections.unmodifiableList(list));
 551 
 552         // Copy over overridden tables from the lineage, and finish up.
 553         for (VisibleMemberTable pvmt : parents) {
 554             overriddenMethodTable.putAll(pvmt.overriddenMethodTable);
 555         }
 556         overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);
 557     }
 558 
 559     boolean isEnclosureInterface(Element e) {
 560         TypeElement enclosing = utils.getEnclosingTypeElement(e);
 561         return utils.isInterface(enclosing);
 562     }
 563 
</pre>
<hr />
<pre>
 656 
 657         LocalMemberTable() {
 658             orderedMembers = new EnumMap&lt;&gt;(Kind.class);
 659             memberMap = new EnumMap&lt;&gt;(Kind.class);
 660 
 661             List&lt;? extends Element&gt; elements = te.getEnclosedElements();
 662             for (Element e : elements) {
 663                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {
 664                     continue;
 665                 }
 666                 switch (e.getKind()) {
 667                     case CLASS:
 668                     case INTERFACE:
 669                     case ENUM:
 670                     case ANNOTATION_TYPE:
 671                     case RECORD:
 672                         addMember(e, Kind.INNER_CLASSES);
 673                         break;
 674                     case FIELD:
 675                         addMember(e, Kind.FIELDS);
<span class="line-removed"> 676                         addMember(e, Kind.ANNOTATION_TYPE_FIELDS);</span>
 677                         break;
 678                     case METHOD:
<span class="line-removed"> 679                         ExecutableElement ee = (ExecutableElement)e;</span>
 680                         if (utils.isAnnotationType(te)) {

 681                             addMember(e, ee.getDefaultValue() == null
 682                                     ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
 683                                     : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);


 684                         }
<span class="line-removed"> 685                         addMember(e, Kind.METHODS);</span>
 686                         break;
 687                     case CONSTRUCTOR:
 688                             addMember(e, Kind.CONSTRUCTORS);
 689                         break;
 690                     case ENUM_CONSTANT:
 691                         addMember(e, Kind.ENUM_CONSTANTS);
 692                         break;
 693                 }
 694             }
 695 
 696             // Freeze the data structures
 697             for (Kind kind : Kind.values()) {
 698                 orderedMembers.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableList(v));
 699                 orderedMembers.computeIfAbsent(kind, t -&gt; Collections.emptyList());
 700 
 701                 memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
 702                 memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
 703             }
 704         }
 705 
</pre>
<hr />
<pre>
 876         return imf.get();
 877     }
 878 
 879     public List&lt;ExecutableElement&gt; getImplementedMethods(ExecutableElement method) {
 880         ImplementedMethods imf = getImplementedMethodsFinder(method);
 881         return imf.getImplementedMethods().stream()
 882                 .filter(m -&gt; getSimplyOverriddenMethod(m) == null)
 883                 .collect(Collectors.toList());
 884     }
 885 
 886     public TypeMirror getImplementedMethodHolder(ExecutableElement method,
 887                                                  ExecutableElement implementedMethod) {
 888         ImplementedMethods imf = getImplementedMethodsFinder(method);
 889         return imf.getMethodHolder(implementedMethod);
 890     }
 891 
 892     private class ImplementedMethods {
 893 
 894         private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
 895         private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
<span class="line-removed"> 896         private final TypeElement typeElement;</span>
<span class="line-removed"> 897         private final ExecutableElement method;</span>
 898 
 899         public ImplementedMethods(ExecutableElement method) {
<span class="line-modified"> 900             this.method = method;</span>
<span class="line-removed"> 901             typeElement = utils.getEnclosingTypeElement(method);</span>
 902             Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
 903             /*
 904              * Search for the method in the list of interfaces. If found check if it is
 905              * overridden by any other subinterface method which this class
 906              * implements. If it is not overridden, add it in the method list.
 907              * Do this recursively for all the extended interfaces for each interface
 908              * from the list.
 909              */
 910             for (TypeMirror interfaceType : intfacs) {
 911                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
 912                 if (found != null) {
 913                     removeOverriddenMethod(found);
 914                     if (!overridingMethodFound(found)) {
 915                         methlist.add(found);
 916                         interfaces.put(found, interfaceType);
 917                     }
 918                 }
 919             }
 920         }
 921 
</pre>
</td>
<td>
<hr />
<pre>
  77  * &lt;p&gt;
  78  * This table generates all the data structures it needs for each
  79  * type, as its own view, and will present some form of this to the
  80  * doclet as and when required to.
  81  *
  82  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  83  * If you write code that depends on this, you do so at your own risk.
  84  * This code and its internal interfaces are subject to change or
  85  * deletion without notice.&lt;/b&gt;
  86  *
  87  */
  88 
  89 public class VisibleMemberTable {
  90 
  91     public enum Kind {
  92         INNER_CLASSES,
  93         ENUM_CONSTANTS,
  94         FIELDS,
  95         CONSTRUCTORS,
  96         METHODS,

  97         ANNOTATION_TYPE_MEMBER_OPTIONAL,
  98         ANNOTATION_TYPE_MEMBER_REQUIRED,
  99         PROPERTIES;
 100 
 101         public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
 102         public static final EnumSet&lt;Kind&gt; detailSet = EnumSet.range(ENUM_CONSTANTS, METHODS);
 103     }
 104 
 105     final TypeElement te;
 106     final TypeElement parent;
 107 
 108     final BaseConfiguration config;
 109     final BaseOptions options;
 110     final Utils utils;
 111     final VisibleMemberCache mcache;
 112 
 113     private List&lt;VisibleMemberTable&gt; allSuperclasses;
 114     private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
 115     private List&lt;VisibleMemberTable&gt; parents;
 116 


 117     private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
 118     private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
 119 
 120     // Keeps track of method overrides
 121     Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
 122             = new LinkedHashMap&lt;&gt;();
 123 
 124     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
 125                                  VisibleMemberCache mcache) {
 126         config = configuration;
 127         utils = configuration.utils;
 128         options = configuration.getOptions();
 129         te = typeElement;
 130         parent = utils.getSuperClass(te);
 131         this.mcache = mcache;
 132         allSuperclasses = new ArrayList&lt;&gt;();
 133         allSuperinterfaces = new ArrayList&lt;&gt;();
 134         parents = new ArrayList&lt;&gt;();
 135     }
 136 
 137     private synchronized void ensureInitialized() {
 138         if (visibleMembers != null)
 139             return;
 140 
 141         visibleMembers = new EnumMap&lt;&gt;(Kind.class);
 142         for (Kind kind : Kind.values()) {
 143             visibleMembers.put(kind, new ArrayList&lt;&gt;());
 144         }
 145         computeParents();
 146         computeVisibleMembers();
 147     }
 148 





 149     List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
 150         ensureInitialized();
 151         return allSuperclasses;
 152     }
 153 
 154     List&lt;VisibleMemberTable&gt; getAllSuperinterfaces() {
 155         ensureInitialized();
 156         return allSuperinterfaces;
 157     }
 158 
 159     /**
 160      * Returns a list of all visible enclosed members of a type element,
 161      * and inherited members.
 162      * &lt;p&gt;
 163      * Notes:
 164      * a. The list may or may not contain simple overridden methods.
 165      * A simple overridden method is one that overrides a super method
 166      * with no specification changes as indicated by the existence of a
 167      * sole &amp;commat;inheritDoc or devoid of any API comments.
 168      * &lt;p&gt;
</pre>
<hr />
<pre>
 262      * order C, B, A, j.l.O. The super-interfaces however are
 263      * alpha sorted and appended to the resulting set.
 264      *
 265      * @return the list of visible classes in this map.
 266      */
 267     public Set&lt;TypeElement&gt; getVisibleTypeElements() {
 268         ensureInitialized();
 269         Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;();
 270 
 271         // Add this type element first.
 272         result.add(te);
 273 
 274         // Add the super classes.
 275         allSuperclasses.stream()
 276                 .map(vmt -&gt; vmt.te)
 277                 .forEach(result::add);
 278 
 279         // ... and finally the sorted super interfaces.
 280         allSuperinterfaces.stream()
 281                 .map(vmt -&gt; vmt.te)
<span class="line-modified"> 282                 .sorted(utils.comparators.makeGeneralPurposeComparator())</span>
 283                 .forEach(result::add);
 284 
 285         return result;
 286     }
 287 
 288     /**
 289      * Returns true if this table contains visible members.
 290      *
 291      * @return true if visible members are present.
 292      */
 293     public boolean hasVisibleMembers() {
 294         for (Kind kind : Kind.values()) {
 295             if (hasVisibleMembers(kind))
 296                 return true;
 297         }
 298         return false;
 299     }
 300 
 301     /**
 302      * Returns true if this table contains visible members of
</pre>
<hr />
<pre>
 327      * @return the getter or null if absent
 328      */
 329     public ExecutableElement getPropertyGetter(ExecutableElement propertyMethod) {
 330         ensureInitialized();
 331         PropertyMembers pm =  propertyMap.get(propertyMethod);
 332         return pm == null ? null : pm.getter;
 333     }
 334 
 335     /**
 336      * Returns the setter method associated with the property method.
 337      * @param propertyMethod the identifying property method
 338      * @return the setter or null if absent
 339      */
 340     public ExecutableElement getPropertySetter(ExecutableElement propertyMethod) {
 341         ensureInitialized();
 342         PropertyMembers pm =  propertyMap.get(propertyMethod);
 343         return pm == null ? null : pm.setter;
 344     }
 345 
 346     private void computeParents() {
<span class="line-added"> 347         // suppress parents of annotation types</span>
<span class="line-added"> 348         if (utils.isAnnotationType(te)) {</span>
<span class="line-added"> 349             return;</span>
<span class="line-added"> 350         }</span>
<span class="line-added"> 351 </span>
 352         for (TypeMirror intfType : te.getInterfaces()) {
 353             TypeElement intfc = utils.asTypeElement(intfType);
 354             if (intfc != null) {
 355                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
 356                 allSuperinterfaces.add(vmt);
 357                 parents.add(vmt);
 358                 allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 359             }
 360         }
 361 
 362         if (parent != null) {
 363             VisibleMemberTable vmt = mcache.getVisibleMemberTable(parent);
 364             allSuperclasses.add(vmt);
 365             allSuperclasses.addAll(vmt.getAllSuperclasses());
 366             // Add direct super interfaces of a super class, if any.
 367             allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 368             parents.add(vmt);
 369         }
 370     }
 371 
 372     private void computeVisibleMembers() {
 373 
 374         // Note: these have some baggage, and are redundant,
 375         // allow this to be GC&#39;ed.
 376         LocalMemberTable lmt = new LocalMemberTable();
 377 
 378         for (Kind k : Kind.values()) {

 379             computeVisibleMembers(lmt, k);
 380         }
 381         // All members have been computed, compute properties.
 382         computeVisibleProperties(lmt);
 383     }
 384 








 385 
 386     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
 387         switch (kind) {
 388             case FIELDS: case INNER_CLASSES:
 389                 computeVisibleFieldsAndInnerClasses(lmt, kind);
 390                 return;
 391 
 392             case METHODS:
 393                 computeVisibleMethods(lmt);
 394                 return;
 395 
 396             // Defer properties related computations for later.
 397             case PROPERTIES:
 398                 return;
 399 
 400             default:
 401                 List&lt;Element&gt; list = lmt.getOrderedMembers(kind).stream()
 402                         .filter(this::mustDocument)
 403                         .collect(Collectors.toList());
 404                 visibleMembers.put(kind, Collections.unmodifiableList(list));
</pre>
<hr />
<pre>
 424 
 425         return true;
 426     }
 427 
 428     private boolean isMemberHidden(Element inheritedMember, Kind kind, LocalMemberTable lmt) {
 429         Elements elementUtils = config.docEnv.getElementUtils();
 430         switch(kind) {
 431             default:
 432                 List&lt;Element&gt; list = lmt.getMembers(inheritedMember, kind);
 433                 if (list.isEmpty())
 434                     return false;
 435                 return elementUtils.hides(list.get(0), inheritedMember);
 436             case METHODS: case CONSTRUCTORS: // Handled elsewhere.
 437                 throw new IllegalArgumentException(&quot;incorrect kind&quot;);
 438         }
 439     }
 440 
 441     private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
 442         Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 443         for (VisibleMemberTable pvmt : parents) {

 444             result.addAll(pvmt.getAllVisibleMembers(kind));
 445         }
 446 
 447         // Filter out members in the inherited list that are hidden
 448         // by this type or should not be inherited at all.
 449         List&lt;Element&gt; list = result.stream()
 450                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))
 451                 .collect(Collectors.toList());
 452 
 453         // Prefix local results first
 454         list.addAll(0, lmt.getOrderedMembers(kind));
 455 
 456         // Filter out elements that should not be documented
 457         list = list.stream()
 458                 .filter(this::mustDocument)
 459                 .collect(Collectors.toList());
 460 
 461         visibleMembers.put(kind, Collections.unmodifiableList(list));
 462     }
 463 
 464     private void computeVisibleMethods(LocalMemberTable lmt) {
 465         Set&lt;Element&gt; inheritedMethods = new LinkedHashSet&lt;&gt;();
 466         Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; overriddenByTable = new HashMap&lt;&gt;();
 467         for (VisibleMemberTable pvmt : parents) {
 468             // Merge the lineage overrides into local table
 469             pvmt.overriddenMethodTable.entrySet().forEach(e -&gt; {
 470                 OverridingMethodInfo p = e.getValue();
 471                 if (!p.simpleOverride) { // consider only real overrides
 472                     List&lt;ExecutableElement&gt; list = overriddenByTable.computeIfAbsent(p.overrider,
 473                             k -&gt; new ArrayList&lt;&gt;());
 474                     list.add(e.getKey());
 475                 }
 476             });
 477             inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));


























 478         }
 479 
 480         // Filter out inherited methods that:
 481         // a. cannot override (private instance members)
 482         // b. are overridden and should not be visible in this type
 483         // c. are hidden in the type being considered
 484         // see allowInheritedMethods, which performs the above actions
 485         List&lt;Element&gt; list = inheritedMethods.stream()
 486                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))
 487                 .collect(Collectors.toList());
 488 
 489         // Filter out the local methods, that do not override or simply
 490         // overrides a super method, or those methods that should not
 491         // be visible.
 492         Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
 493             OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
 494             return p == null || !p.simpleOverride;
 495         };
<span class="line-modified"> 496         List&lt;Element&gt; localList = lmt.getOrderedMembers(Kind.METHODS)</span>
<span class="line-modified"> 497                 .stream()</span>
 498                 .map(m -&gt; (ExecutableElement)m)
 499                 .filter(isVisible)
 500                 .collect(Collectors.toList());
 501 
<span class="line-modified"> 502         // Merge the above lists, making sure the local methods precede the others</span>
<span class="line-modified"> 503         list.addAll(0, localList);</span>

 504 
 505         // Final filtration of elements
 506         list = list.stream()
 507                 .filter(this::mustDocument)
 508                 .collect(Collectors.toList());
 509 
 510         visibleMembers.put(Kind.METHODS, Collections.unmodifiableList(list));
 511 
 512         // Copy over overridden tables from the lineage, and finish up.
 513         for (VisibleMemberTable pvmt : parents) {
 514             overriddenMethodTable.putAll(pvmt.overriddenMethodTable);
 515         }
 516         overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);
 517     }
 518 
 519     boolean isEnclosureInterface(Element e) {
 520         TypeElement enclosing = utils.getEnclosingTypeElement(e);
 521         return utils.isInterface(enclosing);
 522     }
 523 
</pre>
<hr />
<pre>
 616 
 617         LocalMemberTable() {
 618             orderedMembers = new EnumMap&lt;&gt;(Kind.class);
 619             memberMap = new EnumMap&lt;&gt;(Kind.class);
 620 
 621             List&lt;? extends Element&gt; elements = te.getEnclosedElements();
 622             for (Element e : elements) {
 623                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {
 624                     continue;
 625                 }
 626                 switch (e.getKind()) {
 627                     case CLASS:
 628                     case INTERFACE:
 629                     case ENUM:
 630                     case ANNOTATION_TYPE:
 631                     case RECORD:
 632                         addMember(e, Kind.INNER_CLASSES);
 633                         break;
 634                     case FIELD:
 635                         addMember(e, Kind.FIELDS);

 636                         break;
 637                     case METHOD:

 638                         if (utils.isAnnotationType(te)) {
<span class="line-added"> 639                             ExecutableElement ee = (ExecutableElement) e;</span>
 640                             addMember(e, ee.getDefaultValue() == null
 641                                     ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
 642                                     : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
<span class="line-added"> 643                         } else {</span>
<span class="line-added"> 644                             addMember(e, Kind.METHODS);</span>
 645                         }

 646                         break;
 647                     case CONSTRUCTOR:
 648                             addMember(e, Kind.CONSTRUCTORS);
 649                         break;
 650                     case ENUM_CONSTANT:
 651                         addMember(e, Kind.ENUM_CONSTANTS);
 652                         break;
 653                 }
 654             }
 655 
 656             // Freeze the data structures
 657             for (Kind kind : Kind.values()) {
 658                 orderedMembers.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableList(v));
 659                 orderedMembers.computeIfAbsent(kind, t -&gt; Collections.emptyList());
 660 
 661                 memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
 662                 memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
 663             }
 664         }
 665 
</pre>
<hr />
<pre>
 836         return imf.get();
 837     }
 838 
 839     public List&lt;ExecutableElement&gt; getImplementedMethods(ExecutableElement method) {
 840         ImplementedMethods imf = getImplementedMethodsFinder(method);
 841         return imf.getImplementedMethods().stream()
 842                 .filter(m -&gt; getSimplyOverriddenMethod(m) == null)
 843                 .collect(Collectors.toList());
 844     }
 845 
 846     public TypeMirror getImplementedMethodHolder(ExecutableElement method,
 847                                                  ExecutableElement implementedMethod) {
 848         ImplementedMethods imf = getImplementedMethodsFinder(method);
 849         return imf.getMethodHolder(implementedMethod);
 850     }
 851 
 852     private class ImplementedMethods {
 853 
 854         private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
 855         private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();


 856 
 857         public ImplementedMethods(ExecutableElement method) {
<span class="line-modified"> 858             TypeElement typeElement = utils.getEnclosingTypeElement(method);</span>

 859             Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
 860             /*
 861              * Search for the method in the list of interfaces. If found check if it is
 862              * overridden by any other subinterface method which this class
 863              * implements. If it is not overridden, add it in the method list.
 864              * Do this recursively for all the extended interfaces for each interface
 865              * from the list.
 866              */
 867             for (TypeMirror interfaceType : intfacs) {
 868                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
 869                 if (found != null) {
 870                     removeOverriddenMethod(found);
 871                     if (!overridingMethodFound(found)) {
 872                         methlist.add(found);
 873                         interfaces.put(found, interfaceType);
 874                     }
 875                 }
 876             }
 877         }
 878 
</pre>
</td>
</tr>
</table>
<center><a href="Utils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jconsole/share/classes/module-info.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
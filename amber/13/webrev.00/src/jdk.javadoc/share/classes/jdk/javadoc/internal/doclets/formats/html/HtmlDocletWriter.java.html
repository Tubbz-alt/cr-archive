<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.LinkedList;
  32 import java.util.List;
  33 import java.util.ListIterator;
  34 import java.util.Locale;
  35 import java.util.Map;
  36 import java.util.Set;
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  54 import javax.lang.model.util.SimpleElementVisitor14;
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
  89 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  90 import jdk.javadoc.internal.doclets.toolkit.Content;
  91 import jdk.javadoc.internal.doclets.toolkit.Messages;
  92 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  93 import jdk.javadoc.internal.doclets.toolkit.Resources;
  94 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  95 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
  96 import jdk.javadoc.internal.doclets.toolkit.util.Comparators;
  97 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  98 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 104 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 105 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 106 
 107 import static com.sun.source.doctree.DocTree.Kind.CODE;
 108 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 109 import static com.sun.source.doctree.DocTree.Kind.LINK;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 111 import static com.sun.source.doctree.DocTree.Kind.SEE;
 112 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 113 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 114 
 115 
 116 /**
 117  * Class for the Html Format Code Generation specific to JavaDoc.
 118  * This Class contains methods related to the Html Code Generation which
 119  * are used extensively while generating the entire documentation.
 120  *
 121  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 122  *  If you write code that depends on this, you do so at your own risk.
 123  *  This code and its internal interfaces are subject to change or
 124  *  deletion without notice.&lt;/b&gt;
 125  */
 126 public class HtmlDocletWriter {
 127 
 128     /**
 129      * Relative path from the file getting generated to the destination
 130      * directory. For example, if the file getting generated is
 131      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 132      * This string can be empty if the file getting generated is in
 133      * the destination directory.
 134      */
 135     public final DocPath pathToRoot;
 136 
 137     /**
 138      * Platform-independent path from the current or the
 139      * destination directory to the file getting generated.
 140      * Used when creating the file.
 141      */
 142     public final DocPath path;
 143 
 144     /**
 145      * Name of the file getting generated. If the file getting generated is
 146      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 147      */
 148     public final DocPath filename;
 149 
 150     /**
 151      * The global configuration information for this run.
 152      */
 153     public final HtmlConfiguration configuration;
 154 
 155     protected final SearchIndexItems searchItems;
 156 
 157     protected final HtmlOptions options;
 158 
 159     protected final Utils utils;
 160 
 161     protected final Contents contents;
 162 
 163     protected final Messages messages;
 164 
 165     protected final Resources resources;
 166 
 167     protected final Links links;
 168 
 169     protected final DocPaths docPaths;
 170 
 171     protected final Comparators comparators;
 172 
 173     /**
 174      * To check whether annotation heading is printed or not.
 175      */
 176     protected boolean printedAnnotationHeading = false;
 177 
 178     /**
 179      * To check whether annotation field heading is printed or not.
 180      */
 181     protected boolean printedAnnotationFieldHeading = false;
 182 
 183     /**
 184      * To check whether the repeated annotations is documented or not.
 185      */
 186     private boolean isAnnotationDocumented = false;
 187 
 188     /**
 189      * To check whether the container annotations is documented or not.
 190      */
 191     private boolean isContainerDocumented = false;
 192 
 193     /**
 194      * The window title of this file.
 195      */
 196     protected String winTitle;
 197 
 198     protected Script mainBodyScript;
 199 
 200     /**
 201      * A table of the anchors used for at-index and related tags,
 202      * so that they can be made unique by appending a suitable suffix.
 203      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 204      * to avoid generating duplicates.)
 205      */
 206     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 207 
 208     /**
 209      * Creates an {@code HtmlDocletWriter}.
 210      *
 211      * @param configuration the configuration for this doclet
 212      * @param path the file to be generated.
 213      */
 214     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 215         this.configuration = configuration;
 216         this.searchItems = configuration.searchItems;
 217         this.options = configuration.getOptions();
 218         this.contents = configuration.contents;
 219         this.messages = configuration.messages;
 220         this.resources = configuration.docResources;
 221         this.links = new Links(path);
 222         this.utils = configuration.utils;
 223         this.comparators = utils.comparators;
 224         this.path = path;
 225         this.pathToRoot = path.parent().invert();
 226         this.filename = path.basename();
 227         this.docPaths = configuration.docPaths;
 228         this.mainBodyScript = new Script();
 229 
 230         messages.notice(&quot;doclet.Generating_0&quot;,
 231             DocFile.createFileForOutput(configuration, path).getPath());
 232     }
 233 
 234     /**
 235      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 236      * as -header, -footer, -top and -bottom, and when converting a relative
 237      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 238      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 239      * comments.)
 240      * &lt;p&gt;
 241      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 242      * destination directory from the directory where the file is being
 243      * written, looping to handle all such tags in htmlstr.
 244      * &lt;p&gt;
 245      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 246      * the HTML page for source file p/C1.java is being generated, the
 247      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 248      * the relative path from docs/p/ to docs/ (the document root).
 249      * &lt;p&gt;
 250      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 251      * to prevent the inline tag from being interpreted.
 252      */
 253     public String replaceDocRootDir(String htmlstr) {
 254         // Return if no inline tags exist
 255         int index = htmlstr.indexOf(&quot;{@&quot;);
 256         if (index &lt; 0) {
 257             return htmlstr;
 258         }
 259         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 260         if (!docrootMatcher.find()) {
 261             return htmlstr;
 262         }
 263         StringBuilder buf = new StringBuilder();
 264         int prevEnd = 0;
 265         do {
 266             int match = docrootMatcher.start();
 267             // append htmlstr up to start of next {@docroot}
 268             buf.append(htmlstr.substring(prevEnd, match));
 269             prevEnd = docrootMatcher.end();
 270             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 271                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 272                 buf.append(options.docrootParent());
 273                 prevEnd += 3;
 274             } else {
 275                 // Insert relative path where {@docRoot} was located
 276                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 277             }
 278             // Append slash if next character is not a slash
 279             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 280                 buf.append(&#39;/&#39;);
 281             }
 282         } while (docrootMatcher.find());
 283         buf.append(htmlstr.substring(prevEnd));
 284         return buf.toString();
 285     }
 286     //where:
 287         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 288         private static final Pattern docrootPattern =
 289                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 290 
 291 
 292     /**
 293      * Add method information.
 294      *
 295      * @param method the method to be documented
 296      * @param dl the content tree to which the method information will be added
 297      */
 298     private void addMethodInfo(ExecutableElement method, Content dl) {
 299         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 300         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 301         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 302         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 303         // Check whether there is any implementation or overridden info to be
 304         // printed. If no overridden or implementation info needs to be
 305         // printed, do not print this section.
 306         if ((!intfacs.isEmpty()
 307                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 308                 || overriddenMethod != null) {
 309             MethodWriterImpl.addImplementsInfo(this, method, dl);
 310             if (overriddenMethod != null) {
 311                 MethodWriterImpl.addOverridden(this,
 312                         utils.overriddenType(method),
 313                         overriddenMethod,
 314                         dl);
 315             }
 316         }
 317     }
 318 
 319     /**
 320      * Adds the tags information.
 321      *
 322      * @param e the Element for which the tags will be generated
 323      * @param htmlTree the documentation tree to which the tags will be added
 324      */
 325     protected void addTagsInfo(Element e, Content htmlTree) {
 326         if (options.noComment()) {
 327             return;
 328         }
 329         HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);
 330         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 331             addMethodInfo((ExecutableElement)e, dl);
 332         }
 333         Content output = new ContentBuilder();
 334         TagletWriter.genTagOutput(configuration.tagletManager, e,
 335             configuration.tagletManager.getBlockTaglets(e),
 336                 getTagletWriterInstance(false), output);
 337         dl.add(output);
 338         htmlTree.add(dl);
 339     }
 340 
 341     /**
 342      * Check whether there are any tags for Serialization Overview
 343      * section to be printed.
 344      *
 345      * @param field the VariableElement object to check for tags.
 346      * @return true if there are tags to be printed else return false.
 347      */
 348     protected boolean hasSerializationOverviewTags(VariableElement field) {
 349         Content output = new ContentBuilder();
 350         TagletWriter.genTagOutput(configuration.tagletManager, field,
 351                 configuration.tagletManager.getBlockTaglets(field),
 352                 getTagletWriterInstance(false), output);
 353         return !output.isEmpty();
 354     }
 355 
 356     /**
 357      * Returns a TagletWriter that knows how to write HTML.
 358      *
 359      * @param isFirstSentence  true if we want to write the first sentence
 360      * @return a TagletWriter that knows how to write HTML.
 361      */
 362     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 363         return new TagletWriterImpl(this, isFirstSentence);
 364     }
 365 
 366     /**
 367      * Returns a TagletWriter that knows how to write HTML.
 368      *
 369      * @param isFirstSentence  true if we want to write the first sentence
 370      * @param inSummary  true if tags are to be added in a summary section
 371      * @return a TagletWriter
 372      */
 373     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 374         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 375     }
 376 
 377     /**
 378      * Generates the HTML document tree and prints it out.
 379      *
 380      * @param metakeywords Array of String keywords for META tag. Each element
 381      *                     of the array is assigned to a separate META tag.
 382      *                     Pass in null for no array
 383      * @param description the content for the description META tag.
 384      * @param body the body htmltree to be included in the document
 385      * @throws DocFileIOException if there is a problem writing the file
 386      */
 387     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 388                                   String description,
 389                                   Content body)
 390             throws DocFileIOException {
 391         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);
 392     }
 393 
 394     /**
 395      * Generates the HTML document tree and prints it out.
 396      *
 397      * @param metakeywords Array of String keywords for META tag. Each element
 398      *                     of the array is assigned to a separate META tag.
 399      *                     Pass in null for no array
 400      * @param description the content for the description META tag.
 401      * @param localStylesheets local stylesheets to be included in the HEAD element
 402      * @param body the body htmltree to be included in the document
 403      * @throws DocFileIOException if there is a problem writing the file
 404      */
 405     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 406                                   String description,
 407                                   List&lt;DocPath&gt; localStylesheets,
 408                                   Content body)
 409             throws DocFileIOException {
 410         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);
 411     }
 412 
 413     /**
 414      * Generates the HTML document tree and prints it out.
 415      *
 416      * @param metakeywords Array of String keywords for META tag. Each element
 417      *                     of the array is assigned to a separate META tag.
 418      *                     Pass in null for no array
 419      * @param description the content for the description META tag.
 420      * @param extraHeadContent any additional content to be included in the HEAD element
 421      * @param localStylesheets local stylesheets to be included in the HEAD element
 422      * @param body the body htmltree to be included in the document
 423      * @throws DocFileIOException if there is a problem writing the file
 424      */
 425     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 426                                   String description,
 427                                   Content extraHeadContent,
 428                                   List&lt;DocPath&gt; localStylesheets,
 429                                   Content body)
 430             throws DocFileIOException {
 431         Content htmlComment = contents.newPage;
 432         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 433         additionalStylesheets.addAll(localStylesheets);
 434         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 435                 .setTimestamp(!options.noTimestamp())
 436                 .setDescription(description)
 437                 .setGenerator(getGenerator(getClass()))
 438                 .setTitle(winTitle)
 439                 .setCharset(options.charset())
 440                 .addKeywords(metakeywords)
 441                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 442                 .setIndex(options.createIndex(), mainBodyScript)
 443                 .addContent(extraHeadContent);
 444 
 445         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head, body);
 446         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 447         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 448     }
 449 
 450     /**
 451      * Get the window title.
 452      *
 453      * @param title the title string to construct the complete window title
 454      * @return the window title string
 455      */
 456     public String getWindowTitle(String title) {
 457         if (options.windowTitle().length() &gt; 0) {
 458             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 459         }
 460         return title;
 461     }
 462 
 463     /**
 464      * Get user specified header and the footer.
 465      *
 466      * @param header if true print the user provided header else print the
 467      * user provided footer.
 468      */
 469     public Content getUserHeaderFooter(boolean header) {
 470         String content;
 471         if (header) {
 472             content = replaceDocRootDir(options.header());
 473         } else {
 474             if (options.footer().length() != 0) {
 475                 content = replaceDocRootDir(options.footer());
 476             } else {
 477                 content = replaceDocRootDir(options.header());
 478             }
 479         }
 480         Content rawContent = new RawHtml(content);
 481         return rawContent;
 482     }
 483 
 484     /**
 485      * Adds the user specified top.
 486      *
 487      * @param htmlTree the content tree to which user specified top will be added
 488      */
 489     public void addTop(Content htmlTree) {
 490         Content top = new RawHtml(replaceDocRootDir(options.top()));
 491         htmlTree.add(top);
 492     }
 493 
 494     /**
 495      * Adds the user specified bottom.
 496      *
 497      * @param htmlTree the content tree to which user specified bottom will be added
 498      */
 499     public void addBottom(Content htmlTree) {
 500         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));
 501         Content small = HtmlTree.SMALL(bottom);
 502         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 503         htmlTree.add(p);
 504     }
 505 
 506     /**
 507      * Get the overview tree link for the main tree.
 508      *
 509      * @param label the label for the link
 510      * @return a content tree for the link
 511      */
 512     protected Content getNavLinkMainTree(String label) {
 513         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 514                 new StringContent(label));
 515         Content li = HtmlTree.LI(mainTreeContent);
 516         return li;
 517     }
 518 
 519     /**
 520      * Get table caption.
 521      *
 522      * @param title the content for the caption
 523      * @return a content tree for the caption
 524      */
 525     public Content getTableCaption(Content title) {
 526         Content captionSpan = HtmlTree.SPAN(title);
 527         Content space = Entity.NO_BREAK_SPACE;
 528         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 529         Content caption = HtmlTree.CAPTION(captionSpan);
 530         caption.add(tabSpan);
 531         return caption;
 532     }
 533 
 534     /**
 535      * Returns a packagename content.
 536      *
 537      * @param packageElement the package to check
 538      * @return package name content
 539      */
 540     public Content getPackageName(PackageElement packageElement) {
 541         return packageElement == null || packageElement.isUnnamed()
 542                 ? contents.defaultPackageLabel
 543                 : getPackageLabel(packageElement.getQualifiedName());
 544     }
 545 
 546     /**
 547      * Returns a package name label.
 548      *
 549      * @param packageName the package name
 550      * @return the package name content
 551      */
 552     public Content getPackageLabel(CharSequence packageName) {
 553         return new StringContent(packageName);
 554     }
 555 
 556     /**
 557      * Return the path to the class page for a typeElement.
 558      *
 559      * @param te   TypeElement for which the path is requested.
 560      * @param name Name of the file(doesn&#39;t include path).
 561      */
 562     protected DocPath pathString(TypeElement te, DocPath name) {
 563         return pathString(utils.containingPackage(te), name);
 564     }
 565 
 566     /**
 567      * Return path to the given file name in the given package. So if the name
 568      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 569      * if the relative path is &quot;../..&quot; then returned string will be
 570      * &quot;../../java/lang/Object.html&quot;
 571      *
 572      * @param packageElement Package in which the file name is assumed to be.
 573      * @param name File name, to which path string is.
 574      */
 575     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 576         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 577     }
 578 
 579     /**
 580      * Given a package, return the name to be used in HTML anchor tag.
 581      * @param packageElement the package.
 582      * @return the name to be used in HTML anchor tag.
 583      */
 584     public String getPackageAnchorName(PackageElement packageElement) {
 585         return packageElement == null || packageElement.isUnnamed()
 586                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 587                 : utils.getPackageName(packageElement);
 588     }
 589 
 590     /**
 591      * Return the link to the given package.
 592      *
 593      * @param packageElement the package to link to.
 594      * @param label the label for the link.
 595      * @return a content tree for the package link.
 596      */
 597     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 598         return getPackageLink(packageElement, new StringContent(label));
 599     }
 600 
 601     public Content getPackageLink(PackageElement packageElement) {
 602         StringContent content =  packageElement.isUnnamed()
 603                 ? new StringContent()
 604                 : new StringContent(utils.getPackageName(packageElement));
 605         return getPackageLink(packageElement, content);
 606     }
 607 
 608     /**
 609      * Return the link to the given package.
 610      *
 611      * @param packageElement the package to link to.
 612      * @param label the label for the link.
 613      * @return a content tree for the package link.
 614      */
 615     public Content getPackageLink(PackageElement packageElement, Content label) {
 616         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 617         if (!included) {
 618             for (PackageElement p : configuration.packages) {
 619                 if (p.equals(packageElement)) {
 620                     included = true;
 621                     break;
 622                 }
 623             }
 624         }
 625         if (included || packageElement == null) {
 626             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 627                     label);
 628         } else {
 629             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 630             if (crossPkgLink != null) {
 631                 return links.createLink(crossPkgLink, label);
 632             } else {
 633                 return label;
 634             }
 635         }
 636     }
 637 
 638     /**
 639      * Get Module link.
 640      *
 641      * @param mdle the module being documented
 642      * @param label tag for the link
 643      * @return a content for the module link
 644      */
 645     public Content getModuleLink(ModuleElement mdle, Content label) {
 646         boolean included = utils.isIncluded(mdle);
 647         return (included)
 648                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 649                 : label;
 650     }
 651 
 652     public Content interfaceName(TypeElement typeElement, boolean qual) {
 653         Content name = new StringContent((qual)
 654                 ? typeElement.getQualifiedName()
 655                 : utils.getSimpleName(typeElement));
 656         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 657     }
 658 
 659     /**
 660      * Add the link to the content tree.
 661      *
 662      * @param element program element for which the link will be added
 663      * @param label label for the link
 664      * @param htmltree the content tree to which the link will be added
 665      */
 666     public void addSrcLink(Element element, Content label, Content htmltree) {
 667         if (element == null) {
 668             return;
 669         }
 670         TypeElement te = utils.getEnclosingTypeElement(element);
 671         if (te == null) {
 672             // must be a typeElement since in has no containing class.
 673             te = (TypeElement) element;
 674         }
 675         if (utils.isIncluded(te)) {
 676             DocPath href = pathToRoot
 677                     .resolve(DocPaths.SOURCE_OUTPUT)
 678                     .resolve(docPaths.forClass(te));
 679             Content content = links.createLink(href
 680                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 681             htmltree.add(content);
 682         } else {
 683             htmltree.add(label);
 684         }
 685     }
 686 
 687     /**
 688      * Return the link to the given class.
 689      *
 690      * @param linkInfo the information about the link.
 691      *
 692      * @return the link for the given class.
 693      */
 694     public Content getLink(LinkInfoImpl linkInfo) {
 695         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 696         return factory.getLink(linkInfo);
 697     }
 698 
 699     /**
 700      * Return the type parameters for the given class.
 701      *
 702      * @param linkInfo the information about the link.
 703      * @return the type for the given class.
 704      */
 705     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 706         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 707         return factory.getTypeParameterLinks(linkInfo, false);
 708     }
 709 
 710     /*************************************************************
 711      * Return a class cross link to external class documentation.
 712      * The -link option does not allow users to
 713      * link to external classes in the &quot;default&quot; package.
 714      *
 715      * @param classElement the class element
 716      * @param refMemName the name of the member being referenced.  This should
 717      * be null or empty string if no member is being referenced.
 718      * @param label the label for the external link.
 719      * @param strong true if the link should be strong.
 720      * @param code true if the label should be code font.
 721      * @return the link
 722      */
 723     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 724                                     Content label, boolean strong, boolean code) {
 725         if (classElement != null) {
 726             String className = utils.getSimpleName(classElement);
 727             PackageElement packageElement = utils.containingPackage(classElement);
 728             Content defaultLabel = new StringContent(className);
 729             if (code)
 730                 defaultLabel = HtmlTree.CODE(defaultLabel);
 731             if (getCrossPackageLink(packageElement) != null) {
 732                 /*
 733                 The package exists in external documentation, so link to the external
 734                 class (assuming that it exists).  This is definitely a limitation of
 735                 the -link option.  There are ways to determine if an external package
 736                 exists, but no way to determine if the external class exists.  We just
 737                 have to assume that it does.
 738                 */
 739                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 740                                 className + &quot;.html&quot;, refMemName);
 741                 return links.createLink(link,
 742                     (label == null) || label.isEmpty() ? defaultLabel : label,
 743                     strong,
 744                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 745                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 746             }
 747         }
 748         return null;
 749     }
 750 
 751     public boolean isClassLinkable(TypeElement typeElement) {
 752         if (utils.isIncluded(typeElement)) {
 753             return configuration.isGeneratedDoc(typeElement);
 754         }
 755         return configuration.extern.isExternal(typeElement);
 756     }
 757 
 758     public DocLink getCrossPackageLink(PackageElement element) {
 759         return configuration.extern.getExternalLink(element, pathToRoot,
 760             DocPaths.PACKAGE_SUMMARY.getPath());
 761     }
 762 
 763     public DocLink getCrossModuleLink(ModuleElement element) {
 764         return configuration.extern.getExternalLink(element, pathToRoot,
 765             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 766     }
 767 
 768     /**
 769      * Get the class link.
 770      *
 771      * @param context the id of the context where the link will be added
 772      * @param element to link to
 773      * @return a content tree for the link
 774      */
 775     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 776         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 777         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 778     }
 779 
 780     /**
 781      * Add the class link.
 782      *
 783      * @param context the id of the context where the link will be added
 784      * @param typeElement to link to
 785      * @param contentTree the content tree to which the link will be added
 786      */
 787     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 788         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 789     }
 790 
 791     /**
 792      * Retrieve the class link with the package portion of the label in
 793      * plain text.  If the qualifier is excluded, it will not be included in the
 794      * link label.
 795      *
 796      * @param typeElement the class to link to.
 797      * @param isStrong true if the link should be strong.
 798      * @return the link with the package portion of the label in plain text.
 799      */
 800     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 801             TypeElement typeElement, boolean isStrong) {
 802         ContentBuilder classlink = new ContentBuilder();
 803         PackageElement pkg = utils.containingPackage(typeElement);
 804         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 805             classlink.add(getEnclosingPackageName(typeElement));
 806         }
 807         classlink.add(getLink(new LinkInfoImpl(configuration,
 808                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 809         return classlink;
 810     }
 811 
 812     /**
 813      * Add the class link with the package portion of the label in
 814      * plain text. If the qualifier is excluded, it will not be included in the
 815      * link label.
 816      *
 817      * @param context the id of the context where the link will be added
 818      * @param typeElement the class to link to
 819      * @param isStrong true if the link should be strong
 820      * @param contentTree the content tree to which the link with be added
 821      */
 822     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 823             TypeElement typeElement, boolean isStrong, Content contentTree) {
 824         PackageElement pkg = utils.containingPackage(typeElement);
 825         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 826             contentTree.add(getEnclosingPackageName(typeElement));
 827         }
 828         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 829                 .label(utils.getSimpleName(typeElement))
 830                 .strong(isStrong);
 831         Content link = getLink(linkinfo);
 832         contentTree.add(link);
 833     }
 834 
 835     /**
 836      * Get the enclosed name of the package
 837      *
 838      * @param te  TypeElement
 839      * @return the name
 840      */
 841     public String getEnclosingPackageName(TypeElement te) {
 842 
 843         PackageElement encl = configuration.utils.containingPackage(te);
 844         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 845     }
 846 
 847     /**
 848      * Return the main type element of the current page or null for pages that don&#39;t have one.
 849      *
 850      * @return the type element of the current page.
 851      */
 852     protected TypeElement getCurrentPageElement() {
 853         return null;
 854     }
 855 
 856     /**
 857      * Add the class link, with only class name as the strong link and prefixing
 858      * plain package name.
 859      *
 860      * @param context the id of the context where the link will be added
 861      * @param typeElement the class to link to
 862      * @param contentTree the content tree to which the link with be added
 863      */
 864     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 865         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 866     }
 867 
 868     /**
 869      * Get the link for the given member.
 870      *
 871      * @param context the id of the context where the link will be added
 872      * @param element the member being linked to
 873      * @param label the label for the link
 874      * @return a content tree for the element link
 875      */
 876     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 877         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 878                 new StringContent(label));
 879     }
 880 
 881     /**
 882      * Return the link for the given member.
 883      *
 884      * @param context the id of the context where the link will be printed.
 885      * @param element the member being linked to.
 886      * @param label the label for the link.
 887      * @param strong true if the link should be strong.
 888      * @return the link for the given member.
 889      */
 890     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 891             boolean strong) {
 892         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 893     }
 894 
 895     /**
 896      * Return the link for the given member.
 897      *
 898      * @param context the id of the context where the link will be printed.
 899      * @param typeElement the typeElement that we should link to.  This is not
 900                  necessarily equal to element.containingClass().  We may be
 901                  inheriting comments.
 902      * @param element the member being linked to.
 903      * @param label the label for the link.
 904      * @param strong true if the link should be strong.
 905      * @return the link for the given member.
 906      */
 907     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 908             CharSequence label, boolean strong) {
 909         return getDocLink(context, typeElement, element, label, strong, false);
 910     }
 911 
 912     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 913             Content label, boolean strong) {
 914         return getDocLink(context, typeElement, element, label, strong, false);
 915     }
 916 
 917     /**
 918      * Return the link for the given member.
 919      *
 920      * @param context the id of the context where the link will be printed.
 921      * @param typeElement the typeElement that we should link to.  This is not
 922                  necessarily equal to element.containingClass().  We may be
 923                  inheriting comments.
 924      * @param element the member being linked to.
 925      * @param label the label for the link.
 926      * @param strong true if the link should be strong.
 927      * @param isProperty true if the element parameter is a JavaFX property.
 928      * @return the link for the given member.
 929      */
 930     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 931             CharSequence label, boolean strong, boolean isProperty) {
 932         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 933     }
 934 
 935     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 936             Content label, boolean strong, boolean isProperty) {
 937         if (!utils.isLinkable(typeElement, element)) {
 938             return label;
 939         }
 940 
 941         if (utils.isExecutableElement(element)) {
 942             ExecutableElement ee = (ExecutableElement)element;
 943             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 944                 .label(label)
 945                 .where(links.getName(getAnchor(ee, isProperty)))
 946                 .strong(strong));
 947         }
 948 
 949         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 950             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 951                 .label(label)
 952                 .where(links.getName(element.getSimpleName().toString()))
 953                 .strong(strong));
 954         }
 955 
 956         return label;
 957     }
 958 
 959     /**
 960      * Return the link for the given member.
 961      *
 962      * @param context the id of the context where the link will be added
 963      * @param typeElement the typeElement that we should link to.  This is not
 964                  necessarily equal to element.containingClass().  We may be
 965                  inheriting comments
 966      * @param element the member being linked to
 967      * @param label the label for the link
 968      * @return the link for the given member
 969      */
 970     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 971             Content label) {
 972         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 973             return label;
 974         } else if (utils.isExecutableElement(element)) {
 975             ExecutableElement emd = (ExecutableElement) element;
 976             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 977                 .label(label)
 978                 .where(links.getName(getAnchor(emd))));
 979         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 980             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 981                 .label(label).where(links.getName(element.getSimpleName().toString())));
 982         } else {
 983             return label;
 984         }
 985     }
 986 
 987     public String getAnchor(ExecutableElement executableElement) {
 988         return getAnchor(executableElement, false);
 989     }
 990 
 991     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
 992         if (isProperty) {
 993             return executableElement.getSimpleName().toString();
 994         }
 995         String member = anchorName(executableElement);
 996         String erasedSignature = utils.makeSignature(executableElement, null, true, true);
 997         return member + erasedSignature;
 998     }
 999 
1000     public String anchorName(Element member) {
1001         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1002             return &quot;&lt;init&gt;&quot;;
1003         } else {
1004             return utils.getSimpleName(member);
1005         }
1006     }
1007 
1008     public Content seeTagToContent(Element element, DocTree see) {
1009         Kind kind = see.getKind();
1010         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1011             return new ContentBuilder();
1012         }
1013 
1014         CommentHelper ch = utils.getCommentHelper(element);
1015         String tagName = ch.getTagName(see);
1016         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1017         // Check if @see is an href or &quot;string&quot;
1018         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1019             return new RawHtml(seetext);
1020         }
1021         boolean isLinkPlain = kind == LINK_PLAIN;
1022         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));
1023 
1024         //The text from the @see tag.  We will output this text when a label is not specified.
1025         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1026 
1027         TypeElement refClass = ch.getReferencedClass(see);
1028         String refClassName =  ch.getReferencedClassName(see);
1029         Element refMem =       ch.getReferencedMember(see);
1030         String refMemName =    ch.getReferencedMemberName(see);
1031 
1032         if (refMemName == null &amp;&amp; refMem != null) {
1033             refMemName = refMem.toString();
1034         }
1035         if (refClass == null) {
1036             //@see is not referencing an included class
1037             PackageElement refPackage = ch.getReferencedPackage(see);
1038             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1039                 //@see is referencing an included package
1040                 if (label.isEmpty())
1041                     label = plainOrCode(isLinkPlain,
1042                             new StringContent(refPackage.getQualifiedName()));
1043                 return getPackageLink(refPackage, label);
1044             } else {
1045                 // @see is not referencing an included class, module or package. Check for cross links.
1046                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1047                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1048                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1049                 if (elementCrossLink != null) {
1050                     // Element cross link found
1051                     return links.createLink(elementCrossLink,
1052                             (label.isEmpty() ? text : label), true);
1053                 } else {
1054                     // No cross link found so print warning
1055                     messages.warning(ch.getDocTreePath(see),
1056                             &quot;doclet.see.class_or_package_not_found&quot;,
1057                             &quot;@&quot; + tagName,
1058                             seetext);
1059                     return (label.isEmpty() ? text: label);
1060                 }
1061             }
1062         } else if (refMemName == null) {
1063             // Must be a class reference since refClass is not null and refMemName is null.
1064             if (label.isEmpty()) {
1065                 /*
1066                  * it seems to me this is the right thing to do, but it causes comparator failures.
1067                  */
1068                 if (!configuration.backwardCompatibility) {
1069                     StringContent content = utils.isEnclosingPackageIncluded(refClass)
1070                             ? new StringContent(utils.getSimpleName(refClass))
1071                             : new StringContent(utils.getFullyQualifiedName(refClass));
1072                     label = plainOrCode(isLinkPlain, content);
1073                 } else {
1074                     label = plainOrCode(isLinkPlain,
1075                             new StringContent(utils.getSimpleName(refClass)));
1076                 }
1077 
1078             }
1079             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1080                     .label(label));
1081         } else if (refMem == null) {
1082             // Must be a member reference since refClass is not null and refMemName is not null.
1083             // However, refMem is null, so this referenced member does not exist.
1084             return (label.isEmpty() ? text: label);
1085         } else {
1086             // Must be a member reference since refClass is not null and refMemName is not null.
1087             // refMem is not null, so this @see tag must be referencing a valid member.
1088             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1089 
1090             // Find the enclosing type where the method is actually visible
1091             // in the inheritance hierarchy.
1092             ExecutableElement overriddenMethod = null;
1093             if (refMem.getKind() == ElementKind.METHOD) {
1094                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1095                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1096 
1097                 if (overriddenMethod != null)
1098                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1099             }
1100             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1101                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1102                 // Since the link is relative and the holder is not even being
1103                 // documented, this must be an inherited link.  Redirect it.
1104                 // The current class either overrides the referenced member or
1105                 // inherits it automatically.
1106                 if (this instanceof ClassWriterImpl) {
1107                     containing = ((ClassWriterImpl) this).getTypeElement();
1108                 } else if (!utils.isPublic(containing)) {
1109                     messages.warning(
1110                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1111                         tagName, utils.getFullyQualifiedName(containing));
1112                 } else {
1113                     messages.warning(
1114                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1115                         tagName, seetext);
1116                 }
1117             }
1118             if (configuration.currentTypeElement != containing) {
1119                 refMemName = (utils.isConstructor(refMem))
1120                         ? refMemName
1121                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1122             }
1123             if (utils.isExecutableElement(refMem)) {
1124                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
1125                     refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);
1126                 }
1127                 if (overriddenMethod != null) {
1128                     // The method to actually link.
1129                     refMem = overriddenMethod;
1130                 }
1131             }
1132 
1133             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1134 
1135             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1136                     refMem, (label.isEmpty() ? text: label), false);
1137         }
1138     }
1139 
1140     private Content plainOrCode(boolean plain, Content body) {
1141         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1142     }
1143 
1144     /**
1145      * Add the inline comment.
1146      *
1147      * @param element the Element for which the inline comment will be added
1148      * @param tag the inline tag to be added
1149      * @param htmltree the content tree to which the comment will be added
1150      */
1151     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1152         CommentHelper ch = utils.getCommentHelper(element);
1153         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);
1154         addCommentTags(element, tag, description, false, false, false, htmltree);
1155     }
1156 
1157     /**
1158      * Get the deprecated phrase as content.
1159      *
1160      * @param e the Element for which the inline deprecated comment will be added
1161      * @return a content tree for the deprecated phrase.
1162      */
1163     public Content getDeprecatedPhrase(Element e) {
1164         return (utils.isDeprecatedForRemoval(e))
1165                 ? contents.deprecatedForRemovalPhrase
1166                 : contents.deprecatedPhrase;
1167     }
1168 
1169     /**
1170      * Add the inline deprecated comment.
1171      *
1172      * @param e the Element for which the inline deprecated comment will be added
1173      * @param tag the inline tag to be added
1174      * @param htmltree the content tree to which the comment will be added
1175      */
1176     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1177         CommentHelper ch = utils.getCommentHelper(e);
1178         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);
1179     }
1180 
1181     /**
1182      * Adds the summary content.
1183      *
1184      * @param element the Element for which the summary will be generated
1185      * @param htmltree the documentation tree to which the summary will be added
1186      */
1187     public void addSummaryComment(Element element, Content htmltree) {
1188         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1189     }
1190 
1191     /**
1192      * Adds the summary content.
1193      *
1194      * @param element the Element for which the summary will be generated
1195      * @param firstSentenceTags the first sentence tags for the doc
1196      * @param htmltree the documentation tree to which the summary will be added
1197      */
1198     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1199         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1200     }
1201 
1202     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1203         CommentHelper ch = utils.getCommentHelper(element);
1204         List&lt;? extends DocTree&gt; body = ch.getBody(tag);
1205         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);
1206     }
1207 
1208     /**
1209      * Adds the inline comment.
1210      *
1211      * @param element the Element for which the inline comments will be generated
1212      * @param htmltree the documentation tree to which the inline comments will be added
1213      */
1214     public void addInlineComment(Element element, Content htmltree) {
1215         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1216     }
1217 
1218     /**
1219      * Adds the comment tags.
1220      *
1221      * @param element the Element for which the comment tags will be generated
1222      * @param tags the first sentence tags for the doc
1223      * @param depr true if it is deprecated
1224      * @param first true if the first sentence tags should be added
1225      * @param inSummary true if the comment tags are added into the summary section
1226      * @param htmltree the documentation tree to which the comment tags will be added
1227      */
1228     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1229             boolean first, boolean inSummary, Content htmltree) {
1230         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1231     }
1232 
1233     /**
1234      * Adds the comment tags.
1235      *
1236      * @param element for which the comment tags will be generated
1237      * @param holderTag the block tag context for the inline tags
1238      * @param tags the first sentence tags for the doc
1239      * @param depr true if it is deprecated
1240      * @param first true if the first sentence tags should be added
1241      * @param inSummary true if the comment tags are added into the summary section
1242      * @param htmltree the documentation tree to which the comment tags will be added
1243      */
1244     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1245             boolean first, boolean inSummary, Content htmltree) {
1246         if (options.noComment()){
1247             return;
1248         }
1249         Content div;
1250         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1251         if (depr) {
1252             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1253             htmltree.add(div);
1254         }
1255         else {
1256             div = HtmlTree.DIV(HtmlStyle.block, result);
1257             htmltree.add(div);
1258         }
1259         if (tags.isEmpty()) {
1260             htmltree.add(Entity.NO_BREAK_SPACE);
1261         }
1262     }
1263 
1264     boolean ignoreNonInlineTag(DocTree dtree) {
1265         Name name = null;
1266         if (dtree.getKind() == Kind.START_ELEMENT) {
1267             StartElementTree setree = (StartElementTree)dtree;
1268             name = setree.getName();
1269         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1270             EndElementTree eetree = (EndElementTree)dtree;
1271             name = eetree.getName();
1272         }
1273 
1274         if (name != null) {
1275             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1276             if (htmlTag != null &amp;&amp;
1277                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1278                 return true;
1279             }
1280         }
1281         return false;
1282     }
1283 
1284     boolean isAllWhiteSpace(String body) {
1285         for (int i = 0 ; i &lt; body.length(); i++) {
1286             if (!Character.isWhitespace(body.charAt(i)))
1287                 return false;
1288         }
1289         return true;
1290     }
1291 
1292     // Notify the next DocTree handler to take necessary action
1293     private boolean commentRemoved = false;
1294 
1295     /**
1296      * Converts inline tags and text to Content, expanding the
1297      * inline tags along the way.  Called wherever text can contain
1298      * an inline tag, such as in comments or in free-form text arguments
1299      * to block tags.
1300      *
1301      * @param holderTag    specific tag where comment resides
1302      * @param element    specific element where comment resides
1303      * @param tags   array of text tags and inline tags (often alternating)
1304                present in the text of interest for this element
1305      * @param isFirstSentence  true if text is first sentence
1306      * @return a Content object
1307      */
1308     public Content commentTagsToContent(DocTree holderTag,
1309                                         Element element,
1310                                         List&lt;? extends DocTree&gt; tags,
1311                                         boolean isFirstSentence)
1312     {
1313         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1314     }
1315 
1316     /**
1317      * Converts inline tags and text to text strings, expanding the
1318      * inline tags along the way.  Called wherever text can contain
1319      * an inline tag, such as in comments or in free-form text arguments
1320      * to block tags.
1321      *
1322      * @param holderTag       specific tag where comment resides
1323      * @param element         specific element where comment resides
1324      * @param trees           array of text tags and inline tags (often alternating)
1325      *                        present in the text of interest for this element
1326      * @param isFirstSentence true if text is first sentence
1327      * @param inSummary       if the comment tags are added into the summary section
1328      * @return a Content object
1329      */
1330     public Content commentTagsToContent(DocTree holderTag,
1331                                         Element element,
1332                                         List&lt;? extends DocTree&gt; trees,
1333                                         boolean isFirstSentence,
1334                                         boolean inSummary)
1335     {
1336         final Content result = new ContentBuilder() {
1337             @Override
1338             public ContentBuilder add(CharSequence text) {
1339                 return super.add(utils.normalizeNewlines(text));
1340             }
1341         };
1342         CommentHelper ch = utils.getCommentHelper(element);
1343         // Array of all possible inline tags for this javadoc run
1344         configuration.tagletManager.checkTags(element, trees, true);
1345         commentRemoved = false;
1346 
1347         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1348             boolean isFirstNode = !iterator.hasPrevious();
1349             DocTree tag = iterator.next();
1350             boolean isLastNode  = !iterator.hasNext();
1351 
1352             if (isFirstSentence) {
1353                 // Ignore block tags
1354                 if (ignoreNonInlineTag(tag))
1355                     continue;
1356 
1357                 // Ignore any trailing whitespace OR whitespace after removed html comment
1358                 if ((isLastNode || commentRemoved)
1359                         &amp;&amp; tag.getKind() == TEXT
1360                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1361                     continue;
1362 
1363                 // Ignore any leading html comments
1364                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1365                     commentRemoved = true;
1366                     continue;
1367                 }
1368             }
1369 
1370             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1371 
1372                 private boolean inAnAtag() {
1373                     if (utils.isStartElement(tag)) {
1374                         StartElementTree st = (StartElementTree)tag;
1375                         Name name = st.getName();
1376                         if (name != null) {
1377                             com.sun.tools.doclint.HtmlTag htag =
1378                                     com.sun.tools.doclint.HtmlTag.get(name);
1379                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1380                         }
1381                     }
1382                     return false;
1383                 }
1384 
1385                 @Override
1386                 public Boolean visitAttribute(AttributeTree node, Content c) {
1387                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1388                     if (node.getValueKind() == ValueKind.EMPTY) {
1389                         result.add(sb);
1390                         return false;
1391                     }
1392                     sb.append(&quot;=&quot;);
1393                     String quote;
1394                     switch (node.getValueKind()) {
1395                         case DOUBLE:
1396                             quote = &quot;\&quot;&quot;;
1397                             break;
1398                         case SINGLE:
1399                             quote = &quot;&#39;&quot;;
1400                             break;
1401                         default:
1402                             quote = &quot;&quot;;
1403                             break;
1404                     }
1405                     sb.append(quote);
1406                     result.add(sb);
1407                     Content docRootContent = new ContentBuilder();
1408 
1409                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1410                     for (DocTree dt : node.getValue()) {
1411                         if (utils.isText(dt) &amp;&amp; isHRef) {
1412                             String text = ((TextTree) dt).getBody();
1413                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {
1414                                 result.add(options.docrootParent());
1415                                 docRootContent = new ContentBuilder();
1416                                 result.add(textCleanup(text.substring(3), isLastNode));
1417                             } else {
1418                                 if (!docRootContent.isEmpty()) {
1419                                     docRootContent = copyDocRootContent(docRootContent);
1420                                 } else {
1421                                     text = redirectRelativeLinks(element, (TextTree) dt);
1422                                 }
1423                                 result.add(textCleanup(text, isLastNode));
1424                             }
1425                         } else {
1426                             docRootContent = copyDocRootContent(docRootContent);
1427                             dt.accept(this, docRootContent);
1428                         }
1429                     }
1430                     copyDocRootContent(docRootContent);
1431                     result.add(quote);
1432                     return false;
1433                 }
1434 
1435                 @Override
1436                 public Boolean visitComment(CommentTree node, Content c) {
1437                     result.add(new RawHtml(node.getBody()));
1438                     return false;
1439                 }
1440 
1441                 private Content copyDocRootContent(Content content) {
1442                     if (!content.isEmpty()) {
1443                         result.add(content);
1444                         return new ContentBuilder();
1445                     }
1446                     return content;
1447                 }
1448 
1449                 @Override
1450                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1451                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1452                             configuration.tagletManager,
1453                             holderTag,
1454                             node,
1455                             getTagletWriterInstance(isFirstSentence));
1456                     if (c != null) {
1457                         c.add(docRootContent);
1458                     } else {
1459                         result.add(docRootContent);
1460                     }
1461                     return false;
1462                 }
1463 
1464                 @Override
1465                 public Boolean visitEndElement(EndElementTree node, Content c) {
1466                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1467                     result.add(rawHtml);
1468                     return false;
1469                 }
1470 
1471                 @Override
1472                 public Boolean visitEntity(EntityTree node, Content c) {
1473                     result.add(new RawHtml(node.toString()));
1474                     return false;
1475                 }
1476 
1477                 @Override
1478                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1479                     messages.warning(ch.getDocTreePath(node),
1480                             &quot;doclet.tag.invalid_usage&quot;, node);
1481                     result.add(new RawHtml(node.toString()));
1482                     return false;
1483                 }
1484 
1485                 @Override
1486                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1487                     Content output = TagletWriter.getInlineTagOutput(element,
1488                             configuration.tagletManager, holderTag,
1489                             tag, getTagletWriterInstance(isFirstSentence));
1490                     result.add(output);
1491                     // if we obtained the first sentence successfully, nothing more to do
1492                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1493                 }
1494 
1495                 @Override
1496                 public Boolean visitIndex(IndexTree node, Content p) {
1497                     Content output = TagletWriter.getInlineTagOutput(element,
1498                             configuration.tagletManager, holderTag, tag,
1499                             getTagletWriterInstance(isFirstSentence, inSummary));
1500                     if (output != null) {
1501                         result.add(output);
1502                     }
1503                     return false;
1504                 }
1505 
1506                 @Override
1507                 public Boolean visitLink(LinkTree node, Content c) {
1508                     // we need to pass the DocTreeImpl here, so ignore node
1509                     Content content = seeTagToContent(element, tag);
1510                     result.add(content);
1511                     return false;
1512                 }
1513 
1514                 @Override
1515                 public Boolean visitLiteral(LiteralTree node, Content c) {
1516                     String s = node.getBody().getBody();
1517                     Content content = new StringContent(utils.normalizeNewlines(s));
1518                     if (node.getKind() == CODE)
1519                         content = HtmlTree.CODE(content);
1520                     result.add(content);
1521                     return false;
1522                 }
1523 
1524                 @Override
1525                 public Boolean visitSee(SeeTree node, Content c) {
1526                     // we need to pass the DocTreeImpl here, so ignore node
1527                     result.add(seeTagToContent(element, tag));
1528                     return false;
1529                 }
1530 
1531                 @Override
1532                 public Boolean visitStartElement(StartElementTree node, Content c) {
1533                     String text = &quot;&lt;&quot; + node.getName();
1534                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1535                     result.add(rawHtml);
1536 
1537                     for (DocTree dt : node.getAttributes()) {
1538                         dt.accept(this, null);
1539                     }
1540                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1541                     return false;
1542                 }
1543 
1544                 @Override
1545                 public Boolean visitSummary(SummaryTree node, Content c) {
1546                     Content output = TagletWriter.getInlineTagOutput(element,
1547                             configuration.tagletManager, holderTag, tag,
1548                             getTagletWriterInstance(isFirstSentence));
1549                     result.add(output);
1550                     return false;
1551                 }
1552 
1553                 @Override
1554                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1555                     Content output = TagletWriter.getInlineTagOutput(element,
1556                             configuration.tagletManager, holderTag, tag,
1557                             getTagletWriterInstance(isFirstSentence, inSummary));
1558                     if (output != null) {
1559                         result.add(output);
1560                     }
1561                     return false;
1562                 }
1563 
1564                 private CharSequence textCleanup(String text, boolean isLast) {
1565                     return textCleanup(text, isLast, false);
1566                 }
1567 
1568                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {
1569                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;
1570                     if (stripLeading &amp;&amp; stripTrailing) {
1571                         text = text.strip();
1572                     } else if (stripLeading) {
1573                         text = text.stripLeading();
1574                     } else if (stripTrailing) {
1575                         text = text.stripTrailing();
1576                     }
1577                     text = utils.replaceTabs(text);
1578                     return utils.normalizeNewlines(text);
1579                 }
1580 
1581                 @Override
1582                 public Boolean visitText(TextTree node, Content c) {
1583                     String text = node.getBody();
1584                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1585                     return false;
1586                 }
1587 
1588                 @Override
1589                 protected Boolean defaultAction(DocTree node, Content c) {
1590                     Content output = TagletWriter.getInlineTagOutput(element,
1591                             configuration.tagletManager, holderTag, tag,
1592                             getTagletWriterInstance(isFirstSentence));
1593                     if (output != null) {
1594                         result.add(output);
1595                     }
1596                     return false;
1597                 }
1598 
1599             }.visit(tag, null);
1600             commentRemoved = false;
1601             if (allDone)
1602                 break;
1603         }
1604         return result;
1605     }
1606 
1607     /**
1608      * Return true if relative links should not be redirected.
1609      *
1610      * @return Return true if a relative link should not be redirected.
1611      */
1612     private boolean shouldNotRedirectRelativeLinks() {
1613         return  this instanceof ClassWriter ||
1614                 this instanceof PackageSummaryWriter;
1615     }
1616 
1617     /**
1618      * Suppose a piece of documentation has a relative link.  When you copy
1619      * that documentation to another place such as the index or class-use page,
1620      * that relative link will no longer work.  We should redirect those links
1621      * so that they will work again.
1622      * &lt;p&gt;
1623      * Here is the algorithm used to fix the link:
1624      * &lt;p&gt;
1625      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1626      * &lt;p&gt;
1627      * For example, suppose DocletEnvironment has this link:
1628      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1629      * &lt;p&gt;
1630      * If this link appeared in the index, we would redirect
1631      * the link like this:
1632      *
1633      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1634      *
1635      * @param element the Element object whose documentation is being written.
1636      * @param tt the text being written.
1637      *
1638      * @return the text, with all the relative links redirected to work.
1639      */
1640     @SuppressWarnings(&quot;preview&quot;)
1641     private String redirectRelativeLinks(Element element, TextTree tt) {
1642         String text = tt.getBody();
1643         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1644             return text;
1645         }
1646 
1647         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {
1648             @Override
1649             public DocPath visitType(TypeElement e, Void p) {
1650                 return docPaths.forPackage(utils.containingPackage(e));
1651             }
1652 
1653             @Override
1654             public DocPath visitPackage(PackageElement e, Void p) {
1655                 return docPaths.forPackage(e);
1656             }
1657 
1658             @Override
1659             public DocPath visitVariable(VariableElement e, Void p) {
1660                 return docPaths.forPackage(utils.containingPackage(e));
1661             }
1662 
1663             @Override
1664             public DocPath visitExecutable(ExecutableElement e, Void p) {
1665                 return docPaths.forPackage(utils.containingPackage(e));
1666             }
1667 
1668             @Override
1669             protected DocPath defaultAction(Element e, Void p) {
1670                 return null;
1671             }
1672         }.visit(element);
1673         if (redirectPathFromRoot == null) {
1674             return text;
1675         }
1676         String lower = Utils.toLowerCase(text);
1677         if (!(lower.startsWith(&quot;mailto:&quot;)
1678                 || lower.startsWith(&quot;http:&quot;)
1679                 || lower.startsWith(&quot;https:&quot;)
1680                 || lower.startsWith(&quot;file:&quot;))) {
1681             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1682                     + redirectPathFromRoot.resolve(text).getPath();
1683             text = replaceDocRootDir(text);
1684         }
1685         return text;
1686     }
1687 
1688     /**
1689      * According to
1690      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1691      * all the outer classes and static nested classes are core classes.
1692      */
1693     public boolean isCoreClass(TypeElement typeElement) {
1694         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1695     }
1696 
1697     /**
1698      * Adds the annotation types for the given packageElement.
1699      *
1700      * @param packageElement the package to write annotations for.
1701      * @param htmltree the documentation tree to which the annotation info will be
1702      *        added
1703      */
1704     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1705         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);
1706     }
1707 
1708     /*
1709      * this is a hack to delay dealing with Annotations in the writers, the assumption
1710      * is that all necessary checks have been made to get here.
1711      */
1712     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1713             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1714         TypeMirror rcvrType = method.getReceiverType();
1715         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1716         htmltree.add(getAnnotationInfo(annotationMirrors1, false));
1717     }
1718 
1719     /**
1720      * Adds the annotation types for the given element.
1721      *
1722      * @param element the package to write annotations for
1723      * @param htmltree the content tree to which the annotation types will be added
1724      */
1725     public void addAnnotationInfo(Element element, Content htmltree) {
1726         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);
1727     }
1728 
1729     /**
1730      * Add the annotation types for the given element and parameter.
1731      *
1732      * @param param the parameter to write annotations for.
1733      * @param tree the content tree to which the annotation types will be added
1734      */
1735     public boolean addAnnotationInfo(VariableElement param, Content tree) {
1736         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);
1737         if (annotationInfo.isEmpty()) {
1738             return false;
1739         }
1740         tree.add(annotationInfo);
1741         return true;
1742     }
1743 
1744     /**
1745      * Adds the annotation types for the given Element.
1746      *
1747      * @param descList a list of annotation mirrors.
1748      * @param htmltree the documentation tree to which the annotation info will be
1749      *        added
1750      */
1751     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {
1752         htmltree.add(getAnnotationInfo(descList, true));
1753     }
1754 
1755     /**
1756      * Return a content tree containing the annotation types for the given element.
1757      *
1758      * @param descList a list of annotation mirrors.
1759      * @return the documentation tree containing the annotation info.
1760      */
1761     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {
1762         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);
1763         String sep = &quot;&quot;;
1764         ContentBuilder builder = new ContentBuilder();
1765         for (Content annotation: annotations) {
1766             builder.add(sep);
1767             builder.add(annotation);
1768             if (!lineBreak) {
1769                 sep = &quot; &quot;;
1770             }
1771         }
1772         return builder;
1773     }
1774 
1775     /**
1776      * Return the string representations of the annotation types for
1777      * the given doc.
1778      *
1779      * @param descList a list of annotation mirrors.
1780      * @param linkBreak if true, add new line between each member value.
1781      * @return a list of strings representing the annotations being
1782      *         documented.
1783      */
1784     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1785         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1786         ContentBuilder annotation;
1787         for (AnnotationMirror aDesc : descList) {
1788             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1789             // If an annotation is not documented, do not add it to the list. If
1790             // the annotation is of a repeatable type, and if it is not documented
1791             // and also if its container annotation is not documented, do not add it
1792             // to the list. If an annotation of a repeatable type is not documented
1793             // but its container is documented, it will be added to the list.
1794             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1795                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1796                 continue;
1797             }
1798             annotation = new ContentBuilder();
1799             isAnnotationDocumented = false;
1800             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1801                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1802             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1803             // If the annotation is synthesized, do not print the container.
1804             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1805                 for (ExecutableElement ee : pairs.keySet()) {
1806                     AnnotationValue annotationValue = pairs.get(ee);
1807                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1808 
1809                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1810                         @Override
1811                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1812                             p.addAll(vals);
1813                             return null;
1814                         }
1815 
1816                         @Override
1817                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1818                             p.add(annotationValue);
1819                             return null;
1820                         }
1821                     }.visit(annotationValue, annotationTypeValues);
1822 
1823                     String sep = &quot;&quot;;
1824                     for (AnnotationValue av : annotationTypeValues) {
1825                         annotation.add(sep);
1826                         annotation.add(annotationValueToContent(av));
1827                         sep = &quot; &quot;;
1828                     }
1829                 }
1830             } else if (isAnnotationArray(pairs)) {
1831                 // If the container has 1 or more value defined and if the
1832                 // repeatable type annotation is not documented, do not print
1833                 // the container.
1834                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1835                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1836                     for (AnnotationValue a :  pairs.values()) {
1837                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1838                             @Override
1839                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1840                                annotationTypeValues.addAll(vals);
1841                                return null;
1842                             }
1843                         }.visit(a, annotationTypeValues);
1844                     }
1845                     String sep = &quot;&quot;;
1846                     for (AnnotationValue av : annotationTypeValues) {
1847                         annotation.add(sep);
1848                         annotation.add(annotationValueToContent(av));
1849                         sep = &quot; &quot;;
1850                     }
1851                 }
1852                 // If the container has 1 or more value defined and if the
1853                 // repeatable type annotation is not documented, print the container.
1854                 else {
1855                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);
1856                 }
1857             }
1858             else {
1859                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);
1860             }
1861             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1862             results.add(annotation);
1863         }
1864         return results;
1865     }
1866 
1867     /**
1868      * Add annotation to the annotation string.
1869      *
1870      * @param annotationDoc the annotation being documented
1871      * @param linkInfo the information about the link
1872      * @param annotation the annotation string to which the annotation will be added
1873      * @param map annotation type element to annotation value pairs
1874      * @param linkBreak if true, add new line between each member value
1875      */
1876     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1877                                 ContentBuilder annotation,
1878                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1879                                 boolean linkBreak) {
1880         linkInfo.label = new StringContent(&quot;@&quot;);
1881         linkInfo.label.add(annotationDoc.getSimpleName());
1882         annotation.add(getLink(linkInfo));
1883         if (!map.isEmpty()) {
1884             annotation.add(&quot;(&quot;);
1885             boolean isFirst = true;
1886             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1887             boolean multipleValues = keys.size() &gt; 1;
1888             for (ExecutableElement element : keys) {
1889                 if (isFirst) {
1890                     isFirst = false;
1891                 } else {
1892                     annotation.add(&quot;,&quot;);
1893                     if (linkBreak) {
1894                         annotation.add(DocletConstants.NL);
1895                         int spaces = annotationDoc.getSimpleName().length() + 2;
1896                         for (int k = 0; k &lt; (spaces); k++) {
1897                             annotation.add(&quot; &quot;);
1898                         }
1899                     }
1900                 }
1901                 String simpleName = element.getSimpleName().toString();
1902                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1903                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1904                                                      element, simpleName, false));
1905                     annotation.add(&quot;=&quot;);
1906                 }
1907                 AnnotationValue annotationValue = map.get(element);
1908                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1909                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1910                     @Override
1911                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1912                         annotationTypeValues.addAll(vals);
1913                         return null;
1914                     }
1915                     @Override
1916                     protected Void defaultAction(Object o, AnnotationValue p) {
1917                         annotationTypeValues.add(p);
1918                         return null;
1919                     }
1920                 }.visit(annotationValue, annotationValue);
1921                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1922                 String sep = &quot;&quot;;
1923                 for (AnnotationValue av : annotationTypeValues) {
1924                     annotation.add(sep);
1925                     annotation.add(annotationValueToContent(av));
1926                     sep = &quot;,&quot;;
1927                 }
1928                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1929                 isContainerDocumented = false;
1930             }
1931             annotation.add(&quot;)&quot;);
1932         }
1933     }
1934 
1935     /**
1936      * Check if the annotation contains an array of annotation as a value. This
1937      * check is to verify if a repeatable type annotation is present or not.
1938      *
1939      * @param pairs annotation type element and value pairs
1940      *
1941      * @return true if the annotation contains an array of annotation as a value.
1942      */
1943     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1944         AnnotationValue annotationValue;
1945         for (ExecutableElement ee : pairs.keySet()) {
1946             annotationValue = pairs.get(ee);
1947             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1948                 @Override
1949                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1950                     if (vals.size() &gt; 1) {
1951                         if (vals.get(0) instanceof AnnotationMirror) {
1952                             isContainerDocumented = true;
1953                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1954                                 @Override
1955                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1956                                     isContainerDocumented = true;
1957                                     Element asElement = a.getAnnotationType().asElement();
1958                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1959                                         isAnnotationDocumented = true;
1960                                     }
1961                                     return true;
1962                                 }
1963                                 @Override
1964                                 protected Boolean defaultAction(Object o, Void p) {
1965                                     return false;
1966                                 }
1967                             }.visit(vals.get(0));
1968                         }
1969                     }
1970                     return false;
1971                 }
1972 
1973                 @Override
1974                 protected Boolean defaultAction(Object o, Void p) {
1975                     return false;
1976                 }
1977             }.visit(annotationValue);
1978             if (rvalue) {
1979                 return true;
1980             }
1981         }
1982         return false;
1983     }
1984 
1985     private Content annotationValueToContent(AnnotationValue annotationValue) {
1986         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
1987 
1988             @Override
1989             public Content visitType(TypeMirror t, Void p) {
1990                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
1991                     @Override
1992                     public Content visitDeclared(DeclaredType t, Void p) {
1993                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1994                                 LinkInfoImpl.Kind.ANNOTATION, t);
1995                         String name = utils.isIncluded(t.asElement())
1996                                 ? t.asElement().getSimpleName().toString()
1997                                 : utils.getFullyQualifiedName(t.asElement());
1998                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
1999                         return getLink(linkInfo);
2000                     }
2001                     @Override
2002                     protected Content defaultAction(TypeMirror e, Void p) {
2003                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2004                     }
2005                 }.visit(t);
2006             }
2007             @Override
2008             public Content visitAnnotation(AnnotationMirror a, Void p) {
2009                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);
2010                 ContentBuilder buf = new ContentBuilder();
2011                 for (Content c : list) {
2012                     buf.add(c);
2013                 }
2014                 return buf;
2015             }
2016             @Override
2017             public Content visitEnumConstant(VariableElement c, Void p) {
2018                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2019                         c, c.getSimpleName(), false);
2020             }
2021             @Override
2022             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2023                 ContentBuilder buf = new ContentBuilder();
2024                 String sep = &quot;&quot;;
2025                 for (AnnotationValue av : vals) {
2026                     buf.add(sep);
2027                     buf.add(visit(av));
2028                     sep = &quot; &quot;;
2029                 }
2030                 return buf;
2031             }
2032             @Override
2033             protected Content defaultAction(Object o, Void p) {
2034                 return new StringContent(annotationValue.toString());
2035             }
2036         }.visit(annotationValue);
2037     }
2038 
2039     protected TableHeader getPackageTableHeader() {
2040         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2041     }
2042 
2043     /**
2044      * Generates a string for use in a description meta element,
2045      * based on an element and its enclosing elements
2046      * @param prefix a prefix for the string
2047      * @param elem the element
2048      * @return the description
2049      */
2050     static String getDescription(String prefix, Element elem) {
2051         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2052         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2053             // ignore unnamed enclosing elements
2054             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2055                 break;
2056             }
2057             chain.addFirst(e);
2058         }
2059         StringBuilder sb = new StringBuilder();
2060         for (Element e: chain) {
2061             CharSequence name;
2062             switch (e.getKind()) {
2063                 case MODULE:
2064                 case PACKAGE:
2065                     name = ((QualifiedNameable) e).getQualifiedName();
2066                     if (name.length() == 0) {
2067                         name = &quot;&lt;unnamed&gt;&quot;;
2068                     }
2069                     break;
2070 
2071                 default:
2072                     name = e.getSimpleName();
2073                     break;
2074             }
2075 
2076             if (sb.length() == 0) {
2077                 sb.append(prefix).append(&quot;: &quot;);
2078             } else {
2079                 sb.append(&quot;, &quot;);
2080             }
2081             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2082                     .append(&quot;: &quot;)
2083                     .append(name);
2084         }
2085         return sb.toString();
2086     }
2087 
2088     static String getGenerator(Class&lt;?&gt; clazz) {
2089         return &quot;javadoc/&quot; + clazz.getSimpleName();
2090     }
2091 
2092     /**
2093      * Returns an HtmlTree for the BODY tag.
2094      *
2095      * @param title title for the window
2096      * @return an HtmlTree for the BODY tag
2097      */
2098     public HtmlTree getBody(String title) {
2099         HtmlTree body = new HtmlTree(TagName.BODY).setStyle(getBodyStyle());
2100 
2101         this.winTitle = title;
2102         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2103         // and package-frame
2104         body.add(mainBodyScript.asContent());
2105         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2106         body.add(noScript);
2107         return body;
2108     }
2109 
2110     public HtmlStyle getBodyStyle() {
2111         String kind = getClass().getSimpleName()
2112                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2113                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
2114                 .replaceAll(&quot;^(Module|Package|Class)$&quot;, &quot;$1Declaration&quot;);
2115         String page = kind.substring(0, 1).toLowerCase(Locale.US) + kind.substring(1) + &quot;Page&quot;;
2116         return HtmlStyle.valueOf(page);
2117     }
2118 
2119     Script getMainBodyScript() {
2120         return mainBodyScript;
2121     }
2122 
2123     /**
2124      * Returns the path of module/package specific stylesheets for the element.
2125      * @param element module/Package element
2126      * @return list of path of module/package specific stylesheets
2127      * @throws DocFileIOException
2128      */
2129     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2130         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2131         DocPath basePath = null;
2132         if (element instanceof PackageElement) {
2133             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2134             basePath = docPaths.forPackage((PackageElement)element);
2135         } else if (element instanceof ModuleElement) {
2136             basePath = DocPaths.forModule((ModuleElement)element);
2137         }
2138         for (DocPath stylesheet : getStylesheets(element)) {
2139             stylesheets.add(basePath.resolve(stylesheet.getPath()));
2140         }
2141         return stylesheets;
2142     }
2143 
2144     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws
2145             DocFileIOException {
2146         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();
2147         ModuleElement moduleElement = utils.containingModule(pkgElement);
2148         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {
2149             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);
2150             DocPath basePath = DocPaths.forModule(moduleElement);
2151             for (DocPath stylesheet : localStylesheets) {
2152                 moduleStylesheets.add(basePath.resolve(stylesheet));
2153             }
2154         }
2155         return moduleStylesheets;
2156     }
2157 
2158     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {
2159         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2160         if (localStylesheets == null) {
2161             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2162                     .getWriterFactory().getDocFilesHandler(element);
2163             localStylesheets = docFilesHandler.getStylesheets();
2164             configuration.localStylesheetMap.put(element, localStylesheets);
2165         }
2166         return localStylesheets;
2167     }
2168 
2169     Content getVerticalSeparator() {
2170         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));
2171     }
2172 }
    </pre>
  </body>
</html>
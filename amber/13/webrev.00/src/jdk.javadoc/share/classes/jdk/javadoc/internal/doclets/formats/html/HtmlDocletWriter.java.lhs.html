<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.formats.html;
  27 
  28 import java.util.ArrayList;
  29 import java.util.Collections;
  30 import java.util.HashMap;
  31 import java.util.LinkedList;
  32 import java.util.List;
  33 import java.util.ListIterator;
  34 import java.util.Locale;
  35 import java.util.Map;
  36 import java.util.Set;
  37 import java.util.regex.Matcher;
  38 import java.util.regex.Pattern;
  39 
  40 import javax.lang.model.element.AnnotationMirror;
  41 import javax.lang.model.element.AnnotationValue;
  42 import javax.lang.model.element.Element;
  43 import javax.lang.model.element.ElementKind;
  44 import javax.lang.model.element.ExecutableElement;
  45 import javax.lang.model.element.ModuleElement;
  46 import javax.lang.model.element.Name;
  47 import javax.lang.model.element.PackageElement;
  48 import javax.lang.model.element.QualifiedNameable;
  49 import javax.lang.model.element.TypeElement;
  50 import javax.lang.model.element.VariableElement;
  51 import javax.lang.model.type.DeclaredType;
  52 import javax.lang.model.type.TypeMirror;
  53 import javax.lang.model.util.SimpleAnnotationValueVisitor9;
  54 import javax.lang.model.util.SimpleElementVisitor14;
  55 import javax.lang.model.util.SimpleTypeVisitor9;
  56 
  57 import com.sun.source.doctree.AttributeTree;
  58 import com.sun.source.doctree.AttributeTree.ValueKind;
  59 import com.sun.source.doctree.CommentTree;
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
<a name="1" id="anc1"></a><span class="line-removed">  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<a name="2" id="anc2"></a><span class="line-modified">  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;</span>
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
<a name="3" id="anc3"></a><span class="line-removed">  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;</span>
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
<a name="4" id="anc4"></a>
  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 104 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 105 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 106 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 107 
 108 import static com.sun.source.doctree.DocTree.Kind.CODE;
 109 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK;
 111 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 112 import static com.sun.source.doctree.DocTree.Kind.SEE;
 113 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 114 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 115 
 116 
 117 /**
 118  * Class for the Html Format Code Generation specific to JavaDoc.
 119  * This Class contains methods related to the Html Code Generation which
 120  * are used extensively while generating the entire documentation.
 121  *
 122  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 123  *  If you write code that depends on this, you do so at your own risk.
 124  *  This code and its internal interfaces are subject to change or
 125  *  deletion without notice.&lt;/b&gt;
 126  */
 127 public class HtmlDocletWriter {
 128 
 129     /**
 130      * Relative path from the file getting generated to the destination
 131      * directory. For example, if the file getting generated is
 132      * &quot;java/lang/Object.html&quot;, then the path to the root is &quot;../..&quot;.
 133      * This string can be empty if the file getting generated is in
 134      * the destination directory.
 135      */
 136     public final DocPath pathToRoot;
 137 
 138     /**
 139      * Platform-independent path from the current or the
 140      * destination directory to the file getting generated.
 141      * Used when creating the file.
 142      */
 143     public final DocPath path;
 144 
 145     /**
 146      * Name of the file getting generated. If the file getting generated is
 147      * &quot;java/lang/Object.html&quot;, then the filename is &quot;Object.html&quot;.
 148      */
 149     public final DocPath filename;
 150 
 151     /**
 152      * The global configuration information for this run.
 153      */
 154     public final HtmlConfiguration configuration;
 155 
 156     protected final SearchIndexItems searchItems;
 157 
 158     protected final HtmlOptions options;
 159 
 160     protected final Utils utils;
 161 
 162     protected final Contents contents;
 163 
 164     protected final Messages messages;
 165 
 166     protected final Resources resources;
 167 
 168     protected final Links links;
 169 
 170     protected final DocPaths docPaths;
 171 
<a name="5" id="anc5"></a>

 172     /**
 173      * To check whether annotation heading is printed or not.
 174      */
 175     protected boolean printedAnnotationHeading = false;
 176 
 177     /**
 178      * To check whether annotation field heading is printed or not.
 179      */
 180     protected boolean printedAnnotationFieldHeading = false;
 181 
 182     /**
 183      * To check whether the repeated annotations is documented or not.
 184      */
 185     private boolean isAnnotationDocumented = false;
 186 
 187     /**
 188      * To check whether the container annotations is documented or not.
 189      */
 190     private boolean isContainerDocumented = false;
 191 
 192     /**
 193      * The window title of this file.
 194      */
 195     protected String winTitle;
 196 
 197     protected Script mainBodyScript;
 198 
 199     /**
 200      * A table of the anchors used for at-index and related tags,
 201      * so that they can be made unique by appending a suitable suffix.
 202      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 203      * to avoid generating duplicates.)
 204      */
 205     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 206 
 207     /**
 208      * Creates an {@code HtmlDocletWriter}.
 209      *
 210      * @param configuration the configuration for this doclet
 211      * @param path the file to be generated.
 212      */
 213     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 214         this.configuration = configuration;
 215         this.searchItems = configuration.searchItems;
 216         this.options = configuration.getOptions();
 217         this.contents = configuration.contents;
 218         this.messages = configuration.messages;
 219         this.resources = configuration.docResources;
 220         this.links = new Links(path);
 221         this.utils = configuration.utils;
<a name="6" id="anc6"></a>
 222         this.path = path;
 223         this.pathToRoot = path.parent().invert();
 224         this.filename = path.basename();
 225         this.docPaths = configuration.docPaths;
 226         this.mainBodyScript = new Script();
 227 
 228         messages.notice(&quot;doclet.Generating_0&quot;,
 229             DocFile.createFileForOutput(configuration, path).getPath());
 230     }
 231 
 232     /**
 233      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 234      * as -header, -footer, -top and -bottom, and when converting a relative
 235      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 236      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 237      * comments.)
 238      * &lt;p&gt;
 239      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 240      * destination directory from the directory where the file is being
 241      * written, looping to handle all such tags in htmlstr.
 242      * &lt;p&gt;
 243      * For example, for &quot;-d docs&quot; and -header containing {&amp;#064;docRoot}, when
 244      * the HTML page for source file p/C1.java is being generated, the
 245      * {&amp;#064;docRoot} tag would be inserted into the header as &quot;../&quot;,
 246      * the relative path from docs/p/ to docs/ (the document root).
 247      * &lt;p&gt;
 248      * Note: This doc comment was written with &#39;&amp;amp;#064;&#39; representing &#39;@&#39;
 249      * to prevent the inline tag from being interpreted.
 250      */
 251     public String replaceDocRootDir(String htmlstr) {
 252         // Return if no inline tags exist
 253         int index = htmlstr.indexOf(&quot;{@&quot;);
 254         if (index &lt; 0) {
 255             return htmlstr;
 256         }
 257         Matcher docrootMatcher = docrootPattern.matcher(htmlstr);
 258         if (!docrootMatcher.find()) {
 259             return htmlstr;
 260         }
 261         StringBuilder buf = new StringBuilder();
 262         int prevEnd = 0;
 263         do {
 264             int match = docrootMatcher.start();
 265             // append htmlstr up to start of next {@docroot}
 266             buf.append(htmlstr.substring(prevEnd, match));
 267             prevEnd = docrootMatcher.end();
 268             if (options.docrootParent().length() &gt; 0 &amp;&amp; htmlstr.startsWith(&quot;/..&quot;, prevEnd)) {
 269                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 270                 buf.append(options.docrootParent());
 271                 prevEnd += 3;
 272             } else {
 273                 // Insert relative path where {@docRoot} was located
 274                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 275             }
 276             // Append slash if next character is not a slash
 277             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 278                 buf.append(&#39;/&#39;);
 279             }
 280         } while (docrootMatcher.find());
 281         buf.append(htmlstr.substring(prevEnd));
 282         return buf.toString();
 283     }
 284     //where:
 285         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 286         private static final Pattern docrootPattern =
 287                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 288 
<a name="7" id="anc7"></a><span class="line-removed"> 289     /**</span>
<span class="line-removed"> 290      * Get the script to show or hide the All classes link.</span>
<span class="line-removed"> 291      *</span>
<span class="line-removed"> 292      * @param id id of the element to show or hide</span>
<span class="line-removed"> 293      * @return a content tree for the script</span>
<span class="line-removed"> 294      */</span>
<span class="line-removed"> 295     public Content getAllClassesLinkScript(String id) {</span>
<span class="line-removed"> 296         Script script = new Script(&quot;&lt;!--\n&quot; +</span>
<span class="line-removed"> 297                 &quot;  allClassesLink = document.getElementById(&quot;)</span>
<span class="line-removed"> 298                 .appendStringLiteral(id)</span>
<span class="line-removed"> 299                 .append(&quot;);\n&quot; +</span>
<span class="line-removed"> 300                 &quot;  if(window==top) {\n&quot; +</span>
<span class="line-removed"> 301                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +</span>
<span class="line-removed"> 302                 &quot;  }\n&quot; +</span>
<span class="line-removed"> 303                 &quot;  else {\n&quot; +</span>
<span class="line-removed"> 304                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +</span>
<span class="line-removed"> 305                 &quot;  }\n&quot; +</span>
<span class="line-removed"> 306                 &quot;  //--&gt;\n&quot;);</span>
<span class="line-removed"> 307         Content div = HtmlTree.DIV(script.asContent());</span>
<span class="line-removed"> 308         Content div_noscript = HtmlTree.DIV(contents.noScriptMessage);</span>
<span class="line-removed"> 309         Content noScript = HtmlTree.NOSCRIPT(div_noscript);</span>
<span class="line-removed"> 310         div.add(noScript);</span>
<span class="line-removed"> 311         return div;</span>
<span class="line-removed"> 312     }</span>
 313 
 314     /**
 315      * Add method information.
 316      *
 317      * @param method the method to be documented
 318      * @param dl the content tree to which the method information will be added
 319      */
 320     private void addMethodInfo(ExecutableElement method, Content dl) {
 321         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 322         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 323         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 324         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 325         // Check whether there is any implementation or overridden info to be
 326         // printed. If no overridden or implementation info needs to be
 327         // printed, do not print this section.
 328         if ((!intfacs.isEmpty()
 329                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 330                 || overriddenMethod != null) {
 331             MethodWriterImpl.addImplementsInfo(this, method, dl);
 332             if (overriddenMethod != null) {
 333                 MethodWriterImpl.addOverridden(this,
 334                         utils.overriddenType(method),
 335                         overriddenMethod,
 336                         dl);
 337             }
 338         }
 339     }
 340 
 341     /**
 342      * Adds the tags information.
 343      *
 344      * @param e the Element for which the tags will be generated
 345      * @param htmlTree the documentation tree to which the tags will be added
 346      */
 347     protected void addTagsInfo(Element e, Content htmlTree) {
 348         if (options.noComment()) {
 349             return;
 350         }
 351         HtmlTree dl = HtmlTree.DL(HtmlStyle.notes);
 352         if (utils.isExecutableElement(e) &amp;&amp; !utils.isConstructor(e)) {
 353             addMethodInfo((ExecutableElement)e, dl);
 354         }
 355         Content output = new ContentBuilder();
 356         TagletWriter.genTagOutput(configuration.tagletManager, e,
 357             configuration.tagletManager.getBlockTaglets(e),
 358                 getTagletWriterInstance(false), output);
 359         dl.add(output);
 360         htmlTree.add(dl);
 361     }
 362 
 363     /**
 364      * Check whether there are any tags for Serialization Overview
 365      * section to be printed.
 366      *
 367      * @param field the VariableElement object to check for tags.
 368      * @return true if there are tags to be printed else return false.
 369      */
 370     protected boolean hasSerializationOverviewTags(VariableElement field) {
 371         Content output = new ContentBuilder();
 372         TagletWriter.genTagOutput(configuration.tagletManager, field,
 373                 configuration.tagletManager.getBlockTaglets(field),
 374                 getTagletWriterInstance(false), output);
 375         return !output.isEmpty();
 376     }
 377 
 378     /**
 379      * Returns a TagletWriter that knows how to write HTML.
 380      *
 381      * @param isFirstSentence  true if we want to write the first sentence
 382      * @return a TagletWriter that knows how to write HTML.
 383      */
 384     public TagletWriter getTagletWriterInstance(boolean isFirstSentence) {
 385         return new TagletWriterImpl(this, isFirstSentence);
 386     }
 387 
 388     /**
 389      * Returns a TagletWriter that knows how to write HTML.
 390      *
 391      * @param isFirstSentence  true if we want to write the first sentence
 392      * @param inSummary  true if tags are to be added in a summary section
 393      * @return a TagletWriter
 394      */
 395     public TagletWriter getTagletWriterInstance(boolean isFirstSentence, boolean inSummary) {
 396         return new TagletWriterImpl(this, isFirstSentence, inSummary);
 397     }
 398 
 399     /**
 400      * Generates the HTML document tree and prints it out.
 401      *
 402      * @param metakeywords Array of String keywords for META tag. Each element
 403      *                     of the array is assigned to a separate META tag.
 404      *                     Pass in null for no array
 405      * @param description the content for the description META tag.
 406      * @param body the body htmltree to be included in the document
 407      * @throws DocFileIOException if there is a problem writing the file
 408      */
 409     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 410                                   String description,
 411                                   Content body)
 412             throws DocFileIOException {
 413         printHtmlDocument(metakeywords, description, new ContentBuilder(), Collections.emptyList(), body);
 414     }
 415 
 416     /**
 417      * Generates the HTML document tree and prints it out.
 418      *
 419      * @param metakeywords Array of String keywords for META tag. Each element
 420      *                     of the array is assigned to a separate META tag.
 421      *                     Pass in null for no array
 422      * @param description the content for the description META tag.
 423      * @param localStylesheets local stylesheets to be included in the HEAD element
 424      * @param body the body htmltree to be included in the document
 425      * @throws DocFileIOException if there is a problem writing the file
 426      */
 427     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 428                                   String description,
 429                                   List&lt;DocPath&gt; localStylesheets,
 430                                   Content body)
 431             throws DocFileIOException {
 432         printHtmlDocument(metakeywords, description, new ContentBuilder(), localStylesheets, body);
 433     }
 434 
 435     /**
 436      * Generates the HTML document tree and prints it out.
 437      *
 438      * @param metakeywords Array of String keywords for META tag. Each element
 439      *                     of the array is assigned to a separate META tag.
 440      *                     Pass in null for no array
 441      * @param description the content for the description META tag.
 442      * @param extraHeadContent any additional content to be included in the HEAD element
 443      * @param localStylesheets local stylesheets to be included in the HEAD element
 444      * @param body the body htmltree to be included in the document
 445      * @throws DocFileIOException if there is a problem writing the file
 446      */
 447     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 448                                   String description,
 449                                   Content extraHeadContent,
 450                                   List&lt;DocPath&gt; localStylesheets,
 451                                   Content body)
 452             throws DocFileIOException {
 453         Content htmlComment = contents.newPage;
 454         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 455         additionalStylesheets.addAll(localStylesheets);
 456         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 457                 .setTimestamp(!options.noTimestamp())
 458                 .setDescription(description)
 459                 .setGenerator(getGenerator(getClass()))
 460                 .setTitle(winTitle)
 461                 .setCharset(options.charset())
 462                 .addKeywords(metakeywords)
 463                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 464                 .setIndex(options.createIndex(), mainBodyScript)
 465                 .addContent(extraHeadContent);
 466 
<a name="8" id="anc8"></a><span class="line-modified"> 467         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);</span>
 468         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 469         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 470     }
 471 
 472     /**
 473      * Get the window title.
 474      *
 475      * @param title the title string to construct the complete window title
 476      * @return the window title string
 477      */
 478     public String getWindowTitle(String title) {
 479         if (options.windowTitle().length() &gt; 0) {
 480             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 481         }
 482         return title;
 483     }
 484 
 485     /**
 486      * Get user specified header and the footer.
 487      *
 488      * @param header if true print the user provided header else print the
 489      * user provided footer.
 490      */
 491     public Content getUserHeaderFooter(boolean header) {
 492         String content;
 493         if (header) {
 494             content = replaceDocRootDir(options.header());
 495         } else {
 496             if (options.footer().length() != 0) {
 497                 content = replaceDocRootDir(options.footer());
 498             } else {
 499                 content = replaceDocRootDir(options.header());
 500             }
 501         }
 502         Content rawContent = new RawHtml(content);
 503         return rawContent;
 504     }
 505 
 506     /**
 507      * Adds the user specified top.
 508      *
 509      * @param htmlTree the content tree to which user specified top will be added
 510      */
 511     public void addTop(Content htmlTree) {
 512         Content top = new RawHtml(replaceDocRootDir(options.top()));
 513         htmlTree.add(top);
 514     }
 515 
 516     /**
 517      * Adds the user specified bottom.
 518      *
 519      * @param htmlTree the content tree to which user specified bottom will be added
 520      */
 521     public void addBottom(Content htmlTree) {
 522         Content bottom = new RawHtml(replaceDocRootDir(options.bottom()));
 523         Content small = HtmlTree.SMALL(bottom);
 524         Content p = HtmlTree.P(HtmlStyle.legalCopy, small);
 525         htmlTree.add(p);
 526     }
 527 
 528     /**
 529      * Get the overview tree link for the main tree.
 530      *
 531      * @param label the label for the link
 532      * @return a content tree for the link
 533      */
 534     protected Content getNavLinkMainTree(String label) {
 535         Content mainTreeContent = links.createLink(pathToRoot.resolve(DocPaths.OVERVIEW_TREE),
 536                 new StringContent(label));
 537         Content li = HtmlTree.LI(mainTreeContent);
 538         return li;
 539     }
 540 
 541     /**
 542      * Get table caption.
 543      *
 544      * @param title the content for the caption
 545      * @return a content tree for the caption
 546      */
 547     public Content getTableCaption(Content title) {
 548         Content captionSpan = HtmlTree.SPAN(title);
 549         Content space = Entity.NO_BREAK_SPACE;
 550         Content tabSpan = HtmlTree.SPAN(HtmlStyle.tabEnd, space);
 551         Content caption = HtmlTree.CAPTION(captionSpan);
 552         caption.add(tabSpan);
 553         return caption;
 554     }
 555 
 556     /**
 557      * Returns a packagename content.
 558      *
 559      * @param packageElement the package to check
 560      * @return package name content
 561      */
 562     public Content getPackageName(PackageElement packageElement) {
 563         return packageElement == null || packageElement.isUnnamed()
 564                 ? contents.defaultPackageLabel
 565                 : getPackageLabel(packageElement.getQualifiedName());
 566     }
 567 
 568     /**
 569      * Returns a package name label.
 570      *
 571      * @param packageName the package name
 572      * @return the package name content
 573      */
 574     public Content getPackageLabel(CharSequence packageName) {
 575         return new StringContent(packageName);
 576     }
 577 
 578     /**
 579      * Return the path to the class page for a typeElement.
 580      *
 581      * @param te   TypeElement for which the path is requested.
 582      * @param name Name of the file(doesn&#39;t include path).
 583      */
 584     protected DocPath pathString(TypeElement te, DocPath name) {
 585         return pathString(utils.containingPackage(te), name);
 586     }
 587 
 588     /**
 589      * Return path to the given file name in the given package. So if the name
 590      * passed is &quot;Object.html&quot; and the name of the package is &quot;java.lang&quot;, and
 591      * if the relative path is &quot;../..&quot; then returned string will be
 592      * &quot;../../java/lang/Object.html&quot;
 593      *
 594      * @param packageElement Package in which the file name is assumed to be.
 595      * @param name File name, to which path string is.
 596      */
 597     protected DocPath pathString(PackageElement packageElement, DocPath name) {
 598         return pathToRoot.resolve(docPaths.forPackage(packageElement).resolve(name));
 599     }
 600 
 601     /**
 602      * Given a package, return the name to be used in HTML anchor tag.
 603      * @param packageElement the package.
 604      * @return the name to be used in HTML anchor tag.
 605      */
 606     public String getPackageAnchorName(PackageElement packageElement) {
 607         return packageElement == null || packageElement.isUnnamed()
 608                 ? SectionName.UNNAMED_PACKAGE_ANCHOR.getName()
 609                 : utils.getPackageName(packageElement);
 610     }
 611 
 612     /**
 613      * Return the link to the given package.
 614      *
 615      * @param packageElement the package to link to.
 616      * @param label the label for the link.
 617      * @return a content tree for the package link.
 618      */
 619     public Content getPackageLink(PackageElement packageElement, CharSequence label) {
 620         return getPackageLink(packageElement, new StringContent(label));
 621     }
 622 
 623     public Content getPackageLink(PackageElement packageElement) {
 624         StringContent content =  packageElement.isUnnamed()
 625                 ? new StringContent()
 626                 : new StringContent(utils.getPackageName(packageElement));
 627         return getPackageLink(packageElement, content);
 628     }
 629 
 630     /**
 631      * Return the link to the given package.
 632      *
 633      * @param packageElement the package to link to.
 634      * @param label the label for the link.
 635      * @return a content tree for the package link.
 636      */
 637     public Content getPackageLink(PackageElement packageElement, Content label) {
 638         boolean included = packageElement != null &amp;&amp; utils.isIncluded(packageElement);
 639         if (!included) {
 640             for (PackageElement p : configuration.packages) {
 641                 if (p.equals(packageElement)) {
 642                     included = true;
 643                     break;
 644                 }
 645             }
 646         }
 647         if (included || packageElement == null) {
 648             return links.createLink(pathString(packageElement, DocPaths.PACKAGE_SUMMARY),
 649                     label);
 650         } else {
 651             DocLink crossPkgLink = getCrossPackageLink(packageElement);
 652             if (crossPkgLink != null) {
 653                 return links.createLink(crossPkgLink, label);
 654             } else {
 655                 return label;
 656             }
 657         }
 658     }
 659 
 660     /**
 661      * Get Module link.
 662      *
 663      * @param mdle the module being documented
 664      * @param label tag for the link
 665      * @return a content for the module link
 666      */
 667     public Content getModuleLink(ModuleElement mdle, Content label) {
 668         boolean included = utils.isIncluded(mdle);
 669         return (included)
 670                 ? links.createLink(pathToRoot.resolve(docPaths.moduleSummary(mdle)), label, &quot;&quot;, &quot;&quot;)
 671                 : label;
 672     }
 673 
 674     public Content interfaceName(TypeElement typeElement, boolean qual) {
 675         Content name = new StringContent((qual)
 676                 ? typeElement.getQualifiedName()
 677                 : utils.getSimpleName(typeElement));
 678         return (utils.isInterface(typeElement)) ?  HtmlTree.SPAN(HtmlStyle.interfaceName, name) : name;
 679     }
 680 
 681     /**
 682      * Add the link to the content tree.
 683      *
 684      * @param element program element for which the link will be added
 685      * @param label label for the link
 686      * @param htmltree the content tree to which the link will be added
 687      */
 688     public void addSrcLink(Element element, Content label, Content htmltree) {
 689         if (element == null) {
 690             return;
 691         }
 692         TypeElement te = utils.getEnclosingTypeElement(element);
 693         if (te == null) {
 694             // must be a typeElement since in has no containing class.
 695             te = (TypeElement) element;
 696         }
 697         if (utils.isIncluded(te)) {
 698             DocPath href = pathToRoot
 699                     .resolve(DocPaths.SOURCE_OUTPUT)
 700                     .resolve(docPaths.forClass(te));
 701             Content content = links.createLink(href
 702                     .fragment(SourceToHTMLConverter.getAnchorName(utils, element)), label, &quot;&quot;, &quot;&quot;);
 703             htmltree.add(content);
 704         } else {
 705             htmltree.add(label);
 706         }
 707     }
 708 
 709     /**
 710      * Return the link to the given class.
 711      *
 712      * @param linkInfo the information about the link.
 713      *
 714      * @return the link for the given class.
 715      */
 716     public Content getLink(LinkInfoImpl linkInfo) {
 717         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 718         return factory.getLink(linkInfo);
 719     }
 720 
 721     /**
 722      * Return the type parameters for the given class.
 723      *
 724      * @param linkInfo the information about the link.
 725      * @return the type for the given class.
 726      */
 727     public Content getTypeParameterLinks(LinkInfoImpl linkInfo) {
 728         LinkFactoryImpl factory = new LinkFactoryImpl(this);
 729         return factory.getTypeParameterLinks(linkInfo, false);
 730     }
 731 
 732     /*************************************************************
 733      * Return a class cross link to external class documentation.
 734      * The -link option does not allow users to
 735      * link to external classes in the &quot;default&quot; package.
 736      *
 737      * @param classElement the class element
 738      * @param refMemName the name of the member being referenced.  This should
 739      * be null or empty string if no member is being referenced.
 740      * @param label the label for the external link.
 741      * @param strong true if the link should be strong.
 742      * @param code true if the label should be code font.
 743      * @return the link
 744      */
 745     public Content getCrossClassLink(TypeElement classElement, String refMemName,
 746                                     Content label, boolean strong, boolean code) {
 747         if (classElement != null) {
 748             String className = utils.getSimpleName(classElement);
 749             PackageElement packageElement = utils.containingPackage(classElement);
 750             Content defaultLabel = new StringContent(className);
 751             if (code)
 752                 defaultLabel = HtmlTree.CODE(defaultLabel);
 753             if (getCrossPackageLink(packageElement) != null) {
 754                 /*
 755                 The package exists in external documentation, so link to the external
 756                 class (assuming that it exists).  This is definitely a limitation of
 757                 the -link option.  There are ways to determine if an external package
 758                 exists, but no way to determine if the external class exists.  We just
 759                 have to assume that it does.
 760                 */
 761                 DocLink link = configuration.extern.getExternalLink(packageElement, pathToRoot,
 762                                 className + &quot;.html&quot;, refMemName);
 763                 return links.createLink(link,
 764                     (label == null) || label.isEmpty() ? defaultLabel : label,
 765                     strong,
 766                     resources.getText(&quot;doclet.Href_Class_Or_Interface_Title&quot;,
 767                         utils.getPackageName(packageElement)), &quot;&quot;, true);
 768             }
 769         }
 770         return null;
 771     }
 772 
 773     public boolean isClassLinkable(TypeElement typeElement) {
 774         if (utils.isIncluded(typeElement)) {
 775             return configuration.isGeneratedDoc(typeElement);
 776         }
 777         return configuration.extern.isExternal(typeElement);
 778     }
 779 
 780     public DocLink getCrossPackageLink(PackageElement element) {
 781         return configuration.extern.getExternalLink(element, pathToRoot,
 782             DocPaths.PACKAGE_SUMMARY.getPath());
 783     }
 784 
 785     public DocLink getCrossModuleLink(ModuleElement element) {
 786         return configuration.extern.getExternalLink(element, pathToRoot,
 787             docPaths.moduleSummary(utils.getModuleName(element)).getPath());
 788     }
 789 
 790     /**
 791      * Get the class link.
 792      *
 793      * @param context the id of the context where the link will be added
 794      * @param element to link to
 795      * @return a content tree for the link
 796      */
 797     public Content getQualifiedClassLink(LinkInfoImpl.Kind context, Element element) {
 798         LinkInfoImpl linkInfoImpl = new LinkInfoImpl(configuration, context, (TypeElement)element);
 799         return getLink(linkInfoImpl.label(utils.getFullyQualifiedName(element)));
 800     }
 801 
 802     /**
 803      * Add the class link.
 804      *
 805      * @param context the id of the context where the link will be added
 806      * @param typeElement to link to
 807      * @param contentTree the content tree to which the link will be added
 808      */
 809     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 810         addPreQualifiedClassLink(context, typeElement, false, contentTree);
 811     }
 812 
 813     /**
 814      * Retrieve the class link with the package portion of the label in
 815      * plain text.  If the qualifier is excluded, it will not be included in the
 816      * link label.
 817      *
 818      * @param typeElement the class to link to.
 819      * @param isStrong true if the link should be strong.
 820      * @return the link with the package portion of the label in plain text.
 821      */
 822     public Content getPreQualifiedClassLink(LinkInfoImpl.Kind context,
 823             TypeElement typeElement, boolean isStrong) {
 824         ContentBuilder classlink = new ContentBuilder();
 825         PackageElement pkg = utils.containingPackage(typeElement);
 826         if (pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 827             classlink.add(getEnclosingPackageName(typeElement));
 828         }
 829         classlink.add(getLink(new LinkInfoImpl(configuration,
 830                 context, typeElement).label(utils.getSimpleName(typeElement)).strong(isStrong)));
 831         return classlink;
 832     }
 833 
 834     /**
 835      * Add the class link with the package portion of the label in
 836      * plain text. If the qualifier is excluded, it will not be included in the
 837      * link label.
 838      *
 839      * @param context the id of the context where the link will be added
 840      * @param typeElement the class to link to
 841      * @param isStrong true if the link should be strong
 842      * @param contentTree the content tree to which the link with be added
 843      */
 844     public void addPreQualifiedClassLink(LinkInfoImpl.Kind context,
 845             TypeElement typeElement, boolean isStrong, Content contentTree) {
 846         PackageElement pkg = utils.containingPackage(typeElement);
 847         if(pkg != null &amp;&amp; ! configuration.shouldExcludeQualifier(pkg.getSimpleName().toString())) {
 848             contentTree.add(getEnclosingPackageName(typeElement));
 849         }
 850         LinkInfoImpl linkinfo = new LinkInfoImpl(configuration, context, typeElement)
 851                 .label(utils.getSimpleName(typeElement))
 852                 .strong(isStrong);
 853         Content link = getLink(linkinfo);
 854         contentTree.add(link);
 855     }
 856 
 857     /**
 858      * Get the enclosed name of the package
 859      *
 860      * @param te  TypeElement
 861      * @return the name
 862      */
 863     public String getEnclosingPackageName(TypeElement te) {
 864 
 865         PackageElement encl = configuration.utils.containingPackage(te);
 866         return (encl.isUnnamed()) ? &quot;&quot; : (encl.getQualifiedName() + &quot;.&quot;);
 867     }
 868 
 869     /**
 870      * Return the main type element of the current page or null for pages that don&#39;t have one.
 871      *
 872      * @return the type element of the current page.
 873      */
 874     protected TypeElement getCurrentPageElement() {
 875         return null;
 876     }
 877 
 878     /**
 879      * Add the class link, with only class name as the strong link and prefixing
 880      * plain package name.
 881      *
 882      * @param context the id of the context where the link will be added
 883      * @param typeElement the class to link to
 884      * @param contentTree the content tree to which the link with be added
 885      */
 886     public void addPreQualifiedStrongClassLink(LinkInfoImpl.Kind context, TypeElement typeElement, Content contentTree) {
 887         addPreQualifiedClassLink(context, typeElement, true, contentTree);
 888     }
 889 
 890     /**
 891      * Get the link for the given member.
 892      *
 893      * @param context the id of the context where the link will be added
 894      * @param element the member being linked to
 895      * @param label the label for the link
 896      * @return a content tree for the element link
 897      */
 898     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label) {
 899         return getDocLink(context, utils.getEnclosingTypeElement(element), element,
 900                 new StringContent(label));
 901     }
 902 
 903     /**
 904      * Return the link for the given member.
 905      *
 906      * @param context the id of the context where the link will be printed.
 907      * @param element the member being linked to.
 908      * @param label the label for the link.
 909      * @param strong true if the link should be strong.
 910      * @return the link for the given member.
 911      */
 912     public Content getDocLink(LinkInfoImpl.Kind context, Element element, CharSequence label,
 913             boolean strong) {
 914         return getDocLink(context, utils.getEnclosingTypeElement(element), element, label, strong);
 915     }
 916 
 917     /**
 918      * Return the link for the given member.
 919      *
 920      * @param context the id of the context where the link will be printed.
 921      * @param typeElement the typeElement that we should link to.  This is not
 922                  necessarily equal to element.containingClass().  We may be
 923                  inheriting comments.
 924      * @param element the member being linked to.
 925      * @param label the label for the link.
 926      * @param strong true if the link should be strong.
 927      * @return the link for the given member.
 928      */
 929     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 930             CharSequence label, boolean strong) {
 931         return getDocLink(context, typeElement, element, label, strong, false);
 932     }
 933 
 934     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 935             Content label, boolean strong) {
 936         return getDocLink(context, typeElement, element, label, strong, false);
 937     }
 938 
 939     /**
 940      * Return the link for the given member.
 941      *
 942      * @param context the id of the context where the link will be printed.
 943      * @param typeElement the typeElement that we should link to.  This is not
 944                  necessarily equal to element.containingClass().  We may be
 945                  inheriting comments.
 946      * @param element the member being linked to.
 947      * @param label the label for the link.
 948      * @param strong true if the link should be strong.
 949      * @param isProperty true if the element parameter is a JavaFX property.
 950      * @return the link for the given member.
 951      */
 952     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 953             CharSequence label, boolean strong, boolean isProperty) {
 954         return getDocLink(context, typeElement, element, new StringContent(label), strong, isProperty);
 955     }
 956 
 957     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 958             Content label, boolean strong, boolean isProperty) {
 959         if (!utils.isLinkable(typeElement, element)) {
 960             return label;
 961         }
 962 
 963         if (utils.isExecutableElement(element)) {
 964             ExecutableElement ee = (ExecutableElement)element;
 965             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 966                 .label(label)
 967                 .where(links.getName(getAnchor(ee, isProperty)))
 968                 .strong(strong));
 969         }
 970 
 971         if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 972             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 973                 .label(label)
 974                 .where(links.getName(element.getSimpleName().toString()))
 975                 .strong(strong));
 976         }
 977 
 978         return label;
 979     }
 980 
 981     /**
 982      * Return the link for the given member.
 983      *
 984      * @param context the id of the context where the link will be added
 985      * @param typeElement the typeElement that we should link to.  This is not
 986                  necessarily equal to element.containingClass().  We may be
 987                  inheriting comments
 988      * @param element the member being linked to
 989      * @param label the label for the link
 990      * @return the link for the given member
 991      */
 992     public Content getDocLink(LinkInfoImpl.Kind context, TypeElement typeElement, Element element,
 993             Content label) {
 994         if (! (utils.isIncluded(element) || utils.isLinkable(typeElement))) {
 995             return label;
 996         } else if (utils.isExecutableElement(element)) {
 997             ExecutableElement emd = (ExecutableElement) element;
 998             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 999                 .label(label)
1000                 .where(links.getName(getAnchor(emd))));
1001         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
1002             return getLink(new LinkInfoImpl(configuration, context, typeElement)
1003                 .label(label).where(links.getName(element.getSimpleName().toString())));
1004         } else {
1005             return label;
1006         }
1007     }
1008 
1009     public String getAnchor(ExecutableElement executableElement) {
1010         return getAnchor(executableElement, false);
1011     }
1012 
1013     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
1014         if (isProperty) {
1015             return executableElement.getSimpleName().toString();
1016         }
1017         String member = anchorName(executableElement);
<a name="9" id="anc9"></a><span class="line-modified">1018         String erasedSignature = utils.makeSignature(executableElement, true, true);</span>
1019         return member + erasedSignature;
1020     }
1021 
1022     public String anchorName(Element member) {
1023         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1024             return &quot;&lt;init&gt;&quot;;
1025         } else {
1026             return utils.getSimpleName(member);
1027         }
1028     }
1029 
1030     public Content seeTagToContent(Element element, DocTree see) {
1031         Kind kind = see.getKind();
1032         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1033             return new ContentBuilder();
1034         }
1035 
1036         CommentHelper ch = utils.getCommentHelper(element);
1037         String tagName = ch.getTagName(see);
1038         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
1039         // Check if @see is an href or &quot;string&quot;
1040         if (seetext.startsWith(&quot;&lt;&quot;) || seetext.startsWith(&quot;\&quot;&quot;)) {
1041             return new RawHtml(seetext);
1042         }
1043         boolean isLinkPlain = kind == LINK_PLAIN;
1044         Content label = plainOrCode(isLinkPlain, new RawHtml(ch.getLabel(see)));
1045 
1046         //The text from the @see tag.  We will output this text when a label is not specified.
1047         Content text = plainOrCode(kind == LINK_PLAIN, new RawHtml(seetext));
1048 
1049         TypeElement refClass = ch.getReferencedClass(see);
1050         String refClassName =  ch.getReferencedClassName(see);
1051         Element refMem =       ch.getReferencedMember(see);
1052         String refMemName =    ch.getReferencedMemberName(see);
1053 
1054         if (refMemName == null &amp;&amp; refMem != null) {
1055             refMemName = refMem.toString();
1056         }
1057         if (refClass == null) {
1058             //@see is not referencing an included class
1059             PackageElement refPackage = ch.getReferencedPackage(see);
1060             if (refPackage != null &amp;&amp; utils.isIncluded(refPackage)) {
1061                 //@see is referencing an included package
1062                 if (label.isEmpty())
1063                     label = plainOrCode(isLinkPlain,
1064                             new StringContent(refPackage.getQualifiedName()));
1065                 return getPackageLink(refPackage, label);
1066             } else {
1067                 // @see is not referencing an included class, module or package. Check for cross links.
1068                 DocLink elementCrossLink = (configuration.extern.isModule(refClassName))
1069                         ? getCrossModuleLink(utils.elementUtils.getModuleElement(refClassName)) :
1070                         (refPackage != null) ? getCrossPackageLink(refPackage) : null;
1071                 if (elementCrossLink != null) {
1072                     // Element cross link found
1073                     return links.createLink(elementCrossLink,
1074                             (label.isEmpty() ? text : label), true);
1075                 } else {
1076                     // No cross link found so print warning
1077                     messages.warning(ch.getDocTreePath(see),
1078                             &quot;doclet.see.class_or_package_not_found&quot;,
1079                             &quot;@&quot; + tagName,
1080                             seetext);
1081                     return (label.isEmpty() ? text: label);
1082                 }
1083             }
1084         } else if (refMemName == null) {
1085             // Must be a class reference since refClass is not null and refMemName is null.
1086             if (label.isEmpty()) {
1087                 /*
1088                  * it seems to me this is the right thing to do, but it causes comparator failures.
1089                  */
1090                 if (!configuration.backwardCompatibility) {
1091                     StringContent content = utils.isEnclosingPackageIncluded(refClass)
1092                             ? new StringContent(utils.getSimpleName(refClass))
1093                             : new StringContent(utils.getFullyQualifiedName(refClass));
1094                     label = plainOrCode(isLinkPlain, content);
1095                 } else {
1096                     label = plainOrCode(isLinkPlain,
1097                             new StringContent(utils.getSimpleName(refClass)));
1098                 }
1099 
1100             }
1101             return getLink(new LinkInfoImpl(configuration, LinkInfoImpl.Kind.DEFAULT, refClass)
1102                     .label(label));
1103         } else if (refMem == null) {
1104             // Must be a member reference since refClass is not null and refMemName is not null.
1105             // However, refMem is null, so this referenced member does not exist.
1106             return (label.isEmpty() ? text: label);
1107         } else {
1108             // Must be a member reference since refClass is not null and refMemName is not null.
1109             // refMem is not null, so this @see tag must be referencing a valid member.
1110             TypeElement containing = utils.getEnclosingTypeElement(refMem);
1111 
1112             // Find the enclosing type where the method is actually visible
1113             // in the inheritance hierarchy.
1114             ExecutableElement overriddenMethod = null;
1115             if (refMem.getKind() == ElementKind.METHOD) {
1116                 VisibleMemberTable vmt = configuration.getVisibleMemberTable(containing);
1117                 overriddenMethod = vmt.getOverriddenMethod((ExecutableElement)refMem);
1118 
1119                 if (overriddenMethod != null)
1120                     containing = utils.getEnclosingTypeElement(overriddenMethod);
1121             }
1122             if (ch.getText(see).trim().startsWith(&quot;#&quot;) &amp;&amp;
1123                 ! (utils.isPublic(containing) || utils.isLinkable(containing))) {
1124                 // Since the link is relative and the holder is not even being
1125                 // documented, this must be an inherited link.  Redirect it.
1126                 // The current class either overrides the referenced member or
1127                 // inherits it automatically.
1128                 if (this instanceof ClassWriterImpl) {
1129                     containing = ((ClassWriterImpl) this).getTypeElement();
1130                 } else if (!utils.isPublic(containing)) {
1131                     messages.warning(
1132                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1133                         tagName, utils.getFullyQualifiedName(containing));
1134                 } else {
1135                     messages.warning(
1136                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1137                         tagName, seetext);
1138                 }
1139             }
1140             if (configuration.currentTypeElement != containing) {
1141                 refMemName = (utils.isConstructor(refMem))
1142                         ? refMemName
1143                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1144             }
1145             if (utils.isExecutableElement(refMem)) {
1146                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
<a name="10" id="anc10"></a><span class="line-modified">1147                     refMemName += utils.makeSignature((ExecutableElement)refMem, true);</span>
1148                 }
1149                 if (overriddenMethod != null) {
1150                     // The method to actually link.
1151                     refMem = overriddenMethod;
1152                 }
1153             }
1154 
1155             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1156 
1157             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1158                     refMem, (label.isEmpty() ? text: label), false);
1159         }
1160     }
1161 
1162     private Content plainOrCode(boolean plain, Content body) {
1163         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1164     }
1165 
1166     /**
1167      * Add the inline comment.
1168      *
1169      * @param element the Element for which the inline comment will be added
1170      * @param tag the inline tag to be added
1171      * @param htmltree the content tree to which the comment will be added
1172      */
1173     public void addInlineComment(Element element, DocTree tag, Content htmltree) {
1174         CommentHelper ch = utils.getCommentHelper(element);
1175         List&lt;? extends DocTree&gt; description = ch.getDescription(tag);
1176         addCommentTags(element, tag, description, false, false, false, htmltree);
1177     }
1178 
1179     /**
1180      * Get the deprecated phrase as content.
1181      *
1182      * @param e the Element for which the inline deprecated comment will be added
1183      * @return a content tree for the deprecated phrase.
1184      */
1185     public Content getDeprecatedPhrase(Element e) {
1186         return (utils.isDeprecatedForRemoval(e))
1187                 ? contents.deprecatedForRemovalPhrase
1188                 : contents.deprecatedPhrase;
1189     }
1190 
1191     /**
1192      * Add the inline deprecated comment.
1193      *
1194      * @param e the Element for which the inline deprecated comment will be added
1195      * @param tag the inline tag to be added
1196      * @param htmltree the content tree to which the comment will be added
1197      */
1198     public void addInlineDeprecatedComment(Element e, DocTree tag, Content htmltree) {
1199         CommentHelper ch = utils.getCommentHelper(e);
1200         addCommentTags(e, ch.getBody(tag), true, false, false, htmltree);
1201     }
1202 
1203     /**
1204      * Adds the summary content.
1205      *
1206      * @param element the Element for which the summary will be generated
1207      * @param htmltree the documentation tree to which the summary will be added
1208      */
1209     public void addSummaryComment(Element element, Content htmltree) {
1210         addSummaryComment(element, utils.getFirstSentenceTrees(element), htmltree);
1211     }
1212 
1213     /**
1214      * Adds the summary content.
1215      *
1216      * @param element the Element for which the summary will be generated
1217      * @param firstSentenceTags the first sentence tags for the doc
1218      * @param htmltree the documentation tree to which the summary will be added
1219      */
1220     public void addSummaryComment(Element element, List&lt;? extends DocTree&gt; firstSentenceTags, Content htmltree) {
1221         addCommentTags(element, firstSentenceTags, false, true, true, htmltree);
1222     }
1223 
1224     public void addSummaryDeprecatedComment(Element element, DocTree tag, Content htmltree) {
1225         CommentHelper ch = utils.getCommentHelper(element);
1226         List&lt;? extends DocTree&gt; body = ch.getBody(tag);
1227         addCommentTags(element, ch.getFirstSentenceTrees(body), true, true, true, htmltree);
1228     }
1229 
1230     /**
1231      * Adds the inline comment.
1232      *
1233      * @param element the Element for which the inline comments will be generated
1234      * @param htmltree the documentation tree to which the inline comments will be added
1235      */
1236     public void addInlineComment(Element element, Content htmltree) {
1237         addCommentTags(element, utils.getFullBody(element), false, false, false, htmltree);
1238     }
1239 
1240     /**
1241      * Adds the comment tags.
1242      *
1243      * @param element the Element for which the comment tags will be generated
1244      * @param tags the first sentence tags for the doc
1245      * @param depr true if it is deprecated
1246      * @param first true if the first sentence tags should be added
1247      * @param inSummary true if the comment tags are added into the summary section
1248      * @param htmltree the documentation tree to which the comment tags will be added
1249      */
1250     private void addCommentTags(Element element, List&lt;? extends DocTree&gt; tags, boolean depr,
1251             boolean first, boolean inSummary, Content htmltree) {
1252         addCommentTags(element, null, tags, depr, first, inSummary, htmltree);
1253     }
1254 
1255     /**
1256      * Adds the comment tags.
1257      *
1258      * @param element for which the comment tags will be generated
1259      * @param holderTag the block tag context for the inline tags
1260      * @param tags the first sentence tags for the doc
1261      * @param depr true if it is deprecated
1262      * @param first true if the first sentence tags should be added
1263      * @param inSummary true if the comment tags are added into the summary section
1264      * @param htmltree the documentation tree to which the comment tags will be added
1265      */
1266     private void addCommentTags(Element element, DocTree holderTag, List&lt;? extends DocTree&gt; tags, boolean depr,
1267             boolean first, boolean inSummary, Content htmltree) {
1268         if (options.noComment()){
1269             return;
1270         }
1271         Content div;
1272         Content result = commentTagsToContent(null, element, tags, first, inSummary);
1273         if (depr) {
1274             div = HtmlTree.DIV(HtmlStyle.deprecationComment, result);
1275             htmltree.add(div);
1276         }
1277         else {
1278             div = HtmlTree.DIV(HtmlStyle.block, result);
1279             htmltree.add(div);
1280         }
1281         if (tags.isEmpty()) {
1282             htmltree.add(Entity.NO_BREAK_SPACE);
1283         }
1284     }
1285 
1286     boolean ignoreNonInlineTag(DocTree dtree) {
1287         Name name = null;
1288         if (dtree.getKind() == Kind.START_ELEMENT) {
1289             StartElementTree setree = (StartElementTree)dtree;
1290             name = setree.getName();
1291         } else if (dtree.getKind() == Kind.END_ELEMENT) {
1292             EndElementTree eetree = (EndElementTree)dtree;
1293             name = eetree.getName();
1294         }
1295 
1296         if (name != null) {
1297             com.sun.tools.doclint.HtmlTag htmlTag = com.sun.tools.doclint.HtmlTag.get(name);
1298             if (htmlTag != null &amp;&amp;
1299                     htmlTag.blockType != com.sun.tools.doclint.HtmlTag.BlockType.INLINE) {
1300                 return true;
1301             }
1302         }
1303         return false;
1304     }
1305 
1306     boolean isAllWhiteSpace(String body) {
1307         for (int i = 0 ; i &lt; body.length(); i++) {
1308             if (!Character.isWhitespace(body.charAt(i)))
1309                 return false;
1310         }
1311         return true;
1312     }
1313 
1314     // Notify the next DocTree handler to take necessary action
1315     private boolean commentRemoved = false;
1316 
1317     /**
1318      * Converts inline tags and text to Content, expanding the
1319      * inline tags along the way.  Called wherever text can contain
1320      * an inline tag, such as in comments or in free-form text arguments
1321      * to block tags.
1322      *
1323      * @param holderTag    specific tag where comment resides
1324      * @param element    specific element where comment resides
1325      * @param tags   array of text tags and inline tags (often alternating)
1326                present in the text of interest for this element
1327      * @param isFirstSentence  true if text is first sentence
1328      * @return a Content object
1329      */
1330     public Content commentTagsToContent(DocTree holderTag,
1331                                         Element element,
1332                                         List&lt;? extends DocTree&gt; tags,
1333                                         boolean isFirstSentence)
1334     {
1335         return commentTagsToContent(holderTag, element, tags, isFirstSentence, false);
1336     }
1337 
1338     /**
1339      * Converts inline tags and text to text strings, expanding the
1340      * inline tags along the way.  Called wherever text can contain
1341      * an inline tag, such as in comments or in free-form text arguments
1342      * to block tags.
1343      *
1344      * @param holderTag       specific tag where comment resides
1345      * @param element         specific element where comment resides
1346      * @param trees           array of text tags and inline tags (often alternating)
1347      *                        present in the text of interest for this element
1348      * @param isFirstSentence true if text is first sentence
1349      * @param inSummary       if the comment tags are added into the summary section
1350      * @return a Content object
1351      */
1352     public Content commentTagsToContent(DocTree holderTag,
1353                                         Element element,
1354                                         List&lt;? extends DocTree&gt; trees,
1355                                         boolean isFirstSentence,
1356                                         boolean inSummary)
1357     {
1358         final Content result = new ContentBuilder() {
1359             @Override
<a name="11" id="anc11"></a><span class="line-modified">1360             public void add(CharSequence text) {</span>
<span class="line-modified">1361                 super.add(utils.normalizeNewlines(text));</span>
1362             }
1363         };
1364         CommentHelper ch = utils.getCommentHelper(element);
1365         // Array of all possible inline tags for this javadoc run
1366         configuration.tagletManager.checkTags(element, trees, true);
1367         commentRemoved = false;
1368 
1369         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1370             boolean isFirstNode = !iterator.hasPrevious();
1371             DocTree tag = iterator.next();
1372             boolean isLastNode  = !iterator.hasNext();
1373 
1374             if (isFirstSentence) {
1375                 // Ignore block tags
1376                 if (ignoreNonInlineTag(tag))
1377                     continue;
1378 
1379                 // Ignore any trailing whitespace OR whitespace after removed html comment
1380                 if ((isLastNode || commentRemoved)
1381                         &amp;&amp; tag.getKind() == TEXT
1382                         &amp;&amp; isAllWhiteSpace(ch.getText(tag)))
1383                     continue;
1384 
1385                 // Ignore any leading html comments
1386                 if ((isFirstNode || commentRemoved) &amp;&amp; tag.getKind() == COMMENT) {
1387                     commentRemoved = true;
1388                     continue;
1389                 }
1390             }
1391 
1392             boolean allDone = new SimpleDocTreeVisitor&lt;Boolean, Content&gt;() {
1393 
1394                 private boolean inAnAtag() {
1395                     if (utils.isStartElement(tag)) {
1396                         StartElementTree st = (StartElementTree)tag;
1397                         Name name = st.getName();
1398                         if (name != null) {
1399                             com.sun.tools.doclint.HtmlTag htag =
1400                                     com.sun.tools.doclint.HtmlTag.get(name);
1401                             return htag != null &amp;&amp; htag.equals(com.sun.tools.doclint.HtmlTag.A);
1402                         }
1403                     }
1404                     return false;
1405                 }
1406 
1407                 @Override
1408                 public Boolean visitAttribute(AttributeTree node, Content c) {
1409                     StringBuilder sb = new StringBuilder(SPACER).append(node.getName());
1410                     if (node.getValueKind() == ValueKind.EMPTY) {
1411                         result.add(sb);
1412                         return false;
1413                     }
1414                     sb.append(&quot;=&quot;);
1415                     String quote;
1416                     switch (node.getValueKind()) {
1417                         case DOUBLE:
1418                             quote = &quot;\&quot;&quot;;
1419                             break;
1420                         case SINGLE:
1421                             quote = &quot;&#39;&quot;;
1422                             break;
1423                         default:
1424                             quote = &quot;&quot;;
1425                             break;
1426                     }
1427                     sb.append(quote);
1428                     result.add(sb);
1429                     Content docRootContent = new ContentBuilder();
1430 
1431                     boolean isHRef = inAnAtag() &amp;&amp; node.getName().toString().equalsIgnoreCase(&quot;href&quot;);
1432                     for (DocTree dt : node.getValue()) {
1433                         if (utils.isText(dt) &amp;&amp; isHRef) {
1434                             String text = ((TextTree) dt).getBody();
1435                             if (text.startsWith(&quot;/..&quot;) &amp;&amp; !options.docrootParent().isEmpty()) {
1436                                 result.add(options.docrootParent());
1437                                 docRootContent = new ContentBuilder();
1438                                 result.add(textCleanup(text.substring(3), isLastNode));
1439                             } else {
1440                                 if (!docRootContent.isEmpty()) {
1441                                     docRootContent = copyDocRootContent(docRootContent);
1442                                 } else {
1443                                     text = redirectRelativeLinks(element, (TextTree) dt);
1444                                 }
1445                                 result.add(textCleanup(text, isLastNode));
1446                             }
1447                         } else {
1448                             docRootContent = copyDocRootContent(docRootContent);
1449                             dt.accept(this, docRootContent);
1450                         }
1451                     }
1452                     copyDocRootContent(docRootContent);
1453                     result.add(quote);
1454                     return false;
1455                 }
1456 
1457                 @Override
1458                 public Boolean visitComment(CommentTree node, Content c) {
1459                     result.add(new RawHtml(node.getBody()));
1460                     return false;
1461                 }
1462 
1463                 private Content copyDocRootContent(Content content) {
1464                     if (!content.isEmpty()) {
1465                         result.add(content);
1466                         return new ContentBuilder();
1467                     }
1468                     return content;
1469                 }
1470 
1471                 @Override
1472                 public Boolean visitDocRoot(DocRootTree node, Content c) {
1473                     Content docRootContent = TagletWriter.getInlineTagOutput(element,
1474                             configuration.tagletManager,
1475                             holderTag,
1476                             node,
1477                             getTagletWriterInstance(isFirstSentence));
1478                     if (c != null) {
1479                         c.add(docRootContent);
1480                     } else {
1481                         result.add(docRootContent);
1482                     }
1483                     return false;
1484                 }
1485 
1486                 @Override
1487                 public Boolean visitEndElement(EndElementTree node, Content c) {
1488                     RawHtml rawHtml = new RawHtml(&quot;&lt;/&quot; + node.getName() + &quot;&gt;&quot;);
1489                     result.add(rawHtml);
1490                     return false;
1491                 }
1492 
1493                 @Override
1494                 public Boolean visitEntity(EntityTree node, Content c) {
1495                     result.add(new RawHtml(node.toString()));
1496                     return false;
1497                 }
1498 
1499                 @Override
1500                 public Boolean visitErroneous(ErroneousTree node, Content c) {
1501                     messages.warning(ch.getDocTreePath(node),
1502                             &quot;doclet.tag.invalid_usage&quot;, node);
1503                     result.add(new RawHtml(node.toString()));
1504                     return false;
1505                 }
1506 
1507                 @Override
1508                 public Boolean visitInheritDoc(InheritDocTree node, Content c) {
1509                     Content output = TagletWriter.getInlineTagOutput(element,
1510                             configuration.tagletManager, holderTag,
1511                             tag, getTagletWriterInstance(isFirstSentence));
1512                     result.add(output);
1513                     // if we obtained the first sentence successfully, nothing more to do
1514                     return (isFirstSentence &amp;&amp; !output.isEmpty());
1515                 }
1516 
1517                 @Override
1518                 public Boolean visitIndex(IndexTree node, Content p) {
1519                     Content output = TagletWriter.getInlineTagOutput(element,
1520                             configuration.tagletManager, holderTag, tag,
1521                             getTagletWriterInstance(isFirstSentence, inSummary));
1522                     if (output != null) {
1523                         result.add(output);
1524                     }
1525                     return false;
1526                 }
1527 
1528                 @Override
1529                 public Boolean visitLink(LinkTree node, Content c) {
1530                     // we need to pass the DocTreeImpl here, so ignore node
1531                     Content content = seeTagToContent(element, tag);
1532                     result.add(content);
1533                     return false;
1534                 }
1535 
1536                 @Override
1537                 public Boolean visitLiteral(LiteralTree node, Content c) {
1538                     String s = node.getBody().getBody();
1539                     Content content = new StringContent(utils.normalizeNewlines(s));
1540                     if (node.getKind() == CODE)
1541                         content = HtmlTree.CODE(content);
1542                     result.add(content);
1543                     return false;
1544                 }
1545 
1546                 @Override
1547                 public Boolean visitSee(SeeTree node, Content c) {
1548                     // we need to pass the DocTreeImpl here, so ignore node
1549                     result.add(seeTagToContent(element, tag));
1550                     return false;
1551                 }
1552 
1553                 @Override
1554                 public Boolean visitStartElement(StartElementTree node, Content c) {
1555                     String text = &quot;&lt;&quot; + node.getName();
1556                     RawHtml rawHtml = new RawHtml(utils.normalizeNewlines(text));
1557                     result.add(rawHtml);
1558 
1559                     for (DocTree dt : node.getAttributes()) {
1560                         dt.accept(this, null);
1561                     }
1562                     result.add(new RawHtml(node.isSelfClosing() ? &quot;/&gt;&quot; : &quot;&gt;&quot;));
1563                     return false;
1564                 }
1565 
1566                 @Override
1567                 public Boolean visitSummary(SummaryTree node, Content c) {
1568                     Content output = TagletWriter.getInlineTagOutput(element,
1569                             configuration.tagletManager, holderTag, tag,
1570                             getTagletWriterInstance(isFirstSentence));
1571                     result.add(output);
1572                     return false;
1573                 }
1574 
1575                 @Override
1576                 public Boolean visitSystemProperty(SystemPropertyTree node, Content p) {
1577                     Content output = TagletWriter.getInlineTagOutput(element,
1578                             configuration.tagletManager, holderTag, tag,
1579                             getTagletWriterInstance(isFirstSentence, inSummary));
1580                     if (output != null) {
1581                         result.add(output);
1582                     }
1583                     return false;
1584                 }
1585 
1586                 private CharSequence textCleanup(String text, boolean isLast) {
1587                     return textCleanup(text, isLast, false);
1588                 }
1589 
1590                 private CharSequence textCleanup(String text, boolean isLast, boolean stripLeading) {
1591                     boolean stripTrailing = isFirstSentence &amp;&amp; isLast;
1592                     if (stripLeading &amp;&amp; stripTrailing) {
1593                         text = text.strip();
1594                     } else if (stripLeading) {
1595                         text = text.stripLeading();
1596                     } else if (stripTrailing) {
1597                         text = text.stripTrailing();
1598                     }
1599                     text = utils.replaceTabs(text);
1600                     return utils.normalizeNewlines(text);
1601                 }
1602 
1603                 @Override
1604                 public Boolean visitText(TextTree node, Content c) {
1605                     String text = node.getBody();
1606                     result.add(new RawHtml(textCleanup(text, isLastNode, commentRemoved)));
1607                     return false;
1608                 }
1609 
1610                 @Override
1611                 protected Boolean defaultAction(DocTree node, Content c) {
1612                     Content output = TagletWriter.getInlineTagOutput(element,
1613                             configuration.tagletManager, holderTag, tag,
1614                             getTagletWriterInstance(isFirstSentence));
1615                     if (output != null) {
1616                         result.add(output);
1617                     }
1618                     return false;
1619                 }
1620 
1621             }.visit(tag, null);
1622             commentRemoved = false;
1623             if (allDone)
1624                 break;
1625         }
1626         return result;
1627     }
1628 
1629     /**
1630      * Return true if relative links should not be redirected.
1631      *
1632      * @return Return true if a relative link should not be redirected.
1633      */
1634     private boolean shouldNotRedirectRelativeLinks() {
<a name="12" id="anc12"></a><span class="line-modified">1635         return  this instanceof AnnotationTypeWriter ||</span>
<span class="line-removed">1636                 this instanceof ClassWriter ||</span>
1637                 this instanceof PackageSummaryWriter;
1638     }
1639 
1640     /**
1641      * Suppose a piece of documentation has a relative link.  When you copy
1642      * that documentation to another place such as the index or class-use page,
1643      * that relative link will no longer work.  We should redirect those links
1644      * so that they will work again.
1645      * &lt;p&gt;
1646      * Here is the algorithm used to fix the link:
1647      * &lt;p&gt;
1648      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1649      * &lt;p&gt;
1650      * For example, suppose DocletEnvironment has this link:
1651      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1652      * &lt;p&gt;
1653      * If this link appeared in the index, we would redirect
1654      * the link like this:
1655      *
1656      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
1657      *
1658      * @param element the Element object whose documentation is being written.
1659      * @param tt the text being written.
1660      *
1661      * @return the text, with all the relative links redirected to work.
1662      */
1663     @SuppressWarnings(&quot;preview&quot;)
1664     private String redirectRelativeLinks(Element element, TextTree tt) {
1665         String text = tt.getBody();
1666         if (element == null || utils.isOverviewElement(element) || shouldNotRedirectRelativeLinks()) {
1667             return text;
1668         }
1669 
1670         DocPath redirectPathFromRoot = new SimpleElementVisitor14&lt;DocPath, Void&gt;() {
1671             @Override
1672             public DocPath visitType(TypeElement e, Void p) {
1673                 return docPaths.forPackage(utils.containingPackage(e));
1674             }
1675 
1676             @Override
1677             public DocPath visitPackage(PackageElement e, Void p) {
1678                 return docPaths.forPackage(e);
1679             }
1680 
1681             @Override
1682             public DocPath visitVariable(VariableElement e, Void p) {
1683                 return docPaths.forPackage(utils.containingPackage(e));
1684             }
1685 
1686             @Override
1687             public DocPath visitExecutable(ExecutableElement e, Void p) {
1688                 return docPaths.forPackage(utils.containingPackage(e));
1689             }
1690 
1691             @Override
1692             protected DocPath defaultAction(Element e, Void p) {
1693                 return null;
1694             }
1695         }.visit(element);
1696         if (redirectPathFromRoot == null) {
1697             return text;
1698         }
1699         String lower = Utils.toLowerCase(text);
1700         if (!(lower.startsWith(&quot;mailto:&quot;)
1701                 || lower.startsWith(&quot;http:&quot;)
1702                 || lower.startsWith(&quot;https:&quot;)
1703                 || lower.startsWith(&quot;file:&quot;))) {
1704             text = &quot;{@&quot; + (new DocRootTaglet()).getName() + &quot;}/&quot;
1705                     + redirectPathFromRoot.resolve(text).getPath();
1706             text = replaceDocRootDir(text);
1707         }
1708         return text;
1709     }
1710 
1711     /**
1712      * According to
1713      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,
1714      * all the outer classes and static nested classes are core classes.
1715      */
1716     public boolean isCoreClass(TypeElement typeElement) {
1717         return utils.getEnclosingTypeElement(typeElement) == null || utils.isStatic(typeElement);
1718     }
1719 
1720     /**
1721      * Adds the annotation types for the given packageElement.
1722      *
1723      * @param packageElement the package to write annotations for.
1724      * @param htmltree the documentation tree to which the annotation info will be
1725      *        added
1726      */
1727     public void addAnnotationInfo(PackageElement packageElement, Content htmltree) {
1728         addAnnotationInfo(packageElement.getAnnotationMirrors(), htmltree);
1729     }
1730 
1731     /*
1732      * this is a hack to delay dealing with Annotations in the writers, the assumption
1733      * is that all necessary checks have been made to get here.
1734      */
1735     public void addReceiverAnnotationInfo(ExecutableElement method, TypeMirror rcvrTypeMirror,
1736             List&lt;? extends AnnotationMirror&gt; annotationMirrors, Content htmltree) {
1737         TypeMirror rcvrType = method.getReceiverType();
1738         List&lt;? extends AnnotationMirror&gt; annotationMirrors1 = rcvrType.getAnnotationMirrors();
1739         htmltree.add(getAnnotationInfo(annotationMirrors1, false));
1740     }
1741 
1742     /**
1743      * Adds the annotation types for the given element.
1744      *
1745      * @param element the package to write annotations for
1746      * @param htmltree the content tree to which the annotation types will be added
1747      */
1748     public void addAnnotationInfo(Element element, Content htmltree) {
1749         addAnnotationInfo(element.getAnnotationMirrors(), htmltree);
1750     }
1751 
1752     /**
1753      * Add the annotation types for the given element and parameter.
1754      *
1755      * @param param the parameter to write annotations for.
1756      * @param tree the content tree to which the annotation types will be added
1757      */
1758     public boolean addAnnotationInfo(VariableElement param, Content tree) {
1759         Content annotationInfo = getAnnotationInfo(param.getAnnotationMirrors(), false);
1760         if (annotationInfo.isEmpty()) {
1761             return false;
1762         }
1763         tree.add(annotationInfo);
1764         return true;
1765     }
1766 
1767     /**
1768      * Adds the annotation types for the given Element.
1769      *
1770      * @param descList a list of annotation mirrors.
1771      * @param htmltree the documentation tree to which the annotation info will be
1772      *        added
1773      */
1774     private void addAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, Content htmltree) {
1775         htmltree.add(getAnnotationInfo(descList, true));
1776     }
1777 
1778     /**
1779      * Return a content tree containing the annotation types for the given element.
1780      *
1781      * @param descList a list of annotation mirrors.
1782      * @return the documentation tree containing the annotation info.
1783      */
1784     Content getAnnotationInfo(List&lt;? extends AnnotationMirror&gt; descList, boolean lineBreak) {
1785         List&lt;Content&gt; annotations = getAnnotations(descList, lineBreak);
1786         String sep = &quot;&quot;;
1787         ContentBuilder builder = new ContentBuilder();
1788         for (Content annotation: annotations) {
1789             builder.add(sep);
1790             builder.add(annotation);
1791             if (!lineBreak) {
1792                 sep = &quot; &quot;;
1793             }
1794         }
1795         return builder;
1796     }
1797 
1798     /**
1799      * Return the string representations of the annotation types for
1800      * the given doc.
1801      *
1802      * @param descList a list of annotation mirrors.
1803      * @param linkBreak if true, add new line between each member value.
1804      * @return a list of strings representing the annotations being
1805      *         documented.
1806      */
1807     public List&lt;Content&gt; getAnnotations(List&lt;? extends AnnotationMirror&gt; descList, boolean linkBreak) {
1808         List&lt;Content&gt; results = new ArrayList&lt;&gt;();
1809         ContentBuilder annotation;
1810         for (AnnotationMirror aDesc : descList) {
1811             TypeElement annotationElement = (TypeElement)aDesc.getAnnotationType().asElement();
1812             // If an annotation is not documented, do not add it to the list. If
1813             // the annotation is of a repeatable type, and if it is not documented
1814             // and also if its container annotation is not documented, do not add it
1815             // to the list. If an annotation of a repeatable type is not documented
1816             // but its container is documented, it will be added to the list.
1817             if (!utils.isDocumentedAnnotation(annotationElement) &amp;&amp;
1818                 (!isAnnotationDocumented &amp;&amp; !isContainerDocumented)) {
1819                 continue;
1820             }
1821             annotation = new ContentBuilder();
1822             isAnnotationDocumented = false;
1823             LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
1824                                                      LinkInfoImpl.Kind.ANNOTATION, annotationElement);
1825             Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs = aDesc.getElementValues();
1826             // If the annotation is synthesized, do not print the container.
1827             if (utils.configuration.workArounds.isSynthesized(aDesc)) {
1828                 for (ExecutableElement ee : pairs.keySet()) {
1829                     AnnotationValue annotationValue = pairs.get(ee);
1830                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1831 
1832                     new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1833                         @Override
1834                         public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; p) {
1835                             p.addAll(vals);
1836                             return null;
1837                         }
1838 
1839                         @Override
1840                         protected Void defaultAction(Object o, List&lt;AnnotationValue&gt; p) {
1841                             p.add(annotationValue);
1842                             return null;
1843                         }
1844                     }.visit(annotationValue, annotationTypeValues);
1845 
1846                     String sep = &quot;&quot;;
1847                     for (AnnotationValue av : annotationTypeValues) {
1848                         annotation.add(sep);
1849                         annotation.add(annotationValueToContent(av));
1850                         sep = &quot; &quot;;
1851                     }
1852                 }
1853             } else if (isAnnotationArray(pairs)) {
1854                 // If the container has 1 or more value defined and if the
1855                 // repeatable type annotation is not documented, do not print
1856                 // the container.
1857                 if (pairs.size() == 1 &amp;&amp; isAnnotationDocumented) {
1858                     List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1859                     for (AnnotationValue a :  pairs.values()) {
1860                         new SimpleAnnotationValueVisitor9&lt;Void, List&lt;AnnotationValue&gt;&gt;() {
1861                             @Override
1862                             public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;AnnotationValue&gt; annotationTypeValues) {
1863                                annotationTypeValues.addAll(vals);
1864                                return null;
1865                             }
1866                         }.visit(a, annotationTypeValues);
1867                     }
1868                     String sep = &quot;&quot;;
1869                     for (AnnotationValue av : annotationTypeValues) {
1870                         annotation.add(sep);
1871                         annotation.add(annotationValueToContent(av));
1872                         sep = &quot; &quot;;
1873                     }
1874                 }
1875                 // If the container has 1 or more value defined and if the
1876                 // repeatable type annotation is not documented, print the container.
1877                 else {
1878                     addAnnotations(annotationElement, linkInfo, annotation, pairs, false);
1879                 }
1880             }
1881             else {
1882                 addAnnotations(annotationElement, linkInfo, annotation, pairs, linkBreak);
1883             }
1884             annotation.add(linkBreak ? DocletConstants.NL : &quot;&quot;);
1885             results.add(annotation);
1886         }
1887         return results;
1888     }
1889 
1890     /**
1891      * Add annotation to the annotation string.
1892      *
1893      * @param annotationDoc the annotation being documented
1894      * @param linkInfo the information about the link
1895      * @param annotation the annotation string to which the annotation will be added
1896      * @param map annotation type element to annotation value pairs
1897      * @param linkBreak if true, add new line between each member value
1898      */
1899     private void addAnnotations(TypeElement annotationDoc, LinkInfoImpl linkInfo,
1900                                 ContentBuilder annotation,
1901                                 Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; map,
1902                                 boolean linkBreak) {
1903         linkInfo.label = new StringContent(&quot;@&quot;);
1904         linkInfo.label.add(annotationDoc.getSimpleName());
1905         annotation.add(getLink(linkInfo));
1906         if (!map.isEmpty()) {
1907             annotation.add(&quot;(&quot;);
1908             boolean isFirst = true;
1909             Set&lt;? extends ExecutableElement&gt; keys = map.keySet();
1910             boolean multipleValues = keys.size() &gt; 1;
1911             for (ExecutableElement element : keys) {
1912                 if (isFirst) {
1913                     isFirst = false;
1914                 } else {
1915                     annotation.add(&quot;,&quot;);
1916                     if (linkBreak) {
1917                         annotation.add(DocletConstants.NL);
1918                         int spaces = annotationDoc.getSimpleName().length() + 2;
1919                         for (int k = 0; k &lt; (spaces); k++) {
1920                             annotation.add(&quot; &quot;);
1921                         }
1922                     }
1923                 }
1924                 String simpleName = element.getSimpleName().toString();
1925                 if (multipleValues || !&quot;value&quot;.equals(simpleName)) { // Omit &quot;value=&quot; where unnecessary
1926                     annotation.add(getDocLink(LinkInfoImpl.Kind.ANNOTATION,
1927                                                      element, simpleName, false));
1928                     annotation.add(&quot;=&quot;);
1929                 }
1930                 AnnotationValue annotationValue = map.get(element);
1931                 List&lt;AnnotationValue&gt; annotationTypeValues = new ArrayList&lt;&gt;();
1932                 new SimpleAnnotationValueVisitor9&lt;Void, AnnotationValue&gt;() {
1933                     @Override
1934                     public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, AnnotationValue p) {
1935                         annotationTypeValues.addAll(vals);
1936                         return null;
1937                     }
1938                     @Override
1939                     protected Void defaultAction(Object o, AnnotationValue p) {
1940                         annotationTypeValues.add(p);
1941                         return null;
1942                     }
1943                 }.visit(annotationValue, annotationValue);
1944                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;{&quot;);
1945                 String sep = &quot;&quot;;
1946                 for (AnnotationValue av : annotationTypeValues) {
1947                     annotation.add(sep);
1948                     annotation.add(annotationValueToContent(av));
1949                     sep = &quot;,&quot;;
1950                 }
1951                 annotation.add(annotationTypeValues.size() == 1 ? &quot;&quot; : &quot;}&quot;);
1952                 isContainerDocumented = false;
1953             }
1954             annotation.add(&quot;)&quot;);
1955         }
1956     }
1957 
1958     /**
1959      * Check if the annotation contains an array of annotation as a value. This
1960      * check is to verify if a repeatable type annotation is present or not.
1961      *
1962      * @param pairs annotation type element and value pairs
1963      *
1964      * @return true if the annotation contains an array of annotation as a value.
1965      */
1966     private boolean isAnnotationArray(Map&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; pairs) {
1967         AnnotationValue annotationValue;
1968         for (ExecutableElement ee : pairs.keySet()) {
1969             annotationValue = pairs.get(ee);
1970             boolean rvalue = new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1971                 @Override
1972                 public Boolean visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
1973                     if (vals.size() &gt; 1) {
1974                         if (vals.get(0) instanceof AnnotationMirror) {
1975                             isContainerDocumented = true;
1976                             return new SimpleAnnotationValueVisitor9&lt;Boolean, Void&gt;() {
1977                                 @Override
1978                                 public Boolean visitAnnotation(AnnotationMirror a, Void p) {
1979                                     isContainerDocumented = true;
1980                                     Element asElement = a.getAnnotationType().asElement();
1981                                     if (utils.isDocumentedAnnotation((TypeElement)asElement)) {
1982                                         isAnnotationDocumented = true;
1983                                     }
1984                                     return true;
1985                                 }
1986                                 @Override
1987                                 protected Boolean defaultAction(Object o, Void p) {
1988                                     return false;
1989                                 }
1990                             }.visit(vals.get(0));
1991                         }
1992                     }
1993                     return false;
1994                 }
1995 
1996                 @Override
1997                 protected Boolean defaultAction(Object o, Void p) {
1998                     return false;
1999                 }
2000             }.visit(annotationValue);
2001             if (rvalue) {
2002                 return true;
2003             }
2004         }
2005         return false;
2006     }
2007 
2008     private Content annotationValueToContent(AnnotationValue annotationValue) {
2009         return new SimpleAnnotationValueVisitor9&lt;Content, Void&gt;() {
2010 
2011             @Override
2012             public Content visitType(TypeMirror t, Void p) {
2013                 return new SimpleTypeVisitor9&lt;Content, Void&gt;() {
2014                     @Override
2015                     public Content visitDeclared(DeclaredType t, Void p) {
2016                         LinkInfoImpl linkInfo = new LinkInfoImpl(configuration,
2017                                 LinkInfoImpl.Kind.ANNOTATION, t);
2018                         String name = utils.isIncluded(t.asElement())
2019                                 ? t.asElement().getSimpleName().toString()
2020                                 : utils.getFullyQualifiedName(t.asElement());
2021                         linkInfo.label = new StringContent(name + utils.getDimension(t) + &quot;.class&quot;);
2022                         return getLink(linkInfo);
2023                     }
2024                     @Override
2025                     protected Content defaultAction(TypeMirror e, Void p) {
2026                         return new StringContent(t + utils.getDimension(t) + &quot;.class&quot;);
2027                     }
2028                 }.visit(t);
2029             }
2030             @Override
2031             public Content visitAnnotation(AnnotationMirror a, Void p) {
2032                 List&lt;Content&gt; list = getAnnotations(List.of(a), false);
2033                 ContentBuilder buf = new ContentBuilder();
2034                 for (Content c : list) {
2035                     buf.add(c);
2036                 }
2037                 return buf;
2038             }
2039             @Override
2040             public Content visitEnumConstant(VariableElement c, Void p) {
2041                 return getDocLink(LinkInfoImpl.Kind.ANNOTATION,
2042                         c, c.getSimpleName(), false);
2043             }
2044             @Override
2045             public Content visitArray(List&lt;? extends AnnotationValue&gt; vals, Void p) {
2046                 ContentBuilder buf = new ContentBuilder();
2047                 String sep = &quot;&quot;;
2048                 for (AnnotationValue av : vals) {
2049                     buf.add(sep);
2050                     buf.add(visit(av));
2051                     sep = &quot; &quot;;
2052                 }
2053                 return buf;
2054             }
2055             @Override
2056             protected Content defaultAction(Object o, Void p) {
2057                 return new StringContent(annotationValue.toString());
2058             }
2059         }.visit(annotationValue);
2060     }
2061 
2062     protected TableHeader getPackageTableHeader() {
2063         return new TableHeader(contents.packageLabel, contents.descriptionLabel);
2064     }
2065 
2066     /**
2067      * Generates a string for use in a description meta element,
2068      * based on an element and its enclosing elements
2069      * @param prefix a prefix for the string
2070      * @param elem the element
2071      * @return the description
2072      */
2073     static String getDescription(String prefix, Element elem) {
2074         LinkedList&lt;Element&gt; chain = new LinkedList&lt;&gt;();
2075         for (Element e = elem; e != null; e = e.getEnclosingElement()) {
2076             // ignore unnamed enclosing elements
2077             if (e.getSimpleName().length() == 0 &amp;&amp; e != elem) {
2078                 break;
2079             }
2080             chain.addFirst(e);
2081         }
2082         StringBuilder sb = new StringBuilder();
2083         for (Element e: chain) {
2084             CharSequence name;
2085             switch (e.getKind()) {
2086                 case MODULE:
2087                 case PACKAGE:
2088                     name = ((QualifiedNameable) e).getQualifiedName();
2089                     if (name.length() == 0) {
2090                         name = &quot;&lt;unnamed&gt;&quot;;
2091                     }
2092                     break;
2093 
2094                 default:
2095                     name = e.getSimpleName();
2096                     break;
2097             }
2098 
2099             if (sb.length() == 0) {
2100                 sb.append(prefix).append(&quot;: &quot;);
2101             } else {
2102                 sb.append(&quot;, &quot;);
2103             }
2104             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2105                     .append(&quot;: &quot;)
2106                     .append(name);
2107         }
2108         return sb.toString();
2109     }
2110 
2111     static String getGenerator(Class&lt;?&gt; clazz) {
2112         return &quot;javadoc/&quot; + clazz.getSimpleName();
2113     }
2114 
2115     /**
2116      * Returns an HtmlTree for the BODY tag.
2117      *
2118      * @param title title for the window
2119      * @return an HtmlTree for the BODY tag
2120      */
2121     public HtmlTree getBody(String title) {
<a name="13" id="anc13"></a><span class="line-modified">2122         HtmlTree body = new HtmlTree(HtmlTag.BODY);</span>
<span class="line-removed">2123         body.put(HtmlAttr.CLASS, getBodyClass());</span>
2124 
2125         this.winTitle = title;
2126         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2127         // and package-frame
2128         body.add(mainBodyScript.asContent());
2129         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2130         body.add(noScript);
2131         return body;
2132     }
2133 
<a name="14" id="anc14"></a><span class="line-modified">2134     public String getBodyClass() {</span>
<span class="line-modified">2135         return getClass().getSimpleName()</span>
2136                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2137                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
<a name="15" id="anc15"></a><span class="line-modified">2138                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)</span>
<span class="line-modified">2139                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)</span>
<span class="line-modified">2140                 .toLowerCase(Locale.US);</span>
2141     }
2142 
2143     Script getMainBodyScript() {
2144         return mainBodyScript;
2145     }
2146 
2147     /**
2148      * Returns the path of module/package specific stylesheets for the element.
2149      * @param element module/Package element
2150      * @return list of path of module/package specific stylesheets
2151      * @throws DocFileIOException
2152      */
2153     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2154         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2155         DocPath basePath = null;
2156         if (element instanceof PackageElement) {
2157             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2158             basePath = docPaths.forPackage((PackageElement)element);
2159         } else if (element instanceof ModuleElement) {
2160             basePath = DocPaths.forModule((ModuleElement)element);
2161         }
2162         for (DocPath stylesheet : getStylesheets(element)) {
2163             stylesheets.add(basePath.resolve(stylesheet.getPath()));
2164         }
2165         return stylesheets;
2166     }
2167 
2168     private List&lt;DocPath&gt; getModuleStylesheets(PackageElement pkgElement) throws
2169             DocFileIOException {
2170         List&lt;DocPath&gt; moduleStylesheets = new ArrayList&lt;&gt;();
2171         ModuleElement moduleElement = utils.containingModule(pkgElement);
2172         if (moduleElement != null &amp;&amp; !moduleElement.isUnnamed()) {
2173             List&lt;DocPath&gt; localStylesheets = getStylesheets(moduleElement);
2174             DocPath basePath = DocPaths.forModule(moduleElement);
2175             for (DocPath stylesheet : localStylesheets) {
2176                 moduleStylesheets.add(basePath.resolve(stylesheet));
2177             }
2178         }
2179         return moduleStylesheets;
2180     }
2181 
2182     private List&lt;DocPath&gt; getStylesheets(Element element) throws DocFileIOException {
2183         List&lt;DocPath&gt; localStylesheets = configuration.localStylesheetMap.get(element);
2184         if (localStylesheets == null) {
2185             DocFilesHandlerImpl docFilesHandler = (DocFilesHandlerImpl)configuration
2186                     .getWriterFactory().getDocFilesHandler(element);
2187             localStylesheets = docFilesHandler.getStylesheets();
2188             configuration.localStylesheetMap.put(element, localStylesheets);
2189         }
2190         return localStylesheets;
2191     }
2192 
2193     Content getVerticalSeparator() {
2194         return HtmlTree.SPAN(HtmlStyle.verticalSeparator, new FixedStringContent(&quot;|&quot;));
2195     }
2196 }
<a name="16" id="anc16"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="16" type="hidden" />
</body>
</html>
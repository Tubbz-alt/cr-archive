<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Utils.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jconsole/share/classes/module-info.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 92,11 ***</span>
          INNER_CLASSES,
          ENUM_CONSTANTS,
          FIELDS,
          CONSTRUCTORS,
          METHODS,
<span class="line-removed">-         ANNOTATION_TYPE_FIELDS,</span>
          ANNOTATION_TYPE_MEMBER_OPTIONAL,
          ANNOTATION_TYPE_MEMBER_REQUIRED,
          PROPERTIES;
  
          public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
<span class="line-new-header">--- 92,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 113,12 ***</span>
  
      private List&lt;VisibleMemberTable&gt; allSuperclasses;
      private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
      private List&lt;VisibleMemberTable&gt; parents;
  
<span class="line-removed">- </span>
<span class="line-removed">-     private Map&lt;Kind, List&lt;Element&gt;&gt; extraMembers = new EnumMap&lt;&gt;(Kind.class);</span>
      private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
      private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
  
      // Keeps track of method overrides
      Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
<span class="line-new-header">--- 112,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 147,15 ***</span>
          }
          computeParents();
          computeVisibleMembers();
      }
  
<span class="line-removed">-     List&lt;? extends Element&gt; getExtraMembers(Kind kind) {</span>
<span class="line-removed">-         ensureInitialized();</span>
<span class="line-removed">-         return visibleMembers.getOrDefault(kind, Collections.emptyList());</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
      List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
          ensureInitialized();
          return allSuperclasses;
      }
  
<span class="line-new-header">--- 144,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 285,11 ***</span>
                  .forEach(result::add);
  
          // ... and finally the sorted super interfaces.
          allSuperinterfaces.stream()
                  .map(vmt -&gt; vmt.te)
<span class="line-modified">!                 .sorted(utils.makeGeneralPurposeComparator())</span>
                  .forEach(result::add);
  
          return result;
      }
  
<span class="line-new-header">--- 277,11 ---</span>
                  .forEach(result::add);
  
          // ... and finally the sorted super interfaces.
          allSuperinterfaces.stream()
                  .map(vmt -&gt; vmt.te)
<span class="line-modified">!                 .sorted(utils.comparators.makeGeneralPurposeComparator())</span>
                  .forEach(result::add);
  
          return result;
      }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 350,10 ***</span>
<span class="line-new-header">--- 342,15 ---</span>
          PropertyMembers pm =  propertyMap.get(propertyMethod);
          return pm == null ? null : pm.setter;
      }
  
      private void computeParents() {
<span class="line-added">+         // suppress parents of annotation types</span>
<span class="line-added">+         if (utils.isAnnotationType(te)) {</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+ </span>
          for (TypeMirror intfType : te.getInterfaces()) {
              TypeElement intfc = utils.asTypeElement(intfType);
              if (intfc != null) {
                  VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
                  allSuperinterfaces.add(vmt);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 377,25 ***</span>
          // Note: these have some baggage, and are redundant,
          // allow this to be GC&#39;ed.
          LocalMemberTable lmt = new LocalMemberTable();
  
          for (Kind k : Kind.values()) {
<span class="line-removed">-             computeLeafMembers(lmt, k);</span>
              computeVisibleMembers(lmt, k);
          }
          // All members have been computed, compute properties.
          computeVisibleProperties(lmt);
      }
  
<span class="line-removed">-     private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {</span>
<span class="line-removed">-         List&lt;Element&gt; list = new ArrayList&lt;&gt;();</span>
<span class="line-removed">-         if (utils.isUndocumentedEnclosure(te)) {</span>
<span class="line-removed">-             list.addAll(lmt.getOrderedMembers(kind));</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         parents.forEach(pvmt -&gt; list.addAll(pvmt.getExtraMembers(kind)));</span>
<span class="line-removed">-         extraMembers.put(kind, Collections.unmodifiableList(list));</span>
<span class="line-removed">-     }</span>
  
      void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
          switch (kind) {
              case FIELDS: case INNER_CLASSES:
                  computeVisibleFieldsAndInnerClasses(lmt, kind);
<span class="line-new-header">--- 374,16 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 451,11 ***</span>
      }
  
      private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
          Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
          for (VisibleMemberTable pvmt : parents) {
<span class="line-removed">-             result.addAll(pvmt.getExtraMembers(kind));</span>
              result.addAll(pvmt.getAllVisibleMembers(kind));
          }
  
          // Filter out members in the inherited list that are hidden
          // by this type or should not be inherited at all.
<span class="line-new-header">--- 439,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 486,36 ***</span>
                              k -&gt; new ArrayList&lt;&gt;());
                      list.add(e.getKey());
                  }
              });
              inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));
<span class="line-removed">- </span>
<span class="line-removed">-             // Copy the extra members (if any) from the lineage.</span>
<span class="line-removed">-             if (!utils.shouldDocument(pvmt.te)) {</span>
<span class="line-removed">-                 List&lt;? extends Element&gt; extraMethods = pvmt.getExtraMembers(Kind.METHODS);</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 if (lmt.getOrderedMembers(Kind.METHODS).isEmpty()) {</span>
<span class="line-removed">-                     inheritedMethods.addAll(extraMethods);</span>
<span class="line-removed">-                     continue;</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">- </span>
<span class="line-removed">-                 // Check if an extra-method ought to percolate through.</span>
<span class="line-removed">-                 for (Element extraMethod : extraMethods) {</span>
<span class="line-removed">-                     boolean found = false;</span>
<span class="line-removed">- </span>
<span class="line-removed">-                     List&lt;Element&gt; lmethods = lmt.getMembers(extraMethod, Kind.METHODS);</span>
<span class="line-removed">-                     for (Element lmethod : lmethods) {</span>
<span class="line-removed">-                         ExecutableElement method = (ExecutableElement)lmethod;</span>
<span class="line-removed">-                         found = utils.elementUtils.overrides(method,</span>
<span class="line-removed">-                                 (ExecutableElement)extraMethod, te);</span>
<span class="line-removed">-                         if (found)</span>
<span class="line-removed">-                             break;</span>
<span class="line-removed">-                     }</span>
<span class="line-removed">-                     if (!found)</span>
<span class="line-removed">-                         inheritedMethods.add(extraMethod);</span>
<span class="line-removed">-                 }</span>
<span class="line-removed">-             }</span>
          }
  
          // Filter out inherited methods that:
          // a. cannot override (private instance members)
          // b. are overridden and should not be visible in this type
<span class="line-new-header">--- 473,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 530,19 ***</span>
          // be visible.
          Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
              OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
              return p == null || !p.simpleOverride;
          };
<span class="line-modified">!         List&lt;Element&gt; mlist = lmt.getOrderedMembers(Kind.METHODS);</span>
<span class="line-modified">!         List&lt;Element&gt; llist = mlist.stream()</span>
                  .map(m -&gt; (ExecutableElement)m)
                  .filter(isVisible)
                  .collect(Collectors.toList());
  
<span class="line-modified">!         // Merge the above lists, making sure the local methods precede</span>
<span class="line-modified">!         // the others</span>
<span class="line-removed">-         list.addAll(0, llist);</span>
  
          // Final filtration of elements
          list = list.stream()
                  .filter(this::mustDocument)
                  .collect(Collectors.toList());
<span class="line-new-header">--- 491,18 ---</span>
          // be visible.
          Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
              OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
              return p == null || !p.simpleOverride;
          };
<span class="line-modified">!         List&lt;Element&gt; localList = lmt.getOrderedMembers(Kind.METHODS)</span>
<span class="line-modified">!                 .stream()</span>
                  .map(m -&gt; (ExecutableElement)m)
                  .filter(isVisible)
                  .collect(Collectors.toList());
  
<span class="line-modified">!         // Merge the above lists, making sure the local methods precede the others</span>
<span class="line-modified">!         list.addAll(0, localList);</span>
  
          // Final filtration of elements
          list = list.stream()
                  .filter(this::mustDocument)
                  .collect(Collectors.toList());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 671,20 ***</span>
                      case RECORD:
                          addMember(e, Kind.INNER_CLASSES);
                          break;
                      case FIELD:
                          addMember(e, Kind.FIELDS);
<span class="line-removed">-                         addMember(e, Kind.ANNOTATION_TYPE_FIELDS);</span>
                          break;
                      case METHOD:
<span class="line-removed">-                         ExecutableElement ee = (ExecutableElement)e;</span>
                          if (utils.isAnnotationType(te)) {
                              addMember(e, ee.getDefaultValue() == null
                                      ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
                                      : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
                          }
<span class="line-removed">-                         addMember(e, Kind.METHODS);</span>
                          break;
                      case CONSTRUCTOR:
                              addMember(e, Kind.CONSTRUCTORS);
                          break;
                      case ENUM_CONSTANT:
<span class="line-new-header">--- 631,20 ---</span>
                      case RECORD:
                          addMember(e, Kind.INNER_CLASSES);
                          break;
                      case FIELD:
                          addMember(e, Kind.FIELDS);
                          break;
                      case METHOD:
                          if (utils.isAnnotationType(te)) {
<span class="line-added">+                             ExecutableElement ee = (ExecutableElement) e;</span>
                              addMember(e, ee.getDefaultValue() == null
                                      ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
                                      : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
<span class="line-added">+                         } else {</span>
<span class="line-added">+                             addMember(e, Kind.METHODS);</span>
                          }
                          break;
                      case CONSTRUCTOR:
                              addMember(e, Kind.CONSTRUCTORS);
                          break;
                      case ENUM_CONSTANT:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 891,16 ***</span>
  
      private class ImplementedMethods {
  
          private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
          private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
<span class="line-removed">-         private final TypeElement typeElement;</span>
<span class="line-removed">-         private final ExecutableElement method;</span>
  
          public ImplementedMethods(ExecutableElement method) {
<span class="line-modified">!             this.method = method;</span>
<span class="line-removed">-             typeElement = utils.getEnclosingTypeElement(method);</span>
              Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
              /*
               * Search for the method in the list of interfaces. If found check if it is
               * overridden by any other subinterface method which this class
               * implements. If it is not overridden, add it in the method list.
<span class="line-new-header">--- 851,13 ---</span>
  
      private class ImplementedMethods {
  
          private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
          private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
  
          public ImplementedMethods(ExecutableElement method) {
<span class="line-modified">!             TypeElement typeElement = utils.getEnclosingTypeElement(method);</span>
              Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
              /*
               * Search for the method in the list of interfaces. If found check if it is
               * overridden by any other subinterface method which this class
               * implements. If it is not overridden, add it in the method list.
</pre>
<center><a href="Utils.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../../../../jdk.jconsole/share/classes/module-info.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeDiffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Kinds.Kind;
 30 import com.sun.tools.javac.code.Symbol;
 31 import com.sun.tools.javac.code.Symbol.BindingSymbol;

 32 import com.sun.tools.javac.code.Symbol.VarSymbol;
 33 import com.sun.tools.javac.code.Symtab;
 34 import com.sun.tools.javac.code.Types;
 35 import com.sun.tools.javac.tree.JCTree.JCAssign;
 36 import com.sun.tools.javac.tree.JCTree.JCBinary;
 37 import com.sun.tools.javac.tree.JCTree.JCConditional;
 38 import com.sun.tools.javac.tree.JCTree.JCExpression;
 39 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 40 import com.sun.tools.javac.tree.JCTree.JCIdent;
 41 import com.sun.tools.javac.tree.JCTree.JCIf;
 42 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 43 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 44 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 45 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 46 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 47 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 48 import com.sun.tools.javac.tree.JCTree.Tag;
 49 import com.sun.tools.javac.tree.TreeMaker;
 50 import com.sun.tools.javac.tree.TreeTranslator;
 51 import com.sun.tools.javac.util.Assert;
 52 import com.sun.tools.javac.util.Context;
 53 import com.sun.tools.javac.util.ListBuffer;
 54 import com.sun.tools.javac.util.Log;
 55 import com.sun.tools.javac.util.Names;
 56 import com.sun.tools.javac.util.Options;
 57 
 58 import java.util.Map;
 59 import java.util.Map.Entry;

 60 
 61 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 62 import com.sun.tools.javac.code.Symbol.RecordComponent;
 63 import com.sun.tools.javac.code.Type;
 64 import static com.sun.tools.javac.code.TypeTag.BOT;
 65 import com.sun.tools.javac.jvm.Target;
 66 import com.sun.tools.javac.tree.JCTree;
 67 import com.sun.tools.javac.tree.JCTree.JCBlock;
 68 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 69 import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;
 70 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 71 import com.sun.tools.javac.tree.JCTree.JCPattern;
 72 import com.sun.tools.javac.tree.JCTree.JCLambda;
 73 import com.sun.tools.javac.tree.JCTree.JCStatement;
 74 import com.sun.tools.javac.tree.JCTree.LetExpr;
 75 import com.sun.tools.javac.util.List;
<span class="line-removed"> 76 import java.util.HashMap;</span>
 77 
 78 /**
 79  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 80  */
 81 public class TransPatterns extends TreeTranslator {
 82 
 83     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 84 
 85     public static TransPatterns instance(Context context) {
 86         TransPatterns instance = context.get(transPatternsKey);
 87         if (instance == null)
 88             instance = new TransPatterns(context);
 89         return instance;
 90     }
 91 
 92     private final Symtab syms;
 93     private final Types types;
 94     private final Operators operators;
 95     private final Log log;
 96     private final ConstFold constFold;
</pre>
<hr />
<pre>
118         JCExpression decorateExpression(JCExpression expr) {
119             return expr;
120         }
121 
122         @Override
123         BindingContext pop() {
124             //do nothing
125             return this;
126         }
127 
128         @Override
129         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
130             return false;
131         }
132     };
133 
134     JCLabeledStatement pendingMatchLabel = null;
135 
136     boolean debugTransPatterns;
137 
<span class="line-modified">138     private JCClassDecl currentClass;</span>
139     private Symbol currentOwnerSym = null;
140 
141     protected TransPatterns(Context context) {
142         context.put(transPatternsKey, this);
143         syms = Symtab.instance(context);
144         make = TreeMaker.instance(context);
145         types = Types.instance(context);
146         operators = Operators.instance(context);
147         log = Log.instance(context);
148         constFold = ConstFold.instance(context);
149         names = Names.instance(context);
150         target = Target.instance(context);
151         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
152     }
153 
154     @Override
155     public void visitTypeTest(JCInstanceOf tree) {
156         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
157             //E instanceof T N

158             //=&gt;
<span class="line-modified">159             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))</span>
160             Type tempType = tree.expr.type.hasTag(BOT) ?
161                     syms.objectType
162                     : tree.expr.type;
163             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
<span class="line-modified">164                     names.fromString(&quot;e&quot; + target.syntheticNameChar() + tree.pos),</span>
165                     tempType,
166                     currentOwnerSym);
167             JCExpression translatedExpr = translate(tree.expr);
168             Type castTargetType;
169             //TODO: use rule switch (when boot JDK is 14):
170             switch (tree.pattern.getTag()) {
<span class="line-modified">171                 case BINDINGPATTERN: castTargetType = ((JCBindingPattern)tree.pattern).symbol.type; break;</span>
<span class="line-modified">172                 case DECONSTRUCTIONPATTERN: castTargetType = ((JCDeconstructionPattern)tree.pattern).type; break;</span>
<span class="line-modified">173                 default: throw new AssertionError(&quot;Unexpected pattern type: &quot; + tree.pattern.getTag());</span>





174             }
175 
176             castTargetType = types.boxedTypeOrType(types.erasure(castTargetType));
177 
<span class="line-modified">178             result = makeTypeTest(make.Ident(temp), make.Type(castTargetType));</span>
<span class="line-modified">179             result = makeBinary(Tag.AND, (JCExpression)result, preparePatternExtractor(tree.getPattern(), temp, castTargetType));</span>
<span class="line-modified">180             result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr), (JCExpression)result).setType(syms.booleanType);</span>


181             ((LetExpr) result).needsCond = true;
182         } else {
183             super.visitTypeTest(tree);
184         }
185     }
<span class="line-modified">186     </span>
<span class="line-modified">187     private JCExpression preparePatternExtractor(JCPattern patt, VarSymbol temp, Type targetType) {</span>
188         if (targetType == syms.botType) {
189             targetType = syms.objectType;
190         }
191         if (patt.hasTag(Tag.BINDINGPATTERN)) {



192             VarSymbol bindingVar = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
193             if (bindingVar != null) { //TODO: cannot be null here?
<span class="line-modified">194                 JCAssign fakeInit = (JCAssign)make.at(patt.pos).Assign(</span>
195                         make.Ident(bindingVar), convert(make.Ident(temp), targetType)).setType(bindingVar.erasure(types));
196                 LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),
197                                                 make.Literal(true));
198                 nestedLE.needsCond = true;
199                 nestedLE.setType(syms.booleanType);
200                 return nestedLE;
201             }
<span class="line-modified">202             return make.Literal(true);//XXX</span>
203         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {



204             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
205             List&lt;? extends RecordComponent&gt; components = dpatt.record.getRecordComponents();
206             List&lt;? extends JCPattern&gt; nestedPatterns = dpatt.nested;
207             JCExpression test = null;
208             while (components.nonEmpty() &amp;&amp; nestedPatterns.nonEmpty()) {








209                 RecordComponent component = components.head;
210                 JCPattern nested = nestedPatterns.head;
211                 VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,
<span class="line-modified">212                     names.fromString(&quot;e&quot; + target.syntheticNameChar() + nested.pos),</span>
213                                      component.erasure(types),
214                                      currentOwnerSym);
<span class="line-modified">215                 Symbol accessor = dpatt.record.members().findFirst(component.name, s -&gt; s.kind == Kind.MTH &amp;&amp; ((MethodSymbol) s).params.isEmpty());</span>
<span class="line-modified">216                 LetExpr getAndRun = make.LetExpr(make.VarDef(nestedTemp, make.App(make.Select(convert(make.Ident(temp), dpatt.type), accessor))), preparePatternExtractor(nested, nestedTemp, nestedTemp.type));</span>



















217                 getAndRun.needsCond = true;
218                 getAndRun.setType(syms.booleanType);
<span class="line-removed">219                 if (!types.isAssignable(nestedTemp.type, nested.type)) { //TODO: erasure? primitives?</span>
<span class="line-removed">220                     getAndRun.expr = makeBinary(Tag.AND, makeTypeTest(make.Ident(nestedTemp), make.Type(nested.type)), getAndRun.expr);</span>
<span class="line-removed">221                 }</span>
222                 if (test == null) {
223                     test = getAndRun;
224                 } else {
225                     test = makeBinary(Tag.AND, test, getAndRun);
226                 }
227                 components = components.tail;
228                 nestedPatterns = nestedPatterns.tail;
229             }
230             Assert.check(components.isEmpty() == nestedPatterns.isEmpty());
231             return test != null ? test : make.Literal(true);
232         } else {
233             throw new IllegalStateException();
234         }
235     }
<span class="line-modified">236     </span>
237     @Override
238     public void visitBinary(JCBinary tree) {
239         bindingContext = new BasicBindingContext();
240         try {
241             super.visitBinary(tree);
242             result = bindingContext.decorateExpression(tree);
243         } finally {
244             bindingContext.pop();
245         }
246     }
247 
248     @Override
249     public void visitConditional(JCConditional tree) {
250         bindingContext = new BasicBindingContext();
251         try {
252             super.visitConditional(tree);
253             result = bindingContext.decorateExpression(tree);
254         } finally {
255             bindingContext.pop();
256         }
</pre>
<hr />
<pre>
283         bindingContext = new BasicBindingContext();
284         try {
285             super.visitWhileLoop(tree);
286             result = bindingContext.decorateStatement(tree);
287         } finally {
288             bindingContext.pop();
289         }
290     }
291 
292     @Override
293     public void visitDoLoop(JCDoWhileLoop tree) {
294         bindingContext = new BasicBindingContext();
295         try {
296             super.visitDoLoop(tree);
297             result = bindingContext.decorateStatement(tree);
298         } finally {
299             bindingContext.pop();
300         }
301     }
302 
<span class="line-removed">303     @Override</span>
<span class="line-removed">304     public void visitClassDef(JCTree.JCClassDecl tree) {</span>
<span class="line-removed">305         JCClassDecl prevCurrentClass = currentClass;</span>
<span class="line-removed">306         try {</span>
<span class="line-removed">307             currentClass = tree;</span>
<span class="line-removed">308             super.visitClassDef(tree);</span>
<span class="line-removed">309         } finally {</span>
<span class="line-removed">310             currentClass = prevCurrentClass;</span>
<span class="line-removed">311         }</span>
<span class="line-removed">312     }</span>
<span class="line-removed">313 </span>
314     @Override
315     public void visitMethodDef(JCMethodDecl tree) {
316         Symbol prevOwnerSym = currentOwnerSym;
317         try {
318             currentOwnerSym = tree.sym;
319             super.visitMethodDef(tree);
320         } finally {
321             currentOwnerSym = prevOwnerSym;
322         }
323     }
324 
325     @Override
326     public void visitVarDef(JCVariableDecl tree) {
327         Symbol prevOwnerSym = currentOwnerSym;
328         try {
329             if (tree.sym.owner.kind == Kind.TYP) {
330                 currentOwnerSym = tree.sym;
331             }
332             super.visitVarDef(tree);
333         } finally {
334             currentOwnerSym = prevOwnerSym;
335         }
336     }
337 











338     @Override
339     public void visitIdent(JCIdent tree) {
340         VarSymbol bindingVar = null;
341         if ((tree.sym.flags() &amp; Flags.MATCH_BINDING) != 0) {
342             bindingVar = bindingContext.getBindingFor((BindingSymbol)tree.sym);
343         }
344         if (bindingVar == null) {
345             super.visitIdent(tree);
346         } else {
347             result = make.at(tree.pos).Ident(bindingVar);
348         }
349     }
350 
351     @Override
352     public void visitBlock(JCBlock tree) {
353         ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
354         bindingContext = new BindingDeclarationFenceBindingContext() {
355             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
356                 //{
357                 //    if (E instanceof T N) {
358                 //        return ;
359                 //    }
360                 //    //use of N:
361                 //}
362                 //=&gt;
363                 //{
364                 //    T N;
365                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
366                 //        return ;
367                 //    }
368                 //    //use of N:
369                 //}
370                 hoistedVarMap.put(binding, var.sym);
371                 statements.append(var);
372                 return true;
373             }
374         };

375         try {





376             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
377                 statements.append(translate(l.head));
378             }
379 
380             tree.stats = statements.toList();
381             result = tree;
382         } finally {
383             bindingContext.pop();

384         }
385     }
386 
387     @Override
388     public void visitLambda(JCLambda tree) {
389         BindingContext prevContent = bindingContext;
390         try {
391             bindingContext = new BindingDeclarationFenceBindingContext();
392             super.visitLambda(tree);
393         } finally {
394             bindingContext = prevContent;
395         }
396     }
397 
398     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
399         try {
400             this.make = make;
401             translate(cdef);
402         } finally {
403             // note that recursive invocations of this method fail hard
</pre>
<hr />
<pre>
413      */
414 
415     JCInstanceOf makeTypeTest(JCExpression lhs, JCExpression type) {
416         JCInstanceOf tree = make.TypeTest(lhs, type);
417         tree.type = syms.booleanType;
418         return tree;
419     }
420 
421     /** Make an attributed binary expression (copied from Lower).
422      *  @param optag    The operators tree tag.
423      *  @param lhs      The operator&#39;s left argument.
424      *  @param rhs      The operator&#39;s right argument.
425      */
426     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
427         JCBinary tree = make.Binary(optag, lhs, rhs);
428         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
429         tree.type = tree.operator.type.getReturnType();
430         return tree;
431     }
432 
















433     JCExpression convert(JCExpression expr, Type target) {
434         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
435         result.type = target;
436         return result;
437     }
438 
439     abstract class BindingContext {
440         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
441         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
442         abstract JCStatement decorateStatement(JCStatement stat);
443         abstract JCExpression decorateExpression(JCExpression expr);
444         abstract BindingContext pop();
445         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
446     }
447 
448     class BasicBindingContext extends BindingContext {
449         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
450         BindingContext parent;
451 
452         public BasicBindingContext() {
453             this.parent = bindingContext;
<span class="line-modified">454             this.hoistedVarMap = new HashMap&lt;&gt;();</span>
455         }
456 
457         @Override
458         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
459             VarSymbol res = parent.bindingDeclared(varSymbol);
460             if (res == null) {
<span class="line-modified">461                 res = new VarSymbol(varSymbol.flags() &amp; ~Flags.MATCH_BINDING, varSymbol.name, varSymbol.type, varSymbol.owner);</span>
462                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
463                 hoistedVarMap.put(varSymbol, res);
464             }
465             return res;
466         }
467 
468         @Override
469         VarSymbol getBindingFor(BindingSymbol varSymbol) {
470             VarSymbol res = parent.getBindingFor(varSymbol);
471             if (res != null) {
472                 return res;
473             }
474             return hoistedVarMap.entrySet().stream()
475                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
476                     .findFirst()
477                     .map(e -&gt; e.getValue()).orElse(null);
478         }
479 
480         @Override
481         JCStatement decorateStatement(JCStatement stat) {
</pre>
</td>
<td>
<hr />
<pre>
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Kinds.Kind;
 30 import com.sun.tools.javac.code.Symbol;
 31 import com.sun.tools.javac.code.Symbol.BindingSymbol;
<span class="line-added"> 32 import com.sun.tools.javac.code.Symbol.ClassSymbol;</span>
 33 import com.sun.tools.javac.code.Symbol.VarSymbol;
 34 import com.sun.tools.javac.code.Symtab;
 35 import com.sun.tools.javac.code.Types;
 36 import com.sun.tools.javac.tree.JCTree.JCAssign;
 37 import com.sun.tools.javac.tree.JCTree.JCBinary;
 38 import com.sun.tools.javac.tree.JCTree.JCConditional;
 39 import com.sun.tools.javac.tree.JCTree.JCExpression;
 40 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 41 import com.sun.tools.javac.tree.JCTree.JCIdent;
 42 import com.sun.tools.javac.tree.JCTree.JCIf;
 43 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 44 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 45 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 46 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 47 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 48 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 49 import com.sun.tools.javac.tree.JCTree.Tag;
 50 import com.sun.tools.javac.tree.TreeMaker;
 51 import com.sun.tools.javac.tree.TreeTranslator;
 52 import com.sun.tools.javac.util.Assert;
 53 import com.sun.tools.javac.util.Context;
 54 import com.sun.tools.javac.util.ListBuffer;
 55 import com.sun.tools.javac.util.Log;
 56 import com.sun.tools.javac.util.Names;
 57 import com.sun.tools.javac.util.Options;
 58 
 59 import java.util.Map;
 60 import java.util.Map.Entry;
<span class="line-added"> 61 import java.util.LinkedHashMap;</span>
 62 
 63 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 64 import com.sun.tools.javac.code.Symbol.RecordComponent;
 65 import com.sun.tools.javac.code.Type;
 66 import static com.sun.tools.javac.code.TypeTag.BOT;
 67 import com.sun.tools.javac.jvm.Target;
 68 import com.sun.tools.javac.tree.JCTree;
 69 import com.sun.tools.javac.tree.JCTree.JCBlock;
 70 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 71 import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;
 72 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 73 import com.sun.tools.javac.tree.JCTree.JCPattern;
 74 import com.sun.tools.javac.tree.JCTree.JCLambda;
 75 import com.sun.tools.javac.tree.JCTree.JCStatement;
 76 import com.sun.tools.javac.tree.JCTree.LetExpr;
 77 import com.sun.tools.javac.util.List;

 78 
 79 /**
 80  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 81  */
 82 public class TransPatterns extends TreeTranslator {
 83 
 84     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 85 
 86     public static TransPatterns instance(Context context) {
 87         TransPatterns instance = context.get(transPatternsKey);
 88         if (instance == null)
 89             instance = new TransPatterns(context);
 90         return instance;
 91     }
 92 
 93     private final Symtab syms;
 94     private final Types types;
 95     private final Operators operators;
 96     private final Log log;
 97     private final ConstFold constFold;
</pre>
<hr />
<pre>
119         JCExpression decorateExpression(JCExpression expr) {
120             return expr;
121         }
122 
123         @Override
124         BindingContext pop() {
125             //do nothing
126             return this;
127         }
128 
129         @Override
130         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
131             return false;
132         }
133     };
134 
135     JCLabeledStatement pendingMatchLabel = null;
136 
137     boolean debugTransPatterns;
138 
<span class="line-modified">139     private ClassSymbol currentClass;</span>
140     private Symbol currentOwnerSym = null;
141 
142     protected TransPatterns(Context context) {
143         context.put(transPatternsKey, this);
144         syms = Symtab.instance(context);
145         make = TreeMaker.instance(context);
146         types = Types.instance(context);
147         operators = Operators.instance(context);
148         log = Log.instance(context);
149         constFold = ConstFold.instance(context);
150         names = Names.instance(context);
151         target = Target.instance(context);
152         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
153     }
154 
155     @Override
156     public void visitTypeTest(JCInstanceOf tree) {
157         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
158             //E instanceof T N
<span class="line-added">159             //E instanceof T(PATT1, PATT2, ...)</span>
160             //=&gt;
<span class="line-modified">161             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; &lt;pattern extractor&gt;)</span>
162             Type tempType = tree.expr.type.hasTag(BOT) ?
163                     syms.objectType
164                     : tree.expr.type;
165             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
<span class="line-modified">166                     names.fromString(target.syntheticNameChar() + &quot;e&quot; + target.syntheticNameChar()),</span>
167                     tempType,
168                     currentOwnerSym);
169             JCExpression translatedExpr = translate(tree.expr);
170             Type castTargetType;
171             //TODO: use rule switch (when boot JDK is 14):
172             switch (tree.pattern.getTag()) {
<span class="line-modified">173                 case BINDINGPATTERN:</span>
<span class="line-modified">174                     castTargetType = ((JCBindingPattern)tree.pattern).symbol.type;</span>
<span class="line-modified">175                     break;</span>
<span class="line-added">176                 case DECONSTRUCTIONPATTERN:</span>
<span class="line-added">177                     castTargetType = ((JCDeconstructionPattern)tree.pattern).type;</span>
<span class="line-added">178                     break;</span>
<span class="line-added">179                 default:</span>
<span class="line-added">180                     throw new AssertionError(&quot;Unexpected pattern type: &quot; + tree.pattern.getTag());</span>
181             }
182 
183             castTargetType = types.boxedTypeOrType(types.erasure(castTargetType));
184 
<span class="line-modified">185             result = makeTypeTest(make.at(tree.pos).Ident(temp), make.Type(castTargetType));</span>
<span class="line-modified">186             result = makeBinary(Tag.AND, (JCExpression)result,</span>
<span class="line-modified">187                                          preparePatternExtractor(tree, tree.getPattern(), temp, castTargetType));</span>
<span class="line-added">188             result = make.at(tree.pos).LetExpr(make.VarDef(temp, translatedExpr),</span>
<span class="line-added">189                                                (JCExpression)result).setType(syms.booleanType);</span>
190             ((LetExpr) result).needsCond = true;
191         } else {
192             super.visitTypeTest(tree);
193         }
194     }
<span class="line-modified">195 </span>
<span class="line-modified">196     private JCExpression preparePatternExtractor(JCInstanceOf tree, JCPattern patt, VarSymbol temp, Type targetType) {</span>
197         if (targetType == syms.botType) {
198             targetType = syms.objectType;
199         }
200         if (patt.hasTag(Tag.BINDINGPATTERN)) {
<span class="line-added">201             //type test already done, finish handling of type test patterns (&quot;T N&quot;)</span>
<span class="line-added">202             //=&gt;</span>
<span class="line-added">203             //(let N = (T) N$temp; true)</span>
204             VarSymbol bindingVar = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
205             if (bindingVar != null) { //TODO: cannot be null here?
<span class="line-modified">206                 JCAssign fakeInit = (JCAssign)make.at(tree.pos).Assign(</span>
207                         make.Ident(bindingVar), convert(make.Ident(temp), targetType)).setType(bindingVar.erasure(types));
208                 LetExpr nestedLE = make.LetExpr(List.of(make.Exec(fakeInit)),
209                                                 make.Literal(true));
210                 nestedLE.needsCond = true;
211                 nestedLE.setType(syms.booleanType);
212                 return nestedLE;
213             }
<span class="line-modified">214             return make.Literal(true);</span>
215         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
<span class="line-added">216             //type test already done, finish handling of deconstruction patterns (&quot;T(PATT1, PATT2, ...)&quot;)</span>
<span class="line-added">217             //=&gt;</span>
<span class="line-added">218             //&lt;PATT1-handling&gt; &amp;&amp; &lt;PATT2-handling&gt; &amp;&amp; ...</span>
219             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
220             List&lt;? extends RecordComponent&gt; components = dpatt.record.getRecordComponents();
221             List&lt;? extends JCPattern&gt; nestedPatterns = dpatt.nested;
222             JCExpression test = null;
223             while (components.nonEmpty() &amp;&amp; nestedPatterns.nonEmpty()) {
<span class="line-added">224                 //PATTn for record component COMPn of type Tn;</span>
<span class="line-added">225                 //PATTn is a type test pattern or a deconstruction pattern:</span>
<span class="line-added">226                 //=&gt;</span>
<span class="line-added">227                 //(let Tn $c$COMPn = ((T) N$temp).COMPn(); &lt;PATTn extractor&gt;)</span>
<span class="line-added">228                 //or</span>
<span class="line-added">229                 //(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn != null &amp;&amp; &lt;PATTn extractor&gt;)</span>
<span class="line-added">230                 //or</span>
<span class="line-added">231                 //(let Tn $c$COMPn = ((T) N$temp).COMPn(); $c$COMPn instanceof T&#39; &amp;&amp; &lt;PATTn extractor&gt;)</span>
232                 RecordComponent component = components.head;
233                 JCPattern nested = nestedPatterns.head;
234                 VarSymbol nestedTemp = new VarSymbol(Flags.SYNTHETIC,
<span class="line-modified">235                     names.fromString(target.syntheticNameChar() + &quot;c&quot; + target.syntheticNameChar() + component.name),</span>
236                                      component.erasure(types),
237                                      currentOwnerSym);
<span class="line-modified">238                 Symbol accessor = dpatt.record</span>
<span class="line-modified">239                                        .members()</span>
<span class="line-added">240                                        .findFirst(component.name, s -&gt; s.kind == Kind.MTH &amp;&amp;</span>
<span class="line-added">241                                                                        ((MethodSymbol) s).params.isEmpty());</span>
<span class="line-added">242                 JCVariableDecl nestedTempVar =</span>
<span class="line-added">243                         make.VarDef(nestedTemp,</span>
<span class="line-added">244                                     make.App(make.Select(convert(make.Ident(temp), dpatt.type),</span>
<span class="line-added">245                                                          accessor)));</span>
<span class="line-added">246                 JCExpression extracted =</span>
<span class="line-added">247                         preparePatternExtractor(tree, nested, nestedTemp, nested.type);</span>
<span class="line-added">248                 JCExpression extraTest = null;</span>
<span class="line-added">249                 if (!types.isAssignable(nestedTemp.type, nested.type)) {</span>
<span class="line-added">250                     extraTest = makeTypeTest(make.Ident(nestedTemp),</span>
<span class="line-added">251                                              make.Type(nested.type));</span>
<span class="line-added">252                 } else if (nested.type.isReference()) {</span>
<span class="line-added">253                     extraTest = makeBinary(Tag.NE, make.Ident(nestedTemp), makeNull());</span>
<span class="line-added">254                 }</span>
<span class="line-added">255                 if (extraTest != null) {</span>
<span class="line-added">256                     extracted = makeBinary(Tag.AND, extraTest, extracted);</span>
<span class="line-added">257                 }</span>
<span class="line-added">258                 LetExpr getAndRun = make.LetExpr(nestedTempVar, extracted);</span>
259                 getAndRun.needsCond = true;
260                 getAndRun.setType(syms.booleanType);



261                 if (test == null) {
262                     test = getAndRun;
263                 } else {
264                     test = makeBinary(Tag.AND, test, getAndRun);
265                 }
266                 components = components.tail;
267                 nestedPatterns = nestedPatterns.tail;
268             }
269             Assert.check(components.isEmpty() == nestedPatterns.isEmpty());
270             return test != null ? test : make.Literal(true);
271         } else {
272             throw new IllegalStateException();
273         }
274     }
<span class="line-modified">275 </span>
276     @Override
277     public void visitBinary(JCBinary tree) {
278         bindingContext = new BasicBindingContext();
279         try {
280             super.visitBinary(tree);
281             result = bindingContext.decorateExpression(tree);
282         } finally {
283             bindingContext.pop();
284         }
285     }
286 
287     @Override
288     public void visitConditional(JCConditional tree) {
289         bindingContext = new BasicBindingContext();
290         try {
291             super.visitConditional(tree);
292             result = bindingContext.decorateExpression(tree);
293         } finally {
294             bindingContext.pop();
295         }
</pre>
<hr />
<pre>
322         bindingContext = new BasicBindingContext();
323         try {
324             super.visitWhileLoop(tree);
325             result = bindingContext.decorateStatement(tree);
326         } finally {
327             bindingContext.pop();
328         }
329     }
330 
331     @Override
332     public void visitDoLoop(JCDoWhileLoop tree) {
333         bindingContext = new BasicBindingContext();
334         try {
335             super.visitDoLoop(tree);
336             result = bindingContext.decorateStatement(tree);
337         } finally {
338             bindingContext.pop();
339         }
340     }
341 











342     @Override
343     public void visitMethodDef(JCMethodDecl tree) {
344         Symbol prevOwnerSym = currentOwnerSym;
345         try {
346             currentOwnerSym = tree.sym;
347             super.visitMethodDef(tree);
348         } finally {
349             currentOwnerSym = prevOwnerSym;
350         }
351     }
352 
353     @Override
354     public void visitVarDef(JCVariableDecl tree) {
355         Symbol prevOwnerSym = currentOwnerSym;
356         try {
357             if (tree.sym.owner.kind == Kind.TYP) {
358                 currentOwnerSym = tree.sym;
359             }
360             super.visitVarDef(tree);
361         } finally {
362             currentOwnerSym = prevOwnerSym;
363         }
364     }
365 
<span class="line-added">366     @Override</span>
<span class="line-added">367     public void visitClassDef(JCClassDecl tree) {</span>
<span class="line-added">368         ClassSymbol prevCurrentClass = currentClass;</span>
<span class="line-added">369         try {</span>
<span class="line-added">370             currentClass = tree.sym;</span>
<span class="line-added">371             super.visitClassDef(tree);</span>
<span class="line-added">372         } finally {</span>
<span class="line-added">373             currentClass = prevCurrentClass;</span>
<span class="line-added">374         }</span>
<span class="line-added">375     }</span>
<span class="line-added">376 </span>
377     @Override
378     public void visitIdent(JCIdent tree) {
379         VarSymbol bindingVar = null;
380         if ((tree.sym.flags() &amp; Flags.MATCH_BINDING) != 0) {
381             bindingVar = bindingContext.getBindingFor((BindingSymbol)tree.sym);
382         }
383         if (bindingVar == null) {
384             super.visitIdent(tree);
385         } else {
386             result = make.at(tree.pos).Ident(bindingVar);
387         }
388     }
389 
390     @Override
391     public void visitBlock(JCBlock tree) {
392         ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
393         bindingContext = new BindingDeclarationFenceBindingContext() {
394             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
395                 //{
396                 //    if (E instanceof T N) {
397                 //        return ;
398                 //    }
399                 //    //use of N:
400                 //}
401                 //=&gt;
402                 //{
403                 //    T N;
404                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
405                 //        return ;
406                 //    }
407                 //    //use of N:
408                 //}
409                 hoistedVarMap.put(binding, var.sym);
410                 statements.append(var);
411                 return true;
412             }
413         };
<span class="line-added">414         Symbol prevOwnerSym = currentOwnerSym;</span>
415         try {
<span class="line-added">416             if (currentOwnerSym == null) {</span>
<span class="line-added">417                 currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,</span>
<span class="line-added">418                                  names.empty, null,</span>
<span class="line-added">419                                  currentClass);</span>
<span class="line-added">420             }</span>
421             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
422                 statements.append(translate(l.head));
423             }
424 
425             tree.stats = statements.toList();
426             result = tree;
427         } finally {
428             bindingContext.pop();
<span class="line-added">429             currentOwnerSym = prevOwnerSym;</span>
430         }
431     }
432 
433     @Override
434     public void visitLambda(JCLambda tree) {
435         BindingContext prevContent = bindingContext;
436         try {
437             bindingContext = new BindingDeclarationFenceBindingContext();
438             super.visitLambda(tree);
439         } finally {
440             bindingContext = prevContent;
441         }
442     }
443 
444     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
445         try {
446             this.make = make;
447             translate(cdef);
448         } finally {
449             // note that recursive invocations of this method fail hard
</pre>
<hr />
<pre>
459      */
460 
461     JCInstanceOf makeTypeTest(JCExpression lhs, JCExpression type) {
462         JCInstanceOf tree = make.TypeTest(lhs, type);
463         tree.type = syms.booleanType;
464         return tree;
465     }
466 
467     /** Make an attributed binary expression (copied from Lower).
468      *  @param optag    The operators tree tag.
469      *  @param lhs      The operator&#39;s left argument.
470      *  @param rhs      The operator&#39;s right argument.
471      */
472     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
473         JCBinary tree = make.Binary(optag, lhs, rhs);
474         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
475         tree.type = tree.operator.type.getReturnType();
476         return tree;
477     }
478 
<span class="line-added">479     /** Make an attributed tree representing a literal. This will be an</span>
<span class="line-added">480      *  Ident node in the case of boolean literals, a Literal node in all</span>
<span class="line-added">481      *  other cases.</span>
<span class="line-added">482      *  @param type       The literal&#39;s type.</span>
<span class="line-added">483      *  @param value      The literal&#39;s value.</span>
<span class="line-added">484      */</span>
<span class="line-added">485     JCExpression makeLit(Type type, Object value) {</span>
<span class="line-added">486         return make.Literal(type.getTag(), value).setType(type.constType(value));</span>
<span class="line-added">487     }</span>
<span class="line-added">488 </span>
<span class="line-added">489     /** Make an attributed tree representing null.</span>
<span class="line-added">490      */</span>
<span class="line-added">491     JCExpression makeNull() {</span>
<span class="line-added">492         return makeLit(syms.botType, null);</span>
<span class="line-added">493     }</span>
<span class="line-added">494 </span>
495     JCExpression convert(JCExpression expr, Type target) {
496         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
497         result.type = target;
498         return result;
499     }
500 
501     abstract class BindingContext {
502         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
503         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
504         abstract JCStatement decorateStatement(JCStatement stat);
505         abstract JCExpression decorateExpression(JCExpression expr);
506         abstract BindingContext pop();
507         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
508     }
509 
510     class BasicBindingContext extends BindingContext {
511         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
512         BindingContext parent;
513 
514         public BasicBindingContext() {
515             this.parent = bindingContext;
<span class="line-modified">516             this.hoistedVarMap = new LinkedHashMap&lt;&gt;();</span>
517         }
518 
519         @Override
520         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
521             VarSymbol res = parent.bindingDeclared(varSymbol);
522             if (res == null) {
<span class="line-modified">523                 res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, varSymbol.owner);</span>
524                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
525                 hoistedVarMap.put(varSymbol, res);
526             }
527             return res;
528         }
529 
530         @Override
531         VarSymbol getBindingFor(BindingSymbol varSymbol) {
532             VarSymbol res = parent.getBindingFor(varSymbol);
533             if (res != null) {
534                 return res;
535             }
536             return hoistedVarMap.entrySet().stream()
537                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
538                     .findFirst()
539                     .map(e -&gt; e.getValue()).orElse(null);
540         }
541 
542         @Override
543         JCStatement decorateStatement(JCStatement stat) {
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeDiffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed

 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
<span class="line-modified"> 243     protected static final int NOINVOCATION = 0x20;</span>
 244 
 245     protected void selectExprMode() {
<span class="line-modified"> 246         //TODO: copy NOINVOCATION</span>
<span class="line-removed"> 247         mode = (mode &amp; NOLAMBDA) | EXPR;</span>
 248     }
 249 
 250     protected void selectTypeMode() {
<span class="line-modified"> 251         //TODO: copy NOINVOCATION</span>
<span class="line-removed"> 252         mode = (mode &amp; NOLAMBDA) | TYPE;</span>
 253     }
 254 
 255     /** The current mode.
 256      */
 257     protected int mode = 0;
 258 
 259     /** The mode of the term that was parsed last.
 260      */
 261     protected int lastmode = 0;
 262 
 263     /* ---------- token management -------------- */
 264 
 265     protected Token token;
 266 
 267     public Token token() {
 268         return token;
 269     }
 270 
 271     public void nextToken() {
 272         S.nextToken();
</pre>
<hr />
<pre>
 749      */
 750     public JCExpression parseExpression() {
 751         return term(EXPR);
 752     }
 753 
 754     /** parses patterns.
 755      */
 756 
 757     public JCPattern parsePattern() {
 758         int pos = token.pos;
 759         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 760             nextToken();
 761             return toP(F.at(pos).BindingPattern(ident(), null));
 762         } else {
 763             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 764             if (token.kind == LPAREN) {
 765                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 766                 do {
 767                     nextToken();
 768                     JCPattern nestedPattern = parsePattern();
<span class="line-removed"> 769                     if (nestedPattern.hasTag(BINDINGPATTERN) &amp;&amp; ((JCBindingPattern) nestedPattern).vartype != null) {</span>
<span class="line-removed"> 770                         log.error(nestedPattern.pos(), Errors.DeconstructionPatternNoVar);</span>
<span class="line-removed"> 771                     }</span>
 772                     nested.append(nestedPattern);
 773                 } while (token.kind == COMMA);
<span class="line-removed"> 774                 Name name = null;</span>
<span class="line-removed"> 775                 if (token.kind == IDENTIFIER) {</span>
<span class="line-removed"> 776                     name = ident();</span>
<span class="line-removed"> 777                 }</span>
 778                 accept(RPAREN);
<span class="line-modified"> 779                 return toP(F.at(pos).DeconstructionPattern(name, e, nested.toList()));</span>
 780             } else {
 781                 return toP(F.at(pos).BindingPattern(ident(), e));
 782             }
 783         }
 784     }
 785 
 786     /**
 787      * parses (optional) type annotations followed by a type. If the
 788      * annotations are present before the type and are not consumed during array
 789      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 790      * these annotations and the underlying type. Otherwise, it returns the
 791      * underlying type.
 792      *
 793      * &lt;p&gt;
 794      *
 795      * Note that this method sets {@code mode} to {@code TYPE} first, before
 796      * parsing annotations.
 797      */
 798     public JCExpression parseType() {
 799         return parseType(false);
</pre>
<hr />
<pre>
 949     JCExpression term2Rest(JCExpression t, int minprec) {
 950         JCExpression[] odStack = newOdStack();
 951         Token[] opStack = newOpStack();
 952 
 953         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 954         int top = 0;
 955         odStack[0] = t;
 956         int startPos = token.pos;
 957         Token topOp = Tokens.DUMMY;
 958         while (prec(token.kind) &gt;= minprec) {
 959             opStack[top] = topOp;
 960 
 961             if (token.kind == INSTANCEOF) {
 962                 int pos = token.pos;
 963                 nextToken();
 964                 JCTree pattern = parseType();
 965                 if (token.kind == IDENTIFIER) {
 966                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 967                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 968                 } else if (token.kind == LPAREN) {

 969                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 970                     do {
 971                         nextToken();
 972                         JCPattern nestedPattern = parsePattern();
<span class="line-removed"> 973                         if (nestedPattern.hasTag(BINDINGPATTERN) &amp;&amp; ((JCBindingPattern) nestedPattern).vartype != null) {</span>
<span class="line-removed"> 974                             log.error(nestedPattern.pos(), Errors.DeconstructionPatternNoVar);</span>
<span class="line-removed"> 975                         }</span>
 976                         nested.append(nestedPattern);
 977                     } while (token.kind == COMMA);
<span class="line-removed"> 978                     Name name = null;</span>
<span class="line-removed"> 979                     if (token.kind == IDENTIFIER) {</span>
<span class="line-removed"> 980                         name = ident();</span>
<span class="line-removed"> 981                     }</span>
 982                     accept(RPAREN);
<span class="line-modified"> 983                     pattern = toP(F.at(pos).DeconstructionPattern(name, (JCExpression) pattern, nested.toList()));</span>
 984                 }
 985                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 986             } else {
 987                 topOp = token;
 988                 nextToken();
 989                 top++;
 990                 odStack[top] = term3();
 991             }
 992             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 993                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 994                 top--;
 995                 topOp = opStack[top];
 996             }
 997         }
 998         Assert.check(top == 0);
 999         t = odStack[0];
1000 
1001         if (t.hasTag(JCTree.Tag.PLUS)) {
1002             t = foldStrings(t);
1003         }
</pre>
<hr />
<pre>
2616         }
2617         case ABSTRACT: case STRICTFP: {
2618             dc = token.comment(CommentStyle.JAVADOC);
2619             JCModifiers mods = modifiersOpt();
2620             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2621         }
2622         case INTERFACE:
2623         case CLASS:
2624             dc = token.comment(CommentStyle.JAVADOC);
2625             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2626         case ENUM:
2627             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2628             dc = token.comment(CommentStyle.JAVADOC);
2629             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2630         case IDENTIFIER:
2631             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2632                 Token next = S.token(1);
2633                 boolean isYieldStatement;
2634                 switch (next.kind) {
2635                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<span class="line-modified">2636                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2637                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2638                     case NEW: case SWITCH: case THIS: case SUPER:
2639                         isYieldStatement = true;
2640                         break;
2641                     case PLUSPLUS: case SUBSUB:
2642                         isYieldStatement = S.token(2).kind != SEMI;
2643                         break;
2644                     case LPAREN:
2645                         int lookahead = 2;
2646                         int balance = 1;
2647                         boolean hasComma = false;
2648                         Token l;
2649                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2650                             switch (l.kind) {
2651                                 case LPAREN: balance++; break;
2652                                 case RPAREN: balance--; break;
2653                                 case COMMA: if (balance == 1) hasComma = true; break;
2654                             }
2655                             lookahead++;
2656                         }
</pre>
</td>
<td>
<hr />
<pre>
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
<span class="line-added"> 236      *     mode |= NOINVOCATION : method invocations are not allowed</span>
 237      */
 238     protected static final int EXPR = 0x1;
 239     protected static final int TYPE = 0x2;
 240     protected static final int NOPARAMS = 0x4;
 241     protected static final int TYPEARG = 0x8;
 242     protected static final int DIAMOND = 0x10;
 243     protected static final int NOLAMBDA = 0x20;
<span class="line-modified"> 244     protected static final int NOINVOCATION = 0x40;</span>
 245 
 246     protected void selectExprMode() {
<span class="line-modified"> 247         mode = (mode &amp; (NOLAMBDA | NOINVOCATION)) | EXPR;</span>

 248     }
 249 
 250     protected void selectTypeMode() {
<span class="line-modified"> 251         mode = (mode &amp; (NOLAMBDA|NOINVOCATION)) | TYPE;</span>

 252     }
 253 
 254     /** The current mode.
 255      */
 256     protected int mode = 0;
 257 
 258     /** The mode of the term that was parsed last.
 259      */
 260     protected int lastmode = 0;
 261 
 262     /* ---------- token management -------------- */
 263 
 264     protected Token token;
 265 
 266     public Token token() {
 267         return token;
 268     }
 269 
 270     public void nextToken() {
 271         S.nextToken();
</pre>
<hr />
<pre>
 748      */
 749     public JCExpression parseExpression() {
 750         return term(EXPR);
 751     }
 752 
 753     /** parses patterns.
 754      */
 755 
 756     public JCPattern parsePattern() {
 757         int pos = token.pos;
 758         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 759             nextToken();
 760             return toP(F.at(pos).BindingPattern(ident(), null));
 761         } else {
 762             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 763             if (token.kind == LPAREN) {
 764                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 765                 do {
 766                     nextToken();
 767                     JCPattern nestedPattern = parsePattern();



 768                     nested.append(nestedPattern);
 769                 } while (token.kind == COMMA);




 770                 accept(RPAREN);
<span class="line-modified"> 771                 return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));</span>
 772             } else {
 773                 return toP(F.at(pos).BindingPattern(ident(), e));
 774             }
 775         }
 776     }
 777 
 778     /**
 779      * parses (optional) type annotations followed by a type. If the
 780      * annotations are present before the type and are not consumed during array
 781      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 782      * these annotations and the underlying type. Otherwise, it returns the
 783      * underlying type.
 784      *
 785      * &lt;p&gt;
 786      *
 787      * Note that this method sets {@code mode} to {@code TYPE} first, before
 788      * parsing annotations.
 789      */
 790     public JCExpression parseType() {
 791         return parseType(false);
</pre>
<hr />
<pre>
 941     JCExpression term2Rest(JCExpression t, int minprec) {
 942         JCExpression[] odStack = newOdStack();
 943         Token[] opStack = newOpStack();
 944 
 945         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 946         int top = 0;
 947         odStack[0] = t;
 948         int startPos = token.pos;
 949         Token topOp = Tokens.DUMMY;
 950         while (prec(token.kind) &gt;= minprec) {
 951             opStack[top] = topOp;
 952 
 953             if (token.kind == INSTANCEOF) {
 954                 int pos = token.pos;
 955                 nextToken();
 956                 JCTree pattern = parseType();
 957                 if (token.kind == IDENTIFIER) {
 958                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 959                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 960                 } else if (token.kind == LPAREN) {
<span class="line-added"> 961                     checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);</span>
 962                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 963                     do {
 964                         nextToken();
 965                         JCPattern nestedPattern = parsePattern();



 966                         nested.append(nestedPattern);
 967                     } while (token.kind == COMMA);




 968                     accept(RPAREN);
<span class="line-modified"> 969                     pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));</span>
 970                 }
 971                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 972             } else {
 973                 topOp = token;
 974                 nextToken();
 975                 top++;
 976                 odStack[top] = term3();
 977             }
 978             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 979                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 980                 top--;
 981                 topOp = opStack[top];
 982             }
 983         }
 984         Assert.check(top == 0);
 985         t = odStack[0];
 986 
 987         if (t.hasTag(JCTree.Tag.PLUS)) {
 988             t = foldStrings(t);
 989         }
</pre>
<hr />
<pre>
2602         }
2603         case ABSTRACT: case STRICTFP: {
2604             dc = token.comment(CommentStyle.JAVADOC);
2605             JCModifiers mods = modifiersOpt();
2606             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2607         }
2608         case INTERFACE:
2609         case CLASS:
2610             dc = token.comment(CommentStyle.JAVADOC);
2611             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2612         case ENUM:
2613             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2614             dc = token.comment(CommentStyle.JAVADOC);
2615             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2616         case IDENTIFIER:
2617             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2618                 Token next = S.token(1);
2619                 boolean isYieldStatement;
2620                 switch (next.kind) {
2621                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<span class="line-modified">2622                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2623                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2624                     case NEW: case SWITCH: case THIS: case SUPER:
2625                         isYieldStatement = true;
2626                         break;
2627                     case PLUSPLUS: case SUBSUB:
2628                         isYieldStatement = S.token(2).kind != SEMI;
2629                         break;
2630                     case LPAREN:
2631                         int lookahead = 2;
2632                         int balance = 1;
2633                         boolean hasComma = false;
2634                         Token l;
2635                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2636                             switch (l.kind) {
2637                                 case LPAREN: balance++; break;
2638                                 case RPAREN: balance--; break;
2639                                 case COMMA: if (balance == 1) hasComma = true; break;
2640                             }
2641                             lookahead++;
2642                         }
</pre>
</td>
</tr>
</table>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
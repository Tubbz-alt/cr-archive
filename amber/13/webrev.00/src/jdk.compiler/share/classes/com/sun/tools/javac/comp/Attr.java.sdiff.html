<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;

  30 
  31 import javax.lang.model.element.ElementKind;
  32 import javax.tools.JavaFileObject;
  33 
  34 import com.sun.source.tree.CaseTree;
  35 import com.sun.source.tree.IdentifierTree;
  36 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  37 import com.sun.source.tree.MemberSelectTree;
  38 import com.sun.source.tree.TreeVisitor;
  39 import com.sun.source.util.SimpleTreeVisitor;
  40 import com.sun.tools.javac.code.*;
  41 import com.sun.tools.javac.code.Lint.LintCategory;
  42 import com.sun.tools.javac.code.Scope.WriteableScope;
  43 import com.sun.tools.javac.code.Source.Feature;
  44 import com.sun.tools.javac.code.Symbol.*;
  45 import com.sun.tools.javac.code.Type.*;
  46 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  47 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  48 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  49 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
  59 import com.sun.tools.javac.tree.*;
  60 import com.sun.tools.javac.tree.JCTree.*;
  61 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  62 import com.sun.tools.javac.util.*;
  63 import com.sun.tools.javac.util.DefinedBy.Api;
  64 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  65 import com.sun.tools.javac.util.JCDiagnostic.Error;
  66 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  67 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  68 import com.sun.tools.javac.util.List;
  69 
  70 import static com.sun.tools.javac.code.Flags.*;
  71 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  72 import static com.sun.tools.javac.code.Flags.BLOCK;
  73 import static com.sun.tools.javac.code.Kinds.*;
  74 import static com.sun.tools.javac.code.Kinds.Kind.*;
  75 import static com.sun.tools.javac.code.TypeTag.*;
  76 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  77 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  78 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
<span class="line-removed">  79 import java.util.stream.Stream;</span>
  80 
  81 /** This is the main context-dependent analysis phase in GJC. It
  82  *  encompasses name resolution, type checking and constant folding as
  83  *  subtasks. Some subtasks involve auxiliary classes.
  84  *  @see Check
  85  *  @see Resolve
  86  *  @see ConstFold
  87  *  @see Infer
  88  *
  89  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  90  *  If you write code that depends on this, you do so at your own risk.
  91  *  This code and its internal interfaces are subject to change or
  92  *  deletion without notice.&lt;/b&gt;
  93  */
  94 public class Attr extends JCTree.Visitor {
  95     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  96 
  97     final Names names;
  98     final Log log;
  99     final Symtab syms;
</pre>
<hr />
<pre>
3878             attribTree(tree.pattern, env, unknownExprInfo);
3879             clazztype = tree.pattern.type;
3880             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
3881             typeTree = pattern.vartype;
3882             if (!clazztype.hasTag(TYPEVAR)) {
3883                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
3884             }
3885         } else {
3886             clazztype = attribType(tree.pattern, env);
3887             typeTree = tree.pattern;
3888         }
3889         if (!clazztype.hasTag(TYPEVAR)) {
3890             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
3891         }
3892         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
3893             boolean valid = false;
3894             if (allowReifiableTypesInInstanceof) {
3895                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
3896                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
3897                 }
<span class="line-modified">3898                 Warner warner = new Warner();</span>
<span class="line-removed">3899                 if (!types.isCastable(exprtype, clazztype, warner)) {</span>
<span class="line-removed">3900                     chk.basicHandler.report(tree.expr.pos(),</span>
<span class="line-removed">3901                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));</span>
<span class="line-removed">3902                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {</span>
<span class="line-removed">3903                     log.error(tree.expr.pos(),</span>
<span class="line-removed">3904                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));</span>
<span class="line-removed">3905                 } else {</span>
<span class="line-removed">3906                     valid = true;</span>
<span class="line-removed">3907                 }</span>
3908             } else {
3909                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
3910             }
3911             if (!valid) {
3912                 clazztype = types.createErrorType(clazztype);
3913             }
3914         }
3915         chk.validate(typeTree, env, false);
3916         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3917         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
3918     }
3919 
3920     public void visitBindingPattern(JCBindingPattern tree) {
3921         if (tree.vartype != null) {
3922             ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
3923             tree.type = attribTree(tree.vartype, env, varInfo);
3924         } else {
3925             tree.type = resultInfo.pt;
3926         }
3927         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype != null ? tree.vartype.type : (tree.type.hasTag(BOT) ? syms.objectType : tree.type), env.info.scope.owner);
3928         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
3929             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
3930         }
3931         if (tree.vartype != null) {
3932             annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
3933             annotate.flush();
3934         }
3935         result = tree.type;
3936         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
3937     }
3938 
3939     @Override
3940     public void visitDeconstructionPattern(JCDeconstructionPattern tree) {
<span class="line-modified">3941         Type site = tree.type = attribType(tree.deconstructor, env);</span>
<span class="line-modified">3942         List&lt;Type&gt; recordTypes;</span>

3943         if (site.tsym.kind == Kind.TYP &amp;&amp; ((ClassSymbol) site.tsym).isRecord()) {
3944             ClassSymbol record = (ClassSymbol) site.tsym;
<span class="line-modified">3945             recordTypes = record.getRecordComponents().stream().map(rc -&gt; rc.type).collect(List.collector());</span>
3946             tree.record = record;
3947         } else {
3948             log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));
<span class="line-modified">3949             recordTypes = Stream.generate(() -&gt; Type.noType)</span>
3950                                 .limit(tree.nested.size())
3951                                 .collect(List.collector());
3952         }
3953         ListBuffer&lt;BindingSymbol&gt; outBindings = new ListBuffer&lt;&gt;();

3954         List&lt;JCPattern&gt; nestedPatterns = tree.nested;
3955         while (recordTypes.nonEmpty() &amp;&amp; nestedPatterns.nonEmpty()) {
<span class="line-modified">3956             boolean nestedIsValidPattern = !nestedPatterns.head.hasTag(BINDINGPATTERN) ||</span>
<span class="line-modified">3957                                            ((JCBindingPattern) nestedPatterns.head).vartype == null;</span>
<span class="line-modified">3958             attribExpr(nestedPatterns.head, env, nestedIsValidPattern ? recordTypes.head : Type.noType);</span>

3959             outBindings.addAll(matchBindings.bindingsWhenTrue);
3960             nestedPatterns = nestedPatterns.tail;
3961             recordTypes = recordTypes.tail;
3962         }











3963         result = tree.type;
3964         matchBindings = new MatchBindings(outBindings.toList(), List.nil());
3965     }
3966 
<span class="line-modified">3967     private boolean isSubTypesIgnoreNone(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {</span>
<span class="line-modified">3968         while (ts.tail != null &amp;&amp; ss.tail != null &amp;&amp;</span>
<span class="line-modified">3969                (ts.head == Type.noType || types.isSubtype(ts.head, ss.head))) {</span>
<span class="line-modified">3970             ts = ts.tail;</span>
<span class="line-modified">3971             ss = ss.tail;</span>





3972         }
<span class="line-removed">3973         return ts.tail == null &amp;&amp; ss.tail == null;</span>
3974     }
3975 
3976     public void visitIndexed(JCArrayAccess tree) {
3977         Type owntype = types.createErrorType(tree.type);
3978         Type atype = attribExpr(tree.indexed, env);
3979         attribExpr(tree.index, env, syms.intType);
3980         if (types.isArray(atype))
3981             owntype = types.elemtype(atype);
3982         else if (!atype.hasTag(ERROR))
3983             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
3984         if (!pkind().contains(KindSelector.VAL))
3985             owntype = capture(owntype);
3986         result = check(tree, owntype, KindSelector.VAR, resultInfo);
3987     }
3988 
3989     public void visitIdent(JCIdent tree) {
3990         Symbol sym;
3991 
3992         // Find symbol
3993         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
</pre>
<hr />
<pre>
5616         public void visitVarDef(JCVariableDecl that) {
5617             initTypeIfNeeded(that);
5618             if (that.sym == null) {
5619                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5620                 that.sym.adr = 0;
5621             }
5622             if (that.vartype == null) {
5623                 that.vartype = make.at(Position.NOPOS).Erroneous();
5624             }
5625             super.visitVarDef(that);
5626         }
5627 
5628         @Override
5629         public void visitBindingPattern(JCBindingPattern that) {
5630             if (that.symbol == null) {
5631                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5632                 that.symbol.adr = 0;
5633             }
5634             super.visitBindingPattern(that);
5635         }
<span class="line-modified">5636         //XXX: DeconstructionPattern!!!!</span>
5637         @Override
5638         public void visitNewClass(JCNewClass that) {
5639             if (that.constructor == null) {
5640                 that.constructor = new MethodSymbol(0, names.init,
5641                         dummyMethodType(), syms.noSymbol);
5642             }
5643             if (that.constructorType == null) {
5644                 that.constructorType = syms.unknownType;
5645             }
5646             super.visitNewClass(that);
5647         }
5648 
5649         @Override
5650         public void visitAssignop(JCAssignOp that) {
5651             if (that.operator == null) {
5652                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5653                         -1, syms.noSymbol);
5654             }
5655             super.visitAssignop(that);
5656         }
</pre>
</td>
<td>
<hr />
<pre>
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import java.util.*;
  29 import java.util.function.BiConsumer;
<span class="line-added">  30 import java.util.stream.Stream;</span>
  31 
  32 import javax.lang.model.element.ElementKind;
  33 import javax.tools.JavaFileObject;
  34 
  35 import com.sun.source.tree.CaseTree;
  36 import com.sun.source.tree.IdentifierTree;
  37 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  38 import com.sun.source.tree.MemberSelectTree;
  39 import com.sun.source.tree.TreeVisitor;
  40 import com.sun.source.util.SimpleTreeVisitor;
  41 import com.sun.tools.javac.code.*;
  42 import com.sun.tools.javac.code.Lint.LintCategory;
  43 import com.sun.tools.javac.code.Scope.WriteableScope;
  44 import com.sun.tools.javac.code.Source.Feature;
  45 import com.sun.tools.javac.code.Symbol.*;
  46 import com.sun.tools.javac.code.Type.*;
  47 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  48 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  49 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  50 import com.sun.tools.javac.comp.Check.CheckContext;
</pre>
<hr />
<pre>
  60 import com.sun.tools.javac.tree.*;
  61 import com.sun.tools.javac.tree.JCTree.*;
  62 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  63 import com.sun.tools.javac.util.*;
  64 import com.sun.tools.javac.util.DefinedBy.Api;
  65 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  66 import com.sun.tools.javac.util.JCDiagnostic.Error;
  67 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  68 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  69 import com.sun.tools.javac.util.List;
  70 
  71 import static com.sun.tools.javac.code.Flags.*;
  72 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  73 import static com.sun.tools.javac.code.Flags.BLOCK;
  74 import static com.sun.tools.javac.code.Kinds.*;
  75 import static com.sun.tools.javac.code.Kinds.Kind.*;
  76 import static com.sun.tools.javac.code.TypeTag.*;
  77 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  78 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  79 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;

  80 
  81 /** This is the main context-dependent analysis phase in GJC. It
  82  *  encompasses name resolution, type checking and constant folding as
  83  *  subtasks. Some subtasks involve auxiliary classes.
  84  *  @see Check
  85  *  @see Resolve
  86  *  @see ConstFold
  87  *  @see Infer
  88  *
  89  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  90  *  If you write code that depends on this, you do so at your own risk.
  91  *  This code and its internal interfaces are subject to change or
  92  *  deletion without notice.&lt;/b&gt;
  93  */
  94 public class Attr extends JCTree.Visitor {
  95     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
  96 
  97     final Names names;
  98     final Log log;
  99     final Symtab syms;
</pre>
<hr />
<pre>
3878             attribTree(tree.pattern, env, unknownExprInfo);
3879             clazztype = tree.pattern.type;
3880             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
3881             typeTree = pattern.vartype;
3882             if (!clazztype.hasTag(TYPEVAR)) {
3883                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
3884             }
3885         } else {
3886             clazztype = attribType(tree.pattern, env);
3887             typeTree = tree.pattern;
3888         }
3889         if (!clazztype.hasTag(TYPEVAR)) {
3890             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
3891         }
3892         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
3893             boolean valid = false;
3894             if (allowReifiableTypesInInstanceof) {
3895                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
3896                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
3897                 }
<span class="line-modified">3898                 valid = verifyCastable(tree.expr.pos(), exprtype, clazztype);</span>









3899             } else {
3900                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
3901             }
3902             if (!valid) {
3903                 clazztype = types.createErrorType(clazztype);
3904             }
3905         }
3906         chk.validate(typeTree, env, false);
3907         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3908         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
3909     }
3910 
3911     public void visitBindingPattern(JCBindingPattern tree) {
3912         if (tree.vartype != null) {
3913             ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
3914             tree.type = attribTree(tree.vartype, env, varInfo);
3915         } else {
3916             tree.type = resultInfo.pt;
3917         }
3918         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype != null ? tree.vartype.type : (tree.type.hasTag(BOT) ? syms.objectType : tree.type), env.info.scope.owner);
3919         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
3920             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
3921         }
3922         if (tree.vartype != null) {
3923             annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
3924             annotate.flush();
3925         }
3926         result = tree.type;
3927         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
3928     }
3929 
3930     @Override
3931     public void visitDeconstructionPattern(JCDeconstructionPattern tree) {
<span class="line-modified">3932         tree.type = attribType(tree.deconstructor, env);</span>
<span class="line-modified">3933         Type site = types.removeWildcards(tree.type);</span>
<span class="line-added">3934         List&lt;Type&gt; expectedRecordTypes;</span>
3935         if (site.tsym.kind == Kind.TYP &amp;&amp; ((ClassSymbol) site.tsym).isRecord()) {
3936             ClassSymbol record = (ClassSymbol) site.tsym;
<span class="line-modified">3937             expectedRecordTypes = record.getRecordComponents().stream().map(rc -&gt; types.memberType(site, rc)).collect(List.collector());</span>
3938             tree.record = record;
3939         } else {
3940             log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));
<span class="line-modified">3941             expectedRecordTypes = Stream.generate(() -&gt; Type.noType)</span>
3942                                 .limit(tree.nested.size())
3943                                 .collect(List.collector());
3944         }
3945         ListBuffer&lt;BindingSymbol&gt; outBindings = new ListBuffer&lt;&gt;();
<span class="line-added">3946         List&lt;Type&gt; recordTypes = expectedRecordTypes;</span>
3947         List&lt;JCPattern&gt; nestedPatterns = tree.nested;
3948         while (recordTypes.nonEmpty() &amp;&amp; nestedPatterns.nonEmpty()) {
<span class="line-modified">3949             boolean nestedIsVarPattern = nestedPatterns.head.hasTag(BINDINGPATTERN) &amp;&amp;</span>
<span class="line-modified">3950                                          ((JCBindingPattern) nestedPatterns.head).vartype == null;</span>
<span class="line-modified">3951             attribExpr(nestedPatterns.head, env, nestedIsVarPattern ? recordTypes.head : Type.noType);</span>
<span class="line-added">3952             verifyCastable(nestedPatterns.head.pos(), recordTypes.head, nestedPatterns.head.type);</span>
3953             outBindings.addAll(matchBindings.bindingsWhenTrue);
3954             nestedPatterns = nestedPatterns.tail;
3955             recordTypes = recordTypes.tail;
3956         }
<span class="line-added">3957         if (recordTypes.nonEmpty() || nestedPatterns.nonEmpty()) {</span>
<span class="line-added">3958             while (nestedPatterns.nonEmpty()) {</span>
<span class="line-added">3959                 attribExpr(nestedPatterns.head, env, Type.noType);</span>
<span class="line-added">3960                 nestedPatterns = nestedPatterns.tail;</span>
<span class="line-added">3961             }</span>
<span class="line-added">3962             List&lt;Type&gt; nestedTypes =</span>
<span class="line-added">3963                     tree.nested.stream().map(p -&gt; p.type).collect(List.collector());</span>
<span class="line-added">3964             log.error(tree.pos(),</span>
<span class="line-added">3965                       Errors.IncorrectNumberOfNestedPatterns(expectedRecordTypes,</span>
<span class="line-added">3966                                                              nestedTypes));</span>
<span class="line-added">3967         }</span>
3968         result = tree.type;
3969         matchBindings = new MatchBindings(outBindings.toList(), List.nil());
3970     }
3971 
<span class="line-modified">3972     private boolean verifyCastable(DiagnosticPosition pos, Type exprtype, Type clazztype) {</span>
<span class="line-modified">3973         Warner warner = new Warner();</span>
<span class="line-modified">3974         if (!chk.checkCastable(pos, exprtype, clazztype, chk.basicHandler, warner)) {</span>
<span class="line-modified">3975             return false;</span>
<span class="line-modified">3976         } else if (warner.hasLint(LintCategory.UNCHECKED)) {</span>
<span class="line-added">3977             log.error(pos,</span>
<span class="line-added">3978                       Errors.InstanceofReifiableNotSafe(exprtype, clazztype));</span>
<span class="line-added">3979             return false;</span>
<span class="line-added">3980         } else {</span>
<span class="line-added">3981             return true;</span>
3982         }

3983     }
3984 
3985     public void visitIndexed(JCArrayAccess tree) {
3986         Type owntype = types.createErrorType(tree.type);
3987         Type atype = attribExpr(tree.indexed, env);
3988         attribExpr(tree.index, env, syms.intType);
3989         if (types.isArray(atype))
3990             owntype = types.elemtype(atype);
3991         else if (!atype.hasTag(ERROR))
3992             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
3993         if (!pkind().contains(KindSelector.VAL))
3994             owntype = capture(owntype);
3995         result = check(tree, owntype, KindSelector.VAR, resultInfo);
3996     }
3997 
3998     public void visitIdent(JCIdent tree) {
3999         Symbol sym;
4000 
4001         // Find symbol
4002         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
</pre>
<hr />
<pre>
5625         public void visitVarDef(JCVariableDecl that) {
5626             initTypeIfNeeded(that);
5627             if (that.sym == null) {
5628                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5629                 that.sym.adr = 0;
5630             }
5631             if (that.vartype == null) {
5632                 that.vartype = make.at(Position.NOPOS).Erroneous();
5633             }
5634             super.visitVarDef(that);
5635         }
5636 
5637         @Override
5638         public void visitBindingPattern(JCBindingPattern that) {
5639             if (that.symbol == null) {
5640                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5641                 that.symbol.adr = 0;
5642             }
5643             super.visitBindingPattern(that);
5644         }
<span class="line-modified">5645 </span>
5646         @Override
5647         public void visitNewClass(JCNewClass that) {
5648             if (that.constructor == null) {
5649                 that.constructor = new MethodSymbol(0, names.init,
5650                         dummyMethodType(), syms.noSymbol);
5651             }
5652             if (that.constructorType == null) {
5653                 that.constructorType = syms.unknownType;
5654             }
5655             super.visitNewClass(that);
5656         }
5657 
5658         @Override
5659         public void visitAssignop(JCAssignOp that) {
5660             if (that.operator == null) {
5661                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5662                         -1, syms.noSymbol);
5663             }
5664             super.visitAssignop(that);
5665         }
</pre>
</td>
</tr>
</table>
<center><a href="../code/Symbol.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
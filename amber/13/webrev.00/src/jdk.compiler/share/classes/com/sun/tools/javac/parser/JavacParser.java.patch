diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java
@@ -231,27 +231,26 @@
      *     mode = EXPR        : an expression
      *     mode = TYPE        : a type
      *     mode = NOPARAMS    : no parameters allowed for type
      *     mode = TYPEARG     : type argument
      *     mode |= NOLAMBDA   : lambdas are not allowed
+     *     mode |= NOINVOCATION : method invocations are not allowed
      */
     protected static final int EXPR = 0x1;
     protected static final int TYPE = 0x2;
     protected static final int NOPARAMS = 0x4;
     protected static final int TYPEARG = 0x8;
     protected static final int DIAMOND = 0x10;
     protected static final int NOLAMBDA = 0x20;
-    protected static final int NOINVOCATION = 0x20;
+    protected static final int NOINVOCATION = 0x40;
 
     protected void selectExprMode() {
-        //TODO: copy NOINVOCATION
-        mode = (mode & NOLAMBDA) | EXPR;
+        mode = (mode & (NOLAMBDA | NOINVOCATION)) | EXPR;
     }
 
     protected void selectTypeMode() {
-        //TODO: copy NOINVOCATION
-        mode = (mode & NOLAMBDA) | TYPE;
+        mode = (mode & (NOLAMBDA|NOINVOCATION)) | TYPE;
     }
 
     /** The current mode.
      */
     protected int mode = 0;
@@ -764,21 +763,14 @@
             if (token.kind == LPAREN) {
                 ListBuffer<JCPattern> nested = new ListBuffer<>();
                 do {
                     nextToken();
                     JCPattern nestedPattern = parsePattern();
-                    if (nestedPattern.hasTag(BINDINGPATTERN) && ((JCBindingPattern) nestedPattern).vartype != null) {
-                        log.error(nestedPattern.pos(), Errors.DeconstructionPatternNoVar);
-                    }
                     nested.append(nestedPattern);
                 } while (token.kind == COMMA);
-                Name name = null;
-                if (token.kind == IDENTIFIER) {
-                    name = ident();
-                }
                 accept(RPAREN);
-                return toP(F.at(pos).DeconstructionPattern(name, e, nested.toList()));
+                return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));
             } else {
                 return toP(F.at(pos).BindingPattern(ident(), e));
             }
         }
     }
@@ -964,25 +956,19 @@
                 JCTree pattern = parseType();
                 if (token.kind == IDENTIFIER) {
                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
                 } else if (token.kind == LPAREN) {
+                    checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);
                     ListBuffer<JCPattern> nested = new ListBuffer<>();
                     do {
                         nextToken();
                         JCPattern nestedPattern = parsePattern();
-                        if (nestedPattern.hasTag(BINDINGPATTERN) && ((JCBindingPattern) nestedPattern).vartype != null) {
-                            log.error(nestedPattern.pos(), Errors.DeconstructionPatternNoVar);
-                        }
                         nested.append(nestedPattern);
                     } while (token.kind == COMMA);
-                    Name name = null;
-                    if (token.kind == IDENTIFIER) {
-                        name = ident();
-                    }
                     accept(RPAREN);
-                    pattern = toP(F.at(pos).DeconstructionPattern(name, (JCExpression) pattern, nested.toList()));
+                    pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));
                 }
                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
             } else {
                 topOp = token;
                 nextToken();
@@ -2631,11 +2617,11 @@
             if (token.name() == names.yield && allowYieldStatement) {
                 Token next = S.token(1);
                 boolean isYieldStatement;
                 switch (next.kind) {
                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
-                    case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
+                    case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
                     case NEW: case SWITCH: case THIS: case SUPER:
                         isYieldStatement = true;
                         break;
                     case PLUSPLUS: case SUBSUB:

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../resources/compiler.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pretty.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2215 
2216         @DefinedBy(Api.COMPILER_TREE)
2217         public Kind getKind() {
2218             return Kind.BINDING_PATTERN;
2219         }
2220 
2221         @Override
2222         @DefinedBy(Api.COMPILER_TREE)
2223         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2224             return v.visitBindingPattern(this, d);
2225         }
2226 
2227         @Override
2228         public Tag getTag() {
2229             return BINDINGPATTERN;
2230         }
2231     }
2232 
2233     public static class JCDeconstructionPattern extends JCPattern
2234             implements DeconstructionPatternTree {
<span class="line-removed">2235         public Name name; //possibly null</span>
2236         public JCExpression deconstructor;
2237         public List&lt;JCPattern&gt; nested;
2238         public ClassSymbol record;
2239         public List&lt;Type&gt; innerTypes;
2240 
<span class="line-modified">2241         protected JCDeconstructionPattern(Name name, JCExpression deconstructor, List&lt;JCPattern&gt; nested) {</span>
<span class="line-removed">2242             this.name = name;</span>
2243             this.deconstructor = deconstructor;
2244             this.nested = nested;
2245         }
2246 
2247         @DefinedBy(Api.COMPILER_TREE)
2248         public Name getBinding() {
<span class="line-modified">2249             return name;</span>
2250         }
2251 
2252         @Override @DefinedBy(Api.COMPILER_TREE)
2253         public Tree getDeconstructor() {
2254             return deconstructor;
2255         }
2256 
2257         @Override @DefinedBy(Api.COMPILER_TREE)
2258         public List&lt;? extends JCPattern&gt; getNestedPatterns() {
2259             return nested;
2260         }
2261 
2262         @Override
2263         public void accept(Visitor v) {
2264             v.visitDeconstructionPattern(this);
2265         }
2266 
2267         @DefinedBy(Api.COMPILER_TREE)
2268         public Kind getKind() {
2269             return Kind.DECONSTRUCTION_PATTERN;
</pre>
<hr />
<pre>
3137         @DefinedBy(Api.COMPILER_TREE)
3138         public Kind getKind() { return Kind.ERRONEOUS; }
3139 
3140         @DefinedBy(Api.COMPILER_TREE)
3141         public List&lt;? extends JCTree&gt; getErrorTrees() {
3142             return errs;
3143         }
3144 
3145         @Override @DefinedBy(Api.COMPILER_TREE)
3146         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3147             return v.visitErroneous(this, d);
3148         }
3149         @Override
3150         public Tag getTag() {
3151             return ERRONEOUS;
3152         }
3153     }
3154 
3155     /** (let int x = 3; in x+2) */
3156     public static class LetExpr extends JCExpression {
<span class="line-modified">3157         public List&lt;? extends JCStatement&gt; defs;</span>
3158         public JCExpression expr;
3159         /**true if a expr should be run through Gen.genCond:*/
3160         public boolean needsCond;
<span class="line-modified">3161         protected LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr) {</span>
3162             this.defs = defs;
3163             this.expr = expr;
3164         }
3165         @Override
3166         public void accept(Visitor v) { v.visitLetExpr(this); }
3167 
3168         @DefinedBy(Api.COMPILER_TREE)
3169         public Kind getKind() {
3170             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3171         }
3172         @Override @DefinedBy(Api.COMPILER_TREE)
3173         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3174             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3175         }
3176         @Override
3177         public Tag getTag() {
3178             return LETEXPR;
3179         }
3180     }
3181 
</pre>
<hr />
<pre>
3258         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3259         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3260         JCFieldAccess Select(JCExpression selected, Name selector);
3261         JCIdent Ident(Name idname);
3262         JCLiteral Literal(TypeTag tag, Object value);
3263         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3264         JCArrayTypeTree TypeArray(JCExpression elemtype);
3265         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3266         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3267         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3268         TypeBoundKind TypeBoundKind(BoundKind kind);
3269         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3270         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3271         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3272         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3273         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3274         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3275         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3276         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3277         JCUses Uses(JCExpression qualId);
<span class="line-modified">3278         LetExpr LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr);</span>
3279     }
3280 
3281     /** A generic visitor class for trees.
3282      */
3283     public static abstract class Visitor {
3284         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3285         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3286         public void visitImport(JCImport that)               { visitTree(that); }
3287         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3288         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3289         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3290         public void visitSkip(JCSkip that)                   { visitTree(that); }
3291         public void visitBlock(JCBlock that)                 { visitTree(that); }
3292         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3293         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3294         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3295         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3296         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3297         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3298         public void visitCase(JCCase that)                   { visitTree(that); }
</pre>
</td>
<td>
<hr />
<pre>
2215 
2216         @DefinedBy(Api.COMPILER_TREE)
2217         public Kind getKind() {
2218             return Kind.BINDING_PATTERN;
2219         }
2220 
2221         @Override
2222         @DefinedBy(Api.COMPILER_TREE)
2223         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2224             return v.visitBindingPattern(this, d);
2225         }
2226 
2227         @Override
2228         public Tag getTag() {
2229             return BINDINGPATTERN;
2230         }
2231     }
2232 
2233     public static class JCDeconstructionPattern extends JCPattern
2234             implements DeconstructionPatternTree {

2235         public JCExpression deconstructor;
2236         public List&lt;JCPattern&gt; nested;
2237         public ClassSymbol record;
2238         public List&lt;Type&gt; innerTypes;
2239 
<span class="line-modified">2240         protected JCDeconstructionPattern(JCExpression deconstructor, List&lt;JCPattern&gt; nested) {</span>

2241             this.deconstructor = deconstructor;
2242             this.nested = nested;
2243         }
2244 
2245         @DefinedBy(Api.COMPILER_TREE)
2246         public Name getBinding() {
<span class="line-modified">2247             return null;</span>
2248         }
2249 
2250         @Override @DefinedBy(Api.COMPILER_TREE)
2251         public Tree getDeconstructor() {
2252             return deconstructor;
2253         }
2254 
2255         @Override @DefinedBy(Api.COMPILER_TREE)
2256         public List&lt;? extends JCPattern&gt; getNestedPatterns() {
2257             return nested;
2258         }
2259 
2260         @Override
2261         public void accept(Visitor v) {
2262             v.visitDeconstructionPattern(this);
2263         }
2264 
2265         @DefinedBy(Api.COMPILER_TREE)
2266         public Kind getKind() {
2267             return Kind.DECONSTRUCTION_PATTERN;
</pre>
<hr />
<pre>
3135         @DefinedBy(Api.COMPILER_TREE)
3136         public Kind getKind() { return Kind.ERRONEOUS; }
3137 
3138         @DefinedBy(Api.COMPILER_TREE)
3139         public List&lt;? extends JCTree&gt; getErrorTrees() {
3140             return errs;
3141         }
3142 
3143         @Override @DefinedBy(Api.COMPILER_TREE)
3144         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3145             return v.visitErroneous(this, d);
3146         }
3147         @Override
3148         public Tag getTag() {
3149             return ERRONEOUS;
3150         }
3151     }
3152 
3153     /** (let int x = 3; in x+2) */
3154     public static class LetExpr extends JCExpression {
<span class="line-modified">3155         public List&lt;JCStatement&gt; defs;</span>
3156         public JCExpression expr;
3157         /**true if a expr should be run through Gen.genCond:*/
3158         public boolean needsCond;
<span class="line-modified">3159         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {</span>
3160             this.defs = defs;
3161             this.expr = expr;
3162         }
3163         @Override
3164         public void accept(Visitor v) { v.visitLetExpr(this); }
3165 
3166         @DefinedBy(Api.COMPILER_TREE)
3167         public Kind getKind() {
3168             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3169         }
3170         @Override @DefinedBy(Api.COMPILER_TREE)
3171         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3172             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3173         }
3174         @Override
3175         public Tag getTag() {
3176             return LETEXPR;
3177         }
3178     }
3179 
</pre>
<hr />
<pre>
3256         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3257         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3258         JCFieldAccess Select(JCExpression selected, Name selector);
3259         JCIdent Ident(Name idname);
3260         JCLiteral Literal(TypeTag tag, Object value);
3261         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3262         JCArrayTypeTree TypeArray(JCExpression elemtype);
3263         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3264         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3265         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3266         TypeBoundKind TypeBoundKind(BoundKind kind);
3267         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3268         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3269         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3270         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3271         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3272         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3273         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3274         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3275         JCUses Uses(JCExpression qualId);
<span class="line-modified">3276         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);</span>
3277     }
3278 
3279     /** A generic visitor class for trees.
3280      */
3281     public static abstract class Visitor {
3282         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3283         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3284         public void visitImport(JCImport that)               { visitTree(that); }
3285         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3286         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3287         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3288         public void visitSkip(JCSkip that)                   { visitTree(that); }
3289         public void visitBlock(JCBlock that)                 { visitTree(that); }
3290         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3291         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3292         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3293         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3294         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3295         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3296         public void visitCase(JCCase that)                   { visitTree(that); }
</pre>
</td>
</tr>
</table>
<center><a href="../resources/compiler.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pretty.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
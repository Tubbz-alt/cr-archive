<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.main;
  27 
  28 import java.io.*;
  29 import java.util.Collection;
  30 import java.util.Collections;
  31 import java.util.HashMap;
  32 import java.util.HashSet;
  33 import java.util.LinkedHashMap;
  34 import java.util.LinkedHashSet;
  35 import java.util.Map;
  36 import java.util.MissingResourceException;
  37 import java.util.Queue;
  38 import java.util.ResourceBundle;
  39 import java.util.Set;
  40 import java.util.function.Function;
  41 
  42 import javax.annotation.processing.Processor;
  43 import javax.lang.model.SourceVersion;
  44 import javax.lang.model.element.ElementVisitor;
  45 import javax.tools.DiagnosticListener;
  46 import javax.tools.JavaFileManager;
  47 import javax.tools.JavaFileObject;
  48 import javax.tools.JavaFileObject.Kind;
  49 import javax.tools.StandardLocation;
  50 
  51 import com.sun.source.util.TaskEvent;
  52 import com.sun.tools.javac.api.MultiTaskListener;
  53 import com.sun.tools.javac.code.*;
  54 import com.sun.tools.javac.code.Lint.LintCategory;
  55 import com.sun.tools.javac.code.Source.Feature;
  56 import com.sun.tools.javac.code.Symbol.ClassSymbol;
  57 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  58 import com.sun.tools.javac.code.Symbol.PackageSymbol;
  59 import com.sun.tools.javac.comp.*;
  60 import com.sun.tools.javac.comp.CompileStates.CompileState;
  61 import com.sun.tools.javac.file.JavacFileManager;
  62 import com.sun.tools.javac.jvm.*;
  63 import com.sun.tools.javac.parser.*;
  64 import com.sun.tools.javac.platform.PlatformDescription;
  65 import com.sun.tools.javac.processing.*;
  66 import com.sun.tools.javac.tree.*;
  67 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
  68 import com.sun.tools.javac.tree.JCTree.JCCompilationUnit;
  69 import com.sun.tools.javac.tree.JCTree.JCExpression;
  70 import com.sun.tools.javac.tree.JCTree.JCLambda;
  71 import com.sun.tools.javac.tree.JCTree.JCMemberReference;
  72 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
  73 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
  74 import com.sun.tools.javac.util.*;
  75 import com.sun.tools.javac.util.DefinedBy.Api;
  76 import com.sun.tools.javac.util.JCDiagnostic.Factory;
  77 import com.sun.tools.javac.util.Log.DiagnosticHandler;
  78 import com.sun.tools.javac.util.Log.DiscardDiagnosticHandler;
  79 import com.sun.tools.javac.util.Log.WriterKind;
  80 
  81 import static com.sun.tools.javac.code.Kinds.Kind.*;
  82 
  83 import com.sun.tools.javac.code.Symbol.ModuleSymbol;
  84 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  85 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  86 import com.sun.tools.javac.resources.CompilerProperties.Notes;
  87 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  88 
  89 import static com.sun.tools.javac.code.TypeTag.CLASS;
  90 import static com.sun.tools.javac.main.Option.*;
  91 import static com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag.*;
  92 
  93 import static javax.tools.StandardLocation.CLASS_OUTPUT;
  94 
  95 import com.sun.tools.javac.tree.JCTree.JCModuleDecl;
  96 
  97 /** This class could be the main entry point for GJC when GJC is used as a
  98  *  component in a larger software system. It provides operations to
  99  *  construct a new compiler, and to run a new compiler on a set of source
 100  *  files.
 101  *
 102  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 103  *  If you write code that depends on this, you do so at your own risk.
 104  *  This code and its internal interfaces are subject to change or
 105  *  deletion without notice.&lt;/b&gt;
 106  */
 107 public class JavaCompiler {
 108     /** The context key for the compiler. */
 109     public static final Context.Key&lt;JavaCompiler&gt; compilerKey = new Context.Key&lt;&gt;();
 110 
 111     /** Get the JavaCompiler instance for this context. */
 112     public static JavaCompiler instance(Context context) {
 113         JavaCompiler instance = context.get(compilerKey);
 114         if (instance == null)
 115             instance = new JavaCompiler(context);
 116         return instance;
 117     }
 118 
 119     /** The current version number as a string.
 120      */
 121     public static String version() {
 122         return version(&quot;release&quot;);  // mm.nn.oo[-milestone]
 123     }
 124 
 125     /** The current full version number as a string.
 126      */
 127     public static String fullVersion() {
 128         return version(&quot;full&quot;); // mm.mm.oo[-milestone]-build
 129     }
 130 
 131     private static final String versionRBName = &quot;com.sun.tools.javac.resources.version&quot;;
 132     private static ResourceBundle versionRB;
 133 
 134     private static String version(String key) {
 135         if (versionRB == null) {
 136             try {
 137                 versionRB = ResourceBundle.getBundle(versionRBName);
 138             } catch (MissingResourceException e) {
 139                 return Log.getLocalizedString(&quot;version.not.available&quot;);
 140             }
 141         }
 142         try {
 143             return versionRB.getString(key);
 144         }
 145         catch (MissingResourceException e) {
 146             return Log.getLocalizedString(&quot;version.not.available&quot;);
 147         }
 148     }
 149 
 150     /**
 151      * Control how the compiler&#39;s latter phases (attr, flow, desugar, generate)
 152      * are connected. Each individual file is processed by each phase in turn,
 153      * but with different compile policies, you can control the order in which
 154      * each class is processed through its next phase.
 155      *
 156      * &lt;p&gt;Generally speaking, the compiler will &quot;fail fast&quot; in the face of
 157      * errors, although not aggressively so. flow, desugar, etc become no-ops
 158      * once any errors have occurred. No attempt is currently made to determine
 159      * if it might be safe to process a class through its next phase because
 160      * it does not depend on any unrelated errors that might have occurred.
 161      */
 162     protected static enum CompilePolicy {
 163         /**
 164          * Just attribute the parse trees.
 165          */
 166         ATTR_ONLY,
 167 
 168         /**
 169          * Just attribute and do flow analysis on the parse trees.
 170          * This should catch most user errors.
 171          */
 172         CHECK_ONLY,
 173 
 174         /**
 175          * Attribute everything, then do flow analysis for everything,
 176          * then desugar everything, and only then generate output.
 177          * This means no output will be generated if there are any
 178          * errors in any classes.
 179          */
 180         SIMPLE,
 181 
 182         /**
 183          * Groups the classes for each source file together, then process
 184          * each group in a manner equivalent to the {@code SIMPLE} policy.
 185          * This means no output will be generated if there are any
 186          * errors in any of the classes in a source file.
 187          */
 188         BY_FILE,
 189 
 190         /**
 191          * Completely process each entry on the todo list in turn.
 192          * -- this is the same for 1.5.
 193          * Means output might be generated for some classes in a compilation unit
 194          * and not others.
 195          */
 196         BY_TODO;
 197 
 198         static CompilePolicy decode(String option) {
 199             if (option == null)
 200                 return DEFAULT_COMPILE_POLICY;
 201             else if (option.equals(&quot;attr&quot;))
 202                 return ATTR_ONLY;
 203             else if (option.equals(&quot;check&quot;))
 204                 return CHECK_ONLY;
 205             else if (option.equals(&quot;simple&quot;))
 206                 return SIMPLE;
 207             else if (option.equals(&quot;byfile&quot;))
 208                 return BY_FILE;
 209             else if (option.equals(&quot;bytodo&quot;))
 210                 return BY_TODO;
 211             else
 212                 return DEFAULT_COMPILE_POLICY;
 213         }
 214     }
 215 
 216     private static final CompilePolicy DEFAULT_COMPILE_POLICY = CompilePolicy.BY_TODO;
 217 
 218     protected static enum ImplicitSourcePolicy {
 219         /** Don&#39;t generate or process implicitly read source files. */
 220         NONE,
 221         /** Generate classes for implicitly read source files. */
 222         CLASS,
 223         /** Like CLASS, but generate warnings if annotation processing occurs */
 224         UNSET;
 225 
 226         static ImplicitSourcePolicy decode(String option) {
 227             if (option == null)
 228                 return UNSET;
 229             else if (option.equals(&quot;none&quot;))
 230                 return NONE;
 231             else if (option.equals(&quot;class&quot;))
 232                 return CLASS;
 233             else
 234                 return UNSET;
 235         }
 236     }
 237 
 238     /** The log to be used for error reporting.
 239      */
 240     public Log log;
 241 
 242     /** Factory for creating diagnostic objects
 243      */
 244     JCDiagnostic.Factory diagFactory;
 245 
 246     /** The tree factory module.
 247      */
 248     protected TreeMaker make;
 249 
 250     /** The class finder.
 251      */
 252     protected ClassFinder finder;
 253 
 254     /** The class reader.
 255      */
 256     protected ClassReader reader;
 257 
 258     /** The class writer.
 259      */
 260     protected ClassWriter writer;
 261 
 262     /** The native header writer.
 263      */
 264     protected JNIWriter jniWriter;
 265 
 266     /** The module for the symbol table entry phases.
 267      */
 268     protected Enter enter;
 269 
 270     /** The symbol table.
 271      */
 272     protected Symtab syms;
 273 
 274     /** The language version.
 275      */
 276     protected Source source;
 277 
 278     /** The preview language version.
 279      */
 280     protected Preview preview;
 281 
 282     /** The module for code generation.
 283      */
 284     protected Gen gen;
 285 
 286     /** The name table.
 287      */
 288     protected Names names;
 289 
 290     /** The attributor.
 291      */
 292     protected Attr attr;
 293 
 294     /** The analyzer
 295      */
 296     protected Analyzer analyzer;
 297 
 298     /** The attributor.
 299      */
 300     protected Check chk;
 301 
 302     /** The flow analyzer.
 303      */
 304     protected Flow flow;
 305 
 306     /** The modules visitor
 307      */
 308     protected Modules modules;
 309 
 310     /** The module finder
 311      */
 312     protected ModuleFinder moduleFinder;
 313 
 314     /** The diagnostics factory
 315      */
 316     protected JCDiagnostic.Factory diags;
 317 
 318     protected DeferredCompletionFailureHandler dcfh;
 319 
 320     /** The type eraser.
 321      */
 322     protected TransTypes transTypes;
 323 
 324     /** The syntactic sugar desweetener.
 325      */
 326     protected Lower lower;
 327 
 328     /** The annotation annotator.
 329      */
 330     protected Annotate annotate;
 331 
 332     /** Force a completion failure on this name
 333      */
 334     protected final Name completionFailureName;
 335 
 336     /** Type utilities.
 337      */
 338     protected Types types;
 339 
 340     /** Access to file objects.
 341      */
 342     protected JavaFileManager fileManager;
 343 
 344     /** Factory for parsers.
 345      */
 346     protected ParserFactory parserFactory;
 347 
 348     /** Broadcasting listener for progress events
 349      */
 350     protected MultiTaskListener taskListener;
 351 
 352     /**
 353      * SourceCompleter that delegates to the readSourceFile method of this class.
 354      */
 355     protected final Symbol.Completer sourceCompleter =
 356             sym -&gt; readSourceFile((ClassSymbol) sym);
 357 
 358     /**
 359      * Command line options.
 360      */
 361     protected Options options;
 362 
 363     protected Context context;
 364 
 365     /**
 366      * Flag set if any annotation processing occurred.
 367      **/
 368     protected boolean annotationProcessingOccurred;
 369 
 370     /**
 371      * Flag set if any implicit source files read.
 372      **/
 373     protected boolean implicitSourceFilesRead;
 374 
 375     private boolean enterDone;
 376 
 377     protected CompileStates compileStates;
 378 
 379     /** Construct a new compiler using a shared context.
 380      */
 381     public JavaCompiler(Context context) {
 382         this.context = context;
 383         context.put(compilerKey, this);
 384 
 385         // if fileManager not already set, register the JavacFileManager to be used
 386         if (context.get(JavaFileManager.class) == null)
 387             JavacFileManager.preRegister(context);
 388 
 389         names = Names.instance(context);
 390         log = Log.instance(context);
 391         diagFactory = JCDiagnostic.Factory.instance(context);
 392         finder = ClassFinder.instance(context);
 393         reader = ClassReader.instance(context);
 394         make = TreeMaker.instance(context);
 395         writer = ClassWriter.instance(context);
 396         jniWriter = JNIWriter.instance(context);
 397         enter = Enter.instance(context);
 398         todo = Todo.instance(context);
 399 
 400         fileManager = context.get(JavaFileManager.class);
 401         parserFactory = ParserFactory.instance(context);
 402         compileStates = CompileStates.instance(context);
 403 
 404         try {
 405             // catch completion problems with predefineds
 406             syms = Symtab.instance(context);
 407         } catch (CompletionFailure ex) {
 408             // inlined Check.completionError as it is not initialized yet
 409             log.error(Errors.CantAccess(ex.sym, ex.getDetailValue()));
 410         }
 411         source = Source.instance(context);
 412         preview = Preview.instance(context);
 413         attr = Attr.instance(context);
 414         analyzer = Analyzer.instance(context);
 415         chk = Check.instance(context);
 416         gen = Gen.instance(context);
 417         flow = Flow.instance(context);
 418         transTypes = TransTypes.instance(context);
 419         lower = Lower.instance(context);
 420         annotate = Annotate.instance(context);
 421         types = Types.instance(context);
 422         taskListener = MultiTaskListener.instance(context);
 423         modules = Modules.instance(context);
 424         moduleFinder = ModuleFinder.instance(context);
 425         diags = Factory.instance(context);
 426         dcfh = DeferredCompletionFailureHandler.instance(context);
 427 
 428         finder.sourceCompleter = sourceCompleter;
 429         modules.findPackageInFile = this::findPackageInFile;
 430         moduleFinder.moduleNameFromSourceReader = this::readModuleName;
 431 
 432         options = Options.instance(context);
 433 
 434         verbose       = options.isSet(VERBOSE);
 435         sourceOutput  = options.isSet(PRINTSOURCE); // used to be -s
 436         lineDebugInfo = options.isUnset(G_CUSTOM) ||
 437                         options.isSet(G_CUSTOM, &quot;lines&quot;);
 438         genEndPos     = options.isSet(XJCOV) ||
 439                         context.get(DiagnosticListener.class) != null;
 440         devVerbose    = options.isSet(&quot;dev&quot;);
 441         processPcks   = options.isSet(&quot;process.packages&quot;);
 442         werror        = options.isSet(WERROR);
 443 
 444         verboseCompilePolicy = options.isSet(&quot;verboseCompilePolicy&quot;);
 445 
 446         if (options.isSet(&quot;should-stop.at&quot;) &amp;&amp;
 447             CompileState.valueOf(options.get(&quot;should-stop.at&quot;)) == CompileState.ATTR)
 448             compilePolicy = CompilePolicy.ATTR_ONLY;
 449         else
 450             compilePolicy = CompilePolicy.decode(options.get(&quot;compilePolicy&quot;));
 451 
 452         implicitSourcePolicy = ImplicitSourcePolicy.decode(options.get(&quot;-implicit&quot;));
 453 
 454         completionFailureName =
 455             options.isSet(&quot;failcomplete&quot;)
 456             ? names.fromString(options.get(&quot;failcomplete&quot;))
 457             : null;
 458 
 459         shouldStopPolicyIfError =
 460             options.isSet(&quot;should-stop.at&quot;) // backwards compatible
 461             ? CompileState.valueOf(options.get(&quot;should-stop.at&quot;))
 462             : options.isSet(&quot;should-stop.ifError&quot;)
 463             ? CompileState.valueOf(options.get(&quot;should-stop.ifError&quot;))
 464             : CompileState.INIT;
 465         shouldStopPolicyIfNoError =
 466             options.isSet(&quot;should-stop.ifNoError&quot;)
 467             ? CompileState.valueOf(options.get(&quot;should-stop.ifNoError&quot;))
 468             : CompileState.GENERATE;
 469 
 470         if (options.isUnset(&quot;diags.legacy&quot;))
 471             log.setDiagnosticFormatter(RichDiagnosticFormatter.instance(context));
 472 
 473         PlatformDescription platformProvider = context.get(PlatformDescription.class);
 474 
 475         if (platformProvider != null)
 476             closeables = closeables.prepend(platformProvider);
 477 
 478         silentFail = new Symbol(ABSENT_TYP, 0, names.empty, Type.noType, syms.rootPackage) {
 479             @DefinedBy(Api.LANGUAGE_MODEL)
 480             public &lt;R, P&gt; R accept(ElementVisitor&lt;R, P&gt; v, P p) {
 481                 return v.visitUnknown(this, p);
 482             }
 483             @Override
 484             public boolean exists() {
 485                 return false;
 486             }
 487         };
 488 
 489     }
 490 
 491     /* Switches:
 492      */
 493 
 494     /** Verbose output.
 495      */
 496     public boolean verbose;
 497 
 498     /** Emit plain Java source files rather than class files.
 499      */
 500     public boolean sourceOutput;
 501 
 502 
 503     /** Generate code with the LineNumberTable attribute for debugging
 504      */
 505     public boolean lineDebugInfo;
 506 
 507     /** Switch: should we store the ending positions?
 508      */
 509     public boolean genEndPos;
 510 
 511     /** Switch: should we debug ignored exceptions
 512      */
 513     protected boolean devVerbose;
 514 
 515     /** Switch: should we (annotation) process packages as well
 516      */
 517     protected boolean processPcks;
 518 
 519     /** Switch: treat warnings as errors
 520      */
 521     protected boolean werror;
 522 
 523     /** Switch: is annotation processing requested explicitly via
 524      * CompilationTask.setProcessors?
 525      */
 526     protected boolean explicitAnnotationProcessingRequested = false;
 527 
 528     /**
 529      * The policy for the order in which to perform the compilation
 530      */
 531     protected CompilePolicy compilePolicy;
 532 
 533     /**
 534      * The policy for what to do with implicitly read source files
 535      */
 536     protected ImplicitSourcePolicy implicitSourcePolicy;
 537 
 538     /**
 539      * Report activity related to compilePolicy
 540      */
 541     public boolean verboseCompilePolicy;
 542 
 543     /**
 544      * Policy of how far to continue compilation after errors have occurred.
 545      * Set this to minimum CompileState (INIT) to stop as soon as possible
 546      * after errors.
 547      */
 548     public CompileState shouldStopPolicyIfError;
 549 
 550     /**
 551      * Policy of how far to continue compilation when no errors have occurred.
 552      * Set this to maximum CompileState (GENERATE) to perform full compilation.
 553      * Set this lower to perform partial compilation, such as -proc:only.
 554      */
 555     public CompileState shouldStopPolicyIfNoError;
 556 
 557     /** A queue of all as yet unattributed classes.
 558      */
 559     public Todo todo;
 560 
 561     /** A list of items to be closed when the compilation is complete.
 562      */
 563     public List&lt;Closeable&gt; closeables = List.nil();
 564 
 565     /** The set of currently compiled inputfiles, needed to ensure
 566      *  we don&#39;t accidentally overwrite an input file when -s is set.
 567      *  initialized by `compile&#39;.
 568      */
 569     protected Set&lt;JavaFileObject&gt; inputFiles = new HashSet&lt;&gt;();
 570 
 571     /** Used by the resolveBinaryNameOrIdent to say that the given type cannot be found, and that
 572      *  an error has already been produced about that.
 573      */
 574     private final Symbol silentFail;
 575 
 576     protected boolean shouldStop(CompileState cs) {
 577         CompileState shouldStopPolicy = (errorCount() &gt; 0 || unrecoverableError())
 578             ? shouldStopPolicyIfError
 579             : shouldStopPolicyIfNoError;
 580         return cs.isAfter(shouldStopPolicy);
 581     }
 582 
 583     /** The number of errors reported so far.
 584      */
 585     public int errorCount() {
 586         if (werror &amp;&amp; log.nerrors == 0 &amp;&amp; log.nwarnings &gt; 0) {
 587             log.error(Errors.WarningsAndWerror);
 588         }
 589         return log.nerrors;
 590     }
 591 
 592     protected final &lt;T&gt; Queue&lt;T&gt; stopIfError(CompileState cs, Queue&lt;T&gt; queue) {
 593         return shouldStop(cs) ? new ListBuffer&lt;T&gt;() : queue;
 594     }
 595 
 596     protected final &lt;T&gt; List&lt;T&gt; stopIfError(CompileState cs, List&lt;T&gt; list) {
 597         return shouldStop(cs) ? List.nil() : list;
 598     }
 599 
 600     /** The number of warnings reported so far.
 601      */
 602     public int warningCount() {
 603         return log.nwarnings;
 604     }
 605 
 606     /** Try to open input stream with given name.
 607      *  Report an error if this fails.
 608      *  @param filename   The file name of the input stream to be opened.
 609      */
 610     public CharSequence readSource(JavaFileObject filename) {
 611         try {
 612             inputFiles.add(filename);
 613             return filename.getCharContent(false);
 614         } catch (IOException e) {
 615             log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 616             return null;
 617         }
 618     }
 619 
 620     /** Parse contents of input stream.
 621      *  @param filename     The name of the file from which input stream comes.
 622      *  @param content      The characters to be parsed.
 623      */
 624     protected JCCompilationUnit parse(JavaFileObject filename, CharSequence content) {
 625         long msec = now();
 626         JCCompilationUnit tree = make.TopLevel(List.nil());
 627         if (content != null) {
 628             if (verbose) {
 629                 log.printVerbose(&quot;parsing.started&quot;, filename);
 630             }
 631             if (!taskListener.isEmpty()) {
 632                 TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, filename);
 633                 taskListener.started(e);
 634                 keepComments = true;
 635                 genEndPos = true;
 636             }
 637             Parser parser = parserFactory.newParser(content, keepComments(), genEndPos,
 638                                 lineDebugInfo, filename.isNameCompatible(&quot;module-info&quot;, Kind.SOURCE));
 639             tree = parser.parseCompilationUnit();
 640             if (verbose) {
 641                 log.printVerbose(&quot;parsing.done&quot;, Long.toString(elapsed(msec)));
 642             }
 643         }
 644 
 645         tree.sourcefile = filename;
 646 
 647         if (content != null &amp;&amp; !taskListener.isEmpty()) {
 648             TaskEvent e = new TaskEvent(TaskEvent.Kind.PARSE, tree);
 649             taskListener.finished(e);
 650         }
 651 
 652         return tree;
 653     }
 654     // where
 655         public boolean keepComments = false;
 656         protected boolean keepComments() {
 657             return keepComments || sourceOutput;
 658         }
 659 
 660 
 661     /** Parse contents of file.
 662      *  @param filename     The name of the file to be parsed.
 663      */
 664     @Deprecated
 665     public JCTree.JCCompilationUnit parse(String filename) {
 666         JavacFileManager fm = (JavacFileManager)fileManager;
 667         return parse(fm.getJavaFileObjectsFromStrings(List.of(filename)).iterator().next());
 668     }
 669 
 670     /** Parse contents of file.
 671      *  @param filename     The name of the file to be parsed.
 672      */
 673     public JCTree.JCCompilationUnit parse(JavaFileObject filename) {
 674         JavaFileObject prev = log.useSource(filename);
 675         try {
 676             JCTree.JCCompilationUnit t = parse(filename, readSource(filename));
 677             if (t.endPositions != null)
 678                 log.setEndPosTable(filename, t.endPositions);
 679             return t;
 680         } finally {
 681             log.useSource(prev);
 682         }
 683     }
 684 
 685     /** Resolve an identifier which may be the binary name of a class or
 686      * the Java name of a class or package.
 687      * @param name      The name to resolve
 688      */
 689     public Symbol resolveBinaryNameOrIdent(String name) {
 690         ModuleSymbol msym;
 691         String typeName;
 692         int sep = name.indexOf(&#39;/&#39;);
 693         if (sep == -1) {
 694             msym = modules.getDefaultModule();
 695             typeName = name;
 696         } else if (Feature.MODULES.allowedInSource(source)) {
 697             Name modName = names.fromString(name.substring(0, sep));
 698 
 699             msym = moduleFinder.findModule(modName);
 700             typeName = name.substring(sep + 1);
 701         } else {
 702             log.error(Errors.InvalidModuleSpecifier(name));
 703             return silentFail;
 704         }
 705 
 706         return resolveBinaryNameOrIdent(msym, typeName);
 707     }
 708 
 709     /** Resolve an identifier which may be the binary name of a class or
 710      * the Java name of a class or package.
 711      * @param msym      The module in which the search should be performed
 712      * @param name      The name to resolve
 713      */
 714     public Symbol resolveBinaryNameOrIdent(ModuleSymbol msym, String name) {
 715         try {
 716             Name flatname = names.fromString(name.replace(&quot;/&quot;, &quot;.&quot;));
 717             return finder.loadClass(msym, flatname);
 718         } catch (CompletionFailure ignore) {
 719             return resolveIdent(msym, name);
 720         }
 721     }
 722 
 723     /** Resolve an identifier.
 724      * @param msym      The module in which the search should be performed
 725      * @param name      The identifier to resolve
 726      */
 727     public Symbol resolveIdent(ModuleSymbol msym, String name) {
 728         if (name.equals(&quot;&quot;))
 729             return syms.errSymbol;
 730         JavaFileObject prev = log.useSource(null);
 731         try {
 732             JCExpression tree = null;
 733             for (String s : name.split(&quot;\\.&quot;, -1)) {
 734                 if (!SourceVersion.isIdentifier(s)) // TODO: check for keywords
 735                     return syms.errSymbol;
 736                 tree = (tree == null) ? make.Ident(names.fromString(s))
 737                                       : make.Select(tree, names.fromString(s));
 738             }
 739             JCCompilationUnit toplevel =
 740                 make.TopLevel(List.nil());
 741             toplevel.modle = msym;
 742             toplevel.packge = msym.unnamedPackage;
 743             return attr.attribIdent(tree, toplevel);
 744         } finally {
 745             log.useSource(prev);
 746         }
 747     }
 748 
 749     /** Generate code and emit a class file for a given class
 750      *  @param env    The attribution environment of the outermost class
 751      *                containing this class.
 752      *  @param cdef   The class definition from which code is generated.
 753      */
 754     JavaFileObject genCode(Env&lt;AttrContext&gt; env, JCClassDecl cdef) throws IOException {
 755         try {
 756             if (gen.genClass(env, cdef) &amp;&amp; (errorCount() == 0))
 757                 return writer.writeClass(cdef.sym);
 758         } catch (ClassWriter.PoolOverflow ex) {
 759             log.error(cdef.pos(), Errors.LimitPool);
 760         } catch (ClassWriter.StringOverflow ex) {
 761             log.error(cdef.pos(),
 762                       Errors.LimitStringOverflow(ex.value.substring(0, 20)));
 763         } catch (CompletionFailure ex) {
 764             chk.completionError(cdef.pos(), ex);
 765         }
 766         return null;
 767     }
 768 
 769     /** Emit plain Java source for a class.
 770      *  @param env    The attribution environment of the outermost class
 771      *                containing this class.
 772      *  @param cdef   The class definition to be printed.
 773      */
 774     JavaFileObject printSource(Env&lt;AttrContext&gt; env, JCClassDecl cdef) throws IOException {
 775         JavaFileObject outFile
 776            = fileManager.getJavaFileForOutput(CLASS_OUTPUT,
 777                                                cdef.sym.flatname.toString(),
 778                                                JavaFileObject.Kind.SOURCE,
 779                                                null);
 780         if (inputFiles.contains(outFile)) {
 781             log.error(cdef.pos(), Errors.SourceCantOverwriteInputFile(outFile));
 782             return null;
 783         } else {
 784             try (BufferedWriter out = new BufferedWriter(outFile.openWriter())) {
 785                 new Pretty(out, true).printUnit(env.toplevel, cdef);
 786                 if (verbose)
 787                     log.printVerbose(&quot;wrote.file&quot;, outFile.getName());
 788             }
 789             return outFile;
 790         }
 791     }
 792 
 793     /** Compile a source file that has been accessed by the class finder.
 794      *  @param c          The class the source file of which needs to be compiled.
 795      */
 796     private void readSourceFile(ClassSymbol c) throws CompletionFailure {
 797         readSourceFile(null, c);
 798     }
 799 
 800     /** Compile a ClassSymbol from source, optionally using the given compilation unit as
 801      *  the source tree.
 802      *  @param tree the compilation unit in which the given ClassSymbol resides,
 803      *              or null if should be parsed from source
 804      *  @param c    the ClassSymbol to complete
 805      */
 806     public void readSourceFile(JCCompilationUnit tree, ClassSymbol c) throws CompletionFailure {
 807         if (completionFailureName == c.fullname) {
 808             throw new CompletionFailure(
 809                 c, () -&gt; diagFactory.fragment(Fragments.UserSelectedCompletionFailure), dcfh);
 810         }
 811         JavaFileObject filename = c.classfile;
 812         JavaFileObject prev = log.useSource(filename);
 813 
 814         if (tree == null) {
 815             try {
 816                 tree = parse(filename, filename.getCharContent(false));
 817             } catch (IOException e) {
 818                 log.error(Errors.ErrorReadingFile(filename, JavacFileManager.getMessage(e)));
 819                 tree = make.TopLevel(List.&lt;JCTree&gt;nil());
 820             } finally {
 821                 log.useSource(prev);
 822             }
 823         }
 824 
 825         if (!taskListener.isEmpty()) {
 826             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 827             taskListener.started(e);
 828         }
 829 
 830         // Process module declarations.
 831         // If module resolution fails, ignore trees, and if trying to
 832         // complete a specific symbol, throw CompletionFailure.
 833         // Note that if module resolution failed, we may not even
 834         // have enough modules available to access java.lang, and
 835         // so risk getting FatalError(&quot;no.java.lang&quot;) from MemberEnter.
 836         if (!modules.enter(List.of(tree), c)) {
 837             throw new CompletionFailure(c, () -&gt; diags.fragment(Fragments.CantResolveModules), dcfh);
 838         }
 839 
 840         enter.complete(List.of(tree), c);
 841 
 842         if (!taskListener.isEmpty()) {
 843             TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, tree);
 844             taskListener.finished(e);
 845         }
 846 
 847         if (enter.getEnv(c) == null) {
 848             boolean isPkgInfo =
 849                 tree.sourcefile.isNameCompatible(&quot;package-info&quot;,
 850                                                  JavaFileObject.Kind.SOURCE);
 851             boolean isModuleInfo =
 852                 tree.sourcefile.isNameCompatible(&quot;module-info&quot;,
 853                                                  JavaFileObject.Kind.SOURCE);
 854             if (isModuleInfo) {
 855                 if (enter.getEnv(tree.modle) == null) {
 856                     JCDiagnostic diag =
 857                         diagFactory.fragment(Fragments.FileDoesNotContainModule);
 858                     throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 859                 }
 860             } else if (isPkgInfo) {
 861                 if (enter.getEnv(tree.packge) == null) {
 862                     JCDiagnostic diag =
 863                         diagFactory.fragment(Fragments.FileDoesNotContainPackage(c.location()));
 864                     throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 865                 }
 866             } else {
 867                 JCDiagnostic diag =
 868                         diagFactory.fragment(Fragments.FileDoesntContainClass(c.getQualifiedName()));
 869                 throw new ClassFinder.BadClassFile(c, filename, diag, diagFactory, dcfh);
 870             }
 871         }
 872 
 873         implicitSourceFilesRead = true;
 874     }
 875 
 876     /** Track when the JavaCompiler has been used to compile something. */
 877     private boolean hasBeenUsed = false;
 878     private long start_msec = 0;
 879     public long elapsed_msec = 0;
 880 
 881     public void compile(List&lt;JavaFileObject&gt; sourceFileObject)
 882         throws Throwable {
 883         compile(sourceFileObject, List.nil(), null, List.nil());
 884     }
 885 
 886     /**
 887      * Main method: compile a list of files, return all compiled classes
 888      *
 889      * @param sourceFileObjects file objects to be compiled
 890      * @param classnames class names to process for annotations
 891      * @param processors user provided annotation processors to bypass
 892      * discovery, {@code null} means that no processors were provided
 893      * @param addModules additional root modules to be used during
 894      * module resolution.
 895      */
 896     public void compile(Collection&lt;JavaFileObject&gt; sourceFileObjects,
 897                         Collection&lt;String&gt; classnames,
 898                         Iterable&lt;? extends Processor&gt; processors,
 899                         Collection&lt;String&gt; addModules)
 900     {
 901         if (!taskListener.isEmpty()) {
 902             taskListener.started(new TaskEvent(TaskEvent.Kind.COMPILATION));
 903         }
 904 
 905         if (processors != null &amp;&amp; processors.iterator().hasNext())
 906             explicitAnnotationProcessingRequested = true;
 907         // as a JavaCompiler can only be used once, throw an exception if
 908         // it has been used before.
 909         if (hasBeenUsed)
 910             checkReusable();
 911         hasBeenUsed = true;
 912 
 913         // forcibly set the equivalent of -Xlint:-options, so that no further
 914         // warnings about command line options are generated from this point on
 915         options.put(XLINT_CUSTOM.primaryName + &quot;-&quot; + LintCategory.OPTIONS.option, &quot;true&quot;);
 916         options.remove(XLINT_CUSTOM.primaryName + LintCategory.OPTIONS.option);
 917 
 918         start_msec = now();
 919 
 920         try {
 921             initProcessAnnotations(processors, sourceFileObjects, classnames);
 922 
 923             for (String className : classnames) {
 924                 int sep = className.indexOf(&#39;/&#39;);
 925                 if (sep != -1) {
 926                     modules.addExtraAddModules(className.substring(0, sep));
 927                 }
 928             }
 929 
 930             for (String moduleName : addModules) {
 931                 modules.addExtraAddModules(moduleName);
 932             }
 933 
 934             // These method calls must be chained to avoid memory leaks
 935             processAnnotations(
 936                 enterTrees(
 937                         stopIfError(CompileState.ENTER,
 938                                 initModules(stopIfError(CompileState.ENTER, parseFiles(sourceFileObjects))))
 939                 ),
 940                 classnames
 941             );
 942 
 943             // If it&#39;s safe to do so, skip attr / flow / gen for implicit classes
 944             if (taskListener.isEmpty() &amp;&amp;
 945                     implicitSourcePolicy == ImplicitSourcePolicy.NONE) {
 946                 todo.retainFiles(inputFiles);
 947             }
 948 
 949             if (!CompileState.ATTR.isAfter(shouldStopPolicyIfNoError)) {
 950                 switch (compilePolicy) {
 951                 case ATTR_ONLY:
 952                     attribute(todo);
 953                     break;
 954 
 955                 case CHECK_ONLY:
 956                     flow(attribute(todo));
 957                     break;
 958 
 959                 case SIMPLE:
 960                     generate(desugar(flow(attribute(todo))));
 961                     break;
 962 
 963                 case BY_FILE: {
 964                         Queue&lt;Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; q = todo.groupByFile();
 965                         while (!q.isEmpty() &amp;&amp; !shouldStop(CompileState.ATTR)) {
 966                             generate(desugar(flow(attribute(q.remove()))));
 967                         }
 968                     }
 969                     break;
 970 
 971                 case BY_TODO:
 972                     while (!todo.isEmpty())
 973                         generate(desugar(flow(attribute(todo.remove()))));
 974                     break;
 975 
 976                 default:
 977                     Assert.error(&quot;unknown compile policy&quot;);
 978                 }
 979             }
 980         } catch (Abort ex) {
 981             if (devVerbose)
 982                 ex.printStackTrace(System.err);
 983         } finally {
 984             if (verbose) {
 985                 elapsed_msec = elapsed(start_msec);
 986                 log.printVerbose(&quot;total&quot;, Long.toString(elapsed_msec));
 987             }
 988 
 989             reportDeferredDiagnostics();
 990 
 991             if (!log.hasDiagnosticListener()) {
 992                 printCount(&quot;error&quot;, errorCount());
 993                 printCount(&quot;warn&quot;, warningCount());
 994                 printSuppressedCount(errorCount(), log.nsuppressederrors, &quot;count.error.recompile&quot;);
 995                 printSuppressedCount(warningCount(), log.nsuppressedwarns, &quot;count.warn.recompile&quot;);
 996             }
 997             if (!taskListener.isEmpty()) {
 998                 taskListener.finished(new TaskEvent(TaskEvent.Kind.COMPILATION));
 999             }
1000             close();
1001             if (procEnvImpl != null)
1002                 procEnvImpl.close();
1003         }
1004     }
1005 
1006     protected void checkReusable() {
1007         throw new AssertionError(&quot;attempt to reuse JavaCompiler&quot;);
1008     }
1009 
1010     /**
1011      * The list of classes explicitly supplied on the command line for compilation.
1012      * Not always populated.
1013      */
1014     private List&lt;JCClassDecl&gt; rootClasses;
1015 
1016     /**
1017      * Parses a list of files.
1018      */
1019    public List&lt;JCCompilationUnit&gt; parseFiles(Iterable&lt;JavaFileObject&gt; fileObjects) {
1020        return parseFiles(fileObjects, false);
1021    }
1022 
1023    public List&lt;JCCompilationUnit&gt; parseFiles(Iterable&lt;JavaFileObject&gt; fileObjects, boolean force) {
1024        if (!force &amp;&amp; shouldStop(CompileState.PARSE))
1025            return List.nil();
1026 
1027         //parse all files
1028         ListBuffer&lt;JCCompilationUnit&gt; trees = new ListBuffer&lt;&gt;();
1029         Set&lt;JavaFileObject&gt; filesSoFar = new HashSet&lt;&gt;();
1030         for (JavaFileObject fileObject : fileObjects) {
1031             if (!filesSoFar.contains(fileObject)) {
1032                 filesSoFar.add(fileObject);
1033                 trees.append(parse(fileObject));
1034             }
1035         }
1036         return trees.toList();
1037     }
1038 
1039     /**
1040      * Enter the symbols found in a list of parse trees if the compilation
1041      * is expected to proceed beyond anno processing into attr.
1042      * As a side-effect, this puts elements on the &quot;todo&quot; list.
1043      * Also stores a list of all top level classes in rootClasses.
1044      */
1045     public List&lt;JCCompilationUnit&gt; enterTreesIfNeeded(List&lt;JCCompilationUnit&gt; roots) {
1046        if (shouldStop(CompileState.ATTR))
1047            return List.nil();
1048         return enterTrees(initModules(roots));
1049     }
1050 
1051     public List&lt;JCCompilationUnit&gt; initModules(List&lt;JCCompilationUnit&gt; roots) {
1052         modules.initModules(roots);
1053         if (roots.isEmpty()) {
1054             enterDone();
1055         }
1056         return roots;
1057     }
1058 
1059     /**
1060      * Enter the symbols found in a list of parse trees.
1061      * As a side-effect, this puts elements on the &quot;todo&quot; list.
1062      * Also stores a list of all top level classes in rootClasses.
1063      */
1064     public List&lt;JCCompilationUnit&gt; enterTrees(List&lt;JCCompilationUnit&gt; roots) {
1065         //enter symbols for all files
1066         if (!taskListener.isEmpty()) {
1067             for (JCCompilationUnit unit: roots) {
1068                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
1069                 taskListener.started(e);
1070             }
1071         }
1072 
1073         enter.main(roots);
1074 
1075         enterDone();
1076 
1077         if (!taskListener.isEmpty()) {
1078             for (JCCompilationUnit unit: roots) {
1079                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ENTER, unit);
1080                 taskListener.finished(e);
1081             }
1082         }
1083 
1084         // If generating source, or if tracking public apis,
1085         // then remember the classes declared in
1086         // the original compilation units listed on the command line.
1087         if (sourceOutput) {
1088             ListBuffer&lt;JCClassDecl&gt; cdefs = new ListBuffer&lt;&gt;();
1089             for (JCCompilationUnit unit : roots) {
1090                 for (List&lt;JCTree&gt; defs = unit.defs;
1091                      defs.nonEmpty();
1092                      defs = defs.tail) {
1093                     if (defs.head instanceof JCClassDecl)
1094                         cdefs.append((JCClassDecl)defs.head);
1095                 }
1096             }
1097             rootClasses = cdefs.toList();
1098         }
1099 
1100         // Ensure the input files have been recorded. Although this is normally
1101         // done by readSource, it may not have been done if the trees were read
1102         // in a prior round of annotation processing, and the trees have been
1103         // cleaned and are being reused.
1104         for (JCCompilationUnit unit : roots) {
1105             inputFiles.add(unit.sourcefile);
1106         }
1107 
1108         return roots;
1109     }
1110 
1111     /**
1112      * Set to true to enable skeleton annotation processing code.
1113      * Currently, we assume this variable will be replaced more
1114      * advanced logic to figure out if annotation processing is
1115      * needed.
1116      */
1117     boolean processAnnotations = false;
1118 
1119     Log.DeferredDiagnosticHandler deferredDiagnosticHandler;
1120 
1121     /**
1122      * Object to handle annotation processing.
1123      */
1124     private JavacProcessingEnvironment procEnvImpl = null;
1125 
1126     /**
1127      * Check if we should process annotations.
1128      * If so, and if no scanner is yet registered, then set up the DocCommentScanner
1129      * to catch doc comments, and set keepComments so the parser records them in
1130      * the compilation unit.
1131      *
1132      * @param processors user provided annotation processors to bypass
1133      * discovery, {@code null} means that no processors were provided
1134      */
1135     public void initProcessAnnotations(Iterable&lt;? extends Processor&gt; processors,
1136                                        Collection&lt;? extends JavaFileObject&gt; initialFiles,
1137                                        Collection&lt;String&gt; initialClassNames) {
1138         // Process annotations if processing is not disabled and there
1139         // is at least one Processor available.
1140         if (options.isSet(PROC, &quot;none&quot;)) {
1141             processAnnotations = false;
1142         } else if (procEnvImpl == null) {
1143             procEnvImpl = JavacProcessingEnvironment.instance(context);
1144             procEnvImpl.setProcessors(processors);
1145             processAnnotations = procEnvImpl.atLeastOneProcessor();
1146 
1147             if (processAnnotations) {
1148                 options.put(&quot;parameters&quot;, &quot;parameters&quot;);
1149                 reader.saveParameterNames = true;
1150                 keepComments = true;
1151                 genEndPos = true;
1152                 if (!taskListener.isEmpty())
1153                     taskListener.started(new TaskEvent(TaskEvent.Kind.ANNOTATION_PROCESSING));
1154                 deferredDiagnosticHandler = new Log.DeferredDiagnosticHandler(log);
1155                 procEnvImpl.getFiler().setInitialState(initialFiles, initialClassNames);
1156             } else { // free resources
1157                 procEnvImpl.close();
1158             }
1159         }
1160     }
1161 
1162     // TODO: called by JavacTaskImpl
1163     public void processAnnotations(List&lt;JCCompilationUnit&gt; roots) {
1164         processAnnotations(roots, List.nil());
1165     }
1166 
1167     /**
1168      * Process any annotations found in the specified compilation units.
1169      * @param roots a list of compilation units
1170      */
1171     // Implementation note: when this method is called, log.deferredDiagnostics
1172     // will have been set true by initProcessAnnotations, meaning that any diagnostics
1173     // that are reported will go into the log.deferredDiagnostics queue.
1174     // By the time this method exits, log.deferDiagnostics must be set back to false,
1175     // and all deferredDiagnostics must have been handled: i.e. either reported
1176     // or determined to be transient, and therefore suppressed.
1177     public void processAnnotations(List&lt;JCCompilationUnit&gt; roots,
1178                                    Collection&lt;String&gt; classnames) {
1179         if (shouldStop(CompileState.PROCESS)) {
1180             // Errors were encountered.
1181             // Unless all the errors are resolve errors, the errors were parse errors
1182             // or other errors during enter which cannot be fixed by running
1183             // any annotation processors.
1184             if (processAnnotations) {
1185                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1186                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1187                 return ;
1188             }
1189         }
1190 
1191         // ASSERT: processAnnotations and procEnvImpl should have been set up by
1192         // by initProcessAnnotations
1193 
1194         // NOTE: The !classnames.isEmpty() checks should be refactored to Main.
1195 
1196         if (!processAnnotations) {
1197             // If there are no annotation processors present, and
1198             // annotation processing is to occur with compilation,
1199             // emit a warning.
1200             if (options.isSet(PROC, &quot;only&quot;)) {
1201                 log.warning(Warnings.ProcProcOnlyRequestedNoProcs);
1202                 todo.clear();
1203             }
1204             // If not processing annotations, classnames must be empty
1205             if (!classnames.isEmpty()) {
1206                 log.error(Errors.ProcNoExplicitAnnotationProcessingRequested(classnames));
1207             }
1208             Assert.checkNull(deferredDiagnosticHandler);
1209             return ; // continue regular compilation
1210         }
1211 
1212         Assert.checkNonNull(deferredDiagnosticHandler);
1213 
1214         try {
1215             List&lt;ClassSymbol&gt; classSymbols = List.nil();
1216             List&lt;PackageSymbol&gt; pckSymbols = List.nil();
1217             if (!classnames.isEmpty()) {
1218                  // Check for explicit request for annotation
1219                  // processing
1220                 if (!explicitAnnotationProcessingRequested()) {
1221                     log.error(Errors.ProcNoExplicitAnnotationProcessingRequested(classnames));
1222                     deferredDiagnosticHandler.reportDeferredDiagnostics();
1223                     log.popDiagnosticHandler(deferredDiagnosticHandler);
1224                     return ; // TODO: Will this halt compilation?
1225                 } else {
1226                     boolean errors = false;
1227                     for (String nameStr : classnames) {
1228                         Symbol sym = resolveBinaryNameOrIdent(nameStr);
1229                         if (sym == null ||
1230                             (sym.kind == PCK &amp;&amp; !processPcks) ||
1231                             sym.kind == ABSENT_TYP) {
1232                             if (sym != silentFail)
1233                                 log.error(Errors.ProcCantFindClass(nameStr));
1234                             errors = true;
1235                             continue;
1236                         }
1237                         try {
1238                             if (sym.kind == PCK)
1239                                 sym.complete();
1240                             if (sym.exists()) {
1241                                 if (sym.kind == PCK)
1242                                     pckSymbols = pckSymbols.prepend((PackageSymbol)sym);
1243                                 else
1244                                     classSymbols = classSymbols.prepend((ClassSymbol)sym);
1245                                 continue;
1246                             }
1247                             Assert.check(sym.kind == PCK);
1248                             log.warning(Warnings.ProcPackageDoesNotExist(nameStr));
1249                             pckSymbols = pckSymbols.prepend((PackageSymbol)sym);
1250                         } catch (CompletionFailure e) {
1251                             log.error(Errors.ProcCantFindClass(nameStr));
1252                             errors = true;
1253                             continue;
1254                         }
1255                     }
1256                     if (errors) {
1257                         deferredDiagnosticHandler.reportDeferredDiagnostics();
1258                         log.popDiagnosticHandler(deferredDiagnosticHandler);
1259                         return ;
1260                     }
1261                 }
1262             }
1263             try {
1264                 annotationProcessingOccurred =
1265                         procEnvImpl.doProcessing(roots,
1266                                                  classSymbols,
1267                                                  pckSymbols,
1268                                                  deferredDiagnosticHandler);
1269                 // doProcessing will have handled deferred diagnostics
1270             } finally {
1271                 procEnvImpl.close();
1272             }
1273         } catch (CompletionFailure ex) {
1274             log.error(Errors.CantAccess(ex.sym, ex.getDetailValue()));
1275             if (deferredDiagnosticHandler != null) {
1276                 deferredDiagnosticHandler.reportDeferredDiagnostics();
1277                 log.popDiagnosticHandler(deferredDiagnosticHandler);
1278             }
1279         }
1280     }
1281 
1282     private boolean unrecoverableError() {
1283         if (deferredDiagnosticHandler != null) {
1284             for (JCDiagnostic d: deferredDiagnosticHandler.getDiagnostics()) {
1285                 if (d.getKind() == JCDiagnostic.Kind.ERROR &amp;&amp; !d.isFlagSet(RECOVERABLE))
1286                     return true;
1287             }
1288         }
1289         return false;
1290     }
1291 
1292     boolean explicitAnnotationProcessingRequested() {
1293         return
1294             explicitAnnotationProcessingRequested ||
1295             explicitAnnotationProcessingRequested(options);
1296     }
1297 
1298     static boolean explicitAnnotationProcessingRequested(Options options) {
1299         return
1300             options.isSet(PROCESSOR) ||
1301             options.isSet(PROCESSOR_PATH) ||
1302             options.isSet(PROCESSOR_MODULE_PATH) ||
1303             options.isSet(PROC, &quot;only&quot;) ||
1304             options.isSet(XPRINT);
1305     }
1306 
1307     public void setDeferredDiagnosticHandler(Log.DeferredDiagnosticHandler deferredDiagnosticHandler) {
1308         this.deferredDiagnosticHandler = deferredDiagnosticHandler;
1309     }
1310 
1311     /**
1312      * Attribute a list of parse trees, such as found on the &quot;todo&quot; list.
1313      * Note that attributing classes may cause additional files to be
1314      * parsed and entered via the SourceCompleter.
1315      * Attribution of the entries in the list does not stop if any errors occur.
1316      * @return a list of environments for attribute classes.
1317      */
1318     public Queue&lt;Env&lt;AttrContext&gt;&gt; attribute(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1319         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1320         while (!envs.isEmpty())
1321             results.append(attribute(envs.remove()));
1322         return stopIfError(CompileState.ATTR, results);
1323     }
1324 
1325     /**
1326      * Attribute a parse tree.
1327      * @return the attributed parse tree
1328      */
1329     public Env&lt;AttrContext&gt; attribute(Env&lt;AttrContext&gt; env) {
1330         if (compileStates.isDone(env, CompileState.ATTR))
1331             return env;
1332 
1333         if (verboseCompilePolicy)
1334             printNote(&quot;[attribute &quot; + env.enclClass.sym + &quot;]&quot;);
1335         if (verbose)
1336             log.printVerbose(&quot;checking.attribution&quot;, env.enclClass.sym);
1337 
1338         if (!taskListener.isEmpty()) {
1339             TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
1340             taskListener.started(e);
1341         }
1342 
1343         JavaFileObject prev = log.useSource(
1344                                   env.enclClass.sym.sourcefile != null ?
1345                                   env.enclClass.sym.sourcefile :
1346                                   env.toplevel.sourcefile);
1347         try {
1348             attr.attrib(env);
1349             if (errorCount() &gt; 0 &amp;&amp; !shouldStop(CompileState.ATTR)) {
1350                 //if in fail-over mode, ensure that AST expression nodes
1351                 //are correctly initialized (e.g. they have a type/symbol)
1352                 attr.postAttr(env.tree);
1353             }
1354             compileStates.put(env, CompileState.ATTR);
1355         }
1356         finally {
1357             log.useSource(prev);
1358         }
1359 
1360         return env;
1361     }
1362 
1363     /**
1364      * Perform dataflow checks on attributed parse trees.
1365      * These include checks for definite assignment and unreachable statements.
1366      * If any errors occur, an empty list will be returned.
1367      * @return the list of attributed parse trees
1368      */
1369     public Queue&lt;Env&lt;AttrContext&gt;&gt; flow(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1370         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1371         for (Env&lt;AttrContext&gt; env: envs) {
1372             flow(env, results);
1373         }
1374         return stopIfError(CompileState.FLOW, results);
1375     }
1376 
1377     /**
1378      * Perform dataflow checks on an attributed parse tree.
1379      */
1380     public Queue&lt;Env&lt;AttrContext&gt;&gt; flow(Env&lt;AttrContext&gt; env) {
1381         ListBuffer&lt;Env&lt;AttrContext&gt;&gt; results = new ListBuffer&lt;&gt;();
1382         flow(env, results);
1383         return stopIfError(CompileState.FLOW, results);
1384     }
1385 
1386     /**
1387      * Perform dataflow checks on an attributed parse tree.
1388      */
1389     protected void flow(Env&lt;AttrContext&gt; env, Queue&lt;Env&lt;AttrContext&gt;&gt; results) {
1390         if (compileStates.isDone(env, CompileState.FLOW)) {
1391             results.add(env);
1392             return;
1393         }
1394 
1395         try {
1396             if (shouldStop(CompileState.FLOW))
1397                 return;
1398 
1399             if (verboseCompilePolicy)
1400                 printNote(&quot;[flow &quot; + env.enclClass.sym + &quot;]&quot;);
1401             JavaFileObject prev = log.useSource(
1402                                                 env.enclClass.sym.sourcefile != null ?
1403                                                 env.enclClass.sym.sourcefile :
1404                                                 env.toplevel.sourcefile);
1405             try {
1406                 make.at(Position.FIRSTPOS);
1407                 TreeMaker localMake = make.forToplevel(env.toplevel);
1408                 flow.analyzeTree(env, localMake);
1409                 compileStates.put(env, CompileState.FLOW);
1410 
1411                 if (shouldStop(CompileState.FLOW))
1412                     return;
1413 
1414                 analyzer.flush(env);
1415 
1416                 results.add(env);
1417             }
1418             finally {
1419                 log.useSource(prev);
1420             }
1421         }
1422         finally {
1423             if (!taskListener.isEmpty()) {
1424                 TaskEvent e = new TaskEvent(TaskEvent.Kind.ANALYZE, env.toplevel, env.enclClass.sym);
1425                 taskListener.finished(e);
1426             }
1427         }
1428     }
1429 
1430     /**
1431      * Prepare attributed parse trees, in conjunction with their attribution contexts,
1432      * for source or code generation.
1433      * If any errors occur, an empty list will be returned.
1434      * @return a list containing the classes to be generated
1435      */
1436     public Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; desugar(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1437         ListBuffer&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; results = new ListBuffer&lt;&gt;();
1438         for (Env&lt;AttrContext&gt; env: envs)
1439             desugar(env, results);
1440         return stopIfError(CompileState.FLOW, results);
1441     }
1442 
1443     HashMap&lt;Env&lt;AttrContext&gt;, Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt;&gt; desugaredEnvs = new HashMap&lt;&gt;();
1444 
1445     /**
1446      * Prepare attributed parse trees, in conjunction with their attribution contexts,
1447      * for source or code generation. If the file was not listed on the command line,
1448      * the current implicitSourcePolicy is taken into account.
1449      * The preparation stops as soon as an error is found.
1450      */
1451     protected void desugar(final Env&lt;AttrContext&gt; env, Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; results) {
1452         if (shouldStop(CompileState.TRANSTYPES))
1453             return;
1454 
1455         if (implicitSourcePolicy == ImplicitSourcePolicy.NONE
1456                 &amp;&amp; !inputFiles.contains(env.toplevel.sourcefile)) {
1457             return;
1458         }
1459 
1460         if (!modules.multiModuleMode &amp;&amp; env.toplevel.modle != modules.getDefaultModule()) {
1461             //can only generate classfiles for a single module:
1462             return;
1463         }
1464 
1465         if (compileStates.isDone(env, CompileState.LOWER)) {
1466             results.addAll(desugaredEnvs.get(env));
1467             return;
1468         }
1469 
1470         /**
1471          * Ensure that superclasses of C are desugared before C itself. This is
1472          * required for two reasons: (i) as erasure (TransTypes) destroys
1473          * information needed in flow analysis and (ii) as some checks carried
1474          * out during lowering require that all synthetic fields/methods have
1475          * already been added to C and its superclasses.
1476          */
1477         class ScanNested extends TreeScanner {
1478             Set&lt;Env&lt;AttrContext&gt;&gt; dependencies = new LinkedHashSet&lt;&gt;();
1479             protected boolean hasLambdas;
1480             @Override
1481             public void visitClassDef(JCClassDecl node) {
1482                 Type st = types.supertype(node.sym.type);
1483                 boolean envForSuperTypeFound = false;
1484                 while (!envForSuperTypeFound &amp;&amp; st.hasTag(CLASS)) {
1485                     ClassSymbol c = st.tsym.outermostClass();
1486                     Env&lt;AttrContext&gt; stEnv = enter.getEnv(c);
1487                     if (stEnv != null &amp;&amp; env != stEnv) {
1488                         if (dependencies.add(stEnv)) {
1489                             boolean prevHasLambdas = hasLambdas;
1490                             try {
1491                                 scan(stEnv.tree);
1492                             } finally {
1493                                 /*
1494                                  * ignore any updates to hasLambdas made during
1495                                  * the nested scan, this ensures an initialized
1496                                  * LambdaToMethod is available only to those
1497                                  * classes that contain lambdas
1498                                  */
1499                                 hasLambdas = prevHasLambdas;
1500                             }
1501                         }
1502                         envForSuperTypeFound = true;
1503                     }
1504                     st = types.supertype(st);
1505                 }
1506                 super.visitClassDef(node);
1507             }
1508             @Override
1509             public void visitLambda(JCLambda tree) {
1510                 hasLambdas = true;
1511                 super.visitLambda(tree);
1512             }
1513             @Override
1514             public void visitReference(JCMemberReference tree) {
1515                 hasLambdas = true;
1516                 super.visitReference(tree);
1517             }
1518         }
1519         ScanNested scanner = new ScanNested();
1520         scanner.scan(env.tree);
1521         for (Env&lt;AttrContext&gt; dep: scanner.dependencies) {
1522         if (!compileStates.isDone(dep, CompileState.FLOW))
1523             desugaredEnvs.put(dep, desugar(flow(attribute(dep))));
1524         }
1525 
1526         //We need to check for error another time as more classes might
1527         //have been attributed and analyzed at this stage
1528         if (shouldStop(CompileState.TRANSTYPES))
1529             return;
1530 
1531         if (verboseCompilePolicy)
1532             printNote(&quot;[desugar &quot; + env.enclClass.sym + &quot;]&quot;);
1533 
1534         JavaFileObject prev = log.useSource(env.enclClass.sym.sourcefile != null ?
1535                                   env.enclClass.sym.sourcefile :
1536                                   env.toplevel.sourcefile);
1537         try {
1538             //save tree prior to rewriting
1539             JCTree untranslated = env.tree;
1540 
1541             make.at(Position.FIRSTPOS);
1542             TreeMaker localMake = make.forToplevel(env.toplevel);
1543 
1544             if (env.tree.hasTag(JCTree.Tag.PACKAGEDEF) || env.tree.hasTag(JCTree.Tag.MODULEDEF)) {
1545                 if (!(sourceOutput)) {
1546                     if (shouldStop(CompileState.LOWER))
1547                         return;
1548                     List&lt;JCTree&gt; def = lower.translateTopLevelClass(env, env.tree, localMake);
1549                     if (def.head != null) {
1550                         Assert.check(def.tail.isEmpty());
1551                         results.add(new Pair&lt;&gt;(env, (JCClassDecl)def.head));
1552                     }
1553                 }
1554                 return;
1555             }
1556 
1557             if (shouldStop(CompileState.TRANSTYPES))
1558                 return;
1559 
1560             env.tree = transTypes.translateTopLevelClass(env.tree, localMake);
1561             compileStates.put(env, CompileState.TRANSTYPES);
1562 
1563             if (shouldStop(CompileState.TRANSPATTERNS))
1564                 return;
1565 
1566             env.tree = TransPatterns.instance(context).translateTopLevelClass(env, env.tree, localMake);
1567             compileStates.put(env, CompileState.TRANSPATTERNS);
1568 
1569             if (Feature.LAMBDA.allowedInSource(source) &amp;&amp; scanner.hasLambdas) {
1570                 if (shouldStop(CompileState.UNLAMBDA))
1571                     return;
1572 
1573                 env.tree = LambdaToMethod.instance(context).translateTopLevelClass(env, env.tree, localMake);
1574                 compileStates.put(env, CompileState.UNLAMBDA);
1575             }
1576 
1577             if (shouldStop(CompileState.LOWER))
1578                 return;
1579 
1580             if (sourceOutput) {
1581                 //emit standard Java source file, only for compilation
1582                 //units enumerated explicitly on the command line
1583                 JCClassDecl cdef = (JCClassDecl)env.tree;
1584                 if (untranslated instanceof JCClassDecl &amp;&amp;
1585                     rootClasses.contains((JCClassDecl)untranslated)) {
1586                     results.add(new Pair&lt;&gt;(env, cdef));
1587                 }
1588                 return;
1589             }
1590 
1591             //translate out inner classes
1592             List&lt;JCTree&gt; cdefs = lower.translateTopLevelClass(env, env.tree, localMake);
1593             compileStates.put(env, CompileState.LOWER);
1594 
1595             if (shouldStop(CompileState.LOWER))
1596                 return;
1597 
1598             //generate code for each class
1599             for (List&lt;JCTree&gt; l = cdefs; l.nonEmpty(); l = l.tail) {
1600                 JCClassDecl cdef = (JCClassDecl)l.head;
1601                 results.add(new Pair&lt;&gt;(env, cdef));
1602             }
1603         }
1604         finally {
1605             log.useSource(prev);
1606         }
1607 
1608     }
1609 
1610     /** Generates the source or class file for a list of classes.
1611      * The decision to generate a source file or a class file is
1612      * based upon the compiler&#39;s options.
1613      * Generation stops if an error occurs while writing files.
1614      */
1615     public void generate(Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; queue) {
1616         generate(queue, null);
1617     }
1618 
1619     public void generate(Queue&lt;Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt;&gt; queue, Queue&lt;JavaFileObject&gt; results) {
1620         if (shouldStop(CompileState.GENERATE))
1621             return;
1622 
1623         for (Pair&lt;Env&lt;AttrContext&gt;, JCClassDecl&gt; x: queue) {
1624             Env&lt;AttrContext&gt; env = x.fst;
1625             JCClassDecl cdef = x.snd;
1626 
1627             if (verboseCompilePolicy) {
1628                 printNote(&quot;[generate &quot; + (sourceOutput ? &quot; source&quot; : &quot;code&quot;) + &quot; &quot; + cdef.sym + &quot;]&quot;);
1629             }
1630 
1631             if (!taskListener.isEmpty()) {
1632                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
1633                 taskListener.started(e);
1634             }
1635 
1636             JavaFileObject prev = log.useSource(env.enclClass.sym.sourcefile != null ?
1637                                       env.enclClass.sym.sourcefile :
1638                                       env.toplevel.sourcefile);
1639             try {
1640                 JavaFileObject file;
1641                 if (sourceOutput) {
1642                     file = printSource(env, cdef);
1643                 } else {
1644                     if (fileManager.hasLocation(StandardLocation.NATIVE_HEADER_OUTPUT)
1645                             &amp;&amp; jniWriter.needsHeader(cdef.sym)) {
1646                         jniWriter.write(cdef.sym);
1647                     }
1648                     file = genCode(env, cdef);
1649                 }
1650                 if (results != null &amp;&amp; file != null)
1651                     results.add(file);
1652             } catch (IOException ex) {
1653                 log.error(cdef.pos(),
1654                           Errors.ClassCantWrite(cdef.sym, ex.getMessage()));
1655                 return;
1656             } finally {
1657                 log.useSource(prev);
1658             }
1659 
1660             if (!taskListener.isEmpty()) {
1661                 TaskEvent e = new TaskEvent(TaskEvent.Kind.GENERATE, env.toplevel, cdef.sym);
1662                 taskListener.finished(e);
1663             }
1664         }
1665     }
1666 
1667         // where
1668         Map&lt;JCCompilationUnit, Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; groupByFile(Queue&lt;Env&lt;AttrContext&gt;&gt; envs) {
1669             // use a LinkedHashMap to preserve the order of the original list as much as possible
1670             Map&lt;JCCompilationUnit, Queue&lt;Env&lt;AttrContext&gt;&gt;&gt; map = new LinkedHashMap&lt;&gt;();
1671             for (Env&lt;AttrContext&gt; env: envs) {
1672                 Queue&lt;Env&lt;AttrContext&gt;&gt; sublist = map.get(env.toplevel);
1673                 if (sublist == null) {
1674                     sublist = new ListBuffer&lt;&gt;();
1675                     map.put(env.toplevel, sublist);
1676                 }
1677                 sublist.add(env);
1678             }
1679             return map;
1680         }
1681 
1682         JCClassDecl removeMethodBodies(JCClassDecl cdef) {
1683             final boolean isInterface = (cdef.mods.flags &amp; Flags.INTERFACE) != 0;
1684             class MethodBodyRemover extends TreeTranslator {
1685                 @Override
1686                 public void visitMethodDef(JCMethodDecl tree) {
1687                     tree.mods.flags &amp;= ~Flags.SYNCHRONIZED;
1688                     for (JCVariableDecl vd : tree.params)
1689                         vd.mods.flags &amp;= ~Flags.FINAL;
1690                     tree.body = null;
1691                     super.visitMethodDef(tree);
1692                 }
1693                 @Override
1694                 public void visitVarDef(JCVariableDecl tree) {
1695                     if (tree.init != null &amp;&amp; tree.init.type.constValue() == null)
1696                         tree.init = null;
1697                     super.visitVarDef(tree);
1698                 }
1699                 @Override
1700                 public void visitClassDef(JCClassDecl tree) {
1701                     ListBuffer&lt;JCTree&gt; newdefs = new ListBuffer&lt;&gt;();
1702                     for (List&lt;JCTree&gt; it = tree.defs; it.tail != null; it = it.tail) {
1703                         JCTree t = it.head;
1704                         switch (t.getTag()) {
1705                         case CLASSDEF:
1706                             if (isInterface ||
1707                                 (((JCClassDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1708                                 (((JCClassDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCClassDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1709                                 newdefs.append(t);
1710                             break;
1711                         case METHODDEF:
1712                             if (isInterface ||
1713                                 (((JCMethodDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1714                                 ((JCMethodDecl) t).sym.name == names.init ||
1715                                 (((JCMethodDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCMethodDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1716                                 newdefs.append(t);
1717                             break;
1718                         case VARDEF:
1719                             if (isInterface || (((JCVariableDecl) t).mods.flags &amp; (Flags.PROTECTED|Flags.PUBLIC)) != 0 ||
1720                                 (((JCVariableDecl) t).mods.flags &amp; (Flags.PRIVATE)) == 0 &amp;&amp; ((JCVariableDecl) t).sym.packge().getQualifiedName() == names.java_lang)
1721                                 newdefs.append(t);
1722                             break;
1723                         default:
1724                             break;
1725                         }
1726                     }
1727                     tree.defs = newdefs.toList();
1728                     super.visitClassDef(tree);
1729                 }
1730             }
1731             MethodBodyRemover r = new MethodBodyRemover();
1732             return r.translate(cdef);
1733         }
1734 
1735     public void reportDeferredDiagnostics() {
1736         if (errorCount() == 0
1737                 &amp;&amp; annotationProcessingOccurred
1738                 &amp;&amp; implicitSourceFilesRead
1739                 &amp;&amp; implicitSourcePolicy == ImplicitSourcePolicy.UNSET) {
1740             if (explicitAnnotationProcessingRequested())
1741                 log.warning(Warnings.ProcUseImplicit);
1742             else
1743                 log.warning(Warnings.ProcUseProcOrImplicit);
1744         }
1745         chk.reportDeferredDiagnostics();
1746         preview.reportDeferredDiagnostics();
1747         if (log.compressedOutput) {
1748             log.mandatoryNote(null, Notes.CompressedDiags);
1749         }
1750     }
1751 
1752     public void enterDone() {
1753         enterDone = true;
1754         annotate.enterDone();
1755     }
1756 
1757     public boolean isEnterDone() {
1758         return enterDone;
1759     }
1760 
1761     private Name readModuleName(JavaFileObject fo) {
1762         return parseAndGetName(fo, t -&gt; {
1763             JCModuleDecl md = t.getModuleDecl();
1764 
1765             return md != null ? TreeInfo.fullName(md.getName()) : null;
1766         });
1767     }
1768 
1769     private Name findPackageInFile(JavaFileObject fo) {
1770         return parseAndGetName(fo, t -&gt; t.getPackage() != null ?
1771                                         TreeInfo.fullName(t.getPackage().getPackageName()) : null);
1772     }
1773 
1774     private Name parseAndGetName(JavaFileObject fo,
1775                                  Function&lt;JCTree.JCCompilationUnit, Name&gt; tree2Name) {
1776         DiagnosticHandler dh = new DiscardDiagnosticHandler(log);
1777         JavaFileObject prevSource = log.useSource(fo);
1778         try {
1779             JCTree.JCCompilationUnit t = parse(fo, fo.getCharContent(false));
1780             return tree2Name.apply(t);
1781         } catch (IOException e) {
1782             return null;
1783         } finally {
1784             log.popDiagnosticHandler(dh);
1785             log.useSource(prevSource);
1786         }
1787     }
1788 
1789     /** Close the compiler, flushing the logs
1790      */
1791     public void close() {
1792         rootClasses = null;
1793         finder = null;
1794         reader = null;
1795         make = null;
1796         writer = null;
1797         enter = null;
1798         if (todo != null)
1799             todo.clear();
1800         todo = null;
1801         parserFactory = null;
1802         syms = null;
1803         source = null;
1804         attr = null;
1805         chk = null;
1806         gen = null;
1807         flow = null;
1808         transTypes = null;
1809         lower = null;
1810         annotate = null;
1811         types = null;
1812 
1813         log.flush();
1814         try {
1815             fileManager.flush();
1816         } catch (IOException e) {
1817             throw new Abort(e);
1818         } finally {
1819             if (names != null)
1820                 names.dispose();
1821             names = null;
1822 
1823             for (Closeable c: closeables) {
1824                 try {
1825                     c.close();
1826                 } catch (IOException e) {
1827                     // When javac uses JDK 7 as a baseline, this code would be
1828                     // better written to set any/all exceptions from all the
1829                     // Closeables as suppressed exceptions on the FatalError
1830                     // that is thrown.
1831                     JCDiagnostic msg = diagFactory.fragment(Fragments.FatalErrCantClose);
1832                     throw new FatalError(msg, e);
1833                 }
1834             }
1835             closeables = List.nil();
1836         }
1837     }
1838 
1839     protected void printNote(String lines) {
1840         log.printRawLines(Log.WriterKind.NOTICE, lines);
1841     }
1842 
1843     /** Print numbers of errors and warnings.
1844      */
1845     public void printCount(String kind, int count) {
1846         if (count != 0) {
1847             String key;
1848             if (count == 1)
1849                 key = &quot;count.&quot; + kind;
1850             else
1851                 key = &quot;count.&quot; + kind + &quot;.plural&quot;;
1852             log.printLines(WriterKind.ERROR, key, String.valueOf(count));
1853             log.flush(Log.WriterKind.ERROR);
1854         }
1855     }
1856 
1857     private void printSuppressedCount(int shown, int suppressed, String diagKey) {
1858         if (suppressed &gt; 0) {
1859             int total = shown + suppressed;
1860             log.printLines(WriterKind.ERROR, diagKey,
1861                     String.valueOf(shown), String.valueOf(total));
1862             log.flush(Log.WriterKind.ERROR);
1863         }
1864     }
1865 
1866     private static long now() {
1867         return System.currentTimeMillis();
1868     }
1869 
1870     private static long elapsed(long then) {
1871         return now() - then;
1872     }
1873 
1874     public void newRound() {
1875         inputFiles.clear();
1876         todo.clear();
1877     }
1878 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
<a name="1" id="anc1"></a><span class="line-added"> 236      *     mode |= NOINVOCATION : method invocations are not allowed</span>
 237      */
 238     protected static final int EXPR = 0x1;
 239     protected static final int TYPE = 0x2;
 240     protected static final int NOPARAMS = 0x4;
 241     protected static final int TYPEARG = 0x8;
 242     protected static final int DIAMOND = 0x10;
 243     protected static final int NOLAMBDA = 0x20;
<a name="2" id="anc2"></a><span class="line-modified"> 244     protected static final int NOINVOCATION = 0x40;</span>
 245 
 246     protected void selectExprMode() {
<a name="3" id="anc3"></a><span class="line-modified"> 247         mode = (mode &amp; (NOLAMBDA | NOINVOCATION)) | EXPR;</span>

 248     }
 249 
 250     protected void selectTypeMode() {
<a name="4" id="anc4"></a><span class="line-modified"> 251         mode = (mode &amp; (NOLAMBDA|NOINVOCATION)) | TYPE;</span>

 252     }
 253 
 254     /** The current mode.
 255      */
 256     protected int mode = 0;
 257 
 258     /** The mode of the term that was parsed last.
 259      */
 260     protected int lastmode = 0;
 261 
 262     /* ---------- token management -------------- */
 263 
 264     protected Token token;
 265 
 266     public Token token() {
 267         return token;
 268     }
 269 
 270     public void nextToken() {
 271         S.nextToken();
 272         token = S.token();
 273     }
 274 
 275     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 276         return peekToken(0, tk);
 277     }
 278 
 279     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 280         return tk.accepts(S.token(lookahead + 1).kind);
 281     }
 282 
 283     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 284         return peekToken(0, tk1, tk2);
 285     }
 286 
 287     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 288         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 289                 tk2.accepts(S.token(lookahead + 2).kind);
 290     }
 291 
 292     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 293         return peekToken(0, tk1, tk2, tk3);
 294     }
 295 
 296     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 297         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 298                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 299                 tk3.accepts(S.token(lookahead + 3).kind);
 300     }
 301 
 302     @SuppressWarnings(&quot;unchecked&quot;)
 303     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 304         return peekToken(0, kinds);
 305     }
 306 
 307     @SuppressWarnings(&quot;unchecked&quot;)
 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 309         for (; lookahead &lt; kinds.length ; lookahead++) {
 310             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 311                 return false;
 312             }
 313         }
 314         return true;
 315     }
 316 
 317     /* ---------- error recovery -------------- */
 318 
 319     private JCErroneous errorTree;
 320 
 321     /** Skip forward until a suitable stop token is found.
 322      */
 323     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 324          while (true) {
 325              switch (token.kind) {
 326                 case SEMI:
 327                     nextToken();
 328                     return;
 329                 case PUBLIC:
 330                 case FINAL:
 331                 case ABSTRACT:
 332                 case MONKEYS_AT:
 333                 case EOF:
 334                 case CLASS:
 335                 case INTERFACE:
 336                 case ENUM:
 337                     return;
 338                 case IMPORT:
 339                     if (stopAtImport)
 340                         return;
 341                     break;
 342                 case LBRACE:
 343                 case RBRACE:
 344                 case PRIVATE:
 345                 case PROTECTED:
 346                 case STATIC:
 347                 case TRANSIENT:
 348                 case NATIVE:
 349                 case VOLATILE:
 350                 case SYNCHRONIZED:
 351                 case STRICTFP:
 352                 case LT:
 353                 case BYTE:
 354                 case SHORT:
 355                 case CHAR:
 356                 case INT:
 357                 case LONG:
 358                 case FLOAT:
 359                 case DOUBLE:
 360                 case BOOLEAN:
 361                 case VOID:
 362                     if (stopAtMemberDecl)
 363                         return;
 364                     break;
 365                 case UNDERSCORE:
 366                 case IDENTIFIER:
 367                    if (stopAtIdentifier)
 368                         return;
 369                     break;
 370                 case CASE:
 371                 case DEFAULT:
 372                 case IF:
 373                 case FOR:
 374                 case WHILE:
 375                 case DO:
 376                 case TRY:
 377                 case SWITCH:
 378                 case RETURN:
 379                 case THROW:
 380                 case BREAK:
 381                 case CONTINUE:
 382                 case ELSE:
 383                 case FINALLY:
 384                 case CATCH:
 385                 case THIS:
 386                 case SUPER:
 387                 case NEW:
 388                     if (stopAtStatement)
 389                         return;
 390                     break;
 391                 case ASSERT:
 392                     if (stopAtStatement)
 393                         return;
 394                     break;
 395             }
 396             nextToken();
 397         }
 398     }
 399 
 400     protected JCErroneous syntaxError(int pos, Error errorKey) {
 401         return syntaxError(pos, List.nil(), errorKey);
 402     }
 403 
 404     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 405         setErrorEndPos(pos);
 406         JCErroneous err = F.at(pos).Erroneous(errs);
 407         reportSyntaxError(err, errorKey);
 408         if (errs != null) {
 409             JCTree last = errs.last();
 410             if (last != null)
 411                 storeEnd(last, pos);
 412         }
 413         return toP(err);
 414     }
 415 
 416     private static final int RECOVERY_THRESHOLD = 50;
 417     private int errorPos = Position.NOPOS;
 418     private int count = 0;
 419 
 420     /**
 421      * Report a syntax using the given the position parameter and arguments,
 422      * unless one was already reported at the same position.
 423      */
 424     protected void reportSyntaxError(int pos, Error errorKey) {
 425         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 426         reportSyntaxError(diag, errorKey);
 427     }
 428 
 429     /**
 430      * Report a syntax error using the given DiagnosticPosition object and
 431      * arguments, unless one was already reported at the same position.
 432      */
 433     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 434         int pos = diagPos.getPreferredPosition();
 435         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 436             if (token.kind == EOF) {
 437                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 438             } else {
 439                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 440             }
 441         }
 442         S.errPos(pos);
 443         if (token.pos == errorPos) {
 444             //check for a possible infinite loop in parsing:
 445             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 446         } else {
 447             count = 0;
 448             errorPos = token.pos;
 449         }
 450     }
 451 
 452     /** If next input token matches given token, skip it, otherwise report
 453      *  an error.
 454      */
 455     public void accept(TokenKind tk) {
 456         accept(tk, Errors::Expected);
 457     }
 458 
 459     /** If next input token matches given token, skip it, otherwise report
 460      *  an error.
 461      */
 462     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 463         if (token.kind == tk) {
 464             nextToken();
 465         } else {
 466             setErrorEndPos(token.pos);
 467             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 468         }
 469     }
 470 
 471     /** Report an illegal start of expression/type error at given position.
 472      */
 473     JCExpression illegal(int pos) {
 474         setErrorEndPos(pos);
 475         if ((mode &amp; EXPR) != 0)
 476             return syntaxError(pos, Errors.IllegalStartOfExpr);
 477         else
 478             return syntaxError(pos, Errors.IllegalStartOfType);
 479 
 480     }
 481 
 482     /** Report an illegal start of expression/type error at current position.
 483      */
 484     JCExpression illegal() {
 485         return illegal(token.pos);
 486     }
 487 
 488     /** Diagnose a modifier flag from the set, if any. */
 489     protected void checkNoMods(long mods) {
 490         if (mods != 0) {
 491             long lowestMod = mods &amp; -mods;
 492             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 493         }
 494     }
 495 
 496 /* ---------- doc comments --------- */
 497 
 498     /** A table to store all documentation comments
 499      *  indexed by the tree nodes they refer to.
 500      *  defined only if option flag keepDocComment is set.
 501      */
 502     private final DocCommentTable docComments;
 503 
 504     /** Make an entry into docComments hashtable,
 505      *  provided flag keepDocComments is set and given doc comment is non-null.
 506      *  @param tree   The tree to be used as index in the hashtable
 507      *  @param dc     The doc comment to associate with the tree, or null.
 508      */
 509     protected void attach(JCTree tree, Comment dc) {
 510         if (keepDocComments &amp;&amp; dc != null) {
 511 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 512             docComments.putComment(tree, dc);
 513         }
 514     }
 515 
 516 /* -------- source positions ------- */
 517 
 518     protected void setErrorEndPos(int errPos) {
 519         endPosTable.setErrorEndPos(errPos);
 520     }
 521 
 522     protected void storeEnd(JCTree tree, int endpos) {
 523         endPosTable.storeEnd(tree, endpos);
 524     }
 525 
 526     protected &lt;T extends JCTree&gt; T to(T t) {
 527         return endPosTable.to(t);
 528     }
 529 
 530     protected &lt;T extends JCTree&gt; T toP(T t) {
 531         return endPosTable.toP(t);
 532     }
 533 
 534     /** Get the start position for a tree node.  The start position is
 535      * defined to be the position of the first character of the first
 536      * token of the node&#39;s source text.
 537      * @param tree  The tree node
 538      */
 539     public int getStartPos(JCTree tree) {
 540         return TreeInfo.getStartPos(tree);
 541     }
 542 
 543     /**
 544      * Get the end position for a tree node.  The end position is
 545      * defined to be the position of the last character of the last
 546      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 547      * positions are not generated or the position is otherwise not
 548      * found.
 549      * @param tree  The tree node
 550      */
 551     public int getEndPos(JCTree tree) {
 552         return endPosTable.getEndPos(tree);
 553     }
 554 
 555 
 556 
 557 /* ---------- parsing -------------- */
 558 
 559     /**
 560      * Ident = IDENTIFIER
 561      */
 562     public Name ident() {
 563         return ident(false);
 564     }
 565 
 566     protected Name ident(boolean advanceOnErrors) {
 567         if (token.kind == IDENTIFIER) {
 568             Name name = token.name();
 569             nextToken();
 570             return name;
 571         } else if (token.kind == ASSERT) {
 572             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 573             nextToken();
 574             return names.error;
 575         } else if (token.kind == ENUM) {
 576             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 577             nextToken();
 578             return names.error;
 579         } else if (token.kind == THIS) {
 580             if (allowThisIdent) {
 581                 // Make sure we&#39;re using a supported source version.
 582                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 583                 Name name = token.name();
 584                 nextToken();
 585                 return name;
 586             } else {
 587                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 588                 nextToken();
 589                 return names.error;
 590             }
 591         } else if (token.kind == UNDERSCORE) {
 592             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 593                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 594             } else {
 595                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 596             }
 597             Name name = token.name();
 598             nextToken();
 599             return name;
 600         } else {
 601             accept(IDENTIFIER);
 602             if (advanceOnErrors) {
 603                 nextToken();
 604             }
 605             return names.error;
 606         }
 607     }
 608 
 609     /**
 610      * Qualident = Ident { DOT [Annotations] Ident }
 611      */
 612     public JCExpression qualident(boolean allowAnnos) {
 613         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 614         while (token.kind == DOT) {
 615             int pos = token.pos;
 616             nextToken();
 617             List&lt;JCAnnotation&gt; tyannos = null;
 618             if (allowAnnos) {
 619                 tyannos = typeAnnotationsOpt();
 620             }
 621             t = toP(F.at(pos).Select(t, ident()));
 622             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 623                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 624             }
 625         }
 626         return t;
 627     }
 628 
 629     JCExpression literal(Name prefix) {
 630         return literal(prefix, token.pos);
 631     }
 632 
 633     /**
 634      * Literal =
 635      *     INTLITERAL
 636      *   | LONGLITERAL
 637      *   | FLOATLITERAL
 638      *   | DOUBLELITERAL
 639      *   | CHARLITERAL
 640      *   | STRINGLITERAL
 641      *   | TRUE
 642      *   | FALSE
 643      *   | NULL
 644      */
 645     JCExpression literal(Name prefix, int pos) {
 646         JCExpression t = errorTree;
 647         switch (token.kind) {
 648         case INTLITERAL:
 649             try {
 650                 t = F.at(pos).Literal(
 651                     TypeTag.INT,
 652                     Convert.string2int(strval(prefix), token.radix()));
 653             } catch (NumberFormatException ex) {
 654                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 655             }
 656             break;
 657         case LONGLITERAL:
 658             try {
 659                 t = F.at(pos).Literal(
 660                     TypeTag.LONG,
 661                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 662             } catch (NumberFormatException ex) {
 663                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 664             }
 665             break;
 666         case FLOATLITERAL: {
 667             String proper = token.radix() == 16 ?
 668                     (&quot;0x&quot;+ token.stringVal()) :
 669                     token.stringVal();
 670             Float n;
 671             try {
 672                 n = Float.valueOf(proper);
 673             } catch (NumberFormatException ex) {
 674                 // error already reported in scanner
 675                 n = Float.NaN;
 676             }
 677             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 678                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 679             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 680                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 681             else
 682                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 683             break;
 684         }
 685         case DOUBLELITERAL: {
 686             String proper = token.radix() == 16 ?
 687                     (&quot;0x&quot;+ token.stringVal()) :
 688                     token.stringVal();
 689             Double n;
 690             try {
 691                 n = Double.valueOf(proper);
 692             } catch (NumberFormatException ex) {
 693                 // error already reported in scanner
 694                 n = Double.NaN;
 695             }
 696             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 697                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 698             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 699                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 700             else
 701                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 702             break;
 703         }
 704         case CHARLITERAL:
 705             t = F.at(pos).Literal(
 706                 TypeTag.CHAR,
 707                 token.stringVal().charAt(0) + 0);
 708             break;
 709         case STRINGLITERAL:
 710             t = F.at(pos).Literal(
 711                 TypeTag.CLASS,
 712                 token.stringVal());
 713             break;
 714         case TRUE: case FALSE:
 715             t = F.at(pos).Literal(
 716                 TypeTag.BOOLEAN,
 717                 (token.kind == TRUE ? 1 : 0));
 718             break;
 719         case NULL:
 720             t = F.at(pos).Literal(
 721                 TypeTag.BOT,
 722                 null);
 723             break;
 724         default:
 725             Assert.error();
 726         }
 727         if (t == errorTree)
 728             t = F.at(pos).Erroneous();
 729         storeEnd(t, token.endPos);
 730         nextToken();
 731         return t;
 732     }
 733     //where
 734         boolean isZero(String s) {
 735             char[] cs = s.toCharArray();
 736             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 737             int i = ((base==16) ? 2 : 0);
 738             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 739             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 740         }
 741 
 742         String strval(Name prefix) {
 743             String s = token.stringVal();
 744             return prefix.isEmpty() ? s : prefix + s;
 745         }
 746 
 747     /** terms can be either expressions or types.
 748      */
 749     public JCExpression parseExpression() {
 750         return term(EXPR);
 751     }
 752 
 753     /** parses patterns.
 754      */
 755 
 756     public JCPattern parsePattern() {
 757         int pos = token.pos;
 758         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 759             nextToken();
 760             return toP(F.at(pos).BindingPattern(ident(), null));
 761         } else {
 762             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 763             if (token.kind == LPAREN) {
 764                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 765                 do {
 766                     nextToken();
 767                     JCPattern nestedPattern = parsePattern();
<a name="5" id="anc5"></a>


 768                     nested.append(nestedPattern);
 769                 } while (token.kind == COMMA);
<a name="6" id="anc6"></a>



 770                 accept(RPAREN);
<a name="7" id="anc7"></a><span class="line-modified"> 771                 return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));</span>
 772             } else {
 773                 return toP(F.at(pos).BindingPattern(ident(), e));
 774             }
 775         }
 776     }
 777 
 778     /**
 779      * parses (optional) type annotations followed by a type. If the
 780      * annotations are present before the type and are not consumed during array
 781      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 782      * these annotations and the underlying type. Otherwise, it returns the
 783      * underlying type.
 784      *
 785      * &lt;p&gt;
 786      *
 787      * Note that this method sets {@code mode} to {@code TYPE} first, before
 788      * parsing annotations.
 789      */
 790     public JCExpression parseType() {
 791         return parseType(false);
 792     }
 793 
 794     public JCExpression parseType(boolean allowVar) {
 795         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 796         return parseType(allowVar, annotations);
 797     }
 798 
 799     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 800         JCExpression result = unannotatedType(allowVar);
 801 
 802         if (annotations.nonEmpty()) {
 803             result = insertAnnotationsToMostInner(result, annotations, false);
 804         }
 805 
 806         return result;
 807     }
 808 
 809     public JCExpression unannotatedType(boolean allowVar) {
 810         JCExpression result = term(TYPE);
 811         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 812 
 813         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 814             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 815         }
 816 
 817         return result;
 818     }
 819 
 820 
 821 
 822     protected JCExpression term(int newmode) {
 823         int prevmode = mode;
 824         mode = newmode;
 825         JCExpression t = term();
 826         lastmode = mode;
 827         mode = prevmode;
 828         return t;
 829     }
 830 
 831     /**
 832      *  {@literal
 833      *  Expression = Expression1 [ExpressionRest]
 834      *  ExpressionRest = [AssignmentOperator Expression1]
 835      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 836      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 837      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 838      *  Type = Type1
 839      *  TypeNoParams = TypeNoParams1
 840      *  StatementExpression = Expression
 841      *  ConstantExpression = Expression
 842      *  }
 843      */
 844     JCExpression term() {
 845         JCExpression t = term1();
 846         if ((mode &amp; EXPR) != 0 &amp;&amp;
 847             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 848             return termRest(t);
 849         else
 850             return t;
 851     }
 852 
 853     JCExpression termRest(JCExpression t) {
 854         switch (token.kind) {
 855         case EQ: {
 856             int pos = token.pos;
 857             nextToken();
 858             selectExprMode();
 859             JCExpression t1 = term();
 860             return toP(F.at(pos).Assign(t, t1));
 861         }
 862         case PLUSEQ:
 863         case SUBEQ:
 864         case STAREQ:
 865         case SLASHEQ:
 866         case PERCENTEQ:
 867         case AMPEQ:
 868         case BAREQ:
 869         case CARETEQ:
 870         case LTLTEQ:
 871         case GTGTEQ:
 872         case GTGTGTEQ:
 873             int pos = token.pos;
 874             TokenKind tk = token.kind;
 875             nextToken();
 876             selectExprMode();
 877             JCExpression t1 = term();
 878             return F.at(pos).Assignop(optag(tk), t, t1);
 879         default:
 880             return t;
 881         }
 882     }
 883 
 884     /** Expression1   = Expression2 [Expression1Rest]
 885      *  Type1         = Type2
 886      *  TypeNoParams1 = TypeNoParams2
 887      */
 888     JCExpression term1() {
 889         JCExpression t = term2();
 890         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 891             selectExprMode();
 892             return term1Rest(t);
 893         } else {
 894             return t;
 895         }
 896     }
 897 
 898     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 899      */
 900     JCExpression term1Rest(JCExpression t) {
 901         if (token.kind == QUES) {
 902             int pos = token.pos;
 903             nextToken();
 904             JCExpression t1 = term();
 905             accept(COLON);
 906             JCExpression t2 = term1();
 907             return F.at(pos).Conditional(t, t1, t2);
 908         } else {
 909             return t;
 910         }
 911     }
 912 
 913     /** Expression2   = Expression3 [Expression2Rest]
 914      *  Type2         = Type3
 915      *  TypeNoParams2 = TypeNoParams3
 916      */
 917     JCExpression term2() {
 918         JCExpression t = term3();
 919         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 920             selectExprMode();
 921             return term2Rest(t, TreeInfo.orPrec);
 922         } else {
 923             return t;
 924         }
 925     }
 926 
 927     /*  Expression2Rest = {infixop Expression3}
 928      *                  | Expression3 instanceof Type
 929      *                  | Expression3 instanceof Pattern
 930      *  infixop         = &quot;||&quot;
 931      *                  | &quot;&amp;&amp;&quot;
 932      *                  | &quot;|&quot;
 933      *                  | &quot;^&quot;
 934      *                  | &quot;&amp;&quot;
 935      *                  | &quot;==&quot; | &quot;!=&quot;
 936      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 937      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 938      *                  | &quot;+&quot; | &quot;-&quot;
 939      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 940      */
 941     JCExpression term2Rest(JCExpression t, int minprec) {
 942         JCExpression[] odStack = newOdStack();
 943         Token[] opStack = newOpStack();
 944 
 945         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 946         int top = 0;
 947         odStack[0] = t;
 948         int startPos = token.pos;
 949         Token topOp = Tokens.DUMMY;
 950         while (prec(token.kind) &gt;= minprec) {
 951             opStack[top] = topOp;
 952 
 953             if (token.kind == INSTANCEOF) {
 954                 int pos = token.pos;
 955                 nextToken();
 956                 JCTree pattern = parseType();
 957                 if (token.kind == IDENTIFIER) {
 958                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 959                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 960                 } else if (token.kind == LPAREN) {
<a name="8" id="anc8"></a><span class="line-added"> 961                     checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);</span>
 962                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 963                     do {
 964                         nextToken();
 965                         JCPattern nestedPattern = parsePattern();
<a name="9" id="anc9"></a>


 966                         nested.append(nestedPattern);
 967                     } while (token.kind == COMMA);
<a name="10" id="anc10"></a>



 968                     accept(RPAREN);
<a name="11" id="anc11"></a><span class="line-modified"> 969                     pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));</span>
 970                 }
 971                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 972             } else {
 973                 topOp = token;
 974                 nextToken();
 975                 top++;
 976                 odStack[top] = term3();
 977             }
 978             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 979                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 980                 top--;
 981                 topOp = opStack[top];
 982             }
 983         }
 984         Assert.check(top == 0);
 985         t = odStack[0];
 986 
 987         if (t.hasTag(JCTree.Tag.PLUS)) {
 988             t = foldStrings(t);
 989         }
 990 
 991         odStackSupply.add(odStack);
 992         opStackSupply.add(opStack);
 993         return t;
 994     }
 995     //where
 996         /** If tree is a concatenation of string literals, replace it
 997          *  by a single literal representing the concatenated string.
 998          */
 999         protected JCExpression foldStrings(JCExpression tree) {
1000             if (!allowStringFolding)
1001                 return tree;
1002             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
1003             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
1004             boolean needsFolding = false;
1005             JCExpression curr = tree;
1006             while (true) {
1007                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1008                     JCBinary op = (JCBinary)curr;
1009                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1010                     curr = op.lhs;
1011                 } else {
1012                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1013                     break; //last one!
1014                 }
1015             }
1016             if (needsFolding) {
1017                 List&lt;JCExpression&gt; ops = opStack.toList();
1018                 JCExpression res = ops.head;
1019                 for (JCExpression op : ops.tail) {
1020                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1021                     storeEnd(res, getEndPos(op));
1022                 }
1023                 return res;
1024             } else {
1025                 return tree;
1026             }
1027         }
1028 
1029         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1030                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1031             JCLiteral str = stringLiteral(tree);
1032             if (str != null) {
1033                 litBuf.prepend(str);
1034                 return last &amp;&amp; merge(litBuf, opStack);
1035             } else {
1036                 boolean res = merge(litBuf, opStack);
1037                 litBuf.clear();
1038                 opStack.prepend(tree);
1039                 return res;
1040             }
1041         }
1042 
1043         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1044             if (litBuf.isEmpty()) {
1045                 return false;
1046             } else if (litBuf.size() == 1) {
1047                 opStack.prepend(litBuf.first());
1048                 return false;
1049             } else {
1050                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1051                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1052                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1053                 opStack.prepend(t);
1054                 return true;
1055             }
1056         }
1057 
1058         private JCLiteral stringLiteral(JCTree tree) {
1059             if (tree.hasTag(LITERAL)) {
1060                 JCLiteral lit = (JCLiteral)tree;
1061                 if (lit.typetag == TypeTag.CLASS) {
1062                     return lit;
1063                 }
1064             }
1065             return null;
1066         }
1067 
1068 
1069         /** optimization: To save allocating a new operand/operator stack
1070          *  for every binary operation, we use supplys.
1071          */
1072         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1073         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1074 
1075         private JCExpression[] newOdStack() {
1076             if (odStackSupply.isEmpty())
1077                 return new JCExpression[infixPrecedenceLevels + 1];
1078             return odStackSupply.remove(odStackSupply.size() - 1);
1079         }
1080 
1081         private Token[] newOpStack() {
1082             if (opStackSupply.isEmpty())
1083                 return new Token[infixPrecedenceLevels + 1];
1084             return opStackSupply.remove(opStackSupply.size() - 1);
1085         }
1086 
1087     /**
1088      *  Expression3    = PrefixOp Expression3
1089      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1090      *                 | Primary {Selector} {PostfixOp}
1091      *
1092      *  {@literal
1093      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1094      *                 | Literal
1095      *                 | [TypeArguments] THIS [Arguments]
1096      *                 | [TypeArguments] SUPER SuperSuffix
1097      *                 | NEW [TypeArguments] Creator
1098      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1099      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1100      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1101      *                 | Expression3 MemberReferenceSuffix
1102      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1103      *                   | Arguments
1104      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1105      *                   ]
1106      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1107      *  }
1108      *
1109      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1110      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1111      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1112      *                 | BasicType
1113      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1114      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1115      *                 | &quot;.&quot; THIS
1116      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1117      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1118      *                 | &quot;[&quot; Expression &quot;]&quot;
1119      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1120      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1121      */
1122     protected JCExpression term3() {
1123         int pos = token.pos;
1124         JCExpression t;
1125         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1126         switch (token.kind) {
1127         case QUES:
1128             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1129                 selectTypeMode();
1130                 return typeArgument();
1131             } else
1132                 return illegal();
1133         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1134             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1135                 TokenKind tk = token.kind;
1136                 nextToken();
1137                 selectExprMode();
1138                 if (tk == SUB &amp;&amp;
1139                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1140                     token.radix() == 10) {
1141                     selectExprMode();
1142                     t = literal(names.hyphen, pos);
1143                 } else {
1144                     t = term3();
1145                     return F.at(pos).Unary(unoptag(tk), t);
1146                 }
1147             } else return illegal();
1148             break;
1149         case LPAREN:
1150             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1151                 ParensResult pres = analyzeParens();
1152                 switch (pres) {
1153                     case CAST:
1154                        accept(LPAREN);
1155                        selectTypeMode();
1156                        int pos1 = pos;
1157                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1158                        while (token.kind == AMP) {
1159                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1160                            accept(AMP);
1161                            targets = targets.prepend(parseType());
1162                        }
1163                        if (targets.length() &gt; 1) {
1164                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1165                        }
1166                        accept(RPAREN);
1167                        selectExprMode();
1168                        JCExpression t1 = term3();
1169                        return F.at(pos).TypeCast(t, t1);
1170                     case IMPLICIT_LAMBDA:
1171                     case EXPLICIT_LAMBDA:
1172                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1173                         break;
1174                     default: //PARENS
1175                         accept(LPAREN);
1176                         selectExprMode();
1177                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1178                         accept(RPAREN);
1179                         t = toP(F.at(pos).Parens(t));
1180                         break;
1181                 }
1182             } else {
1183                 return illegal();
1184             }
1185             break;
1186         case THIS:
1187             if ((mode &amp; EXPR) != 0) {
1188                 selectExprMode();
1189                 t = to(F.at(pos).Ident(names._this));
1190                 nextToken();
1191                 if (typeArgs == null)
1192                     t = argumentsOpt(null, t);
1193                 else
1194                     t = arguments(typeArgs, t);
1195                 typeArgs = null;
1196             } else return illegal();
1197             break;
1198         case SUPER:
1199             if ((mode &amp; EXPR) != 0) {
1200                 selectExprMode();
1201                 t = to(F.at(pos).Ident(names._super));
1202                 t = superSuffix(typeArgs, t);
1203                 typeArgs = null;
1204             } else return illegal();
1205             break;
1206         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1207         case CHARLITERAL: case STRINGLITERAL:
1208         case TRUE: case FALSE: case NULL:
1209             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1210                 selectExprMode();
1211                 t = literal(names.empty);
1212             } else return illegal();
1213             break;
1214         case NEW:
1215             if (typeArgs != null) return illegal();
1216             if ((mode &amp; EXPR) != 0) {
1217                 selectExprMode();
1218                 nextToken();
1219                 if (token.kind == LT) typeArgs = typeArguments(false);
1220                 t = creator(pos, typeArgs);
1221                 typeArgs = null;
1222             } else return illegal();
1223             break;
1224         case MONKEYS_AT:
1225             // Only annotated cast types and method references are valid
1226             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1227             if (typeAnnos.isEmpty()) {
1228                 // else there would be no &#39;@&#39;
1229                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1230             }
1231 
1232             JCExpression expr = term3();
1233 
1234             if ((mode &amp; TYPE) == 0) {
1235                 // Type annotations on class literals no longer legal
1236                 switch (expr.getTag()) {
1237                 case REFERENCE: {
1238                     JCMemberReference mref = (JCMemberReference) expr;
1239                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1240                     t = mref;
1241                     break;
1242                 }
1243                 case SELECT: {
1244                     JCFieldAccess sel = (JCFieldAccess) expr;
1245 
1246                     if (sel.name != names._class) {
1247                         return illegal();
1248                     } else {
1249                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1250                         return expr;
1251                     }
1252                 }
1253                 default:
1254                     return illegal(typeAnnos.head.pos);
1255                 }
1256 
1257             } else {
1258                 // Type annotations targeting a cast
1259                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1260             }
1261             break;
1262         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1263             if (typeArgs != null) return illegal();
1264             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1265                 t = lambdaExpressionOrStatement(false, false, pos);
1266             } else {
1267                 t = toP(F.at(token.pos).Ident(ident()));
1268                 loop: while (true) {
1269                     pos = token.pos;
1270                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1271 
1272                     // need to report an error later if LBRACKET is for array
1273                     // index access rather than array creation level
1274                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1275                         return illegal(annos.head.pos);
1276 
1277                     switch (token.kind) {
1278                     case LBRACKET:
1279                         nextToken();
1280                         if (token.kind == RBRACKET) {
1281                             nextToken();
1282                             t = bracketsOpt(t);
1283                             t = toP(F.at(pos).TypeArray(t));
1284                             if (annos.nonEmpty()) {
1285                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1286                             }
1287                             t = bracketsSuffix(t);
1288                         } else {
1289                             if ((mode &amp; EXPR) != 0) {
1290                                 selectExprMode();
1291                                 JCExpression t1 = term();
1292                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1293                                 t = to(F.at(pos).Indexed(t, t1));
1294                             }
1295                             accept(RBRACKET);
1296                         }
1297                         break loop;
1298                     case LPAREN:
1299                         if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOINVOCATION) == 0) {
1300                             selectExprMode();
1301                             t = arguments(typeArgs, t);
1302                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1303                             typeArgs = null;
1304                         }
1305                         break loop;
1306                     case DOT:
1307                         nextToken();
1308                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1309                             return illegal();
1310                         }
1311                         int oldmode = mode;
1312                         mode &amp;= ~NOPARAMS;
1313                         typeArgs = typeArgumentsOpt(EXPR);
1314                         mode = oldmode;
1315                         if ((mode &amp; EXPR) != 0) {
1316                             switch (token.kind) {
1317                             case CLASS:
1318                                 if (typeArgs != null) return illegal();
1319                                 selectExprMode();
1320                                 t = to(F.at(pos).Select(t, names._class));
1321                                 nextToken();
1322                                 break loop;
1323                             case THIS:
1324                                 if (typeArgs != null) return illegal();
1325                                 selectExprMode();
1326                                 t = to(F.at(pos).Select(t, names._this));
1327                                 nextToken();
1328                                 break loop;
1329                             case SUPER:
1330                                 selectExprMode();
1331                                 t = to(F.at(pos).Select(t, names._super));
1332                                 t = superSuffix(typeArgs, t);
1333                                 typeArgs = null;
1334                                 break loop;
1335                             case NEW:
1336                                 if (typeArgs != null) return illegal();
1337                                 selectExprMode();
1338                                 int pos1 = token.pos;
1339                                 nextToken();
1340                                 if (token.kind == LT) typeArgs = typeArguments(false);
1341                                 t = innerCreator(pos1, typeArgs, t);
1342                                 typeArgs = null;
1343                                 break loop;
1344                             }
1345                         }
1346 
1347                         List&lt;JCAnnotation&gt; tyannos = null;
1348                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1349                             tyannos = typeAnnotationsOpt();
1350                         }
1351                         // typeArgs saved for next loop iteration.
1352                         t = toP(F.at(pos).Select(t, ident()));
1353                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1354                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1355                         }
1356                         break;
1357                     case ELLIPSIS:
1358                         if (this.permitTypeAnnotationsPushBack) {
1359                             this.typeAnnotationsPushedBack = annos;
1360                         } else if (annos.nonEmpty()) {
1361                             // Don&#39;t return here -- error recovery attempt
1362                             illegal(annos.head.pos);
1363                         }
1364                         break loop;
1365                     case LT:
1366                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1367                             //this is an unbound method reference whose qualifier
1368                             //is a generic type i.e. A&lt;S&gt;::m
1369                             int pos1 = token.pos;
1370                             accept(LT);
1371                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1372                             args.append(typeArgument());
1373                             while (token.kind == COMMA) {
1374                                 nextToken();
1375                                 args.append(typeArgument());
1376                             }
1377                             accept(GT);
1378                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1379                             while (token.kind == DOT) {
1380                                 nextToken();
1381                                 selectTypeMode();
1382                                 t = toP(F.at(token.pos).Select(t, ident()));
1383                                 t = typeArgumentsOpt(t);
1384                             }
1385                             t = bracketsOpt(t);
1386                             if (token.kind != COLCOL) {
1387                                 //method reference expected here
1388                                 t = illegal();
1389                             }
1390                             selectExprMode();
1391                             return term3Rest(t, typeArgs);
1392                         }
1393                         break loop;
1394                     default:
1395                         break loop;
1396                     }
1397                 }
1398             }
1399             if (typeArgs != null) illegal();
1400             t = typeArgumentsOpt(t);
1401             break;
1402         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1403         case DOUBLE: case BOOLEAN:
1404             if (typeArgs != null) illegal();
1405             t = bracketsSuffix(bracketsOpt(basicType()));
1406             break;
1407         case VOID:
1408             if (typeArgs != null) illegal();
1409             if ((mode &amp; EXPR) != 0) {
1410                 nextToken();
1411                 if (token.kind == DOT) {
1412                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1413                     t = bracketsSuffix(ti);
1414                 } else {
1415                     return illegal(pos);
1416                 }
1417             } else {
1418                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1419                 // a void type (like other primitive types) to the next phase.
1420                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1421                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1422                 nextToken();
1423                 return ti;
1424                 //return illegal();
1425             }
1426             break;
1427         case SWITCH:
1428             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1429             allowYieldStatement = true;
1430             int switchPos = token.pos;
1431             nextToken();
1432             JCExpression selector = parExpression();
1433             accept(LBRACE);
1434             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1435             while (true) {
1436                 pos = token.pos;
1437                 switch (token.kind) {
1438                 case CASE:
1439                 case DEFAULT:
1440                     cases.appendList(switchExpressionStatementGroup());
1441                     break;
1442                 case RBRACE: case EOF:
1443                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1444                                                                                cases.toList()));
1445                     e.endpos = token.pos;
1446                     accept(RBRACE);
1447                     return e;
1448                 default:
1449                     nextToken(); // to ensure progress
1450                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1451                 }
1452             }
1453         default:
1454             return illegal();
1455         }
1456         return term3Rest(t, typeArgs);
1457     }
1458 
1459     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1460         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1461         int casePos = token.pos;
1462         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1463 
1464         if (token.kind == DEFAULT) {
1465             nextToken();
1466         } else {
1467             accept(CASE);
1468             while (true) {
1469                 pats.append(term(EXPR | NOLAMBDA));
1470                 if (token.kind != COMMA) break;
1471                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1472                 nextToken();
1473             };
1474         }
1475         List&lt;JCStatement&gt; stats = null;
1476         JCTree body = null;
1477         CaseTree.CaseKind kind;
1478         switch (token.kind) {
1479             case ARROW:
1480                 checkSourceLevel(Feature.SWITCH_RULE);
1481                 nextToken();
1482                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1483                     stats = List.of(parseStatement());
1484                     body = stats.head;
1485                     kind = JCCase.RULE;
1486                 } else {
1487                     JCExpression value = parseExpression();
1488                     stats = List.of(to(F.at(value).Yield(value)));
1489                     body = value;
1490                     kind = JCCase.RULE;
1491                     accept(SEMI);
1492                 }
1493                 break;
1494             default:
1495                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1496                 stats = blockStatements();
1497                 kind = JCCase.STATEMENT;
1498                 break;
1499         }
1500         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1501         return caseExprs.toList();
1502     }
1503 
1504     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1505         if (typeArgs != null) illegal();
1506         while (true) {
1507             int pos1 = token.pos;
1508             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1509 
1510             if (token.kind == LBRACKET) {
1511                 nextToken();
1512                 if ((mode &amp; TYPE) != 0) {
1513                     int oldmode = mode;
1514                     selectTypeMode();
1515                     if (token.kind == RBRACKET) {
1516                         nextToken();
1517                         t = bracketsOpt(t);
1518                         t = toP(F.at(pos1).TypeArray(t));
1519                         if (token.kind == COLCOL) {
1520                             selectExprMode();
1521                             continue;
1522                         }
1523                         if (annos.nonEmpty()) {
1524                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1525                         }
1526                         return t;
1527                     }
1528                     mode = oldmode;
1529                 }
1530                 if ((mode &amp; EXPR) != 0) {
1531                     selectExprMode();
1532                     JCExpression t1 = term();
1533                     t = to(F.at(pos1).Indexed(t, t1));
1534                 }
1535                 accept(RBRACKET);
1536             } else if (token.kind == DOT) {
1537                 nextToken();
1538                 typeArgs = typeArgumentsOpt(EXPR);
1539                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1540                     selectExprMode();
1541                     t = to(F.at(pos1).Select(t, names._super));
1542                     nextToken();
1543                     t = arguments(typeArgs, t);
1544                     typeArgs = null;
1545                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1546                     if (typeArgs != null) return illegal();
1547                     selectExprMode();
1548                     int pos2 = token.pos;
1549                     nextToken();
1550                     if (token.kind == LT) typeArgs = typeArguments(false);
1551                     t = innerCreator(pos2, typeArgs, t);
1552                     typeArgs = null;
1553                 } else {
1554                     List&lt;JCAnnotation&gt; tyannos = null;
1555                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1556                         // is the mode check needed?
1557                         tyannos = typeAnnotationsOpt();
1558                     }
1559                     t = toP(F.at(pos1).Select(t, ident(true)));
1560                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1561                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1562                     }
1563                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1564                     typeArgs = null;
1565                 }
1566             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1567                 selectExprMode();
1568                 if (typeArgs != null) return illegal();
1569                 accept(COLCOL);
1570                 t = memberReferenceSuffix(pos1, t);
1571             } else {
1572                 if (!annos.isEmpty()) {
1573                     if (permitTypeAnnotationsPushBack)
1574                         typeAnnotationsPushedBack = annos;
1575                     else
1576                         return illegal(annos.head.pos);
1577                 }
1578                 break;
1579             }
1580         }
1581         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1582             selectExprMode();
1583             t = to(F.at(token.pos).Unary(
1584                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1585             nextToken();
1586         }
1587         return toP(t);
1588     }
1589 
1590     /**
1591      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1592      * method reference or a binary expression. To disambiguate, look for a
1593      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1594      */
1595     @SuppressWarnings(&quot;fallthrough&quot;)
1596     boolean isUnboundMemberRef() {
1597         int pos = 0, depth = 0;
1598         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1599             switch (t.kind) {
1600                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1601                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1602                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1603                 case DOUBLE: case BOOLEAN: case CHAR:
1604                 case MONKEYS_AT:
1605                     break;
1606 
1607                 case LPAREN:
1608                     // skip annotation values
1609                     int nesting = 0;
1610                     for (; ; pos++) {
1611                         TokenKind tk2 = S.token(pos).kind;
1612                         switch (tk2) {
1613                             case EOF:
1614                                 return false;
1615                             case LPAREN:
1616                                 nesting++;
1617                                 break;
1618                             case RPAREN:
1619                                 nesting--;
1620                                 if (nesting == 0) {
1621                                     continue outer;
1622                                 }
1623                                 break;
1624                         }
1625                     }
1626 
1627                 case LT:
1628                     depth++; break;
1629                 case GTGTGT:
1630                     depth--;
1631                 case GTGT:
1632                     depth--;
1633                 case GT:
1634                     depth--;
1635                     if (depth == 0) {
1636                         TokenKind nextKind = S.token(pos + 1).kind;
1637                         return
1638                             nextKind == TokenKind.DOT ||
1639                             nextKind == TokenKind.LBRACKET ||
1640                             nextKind == TokenKind.COLCOL;
1641                     }
1642                     break;
1643                 default:
1644                     return false;
1645             }
1646         }
1647     }
1648 
1649     /**
1650      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1651      * method reference or a binary expression. To disambiguate, look for a
1652      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1653      */
1654     @SuppressWarnings(&quot;fallthrough&quot;)
1655     ParensResult analyzeParens() {
1656         int depth = 0;
1657         boolean type = false;
1658         ParensResult defaultResult = ParensResult.PARENS;
1659         outer: for (int lookahead = 0; ; lookahead++) {
1660             TokenKind tk = S.token(lookahead).kind;
1661             switch (tk) {
1662                 case COMMA:
1663                     type = true;
1664                 case EXTENDS: case SUPER: case DOT: case AMP:
1665                     //skip
1666                     break;
1667                 case QUES:
1668                     if (peekToken(lookahead, EXTENDS) ||
1669                             peekToken(lookahead, SUPER)) {
1670                         //wildcards
1671                         type = true;
1672                     }
1673                     break;
1674                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1675                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1676                     if (peekToken(lookahead, RPAREN)) {
1677                         //Type, &#39;)&#39; -&gt; cast
1678                         return ParensResult.CAST;
1679                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1680                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1681                         return ParensResult.EXPLICIT_LAMBDA;
1682                     }
1683                     break;
1684                 case LPAREN:
1685                     if (lookahead != 0) {
1686                         // &#39;(&#39; in a non-starting position -&gt; parens
1687                         return ParensResult.PARENS;
1688                     } else if (peekToken(lookahead, RPAREN)) {
1689                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1690                         return ParensResult.EXPLICIT_LAMBDA;
1691                     }
1692                     break;
1693                 case RPAREN:
1694                     // if we have seen something that looks like a type,
1695                     // then it&#39;s a cast expression
1696                     if (type) return ParensResult.CAST;
1697                     // otherwise, disambiguate cast vs. parenthesized expression
1698                     // based on subsequent token.
1699                     switch (S.token(lookahead + 1).kind) {
1700                         /*case PLUSPLUS: case SUBSUB: */
1701                         case BANG: case TILDE:
1702                         case LPAREN: case THIS: case SUPER:
1703                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1704                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1705                         case TRUE: case FALSE: case NULL:
1706                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1707                         case SWITCH:
1708                         case BYTE: case SHORT: case CHAR: case INT:
1709                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1710                             return ParensResult.CAST;
1711                         default:
1712                             return defaultResult;
1713                     }
1714                 case UNDERSCORE:
1715                 case ASSERT:
1716                 case ENUM:
1717                 case IDENTIFIER:
1718                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1719                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1720                         return ParensResult.EXPLICIT_LAMBDA;
1721                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1722                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1723                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1724                                                       : ParensResult.PARENS;
1725                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1726                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1727                     }
1728                     type = false;
1729                     break;
1730                 case FINAL:
1731                 case ELLIPSIS:
1732                     //those can only appear in explicit lambdas
1733                     return ParensResult.EXPLICIT_LAMBDA;
1734                 case MONKEYS_AT:
1735                     type = true;
1736                     lookahead += 1; //skip &#39;@&#39;
1737                     while (peekToken(lookahead, DOT)) {
1738                         lookahead += 2;
1739                     }
1740                     if (peekToken(lookahead, LPAREN)) {
1741                         lookahead++;
1742                         //skip annotation values
1743                         int nesting = 0;
1744                         for (; ; lookahead++) {
1745                             TokenKind tk2 = S.token(lookahead).kind;
1746                             switch (tk2) {
1747                                 case EOF:
1748                                     return ParensResult.PARENS;
1749                                 case LPAREN:
1750                                     nesting++;
1751                                     break;
1752                                 case RPAREN:
1753                                     nesting--;
1754                                     if (nesting == 0) {
1755                                         continue outer;
1756                                     }
1757                                 break;
1758                             }
1759                         }
1760                     }
1761                     break;
1762                 case LBRACKET:
1763                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1764                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1765                         return ParensResult.EXPLICIT_LAMBDA;
1766                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1767                             peekToken(lookahead, RBRACKET, AMP)) {
1768                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1769                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1770                         return ParensResult.CAST;
1771                     } else if (peekToken(lookahead, RBRACKET)) {
1772                         //consume the &#39;]&#39; and skip
1773                         type = true;
1774                         lookahead++;
1775                         break;
1776                     } else {
1777                         return ParensResult.PARENS;
1778                     }
1779                 case LT:
1780                     depth++; break;
1781                 case GTGTGT:
1782                     depth--;
1783                 case GTGT:
1784                     depth--;
1785                 case GT:
1786                     depth--;
1787                     if (depth == 0) {
1788                         if (peekToken(lookahead, RPAREN) ||
1789                                 peekToken(lookahead, AMP)) {
1790                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1791                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1792                             return ParensResult.CAST;
1793                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1794                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1795                                 peekToken(lookahead, ELLIPSIS)) {
1796                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1797                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1798                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1799                             return ParensResult.EXPLICIT_LAMBDA;
1800                         }
1801                         //it looks a type, but could still be (i) a cast to generic type,
1802                         //(ii) an unbound method reference or (iii) an explicit lambda
1803                         type = true;
1804                         break;
1805                     } else if (depth &lt; 0) {
1806                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1807                         return ParensResult.PARENS;
1808                     }
1809                     break;
1810                 default:
1811                     //this includes EOF
1812                     return defaultResult;
1813             }
1814         }
1815     }
1816 
1817     /** Accepts all identifier-like tokens */
1818     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1819 
1820     enum ParensResult {
1821         CAST,
1822         EXPLICIT_LAMBDA,
1823         IMPLICIT_LAMBDA,
1824         PARENS
1825     }
1826 
1827     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1828         List&lt;JCVariableDecl&gt; params = explicitParams ?
1829                 formalParameters(true, false) :
1830                 implicitParameters(hasParens);
1831         if (explicitParams) {
1832             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1833             for (JCVariableDecl param: params) {
1834                 Name restrictedTypeName;
1835                 if (param.vartype != null &amp;&amp;
1836                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1837                         param.vartype.hasTag(TYPEARRAY)) {
1838                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1839                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1840                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1841                 }
1842                 lambdaClassifier.addParameter(param);
1843                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1844                     break;
1845                 }
1846             }
1847             if (lambdaClassifier.diagFragment != null) {
1848                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1849             }
1850             for (JCVariableDecl param: params) {
1851                 if (param.vartype != null
1852                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1853                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1854                     param.startPos = TreeInfo.getStartPos(param.vartype);
1855                     param.vartype = null;
1856                 }
1857             }
1858         }
1859         return lambdaExpressionOrStatementRest(params, pos);
1860     }
1861 
1862     enum LambdaParameterKind {
1863         VAR(0),
1864         EXPLICIT(1),
1865         IMPLICIT(2),
1866         ERROR(-1);
1867 
1868         private final int index;
1869 
1870         LambdaParameterKind(int index) {
1871             this.index = index;
1872         }
1873     }
1874 
1875     private final static Fragment[][] decisionTable = new Fragment[][] {
1876         /*              VAR                              EXPLICIT                         IMPLICIT  */
1877         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1878         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1879         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1880     };
1881 
1882     class LambdaClassifier {
1883 
1884         LambdaParameterKind kind;
1885         Fragment diagFragment;
1886         List&lt;JCVariableDecl&gt; params;
1887 
1888         void addParameter(JCVariableDecl param) {
1889             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1890                 if (restrictedTypeName(param.vartype, false) != null) {
1891                     reduce(LambdaParameterKind.VAR);
1892                 } else {
1893                     reduce(LambdaParameterKind.EXPLICIT);
1894                 }
1895             }
1896             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1897                 param.vartype != null &amp;&amp; param.name == names.empty) {
1898                 reduce(LambdaParameterKind.IMPLICIT);
1899             }
1900         }
1901 
1902         private void reduce(LambdaParameterKind newKind) {
1903             if (kind == null) {
1904                 kind = newKind;
1905             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1906                 LambdaParameterKind currentKind = kind;
1907                 kind = LambdaParameterKind.ERROR;
1908                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1909                         newKind.index == LambdaParameterKind.VAR.index;
1910                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1911                         decisionTable[currentKind.index][newKind.index] : null;
1912             }
1913         }
1914 
1915         LambdaParameterKind result() {
1916             return kind;
1917         }
1918     }
1919 
1920     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1921         checkSourceLevel(Feature.LAMBDA);
1922         accept(ARROW);
1923 
1924         return token.kind == LBRACE ?
1925             lambdaStatement(args, pos, token.pos) :
1926             lambdaExpression(args, pos);
1927     }
1928 
1929     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1930         JCBlock block = block(pos2, 0);
1931         return toP(F.at(pos).Lambda(args, block));
1932     }
1933 
1934     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1935         JCTree expr = parseExpression();
1936         return toP(F.at(pos).Lambda(args, expr));
1937     }
1938 
1939     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1940      */
1941     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1942         nextToken();
1943         if (token.kind == LPAREN || typeArgs != null) {
1944             t = arguments(typeArgs, t);
1945         } else if (token.kind == COLCOL) {
1946             if (typeArgs != null) return illegal();
1947             t = memberReferenceSuffix(t);
1948         } else {
1949             int pos = token.pos;
1950             accept(DOT);
1951             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1952             t = toP(F.at(pos).Select(t, ident()));
1953             t = argumentsOpt(typeArgs, t);
1954         }
1955         return t;
1956     }
1957 
1958     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1959      */
1960     JCPrimitiveTypeTree basicType() {
1961         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1962         nextToken();
1963         return t;
1964     }
1965 
1966     /** ArgumentsOpt = [ Arguments ]
1967      */
1968     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1969         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1970             selectExprMode();
1971             return arguments(typeArgs, t);
1972         } else {
1973             return t;
1974         }
1975     }
1976 
1977     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1978      */
1979     List&lt;JCExpression&gt; arguments() {
1980         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1981         if (token.kind == LPAREN) {
1982             nextToken();
1983             if (token.kind != RPAREN) {
1984                 args.append(parseExpression());
1985                 while (token.kind == COMMA) {
1986                     nextToken();
1987                     args.append(parseExpression());
1988                 }
1989             }
1990             accept(RPAREN);
1991         } else {
1992             syntaxError(token.pos, Errors.Expected(LPAREN));
1993         }
1994         return args.toList();
1995     }
1996 
1997     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1998         int pos = token.pos;
1999         List&lt;JCExpression&gt; args = arguments();
2000         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2001         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2002                                                                     ((JCIdent) t).name)) {
2003             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2004             mi = F.Erroneous(List.of(mi));
2005         }
2006         return toP(mi);
2007     }
2008 
2009     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2010         if (name == names.yield) {
2011             if (allowYieldStatement) {
2012                 return true;
2013             } else {
2014                 log.warning(pos, Warnings.InvalidYield);
2015             }
2016         }
2017         return false;
2018     }
2019 
2020     /**  TypeArgumentsOpt = [ TypeArguments ]
2021      */
2022     JCExpression typeArgumentsOpt(JCExpression t) {
2023         if (token.kind == LT &amp;&amp;
2024             (mode &amp; TYPE) != 0 &amp;&amp;
2025             (mode &amp; NOPARAMS) == 0) {
2026             selectTypeMode();
2027             return typeArguments(t, false);
2028         } else {
2029             return t;
2030         }
2031     }
2032     List&lt;JCExpression&gt; typeArgumentsOpt() {
2033         return typeArgumentsOpt(TYPE);
2034     }
2035 
2036     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2037         if (token.kind == LT) {
2038             if ((mode &amp; useMode) == 0 ||
2039                 (mode &amp; NOPARAMS) != 0) {
2040                 illegal();
2041             }
2042             mode = useMode;
2043             return typeArguments(false);
2044         }
2045         return null;
2046     }
2047 
2048     /**
2049      *  {@literal
2050      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2051      *  }
2052      */
2053     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2054         if (token.kind == LT) {
2055             nextToken();
2056             if (token.kind == GT &amp;&amp; diamondAllowed) {
2057                 checkSourceLevel(Feature.DIAMOND);
2058                 mode |= DIAMOND;
2059                 nextToken();
2060                 return List.nil();
2061             } else {
2062                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2063                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2064                 while (token.kind == COMMA) {
2065                     nextToken();
2066                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2067                 }
2068                 switch (token.kind) {
2069 
2070                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2071                 case GTGTGT: case GTGT:
2072                     token = S.split();
2073                     break;
2074                 case GT:
2075                     nextToken();
2076                     break;
2077                 default:
2078                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2079                     break;
2080                 }
2081                 return args.toList();
2082             }
2083         } else {
2084             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2085         }
2086     }
2087 
2088     /**
2089      *  {@literal
2090      *  TypeArgument = Type
2091      *               | [Annotations] &quot;?&quot;
2092      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2093      *               | [Annotations] &quot;?&quot; SUPER Type
2094      *  }
2095      */
2096     JCExpression typeArgument() {
2097         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2098         if (token.kind != QUES) return parseType(false, annotations);
2099         int pos = token.pos;
2100         nextToken();
2101         JCExpression result;
2102         if (token.kind == EXTENDS) {
2103             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2104             nextToken();
2105             JCExpression bound = parseType();
2106             result = F.at(pos).Wildcard(t, bound);
2107         } else if (token.kind == SUPER) {
2108             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2109             nextToken();
2110             JCExpression bound = parseType();
2111             result = F.at(pos).Wildcard(t, bound);
2112         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2113             //error recovery
2114             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2115             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2116             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2117             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2118             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2119             result = err;
2120         } else {
2121             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2122             result = toP(F.at(pos).Wildcard(t, null));
2123         }
2124         if (!annotations.isEmpty()) {
2125             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2126         }
2127         return result;
2128     }
2129 
2130     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2131         int pos = token.pos;
2132         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2133         return toP(F.at(pos).TypeApply(t, args));
2134     }
2135 
2136     /**
2137      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2138      *
2139      * &lt;p&gt;
2140      *
2141      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2142      * the expression &lt;code&gt;t&lt;/code&gt;.
2143      */
2144     private JCExpression bracketsOpt(JCExpression t,
2145             List&lt;JCAnnotation&gt; annotations) {
2146         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2147 
2148         if (token.kind == LBRACKET) {
2149             int pos = token.pos;
2150             nextToken();
2151             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2152         } else if (!nextLevelAnnotations.isEmpty()) {
2153             if (permitTypeAnnotationsPushBack) {
2154                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2155             } else {
2156                 return illegal(nextLevelAnnotations.head.pos);
2157             }
2158         }
2159 
2160         if (!annotations.isEmpty()) {
2161             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2162         }
2163         return t;
2164     }
2165 
2166     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2167      */
2168     private JCExpression bracketsOpt(JCExpression t) {
2169         return bracketsOpt(t, List.nil());
2170     }
2171 
2172     private JCExpression bracketsOptCont(JCExpression t, int pos,
2173             List&lt;JCAnnotation&gt; annotations) {
2174         accept(RBRACKET);
2175         t = bracketsOpt(t);
2176         t = toP(F.at(pos).TypeArray(t));
2177         if (annotations.nonEmpty()) {
2178             t = toP(F.at(pos).AnnotatedType(annotations, t));
2179         }
2180         return t;
2181     }
2182 
2183     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2184      *  BracketsSuffixType =
2185      */
2186     JCExpression bracketsSuffix(JCExpression t) {
2187         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2188             selectExprMode();
2189             int pos = token.pos;
2190             nextToken();
2191             accept(CLASS);
2192             if (token.pos == endPosTable.errorEndPos) {
2193                 // error recovery
2194                 Name name;
2195                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2196                     name = token.name();
2197                     nextToken();
2198                 } else {
2199                     name = names.error;
2200                 }
2201                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2202             } else {
2203                 Tag tag = t.getTag();
2204                 // Type annotations are illegal on class literals. Annotated non array class literals
2205                 // are complained about directly in term3(), Here check for type annotations on dimensions
2206                 // taking care to handle some interior dimension(s) being annotated.
2207                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2208                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2209                 t = toP(F.at(pos).Select(t, names._class));
2210             }
2211         } else if ((mode &amp; TYPE) != 0) {
2212             if (token.kind != COLCOL) {
2213                 selectTypeMode();
2214             }
2215         } else if (token.kind != COLCOL) {
2216             syntaxError(token.pos, Errors.DotClassExpected);
2217         }
2218         return t;
2219     }
2220 
2221     /**
2222      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2223      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2224      */
2225     JCExpression memberReferenceSuffix(JCExpression t) {
2226         int pos1 = token.pos;
2227         accept(COLCOL);
2228         return memberReferenceSuffix(pos1, t);
2229     }
2230 
2231     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2232         checkSourceLevel(Feature.METHOD_REFERENCES);
2233         selectExprMode();
2234         List&lt;JCExpression&gt; typeArgs = null;
2235         if (token.kind == LT) {
2236             typeArgs = typeArguments(false);
2237         }
2238         Name refName;
2239         ReferenceMode refMode;
2240         if (token.kind == NEW) {
2241             refMode = ReferenceMode.NEW;
2242             refName = names.init;
2243             nextToken();
2244         } else {
2245             refMode = ReferenceMode.INVOKE;
2246             refName = ident();
2247         }
2248         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2249     }
2250 
2251     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2252      */
2253     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2254         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2255 
2256         switch (token.kind) {
2257         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2258         case DOUBLE: case BOOLEAN:
2259             if (typeArgs == null) {
2260                 if (newAnnotations.isEmpty()) {
2261                     return arrayCreatorRest(newpos, basicType());
2262                 } else {
2263                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2264                 }
2265             }
2266             break;
2267         default:
2268         }
2269         JCExpression t = qualident(true);
2270 
2271         int oldmode = mode;
2272         selectTypeMode();
2273         boolean diamondFound = false;
2274         int lastTypeargsPos = -1;
2275         if (token.kind == LT) {
2276             lastTypeargsPos = token.pos;
2277             t = typeArguments(t, true);
2278             diamondFound = (mode &amp; DIAMOND) != 0;
2279         }
2280         while (token.kind == DOT) {
2281             if (diamondFound) {
2282                 //cannot select after a diamond
2283                 illegal();
2284             }
2285             int pos = token.pos;
2286             nextToken();
2287             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2288             t = toP(F.at(pos).Select(t, ident()));
2289 
2290             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2291                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2292             }
2293 
2294             if (token.kind == LT) {
2295                 lastTypeargsPos = token.pos;
2296                 t = typeArguments(t, true);
2297                 diamondFound = (mode &amp; DIAMOND) != 0;
2298             }
2299         }
2300         mode = oldmode;
2301         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2302             // handle type annotations for non primitive arrays
2303             if (newAnnotations.nonEmpty()) {
2304                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2305             }
2306 
2307             JCExpression e = arrayCreatorRest(newpos, t);
2308             if (diamondFound) {
2309                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2310                 return toP(F.at(newpos).Erroneous(List.of(e)));
2311             }
2312             else if (typeArgs != null) {
2313                 int pos = newpos;
2314                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2315                     // note: this should always happen but we should
2316                     // not rely on this as the parser is continuously
2317                     // modified to improve error recovery.
2318                     pos = typeArgs.head.pos;
2319                 }
2320                 setErrorEndPos(S.prevToken().endPos);
2321                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2322                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2323                 return toP(err);
2324             }
2325             return e;
2326         } else if (token.kind == LPAREN) {
2327             // handle type annotations for instantiations and anonymous classes
2328             if (newAnnotations.nonEmpty()) {
2329                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2330             }
2331             return classCreatorRest(newpos, null, typeArgs, t);
2332         } else {
2333             setErrorEndPos(token.pos);
2334             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2335             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2336             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2337         }
2338     }
2339 
2340     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2341      */
2342     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2343         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2344 
2345         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2346 
2347         if (newAnnotations.nonEmpty()) {
2348             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2349         }
2350 
2351         if (token.kind == LT) {
2352             int oldmode = mode;
2353             t = typeArguments(t, true);
2354             mode = oldmode;
2355         }
2356         return classCreatorRest(newpos, encl, typeArgs, t);
2357     }
2358 
2359     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2360      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2361      */
2362     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2363         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2364 
2365         accept(LBRACKET);
2366         if (token.kind == RBRACKET) {
2367             accept(RBRACKET);
2368             elemtype = bracketsOpt(elemtype, annos);
2369             if (token.kind == LBRACE) {
2370                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2371                 if (annos.nonEmpty()) {
2372                     // when an array initializer is present then
2373                     // the parsed annotations should target the
2374                     // new array tree
2375                     // bracketsOpt inserts the annotation in
2376                     // elemtype, and it needs to be corrected
2377                     //
2378                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2379                     assert annotated.annotations == annos;
2380                     na.annotations = annotated.annotations;
2381                     na.elemtype = annotated.underlyingType;
2382                 }
2383                 return na;
2384             } else {
2385                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2386                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2387             }
2388         } else {
2389             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2390 
2391             // maintain array dimension type annotations
2392             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2393             dimAnnotations.append(annos);
2394 
2395             dims.append(parseExpression());
2396             accept(RBRACKET);
2397             while (token.kind == LBRACKET
2398                     || token.kind == MONKEYS_AT) {
2399                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2400                 int pos = token.pos;
2401                 nextToken();
2402                 if (token.kind == RBRACKET) {
2403                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2404                 } else {
2405                     if (token.kind == RBRACKET) { // no dimension
2406                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2407                     } else {
2408                         dimAnnotations.append(maybeDimAnnos);
2409                         dims.append(parseExpression());
2410                         accept(RBRACKET);
2411                     }
2412                 }
2413             }
2414 
2415             List&lt;JCExpression&gt; elems = null;
2416             int errpos = token.pos;
2417 
2418             if (token.kind == LBRACE) {
2419                 elems = arrayInitializerElements(newpos, elemtype);
2420             }
2421 
2422             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2423             na.dimAnnotations = dimAnnotations.toList();
2424 
2425             if (elems != null) {
2426                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2427             }
2428 
2429             return na;
2430         }
2431     }
2432 
2433     /** ClassCreatorRest = Arguments [ClassBody]
2434      */
2435     JCNewClass classCreatorRest(int newpos,
2436                                   JCExpression encl,
2437                                   List&lt;JCExpression&gt; typeArgs,
2438                                   JCExpression t)
2439     {
2440         List&lt;JCExpression&gt; args = arguments();
2441         JCClassDecl body = null;
2442         if (token.kind == LBRACE) {
2443             int pos = token.pos;
2444             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2445             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2446             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2447         }
2448         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2449     }
2450 
2451     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2452      */
2453     JCExpression arrayInitializer(int newpos, JCExpression t) {
2454         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2455         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2456     }
2457 
2458     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2459         accept(LBRACE);
2460         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2461         if (token.kind == COMMA) {
2462             nextToken();
2463         } else if (token.kind != RBRACE) {
2464             elems.append(variableInitializer());
2465             while (token.kind == COMMA) {
2466                 nextToken();
2467                 if (token.kind == RBRACE) break;
2468                 elems.append(variableInitializer());
2469             }
2470         }
2471         accept(RBRACE);
2472         return elems.toList();
2473     }
2474 
2475     /** VariableInitializer = ArrayInitializer | Expression
2476      */
2477     public JCExpression variableInitializer() {
2478         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2479     }
2480 
2481     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2482      */
2483     JCExpression parExpression() {
2484         int pos = token.pos;
2485         accept(LPAREN);
2486         JCExpression t = parseExpression();
2487         accept(RPAREN);
2488         return toP(F.at(pos).Parens(t));
2489     }
2490 
2491     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2492      */
2493     JCBlock block(int pos, long flags) {
2494         accept(LBRACE);
2495         List&lt;JCStatement&gt; stats = blockStatements();
2496         JCBlock t = F.at(pos).Block(flags, stats);
2497         while (token.kind == CASE || token.kind == DEFAULT) {
2498             syntaxError(token.pos, Errors.Orphaned(token.kind));
2499             switchBlockStatementGroups();
2500         }
2501         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2502         // usually but not necessarily the last char of the last token.
2503         t.endpos = token.pos;
2504         accept(RBRACE);
2505         return toP(t);
2506     }
2507 
2508     public JCBlock block() {
2509         return block(token.pos, 0);
2510     }
2511 
2512     /** BlockStatements = { BlockStatement }
2513      *  BlockStatement  = LocalVariableDeclarationStatement
2514      *                  | ClassOrInterfaceOrEnumDeclaration
2515      *                  | [Ident &quot;:&quot;] Statement
2516      *  LocalVariableDeclarationStatement
2517      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2518      */
2519     @SuppressWarnings(&quot;fallthrough&quot;)
2520     List&lt;JCStatement&gt; blockStatements() {
2521         //todo: skip to anchor on error(?)
2522         int lastErrPos = -1;
2523         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2524         while (true) {
2525             List&lt;JCStatement&gt; stat = blockStatement();
2526             if (stat.isEmpty()) {
2527                 return stats.toList();
2528             } else {
2529                 // error recovery
2530                 if (token.pos == lastErrPos)
2531                     return stats.toList();
2532                 if (token.pos &lt;= endPosTable.errorEndPos) {
2533                     skip(false, true, true, true);
2534                     lastErrPos = token.pos;
2535                 }
2536                 stats.addAll(stat);
2537             }
2538         }
2539     }
2540 
2541     /*
2542      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2543      * this method will also recognize variable and class declarations (which are
2544      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2545      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2546      * and an error will be produced by this method.
2547      */
2548     JCStatement parseStatementAsBlock() {
2549         int pos = token.pos;
2550         List&lt;JCStatement&gt; stats = blockStatement();
2551         if (stats.isEmpty()) {
2552             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2553             return toP(F.at(pos).Exec(e));
2554         } else {
2555             JCStatement first = stats.head;
2556             Error error = null;
2557             switch (first.getTag()) {
2558             case CLASSDEF:
2559                 error = Errors.ClassNotAllowed;
2560                 break;
2561             case VARDEF:
2562                 error = Errors.VariableNotAllowed;
2563                 break;
2564             }
2565             if (error != null) {
2566                 log.error(DiagnosticFlag.SYNTAX, first, error);
2567                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2568                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2569             }
2570             return first;
2571         }
2572     }
2573 
2574     /**This method parses a statement appearing inside a block.
2575      */
2576     @SuppressWarnings(&quot;fallthrough&quot;)
2577     List&lt;JCStatement&gt; blockStatement() {
2578         //todo: skip to anchor on error(?)
2579         Comment dc;
2580         int pos = token.pos;
2581         switch (token.kind) {
2582         case RBRACE: case CASE: case DEFAULT: case EOF:
2583             return List.nil();
2584         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2585         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2586         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2587         case ASSERT:
2588             return List.of(parseSimpleStatement());
2589         case MONKEYS_AT:
2590         case FINAL: {
2591             dc = token.comment(CommentStyle.JAVADOC);
2592             JCModifiers mods = modifiersOpt();
2593             if (token.kind == INTERFACE ||
2594                 token.kind == CLASS ||
2595                 token.kind == ENUM ||
2596                 isRecordStart()) {
2597                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2598             } else {
2599                 JCExpression t = parseType(true);
2600                 return localVariableDeclarations(mods, t);
2601             }
2602         }
2603         case ABSTRACT: case STRICTFP: {
2604             dc = token.comment(CommentStyle.JAVADOC);
2605             JCModifiers mods = modifiersOpt();
2606             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2607         }
2608         case INTERFACE:
2609         case CLASS:
2610             dc = token.comment(CommentStyle.JAVADOC);
2611             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2612         case ENUM:
2613             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2614             dc = token.comment(CommentStyle.JAVADOC);
2615             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2616         case IDENTIFIER:
2617             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2618                 Token next = S.token(1);
2619                 boolean isYieldStatement;
2620                 switch (next.kind) {
2621                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<a name="12" id="anc12"></a><span class="line-modified">2622                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2623                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2624                     case NEW: case SWITCH: case THIS: case SUPER:
2625                         isYieldStatement = true;
2626                         break;
2627                     case PLUSPLUS: case SUBSUB:
2628                         isYieldStatement = S.token(2).kind != SEMI;
2629                         break;
2630                     case LPAREN:
2631                         int lookahead = 2;
2632                         int balance = 1;
2633                         boolean hasComma = false;
2634                         Token l;
2635                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2636                             switch (l.kind) {
2637                                 case LPAREN: balance++; break;
2638                                 case RPAREN: balance--; break;
2639                                 case COMMA: if (balance == 1) hasComma = true; break;
2640                             }
2641                             lookahead++;
2642                         }
2643                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2644                         break;
2645                     case SEMI: //error recovery - this is not a valid statement:
2646                         isYieldStatement = true;
2647                         break;
2648                     default:
2649                         isYieldStatement = false;
2650                         break;
2651                 }
2652 
2653                 if (isYieldStatement) {
2654                     nextToken();
2655                     JCExpression t = term(EXPR);
2656                     accept(SEMI);
2657                     return List.of(toP(F.at(pos).Yield(t)));
2658                 }
2659 
2660                 //else intentional fall-through
2661             }
2662         }
2663         if (isRecordStart() &amp;&amp; allowRecords) {
2664             dc = token.comment(CommentStyle.JAVADOC);
2665             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2666         } else {
2667             Token prevToken = token;
2668             JCExpression t = term(EXPR | TYPE);
2669             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2670                 nextToken();
2671                 JCStatement stat = parseStatementAsBlock();
2672                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2673             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2674                 pos = token.pos;
2675                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2676                 F.at(pos);
2677                 return localVariableDeclarations(mods, t);
2678             } else {
2679                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2680                 t = checkExprStat(t);
2681                 accept(SEMI);
2682                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2683                 return List.of(expr);
2684             }
2685         }
2686     }
2687     //where
2688         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2689             ListBuffer&lt;JCStatement&gt; stats =
2690                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2691             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2692             accept(SEMI);
2693             storeEnd(stats.last(), S.prevToken().endPos);
2694             return stats.toList();
2695         }
2696 
2697     /** Statement =
2698      *       Block
2699      *     | IF ParExpression Statement [ELSE Statement]
2700      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2701      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2702      *     | WHILE ParExpression Statement
2703      *     | DO Statement WHILE ParExpression &quot;;&quot;
2704      *     | TRY Block ( Catches | [Catches] FinallyPart )
2705      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2706      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2707      *     | SYNCHRONIZED ParExpression Block
2708      *     | RETURN [Expression] &quot;;&quot;
2709      *     | THROW Expression &quot;;&quot;
2710      *     | BREAK [Ident] &quot;;&quot;
2711      *     | CONTINUE [Ident] &quot;;&quot;
2712      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2713      *     | &quot;;&quot;
2714      */
2715     public JCStatement parseSimpleStatement() {
2716         int pos = token.pos;
2717         switch (token.kind) {
2718         case LBRACE:
2719             return block();
2720         case IF: {
2721             nextToken();
2722             JCExpression cond = parExpression();
2723             JCStatement thenpart = parseStatementAsBlock();
2724             JCStatement elsepart = null;
2725             if (token.kind == ELSE) {
2726                 nextToken();
2727                 elsepart = parseStatementAsBlock();
2728             }
2729             return F.at(pos).If(cond, thenpart, elsepart);
2730         }
2731         case FOR: {
2732             nextToken();
2733             accept(LPAREN);
2734             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2735             if (inits.length() == 1 &amp;&amp;
2736                 inits.head.hasTag(VARDEF) &amp;&amp;
2737                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2738                 token.kind == COLON) {
2739                 JCVariableDecl var = (JCVariableDecl)inits.head;
2740                 accept(COLON);
2741                 JCExpression expr = parseExpression();
2742                 accept(RPAREN);
2743                 JCStatement body = parseStatementAsBlock();
2744                 return F.at(pos).ForeachLoop(var, expr, body);
2745             } else {
2746                 accept(SEMI);
2747                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2748                 accept(SEMI);
2749                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2750                 accept(RPAREN);
2751                 JCStatement body = parseStatementAsBlock();
2752                 return F.at(pos).ForLoop(inits, cond, steps, body);
2753             }
2754         }
2755         case WHILE: {
2756             nextToken();
2757             JCExpression cond = parExpression();
2758             JCStatement body = parseStatementAsBlock();
2759             return F.at(pos).WhileLoop(cond, body);
2760         }
2761         case DO: {
2762             nextToken();
2763             JCStatement body = parseStatementAsBlock();
2764             accept(WHILE);
2765             JCExpression cond = parExpression();
2766             accept(SEMI);
2767             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2768             return t;
2769         }
2770         case TRY: {
2771             nextToken();
2772             List&lt;JCTree&gt; resources = List.nil();
2773             if (token.kind == LPAREN) {
2774                 nextToken();
2775                 resources = resources();
2776                 accept(RPAREN);
2777             }
2778             JCBlock body = block();
2779             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2780             JCBlock finalizer = null;
2781             if (token.kind == CATCH || token.kind == FINALLY) {
2782                 while (token.kind == CATCH) catchers.append(catchClause());
2783                 if (token.kind == FINALLY) {
2784                     nextToken();
2785                     finalizer = block();
2786                 }
2787             } else {
2788                 if (resources.isEmpty()) {
2789                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2790                 }
2791             }
2792             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2793         }
2794         case SWITCH: {
2795             nextToken();
2796             JCExpression selector = parExpression();
2797             accept(LBRACE);
2798             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2799             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2800             accept(RBRACE);
2801             return t;
2802         }
2803         case SYNCHRONIZED: {
2804             nextToken();
2805             JCExpression lock = parExpression();
2806             JCBlock body = block();
2807             return F.at(pos).Synchronized(lock, body);
2808         }
2809         case RETURN: {
2810             nextToken();
2811             JCExpression result = token.kind == SEMI ? null : parseExpression();
2812             accept(SEMI);
2813             JCReturn t = toP(F.at(pos).Return(result));
2814             return t;
2815         }
2816         case THROW: {
2817             nextToken();
2818             JCExpression exc = parseExpression();
2819             accept(SEMI);
2820             JCThrow t = toP(F.at(pos).Throw(exc));
2821             return t;
2822         }
2823         case BREAK: {
2824             nextToken();
2825             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2826             accept(SEMI);
2827             JCBreak t = toP(F.at(pos).Break(label));
2828             return t;
2829         }
2830         case CONTINUE: {
2831             nextToken();
2832             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2833             accept(SEMI);
2834             JCContinue t =  toP(F.at(pos).Continue(label));
2835             return t;
2836         }
2837         case SEMI:
2838             nextToken();
2839             return toP(F.at(pos).Skip());
2840         case ELSE:
2841             int elsePos = token.pos;
2842             nextToken();
2843             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2844         case FINALLY:
2845             int finallyPos = token.pos;
2846             nextToken();
2847             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2848         case CATCH:
2849             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2850         case ASSERT: {
2851             nextToken();
2852             JCExpression assertion = parseExpression();
2853             JCExpression message = null;
2854             if (token.kind == COLON) {
2855                 nextToken();
2856                 message = parseExpression();
2857             }
2858             accept(SEMI);
2859             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2860             return t;
2861         }
2862         default:
2863             Assert.error();
2864             return null;
2865         }
2866     }
2867 
2868     @Override
2869     public JCStatement parseStatement() {
2870         return parseStatementAsBlock();
2871     }
2872 
2873     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2874         int errPos = S.errPos();
2875         JCTree stm = action.doRecover(this);
2876         S.errPos(errPos);
2877         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2878     }
2879 
2880     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2881      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2882      */
2883     protected JCCatch catchClause() {
2884         int pos = token.pos;
2885         accept(CATCH);
2886         accept(LPAREN);
2887         JCModifiers mods = optFinal(Flags.PARAMETER);
2888         List&lt;JCExpression&gt; catchTypes = catchTypes();
2889         JCExpression paramType = catchTypes.size() &gt; 1 ?
2890                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2891                 catchTypes.head;
2892         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2893         accept(RPAREN);
2894         JCBlock body = block();
2895         return F.at(pos).Catch(formal, body);
2896     }
2897 
2898     List&lt;JCExpression&gt; catchTypes() {
2899         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2900         catchTypes.add(parseType());
2901         while (token.kind == BAR) {
2902             nextToken();
2903             // Instead of qualident this is now parseType.
2904             // But would that allow too much, e.g. arrays or generics?
2905             catchTypes.add(parseType());
2906         }
2907         return catchTypes.toList();
2908     }
2909 
2910     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2911      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2912      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2913      */
2914     List&lt;JCCase&gt; switchBlockStatementGroups() {
2915         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2916         while (true) {
2917             int pos = token.pos;
2918             switch (token.kind) {
2919             case CASE:
2920             case DEFAULT:
2921                 cases.appendList(switchBlockStatementGroup());
2922                 break;
2923             case RBRACE: case EOF:
2924                 return cases.toList();
2925             default:
2926                 nextToken(); // to ensure progress
2927                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2928             }
2929         }
2930     }
2931 
2932     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2933         int pos = token.pos;
2934         List&lt;JCStatement&gt; stats;
2935         JCCase c;
2936         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2937         switch (token.kind) {
2938         case CASE: {
2939             nextToken();
2940             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2941             while (true) {
2942                 pats.append(term(EXPR | NOLAMBDA));
2943                 if (token.kind != COMMA) break;
2944                 nextToken();
2945                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2946             };
2947             CaseTree.CaseKind caseKind;
2948             JCTree body = null;
2949             if (token.kind == ARROW) {
2950                 checkSourceLevel(Feature.SWITCH_RULE);
2951                 accept(ARROW);
2952                 caseKind = JCCase.RULE;
2953                 JCStatement statement = parseStatementAsBlock();
2954                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2955                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2956                 }
2957                 stats = List.of(statement);
2958                 body = stats.head;
2959             } else {
2960                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2961                 caseKind = JCCase.STATEMENT;
2962                 stats = blockStatements();
2963             }
2964             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2965             if (stats.isEmpty())
2966                 storeEnd(c, S.prevToken().endPos);
2967             return cases.append(c).toList();
2968         }
2969         case DEFAULT: {
2970             nextToken();
2971             CaseTree.CaseKind caseKind;
2972             JCTree body = null;
2973             if (token.kind == ARROW) {
2974                 checkSourceLevel(Feature.SWITCH_RULE);
2975                 accept(ARROW);
2976                 caseKind = JCCase.RULE;
2977                 JCStatement statement = parseStatementAsBlock();
2978                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2979                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2980                 }
2981                 stats = List.of(statement);
2982                 body = stats.head;
2983             } else {
2984                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2985                 caseKind = JCCase.STATEMENT;
2986                 stats = blockStatements();
2987             }
2988             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
2989             if (stats.isEmpty())
2990                 storeEnd(c, S.prevToken().endPos);
2991             return cases.append(c).toList();
2992         }
2993         }
2994         throw new AssertionError(&quot;should not reach here&quot;);
2995     }
2996 
2997     /** MoreStatementExpressions = { COMMA StatementExpression }
2998      */
2999     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3000                                                                     JCExpression first,
3001                                                                     T stats) {
3002         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3003         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3004         while (token.kind == COMMA) {
3005             nextToken();
3006             pos = token.pos;
3007             JCExpression t = parseExpression();
3008             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3009             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3010         }
3011         return stats;
3012     }
3013 
3014     /** ForInit = StatementExpression MoreStatementExpressions
3015      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3016      */
3017     List&lt;JCStatement&gt; forInit() {
3018         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3019         int pos = token.pos;
3020         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3021             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3022         } else {
3023             JCExpression t = term(EXPR | TYPE);
3024             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3025                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
3026             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3027                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3028                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3029             } else {
3030                 return moreStatementExpressions(pos, t, stats).toList();
3031             }
3032         }
3033     }
3034 
3035     /** ForUpdate = StatementExpression MoreStatementExpressions
3036      */
3037     List&lt;JCExpressionStatement&gt; forUpdate() {
3038         return moreStatementExpressions(token.pos,
3039                                         parseExpression(),
3040                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3041     }
3042 
3043     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3044      *
3045      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3046      */
3047     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3048         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3049         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3050         int prevmode = mode;
3051         while (token.kind == MONKEYS_AT) {
3052             int pos = token.pos;
3053             nextToken();
3054             buf.append(annotation(pos, kind));
3055         }
3056         lastmode = mode;
3057         mode = prevmode;
3058         List&lt;JCAnnotation&gt; annotations = buf.toList();
3059 
3060         return annotations;
3061     }
3062 
3063     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3064         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3065         return annotations;
3066     }
3067 
3068     /** ModifiersOpt = { Modifier }
3069      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3070      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3071      *           | &quot;@&quot; Annotation
3072      */
3073     protected JCModifiers modifiersOpt() {
3074         return modifiersOpt(null);
3075     }
3076     protected JCModifiers modifiersOpt(JCModifiers partial) {
3077         long flags;
3078         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3079         int pos;
3080         if (partial == null) {
3081             flags = 0;
3082             pos = token.pos;
3083         } else {
3084             flags = partial.flags;
3085             annotations.appendList(partial.annotations);
3086             pos = partial.pos;
3087         }
3088         if (token.deprecatedFlag()) {
3089             flags |= Flags.DEPRECATED;
3090         }
3091         int lastPos;
3092     loop:
3093         while (true) {
3094             long flag;
3095             switch (token.kind) {
3096             case PRIVATE     : flag = Flags.PRIVATE; break;
3097             case PROTECTED   : flag = Flags.PROTECTED; break;
3098             case PUBLIC      : flag = Flags.PUBLIC; break;
3099             case STATIC      : flag = Flags.STATIC; break;
3100             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3101             case FINAL       : flag = Flags.FINAL; break;
3102             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3103             case NATIVE      : flag = Flags.NATIVE; break;
3104             case VOLATILE    : flag = Flags.VOLATILE; break;
3105             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3106             case STRICTFP    : flag = Flags.STRICTFP; break;
3107             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3108             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3109             case ERROR       : flag = 0; nextToken(); break;
3110             default: break loop;
3111             }
3112             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3113             lastPos = token.pos;
3114             nextToken();
3115             if (flag == Flags.ANNOTATION) {
3116                 if (token.kind != INTERFACE) {
3117                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3118                     // if first modifier is an annotation, set pos to annotation&#39;s.
3119                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3120                         pos = ann.pos;
3121                     annotations.append(ann);
3122                     flag = 0;
3123                 }
3124             }
3125             flags |= flag;
3126         }
3127         switch (token.kind) {
3128         case ENUM: flags |= Flags.ENUM; break;
3129         case INTERFACE: flags |= Flags.INTERFACE; break;
3130         default: break;
3131         }
3132 
3133         /* A modifiers tree with no modifier tokens or annotations
3134          * has no text position. */
3135         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3136             pos = Position.NOPOS;
3137 
3138         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3139         if (pos != Position.NOPOS)
3140             storeEnd(mods, S.prevToken().endPos);
3141         return mods;
3142     }
3143 
3144     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3145      *
3146      * @param pos position of &quot;@&quot; token
3147      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3148      */
3149     JCAnnotation annotation(int pos, Tag kind) {
3150         // accept(AT); // AT consumed by caller
3151         if (kind == Tag.TYPE_ANNOTATION) {
3152             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3153         }
3154         JCTree ident = qualident(false);
3155         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3156         JCAnnotation ann;
3157         if (kind == Tag.ANNOTATION) {
3158             ann = F.at(pos).Annotation(ident, fieldValues);
3159         } else if (kind == Tag.TYPE_ANNOTATION) {
3160             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3161         } else {
3162             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3163         }
3164 
3165         storeEnd(ann, S.prevToken().endPos);
3166         return ann;
3167     }
3168 
3169     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3170         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3171     }
3172 
3173     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3174     List&lt;JCExpression&gt; annotationFieldValues() {
3175         accept(LPAREN);
3176         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3177         if (token.kind != RPAREN) {
3178             buf.append(annotationFieldValue());
3179             while (token.kind == COMMA) {
3180                 nextToken();
3181                 buf.append(annotationFieldValue());
3182             }
3183         }
3184         accept(RPAREN);
3185         return buf.toList();
3186     }
3187 
3188     /** AnnotationFieldValue    = AnnotationValue
3189      *                          | Identifier &quot;=&quot; AnnotationValue
3190      */
3191     JCExpression annotationFieldValue() {
3192         if (LAX_IDENTIFIER.accepts(token.kind)) {
3193             selectExprMode();
3194             JCExpression t1 = term1();
3195             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3196                 int pos = token.pos;
3197                 accept(EQ);
3198                 JCExpression v = annotationValue();
3199                 return toP(F.at(pos).Assign(t1, v));
3200             } else {
3201                 return t1;
3202             }
3203         }
3204         return annotationValue();
3205     }
3206 
3207     /* AnnotationValue          = ConditionalExpression
3208      *                          | Annotation
3209      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3210      */
3211     JCExpression annotationValue() {
3212         int pos;
3213         switch (token.kind) {
3214         case MONKEYS_AT:
3215             pos = token.pos;
3216             nextToken();
3217             return annotation(pos, Tag.ANNOTATION);
3218         case LBRACE:
3219             pos = token.pos;
3220             accept(LBRACE);
3221             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3222             if (token.kind == COMMA) {
3223                 nextToken();
3224             } else if (token.kind != RBRACE) {
3225                 buf.append(annotationValue());
3226                 while (token.kind == COMMA) {
3227                     nextToken();
3228                     if (token.kind == RBRACE) break;
3229                     buf.append(annotationValue());
3230                 }
3231             }
3232             accept(RBRACE);
3233             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3234         default:
3235             selectExprMode();
3236             return term1();
3237         }
3238     }
3239 
3240     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3241      */
3242     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3243                                                                          JCExpression type,
3244                                                                          T vdefs,
3245                                                                          boolean localDecl)
3246     {
3247         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3248     }
3249 
3250     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3251      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3252      *
3253      *  @param reqInit  Is an initializer always required?
3254      *  @param dc       The documentation comment for the variable declarations, or null.
3255      */
3256     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3257                                                                      JCModifiers mods,
3258                                                                      JCExpression type,
3259                                                                      Name name,
3260                                                                      boolean reqInit,
3261                                                                      Comment dc,
3262                                                                      T vdefs,
3263                                                                      boolean localDecl)
3264     {
3265         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3266         vdefs.append(head);
3267         while (token.kind == COMMA) {
3268             // All but last of multiple declarators subsume a comma
3269             storeEnd((JCTree)vdefs.last(), token.endPos);
3270             nextToken();
3271             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3272         }
3273         return vdefs;
3274     }
3275 
3276     /** VariableDeclarator = Ident VariableDeclaratorRest
3277      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3278      */
3279     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3280         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3281     }
3282 
3283     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3284      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3285      *
3286      *  @param reqInit  Is an initializer always required?
3287      *  @param dc       The documentation comment for the variable declarations, or null.
3288      */
3289     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3290                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3291         type = bracketsOpt(type);
3292         JCExpression init = null;
3293         if (token.kind == EQ) {
3294             nextToken();
3295             init = variableInitializer();
3296         }
3297         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3298         JCTree elemType = TreeInfo.innermostType(type, true);
3299         int startPos = Position.NOPOS;
3300         if (elemType.hasTag(IDENT)) {
3301             Name typeName = ((JCIdent)elemType).name;
3302             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3303                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3304                     //error - &#39;var&#39; and arrays
3305                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3306                 } else {
3307                     if(compound)
3308                         //error - &#39;var&#39; in compound local var decl
3309                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3310                     startPos = TreeInfo.getStartPos(mods);
3311                     if (startPos == Position.NOPOS)
3312                         startPos = TreeInfo.getStartPos(type);
3313                     //implicit type
3314                     type = null;
3315                 }
3316             }
3317         }
3318         JCVariableDecl result =
3319             toP(F.at(pos).VarDef(mods, name, type, init));
3320         attach(result, dc);
3321         result.startPos = startPos;
3322         return result;
3323     }
3324 
3325     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3326         switch (e.getTag()) {
3327             case IDENT:
3328                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3329             case TYPEARRAY:
3330                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3331             default:
3332                 return null;
3333         }
3334     }
3335 
3336     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3337         if (name == names.var) {
3338             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3339                 return Source.JDK10;
3340             } else if (shouldWarn) {
3341                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3342             }
3343         }
3344         if (name == names.yield) {
3345             if (allowYieldStatement) {
3346                 return Source.JDK14;
3347             } else if (shouldWarn) {
3348                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3349             }
3350         }
3351         if (name == names.record) {
3352             if (allowRecords) {
3353                 return Source.JDK14;
3354             } else if (shouldWarn) {
3355                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3356             }
3357         }
3358         return null;
3359     }
3360 
3361     /** VariableDeclaratorId = Ident BracketsOpt
3362      */
3363     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3364         return variableDeclaratorId(mods, type, false);
3365     }
3366     //where
3367     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3368         int pos = token.pos;
3369         Name name;
3370         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3371             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3372             name = token.name();
3373             nextToken();
3374         } else {
3375             if (allowThisIdent ||
3376                 !lambdaParameter ||
3377                 LAX_IDENTIFIER.accepts(token.kind) ||
3378                 mods.flags != Flags.PARAMETER ||
3379                 mods.annotations.nonEmpty()) {
3380                 JCExpression pn = qualident(false);
3381                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3382                     name = ((JCIdent)pn).name;
3383                 } else {
3384                     if (allowThisIdent) {
3385                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3386                             log.error(token.pos, Errors.VarargsAndReceiver);
3387                         }
3388                         if (token.kind == LBRACKET) {
3389                             log.error(token.pos, Errors.ArrayAndReceiver);
3390                         }
3391                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3392                             log.error(token.pos, Errors.WrongReceiver);
3393                         }
3394                     }
3395                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3396                 }
3397             } else {
3398                 /** if it is a lambda parameter and the token kind is not an identifier,
3399                  *  and there are no modifiers or annotations, then this means that the compiler
3400                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3401                  *  var or explicit parameters. So we assign the error name to the parameter name
3402                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3403                  *  a higher level.
3404                  */
3405                 name = names.empty;
3406             }
3407         }
3408         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3409                 token.kind == LBRACKET) {
3410             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3411         }
3412         type = bracketsOpt(type);
3413 
3414         return toP(F.at(pos).VarDef(mods, name, type, null));
3415     }
3416 
3417     /** Resources = Resource { &quot;;&quot; Resources }
3418      */
3419     List&lt;JCTree&gt; resources() {
3420         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3421         defs.append(resource());
3422         while (token.kind == SEMI) {
3423             // All but last of multiple declarators must subsume a semicolon
3424             storeEnd(defs.last(), token.endPos);
3425             int semiColonPos = token.pos;
3426             nextToken();
3427             if (token.kind == RPAREN) { // Optional trailing semicolon
3428                                        // after last resource
3429                 break;
3430             }
3431             defs.append(resource());
3432         }
3433         return defs.toList();
3434     }
3435 
3436     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3437      *           | Expression
3438      */
3439     protected JCTree resource() {
3440         int startPos = token.pos;
3441         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3442             JCModifiers mods = optFinal(Flags.FINAL);
3443             JCExpression t = parseType(true);
3444             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3445         }
3446         JCExpression t = term(EXPR | TYPE);
3447         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3448             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3449             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3450         } else {
3451             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3452             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3453                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3454             }
3455 
3456             return t;
3457         }
3458     }
3459 
3460     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3461      */
3462     public JCTree.JCCompilationUnit parseCompilationUnit() {
3463         Token firstToken = token;
3464         JCModifiers mods = null;
3465         boolean consumedToplevelDoc = false;
3466         boolean seenImport = false;
3467         boolean seenPackage = false;
3468         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3469         if (token.kind == MONKEYS_AT)
3470             mods = modifiersOpt();
3471 
3472         if (token.kind == PACKAGE) {
3473             int packagePos = token.pos;
3474             List&lt;JCAnnotation&gt; annotations = List.nil();
3475             seenPackage = true;
3476             if (mods != null) {
3477                 checkNoMods(mods.flags);
3478                 annotations = mods.annotations;
3479                 mods = null;
3480             }
3481             nextToken();
3482             JCExpression pid = qualident(false);
3483             accept(SEMI);
3484             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3485             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3486             consumedToplevelDoc = true;
3487             defs.append(pd);
3488         }
3489 
3490         boolean checkForImports = true;
3491         boolean firstTypeDecl = true;
3492         while (token.kind != EOF) {
3493             if (token.pos &lt;= endPosTable.errorEndPos) {
3494                 // error recovery
3495                 skip(checkForImports, false, false, false);
3496                 if (token.kind == EOF)
3497                     break;
3498             }
3499             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3500                 seenImport = true;
3501                 defs.append(importDeclaration());
3502             } else {
3503                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3504                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3505                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3506                     consumedToplevelDoc = true;
3507                 }
3508                 if (mods != null || token.kind != SEMI)
3509                     mods = modifiersOpt(mods);
3510                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3511                     ModuleKind kind = ModuleKind.STRONG;
3512                     if (token.name() == names.open) {
3513                         kind = ModuleKind.OPEN;
3514                         nextToken();
3515                     }
3516                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3517                         if (mods != null) {
3518                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3519                         }
3520                         defs.append(moduleDecl(mods, kind, docComment));
3521                         consumedToplevelDoc = true;
3522                         break;
3523                     } else if (kind != ModuleKind.STRONG) {
3524                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3525                     }
3526                 }
3527                 JCTree def = typeDeclaration(mods, docComment);
3528                 if (def instanceof JCExpressionStatement)
3529                     def = ((JCExpressionStatement)def).expr;
3530                 defs.append(def);
3531                 if (def instanceof JCClassDecl)
3532                     checkForImports = false;
3533                 mods = null;
3534                 firstTypeDecl = false;
3535             }
3536         }
3537         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3538         if (!consumedToplevelDoc)
3539             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3540         if (defs.isEmpty())
3541             storeEnd(toplevel, S.prevToken().endPos);
3542         if (keepDocComments)
3543             toplevel.docComments = docComments;
3544         if (keepLineMap)
3545             toplevel.lineMap = S.getLineMap();
3546         this.endPosTable.setParser(null); // remove reference to parser
3547         toplevel.endPositions = this.endPosTable;
3548         return toplevel;
3549     }
3550 
3551     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3552         int pos = token.pos;
3553         checkSourceLevel(Feature.MODULES);
3554 
3555         nextToken();
3556         JCExpression name = qualident(false);
3557         List&lt;JCDirective&gt; directives = null;
3558 
3559         accept(LBRACE);
3560         directives = moduleDirectiveList();
3561         accept(RBRACE);
3562         accept(EOF);
3563 
3564         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3565         attach(result, dc);
3566         return result;
3567     }
3568 
3569     List&lt;JCDirective&gt; moduleDirectiveList() {
3570         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3571         while (token.kind == IDENTIFIER) {
3572             int pos = token.pos;
3573             if (token.name() == names.requires) {
3574                 nextToken();
3575                 boolean isTransitive = false;
3576                 boolean isStaticPhase = false;
3577             loop:
3578                 while (true) {
3579                     switch (token.kind) {
3580                         case IDENTIFIER:
3581                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3582                                 Token t1 = S.token(1);
3583                                 if (t1.kind == SEMI || t1.kind == DOT) {
3584                                     break loop;
3585                                 }
3586                                 isTransitive = true;
3587                                 break;
3588                             } else {
3589                                 break loop;
3590                             }
3591                         case STATIC:
3592                             if (isStaticPhase) {
3593                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3594                             }
3595                             isStaticPhase = true;
3596                             break;
3597                         default:
3598                             break loop;
3599                     }
3600                     nextToken();
3601                 }
3602                 JCExpression moduleName = qualident(false);
3603                 accept(SEMI);
3604                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3605             } else if (token.name() == names.exports || token.name() == names.opens) {
3606                 boolean exports = token.name() == names.exports;
3607                 nextToken();
3608                 JCExpression pkgName = qualident(false);
3609                 List&lt;JCExpression&gt; moduleNames = null;
3610                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3611                     nextToken();
3612                     moduleNames = qualidentList(false);
3613                 }
3614                 accept(SEMI);
3615                 JCDirective d;
3616                 if (exports) {
3617                     d = F.at(pos).Exports(pkgName, moduleNames);
3618                 } else {
3619                     d = F.at(pos).Opens(pkgName, moduleNames);
3620                 }
3621                 defs.append(toP(d));
3622             } else if (token.name() == names.provides) {
3623                 nextToken();
3624                 JCExpression serviceName = qualident(false);
3625                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3626                     nextToken();
3627                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3628                     accept(SEMI);
3629                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3630                 } else {
3631                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3632                     skip(false, false, false, false);
3633                 }
3634             } else if (token.name() == names.uses) {
3635                 nextToken();
3636                 JCExpression service = qualident(false);
3637                 accept(SEMI);
3638                 defs.append(toP(F.at(pos).Uses(service)));
3639             } else {
3640                 setErrorEndPos(pos);
3641                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3642                 break;
3643             }
3644         }
3645         return defs.toList();
3646     }
3647 
3648     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3649      */
3650     protected JCTree importDeclaration() {
3651         int pos = token.pos;
3652         nextToken();
3653         boolean importStatic = false;
3654         if (token.kind == STATIC) {
3655             importStatic = true;
3656             nextToken();
3657         }
3658         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3659         do {
3660             int pos1 = token.pos;
3661             accept(DOT);
3662             if (token.kind == STAR) {
3663                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3664                 nextToken();
3665                 break;
3666             } else {
3667                 pid = toP(F.at(pos1).Select(pid, ident()));
3668             }
3669         } while (token.kind == DOT);
3670         accept(SEMI);
3671         return toP(F.at(pos).Import(pid, importStatic));
3672     }
3673 
3674     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3675      *                  | &quot;;&quot;
3676      */
3677     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3678         int pos = token.pos;
3679         if (mods == null &amp;&amp; token.kind == SEMI) {
3680             nextToken();
3681             return toP(F.at(pos).Skip());
3682         } else {
3683             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3684         }
3685     }
3686 
3687     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3688      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3689      *  @param mods     Any modifiers starting the class or interface declaration
3690      *  @param dc       The documentation comment for the class, or null.
3691      */
3692     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3693         if (token.kind == CLASS) {
3694             return classDeclaration(mods, dc);
3695         } if (isRecordStart()) {
3696             return recordDeclaration(mods, dc);
3697         } else if (token.kind == INTERFACE) {
3698             return interfaceDeclaration(mods, dc);
3699         } else if (token.kind == ENUM) {
3700             return enumDeclaration(mods, dc);
3701         } else {
3702             int pos = token.pos;
3703             List&lt;JCTree&gt; errs;
3704             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3705                 checkSourceLevel(Feature.RECORDS);
3706                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3707                 return toP(F.Exec(erroneousTree));
3708             } else {
3709                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3710                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3711                     setErrorEndPos(token.pos);
3712                 } else {
3713                     errs = List.of(mods);
3714                 }
3715                 final JCErroneous erroneousTree;
3716                 if (parseModuleInfo) {
3717                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3718                 } else {
3719                     if (allowRecords) {
3720                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3721                     } else {
3722                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3723                     }
3724                 }
3725                 return toP(F.Exec(erroneousTree));
3726             }
3727         }
3728     }
3729 
3730     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3731      *                     [IMPLEMENTS TypeList] ClassBody
3732      *  @param mods    The modifiers starting the class declaration
3733      *  @param dc       The documentation comment for the class, or null.
3734      */
3735     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3736         int pos = token.pos;
3737         accept(CLASS);
3738         Name name = typeName();
3739 
3740         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3741 
3742         JCExpression extending = null;
3743         if (token.kind == EXTENDS) {
3744             nextToken();
3745             extending = parseType();
3746         }
3747         List&lt;JCExpression&gt; implementing = List.nil();
3748         if (token.kind == IMPLEMENTS) {
3749             nextToken();
3750             implementing = typeList();
3751         }
3752         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3753         JCClassDecl result = toP(F.at(pos).ClassDef(
3754             mods, name, typarams, extending, implementing, defs));
3755         attach(result, dc);
3756         return result;
3757     }
3758 
3759     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3760         int pos = token.pos;
3761         nextToken();
3762         mods.flags |= Flags.RECORD;
3763         Name name = typeName();
3764 
3765         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3766 
3767         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3768 
3769         List&lt;JCExpression&gt; implementing = List.nil();
3770         if (token.kind == IMPLEMENTS) {
3771             nextToken();
3772             implementing = typeList();
3773         }
3774         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3775         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3776         for (JCVariableDecl field : headerFields) {
3777             fields.add(field);
3778         }
3779         for (JCTree def : defs) {
3780             if (def.hasTag(METHODDEF)) {
3781                 JCMethodDecl methDef = (JCMethodDecl) def;
3782                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3783                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3784                     for (JCVariableDecl param : headerFields) {
3785                         tmpParams.add(F.at(param)
3786                                 // we will get flags plus annotations from the record component
3787                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3788                                 param.name, param.vartype, null));
3789                     }
3790                     methDef.params = tmpParams.toList();
3791                 }
3792             }
3793         }
3794         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3795             JCVariableDecl field = fields.get(i);
3796             defs = defs.prepend(field);
3797         }
3798         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3799         attach(result, dc);
3800         return result;
3801     }
3802 
3803     Name typeName() {
3804         int pos = token.pos;
3805         Name name = ident();
3806         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3807         if (source != null) {
3808             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3809         }
3810         return name;
3811     }
3812 
3813     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3814      *                         [EXTENDS TypeList] InterfaceBody
3815      *  @param mods    The modifiers starting the interface declaration
3816      *  @param dc       The documentation comment for the interface, or null.
3817      */
3818     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3819         int pos = token.pos;
3820         accept(INTERFACE);
3821 
3822         Name name = typeName();
3823 
3824         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3825 
3826         List&lt;JCExpression&gt; extending = List.nil();
3827         if (token.kind == EXTENDS) {
3828             nextToken();
3829             extending = typeList();
3830         }
3831         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3832         JCClassDecl result = toP(F.at(pos).ClassDef(
3833             mods, name, typarams, null, extending, defs));
3834         attach(result, dc);
3835         return result;
3836     }
3837 
3838     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3839      *  @param mods    The modifiers starting the enum declaration
3840      *  @param dc       The documentation comment for the enum, or null.
3841      */
3842     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3843         int pos = token.pos;
3844         accept(ENUM);
3845 
3846         Name name = typeName();
3847 
3848         List&lt;JCExpression&gt; implementing = List.nil();
3849         if (token.kind == IMPLEMENTS) {
3850             nextToken();
3851             implementing = typeList();
3852         }
3853 
3854         List&lt;JCTree&gt; defs = enumBody(name);
3855         mods.flags |= Flags.ENUM;
3856         JCClassDecl result = toP(F.at(pos).
3857             ClassDef(mods, name, List.nil(),
3858                      null, implementing, defs));
3859         attach(result, dc);
3860         return result;
3861     }
3862 
3863     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3864      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3865      */
3866     List&lt;JCTree&gt; enumBody(Name enumName) {
3867         accept(LBRACE);
3868         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3869         boolean wasSemi = false;
3870         boolean hasStructuralErrors = false;
3871         boolean wasError = false;
3872         if (token.kind == COMMA) {
3873             nextToken();
3874             if (token.kind == SEMI) {
3875                 wasSemi = true;
3876                 nextToken();
3877             } else if (token.kind != RBRACE) {
3878                 reportSyntaxError(S.prevToken().endPos,
3879                                   Errors.Expected2(RBRACE, SEMI));
3880                 wasError = true;
3881             }
3882         }
3883         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3884             if (token.kind == SEMI) {
3885                 accept(SEMI);
3886                 wasSemi = true;
3887                 if (token.kind == RBRACE || token.kind == EOF) break;
3888             }
3889             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3890             if (memberType == EnumeratorEstimate.UNKNOWN) {
3891                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3892                                      : EnumeratorEstimate.ENUMERATOR;
3893             }
3894             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3895                 wasError = false;
3896                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3897                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3898                     hasStructuralErrors = true;
3899                 }
3900                 defs.append(enumeratorDeclaration(enumName));
3901                 if (token.pos &lt;= endPosTable.errorEndPos) {
3902                     // error recovery
3903                    skip(false, true, true, false);
3904                 } else {
3905                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
3906                         if (token.kind == COMMA) {
3907                             nextToken();
3908                         } else {
3909                             setErrorEndPos(token.pos);
3910                             reportSyntaxError(S.prevToken().endPos,
3911                                               Errors.Expected3(COMMA, RBRACE, SEMI));
3912                             wasError = true;
3913                         }
3914                     }
3915                 }
3916             } else {
3917                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
3918                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
3919                     hasStructuralErrors = true;
3920                 }
3921                 wasError = false;
3922                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
3923                                                                 false, false));
3924                 if (token.pos &lt;= endPosTable.errorEndPos) {
3925                     // error recovery
3926                    skip(false, true, true, false);
3927                 }
3928             }
3929         }
3930         accept(RBRACE);
3931         return defs.toList();
3932     }
3933 
3934     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
3935         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {
3936             Token next = S.token(1);
3937             switch (next.kind) {
3938                 case LPAREN: case LBRACE: case COMMA: case SEMI:
3939                     return EnumeratorEstimate.ENUMERATOR;
3940             }
3941         }
3942         switch (token.kind) {
3943             case IDENTIFIER: case MONKEYS_AT: case LT:
3944                 return EnumeratorEstimate.UNKNOWN;
3945             default:
3946                 return EnumeratorEstimate.MEMBER;
3947         }
3948     }
3949 
3950     private enum EnumeratorEstimate {
3951         ENUMERATOR,
3952         MEMBER,
3953         UNKNOWN;
3954     }
3955 
3956     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3957      */
3958     JCTree enumeratorDeclaration(Name enumName) {
3959         Comment dc = token.comment(CommentStyle.JAVADOC);
3960         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3961         if (token.deprecatedFlag()) {
3962             flags |= Flags.DEPRECATED;
3963         }
3964         int pos = token.pos;
3965         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3966         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3967         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3968         int identPos = token.pos;
3969         Name name = ident();
3970         int createPos = token.pos;
3971         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3972             ? arguments() : List.nil();
3973         JCClassDecl body = null;
3974         if (token.kind == LBRACE) {
3975             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
3976             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
3977             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3978         }
3979         if (args.isEmpty() &amp;&amp; body == null)
3980             createPos = identPos;
3981         JCIdent ident = F.at(identPos).Ident(enumName);
3982         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
3983         if (createPos != identPos)
3984             storeEnd(create, S.prevToken().endPos);
3985         ident = F.at(identPos).Ident(enumName);
3986         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
3987         attach(result, dc);
3988         return result;
3989     }
3990 
3991     /** TypeList = Type {&quot;,&quot; Type}
3992      */
3993     List&lt;JCExpression&gt; typeList() {
3994         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
3995         ts.append(parseType());
3996         while (token.kind == COMMA) {
3997             nextToken();
3998             ts.append(parseType());
3999         }
4000         return ts.toList();
4001     }
4002 
4003     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4004      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4005      */
4006     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4007         accept(LBRACE);
4008         if (token.pos &lt;= endPosTable.errorEndPos) {
4009             // error recovery
4010             skip(false, true, false, false);
4011             if (token.kind == LBRACE)
4012                 nextToken();
4013         }
4014         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4015         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4016             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4017             if (token.pos &lt;= endPosTable.errorEndPos) {
4018                // error recovery
4019                skip(false, true, true, false);
4020            }
4021         }
4022         accept(RBRACE);
4023         return defs.toList();
4024     }
4025 
4026     /** ClassBodyDeclaration =
4027      *      &quot;;&quot;
4028      *    | [STATIC] Block
4029      *    | ModifiersOpt
4030      *      ( Type Ident
4031      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4032      *      | VOID Ident VoidMethodDeclaratorRest
4033      *      | TypeParameters [Annotations]
4034      *        ( Type Ident MethodDeclaratorRest
4035      *        | VOID Ident VoidMethodDeclaratorRest
4036      *        )
4037      *      | Ident ConstructorDeclaratorRest
4038      *      | TypeParameters Ident ConstructorDeclaratorRest
4039      *      | ClassOrInterfaceOrEnumDeclaration
4040      *      )
4041      *  InterfaceBodyDeclaration =
4042      *      &quot;;&quot;
4043      *    | ModifiersOpt
4044      *      ( Type Ident
4045      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4046      *      | VOID Ident MethodDeclaratorRest
4047      *      | TypeParameters [Annotations]
4048      *        ( Type Ident MethodDeclaratorRest
4049      *        | VOID Ident VoidMethodDeclaratorRest
4050      *        )
4051      *      | ClassOrInterfaceOrEnumDeclaration
4052      *      )
4053      *
4054      */
4055     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4056         if (token.kind == SEMI) {
4057             nextToken();
4058             return List.nil();
4059         } else {
4060             Comment dc = token.comment(CommentStyle.JAVADOC);
4061             int pos = token.pos;
4062             JCModifiers mods = modifiersOpt();
4063             if (token.kind == CLASS ||
4064                 allowRecords &amp;&amp; isRecordStart() ||
4065                 token.kind == INTERFACE ||
4066                 token.kind == ENUM) {
4067                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4068             } else if (token.kind == LBRACE &amp;&amp;
4069                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4070                        mods.annotations.isEmpty()) {
4071                 if (isInterface) {
4072                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4073                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4074                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4075                 }
4076                 return List.of(block(pos, mods.flags));
4077             } else {
4078                 pos = token.pos;
4079                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4080                 // if there are type parameters but no modifiers, save the start
4081                 // position of the method in the modifiers.
4082                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4083                     mods.pos = pos;
4084                     storeEnd(mods, pos);
4085                 }
4086                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4087 
4088                 if (annosAfterParams.nonEmpty()) {
4089                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4090                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4091                     if (mods.pos == Position.NOPOS)
4092                         mods.pos = mods.annotations.head.pos;
4093                 }
4094 
4095                 Token tk = token;
4096                 pos = token.pos;
4097                 JCExpression type;
4098                 boolean isVoid = token.kind == VOID;
4099                 if (isVoid) {
4100                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4101                     nextToken();
4102                 } else {
4103                     // method returns types are un-annotated types
4104                     type = unannotatedType(false);
4105                 }
4106                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4107                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4108                     if (isInterface || tk.name() != className)
4109                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4110                     else if (annosAfterParams.nonEmpty())
4111                         illegal(annosAfterParams.head.pos);
4112                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4113                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4114                     }
4115                     return List.of(methodDeclaratorRest(
4116                         pos, mods, null, names.init, typarams,
4117                         isInterface, true, isRecord, dc));
4118                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4119                     // trying to define a compact constructor with a throws clause
4120                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4121                             Errors.InvalidCanonicalConstructorInRecord(
4122                                     Fragments.Compact,
4123                                     className,
4124                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4125                     skip(false, true, false, false);
4126                     return List.of(methodDeclaratorRest(
4127                             pos, mods, null, names.init, typarams,
4128                             isInterface, true, isRecord, dc));
4129                 } else {
4130                     pos = token.pos;
4131                     Name name = ident();
4132                     if (token.kind == LPAREN) {
4133                         return List.of(methodDeclaratorRest(
4134                             pos, mods, type, name, typarams,
4135                             isInterface, isVoid, false, dc));
4136                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4137                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4138                         List&lt;JCTree&gt; defs =
4139                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4140                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4141                         accept(SEMI);
4142                         storeEnd(defs.last(), S.prevToken().endPos);
4143                         return defs;
4144                     } else {
4145                             int errPos = pos;
4146                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4147                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4148                             accept(SEMI);
4149                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4150                         }
4151                     } else {
4152                         pos = token.pos;
4153                         List&lt;JCTree&gt; err;
4154                         if (isVoid || typarams.nonEmpty()) {
4155                             JCMethodDecl m =
4156                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4157                                                             List.nil(), List.nil(), null, null));
4158                             attach(m, dc);
4159                             err = List.of(m);
4160                         } else {
4161                             err = List.nil();
4162                         }
4163                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4164                     }
4165                 }
4166             }
4167         }
4168     }
4169 
4170     protected boolean isRecordStart() {
4171      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4172             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4173              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4174              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4175           checkSourceLevel(Feature.RECORDS);
4176           return true;
4177     } else {
4178        return false;
4179    }
4180 }
4181 
4182     /** MethodDeclaratorRest =
4183      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4184      *  VoidMethodDeclaratorRest =
4185      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4186      *  ConstructorDeclaratorRest =
4187      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4188      */
4189     protected JCTree methodDeclaratorRest(int pos,
4190                               JCModifiers mods,
4191                               JCExpression type,
4192                               Name name,
4193                               List&lt;JCTypeParameter&gt; typarams,
4194                               boolean isInterface, boolean isVoid,
4195                               boolean isRecord,
4196                               Comment dc) {
4197         if (isInterface) {
4198             if ((mods.flags &amp; Flags.STATIC) != 0) {
4199                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4200             }
4201             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4202                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4203             }
4204         }
4205         JCVariableDecl prevReceiverParam = this.receiverParam;
4206         try {
4207             this.receiverParam = null;
4208             // Parsing formalParameters sets the receiverParam, if present
4209             List&lt;JCVariableDecl&gt; params = List.nil();
4210             List&lt;JCExpression&gt; thrown = List.nil();
4211             if (!isRecord || name != names.init || token.kind == LPAREN) {
4212                 params = formalParameters();
4213                 if (!isVoid) type = bracketsOpt(type);
4214                 if (token.kind == THROWS) {
4215                     nextToken();
4216                     thrown = qualidentList(true);
4217                 }
4218             }
4219             JCBlock body = null;
4220             JCExpression defaultValue;
4221             if (token.kind == LBRACE) {
4222                 body = block();
4223                 defaultValue = null;
4224             } else {
4225                 if (token.kind == DEFAULT) {
4226                     accept(DEFAULT);
4227                     defaultValue = annotationValue();
4228                 } else {
4229                     defaultValue = null;
4230                 }
4231                 accept(SEMI);
4232                 if (token.pos &lt;= endPosTable.errorEndPos) {
4233                     // error recovery
4234                     skip(false, true, false, false);
4235                     if (token.kind == LBRACE) {
4236                         body = block();
4237                     }
4238                 }
4239             }
4240 
4241             JCMethodDecl result =
4242                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4243                                             receiverParam, params, thrown,
4244                                             body, defaultValue));
4245             attach(result, dc);
4246             return result;
4247         } finally {
4248             this.receiverParam = prevReceiverParam;
4249         }
4250     }
4251 
4252     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4253      */
4254     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4255         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4256 
4257         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4258         JCExpression qi = qualident(allowAnnos);
4259         if (!typeAnnos.isEmpty()) {
4260             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4261             ts.append(at);
4262         } else {
4263             ts.append(qi);
4264         }
4265         while (token.kind == COMMA) {
4266             nextToken();
4267 
4268             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4269             qi = qualident(allowAnnos);
4270             if (!typeAnnos.isEmpty()) {
4271                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4272                 ts.append(at);
4273             } else {
4274                 ts.append(qi);
4275             }
4276         }
4277         return ts.toList();
4278     }
4279 
4280     /**
4281      *  {@literal
4282      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4283      *  }
4284      */
4285     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4286         if (token.kind == LT) {
4287             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4288             nextToken();
4289             typarams.append(typeParameter());
4290             while (token.kind == COMMA) {
4291                 nextToken();
4292                 typarams.append(typeParameter());
4293             }
4294             accept(GT);
4295             return typarams.toList();
4296         } else {
4297             return List.nil();
4298         }
4299     }
4300 
4301     /**
4302      *  {@literal
4303      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4304      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4305      *  TypeVariable = Ident
4306      *  }
4307      */
4308     JCTypeParameter typeParameter() {
4309         int pos = token.pos;
4310         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4311         Name name = typeName();
4312         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4313         if (token.kind == EXTENDS) {
4314             nextToken();
4315             bounds.append(parseType());
4316             while (token.kind == AMP) {
4317                 nextToken();
4318                 bounds.append(parseType());
4319             }
4320         }
4321         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4322     }
4323 
4324     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4325      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4326      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4327      */
4328     List&lt;JCVariableDecl&gt; formalParameters() {
4329         return formalParameters(false, false);
4330     }
4331     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4332         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4333         JCVariableDecl lastParam;
4334         accept(LPAREN);
4335         if (token.kind != RPAREN) {
4336             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4337             lastParam = formalParameter(lambdaParameters, recordComponents);
4338             if (lastParam.nameexpr != null) {
4339                 this.receiverParam = lastParam;
4340             } else {
4341                 params.append(lastParam);
4342             }
4343             this.allowThisIdent = false;
4344             while (token.kind == COMMA) {
4345                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4346                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4347                 }
4348                 nextToken();
4349                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4350             }
4351         }
4352         if (token.kind == RPAREN) {
4353             nextToken();
4354         } else {
4355             setErrorEndPos(token.pos);
4356             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4357         }
4358         return params.toList();
4359     }
4360 
4361     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4362         if (hasParens) {
4363             accept(LPAREN);
4364         }
4365         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4366         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4367             params.append(implicitParameter());
4368             while (token.kind == COMMA) {
4369                 nextToken();
4370                 params.append(implicitParameter());
4371             }
4372         }
4373         if (hasParens) {
4374             accept(RPAREN);
4375         }
4376         return params.toList();
4377     }
4378 
4379     JCModifiers optFinal(long flags) {
4380         JCModifiers mods = modifiersOpt();
4381         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4382         mods.flags |= flags;
4383         return mods;
4384     }
4385 
4386     /**
4387      * Inserts the annotations (and possibly a new array level)
4388      * to the left-most type in an array or nested type.
4389      *
4390      * When parsing a type like {@code @B Outer.Inner @A []}, the
4391      * {@code @A} annotation should target the array itself, while
4392      * {@code @B} targets the nested type {@code Outer}.
4393      *
4394      * Currently the parser parses the annotation first, then
4395      * the array, and then inserts the annotation to the left-most
4396      * nested type.
4397      *
4398      * When {@code createNewLevel} is true, then a new array
4399      * level is inserted as the most inner type, and have the
4400      * annotations target it.  This is useful in the case of
4401      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4402      * first parses the type {@code String @A []} then inserts
4403      * a new array level with {@code @B} annotation.
4404      */
4405     private JCExpression insertAnnotationsToMostInner(
4406             JCExpression type, List&lt;JCAnnotation&gt; annos,
4407             boolean createNewLevel) {
4408         int origEndPos = getEndPos(type);
4409         JCExpression mostInnerType = type;
4410         JCArrayTypeTree mostInnerArrayType = null;
4411         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4412             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4413             mostInnerType = mostInnerArrayType.elemtype;
4414         }
4415 
4416         if (createNewLevel) {
4417             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4418         }
4419 
4420         JCExpression mostInnerTypeToReturn = mostInnerType;
4421         if (annos.nonEmpty()) {
4422             JCExpression lastToModify = mostInnerType;
4423 
4424             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4425                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4426                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4427                     lastToModify = mostInnerType;
4428                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4429                 }
4430                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4431                     lastToModify = mostInnerType;
4432                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4433                 }
4434             }
4435 
4436             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4437 
4438             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4439                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4440             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4441                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4442             } else {
4443                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4444                 mostInnerTypeToReturn = mostInnerType;
4445             }
4446         }
4447 
4448         if (mostInnerArrayType == null) {
4449             return mostInnerTypeToReturn;
4450         } else {
4451             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4452             storeEnd(type, origEndPos);
4453             return type;
4454         }
4455     }
4456 
4457     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4458      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4459      */
4460     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4461         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4462         if (recordComponent &amp;&amp; mods.flags != 0) {
4463             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4464         }
4465         if (recordComponent) {
4466             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4467         }
4468         // need to distinguish between vararg annos and array annos
4469         // look at typeAnnotationsPushedBack comment
4470         this.permitTypeAnnotationsPushBack = true;
4471         JCExpression type = parseType(lambdaParameter);
4472         this.permitTypeAnnotationsPushBack = false;
4473 
4474         if (token.kind == ELLIPSIS) {
4475             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4476             typeAnnotationsPushedBack = List.nil();
4477             mods.flags |= Flags.VARARGS;
4478             // insert var arg type annotations
4479             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4480             nextToken();
4481         } else {
4482             // if not a var arg, then typeAnnotationsPushedBack should be null
4483             if (typeAnnotationsPushedBack.nonEmpty()) {
4484                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4485             }
4486             typeAnnotationsPushedBack = List.nil();
4487         }
4488         return variableDeclaratorId(mods, type, lambdaParameter);
4489     }
4490 
4491     protected JCVariableDecl implicitParameter() {
4492         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4493         return variableDeclaratorId(mods, null, true);
4494     }
4495 
4496 /* ---------- auxiliary methods -------------- */
4497     /** Check that given tree is a legal expression statement.
4498      */
4499     protected JCExpression checkExprStat(JCExpression t) {
4500         if (!TreeInfo.isExpressionStatement(t)) {
4501             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4502             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4503             return ret;
4504         } else {
4505             return t;
4506         }
4507     }
4508 
4509     /** Return precedence of operator represented by token,
4510      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4511      */
4512     static int prec(TokenKind token) {
4513         JCTree.Tag oc = optag(token);
4514         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4515     }
4516 
4517     /**
4518      * Return the lesser of two positions, making allowance for either one
4519      * being unset.
4520      */
4521     static int earlier(int pos1, int pos2) {
4522         if (pos1 == Position.NOPOS)
4523             return pos2;
4524         if (pos2 == Position.NOPOS)
4525             return pos1;
4526         return (pos1 &lt; pos2 ? pos1 : pos2);
4527     }
4528 
4529     /** Return operation tag of binary operator represented by token,
4530      *  No_TAG if token is not a binary operator.
4531      */
4532     static JCTree.Tag optag(TokenKind token) {
4533         switch (token) {
4534         case BARBAR:
4535             return OR;
4536         case AMPAMP:
4537             return AND;
4538         case BAR:
4539             return BITOR;
4540         case BAREQ:
4541             return BITOR_ASG;
4542         case CARET:
4543             return BITXOR;
4544         case CARETEQ:
4545             return BITXOR_ASG;
4546         case AMP:
4547             return BITAND;
4548         case AMPEQ:
4549             return BITAND_ASG;
4550         case EQEQ:
4551             return JCTree.Tag.EQ;
4552         case BANGEQ:
4553             return NE;
4554         case LT:
4555             return JCTree.Tag.LT;
4556         case GT:
4557             return JCTree.Tag.GT;
4558         case LTEQ:
4559             return LE;
4560         case GTEQ:
4561             return GE;
4562         case LTLT:
4563             return SL;
4564         case LTLTEQ:
4565             return SL_ASG;
4566         case GTGT:
4567             return SR;
4568         case GTGTEQ:
4569             return SR_ASG;
4570         case GTGTGT:
4571             return USR;
4572         case GTGTGTEQ:
4573             return USR_ASG;
4574         case PLUS:
4575             return JCTree.Tag.PLUS;
4576         case PLUSEQ:
4577             return PLUS_ASG;
4578         case SUB:
4579             return MINUS;
4580         case SUBEQ:
4581             return MINUS_ASG;
4582         case STAR:
4583             return MUL;
4584         case STAREQ:
4585             return MUL_ASG;
4586         case SLASH:
4587             return DIV;
4588         case SLASHEQ:
4589             return DIV_ASG;
4590         case PERCENT:
4591             return MOD;
4592         case PERCENTEQ:
4593             return MOD_ASG;
4594         case INSTANCEOF:
4595             return TYPETEST;
4596         default:
4597             return NO_TAG;
4598         }
4599     }
4600 
4601     /** Return operation tag of unary operator represented by token,
4602      *  No_TAG if token is not a binary operator.
4603      */
4604     static JCTree.Tag unoptag(TokenKind token) {
4605         switch (token) {
4606         case PLUS:
4607             return POS;
4608         case SUB:
4609             return NEG;
4610         case BANG:
4611             return NOT;
4612         case TILDE:
4613             return COMPL;
4614         case PLUSPLUS:
4615             return PREINC;
4616         case SUBSUB:
4617             return PREDEC;
4618         default:
4619             return NO_TAG;
4620         }
4621     }
4622 
4623     /** Return type tag of basic type represented by token,
4624      *  NONE if token is not a basic type identifier.
4625      */
4626     static TypeTag typetag(TokenKind token) {
4627         switch (token) {
4628         case BYTE:
4629             return TypeTag.BYTE;
4630         case CHAR:
4631             return TypeTag.CHAR;
4632         case SHORT:
4633             return TypeTag.SHORT;
4634         case INT:
4635             return TypeTag.INT;
4636         case LONG:
4637             return TypeTag.LONG;
4638         case FLOAT:
4639             return TypeTag.FLOAT;
4640         case DOUBLE:
4641             return TypeTag.DOUBLE;
4642         case BOOLEAN:
4643             return TypeTag.BOOLEAN;
4644         default:
4645             return TypeTag.NONE;
4646         }
4647     }
4648 
4649     void checkSourceLevel(Feature feature) {
4650         checkSourceLevel(token.pos, feature);
4651     }
4652 
4653     protected void checkSourceLevel(int pos, Feature feature) {
4654         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4655             //preview feature without --preview flag, error
4656             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4657         } else if (!feature.allowedInSource(source)) {
4658             //incompatible source level, error
4659             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4660         } else if (preview.isPreview(feature)) {
4661             //use of preview feature, warn
4662             preview.warnPreview(pos, feature);
4663         }
4664     }
4665 
4666     /*
4667      * a functional source tree and end position mappings
4668      */
4669     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4670 
4671         private final IntHashTable endPosMap;
4672 
4673         SimpleEndPosTable(JavacParser parser) {
4674             super(parser);
4675             endPosMap = new IntHashTable();
4676         }
4677 
4678         public void storeEnd(JCTree tree, int endpos) {
4679             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4680                                  endPosMap.lookup(tree));
4681         }
4682 
4683         protected &lt;T extends JCTree&gt; T to(T t) {
4684             storeEnd(t, parser.token.endPos);
4685             return t;
4686         }
4687 
4688         protected &lt;T extends JCTree&gt; T toP(T t) {
4689             storeEnd(t, parser.S.prevToken().endPos);
4690             return t;
4691         }
4692 
4693         public int getEndPos(JCTree tree) {
4694             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4695             // As long as Position.NOPOS==-1, this just returns value.
4696             return (value == -1) ? Position.NOPOS : value;
4697         }
4698 
4699         public int replaceTree(JCTree oldTree, JCTree newTree) {
4700             int pos = endPosMap.remove(oldTree);
4701             if (pos != -1) {
4702                 storeEnd(newTree, pos);
4703                 return pos;
4704             }
4705             return Position.NOPOS;
4706         }
4707     }
4708 
4709     /*
4710      * a default skeletal implementation without any mapping overhead.
4711      */
4712     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4713 
4714         EmptyEndPosTable(JavacParser parser) {
4715             super(parser);
4716         }
4717 
4718         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4719 
4720         protected &lt;T extends JCTree&gt; T to(T t) {
4721             return t;
4722         }
4723 
4724         protected &lt;T extends JCTree&gt; T toP(T t) {
4725             return t;
4726         }
4727 
4728         public int getEndPos(JCTree tree) {
4729             return Position.NOPOS;
4730         }
4731 
4732         public int replaceTree(JCTree oldTree, JCTree newTree) {
4733             return Position.NOPOS;
4734         }
4735 
4736     }
4737 
4738     protected static abstract class AbstractEndPosTable implements EndPosTable {
4739         /**
4740          * The current parser.
4741          */
4742         protected JavacParser parser;
4743 
4744         /**
4745          * Store the last error position.
4746          */
4747         public int errorEndPos = Position.NOPOS;
4748 
4749         public AbstractEndPosTable(JavacParser parser) {
4750             this.parser = parser;
4751         }
4752 
4753         /**
4754          * Store current token&#39;s ending position for a tree, the value of which
4755          * will be the greater of last error position and the ending position of
4756          * the current token.
4757          * @param t The tree.
4758          */
4759         protected abstract &lt;T extends JCTree&gt; T to(T t);
4760 
4761         /**
4762          * Store current token&#39;s ending position for a tree, the value of which
4763          * will be the greater of last error position and the ending position of
4764          * the previous token.
4765          * @param t The tree.
4766          */
4767         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4768 
4769         /**
4770          * Set the error position during the parsing phases, the value of which
4771          * will be set only if it is greater than the last stored error position.
4772          * @param errPos The error position
4773          */
4774         public void setErrorEndPos(int errPos) {
4775             if (errPos &gt; errorEndPos) {
4776                 errorEndPos = errPos;
4777             }
4778         }
4779 
4780         public void setParser(JavacParser parser) {
4781             this.parser = parser;
4782         }
4783     }
4784 }
<a name="13" id="anc13"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="13" type="hidden" />
</body>
</html>
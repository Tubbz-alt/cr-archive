<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 
  32 import javax.lang.model.element.Modifier;
  33 import javax.lang.model.type.TypeKind;
  34 import javax.tools.JavaFileObject;
  35 
  36 import com.sun.source.tree.*;
  37 import com.sun.tools.javac.code.*;
  38 import com.sun.tools.javac.code.Directive.RequiresDirective;
  39 import com.sun.tools.javac.code.Scope.*;
  40 import com.sun.tools.javac.code.Symbol.*;
  41 import com.sun.tools.javac.util.*;
  42 import com.sun.tools.javac.util.DefinedBy.Api;
  43 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  44 import com.sun.tools.javac.util.List;
  45 
  46 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  47 
  48 import javax.tools.JavaFileManager.Location;
  49 
  50 import com.sun.source.tree.ModuleTree.ModuleKind;
  51 import com.sun.tools.javac.code.Directive.ExportsDirective;
  52 import com.sun.tools.javac.code.Directive.OpensDirective;
  53 import com.sun.tools.javac.code.Type.ModuleType;
  54 
  55 /**
  56  * Root class for abstract syntax tree nodes. It provides definitions
  57  * for specific tree nodes as subclasses nested inside.
  58  *
  59  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  60  * only tree fields for the syntactic subcomponents of the node.  Some
  61  * classes that represent identifier uses or definitions also define a
  62  * Symbol field that denotes the represented identifier.  Classes for
  63  * non-local jumps also carry the jump target as a field.  The root
  64  * class Tree itself defines fields for the tree&#39;s type and position.
  65  * No other fields are kept in a tree node; instead parameters are
  66  * passed to methods accessing the node.
  67  *
  68  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  69  * method defined in subclasses is `visit&#39; which applies a given
  70  * visitor to the tree. The actual tree processing is done by visitor
  71  * classes in other packages. The abstract class Visitor, as well as
  72  * an Factory interface for trees, are defined as inner classes in
  73  * Tree.
  74  *
  75  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  76  * classes should, by convention, start with JC (javac).
  77  *
  78  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  79  * If you write code that depends on this, you do so at your own risk.
  80  * This code and its internal interfaces are subject to change or
  81  * deletion without notice.&lt;/b&gt;
  82  *
  83  * @see TreeMaker
  84  * @see TreeInfo
  85  * @see TreeTranslator
  86  * @see Pretty
  87  */
  88 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  89 
  90     /* Tree tag values, identifying kinds of trees */
  91     public enum Tag {
  92         /** For methods that return an invalid tag if a given condition is not met
  93          */
  94         NO_TAG,
  95 
  96         /** Toplevel nodes, of type TopLevel, representing entire source files.
  97         */
  98         TOPLEVEL,
  99 
 100         /** Package level definitions.
 101          */
 102         PACKAGEDEF,
 103 
 104         /** Import clauses, of type Import.
 105          */
 106         IMPORT,
 107 
 108         /** Class definitions, of type ClassDef.
 109          */
 110         CLASSDEF,
 111 
 112         /** Method definitions, of type MethodDef.
 113          */
 114         METHODDEF,
 115 
 116         /** Variable definitions, of type VarDef.
 117          */
 118         VARDEF,
 119 
 120         /** The no-op statement &quot;;&quot;, of type Skip
 121          */
 122         SKIP,
 123 
 124         /** Blocks, of type Block.
 125          */
 126         BLOCK,
 127 
 128         /** Do-while loops, of type DoLoop.
 129          */
 130         DOLOOP,
 131 
 132         /** While-loops, of type WhileLoop.
 133          */
 134         WHILELOOP,
 135 
 136         /** For-loops, of type ForLoop.
 137          */
 138         FORLOOP,
 139 
 140         /** Foreach-loops, of type ForeachLoop.
 141          */
 142         FOREACHLOOP,
 143 
 144         /** Labelled statements, of type Labelled.
 145          */
 146         LABELLED,
 147 
 148         /** Switch statements, of type Switch.
 149          */
 150         SWITCH,
 151 
 152         /** Case parts in switch statements/expressions, of type Case.
 153          */
 154         CASE,
 155 
 156         /** Switch expression statements, of type Switch.
 157          */
 158         SWITCH_EXPRESSION,
 159 
 160         /** Synchronized statements, of type Synchronized.
 161          */
 162         SYNCHRONIZED,
 163 
 164         /** Try statements, of type Try.
 165          */
 166         TRY,
 167 
 168         /** Catch clauses in try statements, of type Catch.
 169          */
 170         CATCH,
 171 
 172         /** Conditional expressions, of type Conditional.
 173          */
 174         CONDEXPR,
 175 
 176         /** Conditional statements, of type If.
 177          */
 178         IF,
 179 
 180         /** Expression statements, of type Exec.
 181          */
 182         EXEC,
 183 
 184         /** Break statements, of type Break.
 185          */
 186         BREAK,
 187 
 188         /** Yield statements, of type Yield.
 189          */
 190         YIELD,
 191 
 192         /** Continue statements, of type Continue.
 193          */
 194         CONTINUE,
 195 
 196         /** Return statements, of type Return.
 197          */
 198         RETURN,
 199 
 200         /** Throw statements, of type Throw.
 201          */
 202         THROW,
 203 
 204         /** Assert statements, of type Assert.
 205          */
 206         ASSERT,
 207 
 208         /** Method invocation expressions, of type Apply.
 209          */
 210         APPLY,
 211 
 212         /** Class instance creation expressions, of type NewClass.
 213          */
 214         NEWCLASS,
 215 
 216         /** Array creation expressions, of type NewArray.
 217          */
 218         NEWARRAY,
 219 
 220         /** Lambda expression, of type Lambda.
 221          */
 222         LAMBDA,
 223 
 224         /** Parenthesized subexpressions, of type Parens.
 225          */
 226         PARENS,
 227 
 228         /** Assignment expressions, of type Assign.
 229          */
 230         ASSIGN,
 231 
 232         /** Type cast expressions, of type TypeCast.
 233          */
 234         TYPECAST,
 235 
 236         /** Type test expressions, of type TypeTest.
 237          */
 238         TYPETEST,
 239 
 240         /** Patterns.
 241          */
 242         BINDINGPATTERN,
 243 
 244         DECONSTRUCTIONPATTERN,
 245 
 246         /** Indexed array expressions, of type Indexed.
 247          */
 248         INDEXED,
 249 
 250         /** Selections, of type Select.
 251          */
 252         SELECT,
 253 
 254         /** Member references, of type Reference.
 255          */
 256         REFERENCE,
 257 
 258         /** Simple identifiers, of type Ident.
 259          */
 260         IDENT,
 261 
 262         /** Literals, of type Literal.
 263          */
 264         LITERAL,
 265 
 266         /** Basic type identifiers, of type TypeIdent.
 267          */
 268         TYPEIDENT,
 269 
 270         /** Array types, of type TypeArray.
 271          */
 272         TYPEARRAY,
 273 
 274         /** Parameterized types, of type TypeApply.
 275          */
 276         TYPEAPPLY,
 277 
 278         /** Union types, of type TypeUnion.
 279          */
 280         TYPEUNION,
 281 
 282         /** Intersection types, of type TypeIntersection.
 283          */
 284         TYPEINTERSECTION,
 285 
 286         /** Formal type parameters, of type TypeParameter.
 287          */
 288         TYPEPARAMETER,
 289 
 290         /** Type argument.
 291          */
 292         WILDCARD,
 293 
 294         /** Bound kind: extends, super, exact, or unbound
 295          */
 296         TYPEBOUNDKIND,
 297 
 298         /** metadata: Annotation.
 299          */
 300         ANNOTATION,
 301 
 302         /** metadata: Type annotation.
 303          */
 304         TYPE_ANNOTATION,
 305 
 306         /** metadata: Modifiers
 307          */
 308         MODIFIERS,
 309 
 310         /** An annotated type tree.
 311          */
 312         ANNOTATED_TYPE,
 313 
 314         /** Error trees, of type Erroneous.
 315          */
 316         ERRONEOUS,
 317 
 318         /** Unary operators, of type Unary.
 319          */
 320         POS,                             // +
 321         NEG,                             // -
 322         NOT,                             // !
 323         COMPL,                           // ~
 324         PREINC,                          // ++ _
 325         PREDEC,                          // -- _
 326         POSTINC,                         // _ ++
 327         POSTDEC,                         // _ --
 328 
 329         /** unary operator for null reference checks, only used internally.
 330          */
 331         NULLCHK,
 332 
 333         /** Binary operators, of type Binary.
 334          */
 335         OR,                              // ||
 336         AND,                             // &amp;&amp;
 337         BITOR,                           // |
 338         BITXOR,                          // ^
 339         BITAND,                          // &amp;
 340         EQ,                              // ==
 341         NE,                              // !=
 342         LT,                              // &lt;
 343         GT,                              // &gt;
 344         LE,                              // &lt;=
 345         GE,                              // &gt;=
 346         SL,                              // &lt;&lt;
 347         SR,                              // &gt;&gt;
 348         USR,                             // &gt;&gt;&gt;
 349         PLUS,                            // +
 350         MINUS,                           // -
 351         MUL,                             // *
 352         DIV,                             // /
 353         MOD,                             // %
 354 
 355         /** Assignment operators, of type Assignop.
 356          */
 357         BITOR_ASG(BITOR),                // |=
 358         BITXOR_ASG(BITXOR),              // ^=
 359         BITAND_ASG(BITAND),              // &amp;=
 360 
 361         SL_ASG(SL),                      // &lt;&lt;=
 362         SR_ASG(SR),                      // &gt;&gt;=
 363         USR_ASG(USR),                    // &gt;&gt;&gt;=
 364         PLUS_ASG(PLUS),                  // +=
 365         MINUS_ASG(MINUS),                // -=
 366         MUL_ASG(MUL),                    // *=
 367         DIV_ASG(DIV),                    // /=
 368         MOD_ASG(MOD),                    // %=
 369 
 370         MODULEDEF,
 371         EXPORTS,
 372         OPENS,
 373         PROVIDES,
 374         REQUIRES,
 375         USES,
 376 
 377         /** A synthetic let expression, of type LetExpr.
 378          */
 379         LETEXPR;                         // ala scheme
 380 
 381         private final Tag noAssignTag;
 382 
 383         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 384 
 385         private Tag(Tag noAssignTag) {
 386             this.noAssignTag = noAssignTag;
 387         }
 388 
 389         private Tag() {
 390             this(null);
 391         }
 392 
 393         public static int getNumberOfOperators() {
 394             return numberOfOperators;
 395         }
 396 
 397         public Tag noAssignOp() {
 398             if (noAssignTag != null)
 399                 return noAssignTag;
 400             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 401         }
 402 
 403         public boolean isPostUnaryOp() {
 404             return (this == POSTINC || this == POSTDEC);
 405         }
 406 
 407         public boolean isIncOrDecUnaryOp() {
 408             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 409         }
 410 
 411         public boolean isAssignop() {
 412             return noAssignTag != null;
 413         }
 414 
 415         public int operatorIndex() {
 416             return (this.ordinal() - POS.ordinal());
 417         }
 418     }
 419 
 420     /* The (encoded) position in the source file. @see util.Position.
 421      */
 422     public int pos;
 423 
 424     /* The type of this node.
 425      */
 426     public Type type;
 427 
 428     /* The tag of this node -- one of the constants declared above.
 429      */
 430     public abstract Tag getTag();
 431 
 432     /* Returns true if the tag of this node is equals to tag.
 433      */
 434     public boolean hasTag(Tag tag) {
 435         return tag == getTag();
 436     }
 437 
 438     /** Convert a tree to a pretty-printed string. */
 439     @Override
 440     public String toString() {
 441         StringWriter s = new StringWriter();
 442         try {
 443             new Pretty(s, false).printExpr(this);
 444         }
 445         catch (IOException e) {
 446             // should never happen, because StringWriter is defined
 447             // never to throw any IOExceptions
 448             throw new AssertionError(e);
 449         }
 450         return s.toString();
 451     }
 452 
 453     /** Set position field and return this tree.
 454      */
 455     public JCTree setPos(int pos) {
 456         this.pos = pos;
 457         return this;
 458     }
 459 
 460     /** Set type field and return this tree.
 461      */
 462     public JCTree setType(Type type) {
 463         this.type = type;
 464         return this;
 465     }
 466 
 467     /** Visit this tree with a given visitor.
 468      */
 469     public abstract void accept(Visitor v);
 470 
 471     @DefinedBy(Api.COMPILER_TREE)
 472     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 473 
 474     /** Return a shallow copy of this tree.
 475      */
 476     @Override
 477     public Object clone() {
 478         try {
 479             return super.clone();
 480         } catch(CloneNotSupportedException e) {
 481             throw new RuntimeException(e);
 482         }
 483     }
 484 
 485     /** Get a default position for this tree node.
 486      */
 487     public DiagnosticPosition pos() {
 488         return this;
 489     }
 490 
 491     // for default DiagnosticPosition
 492     public JCTree getTree() {
 493         return this;
 494     }
 495 
 496     // for default DiagnosticPosition
 497     public int getStartPosition() {
 498         return TreeInfo.getStartPos(this);
 499     }
 500 
 501     // for default DiagnosticPosition
 502     public int getPreferredPosition() {
 503         return pos;
 504     }
 505 
 506     // for default DiagnosticPosition
 507     public int getEndPosition(EndPosTable endPosTable) {
 508         return TreeInfo.getEndPos(this, endPosTable);
 509     }
 510 
 511     /**
 512      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 513      */
 514     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 515         /** All definitions in this file (ClassDef, Import, and Skip) */
 516         public List&lt;JCTree&gt; defs;
 517         /** The source file name. */
 518         public JavaFileObject sourcefile;
 519         /** The module to which this compilation unit belongs. */
 520         public ModuleSymbol modle;
 521         /** The location in which this compilation unit was found. */
 522         public Location locn;
 523         /** The package to which this compilation unit belongs. */
 524         public PackageSymbol packge;
 525         /** A scope containing top level classes. */
 526         public WriteableScope toplevelScope;
 527         /** A scope for all named imports. */
 528         public NamedImportScope namedImportScope;
 529         /** A scope for all import-on-demands. */
 530         public StarImportScope starImportScope;
 531         /** Line starting positions, defined only if option -g is set. */
 532         public Position.LineMap lineMap = null;
 533         /** A table that stores all documentation comments indexed by the tree
 534          * nodes they refer to. defined only if option -s is set. */
 535         public DocCommentTable docComments = null;
 536         /* An object encapsulating ending positions of source ranges indexed by
 537          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 538         public EndPosTable endPositions = null;
 539         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 540             this.defs = defs;
 541         }
 542         @Override
 543         public void accept(Visitor v) { v.visitTopLevel(this); }
 544 
 545         @DefinedBy(Api.COMPILER_TREE)
 546         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 547 
 548         public JCModuleDecl getModuleDecl() {
 549             for (JCTree tree : defs) {
 550                 if (tree.hasTag(MODULEDEF)) {
 551                     return (JCModuleDecl) tree;
 552                 }
 553             }
 554 
 555             return null;
 556         }
 557 
 558         @DefinedBy(Api.COMPILER_TREE)
 559         public JCPackageDecl getPackage() {
 560             // PackageDecl must be the first entry if it exists
 561             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 562                 return (JCPackageDecl)defs.head;
 563             return null;
 564         }
 565         @DefinedBy(Api.COMPILER_TREE)
 566         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 567             JCPackageDecl pd = getPackage();
 568             return pd != null ? pd.getAnnotations() : List.nil();
 569         }
 570         @DefinedBy(Api.COMPILER_TREE)
 571         public ExpressionTree getPackageName() {
 572             JCPackageDecl pd = getPackage();
 573             return pd != null ? pd.getPackageName() : null;
 574         }
 575 
 576         @DefinedBy(Api.COMPILER_TREE)
 577         public List&lt;JCImport&gt; getImports() {
 578             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 579             for (JCTree tree : defs) {
 580                 if (tree.hasTag(IMPORT))
 581                     imports.append((JCImport)tree);
 582                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 583                     break;
 584             }
 585             return imports.toList();
 586         }
 587         @DefinedBy(Api.COMPILER_TREE)
 588         public JavaFileObject getSourceFile() {
 589             return sourcefile;
 590         }
 591         @DefinedBy(Api.COMPILER_TREE)
 592         public Position.LineMap getLineMap() {
 593             return lineMap;
 594         }
 595         @DefinedBy(Api.COMPILER_TREE)
 596         public List&lt;JCTree&gt; getTypeDecls() {
 597             List&lt;JCTree&gt; typeDefs;
 598             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 599                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 600                     break;
 601             return typeDefs;
 602         }
 603         @Override @DefinedBy(Api.COMPILER_TREE)
 604         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 605             return v.visitCompilationUnit(this, d);
 606         }
 607 
 608         @Override
 609         public Tag getTag() {
 610             return TOPLEVEL;
 611         }
 612     }
 613 
 614     /**
 615      * Package definition.
 616      */
 617     public static class JCPackageDecl extends JCTree implements PackageTree {
 618         public List&lt;JCAnnotation&gt; annotations;
 619         /** The tree representing the package clause. */
 620         public JCExpression pid;
 621         public PackageSymbol packge;
 622         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 623             this.annotations = annotations;
 624             this.pid = pid;
 625         }
 626         @Override
 627         public void accept(Visitor v) { v.visitPackageDef(this); }
 628         @DefinedBy(Api.COMPILER_TREE)
 629         public Kind getKind() {
 630             return Kind.PACKAGE;
 631         }
 632         @DefinedBy(Api.COMPILER_TREE)
 633         public List&lt;JCAnnotation&gt; getAnnotations() {
 634             return annotations;
 635         }
 636         @DefinedBy(Api.COMPILER_TREE)
 637         public JCExpression getPackageName() {
 638             return pid;
 639         }
 640         @Override @DefinedBy(Api.COMPILER_TREE)
 641         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 642             return v.visitPackage(this, d);
 643         }
 644         @Override
 645         public Tag getTag() {
 646             return PACKAGEDEF;
 647         }
 648     }
 649 
 650     /**
 651      * An import clause.
 652      */
 653     public static class JCImport extends JCTree implements ImportTree {
 654         public boolean staticImport;
 655         /** The imported class(es). */
 656         public JCTree qualid;
 657         public com.sun.tools.javac.code.Scope importScope;
 658         protected JCImport(JCTree qualid, boolean importStatic) {
 659             this.qualid = qualid;
 660             this.staticImport = importStatic;
 661         }
 662         @Override
 663         public void accept(Visitor v) { v.visitImport(this); }
 664 
 665         @DefinedBy(Api.COMPILER_TREE)
 666         public boolean isStatic() { return staticImport; }
 667         @DefinedBy(Api.COMPILER_TREE)
 668         public JCTree getQualifiedIdentifier() { return qualid; }
 669 
 670         @DefinedBy(Api.COMPILER_TREE)
 671         public Kind getKind() { return Kind.IMPORT; }
 672         @Override @DefinedBy(Api.COMPILER_TREE)
 673         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 674             return v.visitImport(this, d);
 675         }
 676 
 677         @Override
 678         public Tag getTag() {
 679             return IMPORT;
 680         }
 681     }
 682 
 683     public static abstract class JCStatement extends JCTree implements StatementTree {
 684         @Override
 685         public JCStatement setType(Type type) {
 686             super.setType(type);
 687             return this;
 688         }
 689         @Override
 690         public JCStatement setPos(int pos) {
 691             super.setPos(pos);
 692             return this;
 693         }
 694     }
 695 
 696     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 697         @Override
 698         public JCExpression setType(Type type) {
 699             super.setType(type);
 700             return this;
 701         }
 702         @Override
 703         public JCExpression setPos(int pos) {
 704             super.setPos(pos);
 705             return this;
 706         }
 707 
 708         public boolean isPoly() { return false; }
 709         public boolean isStandalone() { return true; }
 710     }
 711 
 712     /**
 713      * Common supertype for all poly expression trees (lambda, method references,
 714      * conditionals, method and constructor calls)
 715      */
 716     public static abstract class JCPolyExpression extends JCExpression {
 717 
 718         /**
 719          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 720          */
 721         public enum PolyKind {
 722             /** poly expression to be treated as a standalone expression */
 723             STANDALONE,
 724             /** true poly expression */
 725             POLY
 726         }
 727 
 728         /** is this poly expression a &#39;true&#39; poly expression? */
 729         public PolyKind polyKind;
 730 
 731         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 732         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 733     }
 734 
 735     /**
 736      * Common supertype for all functional expression trees (lambda and method references)
 737      */
 738     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 739 
 740         public JCFunctionalExpression() {
 741             //a functional expression is always a &#39;true&#39; poly
 742             polyKind = PolyKind.POLY;
 743         }
 744 
 745         /** list of target types inferred for this functional expression. */
 746         public Type target;
 747 
 748         public Type getDescriptorType(Types types) {
 749             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 750         }
 751     }
 752 
 753     /**
 754      * A class definition.
 755      */
 756     public static class JCClassDecl extends JCStatement implements ClassTree {
 757         /** the modifiers */
 758         public JCModifiers mods;
 759         /** the name of the class */
 760         public Name name;
 761         /** formal class parameters */
 762         public List&lt;JCTypeParameter&gt; typarams;
 763         /** the classes this class extends */
 764         public JCExpression extending;
 765         /** the interfaces implemented by this class */
 766         public List&lt;JCExpression&gt; implementing;
 767         /** all variables and methods defined in this class */
 768         public List&lt;JCTree&gt; defs;
 769         /** the symbol */
 770         public ClassSymbol sym;
 771         protected JCClassDecl(JCModifiers mods,
 772                            Name name,
 773                            List&lt;JCTypeParameter&gt; typarams,
 774                            JCExpression extending,
 775                            List&lt;JCExpression&gt; implementing,
 776                            List&lt;JCTree&gt; defs,
 777                            ClassSymbol sym)
 778         {
 779             this.mods = mods;
 780             this.name = name;
 781             this.typarams = typarams;
 782             this.extending = extending;
 783             this.implementing = implementing;
 784             this.defs = defs;
 785             this.sym = sym;
 786         }
 787         @Override
 788         public void accept(Visitor v) { v.visitClassDef(this); }
 789 
 790         @SuppressWarnings(&quot;preview&quot;)
 791         @DefinedBy(Api.COMPILER_TREE)
 792         public Kind getKind() {
 793             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 794                 return Kind.ANNOTATION_TYPE;
 795             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 796                 return Kind.INTERFACE;
 797             else if ((mods.flags &amp; Flags.ENUM) != 0)
 798                 return Kind.ENUM;
 799             else if ((mods.flags &amp; Flags.RECORD) != 0)
 800                 return Kind.RECORD;
 801             else
 802                 return Kind.CLASS;
 803         }
 804 
 805         @DefinedBy(Api.COMPILER_TREE)
 806         public JCModifiers getModifiers() { return mods; }
 807         @DefinedBy(Api.COMPILER_TREE)
 808         public Name getSimpleName() { return name; }
 809         @DefinedBy(Api.COMPILER_TREE)
 810         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 811             return typarams;
 812         }
 813         @DefinedBy(Api.COMPILER_TREE)
 814         public JCExpression getExtendsClause() { return extending; }
 815         @DefinedBy(Api.COMPILER_TREE)
 816         public List&lt;JCExpression&gt; getImplementsClause() {
 817             return implementing;
 818         }
 819         @DefinedBy(Api.COMPILER_TREE)
 820         public List&lt;JCTree&gt; getMembers() {
 821             return defs;
 822         }
 823         @Override @DefinedBy(Api.COMPILER_TREE)
 824         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 825             return v.visitClass(this, d);
 826         }
 827 
 828         @Override
 829         public Tag getTag() {
 830             return CLASSDEF;
 831         }
 832     }
 833 
 834     /**
 835      * A method definition.
 836      */
 837     public static class JCMethodDecl extends JCTree implements MethodTree {
 838         /** method modifiers */
 839         public JCModifiers mods;
 840         /** method name */
 841         public Name name;
 842         /** type of method return value */
 843         public JCExpression restype;
 844         /** type parameters */
 845         public List&lt;JCTypeParameter&gt; typarams;
 846         /** receiver parameter */
 847         public JCVariableDecl recvparam;
 848         /** value parameters */
 849         public List&lt;JCVariableDecl&gt; params;
 850         /** exceptions thrown by this method */
 851         public List&lt;JCExpression&gt; thrown;
 852         /** statements in the method */
 853         public JCBlock body;
 854         /** default value, for annotation types */
 855         public JCExpression defaultValue;
 856         /** method symbol */
 857         public MethodSymbol sym;
 858         /** does this method completes normally */
 859         public boolean completesNormally;
 860 
 861         protected JCMethodDecl(JCModifiers mods,
 862                             Name name,
 863                             JCExpression restype,
 864                             List&lt;JCTypeParameter&gt; typarams,
 865                             JCVariableDecl recvparam,
 866                             List&lt;JCVariableDecl&gt; params,
 867                             List&lt;JCExpression&gt; thrown,
 868                             JCBlock body,
 869                             JCExpression defaultValue,
 870                             MethodSymbol sym)
 871         {
 872             this.mods = mods;
 873             this.name = name;
 874             this.restype = restype;
 875             this.typarams = typarams;
 876             this.params = params;
 877             this.recvparam = recvparam;
 878             // TODO: do something special if the given type is null?
 879             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 880             this.thrown = thrown;
 881             this.body = body;
 882             this.defaultValue = defaultValue;
 883             this.sym = sym;
 884         }
 885         @Override
 886         public void accept(Visitor v) { v.visitMethodDef(this); }
 887 
 888         @DefinedBy(Api.COMPILER_TREE)
 889         public Kind getKind() { return Kind.METHOD; }
 890         @DefinedBy(Api.COMPILER_TREE)
 891         public JCModifiers getModifiers() { return mods; }
 892         @DefinedBy(Api.COMPILER_TREE)
 893         public Name getName() { return name; }
 894         @DefinedBy(Api.COMPILER_TREE)
 895         public JCTree getReturnType() { return restype; }
 896         @DefinedBy(Api.COMPILER_TREE)
 897         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 898             return typarams;
 899         }
 900         @DefinedBy(Api.COMPILER_TREE)
 901         public List&lt;JCVariableDecl&gt; getParameters() {
 902             return params;
 903         }
 904         @DefinedBy(Api.COMPILER_TREE)
 905         public JCVariableDecl getReceiverParameter() { return recvparam; }
 906         @DefinedBy(Api.COMPILER_TREE)
 907         public List&lt;JCExpression&gt; getThrows() {
 908             return thrown;
 909         }
 910         @DefinedBy(Api.COMPILER_TREE)
 911         public JCBlock getBody() { return body; }
 912         @DefinedBy(Api.COMPILER_TREE)
 913         public JCTree getDefaultValue() { // for annotation types
 914             return defaultValue;
 915         }
 916         @Override @DefinedBy(Api.COMPILER_TREE)
 917         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 918             return v.visitMethod(this, d);
 919         }
 920 
 921         @Override
 922         public Tag getTag() {
 923             return METHODDEF;
 924         }
 925   }
 926 
 927     /**
 928      * A variable definition.
 929      */
 930     public static class JCVariableDecl extends JCStatement implements VariableTree {
 931         /** variable modifiers */
 932         public JCModifiers mods;
 933         /** variable name */
 934         public Name name;
 935         /** variable name expression */
 936         public JCExpression nameexpr;
 937         /** type of the variable */
 938         public JCExpression vartype;
 939         /** variable&#39;s initial value */
 940         public JCExpression init;
 941         /** symbol */
 942         public VarSymbol sym;
 943         /** explicit start pos */
 944         public int startPos = Position.NOPOS;
 945 
 946         protected JCVariableDecl(JCModifiers mods,
 947                          Name name,
 948                          JCExpression vartype,
 949                          JCExpression init,
 950                          VarSymbol sym) {
 951             this.mods = mods;
 952             this.name = name;
 953             this.vartype = vartype;
 954             this.init = init;
 955             this.sym = sym;
 956         }
 957 
 958         protected JCVariableDecl(JCModifiers mods,
 959                          JCExpression nameexpr,
 960                          JCExpression vartype) {
 961             this(mods, null, vartype, null, null);
 962             this.nameexpr = nameexpr;
 963             if (nameexpr.hasTag(Tag.IDENT)) {
 964                 this.name = ((JCIdent)nameexpr).name;
 965             } else {
 966                 // Only other option is qualified name x.y.this;
 967                 this.name = ((JCFieldAccess)nameexpr).name;
 968             }
 969         }
 970 
 971         public boolean isImplicitlyTyped() {
 972             return vartype == null;
 973         }
 974 
 975         @Override
 976         public void accept(Visitor v) { v.visitVarDef(this); }
 977 
 978         @DefinedBy(Api.COMPILER_TREE)
 979         public Kind getKind() { return Kind.VARIABLE; }
 980         @DefinedBy(Api.COMPILER_TREE)
 981         public JCModifiers getModifiers() { return mods; }
 982         @DefinedBy(Api.COMPILER_TREE)
 983         public Name getName() { return name; }
 984         @DefinedBy(Api.COMPILER_TREE)
 985         public JCExpression getNameExpression() { return nameexpr; }
 986         @DefinedBy(Api.COMPILER_TREE)
 987         public JCTree getType() { return vartype; }
 988         @DefinedBy(Api.COMPILER_TREE)
 989         public JCExpression getInitializer() {
 990             return init;
 991         }
 992         @Override @DefinedBy(Api.COMPILER_TREE)
 993         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 994             return v.visitVariable(this, d);
 995         }
 996 
 997         @Override
 998         public Tag getTag() {
 999             return VARDEF;
1000         }
1001     }
1002 
1003     /**
1004      * A no-op statement &quot;;&quot;.
1005      */
1006     public static class JCSkip extends JCStatement implements EmptyStatementTree {
1007         protected JCSkip() {
1008         }
1009         @Override
1010         public void accept(Visitor v) { v.visitSkip(this); }
1011 
1012         @DefinedBy(Api.COMPILER_TREE)
1013         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1014         @Override @DefinedBy(Api.COMPILER_TREE)
1015         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1016             return v.visitEmptyStatement(this, d);
1017         }
1018 
1019         @Override
1020         public Tag getTag() {
1021             return SKIP;
1022         }
1023     }
1024 
1025     /**
1026      * A statement block.
1027      */
1028     public static class JCBlock extends JCStatement implements BlockTree {
1029         /** flags */
1030         public long flags;
1031         /** statements */
1032         public List&lt;JCStatement&gt; stats;
1033         /** Position of closing brace, optional. */
1034         public int endpos = Position.NOPOS;
1035         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1036             this.stats = stats;
1037             this.flags = flags;
1038         }
1039         @Override
1040         public void accept(Visitor v) { v.visitBlock(this); }
1041 
1042         @DefinedBy(Api.COMPILER_TREE)
1043         public Kind getKind() { return Kind.BLOCK; }
1044         @DefinedBy(Api.COMPILER_TREE)
1045         public List&lt;JCStatement&gt; getStatements() {
1046             return stats;
1047         }
1048         @DefinedBy(Api.COMPILER_TREE)
1049         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1050         @Override @DefinedBy(Api.COMPILER_TREE)
1051         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1052             return v.visitBlock(this, d);
1053         }
1054 
1055         @Override
1056         public Tag getTag() {
1057             return BLOCK;
1058         }
1059     }
1060 
1061     /**
1062      * A do loop
1063      */
1064     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1065         public JCStatement body;
1066         public JCExpression cond;
1067         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1068             this.body = body;
1069             this.cond = cond;
1070         }
1071         @Override
1072         public void accept(Visitor v) { v.visitDoLoop(this); }
1073 
1074         @DefinedBy(Api.COMPILER_TREE)
1075         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1076         @DefinedBy(Api.COMPILER_TREE)
1077         public JCExpression getCondition() { return cond; }
1078         @DefinedBy(Api.COMPILER_TREE)
1079         public JCStatement getStatement() { return body; }
1080         @Override @DefinedBy(Api.COMPILER_TREE)
1081         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1082             return v.visitDoWhileLoop(this, d);
1083         }
1084 
1085         @Override
1086         public Tag getTag() {
1087             return DOLOOP;
1088         }
1089     }
1090 
1091     /**
1092      * A while loop
1093      */
1094     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1095         public JCExpression cond;
1096         public JCStatement body;
1097         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1098             this.cond = cond;
1099             this.body = body;
1100         }
1101         @Override
1102         public void accept(Visitor v) { v.visitWhileLoop(this); }
1103 
1104         @DefinedBy(Api.COMPILER_TREE)
1105         public Kind getKind() { return Kind.WHILE_LOOP; }
1106         @DefinedBy(Api.COMPILER_TREE)
1107         public JCExpression getCondition() { return cond; }
1108         @DefinedBy(Api.COMPILER_TREE)
1109         public JCStatement getStatement() { return body; }
1110         @Override @DefinedBy(Api.COMPILER_TREE)
1111         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1112             return v.visitWhileLoop(this, d);
1113         }
1114 
1115         @Override
1116         public Tag getTag() {
1117             return WHILELOOP;
1118         }
1119     }
1120 
1121     /**
1122      * A for loop.
1123      */
1124     public static class JCForLoop extends JCStatement implements ForLoopTree {
1125         public List&lt;JCStatement&gt; init;
1126         public JCExpression cond;
1127         public List&lt;JCExpressionStatement&gt; step;
1128         public JCStatement body;
1129         protected JCForLoop(List&lt;JCStatement&gt; init,
1130                           JCExpression cond,
1131                           List&lt;JCExpressionStatement&gt; update,
1132                           JCStatement body)
1133         {
1134             this.init = init;
1135             this.cond = cond;
1136             this.step = update;
1137             this.body = body;
1138         }
1139         @Override
1140         public void accept(Visitor v) { v.visitForLoop(this); }
1141 
1142         @DefinedBy(Api.COMPILER_TREE)
1143         public Kind getKind() { return Kind.FOR_LOOP; }
1144         @DefinedBy(Api.COMPILER_TREE)
1145         public JCExpression getCondition() { return cond; }
1146         @DefinedBy(Api.COMPILER_TREE)
1147         public JCStatement getStatement() { return body; }
1148         @DefinedBy(Api.COMPILER_TREE)
1149         public List&lt;JCStatement&gt; getInitializer() {
1150             return init;
1151         }
1152         @DefinedBy(Api.COMPILER_TREE)
1153         public List&lt;JCExpressionStatement&gt; getUpdate() {
1154             return step;
1155         }
1156         @Override @DefinedBy(Api.COMPILER_TREE)
1157         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1158             return v.visitForLoop(this, d);
1159         }
1160 
1161         @Override
1162         public Tag getTag() {
1163             return FORLOOP;
1164         }
1165     }
1166 
1167     /**
1168      * The enhanced for loop.
1169      */
1170     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1171         public JCVariableDecl var;
1172         public JCExpression expr;
1173         public JCStatement body;
1174         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1175             this.var = var;
1176             this.expr = expr;
1177             this.body = body;
1178         }
1179         @Override
1180         public void accept(Visitor v) { v.visitForeachLoop(this); }
1181 
1182         @DefinedBy(Api.COMPILER_TREE)
1183         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1184         @DefinedBy(Api.COMPILER_TREE)
1185         public JCVariableDecl getVariable() { return var; }
1186         @DefinedBy(Api.COMPILER_TREE)
1187         public JCExpression getExpression() { return expr; }
1188         @DefinedBy(Api.COMPILER_TREE)
1189         public JCStatement getStatement() { return body; }
1190         @Override @DefinedBy(Api.COMPILER_TREE)
1191         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1192             return v.visitEnhancedForLoop(this, d);
1193         }
1194         @Override
1195         public Tag getTag() {
1196             return FOREACHLOOP;
1197         }
1198     }
1199 
1200     /**
1201      * A labelled expression or statement.
1202      */
1203     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1204         public Name label;
1205         public JCStatement body;
1206         protected JCLabeledStatement(Name label, JCStatement body) {
1207             this.label = label;
1208             this.body = body;
1209         }
1210         @Override
1211         public void accept(Visitor v) { v.visitLabelled(this); }
1212         @DefinedBy(Api.COMPILER_TREE)
1213         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1214         @DefinedBy(Api.COMPILER_TREE)
1215         public Name getLabel() { return label; }
1216         @DefinedBy(Api.COMPILER_TREE)
1217         public JCStatement getStatement() { return body; }
1218         @Override @DefinedBy(Api.COMPILER_TREE)
1219         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1220             return v.visitLabeledStatement(this, d);
1221         }
1222         @Override
1223         public Tag getTag() {
1224             return LABELLED;
1225         }
1226     }
1227 
1228     /**
1229      * A &quot;switch ( ) { }&quot; construction.
1230      */
1231     public static class JCSwitch extends JCStatement implements SwitchTree {
1232         public JCExpression selector;
1233         public List&lt;JCCase&gt; cases;
1234         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1235             this.selector = selector;
1236             this.cases = cases;
1237         }
1238         @Override
1239         public void accept(Visitor v) { v.visitSwitch(this); }
1240 
1241         @DefinedBy(Api.COMPILER_TREE)
1242         public Kind getKind() { return Kind.SWITCH; }
1243         @DefinedBy(Api.COMPILER_TREE)
1244         public JCExpression getExpression() { return selector; }
1245         @DefinedBy(Api.COMPILER_TREE)
1246         public List&lt;JCCase&gt; getCases() { return cases; }
1247         @Override @DefinedBy(Api.COMPILER_TREE)
1248         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1249             return v.visitSwitch(this, d);
1250         }
1251         @Override
1252         public Tag getTag() {
1253             return SWITCH;
1254         }
1255     }
1256 
1257     /**
1258      * A &quot;case  :&quot; of a switch.
1259      */
1260     public static class JCCase extends JCStatement implements CaseTree {
1261         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1262         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1263         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1264         public static final CaseKind RULE = CaseKind.RULE;
1265         public final CaseKind caseKind;
1266         public List&lt;JCExpression&gt; pats;
1267         public List&lt;JCStatement&gt; stats;
1268         public JCTree body;
1269         public boolean completesNormally;
1270         protected JCCase(CaseKind caseKind, List&lt;JCExpression&gt; pats,
1271                          List&lt;JCStatement&gt; stats, JCTree body) {
1272             Assert.checkNonNull(pats);
1273             Assert.check(pats.isEmpty() || pats.head != null);
1274             this.caseKind = caseKind;
1275             this.pats = pats;
1276             this.stats = stats;
1277             this.body = body;
1278         }
1279         @Override
1280         public void accept(Visitor v) { v.visitCase(this); }
1281 
1282         @Override @DefinedBy(Api.COMPILER_TREE)
1283         public Kind getKind() { return Kind.CASE; }
1284         @Override @Deprecated @DefinedBy(Api.COMPILER_TREE)
1285         public JCExpression getExpression() { return pats.head; }
1286         @Override @DefinedBy(Api.COMPILER_TREE)
1287         public List&lt;JCExpression&gt; getExpressions() { return pats; }
1288         @Override @DefinedBy(Api.COMPILER_TREE)
1289         public List&lt;JCStatement&gt; getStatements() {
1290             return caseKind == CaseKind.STATEMENT ? stats : null;
1291         }
1292         @Override @DefinedBy(Api.COMPILER_TREE)
1293         public JCTree getBody() { return body; }
1294         @Override @DefinedBy(Api.COMPILER_TREE)
1295         public CaseKind getCaseKind() {
1296             return caseKind;
1297         }
1298         @Override @DefinedBy(Api.COMPILER_TREE)
1299         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1300             return v.visitCase(this, d);
1301         }
1302         @Override
1303         public Tag getTag() {
1304             return CASE;
1305         }
1306     }
1307 
1308     /**
1309      * A &quot;switch ( ) { }&quot; construction.
1310      */
1311     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree {
1312         public JCExpression selector;
1313         public List&lt;JCCase&gt; cases;
1314         /** Position of closing brace, optional. */
1315         public int endpos = Position.NOPOS;
1316         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1317             this.selector = selector;
1318             this.cases = cases;
1319         }
1320         @Override
1321         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1322 
1323         @DefinedBy(Api.COMPILER_TREE)
1324         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1325         @DefinedBy(Api.COMPILER_TREE)
1326         public JCExpression getExpression() { return selector; }
1327         @DefinedBy(Api.COMPILER_TREE)
1328         public List&lt;JCCase&gt; getCases() { return cases; }
1329         @Override @DefinedBy(Api.COMPILER_TREE)
1330         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1331             return v.visitSwitchExpression(this, d);
1332         }
1333         @Override
1334         public Tag getTag() {
1335             return SWITCH_EXPRESSION;
1336         }
1337     }
1338 
1339     /**
1340      * A synchronized block.
1341      */
1342     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1343         public JCExpression lock;
1344         public JCBlock body;
1345         protected JCSynchronized(JCExpression lock, JCBlock body) {
1346             this.lock = lock;
1347             this.body = body;
1348         }
1349         @Override
1350         public void accept(Visitor v) { v.visitSynchronized(this); }
1351 
1352         @DefinedBy(Api.COMPILER_TREE)
1353         public Kind getKind() { return Kind.SYNCHRONIZED; }
1354         @DefinedBy(Api.COMPILER_TREE)
1355         public JCExpression getExpression() { return lock; }
1356         @DefinedBy(Api.COMPILER_TREE)
1357         public JCBlock getBlock() { return body; }
1358         @Override @DefinedBy(Api.COMPILER_TREE)
1359         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1360             return v.visitSynchronized(this, d);
1361         }
1362         @Override
1363         public Tag getTag() {
1364             return SYNCHRONIZED;
1365         }
1366     }
1367 
1368     /**
1369      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1370      */
1371     public static class JCTry extends JCStatement implements TryTree {
1372         public JCBlock body;
1373         public List&lt;JCCatch&gt; catchers;
1374         public JCBlock finalizer;
1375         public List&lt;JCTree&gt; resources;
1376         public boolean finallyCanCompleteNormally;
1377         protected JCTry(List&lt;JCTree&gt; resources,
1378                         JCBlock body,
1379                         List&lt;JCCatch&gt; catchers,
1380                         JCBlock finalizer) {
1381             this.body = body;
1382             this.catchers = catchers;
1383             this.finalizer = finalizer;
1384             this.resources = resources;
1385         }
1386         @Override
1387         public void accept(Visitor v) { v.visitTry(this); }
1388 
1389         @DefinedBy(Api.COMPILER_TREE)
1390         public Kind getKind() { return Kind.TRY; }
1391         @DefinedBy(Api.COMPILER_TREE)
1392         public JCBlock getBlock() { return body; }
1393         @DefinedBy(Api.COMPILER_TREE)
1394         public List&lt;JCCatch&gt; getCatches() {
1395             return catchers;
1396         }
1397         @DefinedBy(Api.COMPILER_TREE)
1398         public JCBlock getFinallyBlock() { return finalizer; }
1399         @Override @DefinedBy(Api.COMPILER_TREE)
1400         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1401             return v.visitTry(this, d);
1402         }
1403         @Override @DefinedBy(Api.COMPILER_TREE)
1404         public List&lt;JCTree&gt; getResources() {
1405             return resources;
1406         }
1407         @Override
1408         public Tag getTag() {
1409             return TRY;
1410         }
1411     }
1412 
1413     /**
1414      * A catch block.
1415      */
1416     public static class JCCatch extends JCTree implements CatchTree {
1417         public JCVariableDecl param;
1418         public JCBlock body;
1419         protected JCCatch(JCVariableDecl param, JCBlock body) {
1420             this.param = param;
1421             this.body = body;
1422         }
1423         @Override
1424         public void accept(Visitor v) { v.visitCatch(this); }
1425 
1426         @DefinedBy(Api.COMPILER_TREE)
1427         public Kind getKind() { return Kind.CATCH; }
1428         @DefinedBy(Api.COMPILER_TREE)
1429         public JCVariableDecl getParameter() { return param; }
1430         @DefinedBy(Api.COMPILER_TREE)
1431         public JCBlock getBlock() { return body; }
1432         @Override @DefinedBy(Api.COMPILER_TREE)
1433         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1434             return v.visitCatch(this, d);
1435         }
1436         @Override
1437         public Tag getTag() {
1438             return CATCH;
1439         }
1440     }
1441 
1442     /**
1443      * A ( ) ? ( ) : ( ) conditional expression
1444      */
1445     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1446         public JCExpression cond;
1447         public JCExpression truepart;
1448         public JCExpression falsepart;
1449         protected JCConditional(JCExpression cond,
1450                               JCExpression truepart,
1451                               JCExpression falsepart)
1452         {
1453             this.cond = cond;
1454             this.truepart = truepart;
1455             this.falsepart = falsepart;
1456         }
1457         @Override
1458         public void accept(Visitor v) { v.visitConditional(this); }
1459 
1460         @DefinedBy(Api.COMPILER_TREE)
1461         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1462         @DefinedBy(Api.COMPILER_TREE)
1463         public JCExpression getCondition() { return cond; }
1464         @DefinedBy(Api.COMPILER_TREE)
1465         public JCExpression getTrueExpression() { return truepart; }
1466         @DefinedBy(Api.COMPILER_TREE)
1467         public JCExpression getFalseExpression() { return falsepart; }
1468         @Override @DefinedBy(Api.COMPILER_TREE)
1469         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1470             return v.visitConditionalExpression(this, d);
1471         }
1472         @Override
1473         public Tag getTag() {
1474             return CONDEXPR;
1475         }
1476     }
1477 
1478     /**
1479      * An &quot;if ( ) { } else { }&quot; block
1480      */
1481     public static class JCIf extends JCStatement implements IfTree {
1482         public JCExpression cond;
1483         public JCStatement thenpart;
1484         public JCStatement elsepart;
1485         protected JCIf(JCExpression cond,
1486                      JCStatement thenpart,
1487                      JCStatement elsepart)
1488         {
1489             this.cond = cond;
1490             this.thenpart = thenpart;
1491             this.elsepart = elsepart;
1492         }
1493         @Override
1494         public void accept(Visitor v) { v.visitIf(this); }
1495 
1496         @DefinedBy(Api.COMPILER_TREE)
1497         public Kind getKind() { return Kind.IF; }
1498         @DefinedBy(Api.COMPILER_TREE)
1499         public JCExpression getCondition() { return cond; }
1500         @DefinedBy(Api.COMPILER_TREE)
1501         public JCStatement getThenStatement() { return thenpart; }
1502         @DefinedBy(Api.COMPILER_TREE)
1503         public JCStatement getElseStatement() { return elsepart; }
1504         @Override @DefinedBy(Api.COMPILER_TREE)
1505         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1506             return v.visitIf(this, d);
1507         }
1508         @Override
1509         public Tag getTag() {
1510             return IF;
1511         }
1512     }
1513 
1514     /**
1515      * an expression statement
1516      */
1517     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1518         /** expression structure */
1519         public JCExpression expr;
1520         protected JCExpressionStatement(JCExpression expr)
1521         {
1522             this.expr = expr;
1523         }
1524         @Override
1525         public void accept(Visitor v) { v.visitExec(this); }
1526 
1527         @DefinedBy(Api.COMPILER_TREE)
1528         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1529         @DefinedBy(Api.COMPILER_TREE)
1530         public JCExpression getExpression() { return expr; }
1531         @Override @DefinedBy(Api.COMPILER_TREE)
1532         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1533             return v.visitExpressionStatement(this, d);
1534         }
1535         @Override
1536         public Tag getTag() {
1537             return EXEC;
1538         }
1539 
1540         /** Convert a expression-statement tree to a pretty-printed string. */
1541         @Override
1542         public String toString() {
1543             StringWriter s = new StringWriter();
1544             try {
1545                 new Pretty(s, false).printStat(this);
1546             }
1547             catch (IOException e) {
1548                 // should never happen, because StringWriter is defined
1549                 // never to throw any IOExceptions
1550                 throw new AssertionError(e);
1551             }
1552             return s.toString();
1553         }
1554     }
1555 
1556     /**
1557      * A break from a loop or switch.
1558      */
1559     public static class JCBreak extends JCStatement implements BreakTree {
1560         public Name label;
1561         public JCTree target;
1562         protected JCBreak(Name label, JCTree target) {
1563             this.label = label;
1564             this.target = target;
1565         }
1566         @Override
1567         public void accept(Visitor v) { v.visitBreak(this); }
1568         public boolean isValueBreak() {
1569             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1570         }
1571 
1572         @DefinedBy(Api.COMPILER_TREE)
1573         public Kind getKind() { return Kind.BREAK; }
1574         @DefinedBy(Api.COMPILER_TREE)
1575         public Name getLabel() {
1576             return label;
1577         }
1578         @Override @DefinedBy(Api.COMPILER_TREE)
1579         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1580             return v.visitBreak(this, d);
1581         }
1582         @Override
1583         public Tag getTag() {
1584             return BREAK;
1585         }
1586     }
1587 
1588     /**
1589      * A break-with from a switch expression.
1590      */
1591     public static class JCYield extends JCStatement implements YieldTree {
1592         public JCExpression value;
1593         public JCTree target;
1594         protected JCYield(JCExpression value, JCTree target) {
1595             this.value = value;
1596             this.target = target;
1597         }
1598         @Override
1599         public void accept(Visitor v) { v.visitYield(this); }
1600         @DefinedBy(Api.COMPILER_TREE)
1601         public Kind getKind() { return Kind.YIELD; }
1602         @DefinedBy(Api.COMPILER_TREE)
1603         public JCExpression getValue() { return value; }
1604         @Override @DefinedBy(Api.COMPILER_TREE)
1605         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1606             return v.visitYield(this, d);
1607         }
1608         @Override
1609         public Tag getTag() {
1610             return YIELD;
1611         }
1612     }
1613 
1614     /**
1615      * A continue of a loop.
1616      */
1617     public static class JCContinue extends JCStatement implements ContinueTree {
1618         public Name label;
1619         public JCTree target;
1620         protected JCContinue(Name label, JCTree target) {
1621             this.label = label;
1622             this.target = target;
1623         }
1624         @Override
1625         public void accept(Visitor v) { v.visitContinue(this); }
1626 
1627         @DefinedBy(Api.COMPILER_TREE)
1628         public Kind getKind() { return Kind.CONTINUE; }
1629         @DefinedBy(Api.COMPILER_TREE)
1630         public Name getLabel() { return label; }
1631         @Override @DefinedBy(Api.COMPILER_TREE)
1632         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1633             return v.visitContinue(this, d);
1634         }
1635         @Override
1636         public Tag getTag() {
1637             return CONTINUE;
1638         }
1639     }
1640 
1641     /**
1642      * A return statement.
1643      */
1644     public static class JCReturn extends JCStatement implements ReturnTree {
1645         public JCExpression expr;
1646         protected JCReturn(JCExpression expr) {
1647             this.expr = expr;
1648         }
1649         @Override
1650         public void accept(Visitor v) { v.visitReturn(this); }
1651 
1652         @DefinedBy(Api.COMPILER_TREE)
1653         public Kind getKind() { return Kind.RETURN; }
1654         @DefinedBy(Api.COMPILER_TREE)
1655         public JCExpression getExpression() { return expr; }
1656         @Override @DefinedBy(Api.COMPILER_TREE)
1657         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1658             return v.visitReturn(this, d);
1659         }
1660         @Override
1661         public Tag getTag() {
1662             return RETURN;
1663         }
1664     }
1665 
1666     /**
1667      * A throw statement.
1668      */
1669     public static class JCThrow extends JCStatement implements ThrowTree {
1670         public JCExpression expr;
1671         protected JCThrow(JCExpression expr) {
1672             this.expr = expr;
1673         }
1674         @Override
1675         public void accept(Visitor v) { v.visitThrow(this); }
1676 
1677         @DefinedBy(Api.COMPILER_TREE)
1678         public Kind getKind() { return Kind.THROW; }
1679         @DefinedBy(Api.COMPILER_TREE)
1680         public JCExpression getExpression() { return expr; }
1681         @Override @DefinedBy(Api.COMPILER_TREE)
1682         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1683             return v.visitThrow(this, d);
1684         }
1685         @Override
1686         public Tag getTag() {
1687             return THROW;
1688         }
1689     }
1690 
1691     /**
1692      * An assert statement.
1693      */
1694     public static class JCAssert extends JCStatement implements AssertTree {
1695         public JCExpression cond;
1696         public JCExpression detail;
1697         protected JCAssert(JCExpression cond, JCExpression detail) {
1698             this.cond = cond;
1699             this.detail = detail;
1700         }
1701         @Override
1702         public void accept(Visitor v) { v.visitAssert(this); }
1703 
1704         @DefinedBy(Api.COMPILER_TREE)
1705         public Kind getKind() { return Kind.ASSERT; }
1706         @DefinedBy(Api.COMPILER_TREE)
1707         public JCExpression getCondition() { return cond; }
1708         @DefinedBy(Api.COMPILER_TREE)
1709         public JCExpression getDetail() { return detail; }
1710         @Override @DefinedBy(Api.COMPILER_TREE)
1711         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1712             return v.visitAssert(this, d);
1713         }
1714         @Override
1715         public Tag getTag() {
1716             return ASSERT;
1717         }
1718     }
1719 
1720     /**
1721      * A method invocation
1722      */
1723     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1724         public List&lt;JCExpression&gt; typeargs;
1725         public JCExpression meth;
1726         public List&lt;JCExpression&gt; args;
1727         public Type varargsElement;
1728         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1729                         JCExpression meth,
1730                         List&lt;JCExpression&gt; args)
1731         {
1732             this.typeargs = (typeargs == null) ? List.nil()
1733                                                : typeargs;
1734             this.meth = meth;
1735             this.args = args;
1736         }
1737         @Override
1738         public void accept(Visitor v) { v.visitApply(this); }
1739 
1740         @DefinedBy(Api.COMPILER_TREE)
1741         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1742         @DefinedBy(Api.COMPILER_TREE)
1743         public List&lt;JCExpression&gt; getTypeArguments() {
1744             return typeargs;
1745         }
1746         @DefinedBy(Api.COMPILER_TREE)
1747         public JCExpression getMethodSelect() { return meth; }
1748         @DefinedBy(Api.COMPILER_TREE)
1749         public List&lt;JCExpression&gt; getArguments() {
1750             return args;
1751         }
1752         @Override @DefinedBy(Api.COMPILER_TREE)
1753         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1754             return v.visitMethodInvocation(this, d);
1755         }
1756         @Override
1757         public JCMethodInvocation setType(Type type) {
1758             super.setType(type);
1759             return this;
1760         }
1761         @Override
1762         public Tag getTag() {
1763             return(APPLY);
1764         }
1765     }
1766 
1767     /**
1768      * A new(...) operation.
1769      */
1770     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1771         public JCExpression encl;
1772         public List&lt;JCExpression&gt; typeargs;
1773         public JCExpression clazz;
1774         public List&lt;JCExpression&gt; args;
1775         public JCClassDecl def;
1776         public Symbol constructor;
1777         public Type varargsElement;
1778         public Type constructorType;
1779         protected JCNewClass(JCExpression encl,
1780                            List&lt;JCExpression&gt; typeargs,
1781                            JCExpression clazz,
1782                            List&lt;JCExpression&gt; args,
1783                            JCClassDecl def)
1784         {
1785             this.encl = encl;
1786             this.typeargs = (typeargs == null) ? List.nil()
1787                                                : typeargs;
1788             this.clazz = clazz;
1789             this.args = args;
1790             this.def = def;
1791         }
1792         @Override
1793         public void accept(Visitor v) { v.visitNewClass(this); }
1794 
1795         @DefinedBy(Api.COMPILER_TREE)
1796         public Kind getKind() { return Kind.NEW_CLASS; }
1797         @DefinedBy(Api.COMPILER_TREE)
1798         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1799             return encl;
1800         }
1801         @DefinedBy(Api.COMPILER_TREE)
1802         public List&lt;JCExpression&gt; getTypeArguments() {
1803             return typeargs;
1804         }
1805         @DefinedBy(Api.COMPILER_TREE)
1806         public JCExpression getIdentifier() { return clazz; }
1807         @DefinedBy(Api.COMPILER_TREE)
1808         public List&lt;JCExpression&gt; getArguments() {
1809             return args;
1810         }
1811         @DefinedBy(Api.COMPILER_TREE)
1812         public JCClassDecl getClassBody() { return def; }
1813         @Override @DefinedBy(Api.COMPILER_TREE)
1814         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1815             return v.visitNewClass(this, d);
1816         }
1817         @Override
1818         public Tag getTag() {
1819             return NEWCLASS;
1820         }
1821 
1822         public boolean classDeclRemoved() {
1823             return false;
1824         }
1825     }
1826 
1827     /**
1828      * A new[...] operation.
1829      */
1830     public static class JCNewArray extends JCExpression implements NewArrayTree {
1831         public JCExpression elemtype;
1832         public List&lt;JCExpression&gt; dims;
1833         // type annotations on inner-most component
1834         public List&lt;JCAnnotation&gt; annotations;
1835         // type annotations on dimensions
1836         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1837         public List&lt;JCExpression&gt; elems;
1838         protected JCNewArray(JCExpression elemtype,
1839                            List&lt;JCExpression&gt; dims,
1840                            List&lt;JCExpression&gt; elems)
1841         {
1842             this.elemtype = elemtype;
1843             this.dims = dims;
1844             this.annotations = List.nil();
1845             this.dimAnnotations = List.nil();
1846             this.elems = elems;
1847         }
1848         @Override
1849         public void accept(Visitor v) { v.visitNewArray(this); }
1850 
1851         @DefinedBy(Api.COMPILER_TREE)
1852         public Kind getKind() { return Kind.NEW_ARRAY; }
1853         @DefinedBy(Api.COMPILER_TREE)
1854         public JCExpression getType() { return elemtype; }
1855         @DefinedBy(Api.COMPILER_TREE)
1856         public List&lt;JCExpression&gt; getDimensions() {
1857             return dims;
1858         }
1859         @DefinedBy(Api.COMPILER_TREE)
1860         public List&lt;JCExpression&gt; getInitializers() {
1861             return elems;
1862         }
1863         @Override @DefinedBy(Api.COMPILER_TREE)
1864         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1865             return v.visitNewArray(this, d);
1866         }
1867         @Override
1868         public Tag getTag() {
1869             return NEWARRAY;
1870         }
1871 
1872         @Override @DefinedBy(Api.COMPILER_TREE)
1873         public List&lt;JCAnnotation&gt; getAnnotations() {
1874             return annotations;
1875         }
1876 
1877         @Override @DefinedBy(Api.COMPILER_TREE)
1878         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1879             return dimAnnotations;
1880         }
1881     }
1882 
1883     /**
1884      * A lambda expression.
1885      */
1886     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1887 
1888         public enum ParameterKind {
1889             IMPLICIT,
1890             EXPLICIT
1891         }
1892 
1893         public List&lt;JCVariableDecl&gt; params;
1894         public JCTree body;
1895         public boolean canCompleteNormally = true;
1896         public ParameterKind paramKind;
1897 
1898         public JCLambda(List&lt;JCVariableDecl&gt; params,
1899                         JCTree body) {
1900             this.params = params;
1901             this.body = body;
1902             if (params.isEmpty() ||
1903                 params.head.vartype != null) {
1904                 paramKind = ParameterKind.EXPLICIT;
1905             } else {
1906                 paramKind = ParameterKind.IMPLICIT;
1907             }
1908         }
1909         @Override
1910         public Tag getTag() {
1911             return LAMBDA;
1912         }
1913         @Override
1914         public void accept(Visitor v) {
1915             v.visitLambda(this);
1916         }
1917         @Override @DefinedBy(Api.COMPILER_TREE)
1918         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1919             return v.visitLambdaExpression(this, d);
1920         }
1921         @DefinedBy(Api.COMPILER_TREE)
1922         public Kind getKind() {
1923             return Kind.LAMBDA_EXPRESSION;
1924         }
1925         @DefinedBy(Api.COMPILER_TREE)
1926         public JCTree getBody() {
1927             return body;
1928         }
1929         @DefinedBy(Api.COMPILER_TREE)
1930         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1931             return params;
1932         }
1933         @Override
1934         public JCLambda setType(Type type) {
1935             super.setType(type);
1936             return this;
1937         }
1938         @Override @DefinedBy(Api.COMPILER_TREE)
1939         public BodyKind getBodyKind() {
1940             return body.hasTag(BLOCK) ?
1941                     BodyKind.STATEMENT :
1942                     BodyKind.EXPRESSION;
1943         }
1944     }
1945 
1946     /**
1947      * A parenthesized subexpression ( ... )
1948      */
1949     public static class JCParens extends JCExpression implements ParenthesizedTree {
1950         public JCExpression expr;
1951         protected JCParens(JCExpression expr) {
1952             this.expr = expr;
1953         }
1954         @Override
1955         public void accept(Visitor v) { v.visitParens(this); }
1956 
1957         @DefinedBy(Api.COMPILER_TREE)
1958         public Kind getKind() { return Kind.PARENTHESIZED; }
1959         @DefinedBy(Api.COMPILER_TREE)
1960         public JCExpression getExpression() { return expr; }
1961         @Override @DefinedBy(Api.COMPILER_TREE)
1962         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1963             return v.visitParenthesized(this, d);
1964         }
1965         @Override
1966         public Tag getTag() {
1967             return PARENS;
1968         }
1969     }
1970 
1971     /**
1972      * A assignment with &quot;=&quot;.
1973      */
1974     public static class JCAssign extends JCExpression implements AssignmentTree {
1975         public JCExpression lhs;
1976         public JCExpression rhs;
1977         protected JCAssign(JCExpression lhs, JCExpression rhs) {
1978             this.lhs = lhs;
1979             this.rhs = rhs;
1980         }
1981         @Override
1982         public void accept(Visitor v) { v.visitAssign(this); }
1983 
1984         @DefinedBy(Api.COMPILER_TREE)
1985         public Kind getKind() { return Kind.ASSIGNMENT; }
1986         @DefinedBy(Api.COMPILER_TREE)
1987         public JCExpression getVariable() { return lhs; }
1988         @DefinedBy(Api.COMPILER_TREE)
1989         public JCExpression getExpression() { return rhs; }
1990         @Override @DefinedBy(Api.COMPILER_TREE)
1991         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1992             return v.visitAssignment(this, d);
1993         }
1994         @Override
1995         public Tag getTag() {
1996             return ASSIGN;
1997         }
1998     }
1999 
2000     public static abstract class JCOperatorExpression extends JCExpression {
2001         public enum OperandPos {
2002             LEFT,
2003             RIGHT
2004         }
2005 
2006         protected Tag opcode;
2007         public OperatorSymbol operator;
2008 
2009         public OperatorSymbol getOperator() {
2010             return operator;
2011         }
2012 
2013         @Override
2014         public Tag getTag() {
2015             return opcode;
2016         }
2017 
2018         public abstract JCExpression getOperand(OperandPos pos);
2019     }
2020 
2021     /**
2022      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
2023      */
2024     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
2025         public JCExpression lhs;
2026         public JCExpression rhs;
2027         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2028             this.opcode = opcode;
2029             this.lhs = (JCExpression)lhs;
2030             this.rhs = (JCExpression)rhs;
2031             this.operator = operator;
2032         }
2033         @Override
2034         public void accept(Visitor v) { v.visitAssignop(this); }
2035 
2036         @DefinedBy(Api.COMPILER_TREE)
2037         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2038         @DefinedBy(Api.COMPILER_TREE)
2039         public JCExpression getVariable() { return lhs; }
2040         @DefinedBy(Api.COMPILER_TREE)
2041         public JCExpression getExpression() { return rhs; }
2042         @Override @DefinedBy(Api.COMPILER_TREE)
2043         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2044             return v.visitCompoundAssignment(this, d);
2045         }
2046         @Override
2047         public JCExpression getOperand(OperandPos pos) {
2048             return pos == OperandPos.LEFT ? lhs : rhs;
2049         }
2050     }
2051 
2052     /**
2053      * A unary operation.
2054      */
2055     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2056         public JCExpression arg;
2057         protected JCUnary(Tag opcode, JCExpression arg) {
2058             this.opcode = opcode;
2059             this.arg = arg;
2060         }
2061         @Override
2062         public void accept(Visitor v) { v.visitUnary(this); }
2063 
2064         @DefinedBy(Api.COMPILER_TREE)
2065         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2066         @DefinedBy(Api.COMPILER_TREE)
2067         public JCExpression getExpression() { return arg; }
2068         @Override @DefinedBy(Api.COMPILER_TREE)
2069         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2070             return v.visitUnary(this, d);
2071         }
2072         public void setTag(Tag tag) {
2073             opcode = tag;
2074         }
2075         @Override
2076         public JCExpression getOperand(OperandPos pos) {
2077             return arg;
2078         }
2079     }
2080 
2081     /**
2082      * A binary operation.
2083      */
2084     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2085         public JCExpression lhs;
2086         public JCExpression rhs;
2087         protected JCBinary(Tag opcode,
2088                          JCExpression lhs,
2089                          JCExpression rhs,
2090                          OperatorSymbol operator) {
2091             this.opcode = opcode;
2092             this.lhs = lhs;
2093             this.rhs = rhs;
2094             this.operator = operator;
2095         }
2096         @Override
2097         public void accept(Visitor v) { v.visitBinary(this); }
2098 
2099         @DefinedBy(Api.COMPILER_TREE)
2100         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2101         @DefinedBy(Api.COMPILER_TREE)
2102         public JCExpression getLeftOperand() { return lhs; }
2103         @DefinedBy(Api.COMPILER_TREE)
2104         public JCExpression getRightOperand() { return rhs; }
2105         @Override @DefinedBy(Api.COMPILER_TREE)
2106         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2107             return v.visitBinary(this, d);
2108         }
2109         @Override
2110         public JCExpression getOperand(OperandPos pos) {
2111             return pos == OperandPos.LEFT ? lhs : rhs;
2112         }
2113     }
2114 
2115     /**
2116      * A type cast.
2117      */
2118     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2119         public JCTree clazz;
2120         public JCExpression expr;
2121         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2122             this.clazz = clazz;
2123             this.expr = expr;
2124         }
2125         @Override
2126         public void accept(Visitor v) { v.visitTypeCast(this); }
2127 
2128         @DefinedBy(Api.COMPILER_TREE)
2129         public Kind getKind() { return Kind.TYPE_CAST; }
2130         @DefinedBy(Api.COMPILER_TREE)
2131         public JCTree getType() { return clazz; }
2132         @DefinedBy(Api.COMPILER_TREE)
2133         public JCExpression getExpression() { return expr; }
2134         @Override @DefinedBy(Api.COMPILER_TREE)
2135         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2136             return v.visitTypeCast(this, d);
2137         }
2138         @Override
2139         public Tag getTag() {
2140             return TYPECAST;
2141         }
2142     }
2143 
2144     /**
2145      * A type test.
2146      */
2147     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2148         public JCExpression expr;
2149         public JCTree pattern;
2150         protected JCInstanceOf(JCExpression expr, JCTree pattern) {
2151             this.expr = expr;
2152             this.pattern = pattern;
2153         }
2154         @Override
2155         public void accept(Visitor v) { v.visitTypeTest(this); }
2156 
2157         @DefinedBy(Api.COMPILER_TREE)
2158         public Kind getKind() { return Kind.INSTANCE_OF; }
2159         @DefinedBy(Api.COMPILER_TREE)
2160         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }
2161 
2162         @Override @DefinedBy(Api.COMPILER_TREE)
2163         public JCPattern getPattern() {
2164             return pattern instanceof JCPattern ? (JCPattern) pattern : null;
2165         }
2166 
2167         @DefinedBy(Api.COMPILER_TREE)
2168         public JCExpression getExpression() { return expr; }
2169         @Override @DefinedBy(Api.COMPILER_TREE)
2170         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2171             return v.visitInstanceOf(this, d);
2172         }
2173         @Override
2174         public Tag getTag() {
2175             return TYPETEST;
2176         }
2177     }
2178 
2179     /**
2180      * Pattern matching forms.
2181      */
2182     public static abstract class JCPattern extends JCTree
2183             implements PatternTree {
2184         public JCExpression constExpression() {
2185             return null;
2186         }
2187     }
2188 
2189     public static class JCBindingPattern extends JCPattern
2190             implements BindingPatternTree {
2191         public Name name;
2192         public BindingSymbol symbol;
2193         public JCTree vartype;
2194 
2195         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {
2196             this.name = name;
2197             this.symbol = symbol;
2198             this.vartype = vartype;
2199         }
2200 
2201         @DefinedBy(Api.COMPILER_TREE)
2202         public Name getBinding() {
2203             return name;
2204         }
2205 
2206         @Override @DefinedBy(Api.COMPILER_TREE)
2207         public Tree getType() {
2208             return vartype;
2209         }
2210 
2211         @Override
2212         public void accept(Visitor v) {
2213             v.visitBindingPattern(this);
2214         }
2215 
2216         @DefinedBy(Api.COMPILER_TREE)
2217         public Kind getKind() {
2218             return Kind.BINDING_PATTERN;
2219         }
2220 
2221         @Override
2222         @DefinedBy(Api.COMPILER_TREE)
2223         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2224             return v.visitBindingPattern(this, d);
2225         }
2226 
2227         @Override
2228         public Tag getTag() {
2229             return BINDINGPATTERN;
2230         }
2231     }
2232 
2233     public static class JCDeconstructionPattern extends JCPattern
2234             implements DeconstructionPatternTree {
2235         public Name name; //possibly null
2236         public JCExpression deconstructor;
2237         public List&lt;JCPattern&gt; nested;
2238         public ClassSymbol record;
2239         public List&lt;Type&gt; innerTypes;
2240 
2241         protected JCDeconstructionPattern(Name name, JCExpression deconstructor, List&lt;JCPattern&gt; nested) {
2242             this.name = name;
2243             this.deconstructor = deconstructor;
2244             this.nested = nested;
2245         }
2246 
2247         @DefinedBy(Api.COMPILER_TREE)
2248         public Name getBinding() {
2249             return name;
2250         }
2251 
2252         @Override @DefinedBy(Api.COMPILER_TREE)
2253         public Tree getDeconstructor() {
2254             return deconstructor;
2255         }
2256 
2257         @Override @DefinedBy(Api.COMPILER_TREE)
2258         public List&lt;? extends JCPattern&gt; getNestedPatterns() {
2259             return nested;
2260         }
2261 
2262         @Override
2263         public void accept(Visitor v) {
2264             v.visitDeconstructionPattern(this);
2265         }
2266 
2267         @DefinedBy(Api.COMPILER_TREE)
2268         public Kind getKind() {
2269             return Kind.DECONSTRUCTION_PATTERN;
2270         }
2271 
2272         @Override
2273         @DefinedBy(Api.COMPILER_TREE)
2274         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2275             return v.visitDeconstructionPattern(this, d);
2276         }
2277 
2278         @Override
2279         public Tag getTag() {
2280             return DECONSTRUCTIONPATTERN;
2281         }
2282     }
2283 
2284     /**
2285      * An array selection
2286      */
2287     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2288         public JCExpression indexed;
2289         public JCExpression index;
2290         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2291             this.indexed = indexed;
2292             this.index = index;
2293         }
2294         @Override
2295         public void accept(Visitor v) { v.visitIndexed(this); }
2296 
2297         @DefinedBy(Api.COMPILER_TREE)
2298         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2299         @DefinedBy(Api.COMPILER_TREE)
2300         public JCExpression getExpression() { return indexed; }
2301         @DefinedBy(Api.COMPILER_TREE)
2302         public JCExpression getIndex() { return index; }
2303         @Override @DefinedBy(Api.COMPILER_TREE)
2304         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2305             return v.visitArrayAccess(this, d);
2306         }
2307         @Override
2308         public Tag getTag() {
2309             return INDEXED;
2310         }
2311     }
2312 
2313     /**
2314      * Selects through packages and classes
2315      */
2316     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2317         /** selected Tree hierarchy */
2318         public JCExpression selected;
2319         /** name of field to select thru */
2320         public Name name;
2321         /** symbol of the selected class */
2322         public Symbol sym;
2323         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2324             this.selected = selected;
2325             this.name = name;
2326             this.sym = sym;
2327         }
2328         @Override
2329         public void accept(Visitor v) { v.visitSelect(this); }
2330 
2331         @DefinedBy(Api.COMPILER_TREE)
2332         public Kind getKind() { return Kind.MEMBER_SELECT; }
2333         @DefinedBy(Api.COMPILER_TREE)
2334         public JCExpression getExpression() { return selected; }
2335         @Override @DefinedBy(Api.COMPILER_TREE)
2336         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2337             return v.visitMemberSelect(this, d);
2338         }
2339         @DefinedBy(Api.COMPILER_TREE)
2340         public Name getIdentifier() { return name; }
2341         @Override
2342         public Tag getTag() {
2343             return SELECT;
2344         }
2345     }
2346 
2347     /**
2348      * Selects a member expression.
2349      */
2350     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2351 
2352         public ReferenceMode mode;
2353         public ReferenceKind kind;
2354         public Name name;
2355         public JCExpression expr;
2356         public List&lt;JCExpression&gt; typeargs;
2357         public Symbol sym;
2358         public Type varargsElement;
2359         public PolyKind refPolyKind;
2360         public boolean ownerAccessible;
2361         private OverloadKind overloadKind;
2362         public Type referentType;
2363 
2364         public enum OverloadKind {
2365             OVERLOADED,
2366             UNOVERLOADED,
2367             ERROR
2368         }
2369 
2370         /**
2371          * Javac-dependent classification for member references, based
2372          * on relevant properties w.r.t. code-generation
2373          */
2374         public enum ReferenceKind {
2375             /** super # instMethod */
2376             SUPER(ReferenceMode.INVOKE, false),
2377             /** Type # instMethod */
2378             UNBOUND(ReferenceMode.INVOKE, true),
2379             /** Type # staticMethod */
2380             STATIC(ReferenceMode.INVOKE, false),
2381             /** Expr # instMethod */
2382             BOUND(ReferenceMode.INVOKE, false),
2383             /** Inner # new */
2384             IMPLICIT_INNER(ReferenceMode.NEW, false),
2385             /** Toplevel # new */
2386             TOPLEVEL(ReferenceMode.NEW, false),
2387             /** ArrayType # new */
2388             ARRAY_CTOR(ReferenceMode.NEW, false);
2389 
2390             final ReferenceMode mode;
2391             final boolean unbound;
2392 
2393             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2394                 this.mode = mode;
2395                 this.unbound = unbound;
2396             }
2397 
2398             public boolean isUnbound() {
2399                 return unbound;
2400             }
2401         }
2402 
2403         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2404             this.mode = mode;
2405             this.name = name;
2406             this.expr = expr;
2407             this.typeargs = typeargs;
2408         }
2409         @Override
2410         public void accept(Visitor v) { v.visitReference(this); }
2411 
2412         @DefinedBy(Api.COMPILER_TREE)
2413         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2414         @Override @DefinedBy(Api.COMPILER_TREE)
2415         public ReferenceMode getMode() { return mode; }
2416         @Override @DefinedBy(Api.COMPILER_TREE)
2417         public JCExpression getQualifierExpression() { return expr; }
2418         @Override @DefinedBy(Api.COMPILER_TREE)
2419         public Name getName() { return name; }
2420         @Override @DefinedBy(Api.COMPILER_TREE)
2421         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2422 
2423         @Override @DefinedBy(Api.COMPILER_TREE)
2424         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2425             return v.visitMemberReference(this, d);
2426         }
2427         @Override
2428         public Tag getTag() {
2429             return REFERENCE;
2430         }
2431         public boolean hasKind(ReferenceKind kind) {
2432             return this.kind == kind;
2433         }
2434 
2435         /**
2436          * @return the overloadKind
2437          */
2438         public OverloadKind getOverloadKind() {
2439             return overloadKind;
2440         }
2441 
2442         /**
2443          * @param overloadKind the overloadKind to set
2444          */
2445         public void setOverloadKind(OverloadKind overloadKind) {
2446             this.overloadKind = overloadKind;
2447         }
2448     }
2449 
2450     /**
2451      * An identifier
2452      */
2453     public static class JCIdent extends JCExpression implements IdentifierTree {
2454         /** the name */
2455         public Name name;
2456         /** the symbol */
2457         public Symbol sym;
2458         protected JCIdent(Name name, Symbol sym) {
2459             this.name = name;
2460             this.sym = sym;
2461         }
2462         @Override
2463         public void accept(Visitor v) { v.visitIdent(this); }
2464 
2465         @DefinedBy(Api.COMPILER_TREE)
2466         public Kind getKind() { return Kind.IDENTIFIER; }
2467         @DefinedBy(Api.COMPILER_TREE)
2468         public Name getName() { return name; }
2469         @Override @DefinedBy(Api.COMPILER_TREE)
2470         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2471             return v.visitIdentifier(this, d);
2472         }
2473         @Override
2474         public Tag getTag() {
2475             return IDENT;
2476         }
2477     }
2478 
2479     /**
2480      * A constant value given literally.
2481      */
2482     public static class JCLiteral extends JCExpression implements LiteralTree {
2483         public TypeTag typetag;
2484         /** value representation */
2485         public Object value;
2486         protected JCLiteral(TypeTag typetag, Object value) {
2487             this.typetag = typetag;
2488             this.value = value;
2489         }
2490         @Override
2491         public void accept(Visitor v) { v.visitLiteral(this); }
2492 
2493         @DefinedBy(Api.COMPILER_TREE)
2494         public Kind getKind() {
2495             return typetag.getKindLiteral();
2496         }
2497 
2498         @DefinedBy(Api.COMPILER_TREE)
2499         public Object getValue() {
2500             switch (typetag) {
2501                 case BOOLEAN:
2502                     int bi = (Integer) value;
2503                     return (bi != 0);
2504                 case CHAR:
2505                     int ci = (Integer) value;
2506                     char c = (char) ci;
2507                     if (c != ci)
2508                         throw new AssertionError(&quot;bad value for char literal&quot;);
2509                     return c;
2510                 default:
2511                     return value;
2512             }
2513         }
2514         @Override @DefinedBy(Api.COMPILER_TREE)
2515         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2516             return v.visitLiteral(this, d);
2517         }
2518         @Override
2519         public JCLiteral setType(Type type) {
2520             super.setType(type);
2521             return this;
2522         }
2523         @Override
2524         public Tag getTag() {
2525             return LITERAL;
2526         }
2527     }
2528 
2529     /**
2530      * Identifies a basic type.
2531      * @see TypeTag
2532      */
2533     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2534         /** the basic type id */
2535         public TypeTag typetag;
2536         protected JCPrimitiveTypeTree(TypeTag typetag) {
2537             this.typetag = typetag;
2538         }
2539         @Override
2540         public void accept(Visitor v) { v.visitTypeIdent(this); }
2541 
2542         @DefinedBy(Api.COMPILER_TREE)
2543         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2544         @DefinedBy(Api.COMPILER_TREE)
2545         public TypeKind getPrimitiveTypeKind() {
2546             return typetag.getPrimitiveTypeKind();
2547         }
2548 
2549         @Override @DefinedBy(Api.COMPILER_TREE)
2550         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2551             return v.visitPrimitiveType(this, d);
2552         }
2553         @Override
2554         public Tag getTag() {
2555             return TYPEIDENT;
2556         }
2557     }
2558 
2559     /**
2560      * An array type, A[]
2561      */
2562     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2563         public JCExpression elemtype;
2564         protected JCArrayTypeTree(JCExpression elemtype) {
2565             this.elemtype = elemtype;
2566         }
2567         @Override
2568         public void accept(Visitor v) { v.visitTypeArray(this); }
2569 
2570         @DefinedBy(Api.COMPILER_TREE)
2571         public Kind getKind() { return Kind.ARRAY_TYPE; }
2572         @DefinedBy(Api.COMPILER_TREE)
2573         public JCTree getType() { return elemtype; }
2574         @Override @DefinedBy(Api.COMPILER_TREE)
2575         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2576             return v.visitArrayType(this, d);
2577         }
2578         @Override
2579         public Tag getTag() {
2580             return TYPEARRAY;
2581         }
2582     }
2583 
2584     /**
2585      * A parameterized type, {@literal T&lt;...&gt;}
2586      */
2587     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2588         public JCExpression clazz;
2589         public List&lt;JCExpression&gt; arguments;
2590         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2591             this.clazz = clazz;
2592             this.arguments = arguments;
2593         }
2594         @Override
2595         public void accept(Visitor v) { v.visitTypeApply(this); }
2596 
2597         @DefinedBy(Api.COMPILER_TREE)
2598         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2599         @DefinedBy(Api.COMPILER_TREE)
2600         public JCTree getType() { return clazz; }
2601         @DefinedBy(Api.COMPILER_TREE)
2602         public List&lt;JCExpression&gt; getTypeArguments() {
2603             return arguments;
2604         }
2605         @Override @DefinedBy(Api.COMPILER_TREE)
2606         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2607             return v.visitParameterizedType(this, d);
2608         }
2609         @Override
2610         public Tag getTag() {
2611             return TYPEAPPLY;
2612         }
2613     }
2614 
2615     /**
2616      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2617      */
2618     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2619 
2620         public List&lt;JCExpression&gt; alternatives;
2621 
2622         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2623             this.alternatives = components;
2624         }
2625         @Override
2626         public void accept(Visitor v) { v.visitTypeUnion(this); }
2627 
2628         @DefinedBy(Api.COMPILER_TREE)
2629         public Kind getKind() { return Kind.UNION_TYPE; }
2630 
2631         @DefinedBy(Api.COMPILER_TREE)
2632         public List&lt;JCExpression&gt; getTypeAlternatives() {
2633             return alternatives;
2634         }
2635         @Override @DefinedBy(Api.COMPILER_TREE)
2636         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2637             return v.visitUnionType(this, d);
2638         }
2639         @Override
2640         public Tag getTag() {
2641             return TYPEUNION;
2642         }
2643     }
2644 
2645     /**
2646      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2647      */
2648     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2649 
2650         public List&lt;JCExpression&gt; bounds;
2651 
2652         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2653             this.bounds = bounds;
2654         }
2655         @Override
2656         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2657 
2658         @DefinedBy(Api.COMPILER_TREE)
2659         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2660 
2661         @DefinedBy(Api.COMPILER_TREE)
2662         public List&lt;JCExpression&gt; getBounds() {
2663             return bounds;
2664         }
2665         @Override @DefinedBy(Api.COMPILER_TREE)
2666         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2667             return v.visitIntersectionType(this, d);
2668         }
2669         @Override
2670         public Tag getTag() {
2671             return TYPEINTERSECTION;
2672         }
2673     }
2674 
2675     /**
2676      * A formal class parameter.
2677      */
2678     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2679         /** name */
2680         public Name name;
2681         /** bounds */
2682         public List&lt;JCExpression&gt; bounds;
2683         /** type annotations on type parameter */
2684         public List&lt;JCAnnotation&gt; annotations;
2685         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2686             this.name = name;
2687             this.bounds = bounds;
2688             this.annotations = annotations;
2689         }
2690         @Override
2691         public void accept(Visitor v) { v.visitTypeParameter(this); }
2692 
2693         @DefinedBy(Api.COMPILER_TREE)
2694         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2695         @DefinedBy(Api.COMPILER_TREE)
2696         public Name getName() { return name; }
2697         @DefinedBy(Api.COMPILER_TREE)
2698         public List&lt;JCExpression&gt; getBounds() {
2699             return bounds;
2700         }
2701         @DefinedBy(Api.COMPILER_TREE)
2702         public List&lt;JCAnnotation&gt; getAnnotations() {
2703             return annotations;
2704         }
2705         @Override @DefinedBy(Api.COMPILER_TREE)
2706         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2707             return v.visitTypeParameter(this, d);
2708         }
2709         @Override
2710         public Tag getTag() {
2711             return TYPEPARAMETER;
2712         }
2713     }
2714 
2715     public static class JCWildcard extends JCExpression implements WildcardTree {
2716         public TypeBoundKind kind;
2717         public JCTree inner;
2718         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2719             this.kind = Assert.checkNonNull(kind);
2720             this.inner = inner;
2721         }
2722         @Override
2723         public void accept(Visitor v) { v.visitWildcard(this); }
2724 
2725         @DefinedBy(Api.COMPILER_TREE)
2726         public Kind getKind() {
2727             switch (kind.kind) {
2728             case UNBOUND:
2729                 return Kind.UNBOUNDED_WILDCARD;
2730             case EXTENDS:
2731                 return Kind.EXTENDS_WILDCARD;
2732             case SUPER:
2733                 return Kind.SUPER_WILDCARD;
2734             default:
2735                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2736             }
2737         }
2738         @DefinedBy(Api.COMPILER_TREE)
2739         public JCTree getBound() { return inner; }
2740         @Override @DefinedBy(Api.COMPILER_TREE)
2741         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2742             return v.visitWildcard(this, d);
2743         }
2744         @Override
2745         public Tag getTag() {
2746             return Tag.WILDCARD;
2747         }
2748     }
2749 
2750     public static class TypeBoundKind extends JCTree {
2751         public BoundKind kind;
2752         protected TypeBoundKind(BoundKind kind) {
2753             this.kind = kind;
2754         }
2755         @Override
2756         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2757 
2758         @DefinedBy(Api.COMPILER_TREE)
2759         public Kind getKind() {
2760             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2761         }
2762         @Override @DefinedBy(Api.COMPILER_TREE)
2763         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2764             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2765         }
2766         @Override
2767         public Tag getTag() {
2768             return TYPEBOUNDKIND;
2769         }
2770     }
2771 
2772     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2773         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2774         private Tag tag;
2775 
2776         public JCTree annotationType;
2777         public List&lt;JCExpression&gt; args;
2778         public Attribute.Compound attribute;
2779 
2780         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2781             this.tag = tag;
2782             this.annotationType = annotationType;
2783             this.args = args;
2784         }
2785 
2786         @Override
2787         public void accept(Visitor v) { v.visitAnnotation(this); }
2788 
2789         @DefinedBy(Api.COMPILER_TREE)
2790         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2791 
2792         @DefinedBy(Api.COMPILER_TREE)
2793         public JCTree getAnnotationType() { return annotationType; }
2794         @DefinedBy(Api.COMPILER_TREE)
2795         public List&lt;JCExpression&gt; getArguments() {
2796             return args;
2797         }
2798         @Override @DefinedBy(Api.COMPILER_TREE)
2799         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2800             return v.visitAnnotation(this, d);
2801         }
2802         @Override
2803         public Tag getTag() {
2804             return tag;
2805         }
2806     }
2807 
2808     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2809         public long flags;
2810         public List&lt;JCAnnotation&gt; annotations;
2811         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2812             this.flags = flags;
2813             this.annotations = annotations;
2814         }
2815         @Override
2816         public void accept(Visitor v) { v.visitModifiers(this); }
2817 
2818         @DefinedBy(Api.COMPILER_TREE)
2819         public Kind getKind() { return Kind.MODIFIERS; }
2820         @DefinedBy(Api.COMPILER_TREE)
2821         public Set&lt;Modifier&gt; getFlags() {
2822             return Flags.asModifierSet(flags);
2823         }
2824         @DefinedBy(Api.COMPILER_TREE)
2825         public List&lt;JCAnnotation&gt; getAnnotations() {
2826             return annotations;
2827         }
2828         @Override @DefinedBy(Api.COMPILER_TREE)
2829         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2830             return v.visitModifiers(this, d);
2831         }
2832         @Override
2833         public Tag getTag() {
2834             return MODIFIERS;
2835         }
2836     }
2837 
2838     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2839         // type annotations
2840         public List&lt;JCAnnotation&gt; annotations;
2841         public JCExpression underlyingType;
2842 
2843         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2844             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2845             this.annotations = annotations;
2846             this.underlyingType = underlyingType;
2847         }
2848         @Override
2849         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2850 
2851         @DefinedBy(Api.COMPILER_TREE)
2852         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2853         @DefinedBy(Api.COMPILER_TREE)
2854         public List&lt;JCAnnotation&gt; getAnnotations() {
2855             return annotations;
2856         }
2857         @DefinedBy(Api.COMPILER_TREE)
2858         public JCExpression getUnderlyingType() {
2859             return underlyingType;
2860         }
2861         @Override @DefinedBy(Api.COMPILER_TREE)
2862         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2863             return v.visitAnnotatedType(this, d);
2864         }
2865         @Override
2866         public Tag getTag() {
2867             return ANNOTATED_TYPE;
2868         }
2869     }
2870 
2871     public static abstract class JCDirective extends JCTree
2872         implements DirectiveTree {
2873     }
2874 
2875     public static class JCModuleDecl extends JCTree implements ModuleTree {
2876         public JCModifiers mods;
2877         public ModuleType type;
2878         private final ModuleKind kind;
2879         public JCExpression qualId;
2880         public List&lt;JCDirective&gt; directives;
2881         public ModuleSymbol sym;
2882 
2883         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
2884                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
2885             this.mods = mods;
2886             this.kind = kind;
2887             this.qualId = qualId;
2888             this.directives = directives;
2889         }
2890 
2891         @Override
2892         public void accept(Visitor v) { v.visitModuleDef(this); }
2893 
2894         @Override @DefinedBy(Api.COMPILER_TREE)
2895         public Kind getKind() {
2896             return Kind.MODULE;
2897         }
2898 
2899         @Override @DefinedBy(Api.COMPILER_TREE)
2900         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
2901             return mods.annotations;
2902         }
2903 
2904         @Override @DefinedBy(Api.COMPILER_TREE)
2905         public ModuleKind getModuleType() {
2906             return kind;
2907         }
2908 
2909         @Override @DefinedBy(Api.COMPILER_TREE)
2910         public JCExpression getName() {
2911             return qualId;
2912         }
2913 
2914         @Override @DefinedBy(Api.COMPILER_TREE)
2915         public List&lt;JCDirective&gt; getDirectives() {
2916             return directives;
2917         }
2918 
2919         @Override @DefinedBy(Api.COMPILER_TREE)
2920         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2921             return v.visitModule(this, d);
2922         }
2923 
2924         @Override
2925         public Tag getTag() {
2926             return MODULEDEF;
2927         }
2928     }
2929 
2930     public static class JCExports extends JCDirective
2931             implements ExportsTree {
2932         public JCExpression qualid;
2933         public List&lt;JCExpression&gt; moduleNames;
2934         public ExportsDirective directive;
2935 
2936         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2937             this.qualid = qualId;
2938             this.moduleNames = moduleNames;
2939         }
2940 
2941         @Override
2942         public void accept(Visitor v) { v.visitExports(this); }
2943 
2944         @Override @DefinedBy(Api.COMPILER_TREE)
2945         public Kind getKind() {
2946             return Kind.EXPORTS;
2947         }
2948 
2949         @Override @DefinedBy(Api.COMPILER_TREE)
2950         public JCExpression getPackageName() {
2951             return qualid;
2952         }
2953 
2954         @Override @DefinedBy(Api.COMPILER_TREE)
2955         public List&lt;JCExpression&gt; getModuleNames() {
2956             return moduleNames;
2957         }
2958 
2959         @Override @DefinedBy(Api.COMPILER_TREE)
2960         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2961             return v.visitExports(this, d);
2962         }
2963 
2964         @Override
2965         public Tag getTag() {
2966             return Tag.EXPORTS;
2967         }
2968     }
2969 
2970     public static class JCOpens extends JCDirective
2971             implements OpensTree {
2972         public JCExpression qualid;
2973         public List&lt;JCExpression&gt; moduleNames;
2974         public OpensDirective directive;
2975 
2976         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
2977             this.qualid = qualId;
2978             this.moduleNames = moduleNames;
2979         }
2980 
2981         @Override
2982         public void accept(Visitor v) { v.visitOpens(this); }
2983 
2984         @Override @DefinedBy(Api.COMPILER_TREE)
2985         public Kind getKind() {
2986             return Kind.OPENS;
2987         }
2988 
2989         @Override @DefinedBy(Api.COMPILER_TREE)
2990         public JCExpression getPackageName() {
2991             return qualid;
2992         }
2993 
2994         @Override @DefinedBy(Api.COMPILER_TREE)
2995         public List&lt;JCExpression&gt; getModuleNames() {
2996             return moduleNames;
2997         }
2998 
2999         @Override @DefinedBy(Api.COMPILER_TREE)
3000         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3001             return v.visitOpens(this, d);
3002         }
3003 
3004         @Override
3005         public Tag getTag() {
3006             return Tag.OPENS;
3007         }
3008     }
3009 
3010     public static class JCProvides extends JCDirective
3011             implements ProvidesTree {
3012         public JCExpression serviceName;
3013         public List&lt;JCExpression&gt; implNames;
3014 
3015         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
3016             this.serviceName = serviceName;
3017             this.implNames = implNames;
3018         }
3019 
3020         @Override
3021         public void accept(Visitor v) { v.visitProvides(this); }
3022 
3023         @Override @DefinedBy(Api.COMPILER_TREE)
3024         public Kind getKind() {
3025             return Kind.PROVIDES;
3026         }
3027 
3028         @Override @DefinedBy(Api.COMPILER_TREE)
3029         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3030             return v.visitProvides(this, d);
3031         }
3032 
3033         @Override @DefinedBy(Api.COMPILER_TREE)
3034         public JCExpression getServiceName() {
3035             return serviceName;
3036         }
3037 
3038         @Override @DefinedBy(Api.COMPILER_TREE)
3039         public List&lt;JCExpression&gt; getImplementationNames() {
3040             return implNames;
3041         }
3042 
3043         @Override
3044         public Tag getTag() {
3045             return PROVIDES;
3046         }
3047     }
3048 
3049     public static class JCRequires extends JCDirective
3050             implements RequiresTree {
3051         public boolean isTransitive;
3052         public boolean isStaticPhase;
3053         public JCExpression moduleName;
3054         public RequiresDirective directive;
3055 
3056         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
3057             this.isTransitive = isTransitive;
3058             this.isStaticPhase = isStaticPhase;
3059             this.moduleName = moduleName;
3060         }
3061 
3062         @Override
3063         public void accept(Visitor v) { v.visitRequires(this); }
3064 
3065         @Override @DefinedBy(Api.COMPILER_TREE)
3066         public Kind getKind() {
3067             return Kind.REQUIRES;
3068         }
3069 
3070         @Override @DefinedBy(Api.COMPILER_TREE)
3071         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3072             return v.visitRequires(this, d);
3073         }
3074 
3075         @Override @DefinedBy(Api.COMPILER_TREE)
3076         public boolean isTransitive() {
3077             return isTransitive;
3078         }
3079 
3080         @Override @DefinedBy(Api.COMPILER_TREE)
3081         public boolean isStatic() {
3082             return isStaticPhase;
3083         }
3084 
3085         @Override @DefinedBy(Api.COMPILER_TREE)
3086         public JCExpression getModuleName() {
3087             return moduleName;
3088         }
3089 
3090         @Override
3091         public Tag getTag() {
3092             return REQUIRES;
3093         }
3094     }
3095 
3096     public static class JCUses extends JCDirective
3097             implements UsesTree {
3098         public JCExpression qualid;
3099 
3100         protected JCUses(JCExpression qualId) {
3101             this.qualid = qualId;
3102         }
3103 
3104         @Override
3105         public void accept(Visitor v) { v.visitUses(this); }
3106 
3107         @Override @DefinedBy(Api.COMPILER_TREE)
3108         public Kind getKind() {
3109             return Kind.USES;
3110         }
3111 
3112         @Override @DefinedBy(Api.COMPILER_TREE)
3113         public JCExpression getServiceName() {
3114             return qualid;
3115         }
3116 
3117         @Override @DefinedBy(Api.COMPILER_TREE)
3118         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3119             return v.visitUses(this, d);
3120         }
3121 
3122         @Override
3123         public Tag getTag() {
3124             return USES;
3125         }
3126     }
3127 
3128     public static class JCErroneous extends JCExpression
3129             implements ErroneousTree {
3130         public List&lt;? extends JCTree&gt; errs;
3131         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
3132             this.errs = errs;
3133         }
3134         @Override
3135         public void accept(Visitor v) { v.visitErroneous(this); }
3136 
3137         @DefinedBy(Api.COMPILER_TREE)
3138         public Kind getKind() { return Kind.ERRONEOUS; }
3139 
3140         @DefinedBy(Api.COMPILER_TREE)
3141         public List&lt;? extends JCTree&gt; getErrorTrees() {
3142             return errs;
3143         }
3144 
3145         @Override @DefinedBy(Api.COMPILER_TREE)
3146         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3147             return v.visitErroneous(this, d);
3148         }
3149         @Override
3150         public Tag getTag() {
3151             return ERRONEOUS;
3152         }
3153     }
3154 
3155     /** (let int x = 3; in x+2) */
3156     public static class LetExpr extends JCExpression {
3157         public List&lt;? extends JCStatement&gt; defs;
3158         public JCExpression expr;
3159         /**true if a expr should be run through Gen.genCond:*/
3160         public boolean needsCond;
3161         protected LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr) {
3162             this.defs = defs;
3163             this.expr = expr;
3164         }
3165         @Override
3166         public void accept(Visitor v) { v.visitLetExpr(this); }
3167 
3168         @DefinedBy(Api.COMPILER_TREE)
3169         public Kind getKind() {
3170             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3171         }
3172         @Override @DefinedBy(Api.COMPILER_TREE)
3173         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3174             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3175         }
3176         @Override
3177         public Tag getTag() {
3178             return LETEXPR;
3179         }
3180     }
3181 
3182     /** An interface for tree factories
3183      */
3184     public interface Factory {
3185         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3186         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3187                                   JCExpression pid);
3188         JCImport Import(JCTree qualid, boolean staticImport);
3189         JCClassDecl ClassDef(JCModifiers mods,
3190                           Name name,
3191                           List&lt;JCTypeParameter&gt; typarams,
3192                           JCExpression extending,
3193                           List&lt;JCExpression&gt; implementing,
3194                           List&lt;JCTree&gt; defs);
3195         JCMethodDecl MethodDef(JCModifiers mods,
3196                             Name name,
3197                             JCExpression restype,
3198                             List&lt;JCTypeParameter&gt; typarams,
3199                             JCVariableDecl recvparam,
3200                             List&lt;JCVariableDecl&gt; params,
3201                             List&lt;JCExpression&gt; thrown,
3202                             JCBlock body,
3203                             JCExpression defaultValue);
3204         JCVariableDecl VarDef(JCModifiers mods,
3205                       Name name,
3206                       JCExpression vartype,
3207                       JCExpression init);
3208         JCSkip Skip();
3209         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3210         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3211         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3212         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3213                         JCExpression cond,
3214                         List&lt;JCExpressionStatement&gt; step,
3215                         JCStatement body);
3216         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3217         JCLabeledStatement Labelled(Name label, JCStatement body);
3218         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3219         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3220         JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pat,
3221                     List&lt;JCStatement&gt; stats, JCTree body);
3222         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3223         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3224         JCTry Try(List&lt;JCTree&gt; resources,
3225                   JCBlock body,
3226                   List&lt;JCCatch&gt; catchers,
3227                   JCBlock finalizer);
3228         JCCatch Catch(JCVariableDecl param, JCBlock body);
3229         JCConditional Conditional(JCExpression cond,
3230                                 JCExpression thenpart,
3231                                 JCExpression elsepart);
3232         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3233         JCExpressionStatement Exec(JCExpression expr);
3234         JCBreak Break(Name label);
3235         JCYield Yield(JCExpression value);
3236         JCContinue Continue(Name label);
3237         JCReturn Return(JCExpression expr);
3238         JCThrow Throw(JCExpression expr);
3239         JCAssert Assert(JCExpression cond, JCExpression detail);
3240         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3241                     JCExpression fn,
3242                     List&lt;JCExpression&gt; args);
3243         JCNewClass NewClass(JCExpression encl,
3244                           List&lt;JCExpression&gt; typeargs,
3245                           JCExpression clazz,
3246                           List&lt;JCExpression&gt; args,
3247                           JCClassDecl def);
3248         JCNewArray NewArray(JCExpression elemtype,
3249                           List&lt;JCExpression&gt; dims,
3250                           List&lt;JCExpression&gt; elems);
3251         JCParens Parens(JCExpression expr);
3252         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3253         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3254         JCUnary Unary(Tag opcode, JCExpression arg);
3255         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3256         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3257         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3258         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3259         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3260         JCFieldAccess Select(JCExpression selected, Name selector);
3261         JCIdent Ident(Name idname);
3262         JCLiteral Literal(TypeTag tag, Object value);
3263         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3264         JCArrayTypeTree TypeArray(JCExpression elemtype);
3265         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3266         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3267         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3268         TypeBoundKind TypeBoundKind(BoundKind kind);
3269         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3270         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3271         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3272         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3273         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3274         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3275         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3276         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3277         JCUses Uses(JCExpression qualId);
3278         LetExpr LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr);
3279     }
3280 
3281     /** A generic visitor class for trees.
3282      */
3283     public static abstract class Visitor {
3284         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3285         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3286         public void visitImport(JCImport that)               { visitTree(that); }
3287         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3288         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3289         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3290         public void visitSkip(JCSkip that)                   { visitTree(that); }
3291         public void visitBlock(JCBlock that)                 { visitTree(that); }
3292         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3293         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3294         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3295         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3296         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3297         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3298         public void visitCase(JCCase that)                   { visitTree(that); }
3299         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3300         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3301         public void visitTry(JCTry that)                     { visitTree(that); }
3302         public void visitCatch(JCCatch that)                 { visitTree(that); }
3303         public void visitConditional(JCConditional that)     { visitTree(that); }
3304         public void visitIf(JCIf that)                       { visitTree(that); }
3305         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3306         public void visitBreak(JCBreak that)                 { visitTree(that); }
3307         public void visitYield(JCYield that)                 { visitTree(that); }
3308         public void visitContinue(JCContinue that)           { visitTree(that); }
3309         public void visitReturn(JCReturn that)               { visitTree(that); }
3310         public void visitThrow(JCThrow that)                 { visitTree(that); }
3311         public void visitAssert(JCAssert that)               { visitTree(that); }
3312         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3313         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3314         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3315         public void visitLambda(JCLambda that)               { visitTree(that); }
3316         public void visitParens(JCParens that)               { visitTree(that); }
3317         public void visitAssign(JCAssign that)               { visitTree(that); }
3318         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3319         public void visitUnary(JCUnary that)                 { visitTree(that); }
3320         public void visitBinary(JCBinary that)               { visitTree(that); }
3321         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3322         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3323         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }
3324         public void visitDeconstructionPattern(JCDeconstructionPattern that) { visitTree(that); }
3325         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3326         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3327         public void visitReference(JCMemberReference that)   { visitTree(that); }
3328         public void visitIdent(JCIdent that)                 { visitTree(that); }
3329         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3330         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3331         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3332         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3333         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3334         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3335         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3336         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3337         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3338         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3339         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3340         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3341         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3342         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3343         public void visitExports(JCExports that)             { visitTree(that); }
3344         public void visitOpens(JCOpens that)                 { visitTree(that); }
3345         public void visitProvides(JCProvides that)           { visitTree(that); }
3346         public void visitRequires(JCRequires that)           { visitTree(that); }
3347         public void visitUses(JCUses that)                   { visitTree(that); }
3348         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3349 
3350         public void visitTree(JCTree that)                   { Assert.error(); }
3351     }
3352 
3353 }
    </pre>
  </body>
</html>
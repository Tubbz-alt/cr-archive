<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.util.Iterator;
  29 
  30 import com.sun.source.tree.CaseTree;
  31 import com.sun.source.tree.ModuleTree.ModuleKind;
  32 import com.sun.tools.javac.code.*;
  33 import com.sun.tools.javac.code.Attribute.UnresolvedClass;
  34 import com.sun.tools.javac.code.Symbol.*;
  35 import com.sun.tools.javac.code.Type.*;
  36 import com.sun.tools.javac.util.*;
  37 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  38 
  39 import com.sun.tools.javac.tree.JCTree.*;
  40 
  41 import static com.sun.tools.javac.code.Flags.*;
  42 import static com.sun.tools.javac.code.Kinds.Kind.*;
  43 import static com.sun.tools.javac.code.TypeTag.*;
  44 import com.sun.tools.javac.tree.JCTree.JCExpression;
  45 import com.sun.tools.javac.tree.JCTree.JCPattern;
  46 import com.sun.tools.javac.util.List;
  47 import com.sun.tools.javac.util.Name;
  48 
  49 /** Factory class for trees.
  50  *
  51  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  52  *  If you write code that depends on this, you do so at your own risk.
  53  *  This code and its internal interfaces are subject to change or
  54  *  deletion without notice.&lt;/b&gt;
  55  */
  56 public class TreeMaker implements JCTree.Factory {
  57 
  58     /** The context key for the tree factory. */
  59     protected static final Context.Key&lt;TreeMaker&gt; treeMakerKey = new Context.Key&lt;&gt;();
  60 
  61     /** Get the TreeMaker instance. */
  62     public static TreeMaker instance(Context context) {
  63         TreeMaker instance = context.get(treeMakerKey);
  64         if (instance == null)
  65             instance = new TreeMaker(context);
  66         return instance;
  67     }
  68 
  69     /** The position at which subsequent trees will be created.
  70      */
  71     public int pos = Position.NOPOS;
  72 
  73     /** The toplevel tree to which created trees belong.
  74      */
  75     public JCCompilationUnit toplevel;
  76 
  77     /** The current name table. */
  78     Names names;
  79 
  80     Types types;
  81 
  82     /** The current symbol table. */
  83     Symtab syms;
  84 
  85     /** Create a tree maker with null toplevel and NOPOS as initial position.
  86      */
  87     protected TreeMaker(Context context) {
  88         context.put(treeMakerKey, this);
  89         this.pos = Position.NOPOS;
  90         this.toplevel = null;
  91         this.names = Names.instance(context);
  92         this.syms = Symtab.instance(context);
  93         this.types = Types.instance(context);
  94     }
  95 
  96     /** Create a tree maker with a given toplevel and FIRSTPOS as initial position.
  97      */
  98     protected TreeMaker(JCCompilationUnit toplevel, Names names, Types types, Symtab syms) {
  99         this.pos = Position.FIRSTPOS;
 100         this.toplevel = toplevel;
 101         this.names = names;
 102         this.types = types;
 103         this.syms = syms;
 104     }
 105 
 106     /** Create a new tree maker for a given toplevel.
 107      */
 108     public TreeMaker forToplevel(JCCompilationUnit toplevel) {
 109         return new TreeMaker(toplevel, names, types, syms);
 110     }
 111 
 112     /** Reassign current position.
 113      */
 114     public TreeMaker at(int pos) {
 115         this.pos = pos;
 116         return this;
 117     }
 118 
 119     /** Reassign current position.
 120      */
 121     public TreeMaker at(DiagnosticPosition pos) {
 122         this.pos = (pos == null ? Position.NOPOS : pos.getStartPosition());
 123         return this;
 124     }
 125 
 126     /**
 127      * Create given tree node at current position.
 128      * @param defs a list of PackageDef, ClassDef, Import, and Skip
 129      */
 130     public JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs) {
 131         for (JCTree node : defs)
 132             Assert.check(node instanceof JCClassDecl
 133                 || node instanceof JCPackageDecl
 134                 || node instanceof JCImport
 135                 || node instanceof JCModuleDecl
 136                 || node instanceof JCSkip
 137                 || node instanceof JCErroneous
 138                 || (node instanceof JCExpressionStatement
 139                     &amp;&amp; ((JCExpressionStatement)node).expr instanceof JCErroneous),
 140                     () -&gt; node.getClass().getSimpleName());
 141         JCCompilationUnit tree = new JCCompilationUnit(defs);
 142         tree.pos = pos;
 143         return tree;
 144     }
 145 
 146     public JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
 147                                      JCExpression pid) {
 148         Assert.checkNonNull(annotations);
 149         Assert.checkNonNull(pid);
 150         JCPackageDecl tree = new JCPackageDecl(annotations, pid);
 151         tree.pos = pos;
 152         return tree;
 153     }
 154 
 155     public JCImport Import(JCTree qualid, boolean importStatic) {
 156         JCImport tree = new JCImport(qualid, importStatic);
 157         tree.pos = pos;
 158         return tree;
 159     }
 160 
 161     public JCClassDecl ClassDef(JCModifiers mods,
 162                                 Name name,
 163                                 List&lt;JCTypeParameter&gt; typarams,
 164                                 JCExpression extending,
 165                                 List&lt;JCExpression&gt; implementing,
 166                                 List&lt;JCTree&gt; defs)
 167     {
 168         JCClassDecl tree = new JCClassDecl(mods,
 169                                      name,
 170                                      typarams,
 171                                      extending,
 172                                      implementing,
 173                                      defs,
 174                                      null);
 175         tree.pos = pos;
 176         return tree;
 177     }
 178 
 179     public JCMethodDecl MethodDef(JCModifiers mods,
 180                                Name name,
 181                                JCExpression restype,
 182                                List&lt;JCTypeParameter&gt; typarams,
 183                                List&lt;JCVariableDecl&gt; params,
 184                                List&lt;JCExpression&gt; thrown,
 185                                JCBlock body,
 186                                JCExpression defaultValue) {
 187         return MethodDef(
 188                 mods, name, restype, typarams, null, params,
 189                 thrown, body, defaultValue);
 190     }
 191 
 192     public JCMethodDecl MethodDef(JCModifiers mods,
 193                                Name name,
 194                                JCExpression restype,
 195                                List&lt;JCTypeParameter&gt; typarams,
 196                                JCVariableDecl recvparam,
 197                                List&lt;JCVariableDecl&gt; params,
 198                                List&lt;JCExpression&gt; thrown,
 199                                JCBlock body,
 200                                JCExpression defaultValue)
 201     {
 202         JCMethodDecl tree = new JCMethodDecl(mods,
 203                                        name,
 204                                        restype,
 205                                        typarams,
 206                                        recvparam,
 207                                        params,
 208                                        thrown,
 209                                        body,
 210                                        defaultValue,
 211                                        null);
 212         tree.pos = pos;
 213         return tree;
 214     }
 215 
 216     public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {
 217         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null);
 218         tree.pos = pos;
 219         return tree;
 220     }
 221 
 222     public JCVariableDecl ReceiverVarDef(JCModifiers mods, JCExpression name, JCExpression vartype) {
 223         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype);
 224         tree.pos = pos;
 225         return tree;
 226     }
 227 
 228     public JCSkip Skip() {
 229         JCSkip tree = new JCSkip();
 230         tree.pos = pos;
 231         return tree;
 232     }
 233 
 234     public JCBlock Block(long flags, List&lt;JCStatement&gt; stats) {
 235         JCBlock tree = new JCBlock(flags, stats);
 236         tree.pos = pos;
 237         return tree;
 238     }
 239 
 240     public JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond) {
 241         JCDoWhileLoop tree = new JCDoWhileLoop(body, cond);
 242         tree.pos = pos;
 243         return tree;
 244     }
 245 
 246     public JCWhileLoop WhileLoop(JCExpression cond, JCStatement body) {
 247         JCWhileLoop tree = new JCWhileLoop(cond, body);
 248         tree.pos = pos;
 249         return tree;
 250     }
 251 
 252     public JCForLoop ForLoop(List&lt;JCStatement&gt; init,
 253                            JCExpression cond,
 254                            List&lt;JCExpressionStatement&gt; step,
 255                            JCStatement body)
 256     {
 257         JCForLoop tree = new JCForLoop(init, cond, step, body);
 258         tree.pos = pos;
 259         return tree;
 260     }
 261 
 262     public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
 263         JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);
 264         tree.pos = pos;
 265         return tree;
 266     }
 267 
 268     public JCLabeledStatement Labelled(Name label, JCStatement body) {
 269         JCLabeledStatement tree = new JCLabeledStatement(label, body);
 270         tree.pos = pos;
 271         return tree;
 272     }
 273 
 274     public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases) {
 275         JCSwitch tree = new JCSwitch(selector, cases);
 276         tree.pos = pos;
 277         return tree;
 278     }
 279 
 280     public JCCase Case(CaseTree.CaseKind caseKind, List&lt;JCExpression&gt; pats,
 281                        List&lt;JCStatement&gt; stats, JCTree body) {
 282         JCCase tree = new JCCase(caseKind, pats, stats, body);
 283         tree.pos = pos;
 284         return tree;
 285     }
 286 
 287     public JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
 288         JCSwitchExpression tree = new JCSwitchExpression(selector, cases);
 289         tree.pos = pos;
 290         return tree;
 291     }
 292 
 293     public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
 294         JCSynchronized tree = new JCSynchronized(lock, body);
 295         tree.pos = pos;
 296         return tree;
 297     }
 298 
 299     public JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer) {
 300         return Try(List.nil(), body, catchers, finalizer);
 301     }
 302 
 303     public JCTry Try(List&lt;JCTree&gt; resources,
 304                      JCBlock body,
 305                      List&lt;JCCatch&gt; catchers,
 306                      JCBlock finalizer) {
 307         JCTry tree = new JCTry(resources, body, catchers, finalizer);
 308         tree.pos = pos;
 309         return tree;
 310     }
 311 
 312     public JCCatch Catch(JCVariableDecl param, JCBlock body) {
 313         JCCatch tree = new JCCatch(param, body);
 314         tree.pos = pos;
 315         return tree;
 316     }
 317 
 318     public JCConditional Conditional(JCExpression cond,
 319                                    JCExpression thenpart,
 320                                    JCExpression elsepart)
 321     {
 322         JCConditional tree = new JCConditional(cond, thenpart, elsepart);
 323         tree.pos = pos;
 324         return tree;
 325     }
 326 
 327     public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
 328         JCIf tree = new JCIf(cond, thenpart, elsepart);
 329         tree.pos = pos;
 330         return tree;
 331     }
 332 
 333     public JCExpressionStatement Exec(JCExpression expr) {
 334         JCExpressionStatement tree = new JCExpressionStatement(expr);
 335         tree.pos = pos;
 336         return tree;
 337     }
 338 
 339     public JCBreak Break(Name label) {
 340         JCBreak tree = new JCBreak(label, null);
 341         tree.pos = pos;
 342         return tree;
 343     }
 344 
 345     public JCYield Yield(JCExpression value) {
 346         JCYield tree = new JCYield(value, null);
 347         tree.pos = pos;
 348         return tree;
 349     }
 350 
 351     public JCContinue Continue(Name label) {
 352         JCContinue tree = new JCContinue(label, null);
 353         tree.pos = pos;
 354         return tree;
 355     }
 356 
 357     public JCReturn Return(JCExpression expr) {
 358         JCReturn tree = new JCReturn(expr);
 359         tree.pos = pos;
 360         return tree;
 361     }
 362 
 363     public JCThrow Throw(JCExpression expr) {
 364         JCThrow tree = new JCThrow(expr);
 365         tree.pos = pos;
 366         return tree;
 367     }
 368 
 369     public JCAssert Assert(JCExpression cond, JCExpression detail) {
 370         JCAssert tree = new JCAssert(cond, detail);
 371         tree.pos = pos;
 372         return tree;
 373     }
 374 
 375     public JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
 376                        JCExpression fn,
 377                        List&lt;JCExpression&gt; args)
 378     {
 379         JCMethodInvocation tree = new JCMethodInvocation(typeargs, fn, args);
 380         tree.pos = pos;
 381         return tree;
 382     }
 383 
 384     public JCNewClass NewClass(JCExpression encl,
 385                              List&lt;JCExpression&gt; typeargs,
 386                              JCExpression clazz,
 387                              List&lt;JCExpression&gt; args,
 388                              JCClassDecl def)
 389     {
 390         return SpeculativeNewClass(encl, typeargs, clazz, args, def, false);
 391     }
 392 
 393     public JCNewClass SpeculativeNewClass(JCExpression encl,
 394                              List&lt;JCExpression&gt; typeargs,
 395                              JCExpression clazz,
 396                              List&lt;JCExpression&gt; args,
 397                              JCClassDecl def,
 398                              boolean classDefRemoved)
 399     {
 400         JCNewClass tree = classDefRemoved ?
 401                 new JCNewClass(encl, typeargs, clazz, args, def) {
 402                     @Override
 403                     public boolean classDeclRemoved() {
 404                         return true;
 405                     }
 406                 } :
 407                 new JCNewClass(encl, typeargs, clazz, args, def);
 408         tree.pos = pos;
 409         return tree;
 410     }
 411 
 412     public JCNewArray NewArray(JCExpression elemtype,
 413                              List&lt;JCExpression&gt; dims,
 414                              List&lt;JCExpression&gt; elems)
 415     {
 416         JCNewArray tree = new JCNewArray(elemtype, dims, elems);
 417         tree.pos = pos;
 418         return tree;
 419     }
 420 
 421     public JCLambda Lambda(List&lt;JCVariableDecl&gt; params,
 422                            JCTree body)
 423     {
 424         JCLambda tree = new JCLambda(params, body);
 425         tree.pos = pos;
 426         return tree;
 427     }
 428 
 429     public JCParens Parens(JCExpression expr) {
 430         JCParens tree = new JCParens(expr);
 431         tree.pos = pos;
 432         return tree;
 433     }
 434 
 435     public JCAssign Assign(JCExpression lhs, JCExpression rhs) {
 436         JCAssign tree = new JCAssign(lhs, rhs);
 437         tree.pos = pos;
 438         return tree;
 439     }
 440 
 441     public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs) {
 442         JCAssignOp tree = new JCAssignOp(opcode, lhs, rhs, null);
 443         tree.pos = pos;
 444         return tree;
 445     }
 446 
 447     public JCUnary Unary(JCTree.Tag opcode, JCExpression arg) {
 448         JCUnary tree = new JCUnary(opcode, arg);
 449         tree.pos = pos;
 450         return tree;
 451     }
 452 
 453     public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
 454         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
 455         tree.pos = pos;
 456         return tree;
 457     }
 458 
 459     public JCTypeCast TypeCast(JCTree clazz, JCExpression expr) {
 460         JCTypeCast tree = new JCTypeCast(clazz, expr);
 461         tree.pos = pos;
 462         return tree;
 463     }
 464 
 465     public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
 466         JCInstanceOf tree = new JCInstanceOf(expr, clazz);
 467         tree.pos = pos;
 468         return tree;
 469     }
 470 
 471     public JCBindingPattern BindingPattern(Name name, JCTree vartype) {
 472         JCBindingPattern tree = new JCBindingPattern(name, null, vartype);
 473         tree.pos = pos;
 474         return tree;
 475     }
 476 
 477     public JCDeconstructionPattern DeconstructionPattern(Name name, JCExpression deconstructor, List&lt;JCPattern&gt; nested) {
 478         JCDeconstructionPattern tree = new JCDeconstructionPattern(name, deconstructor, nested);
 479         tree.pos = pos;
 480         return tree;
 481     }
 482 
 483     public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
 484         JCArrayAccess tree = new JCArrayAccess(indexed, index);
 485         tree.pos = pos;
 486         return tree;
 487     }
 488 
 489     public JCFieldAccess Select(JCExpression selected, Name selector) {
 490         JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
 491         tree.pos = pos;
 492         return tree;
 493     }
 494 
 495     public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
 496             JCExpression expr, List&lt;JCExpression&gt; typeargs) {
 497         JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
 498         tree.pos = pos;
 499         return tree;
 500     }
 501 
 502     public JCIdent Ident(Name name) {
 503         JCIdent tree = new JCIdent(name, null);
 504         tree.pos = pos;
 505         return tree;
 506     }
 507 
 508     public JCLiteral Literal(TypeTag tag, Object value) {
 509         JCLiteral tree = new JCLiteral(tag, value);
 510         tree.pos = pos;
 511         return tree;
 512     }
 513 
 514     public JCPrimitiveTypeTree TypeIdent(TypeTag typetag) {
 515         JCPrimitiveTypeTree tree = new JCPrimitiveTypeTree(typetag);
 516         tree.pos = pos;
 517         return tree;
 518     }
 519 
 520     public JCArrayTypeTree TypeArray(JCExpression elemtype) {
 521         JCArrayTypeTree tree = new JCArrayTypeTree(elemtype);
 522         tree.pos = pos;
 523         return tree;
 524     }
 525 
 526     public JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
 527         JCTypeApply tree = new JCTypeApply(clazz, arguments);
 528         tree.pos = pos;
 529         return tree;
 530     }
 531 
 532     public JCTypeUnion TypeUnion(List&lt;JCExpression&gt; components) {
 533         JCTypeUnion tree = new JCTypeUnion(components);
 534         tree.pos = pos;
 535         return tree;
 536     }
 537 
 538     public JCTypeIntersection TypeIntersection(List&lt;JCExpression&gt; components) {
 539         JCTypeIntersection tree = new JCTypeIntersection(components);
 540         tree.pos = pos;
 541         return tree;
 542     }
 543 
 544     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds) {
 545         return TypeParameter(name, bounds, List.nil());
 546     }
 547 
 548     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annos) {
 549         JCTypeParameter tree = new JCTypeParameter(name, bounds, annos);
 550         tree.pos = pos;
 551         return tree;
 552     }
 553 
 554     public JCWildcard Wildcard(TypeBoundKind kind, JCTree type) {
 555         JCWildcard tree = new JCWildcard(kind, type);
 556         tree.pos = pos;
 557         return tree;
 558     }
 559 
 560     public TypeBoundKind TypeBoundKind(BoundKind kind) {
 561         TypeBoundKind tree = new TypeBoundKind(kind);
 562         tree.pos = pos;
 563         return tree;
 564     }
 565 
 566     public JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 567         JCAnnotation tree = new JCAnnotation(Tag.ANNOTATION, annotationType, args);
 568         tree.pos = pos;
 569         return tree;
 570     }
 571 
 572     public JCAnnotation TypeAnnotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 573         JCAnnotation tree = new JCAnnotation(Tag.TYPE_ANNOTATION, annotationType, args);
 574         tree.pos = pos;
 575         return tree;
 576     }
 577 
 578     public JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
 579         JCModifiers tree = new JCModifiers(flags, annotations);
 580         boolean noFlags = (flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0;
 581         tree.pos = (noFlags &amp;&amp; annotations.isEmpty()) ? Position.NOPOS : pos;
 582         return tree;
 583     }
 584 
 585     public JCModifiers Modifiers(long flags) {
 586         return Modifiers(flags, List.nil());
 587     }
 588 
 589     @Override
 590     public JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind,
 591             JCExpression qualid, List&lt;JCDirective&gt; directives) {
 592         JCModuleDecl tree = new JCModuleDecl(mods, kind, qualid, directives);
 593         tree.pos = pos;
 594         return tree;
 595     }
 596 
 597     @Override
 598     public JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 599         JCExports tree = new JCExports(qualId, moduleNames);
 600         tree.pos = pos;
 601         return tree;
 602     }
 603 
 604     @Override
 605     public JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 606         JCOpens tree = new JCOpens(qualId, moduleNames);
 607         tree.pos = pos;
 608         return tree;
 609     }
 610 
 611     @Override
 612     public JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
 613         JCProvides tree = new JCProvides(serviceName, implNames);
 614         tree.pos = pos;
 615         return tree;
 616     }
 617 
 618     @Override
 619     public JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId) {
 620         JCRequires tree = new JCRequires(isTransitive, isStaticPhase, qualId);
 621         tree.pos = pos;
 622         return tree;
 623     }
 624 
 625     @Override
 626     public JCUses Uses(JCExpression qualId) {
 627         JCUses tree = new JCUses(qualId);
 628         tree.pos = pos;
 629         return tree;
 630     }
 631 
 632     public JCAnnotatedType AnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
 633         JCAnnotatedType tree = new JCAnnotatedType(annotations, underlyingType);
 634         tree.pos = pos;
 635         return tree;
 636     }
 637 
 638     public JCErroneous Erroneous() {
 639         return Erroneous(List.nil());
 640     }
 641 
 642     public JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs) {
 643         JCErroneous tree = new JCErroneous(errs);
 644         tree.pos = pos;
 645         return tree;
 646     }
 647 
 648     public LetExpr LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr) {
 649         LetExpr tree = new LetExpr(defs, expr);
 650         tree.pos = pos;
 651         return tree;
 652     }
 653 
 654 /* ***************************************************************************
 655  * Derived building blocks.
 656  ****************************************************************************/
 657 
 658     public JCClassDecl AnonymousClassDef(JCModifiers mods,
 659                                          List&lt;JCTree&gt; defs)
 660     {
 661         return ClassDef(mods,
 662                         names.empty,
 663                         List.nil(),
 664                         null,
 665                         List.nil(),
 666                         defs);
 667     }
 668 
 669     public LetExpr LetExpr(JCVariableDecl def, JCExpression expr) {
 670         LetExpr tree = new LetExpr(List.of(def), expr);
 671         tree.pos = pos;
 672         return tree;
 673     }
 674 
 675     /** Create an identifier from a symbol.
 676      */
 677     public JCIdent Ident(Symbol sym) {
 678         return (JCIdent)new JCIdent((sym.name != names.empty)
 679                                 ? sym.name
 680                                 : sym.flatName(), sym)
 681             .setPos(pos)
 682             .setType(sym.type);
 683     }
 684 
 685     /** Create a selection node from a qualifier tree and a symbol.
 686      *  @param base   The qualifier tree.
 687      */
 688     public JCExpression Select(JCExpression base, Symbol sym) {
 689         return new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);
 690     }
 691 
 692     /** Create a qualified identifier from a symbol, adding enough qualifications
 693      *  to make the reference unique.
 694      */
 695     public JCExpression QualIdent(Symbol sym) {
 696         return isUnqualifiable(sym)
 697             ? Ident(sym)
 698             : Select(QualIdent(sym.owner), sym);
 699     }
 700 
 701     /** Create an identifier that refers to the variable declared in given variable
 702      *  declaration.
 703      */
 704     public JCExpression Ident(JCVariableDecl param) {
 705         return Ident(param.sym);
 706     }
 707 
 708     /** Create a list of identifiers referring to the variables declared
 709      *  in given list of variable declarations.
 710      */
 711     public List&lt;JCExpression&gt; Idents(List&lt;JCVariableDecl&gt; params) {
 712         ListBuffer&lt;JCExpression&gt; ids = new ListBuffer&lt;&gt;();
 713         for (List&lt;JCVariableDecl&gt; l = params; l.nonEmpty(); l = l.tail)
 714             ids.append(Ident(l.head));
 715         return ids.toList();
 716     }
 717 
 718     /** Create a tree representing `this&#39;, given its type.
 719      */
 720     public JCExpression This(Type t) {
 721         return Ident(new VarSymbol(FINAL, names._this, t, t.tsym));
 722     }
 723 
 724     /** Create a tree representing qualified `this&#39; given its type
 725      */
 726     public JCExpression QualThis(Type t) {
 727         return Select(Type(t), new VarSymbol(FINAL, names._this, t, t.tsym));
 728     }
 729 
 730     /** Create a tree representing a class literal.
 731      */
 732     public JCExpression ClassLiteral(ClassSymbol clazz) {
 733         return ClassLiteral(clazz.type);
 734     }
 735 
 736     /** Create a tree representing a class literal.
 737      */
 738     public JCExpression ClassLiteral(Type t) {
 739         VarSymbol lit = new VarSymbol(STATIC | PUBLIC | FINAL,
 740                                       names._class,
 741                                       t,
 742                                       t.tsym);
 743         return Select(Type(t), lit);
 744     }
 745 
 746     /** Create a tree representing `super&#39;, given its type and owner.
 747      */
 748     public JCIdent Super(Type t, TypeSymbol owner) {
 749         return Ident(new VarSymbol(FINAL, names._super, t, owner));
 750     }
 751 
 752     /**
 753      * Create a method invocation from a method tree and a list of
 754      * argument trees.
 755      */
 756     public JCMethodInvocation App(JCExpression meth, List&lt;JCExpression&gt; args) {
 757         return Apply(null, meth, args).setType(meth.type.getReturnType());
 758     }
 759 
 760     /**
 761      * Create a no-arg method invocation from a method tree
 762      */
 763     public JCMethodInvocation App(JCExpression meth) {
 764         return Apply(null, meth, List.nil()).setType(meth.type.getReturnType());
 765     }
 766 
 767     /** Create a method invocation from a method tree and a list of argument trees.
 768      */
 769     public JCExpression Create(Symbol ctor, List&lt;JCExpression&gt; args) {
 770         Type t = ctor.owner.erasure(types);
 771         JCNewClass newclass = NewClass(null, null, Type(t), args, null);
 772         newclass.constructor = ctor;
 773         newclass.setType(t);
 774         return newclass;
 775     }
 776 
 777     /** Create a tree representing given type.
 778      */
 779     public JCExpression Type(Type t) {
 780         if (t == null) return null;
 781         JCExpression tp;
 782         switch (t.getTag()) {
 783         case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
 784         case DOUBLE: case BOOLEAN: case VOID:
 785             tp = TypeIdent(t.getTag());
 786             break;
 787         case TYPEVAR:
 788             tp = Ident(t.tsym);
 789             break;
 790         case WILDCARD: {
 791             WildcardType a = ((WildcardType) t);
 792             tp = Wildcard(TypeBoundKind(a.kind), a.kind == BoundKind.UNBOUND ? null : Type(a.type));
 793             break;
 794         }
 795         case CLASS:
 796             switch (t.getKind()) {
 797             case UNION: {
 798                 UnionClassType tu = (UnionClassType)t;
 799                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 800                 for (Type ta : tu.getAlternativeTypes()) {
 801                     la.add(Type(ta));
 802                 }
 803                 tp = TypeUnion(la.toList());
 804                 break;
 805             }
 806             case INTERSECTION: {
 807                 IntersectionClassType it = (IntersectionClassType)t;
 808                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 809                 for (Type ta : it.getExplicitComponents()) {
 810                     la.add(Type(ta));
 811                 }
 812                 tp = TypeIntersection(la.toList());
 813                 break;
 814             }
 815             default: {
 816                 Type outer = t.getEnclosingType();
 817                 JCExpression clazz = outer.hasTag(CLASS) &amp;&amp; t.tsym.owner.kind == TYP
 818                         ? Select(Type(outer), t.tsym)
 819                         : QualIdent(t.tsym);
 820                 tp = t.getTypeArguments().isEmpty()
 821                         ? clazz
 822                         : TypeApply(clazz, Types(t.getTypeArguments()));
 823                 break;
 824             }
 825             }
 826             break;
 827         case ARRAY:
 828             tp = TypeArray(Type(types.elemtype(t)));
 829             break;
 830         case ERROR:
 831             tp = TypeIdent(ERROR);
 832             break;
 833         default:
 834             throw new AssertionError(&quot;unexpected type: &quot; + t);
 835         }
 836         return tp.setType(t);
 837     }
 838 
 839     /** Create a list of trees representing given list of types.
 840      */
 841     public List&lt;JCExpression&gt; Types(List&lt;Type&gt; ts) {
 842         ListBuffer&lt;JCExpression&gt; lb = new ListBuffer&lt;&gt;();
 843         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 844             lb.append(Type(l.head));
 845         return lb.toList();
 846     }
 847 
 848     /** Create a variable definition from a variable symbol and an initializer
 849      *  expression.
 850      */
 851     public JCVariableDecl VarDef(VarSymbol v, JCExpression init) {
 852         return (JCVariableDecl)
 853             new JCVariableDecl(
 854                 Modifiers(v.flags(), Annotations(v.getRawAttributes())),
 855                 v.name,
 856                 Type(v.type),
 857                 init,
 858                 v).setPos(pos).setType(v.type);
 859     }
 860 
 861     /** Create annotation trees from annotations.
 862      */
 863     public List&lt;JCAnnotation&gt; Annotations(List&lt;Attribute.Compound&gt; attributes) {
 864         if (attributes == null) return List.nil();
 865         ListBuffer&lt;JCAnnotation&gt; result = new ListBuffer&lt;&gt;();
 866         for (List&lt;Attribute.Compound&gt; i = attributes; i.nonEmpty(); i=i.tail) {
 867             Attribute a = i.head;
 868             result.append(Annotation(a));
 869         }
 870         return result.toList();
 871     }
 872 
 873     public JCLiteral Literal(Object value) {
 874         JCLiteral result = null;
 875         if (value instanceof String) {
 876             result = Literal(CLASS, value).
 877                 setType(syms.stringType.constType(value));
 878         } else if (value instanceof Integer) {
 879             result = Literal(INT, value).
 880                 setType(syms.intType.constType(value));
 881         } else if (value instanceof Long) {
 882             result = Literal(LONG, value).
 883                 setType(syms.longType.constType(value));
 884         } else if (value instanceof Byte) {
 885             result = Literal(BYTE, value).
 886                 setType(syms.byteType.constType(value));
 887         } else if (value instanceof Character) {
 888             int v = (int) (((Character) value).toString().charAt(0));
 889             result = Literal(CHAR, v).
 890                 setType(syms.charType.constType(v));
 891         } else if (value instanceof Double) {
 892             result = Literal(DOUBLE, value).
 893                 setType(syms.doubleType.constType(value));
 894         } else if (value instanceof Float) {
 895             result = Literal(FLOAT, value).
 896                 setType(syms.floatType.constType(value));
 897         } else if (value instanceof Short) {
 898             result = Literal(SHORT, value).
 899                 setType(syms.shortType.constType(value));
 900         } else if (value instanceof Boolean) {
 901             int v = ((Boolean) value) ? 1 : 0;
 902             result = Literal(BOOLEAN, v).
 903                 setType(syms.booleanType.constType(v));
 904         } else {
 905             throw new AssertionError(value);
 906         }
 907         return result;
 908     }
 909 
 910     class AnnotationBuilder implements Attribute.Visitor {
 911         JCExpression result = null;
 912         public void visitConstant(Attribute.Constant v) {
 913             result = Literal(v.type.getTag(), v.value);
 914         }
 915         public void visitClass(Attribute.Class clazz) {
 916             result = ClassLiteral(clazz.classType).setType(syms.classType);
 917         }
 918         public void visitEnum(Attribute.Enum e) {
 919             result = QualIdent(e.value);
 920         }
 921         public void visitError(Attribute.Error e) {
 922             if (e instanceof UnresolvedClass) {
 923                 result = ClassLiteral(((UnresolvedClass) e).classType).setType(syms.classType);
 924             } else {
 925                 result = Erroneous();
 926             }
 927         }
 928         public void visitCompound(Attribute.Compound compound) {
 929             if (compound instanceof Attribute.TypeCompound) {
 930                 result = visitTypeCompoundInternal((Attribute.TypeCompound) compound);
 931             } else {
 932                 result = visitCompoundInternal(compound);
 933             }
 934         }
 935         public JCAnnotation visitCompoundInternal(Attribute.Compound compound) {
 936             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 937             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 938                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 939                 JCExpression valueTree = translate(pair.snd);
 940                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 941             }
 942             return Annotation(Type(compound.type), args.toList());
 943         }
 944         public JCAnnotation visitTypeCompoundInternal(Attribute.TypeCompound compound) {
 945             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 946             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 947                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 948                 JCExpression valueTree = translate(pair.snd);
 949                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 950             }
 951             return TypeAnnotation(Type(compound.type), args.toList());
 952         }
 953         public void visitArray(Attribute.Array array) {
 954             ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
 955             for (int i = 0; i &lt; array.values.length; i++)
 956                 elems.append(translate(array.values[i]));
 957             result = NewArray(null, List.nil(), elems.toList()).setType(array.type);
 958         }
 959         JCExpression translate(Attribute a) {
 960             a.accept(this);
 961             return result;
 962         }
 963         JCAnnotation translate(Attribute.Compound a) {
 964             return visitCompoundInternal(a);
 965         }
 966         JCAnnotation translate(Attribute.TypeCompound a) {
 967             return visitTypeCompoundInternal(a);
 968         }
 969     }
 970 
 971     AnnotationBuilder annotationBuilder = new AnnotationBuilder();
 972 
 973     /** Create an annotation tree from an attribute.
 974      */
 975     public JCAnnotation Annotation(Attribute a) {
 976         return annotationBuilder.translate((Attribute.Compound)a);
 977     }
 978 
 979     public JCAnnotation TypeAnnotation(Attribute a) {
 980         return annotationBuilder.translate((Attribute.TypeCompound) a);
 981     }
 982 
 983     /** Create a method definition from a method symbol and a method body.
 984      */
 985     public JCMethodDecl MethodDef(MethodSymbol m, JCBlock body) {
 986         return MethodDef(m, m.type, body);
 987     }
 988 
 989     /** Create a method definition from a method symbol, method type
 990      *  and a method body.
 991      */
 992     public JCMethodDecl MethodDef(MethodSymbol m, Type mtype, JCBlock body) {
 993         return (JCMethodDecl)
 994             new JCMethodDecl(
 995                 Modifiers(m.flags(), Annotations(m.getRawAttributes())),
 996                 m.name,
 997                 Type(mtype.getReturnType()),
 998                 TypeParams(mtype.getTypeArguments()),
 999                 null, // receiver type
1000                 Params(mtype.getParameterTypes(), m),
1001                 Types(mtype.getThrownTypes()),
1002                 body,
1003                 null,
1004                 m).setPos(pos).setType(mtype);
1005     }
1006 
1007     /** Create a type parameter tree from its name and type.
1008      */
1009     public JCTypeParameter TypeParam(Name name, TypeVar tvar) {
1010         return (JCTypeParameter)
1011             TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);
1012     }
1013 
1014     /** Create a list of type parameter trees from a list of type variables.
1015      */
1016     public List&lt;JCTypeParameter&gt; TypeParams(List&lt;Type&gt; typarams) {
1017         ListBuffer&lt;JCTypeParameter&gt; tparams = new ListBuffer&lt;&gt;();
1018         for (List&lt;Type&gt; l = typarams; l.nonEmpty(); l = l.tail)
1019             tparams.append(TypeParam(l.head.tsym.name, (TypeVar)l.head));
1020         return tparams.toList();
1021     }
1022 
1023     /** Create a value parameter tree from its name, type, and owner.
1024      */
1025     public JCVariableDecl Param(Name name, Type argtype, Symbol owner) {
1026         return VarDef(new VarSymbol(PARAMETER, name, argtype, owner), null);
1027     }
1028 
1029     /** Create a a list of value parameter trees x0, ..., xn from a list of
1030      *  their types and an their owner.
1031      */
1032     public List&lt;JCVariableDecl&gt; Params(List&lt;Type&gt; argtypes, Symbol owner) {
1033         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
1034         MethodSymbol mth = (owner.kind == MTH) ? ((MethodSymbol)owner) : null;
1035         if (mth != null &amp;&amp; mth.params != null &amp;&amp; argtypes.length() == mth.params.length()) {
1036             for (VarSymbol param : ((MethodSymbol)owner).params)
1037                 params.append(VarDef(param, null));
1038         } else {
1039             int i = 0;
1040             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1041                 params.append(Param(paramName(i++), l.head, owner));
1042         }
1043         return params.toList();
1044     }
1045 
1046     /** Wrap a method invocation in an expression statement or return statement,
1047      *  depending on whether the method invocation expression&#39;s type is void.
1048      */
1049     public JCStatement Call(JCExpression apply) {
1050         return apply.type.hasTag(VOID) ? Exec(apply) : Return(apply);
1051     }
1052 
1053     /** Construct an assignment from a variable symbol and a right hand side.
1054      */
1055     public JCStatement Assignment(Symbol v, JCExpression rhs) {
1056         return Exec(Assign(Ident(v), rhs).setType(v.type));
1057     }
1058 
1059     /** Construct an index expression from a variable and an expression.
1060      */
1061     public JCArrayAccess Indexed(Symbol v, JCExpression index) {
1062         JCArrayAccess tree = new JCArrayAccess(QualIdent(v), index);
1063         tree.type = ((ArrayType)v.type).elemtype;
1064         return tree;
1065     }
1066 
1067     /** Make an attributed type cast expression.
1068      */
1069     public JCTypeCast TypeCast(Type type, JCExpression expr) {
1070         return (JCTypeCast)TypeCast(Type(type), expr).setType(type);
1071     }
1072 
1073 /* ***************************************************************************
1074  * Helper methods.
1075  ****************************************************************************/
1076 
1077     /** Can given symbol be referred to in unqualified form?
1078      */
1079     boolean isUnqualifiable(Symbol sym) {
1080         if (sym.name == names.empty ||
1081             sym.owner == null ||
1082             sym.owner == syms.rootPackage ||
1083             sym.owner.kind == MTH || sym.owner.kind == VAR) {
1084             return true;
1085         } else if (sym.kind == TYP &amp;&amp; toplevel != null) {
1086             Iterator&lt;Symbol&gt; it = toplevel.namedImportScope.getSymbolsByName(sym.name).iterator();
1087             if (it.hasNext()) {
1088                 Symbol s = it.next();
1089                 return
1090                   s == sym &amp;&amp;
1091                   !it.hasNext();
1092             }
1093             it = toplevel.packge.members().getSymbolsByName(sym.name).iterator();
1094             if (it.hasNext()) {
1095                 Symbol s = it.next();
1096                 return
1097                   s == sym &amp;&amp;
1098                   !it.hasNext();
1099             }
1100             it = toplevel.starImportScope.getSymbolsByName(sym.name).iterator();
1101             if (it.hasNext()) {
1102                 Symbol s = it.next();
1103                 return
1104                   s == sym &amp;&amp;
1105                   !it.hasNext();
1106             }
1107         }
1108         return false;
1109     }
1110 
1111     /** The name of synthetic parameter number `i&#39;.
1112      */
1113     public Name paramName(int i)   { return names.fromString(&quot;x&quot; + i); }
1114 
1115     /** The name of synthetic type parameter number `i&#39;.
1116      */
1117     public Name typaramName(int i) { return names.fromString(&quot;A&quot; + i); }
1118 }
    </pre>
  </body>
</html>
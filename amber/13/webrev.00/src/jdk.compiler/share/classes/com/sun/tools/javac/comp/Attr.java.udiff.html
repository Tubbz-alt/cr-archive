<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../code/Symbol.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.udiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -25,10 +25,11 @@</span>
  
  package com.sun.tools.javac.comp;
  
  import java.util.*;
  import java.util.function.BiConsumer;
<span class="udiff-line-added">+ import java.util.stream.Stream;</span>
  
  import javax.lang.model.element.ElementKind;
  import javax.tools.JavaFileObject;
  
  import com.sun.source.tree.CaseTree;
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -74,11 +75,10 @@</span>
  import static com.sun.tools.javac.code.Kinds.Kind.*;
  import static com.sun.tools.javac.code.TypeTag.*;
  import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  import static com.sun.tools.javac.tree.JCTree.Tag.*;
  import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
<span class="udiff-line-removed">- import java.util.stream.Stream;</span>
  
  /** This is the main context-dependent analysis phase in GJC. It
   *  encompasses name resolution, type checking and constant folding as
   *  subtasks. Some subtasks involve auxiliary classes.
   *  @see Check
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3893,20 +3893,11 @@</span>
              boolean valid = false;
              if (allowReifiableTypesInInstanceof) {
                  if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
                      preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
                  }
<span class="udiff-line-modified-removed">-                 Warner warner = new Warner();</span>
<span class="udiff-line-removed">-                 if (!types.isCastable(exprtype, clazztype, warner)) {</span>
<span class="udiff-line-removed">-                     chk.basicHandler.report(tree.expr.pos(),</span>
<span class="udiff-line-removed">-                                             diags.fragment(Fragments.InconvertibleTypes(exprtype, clazztype)));</span>
<span class="udiff-line-removed">-                 } else if (warner.hasLint(LintCategory.UNCHECKED)) {</span>
<span class="udiff-line-removed">-                     log.error(tree.expr.pos(),</span>
<span class="udiff-line-removed">-                               Errors.InstanceofReifiableNotSafe(exprtype, clazztype));</span>
<span class="udiff-line-removed">-                 } else {</span>
<span class="udiff-line-removed">-                     valid = true;</span>
<span class="udiff-line-removed">-                 }</span>
<span class="udiff-line-modified-added">+                 valid = verifyCastable(tree.expr.pos(), exprtype, clazztype);</span>
              } else {
                  log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
              }
              if (!valid) {
                  clazztype = types.createErrorType(clazztype);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -3936,43 +3927,61 @@</span>
          matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
      }
  
      @Override
      public void visitDeconstructionPattern(JCDeconstructionPattern tree) {
<span class="udiff-line-modified-removed">-         Type site = tree.type = attribType(tree.deconstructor, env);</span>
<span class="udiff-line-modified-removed">-         List&lt;Type&gt; recordTypes;</span>
<span class="udiff-line-modified-added">+         tree.type = attribType(tree.deconstructor, env);</span>
<span class="udiff-line-modified-added">+         Type site = types.removeWildcards(tree.type);</span>
<span class="udiff-line-added">+         List&lt;Type&gt; expectedRecordTypes;</span>
          if (site.tsym.kind == Kind.TYP &amp;&amp; ((ClassSymbol) site.tsym).isRecord()) {
              ClassSymbol record = (ClassSymbol) site.tsym;
<span class="udiff-line-modified-removed">-             recordTypes = record.getRecordComponents().stream().map(rc -&gt; rc.type).collect(List.collector());</span>
<span class="udiff-line-modified-added">+             expectedRecordTypes = record.getRecordComponents().stream().map(rc -&gt; types.memberType(site, rc)).collect(List.collector());</span>
              tree.record = record;
          } else {
              log.error(tree.pos(), Errors.DeconstructionPatternOnlyRecords(site.tsym));
<span class="udiff-line-modified-removed">-             recordTypes = Stream.generate(() -&gt; Type.noType)</span>
<span class="udiff-line-modified-added">+             expectedRecordTypes = Stream.generate(() -&gt; Type.noType)</span>
                                  .limit(tree.nested.size())
                                  .collect(List.collector());
          }
          ListBuffer&lt;BindingSymbol&gt; outBindings = new ListBuffer&lt;&gt;();
<span class="udiff-line-added">+         List&lt;Type&gt; recordTypes = expectedRecordTypes;</span>
          List&lt;JCPattern&gt; nestedPatterns = tree.nested;
          while (recordTypes.nonEmpty() &amp;&amp; nestedPatterns.nonEmpty()) {
<span class="udiff-line-modified-removed">-             boolean nestedIsValidPattern = !nestedPatterns.head.hasTag(BINDINGPATTERN) ||</span>
<span class="udiff-line-modified-removed">-                                            ((JCBindingPattern) nestedPatterns.head).vartype == null;</span>
<span class="udiff-line-modified-removed">-             attribExpr(nestedPatterns.head, env, nestedIsValidPattern ? recordTypes.head : Type.noType);</span>
<span class="udiff-line-modified-added">+             boolean nestedIsVarPattern = nestedPatterns.head.hasTag(BINDINGPATTERN) &amp;&amp;</span>
<span class="udiff-line-modified-added">+                                          ((JCBindingPattern) nestedPatterns.head).vartype == null;</span>
<span class="udiff-line-modified-added">+             attribExpr(nestedPatterns.head, env, nestedIsVarPattern ? recordTypes.head : Type.noType);</span>
<span class="udiff-line-added">+             verifyCastable(nestedPatterns.head.pos(), recordTypes.head, nestedPatterns.head.type);</span>
              outBindings.addAll(matchBindings.bindingsWhenTrue);
              nestedPatterns = nestedPatterns.tail;
              recordTypes = recordTypes.tail;
          }
<span class="udiff-line-added">+         if (recordTypes.nonEmpty() || nestedPatterns.nonEmpty()) {</span>
<span class="udiff-line-added">+             while (nestedPatterns.nonEmpty()) {</span>
<span class="udiff-line-added">+                 attribExpr(nestedPatterns.head, env, Type.noType);</span>
<span class="udiff-line-added">+                 nestedPatterns = nestedPatterns.tail;</span>
<span class="udiff-line-added">+             }</span>
<span class="udiff-line-added">+             List&lt;Type&gt; nestedTypes =</span>
<span class="udiff-line-added">+                     tree.nested.stream().map(p -&gt; p.type).collect(List.collector());</span>
<span class="udiff-line-added">+             log.error(tree.pos(),</span>
<span class="udiff-line-added">+                       Errors.IncorrectNumberOfNestedPatterns(expectedRecordTypes,</span>
<span class="udiff-line-added">+                                                              nestedTypes));</span>
<span class="udiff-line-added">+         }</span>
          result = tree.type;
          matchBindings = new MatchBindings(outBindings.toList(), List.nil());
      }
  
<span class="udiff-line-modified-removed">-     private boolean isSubTypesIgnoreNone(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {</span>
<span class="udiff-line-modified-removed">-         while (ts.tail != null &amp;&amp; ss.tail != null &amp;&amp;</span>
<span class="udiff-line-modified-removed">-                (ts.head == Type.noType || types.isSubtype(ts.head, ss.head))) {</span>
<span class="udiff-line-modified-removed">-             ts = ts.tail;</span>
<span class="udiff-line-modified-removed">-             ss = ss.tail;</span>
<span class="udiff-line-modified-added">+     private boolean verifyCastable(DiagnosticPosition pos, Type exprtype, Type clazztype) {</span>
<span class="udiff-line-modified-added">+         Warner warner = new Warner();</span>
<span class="udiff-line-modified-added">+         if (!chk.checkCastable(pos, exprtype, clazztype, chk.basicHandler, warner)) {</span>
<span class="udiff-line-modified-added">+             return false;</span>
<span class="udiff-line-modified-added">+         } else if (warner.hasLint(LintCategory.UNCHECKED)) {</span>
<span class="udiff-line-added">+             log.error(pos,</span>
<span class="udiff-line-added">+                       Errors.InstanceofReifiableNotSafe(exprtype, clazztype));</span>
<span class="udiff-line-added">+             return false;</span>
<span class="udiff-line-added">+         } else {</span>
<span class="udiff-line-added">+             return true;</span>
          }
<span class="udiff-line-removed">-         return ts.tail == null &amp;&amp; ss.tail == null;</span>
      }
  
      public void visitIndexed(JCArrayAccess tree) {
          Type owntype = types.createErrorType(tree.type);
          Type atype = attribExpr(tree.indexed, env);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -5631,11 +5640,11 @@</span>
                  that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
                  that.symbol.adr = 0;
              }
              super.visitBindingPattern(that);
          }
<span class="udiff-line-modified-removed">-         //XXX: DeconstructionPattern!!!!</span>
<span class="udiff-line-modified-added">+ </span>
          @Override
          public void visitNewClass(JCNewClass that) {
              if (that.constructor == null) {
                  that.constructor = new MethodSymbol(0, names.init,
                          dummyMethodType(), syms.noSymbol);
</pre>
<center><a href="../code/Symbol.java.udiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Check.java.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
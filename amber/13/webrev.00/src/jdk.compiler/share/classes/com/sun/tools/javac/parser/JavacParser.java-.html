<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
 243     protected static final int NOINVOCATION = 0x20;
 244 
 245     protected void selectExprMode() {
 246         //TODO: copy NOINVOCATION
 247         mode = (mode &amp; NOLAMBDA) | EXPR;
 248     }
 249 
 250     protected void selectTypeMode() {
 251         //TODO: copy NOINVOCATION
 252         mode = (mode &amp; NOLAMBDA) | TYPE;
 253     }
 254 
 255     /** The current mode.
 256      */
 257     protected int mode = 0;
 258 
 259     /** The mode of the term that was parsed last.
 260      */
 261     protected int lastmode = 0;
 262 
 263     /* ---------- token management -------------- */
 264 
 265     protected Token token;
 266 
 267     public Token token() {
 268         return token;
 269     }
 270 
 271     public void nextToken() {
 272         S.nextToken();
 273         token = S.token();
 274     }
 275 
 276     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 277         return peekToken(0, tk);
 278     }
 279 
 280     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 281         return tk.accepts(S.token(lookahead + 1).kind);
 282     }
 283 
 284     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 285         return peekToken(0, tk1, tk2);
 286     }
 287 
 288     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 289         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 290                 tk2.accepts(S.token(lookahead + 2).kind);
 291     }
 292 
 293     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 294         return peekToken(0, tk1, tk2, tk3);
 295     }
 296 
 297     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 298         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 299                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 300                 tk3.accepts(S.token(lookahead + 3).kind);
 301     }
 302 
 303     @SuppressWarnings(&quot;unchecked&quot;)
 304     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 305         return peekToken(0, kinds);
 306     }
 307 
 308     @SuppressWarnings(&quot;unchecked&quot;)
 309     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 310         for (; lookahead &lt; kinds.length ; lookahead++) {
 311             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 312                 return false;
 313             }
 314         }
 315         return true;
 316     }
 317 
 318     /* ---------- error recovery -------------- */
 319 
 320     private JCErroneous errorTree;
 321 
 322     /** Skip forward until a suitable stop token is found.
 323      */
 324     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 325          while (true) {
 326              switch (token.kind) {
 327                 case SEMI:
 328                     nextToken();
 329                     return;
 330                 case PUBLIC:
 331                 case FINAL:
 332                 case ABSTRACT:
 333                 case MONKEYS_AT:
 334                 case EOF:
 335                 case CLASS:
 336                 case INTERFACE:
 337                 case ENUM:
 338                     return;
 339                 case IMPORT:
 340                     if (stopAtImport)
 341                         return;
 342                     break;
 343                 case LBRACE:
 344                 case RBRACE:
 345                 case PRIVATE:
 346                 case PROTECTED:
 347                 case STATIC:
 348                 case TRANSIENT:
 349                 case NATIVE:
 350                 case VOLATILE:
 351                 case SYNCHRONIZED:
 352                 case STRICTFP:
 353                 case LT:
 354                 case BYTE:
 355                 case SHORT:
 356                 case CHAR:
 357                 case INT:
 358                 case LONG:
 359                 case FLOAT:
 360                 case DOUBLE:
 361                 case BOOLEAN:
 362                 case VOID:
 363                     if (stopAtMemberDecl)
 364                         return;
 365                     break;
 366                 case UNDERSCORE:
 367                 case IDENTIFIER:
 368                    if (stopAtIdentifier)
 369                         return;
 370                     break;
 371                 case CASE:
 372                 case DEFAULT:
 373                 case IF:
 374                 case FOR:
 375                 case WHILE:
 376                 case DO:
 377                 case TRY:
 378                 case SWITCH:
 379                 case RETURN:
 380                 case THROW:
 381                 case BREAK:
 382                 case CONTINUE:
 383                 case ELSE:
 384                 case FINALLY:
 385                 case CATCH:
 386                 case THIS:
 387                 case SUPER:
 388                 case NEW:
 389                     if (stopAtStatement)
 390                         return;
 391                     break;
 392                 case ASSERT:
 393                     if (stopAtStatement)
 394                         return;
 395                     break;
 396             }
 397             nextToken();
 398         }
 399     }
 400 
 401     protected JCErroneous syntaxError(int pos, Error errorKey) {
 402         return syntaxError(pos, List.nil(), errorKey);
 403     }
 404 
 405     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 406         setErrorEndPos(pos);
 407         JCErroneous err = F.at(pos).Erroneous(errs);
 408         reportSyntaxError(err, errorKey);
 409         if (errs != null) {
 410             JCTree last = errs.last();
 411             if (last != null)
 412                 storeEnd(last, pos);
 413         }
 414         return toP(err);
 415     }
 416 
 417     private static final int RECOVERY_THRESHOLD = 50;
 418     private int errorPos = Position.NOPOS;
 419     private int count = 0;
 420 
 421     /**
 422      * Report a syntax using the given the position parameter and arguments,
 423      * unless one was already reported at the same position.
 424      */
 425     protected void reportSyntaxError(int pos, Error errorKey) {
 426         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 427         reportSyntaxError(diag, errorKey);
 428     }
 429 
 430     /**
 431      * Report a syntax error using the given DiagnosticPosition object and
 432      * arguments, unless one was already reported at the same position.
 433      */
 434     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 435         int pos = diagPos.getPreferredPosition();
 436         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 437             if (token.kind == EOF) {
 438                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 439             } else {
 440                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 441             }
 442         }
 443         S.errPos(pos);
 444         if (token.pos == errorPos) {
 445             //check for a possible infinite loop in parsing:
 446             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 447         } else {
 448             count = 0;
 449             errorPos = token.pos;
 450         }
 451     }
 452 
 453     /** If next input token matches given token, skip it, otherwise report
 454      *  an error.
 455      */
 456     public void accept(TokenKind tk) {
 457         accept(tk, Errors::Expected);
 458     }
 459 
 460     /** If next input token matches given token, skip it, otherwise report
 461      *  an error.
 462      */
 463     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 464         if (token.kind == tk) {
 465             nextToken();
 466         } else {
 467             setErrorEndPos(token.pos);
 468             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 469         }
 470     }
 471 
 472     /** Report an illegal start of expression/type error at given position.
 473      */
 474     JCExpression illegal(int pos) {
 475         setErrorEndPos(pos);
 476         if ((mode &amp; EXPR) != 0)
 477             return syntaxError(pos, Errors.IllegalStartOfExpr);
 478         else
 479             return syntaxError(pos, Errors.IllegalStartOfType);
 480 
 481     }
 482 
 483     /** Report an illegal start of expression/type error at current position.
 484      */
 485     JCExpression illegal() {
 486         return illegal(token.pos);
 487     }
 488 
 489     /** Diagnose a modifier flag from the set, if any. */
 490     protected void checkNoMods(long mods) {
 491         if (mods != 0) {
 492             long lowestMod = mods &amp; -mods;
 493             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 494         }
 495     }
 496 
 497 /* ---------- doc comments --------- */
 498 
 499     /** A table to store all documentation comments
 500      *  indexed by the tree nodes they refer to.
 501      *  defined only if option flag keepDocComment is set.
 502      */
 503     private final DocCommentTable docComments;
 504 
 505     /** Make an entry into docComments hashtable,
 506      *  provided flag keepDocComments is set and given doc comment is non-null.
 507      *  @param tree   The tree to be used as index in the hashtable
 508      *  @param dc     The doc comment to associate with the tree, or null.
 509      */
 510     protected void attach(JCTree tree, Comment dc) {
 511         if (keepDocComments &amp;&amp; dc != null) {
 512 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 513             docComments.putComment(tree, dc);
 514         }
 515     }
 516 
 517 /* -------- source positions ------- */
 518 
 519     protected void setErrorEndPos(int errPos) {
 520         endPosTable.setErrorEndPos(errPos);
 521     }
 522 
 523     protected void storeEnd(JCTree tree, int endpos) {
 524         endPosTable.storeEnd(tree, endpos);
 525     }
 526 
 527     protected &lt;T extends JCTree&gt; T to(T t) {
 528         return endPosTable.to(t);
 529     }
 530 
 531     protected &lt;T extends JCTree&gt; T toP(T t) {
 532         return endPosTable.toP(t);
 533     }
 534 
 535     /** Get the start position for a tree node.  The start position is
 536      * defined to be the position of the first character of the first
 537      * token of the node&#39;s source text.
 538      * @param tree  The tree node
 539      */
 540     public int getStartPos(JCTree tree) {
 541         return TreeInfo.getStartPos(tree);
 542     }
 543 
 544     /**
 545      * Get the end position for a tree node.  The end position is
 546      * defined to be the position of the last character of the last
 547      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 548      * positions are not generated or the position is otherwise not
 549      * found.
 550      * @param tree  The tree node
 551      */
 552     public int getEndPos(JCTree tree) {
 553         return endPosTable.getEndPos(tree);
 554     }
 555 
 556 
 557 
 558 /* ---------- parsing -------------- */
 559 
 560     /**
 561      * Ident = IDENTIFIER
 562      */
 563     public Name ident() {
 564         return ident(false);
 565     }
 566 
 567     protected Name ident(boolean advanceOnErrors) {
 568         if (token.kind == IDENTIFIER) {
 569             Name name = token.name();
 570             nextToken();
 571             return name;
 572         } else if (token.kind == ASSERT) {
 573             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 574             nextToken();
 575             return names.error;
 576         } else if (token.kind == ENUM) {
 577             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 578             nextToken();
 579             return names.error;
 580         } else if (token.kind == THIS) {
 581             if (allowThisIdent) {
 582                 // Make sure we&#39;re using a supported source version.
 583                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 584                 Name name = token.name();
 585                 nextToken();
 586                 return name;
 587             } else {
 588                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 589                 nextToken();
 590                 return names.error;
 591             }
 592         } else if (token.kind == UNDERSCORE) {
 593             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 594                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 595             } else {
 596                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 597             }
 598             Name name = token.name();
 599             nextToken();
 600             return name;
 601         } else {
 602             accept(IDENTIFIER);
 603             if (advanceOnErrors) {
 604                 nextToken();
 605             }
 606             return names.error;
 607         }
 608     }
 609 
 610     /**
 611      * Qualident = Ident { DOT [Annotations] Ident }
 612      */
 613     public JCExpression qualident(boolean allowAnnos) {
 614         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 615         while (token.kind == DOT) {
 616             int pos = token.pos;
 617             nextToken();
 618             List&lt;JCAnnotation&gt; tyannos = null;
 619             if (allowAnnos) {
 620                 tyannos = typeAnnotationsOpt();
 621             }
 622             t = toP(F.at(pos).Select(t, ident()));
 623             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 624                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 625             }
 626         }
 627         return t;
 628     }
 629 
 630     JCExpression literal(Name prefix) {
 631         return literal(prefix, token.pos);
 632     }
 633 
 634     /**
 635      * Literal =
 636      *     INTLITERAL
 637      *   | LONGLITERAL
 638      *   | FLOATLITERAL
 639      *   | DOUBLELITERAL
 640      *   | CHARLITERAL
 641      *   | STRINGLITERAL
 642      *   | TRUE
 643      *   | FALSE
 644      *   | NULL
 645      */
 646     JCExpression literal(Name prefix, int pos) {
 647         JCExpression t = errorTree;
 648         switch (token.kind) {
 649         case INTLITERAL:
 650             try {
 651                 t = F.at(pos).Literal(
 652                     TypeTag.INT,
 653                     Convert.string2int(strval(prefix), token.radix()));
 654             } catch (NumberFormatException ex) {
 655                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 656             }
 657             break;
 658         case LONGLITERAL:
 659             try {
 660                 t = F.at(pos).Literal(
 661                     TypeTag.LONG,
 662                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 663             } catch (NumberFormatException ex) {
 664                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 665             }
 666             break;
 667         case FLOATLITERAL: {
 668             String proper = token.radix() == 16 ?
 669                     (&quot;0x&quot;+ token.stringVal()) :
 670                     token.stringVal();
 671             Float n;
 672             try {
 673                 n = Float.valueOf(proper);
 674             } catch (NumberFormatException ex) {
 675                 // error already reported in scanner
 676                 n = Float.NaN;
 677             }
 678             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 679                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 680             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 681                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 682             else
 683                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 684             break;
 685         }
 686         case DOUBLELITERAL: {
 687             String proper = token.radix() == 16 ?
 688                     (&quot;0x&quot;+ token.stringVal()) :
 689                     token.stringVal();
 690             Double n;
 691             try {
 692                 n = Double.valueOf(proper);
 693             } catch (NumberFormatException ex) {
 694                 // error already reported in scanner
 695                 n = Double.NaN;
 696             }
 697             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 698                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 699             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 700                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 701             else
 702                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 703             break;
 704         }
 705         case CHARLITERAL:
 706             t = F.at(pos).Literal(
 707                 TypeTag.CHAR,
 708                 token.stringVal().charAt(0) + 0);
 709             break;
 710         case STRINGLITERAL:
 711             t = F.at(pos).Literal(
 712                 TypeTag.CLASS,
 713                 token.stringVal());
 714             break;
 715         case TRUE: case FALSE:
 716             t = F.at(pos).Literal(
 717                 TypeTag.BOOLEAN,
 718                 (token.kind == TRUE ? 1 : 0));
 719             break;
 720         case NULL:
 721             t = F.at(pos).Literal(
 722                 TypeTag.BOT,
 723                 null);
 724             break;
 725         default:
 726             Assert.error();
 727         }
 728         if (t == errorTree)
 729             t = F.at(pos).Erroneous();
 730         storeEnd(t, token.endPos);
 731         nextToken();
 732         return t;
 733     }
 734     //where
 735         boolean isZero(String s) {
 736             char[] cs = s.toCharArray();
 737             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 738             int i = ((base==16) ? 2 : 0);
 739             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 740             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 741         }
 742 
 743         String strval(Name prefix) {
 744             String s = token.stringVal();
 745             return prefix.isEmpty() ? s : prefix + s;
 746         }
 747 
 748     /** terms can be either expressions or types.
 749      */
 750     public JCExpression parseExpression() {
 751         return term(EXPR);
 752     }
 753 
 754     /** parses patterns.
 755      */
 756 
 757     public JCPattern parsePattern() {
 758         int pos = token.pos;
 759         if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 760             nextToken();
 761             return toP(F.at(pos).BindingPattern(ident(), null));
 762         } else {
 763             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 764             if (token.kind == LPAREN) {
 765                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 766                 do {
 767                     nextToken();
 768                     JCPattern nestedPattern = parsePattern();
 769                     if (nestedPattern.hasTag(BINDINGPATTERN) &amp;&amp; ((JCBindingPattern) nestedPattern).vartype != null) {
 770                         log.error(nestedPattern.pos(), Errors.DeconstructionPatternNoVar);
 771                     }
 772                     nested.append(nestedPattern);
 773                 } while (token.kind == COMMA);
 774                 Name name = null;
 775                 if (token.kind == IDENTIFIER) {
 776                     name = ident();
 777                 }
 778                 accept(RPAREN);
 779                 return toP(F.at(pos).DeconstructionPattern(name, e, nested.toList()));
 780             } else {
 781                 return toP(F.at(pos).BindingPattern(ident(), e));
 782             }
 783         }
 784     }
 785 
 786     /**
 787      * parses (optional) type annotations followed by a type. If the
 788      * annotations are present before the type and are not consumed during array
 789      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 790      * these annotations and the underlying type. Otherwise, it returns the
 791      * underlying type.
 792      *
 793      * &lt;p&gt;
 794      *
 795      * Note that this method sets {@code mode} to {@code TYPE} first, before
 796      * parsing annotations.
 797      */
 798     public JCExpression parseType() {
 799         return parseType(false);
 800     }
 801 
 802     public JCExpression parseType(boolean allowVar) {
 803         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 804         return parseType(allowVar, annotations);
 805     }
 806 
 807     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 808         JCExpression result = unannotatedType(allowVar);
 809 
 810         if (annotations.nonEmpty()) {
 811             result = insertAnnotationsToMostInner(result, annotations, false);
 812         }
 813 
 814         return result;
 815     }
 816 
 817     public JCExpression unannotatedType(boolean allowVar) {
 818         JCExpression result = term(TYPE);
 819         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 820 
 821         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 822             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 823         }
 824 
 825         return result;
 826     }
 827 
 828 
 829 
 830     protected JCExpression term(int newmode) {
 831         int prevmode = mode;
 832         mode = newmode;
 833         JCExpression t = term();
 834         lastmode = mode;
 835         mode = prevmode;
 836         return t;
 837     }
 838 
 839     /**
 840      *  {@literal
 841      *  Expression = Expression1 [ExpressionRest]
 842      *  ExpressionRest = [AssignmentOperator Expression1]
 843      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 844      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 845      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 846      *  Type = Type1
 847      *  TypeNoParams = TypeNoParams1
 848      *  StatementExpression = Expression
 849      *  ConstantExpression = Expression
 850      *  }
 851      */
 852     JCExpression term() {
 853         JCExpression t = term1();
 854         if ((mode &amp; EXPR) != 0 &amp;&amp;
 855             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 856             return termRest(t);
 857         else
 858             return t;
 859     }
 860 
 861     JCExpression termRest(JCExpression t) {
 862         switch (token.kind) {
 863         case EQ: {
 864             int pos = token.pos;
 865             nextToken();
 866             selectExprMode();
 867             JCExpression t1 = term();
 868             return toP(F.at(pos).Assign(t, t1));
 869         }
 870         case PLUSEQ:
 871         case SUBEQ:
 872         case STAREQ:
 873         case SLASHEQ:
 874         case PERCENTEQ:
 875         case AMPEQ:
 876         case BAREQ:
 877         case CARETEQ:
 878         case LTLTEQ:
 879         case GTGTEQ:
 880         case GTGTGTEQ:
 881             int pos = token.pos;
 882             TokenKind tk = token.kind;
 883             nextToken();
 884             selectExprMode();
 885             JCExpression t1 = term();
 886             return F.at(pos).Assignop(optag(tk), t, t1);
 887         default:
 888             return t;
 889         }
 890     }
 891 
 892     /** Expression1   = Expression2 [Expression1Rest]
 893      *  Type1         = Type2
 894      *  TypeNoParams1 = TypeNoParams2
 895      */
 896     JCExpression term1() {
 897         JCExpression t = term2();
 898         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 899             selectExprMode();
 900             return term1Rest(t);
 901         } else {
 902             return t;
 903         }
 904     }
 905 
 906     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 907      */
 908     JCExpression term1Rest(JCExpression t) {
 909         if (token.kind == QUES) {
 910             int pos = token.pos;
 911             nextToken();
 912             JCExpression t1 = term();
 913             accept(COLON);
 914             JCExpression t2 = term1();
 915             return F.at(pos).Conditional(t, t1, t2);
 916         } else {
 917             return t;
 918         }
 919     }
 920 
 921     /** Expression2   = Expression3 [Expression2Rest]
 922      *  Type2         = Type3
 923      *  TypeNoParams2 = TypeNoParams3
 924      */
 925     JCExpression term2() {
 926         JCExpression t = term3();
 927         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 928             selectExprMode();
 929             return term2Rest(t, TreeInfo.orPrec);
 930         } else {
 931             return t;
 932         }
 933     }
 934 
 935     /*  Expression2Rest = {infixop Expression3}
 936      *                  | Expression3 instanceof Type
 937      *                  | Expression3 instanceof Pattern
 938      *  infixop         = &quot;||&quot;
 939      *                  | &quot;&amp;&amp;&quot;
 940      *                  | &quot;|&quot;
 941      *                  | &quot;^&quot;
 942      *                  | &quot;&amp;&quot;
 943      *                  | &quot;==&quot; | &quot;!=&quot;
 944      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 945      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 946      *                  | &quot;+&quot; | &quot;-&quot;
 947      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 948      */
 949     JCExpression term2Rest(JCExpression t, int minprec) {
 950         JCExpression[] odStack = newOdStack();
 951         Token[] opStack = newOpStack();
 952 
 953         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 954         int top = 0;
 955         odStack[0] = t;
 956         int startPos = token.pos;
 957         Token topOp = Tokens.DUMMY;
 958         while (prec(token.kind) &gt;= minprec) {
 959             opStack[top] = topOp;
 960 
 961             if (token.kind == INSTANCEOF) {
 962                 int pos = token.pos;
 963                 nextToken();
 964                 JCTree pattern = parseType();
 965                 if (token.kind == IDENTIFIER) {
 966                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 967                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 968                 } else if (token.kind == LPAREN) {
 969                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 970                     do {
 971                         nextToken();
 972                         JCPattern nestedPattern = parsePattern();
 973                         if (nestedPattern.hasTag(BINDINGPATTERN) &amp;&amp; ((JCBindingPattern) nestedPattern).vartype != null) {
 974                             log.error(nestedPattern.pos(), Errors.DeconstructionPatternNoVar);
 975                         }
 976                         nested.append(nestedPattern);
 977                     } while (token.kind == COMMA);
 978                     Name name = null;
 979                     if (token.kind == IDENTIFIER) {
 980                         name = ident();
 981                     }
 982                     accept(RPAREN);
 983                     pattern = toP(F.at(pos).DeconstructionPattern(name, (JCExpression) pattern, nested.toList()));
 984                 }
 985                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 986             } else {
 987                 topOp = token;
 988                 nextToken();
 989                 top++;
 990                 odStack[top] = term3();
 991             }
 992             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 993                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 994                 top--;
 995                 topOp = opStack[top];
 996             }
 997         }
 998         Assert.check(top == 0);
 999         t = odStack[0];
1000 
1001         if (t.hasTag(JCTree.Tag.PLUS)) {
1002             t = foldStrings(t);
1003         }
1004 
1005         odStackSupply.add(odStack);
1006         opStackSupply.add(opStack);
1007         return t;
1008     }
1009     //where
1010         /** If tree is a concatenation of string literals, replace it
1011          *  by a single literal representing the concatenated string.
1012          */
1013         protected JCExpression foldStrings(JCExpression tree) {
1014             if (!allowStringFolding)
1015                 return tree;
1016             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
1017             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
1018             boolean needsFolding = false;
1019             JCExpression curr = tree;
1020             while (true) {
1021                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1022                     JCBinary op = (JCBinary)curr;
1023                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1024                     curr = op.lhs;
1025                 } else {
1026                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1027                     break; //last one!
1028                 }
1029             }
1030             if (needsFolding) {
1031                 List&lt;JCExpression&gt; ops = opStack.toList();
1032                 JCExpression res = ops.head;
1033                 for (JCExpression op : ops.tail) {
1034                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1035                     storeEnd(res, getEndPos(op));
1036                 }
1037                 return res;
1038             } else {
1039                 return tree;
1040             }
1041         }
1042 
1043         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1044                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1045             JCLiteral str = stringLiteral(tree);
1046             if (str != null) {
1047                 litBuf.prepend(str);
1048                 return last &amp;&amp; merge(litBuf, opStack);
1049             } else {
1050                 boolean res = merge(litBuf, opStack);
1051                 litBuf.clear();
1052                 opStack.prepend(tree);
1053                 return res;
1054             }
1055         }
1056 
1057         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1058             if (litBuf.isEmpty()) {
1059                 return false;
1060             } else if (litBuf.size() == 1) {
1061                 opStack.prepend(litBuf.first());
1062                 return false;
1063             } else {
1064                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1065                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1066                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1067                 opStack.prepend(t);
1068                 return true;
1069             }
1070         }
1071 
1072         private JCLiteral stringLiteral(JCTree tree) {
1073             if (tree.hasTag(LITERAL)) {
1074                 JCLiteral lit = (JCLiteral)tree;
1075                 if (lit.typetag == TypeTag.CLASS) {
1076                     return lit;
1077                 }
1078             }
1079             return null;
1080         }
1081 
1082 
1083         /** optimization: To save allocating a new operand/operator stack
1084          *  for every binary operation, we use supplys.
1085          */
1086         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1087         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1088 
1089         private JCExpression[] newOdStack() {
1090             if (odStackSupply.isEmpty())
1091                 return new JCExpression[infixPrecedenceLevels + 1];
1092             return odStackSupply.remove(odStackSupply.size() - 1);
1093         }
1094 
1095         private Token[] newOpStack() {
1096             if (opStackSupply.isEmpty())
1097                 return new Token[infixPrecedenceLevels + 1];
1098             return opStackSupply.remove(opStackSupply.size() - 1);
1099         }
1100 
1101     /**
1102      *  Expression3    = PrefixOp Expression3
1103      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1104      *                 | Primary {Selector} {PostfixOp}
1105      *
1106      *  {@literal
1107      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1108      *                 | Literal
1109      *                 | [TypeArguments] THIS [Arguments]
1110      *                 | [TypeArguments] SUPER SuperSuffix
1111      *                 | NEW [TypeArguments] Creator
1112      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1113      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1114      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1115      *                 | Expression3 MemberReferenceSuffix
1116      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1117      *                   | Arguments
1118      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1119      *                   ]
1120      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1121      *  }
1122      *
1123      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1124      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1125      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1126      *                 | BasicType
1127      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1128      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1129      *                 | &quot;.&quot; THIS
1130      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1131      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1132      *                 | &quot;[&quot; Expression &quot;]&quot;
1133      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1134      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1135      */
1136     protected JCExpression term3() {
1137         int pos = token.pos;
1138         JCExpression t;
1139         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1140         switch (token.kind) {
1141         case QUES:
1142             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1143                 selectTypeMode();
1144                 return typeArgument();
1145             } else
1146                 return illegal();
1147         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1148             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1149                 TokenKind tk = token.kind;
1150                 nextToken();
1151                 selectExprMode();
1152                 if (tk == SUB &amp;&amp;
1153                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1154                     token.radix() == 10) {
1155                     selectExprMode();
1156                     t = literal(names.hyphen, pos);
1157                 } else {
1158                     t = term3();
1159                     return F.at(pos).Unary(unoptag(tk), t);
1160                 }
1161             } else return illegal();
1162             break;
1163         case LPAREN:
1164             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1165                 ParensResult pres = analyzeParens();
1166                 switch (pres) {
1167                     case CAST:
1168                        accept(LPAREN);
1169                        selectTypeMode();
1170                        int pos1 = pos;
1171                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1172                        while (token.kind == AMP) {
1173                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1174                            accept(AMP);
1175                            targets = targets.prepend(parseType());
1176                        }
1177                        if (targets.length() &gt; 1) {
1178                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1179                        }
1180                        accept(RPAREN);
1181                        selectExprMode();
1182                        JCExpression t1 = term3();
1183                        return F.at(pos).TypeCast(t, t1);
1184                     case IMPLICIT_LAMBDA:
1185                     case EXPLICIT_LAMBDA:
1186                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1187                         break;
1188                     default: //PARENS
1189                         accept(LPAREN);
1190                         selectExprMode();
1191                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1192                         accept(RPAREN);
1193                         t = toP(F.at(pos).Parens(t));
1194                         break;
1195                 }
1196             } else {
1197                 return illegal();
1198             }
1199             break;
1200         case THIS:
1201             if ((mode &amp; EXPR) != 0) {
1202                 selectExprMode();
1203                 t = to(F.at(pos).Ident(names._this));
1204                 nextToken();
1205                 if (typeArgs == null)
1206                     t = argumentsOpt(null, t);
1207                 else
1208                     t = arguments(typeArgs, t);
1209                 typeArgs = null;
1210             } else return illegal();
1211             break;
1212         case SUPER:
1213             if ((mode &amp; EXPR) != 0) {
1214                 selectExprMode();
1215                 t = to(F.at(pos).Ident(names._super));
1216                 t = superSuffix(typeArgs, t);
1217                 typeArgs = null;
1218             } else return illegal();
1219             break;
1220         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1221         case CHARLITERAL: case STRINGLITERAL:
1222         case TRUE: case FALSE: case NULL:
1223             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1224                 selectExprMode();
1225                 t = literal(names.empty);
1226             } else return illegal();
1227             break;
1228         case NEW:
1229             if (typeArgs != null) return illegal();
1230             if ((mode &amp; EXPR) != 0) {
1231                 selectExprMode();
1232                 nextToken();
1233                 if (token.kind == LT) typeArgs = typeArguments(false);
1234                 t = creator(pos, typeArgs);
1235                 typeArgs = null;
1236             } else return illegal();
1237             break;
1238         case MONKEYS_AT:
1239             // Only annotated cast types and method references are valid
1240             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1241             if (typeAnnos.isEmpty()) {
1242                 // else there would be no &#39;@&#39;
1243                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1244             }
1245 
1246             JCExpression expr = term3();
1247 
1248             if ((mode &amp; TYPE) == 0) {
1249                 // Type annotations on class literals no longer legal
1250                 switch (expr.getTag()) {
1251                 case REFERENCE: {
1252                     JCMemberReference mref = (JCMemberReference) expr;
1253                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1254                     t = mref;
1255                     break;
1256                 }
1257                 case SELECT: {
1258                     JCFieldAccess sel = (JCFieldAccess) expr;
1259 
1260                     if (sel.name != names._class) {
1261                         return illegal();
1262                     } else {
1263                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1264                         return expr;
1265                     }
1266                 }
1267                 default:
1268                     return illegal(typeAnnos.head.pos);
1269                 }
1270 
1271             } else {
1272                 // Type annotations targeting a cast
1273                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1274             }
1275             break;
1276         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1277             if (typeArgs != null) return illegal();
1278             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1279                 t = lambdaExpressionOrStatement(false, false, pos);
1280             } else {
1281                 t = toP(F.at(token.pos).Ident(ident()));
1282                 loop: while (true) {
1283                     pos = token.pos;
1284                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1285 
1286                     // need to report an error later if LBRACKET is for array
1287                     // index access rather than array creation level
1288                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1289                         return illegal(annos.head.pos);
1290 
1291                     switch (token.kind) {
1292                     case LBRACKET:
1293                         nextToken();
1294                         if (token.kind == RBRACKET) {
1295                             nextToken();
1296                             t = bracketsOpt(t);
1297                             t = toP(F.at(pos).TypeArray(t));
1298                             if (annos.nonEmpty()) {
1299                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1300                             }
1301                             t = bracketsSuffix(t);
1302                         } else {
1303                             if ((mode &amp; EXPR) != 0) {
1304                                 selectExprMode();
1305                                 JCExpression t1 = term();
1306                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1307                                 t = to(F.at(pos).Indexed(t, t1));
1308                             }
1309                             accept(RBRACKET);
1310                         }
1311                         break loop;
1312                     case LPAREN:
1313                         if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOINVOCATION) == 0) {
1314                             selectExprMode();
1315                             t = arguments(typeArgs, t);
1316                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1317                             typeArgs = null;
1318                         }
1319                         break loop;
1320                     case DOT:
1321                         nextToken();
1322                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1323                             return illegal();
1324                         }
1325                         int oldmode = mode;
1326                         mode &amp;= ~NOPARAMS;
1327                         typeArgs = typeArgumentsOpt(EXPR);
1328                         mode = oldmode;
1329                         if ((mode &amp; EXPR) != 0) {
1330                             switch (token.kind) {
1331                             case CLASS:
1332                                 if (typeArgs != null) return illegal();
1333                                 selectExprMode();
1334                                 t = to(F.at(pos).Select(t, names._class));
1335                                 nextToken();
1336                                 break loop;
1337                             case THIS:
1338                                 if (typeArgs != null) return illegal();
1339                                 selectExprMode();
1340                                 t = to(F.at(pos).Select(t, names._this));
1341                                 nextToken();
1342                                 break loop;
1343                             case SUPER:
1344                                 selectExprMode();
1345                                 t = to(F.at(pos).Select(t, names._super));
1346                                 t = superSuffix(typeArgs, t);
1347                                 typeArgs = null;
1348                                 break loop;
1349                             case NEW:
1350                                 if (typeArgs != null) return illegal();
1351                                 selectExprMode();
1352                                 int pos1 = token.pos;
1353                                 nextToken();
1354                                 if (token.kind == LT) typeArgs = typeArguments(false);
1355                                 t = innerCreator(pos1, typeArgs, t);
1356                                 typeArgs = null;
1357                                 break loop;
1358                             }
1359                         }
1360 
1361                         List&lt;JCAnnotation&gt; tyannos = null;
1362                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1363                             tyannos = typeAnnotationsOpt();
1364                         }
1365                         // typeArgs saved for next loop iteration.
1366                         t = toP(F.at(pos).Select(t, ident()));
1367                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1368                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1369                         }
1370                         break;
1371                     case ELLIPSIS:
1372                         if (this.permitTypeAnnotationsPushBack) {
1373                             this.typeAnnotationsPushedBack = annos;
1374                         } else if (annos.nonEmpty()) {
1375                             // Don&#39;t return here -- error recovery attempt
1376                             illegal(annos.head.pos);
1377                         }
1378                         break loop;
1379                     case LT:
1380                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1381                             //this is an unbound method reference whose qualifier
1382                             //is a generic type i.e. A&lt;S&gt;::m
1383                             int pos1 = token.pos;
1384                             accept(LT);
1385                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1386                             args.append(typeArgument());
1387                             while (token.kind == COMMA) {
1388                                 nextToken();
1389                                 args.append(typeArgument());
1390                             }
1391                             accept(GT);
1392                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1393                             while (token.kind == DOT) {
1394                                 nextToken();
1395                                 selectTypeMode();
1396                                 t = toP(F.at(token.pos).Select(t, ident()));
1397                                 t = typeArgumentsOpt(t);
1398                             }
1399                             t = bracketsOpt(t);
1400                             if (token.kind != COLCOL) {
1401                                 //method reference expected here
1402                                 t = illegal();
1403                             }
1404                             selectExprMode();
1405                             return term3Rest(t, typeArgs);
1406                         }
1407                         break loop;
1408                     default:
1409                         break loop;
1410                     }
1411                 }
1412             }
1413             if (typeArgs != null) illegal();
1414             t = typeArgumentsOpt(t);
1415             break;
1416         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1417         case DOUBLE: case BOOLEAN:
1418             if (typeArgs != null) illegal();
1419             t = bracketsSuffix(bracketsOpt(basicType()));
1420             break;
1421         case VOID:
1422             if (typeArgs != null) illegal();
1423             if ((mode &amp; EXPR) != 0) {
1424                 nextToken();
1425                 if (token.kind == DOT) {
1426                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1427                     t = bracketsSuffix(ti);
1428                 } else {
1429                     return illegal(pos);
1430                 }
1431             } else {
1432                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1433                 // a void type (like other primitive types) to the next phase.
1434                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1435                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1436                 nextToken();
1437                 return ti;
1438                 //return illegal();
1439             }
1440             break;
1441         case SWITCH:
1442             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1443             allowYieldStatement = true;
1444             int switchPos = token.pos;
1445             nextToken();
1446             JCExpression selector = parExpression();
1447             accept(LBRACE);
1448             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1449             while (true) {
1450                 pos = token.pos;
1451                 switch (token.kind) {
1452                 case CASE:
1453                 case DEFAULT:
1454                     cases.appendList(switchExpressionStatementGroup());
1455                     break;
1456                 case RBRACE: case EOF:
1457                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1458                                                                                cases.toList()));
1459                     e.endpos = token.pos;
1460                     accept(RBRACE);
1461                     return e;
1462                 default:
1463                     nextToken(); // to ensure progress
1464                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1465                 }
1466             }
1467         default:
1468             return illegal();
1469         }
1470         return term3Rest(t, typeArgs);
1471     }
1472 
1473     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1474         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1475         int casePos = token.pos;
1476         ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
1477 
1478         if (token.kind == DEFAULT) {
1479             nextToken();
1480         } else {
1481             accept(CASE);
1482             while (true) {
1483                 pats.append(term(EXPR | NOLAMBDA));
1484                 if (token.kind != COMMA) break;
1485                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1486                 nextToken();
1487             };
1488         }
1489         List&lt;JCStatement&gt; stats = null;
1490         JCTree body = null;
1491         CaseTree.CaseKind kind;
1492         switch (token.kind) {
1493             case ARROW:
1494                 checkSourceLevel(Feature.SWITCH_RULE);
1495                 nextToken();
1496                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1497                     stats = List.of(parseStatement());
1498                     body = stats.head;
1499                     kind = JCCase.RULE;
1500                 } else {
1501                     JCExpression value = parseExpression();
1502                     stats = List.of(to(F.at(value).Yield(value)));
1503                     body = value;
1504                     kind = JCCase.RULE;
1505                     accept(SEMI);
1506                 }
1507                 break;
1508             default:
1509                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1510                 stats = blockStatements();
1511                 kind = JCCase.STATEMENT;
1512                 break;
1513         }
1514         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1515         return caseExprs.toList();
1516     }
1517 
1518     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1519         if (typeArgs != null) illegal();
1520         while (true) {
1521             int pos1 = token.pos;
1522             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1523 
1524             if (token.kind == LBRACKET) {
1525                 nextToken();
1526                 if ((mode &amp; TYPE) != 0) {
1527                     int oldmode = mode;
1528                     selectTypeMode();
1529                     if (token.kind == RBRACKET) {
1530                         nextToken();
1531                         t = bracketsOpt(t);
1532                         t = toP(F.at(pos1).TypeArray(t));
1533                         if (token.kind == COLCOL) {
1534                             selectExprMode();
1535                             continue;
1536                         }
1537                         if (annos.nonEmpty()) {
1538                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1539                         }
1540                         return t;
1541                     }
1542                     mode = oldmode;
1543                 }
1544                 if ((mode &amp; EXPR) != 0) {
1545                     selectExprMode();
1546                     JCExpression t1 = term();
1547                     t = to(F.at(pos1).Indexed(t, t1));
1548                 }
1549                 accept(RBRACKET);
1550             } else if (token.kind == DOT) {
1551                 nextToken();
1552                 typeArgs = typeArgumentsOpt(EXPR);
1553                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1554                     selectExprMode();
1555                     t = to(F.at(pos1).Select(t, names._super));
1556                     nextToken();
1557                     t = arguments(typeArgs, t);
1558                     typeArgs = null;
1559                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1560                     if (typeArgs != null) return illegal();
1561                     selectExprMode();
1562                     int pos2 = token.pos;
1563                     nextToken();
1564                     if (token.kind == LT) typeArgs = typeArguments(false);
1565                     t = innerCreator(pos2, typeArgs, t);
1566                     typeArgs = null;
1567                 } else {
1568                     List&lt;JCAnnotation&gt; tyannos = null;
1569                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1570                         // is the mode check needed?
1571                         tyannos = typeAnnotationsOpt();
1572                     }
1573                     t = toP(F.at(pos1).Select(t, ident(true)));
1574                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1575                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1576                     }
1577                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1578                     typeArgs = null;
1579                 }
1580             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1581                 selectExprMode();
1582                 if (typeArgs != null) return illegal();
1583                 accept(COLCOL);
1584                 t = memberReferenceSuffix(pos1, t);
1585             } else {
1586                 if (!annos.isEmpty()) {
1587                     if (permitTypeAnnotationsPushBack)
1588                         typeAnnotationsPushedBack = annos;
1589                     else
1590                         return illegal(annos.head.pos);
1591                 }
1592                 break;
1593             }
1594         }
1595         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1596             selectExprMode();
1597             t = to(F.at(token.pos).Unary(
1598                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1599             nextToken();
1600         }
1601         return toP(t);
1602     }
1603 
1604     /**
1605      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1606      * method reference or a binary expression. To disambiguate, look for a
1607      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1608      */
1609     @SuppressWarnings(&quot;fallthrough&quot;)
1610     boolean isUnboundMemberRef() {
1611         int pos = 0, depth = 0;
1612         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1613             switch (t.kind) {
1614                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1615                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1616                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1617                 case DOUBLE: case BOOLEAN: case CHAR:
1618                 case MONKEYS_AT:
1619                     break;
1620 
1621                 case LPAREN:
1622                     // skip annotation values
1623                     int nesting = 0;
1624                     for (; ; pos++) {
1625                         TokenKind tk2 = S.token(pos).kind;
1626                         switch (tk2) {
1627                             case EOF:
1628                                 return false;
1629                             case LPAREN:
1630                                 nesting++;
1631                                 break;
1632                             case RPAREN:
1633                                 nesting--;
1634                                 if (nesting == 0) {
1635                                     continue outer;
1636                                 }
1637                                 break;
1638                         }
1639                     }
1640 
1641                 case LT:
1642                     depth++; break;
1643                 case GTGTGT:
1644                     depth--;
1645                 case GTGT:
1646                     depth--;
1647                 case GT:
1648                     depth--;
1649                     if (depth == 0) {
1650                         TokenKind nextKind = S.token(pos + 1).kind;
1651                         return
1652                             nextKind == TokenKind.DOT ||
1653                             nextKind == TokenKind.LBRACKET ||
1654                             nextKind == TokenKind.COLCOL;
1655                     }
1656                     break;
1657                 default:
1658                     return false;
1659             }
1660         }
1661     }
1662 
1663     /**
1664      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1665      * method reference or a binary expression. To disambiguate, look for a
1666      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1667      */
1668     @SuppressWarnings(&quot;fallthrough&quot;)
1669     ParensResult analyzeParens() {
1670         int depth = 0;
1671         boolean type = false;
1672         ParensResult defaultResult = ParensResult.PARENS;
1673         outer: for (int lookahead = 0; ; lookahead++) {
1674             TokenKind tk = S.token(lookahead).kind;
1675             switch (tk) {
1676                 case COMMA:
1677                     type = true;
1678                 case EXTENDS: case SUPER: case DOT: case AMP:
1679                     //skip
1680                     break;
1681                 case QUES:
1682                     if (peekToken(lookahead, EXTENDS) ||
1683                             peekToken(lookahead, SUPER)) {
1684                         //wildcards
1685                         type = true;
1686                     }
1687                     break;
1688                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1689                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1690                     if (peekToken(lookahead, RPAREN)) {
1691                         //Type, &#39;)&#39; -&gt; cast
1692                         return ParensResult.CAST;
1693                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1694                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1695                         return ParensResult.EXPLICIT_LAMBDA;
1696                     }
1697                     break;
1698                 case LPAREN:
1699                     if (lookahead != 0) {
1700                         // &#39;(&#39; in a non-starting position -&gt; parens
1701                         return ParensResult.PARENS;
1702                     } else if (peekToken(lookahead, RPAREN)) {
1703                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1704                         return ParensResult.EXPLICIT_LAMBDA;
1705                     }
1706                     break;
1707                 case RPAREN:
1708                     // if we have seen something that looks like a type,
1709                     // then it&#39;s a cast expression
1710                     if (type) return ParensResult.CAST;
1711                     // otherwise, disambiguate cast vs. parenthesized expression
1712                     // based on subsequent token.
1713                     switch (S.token(lookahead + 1).kind) {
1714                         /*case PLUSPLUS: case SUBSUB: */
1715                         case BANG: case TILDE:
1716                         case LPAREN: case THIS: case SUPER:
1717                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1718                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1719                         case TRUE: case FALSE: case NULL:
1720                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1721                         case SWITCH:
1722                         case BYTE: case SHORT: case CHAR: case INT:
1723                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1724                             return ParensResult.CAST;
1725                         default:
1726                             return defaultResult;
1727                     }
1728                 case UNDERSCORE:
1729                 case ASSERT:
1730                 case ENUM:
1731                 case IDENTIFIER:
1732                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1733                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1734                         return ParensResult.EXPLICIT_LAMBDA;
1735                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1736                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1737                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1738                                                       : ParensResult.PARENS;
1739                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1740                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1741                     }
1742                     type = false;
1743                     break;
1744                 case FINAL:
1745                 case ELLIPSIS:
1746                     //those can only appear in explicit lambdas
1747                     return ParensResult.EXPLICIT_LAMBDA;
1748                 case MONKEYS_AT:
1749                     type = true;
1750                     lookahead += 1; //skip &#39;@&#39;
1751                     while (peekToken(lookahead, DOT)) {
1752                         lookahead += 2;
1753                     }
1754                     if (peekToken(lookahead, LPAREN)) {
1755                         lookahead++;
1756                         //skip annotation values
1757                         int nesting = 0;
1758                         for (; ; lookahead++) {
1759                             TokenKind tk2 = S.token(lookahead).kind;
1760                             switch (tk2) {
1761                                 case EOF:
1762                                     return ParensResult.PARENS;
1763                                 case LPAREN:
1764                                     nesting++;
1765                                     break;
1766                                 case RPAREN:
1767                                     nesting--;
1768                                     if (nesting == 0) {
1769                                         continue outer;
1770                                     }
1771                                 break;
1772                             }
1773                         }
1774                     }
1775                     break;
1776                 case LBRACKET:
1777                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1778                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1779                         return ParensResult.EXPLICIT_LAMBDA;
1780                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1781                             peekToken(lookahead, RBRACKET, AMP)) {
1782                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1783                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1784                         return ParensResult.CAST;
1785                     } else if (peekToken(lookahead, RBRACKET)) {
1786                         //consume the &#39;]&#39; and skip
1787                         type = true;
1788                         lookahead++;
1789                         break;
1790                     } else {
1791                         return ParensResult.PARENS;
1792                     }
1793                 case LT:
1794                     depth++; break;
1795                 case GTGTGT:
1796                     depth--;
1797                 case GTGT:
1798                     depth--;
1799                 case GT:
1800                     depth--;
1801                     if (depth == 0) {
1802                         if (peekToken(lookahead, RPAREN) ||
1803                                 peekToken(lookahead, AMP)) {
1804                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1805                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1806                             return ParensResult.CAST;
1807                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1808                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1809                                 peekToken(lookahead, ELLIPSIS)) {
1810                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1811                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1812                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1813                             return ParensResult.EXPLICIT_LAMBDA;
1814                         }
1815                         //it looks a type, but could still be (i) a cast to generic type,
1816                         //(ii) an unbound method reference or (iii) an explicit lambda
1817                         type = true;
1818                         break;
1819                     } else if (depth &lt; 0) {
1820                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1821                         return ParensResult.PARENS;
1822                     }
1823                     break;
1824                 default:
1825                     //this includes EOF
1826                     return defaultResult;
1827             }
1828         }
1829     }
1830 
1831     /** Accepts all identifier-like tokens */
1832     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1833 
1834     enum ParensResult {
1835         CAST,
1836         EXPLICIT_LAMBDA,
1837         IMPLICIT_LAMBDA,
1838         PARENS
1839     }
1840 
1841     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1842         List&lt;JCVariableDecl&gt; params = explicitParams ?
1843                 formalParameters(true, false) :
1844                 implicitParameters(hasParens);
1845         if (explicitParams) {
1846             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1847             for (JCVariableDecl param: params) {
1848                 Name restrictedTypeName;
1849                 if (param.vartype != null &amp;&amp;
1850                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1851                         param.vartype.hasTag(TYPEARRAY)) {
1852                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1853                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1854                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1855                 }
1856                 lambdaClassifier.addParameter(param);
1857                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1858                     break;
1859                 }
1860             }
1861             if (lambdaClassifier.diagFragment != null) {
1862                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1863             }
1864             for (JCVariableDecl param: params) {
1865                 if (param.vartype != null
1866                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1867                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1868                     param.startPos = TreeInfo.getStartPos(param.vartype);
1869                     param.vartype = null;
1870                 }
1871             }
1872         }
1873         return lambdaExpressionOrStatementRest(params, pos);
1874     }
1875 
1876     enum LambdaParameterKind {
1877         VAR(0),
1878         EXPLICIT(1),
1879         IMPLICIT(2),
1880         ERROR(-1);
1881 
1882         private final int index;
1883 
1884         LambdaParameterKind(int index) {
1885             this.index = index;
1886         }
1887     }
1888 
1889     private final static Fragment[][] decisionTable = new Fragment[][] {
1890         /*              VAR                              EXPLICIT                         IMPLICIT  */
1891         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1892         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1893         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1894     };
1895 
1896     class LambdaClassifier {
1897 
1898         LambdaParameterKind kind;
1899         Fragment diagFragment;
1900         List&lt;JCVariableDecl&gt; params;
1901 
1902         void addParameter(JCVariableDecl param) {
1903             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1904                 if (restrictedTypeName(param.vartype, false) != null) {
1905                     reduce(LambdaParameterKind.VAR);
1906                 } else {
1907                     reduce(LambdaParameterKind.EXPLICIT);
1908                 }
1909             }
1910             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1911                 param.vartype != null &amp;&amp; param.name == names.empty) {
1912                 reduce(LambdaParameterKind.IMPLICIT);
1913             }
1914         }
1915 
1916         private void reduce(LambdaParameterKind newKind) {
1917             if (kind == null) {
1918                 kind = newKind;
1919             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1920                 LambdaParameterKind currentKind = kind;
1921                 kind = LambdaParameterKind.ERROR;
1922                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1923                         newKind.index == LambdaParameterKind.VAR.index;
1924                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1925                         decisionTable[currentKind.index][newKind.index] : null;
1926             }
1927         }
1928 
1929         LambdaParameterKind result() {
1930             return kind;
1931         }
1932     }
1933 
1934     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1935         checkSourceLevel(Feature.LAMBDA);
1936         accept(ARROW);
1937 
1938         return token.kind == LBRACE ?
1939             lambdaStatement(args, pos, token.pos) :
1940             lambdaExpression(args, pos);
1941     }
1942 
1943     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1944         JCBlock block = block(pos2, 0);
1945         return toP(F.at(pos).Lambda(args, block));
1946     }
1947 
1948     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1949         JCTree expr = parseExpression();
1950         return toP(F.at(pos).Lambda(args, expr));
1951     }
1952 
1953     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1954      */
1955     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1956         nextToken();
1957         if (token.kind == LPAREN || typeArgs != null) {
1958             t = arguments(typeArgs, t);
1959         } else if (token.kind == COLCOL) {
1960             if (typeArgs != null) return illegal();
1961             t = memberReferenceSuffix(t);
1962         } else {
1963             int pos = token.pos;
1964             accept(DOT);
1965             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1966             t = toP(F.at(pos).Select(t, ident()));
1967             t = argumentsOpt(typeArgs, t);
1968         }
1969         return t;
1970     }
1971 
1972     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1973      */
1974     JCPrimitiveTypeTree basicType() {
1975         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1976         nextToken();
1977         return t;
1978     }
1979 
1980     /** ArgumentsOpt = [ Arguments ]
1981      */
1982     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1983         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1984             selectExprMode();
1985             return arguments(typeArgs, t);
1986         } else {
1987             return t;
1988         }
1989     }
1990 
1991     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1992      */
1993     List&lt;JCExpression&gt; arguments() {
1994         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1995         if (token.kind == LPAREN) {
1996             nextToken();
1997             if (token.kind != RPAREN) {
1998                 args.append(parseExpression());
1999                 while (token.kind == COMMA) {
2000                     nextToken();
2001                     args.append(parseExpression());
2002                 }
2003             }
2004             accept(RPAREN);
2005         } else {
2006             syntaxError(token.pos, Errors.Expected(LPAREN));
2007         }
2008         return args.toList();
2009     }
2010 
2011     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2012         int pos = token.pos;
2013         List&lt;JCExpression&gt; args = arguments();
2014         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2015         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2016                                                                     ((JCIdent) t).name)) {
2017             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2018             mi = F.Erroneous(List.of(mi));
2019         }
2020         return toP(mi);
2021     }
2022 
2023     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2024         if (name == names.yield) {
2025             if (allowYieldStatement) {
2026                 return true;
2027             } else {
2028                 log.warning(pos, Warnings.InvalidYield);
2029             }
2030         }
2031         return false;
2032     }
2033 
2034     /**  TypeArgumentsOpt = [ TypeArguments ]
2035      */
2036     JCExpression typeArgumentsOpt(JCExpression t) {
2037         if (token.kind == LT &amp;&amp;
2038             (mode &amp; TYPE) != 0 &amp;&amp;
2039             (mode &amp; NOPARAMS) == 0) {
2040             selectTypeMode();
2041             return typeArguments(t, false);
2042         } else {
2043             return t;
2044         }
2045     }
2046     List&lt;JCExpression&gt; typeArgumentsOpt() {
2047         return typeArgumentsOpt(TYPE);
2048     }
2049 
2050     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2051         if (token.kind == LT) {
2052             if ((mode &amp; useMode) == 0 ||
2053                 (mode &amp; NOPARAMS) != 0) {
2054                 illegal();
2055             }
2056             mode = useMode;
2057             return typeArguments(false);
2058         }
2059         return null;
2060     }
2061 
2062     /**
2063      *  {@literal
2064      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2065      *  }
2066      */
2067     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2068         if (token.kind == LT) {
2069             nextToken();
2070             if (token.kind == GT &amp;&amp; diamondAllowed) {
2071                 checkSourceLevel(Feature.DIAMOND);
2072                 mode |= DIAMOND;
2073                 nextToken();
2074                 return List.nil();
2075             } else {
2076                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2077                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2078                 while (token.kind == COMMA) {
2079                     nextToken();
2080                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2081                 }
2082                 switch (token.kind) {
2083 
2084                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2085                 case GTGTGT: case GTGT:
2086                     token = S.split();
2087                     break;
2088                 case GT:
2089                     nextToken();
2090                     break;
2091                 default:
2092                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2093                     break;
2094                 }
2095                 return args.toList();
2096             }
2097         } else {
2098             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2099         }
2100     }
2101 
2102     /**
2103      *  {@literal
2104      *  TypeArgument = Type
2105      *               | [Annotations] &quot;?&quot;
2106      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2107      *               | [Annotations] &quot;?&quot; SUPER Type
2108      *  }
2109      */
2110     JCExpression typeArgument() {
2111         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2112         if (token.kind != QUES) return parseType(false, annotations);
2113         int pos = token.pos;
2114         nextToken();
2115         JCExpression result;
2116         if (token.kind == EXTENDS) {
2117             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2118             nextToken();
2119             JCExpression bound = parseType();
2120             result = F.at(pos).Wildcard(t, bound);
2121         } else if (token.kind == SUPER) {
2122             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2123             nextToken();
2124             JCExpression bound = parseType();
2125             result = F.at(pos).Wildcard(t, bound);
2126         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2127             //error recovery
2128             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2129             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2130             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2131             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2132             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2133             result = err;
2134         } else {
2135             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2136             result = toP(F.at(pos).Wildcard(t, null));
2137         }
2138         if (!annotations.isEmpty()) {
2139             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2140         }
2141         return result;
2142     }
2143 
2144     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2145         int pos = token.pos;
2146         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2147         return toP(F.at(pos).TypeApply(t, args));
2148     }
2149 
2150     /**
2151      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2152      *
2153      * &lt;p&gt;
2154      *
2155      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2156      * the expression &lt;code&gt;t&lt;/code&gt;.
2157      */
2158     private JCExpression bracketsOpt(JCExpression t,
2159             List&lt;JCAnnotation&gt; annotations) {
2160         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2161 
2162         if (token.kind == LBRACKET) {
2163             int pos = token.pos;
2164             nextToken();
2165             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2166         } else if (!nextLevelAnnotations.isEmpty()) {
2167             if (permitTypeAnnotationsPushBack) {
2168                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2169             } else {
2170                 return illegal(nextLevelAnnotations.head.pos);
2171             }
2172         }
2173 
2174         if (!annotations.isEmpty()) {
2175             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2176         }
2177         return t;
2178     }
2179 
2180     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2181      */
2182     private JCExpression bracketsOpt(JCExpression t) {
2183         return bracketsOpt(t, List.nil());
2184     }
2185 
2186     private JCExpression bracketsOptCont(JCExpression t, int pos,
2187             List&lt;JCAnnotation&gt; annotations) {
2188         accept(RBRACKET);
2189         t = bracketsOpt(t);
2190         t = toP(F.at(pos).TypeArray(t));
2191         if (annotations.nonEmpty()) {
2192             t = toP(F.at(pos).AnnotatedType(annotations, t));
2193         }
2194         return t;
2195     }
2196 
2197     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2198      *  BracketsSuffixType =
2199      */
2200     JCExpression bracketsSuffix(JCExpression t) {
2201         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2202             selectExprMode();
2203             int pos = token.pos;
2204             nextToken();
2205             accept(CLASS);
2206             if (token.pos == endPosTable.errorEndPos) {
2207                 // error recovery
2208                 Name name;
2209                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2210                     name = token.name();
2211                     nextToken();
2212                 } else {
2213                     name = names.error;
2214                 }
2215                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2216             } else {
2217                 Tag tag = t.getTag();
2218                 // Type annotations are illegal on class literals. Annotated non array class literals
2219                 // are complained about directly in term3(), Here check for type annotations on dimensions
2220                 // taking care to handle some interior dimension(s) being annotated.
2221                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2222                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2223                 t = toP(F.at(pos).Select(t, names._class));
2224             }
2225         } else if ((mode &amp; TYPE) != 0) {
2226             if (token.kind != COLCOL) {
2227                 selectTypeMode();
2228             }
2229         } else if (token.kind != COLCOL) {
2230             syntaxError(token.pos, Errors.DotClassExpected);
2231         }
2232         return t;
2233     }
2234 
2235     /**
2236      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2237      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2238      */
2239     JCExpression memberReferenceSuffix(JCExpression t) {
2240         int pos1 = token.pos;
2241         accept(COLCOL);
2242         return memberReferenceSuffix(pos1, t);
2243     }
2244 
2245     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2246         checkSourceLevel(Feature.METHOD_REFERENCES);
2247         selectExprMode();
2248         List&lt;JCExpression&gt; typeArgs = null;
2249         if (token.kind == LT) {
2250             typeArgs = typeArguments(false);
2251         }
2252         Name refName;
2253         ReferenceMode refMode;
2254         if (token.kind == NEW) {
2255             refMode = ReferenceMode.NEW;
2256             refName = names.init;
2257             nextToken();
2258         } else {
2259             refMode = ReferenceMode.INVOKE;
2260             refName = ident();
2261         }
2262         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2263     }
2264 
2265     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2266      */
2267     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2268         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2269 
2270         switch (token.kind) {
2271         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2272         case DOUBLE: case BOOLEAN:
2273             if (typeArgs == null) {
2274                 if (newAnnotations.isEmpty()) {
2275                     return arrayCreatorRest(newpos, basicType());
2276                 } else {
2277                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2278                 }
2279             }
2280             break;
2281         default:
2282         }
2283         JCExpression t = qualident(true);
2284 
2285         int oldmode = mode;
2286         selectTypeMode();
2287         boolean diamondFound = false;
2288         int lastTypeargsPos = -1;
2289         if (token.kind == LT) {
2290             lastTypeargsPos = token.pos;
2291             t = typeArguments(t, true);
2292             diamondFound = (mode &amp; DIAMOND) != 0;
2293         }
2294         while (token.kind == DOT) {
2295             if (diamondFound) {
2296                 //cannot select after a diamond
2297                 illegal();
2298             }
2299             int pos = token.pos;
2300             nextToken();
2301             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2302             t = toP(F.at(pos).Select(t, ident()));
2303 
2304             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2305                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2306             }
2307 
2308             if (token.kind == LT) {
2309                 lastTypeargsPos = token.pos;
2310                 t = typeArguments(t, true);
2311                 diamondFound = (mode &amp; DIAMOND) != 0;
2312             }
2313         }
2314         mode = oldmode;
2315         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2316             // handle type annotations for non primitive arrays
2317             if (newAnnotations.nonEmpty()) {
2318                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2319             }
2320 
2321             JCExpression e = arrayCreatorRest(newpos, t);
2322             if (diamondFound) {
2323                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2324                 return toP(F.at(newpos).Erroneous(List.of(e)));
2325             }
2326             else if (typeArgs != null) {
2327                 int pos = newpos;
2328                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2329                     // note: this should always happen but we should
2330                     // not rely on this as the parser is continuously
2331                     // modified to improve error recovery.
2332                     pos = typeArgs.head.pos;
2333                 }
2334                 setErrorEndPos(S.prevToken().endPos);
2335                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2336                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2337                 return toP(err);
2338             }
2339             return e;
2340         } else if (token.kind == LPAREN) {
2341             // handle type annotations for instantiations and anonymous classes
2342             if (newAnnotations.nonEmpty()) {
2343                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2344             }
2345             return classCreatorRest(newpos, null, typeArgs, t);
2346         } else {
2347             setErrorEndPos(token.pos);
2348             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2349             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2350             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2351         }
2352     }
2353 
2354     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2355      */
2356     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2357         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2358 
2359         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2360 
2361         if (newAnnotations.nonEmpty()) {
2362             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2363         }
2364 
2365         if (token.kind == LT) {
2366             int oldmode = mode;
2367             t = typeArguments(t, true);
2368             mode = oldmode;
2369         }
2370         return classCreatorRest(newpos, encl, typeArgs, t);
2371     }
2372 
2373     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2374      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2375      */
2376     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2377         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2378 
2379         accept(LBRACKET);
2380         if (token.kind == RBRACKET) {
2381             accept(RBRACKET);
2382             elemtype = bracketsOpt(elemtype, annos);
2383             if (token.kind == LBRACE) {
2384                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2385                 if (annos.nonEmpty()) {
2386                     // when an array initializer is present then
2387                     // the parsed annotations should target the
2388                     // new array tree
2389                     // bracketsOpt inserts the annotation in
2390                     // elemtype, and it needs to be corrected
2391                     //
2392                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2393                     assert annotated.annotations == annos;
2394                     na.annotations = annotated.annotations;
2395                     na.elemtype = annotated.underlyingType;
2396                 }
2397                 return na;
2398             } else {
2399                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2400                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2401             }
2402         } else {
2403             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2404 
2405             // maintain array dimension type annotations
2406             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2407             dimAnnotations.append(annos);
2408 
2409             dims.append(parseExpression());
2410             accept(RBRACKET);
2411             while (token.kind == LBRACKET
2412                     || token.kind == MONKEYS_AT) {
2413                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2414                 int pos = token.pos;
2415                 nextToken();
2416                 if (token.kind == RBRACKET) {
2417                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2418                 } else {
2419                     if (token.kind == RBRACKET) { // no dimension
2420                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2421                     } else {
2422                         dimAnnotations.append(maybeDimAnnos);
2423                         dims.append(parseExpression());
2424                         accept(RBRACKET);
2425                     }
2426                 }
2427             }
2428 
2429             List&lt;JCExpression&gt; elems = null;
2430             int errpos = token.pos;
2431 
2432             if (token.kind == LBRACE) {
2433                 elems = arrayInitializerElements(newpos, elemtype);
2434             }
2435 
2436             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2437             na.dimAnnotations = dimAnnotations.toList();
2438 
2439             if (elems != null) {
2440                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2441             }
2442 
2443             return na;
2444         }
2445     }
2446 
2447     /** ClassCreatorRest = Arguments [ClassBody]
2448      */
2449     JCNewClass classCreatorRest(int newpos,
2450                                   JCExpression encl,
2451                                   List&lt;JCExpression&gt; typeArgs,
2452                                   JCExpression t)
2453     {
2454         List&lt;JCExpression&gt; args = arguments();
2455         JCClassDecl body = null;
2456         if (token.kind == LBRACE) {
2457             int pos = token.pos;
2458             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2459             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2460             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2461         }
2462         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2463     }
2464 
2465     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2466      */
2467     JCExpression arrayInitializer(int newpos, JCExpression t) {
2468         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2469         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2470     }
2471 
2472     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2473         accept(LBRACE);
2474         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2475         if (token.kind == COMMA) {
2476             nextToken();
2477         } else if (token.kind != RBRACE) {
2478             elems.append(variableInitializer());
2479             while (token.kind == COMMA) {
2480                 nextToken();
2481                 if (token.kind == RBRACE) break;
2482                 elems.append(variableInitializer());
2483             }
2484         }
2485         accept(RBRACE);
2486         return elems.toList();
2487     }
2488 
2489     /** VariableInitializer = ArrayInitializer | Expression
2490      */
2491     public JCExpression variableInitializer() {
2492         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2493     }
2494 
2495     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2496      */
2497     JCExpression parExpression() {
2498         int pos = token.pos;
2499         accept(LPAREN);
2500         JCExpression t = parseExpression();
2501         accept(RPAREN);
2502         return toP(F.at(pos).Parens(t));
2503     }
2504 
2505     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2506      */
2507     JCBlock block(int pos, long flags) {
2508         accept(LBRACE);
2509         List&lt;JCStatement&gt; stats = blockStatements();
2510         JCBlock t = F.at(pos).Block(flags, stats);
2511         while (token.kind == CASE || token.kind == DEFAULT) {
2512             syntaxError(token.pos, Errors.Orphaned(token.kind));
2513             switchBlockStatementGroups();
2514         }
2515         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2516         // usually but not necessarily the last char of the last token.
2517         t.endpos = token.pos;
2518         accept(RBRACE);
2519         return toP(t);
2520     }
2521 
2522     public JCBlock block() {
2523         return block(token.pos, 0);
2524     }
2525 
2526     /** BlockStatements = { BlockStatement }
2527      *  BlockStatement  = LocalVariableDeclarationStatement
2528      *                  | ClassOrInterfaceOrEnumDeclaration
2529      *                  | [Ident &quot;:&quot;] Statement
2530      *  LocalVariableDeclarationStatement
2531      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2532      */
2533     @SuppressWarnings(&quot;fallthrough&quot;)
2534     List&lt;JCStatement&gt; blockStatements() {
2535         //todo: skip to anchor on error(?)
2536         int lastErrPos = -1;
2537         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2538         while (true) {
2539             List&lt;JCStatement&gt; stat = blockStatement();
2540             if (stat.isEmpty()) {
2541                 return stats.toList();
2542             } else {
2543                 // error recovery
2544                 if (token.pos == lastErrPos)
2545                     return stats.toList();
2546                 if (token.pos &lt;= endPosTable.errorEndPos) {
2547                     skip(false, true, true, true);
2548                     lastErrPos = token.pos;
2549                 }
2550                 stats.addAll(stat);
2551             }
2552         }
2553     }
2554 
2555     /*
2556      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2557      * this method will also recognize variable and class declarations (which are
2558      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2559      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2560      * and an error will be produced by this method.
2561      */
2562     JCStatement parseStatementAsBlock() {
2563         int pos = token.pos;
2564         List&lt;JCStatement&gt; stats = blockStatement();
2565         if (stats.isEmpty()) {
2566             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2567             return toP(F.at(pos).Exec(e));
2568         } else {
2569             JCStatement first = stats.head;
2570             Error error = null;
2571             switch (first.getTag()) {
2572             case CLASSDEF:
2573                 error = Errors.ClassNotAllowed;
2574                 break;
2575             case VARDEF:
2576                 error = Errors.VariableNotAllowed;
2577                 break;
2578             }
2579             if (error != null) {
2580                 log.error(DiagnosticFlag.SYNTAX, first, error);
2581                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2582                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2583             }
2584             return first;
2585         }
2586     }
2587 
2588     /**This method parses a statement appearing inside a block.
2589      */
2590     @SuppressWarnings(&quot;fallthrough&quot;)
2591     List&lt;JCStatement&gt; blockStatement() {
2592         //todo: skip to anchor on error(?)
2593         Comment dc;
2594         int pos = token.pos;
2595         switch (token.kind) {
2596         case RBRACE: case CASE: case DEFAULT: case EOF:
2597             return List.nil();
2598         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2599         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2600         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2601         case ASSERT:
2602             return List.of(parseSimpleStatement());
2603         case MONKEYS_AT:
2604         case FINAL: {
2605             dc = token.comment(CommentStyle.JAVADOC);
2606             JCModifiers mods = modifiersOpt();
2607             if (token.kind == INTERFACE ||
2608                 token.kind == CLASS ||
2609                 token.kind == ENUM ||
2610                 isRecordStart()) {
2611                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2612             } else {
2613                 JCExpression t = parseType(true);
2614                 return localVariableDeclarations(mods, t);
2615             }
2616         }
2617         case ABSTRACT: case STRICTFP: {
2618             dc = token.comment(CommentStyle.JAVADOC);
2619             JCModifiers mods = modifiersOpt();
2620             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2621         }
2622         case INTERFACE:
2623         case CLASS:
2624             dc = token.comment(CommentStyle.JAVADOC);
2625             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2626         case ENUM:
2627             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2628             dc = token.comment(CommentStyle.JAVADOC);
2629             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2630         case IDENTIFIER:
2631             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2632                 Token next = S.token(1);
2633                 boolean isYieldStatement;
2634                 switch (next.kind) {
2635                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2636                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2637                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2638                     case NEW: case SWITCH: case THIS: case SUPER:
2639                         isYieldStatement = true;
2640                         break;
2641                     case PLUSPLUS: case SUBSUB:
2642                         isYieldStatement = S.token(2).kind != SEMI;
2643                         break;
2644                     case LPAREN:
2645                         int lookahead = 2;
2646                         int balance = 1;
2647                         boolean hasComma = false;
2648                         Token l;
2649                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2650                             switch (l.kind) {
2651                                 case LPAREN: balance++; break;
2652                                 case RPAREN: balance--; break;
2653                                 case COMMA: if (balance == 1) hasComma = true; break;
2654                             }
2655                             lookahead++;
2656                         }
2657                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2658                         break;
2659                     case SEMI: //error recovery - this is not a valid statement:
2660                         isYieldStatement = true;
2661                         break;
2662                     default:
2663                         isYieldStatement = false;
2664                         break;
2665                 }
2666 
2667                 if (isYieldStatement) {
2668                     nextToken();
2669                     JCExpression t = term(EXPR);
2670                     accept(SEMI);
2671                     return List.of(toP(F.at(pos).Yield(t)));
2672                 }
2673 
2674                 //else intentional fall-through
2675             }
2676         }
2677         if (isRecordStart() &amp;&amp; allowRecords) {
2678             dc = token.comment(CommentStyle.JAVADOC);
2679             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2680         } else {
2681             Token prevToken = token;
2682             JCExpression t = term(EXPR | TYPE);
2683             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2684                 nextToken();
2685                 JCStatement stat = parseStatementAsBlock();
2686                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2687             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2688                 pos = token.pos;
2689                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2690                 F.at(pos);
2691                 return localVariableDeclarations(mods, t);
2692             } else {
2693                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2694                 t = checkExprStat(t);
2695                 accept(SEMI);
2696                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2697                 return List.of(expr);
2698             }
2699         }
2700     }
2701     //where
2702         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2703             ListBuffer&lt;JCStatement&gt; stats =
2704                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2705             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2706             accept(SEMI);
2707             storeEnd(stats.last(), S.prevToken().endPos);
2708             return stats.toList();
2709         }
2710 
2711     /** Statement =
2712      *       Block
2713      *     | IF ParExpression Statement [ELSE Statement]
2714      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2715      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2716      *     | WHILE ParExpression Statement
2717      *     | DO Statement WHILE ParExpression &quot;;&quot;
2718      *     | TRY Block ( Catches | [Catches] FinallyPart )
2719      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2720      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2721      *     | SYNCHRONIZED ParExpression Block
2722      *     | RETURN [Expression] &quot;;&quot;
2723      *     | THROW Expression &quot;;&quot;
2724      *     | BREAK [Ident] &quot;;&quot;
2725      *     | CONTINUE [Ident] &quot;;&quot;
2726      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2727      *     | &quot;;&quot;
2728      */
2729     public JCStatement parseSimpleStatement() {
2730         int pos = token.pos;
2731         switch (token.kind) {
2732         case LBRACE:
2733             return block();
2734         case IF: {
2735             nextToken();
2736             JCExpression cond = parExpression();
2737             JCStatement thenpart = parseStatementAsBlock();
2738             JCStatement elsepart = null;
2739             if (token.kind == ELSE) {
2740                 nextToken();
2741                 elsepart = parseStatementAsBlock();
2742             }
2743             return F.at(pos).If(cond, thenpart, elsepart);
2744         }
2745         case FOR: {
2746             nextToken();
2747             accept(LPAREN);
2748             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2749             if (inits.length() == 1 &amp;&amp;
2750                 inits.head.hasTag(VARDEF) &amp;&amp;
2751                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2752                 token.kind == COLON) {
2753                 JCVariableDecl var = (JCVariableDecl)inits.head;
2754                 accept(COLON);
2755                 JCExpression expr = parseExpression();
2756                 accept(RPAREN);
2757                 JCStatement body = parseStatementAsBlock();
2758                 return F.at(pos).ForeachLoop(var, expr, body);
2759             } else {
2760                 accept(SEMI);
2761                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2762                 accept(SEMI);
2763                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2764                 accept(RPAREN);
2765                 JCStatement body = parseStatementAsBlock();
2766                 return F.at(pos).ForLoop(inits, cond, steps, body);
2767             }
2768         }
2769         case WHILE: {
2770             nextToken();
2771             JCExpression cond = parExpression();
2772             JCStatement body = parseStatementAsBlock();
2773             return F.at(pos).WhileLoop(cond, body);
2774         }
2775         case DO: {
2776             nextToken();
2777             JCStatement body = parseStatementAsBlock();
2778             accept(WHILE);
2779             JCExpression cond = parExpression();
2780             accept(SEMI);
2781             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2782             return t;
2783         }
2784         case TRY: {
2785             nextToken();
2786             List&lt;JCTree&gt; resources = List.nil();
2787             if (token.kind == LPAREN) {
2788                 nextToken();
2789                 resources = resources();
2790                 accept(RPAREN);
2791             }
2792             JCBlock body = block();
2793             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2794             JCBlock finalizer = null;
2795             if (token.kind == CATCH || token.kind == FINALLY) {
2796                 while (token.kind == CATCH) catchers.append(catchClause());
2797                 if (token.kind == FINALLY) {
2798                     nextToken();
2799                     finalizer = block();
2800                 }
2801             } else {
2802                 if (resources.isEmpty()) {
2803                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2804                 }
2805             }
2806             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2807         }
2808         case SWITCH: {
2809             nextToken();
2810             JCExpression selector = parExpression();
2811             accept(LBRACE);
2812             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2813             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2814             accept(RBRACE);
2815             return t;
2816         }
2817         case SYNCHRONIZED: {
2818             nextToken();
2819             JCExpression lock = parExpression();
2820             JCBlock body = block();
2821             return F.at(pos).Synchronized(lock, body);
2822         }
2823         case RETURN: {
2824             nextToken();
2825             JCExpression result = token.kind == SEMI ? null : parseExpression();
2826             accept(SEMI);
2827             JCReturn t = toP(F.at(pos).Return(result));
2828             return t;
2829         }
2830         case THROW: {
2831             nextToken();
2832             JCExpression exc = parseExpression();
2833             accept(SEMI);
2834             JCThrow t = toP(F.at(pos).Throw(exc));
2835             return t;
2836         }
2837         case BREAK: {
2838             nextToken();
2839             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2840             accept(SEMI);
2841             JCBreak t = toP(F.at(pos).Break(label));
2842             return t;
2843         }
2844         case CONTINUE: {
2845             nextToken();
2846             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2847             accept(SEMI);
2848             JCContinue t =  toP(F.at(pos).Continue(label));
2849             return t;
2850         }
2851         case SEMI:
2852             nextToken();
2853             return toP(F.at(pos).Skip());
2854         case ELSE:
2855             int elsePos = token.pos;
2856             nextToken();
2857             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2858         case FINALLY:
2859             int finallyPos = token.pos;
2860             nextToken();
2861             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2862         case CATCH:
2863             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2864         case ASSERT: {
2865             nextToken();
2866             JCExpression assertion = parseExpression();
2867             JCExpression message = null;
2868             if (token.kind == COLON) {
2869                 nextToken();
2870                 message = parseExpression();
2871             }
2872             accept(SEMI);
2873             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2874             return t;
2875         }
2876         default:
2877             Assert.error();
2878             return null;
2879         }
2880     }
2881 
2882     @Override
2883     public JCStatement parseStatement() {
2884         return parseStatementAsBlock();
2885     }
2886 
2887     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2888         int errPos = S.errPos();
2889         JCTree stm = action.doRecover(this);
2890         S.errPos(errPos);
2891         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2892     }
2893 
2894     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2895      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2896      */
2897     protected JCCatch catchClause() {
2898         int pos = token.pos;
2899         accept(CATCH);
2900         accept(LPAREN);
2901         JCModifiers mods = optFinal(Flags.PARAMETER);
2902         List&lt;JCExpression&gt; catchTypes = catchTypes();
2903         JCExpression paramType = catchTypes.size() &gt; 1 ?
2904                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2905                 catchTypes.head;
2906         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2907         accept(RPAREN);
2908         JCBlock body = block();
2909         return F.at(pos).Catch(formal, body);
2910     }
2911 
2912     List&lt;JCExpression&gt; catchTypes() {
2913         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2914         catchTypes.add(parseType());
2915         while (token.kind == BAR) {
2916             nextToken();
2917             // Instead of qualident this is now parseType.
2918             // But would that allow too much, e.g. arrays or generics?
2919             catchTypes.add(parseType());
2920         }
2921         return catchTypes.toList();
2922     }
2923 
2924     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2925      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2926      *  SwitchLabel = CASE ConstantExpression &quot;:&quot; | DEFAULT &quot;:&quot;
2927      */
2928     List&lt;JCCase&gt; switchBlockStatementGroups() {
2929         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2930         while (true) {
2931             int pos = token.pos;
2932             switch (token.kind) {
2933             case CASE:
2934             case DEFAULT:
2935                 cases.appendList(switchBlockStatementGroup());
2936                 break;
2937             case RBRACE: case EOF:
2938                 return cases.toList();
2939             default:
2940                 nextToken(); // to ensure progress
2941                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2942             }
2943         }
2944     }
2945 
2946     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2947         int pos = token.pos;
2948         List&lt;JCStatement&gt; stats;
2949         JCCase c;
2950         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2951         switch (token.kind) {
2952         case CASE: {
2953             nextToken();
2954             ListBuffer&lt;JCExpression&gt; pats = new ListBuffer&lt;&gt;();
2955             while (true) {
2956                 pats.append(term(EXPR | NOLAMBDA));
2957                 if (token.kind != COMMA) break;
2958                 nextToken();
2959                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2960             };
2961             CaseTree.CaseKind caseKind;
2962             JCTree body = null;
2963             if (token.kind == ARROW) {
2964                 checkSourceLevel(Feature.SWITCH_RULE);
2965                 accept(ARROW);
2966                 caseKind = JCCase.RULE;
2967                 JCStatement statement = parseStatementAsBlock();
2968                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2969                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2970                 }
2971                 stats = List.of(statement);
2972                 body = stats.head;
2973             } else {
2974                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2975                 caseKind = JCCase.STATEMENT;
2976                 stats = blockStatements();
2977             }
2978             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2979             if (stats.isEmpty())
2980                 storeEnd(c, S.prevToken().endPos);
2981             return cases.append(c).toList();
2982         }
2983         case DEFAULT: {
2984             nextToken();
2985             CaseTree.CaseKind caseKind;
2986             JCTree body = null;
2987             if (token.kind == ARROW) {
2988                 checkSourceLevel(Feature.SWITCH_RULE);
2989                 accept(ARROW);
2990                 caseKind = JCCase.RULE;
2991                 JCStatement statement = parseStatementAsBlock();
2992                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2993                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2994                 }
2995                 stats = List.of(statement);
2996                 body = stats.head;
2997             } else {
2998                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2999                 caseKind = JCCase.STATEMENT;
3000                 stats = blockStatements();
3001             }
3002             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3003             if (stats.isEmpty())
3004                 storeEnd(c, S.prevToken().endPos);
3005             return cases.append(c).toList();
3006         }
3007         }
3008         throw new AssertionError(&quot;should not reach here&quot;);
3009     }
3010 
3011     /** MoreStatementExpressions = { COMMA StatementExpression }
3012      */
3013     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3014                                                                     JCExpression first,
3015                                                                     T stats) {
3016         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3017         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3018         while (token.kind == COMMA) {
3019             nextToken();
3020             pos = token.pos;
3021             JCExpression t = parseExpression();
3022             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3023             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3024         }
3025         return stats;
3026     }
3027 
3028     /** ForInit = StatementExpression MoreStatementExpressions
3029      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3030      */
3031     List&lt;JCStatement&gt; forInit() {
3032         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3033         int pos = token.pos;
3034         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3035             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3036         } else {
3037             JCExpression t = term(EXPR | TYPE);
3038             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3039                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
3040             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3041                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3042                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3043             } else {
3044                 return moreStatementExpressions(pos, t, stats).toList();
3045             }
3046         }
3047     }
3048 
3049     /** ForUpdate = StatementExpression MoreStatementExpressions
3050      */
3051     List&lt;JCExpressionStatement&gt; forUpdate() {
3052         return moreStatementExpressions(token.pos,
3053                                         parseExpression(),
3054                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3055     }
3056 
3057     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3058      *
3059      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3060      */
3061     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3062         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3063         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3064         int prevmode = mode;
3065         while (token.kind == MONKEYS_AT) {
3066             int pos = token.pos;
3067             nextToken();
3068             buf.append(annotation(pos, kind));
3069         }
3070         lastmode = mode;
3071         mode = prevmode;
3072         List&lt;JCAnnotation&gt; annotations = buf.toList();
3073 
3074         return annotations;
3075     }
3076 
3077     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3078         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3079         return annotations;
3080     }
3081 
3082     /** ModifiersOpt = { Modifier }
3083      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3084      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3085      *           | &quot;@&quot; Annotation
3086      */
3087     protected JCModifiers modifiersOpt() {
3088         return modifiersOpt(null);
3089     }
3090     protected JCModifiers modifiersOpt(JCModifiers partial) {
3091         long flags;
3092         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3093         int pos;
3094         if (partial == null) {
3095             flags = 0;
3096             pos = token.pos;
3097         } else {
3098             flags = partial.flags;
3099             annotations.appendList(partial.annotations);
3100             pos = partial.pos;
3101         }
3102         if (token.deprecatedFlag()) {
3103             flags |= Flags.DEPRECATED;
3104         }
3105         int lastPos;
3106     loop:
3107         while (true) {
3108             long flag;
3109             switch (token.kind) {
3110             case PRIVATE     : flag = Flags.PRIVATE; break;
3111             case PROTECTED   : flag = Flags.PROTECTED; break;
3112             case PUBLIC      : flag = Flags.PUBLIC; break;
3113             case STATIC      : flag = Flags.STATIC; break;
3114             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3115             case FINAL       : flag = Flags.FINAL; break;
3116             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3117             case NATIVE      : flag = Flags.NATIVE; break;
3118             case VOLATILE    : flag = Flags.VOLATILE; break;
3119             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3120             case STRICTFP    : flag = Flags.STRICTFP; break;
3121             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3122             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3123             case ERROR       : flag = 0; nextToken(); break;
3124             default: break loop;
3125             }
3126             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3127             lastPos = token.pos;
3128             nextToken();
3129             if (flag == Flags.ANNOTATION) {
3130                 if (token.kind != INTERFACE) {
3131                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3132                     // if first modifier is an annotation, set pos to annotation&#39;s.
3133                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3134                         pos = ann.pos;
3135                     annotations.append(ann);
3136                     flag = 0;
3137                 }
3138             }
3139             flags |= flag;
3140         }
3141         switch (token.kind) {
3142         case ENUM: flags |= Flags.ENUM; break;
3143         case INTERFACE: flags |= Flags.INTERFACE; break;
3144         default: break;
3145         }
3146 
3147         /* A modifiers tree with no modifier tokens or annotations
3148          * has no text position. */
3149         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3150             pos = Position.NOPOS;
3151 
3152         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3153         if (pos != Position.NOPOS)
3154             storeEnd(mods, S.prevToken().endPos);
3155         return mods;
3156     }
3157 
3158     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3159      *
3160      * @param pos position of &quot;@&quot; token
3161      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3162      */
3163     JCAnnotation annotation(int pos, Tag kind) {
3164         // accept(AT); // AT consumed by caller
3165         if (kind == Tag.TYPE_ANNOTATION) {
3166             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3167         }
3168         JCTree ident = qualident(false);
3169         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3170         JCAnnotation ann;
3171         if (kind == Tag.ANNOTATION) {
3172             ann = F.at(pos).Annotation(ident, fieldValues);
3173         } else if (kind == Tag.TYPE_ANNOTATION) {
3174             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3175         } else {
3176             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3177         }
3178 
3179         storeEnd(ann, S.prevToken().endPos);
3180         return ann;
3181     }
3182 
3183     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3184         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3185     }
3186 
3187     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3188     List&lt;JCExpression&gt; annotationFieldValues() {
3189         accept(LPAREN);
3190         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3191         if (token.kind != RPAREN) {
3192             buf.append(annotationFieldValue());
3193             while (token.kind == COMMA) {
3194                 nextToken();
3195                 buf.append(annotationFieldValue());
3196             }
3197         }
3198         accept(RPAREN);
3199         return buf.toList();
3200     }
3201 
3202     /** AnnotationFieldValue    = AnnotationValue
3203      *                          | Identifier &quot;=&quot; AnnotationValue
3204      */
3205     JCExpression annotationFieldValue() {
3206         if (LAX_IDENTIFIER.accepts(token.kind)) {
3207             selectExprMode();
3208             JCExpression t1 = term1();
3209             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3210                 int pos = token.pos;
3211                 accept(EQ);
3212                 JCExpression v = annotationValue();
3213                 return toP(F.at(pos).Assign(t1, v));
3214             } else {
3215                 return t1;
3216             }
3217         }
3218         return annotationValue();
3219     }
3220 
3221     /* AnnotationValue          = ConditionalExpression
3222      *                          | Annotation
3223      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3224      */
3225     JCExpression annotationValue() {
3226         int pos;
3227         switch (token.kind) {
3228         case MONKEYS_AT:
3229             pos = token.pos;
3230             nextToken();
3231             return annotation(pos, Tag.ANNOTATION);
3232         case LBRACE:
3233             pos = token.pos;
3234             accept(LBRACE);
3235             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3236             if (token.kind == COMMA) {
3237                 nextToken();
3238             } else if (token.kind != RBRACE) {
3239                 buf.append(annotationValue());
3240                 while (token.kind == COMMA) {
3241                     nextToken();
3242                     if (token.kind == RBRACE) break;
3243                     buf.append(annotationValue());
3244                 }
3245             }
3246             accept(RBRACE);
3247             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3248         default:
3249             selectExprMode();
3250             return term1();
3251         }
3252     }
3253 
3254     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3255      */
3256     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3257                                                                          JCExpression type,
3258                                                                          T vdefs,
3259                                                                          boolean localDecl)
3260     {
3261         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3262     }
3263 
3264     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3265      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3266      *
3267      *  @param reqInit  Is an initializer always required?
3268      *  @param dc       The documentation comment for the variable declarations, or null.
3269      */
3270     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3271                                                                      JCModifiers mods,
3272                                                                      JCExpression type,
3273                                                                      Name name,
3274                                                                      boolean reqInit,
3275                                                                      Comment dc,
3276                                                                      T vdefs,
3277                                                                      boolean localDecl)
3278     {
3279         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3280         vdefs.append(head);
3281         while (token.kind == COMMA) {
3282             // All but last of multiple declarators subsume a comma
3283             storeEnd((JCTree)vdefs.last(), token.endPos);
3284             nextToken();
3285             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3286         }
3287         return vdefs;
3288     }
3289 
3290     /** VariableDeclarator = Ident VariableDeclaratorRest
3291      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3292      */
3293     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3294         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3295     }
3296 
3297     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3298      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3299      *
3300      *  @param reqInit  Is an initializer always required?
3301      *  @param dc       The documentation comment for the variable declarations, or null.
3302      */
3303     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3304                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3305         type = bracketsOpt(type);
3306         JCExpression init = null;
3307         if (token.kind == EQ) {
3308             nextToken();
3309             init = variableInitializer();
3310         }
3311         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3312         JCTree elemType = TreeInfo.innermostType(type, true);
3313         int startPos = Position.NOPOS;
3314         if (elemType.hasTag(IDENT)) {
3315             Name typeName = ((JCIdent)elemType).name;
3316             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3317                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3318                     //error - &#39;var&#39; and arrays
3319                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3320                 } else {
3321                     if(compound)
3322                         //error - &#39;var&#39; in compound local var decl
3323                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3324                     startPos = TreeInfo.getStartPos(mods);
3325                     if (startPos == Position.NOPOS)
3326                         startPos = TreeInfo.getStartPos(type);
3327                     //implicit type
3328                     type = null;
3329                 }
3330             }
3331         }
3332         JCVariableDecl result =
3333             toP(F.at(pos).VarDef(mods, name, type, init));
3334         attach(result, dc);
3335         result.startPos = startPos;
3336         return result;
3337     }
3338 
3339     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3340         switch (e.getTag()) {
3341             case IDENT:
3342                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3343             case TYPEARRAY:
3344                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3345             default:
3346                 return null;
3347         }
3348     }
3349 
3350     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3351         if (name == names.var) {
3352             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3353                 return Source.JDK10;
3354             } else if (shouldWarn) {
3355                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3356             }
3357         }
3358         if (name == names.yield) {
3359             if (allowYieldStatement) {
3360                 return Source.JDK14;
3361             } else if (shouldWarn) {
3362                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3363             }
3364         }
3365         if (name == names.record) {
3366             if (allowRecords) {
3367                 return Source.JDK14;
3368             } else if (shouldWarn) {
3369                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3370             }
3371         }
3372         return null;
3373     }
3374 
3375     /** VariableDeclaratorId = Ident BracketsOpt
3376      */
3377     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3378         return variableDeclaratorId(mods, type, false);
3379     }
3380     //where
3381     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3382         int pos = token.pos;
3383         Name name;
3384         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3385             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3386             name = token.name();
3387             nextToken();
3388         } else {
3389             if (allowThisIdent ||
3390                 !lambdaParameter ||
3391                 LAX_IDENTIFIER.accepts(token.kind) ||
3392                 mods.flags != Flags.PARAMETER ||
3393                 mods.annotations.nonEmpty()) {
3394                 JCExpression pn = qualident(false);
3395                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3396                     name = ((JCIdent)pn).name;
3397                 } else {
3398                     if (allowThisIdent) {
3399                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3400                             log.error(token.pos, Errors.VarargsAndReceiver);
3401                         }
3402                         if (token.kind == LBRACKET) {
3403                             log.error(token.pos, Errors.ArrayAndReceiver);
3404                         }
3405                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3406                             log.error(token.pos, Errors.WrongReceiver);
3407                         }
3408                     }
3409                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3410                 }
3411             } else {
3412                 /** if it is a lambda parameter and the token kind is not an identifier,
3413                  *  and there are no modifiers or annotations, then this means that the compiler
3414                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3415                  *  var or explicit parameters. So we assign the error name to the parameter name
3416                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3417                  *  a higher level.
3418                  */
3419                 name = names.empty;
3420             }
3421         }
3422         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3423                 token.kind == LBRACKET) {
3424             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3425         }
3426         type = bracketsOpt(type);
3427 
3428         return toP(F.at(pos).VarDef(mods, name, type, null));
3429     }
3430 
3431     /** Resources = Resource { &quot;;&quot; Resources }
3432      */
3433     List&lt;JCTree&gt; resources() {
3434         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3435         defs.append(resource());
3436         while (token.kind == SEMI) {
3437             // All but last of multiple declarators must subsume a semicolon
3438             storeEnd(defs.last(), token.endPos);
3439             int semiColonPos = token.pos;
3440             nextToken();
3441             if (token.kind == RPAREN) { // Optional trailing semicolon
3442                                        // after last resource
3443                 break;
3444             }
3445             defs.append(resource());
3446         }
3447         return defs.toList();
3448     }
3449 
3450     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3451      *           | Expression
3452      */
3453     protected JCTree resource() {
3454         int startPos = token.pos;
3455         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3456             JCModifiers mods = optFinal(Flags.FINAL);
3457             JCExpression t = parseType(true);
3458             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3459         }
3460         JCExpression t = term(EXPR | TYPE);
3461         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3462             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3463             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3464         } else {
3465             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3466             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3467                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3468             }
3469 
3470             return t;
3471         }
3472     }
3473 
3474     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3475      */
3476     public JCTree.JCCompilationUnit parseCompilationUnit() {
3477         Token firstToken = token;
3478         JCModifiers mods = null;
3479         boolean consumedToplevelDoc = false;
3480         boolean seenImport = false;
3481         boolean seenPackage = false;
3482         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3483         if (token.kind == MONKEYS_AT)
3484             mods = modifiersOpt();
3485 
3486         if (token.kind == PACKAGE) {
3487             int packagePos = token.pos;
3488             List&lt;JCAnnotation&gt; annotations = List.nil();
3489             seenPackage = true;
3490             if (mods != null) {
3491                 checkNoMods(mods.flags);
3492                 annotations = mods.annotations;
3493                 mods = null;
3494             }
3495             nextToken();
3496             JCExpression pid = qualident(false);
3497             accept(SEMI);
3498             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3499             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3500             consumedToplevelDoc = true;
3501             defs.append(pd);
3502         }
3503 
3504         boolean checkForImports = true;
3505         boolean firstTypeDecl = true;
3506         while (token.kind != EOF) {
3507             if (token.pos &lt;= endPosTable.errorEndPos) {
3508                 // error recovery
3509                 skip(checkForImports, false, false, false);
3510                 if (token.kind == EOF)
3511                     break;
3512             }
3513             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3514                 seenImport = true;
3515                 defs.append(importDeclaration());
3516             } else {
3517                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3518                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3519                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3520                     consumedToplevelDoc = true;
3521                 }
3522                 if (mods != null || token.kind != SEMI)
3523                     mods = modifiersOpt(mods);
3524                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3525                     ModuleKind kind = ModuleKind.STRONG;
3526                     if (token.name() == names.open) {
3527                         kind = ModuleKind.OPEN;
3528                         nextToken();
3529                     }
3530                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3531                         if (mods != null) {
3532                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3533                         }
3534                         defs.append(moduleDecl(mods, kind, docComment));
3535                         consumedToplevelDoc = true;
3536                         break;
3537                     } else if (kind != ModuleKind.STRONG) {
3538                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3539                     }
3540                 }
3541                 JCTree def = typeDeclaration(mods, docComment);
3542                 if (def instanceof JCExpressionStatement)
3543                     def = ((JCExpressionStatement)def).expr;
3544                 defs.append(def);
3545                 if (def instanceof JCClassDecl)
3546                     checkForImports = false;
3547                 mods = null;
3548                 firstTypeDecl = false;
3549             }
3550         }
3551         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3552         if (!consumedToplevelDoc)
3553             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3554         if (defs.isEmpty())
3555             storeEnd(toplevel, S.prevToken().endPos);
3556         if (keepDocComments)
3557             toplevel.docComments = docComments;
3558         if (keepLineMap)
3559             toplevel.lineMap = S.getLineMap();
3560         this.endPosTable.setParser(null); // remove reference to parser
3561         toplevel.endPositions = this.endPosTable;
3562         return toplevel;
3563     }
3564 
3565     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3566         int pos = token.pos;
3567         checkSourceLevel(Feature.MODULES);
3568 
3569         nextToken();
3570         JCExpression name = qualident(false);
3571         List&lt;JCDirective&gt; directives = null;
3572 
3573         accept(LBRACE);
3574         directives = moduleDirectiveList();
3575         accept(RBRACE);
3576         accept(EOF);
3577 
3578         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3579         attach(result, dc);
3580         return result;
3581     }
3582 
3583     List&lt;JCDirective&gt; moduleDirectiveList() {
3584         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3585         while (token.kind == IDENTIFIER) {
3586             int pos = token.pos;
3587             if (token.name() == names.requires) {
3588                 nextToken();
3589                 boolean isTransitive = false;
3590                 boolean isStaticPhase = false;
3591             loop:
3592                 while (true) {
3593                     switch (token.kind) {
3594                         case IDENTIFIER:
3595                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3596                                 Token t1 = S.token(1);
3597                                 if (t1.kind == SEMI || t1.kind == DOT) {
3598                                     break loop;
3599                                 }
3600                                 isTransitive = true;
3601                                 break;
3602                             } else {
3603                                 break loop;
3604                             }
3605                         case STATIC:
3606                             if (isStaticPhase) {
3607                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3608                             }
3609                             isStaticPhase = true;
3610                             break;
3611                         default:
3612                             break loop;
3613                     }
3614                     nextToken();
3615                 }
3616                 JCExpression moduleName = qualident(false);
3617                 accept(SEMI);
3618                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3619             } else if (token.name() == names.exports || token.name() == names.opens) {
3620                 boolean exports = token.name() == names.exports;
3621                 nextToken();
3622                 JCExpression pkgName = qualident(false);
3623                 List&lt;JCExpression&gt; moduleNames = null;
3624                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3625                     nextToken();
3626                     moduleNames = qualidentList(false);
3627                 }
3628                 accept(SEMI);
3629                 JCDirective d;
3630                 if (exports) {
3631                     d = F.at(pos).Exports(pkgName, moduleNames);
3632                 } else {
3633                     d = F.at(pos).Opens(pkgName, moduleNames);
3634                 }
3635                 defs.append(toP(d));
3636             } else if (token.name() == names.provides) {
3637                 nextToken();
3638                 JCExpression serviceName = qualident(false);
3639                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3640                     nextToken();
3641                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3642                     accept(SEMI);
3643                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3644                 } else {
3645                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3646                     skip(false, false, false, false);
3647                 }
3648             } else if (token.name() == names.uses) {
3649                 nextToken();
3650                 JCExpression service = qualident(false);
3651                 accept(SEMI);
3652                 defs.append(toP(F.at(pos).Uses(service)));
3653             } else {
3654                 setErrorEndPos(pos);
3655                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3656                 break;
3657             }
3658         }
3659         return defs.toList();
3660     }
3661 
3662     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3663      */
3664     protected JCTree importDeclaration() {
3665         int pos = token.pos;
3666         nextToken();
3667         boolean importStatic = false;
3668         if (token.kind == STATIC) {
3669             importStatic = true;
3670             nextToken();
3671         }
3672         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3673         do {
3674             int pos1 = token.pos;
3675             accept(DOT);
3676             if (token.kind == STAR) {
3677                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3678                 nextToken();
3679                 break;
3680             } else {
3681                 pid = toP(F.at(pos1).Select(pid, ident()));
3682             }
3683         } while (token.kind == DOT);
3684         accept(SEMI);
3685         return toP(F.at(pos).Import(pid, importStatic));
3686     }
3687 
3688     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3689      *                  | &quot;;&quot;
3690      */
3691     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3692         int pos = token.pos;
3693         if (mods == null &amp;&amp; token.kind == SEMI) {
3694             nextToken();
3695             return toP(F.at(pos).Skip());
3696         } else {
3697             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3698         }
3699     }
3700 
3701     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3702      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3703      *  @param mods     Any modifiers starting the class or interface declaration
3704      *  @param dc       The documentation comment for the class, or null.
3705      */
3706     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3707         if (token.kind == CLASS) {
3708             return classDeclaration(mods, dc);
3709         } if (isRecordStart()) {
3710             return recordDeclaration(mods, dc);
3711         } else if (token.kind == INTERFACE) {
3712             return interfaceDeclaration(mods, dc);
3713         } else if (token.kind == ENUM) {
3714             return enumDeclaration(mods, dc);
3715         } else {
3716             int pos = token.pos;
3717             List&lt;JCTree&gt; errs;
3718             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3719                 checkSourceLevel(Feature.RECORDS);
3720                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3721                 return toP(F.Exec(erroneousTree));
3722             } else {
3723                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3724                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3725                     setErrorEndPos(token.pos);
3726                 } else {
3727                     errs = List.of(mods);
3728                 }
3729                 final JCErroneous erroneousTree;
3730                 if (parseModuleInfo) {
3731                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3732                 } else {
3733                     if (allowRecords) {
3734                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3735                     } else {
3736                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3737                     }
3738                 }
3739                 return toP(F.Exec(erroneousTree));
3740             }
3741         }
3742     }
3743 
3744     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3745      *                     [IMPLEMENTS TypeList] ClassBody
3746      *  @param mods    The modifiers starting the class declaration
3747      *  @param dc       The documentation comment for the class, or null.
3748      */
3749     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3750         int pos = token.pos;
3751         accept(CLASS);
3752         Name name = typeName();
3753 
3754         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3755 
3756         JCExpression extending = null;
3757         if (token.kind == EXTENDS) {
3758             nextToken();
3759             extending = parseType();
3760         }
3761         List&lt;JCExpression&gt; implementing = List.nil();
3762         if (token.kind == IMPLEMENTS) {
3763             nextToken();
3764             implementing = typeList();
3765         }
3766         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3767         JCClassDecl result = toP(F.at(pos).ClassDef(
3768             mods, name, typarams, extending, implementing, defs));
3769         attach(result, dc);
3770         return result;
3771     }
3772 
3773     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3774         int pos = token.pos;
3775         nextToken();
3776         mods.flags |= Flags.RECORD;
3777         Name name = typeName();
3778 
3779         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3780 
3781         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3782 
3783         List&lt;JCExpression&gt; implementing = List.nil();
3784         if (token.kind == IMPLEMENTS) {
3785             nextToken();
3786             implementing = typeList();
3787         }
3788         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3789         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3790         for (JCVariableDecl field : headerFields) {
3791             fields.add(field);
3792         }
3793         for (JCTree def : defs) {
3794             if (def.hasTag(METHODDEF)) {
3795                 JCMethodDecl methDef = (JCMethodDecl) def;
3796                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3797                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3798                     for (JCVariableDecl param : headerFields) {
3799                         tmpParams.add(F.at(param)
3800                                 // we will get flags plus annotations from the record component
3801                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3802                                 param.name, param.vartype, null));
3803                     }
3804                     methDef.params = tmpParams.toList();
3805                 }
3806             }
3807         }
3808         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3809             JCVariableDecl field = fields.get(i);
3810             defs = defs.prepend(field);
3811         }
3812         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3813         attach(result, dc);
3814         return result;
3815     }
3816 
3817     Name typeName() {
3818         int pos = token.pos;
3819         Name name = ident();
3820         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3821         if (source != null) {
3822             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3823         }
3824         return name;
3825     }
3826 
3827     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3828      *                         [EXTENDS TypeList] InterfaceBody
3829      *  @param mods    The modifiers starting the interface declaration
3830      *  @param dc       The documentation comment for the interface, or null.
3831      */
3832     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3833         int pos = token.pos;
3834         accept(INTERFACE);
3835 
3836         Name name = typeName();
3837 
3838         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3839 
3840         List&lt;JCExpression&gt; extending = List.nil();
3841         if (token.kind == EXTENDS) {
3842             nextToken();
3843             extending = typeList();
3844         }
3845         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3846         JCClassDecl result = toP(F.at(pos).ClassDef(
3847             mods, name, typarams, null, extending, defs));
3848         attach(result, dc);
3849         return result;
3850     }
3851 
3852     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3853      *  @param mods    The modifiers starting the enum declaration
3854      *  @param dc       The documentation comment for the enum, or null.
3855      */
3856     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3857         int pos = token.pos;
3858         accept(ENUM);
3859 
3860         Name name = typeName();
3861 
3862         List&lt;JCExpression&gt; implementing = List.nil();
3863         if (token.kind == IMPLEMENTS) {
3864             nextToken();
3865             implementing = typeList();
3866         }
3867 
3868         List&lt;JCTree&gt; defs = enumBody(name);
3869         mods.flags |= Flags.ENUM;
3870         JCClassDecl result = toP(F.at(pos).
3871             ClassDef(mods, name, List.nil(),
3872                      null, implementing, defs));
3873         attach(result, dc);
3874         return result;
3875     }
3876 
3877     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3878      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3879      */
3880     List&lt;JCTree&gt; enumBody(Name enumName) {
3881         accept(LBRACE);
3882         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3883         boolean wasSemi = false;
3884         boolean hasStructuralErrors = false;
3885         boolean wasError = false;
3886         if (token.kind == COMMA) {
3887             nextToken();
3888             if (token.kind == SEMI) {
3889                 wasSemi = true;
3890                 nextToken();
3891             } else if (token.kind != RBRACE) {
3892                 reportSyntaxError(S.prevToken().endPos,
3893                                   Errors.Expected2(RBRACE, SEMI));
3894                 wasError = true;
3895             }
3896         }
3897         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3898             if (token.kind == SEMI) {
3899                 accept(SEMI);
3900                 wasSemi = true;
3901                 if (token.kind == RBRACE || token.kind == EOF) break;
3902             }
3903             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3904             if (memberType == EnumeratorEstimate.UNKNOWN) {
3905                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3906                                      : EnumeratorEstimate.ENUMERATOR;
3907             }
3908             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3909                 wasError = false;
3910                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3911                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3912                     hasStructuralErrors = true;
3913                 }
3914                 defs.append(enumeratorDeclaration(enumName));
3915                 if (token.pos &lt;= endPosTable.errorEndPos) {
3916                     // error recovery
3917                    skip(false, true, true, false);
3918                 } else {
3919                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
3920                         if (token.kind == COMMA) {
3921                             nextToken();
3922                         } else {
3923                             setErrorEndPos(token.pos);
3924                             reportSyntaxError(S.prevToken().endPos,
3925                                               Errors.Expected3(COMMA, RBRACE, SEMI));
3926                             wasError = true;
3927                         }
3928                     }
3929                 }
3930             } else {
3931                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
3932                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
3933                     hasStructuralErrors = true;
3934                 }
3935                 wasError = false;
3936                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
3937                                                                 false, false));
3938                 if (token.pos &lt;= endPosTable.errorEndPos) {
3939                     // error recovery
3940                    skip(false, true, true, false);
3941                 }
3942             }
3943         }
3944         accept(RBRACE);
3945         return defs.toList();
3946     }
3947 
3948     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
3949         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {
3950             Token next = S.token(1);
3951             switch (next.kind) {
3952                 case LPAREN: case LBRACE: case COMMA: case SEMI:
3953                     return EnumeratorEstimate.ENUMERATOR;
3954             }
3955         }
3956         switch (token.kind) {
3957             case IDENTIFIER: case MONKEYS_AT: case LT:
3958                 return EnumeratorEstimate.UNKNOWN;
3959             default:
3960                 return EnumeratorEstimate.MEMBER;
3961         }
3962     }
3963 
3964     private enum EnumeratorEstimate {
3965         ENUMERATOR,
3966         MEMBER,
3967         UNKNOWN;
3968     }
3969 
3970     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3971      */
3972     JCTree enumeratorDeclaration(Name enumName) {
3973         Comment dc = token.comment(CommentStyle.JAVADOC);
3974         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3975         if (token.deprecatedFlag()) {
3976             flags |= Flags.DEPRECATED;
3977         }
3978         int pos = token.pos;
3979         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3980         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3981         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3982         int identPos = token.pos;
3983         Name name = ident();
3984         int createPos = token.pos;
3985         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3986             ? arguments() : List.nil();
3987         JCClassDecl body = null;
3988         if (token.kind == LBRACE) {
3989             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
3990             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
3991             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3992         }
3993         if (args.isEmpty() &amp;&amp; body == null)
3994             createPos = identPos;
3995         JCIdent ident = F.at(identPos).Ident(enumName);
3996         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
3997         if (createPos != identPos)
3998             storeEnd(create, S.prevToken().endPos);
3999         ident = F.at(identPos).Ident(enumName);
4000         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4001         attach(result, dc);
4002         return result;
4003     }
4004 
4005     /** TypeList = Type {&quot;,&quot; Type}
4006      */
4007     List&lt;JCExpression&gt; typeList() {
4008         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4009         ts.append(parseType());
4010         while (token.kind == COMMA) {
4011             nextToken();
4012             ts.append(parseType());
4013         }
4014         return ts.toList();
4015     }
4016 
4017     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4018      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4019      */
4020     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4021         accept(LBRACE);
4022         if (token.pos &lt;= endPosTable.errorEndPos) {
4023             // error recovery
4024             skip(false, true, false, false);
4025             if (token.kind == LBRACE)
4026                 nextToken();
4027         }
4028         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4029         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4030             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4031             if (token.pos &lt;= endPosTable.errorEndPos) {
4032                // error recovery
4033                skip(false, true, true, false);
4034            }
4035         }
4036         accept(RBRACE);
4037         return defs.toList();
4038     }
4039 
4040     /** ClassBodyDeclaration =
4041      *      &quot;;&quot;
4042      *    | [STATIC] Block
4043      *    | ModifiersOpt
4044      *      ( Type Ident
4045      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4046      *      | VOID Ident VoidMethodDeclaratorRest
4047      *      | TypeParameters [Annotations]
4048      *        ( Type Ident MethodDeclaratorRest
4049      *        | VOID Ident VoidMethodDeclaratorRest
4050      *        )
4051      *      | Ident ConstructorDeclaratorRest
4052      *      | TypeParameters Ident ConstructorDeclaratorRest
4053      *      | ClassOrInterfaceOrEnumDeclaration
4054      *      )
4055      *  InterfaceBodyDeclaration =
4056      *      &quot;;&quot;
4057      *    | ModifiersOpt
4058      *      ( Type Ident
4059      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4060      *      | VOID Ident MethodDeclaratorRest
4061      *      | TypeParameters [Annotations]
4062      *        ( Type Ident MethodDeclaratorRest
4063      *        | VOID Ident VoidMethodDeclaratorRest
4064      *        )
4065      *      | ClassOrInterfaceOrEnumDeclaration
4066      *      )
4067      *
4068      */
4069     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4070         if (token.kind == SEMI) {
4071             nextToken();
4072             return List.nil();
4073         } else {
4074             Comment dc = token.comment(CommentStyle.JAVADOC);
4075             int pos = token.pos;
4076             JCModifiers mods = modifiersOpt();
4077             if (token.kind == CLASS ||
4078                 allowRecords &amp;&amp; isRecordStart() ||
4079                 token.kind == INTERFACE ||
4080                 token.kind == ENUM) {
4081                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4082             } else if (token.kind == LBRACE &amp;&amp;
4083                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4084                        mods.annotations.isEmpty()) {
4085                 if (isInterface) {
4086                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4087                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4088                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4089                 }
4090                 return List.of(block(pos, mods.flags));
4091             } else {
4092                 pos = token.pos;
4093                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4094                 // if there are type parameters but no modifiers, save the start
4095                 // position of the method in the modifiers.
4096                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4097                     mods.pos = pos;
4098                     storeEnd(mods, pos);
4099                 }
4100                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4101 
4102                 if (annosAfterParams.nonEmpty()) {
4103                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4104                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4105                     if (mods.pos == Position.NOPOS)
4106                         mods.pos = mods.annotations.head.pos;
4107                 }
4108 
4109                 Token tk = token;
4110                 pos = token.pos;
4111                 JCExpression type;
4112                 boolean isVoid = token.kind == VOID;
4113                 if (isVoid) {
4114                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4115                     nextToken();
4116                 } else {
4117                     // method returns types are un-annotated types
4118                     type = unannotatedType(false);
4119                 }
4120                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4121                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4122                     if (isInterface || tk.name() != className)
4123                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4124                     else if (annosAfterParams.nonEmpty())
4125                         illegal(annosAfterParams.head.pos);
4126                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4127                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4128                     }
4129                     return List.of(methodDeclaratorRest(
4130                         pos, mods, null, names.init, typarams,
4131                         isInterface, true, isRecord, dc));
4132                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4133                     // trying to define a compact constructor with a throws clause
4134                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4135                             Errors.InvalidCanonicalConstructorInRecord(
4136                                     Fragments.Compact,
4137                                     className,
4138                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4139                     skip(false, true, false, false);
4140                     return List.of(methodDeclaratorRest(
4141                             pos, mods, null, names.init, typarams,
4142                             isInterface, true, isRecord, dc));
4143                 } else {
4144                     pos = token.pos;
4145                     Name name = ident();
4146                     if (token.kind == LPAREN) {
4147                         return List.of(methodDeclaratorRest(
4148                             pos, mods, type, name, typarams,
4149                             isInterface, isVoid, false, dc));
4150                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4151                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4152                         List&lt;JCTree&gt; defs =
4153                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4154                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4155                         accept(SEMI);
4156                         storeEnd(defs.last(), S.prevToken().endPos);
4157                         return defs;
4158                     } else {
4159                             int errPos = pos;
4160                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4161                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4162                             accept(SEMI);
4163                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4164                         }
4165                     } else {
4166                         pos = token.pos;
4167                         List&lt;JCTree&gt; err;
4168                         if (isVoid || typarams.nonEmpty()) {
4169                             JCMethodDecl m =
4170                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4171                                                             List.nil(), List.nil(), null, null));
4172                             attach(m, dc);
4173                             err = List.of(m);
4174                         } else {
4175                             err = List.nil();
4176                         }
4177                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4178                     }
4179                 }
4180             }
4181         }
4182     }
4183 
4184     protected boolean isRecordStart() {
4185      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4186             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4187              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4188              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4189           checkSourceLevel(Feature.RECORDS);
4190           return true;
4191     } else {
4192        return false;
4193    }
4194 }
4195 
4196     /** MethodDeclaratorRest =
4197      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4198      *  VoidMethodDeclaratorRest =
4199      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4200      *  ConstructorDeclaratorRest =
4201      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4202      */
4203     protected JCTree methodDeclaratorRest(int pos,
4204                               JCModifiers mods,
4205                               JCExpression type,
4206                               Name name,
4207                               List&lt;JCTypeParameter&gt; typarams,
4208                               boolean isInterface, boolean isVoid,
4209                               boolean isRecord,
4210                               Comment dc) {
4211         if (isInterface) {
4212             if ((mods.flags &amp; Flags.STATIC) != 0) {
4213                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4214             }
4215             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4216                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4217             }
4218         }
4219         JCVariableDecl prevReceiverParam = this.receiverParam;
4220         try {
4221             this.receiverParam = null;
4222             // Parsing formalParameters sets the receiverParam, if present
4223             List&lt;JCVariableDecl&gt; params = List.nil();
4224             List&lt;JCExpression&gt; thrown = List.nil();
4225             if (!isRecord || name != names.init || token.kind == LPAREN) {
4226                 params = formalParameters();
4227                 if (!isVoid) type = bracketsOpt(type);
4228                 if (token.kind == THROWS) {
4229                     nextToken();
4230                     thrown = qualidentList(true);
4231                 }
4232             }
4233             JCBlock body = null;
4234             JCExpression defaultValue;
4235             if (token.kind == LBRACE) {
4236                 body = block();
4237                 defaultValue = null;
4238             } else {
4239                 if (token.kind == DEFAULT) {
4240                     accept(DEFAULT);
4241                     defaultValue = annotationValue();
4242                 } else {
4243                     defaultValue = null;
4244                 }
4245                 accept(SEMI);
4246                 if (token.pos &lt;= endPosTable.errorEndPos) {
4247                     // error recovery
4248                     skip(false, true, false, false);
4249                     if (token.kind == LBRACE) {
4250                         body = block();
4251                     }
4252                 }
4253             }
4254 
4255             JCMethodDecl result =
4256                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4257                                             receiverParam, params, thrown,
4258                                             body, defaultValue));
4259             attach(result, dc);
4260             return result;
4261         } finally {
4262             this.receiverParam = prevReceiverParam;
4263         }
4264     }
4265 
4266     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4267      */
4268     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4269         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4270 
4271         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4272         JCExpression qi = qualident(allowAnnos);
4273         if (!typeAnnos.isEmpty()) {
4274             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4275             ts.append(at);
4276         } else {
4277             ts.append(qi);
4278         }
4279         while (token.kind == COMMA) {
4280             nextToken();
4281 
4282             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4283             qi = qualident(allowAnnos);
4284             if (!typeAnnos.isEmpty()) {
4285                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4286                 ts.append(at);
4287             } else {
4288                 ts.append(qi);
4289             }
4290         }
4291         return ts.toList();
4292     }
4293 
4294     /**
4295      *  {@literal
4296      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4297      *  }
4298      */
4299     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4300         if (token.kind == LT) {
4301             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4302             nextToken();
4303             typarams.append(typeParameter());
4304             while (token.kind == COMMA) {
4305                 nextToken();
4306                 typarams.append(typeParameter());
4307             }
4308             accept(GT);
4309             return typarams.toList();
4310         } else {
4311             return List.nil();
4312         }
4313     }
4314 
4315     /**
4316      *  {@literal
4317      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4318      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4319      *  TypeVariable = Ident
4320      *  }
4321      */
4322     JCTypeParameter typeParameter() {
4323         int pos = token.pos;
4324         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4325         Name name = typeName();
4326         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4327         if (token.kind == EXTENDS) {
4328             nextToken();
4329             bounds.append(parseType());
4330             while (token.kind == AMP) {
4331                 nextToken();
4332                 bounds.append(parseType());
4333             }
4334         }
4335         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4336     }
4337 
4338     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4339      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4340      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4341      */
4342     List&lt;JCVariableDecl&gt; formalParameters() {
4343         return formalParameters(false, false);
4344     }
4345     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4346         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4347         JCVariableDecl lastParam;
4348         accept(LPAREN);
4349         if (token.kind != RPAREN) {
4350             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4351             lastParam = formalParameter(lambdaParameters, recordComponents);
4352             if (lastParam.nameexpr != null) {
4353                 this.receiverParam = lastParam;
4354             } else {
4355                 params.append(lastParam);
4356             }
4357             this.allowThisIdent = false;
4358             while (token.kind == COMMA) {
4359                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4360                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4361                 }
4362                 nextToken();
4363                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4364             }
4365         }
4366         if (token.kind == RPAREN) {
4367             nextToken();
4368         } else {
4369             setErrorEndPos(token.pos);
4370             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4371         }
4372         return params.toList();
4373     }
4374 
4375     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4376         if (hasParens) {
4377             accept(LPAREN);
4378         }
4379         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4380         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4381             params.append(implicitParameter());
4382             while (token.kind == COMMA) {
4383                 nextToken();
4384                 params.append(implicitParameter());
4385             }
4386         }
4387         if (hasParens) {
4388             accept(RPAREN);
4389         }
4390         return params.toList();
4391     }
4392 
4393     JCModifiers optFinal(long flags) {
4394         JCModifiers mods = modifiersOpt();
4395         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4396         mods.flags |= flags;
4397         return mods;
4398     }
4399 
4400     /**
4401      * Inserts the annotations (and possibly a new array level)
4402      * to the left-most type in an array or nested type.
4403      *
4404      * When parsing a type like {@code @B Outer.Inner @A []}, the
4405      * {@code @A} annotation should target the array itself, while
4406      * {@code @B} targets the nested type {@code Outer}.
4407      *
4408      * Currently the parser parses the annotation first, then
4409      * the array, and then inserts the annotation to the left-most
4410      * nested type.
4411      *
4412      * When {@code createNewLevel} is true, then a new array
4413      * level is inserted as the most inner type, and have the
4414      * annotations target it.  This is useful in the case of
4415      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4416      * first parses the type {@code String @A []} then inserts
4417      * a new array level with {@code @B} annotation.
4418      */
4419     private JCExpression insertAnnotationsToMostInner(
4420             JCExpression type, List&lt;JCAnnotation&gt; annos,
4421             boolean createNewLevel) {
4422         int origEndPos = getEndPos(type);
4423         JCExpression mostInnerType = type;
4424         JCArrayTypeTree mostInnerArrayType = null;
4425         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4426             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4427             mostInnerType = mostInnerArrayType.elemtype;
4428         }
4429 
4430         if (createNewLevel) {
4431             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4432         }
4433 
4434         JCExpression mostInnerTypeToReturn = mostInnerType;
4435         if (annos.nonEmpty()) {
4436             JCExpression lastToModify = mostInnerType;
4437 
4438             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4439                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4440                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4441                     lastToModify = mostInnerType;
4442                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4443                 }
4444                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4445                     lastToModify = mostInnerType;
4446                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4447                 }
4448             }
4449 
4450             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4451 
4452             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4453                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4454             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4455                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4456             } else {
4457                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4458                 mostInnerTypeToReturn = mostInnerType;
4459             }
4460         }
4461 
4462         if (mostInnerArrayType == null) {
4463             return mostInnerTypeToReturn;
4464         } else {
4465             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4466             storeEnd(type, origEndPos);
4467             return type;
4468         }
4469     }
4470 
4471     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4472      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4473      */
4474     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4475         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4476         if (recordComponent &amp;&amp; mods.flags != 0) {
4477             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4478         }
4479         if (recordComponent) {
4480             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4481         }
4482         // need to distinguish between vararg annos and array annos
4483         // look at typeAnnotationsPushedBack comment
4484         this.permitTypeAnnotationsPushBack = true;
4485         JCExpression type = parseType(lambdaParameter);
4486         this.permitTypeAnnotationsPushBack = false;
4487 
4488         if (token.kind == ELLIPSIS) {
4489             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4490             typeAnnotationsPushedBack = List.nil();
4491             mods.flags |= Flags.VARARGS;
4492             // insert var arg type annotations
4493             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4494             nextToken();
4495         } else {
4496             // if not a var arg, then typeAnnotationsPushedBack should be null
4497             if (typeAnnotationsPushedBack.nonEmpty()) {
4498                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4499             }
4500             typeAnnotationsPushedBack = List.nil();
4501         }
4502         return variableDeclaratorId(mods, type, lambdaParameter);
4503     }
4504 
4505     protected JCVariableDecl implicitParameter() {
4506         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4507         return variableDeclaratorId(mods, null, true);
4508     }
4509 
4510 /* ---------- auxiliary methods -------------- */
4511     /** Check that given tree is a legal expression statement.
4512      */
4513     protected JCExpression checkExprStat(JCExpression t) {
4514         if (!TreeInfo.isExpressionStatement(t)) {
4515             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4516             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4517             return ret;
4518         } else {
4519             return t;
4520         }
4521     }
4522 
4523     /** Return precedence of operator represented by token,
4524      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4525      */
4526     static int prec(TokenKind token) {
4527         JCTree.Tag oc = optag(token);
4528         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4529     }
4530 
4531     /**
4532      * Return the lesser of two positions, making allowance for either one
4533      * being unset.
4534      */
4535     static int earlier(int pos1, int pos2) {
4536         if (pos1 == Position.NOPOS)
4537             return pos2;
4538         if (pos2 == Position.NOPOS)
4539             return pos1;
4540         return (pos1 &lt; pos2 ? pos1 : pos2);
4541     }
4542 
4543     /** Return operation tag of binary operator represented by token,
4544      *  No_TAG if token is not a binary operator.
4545      */
4546     static JCTree.Tag optag(TokenKind token) {
4547         switch (token) {
4548         case BARBAR:
4549             return OR;
4550         case AMPAMP:
4551             return AND;
4552         case BAR:
4553             return BITOR;
4554         case BAREQ:
4555             return BITOR_ASG;
4556         case CARET:
4557             return BITXOR;
4558         case CARETEQ:
4559             return BITXOR_ASG;
4560         case AMP:
4561             return BITAND;
4562         case AMPEQ:
4563             return BITAND_ASG;
4564         case EQEQ:
4565             return JCTree.Tag.EQ;
4566         case BANGEQ:
4567             return NE;
4568         case LT:
4569             return JCTree.Tag.LT;
4570         case GT:
4571             return JCTree.Tag.GT;
4572         case LTEQ:
4573             return LE;
4574         case GTEQ:
4575             return GE;
4576         case LTLT:
4577             return SL;
4578         case LTLTEQ:
4579             return SL_ASG;
4580         case GTGT:
4581             return SR;
4582         case GTGTEQ:
4583             return SR_ASG;
4584         case GTGTGT:
4585             return USR;
4586         case GTGTGTEQ:
4587             return USR_ASG;
4588         case PLUS:
4589             return JCTree.Tag.PLUS;
4590         case PLUSEQ:
4591             return PLUS_ASG;
4592         case SUB:
4593             return MINUS;
4594         case SUBEQ:
4595             return MINUS_ASG;
4596         case STAR:
4597             return MUL;
4598         case STAREQ:
4599             return MUL_ASG;
4600         case SLASH:
4601             return DIV;
4602         case SLASHEQ:
4603             return DIV_ASG;
4604         case PERCENT:
4605             return MOD;
4606         case PERCENTEQ:
4607             return MOD_ASG;
4608         case INSTANCEOF:
4609             return TYPETEST;
4610         default:
4611             return NO_TAG;
4612         }
4613     }
4614 
4615     /** Return operation tag of unary operator represented by token,
4616      *  No_TAG if token is not a binary operator.
4617      */
4618     static JCTree.Tag unoptag(TokenKind token) {
4619         switch (token) {
4620         case PLUS:
4621             return POS;
4622         case SUB:
4623             return NEG;
4624         case BANG:
4625             return NOT;
4626         case TILDE:
4627             return COMPL;
4628         case PLUSPLUS:
4629             return PREINC;
4630         case SUBSUB:
4631             return PREDEC;
4632         default:
4633             return NO_TAG;
4634         }
4635     }
4636 
4637     /** Return type tag of basic type represented by token,
4638      *  NONE if token is not a basic type identifier.
4639      */
4640     static TypeTag typetag(TokenKind token) {
4641         switch (token) {
4642         case BYTE:
4643             return TypeTag.BYTE;
4644         case CHAR:
4645             return TypeTag.CHAR;
4646         case SHORT:
4647             return TypeTag.SHORT;
4648         case INT:
4649             return TypeTag.INT;
4650         case LONG:
4651             return TypeTag.LONG;
4652         case FLOAT:
4653             return TypeTag.FLOAT;
4654         case DOUBLE:
4655             return TypeTag.DOUBLE;
4656         case BOOLEAN:
4657             return TypeTag.BOOLEAN;
4658         default:
4659             return TypeTag.NONE;
4660         }
4661     }
4662 
4663     void checkSourceLevel(Feature feature) {
4664         checkSourceLevel(token.pos, feature);
4665     }
4666 
4667     protected void checkSourceLevel(int pos, Feature feature) {
4668         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4669             //preview feature without --preview flag, error
4670             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4671         } else if (!feature.allowedInSource(source)) {
4672             //incompatible source level, error
4673             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4674         } else if (preview.isPreview(feature)) {
4675             //use of preview feature, warn
4676             preview.warnPreview(pos, feature);
4677         }
4678     }
4679 
4680     /*
4681      * a functional source tree and end position mappings
4682      */
4683     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4684 
4685         private final IntHashTable endPosMap;
4686 
4687         SimpleEndPosTable(JavacParser parser) {
4688             super(parser);
4689             endPosMap = new IntHashTable();
4690         }
4691 
4692         public void storeEnd(JCTree tree, int endpos) {
4693             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4694                                  endPosMap.lookup(tree));
4695         }
4696 
4697         protected &lt;T extends JCTree&gt; T to(T t) {
4698             storeEnd(t, parser.token.endPos);
4699             return t;
4700         }
4701 
4702         protected &lt;T extends JCTree&gt; T toP(T t) {
4703             storeEnd(t, parser.S.prevToken().endPos);
4704             return t;
4705         }
4706 
4707         public int getEndPos(JCTree tree) {
4708             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4709             // As long as Position.NOPOS==-1, this just returns value.
4710             return (value == -1) ? Position.NOPOS : value;
4711         }
4712 
4713         public int replaceTree(JCTree oldTree, JCTree newTree) {
4714             int pos = endPosMap.remove(oldTree);
4715             if (pos != -1) {
4716                 storeEnd(newTree, pos);
4717                 return pos;
4718             }
4719             return Position.NOPOS;
4720         }
4721     }
4722 
4723     /*
4724      * a default skeletal implementation without any mapping overhead.
4725      */
4726     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4727 
4728         EmptyEndPosTable(JavacParser parser) {
4729             super(parser);
4730         }
4731 
4732         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4733 
4734         protected &lt;T extends JCTree&gt; T to(T t) {
4735             return t;
4736         }
4737 
4738         protected &lt;T extends JCTree&gt; T toP(T t) {
4739             return t;
4740         }
4741 
4742         public int getEndPos(JCTree tree) {
4743             return Position.NOPOS;
4744         }
4745 
4746         public int replaceTree(JCTree oldTree, JCTree newTree) {
4747             return Position.NOPOS;
4748         }
4749 
4750     }
4751 
4752     protected static abstract class AbstractEndPosTable implements EndPosTable {
4753         /**
4754          * The current parser.
4755          */
4756         protected JavacParser parser;
4757 
4758         /**
4759          * Store the last error position.
4760          */
4761         public int errorEndPos = Position.NOPOS;
4762 
4763         public AbstractEndPosTable(JavacParser parser) {
4764             this.parser = parser;
4765         }
4766 
4767         /**
4768          * Store current token&#39;s ending position for a tree, the value of which
4769          * will be the greater of last error position and the ending position of
4770          * the current token.
4771          * @param t The tree.
4772          */
4773         protected abstract &lt;T extends JCTree&gt; T to(T t);
4774 
4775         /**
4776          * Store current token&#39;s ending position for a tree, the value of which
4777          * will be the greater of last error position and the ending position of
4778          * the previous token.
4779          * @param t The tree.
4780          */
4781         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4782 
4783         /**
4784          * Set the error position during the parsing phases, the value of which
4785          * will be set only if it is greater than the last stored error position.
4786          * @param errPos The error position
4787          */
4788         public void setErrorEndPos(int errPos) {
4789             if (errPos &gt; errorEndPos) {
4790                 errorEndPos = errPos;
4791             }
4792         }
4793 
4794         public void setParser(JavacParser parser) {
4795             this.parser = parser;
4796         }
4797     }
4798 }
    </pre>
  </body>
</html>
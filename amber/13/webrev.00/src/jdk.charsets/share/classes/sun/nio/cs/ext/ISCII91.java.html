<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.charsets/share/classes/sun/nio/cs/ext/ISCII91.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /*
 27  */
 28 
 29 
 30 package sun.nio.cs.ext;
 31 
 32 import java.nio.charset.Charset;
 33 import java.nio.CharBuffer;
 34 import java.nio.ByteBuffer;
 35 import java.nio.charset.CharsetDecoder;
 36 import java.nio.charset.CharsetEncoder;
 37 import java.nio.charset.CoderResult;
 38 import sun.nio.cs.Surrogate;
 39 import sun.nio.cs.HistoricallyNamedCharset;
 40 
 41 public class ISCII91 extends Charset implements HistoricallyNamedCharset
 42 {
 43     private static final char NUKTA_CHAR = &#39;\u093c&#39;;
 44     private static final char HALANT_CHAR = &#39;\u094d&#39;;
 45     private static final byte NO_CHAR = (byte)255;
 46 
 47     public ISCII91() {
 48         super(&quot;x-ISCII91&quot;, ExtendedCharsets.aliasesFor(&quot;x-ISCII91&quot;));
 49     }
 50 
 51     public String historicalName() {
 52         return &quot;ISCII91&quot;;
 53     }
 54 
 55     public boolean contains(Charset cs) {
 56         return ((cs.name().equals(&quot;US-ASCII&quot;))
 57                 || (cs instanceof ISCII91));
 58     }
 59 
 60     public CharsetDecoder newDecoder() {
 61         return new Decoder(this);
 62     }
 63 
 64     public CharsetEncoder newEncoder() {
 65         return new Encoder(this);
 66     }
 67 
 68     private static final char[] directMapTable = {
 69         &#39;\u0000&#39;, // ascii character
 70         &#39;\u0001&#39;, // ascii character
 71         &#39;\u0002&#39;, // ascii character
 72         &#39;\u0003&#39;, // ascii character
 73         &#39;\u0004&#39;, // ascii character
 74         &#39;\u0005&#39;, // ascii character
 75         &#39;\u0006&#39;, // ascii character
 76         &#39;\u0007&#39;, // ascii character
 77         &#39;\u0008&#39;, // ascii character
 78         &#39;\u0009&#39;, // ascii character
 79         &#39;\012&#39;, // ascii character
 80         &#39;\u000b&#39;, // ascii character
 81         &#39;\u000c&#39;, // ascii character
 82         &#39;\015&#39;, // ascii character
 83         &#39;\u000e&#39;, // ascii character
 84         &#39;\u000f&#39;, // ascii character
 85         &#39;\u0010&#39;, // ascii character
 86         &#39;\u0011&#39;, // ascii character
 87         &#39;\u0012&#39;, // ascii character
 88         &#39;\u0013&#39;, // ascii character
 89         &#39;\u0014&#39;, // ascii character
 90         &#39;\u0015&#39;, // ascii character
 91         &#39;\u0016&#39;, // ascii character
 92         &#39;\u0017&#39;, // ascii character
 93         &#39;\u0018&#39;, // ascii character
 94         &#39;\u0019&#39;, // ascii character
 95         &#39;\u001a&#39;, // ascii character
 96         &#39;\u001b&#39;, // ascii character
 97         &#39;\u001c&#39;, // ascii character
 98         &#39;\u001d&#39;, // ascii character
 99         &#39;\u001e&#39;, // ascii character
100         &#39;\u001f&#39;, // ascii character
101         &#39;\u0020&#39;, // ascii character
102         &#39;\u0021&#39;, // ascii character
103         &#39;\u0022&#39;, // ascii character
104         &#39;\u0023&#39;, // ascii character
105         &#39;\u0024&#39;, // ascii character
106         &#39;\u0025&#39;, // ascii character
107         &#39;\u0026&#39;, // ascii character
108         (char)0x0027, // &#39;\u0027&#39; control -- ascii character
109         &#39;\u0028&#39;, // ascii character
110         &#39;\u0029&#39;, // ascii character
111         &#39;\u002a&#39;, // ascii character
112         &#39;\u002b&#39;, // ascii character
113         &#39;\u002c&#39;, // ascii character
114         &#39;\u002d&#39;, // ascii character
115         &#39;\u002e&#39;, // ascii character
116         &#39;\u002f&#39;, // ascii character
117         &#39;\u0030&#39;, // ascii character
118         &#39;\u0031&#39;, // ascii character
119         &#39;\u0032&#39;, // ascii character
120         &#39;\u0033&#39;, // ascii character
121         &#39;\u0034&#39;, // ascii character
122         &#39;\u0035&#39;, // ascii character
123         &#39;\u0036&#39;, // ascii character
124         &#39;\u0037&#39;, // ascii character
125         &#39;\u0038&#39;, // ascii character
126         &#39;\u0039&#39;, // ascii character
127         &#39;\u003a&#39;, // ascii character
128         &#39;\u003b&#39;, // ascii character
129         &#39;\u003c&#39;, // ascii character
130         &#39;\u003d&#39;, // ascii character
131         &#39;\u003e&#39;, // ascii character
132         &#39;\u003f&#39;, // ascii character
133         &#39;\u0040&#39;, // ascii character
134         &#39;\u0041&#39;, // ascii character
135         &#39;\u0042&#39;, // ascii character
136         &#39;\u0043&#39;, // ascii character
137         &#39;\u0044&#39;, // ascii character
138         &#39;\u0045&#39;, // ascii character
139         &#39;\u0046&#39;, // ascii character
140         &#39;\u0047&#39;, // ascii character
141         &#39;\u0048&#39;, // ascii character
142         &#39;\u0049&#39;, // ascii character
143         &#39;\u004a&#39;, // ascii character
144         &#39;\u004b&#39;, // ascii character
145         &#39;\u004c&#39;, // ascii character
146         &#39;\u004d&#39;, // ascii character
147         &#39;\u004e&#39;, // ascii character
148         &#39;\u004f&#39;, // ascii character
149         &#39;\u0050&#39;, // ascii character
150         &#39;\u0051&#39;, // ascii character
151         &#39;\u0052&#39;, // ascii character
152         &#39;\u0053&#39;, // ascii character
153         &#39;\u0054&#39;, // ascii character
154         &#39;\u0055&#39;, // ascii character
155         &#39;\u0056&#39;, // ascii character
156         &#39;\u0057&#39;, // ascii character
157         &#39;\u0058&#39;, // ascii character
158         &#39;\u0059&#39;, // ascii character
159         &#39;\u005a&#39;, // ascii character
160         &#39;\u005b&#39;, // ascii character
161         &#39;\\&#39;,// &#39;\u005c&#39; -- ascii character
162         &#39;\u005d&#39;, // ascii character
163         &#39;\u005e&#39;, // ascii character
164         &#39;\u005f&#39;, // ascii character
165         &#39;\u0060&#39;, // ascii character
166         &#39;\u0061&#39;, // ascii character
167         &#39;\u0062&#39;, // ascii character
168         &#39;\u0063&#39;, // ascii character
169         &#39;\u0064&#39;, // ascii character
170         &#39;\u0065&#39;, // ascii character
171         &#39;\u0066&#39;, // ascii character
172         &#39;\u0067&#39;, // ascii character
173         &#39;\u0068&#39;, // ascii character
174         &#39;\u0069&#39;, // ascii character
175         &#39;\u006a&#39;, // ascii character
176         &#39;\u006b&#39;, // ascii character
177         &#39;\u006c&#39;, // ascii character
178         &#39;\u006d&#39;, // ascii character
179         &#39;\u006e&#39;, // ascii character
180         &#39;\u006f&#39;, // ascii character
181         &#39;\u0070&#39;, // ascii character
182         &#39;\u0071&#39;, // ascii character
183         &#39;\u0072&#39;, // ascii character
184         &#39;\u0073&#39;, // ascii character
185         &#39;\u0074&#39;, // ascii character
186         &#39;\u0075&#39;, // ascii character
187         &#39;\u0076&#39;, // ascii character
188         &#39;\u0077&#39;, // ascii character
189         &#39;\u0078&#39;, // ascii character
190         &#39;\u0079&#39;, // ascii character
191         &#39;\u007a&#39;, // ascii character
192         &#39;\u007b&#39;, // ascii character
193         &#39;\u007c&#39;, // ascii character
194         &#39;\u007d&#39;, // ascii character
195         &#39;\u007e&#39;, // ascii character
196         &#39;\u007f&#39;, // ascii character
197         &#39;\uffff&#39;, // unknown character
198         &#39;\uffff&#39;, // unknown character
199         &#39;\uffff&#39;, // unknown character
200         &#39;\uffff&#39;, // unknown character
201         &#39;\uffff&#39;, // unknown character
202         &#39;\uffff&#39;, // unknown character
203         &#39;\uffff&#39;, // unknown character
204         &#39;\uffff&#39;, // unknown character
205         &#39;\uffff&#39;, // unknown character
206         &#39;\uffff&#39;, // unknown character
207         &#39;\uffff&#39;, // unknown character
208         &#39;\uffff&#39;, // unknown character
209         &#39;\uffff&#39;, // unknown character
210         &#39;\uffff&#39;, // unknown character
211         &#39;\uffff&#39;, // unknown character
212         &#39;\uffff&#39;, // unknown character
213         &#39;\uffff&#39;, // unknown character
214         &#39;\uffff&#39;, // unknown character
215         &#39;\uffff&#39;, // unknown character
216         &#39;\uffff&#39;, // unknown character
217         &#39;\uffff&#39;, // unknown character
218         &#39;\uffff&#39;, // unknown character
219         &#39;\uffff&#39;, // unknown character
220         &#39;\uffff&#39;, // unknown character
221         &#39;\uffff&#39;, // unknown character
222         &#39;\uffff&#39;, // unknown character
223         &#39;\uffff&#39;, // unknown character
224         &#39;\uffff&#39;, // unknown character
225         &#39;\uffff&#39;, // unknown character
226         &#39;\uffff&#39;, // unknown character
227         &#39;\uffff&#39;, // unknown character
228         &#39;\uffff&#39;, // unknown character
229         &#39;\u0901&#39;, // a1 -- Vowel-modifier CHANDRABINDU
230         &#39;\u0902&#39;, // a2 -- Vowel-modifier ANUSWAR
231         &#39;\u0903&#39;, // a3 -- Vowel-modifier VISARG
232 
233         &#39;\u0905&#39;, // a4 -- Vowel A
234         &#39;\u0906&#39;, // a5 -- Vowel AA
235         &#39;\u0907&#39;, // a6 -- Vowel I
236         &#39;\u0908&#39;, // a7 -- Vowel II
237         &#39;\u0909&#39;, // a8 -- Vowel U
238         &#39;\u090a&#39;, // a9 -- Vowel UU
239         &#39;\u090b&#39;, // aa -- Vowel RI
240         &#39;\u090e&#39;, // ab -- Vowel E ( Southern Scripts )
241         &#39;\u090f&#39;, // ac -- Vowel EY
242         &#39;\u0910&#39;, // ad -- Vowel AI
243         &#39;\u090d&#39;, // ae -- Vowel AYE ( Devanagari Script )
244         &#39;\u0912&#39;, // af -- Vowel O ( Southern Scripts )
245         &#39;\u0913&#39;, // b0 -- Vowel OW
246         &#39;\u0914&#39;, // b1 -- Vowel AU
247         &#39;\u0911&#39;, // b2 -- Vowel AWE ( Devanagari Script )
248         &#39;\u0915&#39;, // b3 -- Consonant KA
249         &#39;\u0916&#39;, // b4 -- Consonant KHA
250         &#39;\u0917&#39;, // b5 -- Consonant GA
251         &#39;\u0918&#39;, // b6 -- Consonant GHA
252         &#39;\u0919&#39;, // b7 -- Consonant NGA
253         &#39;\u091a&#39;, // b8 -- Consonant CHA
254         &#39;\u091b&#39;, // b9 -- Consonant CHHA
255         &#39;\u091c&#39;, // ba -- Consonant JA
256         &#39;\u091d&#39;, // bb -- Consonant JHA
257         &#39;\u091e&#39;, // bc -- Consonant JNA
258         &#39;\u091f&#39;, // bd -- Consonant Hard TA
259         &#39;\u0920&#39;, // be -- Consonant Hard THA
260         &#39;\u0921&#39;, // bf -- Consonant Hard DA
261         &#39;\u0922&#39;, // c0 -- Consonant Hard DHA
262         &#39;\u0923&#39;, // c1 -- Consonant Hard NA
263         &#39;\u0924&#39;, // c2 -- Consonant Soft TA
264         &#39;\u0925&#39;, // c3 -- Consonant Soft THA
265         &#39;\u0926&#39;, // c4 -- Consonant Soft DA
266         &#39;\u0927&#39;, // c5 -- Consonant Soft DHA
267         &#39;\u0928&#39;, // c6 -- Consonant Soft NA
268         &#39;\u0929&#39;, // c7 -- Consonant NA ( Tamil )
269         &#39;\u092a&#39;, // c8 -- Consonant PA
270         &#39;\u092b&#39;, // c9 -- Consonant PHA
271         &#39;\u092c&#39;, // ca -- Consonant BA
272         &#39;\u092d&#39;, // cb -- Consonant BHA
273         &#39;\u092e&#39;, // cc -- Consonant MA
274         &#39;\u092f&#39;, // cd -- Consonant YA
275         &#39;\u095f&#39;, // ce -- Consonant JYA ( Bengali, Assamese &amp; Oriya )
276         &#39;\u0930&#39;, // cf -- Consonant RA
277         &#39;\u0931&#39;, // d0 -- Consonant Hard RA ( Southern Scripts )
278         &#39;\u0932&#39;, // d1 -- Consonant LA
279         &#39;\u0933&#39;, // d2 -- Consonant Hard LA
280         &#39;\u0934&#39;, // d3 -- Consonant ZHA ( Tamil &amp; Malayalam )
281         &#39;\u0935&#39;, // d4 -- Consonant VA
282         &#39;\u0936&#39;, // d5 -- Consonant SHA
283         &#39;\u0937&#39;, // d6 -- Consonant Hard SHA
284         &#39;\u0938&#39;, // d7 -- Consonant SA
285         &#39;\u0939&#39;, // d8 -- Consonant HA
286 
287         &#39;\u200d&#39;, // d9 -- Consonant INVISIBLE
288         &#39;\u093e&#39;, // da -- Vowel Sign AA
289 
290         &#39;\u093f&#39;, // db -- Vowel Sign I
291         &#39;\u0940&#39;, // dc -- Vowel Sign II
292         &#39;\u0941&#39;, // dd -- Vowel Sign U
293         &#39;\u0942&#39;, // de -- Vowel Sign UU
294         &#39;\u0943&#39;, // df -- Vowel Sign RI
295         &#39;\u0946&#39;, // e0 -- Vowel Sign E ( Southern Scripts )
296         &#39;\u0947&#39;, // e1 -- Vowel Sign EY
297         &#39;\u0948&#39;, // e2 -- Vowel Sign AI
298         &#39;\u0945&#39;, // e3 -- Vowel Sign AYE ( Devanagari Script )
299         &#39;\u094a&#39;, // e4 -- Vowel Sign O ( Southern Scripts )
300         &#39;\u094b&#39;, // e5 -- Vowel Sign OW
301         &#39;\u094c&#39;, // e6 -- Vowel Sign AU
302         &#39;\u0949&#39;, // e7 -- Vowel Sign AWE ( Devanagari Script )
303 
304         &#39;\u094d&#39;, // e8 -- Vowel Omission Sign ( Halant )
305         &#39;\u093c&#39;, // e9 -- Diacritic Sign ( Nukta )
306         &#39;\u0964&#39;, // ea -- Full Stop ( Viram, Northern Scripts )
307 
308         &#39;\uffff&#39;, // eb -- This position shall not be used
309         &#39;\uffff&#39;, // ec -- This position shall not be used
310         &#39;\uffff&#39;, // ed -- This position shall not be used
311         &#39;\uffff&#39;, // ee -- This position shall not be used
312 
313         &#39;\ufffd&#39;, // ef -- Attribute Code ( ATR )
314         &#39;\ufffd&#39;, // f0 -- Extension Code ( EXT )
315 
316         &#39;\u0966&#39;, // f1 -- Digit 0
317         &#39;\u0967&#39;, // f2 -- Digit 1
318         &#39;\u0968&#39;, // f3 -- Digit 2
319         &#39;\u0969&#39;, // f4 -- Digit 3
320         &#39;\u096a&#39;, // f5 -- Digit 4
321         &#39;\u096b&#39;, // f6 -- Digit 5
322         &#39;\u096c&#39;, // f7 -- Digit 6
323         &#39;\u096d&#39;, // f8 -- Digit 7
324         &#39;\u096e&#39;, // f9 -- Digit 8
325         &#39;\u096f&#39;, // fa -- Digit 9
326 
327         &#39;\uffff&#39;, // fb -- This position shall not be used
328         &#39;\uffff&#39;, // fc -- This position shall not be used
329         &#39;\uffff&#39;, // fd -- This position shall not be used
330         &#39;\uffff&#39;, // fe -- This position shall not be used
331         &#39;\uffff&#39;  // ff -- This position shall not be used
332     }; //end of table definition
333 
334     private static final byte[] encoderMappingTable = {
335     NO_CHAR,NO_CHAR, //0900 &lt;reserved&gt;
336     (byte)161,NO_CHAR, //0901 -- DEVANAGARI SIGN CANDRABINDU = anunasika
337     (byte)162,NO_CHAR, //0902 -- DEVANAGARI SIGN ANUSVARA = bindu
338     (byte)163,NO_CHAR, //0903 -- DEVANAGARI SIGN VISARGA
339     NO_CHAR,NO_CHAR, //0904 &lt;reserved&gt;
340     (byte)164,NO_CHAR, //0905 -- DEVANAGARI LETTER A
341     (byte)165,NO_CHAR, //0906 -- DEVANAGARI LETTER AA
342     (byte)166,NO_CHAR, //0907 -- DEVANAGARI LETTER I
343     (byte)167,NO_CHAR, //0908 -- DEVANAGARI LETTER II
344     (byte)168,NO_CHAR, //0909 -- DEVANAGARI LETTER U
345     (byte)169,NO_CHAR, //090a -- DEVANAGARI LETTER UU
346     (byte)170,NO_CHAR, //090b -- DEVANAGARI LETTER VOCALIC R
347     (byte)166,(byte)233, //090c -- DEVANAGARI LETTER VOVALIC L
348     (byte)174,NO_CHAR, //090d -- DEVANAGARI LETTER CANDRA E
349     (byte)171,NO_CHAR, //090e -- DEVANAGARI LETTER SHORT E
350     (byte)172,NO_CHAR, //090f -- DEVANAGARI LETTER E
351     (byte)173,NO_CHAR, //0910 -- DEVANAGARI LETTER AI
352     (byte)178,NO_CHAR, //0911 -- DEVANAGARI LETTER CANDRA O
353     (byte)175,NO_CHAR, //0912 -- DEVANAGARI LETTER SHORT O
354     (byte)176,NO_CHAR, //0913 -- DEVANAGARI LETTER O
355     (byte)177,NO_CHAR, //0914 -- DEVANAGARI LETTER AU
356     (byte)179,NO_CHAR, //0915 -- DEVANAGARI LETTER KA
357     (byte)180,NO_CHAR, //0916 -- DEVANAGARI LETTER KHA
358     (byte)181,NO_CHAR, //0917 -- DEVANAGARI LETTER GA
359     (byte)182,NO_CHAR, //0918 -- DEVANAGARI LETTER GHA
360     (byte)183,NO_CHAR, //0919 -- DEVANAGARI LETTER NGA
361     (byte)184,NO_CHAR, //091a -- DEVANAGARI LETTER CA
362     (byte)185,NO_CHAR, //091b -- DEVANAGARI LETTER CHA
363     (byte)186,NO_CHAR, //091c -- DEVANAGARI LETTER JA
364     (byte)187,NO_CHAR, //091d -- DEVANAGARI LETTER JHA
365     (byte)188,NO_CHAR, //091e -- DEVANAGARI LETTER NYA
366     (byte)189,NO_CHAR, //091f -- DEVANAGARI LETTER TTA
367     (byte)190,NO_CHAR, //0920 -- DEVANAGARI LETTER TTHA
368     (byte)191,NO_CHAR, //0921 -- DEVANAGARI LETTER DDA
369     (byte)192,NO_CHAR, //0922 -- DEVANAGARI LETTER DDHA
370     (byte)193,NO_CHAR, //0923 -- DEVANAGARI LETTER NNA
371     (byte)194,NO_CHAR, //0924 -- DEVANAGARI LETTER TA
372     (byte)195,NO_CHAR, //0925 -- DEVANAGARI LETTER THA
373     (byte)196,NO_CHAR, //0926 -- DEVANAGARI LETTER DA
374     (byte)197,NO_CHAR, //0927 -- DEVANAGARI LETTER DHA
375     (byte)198,NO_CHAR, //0928 -- DEVANAGARI LETTER NA
376     (byte)199,NO_CHAR, //0929 -- DEVANAGARI LETTER NNNA &lt;=&gt; 0928 + 093C
377     (byte)200,NO_CHAR, //092a -- DEVANAGARI LETTER PA
378     (byte)201,NO_CHAR, //092b -- DEVANAGARI LETTER PHA
379     (byte)202,NO_CHAR, //092c -- DEVANAGARI LETTER BA
380     (byte)203,NO_CHAR, //092d -- DEVANAGARI LETTER BHA
381     (byte)204,NO_CHAR, //092e -- DEVANAGARI LETTER MA
382     (byte)205,NO_CHAR, //092f -- DEVANAGARI LETTER YA
383     (byte)207,NO_CHAR, //0930 -- DEVANAGARI LETTER RA
384     (byte)208,NO_CHAR, //0931 -- DEVANAGARI LETTER RRA &lt;=&gt; 0930 + 093C
385     (byte)209,NO_CHAR, //0932 -- DEVANAGARI LETTER LA
386     (byte)210,NO_CHAR, //0933 -- DEVANAGARI LETTER LLA
387     (byte)211,NO_CHAR, //0934 -- DEVANAGARI LETTER LLLA &lt;=&gt; 0933 + 093C
388     (byte)212,NO_CHAR, //0935 -- DEVANAGARI LETTER VA
389     (byte)213,NO_CHAR, //0936 -- DEVANAGARI LETTER SHA
390     (byte)214,NO_CHAR, //0937 -- DEVANAGARI LETTER SSA
391     (byte)215,NO_CHAR, //0938 -- DEVANAGARI LETTER SA
392     (byte)216,NO_CHAR, //0939 -- DEVANAGARI LETTER HA
393     NO_CHAR,NO_CHAR, //093a &lt;reserved&gt;
394     NO_CHAR,NO_CHAR, //093b &lt;reserved&gt;
395     (byte)233,NO_CHAR, //093c -- DEVANAGARI SIGN NUKTA
396     (byte)234,(byte)233, //093d -- DEVANAGARI SIGN AVAGRAHA
397     (byte)218,NO_CHAR, //093e -- DEVANAGARI VOWEL SIGN AA
398     (byte)219,NO_CHAR, //093f -- DEVANAGARI VOWEL SIGN I
399     (byte)220,NO_CHAR, //0940 -- DEVANAGARI VOWEL SIGN II
400     (byte)221,NO_CHAR, //0941 -- DEVANAGARI VOWEL SIGN U
401     (byte)222,NO_CHAR, //0942 -- DEVANAGARI VOWEL SIGN UU
402     (byte)223,NO_CHAR, //0943 -- DEVANAGARI VOWEL SIGN VOCALIC R
403     (byte)223,(byte)233, //0944 -- DEVANAGARI VOWEL SIGN VOCALIC RR
404     (byte)227,NO_CHAR, //0945 -- DEVANAGARI VOWEL SIGN CANDRA E
405     (byte)224,NO_CHAR, //0946 -- DEVANAGARI VOWEL SIGN SHORT E
406     (byte)225,NO_CHAR, //0947 -- DEVANAGARI VOWEL SIGN E
407     (byte)226,NO_CHAR, //0948 -- DEVANAGARI VOWEL SIGN AI
408     (byte)231,NO_CHAR, //0949 -- DEVANAGARI VOWEL SIGN CANDRA O
409     (byte)228,NO_CHAR, //094a -- DEVANAGARI VOWEL SIGN SHORT O
410     (byte)229,NO_CHAR, //094b -- DEVANAGARI VOWEL SIGN O
411     (byte)230,NO_CHAR, //094c -- DEVANAGARI VOWEL SIGN AU
412     (byte)232,NO_CHAR, //094d -- DEVANAGARI SIGN VIRAMA ( halant )
413     NO_CHAR,NO_CHAR, //094e &lt;reserved&gt;
414     NO_CHAR,NO_CHAR, //094f &lt;reserved&gt;
415     (byte)161,(byte)233, //0950 -- DEVANAGARI OM
416     (byte)240,(byte)181, //0951 -- DEVANAGARI STRESS SIGN UDATTA
417     (byte)240,(byte)184, //0952 -- DEVANAGARI STRESS SIGN ANUDATTA
418     (byte)254,NO_CHAR, //0953 -- DEVANAGARI GRAVE ACCENT || MISSING
419     (byte)254,NO_CHAR, //0954 -- DEVANAGARI ACUTE ACCENT || MISSING
420     NO_CHAR,NO_CHAR, //0955 &lt;reserved&gt;
421     NO_CHAR,NO_CHAR, //0956 &lt;reserved&gt;
422     NO_CHAR,NO_CHAR, //0957 &lt;reserved&gt;
423     (byte)179,(byte)233, //0958 -- DEVANAGARI LETTER QA &lt;=&gt; 0915 + 093C
424     (byte)180,(byte)233, //0959 -- DEVANAGARI LETTER KHHA &lt;=&gt; 0916 + 093C
425     (byte)181,(byte)233, //095a -- DEVANAGARI LETTER GHHA &lt;=&gt; 0917 + 093C
426     (byte)186,(byte)233, //095b -- DEVANAGARI LETTER ZA &lt;=&gt; 091C + 093C
427     (byte)191,(byte)233, //095c -- DEVANAGARI LETTER DDDHA &lt;=&gt; 0921 + 093C
428     (byte)192,(byte)233, //095d -- DEVANAGARI LETTER RHA &lt;=&gt; 0922 + 093C
429     (byte)201,(byte)233, //095e -- DEVANAGARI LETTER FA &lt;=&gt; 092B + 093C
430     (byte)206,NO_CHAR, //095f -- DEVANAGARI LETTER YYA &lt;=&gt; 092F + 093C
431     (byte)170,(byte)233, //0960 -- DEVANAGARI LETTER VOCALIC RR
432     (byte)167,(byte)233, //0961 -- DEVANAGARI LETTER VOCALIC LL
433     (byte)219,(byte)233, //0962 -- DEVANAGARI VOWEL SIGN VOCALIC L
434     (byte)220,(byte)233, //0963 -- DEVANAGARI VOWEL SIGN VOCALIC LL
435     (byte)234,NO_CHAR, //0964 -- DEVANAGARI DANDA ( phrase separator )
436     (byte)234,(byte)234, //0965 -- DEVANAGARI DOUBLE DANDA
437     (byte)241,NO_CHAR, //0966 -- DEVANAGARI DIGIT ZERO
438     (byte)242,NO_CHAR, //0967 -- DEVANAGARI DIGIT ONE
439     (byte)243,NO_CHAR, //0968 -- DEVANAGARI DIGIT TWO
440     (byte)244,NO_CHAR, //0969 -- DEVANAGARI DIGIT THREE
441     (byte)245,NO_CHAR, //096a -- DEVANAGARI DIGIT FOUR
442     (byte)246,NO_CHAR, //096b -- DEVANAGARI DIGIT FIVE
443     (byte)247,NO_CHAR, //096c -- DEVANAGARI DIGIT SIX
444     (byte)248,NO_CHAR, //096d -- DEVANAGARI DIGIT SEVEN
445     (byte)249,NO_CHAR, //096e -- DEVANAGARI DIGIT EIGHT
446     (byte)250,NO_CHAR, //096f -- DEVANAGARI DIGIT NINE
447     (byte)240,(byte)191,  //0970 -- DEVANAGARI ABBREVIATION SIGN
448     NO_CHAR,NO_CHAR, //0971 -- reserved
449     NO_CHAR,NO_CHAR, //0972 -- reserved
450     NO_CHAR,NO_CHAR, //0973 -- reserved
451     NO_CHAR,NO_CHAR, //0974 -- reserved
452     NO_CHAR,NO_CHAR, //0975 -- reserved
453     NO_CHAR,NO_CHAR, //0976 -- reserved
454     NO_CHAR,NO_CHAR, //0977 -- reserved
455     NO_CHAR,NO_CHAR, //0978 -- reserved
456     NO_CHAR,NO_CHAR, //0979 -- reserved
457     NO_CHAR,NO_CHAR, //097a -- reserved
458     NO_CHAR,NO_CHAR, //097b -- reserved
459     NO_CHAR,NO_CHAR, //097c -- reserved
460     NO_CHAR,NO_CHAR, //097d -- reserved
461     NO_CHAR,NO_CHAR, //097e -- reserved
462     NO_CHAR,NO_CHAR  //097f -- reserved
463     }; //end of table definition
464 
465     private static class Decoder extends CharsetDecoder {
466 
467         private static final char ZWNJ_CHAR = &#39;\u200c&#39;;
468         private static final char ZWJ_CHAR = &#39;\u200d&#39;;
469         private static final char INVALID_CHAR = &#39;\uffff&#39;;
470 
471         private char contextChar = INVALID_CHAR;
472         private boolean needFlushing = false;
473 
474 
475         private Decoder(Charset cs) {
476             super(cs, 1.0f, 1.0f);
477         }
478 
479         protected CoderResult implFlush(CharBuffer out) {
480             if(needFlushing) {
481                 if (out.remaining() &lt; 1) {
482                     return CoderResult.OVERFLOW;
483                 } else {
484                     out.put(contextChar);
485                 }
486             }
487             contextChar = INVALID_CHAR;
488             needFlushing = false;
489             return CoderResult.UNDERFLOW;
490         }
491 
492         /* Rules:
493          * 1) ATR,EXT,following character to be replaced with &#39;\ufffd&#39;
494          * 2) Halant + Halant =&gt; &#39;\u094d&#39; (Virama) + &#39;\u200c&#39;(ZWNJ)
495          * 3) Halant + Nukta =&gt; &#39;\u094d&#39; (Virama) + &#39;\u200d&#39;(ZWJ)
496          */
497         private CoderResult decodeArrayLoop(ByteBuffer src,
498                                              CharBuffer dst)
499         {
500             byte[] sa = src.array();
501             int sp = src.arrayOffset() + src.position();
502             int sl = src.arrayOffset() + src.limit();
503             assert (sp &lt;= sl);
504             sp = (sp &lt;= sl ? sp : sl);
505 
506             char[] da = dst.array();
507             int dp = dst.arrayOffset() + dst.position();
508             int dl = dst.arrayOffset() + dst.limit();
509             assert (dp &lt;= dl);
510             dp = (dp &lt;= dl ? dp : dl);
511 
512             try {
513                 while (sp &lt; sl) {
514                     int index = sa[sp];
515                     index = ( index &lt; 0 )? ( index + 255 ):index;
516                     char currentChar = directMapTable[index];
517 
518                     // if the contextChar is either ATR || EXT
519                     // set the output to &#39;\ufffd&#39;
520                     if(contextChar == &#39;\ufffd&#39;) {
521                         if (dl - dp &lt; 1)
522                             return CoderResult.OVERFLOW;
523                         da[dp++] = &#39;\ufffd&#39;;
524                         contextChar = INVALID_CHAR;
525                         needFlushing = false;
526                         sp++;
527                         continue;
528                     }
529 
530                     switch(currentChar) {
531                     case &#39;\u0901&#39;:
532                     case &#39;\u0907&#39;:
533                     case &#39;\u0908&#39;:
534                     case &#39;\u090b&#39;:
535                     case &#39;\u093f&#39;:
536                     case &#39;\u0940&#39;:
537                     case &#39;\u0943&#39;:
538                     case &#39;\u0964&#39;:
539                         if(needFlushing) {
540                             if (dl - dp &lt; 1)
541                                 return CoderResult.OVERFLOW;
542                             da[dp++] = contextChar;
543                             contextChar = currentChar;
544                             sp++;
545                             continue;
546                         }
547                         contextChar = currentChar;
548                         needFlushing = true;
549                         sp++;
550                         continue;
551                     case NUKTA_CHAR:
552                         if (dl - dp &lt; 1)
553                                 return CoderResult.OVERFLOW;
554                         switch(contextChar) {
555                         case &#39;\u0901&#39;:
556                             da[dp++] = &#39;\u0950&#39;;
557                             break;
558                         case &#39;\u0907&#39;:
559                             da[dp++] = &#39;\u090c&#39;;
560                             break;
561                         case &#39;\u0908&#39;:
562                             da[dp++] = &#39;\u0961&#39;;
563                             break;
564                         case &#39;\u090b&#39;:
565                             da[dp++] = &#39;\u0960&#39;;
566                             break;
567                         case &#39;\u093f&#39;:
568                             da[dp++] = &#39;\u0962&#39;;
569                             break;
570                         case &#39;\u0940&#39;:
571                             da[dp++] = &#39;\u0963&#39;;
572                             break;
573                         case &#39;\u0943&#39;:
574                             da[dp++] = &#39;\u0944&#39;;
575                             break;
576                         case &#39;\u0964&#39;:
577                             da[dp++] = &#39;\u093d&#39;;
578                             break;
579                         case HALANT_CHAR:
580                             if(needFlushing) {
581                                 da[dp++] = contextChar;
582                                 contextChar = currentChar;
583                                 sp++;
584                                 continue;
585                             }
586                             da[dp++] = ZWJ_CHAR;
587                             break;
588                         default:
589                             if(needFlushing) {
590                                 da[dp++] = contextChar;
591                                 contextChar = currentChar;
592                                 sp++;
593                                 continue;
594                             }
595                             da[dp++] = NUKTA_CHAR;
596                         }
597                         break;
598                     case HALANT_CHAR:
599                         if (dl - dp &lt; 1)
600                             return CoderResult.OVERFLOW;
601                         if(needFlushing) {
602                             da[dp++] = contextChar;
603                             contextChar = currentChar;
604                             sp++;
605                             continue;
606                         }
607                         if(contextChar == HALANT_CHAR) {
608                             da[dp++] = ZWNJ_CHAR;
609                             break;
610                         }
611                         da[dp++] = HALANT_CHAR;
612                         break;
613                     case INVALID_CHAR:
614                         if(needFlushing) {
615                             if (dl - dp &lt; 1)
616                                 return CoderResult.OVERFLOW;
617                             da[dp++] = contextChar;
618                             contextChar = currentChar;
619                             sp++;
620                             continue;
621                         }
622                         return CoderResult.unmappableForLength(1);
623                     default:
624                         if (dl - dp &lt; 1)
625                             return CoderResult.OVERFLOW;
626                         if(needFlushing) {
627                             da[dp++] = contextChar;
628                             contextChar = currentChar;
629                             sp++;
630                             continue;
631                         }
632                         da[dp++] = currentChar;
633                         break;
634                     }//end switch
635 
636                 contextChar = currentChar;
637                 needFlushing = false;
638                 sp++;
639             }
640             return CoderResult.UNDERFLOW;
641            } finally {
642                 src.position(sp - src.arrayOffset());
643                 dst.position(dp - dst.arrayOffset());
644            }
645         }
646 
647         private CoderResult decodeBufferLoop(ByteBuffer src,
648                                              CharBuffer dst)
649         {
650             int mark = src.position();
651 
652             try {
653                 while (src.hasRemaining()) {
654                     int index = src.get();
655                     index = ( index &lt; 0 )? ( index + 255 ):index;
656                     char currentChar = directMapTable[index];
657 
658                     // if the contextChar is either ATR || EXT
659                     // set the output to &#39;\ufffd&#39;
660                     if(contextChar == &#39;\ufffd&#39;) {
661                         if (dst.remaining() &lt; 1)
662                             return CoderResult.OVERFLOW;
663                         dst.put(&#39;\ufffd&#39;);
664                         contextChar = INVALID_CHAR;
665                         needFlushing = false;
666                         mark++;
667                         continue;
668                     }
669 
670                     switch(currentChar) {
671                     case &#39;\u0901&#39;:
672                     case &#39;\u0907&#39;:
673                     case &#39;\u0908&#39;:
674                     case &#39;\u090b&#39;:
675                     case &#39;\u093f&#39;:
676                     case &#39;\u0940&#39;:
677                     case &#39;\u0943&#39;:
678                     case &#39;\u0964&#39;:
679                         if(needFlushing) {
680                             if (dst.remaining() &lt; 1)
681                                 return CoderResult.OVERFLOW;
682                             dst.put(contextChar);
683                             contextChar = currentChar;
684                             mark++;
685                             continue;
686                         }
687                         contextChar = currentChar;
688                         needFlushing = true;
689                         mark++;
690                         continue;
691                     case NUKTA_CHAR:
692                         if (dst.remaining() &lt; 1)
693                             return CoderResult.OVERFLOW;
694                         switch(contextChar) {
695                         case &#39;\u0901&#39;:
696                             dst.put(&#39;\u0950&#39;);
697                             break;
698                         case &#39;\u0907&#39;:
699                             dst.put(&#39;\u090c&#39;);
700                             break;
701                         case &#39;\u0908&#39;:
702                             dst.put(&#39;\u0961&#39;);
703                             break;
704                         case &#39;\u090b&#39;:
705                             dst.put(&#39;\u0960&#39;);
706                             break;
707                         case &#39;\u093f&#39;:
708                             dst.put(&#39;\u0962&#39;);
709                             break;
710                         case &#39;\u0940&#39;:
711                             dst.put(&#39;\u0963&#39;);
712                             break;
713                         case &#39;\u0943&#39;:
714                             dst.put(&#39;\u0944&#39;);
715                             break;
716                         case &#39;\u0964&#39;:
717                             dst.put(&#39;\u093d&#39;);
718                             break;
719                         case HALANT_CHAR:
720                             if(needFlushing) {
721                                 dst.put(contextChar);
722                                 contextChar = currentChar;
723                                 mark++;
724                                 continue;
725                             }
726                             dst.put(ZWJ_CHAR);
727                             break;
728                         default:
729                             if(needFlushing) {
730                                 dst.put(contextChar);
731                                 contextChar = currentChar;
732                                 mark++;
733                                 continue;
734                             }
735                             dst.put(NUKTA_CHAR);
736                         }
737                         break;
738                     case HALANT_CHAR:
739                         if (dst.remaining() &lt; 1)
740                             return CoderResult.OVERFLOW;
741                         if(needFlushing) {
742                             dst.put(contextChar);
743                             contextChar = currentChar;
744                             mark++;
745                             continue;
746                         }
747                         if(contextChar == HALANT_CHAR) {
748                             dst.put(ZWNJ_CHAR);
749                             break;
750                         }
751                         dst.put(HALANT_CHAR);
752                         break;
753                     case INVALID_CHAR:
754                         if(needFlushing) {
755                             if (dst.remaining() &lt; 1)
756                                 return CoderResult.OVERFLOW;
757                             dst.put(contextChar);
758                             contextChar = currentChar;
759                             mark++;
760                             continue;
761                         }
762                         return CoderResult.unmappableForLength(1);
763                     default:
764                         if (dst.remaining() &lt; 1)
765                             return CoderResult.OVERFLOW;
766                         if(needFlushing) {
767                             dst.put(contextChar);
768                             contextChar = currentChar;
769                             mark++;
770                             continue;
771                         }
772                         dst.put(currentChar);
773                         break;
774                     }//end switch
775                 contextChar = currentChar;
776                 needFlushing = false;
777                 mark++;
778                 }
779             return CoderResult.UNDERFLOW;
780             } finally {
781                 src.position(mark);
782            }
783         }
784 
785         protected CoderResult decodeLoop(ByteBuffer src,
786                                          CharBuffer dst)
787         {
788             if (src.hasArray() &amp;&amp; dst.hasArray())
789                 return decodeArrayLoop(src, dst);
790             else
791                 return decodeBufferLoop(src, dst);
792         }
793     }
794 
795     private static class Encoder extends CharsetEncoder {
796 
797         private static final byte NO_CHAR = (byte)255;
798 
799         //private static CharToByteISCII91 c2b = new CharToByteISCII91();
800         //private static final byte[] directMapTable = c2b.getISCIIEncoderMap();
801 
802         private final Surrogate.Parser sgp = new Surrogate.Parser();
803 
804         private Encoder(Charset cs) {
805             super(cs, 2.0f, 2.0f);
806         }
807 
808         public boolean canEncode(char ch) {
809             //check for Devanagari range,ZWJ,ZWNJ and ASCII range.
810             return ((ch &gt;= &#39;\u0900&#39; &amp;&amp; ch &lt;= &#39;\u097f&#39; &amp;&amp;
811                      encoderMappingTable[2*(ch-&#39;\u0900&#39;)] != NO_CHAR) ||
812                     (ch == &#39;\u200d&#39;) ||
813                     (ch == &#39;\u200c&#39;) ||
814                     (ch &lt;= &#39;\u007f&#39;));
815         }
816 
817 
818         private CoderResult encodeArrayLoop(CharBuffer src,
819                                              ByteBuffer dst)
820         {
821             char[] sa = src.array();
822             int sp = src.arrayOffset() + src.position();
823             int sl = src.arrayOffset() + src.limit();
824             assert (sp &lt;= sl);
825             sp = (sp &lt;= sl ? sp : sl);
826             byte[] da = dst.array();
827             int dp = dst.arrayOffset() + dst.position();
828             int dl = dst.arrayOffset() + dst.limit();
829             assert (dp &lt;= dl);
830             dp = (dp &lt;= dl ? dp : dl);
831 
832             int outputSize = 0;
833 
834             try {
835                 char inputChar;
836                 while (sp &lt; sl) {
837                     int index = Integer.MIN_VALUE;
838                     inputChar = sa[sp];
839 
840                     if (inputChar &gt;= 0x0000 &amp;&amp; inputChar &lt;= 0x007f) {
841                         if (dl - dp &lt; 1)
842                             return CoderResult.OVERFLOW;
843                         da[dp++] = (byte) inputChar;
844                         sp++;
845                         continue;
846                     }
847 
848                     // if inputChar == ZWJ replace it with halant
849                     // if inputChar == ZWNJ replace it with Nukta
850 
851                     if (inputChar == 0x200c) {
852                         inputChar = HALANT_CHAR;
853                     }
854                     else if (inputChar == 0x200d) {
855                         inputChar = NUKTA_CHAR;
856                     }
857 
858                     if (inputChar &gt;= 0x0900 &amp;&amp; inputChar &lt;= 0x097f) {
859                         index = ((int)(inputChar) - 0x0900)*2;
860                     }
861 
862                     if (Character.isSurrogate(inputChar)) {
863                         if (sgp.parse(inputChar, sa, sp, sl) &lt; 0)
864                             return sgp.error();
865                         return sgp.unmappableResult();
866                     }
867 
868                     if (index == Integer.MIN_VALUE ||
869                         encoderMappingTable[index] == NO_CHAR) {
870                         return CoderResult.unmappableForLength(1);
871                     } else {
872                         if(encoderMappingTable[index + 1] == NO_CHAR) {
873                             if(dl - dp &lt; 1)
874                                 return CoderResult.OVERFLOW;
875                             da[dp++] = encoderMappingTable[index];
876                         } else {
877                             if(dl - dp &lt; 2)
878                                 return CoderResult.OVERFLOW;
879                             da[dp++] = encoderMappingTable[index];
880                             da[dp++] = encoderMappingTable[index + 1];
881                         }
882                         sp++;
883                     }
884                 }
885                 return CoderResult.UNDERFLOW;
886             } finally {
887                 src.position(sp - src.arrayOffset());
888                 dst.position(dp - dst.arrayOffset());
889             }
890         }
891 
892         private CoderResult encodeBufferLoop(CharBuffer src,
893                                              ByteBuffer dst)
894         {
895             int mark = src.position();
896 
897             try {
898                 char inputChar;
899                 while (src.hasRemaining()) {
900                     int index = Integer.MIN_VALUE;
901                     inputChar = src.get();
902 
903                     if (inputChar &gt;= 0x0000 &amp;&amp; inputChar &lt;= 0x007f) {
904                         if (dst.remaining() &lt; 1)
905                             return CoderResult.OVERFLOW;
906                         dst.put((byte) inputChar);
907                         mark++;
908                         continue;
909                     }
910 
911                     // if inputChar == ZWJ replace it with halant
912                     // if inputChar == ZWNJ replace it with Nukta
913 
914                     if (inputChar == 0x200c) {
915                         inputChar = HALANT_CHAR;
916                     }
917                     else if (inputChar == 0x200d) {
918                         inputChar = NUKTA_CHAR;
919                     }
920 
921                     if (inputChar &gt;= 0x0900 &amp;&amp; inputChar &lt;= 0x097f) {
922                         index = ((int)(inputChar) - 0x0900)*2;
923                     }
924 
925                     if (Character.isSurrogate(inputChar)) {
926                         if (sgp.parse(inputChar, src) &lt; 0)
927                             return sgp.error();
928                         return sgp.unmappableResult();
929                     }
930 
931                     if (index == Integer.MIN_VALUE ||
932                         encoderMappingTable[index] == NO_CHAR) {
933                         return CoderResult.unmappableForLength(1);
934                     } else {
935                         if(encoderMappingTable[index + 1] == NO_CHAR) {
936                             if(dst.remaining() &lt; 1)
937                                 return CoderResult.OVERFLOW;
938                             dst.put(encoderMappingTable[index]);
939                         } else {
940                             if(dst.remaining() &lt; 2)
941                                 return CoderResult.OVERFLOW;
942                             dst.put(encoderMappingTable[index]);
943                             dst.put(encoderMappingTable[index + 1]);
944                         }
945                     }
946                     mark++;
947                 }
948                 return CoderResult.UNDERFLOW;
949             } finally {
950                 src.position(mark);
951             }
952         }
953 
954         protected CoderResult encodeLoop(CharBuffer src,
955                                          ByteBuffer dst)
956         {
957             if (src.hasArray() &amp;&amp; dst.hasArray())
958                 return encodeArrayLoop(src, dst);
959             else
960                 return encodeBufferLoop(src, dst);
961         }
962     }
963 }
    </pre>
  </body>
</html>
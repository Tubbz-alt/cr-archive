<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.net.http/share/classes/jdk/internal/net/http/RequestPublishers.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HttpClientImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="common/ImmutableExtendedSSLSession.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.net.http/share/classes/jdk/internal/net/http/RequestPublishers.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 
<span class="line-removed"> 28 import java.io.File;</span>
 29 import java.io.FileInputStream;
 30 import java.io.FileNotFoundException;
 31 import java.io.FilePermission;
 32 import java.io.IOException;
 33 import java.io.InputStream;
 34 import java.io.UncheckedIOException;

 35 import java.nio.ByteBuffer;
 36 import java.nio.charset.Charset;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.security.AccessControlContext;
 40 import java.security.AccessController;
<span class="line-modified"> 41 import java.security.PrivilegedAction;</span>
 42 import java.security.PrivilegedActionException;
 43 import java.security.PrivilegedExceptionAction;
 44 import java.util.ArrayList;
 45 import java.util.Collections;
 46 import java.util.Iterator;
 47 import java.util.List;
 48 import java.util.NoSuchElementException;
 49 import java.util.Objects;
 50 import java.util.concurrent.ConcurrentLinkedQueue;
 51 import java.util.concurrent.Flow;
 52 import java.util.concurrent.Flow.Publisher;

 53 import java.util.function.Supplier;
 54 import java.net.http.HttpRequest.BodyPublisher;
 55 import jdk.internal.net.http.common.Utils;
 56 
 57 public final class RequestPublishers {
 58 
 59     private RequestPublishers() { }
 60 
 61     public static class ByteArrayPublisher implements BodyPublisher {
 62         private final int length;
 63         private final byte[] content;
 64         private final int offset;
 65         private final int bufSize;
 66 
 67         public ByteArrayPublisher(byte[] content) {
 68             this(content, 0, content.length);
 69         }
 70 
 71         public ByteArrayPublisher(byte[] content, int offset, int length) {
 72             this(content, offset, length, Utils.BUFSIZE);
</pre>
<hr />
<pre>
203         }
204     }
205 
206     public static class EmptyPublisher implements BodyPublisher {
207         private final Flow.Publisher&lt;ByteBuffer&gt; delegate =
208                 new PullPublisher&lt;ByteBuffer&gt;(Collections.emptyList(), null);
209 
210         @Override
211         public long contentLength() {
212             return 0;
213         }
214 
215         @Override
216         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
217             delegate.subscribe(subscriber);
218         }
219     }
220 
221     /**
222      * Publishes the content of a given file.
<span class="line-modified">223      *</span>
224      * Privileged actions are performed within a limited doPrivileged that only
225      * asserts the specific, read, file permission that was checked during the
<span class="line-modified">226      * construction of this FilePublisher.</span>

227      */
<span class="line-modified">228     public static class FilePublisher implements BodyPublisher  {</span>
229 
<span class="line-modified">230         private static final FilePermission[] EMPTY_FILE_PERMISSIONS = new FilePermission[0];</span>
<span class="line-modified">231 </span>
<span class="line-modified">232         private final File file;</span>
<span class="line-removed">233         private final FilePermission[] filePermissions;</span>
234 
235         private static String pathForSecurityCheck(Path path) {
236             return path.toFile().getPath();
237         }
238 
239         /**
240          * Factory for creating FilePublisher.
241          *
242          * Permission checks are performed here before construction of the
243          * FilePublisher. Permission checking and construction are deliberately
244          * and tightly co-located.
245          */
<span class="line-modified">246         public static FilePublisher create(Path path) throws FileNotFoundException {</span>
<span class="line-modified">247             FilePermission filePermission = null;</span>
248             SecurityManager sm = System.getSecurityManager();
<span class="line-modified">249             if (sm != null) {</span>



250                 String fn = pathForSecurityCheck(path);
<span class="line-modified">251                 FilePermission readPermission = new FilePermission(fn, &quot;read&quot;);</span>
<span class="line-modified">252                 sm.checkPermission(readPermission);</span>
<span class="line-modified">253                 filePermission = readPermission;</span>



















254             }
255 
256             // existence check must be after permission checks
257             if (Files.notExists(path))
258                 throw new FileNotFoundException(path + &quot; not found&quot;);
259 
<span class="line-modified">260             return new FilePublisher(path, filePermission);</span>







































261         }
262 
<span class="line-modified">263         private FilePublisher(Path name, FilePermission filePermission) {</span>
<span class="line-modified">264             assert filePermission != null ? filePermission.getActions().equals(&quot;read&quot;) : true;</span>
<span class="line-modified">265             file = name.toFile();</span>
<span class="line-modified">266             this.filePermissions = filePermission == null ? EMPTY_FILE_PERMISSIONS</span>
<span class="line-modified">267                     : new FilePermission[] { filePermission };</span>











268         }
269 
270         @Override
271         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
272             InputStream is = null;
273             Throwable t = null;
<span class="line-modified">274             if (System.getSecurityManager() == null) {</span>
<span class="line-modified">275                 try {</span>
<span class="line-modified">276                     is = new FileInputStream(file);</span>
<span class="line-modified">277                 } catch (IOException ioe) {</span>
<span class="line-modified">278                     t = ioe;</span>
<span class="line-modified">279                 }</span>
<span class="line-removed">280             } else {</span>
<span class="line-removed">281                 try {</span>
<span class="line-removed">282                     PrivilegedExceptionAction&lt;FileInputStream&gt; pa =</span>
<span class="line-removed">283                             () -&gt; new FileInputStream(file);</span>
<span class="line-removed">284                     is = AccessController.doPrivileged(pa, null, filePermissions);</span>
<span class="line-removed">285                 } catch (PrivilegedActionException pae) {</span>
<span class="line-removed">286                     t = pae.getCause();</span>
<span class="line-removed">287                 }</span>
288             }
289             final InputStream fis = is;
290             PullPublisher&lt;ByteBuffer&gt; publisher;
291             if (t == null) {
292                 publisher = new PullPublisher&lt;&gt;(() -&gt; new StreamIterator(fis));
293             } else {
294                 publisher = new PullPublisher&lt;&gt;(null, t);
295             }
296             publisher.subscribe(subscriber);
297         }
298 
299         @Override
300         public long contentLength() {
<span class="line-modified">301             if (System.getSecurityManager() == null) {</span>
<span class="line-removed">302                 return file.length();</span>
<span class="line-removed">303             } else {</span>
<span class="line-removed">304                 PrivilegedAction&lt;Long&gt; pa = () -&gt; file.length();</span>
<span class="line-removed">305                 return AccessController.doPrivileged(pa, null, filePermissions);</span>
<span class="line-removed">306             }</span>
307         }
308     }
309 
310     /**
311      * Reads one buffer ahead all the time, blocking in hasNext()
312      */
313     public static class StreamIterator implements Iterator&lt;ByteBuffer&gt; {
314         final InputStream is;
315         final Supplier&lt;? extends ByteBuffer&gt; bufSupplier;

316         volatile ByteBuffer nextBuffer;
317         volatile boolean need2Read = true;
318         volatile boolean haveNext;
319 
320         StreamIterator(InputStream is) {
321             this(is, Utils::getBuffer);
322         }
323 
324         StreamIterator(InputStream is, Supplier&lt;? extends ByteBuffer&gt; bufSupplier) {
325             this.is = is;
326             this.bufSupplier = bufSupplier;
327         }
328 
329 //        Throwable error() {
330 //            return error;
331 //        }
332 
333         private int read() {


334             nextBuffer = bufSupplier.get();
335             nextBuffer.clear();
336             byte[] buf = nextBuffer.array();
337             int offset = nextBuffer.arrayOffset();
338             int cap = nextBuffer.capacity();
339             try {
340                 int n = is.read(buf, offset, cap);
341                 if (n == -1) {

342                     is.close();
343                     return -1;
344                 }
345                 //flip
346                 nextBuffer.limit(n);
347                 nextBuffer.position(0);
348                 return n;
349             } catch (IOException ex) {
350                 return -1;
351             }
352         }
353 
354         @Override
355         public synchronized boolean hasNext() {
356             if (need2Read) {
357                 haveNext = read() != -1;
358                 if (haveNext) {
359                     need2Read = false;
360                 }
361                 return haveNext;
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2016, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.internal.net.http;
 27 

 28 import java.io.FileInputStream;
 29 import java.io.FileNotFoundException;
 30 import java.io.FilePermission;
 31 import java.io.IOException;
 32 import java.io.InputStream;
 33 import java.io.UncheckedIOException;
<span class="line-added"> 34 import java.lang.reflect.UndeclaredThrowableException;</span>
 35 import java.nio.ByteBuffer;
 36 import java.nio.charset.Charset;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.security.AccessControlContext;
 40 import java.security.AccessController;
<span class="line-modified"> 41 import java.security.Permission;</span>
 42 import java.security.PrivilegedActionException;
 43 import java.security.PrivilegedExceptionAction;
 44 import java.util.ArrayList;
 45 import java.util.Collections;
 46 import java.util.Iterator;
 47 import java.util.List;
 48 import java.util.NoSuchElementException;
 49 import java.util.Objects;
 50 import java.util.concurrent.ConcurrentLinkedQueue;
 51 import java.util.concurrent.Flow;
 52 import java.util.concurrent.Flow.Publisher;
<span class="line-added"> 53 import java.util.function.Function;</span>
 54 import java.util.function.Supplier;
 55 import java.net.http.HttpRequest.BodyPublisher;
 56 import jdk.internal.net.http.common.Utils;
 57 
 58 public final class RequestPublishers {
 59 
 60     private RequestPublishers() { }
 61 
 62     public static class ByteArrayPublisher implements BodyPublisher {
 63         private final int length;
 64         private final byte[] content;
 65         private final int offset;
 66         private final int bufSize;
 67 
 68         public ByteArrayPublisher(byte[] content) {
 69             this(content, 0, content.length);
 70         }
 71 
 72         public ByteArrayPublisher(byte[] content, int offset, int length) {
 73             this(content, offset, length, Utils.BUFSIZE);
</pre>
<hr />
<pre>
204         }
205     }
206 
207     public static class EmptyPublisher implements BodyPublisher {
208         private final Flow.Publisher&lt;ByteBuffer&gt; delegate =
209                 new PullPublisher&lt;ByteBuffer&gt;(Collections.emptyList(), null);
210 
211         @Override
212         public long contentLength() {
213             return 0;
214         }
215 
216         @Override
217         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
218             delegate.subscribe(subscriber);
219         }
220     }
221 
222     /**
223      * Publishes the content of a given file.
<span class="line-modified">224      * &lt;p&gt;</span>
225      * Privileged actions are performed within a limited doPrivileged that only
226      * asserts the specific, read, file permission that was checked during the
<span class="line-modified">227      * construction of this FilePublisher. This only applies if the file system</span>
<span class="line-added">228      * that created the file provides interoperability with {@code java.io.File}.</span>
229      */
<span class="line-modified">230     public static class FilePublisher implements BodyPublisher {</span>
231 
<span class="line-modified">232         private final Path path;</span>
<span class="line-modified">233         private final long length;</span>
<span class="line-modified">234         private final Function&lt;Path, InputStream&gt; inputStreamSupplier;</span>

235 
236         private static String pathForSecurityCheck(Path path) {
237             return path.toFile().getPath();
238         }
239 
240         /**
241          * Factory for creating FilePublisher.
242          *
243          * Permission checks are performed here before construction of the
244          * FilePublisher. Permission checking and construction are deliberately
245          * and tightly co-located.
246          */
<span class="line-modified">247         public static FilePublisher create(Path path)</span>
<span class="line-modified">248                 throws FileNotFoundException {</span>
249             SecurityManager sm = System.getSecurityManager();
<span class="line-modified">250             FilePermission filePermission = null;</span>
<span class="line-added">251             boolean defaultFS = true;</span>
<span class="line-added">252 </span>
<span class="line-added">253             try {</span>
254                 String fn = pathForSecurityCheck(path);
<span class="line-modified">255                 if (sm != null) {</span>
<span class="line-modified">256                     FilePermission readPermission = new FilePermission(fn, &quot;read&quot;);</span>
<span class="line-modified">257                     sm.checkPermission(readPermission);</span>
<span class="line-added">258                     filePermission = readPermission;</span>
<span class="line-added">259                 }</span>
<span class="line-added">260             } catch (UnsupportedOperationException uoe) {</span>
<span class="line-added">261                 defaultFS = false;</span>
<span class="line-added">262                 // Path not associated with the default file system</span>
<span class="line-added">263                 // Test early if an input stream can still be obtained</span>
<span class="line-added">264                 try {</span>
<span class="line-added">265                     if (sm != null) {</span>
<span class="line-added">266                         Files.newInputStream(path).close();</span>
<span class="line-added">267                     }</span>
<span class="line-added">268                 } catch (IOException ioe) {</span>
<span class="line-added">269                     if (ioe instanceof FileNotFoundException) {</span>
<span class="line-added">270                         throw (FileNotFoundException) ioe;</span>
<span class="line-added">271                     } else {</span>
<span class="line-added">272                         var ex = new FileNotFoundException(ioe.getMessage());</span>
<span class="line-added">273                         ex.initCause(ioe);</span>
<span class="line-added">274                         throw ex;</span>
<span class="line-added">275                     }</span>
<span class="line-added">276                 }</span>
277             }
278 
279             // existence check must be after permission checks
280             if (Files.notExists(path))
281                 throw new FileNotFoundException(path + &quot; not found&quot;);
282 
<span class="line-modified">283             Permission perm = filePermission;</span>
<span class="line-added">284             assert perm == null || perm.getActions().equals(&quot;read&quot;);</span>
<span class="line-added">285             AccessControlContext acc = sm != null ?</span>
<span class="line-added">286                     AccessController.getContext() : null;</span>
<span class="line-added">287             boolean finalDefaultFS = defaultFS;</span>
<span class="line-added">288             Function&lt;Path, InputStream&gt; inputStreamSupplier = (p) -&gt;</span>
<span class="line-added">289                     createInputStream(p, acc, perm, finalDefaultFS);</span>
<span class="line-added">290 </span>
<span class="line-added">291             long length;</span>
<span class="line-added">292             try {</span>
<span class="line-added">293                 length = Files.size(path);</span>
<span class="line-added">294             } catch (IOException ioe) {</span>
<span class="line-added">295                 length = -1;</span>
<span class="line-added">296             }</span>
<span class="line-added">297 </span>
<span class="line-added">298             return new FilePublisher(path, length, inputStreamSupplier);</span>
<span class="line-added">299         }</span>
<span class="line-added">300 </span>
<span class="line-added">301         private static InputStream createInputStream(Path path,</span>
<span class="line-added">302                                                      AccessControlContext acc,</span>
<span class="line-added">303                                                      Permission perm,</span>
<span class="line-added">304                                                      boolean defaultFS) {</span>
<span class="line-added">305             try {</span>
<span class="line-added">306                 if (acc != null) {</span>
<span class="line-added">307                     PrivilegedExceptionAction&lt;InputStream&gt; pa = defaultFS</span>
<span class="line-added">308                             ? () -&gt; new FileInputStream(path.toFile())</span>
<span class="line-added">309                             : () -&gt; Files.newInputStream(path);</span>
<span class="line-added">310                     return perm != null</span>
<span class="line-added">311                             ? AccessController.doPrivileged(pa, acc, perm)</span>
<span class="line-added">312                             : AccessController.doPrivileged(pa, acc);</span>
<span class="line-added">313                 } else {</span>
<span class="line-added">314                     return defaultFS</span>
<span class="line-added">315                             ? new FileInputStream(path.toFile())</span>
<span class="line-added">316                             : Files.newInputStream(path);</span>
<span class="line-added">317                 }</span>
<span class="line-added">318             } catch (PrivilegedActionException pae) {</span>
<span class="line-added">319                 throw toUncheckedException(pae.getCause());</span>
<span class="line-added">320             } catch (IOException io) {</span>
<span class="line-added">321                 throw new UncheckedIOException(io);</span>
<span class="line-added">322             }</span>
323         }
324 
<span class="line-modified">325         private static RuntimeException toUncheckedException(Throwable t) {</span>
<span class="line-modified">326             if (t instanceof RuntimeException)</span>
<span class="line-modified">327                 throw (RuntimeException) t;</span>
<span class="line-modified">328             if (t instanceof Error)</span>
<span class="line-modified">329                 throw (Error) t;</span>
<span class="line-added">330             if (t instanceof IOException)</span>
<span class="line-added">331                 throw new UncheckedIOException((IOException) t);</span>
<span class="line-added">332             throw new UndeclaredThrowableException(t);</span>
<span class="line-added">333         }</span>
<span class="line-added">334 </span>
<span class="line-added">335         private FilePublisher(Path name,</span>
<span class="line-added">336                               long length,</span>
<span class="line-added">337                               Function&lt;Path, InputStream&gt; inputStreamSupplier) {</span>
<span class="line-added">338             path = name;</span>
<span class="line-added">339             this.length = length;</span>
<span class="line-added">340             this.inputStreamSupplier = inputStreamSupplier;</span>
341         }
342 
343         @Override
344         public void subscribe(Flow.Subscriber&lt;? super ByteBuffer&gt; subscriber) {
345             InputStream is = null;
346             Throwable t = null;
<span class="line-modified">347             try {</span>
<span class="line-modified">348                 is = inputStreamSupplier.apply(path);</span>
<span class="line-modified">349             } catch (UncheckedIOException | UndeclaredThrowableException ue) {</span>
<span class="line-modified">350                 t = ue.getCause();</span>
<span class="line-modified">351             } catch (Throwable th) {</span>
<span class="line-modified">352                 t = th;</span>








353             }
354             final InputStream fis = is;
355             PullPublisher&lt;ByteBuffer&gt; publisher;
356             if (t == null) {
357                 publisher = new PullPublisher&lt;&gt;(() -&gt; new StreamIterator(fis));
358             } else {
359                 publisher = new PullPublisher&lt;&gt;(null, t);
360             }
361             publisher.subscribe(subscriber);
362         }
363 
364         @Override
365         public long contentLength() {
<span class="line-modified">366             return length;</span>





367         }
368     }
369 
370     /**
371      * Reads one buffer ahead all the time, blocking in hasNext()
372      */
373     public static class StreamIterator implements Iterator&lt;ByteBuffer&gt; {
374         final InputStream is;
375         final Supplier&lt;? extends ByteBuffer&gt; bufSupplier;
<span class="line-added">376         private volatile boolean eof;</span>
377         volatile ByteBuffer nextBuffer;
378         volatile boolean need2Read = true;
379         volatile boolean haveNext;
380 
381         StreamIterator(InputStream is) {
382             this(is, Utils::getBuffer);
383         }
384 
385         StreamIterator(InputStream is, Supplier&lt;? extends ByteBuffer&gt; bufSupplier) {
386             this.is = is;
387             this.bufSupplier = bufSupplier;
388         }
389 
390 //        Throwable error() {
391 //            return error;
392 //        }
393 
394         private int read() {
<span class="line-added">395             if (eof)</span>
<span class="line-added">396                 return -1;</span>
397             nextBuffer = bufSupplier.get();
398             nextBuffer.clear();
399             byte[] buf = nextBuffer.array();
400             int offset = nextBuffer.arrayOffset();
401             int cap = nextBuffer.capacity();
402             try {
403                 int n = is.read(buf, offset, cap);
404                 if (n == -1) {
<span class="line-added">405                     eof = true;</span>
406                     is.close();
407                     return -1;
408                 }
409                 //flip
410                 nextBuffer.limit(n);
411                 nextBuffer.position(0);
412                 return n;
413             } catch (IOException ex) {
414                 return -1;
415             }
416         }
417 
418         @Override
419         public synchronized boolean hasNext() {
420             if (need2Read) {
421                 haveNext = read() != -1;
422                 if (haveNext) {
423                     need2Read = false;
424                 }
425                 return haveNext;
</pre>
</td>
</tr>
</table>
<center><a href="HttpClientImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../index.html" target="_top">index</a> <a href="common/ImmutableExtendedSSLSession.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
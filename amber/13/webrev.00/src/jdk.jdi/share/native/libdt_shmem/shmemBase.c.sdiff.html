<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.jdi/share/native/libdt_shmem/shmemBase.c</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="../../classes/com/sun/tools/jdi/VirtualMachineImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.jdwp.agent/share/native/libjdwp/ArrayReferenceImpl.c.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.jdi/share/native/libdt_shmem/shmemBase.c</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  44  * it requires). It supports multiple connections for the benefit of the
  45  * front-end client; the back end interface assumes only a single connection.
  46  */
  47 
  48 #define MAX_IPC_PREFIX 50   /* user-specified or generated name for */
  49                             /* shared memory seg and prefix for other IPC */
  50 #define MAX_IPC_SUFFIX 25   /* suffix to shmem name for other IPC names */
  51 #define MAX_IPC_NAME   (MAX_IPC_PREFIX + MAX_IPC_SUFFIX)
  52 
  53 #define MAX_GENERATION_RETRIES 20
  54 #define SHARED_BUFFER_SIZE 5000
  55 
  56 #define CHECK_ERROR(expr) do { \
  57                               jint error = (expr); \
  58                               if (error != SYS_OK) { \
  59                                   setLastError(error); \
  60                                   return error; \
  61                               } \
  62                           } while (0)
  63 















  64 /*
  65  * The following assertions should hold anytime the stream&#39;s mutex is not held
  66  */
  67 #define STREAM_INVARIANT(stream) \
  68         do { \
  69             SHMEM_ASSERT((stream-&gt;shared-&gt;readOffset &lt; SHARED_BUFFER_SIZE) \
  70                          &amp;&amp; (stream-&gt;shared-&gt;readOffset &gt;= 0)); \
  71             SHMEM_ASSERT((stream-&gt;shared-&gt;writeOffset &lt; SHARED_BUFFER_SIZE) \
  72                          &amp;&amp; (stream-&gt;shared-&gt;writeOffset &gt;= 0)); \
  73         } while (0)
  74 
  75 /*
  76  * Transports are duplex, so carve the shared memory into &quot;streams&quot;,
  77  * one used to send from client to server, the other vice versa.
  78  */
  79 typedef struct SharedMemoryListener {
  80     char mutexName[MAX_IPC_NAME];
  81     char acceptEventName[MAX_IPC_NAME];
  82     char attachEventName[MAX_IPC_NAME];
  83     jboolean isListening;
</pre>
<hr />
<pre>
 137 #define STATE_CLOSED 0xDEAD
 138 #define STATE_OPEN   (STATE_CLOSED -1)
 139 /*
 140  * State checking macro. We compare against the STATE_OPEN value so
 141  * that STATE_CLOSED and any other value will be considered closed.
 142  * This catches a freed Stream as long as the memory page is still
 143  * valid. If the memory page is gone, then there is little that we
 144  * can do.
 145  */
 146 #define IS_STATE_CLOSED(state) (state != STATE_OPEN)
 147 
 148 
 149 typedef struct SharedMemoryConnection {
 150     char name[MAX_IPC_NAME];
 151     SharedMemory *shared;
 152     sys_shmem_t sharedMemory;
 153     Stream incoming;
 154     Stream outgoing;
 155     sys_process_t otherProcess;
 156     sys_event_t shutdown;           /* signalled to indicate shutdown */


 157 } SharedMemoryConnection;
 158 
 159 static jdwpTransportCallback *callback;
 160 static JavaVM *jvm;
 161 static int tlsIndex;
 162 
 163 typedef jint (*CreateFunc)(char *name, void *arg);
 164 
 165 /*
 166  * Set the per-thread error message (if not already set)
 167  */
 168 static void
 169 setLastErrorMsg(char *newmsg) {
 170     char *msg;
 171 
 172     msg = (char *)sysTlsGet(tlsIndex);
 173     if (msg == NULL) {
 174         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 175         if (msg != NULL) {
 176            strcpy(msg, newmsg);
</pre>
<hr />
<pre>
 344     while ((error == SYS_OK) &amp;&amp; EMPTY(stream)) {
 345         CHECK_ERROR(leaveMutex(stream));
 346         error = sysEventWait(connection-&gt;otherProcess, stream-&gt;hasData, 0);
 347         if (error == SYS_OK) {
 348             CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
 349         } else {
 350             setLastError(error);
 351         }
 352     }
 353     return error;
 354 }
 355 
 356 static jint
 357 signalData(Stream *stream)
 358 {
 359     return sysEventSignal(stream-&gt;hasData);
 360 }
 361 
 362 
 363 static jint
<span class="line-modified"> 364 closeStream(Stream *stream, jboolean linger)</span>
 365 {
 366     /*
 367      * Lock stream during close - ignore shutdown event as we are
 368      * closing down and shutdown should be signalled.
 369      */
 370     CHECK_ERROR(enterMutex(stream, NULL));
 371 
 372     /* mark the stream as closed */
 373     stream-&gt;state = STATE_CLOSED;
 374     /* wake up waitForData() if it is in sysEventWait() */
 375     sysEventSignal(stream-&gt;hasData);
<span class="line-removed"> 376     sysEventClose(stream-&gt;hasData);</span>
 377     /* wake up waitForSpace() if it is in sysEventWait() */
 378     sysEventSignal(stream-&gt;hasSpace);
<span class="line-removed"> 379     sysEventClose(stream-&gt;hasSpace);</span>
 380 
 381     /*
 382      * If linger requested then give the stream a few seconds to
 383      * drain before closing it.
 384      */
 385     if (linger) {
 386         int attempts = 10;
 387         while (!EMPTY(stream) &amp;&amp; attempts&gt;0) {
 388             CHECK_ERROR(leaveMutex(stream));
 389             sysSleep(200);
 390             CHECK_ERROR(enterMutex(stream, NULL));
 391             attempts--;
 392         }
 393     }
 394 
 395     CHECK_ERROR(leaveMutex(stream));
<span class="line-modified"> 396     sysIPMutexClose(stream-&gt;mutex);</span>
<span class="line-modified"> 397     return SYS_OK;</span>












 398 }
 399 
 400 /*
 401  * Server creates stream.
 402  */
 403 static int
 404 createStream(char *name, Stream *stream)
 405 {
 406     jint error;
 407     char objectName[MAX_IPC_NAME];
 408 
 409     sprintf(objectName, &quot;%s.mutex&quot;, name);
 410     error = createWithGeneratedName(objectName, stream-&gt;shared-&gt;mutexName,
 411                                     createMutex, &amp;stream-&gt;mutex);
 412     if (error != SYS_OK) {
 413         return error;
 414     }
 415 
 416     sprintf(objectName, &quot;%s.hasData&quot;, name);
 417     error = createWithGeneratedName(objectName, stream-&gt;shared-&gt;hasDataEventName,
 418                                     createEvent, &amp;stream-&gt;hasData);
 419     if (error != SYS_OK) {
<span class="line-modified"> 420         (void)closeStream(stream, JNI_FALSE);</span>
 421         return error;
 422     }
 423 
 424     sprintf(objectName, &quot;%s.hasSpace&quot;, name);
 425     error = createWithGeneratedName(objectName, stream-&gt;shared-&gt;hasSpaceEventName,
 426                                     createEvent, &amp;stream-&gt;hasSpace);
 427     if (error != SYS_OK) {
<span class="line-modified"> 428         (void)closeStream(stream, JNI_FALSE);</span>

 429         return error;
 430     }
 431 
 432     stream-&gt;shared-&gt;readOffset = 0;
 433     stream-&gt;shared-&gt;writeOffset = 0;
 434     stream-&gt;shared-&gt;isFull = JNI_FALSE;
 435     stream-&gt;state = STATE_OPEN;
 436     return SYS_OK;
 437 }
 438 
 439 
 440 /*
 441  * Initialization for the stream opened by the other process
 442  */
 443 static int
 444 openStream(Stream *stream)
 445 {
 446     jint error;
 447 
 448     CHECK_ERROR(sysIPMutexOpen(stream-&gt;shared-&gt;mutexName, &amp;stream-&gt;mutex));
 449 
 450     error = sysEventOpen(stream-&gt;shared-&gt;hasDataEventName,
 451                              &amp;stream-&gt;hasData);
 452     if (error != SYS_OK) {
 453         setLastError(error);
<span class="line-modified"> 454         (void)closeStream(stream, JNI_FALSE);</span>
 455         return error;
 456     }
 457 
 458     error = sysEventOpen(stream-&gt;shared-&gt;hasSpaceEventName,
 459                              &amp;stream-&gt;hasSpace);
 460     if (error != SYS_OK) {
 461         setLastError(error);
<span class="line-modified"> 462         (void)closeStream(stream, JNI_FALSE);</span>

 463         return error;
 464     }
 465 
 466     stream-&gt;state = STATE_OPEN;
 467 
 468     return SYS_OK;
 469 }
 470 
 471 /********************************************************************/
 472 
 473 static SharedMemoryConnection *
 474 allocConnection(void)
 475 {
 476     /*
 477      * TO DO: Track all allocated connections for clean shutdown?
 478      */
 479     SharedMemoryConnection *conn = (*callback-&gt;alloc)(sizeof(SharedMemoryConnection));
 480     if (conn != NULL) {
 481         memset(conn, 0, sizeof(SharedMemoryConnection));
 482     }

 483     return conn;
 484 }
 485 
 486 static void
 487 freeConnection(SharedMemoryConnection *connection)
 488 {
 489     (*callback-&gt;free)(connection);
 490 }
 491 
 492 static void
 493 closeConnection(SharedMemoryConnection *connection)
 494 {



 495     /*
 496      * Signal all threads accessing this connection that we are
 497      * shutting down.
 498      */
 499     if (connection-&gt;shutdown) {
 500         sysEventSignal(connection-&gt;shutdown);
 501     }
 502 
<span class="line-modified"> 503 </span>
<span class="line-modified"> 504     (void)closeStream(&amp;connection-&gt;outgoing, JNI_TRUE);</span>
<span class="line-modified"> 505     (void)closeStream(&amp;connection-&gt;incoming, JNI_FALSE);</span>
<span class="line-removed"> 506 </span>
<span class="line-removed"> 507     if (connection-&gt;sharedMemory) {</span>
<span class="line-removed"> 508         sysSharedMemClose(connection-&gt;sharedMemory, connection-&gt;shared);</span>
 509     }
<span class="line-modified"> 510     if (connection-&gt;otherProcess) {</span>
<span class="line-modified"> 511         sysProcessClose(connection-&gt;otherProcess);</span>

 512     }
 513 
<span class="line-modified"> 514     /*</span>
<span class="line-modified"> 515      * Ideally we should close the connection-&gt;shutdown event and</span>
<span class="line-modified"> 516      * free the connection structure. However as closing the</span>
<span class="line-modified"> 517      * connection is asynchronous it means that other threads may</span>
<span class="line-modified"> 518      * still be accessing the connection structure. On Win32 this</span>
<span class="line-modified"> 519      * means we leak 132 bytes and one event per connection. This</span>
<span class="line-modified"> 520      * memory will be reclaim at process exit.</span>
<span class="line-modified"> 521      *</span>
<span class="line-modified"> 522      * if (connection-&gt;shutdown)</span>
<span class="line-modified"> 523      *     sysEventClose(connection-&gt;shutdown);</span>
<span class="line-modified"> 524      * freeConnection(connection);</span>
<span class="line-removed"> 525      */</span>
 526 }
 527 
 528 
 529 /*
 530  * For client: connect to the shared memory.  Open incoming and
 531  * outgoing streams.
 532  */
 533 static jint
 534 openConnection(SharedMemoryTransport *transport, jlong otherPID,
 535                SharedMemoryConnection **connectionPtr)
 536 {
 537     jint error;
 538 
 539     SharedMemoryConnection *connection = allocConnection();
 540     if (connection == NULL) {
 541         return SYS_NOMEM;
 542     }
 543 
 544     sprintf(connection-&gt;name, &quot;%s.%&quot; PRId64, transport-&gt;name, sysProcessGetID());
 545     error = sysSharedMemOpen(connection-&gt;name, &amp;connection-&gt;sharedMemory,
 546                              &amp;connection-&gt;shared);
 547     if (error != SYS_OK) {
<span class="line-modified"> 548         closeConnection(connection);</span>
 549         return error;
 550     }
 551 
 552     /* This process is the client */
 553     connection-&gt;incoming.shared = &amp;connection-&gt;shared-&gt;toClient;
 554     connection-&gt;outgoing.shared = &amp;connection-&gt;shared-&gt;toServer;
 555 
 556     error = openStream(&amp;connection-&gt;incoming);
 557     if (error != SYS_OK) {
 558         closeConnection(connection);

 559         return error;
 560     }
 561 
 562     error = openStream(&amp;connection-&gt;outgoing);
 563     if (error != SYS_OK) {
 564         closeConnection(connection);

 565         return error;
 566     }
 567 
 568     error = sysProcessOpen(otherPID, &amp;connection-&gt;otherProcess);
 569     if (error != SYS_OK) {
 570         setLastError(error);
 571         closeConnection(connection);

 572         return error;
 573     }
 574 
 575     /*
 576      * Create an event that signals that the connection is shutting
 577      * down. The event is unnamed as it&#39;s process local, and is
 578      * manually reset (so that signalling the event will signal
 579      * all threads waiting on it).
 580      */
 581     error = sysEventCreate(NULL, &amp;connection-&gt;shutdown, JNI_TRUE);
 582     if (error != SYS_OK) {
 583         setLastError(error);
 584         closeConnection(connection);

 585         return error;
 586     }
 587 
 588     *connectionPtr = connection;
 589     return SYS_OK;
 590 }
 591 
 592 /*
 593  * For server: create the shared memory.  Create incoming and
 594  * outgoing streams.
 595  */
 596 static jint
 597 createConnection(SharedMemoryTransport *transport, jlong otherPID,
 598                  SharedMemoryConnection **connectionPtr)
 599 {
 600     jint error;
 601     char streamName[MAX_IPC_NAME];
 602 
 603     SharedMemoryConnection *connection = allocConnection();
 604     if (connection == NULL) {
 605         return SYS_NOMEM;
 606     }
 607 
 608     sprintf(connection-&gt;name, &quot;%s.%&quot; PRId64, transport-&gt;name, otherPID);
 609     error = sysSharedMemCreate(connection-&gt;name, sizeof(SharedMemory),
 610                                &amp;connection-&gt;sharedMemory, &amp;connection-&gt;shared);
 611     if (error != SYS_OK) {
<span class="line-modified"> 612         closeConnection(connection);</span>
 613         return error;
 614     }
 615 
 616     memset(connection-&gt;shared, 0, sizeof(SharedMemory));
 617 
 618     /* This process is the server */
 619     connection-&gt;incoming.shared = &amp;connection-&gt;shared-&gt;toServer;
 620     connection-&gt;outgoing.shared = &amp;connection-&gt;shared-&gt;toClient;
 621 
 622     strcpy(streamName, connection-&gt;name);
 623     strcat(streamName, &quot;.ctos&quot;);
 624     error = createStream(streamName, &amp;connection-&gt;incoming);
 625     if (error != SYS_OK) {
 626         closeConnection(connection);

 627         return error;
 628     }
 629 
 630     strcpy(streamName, connection-&gt;name);
 631     strcat(streamName, &quot;.stoc&quot;);
 632     error = createStream(streamName, &amp;connection-&gt;outgoing);
 633     if (error != SYS_OK) {
 634         closeConnection(connection);

 635         return error;
 636     }
 637 
 638     error = sysProcessOpen(otherPID, &amp;connection-&gt;otherProcess);
 639     if (error != SYS_OK) {
 640         setLastError(error);
 641         closeConnection(connection);

 642         return error;
 643     }
 644 
 645     /*
 646      * Create an event that signals that the connection is shutting
 647      * down. The event is unnamed as it&#39;s process local, and is
 648      * manually reset (so that a signalling the event will signal
 649      * all threads waiting on it).
 650      */
 651     error = sysEventCreate(NULL, &amp;connection-&gt;shutdown, JNI_TRUE);
 652     if (error != SYS_OK) {
 653         setLastError(error);
 654         closeConnection(connection);

 655         return error;
 656     }
 657 
 658     *connectionPtr = connection;
 659     return SYS_OK;
 660 }
 661 
 662 /********************************************************************/
 663 
 664 static SharedMemoryTransport *
 665 allocTransport(void)
 666 {
 667     /*
 668      * TO DO: Track all allocated transports for clean shutdown?
 669      */
 670     return (*callback-&gt;alloc)(sizeof(SharedMemoryTransport));
 671 }
 672 
 673 static void
 674 freeTransport(SharedMemoryTransport *transport)
</pre>
<hr />
<pre>
 830 shmemBase_accept(SharedMemoryTransport *transport,
 831                  long timeout,
 832                  SharedMemoryConnection **connectionPtr)
 833 {
 834     jint error;
 835     SharedMemoryConnection *connection;
 836 
 837     clearLastError();
 838 
 839     CHECK_ERROR(sysEventWait(NULL, transport-&gt;attachEvent, timeout));
 840 
 841     error = createConnection(transport, transport-&gt;shared-&gt;attachingPID,
 842                              &amp;connection);
 843     if (error != SYS_OK) {
 844         /*
 845          * Reject the attacher
 846          */
 847         transport-&gt;shared-&gt;isAccepted = JNI_FALSE;
 848         sysEventSignal(transport-&gt;acceptEvent);
 849 
<span class="line-removed"> 850         freeConnection(connection);</span>
 851         return error;
 852     }
 853 
 854     transport-&gt;shared-&gt;isAccepted = JNI_TRUE;
 855     error = sysEventSignal(transport-&gt;acceptEvent);
 856     if (error != SYS_OK) {
 857         /*
 858          * No real point trying to reject it.
 859          */
 860         closeConnection(connection);

 861         return error;
 862     }
 863 
 864     *connectionPtr = connection;
 865     return SYS_OK;
 866 }
 867 
 868 static jint
 869 doAttach(SharedMemoryTransport *transport, long timeout)
 870 {
 871     transport-&gt;shared-&gt;attachingPID = sysProcessGetID();
 872     CHECK_ERROR(sysEventSignal(transport-&gt;attachEvent));
 873     CHECK_ERROR(sysEventWait(NULL, transport-&gt;acceptEvent, timeout));
 874     return SYS_OK;
 875 }
 876 
 877 jint
 878 shmemBase_attach(const char *addressString, long timeout, SharedMemoryConnection **connectionPtr)
 879 {
 880     int error;
</pre>
<hr />
<pre>
 910     if (error != SYS_OK) {
 911         closeTransport(transport);
 912         return error;
 913     }
 914 
 915     error = openConnection(transport, acceptingPID, connectionPtr);
 916 
 917     closeTransport(transport);
 918 
 919     return error;
 920 }
 921 
 922 
 923 
 924 
 925 void
 926 shmemBase_closeConnection(SharedMemoryConnection *connection)
 927 {
 928     clearLastError();
 929     closeConnection(connection);




















 930 }
 931 
 932 void
 933 shmemBase_closeTransport(SharedMemoryTransport *transport)
 934 {
 935     clearLastError();
 936     closeTransport(transport);
 937 }
 938 
<span class="line-modified"> 939 jint</span>
<span class="line-modified"> 940 shmemBase_sendByte(SharedMemoryConnection *connection, jbyte data)</span>
 941 {
 942     Stream *stream = &amp;connection-&gt;outgoing;
 943     SharedStream *shared = stream-&gt;shared;
 944     int offset;
 945 
 946     clearLastError();
 947 
 948     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
 949     CHECK_ERROR(waitForSpace(connection, stream));
 950     SHMEM_ASSERT(!FULL(stream));
 951     offset = shared-&gt;writeOffset;
 952     shared-&gt;buffer[offset] = data;
 953     shared-&gt;writeOffset = ADD_OFFSET(offset, 1);
 954     shared-&gt;isFull = (shared-&gt;readOffset == shared-&gt;writeOffset);
 955 
 956     STREAM_INVARIANT(stream);
 957     CHECK_ERROR(leaveMutex(stream));
 958 
 959     CHECK_ERROR(signalData(stream));
 960 
 961     return SYS_OK;
 962 }
 963 
 964 jint
<span class="line-modified"> 965 shmemBase_receiveByte(SharedMemoryConnection *connection, jbyte *data)</span>









 966 {
 967     Stream *stream = &amp;connection-&gt;incoming;
 968     SharedStream *shared = stream-&gt;shared;
 969     int offset;
 970 
 971     clearLastError();
 972 
 973     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
 974     CHECK_ERROR(waitForData(connection, stream));
 975     SHMEM_ASSERT(!EMPTY(stream));
 976     offset = shared-&gt;readOffset;
 977     *data = shared-&gt;buffer[offset];
 978     shared-&gt;readOffset = ADD_OFFSET(offset, 1);
 979     shared-&gt;isFull = JNI_FALSE;
 980 
 981     STREAM_INVARIANT(stream);
 982     CHECK_ERROR(leaveMutex(stream));
 983 
 984     CHECK_ERROR(signalSpace(stream));
 985 
 986     return SYS_OK;
 987 }
 988 









 989 static jint
 990 sendBytes(SharedMemoryConnection *connection, const void *bytes, jint length)
 991 {
 992     Stream *stream = &amp;connection-&gt;outgoing;
 993     SharedStream *shared = stream-&gt;shared;
 994     jint fragmentStart;
 995     jint fragmentLength;
 996     jint index = 0;
 997     jint maxLength;
 998 
 999     clearLastError();
1000 
1001     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
1002     while (index &lt; length) {
1003         CHECK_ERROR(waitForSpace(connection, stream));
1004         SHMEM_ASSERT(!FULL(stream));
1005 
1006         fragmentStart = shared-&gt;writeOffset;
1007 
1008         if (fragmentStart &lt; shared-&gt;readOffset) {
</pre>
<hr />
<pre>
1013         fragmentLength = MIN(maxLength, length - index);
1014         memcpy(shared-&gt;buffer + fragmentStart, (jbyte *)bytes + index, fragmentLength);
1015         shared-&gt;writeOffset = ADD_OFFSET(fragmentStart, fragmentLength);
1016         index += fragmentLength;
1017 
1018         shared-&gt;isFull = (shared-&gt;readOffset == shared-&gt;writeOffset);
1019 
1020         STREAM_INVARIANT(stream);
1021         CHECK_ERROR(signalData(stream));
1022 
1023     }
1024     CHECK_ERROR(leaveMutex(stream));
1025 
1026     return SYS_OK;
1027 }
1028 
1029 
1030 /*
1031  * Send packet header followed by data.
1032  */
<span class="line-modified">1033 jint</span>
<span class="line-modified">1034 shmemBase_sendPacket(SharedMemoryConnection *connection, const jdwpPacket *packet)</span>
1035 {
1036     jint data_length;
1037 
1038     clearLastError();
1039 
1040     CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.id, sizeof(jint)));
1041     CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.flags, sizeof(jbyte)));
1042 
1043     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1044         CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.reply.errorCode, sizeof(jshort)));
1045     } else {
1046         CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.cmdSet, sizeof(jbyte)));
1047         CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.cmd, sizeof(jbyte)));
1048     }
1049 
1050     data_length = packet-&gt;type.cmd.len - JDWP_HEADER_SIZE;
1051     SHMEM_GUARANTEE(data_length &gt;= 0);
1052     CHECK_ERROR(sendBytes(connection, &amp;data_length, sizeof(jint)));
1053 
1054     if (data_length &gt; 0) {
1055         CHECK_ERROR(sendBytes(connection, packet-&gt;type.cmd.data, data_length));
1056     }
1057 
1058     return SYS_OK;
1059 }
1060 









1061 static jint
1062 receiveBytes(SharedMemoryConnection *connection, void *bytes, jint length)
1063 {
1064     Stream *stream = &amp;connection-&gt;incoming;
1065     SharedStream *shared = stream-&gt;shared;
1066     jint fragmentStart;
1067     jint fragmentLength;
1068     jint index = 0;
1069     jint maxLength;
1070 
1071     clearLastError();
1072 
1073     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
1074     while (index &lt; length) {
1075         CHECK_ERROR(waitForData(connection, stream));
1076         SHMEM_ASSERT(!EMPTY(stream));
1077 
1078         fragmentStart = shared-&gt;readOffset;
1079         if (fragmentStart &lt; shared-&gt;writeOffset) {
1080             maxLength = shared-&gt;writeOffset - fragmentStart;
</pre>
<hr />
<pre>
1083         }
1084         fragmentLength = MIN(maxLength, length - index);
1085         memcpy((jbyte *)bytes + index, shared-&gt;buffer + fragmentStart, fragmentLength);
1086         shared-&gt;readOffset = ADD_OFFSET(fragmentStart, fragmentLength);
1087         index += fragmentLength;
1088 
1089         shared-&gt;isFull = JNI_FALSE;
1090 
1091         STREAM_INVARIANT(stream);
1092         CHECK_ERROR(signalSpace(stream));
1093     }
1094     CHECK_ERROR(leaveMutex(stream));
1095 
1096     return SYS_OK;
1097 }
1098 
1099 /*
1100  * Read packet header and insert into packet structure.
1101  * Allocate space for the data and fill it in.
1102  */
<span class="line-modified">1103 jint</span>
<span class="line-modified">1104 shmemBase_receivePacket(SharedMemoryConnection *connection, jdwpPacket *packet)</span>
1105 {
1106     jint data_length;
1107     jint error;
1108 
1109     clearLastError();
1110 
1111     CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.id, sizeof(jint)));
1112     CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.flags, sizeof(jbyte)));
1113 
1114     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1115         CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.reply.errorCode, sizeof(jshort)));
1116     } else {
1117         CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.cmdSet, sizeof(jbyte)));
1118         CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.cmd, sizeof(jbyte)));
1119     }
1120 
1121     CHECK_ERROR(receiveBytes(connection, &amp;data_length, sizeof(jint)));
1122 
1123     if (data_length &lt; 0) {
1124         return SYS_ERR;
1125     } else if (data_length == 0) {
1126         packet-&gt;type.cmd.len = JDWP_HEADER_SIZE;
1127         packet-&gt;type.cmd.data = NULL;
1128     } else {
1129         packet-&gt;type.cmd.len = data_length + JDWP_HEADER_SIZE;
1130         packet-&gt;type.cmd.data = (*callback-&gt;alloc)(data_length);
1131         if (packet-&gt;type.cmd.data == NULL) {
1132             return SYS_ERR;
1133         }
1134 
1135         error = receiveBytes(connection, packet-&gt;type.cmd.data, data_length);
1136         if (error != SYS_OK) {
1137             (*callback-&gt;free)(packet-&gt;type.cmd.data);
1138             return error;
1139         }
1140     }
1141 
1142     return SYS_OK;
1143 }
1144 









1145 jint
1146 shmemBase_name(struct SharedMemoryTransport *transport, char **name)
1147 {
1148     *name = transport-&gt;name;
1149     return SYS_OK;
1150 }
1151 
1152 jint
1153 shmemBase_getlasterror(char *msg, jint size) {
1154     char *errstr = (char *)sysTlsGet(tlsIndex);
1155     if (errstr != NULL) {
1156         strcpy(msg, errstr);
1157         return SYS_OK;
1158     } else {
1159         return SYS_ERR;
1160     }
1161 }
1162 
1163 
1164 void
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  44  * it requires). It supports multiple connections for the benefit of the
  45  * front-end client; the back end interface assumes only a single connection.
  46  */
  47 
  48 #define MAX_IPC_PREFIX 50   /* user-specified or generated name for */
  49                             /* shared memory seg and prefix for other IPC */
  50 #define MAX_IPC_SUFFIX 25   /* suffix to shmem name for other IPC names */
  51 #define MAX_IPC_NAME   (MAX_IPC_PREFIX + MAX_IPC_SUFFIX)
  52 
  53 #define MAX_GENERATION_RETRIES 20
  54 #define SHARED_BUFFER_SIZE 5000
  55 
  56 #define CHECK_ERROR(expr) do { \
  57                               jint error = (expr); \
  58                               if (error != SYS_OK) { \
  59                                   setLastError(error); \
  60                                   return error; \
  61                               } \
  62                           } while (0)
  63 
<span class="line-added">  64 #define ENTER_CONNECTION(connection) \</span>
<span class="line-added">  65         do { \</span>
<span class="line-added">  66             InterlockedIncrement(&amp;connection-&gt;refcount); \</span>
<span class="line-added">  67             if (IS_STATE_CLOSED(connection-&gt;state)) { \</span>
<span class="line-added">  68                 setLastErrorMsg(&quot;stream closed&quot;); \</span>
<span class="line-added">  69                 InterlockedDecrement(&amp;connection-&gt;refcount); \</span>
<span class="line-added">  70                 return SYS_ERR; \</span>
<span class="line-added">  71             } \</span>
<span class="line-added">  72         } while (0)</span>
<span class="line-added">  73 </span>
<span class="line-added">  74 #define LEAVE_CONNECTION(connection) \</span>
<span class="line-added">  75         do { \</span>
<span class="line-added">  76             InterlockedDecrement(&amp;connection-&gt;refcount); \</span>
<span class="line-added">  77         } while (0)</span>
<span class="line-added">  78 </span>
  79 /*
  80  * The following assertions should hold anytime the stream&#39;s mutex is not held
  81  */
  82 #define STREAM_INVARIANT(stream) \
  83         do { \
  84             SHMEM_ASSERT((stream-&gt;shared-&gt;readOffset &lt; SHARED_BUFFER_SIZE) \
  85                          &amp;&amp; (stream-&gt;shared-&gt;readOffset &gt;= 0)); \
  86             SHMEM_ASSERT((stream-&gt;shared-&gt;writeOffset &lt; SHARED_BUFFER_SIZE) \
  87                          &amp;&amp; (stream-&gt;shared-&gt;writeOffset &gt;= 0)); \
  88         } while (0)
  89 
  90 /*
  91  * Transports are duplex, so carve the shared memory into &quot;streams&quot;,
  92  * one used to send from client to server, the other vice versa.
  93  */
  94 typedef struct SharedMemoryListener {
  95     char mutexName[MAX_IPC_NAME];
  96     char acceptEventName[MAX_IPC_NAME];
  97     char attachEventName[MAX_IPC_NAME];
  98     jboolean isListening;
</pre>
<hr />
<pre>
 152 #define STATE_CLOSED 0xDEAD
 153 #define STATE_OPEN   (STATE_CLOSED -1)
 154 /*
 155  * State checking macro. We compare against the STATE_OPEN value so
 156  * that STATE_CLOSED and any other value will be considered closed.
 157  * This catches a freed Stream as long as the memory page is still
 158  * valid. If the memory page is gone, then there is little that we
 159  * can do.
 160  */
 161 #define IS_STATE_CLOSED(state) (state != STATE_OPEN)
 162 
 163 
 164 typedef struct SharedMemoryConnection {
 165     char name[MAX_IPC_NAME];
 166     SharedMemory *shared;
 167     sys_shmem_t sharedMemory;
 168     Stream incoming;
 169     Stream outgoing;
 170     sys_process_t otherProcess;
 171     sys_event_t shutdown;           /* signalled to indicate shutdown */
<span class="line-added"> 172     volatile DWORD32 refcount;</span>
<span class="line-added"> 173     jint state;</span>
 174 } SharedMemoryConnection;
 175 
 176 static jdwpTransportCallback *callback;
 177 static JavaVM *jvm;
 178 static int tlsIndex;
 179 
 180 typedef jint (*CreateFunc)(char *name, void *arg);
 181 
 182 /*
 183  * Set the per-thread error message (if not already set)
 184  */
 185 static void
 186 setLastErrorMsg(char *newmsg) {
 187     char *msg;
 188 
 189     msg = (char *)sysTlsGet(tlsIndex);
 190     if (msg == NULL) {
 191         msg = (*callback-&gt;alloc)((int)strlen(newmsg)+1);
 192         if (msg != NULL) {
 193            strcpy(msg, newmsg);
</pre>
<hr />
<pre>
 361     while ((error == SYS_OK) &amp;&amp; EMPTY(stream)) {
 362         CHECK_ERROR(leaveMutex(stream));
 363         error = sysEventWait(connection-&gt;otherProcess, stream-&gt;hasData, 0);
 364         if (error == SYS_OK) {
 365             CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
 366         } else {
 367             setLastError(error);
 368         }
 369     }
 370     return error;
 371 }
 372 
 373 static jint
 374 signalData(Stream *stream)
 375 {
 376     return sysEventSignal(stream-&gt;hasData);
 377 }
 378 
 379 
 380 static jint
<span class="line-modified"> 381 closeStream(Stream *stream, jboolean linger, volatile DWORD32 *refcount)</span>
 382 {
 383     /*
 384      * Lock stream during close - ignore shutdown event as we are
 385      * closing down and shutdown should be signalled.
 386      */
 387     CHECK_ERROR(enterMutex(stream, NULL));
 388 
 389     /* mark the stream as closed */
 390     stream-&gt;state = STATE_CLOSED;
 391     /* wake up waitForData() if it is in sysEventWait() */
 392     sysEventSignal(stream-&gt;hasData);

 393     /* wake up waitForSpace() if it is in sysEventWait() */
 394     sysEventSignal(stream-&gt;hasSpace);

 395 
 396     /*
 397      * If linger requested then give the stream a few seconds to
 398      * drain before closing it.
 399      */
 400     if (linger) {
 401         int attempts = 10;
 402         while (!EMPTY(stream) &amp;&amp; attempts&gt;0) {
 403             CHECK_ERROR(leaveMutex(stream));
 404             sysSleep(200);
 405             CHECK_ERROR(enterMutex(stream, NULL));
 406             attempts--;
 407         }
 408     }
 409 
 410     CHECK_ERROR(leaveMutex(stream));
<span class="line-modified"> 411 </span>
<span class="line-modified"> 412     /* Attempt to close resources */</span>
<span class="line-added"> 413     int attempts = 10;</span>
<span class="line-added"> 414     while (attempts &gt; 0) {</span>
<span class="line-added"> 415         if (*refcount == 0) {</span>
<span class="line-added"> 416             sysEventClose(stream-&gt;hasData);</span>
<span class="line-added"> 417             sysEventClose(stream-&gt;hasSpace);</span>
<span class="line-added"> 418             sysIPMutexClose(stream-&gt;mutex);</span>
<span class="line-added"> 419             return SYS_OK;</span>
<span class="line-added"> 420         }</span>
<span class="line-added"> 421         sysSleep(200);</span>
<span class="line-added"> 422         attempts--;</span>
<span class="line-added"> 423     }</span>
<span class="line-added"> 424     return SYS_ERR;</span>
 425 }
 426 
 427 /*
 428  * Server creates stream.
 429  */
 430 static int
 431 createStream(char *name, Stream *stream)
 432 {
 433     jint error;
 434     char objectName[MAX_IPC_NAME];
 435 
 436     sprintf(objectName, &quot;%s.mutex&quot;, name);
 437     error = createWithGeneratedName(objectName, stream-&gt;shared-&gt;mutexName,
 438                                     createMutex, &amp;stream-&gt;mutex);
 439     if (error != SYS_OK) {
 440         return error;
 441     }
 442 
 443     sprintf(objectName, &quot;%s.hasData&quot;, name);
 444     error = createWithGeneratedName(objectName, stream-&gt;shared-&gt;hasDataEventName,
 445                                     createEvent, &amp;stream-&gt;hasData);
 446     if (error != SYS_OK) {
<span class="line-modified"> 447         sysIPMutexClose(stream-&gt;mutex);</span>
 448         return error;
 449     }
 450 
 451     sprintf(objectName, &quot;%s.hasSpace&quot;, name);
 452     error = createWithGeneratedName(objectName, stream-&gt;shared-&gt;hasSpaceEventName,
 453                                     createEvent, &amp;stream-&gt;hasSpace);
 454     if (error != SYS_OK) {
<span class="line-modified"> 455         sysIPMutexClose(stream-&gt;mutex);</span>
<span class="line-added"> 456         sysEventClose(stream-&gt;hasData);</span>
 457         return error;
 458     }
 459 
 460     stream-&gt;shared-&gt;readOffset = 0;
 461     stream-&gt;shared-&gt;writeOffset = 0;
 462     stream-&gt;shared-&gt;isFull = JNI_FALSE;
 463     stream-&gt;state = STATE_OPEN;
 464     return SYS_OK;
 465 }
 466 
 467 
 468 /*
 469  * Initialization for the stream opened by the other process
 470  */
 471 static int
 472 openStream(Stream *stream)
 473 {
 474     jint error;
 475 
 476     CHECK_ERROR(sysIPMutexOpen(stream-&gt;shared-&gt;mutexName, &amp;stream-&gt;mutex));
 477 
 478     error = sysEventOpen(stream-&gt;shared-&gt;hasDataEventName,
 479                              &amp;stream-&gt;hasData);
 480     if (error != SYS_OK) {
 481         setLastError(error);
<span class="line-modified"> 482         sysIPMutexClose(stream-&gt;mutex);</span>
 483         return error;
 484     }
 485 
 486     error = sysEventOpen(stream-&gt;shared-&gt;hasSpaceEventName,
 487                              &amp;stream-&gt;hasSpace);
 488     if (error != SYS_OK) {
 489         setLastError(error);
<span class="line-modified"> 490         sysIPMutexClose(stream-&gt;mutex);</span>
<span class="line-added"> 491         sysEventClose(stream-&gt;hasData);</span>
 492         return error;
 493     }
 494 
 495     stream-&gt;state = STATE_OPEN;
 496 
 497     return SYS_OK;
 498 }
 499 
 500 /********************************************************************/
 501 
 502 static SharedMemoryConnection *
 503 allocConnection(void)
 504 {
 505     /*
 506      * TO DO: Track all allocated connections for clean shutdown?
 507      */
 508     SharedMemoryConnection *conn = (*callback-&gt;alloc)(sizeof(SharedMemoryConnection));
 509     if (conn != NULL) {
 510         memset(conn, 0, sizeof(SharedMemoryConnection));
 511     }
<span class="line-added"> 512     conn-&gt;state = STATE_OPEN;</span>
 513     return conn;
 514 }
 515 
 516 static void
 517 freeConnection(SharedMemoryConnection *connection)
 518 {
 519     (*callback-&gt;free)(connection);
 520 }
 521 
 522 static void
 523 closeConnection(SharedMemoryConnection *connection)
 524 {
<span class="line-added"> 525     /* mark the connection as closed */</span>
<span class="line-added"> 526     connection-&gt;state = STATE_CLOSED;</span>
<span class="line-added"> 527 </span>
 528     /*
 529      * Signal all threads accessing this connection that we are
 530      * shutting down.
 531      */
 532     if (connection-&gt;shutdown) {
 533         sysEventSignal(connection-&gt;shutdown);
 534     }
 535 
<span class="line-modified"> 536     Stream * stream = &amp;connection-&gt;outgoing;</span>
<span class="line-modified"> 537     if (stream-&gt;state == STATE_OPEN) {</span>
<span class="line-modified"> 538         (void)closeStream(stream, JNI_TRUE, &amp;connection-&gt;refcount);</span>



 539     }
<span class="line-modified"> 540     stream = &amp;connection-&gt;incoming;</span>
<span class="line-modified"> 541     if (stream-&gt;state == STATE_OPEN) {</span>
<span class="line-added"> 542         (void)closeStream(stream, JNI_FALSE, &amp;connection-&gt;refcount);</span>
 543     }
 544 
<span class="line-modified"> 545     if (connection-&gt;refcount == 0) {</span>
<span class="line-modified"> 546         if (connection-&gt;sharedMemory) {</span>
<span class="line-modified"> 547             sysSharedMemClose(connection-&gt;sharedMemory, connection-&gt;shared);</span>
<span class="line-modified"> 548         }</span>
<span class="line-modified"> 549         if (connection-&gt;otherProcess) {</span>
<span class="line-modified"> 550             sysProcessClose(connection-&gt;otherProcess);</span>
<span class="line-modified"> 551         }</span>
<span class="line-modified"> 552         if (connection-&gt;shutdown) {</span>
<span class="line-modified"> 553             sysEventClose(connection-&gt;shutdown);</span>
<span class="line-modified"> 554         }</span>
<span class="line-modified"> 555     }</span>

 556 }
 557 
 558 
 559 /*
 560  * For client: connect to the shared memory.  Open incoming and
 561  * outgoing streams.
 562  */
 563 static jint
 564 openConnection(SharedMemoryTransport *transport, jlong otherPID,
 565                SharedMemoryConnection **connectionPtr)
 566 {
 567     jint error;
 568 
 569     SharedMemoryConnection *connection = allocConnection();
 570     if (connection == NULL) {
 571         return SYS_NOMEM;
 572     }
 573 
 574     sprintf(connection-&gt;name, &quot;%s.%&quot; PRId64, transport-&gt;name, sysProcessGetID());
 575     error = sysSharedMemOpen(connection-&gt;name, &amp;connection-&gt;sharedMemory,
 576                              &amp;connection-&gt;shared);
 577     if (error != SYS_OK) {
<span class="line-modified"> 578         freeConnection(connection);</span>
 579         return error;
 580     }
 581 
 582     /* This process is the client */
 583     connection-&gt;incoming.shared = &amp;connection-&gt;shared-&gt;toClient;
 584     connection-&gt;outgoing.shared = &amp;connection-&gt;shared-&gt;toServer;
 585 
 586     error = openStream(&amp;connection-&gt;incoming);
 587     if (error != SYS_OK) {
 588         closeConnection(connection);
<span class="line-added"> 589         freeConnection(connection);</span>
 590         return error;
 591     }
 592 
 593     error = openStream(&amp;connection-&gt;outgoing);
 594     if (error != SYS_OK) {
 595         closeConnection(connection);
<span class="line-added"> 596         freeConnection(connection);</span>
 597         return error;
 598     }
 599 
 600     error = sysProcessOpen(otherPID, &amp;connection-&gt;otherProcess);
 601     if (error != SYS_OK) {
 602         setLastError(error);
 603         closeConnection(connection);
<span class="line-added"> 604         freeConnection(connection);</span>
 605         return error;
 606     }
 607 
 608     /*
 609      * Create an event that signals that the connection is shutting
 610      * down. The event is unnamed as it&#39;s process local, and is
 611      * manually reset (so that signalling the event will signal
 612      * all threads waiting on it).
 613      */
 614     error = sysEventCreate(NULL, &amp;connection-&gt;shutdown, JNI_TRUE);
 615     if (error != SYS_OK) {
 616         setLastError(error);
 617         closeConnection(connection);
<span class="line-added"> 618         freeConnection(connection);</span>
 619         return error;
 620     }
 621 
 622     *connectionPtr = connection;
 623     return SYS_OK;
 624 }
 625 
 626 /*
 627  * For server: create the shared memory.  Create incoming and
 628  * outgoing streams.
 629  */
 630 static jint
 631 createConnection(SharedMemoryTransport *transport, jlong otherPID,
 632                  SharedMemoryConnection **connectionPtr)
 633 {
 634     jint error;
 635     char streamName[MAX_IPC_NAME];
 636 
 637     SharedMemoryConnection *connection = allocConnection();
 638     if (connection == NULL) {
 639         return SYS_NOMEM;
 640     }
 641 
 642     sprintf(connection-&gt;name, &quot;%s.%&quot; PRId64, transport-&gt;name, otherPID);
 643     error = sysSharedMemCreate(connection-&gt;name, sizeof(SharedMemory),
 644                                &amp;connection-&gt;sharedMemory, &amp;connection-&gt;shared);
 645     if (error != SYS_OK) {
<span class="line-modified"> 646         freeConnection(connection);</span>
 647         return error;
 648     }
 649 
 650     memset(connection-&gt;shared, 0, sizeof(SharedMemory));
 651 
 652     /* This process is the server */
 653     connection-&gt;incoming.shared = &amp;connection-&gt;shared-&gt;toServer;
 654     connection-&gt;outgoing.shared = &amp;connection-&gt;shared-&gt;toClient;
 655 
 656     strcpy(streamName, connection-&gt;name);
 657     strcat(streamName, &quot;.ctos&quot;);
 658     error = createStream(streamName, &amp;connection-&gt;incoming);
 659     if (error != SYS_OK) {
 660         closeConnection(connection);
<span class="line-added"> 661         freeConnection(connection);</span>
 662         return error;
 663     }
 664 
 665     strcpy(streamName, connection-&gt;name);
 666     strcat(streamName, &quot;.stoc&quot;);
 667     error = createStream(streamName, &amp;connection-&gt;outgoing);
 668     if (error != SYS_OK) {
 669         closeConnection(connection);
<span class="line-added"> 670         freeConnection(connection);</span>
 671         return error;
 672     }
 673 
 674     error = sysProcessOpen(otherPID, &amp;connection-&gt;otherProcess);
 675     if (error != SYS_OK) {
 676         setLastError(error);
 677         closeConnection(connection);
<span class="line-added"> 678         freeConnection(connection);</span>
 679         return error;
 680     }
 681 
 682     /*
 683      * Create an event that signals that the connection is shutting
 684      * down. The event is unnamed as it&#39;s process local, and is
 685      * manually reset (so that a signalling the event will signal
 686      * all threads waiting on it).
 687      */
 688     error = sysEventCreate(NULL, &amp;connection-&gt;shutdown, JNI_TRUE);
 689     if (error != SYS_OK) {
 690         setLastError(error);
 691         closeConnection(connection);
<span class="line-added"> 692         freeConnection(connection);</span>
 693         return error;
 694     }
 695 
 696     *connectionPtr = connection;
 697     return SYS_OK;
 698 }
 699 
 700 /********************************************************************/
 701 
 702 static SharedMemoryTransport *
 703 allocTransport(void)
 704 {
 705     /*
 706      * TO DO: Track all allocated transports for clean shutdown?
 707      */
 708     return (*callback-&gt;alloc)(sizeof(SharedMemoryTransport));
 709 }
 710 
 711 static void
 712 freeTransport(SharedMemoryTransport *transport)
</pre>
<hr />
<pre>
 868 shmemBase_accept(SharedMemoryTransport *transport,
 869                  long timeout,
 870                  SharedMemoryConnection **connectionPtr)
 871 {
 872     jint error;
 873     SharedMemoryConnection *connection;
 874 
 875     clearLastError();
 876 
 877     CHECK_ERROR(sysEventWait(NULL, transport-&gt;attachEvent, timeout));
 878 
 879     error = createConnection(transport, transport-&gt;shared-&gt;attachingPID,
 880                              &amp;connection);
 881     if (error != SYS_OK) {
 882         /*
 883          * Reject the attacher
 884          */
 885         transport-&gt;shared-&gt;isAccepted = JNI_FALSE;
 886         sysEventSignal(transport-&gt;acceptEvent);
 887 

 888         return error;
 889     }
 890 
 891     transport-&gt;shared-&gt;isAccepted = JNI_TRUE;
 892     error = sysEventSignal(transport-&gt;acceptEvent);
 893     if (error != SYS_OK) {
 894         /*
 895          * No real point trying to reject it.
 896          */
 897         closeConnection(connection);
<span class="line-added"> 898         freeConnection(connection);</span>
 899         return error;
 900     }
 901 
 902     *connectionPtr = connection;
 903     return SYS_OK;
 904 }
 905 
 906 static jint
 907 doAttach(SharedMemoryTransport *transport, long timeout)
 908 {
 909     transport-&gt;shared-&gt;attachingPID = sysProcessGetID();
 910     CHECK_ERROR(sysEventSignal(transport-&gt;attachEvent));
 911     CHECK_ERROR(sysEventWait(NULL, transport-&gt;acceptEvent, timeout));
 912     return SYS_OK;
 913 }
 914 
 915 jint
 916 shmemBase_attach(const char *addressString, long timeout, SharedMemoryConnection **connectionPtr)
 917 {
 918     int error;
</pre>
<hr />
<pre>
 948     if (error != SYS_OK) {
 949         closeTransport(transport);
 950         return error;
 951     }
 952 
 953     error = openConnection(transport, acceptingPID, connectionPtr);
 954 
 955     closeTransport(transport);
 956 
 957     return error;
 958 }
 959 
 960 
 961 
 962 
 963 void
 964 shmemBase_closeConnection(SharedMemoryConnection *connection)
 965 {
 966     clearLastError();
 967     closeConnection(connection);
<span class="line-added"> 968     /*</span>
<span class="line-added"> 969      * Ideally we should free the connection structure. However,</span>
<span class="line-added"> 970      * since the connection has already being published, other</span>
<span class="line-added"> 971      * threads may still be accessing it. In particular, refcount</span>
<span class="line-added"> 972      * and state fields could be accessed at any time even after</span>
<span class="line-added"> 973      * closing the connection. On Win32 this means we leak 140</span>
<span class="line-added"> 974      * bytes. This memory will be reclaimed at process exit.</span>
<span class="line-added"> 975      *</span>
<span class="line-added"> 976      * In general reference counting should exist externally to</span>
<span class="line-added"> 977      * the object being managed so that it can be freed. If we</span>
<span class="line-added"> 978      * want to free SharedMemoryConnection, one alternative could</span>
<span class="line-added"> 979      * be to define a new struct X and move all those fields there</span>
<span class="line-added"> 980      * except refcount and state. We would have a pointer to a</span>
<span class="line-added"> 981      * dynamically allocated X from SharedMemoryConnection. Then</span>
<span class="line-added"> 982      * if refcount is 0 we could also free X. This would leak</span>
<span class="line-added"> 983      * 12 bytes instead of 140.</span>
<span class="line-added"> 984      *</span>
<span class="line-added"> 985      * freeConnection(connection);</span>
<span class="line-added"> 986      *</span>
<span class="line-added"> 987      */</span>
 988 }
 989 
 990 void
 991 shmemBase_closeTransport(SharedMemoryTransport *transport)
 992 {
 993     clearLastError();
 994     closeTransport(transport);
 995 }
 996 
<span class="line-modified"> 997 static jint</span>
<span class="line-modified"> 998 shmemBase_sendByte_internal(SharedMemoryConnection *connection, jbyte data)</span>
 999 {
1000     Stream *stream = &amp;connection-&gt;outgoing;
1001     SharedStream *shared = stream-&gt;shared;
1002     int offset;
1003 
1004     clearLastError();
1005 
1006     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
1007     CHECK_ERROR(waitForSpace(connection, stream));
1008     SHMEM_ASSERT(!FULL(stream));
1009     offset = shared-&gt;writeOffset;
1010     shared-&gt;buffer[offset] = data;
1011     shared-&gt;writeOffset = ADD_OFFSET(offset, 1);
1012     shared-&gt;isFull = (shared-&gt;readOffset == shared-&gt;writeOffset);
1013 
1014     STREAM_INVARIANT(stream);
1015     CHECK_ERROR(leaveMutex(stream));
1016 
1017     CHECK_ERROR(signalData(stream));
1018 
1019     return SYS_OK;
1020 }
1021 
1022 jint
<span class="line-modified">1023 shmemBase_sendByte(SharedMemoryConnection *connection, jbyte data)</span>
<span class="line-added">1024 {</span>
<span class="line-added">1025     ENTER_CONNECTION(connection);</span>
<span class="line-added">1026     jint rc = shmemBase_sendByte_internal(connection, data);</span>
<span class="line-added">1027     LEAVE_CONNECTION(connection);</span>
<span class="line-added">1028     return rc;</span>
<span class="line-added">1029 }</span>
<span class="line-added">1030 </span>
<span class="line-added">1031 static jint</span>
<span class="line-added">1032 shmemBase_receiveByte_internal(SharedMemoryConnection *connection, jbyte *data)</span>
1033 {
1034     Stream *stream = &amp;connection-&gt;incoming;
1035     SharedStream *shared = stream-&gt;shared;
1036     int offset;
1037 
1038     clearLastError();
1039 
1040     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
1041     CHECK_ERROR(waitForData(connection, stream));
1042     SHMEM_ASSERT(!EMPTY(stream));
1043     offset = shared-&gt;readOffset;
1044     *data = shared-&gt;buffer[offset];
1045     shared-&gt;readOffset = ADD_OFFSET(offset, 1);
1046     shared-&gt;isFull = JNI_FALSE;
1047 
1048     STREAM_INVARIANT(stream);
1049     CHECK_ERROR(leaveMutex(stream));
1050 
1051     CHECK_ERROR(signalSpace(stream));
1052 
1053     return SYS_OK;
1054 }
1055 
<span class="line-added">1056 jint</span>
<span class="line-added">1057 shmemBase_receiveByte(SharedMemoryConnection *connection, jbyte *data)</span>
<span class="line-added">1058 {</span>
<span class="line-added">1059     ENTER_CONNECTION(connection);</span>
<span class="line-added">1060     jint rc = shmemBase_receiveByte_internal(connection, data);</span>
<span class="line-added">1061     LEAVE_CONNECTION(connection);</span>
<span class="line-added">1062     return rc;</span>
<span class="line-added">1063 }</span>
<span class="line-added">1064 </span>
1065 static jint
1066 sendBytes(SharedMemoryConnection *connection, const void *bytes, jint length)
1067 {
1068     Stream *stream = &amp;connection-&gt;outgoing;
1069     SharedStream *shared = stream-&gt;shared;
1070     jint fragmentStart;
1071     jint fragmentLength;
1072     jint index = 0;
1073     jint maxLength;
1074 
1075     clearLastError();
1076 
1077     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
1078     while (index &lt; length) {
1079         CHECK_ERROR(waitForSpace(connection, stream));
1080         SHMEM_ASSERT(!FULL(stream));
1081 
1082         fragmentStart = shared-&gt;writeOffset;
1083 
1084         if (fragmentStart &lt; shared-&gt;readOffset) {
</pre>
<hr />
<pre>
1089         fragmentLength = MIN(maxLength, length - index);
1090         memcpy(shared-&gt;buffer + fragmentStart, (jbyte *)bytes + index, fragmentLength);
1091         shared-&gt;writeOffset = ADD_OFFSET(fragmentStart, fragmentLength);
1092         index += fragmentLength;
1093 
1094         shared-&gt;isFull = (shared-&gt;readOffset == shared-&gt;writeOffset);
1095 
1096         STREAM_INVARIANT(stream);
1097         CHECK_ERROR(signalData(stream));
1098 
1099     }
1100     CHECK_ERROR(leaveMutex(stream));
1101 
1102     return SYS_OK;
1103 }
1104 
1105 
1106 /*
1107  * Send packet header followed by data.
1108  */
<span class="line-modified">1109 static jint</span>
<span class="line-modified">1110 shmemBase_sendPacket_internal(SharedMemoryConnection *connection, const jdwpPacket *packet)</span>
1111 {
1112     jint data_length;
1113 
1114     clearLastError();
1115 
1116     CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.id, sizeof(jint)));
1117     CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.flags, sizeof(jbyte)));
1118 
1119     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1120         CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.reply.errorCode, sizeof(jshort)));
1121     } else {
1122         CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.cmdSet, sizeof(jbyte)));
1123         CHECK_ERROR(sendBytes(connection, &amp;packet-&gt;type.cmd.cmd, sizeof(jbyte)));
1124     }
1125 
1126     data_length = packet-&gt;type.cmd.len - JDWP_HEADER_SIZE;
1127     SHMEM_GUARANTEE(data_length &gt;= 0);
1128     CHECK_ERROR(sendBytes(connection, &amp;data_length, sizeof(jint)));
1129 
1130     if (data_length &gt; 0) {
1131         CHECK_ERROR(sendBytes(connection, packet-&gt;type.cmd.data, data_length));
1132     }
1133 
1134     return SYS_OK;
1135 }
1136 
<span class="line-added">1137 jint</span>
<span class="line-added">1138 shmemBase_sendPacket(SharedMemoryConnection *connection, const jdwpPacket *packet)</span>
<span class="line-added">1139 {</span>
<span class="line-added">1140     ENTER_CONNECTION(connection);</span>
<span class="line-added">1141     jint rc = shmemBase_sendPacket_internal(connection, packet);</span>
<span class="line-added">1142     LEAVE_CONNECTION(connection);</span>
<span class="line-added">1143     return rc;</span>
<span class="line-added">1144 }</span>
<span class="line-added">1145 </span>
1146 static jint
1147 receiveBytes(SharedMemoryConnection *connection, void *bytes, jint length)
1148 {
1149     Stream *stream = &amp;connection-&gt;incoming;
1150     SharedStream *shared = stream-&gt;shared;
1151     jint fragmentStart;
1152     jint fragmentLength;
1153     jint index = 0;
1154     jint maxLength;
1155 
1156     clearLastError();
1157 
1158     CHECK_ERROR(enterMutex(stream, connection-&gt;shutdown));
1159     while (index &lt; length) {
1160         CHECK_ERROR(waitForData(connection, stream));
1161         SHMEM_ASSERT(!EMPTY(stream));
1162 
1163         fragmentStart = shared-&gt;readOffset;
1164         if (fragmentStart &lt; shared-&gt;writeOffset) {
1165             maxLength = shared-&gt;writeOffset - fragmentStart;
</pre>
<hr />
<pre>
1168         }
1169         fragmentLength = MIN(maxLength, length - index);
1170         memcpy((jbyte *)bytes + index, shared-&gt;buffer + fragmentStart, fragmentLength);
1171         shared-&gt;readOffset = ADD_OFFSET(fragmentStart, fragmentLength);
1172         index += fragmentLength;
1173 
1174         shared-&gt;isFull = JNI_FALSE;
1175 
1176         STREAM_INVARIANT(stream);
1177         CHECK_ERROR(signalSpace(stream));
1178     }
1179     CHECK_ERROR(leaveMutex(stream));
1180 
1181     return SYS_OK;
1182 }
1183 
1184 /*
1185  * Read packet header and insert into packet structure.
1186  * Allocate space for the data and fill it in.
1187  */
<span class="line-modified">1188 static jint</span>
<span class="line-modified">1189 shmemBase_receivePacket_internal(SharedMemoryConnection *connection, jdwpPacket *packet)</span>
1190 {
1191     jint data_length;
1192     jint error;
1193 
1194     clearLastError();
1195 
1196     CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.id, sizeof(jint)));
1197     CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.flags, sizeof(jbyte)));
1198 
1199     if (packet-&gt;type.cmd.flags &amp; JDWPTRANSPORT_FLAGS_REPLY) {
1200         CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.reply.errorCode, sizeof(jshort)));
1201     } else {
1202         CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.cmdSet, sizeof(jbyte)));
1203         CHECK_ERROR(receiveBytes(connection, &amp;packet-&gt;type.cmd.cmd, sizeof(jbyte)));
1204     }
1205 
1206     CHECK_ERROR(receiveBytes(connection, &amp;data_length, sizeof(jint)));
1207 
1208     if (data_length &lt; 0) {
1209         return SYS_ERR;
1210     } else if (data_length == 0) {
1211         packet-&gt;type.cmd.len = JDWP_HEADER_SIZE;
1212         packet-&gt;type.cmd.data = NULL;
1213     } else {
1214         packet-&gt;type.cmd.len = data_length + JDWP_HEADER_SIZE;
1215         packet-&gt;type.cmd.data = (*callback-&gt;alloc)(data_length);
1216         if (packet-&gt;type.cmd.data == NULL) {
1217             return SYS_ERR;
1218         }
1219 
1220         error = receiveBytes(connection, packet-&gt;type.cmd.data, data_length);
1221         if (error != SYS_OK) {
1222             (*callback-&gt;free)(packet-&gt;type.cmd.data);
1223             return error;
1224         }
1225     }
1226 
1227     return SYS_OK;
1228 }
1229 
<span class="line-added">1230 jint</span>
<span class="line-added">1231 shmemBase_receivePacket(SharedMemoryConnection *connection, jdwpPacket *packet)</span>
<span class="line-added">1232 {</span>
<span class="line-added">1233     ENTER_CONNECTION(connection);</span>
<span class="line-added">1234     jint rc = shmemBase_receivePacket_internal(connection, packet);</span>
<span class="line-added">1235     LEAVE_CONNECTION(connection);</span>
<span class="line-added">1236     return rc;</span>
<span class="line-added">1237 }</span>
<span class="line-added">1238 </span>
1239 jint
1240 shmemBase_name(struct SharedMemoryTransport *transport, char **name)
1241 {
1242     *name = transport-&gt;name;
1243     return SYS_OK;
1244 }
1245 
1246 jint
1247 shmemBase_getlasterror(char *msg, jint size) {
1248     char *errstr = (char *)sysTlsGet(tlsIndex);
1249     if (errstr != NULL) {
1250         strcpy(msg, errstr);
1251         return SYS_OK;
1252     } else {
1253         return SYS_ERR;
1254     }
1255 }
1256 
1257 
1258 void
</pre>
</td>
</tr>
</table>
<center><a href="../../classes/com/sun/tools/jdi/VirtualMachineImpl.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="../../../../jdk.jdwp.agent/share/native/libjdwp/ArrayReferenceImpl.c.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
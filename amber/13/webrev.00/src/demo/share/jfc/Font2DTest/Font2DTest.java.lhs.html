<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/demo/share/jfc/Font2DTest/Font2DTest.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2018, Oracle and/or its affiliates. All rights reserved.
   3  *
   4  * Redistribution and use in source and binary forms, with or without
   5  * modification, are permitted provided that the following conditions
   6  * are met:
   7  *
   8  *   - Redistributions of source code must retain the above copyright
   9  *     notice, this list of conditions and the following disclaimer.
  10  *
  11  *   - Redistributions in binary form must reproduce the above copyright
  12  *     notice, this list of conditions and the following disclaimer in the
  13  *     documentation and/or other materials provided with the distribution.
  14  *
  15  *   - Neither the name of Oracle nor the names of its
  16  *     contributors may be used to endorse or promote products derived
  17  *     from this software without specific prior written permission.
  18  *
  19  * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS
  20  * IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
  21  * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
  22  * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR
  23  * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
  24  * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
  25  * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
  26  * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
  27  * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
  28  * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
  29  * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  30  */
  31 
  32 /*
  33  * This source code is provided to illustrate the usage of a given feature
  34  * or technique and has been deliberately simplified. Additional steps
  35  * required for a production-quality application, such as security checks,
  36  * input validation and proper error handling, might not be present in
  37  * this sample code.
  38  */
  39 
  40 
  41 
  42 import java.awt.Color;
  43 import java.awt.Component;
  44 import java.awt.BorderLayout;
  45 import java.awt.CheckboxGroup;
  46 import java.awt.Container;
  47 import java.awt.Dimension;
  48 import java.awt.Font;
  49 import java.awt.Graphics;
  50 import java.awt.Graphics2D;
  51 import java.awt.GraphicsEnvironment;
  52 import java.awt.GridBagConstraints;
  53 import java.awt.GridBagLayout;
  54 import java.awt.GridLayout;
  55 import java.awt.Insets;
  56 import java.awt.RenderingHints;
  57 import java.awt.Toolkit;
  58 import java.awt.event.ActionEvent;
  59 import java.awt.event.ActionListener;
  60 import java.awt.event.ItemEvent;
  61 import java.awt.event.ItemListener;
  62 import java.awt.event.WindowAdapter;
  63 import java.awt.event.WindowEvent;
  64 import java.awt.image.BufferedImage;
  65 import java.io.BufferedInputStream;
  66 import java.io.BufferedOutputStream;
  67 import java.io.File;
  68 import java.io.FileInputStream;
  69 import java.io.FileOutputStream;
<a name="1" id="anc1"></a><span class="line-removed">  70 import java.util.EnumSet;</span>
  71 import java.util.StringTokenizer;
  72 import java.util.BitSet;
  73 import javax.swing.*;
  74 import javax.swing.event.*;
  75 
  76 /**
  77  * Font2DTest.java
  78  *
  79  * @author Shinsuke Fukuda
  80  * @author Ankit Patel [Conversion to Swing - 01/07/30]
  81  */
  82 
  83 /// Main Font2DTest Class
  84 
  85 public final class Font2DTest extends JPanel
  86     implements ActionListener, ItemListener, ChangeListener {
  87 
  88     /// JFrame that will contain Font2DTest
  89     private final JFrame parent;
  90     /// FontPanel class that will contain all graphical output
  91     private final FontPanel fp;
  92     /// RangeMenu class that contains info about the unicode ranges
  93     private final RangeMenu rm;
  94 
  95     /// Other menus to set parameters for text drawing
  96     private final ChoiceV2 fontMenu;
  97     private final JTextField sizeField;
  98     private final ChoiceV2 styleMenu;
  99     private final ChoiceV2 textMenu;
 100     private int currentTextChoice = 0;
 101     private final ChoiceV2 transformMenu;
 102     private final ChoiceV2 transformMenuG2;
 103     private final ChoiceV2 methodsMenu;
<a name="2" id="anc2"></a><span class="line-modified"> 104     private final JComboBox antiAliasMenu;</span>
<span class="line-modified"> 105     private final JComboBox fracMetricsMenu;</span>
 106 
 107     private final JSlider contrastSlider;
 108 
 109     /// CheckboxMenuItems
 110     private CheckboxMenuItemV2 displayGridCBMI;
 111     private CheckboxMenuItemV2 force16ColsCBMI;
 112     private CheckboxMenuItemV2 showFontInfoCBMI;
 113 
 114     /// JDialog boxes
 115     private JDialog userTextDialog;
 116     private JTextArea userTextArea;
 117     private JDialog printDialog;
 118     private JDialog fontInfoDialog;
 119     private LabelV2[] fontInfos = new LabelV2[2];
 120     private JFileChooser filePromptDialog = null;
 121 
 122     private ButtonGroup printCBGroup;
 123     private JRadioButton[] printModeCBs = new JRadioButton[3];
 124 
 125     /// Status bar
 126     private final LabelV2 statusBar;
 127 
 128     private int[] fontStyles  = {Font.PLAIN, Font.BOLD, Font.ITALIC, Font.BOLD | Font.ITALIC};
 129 
 130     /// Text filename
 131     private String tFileName;
 132 
 133     // Enabled or disabled status of canDisplay check
 134     private static boolean canDisplayCheck = true;
 135 
 136     /// Initialize GUI variables and its layouts
 137     public Font2DTest( JFrame f, boolean isApplet ) {
 138         parent = f;
 139 
 140         rm = new RangeMenu( this, parent );
 141         fp = new FontPanel( this, parent );
 142         statusBar = new LabelV2(&quot;&quot;);
 143 
 144         fontMenu = new ChoiceV2( this, canDisplayCheck );
 145         sizeField = new JTextField( &quot;12&quot;, 3 );
 146         sizeField.addActionListener( this );
 147         styleMenu = new ChoiceV2( this );
 148         textMenu = new ChoiceV2( ); // listener added later
 149         transformMenu = new ChoiceV2( this );
 150         transformMenuG2 = new ChoiceV2( this );
 151         methodsMenu = new ChoiceV2( this );
 152 
 153         antiAliasMenu =
<a name="3" id="anc3"></a><span class="line-modified"> 154             new JComboBox(EnumSet.allOf(FontPanel.AAValues.class).toArray());</span>
 155         antiAliasMenu.addActionListener(this);
 156         fracMetricsMenu =
<a name="4" id="anc4"></a><span class="line-modified"> 157             new JComboBox(EnumSet.allOf(FontPanel.FMValues.class).toArray());</span>
 158         fracMetricsMenu.addActionListener(this);
 159 
 160         contrastSlider = new JSlider(JSlider.HORIZONTAL, 100, 250,
 161                                  FontPanel.getDefaultLCDContrast().intValue());
 162         contrastSlider.setEnabled(false);
 163         contrastSlider.setMajorTickSpacing(20);
 164         contrastSlider.setMinorTickSpacing(10);
 165         contrastSlider.setPaintTicks(true);
 166         contrastSlider.setPaintLabels(true);
 167         contrastSlider.addChangeListener(this);
 168         setupPanel();
 169         setupMenu( isApplet );
 170         setupDialog( isApplet );
 171 
 172         if(canDisplayCheck) {
 173             fireRangeChanged();
 174         }
 175     }
 176 
 177     /// Set up the main interface panel
 178     private void setupPanel() {
 179         GridBagLayout gbl = new GridBagLayout();
 180         GridBagConstraints gbc = new GridBagConstraints();
 181         gbc.fill = GridBagConstraints.HORIZONTAL;
 182         gbc.weightx = 1;
 183         gbc.insets = new Insets( 2, 0, 2, 2 );
 184         this.setLayout( gbl );
 185 
 186         addLabeledComponentToGBL( &quot;Font: &quot;, fontMenu, gbl, gbc, this );
 187         addLabeledComponentToGBL( &quot;Size: &quot;, sizeField, gbl, gbc, this );
 188         gbc.gridwidth = GridBagConstraints.REMAINDER;
 189         addLabeledComponentToGBL( &quot;Font Transform:&quot;,
 190                                   transformMenu, gbl, gbc, this );
 191         gbc.gridwidth = 1;
 192 
 193         addLabeledComponentToGBL( &quot;Range: &quot;, rm, gbl, gbc, this );
 194         addLabeledComponentToGBL( &quot;Style: &quot;, styleMenu, gbl, gbc, this );
 195         gbc.gridwidth = GridBagConstraints.REMAINDER;
 196         addLabeledComponentToGBL( &quot;Graphics Transform: &quot;,
 197                                   transformMenuG2, gbl, gbc, this );
 198         gbc.gridwidth = 1;
 199 
 200         gbc.anchor = GridBagConstraints.WEST;
 201         addLabeledComponentToGBL( &quot;Method: &quot;, methodsMenu, gbl, gbc, this );
 202         addLabeledComponentToGBL(&quot;&quot;, null, gbl, gbc, this);
 203         gbc.anchor = GridBagConstraints.EAST;
 204         gbc.gridwidth = GridBagConstraints.REMAINDER;
 205         addLabeledComponentToGBL( &quot;Text to use:&quot;, textMenu, gbl, gbc, this );
 206 
 207         gbc.weightx=1;
 208         gbc.gridwidth = 1;
 209         gbc.fill = GridBagConstraints.HORIZONTAL;
 210         gbc.anchor = GridBagConstraints.WEST;
 211         addLabeledComponentToGBL(&quot;LCD contrast: &quot;,
 212                                   contrastSlider, gbl, gbc, this);
 213 
 214         gbc.gridwidth = 1;
 215         gbc.fill = GridBagConstraints.NONE;
 216         addLabeledComponentToGBL(&quot;Antialiasing: &quot;,
 217                                   antiAliasMenu, gbl, gbc, this);
 218 
 219         gbc.anchor = GridBagConstraints.EAST;
 220         gbc.gridwidth = GridBagConstraints.REMAINDER;
 221         addLabeledComponentToGBL(&quot;Fractional metrics: &quot;,
 222                                   fracMetricsMenu, gbl, gbc, this);
 223 
 224         gbc.weightx = 1;
 225         gbc.weighty = 1;
 226         gbc.anchor = GridBagConstraints.WEST;
 227         gbc.insets = new Insets( 2, 0, 0, 2 );
 228         gbc.fill = GridBagConstraints.BOTH;
 229         gbl.setConstraints( fp, gbc );
 230         this.add( fp );
 231 
 232         gbc.weighty = 0;
 233         gbc.insets = new Insets( 0, 2, 0, 0 );
 234         gbl.setConstraints( statusBar, gbc );
 235         this.add( statusBar );
 236     }
 237 
 238     /// Adds a component to a container with a label to its left in GridBagLayout
 239     private void addLabeledComponentToGBL( String name,
 240                                            JComponent c,
 241                                            GridBagLayout gbl,
 242                                            GridBagConstraints gbc,
 243                                            Container target ) {
 244         LabelV2 l = new LabelV2( name );
 245         GridBagConstraints gbcLabel = (GridBagConstraints) gbc.clone();
 246         gbcLabel.insets = new Insets( 2, 2, 2, 0 );
 247         gbcLabel.gridwidth = 1;
 248         gbcLabel.weightx = 0;
 249 
 250         if ( c == null )
 251           c = new JLabel( &quot;&quot; );
 252 
 253         gbl.setConstraints( l, gbcLabel );
 254         target.add( l );
 255         gbl.setConstraints( c, gbc );
 256         target.add( c );
 257     }
 258 
 259     /// Sets up menu entries
 260     private void setupMenu( boolean isApplet ) {
 261         JMenu fileMenu = new JMenu( &quot;File&quot; );
 262         JMenu optionMenu = new JMenu( &quot;Option&quot; );
 263 
 264         fileMenu.add( new MenuItemV2( &quot;Save Selected Options...&quot;, this ));
 265         fileMenu.add( new MenuItemV2( &quot;Load Options...&quot;, this ));
 266         fileMenu.addSeparator();
 267         fileMenu.add( new MenuItemV2( &quot;Save as PNG...&quot;, this ));
 268         fileMenu.add( new MenuItemV2( &quot;Load PNG File to Compare...&quot;, this ));
 269         fileMenu.add( new MenuItemV2( &quot;Page Setup...&quot;, this ));
 270         fileMenu.add( new MenuItemV2( &quot;Print...&quot;, this ));
 271         fileMenu.addSeparator();
 272         if ( !isApplet )
 273           fileMenu.add( new MenuItemV2( &quot;Exit&quot;, this ));
 274         else
 275           fileMenu.add( new MenuItemV2( &quot;Close&quot;, this ));
 276 
 277         displayGridCBMI = new CheckboxMenuItemV2( &quot;Display Grid&quot;, true, this );
 278         force16ColsCBMI = new CheckboxMenuItemV2( &quot;Force 16 Columns&quot;, false, this );
 279         showFontInfoCBMI = new CheckboxMenuItemV2( &quot;Display Font Info&quot;, false, this );
 280         optionMenu.add( displayGridCBMI );
 281         optionMenu.add( force16ColsCBMI );
 282         optionMenu.add( showFontInfoCBMI );
 283 
 284         JMenuBar mb = parent.getJMenuBar();
 285         if ( mb == null )
 286           mb = new JMenuBar();
 287         mb.add( fileMenu );
 288         mb.add( optionMenu );
 289 
 290         parent.setJMenuBar( mb );
 291 
 292         String[] fontList =
 293           GraphicsEnvironment.getLocalGraphicsEnvironment().getAvailableFontFamilyNames();
 294 
 295         for ( int i = 0; i &lt; fontList.length; i++ )
 296           fontMenu.addItem( fontList[i] );
 297         fontMenu.setSelectedItem( &quot;Dialog&quot; );
 298 
 299         styleMenu.addItem( &quot;Plain&quot; );
 300         styleMenu.addItem( &quot;Bold&quot; );
 301         styleMenu.addItem( &quot;Italic&quot; );
 302         styleMenu.addItem( &quot;Bold Italic&quot; );
 303 
 304         transformMenu.addItem( &quot;None&quot; );
 305         transformMenu.addItem( &quot;Scale&quot; );
 306         transformMenu.addItem( &quot;Shear&quot; );
 307         transformMenu.addItem( &quot;Rotate&quot; );
 308 
 309         transformMenuG2.addItem( &quot;None&quot; );
 310         transformMenuG2.addItem( &quot;Scale&quot; );
 311         transformMenuG2.addItem( &quot;Shear&quot; );
 312         transformMenuG2.addItem( &quot;Rotate&quot; );
 313 
 314         methodsMenu.addItem( &quot;drawString&quot; );
 315         methodsMenu.addItem( &quot;drawChars&quot; );
 316         methodsMenu.addItem( &quot;drawBytes&quot; );
 317         methodsMenu.addItem( &quot;drawGlyphVector&quot; );
 318         methodsMenu.addItem( &quot;TextLayout.draw&quot; );
 319         methodsMenu.addItem( &quot;GlyphVector.getOutline + draw&quot; );
 320         methodsMenu.addItem( &quot;TextLayout.getOutline + draw&quot; );
 321 
 322         textMenu.addItem( &quot;Unicode Range&quot; );
 323         textMenu.addItem( &quot;All Glyphs&quot; );
 324         textMenu.addItem( &quot;User Text&quot; );
 325         textMenu.addItem( &quot;Text File&quot; );
 326         textMenu.addActionListener ( this ); // listener added later so unneeded events not thrown
 327     }
 328 
 329     /// Sets up the all dialogs used in Font2DTest...
 330     private void setupDialog( boolean isApplet ) {
 331         if (!isApplet)
 332                 filePromptDialog = new JFileChooser( );
 333         else
 334                 filePromptDialog = null;
 335 
 336         /// Prepare user text dialog...
 337         userTextDialog = new JDialog( parent, &quot;User Text&quot;, false );
 338         JPanel dialogTopPanel = new JPanel();
 339         JPanel dialogBottomPanel = new JPanel();
 340         LabelV2 message1 = new LabelV2( &quot;Enter text below and then press update&quot; );
 341         LabelV2 message2 = new LabelV2( &quot;(Unicode char can be denoted by \\uXXXX)&quot; );
 342         LabelV2 message3 = new LabelV2( &quot;(Supplementary chars can be denoted by \\UXXXXXX)&quot; );
 343         userTextArea = new JTextArea( &quot;Font2DTest!&quot; );
 344         ButtonV2 bUpdate = new ButtonV2( &quot;Update&quot;, this );
 345         userTextArea.setFont( new Font( &quot;dialog&quot;, Font.PLAIN, 12 ));
 346         dialogTopPanel.setLayout( new GridLayout( 3, 1 ));
 347         dialogTopPanel.add( message1 );
 348         dialogTopPanel.add( message2 );
 349         dialogTopPanel.add( message3 );
 350         dialogBottomPanel.add( bUpdate );
 351         //ABP
 352         JScrollPane userTextAreaSP = new JScrollPane(userTextArea);
 353         userTextAreaSP.setPreferredSize(new Dimension(300, 100));
 354 
 355         userTextDialog.getContentPane().setLayout( new BorderLayout() );
 356         userTextDialog.getContentPane().add( &quot;North&quot;, dialogTopPanel );
 357         userTextDialog.getContentPane().add( &quot;Center&quot;, userTextAreaSP );
 358         userTextDialog.getContentPane().add( &quot;South&quot;, dialogBottomPanel );
 359         userTextDialog.pack();
 360         userTextDialog.addWindowListener( new WindowAdapter() {
 361             public void windowClosing( WindowEvent e ) {
<a name="5" id="anc5"></a><span class="line-modified"> 362                 userTextDialog.hide();</span>
 363             }
 364         });
 365 
 366         /// Prepare printing dialog...
 367         printCBGroup = new ButtonGroup();
 368         printModeCBs[ fp.ONE_PAGE ] =
 369           new JRadioButton( &quot;Print one page from currently displayed character/line&quot;,
 370                          true );
 371         printModeCBs[ fp.CUR_RANGE ] =
 372           new JRadioButton( &quot;Print all characters in currently selected range&quot;,
 373                          false );
 374         printModeCBs[ fp.ALL_TEXT ] =
 375           new JRadioButton( &quot;Print all lines of text&quot;,
 376                          false );
 377         LabelV2 l =
 378           new LabelV2( &quot;Note: Page range in native \&quot;Print\&quot; dialog will not affect the result&quot; );
 379         JPanel buttonPanel = new JPanel();
 380         printModeCBs[ fp.ALL_TEXT ].setEnabled( false );
 381         buttonPanel.add( new ButtonV2( &quot;Print&quot;, this ));
 382         buttonPanel.add( new ButtonV2( &quot;Cancel&quot;, this ));
 383 
 384         printDialog = new JDialog( parent, &quot;Print...&quot;, true );
 385         printDialog.setResizable( false );
 386         printDialog.addWindowListener( new WindowAdapter() {
 387             public void windowClosing( WindowEvent e ) {
<a name="6" id="anc6"></a><span class="line-modified"> 388                 printDialog.hide();</span>
 389             }
 390         });
 391         printDialog.getContentPane().setLayout( new GridLayout( printModeCBs.length + 2, 1 ));
 392         printDialog.getContentPane().add( l );
 393         for ( int i = 0; i &lt; printModeCBs.length; i++ ) {
 394             printCBGroup.add( printModeCBs[i] );
 395             printDialog.getContentPane().add( printModeCBs[i] );
 396         }
 397         printDialog.getContentPane().add( buttonPanel );
 398         printDialog.pack();
 399 
 400         /// Prepare font information dialog...
 401         fontInfoDialog = new JDialog( parent, &quot;Font info&quot;, false );
 402         fontInfoDialog.setResizable( false );
 403         fontInfoDialog.addWindowListener( new WindowAdapter() {
 404             public void windowClosing( WindowEvent e ) {
<a name="7" id="anc7"></a><span class="line-modified"> 405                 fontInfoDialog.hide();</span>
 406                 showFontInfoCBMI.setState( false );
 407             }
 408         });
 409         JPanel fontInfoPanel = new JPanel();
 410         fontInfoPanel.setLayout( new GridLayout( fontInfos.length, 1 ));
 411         for ( int i = 0; i &lt; fontInfos.length; i++ ) {
 412             fontInfos[i] = new LabelV2(&quot;&quot;);
 413             fontInfoPanel.add( fontInfos[i] );
 414         }
 415         fontInfoDialog.getContentPane().add( fontInfoPanel );
 416 
 417         /// Move the location of the dialog...
 418         userTextDialog.setLocation( 200, 300 );
 419         fontInfoDialog.setLocation( 0, 400 );
 420     }
 421 
 422     /// RangeMenu object signals using this function
 423     /// when Unicode range has been changed and text needs to be redrawn
 424     public void fireRangeChanged() {
 425         int[] range = rm.getSelectedRange();
 426         fp.setTextToDraw( fp.RANGE_TEXT, range, null, null );
 427         if(canDisplayCheck) {
 428             setupFontList(range[0], range[1]);
 429         }
 430         if ( showFontInfoCBMI.getState() )
 431           fireUpdateFontInfo();
 432     }
 433 
 434     /// Changes the message on the status bar
 435     public void fireChangeStatus( String message, boolean error ) {
 436         /// If this is not ran as an applet, use own status bar,
 437         /// Otherwise, use the appletviewer/browser&#39;s status bar
 438         statusBar.setText( message );
 439         if ( error )
 440           fp.showingError = true;
 441         else
 442           fp.showingError = false;
 443     }
 444 
 445     /// Updates the information about the selected font
 446     public void fireUpdateFontInfo() {
 447         if ( showFontInfoCBMI.getState() ) {
 448             String[] infos = fp.getFontInfo();
 449             for ( int i = 0; i &lt; fontInfos.length; i++ )
 450               fontInfos[i].setText( infos[i] );
 451             fontInfoDialog.pack();
 452         }
 453     }
 454 
 455     private void setupFontList(int rangeStart, int rangeEnd) {
 456 
 457         int listCount = fontMenu.getItemCount();
 458         int size = 16;
 459 
 460         try {
 461             size =  Float.valueOf(sizeField.getText()).intValue();
 462         }
 463         catch ( Exception e ) {
 464             System.out.println(&quot;Invalid font size in the size textField. Using default value of 16&quot;);
 465         }
 466 
 467         int style = fontStyles[styleMenu.getSelectedIndex()];
 468         Font f;
 469         for (int i = 0; i &lt; listCount; i++) {
<a name="8" id="anc8"></a><span class="line-modified"> 470             String fontName = (String)fontMenu.getItemAt(i);</span>
 471             f = new Font(fontName, style, size);
 472             if ((rm.getSelectedIndex() != RangeMenu.SURROGATES_AREA_INDEX) &amp;&amp;
 473                 canDisplayRange(f, rangeStart, rangeEnd)) {
 474                 fontMenu.setBit(i, true);
 475             }
 476             else {
 477                 fontMenu.setBit(i, false);
 478             }
 479         }
 480 
 481         fontMenu.repaint();
 482     }
 483 
 484     protected boolean canDisplayRange(Font font, int rangeStart, int rangeEnd) {
 485         for (int i = rangeStart; i &lt; rangeEnd; i++) {
 486             if (font.canDisplay(i)) {
 487                 return true;
 488             }
 489         }
 490         return false;
 491     }
 492 
 493     /// Displays a file load/save dialog and returns the specified file
 494     private String promptFile( boolean isSave, String initFileName ) {
 495         int retVal;
 496         String str;
 497 
 498         /// ABP
 499         if ( filePromptDialog == null)
 500                 return null;
 501 
 502         if ( isSave ) {
 503             filePromptDialog.setDialogType( JFileChooser.SAVE_DIALOG );
 504             filePromptDialog.setDialogTitle( &quot;Save...&quot; );
 505             str = &quot;Save&quot;;
 506 
 507 
 508         }
 509         else {
 510             filePromptDialog.setDialogType( JFileChooser.OPEN_DIALOG );
 511             filePromptDialog.setDialogTitle( &quot;Load...&quot; );
 512             str = &quot;Load&quot;;
 513         }
 514 
 515         if (initFileName != null)
 516                 filePromptDialog.setSelectedFile( new File( initFileName ) );
 517         retVal = filePromptDialog.showDialog( this, str );
 518 
 519         if ( retVal == JFileChooser.APPROVE_OPTION ) {
 520                 File file = filePromptDialog.getSelectedFile();
 521                 String fileName = file.getAbsolutePath();
 522                 if ( fileName != null ) {
 523                         return fileName;
 524                 }
 525         }
 526 
 527         return null;
 528     }
 529 
 530     /// Converts user text into arrays of String, delimited at newline character
 531     /// Also replaces any valid escape sequence with appropriate unicode character
 532     /// Support \\UXXXXXX notation for surrogates
 533     private String[] parseUserText( String orig ) {
 534         int length = orig.length();
 535         StringTokenizer perLine = new StringTokenizer( orig, &quot;\n&quot; );
 536         String[] textLines = new String[ perLine.countTokens() ];
 537         int lineNumber = 0;
 538 
 539         while ( perLine.hasMoreElements() ) {
 540             StringBuffer converted = new StringBuffer();
 541             String oneLine = perLine.nextToken();
 542             int lineLength = oneLine.length();
 543             int prevEscapeEnd = 0;
 544             int nextEscape = -1;
 545             do {
 546                 int nextBMPEscape = oneLine.indexOf( &quot;\\u&quot;, prevEscapeEnd );
 547                 int nextSupEscape = oneLine.indexOf( &quot;\\U&quot;, prevEscapeEnd );
 548                 nextEscape = (nextBMPEscape &lt; 0)
 549                     ? ((nextSupEscape &lt; 0)
 550                        ? -1
 551                        : nextSupEscape)
 552                     : ((nextSupEscape &lt; 0)
 553                        ? nextBMPEscape
 554                        : Math.min(nextBMPEscape, nextSupEscape));
 555 
 556                 if ( nextEscape != -1 ) {
 557                     if ( prevEscapeEnd &lt; nextEscape )
 558                         converted.append( oneLine.substring( prevEscapeEnd, nextEscape ));
 559 
 560                     prevEscapeEnd = nextEscape + (nextEscape == nextBMPEscape ? 6 : 8);
 561                     try {
 562                         String hex = oneLine.substring( nextEscape + 2, prevEscapeEnd );
 563                         if (nextEscape == nextBMPEscape) {
 564                             converted.append( (char) Integer.parseInt( hex, 16 ));
 565                         } else {
 566                             converted.append( new String( Character.toChars( Integer.parseInt( hex, 16 ))));
 567                         }
 568                     }
 569                     catch ( Exception e ) {
 570                         int copyLimit = Math.min(lineLength, prevEscapeEnd);
 571                         converted.append( oneLine.substring( nextEscape, copyLimit ));
 572                     }
 573                 }
 574             } while (nextEscape != -1);
 575             if ( prevEscapeEnd &lt; lineLength )
 576               converted.append( oneLine.substring( prevEscapeEnd, lineLength ));
 577             textLines[ lineNumber++ ] = converted.toString();
 578         }
 579         return textLines;
 580     }
 581 
 582     /// Reads the text from specified file, detecting UTF-16 encoding
 583     /// Then breaks the text into String array, delimited at every line break
 584     private void readTextFile( String fileName ) {
 585         try {
 586             String fileText;
 587             String[] textLines;
 588             BufferedInputStream bis =
 589               new BufferedInputStream( new FileInputStream( fileName ));
 590             int numBytes = bis.available();
 591             if (numBytes == 0) {
 592                 throw new Exception(&quot;Text file &quot; + fileName + &quot; is empty&quot;);
 593             }
 594             byte[] byteData = new byte[ numBytes ];
 595             bis.read( byteData, 0, numBytes );
 596             bis.close();
 597 
 598             /// If byte mark is found, then use UTF-16 encoding to convert bytes...
 599             if (numBytes &gt;= 2 &amp;&amp;
 600                 (( byteData[0] == (byte) 0xFF &amp;&amp; byteData[1] == (byte) 0xFE ) ||
 601                  ( byteData[0] == (byte) 0xFE &amp;&amp; byteData[1] == (byte) 0xFF )))
 602               fileText = new String( byteData, &quot;UTF-16&quot; );
 603             /// Otherwise, use system default encoding
 604             else
 605               fileText = new String( byteData );
 606 
 607             int length = fileText.length();
 608             StringTokenizer perLine = new StringTokenizer( fileText, &quot;\n&quot; );
 609             /// Determine &quot;Return Char&quot; used in this file
 610             /// This simply finds first occurrence of CR, CR+LF or LF...
 611             for ( int i = 0; i &lt; length; i++ ) {
 612                 char iTh = fileText.charAt( i );
 613                 if ( iTh == &#39;\r&#39; ) {
 614                     if ( i &lt; length - 1 &amp;&amp; fileText.charAt( i + 1 ) == &#39;\n&#39; )
 615                       perLine = new StringTokenizer( fileText, &quot;\r\n&quot; );
 616                     else
 617                       perLine = new StringTokenizer( fileText, &quot;\r&quot; );
 618                     break;
 619                 }
 620                 else if ( iTh == &#39;\n&#39; )
 621                   /// Use the one already created
 622                   break;
 623             }
 624             int lineNumber = 0, numLines = perLine.countTokens();
 625             textLines = new String[ numLines ];
 626 
 627             while ( perLine.hasMoreElements() ) {
 628                 String oneLine = perLine.nextToken();
 629                 if ( oneLine == null )
 630                   /// To make LineBreakMeasurer to return a valid TextLayout
 631                   /// on an empty line, simply feed it a space char...
 632                   oneLine = &quot; &quot;;
 633                 textLines[ lineNumber++ ] = oneLine;
 634             }
 635             fp.setTextToDraw( fp.FILE_TEXT, null, null, textLines );
 636             rm.setEnabled( false );
 637             methodsMenu.setEnabled( false );
 638         }
 639         catch ( Exception ex ) {
 640             fireChangeStatus( &quot;ERROR: Failed to Read Text File; See Stack Trace&quot;, true );
 641             ex.printStackTrace();
 642         }
 643     }
 644 
 645     /// Returns a String storing current configuration
 646     private void writeCurrentOptions( String fileName ) {
 647         try {
 648             String curOptions = fp.getCurrentOptions();
 649             BufferedOutputStream bos =
 650               new BufferedOutputStream( new FileOutputStream( fileName ));
 651             /// Prepend title and the option that is only obtainable here
 652             int[] range = rm.getSelectedRange();
 653             String completeOptions =
 654               ( &quot;Font2DTest Option File\n&quot; +
 655                 displayGridCBMI.getState() + &quot;\n&quot; +
 656                 force16ColsCBMI.getState() + &quot;\n&quot; +
 657                 showFontInfoCBMI.getState() + &quot;\n&quot; +
 658                 rm.getSelectedItem() + &quot;\n&quot; +
 659                 range[0] + &quot;\n&quot; + range[1] + &quot;\n&quot; + curOptions + tFileName);
 660             byte[] toBeWritten = completeOptions.getBytes( &quot;UTF-16&quot; );
 661             bos.write( toBeWritten, 0, toBeWritten.length );
 662             bos.close();
 663         }
 664         catch ( Exception ex ) {
 665             fireChangeStatus( &quot;ERROR: Failed to Save Options File; See Stack Trace&quot;, true );
 666             ex.printStackTrace();
 667         }
 668     }
 669 
 670     /// Updates GUI visibility/status after some parameters have changed
 671     private void updateGUI() {
 672         int selectedText = textMenu.getSelectedIndex();
 673 
 674         /// Set the visibility of User Text dialog
 675         if ( selectedText == fp.USER_TEXT )
<a name="9" id="anc9"></a><span class="line-modified"> 676           userTextDialog.show();</span>
 677         else
<a name="10" id="anc10"></a><span class="line-modified"> 678           userTextDialog.hide();</span>
 679         /// Change the visibility/status/availability of Print JDialog buttons
 680         printModeCBs[ fp.ONE_PAGE ].setSelected( true );
 681         if ( selectedText == fp.FILE_TEXT || selectedText == fp.USER_TEXT ) {
 682             /// ABP
 683             /// update methodsMenu to show that TextLayout.draw is being used
 684             /// when we are in FILE_TEXT mode
 685             if ( selectedText == fp.FILE_TEXT )
 686                 methodsMenu.setSelectedItem(&quot;TextLayout.draw&quot;);
 687             methodsMenu.setEnabled( selectedText == fp.USER_TEXT );
 688             printModeCBs[ fp.CUR_RANGE ].setEnabled( false );
 689             printModeCBs[ fp.ALL_TEXT ].setEnabled( true );
 690         }
 691         else {
 692             /// ABP
 693             /// update methodsMenu to show that drawGlyph is being used
 694             /// when we are in ALL_GLYPHS mode
 695             if ( selectedText == fp.ALL_GLYPHS )
 696                 methodsMenu.setSelectedItem(&quot;drawGlyphVector&quot;);
 697             methodsMenu.setEnabled( selectedText == fp.RANGE_TEXT );
 698             printModeCBs[ fp.CUR_RANGE ].setEnabled( true );
 699             printModeCBs[ fp.ALL_TEXT ].setEnabled( false );
 700         }
 701         /// Modify RangeMenu and fontInfo label availabilty
 702         if ( selectedText == fp.RANGE_TEXT ) {
 703             fontInfos[1].setVisible( true );
 704             rm.setEnabled( true );
 705         }
 706         else {
 707             fontInfos[1].setVisible( false );
 708             rm.setEnabled( false );
 709         }
 710     }
 711 
 712     /// Loads saved options and applies them
 713     private void loadOptions( String fileName ) {
 714         try {
 715             BufferedInputStream bis =
 716               new BufferedInputStream( new FileInputStream( fileName ));
 717             int numBytes = bis.available();
 718             byte[] byteData = new byte[ numBytes ];
 719             bis.read( byteData, 0, numBytes );
 720             bis.close();
 721             if ( numBytes &lt; 2 ||
 722                 (byteData[0] != (byte) 0xFE || byteData[1] != (byte) 0xFF) )
 723               throw new Exception( &quot;Not a Font2DTest options file&quot; );
 724 
 725             String options = new String( byteData, &quot;UTF-16&quot; );
 726             StringTokenizer perLine = new StringTokenizer( options, &quot;\n&quot; );
 727             String title = perLine.nextToken();
 728             if ( !title.equals( &quot;Font2DTest Option File&quot; ))
 729               throw new Exception( &quot;Not a Font2DTest options file&quot; );
 730 
 731             /// Parse all options
 732             boolean displayGridOpt = Boolean.parseBoolean( perLine.nextToken() );
 733             boolean force16ColsOpt = Boolean.parseBoolean( perLine.nextToken() );
 734             boolean showFontInfoOpt = Boolean.parseBoolean( perLine.nextToken() );
 735             String rangeNameOpt = perLine.nextToken();
 736             int rangeStartOpt = Integer.parseInt( perLine.nextToken() );
 737             int rangeEndOpt = Integer.parseInt( perLine.nextToken() );
 738             String fontNameOpt = perLine.nextToken();
 739             float fontSizeOpt = Float.parseFloat( perLine.nextToken() );
 740             int fontStyleOpt = Integer.parseInt( perLine.nextToken() );
 741             int fontTransformOpt = Integer.parseInt( perLine.nextToken() );
 742             int g2TransformOpt = Integer.parseInt( perLine.nextToken() );
 743             int textToUseOpt = Integer.parseInt( perLine.nextToken() );
 744             int drawMethodOpt = Integer.parseInt( perLine.nextToken() );
 745             int antialiasOpt = Integer.parseInt(perLine.nextToken());
 746             int fractionalOpt = Integer.parseInt(perLine.nextToken());
 747             int lcdContrast = Integer.parseInt(perLine.nextToken());
 748             String[] userTextOpt = { &quot;Font2DTest!&quot; };
 749             String dialogEntry = &quot;Font2DTest!&quot;;
 750             if (textToUseOpt == fp.USER_TEXT )  {
 751                 int numLines = perLine.countTokens(), lineNumber = 0;
 752                 if ( numLines != 0 ) {
 753                     userTextOpt = new String[ numLines ];
 754                     dialogEntry = &quot;&quot;;
 755                     for ( ; perLine.hasMoreElements(); lineNumber++ ) {
 756                         userTextOpt[ lineNumber ] = perLine.nextToken();
 757                         dialogEntry += userTextOpt[ lineNumber ] + &quot;\n&quot;;
 758                     }
 759                 }
 760             }
 761 
 762             /// Reset GUIs
 763             displayGridCBMI.setState( displayGridOpt );
 764             force16ColsCBMI.setState( force16ColsOpt );
 765             showFontInfoCBMI.setState( showFontInfoOpt );
 766             rm.setSelectedRange( rangeNameOpt, rangeStartOpt, rangeEndOpt );
 767             fontMenu.setSelectedItem( fontNameOpt );
 768             sizeField.setText( String.valueOf( fontSizeOpt ));
 769             styleMenu.setSelectedIndex( fontStyleOpt );
 770             transformMenu.setSelectedIndex( fontTransformOpt );
 771             transformMenuG2.setSelectedIndex( g2TransformOpt );
 772             textMenu.setSelectedIndex( textToUseOpt );
 773             methodsMenu.setSelectedIndex( drawMethodOpt );
 774             antiAliasMenu.setSelectedIndex( antialiasOpt );
 775             fracMetricsMenu.setSelectedIndex( fractionalOpt );
 776             contrastSlider.setValue(lcdContrast);
 777 
 778             userTextArea.setText( dialogEntry );
 779             updateGUI();
 780 
 781             if ( textToUseOpt == fp.FILE_TEXT ) {
 782               tFileName = perLine.nextToken();
 783               readTextFile(tFileName );
 784             }
 785 
 786             /// Reset option variables and repaint
 787             fp.loadOptions( displayGridOpt, force16ColsOpt,
 788                             rangeStartOpt, rangeEndOpt,
 789                             fontNameOpt, fontSizeOpt,
 790                             fontStyleOpt, fontTransformOpt, g2TransformOpt,
 791                             textToUseOpt, drawMethodOpt,
 792                             antialiasOpt, fractionalOpt,
 793                             lcdContrast, userTextOpt );
 794             if ( showFontInfoOpt ) {
 795                 fireUpdateFontInfo();
<a name="11" id="anc11"></a><span class="line-modified"> 796                 fontInfoDialog.show();</span>
 797             }
 798             else
<a name="12" id="anc12"></a><span class="line-modified"> 799               fontInfoDialog.hide();</span>
 800         }
 801         catch ( Exception ex ) {
 802             fireChangeStatus( &quot;ERROR: Failed to Load Options File; See Stack Trace&quot;, true );
 803             ex.printStackTrace();
 804         }
 805     }
 806 
 807     /// Loads a previously saved image
 808     private void loadComparisonPNG( String fileName ) {
 809         try {
 810             BufferedImage image =
 811                 javax.imageio.ImageIO.read(new File(fileName));
 812             JFrame f = new JFrame( &quot;Comparison PNG&quot; );
 813             ImagePanel ip = new ImagePanel( image );
 814             f.setResizable( false );
 815             f.getContentPane().add( ip );
 816             f.addWindowListener( new WindowAdapter() {
 817                 public void windowClosing( WindowEvent e ) {
 818                     ( (JFrame) e.getSource() ).dispose();
 819                 }
 820             });
 821             f.pack();
<a name="13" id="anc13"></a><span class="line-modified"> 822             f.show();</span>
 823         }
 824         catch ( Exception ex ) {
 825             fireChangeStatus( &quot;ERROR: Failed to Load PNG File; See Stack Trace&quot;, true );
 826             ex.printStackTrace();
 827         }
 828     }
 829 
 830     /// Interface functions...
 831 
 832     /// ActionListener interface function
 833     /// Responds to JMenuItem, JTextField and JButton actions
 834     public void actionPerformed( ActionEvent e ) {
 835         Object source = e.getSource();
 836 
 837         if ( source instanceof JMenuItem ) {
 838             JMenuItem mi = (JMenuItem) source;
 839             String itemName = mi.getText();
 840 
 841             if ( itemName.equals( &quot;Save Selected Options...&quot; )) {
 842                 String fileName = promptFile( true, &quot;options.txt&quot; );
 843                 if ( fileName != null )
 844                   writeCurrentOptions( fileName );
 845             }
 846             else if ( itemName.equals( &quot;Load Options...&quot; )) {
 847                 String fileName = promptFile( false, &quot;options.txt&quot; );
 848                 if ( fileName != null )
 849                   loadOptions( fileName );
 850             }
 851             else if ( itemName.equals( &quot;Save as PNG...&quot; )) {
 852                 String fileName = promptFile( true, fontMenu.getSelectedItem() + &quot;.png&quot; );
 853                 if ( fileName != null )
 854                   fp.doSavePNG( fileName );
 855             }
 856             else if ( itemName.equals( &quot;Load PNG File to Compare...&quot; )) {
 857                 String fileName = promptFile( false, null );
 858                 if ( fileName != null )
 859                   loadComparisonPNG( fileName );
 860             }
 861             else if ( itemName.equals( &quot;Page Setup...&quot; ))
 862               fp.doPageSetup();
 863             else if ( itemName.equals( &quot;Print...&quot; ))
<a name="14" id="anc14"></a><span class="line-modified"> 864               printDialog.show();</span>
 865             else if ( itemName.equals( &quot;Close&quot; ))
 866               parent.dispose();
 867             else if ( itemName.equals( &quot;Exit&quot; ))
 868               System.exit(0);
 869         }
 870 
 871         else if ( source instanceof JTextField ) {
 872             JTextField tf = (JTextField) source;
 873             float sz = 12f;
 874             try {
 875                  sz = Float.parseFloat(sizeField.getText());
 876                  if (sz &lt; 1f || sz &gt; 120f) {
 877                       sz = 12f;
 878                       sizeField.setText(&quot;12&quot;);
 879                  }
 880             } catch (Exception se) {
 881                  sizeField.setText(&quot;12&quot;);
 882             }
 883             if ( tf == sizeField )
 884               fp.setFontParams( fontMenu.getSelectedItem(),
 885                                 sz,
 886                                 styleMenu.getSelectedIndex(),
 887                                 transformMenu.getSelectedIndex() );
 888         }
 889 
 890         else if ( source instanceof JButton ) {
 891             String itemName = ( (JButton) source ).getText();
 892             /// Print dialog buttons...
 893             if ( itemName.equals( &quot;Print&quot; )) {
 894                 for ( int i = 0; i &lt; printModeCBs.length; i++ )
 895                   if ( printModeCBs[i].isSelected() ) {
<a name="15" id="anc15"></a><span class="line-modified"> 896                       printDialog.hide();</span>
 897                       fp.doPrint( i );
 898                   }
 899             }
 900             else if ( itemName.equals( &quot;Cancel&quot; ))
<a name="16" id="anc16"></a><span class="line-modified"> 901               printDialog.hide();</span>
 902             /// Update button from Usert Text JDialog...
 903             else if ( itemName.equals( &quot;Update&quot; ))
 904               fp.setTextToDraw( fp.USER_TEXT, null,
 905                                 parseUserText( userTextArea.getText() ), null );
 906         }
 907         else if ( source instanceof JComboBox ) {
<a name="17" id="anc17"></a><span class="line-modified"> 908             JComboBox c = (JComboBox) source;</span>
 909 
 910             /// RangeMenu handles actions by itself and then calls fireRangeChanged,
 911             /// so it is not listed or handled here
 912             if ( c == fontMenu || c == styleMenu || c == transformMenu ) {
 913                 float sz = 12f;
 914                 try {
 915                     sz = Float.parseFloat(sizeField.getText());
 916                     if (sz &lt; 1f || sz &gt; 120f) {
 917                         sz = 12f;
 918                         sizeField.setText(&quot;12&quot;);
 919                     }
 920                 } catch (Exception se) {
 921                     sizeField.setText(&quot;12&quot;);
 922                 }
 923                 fp.setFontParams(fontMenu.getSelectedItem(),
 924                                  sz,
 925                                  styleMenu.getSelectedIndex(),
 926                                  transformMenu.getSelectedIndex());
 927             } else if ( c == methodsMenu )
 928               fp.setDrawMethod( methodsMenu.getSelectedIndex() );
 929             else if ( c == textMenu ) {
 930 
 931                 if(canDisplayCheck) {
 932                     fireRangeChanged();
 933                 }
 934 
 935                 int selected = textMenu.getSelectedIndex();
 936 
 937                 if ( selected == fp.RANGE_TEXT )
 938                   fp.setTextToDraw( fp.RANGE_TEXT, rm.getSelectedRange(),
 939                                     null, null );
 940                 else if ( selected == fp.USER_TEXT )
 941                   fp.setTextToDraw( fp.USER_TEXT, null,
 942                                     parseUserText( userTextArea.getText() ), null );
 943                 else if ( selected == fp.FILE_TEXT ) {
 944                     String fileName = promptFile( false, null );
 945                     if ( fileName != null ) {
 946                       tFileName = fileName;
 947                       readTextFile( fileName );
 948                     } else {
 949                         /// User cancelled selection; reset to previous choice
 950                         c.setSelectedIndex( currentTextChoice );
 951                         return;
 952                     }
 953                 }
 954                 else if ( selected == fp.ALL_GLYPHS )
 955                   fp.setTextToDraw( fp.ALL_GLYPHS, null, null, null );
 956 
 957                 updateGUI();
 958                 currentTextChoice = selected;
 959             }
 960             else if ( c == transformMenuG2 ) {
 961                 fp.setTransformG2( transformMenuG2.getSelectedIndex() );
 962             }
 963             else if (c == antiAliasMenu || c == fracMetricsMenu) {
 964                 if (c == antiAliasMenu) {
 965                     boolean enabled = FontPanel.AAValues.
 966                         isLCDMode(antiAliasMenu.getSelectedItem());
 967                         contrastSlider.setEnabled(enabled);
 968                 }
 969                 fp.setRenderingHints(antiAliasMenu.getSelectedItem(),
 970                                      fracMetricsMenu.getSelectedItem(),
 971                                      contrastSlider.getValue());
 972             }
 973         }
 974     }
 975 
 976     public void stateChanged(ChangeEvent e) {
 977          Object source = e.getSource();
 978          if (source instanceof JSlider) {
 979              fp.setRenderingHints(antiAliasMenu.getSelectedItem(),
 980                                   fracMetricsMenu.getSelectedItem(),
 981                                   contrastSlider.getValue());
 982          }
 983     }
 984 
 985     /// ItemListener interface function
 986     /// Responds to JCheckBoxMenuItem, JComboBox and JCheckBox actions
 987     public void itemStateChanged( ItemEvent e ) {
 988         Object source = e.getSource();
 989 
 990         if ( source instanceof JCheckBoxMenuItem ) {
 991             JCheckBoxMenuItem cbmi = (JCheckBoxMenuItem) source;
 992             if ( cbmi == displayGridCBMI )
 993               fp.setGridDisplay( displayGridCBMI.getState() );
 994             else if ( cbmi == force16ColsCBMI )
 995               fp.setForce16Columns( force16ColsCBMI.getState() );
 996             else if ( cbmi == showFontInfoCBMI ) {
 997                 if ( showFontInfoCBMI.getState() ) {
 998                     fireUpdateFontInfo();
<a name="18" id="anc18"></a><span class="line-modified"> 999                     fontInfoDialog.show();</span>
1000                 }
1001                 else
<a name="19" id="anc19"></a><span class="line-modified">1002                   fontInfoDialog.hide();</span>
1003             }
1004         }
1005     }
1006 
1007     private static void printUsage() {
1008         String usage = &quot;Usage: java -jar Font2DTest.jar [options]\n&quot; +
1009             &quot;\nwhere options include:\n&quot; +
1010             &quot;    -dcdc | -disablecandisplaycheck disable canDisplay check for font\n&quot; +
1011             &quot;    -?    | -help                   print this help message\n&quot; +
1012             &quot;\nExample :\n&quot; +
1013             &quot;     To disable canDisplay check on font for ranges\n&quot; +
1014             &quot;     java -jar Font2DTest.jar -dcdc&quot;;
1015         System.out.println(usage);
1016         System.exit(0);
1017     }
1018 
1019     /// Main function
1020     public static void main(String[] argv) {
1021 
1022         if(argv.length &gt; 0) {
1023             if(argv[0].equalsIgnoreCase(&quot;-disablecandisplaycheck&quot;) ||
1024                argv[0].equalsIgnoreCase(&quot;-dcdc&quot;)) {
1025                 canDisplayCheck = false;
1026             }
1027             else {
1028                 printUsage();
1029             }
1030         }
1031 
1032         UIManager.put(&quot;swing.boldMetal&quot;, Boolean.FALSE);
1033         final JFrame f = new JFrame( &quot;Font2DTest&quot; );
1034         final Font2DTest f2dt = new Font2DTest( f, false );
1035         f.addWindowListener( new WindowAdapter() {
1036             public void windowOpening( WindowEvent e ) { f2dt.repaint(); }
1037             public void windowClosing( WindowEvent e ) { System.exit(0); }
1038         });
1039 
1040         f.getContentPane().add( f2dt );
1041         f.pack();
<a name="20" id="anc20"></a><span class="line-modified">1042         f.show();</span>
1043     }
1044 
1045     /// Inner class definitions...
1046 
1047     /// Class to display just an image file
1048     /// Used to show the comparison PNG image
1049     private final class ImagePanel extends JPanel {
1050         private final BufferedImage bi;
1051 
1052         public ImagePanel( BufferedImage image ) {
1053             bi = image;
1054         }
1055 
1056         public Dimension getPreferredSize() {
1057             return new Dimension( bi.getWidth(), bi.getHeight() );
1058         }
1059 
1060         public void paintComponent( Graphics g ) {
1061             g.drawImage( bi, 0, 0, this );
1062         }
1063     }
1064 
1065     /// Classes made to avoid repetitive calls... (being lazy)
1066     private final class ButtonV2 extends JButton {
1067         public ButtonV2( String name, ActionListener al ) {
1068             super( name );
1069             this.addActionListener( al );
1070         }
1071     }
1072 
<a name="21" id="anc21"></a><span class="line-modified">1073     private final class ChoiceV2 extends JComboBox {</span>
1074 
1075         private BitSet bitSet = null;
1076 
1077         public ChoiceV2() {;}
1078 
1079         public ChoiceV2( ActionListener al ) {
1080             super();
1081             this.addActionListener( al );
1082         }
1083 
1084         public ChoiceV2( ActionListener al, boolean fontChoice) {
1085             this(al);
1086             if(fontChoice) {
1087                 //Register this component in ToolTipManager
1088                 setToolTipText(&quot;&quot;);
1089                 bitSet = new BitSet();
1090                 setRenderer(new ChoiceV2Renderer(this));
1091             }
1092         }
1093 
1094         public String getToolTipText() {
1095             int index = this.getSelectedIndex();
1096             String fontName = (String) this.getSelectedItem();
1097             if(fontName != null &amp;&amp;
1098                (textMenu.getSelectedIndex() == fp.RANGE_TEXT)) {
1099                 if (getBit(index)) {
1100                     return &quot;Font \&quot;&quot; + fontName + &quot;\&quot; can display some characters in \&quot;&quot; +
1101                         rm.getSelectedItem() + &quot;\&quot; range&quot;;
1102                 }
1103                 else {
1104                     return &quot;Font \&quot;&quot; + fontName + &quot;\&quot; cannot display any characters in \&quot;&quot; +
1105                         rm.getSelectedItem() + &quot;\&quot; range&quot;;
1106                 }
1107             }
1108             return super.getToolTipText();
1109         }
1110 
1111         public void setBit(int bitIndex, boolean value) {
1112             bitSet.set(bitIndex, value);
1113         }
1114 
1115         public boolean getBit(int bitIndex) {
1116             return bitSet.get(bitIndex);
1117         }
1118     }
1119 
1120     private final class ChoiceV2Renderer extends DefaultListCellRenderer {
1121 
1122         private ImageIcon yesImage, blankImage;
1123         private ChoiceV2 choice = null;
1124 
1125         public ChoiceV2Renderer(ChoiceV2 choice) {
1126             BufferedImage yes =
1127                 new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);
1128             Graphics2D g = yes.createGraphics();
1129             g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
1130                                RenderingHints.VALUE_ANTIALIAS_ON);
1131             g.setColor(Color.BLUE);
1132             g.drawLine(0, 5, 3, 10);
1133             g.drawLine(1, 5, 4, 10);
1134             g.drawLine(3, 10, 10, 0);
1135             g.drawLine(4, 9, 9, 0);
1136             g.dispose();
1137             BufferedImage blank =
1138                 new BufferedImage(10, 10, BufferedImage.TYPE_INT_ARGB);
1139             yesImage = new ImageIcon(yes);
1140             blankImage = new ImageIcon(blank);
1141             this.choice = choice;
1142         }
1143 
<a name="22" id="anc22"></a><span class="line-modified">1144         public Component getListCellRendererComponent(JList list,</span>
1145                                                       Object value,
1146                                                       int index,
1147                                                       boolean isSelected,
1148                                                       boolean cellHasFocus) {
1149 
1150             if(textMenu.getSelectedIndex() == fp.RANGE_TEXT) {
1151 
1152                 super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
1153 
1154                 //For JComboBox if index is -1, its rendering the selected index.
1155                 if(index == -1) {
1156                     index = choice.getSelectedIndex();
1157                 }
1158 
1159                 if(choice.getBit(index)) {
1160                     setIcon(yesImage);
1161                 }
1162                 else {
1163                     setIcon(blankImage);
1164                 }
1165 
1166             } else {
1167                 super.getListCellRendererComponent(list, value, index, isSelected, cellHasFocus);
1168                 setIcon(blankImage);
1169             }
1170 
1171             return this;
1172         }
1173     }
1174 
1175     private final class LabelV2 extends JLabel {
1176         public LabelV2( String name ) {
1177             super( name );
1178         }
1179     }
1180 
1181     private final class MenuItemV2 extends JMenuItem {
1182         public MenuItemV2( String name, ActionListener al ) {
1183             super( name );
1184             this.addActionListener( al );
1185         }
1186     }
1187 
1188     private final class CheckboxMenuItemV2 extends JCheckBoxMenuItem {
1189         public CheckboxMenuItemV2( String name, boolean b, ItemListener il ) {
1190             super( name, b );
1191             this.addItemListener( il );
1192         }
1193     }
1194 }
<a name="23" id="anc23"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="23" type="hidden" />
</body>
</html>
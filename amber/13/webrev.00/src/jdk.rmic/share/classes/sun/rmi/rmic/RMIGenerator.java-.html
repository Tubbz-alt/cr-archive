<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.rmic/share/classes/sun/rmi/rmic/RMIGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*****************************************************************************/
  27 /*                    Copyright (c) IBM Corporation 1998                     */
  28 /*                                                                           */
  29 /* (C) Copyright IBM Corp. 1998                                              */
  30 /*                                                                           */
  31 /*****************************************************************************/
  32 
  33 package sun.rmi.rmic;
  34 
  35 import java.io.File;
  36 import java.io.FileOutputStream;
  37 import java.io.OutputStreamWriter;
  38 import java.io.IOException;
  39 import java.util.Enumeration;
  40 import java.util.Hashtable;
  41 import java.util.Vector;
  42 import sun.tools.java.Type;
  43 import sun.tools.java.Identifier;
  44 import sun.tools.java.ClassDefinition;
  45 import sun.tools.java.ClassDeclaration;
  46 import sun.tools.java.ClassNotFound;
  47 import sun.tools.java.ClassFile;
  48 import sun.tools.java.MemberDefinition;
  49 
  50 /**
  51  * A Generator object will generate the Java source code of the stub
  52  * and skeleton classes for an RMI remote implementation class, using
  53  * a particular stub protocol version.
  54  *
  55  * WARNING: The contents of this source file are not part of any
  56  * supported API.  Code that depends on them does so at its own risk:
  57  * they are subject to change or removal without notice.
  58  *
  59  * @author      Peter Jones,  Bryan Atsatt
  60  */
  61 public class RMIGenerator implements RMIConstants, Generator {
  62 
  63     private static final Hashtable&lt;String, Integer&gt; versionOptions = new Hashtable&lt;&gt;();
  64     static {
  65         versionOptions.put(&quot;-v1.1&quot;, STUB_VERSION_1_1);
  66         versionOptions.put(&quot;-vcompat&quot;, STUB_VERSION_FAT);
  67         versionOptions.put(&quot;-v1.2&quot;, STUB_VERSION_1_2);
  68     }
  69 
  70     /**
  71      * Default constructor for Main to use.
  72      */
  73     public RMIGenerator() {
  74         version = STUB_VERSION_1_2;     // default is -v1.2 (see 4638155)
  75     }
  76 
  77     /**
  78      * Examine and consume command line arguments.
  79      * @param argv The command line arguments. Ignore null
  80      * and unknown arguments. Set each consumed argument to null.
  81      * @param main Report any errors using the main.error() methods.
  82      * @return true if no errors, false otherwise.
  83      */
  84     public boolean parseArgs(String argv[], Main main) {
  85         String explicitVersion = null;
  86         for (int i = 0; i &lt; argv.length; i++) {
  87             if (argv[i] != null) {
  88                 String arg = argv[i].toLowerCase();
  89                 if (versionOptions.containsKey(arg)) {
  90                     if (explicitVersion != null &amp;&amp;
  91                         !explicitVersion.equals(arg))
  92                     {
  93                         main.error(&quot;rmic.cannot.use.both&quot;,
  94                                    explicitVersion, arg);
  95                         return false;
  96                     }
  97                     explicitVersion = arg;
  98                     version = versionOptions.get(arg);
  99                     argv[i] = null;
 100                 }
 101             }
 102         }
 103         return true;
 104     }
 105 
 106     /**
 107      * Generate the source files for the stub and/or skeleton classes
 108      * needed by RMI for the given remote implementation class.
 109      *
 110      * @param env       compiler environment
 111      * @param cdef      definition of remote implementation class
 112      *                  to generate stubs and/or skeletons for
 113      * @param destDir   directory for the root of the package hierarchy
 114      *                  for generated files
 115      */
 116     public void generate(BatchEnvironment env, ClassDefinition cdef, File destDir) {
 117         RemoteClass remoteClass = RemoteClass.forClass(env, cdef);
 118         if (remoteClass == null)        // exit if an error occurred
 119             return;
 120 
 121         RMIGenerator gen;
 122         try {
 123             gen = new RMIGenerator(env, cdef, destDir, remoteClass, version);
 124         } catch (ClassNotFound e) {
 125             env.error(0, &quot;rmic.class.not.found&quot;, e.name);
 126             return;
 127         }
 128         gen.generate();
 129     }
 130 
 131     private void generate() {
 132         env.addGeneratedFile(stubFile);
 133 
 134         try {
 135             IndentingWriter out = new IndentingWriter(
 136                 new OutputStreamWriter(new FileOutputStream(stubFile)));
 137             writeStub(out);
 138             out.close();
 139             if (env.verbose()) {
 140                 env.output(Main.getText(&quot;rmic.wrote&quot;, stubFile.getPath()));
 141             }
 142             env.parseFile(ClassFile.newClassFile(stubFile));
 143         } catch (IOException e) {
 144             env.error(0, &quot;cant.write&quot;, stubFile.toString());
 145             return;
 146         }
 147 
 148         if (version == STUB_VERSION_1_1 ||
 149             version == STUB_VERSION_FAT)
 150         {
 151             env.addGeneratedFile(skeletonFile);
 152 
 153             try {
 154                 IndentingWriter out = new IndentingWriter(
 155                     new OutputStreamWriter(
 156                         new FileOutputStream(skeletonFile)));
 157                 writeSkeleton(out);
 158                 out.close();
 159                 if (env.verbose()) {
 160                     env.output(Main.getText(&quot;rmic.wrote&quot;,
 161                         skeletonFile.getPath()));
 162                 }
 163                 env.parseFile(ClassFile.newClassFile(skeletonFile));
 164             } catch (IOException e) {
 165                 env.error(0, &quot;cant.write&quot;, stubFile.toString());
 166                 return;
 167             }
 168         } else {
 169             /*
 170              * For bugid 4135136: if skeleton files are not being generated
 171              * for this compilation run, delete old skeleton source or class
 172              * files for this remote implementation class that were
 173              * (presumably) left over from previous runs, to avoid user
 174              * confusion from extraneous or inconsistent generated files.
 175              */
 176 
 177             File outputDir = Util.getOutputDirectoryFor(remoteClassName,destDir,env);
 178             File skeletonClassFile = new File(outputDir,skeletonClassName.getName().toString() + &quot;.class&quot;);
 179 
 180             skeletonFile.delete();      // ignore failures (no big deal)
 181             skeletonClassFile.delete();
 182         }
 183     }
 184 
 185     /**
 186      * Return the File object that should be used as the source file
 187      * for the given Java class, using the supplied destination
 188      * directory for the top of the package hierarchy.
 189      */
 190     protected static File sourceFileForClass(Identifier className,
 191                                              Identifier outputClassName,
 192                                              File destDir,
 193                                              BatchEnvironment env)
 194     {
 195         File packageDir = Util.getOutputDirectoryFor(className,destDir,env);
 196         String outputName = Names.mangleClass(outputClassName).getName().toString();
 197 
 198         String outputFileName = outputName + &quot;.java&quot;;
 199         return new File(packageDir, outputFileName);
 200     }
 201 
 202 
 203     /** rmic environment for this object */
 204     private BatchEnvironment env;
 205 
 206     /** the remote class that this instance is generating code for */
 207     private RemoteClass remoteClass;
 208 
 209     /** version of the stub protocol to use in code generation */
 210     private int version;
 211 
 212     /** remote methods for remote class, indexed by operation number */
 213     private RemoteClass.Method[] remoteMethods;
 214 
 215     /**
 216      * Names for the remote class and the stub and skeleton classes
 217      * to be generated for it.
 218      */
 219     private Identifier remoteClassName;
 220     private Identifier stubClassName;
 221     private Identifier skeletonClassName;
 222 
 223     private ClassDefinition cdef;
 224     private File destDir;
 225     private File stubFile;
 226     private File skeletonFile;
 227 
 228     /**
 229      * Names to use for the java.lang.reflect.Method static fields
 230      * corresponding to each remote method.
 231      */
 232     private String[] methodFieldNames;
 233 
 234     /** cached definition for certain exception classes in this environment */
 235     private ClassDefinition defException;
 236     private ClassDefinition defRemoteException;
 237     private ClassDefinition defRuntimeException;
 238 
 239     /**
 240      * Create a new stub/skeleton Generator object for the given
 241      * remote implementation class to generate code according to
 242      * the given stub protocol version.
 243      */
 244     private RMIGenerator(BatchEnvironment env, ClassDefinition cdef,
 245                            File destDir, RemoteClass remoteClass, int version)
 246         throws ClassNotFound
 247     {
 248         this.destDir     = destDir;
 249         this.cdef        = cdef;
 250         this.env         = env;
 251         this.remoteClass = remoteClass;
 252         this.version     = version;
 253 
 254         remoteMethods = remoteClass.getRemoteMethods();
 255 
 256         remoteClassName = remoteClass.getName();
 257         stubClassName = Names.stubFor(remoteClassName);
 258         skeletonClassName = Names.skeletonFor(remoteClassName);
 259 
 260         methodFieldNames = nameMethodFields(remoteMethods);
 261 
 262         stubFile = sourceFileForClass(remoteClassName,stubClassName, destDir , env);
 263         skeletonFile = sourceFileForClass(remoteClassName,skeletonClassName, destDir, env);
 264 
 265         /*
 266          * Initialize cached definitions for exception classes used
 267          * in the generation process.
 268          */
 269         defException =
 270             env.getClassDeclaration(idJavaLangException).
 271                 getClassDefinition(env);
 272         defRemoteException =
 273             env.getClassDeclaration(idRemoteException).
 274                 getClassDefinition(env);
 275         defRuntimeException =
 276             env.getClassDeclaration(idJavaLangRuntimeException).
 277                 getClassDefinition(env);
 278     }
 279 
 280     /**
 281      * Write the stub for the remote class to a stream.
 282      */
 283     private void writeStub(IndentingWriter p) throws IOException {
 284 
 285         /*
 286          * Write boiler plate comment.
 287          */
 288         p.pln(&quot;// Stub class generated by rmic, do not edit.&quot;);
 289         p.pln(&quot;// Contents subject to change without notice.&quot;);
 290         p.pln();
 291 
 292         /*
 293          * If remote implementation class was in a particular package,
 294          * declare the stub class to be in the same package.
 295          */
 296         if (remoteClassName.isQualified()) {
 297             p.pln(&quot;package &quot; + remoteClassName.getQualifier() + &quot;;&quot;);
 298             p.pln();
 299         }
 300 
 301         /*
 302          * Declare the stub class; implement all remote interfaces.
 303          */
 304         p.plnI(&quot;public final class &quot; +
 305             Names.mangleClass(stubClassName.getName()));
 306         p.pln(&quot;extends &quot; + idRemoteStub);
 307         ClassDefinition[] remoteInterfaces = remoteClass.getRemoteInterfaces();
 308         if (remoteInterfaces.length &gt; 0) {
 309             p.p(&quot;implements &quot;);
 310             for (int i = 0; i &lt; remoteInterfaces.length; i++) {
 311                 if (i &gt; 0)
 312                     p.p(&quot;, &quot;);
 313                 p.p(remoteInterfaces[i].getName().toString());
 314             }
 315             p.pln();
 316         }
 317         p.pOlnI(&quot;{&quot;);
 318 
 319         if (version == STUB_VERSION_1_1 ||
 320             version == STUB_VERSION_FAT)
 321         {
 322             writeOperationsArray(p);
 323             p.pln();
 324             writeInterfaceHash(p);
 325             p.pln();
 326         }
 327 
 328         if (version == STUB_VERSION_FAT ||
 329             version == STUB_VERSION_1_2)
 330         {
 331             p.pln(&quot;private static final long serialVersionUID = &quot; +
 332                 STUB_SERIAL_VERSION_UID + &quot;;&quot;);
 333             p.pln();
 334 
 335             /*
 336              * We only need to declare and initialize the static fields of
 337              * Method objects for each remote method if there are any remote
 338              * methods; otherwise, skip this code entirely, to avoid generating
 339              * a try/catch block for a checked exception that cannot occur
 340              * (see bugid 4125181).
 341              */
 342             if (methodFieldNames.length &gt; 0) {
 343                 if (version == STUB_VERSION_FAT) {
 344                     p.pln(&quot;private static boolean useNewInvoke;&quot;);
 345                 }
 346                 writeMethodFieldDeclarations(p);
 347                 p.pln();
 348 
 349                 /*
 350                  * Initialize java.lang.reflect.Method fields for each remote
 351                  * method in a static initializer.
 352                  */
 353                 p.plnI(&quot;static {&quot;);
 354                 p.plnI(&quot;try {&quot;);
 355                 if (version == STUB_VERSION_FAT) {
 356                     /*
 357                      * Fat stubs must determine whether the API required for
 358                      * the JDK 1.2 stub protocol is supported in the current
 359                      * runtime, so that it can use it if supported.  This is
 360                      * determined by using the Reflection API to test if the
 361                      * new invoke method on RemoteRef exists, and setting the
 362                      * static boolean &quot;useNewInvoke&quot; to true if it does, or
 363                      * to false if a NoSuchMethodException is thrown.
 364                      */
 365                     p.plnI(idRemoteRef + &quot;.class.getMethod(\&quot;invoke\&quot;,&quot;);
 366                     p.plnI(&quot;new java.lang.Class[] {&quot;);
 367                     p.pln(idRemote + &quot;.class,&quot;);
 368                     p.pln(&quot;java.lang.reflect.Method.class,&quot;);
 369                     p.pln(&quot;java.lang.Object[].class,&quot;);
 370                     p.pln(&quot;long.class&quot;);
 371                     p.pOln(&quot;});&quot;);
 372                     p.pO();
 373                     p.pln(&quot;useNewInvoke = true;&quot;);
 374                 }
 375                 writeMethodFieldInitializers(p);
 376                 p.pOlnI(&quot;} catch (java.lang.NoSuchMethodException e) {&quot;);
 377                 if (version == STUB_VERSION_FAT) {
 378                     p.pln(&quot;useNewInvoke = false;&quot;);
 379                 } else {
 380                     /*
 381                      * REMIND: By throwing an Error here, the application will
 382                      * get the NoSuchMethodError directly when the stub class
 383                      * is initialized.  If we throw a RuntimeException
 384                      * instead, the application would get an
 385                      * ExceptionInInitializerError.  Would that be more
 386                      * appropriate, and if so, which RuntimeException should
 387                      * be thrown?
 388                      */
 389                     p.plnI(&quot;throw new java.lang.NoSuchMethodError(&quot;);
 390                     p.pln(&quot;\&quot;stub class initialization failed\&quot;);&quot;);
 391                     p.pO();
 392                 }
 393                 p.pOln(&quot;}&quot;);            // end try/catch block
 394                 p.pOln(&quot;}&quot;);            // end static initializer
 395                 p.pln();
 396             }
 397         }
 398 
 399         writeStubConstructors(p);
 400         p.pln();
 401 
 402         /*
 403          * Write each stub method.
 404          */
 405         if (remoteMethods.length &gt; 0) {
 406             p.pln(&quot;// methods from remote interfaces&quot;);
 407             for (int i = 0; i &lt; remoteMethods.length; ++i) {
 408                 p.pln();
 409                 writeStubMethod(p, i);
 410             }
 411         }
 412 
 413         p.pOln(&quot;}&quot;);                    // end stub class
 414     }
 415 
 416     /**
 417      * Write the constructors for the stub class.
 418      */
 419     private void writeStubConstructors(IndentingWriter p)
 420         throws IOException
 421     {
 422         p.pln(&quot;// constructors&quot;);
 423 
 424         /*
 425          * Only stubs compatible with the JDK 1.1 stub protocol need
 426          * a no-arg constructor; later versions use reflection to find
 427          * the constructor that directly takes a RemoteRef argument.
 428          */
 429         if (version == STUB_VERSION_1_1 ||
 430             version == STUB_VERSION_FAT)
 431         {
 432             p.plnI(&quot;public &quot; + Names.mangleClass(stubClassName.getName()) +
 433                 &quot;() {&quot;);
 434             p.pln(&quot;super();&quot;);
 435             p.pOln(&quot;}&quot;);
 436         }
 437 
 438         p.plnI(&quot;public &quot; + Names.mangleClass(stubClassName.getName()) +
 439             &quot;(&quot; + idRemoteRef + &quot; ref) {&quot;);
 440         p.pln(&quot;super(ref);&quot;);
 441         p.pOln(&quot;}&quot;);
 442     }
 443 
 444     /**
 445      * Write the stub method for the remote method with the given &quot;opnum&quot;.
 446      */
 447     private void writeStubMethod(IndentingWriter p, int opnum)
 448         throws IOException
 449     {
 450         RemoteClass.Method method = remoteMethods[opnum];
 451         Identifier methodName = method.getName();
 452         Type methodType = method.getType();
 453         Type paramTypes[] = methodType.getArgumentTypes();
 454         String paramNames[] = nameParameters(paramTypes);
 455         Type returnType = methodType.getReturnType();
 456         ClassDeclaration[] exceptions = method.getExceptions();
 457 
 458         /*
 459          * Declare stub method; throw exceptions declared in remote
 460          * interface(s).
 461          */
 462         p.pln(&quot;// implementation of &quot; +
 463             methodType.typeString(methodName.toString(), true, false));
 464         p.p(&quot;public &quot; + returnType + &quot; &quot; + methodName + &quot;(&quot;);
 465         for (int i = 0; i &lt; paramTypes.length; i++) {
 466             if (i &gt; 0)
 467                 p.p(&quot;, &quot;);
 468             p.p(paramTypes[i] + &quot; &quot; + paramNames[i]);
 469         }
 470         p.plnI(&quot;)&quot;);
 471         if (exceptions.length &gt; 0) {
 472             p.p(&quot;throws &quot;);
 473             for (int i = 0; i &lt; exceptions.length; i++) {
 474                 if (i &gt; 0)
 475                     p.p(&quot;, &quot;);
 476                 p.p(exceptions[i].getName().toString());
 477             }
 478             p.pln();
 479         }
 480         p.pOlnI(&quot;{&quot;);
 481 
 482         /*
 483          * The RemoteRef.invoke methods throw Exception, but unless this
 484          * stub method throws Exception as well, we must catch Exceptions
 485          * thrown from the invocation.  So we must catch Exception and
 486          * rethrow something we can throw: UnexpectedException, which is a
 487          * subclass of RemoteException.  But for any subclasses of Exception
 488          * that we can throw, like RemoteException, RuntimeException, and
 489          * any of the exceptions declared by this stub method, we want them
 490          * to pass through unharmed, so first we must catch any such
 491          * exceptions and rethrow it directly.
 492          *
 493          * We have to be careful generating the rethrowing catch blocks
 494          * here, because javac will flag an error if there are any
 495          * unreachable catch blocks, i.e. if the catch of an exception class
 496          * follows a previous catch of it or of one of its superclasses.
 497          * The following method invocation takes care of these details.
 498          */
 499         Vector&lt;ClassDefinition&gt; catchList = computeUniqueCatchList(exceptions);
 500 
 501         /*
 502          * If we need to catch any particular exceptions (i.e. this method
 503          * does not declare java.lang.Exception), put the entire stub
 504          * method in a try block.
 505          */
 506         if (catchList.size() &gt; 0) {
 507             p.plnI(&quot;try {&quot;);
 508         }
 509 
 510         if (version == STUB_VERSION_FAT) {
 511             p.plnI(&quot;if (useNewInvoke) {&quot;);
 512         }
 513         if (version == STUB_VERSION_FAT ||
 514             version == STUB_VERSION_1_2)
 515         {
 516             if (!returnType.isType(TC_VOID)) {
 517                 p.p(&quot;Object $result = &quot;);               // REMIND: why $?
 518             }
 519             p.p(&quot;ref.invoke(this, &quot; + methodFieldNames[opnum] + &quot;, &quot;);
 520             if (paramTypes.length &gt; 0) {
 521                 p.p(&quot;new java.lang.Object[] {&quot;);
 522                 for (int i = 0; i &lt; paramTypes.length; i++) {
 523                     if (i &gt; 0)
 524                         p.p(&quot;, &quot;);
 525                     p.p(wrapArgumentCode(paramTypes[i], paramNames[i]));
 526                 }
 527                 p.p(&quot;}&quot;);
 528             } else {
 529                 p.p(&quot;null&quot;);
 530             }
 531             p.pln(&quot;, &quot; + method.getMethodHash() + &quot;L);&quot;);
 532             if (!returnType.isType(TC_VOID)) {
 533                 p.pln(&quot;return &quot; +
 534                     unwrapArgumentCode(returnType, &quot;$result&quot;) + &quot;;&quot;);
 535             }
 536         }
 537         if (version == STUB_VERSION_FAT) {
 538             p.pOlnI(&quot;} else {&quot;);
 539         }
 540         if (version == STUB_VERSION_1_1 ||
 541             version == STUB_VERSION_FAT)
 542         {
 543             p.pln(idRemoteCall + &quot; call = ref.newCall((&quot; + idRemoteObject +
 544                 &quot;) this, operations, &quot; + opnum + &quot;, interfaceHash);&quot;);
 545 
 546             if (paramTypes.length &gt; 0) {
 547                 p.plnI(&quot;try {&quot;);
 548                 p.pln(&quot;java.io.ObjectOutput out = call.getOutputStream();&quot;);
 549                 writeMarshalArguments(p, &quot;out&quot;, paramTypes, paramNames);
 550                 p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
 551                 p.pln(&quot;throw new &quot; + idMarshalException +
 552                     &quot;(\&quot;error marshalling arguments\&quot;, e);&quot;);
 553                 p.pOln(&quot;}&quot;);
 554             }
 555 
 556             p.pln(&quot;ref.invoke(call);&quot;);
 557 
 558             if (returnType.isType(TC_VOID)) {
 559                 p.pln(&quot;ref.done(call);&quot;);
 560             } else {
 561                 p.pln(returnType + &quot; $result;&quot;);        // REMIND: why $?
 562                 p.plnI(&quot;try {&quot;);
 563                 p.pln(&quot;java.io.ObjectInput in = call.getInputStream();&quot;);
 564                 boolean objectRead =
 565                     writeUnmarshalArgument(p, &quot;in&quot;, returnType, &quot;$result&quot;);
 566                 p.pln(&quot;;&quot;);
 567                 p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
 568                 p.pln(&quot;throw new &quot; + idUnmarshalException +
 569                     &quot;(\&quot;error unmarshalling return\&quot;, e);&quot;);
 570                 /*
 571                  * If any only if readObject has been invoked, we must catch
 572                  * ClassNotFoundException as well as IOException.
 573                  */
 574                 if (objectRead) {
 575                     p.pOlnI(&quot;} catch (java.lang.ClassNotFoundException e) {&quot;);
 576                     p.pln(&quot;throw new &quot; + idUnmarshalException +
 577                         &quot;(\&quot;error unmarshalling return\&quot;, e);&quot;);
 578                 }
 579                 p.pOlnI(&quot;} finally {&quot;);
 580                 p.pln(&quot;ref.done(call);&quot;);
 581                 p.pOln(&quot;}&quot;);
 582                 p.pln(&quot;return $result;&quot;);
 583             }
 584         }
 585         if (version == STUB_VERSION_FAT) {
 586             p.pOln(&quot;}&quot;);                // end if/else (useNewInvoke) block
 587         }
 588 
 589         /*
 590          * If we need to catch any particular exceptions, finally write
 591          * the catch blocks for them, rethrow any other Exceptions with an
 592          * UnexpectedException, and end the try block.
 593          */
 594         if (catchList.size() &gt; 0) {
 595             for (Enumeration&lt;ClassDefinition&gt; enumeration = catchList.elements();
 596                  enumeration.hasMoreElements();)
 597             {
 598                 ClassDefinition def = enumeration.nextElement();
 599                 p.pOlnI(&quot;} catch (&quot; + def.getName() + &quot; e) {&quot;);
 600                 p.pln(&quot;throw e;&quot;);
 601             }
 602             p.pOlnI(&quot;} catch (java.lang.Exception e) {&quot;);
 603             p.pln(&quot;throw new &quot; + idUnexpectedException +
 604                 &quot;(\&quot;undeclared checked exception\&quot;, e);&quot;);
 605             p.pOln(&quot;}&quot;);                // end try/catch block
 606         }
 607 
 608         p.pOln(&quot;}&quot;);                    // end stub method
 609     }
 610 
 611     /**
 612      * Compute the exceptions which need to be caught and rethrown in a
 613      * stub method before wrapping Exceptions in UnexpectedExceptions,
 614      * given the exceptions declared in the throws clause of the method.
 615      * Returns a Vector containing ClassDefinition objects for each
 616      * exception to catch.  Each exception is guaranteed to be unique,
 617      * i.e. not a subclass of any of the other exceptions in the Vector,
 618      * so the catch blocks for these exceptions may be generated in any
 619      * order relative to each other.
 620      *
 621      * RemoteException and RuntimeException are each automatically placed
 622      * in the returned Vector (if none of their superclasses are already
 623      * present), since those exceptions should always be directly rethrown
 624      * by a stub method.
 625      *
 626      * The returned Vector will be empty if java.lang.Exception or one
 627      * of its superclasses is in the throws clause of the method, indicating
 628      * that no exceptions need to be caught.
 629      */
 630     private Vector&lt;ClassDefinition&gt; computeUniqueCatchList(ClassDeclaration[] exceptions) {
 631         Vector&lt;ClassDefinition&gt; uniqueList = new Vector&lt;&gt;();       // unique exceptions to catch
 632 
 633         uniqueList.addElement(defRuntimeException);
 634         uniqueList.addElement(defRemoteException);
 635 
 636         /* For each exception declared by the stub method&#39;s throws clause: */
 637     nextException:
 638         for (int i = 0; i &lt; exceptions.length; i++) {
 639             ClassDeclaration decl = exceptions[i];
 640             try {
 641                 if (defException.subClassOf(env, decl)) {
 642                     /*
 643                      * (If java.lang.Exception (or a superclass) was declared
 644                      * in the throws clause of this stub method, then we don&#39;t
 645                      * have to bother catching anything; clear the list and
 646                      * return.)
 647                      */
 648                     uniqueList.clear();
 649                     break;
 650                 } else if (!defException.superClassOf(env, decl)) {
 651                     /*
 652                      * Ignore other Throwables that do not extend Exception,
 653                      * since they do not need to be caught anyway.
 654                      */
 655                     continue;
 656                 }
 657                 /*
 658                  * Compare this exception against the current list of
 659                  * exceptions that need to be caught:
 660                  */
 661                 for (int j = 0; j &lt; uniqueList.size();) {
 662                     ClassDefinition def = uniqueList.elementAt(j);
 663                     if (def.superClassOf(env, decl)) {
 664                         /*
 665                          * If a superclass of this exception is already on
 666                          * the list to catch, then ignore and continue;
 667                          */
 668                         continue nextException;
 669                     } else if (def.subClassOf(env, decl)) {
 670                         /*
 671                          * If a subclass of this exception is on the list
 672                          * to catch, then remove it.
 673                          */
 674                         uniqueList.removeElementAt(j);
 675                     } else {
 676                         j++;    // else continue comparing
 677                     }
 678                 }
 679                 /* This exception is unique: add it to the list to catch. */
 680                 uniqueList.addElement(decl.getClassDefinition(env));
 681             } catch (ClassNotFound e) {
 682                 env.error(0, &quot;class.not.found&quot;, e.name, decl.getName());
 683                 /*
 684                  * REMIND: We do not exit from this exceptional condition,
 685                  * generating questionable code and likely letting the
 686                  * compiler report a resulting error later.
 687                  */
 688             }
 689         }
 690         return uniqueList;
 691     }
 692 
 693     /**
 694      * Write the skeleton for the remote class to a stream.
 695      */
 696     private void writeSkeleton(IndentingWriter p) throws IOException {
 697         if (version == STUB_VERSION_1_2) {
 698             throw new Error(&quot;should not generate skeleton for version&quot;);
 699         }
 700 
 701         /*
 702          * Write boiler plate comment.
 703          */
 704         p.pln(&quot;// Skeleton class generated by rmic, do not edit.&quot;);
 705         p.pln(&quot;// Contents subject to change without notice.&quot;);
 706         p.pln();
 707 
 708         /*
 709          * If remote implementation class was in a particular package,
 710          * declare the skeleton class to be in the same package.
 711          */
 712         if (remoteClassName.isQualified()) {
 713             p.pln(&quot;package &quot; + remoteClassName.getQualifier() + &quot;;&quot;);
 714             p.pln();
 715         }
 716 
 717         /*
 718          * Declare the skeleton class.
 719          */
 720         p.plnI(&quot;public final class &quot; +
 721             Names.mangleClass(skeletonClassName.getName()));
 722         p.pln(&quot;implements &quot; + idSkeleton);
 723         p.pOlnI(&quot;{&quot;);
 724 
 725         writeOperationsArray(p);
 726         p.pln();
 727 
 728         writeInterfaceHash(p);
 729         p.pln();
 730 
 731         /*
 732          * Define the getOperations() method.
 733          */
 734         p.plnI(&quot;public &quot; + idOperation + &quot;[] getOperations() {&quot;);
 735         p.pln(&quot;return (&quot; + idOperation + &quot;[]) operations.clone();&quot;);
 736         p.pOln(&quot;}&quot;);
 737         p.pln();
 738 
 739         /*
 740          * Define the dispatch() method.
 741          */
 742         p.plnI(&quot;public void dispatch(&quot; + idRemote + &quot; obj, &quot; +
 743             idRemoteCall + &quot; call, int opnum, long hash)&quot;);
 744         p.pln(&quot;throws java.lang.Exception&quot;);
 745         p.pOlnI(&quot;{&quot;);
 746 
 747         if (version == STUB_VERSION_FAT) {
 748             p.plnI(&quot;if (opnum &lt; 0) {&quot;);
 749             if (remoteMethods.length &gt; 0) {
 750                 for (int opnum = 0; opnum &lt; remoteMethods.length; opnum++) {
 751                     if (opnum &gt; 0)
 752                         p.pO(&quot;} else &quot;);
 753                     p.plnI(&quot;if (hash == &quot; +
 754                         remoteMethods[opnum].getMethodHash() + &quot;L) {&quot;);
 755                     p.pln(&quot;opnum = &quot; + opnum + &quot;;&quot;);
 756                 }
 757                 p.pOlnI(&quot;} else {&quot;);
 758             }
 759             /*
 760              * Skeleton throws UnmarshalException if it does not recognize
 761              * the method hash; this is what UnicastServerRef.dispatch()
 762              * would do.
 763              */
 764             p.pln(&quot;throw new &quot; +
 765                 idUnmarshalException + &quot;(\&quot;invalid method hash\&quot;);&quot;);
 766             if (remoteMethods.length &gt; 0) {
 767                 p.pOln(&quot;}&quot;);
 768             }
 769             /*
 770              * Ignore the validation of the interface hash if the
 771              * operation number was negative, since it is really a
 772              * method hash instead.
 773              */
 774             p.pOlnI(&quot;} else {&quot;);
 775         }
 776 
 777         p.plnI(&quot;if (hash != interfaceHash)&quot;);
 778         p.pln(&quot;throw new &quot; +
 779             idSkeletonMismatchException + &quot;(\&quot;interface hash mismatch\&quot;);&quot;);
 780         p.pO();
 781 
 782         if (version == STUB_VERSION_FAT) {
 783             p.pOln(&quot;}&quot;);                // end if/else (opnum &lt; 0) block
 784         }
 785         p.pln();
 786 
 787         /*
 788          * Cast remote object instance to our specific implementation class.
 789          */
 790         p.pln(remoteClassName + &quot; server = (&quot; + remoteClassName + &quot;) obj;&quot;);
 791 
 792         /*
 793          * Process call according to the operation number.
 794          */
 795         p.plnI(&quot;switch (opnum) {&quot;);
 796         for (int opnum = 0; opnum &lt; remoteMethods.length; opnum++) {
 797             writeSkeletonDispatchCase(p, opnum);
 798         }
 799         p.pOlnI(&quot;default:&quot;);
 800         /*
 801          * Skeleton throws UnmarshalException if it does not recognize
 802          * the operation number; this is consistent with the case of an
 803          * unrecognized method hash.
 804          */
 805         p.pln(&quot;throw new &quot; + idUnmarshalException +
 806             &quot;(\&quot;invalid method number\&quot;);&quot;);
 807         p.pOln(&quot;}&quot;);                    // end switch statement
 808 
 809         p.pOln(&quot;}&quot;);                    // end dispatch() method
 810 
 811         p.pOln(&quot;}&quot;);                    // end skeleton class
 812     }
 813 
 814     /**
 815      * Write the case block for the skeleton&#39;s dispatch method for
 816      * the remote method with the given &quot;opnum&quot;.
 817      */
 818     private void writeSkeletonDispatchCase(IndentingWriter p, int opnum)
 819         throws IOException
 820     {
 821         RemoteClass.Method method = remoteMethods[opnum];
 822         Identifier methodName = method.getName();
 823         Type methodType = method.getType();
 824         Type paramTypes[] = methodType.getArgumentTypes();
 825         String paramNames[] = nameParameters(paramTypes);
 826         Type returnType = methodType.getReturnType();
 827 
 828         p.pOlnI(&quot;case &quot; + opnum + &quot;: // &quot; +
 829             methodType.typeString(methodName.toString(), true, false));
 830         /*
 831          * Use nested block statement inside case to provide an independent
 832          * namespace for local variables used to unmarshal parameters for
 833          * this remote method.
 834          */
 835         p.pOlnI(&quot;{&quot;);
 836 
 837         if (paramTypes.length &gt; 0) {
 838             /*
 839              * Declare local variables to hold arguments.
 840              */
 841             for (int i = 0; i &lt; paramTypes.length; i++) {
 842                 p.pln(paramTypes[i] + &quot; &quot; + paramNames[i] + &quot;;&quot;);
 843             }
 844 
 845             /*
 846              * Unmarshal arguments from call stream.
 847              */
 848             p.plnI(&quot;try {&quot;);
 849             p.pln(&quot;java.io.ObjectInput in = call.getInputStream();&quot;);
 850             boolean objectsRead = writeUnmarshalArguments(p, &quot;in&quot;,
 851                 paramTypes, paramNames);
 852             p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
 853             p.pln(&quot;throw new &quot; + idUnmarshalException +
 854                 &quot;(\&quot;error unmarshalling arguments\&quot;, e);&quot;);
 855             /*
 856              * If any only if readObject has been invoked, we must catch
 857              * ClassNotFoundException as well as IOException.
 858              */
 859             if (objectsRead) {
 860                 p.pOlnI(&quot;} catch (java.lang.ClassNotFoundException e) {&quot;);
 861                 p.pln(&quot;throw new &quot; + idUnmarshalException +
 862                     &quot;(\&quot;error unmarshalling arguments\&quot;, e);&quot;);
 863             }
 864             p.pOlnI(&quot;} finally {&quot;);
 865             p.pln(&quot;call.releaseInputStream();&quot;);
 866             p.pOln(&quot;}&quot;);
 867         } else {
 868             p.pln(&quot;call.releaseInputStream();&quot;);
 869         }
 870 
 871         if (!returnType.isType(TC_VOID)) {
 872             /*
 873              * Declare variable to hold return type, if not void.
 874              */
 875             p.p(returnType + &quot; $result = &quot;);            // REMIND: why $?
 876         }
 877 
 878         /*
 879          * Invoke the method on the server object.
 880          */
 881         p.p(&quot;server.&quot; + methodName + &quot;(&quot;);
 882         for (int i = 0; i &lt; paramNames.length; i++) {
 883             if (i &gt; 0)
 884                 p.p(&quot;, &quot;);
 885             p.p(paramNames[i]);
 886         }
 887         p.pln(&quot;);&quot;);
 888 
 889         /*
 890          * Always invoke getResultStream(true) on the call object to send
 891          * the indication of a successful invocation to the caller.  If
 892          * the return type is not void, keep the result stream and marshal
 893          * the return value.
 894          */
 895         p.plnI(&quot;try {&quot;);
 896         if (!returnType.isType(TC_VOID)) {
 897             p.p(&quot;java.io.ObjectOutput out = &quot;);
 898         }
 899         p.pln(&quot;call.getResultStream(true);&quot;);
 900         if (!returnType.isType(TC_VOID)) {
 901             writeMarshalArgument(p, &quot;out&quot;, returnType, &quot;$result&quot;);
 902             p.pln(&quot;;&quot;);
 903         }
 904         p.pOlnI(&quot;} catch (java.io.IOException e) {&quot;);
 905         p.pln(&quot;throw new &quot; +
 906             idMarshalException + &quot;(\&quot;error marshalling return\&quot;, e);&quot;);
 907         p.pOln(&quot;}&quot;);
 908 
 909         p.pln(&quot;break;&quot;);                // break from switch statement
 910 
 911         p.pOlnI(&quot;}&quot;);                   // end nested block statement
 912         p.pln();
 913     }
 914 
 915     /**
 916      * Write declaration and initializer for &quot;operations&quot; static array.
 917      */
 918     private void writeOperationsArray(IndentingWriter p)
 919         throws IOException
 920     {
 921         p.plnI(&quot;private static final &quot; + idOperation + &quot;[] operations = {&quot;);
 922         for (int i = 0; i &lt; remoteMethods.length; i++) {
 923             if (i &gt; 0)
 924                 p.pln(&quot;,&quot;);
 925             p.p(&quot;new &quot; + idOperation + &quot;(\&quot;&quot; +
 926                 remoteMethods[i].getOperationString() + &quot;\&quot;)&quot;);
 927         }
 928         p.pln();
 929         p.pOln(&quot;};&quot;);
 930     }
 931 
 932     /**
 933      * Write declaration and initializer for &quot;interfaceHash&quot; static field.
 934      */
 935     private void writeInterfaceHash(IndentingWriter p)
 936         throws IOException
 937     {
 938         p.pln(&quot;private static final long interfaceHash = &quot; +
 939             remoteClass.getInterfaceHash() + &quot;L;&quot;);
 940     }
 941 
 942     /**
 943      * Write declaration for java.lang.reflect.Method static fields
 944      * corresponding to each remote method in a stub.
 945      */
 946     private void writeMethodFieldDeclarations(IndentingWriter p)
 947         throws IOException
 948     {
 949         for (int i = 0; i &lt; methodFieldNames.length; i++) {
 950             p.pln(&quot;private static java.lang.reflect.Method &quot; +
 951                 methodFieldNames[i] + &quot;;&quot;);
 952         }
 953     }
 954 
 955     /**
 956      * Write code to initialize the static fields for each method
 957      * using the Java Reflection API.
 958      */
 959     private void writeMethodFieldInitializers(IndentingWriter p)
 960         throws IOException
 961     {
 962         for (int i = 0; i &lt; methodFieldNames.length; i++) {
 963             p.p(methodFieldNames[i] + &quot; = &quot;);
 964             /*
 965              * Here we look up the Method object in the arbitrary interface
 966              * that we find in the RemoteClass.Method object.
 967              * REMIND: Is this arbitrary choice OK?
 968              * REMIND: Should this access be part of RemoteClass.Method&#39;s
 969              * abstraction?
 970              */
 971             RemoteClass.Method method = remoteMethods[i];
 972             MemberDefinition def = method.getMemberDefinition();
 973             Identifier methodName = method.getName();
 974             Type methodType = method.getType();
 975             Type paramTypes[] = methodType.getArgumentTypes();
 976 
 977             p.p(def.getClassDefinition().getName() + &quot;.class.getMethod(\&quot;&quot; +
 978                 methodName + &quot;\&quot;, new java.lang.Class[] {&quot;);
 979             for (int j = 0; j &lt; paramTypes.length; j++) {
 980                 if (j &gt; 0)
 981                     p.p(&quot;, &quot;);
 982                 p.p(paramTypes[j] + &quot;.class&quot;);
 983             }
 984             p.pln(&quot;});&quot;);
 985         }
 986     }
 987 
 988 
 989     /*
 990      * Following are a series of static utility methods useful during
 991      * the code generation process:
 992      */
 993 
 994     /**
 995      * Generate an array of names for fields that correspond to the given
 996      * array of remote methods.  Each name in the returned array is
 997      * guaranteed to be unique.
 998      *
 999      * The name of a method is included in its corresponding field name
1000      * to enhance readability of the generated code.
1001      */
1002     private static String[] nameMethodFields(RemoteClass.Method[] methods) {
1003         String[] names = new String[methods.length];
1004         for (int i = 0; i &lt; names.length; i++) {
1005             names[i] = &quot;$method_&quot; + methods[i].getName() + &quot;_&quot; + i;
1006         }
1007         return names;
1008     }
1009 
1010     /**
1011      * Generate an array of names for parameters corresponding to the
1012      * given array of types for the parameters.  Each name in the returned
1013      * array is guaranteed to be unique.
1014      *
1015      * A representation of the type of a parameter is included in its
1016      * corresponding field name to enhance the readability of the generated
1017      * code.
1018      */
1019     private static String[] nameParameters(Type[] types) {
1020         String[] names = new String[types.length];
1021         for (int i = 0; i &lt; names.length; i++) {
1022             names[i] = &quot;$param_&quot; +
1023                 generateNameFromType(types[i]) + &quot;_&quot; + (i + 1);
1024         }
1025         return names;
1026     }
1027 
1028     /**
1029      * Generate a readable string representing the given type suitable
1030      * for embedding within a Java identifier.
1031      */
1032     private static String generateNameFromType(Type type) {
1033         int typeCode = type.getTypeCode();
1034         switch (typeCode) {
1035         case TC_BOOLEAN:
1036         case TC_BYTE:
1037         case TC_CHAR:
1038         case TC_SHORT:
1039         case TC_INT:
1040         case TC_LONG:
1041         case TC_FLOAT:
1042         case TC_DOUBLE:
1043             return type.toString();
1044         case TC_ARRAY:
1045             return &quot;arrayOf_&quot; + generateNameFromType(type.getElementType());
1046         case TC_CLASS:
1047             return Names.mangleClass(type.getClassName().getName()).toString();
1048         default:
1049             throw new Error(&quot;unexpected type code: &quot; + typeCode);
1050         }
1051     }
1052 
1053     /**
1054      * Write a snippet of Java code to marshal a value named &quot;name&quot; of
1055      * type &quot;type&quot; to the java.io.ObjectOutput stream named &quot;stream&quot;.
1056      *
1057      * Primitive types are marshalled with their corresponding methods
1058      * in the java.io.DataOutput interface, and objects (including arrays)
1059      * are marshalled using the writeObject method.
1060      */
1061     private static void writeMarshalArgument(IndentingWriter p,
1062                                              String streamName,
1063                                              Type type, String name)
1064         throws IOException
1065     {
1066         int typeCode = type.getTypeCode();
1067         switch (typeCode) {
1068         case TC_BOOLEAN:
1069             p.p(streamName + &quot;.writeBoolean(&quot; + name + &quot;)&quot;);
1070             break;
1071         case TC_BYTE:
1072             p.p(streamName + &quot;.writeByte(&quot; + name + &quot;)&quot;);
1073             break;
1074         case TC_CHAR:
1075             p.p(streamName + &quot;.writeChar(&quot; + name + &quot;)&quot;);
1076             break;
1077         case TC_SHORT:
1078             p.p(streamName + &quot;.writeShort(&quot; + name + &quot;)&quot;);
1079             break;
1080         case TC_INT:
1081             p.p(streamName + &quot;.writeInt(&quot; + name + &quot;)&quot;);
1082             break;
1083         case TC_LONG:
1084             p.p(streamName + &quot;.writeLong(&quot; + name + &quot;)&quot;);
1085             break;
1086         case TC_FLOAT:
1087             p.p(streamName + &quot;.writeFloat(&quot; + name + &quot;)&quot;);
1088             break;
1089         case TC_DOUBLE:
1090             p.p(streamName + &quot;.writeDouble(&quot; + name + &quot;)&quot;);
1091             break;
1092         case TC_ARRAY:
1093         case TC_CLASS:
1094             p.p(streamName + &quot;.writeObject(&quot; + name + &quot;)&quot;);
1095             break;
1096         default:
1097             throw new Error(&quot;unexpected type code: &quot; + typeCode);
1098         }
1099     }
1100 
1101     /**
1102      * Write Java statements to marshal a series of values in order as
1103      * named in the &quot;names&quot; array, with types as specified in the &quot;types&quot;
1104      * array&quot;, to the java.io.ObjectOutput stream named &quot;stream&quot;.
1105      */
1106     private static void writeMarshalArguments(IndentingWriter p,
1107                                               String streamName,
1108                                               Type[] types, String[] names)
1109         throws IOException
1110     {
1111         if (types.length != names.length) {
1112             throw new Error(&quot;parameter type and name arrays different sizes&quot;);
1113         }
1114 
1115         for (int i = 0; i &lt; types.length; i++) {
1116             writeMarshalArgument(p, streamName, types[i], names[i]);
1117             p.pln(&quot;;&quot;);
1118         }
1119     }
1120 
1121     /**
1122      * Write a snippet of Java code to unmarshal a value of type &quot;type&quot;
1123      * from the java.io.ObjectInput stream named &quot;stream&quot; into a variable
1124      * named &quot;name&quot; (if &quot;name&quot; is null, the value in unmarshalled and
1125      * discarded).
1126      *
1127      * Primitive types are unmarshalled with their corresponding methods
1128      * in the java.io.DataInput interface, and objects (including arrays)
1129      * are unmarshalled using the readObject method.
1130      */
1131     private static boolean writeUnmarshalArgument(IndentingWriter p,
1132                                                   String streamName,
1133                                                   Type type, String name)
1134         throws IOException
1135     {
1136         boolean readObject = false;
1137 
1138         if (name != null) {
1139             p.p(name + &quot; = &quot;);
1140         }
1141 
1142         int typeCode = type.getTypeCode();
1143         switch (type.getTypeCode()) {
1144         case TC_BOOLEAN:
1145             p.p(streamName + &quot;.readBoolean()&quot;);
1146             break;
1147         case TC_BYTE:
1148             p.p(streamName + &quot;.readByte()&quot;);
1149             break;
1150         case TC_CHAR:
1151             p.p(streamName + &quot;.readChar()&quot;);
1152             break;
1153         case TC_SHORT:
1154             p.p(streamName + &quot;.readShort()&quot;);
1155             break;
1156         case TC_INT:
1157             p.p(streamName + &quot;.readInt()&quot;);
1158             break;
1159         case TC_LONG:
1160             p.p(streamName + &quot;.readLong()&quot;);
1161             break;
1162         case TC_FLOAT:
1163             p.p(streamName + &quot;.readFloat()&quot;);
1164             break;
1165         case TC_DOUBLE:
1166             p.p(streamName + &quot;.readDouble()&quot;);
1167             break;
1168         case TC_ARRAY:
1169         case TC_CLASS:
1170             p.p(&quot;(&quot; + type + &quot;) &quot; + streamName + &quot;.readObject()&quot;);
1171             readObject = true;
1172             break;
1173         default:
1174             throw new Error(&quot;unexpected type code: &quot; + typeCode);
1175         }
1176         return readObject;
1177     }
1178 
1179     /**
1180      * Write Java statements to unmarshal a series of values in order of
1181      * types as in the &quot;types&quot; array from the java.io.ObjectInput stream
1182      * named &quot;stream&quot; into variables as named in &quot;names&quot; (for any element
1183      * of &quot;names&quot; that is null, the corresponding value is unmarshalled
1184      * and discarded).
1185      */
1186     private static boolean writeUnmarshalArguments(IndentingWriter p,
1187                                                    String streamName,
1188                                                    Type[] types,
1189                                                    String[] names)
1190         throws IOException
1191     {
1192         if (types.length != names.length) {
1193             throw new Error(&quot;parameter type and name arrays different sizes&quot;);
1194         }
1195 
1196         boolean readObject = false;
1197         for (int i = 0; i &lt; types.length; i++) {
1198             if (writeUnmarshalArgument(p, streamName, types[i], names[i])) {
1199                 readObject = true;
1200             }
1201             p.pln(&quot;;&quot;);
1202         }
1203         return readObject;
1204     }
1205 
1206     /**
1207      * Return a snippet of Java code to wrap a value named &quot;name&quot; of
1208      * type &quot;type&quot; into an object as appropriate for use by the
1209      * Java Reflection API.
1210      *
1211      * For primitive types, an appropriate wrapper class instantiated
1212      * with the primitive value.  For object types (including arrays),
1213      * no wrapping is necessary, so the value is named directly.
1214      */
1215     private static String wrapArgumentCode(Type type, String name) {
1216         int typeCode = type.getTypeCode();
1217         switch (typeCode) {
1218         case TC_BOOLEAN:
1219             return (&quot;(&quot; + name +
1220                     &quot; ? java.lang.Boolean.TRUE : java.lang.Boolean.FALSE)&quot;);
1221         case TC_BYTE:
1222             return &quot;new java.lang.Byte(&quot; + name + &quot;)&quot;;
1223         case TC_CHAR:
1224             return &quot;new java.lang.Character(&quot; + name + &quot;)&quot;;
1225         case TC_SHORT:
1226             return &quot;new java.lang.Short(&quot; + name + &quot;)&quot;;
1227         case TC_INT:
1228             return &quot;new java.lang.Integer(&quot; + name + &quot;)&quot;;
1229         case TC_LONG:
1230             return &quot;new java.lang.Long(&quot; + name + &quot;)&quot;;
1231         case TC_FLOAT:
1232             return &quot;new java.lang.Float(&quot; + name + &quot;)&quot;;
1233         case TC_DOUBLE:
1234             return &quot;new java.lang.Double(&quot; + name + &quot;)&quot;;
1235         case TC_ARRAY:
1236         case TC_CLASS:
1237             return name;
1238         default:
1239             throw new Error(&quot;unexpected type code: &quot; + typeCode);
1240         }
1241     }
1242 
1243     /**
1244      * Return a snippet of Java code to unwrap a value named &quot;name&quot; into
1245      * a value of type &quot;type&quot;, as appropriate for the Java Reflection API.
1246      *
1247      * For primitive types, the value is assumed to be of the corresponding
1248      * wrapper type, and a method is called on the wrapper type to retrieve
1249      * the primitive value.  For object types (include arrays), no
1250      * unwrapping is necessary; the value is simply cast to the expected
1251      * real object type.
1252      */
1253     private static String unwrapArgumentCode(Type type, String name) {
1254         int typeCode = type.getTypeCode();
1255         switch (typeCode) {
1256         case TC_BOOLEAN:
1257             return &quot;((java.lang.Boolean) &quot; + name + &quot;).booleanValue()&quot;;
1258         case TC_BYTE:
1259             return &quot;((java.lang.Byte) &quot; + name + &quot;).byteValue()&quot;;
1260         case TC_CHAR:
1261             return &quot;((java.lang.Character) &quot; + name + &quot;).charValue()&quot;;
1262         case TC_SHORT:
1263             return &quot;((java.lang.Short) &quot; + name + &quot;).shortValue()&quot;;
1264         case TC_INT:
1265             return &quot;((java.lang.Integer) &quot; + name + &quot;).intValue()&quot;;
1266         case TC_LONG:
1267             return &quot;((java.lang.Long) &quot; + name + &quot;).longValue()&quot;;
1268         case TC_FLOAT:
1269             return &quot;((java.lang.Float) &quot; + name + &quot;).floatValue()&quot;;
1270         case TC_DOUBLE:
1271             return &quot;((java.lang.Double) &quot; + name + &quot;).doubleValue()&quot;;
1272         case TC_ARRAY:
1273         case TC_CLASS:
1274             return &quot;((&quot; + type + &quot;) &quot; + name + &quot;)&quot;;
1275         default:
1276             throw new Error(&quot;unexpected type code: &quot; + typeCode);
1277         }
1278     }
1279 }
    </pre>
  </body>
</html>
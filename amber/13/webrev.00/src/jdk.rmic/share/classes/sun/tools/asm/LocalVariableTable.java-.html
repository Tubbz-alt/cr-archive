<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.rmic/share/classes/sun/tools/asm/LocalVariableTable.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1995, 2003, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package sun.tools.asm;
 27 
 28 import sun.tools.java.*;
 29 import java.io.IOException;
 30 import java.io.DataOutputStream;
 31 
 32 /**
 33  * This class is used to assemble the local variable table.
 34  *
 35  * WARNING: The contents of this source file are not part of any
 36  * supported API.  Code that depends on them does so at its own risk:
 37  * they are subject to change or removal without notice.
 38  *
 39  * @author Arthur van Hoff
 40  */
 41 final
 42 class LocalVariableTable {
 43     LocalVariable locals[] = new LocalVariable[8];
 44     int len;
 45 
 46     /**
 47      * Define a new local variable. Merge entries where possible.
 48      */
 49     void define(MemberDefinition field, int slot, int from, int to) {
 50         if (from &gt;= to) {
 51             return;
 52         }
 53         for (int i = 0 ; i &lt; len ; i++) {
 54             if ((locals[i].field == field) &amp;&amp; (locals[i].slot == slot) &amp;&amp;
 55                 (from &lt;= locals[i].to) &amp;&amp; (to &gt;= locals[i].from)) {
 56                 locals[i].from = Math.min(locals[i].from, from);
 57                 locals[i].to = Math.max(locals[i].to, to);
 58                 return;
 59             }
 60         }
 61         if (len == locals.length) {
 62             LocalVariable newlocals[] = new LocalVariable[len * 2];
 63             System.arraycopy(locals, 0, newlocals, 0, len);
 64             locals = newlocals;
 65         }
 66         locals[len++] = new LocalVariable(field, slot, from, to);
 67     }
 68 
 69     /**
 70      * Trim overlapping local ranges.  Java forbids shadowing of
 71      * locals in nested scopes, but non-nested scopes may still declare
 72      * locals with the same name.  Because local variable ranges are
 73      * computed using flow analysis as part of assembly, it isn&#39;t
 74      * possible to simply make sure variable ranges end where the
 75      * enclosing lexical scope ends.  This method makes sure that
 76      * variables with the same name don&#39;t overlap, giving priority to
 77      * fields with higher slot numbers that should have appeared later
 78      * in the source.
 79      */
 80     private void trim_ranges() {
 81         for (int i=0; i&lt;len; i++) {
 82             for (int j=i+1; j&lt;len; j++) {
 83                 if ((locals[i].field.getName()==locals[j].field.getName())
 84                         &amp;&amp; (locals[i].from &lt;= locals[j].to)
 85                         &amp;&amp; (locals[i].to &gt;= locals[j].from)) {
 86                     // At this point we know that both ranges are
 87                     // the same name and there is also overlap or they abut
 88                     if (locals[i].slot &lt; locals[j].slot) {
 89                         if (locals[i].from &lt; locals[j].from) {
 90                           locals[i].to = Math.min(locals[i].to, locals[j].from);
 91                         } else {
 92                           // We&#39;ve detected two local variables with the
 93                           // same name, and the one with the greater slot
 94                           // number starts before the other.  This order
 95                           // reversal may happen with locals with the same
 96                           // name declared in both a try body and an
 97                           // associated catch clause.  This is rare, and
 98                           // we give up.
 99                         }
100                     } else if (locals[i].slot &gt; locals[j].slot) {
101                         if (locals[i].from &gt; locals[j].from) {
102                           locals[j].to = Math.min(locals[j].to, locals[i].from);
103                         } else {
104                           // Same situation as above; just give up.
105                         }
106                     } else {
107                         // This case can happen if there are two variables
108                         // with the same name and slot numbers, and ranges
109                         // that abut.  AFAIK the only way this can occur
110                         // is with multiple static initializers.  Punt.
111                     }
112                 }
113             }
114         }
115     }
116 
117     /**
118      * Write out the data.
119      */
120     void write(Environment env, DataOutputStream out, ConstantPool tab) throws IOException {
121         trim_ranges();
122         out.writeShort(len);
123         for (int i = 0 ; i &lt; len ; i++) {
124             //System.out.println(&quot;pc=&quot; + locals[i].from + &quot;, len=&quot; + (locals[i].to - locals[i].from) + &quot;, nm=&quot; + locals[i].field.getName() + &quot;, slot=&quot; + locals[i].slot);
125             out.writeShort(locals[i].from);
126             out.writeShort(locals[i].to - locals[i].from);
127             out.writeShort(tab.index(locals[i].field.getName().toString()));
128             out.writeShort(tab.index(locals[i].field.getType().getTypeSignature()));
129             out.writeShort(locals[i].slot);
130         }
131     }
132 }
    </pre>
  </body>
</html>
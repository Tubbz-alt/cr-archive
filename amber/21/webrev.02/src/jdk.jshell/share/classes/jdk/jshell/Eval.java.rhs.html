<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.jshell/share/classes/jdk/jshell/Eval.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2014, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package jdk.jshell;
  26 
  27 import java.util.ArrayList;
  28 import java.util.Collection;
  29 import java.util.Collections;
  30 import java.util.List;
  31 import java.util.Locale;
  32 import java.util.regex.Matcher;
  33 import java.util.regex.Pattern;
  34 import java.util.stream.Collectors;
  35 import javax.lang.model.element.Modifier;
  36 import com.sun.source.tree.ArrayTypeTree;
  37 import com.sun.source.tree.AssignmentTree;
  38 import com.sun.source.tree.ClassTree;
  39 import com.sun.source.tree.ExpressionStatementTree;
  40 import com.sun.source.tree.ExpressionTree;
  41 import com.sun.source.tree.IdentifierTree;
  42 import com.sun.source.tree.MethodTree;
  43 import com.sun.source.tree.ModifiersTree;
  44 import com.sun.source.tree.NewClassTree;
  45 import com.sun.source.tree.Tree;
  46 import com.sun.source.tree.VariableTree;
  47 import com.sun.tools.javac.tree.JCTree;
  48 import com.sun.tools.javac.tree.Pretty;
  49 import java.io.IOException;
  50 import java.io.StringWriter;
  51 import java.io.Writer;
  52 import java.util.Arrays;
  53 import java.util.LinkedHashSet;
  54 import java.util.Set;
  55 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo;
  56 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription;
  57 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo.AnonymousDescription.VariableDesc;
  58 import jdk.jshell.Key.ErroneousKey;
  59 import jdk.jshell.Key.MethodKey;
  60 import jdk.jshell.Key.TypeDeclKey;
  61 import jdk.jshell.Snippet.Kind;
  62 import jdk.jshell.Snippet.SubKind;
  63 import jdk.jshell.TaskFactory.AnalyzeTask;
  64 import jdk.jshell.TaskFactory.BaseTask;
  65 import jdk.jshell.TaskFactory.ParseTask;
  66 import jdk.jshell.Util.Pair;
  67 import jdk.jshell.Wrap.CompoundWrap;
  68 import jdk.jshell.Wrap.Range;
  69 import jdk.jshell.Snippet.Status;
  70 import jdk.jshell.spi.ExecutionControl.ClassBytecodes;
  71 import jdk.jshell.spi.ExecutionControl.ClassInstallException;
  72 import jdk.jshell.spi.ExecutionControl.EngineTerminationException;
  73 import jdk.jshell.spi.ExecutionControl.InternalException;
  74 import jdk.jshell.spi.ExecutionControl.NotImplementedException;
  75 import jdk.jshell.spi.ExecutionControl.ResolutionException;
  76 import jdk.jshell.spi.ExecutionControl.RunException;
  77 import jdk.jshell.spi.ExecutionControl.UserException;
  78 import static java.util.stream.Collectors.toList;
  79 import static java.util.stream.Collectors.toSet;
  80 import static java.util.Collections.singletonList;
  81 import com.sun.tools.javac.code.Symbol.TypeSymbol;
<a name="1" id="anc1"></a><span class="line-added">  82 import java.util.EnumSet;</span>
  83 import static jdk.internal.jshell.debug.InternalDebugControl.DBG_GEN;
  84 import static jdk.jshell.Util.DOIT_METHOD_NAME;
  85 import static jdk.jshell.Util.PREFIX_PATTERN;
  86 import static jdk.jshell.Util.expunge;
  87 import static jdk.jshell.Snippet.SubKind.SINGLE_TYPE_IMPORT_SUBKIND;
  88 import static jdk.jshell.Snippet.SubKind.SINGLE_STATIC_IMPORT_SUBKIND;
  89 import static jdk.jshell.Snippet.SubKind.TYPE_IMPORT_ON_DEMAND_SUBKIND;
  90 import static jdk.jshell.Snippet.SubKind.STATIC_IMPORT_ON_DEMAND_SUBKIND;
  91 
  92 /**
  93  * The Evaluation Engine. Source internal analysis, wrapping control,
  94  * compilation, declaration. redefinition, replacement, and execution.
  95  *
  96  * @author Robert Field
  97  */
  98 class Eval {
  99 
 100     private static final Pattern IMPORT_PATTERN = Pattern.compile(&quot;import\\p{javaWhitespace}+(?&lt;static&gt;static\\p{javaWhitespace}+)?(?&lt;fullname&gt;[\\p{L}\\p{N}_\\$\\.]+\\.(?&lt;name&gt;[\\p{L}\\p{N}_\\$]+|\\*))&quot;);
 101     private static final Pattern DEFAULT_PREFIX = Pattern.compile(&quot;\\p{javaWhitespace}*(default)\\p{javaWhitespace}+&quot;);
 102 
 103     // for uses that should not change state -- non-evaluations
 104     private boolean preserveState = false;
 105 
 106     private int varNumber = 0;
 107 
 108     /* The number of anonymous innerclasses seen so far. Used to generate unique
 109      * names of these classes.
 110      */
 111     private int anonCount = 0;
 112 
 113     private final JShell state;
 114 
 115     // The set of names of methods on Object
 116     private final Set&lt;String&gt; objectMethods = Arrays
 117             .stream(Object.class.getMethods())
 118             .map(m -&gt; m.getName())
 119             .collect(toSet());
 120 
 121     Eval(JShell state) {
 122         this.state = state;
 123     }
 124 
 125     /**
 126      * Evaluates a snippet of source.
 127      *
 128      * @param userSource the source of the snippet
 129      * @return the list of primary and update events
 130      * @throws IllegalStateException
 131      */
 132     List&lt;SnippetEvent&gt; eval(String userSource) throws IllegalStateException {
 133         List&lt;SnippetEvent&gt; allEvents = new ArrayList&lt;&gt;();
 134         for (Snippet snip : sourceToSnippets(userSource)) {
 135             if (snip.kind() == Kind.ERRONEOUS) {
 136                 state.maps.installSnippet(snip);
 137                 allEvents.add(new SnippetEvent(
 138                         snip, Status.NONEXISTENT, Status.REJECTED,
 139                         false, null, null, null));
 140             } else {
 141                 allEvents.addAll(declare(snip, snip.syntheticDiags()));
 142             }
 143         }
 144         return allEvents;
 145     }
 146 
 147     /**
 148      * Converts the user source of a snippet into a Snippet list -- Snippet will
 149      * have wrappers.
 150      *
 151      * @param userSource the source of the snippet
 152      * @return usually a singleton list of Snippet, but may be empty or multiple
 153      */
 154     List&lt;Snippet&gt; sourceToSnippetsWithWrappers(String userSource) {
 155         List&lt;Snippet&gt; snippets = sourceToSnippets(userSource);
 156         for (Snippet snip : snippets) {
 157             if (snip.outerWrap() == null) {
 158                 snip.setOuterWrap(
 159                         (snip.kind() == Kind.IMPORT)
 160                                 ? state.outerMap.wrapImport(snip.guts(), snip)
 161                                 : state.outerMap.wrapInTrialClass(snip.guts())
 162                 );
 163             }
 164         }
 165         return snippets;
 166     }
 167 
 168     /**
 169      * Converts the user source of a snippet into a Snippet object (or list of
 170      * objects in the case of: int x, y, z;).  Does not install the Snippets
 171      * or execute them.  Does not change any state.
 172      *
 173      * @param userSource the source of the snippet
 174      * @return usually a singleton list of Snippet, but may be empty or multiple
 175      */
 176     List&lt;Snippet&gt; toScratchSnippets(String userSource) {
 177         try {
 178             preserveState = true;
 179             return sourceToSnippets(userSource);
 180         } finally {
 181             preserveState = false;
 182         }
 183     }
 184 
 185     /**
 186      * Converts the user source of a snippet into a Snippet object (or list of
 187      * objects in the case of: int x, y, z;).  Does not install the Snippets
 188      * or execute them.
 189      *
 190      * @param userSource the source of the snippet
 191      * @return usually a singleton list of Snippet, but may be empty or multiple
 192      */
 193     private List&lt;Snippet&gt; sourceToSnippets(String userSource) {
<a name="2" id="anc2"></a><span class="line-modified"> 194         String compileSource = Util.trimEnd(new MaskCommentsAndModifiers(userSource, false, false).cleared());</span>
 195         if (compileSource.length() == 0) {
 196             return Collections.emptyList();
 197         }
 198         return state.taskFactory.parse(compileSource, pt -&gt; {
 199             List&lt;? extends Tree&gt; units = pt.units();
 200             if (units.isEmpty()) {
 201                 return compileFailResult(pt, userSource, Kind.ERRONEOUS);
 202             }
 203             Tree unitTree = units.get(0);
 204             if (pt.getDiagnostics().hasOtherThanNotStatementErrors()) {
 205                 Matcher matcher = DEFAULT_PREFIX.matcher(compileSource);
 206                 DiagList dlist = matcher.lookingAt()
 207                         ? new DiagList(new ModifierDiagnostic(true,
 208                             state.messageFormat(&quot;jshell.diag.modifier.single.fatal&quot;, &quot;&#39;default&#39;&quot;),
 209                             matcher.start(1), matcher.end(1)))
 210                         : pt.getDiagnostics();
 211                 return compileFailResult(dlist, userSource, kindOfTree(unitTree));
 212             }
 213 
 214             // Erase illegal/ignored modifiers
<a name="3" id="anc3"></a><span class="line-modified"> 215             String compileSourceInt = new MaskCommentsAndModifiers(compileSource, true, CLASS_LIKE_KINDS.contains(unitTree.getKind())).cleared();</span>
 216 
 217             state.debug(DBG_GEN, &quot;Kind: %s -- %s\n&quot;, unitTree.getKind(), unitTree);
 218             switch (unitTree.getKind()) {
 219                 case IMPORT:
 220                     return processImport(userSource, compileSourceInt);
 221                 case VARIABLE:
 222                     return processVariables(userSource, units, compileSourceInt, pt);
 223                 case EXPRESSION_STATEMENT:
 224                     return processExpression(userSource, unitTree, compileSourceInt, pt);
 225                 case CLASS:
 226                     return processClass(userSource, unitTree, compileSourceInt, SubKind.CLASS_SUBKIND, pt);
 227                 case ENUM:
 228                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ENUM_SUBKIND, pt);
 229                 case ANNOTATION_TYPE:
 230                     return processClass(userSource, unitTree, compileSourceInt, SubKind.ANNOTATION_TYPE_SUBKIND, pt);
 231                 case INTERFACE:
 232                     return processClass(userSource, unitTree, compileSourceInt, SubKind.INTERFACE_SUBKIND, pt);
 233                 case RECORD:
 234                     @SuppressWarnings(&quot;preview&quot;)
 235                     List&lt;Snippet&gt; snippets = processClass(userSource, unitTree, compileSourceInt, SubKind.RECORD_SUBKIND, pt);
 236                     return snippets;
 237                 case METHOD:
 238                     return processMethod(userSource, unitTree, compileSourceInt, pt);
 239                 default:
 240                     return processStatement(userSource, compileSourceInt);
 241             }
 242         });
 243     }
 244 
<a name="4" id="anc4"></a><span class="line-added"> 245     @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-added"> 246     private static final Set&lt;Tree.Kind&gt; CLASS_LIKE_KINDS =</span>
<span class="line-added"> 247             EnumSet.of(Tree.Kind.ANNOTATION_TYPE, Tree.Kind.CLASS, Tree.Kind.ENUM,</span>
<span class="line-added"> 248                        Tree.Kind.INTERFACE, Tree.Kind.RECORD);</span>
<span class="line-added"> 249 </span>
 250     private List&lt;Snippet&gt; processImport(String userSource, String compileSource) {
 251         Wrap guts = Wrap.simpleWrap(compileSource);
 252         Matcher mat = IMPORT_PATTERN.matcher(compileSource);
 253         String fullname;
 254         String name;
 255         boolean isStatic;
 256         if (mat.find()) {
 257             isStatic = mat.group(&quot;static&quot;) != null;
 258             name = mat.group(&quot;name&quot;);
 259             fullname = mat.group(&quot;fullname&quot;);
 260         } else {
 261             // bad import -- fake it
 262             isStatic = compileSource.contains(&quot;static&quot;);
 263             name = fullname = compileSource;
 264         }
 265         String fullkey = (isStatic ? &quot;static-&quot; : &quot;&quot;) + fullname;
 266         boolean isStar = name.equals(&quot;*&quot;);
 267         String keyName = isStar
 268                 ? fullname
 269                 : name;
 270         SubKind snippetKind = isStar
 271                 ? (isStatic ? STATIC_IMPORT_ON_DEMAND_SUBKIND : TYPE_IMPORT_ON_DEMAND_SUBKIND)
 272                 : (isStatic ? SINGLE_STATIC_IMPORT_SUBKIND : SINGLE_TYPE_IMPORT_SUBKIND);
 273         Snippet snip = new ImportSnippet(state.keyMap.keyForImport(keyName, snippetKind),
 274                 userSource, guts, fullname, name, snippetKind, fullkey, isStatic, isStar);
 275         return singletonList(snip);
 276     }
 277 
 278     private static class EvalPretty extends Pretty {
 279 
 280         private final Writer out;
 281 
 282         public EvalPretty(Writer writer, boolean bln) {
 283             super(writer, bln);
 284             this.out = writer;
 285         }
 286 
 287         /**
 288          * Print string, DO NOT replacing all non-ascii character with unicode
 289          * escapes.
 290          */
 291         @Override
 292         public void print(Object o) throws IOException {
 293             out.write(o.toString());
 294         }
 295 
 296         static String prettyExpr(JCTree tree, boolean bln) {
 297             StringWriter out = new StringWriter();
 298             try {
 299                 new EvalPretty(out, bln).printExpr(tree);
 300             } catch (IOException e) {
 301                 throw new AssertionError(e);
 302             }
 303             return out.toString();
 304         }
 305     }
 306 
 307     private List&lt;Snippet&gt; processVariables(String userSource, List&lt;? extends Tree&gt; units, String compileSource, ParseTask pt) {
 308         List&lt;Snippet&gt; snippets = new ArrayList&lt;&gt;();
 309         TreeDissector dis = TreeDissector.createByFirstClass(pt);
 310         for (Tree unitTree : units) {
 311             VariableTree vt = (VariableTree) unitTree;
 312             String name = vt.getName().toString();
 313             String typeName;
 314             String fullTypeName;
 315             String displayType;
 316             boolean hasEnhancedType = false;
 317             TreeDependencyScanner tds = new TreeDependencyScanner();
 318             Wrap typeWrap;
 319             Wrap anonDeclareWrap = null;
 320             Wrap winit = null;
 321             boolean enhancedDesugaring = false;
 322             Set&lt;String&gt; anonymousClasses = Collections.emptySet();
 323             StringBuilder sbBrackets = new StringBuilder();
 324             Tree baseType = vt.getType();
 325             if (baseType != null) {
 326                 tds.scan(baseType); // Not dependent on initializer
 327                 fullTypeName = displayType = typeName = EvalPretty.prettyExpr((JCTree) vt.getType(), false);
 328                 while (baseType instanceof ArrayTypeTree) {
 329                     //TODO handle annotations too
 330                     baseType = ((ArrayTypeTree) baseType).getType();
 331                     sbBrackets.append(&quot;[]&quot;);
 332                 }
 333                 Range rtype = dis.treeToRange(baseType);
 334                 typeWrap = Wrap.rangeWrap(compileSource, rtype);
 335             } else {
 336                 DiagList dl = trialCompile(Wrap.methodWrap(compileSource));
 337                 if (dl.hasErrors()) {
 338                     return compileFailResult(dl, userSource, kindOfTree(unitTree));
 339                 }
 340                 Tree init = vt.getInitializer();
 341                 if (init != null) {
 342                     Range rinit = dis.treeToRange(init);
 343                     String initCode = rinit.part(compileSource);
 344                     ExpressionInfo ei =
 345                             ExpressionToTypeInfo.localVariableTypeForInitializer(initCode, state, false);
 346                     if (ei != null &amp;&amp; ei.declareTypeName != null) {
 347                         typeName = ei.declareTypeName;
 348                         fullTypeName = ei.fullTypeName;
 349                         displayType = ei.displayTypeName;
 350 
 351                         hasEnhancedType = !typeName.equals(fullTypeName);
 352 
 353                         enhancedDesugaring = !ei.isPrimitiveType;
 354 
 355                         Pair&lt;Wrap, Wrap&gt; anonymous2Member =
 356                                 anonymous2Member(ei, compileSource, rinit, dis, init);
 357                         anonDeclareWrap = anonymous2Member.first;
 358                         winit = anonymous2Member.second;
 359                         anonymousClasses = ei.anonymousClasses.stream().map(ad -&gt; ad.declareTypeName).collect(Collectors.toSet());
 360                     } else {
 361                         displayType = fullTypeName = typeName = &quot;java.lang.Object&quot;;
 362                     }
 363                     tds.scan(init);
 364                 } else {
 365                     displayType = fullTypeName = typeName = &quot;java.lang.Object&quot;;
 366                 }
 367                 typeWrap = Wrap.identityWrap(typeName);
 368             }
 369             Range runit = dis.treeToRange(vt);
 370             runit = new Range(runit.begin, runit.end - 1);
 371             ExpressionTree it = vt.getInitializer();
 372             int nameMax = runit.end - 1;
 373             SubKind subkind;
 374             if (it != null) {
 375                 subkind = SubKind.VAR_DECLARATION_WITH_INITIALIZER_SUBKIND;
 376                 Range rinit = dis.treeToRange(it);
 377                 winit = winit == null ? Wrap.rangeWrap(compileSource, rinit) : winit;
 378                 nameMax = rinit.begin - 1;
 379             } else {
 380                 String sinit;
 381                 switch (typeName) {
 382                     case &quot;byte&quot;:
 383                     case &quot;short&quot;:
 384                     case &quot;int&quot;:
 385                         sinit = &quot;0&quot;;
 386                         break;
 387                     case &quot;long&quot;:
 388                         sinit = &quot;0L&quot;;
 389                         break;
 390                     case &quot;float&quot;:
 391                         sinit = &quot;0.0f&quot;;
 392                         break;
 393                     case &quot;double&quot;:
 394                         sinit = &quot;0.0d&quot;;
 395                         break;
 396                     case &quot;boolean&quot;:
 397                         sinit = &quot;false&quot;;
 398                         break;
 399                     case &quot;char&quot;:
 400                         sinit = &quot;&#39;\\u0000&#39;&quot;;
 401                         break;
 402                     default:
 403                         sinit = &quot;null&quot;;
 404                         break;
 405                 }
 406                 winit = Wrap.simpleWrap(sinit);
 407                 subkind = SubKind.VAR_DECLARATION_SUBKIND;
 408             }
 409             int nameStart = compileSource.lastIndexOf(name, nameMax);
 410             if (nameStart &lt; 0) {
 411                 throw new AssertionError(&quot;Name &#39;&quot; + name + &quot;&#39; not found&quot;);
 412             }
 413             int nameEnd = nameStart + name.length();
 414             Range rname = new Range(nameStart, nameEnd);
 415             Wrap guts = Wrap.varWrap(compileSource, typeWrap, sbBrackets.toString(), rname,
 416                                      winit, enhancedDesugaring, anonDeclareWrap);
 417             DiagList modDiag = modifierDiagnostics(vt.getModifiers(), dis, true);
 418             Snippet snip = new VarSnippet(state.keyMap.keyForVariable(name), userSource, guts,
 419                     name, subkind, displayType, hasEnhancedType ? fullTypeName : null, anonymousClasses,
 420                     tds.declareReferences(), modDiag);
 421             snippets.add(snip);
 422         }
 423         return snippets;
 424     }
 425 
 426     /**Convert anonymous classes in &quot;init&quot; to member classes, based
 427      * on the additional information from ExpressionInfo.anonymousClasses.
 428      *
 429      * This means:
 430      * -if the code in the anonymous class captures any variables from the
 431      *  enclosing context, create fields for them
 432      * -creating an explicit constructor that:
 433      * --if the new class expression has a base/enclosing expression, make it an
 434      *   explicit constructor parameter &quot;encl&quot; and use &quot;encl.super&quot; when invoking
 435      *   the supertype constructor
 436      * --if the (used) supertype constructor has any parameters, declare them
 437      *   as explicit parameters of the constructor, and pass them to the super
 438      *   constructor
 439      * --if the code in the anonymous class captures any variables from the
 440      *   enclosing context, make them an explicit paramters of the constructor
 441      *   and assign to respective fields.
 442      * --if there are any explicit fields with initializers in the anonymous class,
 443      *   move the initializers at the end of the constructor (after the captured fields
 444      *   are assigned, so that the initializers of these fields can use them).
 445      * -from the captured variables fields, constructor, and existing members
 446      *  (with cleared field initializers), create an explicit class that extends or
 447      *  implements the supertype of the anonymous class.
 448      *
 449      * This method returns two wraps: the first contains the class declarations for the
 450      * converted classes, the first one should be used instead of &quot;init&quot; in the variable
 451      * declaration.
 452      */
 453     private Pair&lt;Wrap, Wrap&gt; anonymous2Member(ExpressionInfo ei,
 454                                               String compileSource,
 455                                               Range rinit,
 456                                               TreeDissector dis,
 457                                               Tree init) {
 458         List&lt;Wrap&gt; anonymousDeclarations = new ArrayList&lt;&gt;();
 459         List&lt;Wrap&gt; partitionedInit = new ArrayList&lt;&gt;();
 460         int lastPos = rinit.begin;
 461         com.sun.tools.javac.util.List&lt;NewClassTree&gt; toConvert =
 462                 ExpressionToTypeInfo.listAnonymousClassesToConvert(init);
 463         com.sun.tools.javac.util.List&lt;AnonymousDescription&gt; descriptions =
 464                 ei.anonymousClasses;
 465         while (toConvert.nonEmpty() &amp;&amp; descriptions.nonEmpty()) {
 466             NewClassTree node = toConvert.head;
 467             AnonymousDescription ad = descriptions.head;
 468 
 469             toConvert = toConvert.tail;
 470             descriptions = descriptions.tail;
 471 
 472             List&lt;Object&gt; classBodyParts = new ArrayList&lt;&gt;();
 473             //declarations of the captured variables:
 474             for (VariableDesc vd : ad.capturedVariables) {
 475                 classBodyParts.add(vd.type + &quot; &quot; + vd.name + &quot;;\n&quot;);
 476             }
 477 
 478             List&lt;Object&gt; constructorParts = new ArrayList&lt;&gt;();
 479             constructorParts.add(ad.declareTypeName + &quot;(&quot;);
 480             String sep = &quot;&quot;;
 481             //add the parameter for the base/enclosing expression, if any:
 482             if (ad.enclosingInstanceType != null) {
 483                 constructorParts.add(ad.enclosingInstanceType + &quot; encl&quot;);
 484                 sep = &quot;, &quot;;
 485             }
 486             int idx = 0;
 487             //add parameters of the super constructor, if any:
 488             for (String type : ad.parameterTypes) {
 489                 constructorParts.add(sep);
 490                 constructorParts.add(type + &quot; &quot; + &quot;arg&quot; + idx++);
 491                 sep = &quot;, &quot;;
 492             }
 493             //add parameters for the captured variables:
 494             for (VariableDesc vd : ad.capturedVariables) {
 495                 constructorParts.add(sep);
 496                 constructorParts.add(vd.type + &quot; &quot; + &quot;cap$&quot; + vd.name);
 497                 sep = &quot;, &quot;;
 498             }
 499             //construct super constructor call:
 500             if (ad.enclosingInstanceType != null) {
 501                 //if there&#39;s an enclosing instance, call super on it:
 502                 constructorParts.add(&quot;) { encl.super (&quot;);
 503             } else {
 504                 constructorParts.add(&quot;) { super (&quot;);
 505             }
 506             sep = &quot;&quot;;
 507             for (int i = 0; i &lt; idx; i++) {
 508                 constructorParts.add(sep);
 509                 constructorParts.add(&quot;arg&quot; + i);
 510                 sep = &quot;, &quot;;
 511             }
 512             constructorParts.add(&quot;);&quot;);
 513             //initialize the captured variables:
 514             for (VariableDesc vd : ad.capturedVariables) {
 515                 constructorParts.add(&quot;this.&quot; + vd.name + &quot; = &quot; + &quot;cap$&quot; + vd.name + &quot;;\n&quot;);
 516             }
 517             List&lt;? extends Tree&gt; members =
 518                     node.getClassBody().getMembers();
 519             for (Tree member : members) {
 520                 if (member.getKind() == Tree.Kind.VARIABLE) {
 521                     VariableTree vt = (VariableTree) member;
 522 
 523                     if (vt.getInitializer() != null) {
 524                         //for variables with initializer, explicitly move the initializer
 525                         //to the constructor after the captured variables as assigned
 526                         //(the initializers would otherwise run too early):
 527                         Range wholeVar = dis.treeToRange(vt);
 528                         int name = ((JCTree) vt).pos;
 529                         classBodyParts.add(new CompoundWrap(Wrap.rangeWrap(compileSource,
 530                                                                       new Range(wholeVar.begin, name)),
 531                                                        vt.getName().toString(),
 532                                                        &quot;;\n&quot;));
 533                         constructorParts.add(Wrap.rangeWrap(compileSource,
 534                                                             new Range(name, wholeVar.end)));
 535                         continue;
 536                     }
 537                 }
 538                 classBodyParts.add(Wrap.rangeWrap(compileSource,
 539                                              dis.treeToRange(member)));
 540             }
 541 
 542             constructorParts.add(&quot;}&quot;);
 543 
 544             //construct the member class:
 545             classBodyParts.add(new CompoundWrap(constructorParts.toArray()));
 546 
 547             Wrap classBodyWrap = new CompoundWrap(classBodyParts.toArray());
 548 
 549             anonymousDeclarations.add(new CompoundWrap(&quot;public static class &quot;, ad.declareTypeName,
 550                                          (ad.isClass ? &quot; extends &quot; : &quot; implements &quot;),
 551                                          ad.superTypeName, &quot; { &quot;, classBodyWrap, &quot;}&quot;));
 552 
 553             //change the new class expression to use the newly created member type:
 554             Range argRange = dis.treeListToRange(node.getArguments());
 555             Wrap argWrap;
 556 
 557             if (argRange != null) {
 558                 argWrap = Wrap.rangeWrap(compileSource, argRange);
 559             } else {
 560                 argWrap = Wrap.simpleWrap(&quot; &quot;);
 561             }
 562 
 563             if (ad.enclosingInstanceType != null) {
 564                 //if there&#39;s an enclosing expression, set it as the first parameter:
 565                 Range enclosingRanges =
 566                         dis.treeToRange(node.getEnclosingExpression());
 567                 Wrap enclosingWrap = Wrap.rangeWrap(compileSource, enclosingRanges);
 568                 argWrap = argRange != null ? new CompoundWrap(enclosingWrap,
 569                                                               Wrap.simpleWrap(&quot;,&quot;),
 570                                                               argWrap)
 571                                            : enclosingWrap;
 572             }
 573 
 574             Range current = dis.treeToRange(node);
 575             String capturedArgs;
 576             if (!ad.capturedVariables.isEmpty()) {
 577                 capturedArgs = (ad.parameterTypes.isEmpty() ? &quot;&quot; : &quot;, &quot;) +
 578                                ad.capturedVariables.stream()
 579                                                    .map(vd -&gt; vd.name)
 580                                                    .collect(Collectors.joining(&quot;,&quot;));
 581             } else {
 582                 capturedArgs = &quot;&quot;;
 583             }
 584             if (lastPos &lt; current.begin)
 585                 partitionedInit.add(Wrap.rangeWrap(compileSource,
 586                                                    new Range(lastPos, current.begin)));
 587             partitionedInit.add(new CompoundWrap(&quot;new &quot; + ad.declareTypeName + &quot;(&quot;,
 588                                                  argWrap,
 589                                                  capturedArgs,
 590                                                  &quot;)&quot;));
 591             lastPos = current.end;
 592         }
 593 
 594         if (lastPos &lt; rinit.end)
 595             partitionedInit.add(Wrap.rangeWrap(compileSource, new Range(lastPos, rinit.end)));
 596 
 597         return new Pair&lt;&gt;(new CompoundWrap(anonymousDeclarations.toArray()),
 598                           new CompoundWrap(partitionedInit.toArray()));
 599     }
 600 
 601     private List&lt;Snippet&gt; processExpression(String userSource, Tree tree, String compileSource, ParseTask pt) {
 602         ExpressionStatementTree expr = (ExpressionStatementTree) tree;
 603         String name = null;
 604         ExpressionInfo ei = ExpressionToTypeInfo.expressionInfo(compileSource, state);
 605         ExpressionTree assignVar;
 606         Wrap guts;
 607         Snippet snip;
 608         if (ei != null &amp;&amp; ei.isNonVoid) {
 609             String typeName = ei.typeName;
 610             SubKind subkind;
 611             if (ei.tree instanceof IdentifierTree) {
 612                 IdentifierTree id = (IdentifierTree) ei.tree;
 613                 name = id.getName().toString();
 614                 subkind = SubKind.VAR_VALUE_SUBKIND;
 615 
 616             } else if (ei.tree instanceof AssignmentTree
 617                     &amp;&amp; (assignVar = ((AssignmentTree) ei.tree).getVariable()) instanceof IdentifierTree) {
 618                 name = assignVar.toString();
 619                 subkind = SubKind.ASSIGNMENT_SUBKIND;
 620             } else {
 621                 subkind = SubKind.OTHER_EXPRESSION_SUBKIND;
 622             }
 623             if (shouldGenTempVar(subkind)) {
 624                 if (preserveState) {
 625                     name = &quot;$$&quot;;
 626                 } else {
 627                     if (state.tempVariableNameGenerator != null) {
 628                         name = state.tempVariableNameGenerator.get();
 629                     }
 630                     while (name == null || state.keyMap.doesVariableNameExist(name)) {
 631                         name = &quot;$&quot; + ++varNumber;
 632                     }
 633                 }
 634                 ExpressionInfo varEI =
 635                         ExpressionToTypeInfo.localVariableTypeForInitializer(compileSource, state, true);
 636                 String declareTypeName;
 637                 String fullTypeName;
 638                 String displayTypeName;
 639                 Set&lt;String&gt; anonymousClasses;
 640                 if (varEI != null) {
 641                     declareTypeName = varEI.declareTypeName;
 642                     fullTypeName = varEI.fullTypeName;
 643                     displayTypeName = varEI.displayTypeName;
 644 
 645                     TreeDissector dis = TreeDissector.createByFirstClass(pt);
 646                     Pair&lt;Wrap, Wrap&gt; anonymous2Member =
 647                             anonymous2Member(varEI, compileSource, new Range(0, compileSource.length()), dis, expr.getExpression());
 648                     guts = Wrap.tempVarWrap(anonymous2Member.second.wrapped(), declareTypeName, name, anonymous2Member.first);
 649                     anonymousClasses = varEI.anonymousClasses.stream().map(ad -&gt; ad.declareTypeName).collect(Collectors.toSet());
 650                 } else {
 651                     declareTypeName = ei.accessibleTypeName;
 652                     displayTypeName = fullTypeName = typeName;
 653                     guts = Wrap.tempVarWrap(compileSource, declareTypeName, name, null);
 654                     anonymousClasses = Collections.emptySet();
 655                 }
 656                 Collection&lt;String&gt; declareReferences = null; //TODO
 657                 snip = new VarSnippet(state.keyMap.keyForVariable(name), userSource, guts,
 658                         name, SubKind.TEMP_VAR_EXPRESSION_SUBKIND, displayTypeName, fullTypeName, anonymousClasses, declareReferences, null);
 659             } else {
 660                 guts = Wrap.methodReturnWrap(compileSource);
 661                 snip = new ExpressionSnippet(state.keyMap.keyForExpression(name, typeName), userSource, guts,
 662                         name, subkind);
 663             }
 664         } else {
 665             guts = Wrap.methodWrap(compileSource);
 666             if (ei == null) {
 667                 // We got no type info, check for not a statement by trying
 668                 DiagList dl = trialCompile(guts);
 669                 if (dl.hasNotStatement()) {
 670                     guts = Wrap.methodReturnWrap(compileSource);
 671                     dl = trialCompile(guts);
 672                 }
 673                 if (dl.hasErrors()) {
 674                     return compileFailResult(dl, userSource, Kind.EXPRESSION);
 675                 }
 676             }
 677             snip = new StatementSnippet(state.keyMap.keyForStatement(), userSource, guts);
 678         }
 679         return singletonList(snip);
 680     }
 681 
 682     private List&lt;Snippet&gt; processClass(String userSource, Tree unitTree, String compileSource, SubKind snippetKind, ParseTask pt) {
 683         TreeDependencyScanner tds = new TreeDependencyScanner();
 684         tds.scan(unitTree);
 685 
 686         TreeDissector dis = TreeDissector.createByFirstClass(pt);
 687 
 688         ClassTree klassTree = (ClassTree) unitTree;
 689         String name = klassTree.getSimpleName().toString();
 690         DiagList modDiag = modifierDiagnostics(klassTree.getModifiers(), dis, false);
 691         TypeDeclKey key = state.keyMap.keyForClass(name);
 692         // Corralling
 693         Wrap corralled = new Corraller(dis, key.index(), compileSource).corralType(klassTree);
 694 
 695         Wrap guts = Wrap.classMemberWrap(compileSource);
 696         Snippet snip = new TypeDeclSnippet(key, userSource, guts,
 697                 name, snippetKind,
 698                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
 699         return singletonList(snip);
 700     }
 701 
 702     private List&lt;Snippet&gt; processStatement(String userSource, String compileSource) {
 703         Wrap guts = Wrap.methodWrap(compileSource);
 704         // Check for unreachable by trying
 705         DiagList dl = trialCompile(guts);
 706         if (dl.hasErrors()) {
 707             if (dl.hasUnreachableError()) {
 708                 guts = Wrap.methodUnreachableSemiWrap(compileSource);
 709                 dl = trialCompile(guts);
 710                 if (dl.hasErrors()) {
 711                     if (dl.hasUnreachableError()) {
 712                         // Without ending semicolon
 713                         guts = Wrap.methodUnreachableWrap(compileSource);
 714                         dl = trialCompile(guts);
 715                     }
 716                     if (dl.hasErrors()) {
 717                         return compileFailResult(dl, userSource, Kind.STATEMENT);
 718                     }
 719                 }
 720             } else {
 721                 return compileFailResult(dl, userSource, Kind.STATEMENT);
 722             }
 723         }
 724         Snippet snip = new StatementSnippet(state.keyMap.keyForStatement(), userSource, guts);
 725         return singletonList(snip);
 726     }
 727 
 728     private DiagList trialCompile(Wrap guts) {
 729         OuterWrap outer = state.outerMap.wrapInTrialClass(guts);
 730         return state.taskFactory.analyze(outer, AnalyzeTask::getDiagnostics);
 731     }
 732 
 733     private List&lt;Snippet&gt; processMethod(String userSource, Tree unitTree, String compileSource, ParseTask pt) {
 734         TreeDependencyScanner tds = new TreeDependencyScanner();
 735         tds.scan(unitTree);
 736         final TreeDissector dis = TreeDissector.createByFirstClass(pt);
 737 
 738         final MethodTree mt = (MethodTree) unitTree;
 739         final String name = mt.getName().toString();
 740         if (objectMethods.contains(name)) {
 741             // The name matches a method on Object, short of an overhaul, this
 742             // fails, see 8187137.  Generate a descriptive error message
 743 
 744             // The error position will be the position of the name, find it
 745             long possibleStart = dis.getEndPosition(mt.getReturnType());
 746             Range possibleRange = new Range((int) possibleStart,
 747                     dis.getStartPosition(mt.getBody()));
 748             String possibleNameSection = possibleRange.part(compileSource);
 749             int offset = possibleNameSection.indexOf(name);
 750             long start = offset &lt; 0
 751                     ? possibleStart // something wrong, punt
 752                     : possibleStart + offset;
 753 
 754             return compileFailResult(new DiagList(objectMethodNameDiag(name, start)), userSource, Kind.METHOD);
 755         }
 756         String parameterTypes
 757                 = mt.getParameters()
 758                 .stream()
 759                 .map(param -&gt; dis.treeToRange(param.getType()).part(compileSource))
 760                 .collect(Collectors.joining(&quot;,&quot;));
 761         Tree returnType = mt.getReturnType();
 762         DiagList modDiag = modifierDiagnostics(mt.getModifiers(), dis, true);
 763         MethodKey key = state.keyMap.keyForMethod(name, parameterTypes);
 764         // Corralling
 765         Wrap corralled = new Corraller(dis, key.index(), compileSource).corralMethod(mt);
 766 
 767         if (modDiag.hasErrors()) {
 768             return compileFailResult(modDiag, userSource, Kind.METHOD);
 769         }
 770         Wrap guts = Wrap.classMemberWrap(compileSource);
 771         Range typeRange = dis.treeToRange(returnType);
 772         String signature = &quot;(&quot; + parameterTypes + &quot;)&quot; + typeRange.part(compileSource);
 773 
 774         Snippet snip = new MethodSnippet(key, userSource, guts,
 775                 name, signature,
 776                 corralled, tds.declareReferences(), tds.bodyReferences(), modDiag);
 777         return singletonList(snip);
 778     }
 779 
 780     private Kind kindOfTree(Tree tree) {
 781         switch (tree.getKind()) {
 782             case IMPORT:
 783                 return Kind.IMPORT;
 784             case VARIABLE:
 785                 return Kind.VAR;
 786             case EXPRESSION_STATEMENT:
 787                 return Kind.EXPRESSION;
 788             case CLASS:
 789             case ENUM:
 790             case ANNOTATION_TYPE:
 791             case INTERFACE:
 792                 return Kind.TYPE_DECL;
 793             case METHOD:
 794                 return Kind.METHOD;
 795             default:
 796                 return Kind.STATEMENT;
 797         }
 798     }
 799 
 800     /**
 801      * The snippet has failed, return with the rejected snippet
 802      *
 803      * @param xt the task from which to extract the failure diagnostics
 804      * @param userSource the incoming bad user source
 805      * @return a rejected snippet
 806      */
 807     private List&lt;Snippet&gt; compileFailResult(BaseTask xt, String userSource, Kind probableKind) {
 808         return compileFailResult(xt.getDiagnostics(), userSource, probableKind);
 809     }
 810 
 811     /**
 812      * The snippet has failed, return with the rejected snippet
 813      *
 814      * @param diags the failure diagnostics
 815      * @param userSource the incoming bad user source
 816      * @return a rejected snippet
 817      */
 818     private List&lt;Snippet&gt; compileFailResult(DiagList diags, String userSource, Kind probableKind) {
 819         ErroneousKey key = state.keyMap.keyForErroneous();
 820         Snippet snip = new ErroneousSnippet(key, userSource, null,
 821                 probableKind, SubKind.UNKNOWN_SUBKIND);
 822         snip.setFailed(diags);
 823 
 824         // Install  wrapper for query by SourceCodeAnalysis.wrapper
<a name="5" id="anc5"></a><span class="line-modified"> 825         String compileSource = Util.trimEnd(new MaskCommentsAndModifiers(userSource, true, probableKind == Kind.TYPE_DECL).cleared());</span>
 826         OuterWrap outer;
 827         switch (probableKind) {
 828             case IMPORT:
 829                 outer = state.outerMap.wrapImport(Wrap.simpleWrap(compileSource), snip);
 830                 break;
 831             case EXPRESSION:
 832                 outer = state.outerMap.wrapInTrialClass(Wrap.methodReturnWrap(compileSource));
 833                 break;
 834             case VAR:
 835             case TYPE_DECL:
 836             case METHOD:
 837                 outer = state.outerMap.wrapInTrialClass(Wrap.classMemberWrap(compileSource));
 838                 break;
 839             default:
 840                 outer = state.outerMap.wrapInTrialClass(Wrap.methodWrap(compileSource));
 841                 break;
 842         }
 843         snip.setOuterWrap(outer);
 844 
 845         return singletonList(snip);
 846     }
 847 
 848     /**
 849      * Should a temp var wrap the expression. TODO make this user configurable.
 850      *
 851      * @param snippetKind
 852      * @return
 853      */
 854     private boolean shouldGenTempVar(SubKind snippetKind) {
 855         return snippetKind == SubKind.OTHER_EXPRESSION_SUBKIND;
 856     }
 857 
 858     List&lt;SnippetEvent&gt; drop(Snippet si) {
 859         Unit c = new Unit(state, si);
 860         Set&lt;Unit&gt; outs;
 861         if (si instanceof PersistentSnippet) {
 862             Set&lt;Unit&gt; ins = c.dependents().collect(toSet());
 863             outs = compileAndLoad(ins);
 864         } else {
 865             outs = Collections.emptySet();
 866         }
 867         return events(c, outs, null, null);
 868     }
 869 
 870     private List&lt;SnippetEvent&gt; declare(Snippet si, DiagList generatedDiagnostics) {
 871         Unit c = new Unit(state, si, null, generatedDiagnostics);
 872         Set&lt;Unit&gt; ins = new LinkedHashSet&lt;&gt;();
 873         ins.add(c);
 874         Set&lt;Unit&gt; outs = compileAndLoad(ins);
 875 
 876         if (!si.status().isDefined()
 877                 &amp;&amp; si.diagnostics().isEmpty()
 878                 &amp;&amp; si.unresolved().isEmpty()) {
 879             // did not succeed, but no record of it, extract from others
 880             si.setDiagnostics(outs.stream()
 881                     .flatMap(u -&gt; u.snippet().diagnostics().stream())
 882                     .collect(Collectors.toCollection(DiagList::new)));
 883         }
 884 
 885         // If appropriate, execute the snippet
 886         String value = null;
 887         JShellException exception = null;
 888         if (si.status().isDefined()) {
 889             if (si.isExecutable()) {
 890                 try {
 891                     value = state.executionControl().invoke(si.classFullName(), DOIT_METHOD_NAME);
 892                     value = si.subKind().hasValue()
 893                             ? expunge(value)
 894                             : &quot;&quot;;
 895                 } catch (ResolutionException ex) {
 896                     exception = asUnresolvedReferenceException(ex);
 897                 } catch (UserException ex) {
 898                     exception = asEvalException(ex);
 899                 } catch (RunException ex) {
 900                     // StopException - no-op
 901                 } catch (InternalException ex) {
 902                     state.debug(ex, &quot;invoke&quot;);
 903                 } catch (EngineTerminationException ex) {
 904                     state.debug(ex, &quot;termination&quot;);
 905                     state.closeDown();
 906                 }
 907             }
 908         }
 909         return events(c, outs, value, exception);
 910     }
 911 
 912     // Convert an internal UserException to an API EvalException, translating
 913     // the stack to snippet form.  Convert any chained exceptions
 914     private EvalException asEvalException(UserException ue) {
 915         return new EvalException(ue.getMessage(),
 916                 ue.causeExceptionClass(),
 917                 translateExceptionStack(ue),
 918                 asJShellException(ue.getCause()));
 919     }
 920 
 921     // Convert an internal ResolutionException to an API UnresolvedReferenceException,
 922     // translating the snippet id to snipper and the stack to snippet form
 923     private UnresolvedReferenceException asUnresolvedReferenceException(ResolutionException re) {
 924         DeclarationSnippet sn = (DeclarationSnippet) state.maps.getSnippetDeadOrAlive(re.id());
 925         return new UnresolvedReferenceException(sn, translateExceptionStack(re));
 926     }
 927 
 928     // Convert an internal UserException/ResolutionException to an API
 929     // EvalException/UnresolvedReferenceException
 930     private JShellException asJShellException(Throwable e) {
 931         if (e == null) {
 932             return null;
 933         } else if (e instanceof UserException) {
 934             return asEvalException((UserException) e);
 935         } else if (e instanceof ResolutionException) {
 936             return asUnresolvedReferenceException((ResolutionException) e);
 937         } else {
 938             throw new AssertionError(e);
 939         }
 940     }
 941 
 942     private boolean interestingEvent(SnippetEvent e) {
 943         return e.isSignatureChange()
 944                     || e.causeSnippet() == null
 945                     || e.status() != e.previousStatus()
 946                     || e.exception() != null;
 947     }
 948 
 949     private List&lt;SnippetEvent&gt; events(Unit c, Collection&lt;Unit&gt; outs, String value, JShellException exception) {
 950         List&lt;SnippetEvent&gt; events = new ArrayList&lt;&gt;();
 951         events.add(c.event(value, exception));
 952         events.addAll(outs.stream()
 953                 .filter(u -&gt; u != c)
 954                 .map(u -&gt; u.event(null, null))
 955                 .filter(this::interestingEvent)
 956                 .collect(Collectors.toList()));
 957         events.addAll(outs.stream()
 958                 .flatMap(u -&gt; u.secondaryEvents().stream())
 959                 .filter(this::interestingEvent)
 960                 .collect(Collectors.toList()));
 961         //System.err.printf(&quot;Events: %s\n&quot;, events);
 962         return events;
 963     }
 964 
 965     private Set&lt;OuterWrap&gt; outerWrapSet(Collection&lt;Unit&gt; units) {
 966         return units.stream()
 967                 .map(u -&gt; u.snippet().outerWrap())
 968                 .collect(toSet());
 969     }
 970 
 971     private Set&lt;Unit&gt; compileAndLoad(Set&lt;Unit&gt; ins) {
 972         if (ins.isEmpty()) {
 973             return ins;
 974         }
 975         Set&lt;Unit&gt; replaced = new LinkedHashSet&lt;&gt;();
 976         // Loop until dependencies and errors are stable
 977         while (true) {
 978             state.debug(DBG_GEN, &quot;compileAndLoad  %s\n&quot;, ins);
 979 
 980             ins.stream().forEach(Unit::initialize);
 981             ins.stream().forEach(u -&gt; u.setWrap(ins, ins));
 982             state.taskFactory.analyze(outerWrapSet(ins), at -&gt; {
 983                 ins.stream().forEach(u -&gt; u.setDiagnostics(at));
 984 
 985                 // corral any Snippets that need it
 986                 if (ins.stream().filter(u -&gt; u.corralIfNeeded(ins)).count() &gt; 0) {
 987                     // if any were corralled, re-analyze everything
 988                     state.taskFactory.analyze(outerWrapSet(ins), cat -&gt; {
 989                         ins.stream().forEach(u -&gt; u.setCorralledDiagnostics(cat));
 990                         ins.stream().forEach(u -&gt; u.setStatus(cat));
 991                         return null;
 992                     });
 993                 } else {
 994                     ins.stream().forEach(u -&gt; u.setStatus(at));
 995                 }
 996                 return null;
 997             });
 998             // compile and load the legit snippets
 999             boolean success;
1000             while (true) {
1001                 List&lt;Unit&gt; legit = ins.stream()
1002                         .filter(Unit::isDefined)
1003                         .collect(toList());
1004                 state.debug(DBG_GEN, &quot;compileAndLoad ins = %s -- legit = %s\n&quot;,
1005                         ins, legit);
1006                 if (legit.isEmpty()) {
1007                     // no class files can be generated
1008                     success = true;
1009                 } else {
1010                     // re-wrap with legit imports
1011                     legit.stream().forEach(u -&gt; u.setWrap(ins, legit));
1012 
1013                     // generate class files for those capable
1014                     Result res = state.taskFactory.compile(outerWrapSet(legit), ct -&gt; {
1015                         if (!ct.compile()) {
1016                             // oy! compile failed because of recursive new unresolved
1017                             if (legit.stream()
1018                                     .filter(u -&gt; u.smashingErrorDiagnostics(ct))
1019                                     .count() &gt; 0) {
1020                                 // try again, with the erroreous removed
1021                                 return Result.CONTINUE;
1022                             } else {
1023                                 state.debug(DBG_GEN, &quot;Should never happen error-less failure - %s\n&quot;,
1024                                         legit);
1025                             }
1026                         }
1027 
1028                         // load all new classes
1029                         load(legit.stream()
1030                                 .flatMap(u -&gt; u.classesToLoad(ct.classList(u.snippet().outerWrap())))
1031                                 .collect(toSet()));
1032                         // attempt to redefine the remaining classes
1033                         List&lt;Unit&gt; toReplace = legit.stream()
1034                                 .filter(u -&gt; !u.doRedefines())
1035                                 .collect(toList());
1036 
1037                         // prevent alternating redefine/replace cyclic dependency
1038                         // loop by replacing all that have been replaced
1039                         if (!toReplace.isEmpty()) {
1040                             replaced.addAll(toReplace);
1041                             replaced.stream().forEach(Unit::markForReplacement);
1042                             //ensure correct classnames are set in the snippets:
1043                             replaced.stream().forEach(u -&gt; u.setWrap(ins, legit));
1044                         }
1045 
1046                         return toReplace.isEmpty() ? Result.SUCESS : Result.FAILURE;
1047                     });
1048 
1049                     switch (res) {
1050                         case CONTINUE: continue;
1051                         case SUCESS: success = true; break;
1052                         default:
1053                         case FAILURE: success = false; break;
1054                     }
1055                 }
1056                 break;
1057             }
1058 
1059             // add any new dependencies to the working set
1060             List&lt;Unit&gt; newDependencies = ins.stream()
1061                     .flatMap(Unit::effectedDependents)
1062                     .collect(toList());
1063             state.debug(DBG_GEN, &quot;compileAndLoad %s -- deps: %s  success: %s\n&quot;,
1064                     ins, newDependencies, success);
1065             if (!ins.addAll(newDependencies) &amp;&amp; success) {
1066                 // all classes that could not be directly loaded (because they
1067                 // are new) have been redefined, and no new dependnencies were
1068                 // identified
1069                 ins.stream().forEach(Unit::finish);
1070                 return ins;
1071             }
1072         }
1073     }
1074     //where:
1075         enum Result {SUCESS, FAILURE, CONTINUE}
1076 
1077     /**
1078      * If there are classes to load, loads by calling the execution engine.
1079      * @param classbytecodes names of the classes to load.
1080      */
1081     private void load(Collection&lt;ClassBytecodes&gt; classbytecodes) {
1082         if (!classbytecodes.isEmpty()) {
1083             ClassBytecodes[] cbcs = classbytecodes.toArray(new ClassBytecodes[classbytecodes.size()]);
1084             try {
1085                 state.executionControl().load(cbcs);
1086                 state.classTracker.markLoaded(cbcs);
1087             } catch (ClassInstallException ex) {
1088                 state.classTracker.markLoaded(cbcs, ex.installed());
1089             } catch (NotImplementedException ex) {
1090                 state.debug(ex, &quot;Seriously?!? load not implemented&quot;);
1091                 state.closeDown();
1092             } catch (EngineTerminationException ex) {
1093                 state.closeDown();
1094             }
1095         }
1096     }
1097 
1098     private StackTraceElement[] translateExceptionStack(Exception ex) {
1099         StackTraceElement[] raw = ex.getStackTrace();
1100         int last = raw.length;
1101         do {
1102             if (last == 0) {
1103                 last = raw.length - 1;
1104                 break;
1105             }
1106         } while (!isWrap(raw[--last]));
1107         StackTraceElement[] elems = new StackTraceElement[last + 1];
1108         for (int i = 0; i &lt;= last; ++i) {
1109             StackTraceElement r = raw[i];
1110             OuterSnippetsClassWrap outer = state.outerMap.getOuter(r.getClassName());
1111             if (outer != null) {
1112                 String klass = expunge(r.getClassName());
1113                 String method = r.getMethodName().equals(DOIT_METHOD_NAME) ? &quot;&quot; : r.getMethodName();
1114                 int wln = r.getLineNumber() - 1;
1115                 int line = outer.wrapLineToSnippetLine(wln) + 1;
1116                 Snippet sn = outer.wrapLineToSnippet(wln);
1117                 String file = &quot;#&quot; + sn.id();
1118                 elems[i] = new StackTraceElement(klass, method, file, line);
1119             } else if (&quot;&lt;none&gt;&quot;.equals(r.getFileName())) {
1120                 elems[i] = new StackTraceElement(r.getClassName(), r.getMethodName(), null, r.getLineNumber());
1121             } else {
1122                 elems[i] = r;
1123             }
1124         }
1125         return elems;
1126     }
1127 
1128     private boolean isWrap(StackTraceElement ste) {
1129         return PREFIX_PATTERN.matcher(ste.getClassName()).find();
1130     }
1131 
1132     /**
1133      * Construct a diagnostic for a method name matching an Object method name
1134      * @param name the method name
1135      * @param nameStart the position within the source of the method name
1136      * @return the generated diagnostic
1137      */
1138     private Diag objectMethodNameDiag(String name, long nameStart) {
1139         return new Diag() {
1140             @Override
1141             public boolean isError() {
1142                 return true;
1143             }
1144 
1145             @Override
1146             public long getPosition() {
1147                 return nameStart;
1148             }
1149 
1150             @Override
1151             public long getStartPosition() {
1152                 return nameStart;
1153             }
1154 
1155             @Override
1156             public long getEndPosition() {
1157                 return nameStart + name.length();
1158             }
1159 
1160             @Override
1161             public String getCode() {
1162                 return &quot;jdk.eval.error.object.method&quot;;
1163             }
1164 
1165             @Override
1166             public String getMessage(Locale locale) {
1167                 return state.messageFormat(&quot;jshell.diag.object.method.fatal&quot;,
1168                         String.join(&quot; &quot;, objectMethods));
1169             }
1170         };
1171     }
1172 
1173     private class ModifierDiagnostic extends Diag {
1174 
1175             final boolean fatal;
1176             final String message;
1177             final long start;
1178             final long end;
1179 
1180             ModifierDiagnostic(boolean fatal,
1181                     final String message,
1182                     long start,
1183                     long end) {
1184                 this.fatal = fatal;
1185                 this.message = message;
1186                 this.start = start;
1187                 this.end = end;
1188             }
1189 
1190             @Override
1191             public boolean isError() {
1192                 return fatal;
1193             }
1194 
1195             @Override
1196             public long getPosition() {
1197                 return start;
1198             }
1199 
1200             @Override
1201             public long getStartPosition() {
1202                 return start;
1203             }
1204 
1205             @Override
1206             public long getEndPosition() {
1207                 return end;
1208             }
1209 
1210             @Override
1211             public String getCode() {
1212                 return fatal
1213                         ? &quot;jdk.eval.error.illegal.modifiers&quot;
1214                         : &quot;jdk.eval.warn.illegal.modifiers&quot;;
1215             }
1216 
1217             @Override
1218             public String getMessage(Locale locale) {
1219                 return message;
1220             }
1221     }
1222 
1223     private DiagList modifierDiagnostics(ModifiersTree modtree,
<a name="6" id="anc6"></a><span class="line-modified">1224                                          final TreeDissector dis, boolean isNotClass) {</span>
1225 
1226         List&lt;Modifier&gt; list = new ArrayList&lt;&gt;();
1227         boolean fatal = false;
1228         for (Modifier mod : modtree.getFlags()) {
1229             switch (mod) {
1230                 case SYNCHRONIZED:
1231                 case NATIVE:
1232                     list.add(mod);
1233                     fatal = true;
1234                     break;
1235                 case ABSTRACT:
<a name="7" id="anc7"></a><span class="line-modified">1236                     if (isNotClass) {</span>
1237                         list.add(mod);
1238                         fatal = true;
1239                     }
1240                     break;
1241                 case PUBLIC:
1242                 case PROTECTED:
1243                 case PRIVATE:
1244                     // quietly ignore, user cannot see effects one way or the other
1245                     break;
<a name="8" id="anc8"></a>
1246                 case FINAL:
<a name="9" id="anc9"></a><span class="line-added">1247                     if (isNotClass) {</span>
<span class="line-added">1248                         //OK to declare a class final, to aid sealed classes</span>
<span class="line-added">1249                         list.add(mod);</span>
<span class="line-added">1250                         break;</span>
<span class="line-added">1251                     }</span>
<span class="line-added">1252                     break;</span>
<span class="line-added">1253                 case STATIC:</span>
1254                     list.add(mod);
1255                     break;
1256             }
1257         }
1258         if (list.isEmpty()) {
1259             return new DiagList();
1260         } else {
1261             StringBuilder sb = new StringBuilder();
1262             for (Modifier mod : list) {
1263                 sb.append(&quot;&#39;&quot;);
1264                 sb.append(mod.toString());
1265                 sb.append(&quot;&#39; &quot;);
1266             }
1267             String key = (list.size() &gt; 1)
1268                     ? fatal
1269                     ? &quot;jshell.diag.modifier.plural.fatal&quot;
1270                     : &quot;jshell.diag.modifier.plural.ignore&quot;
1271                     : fatal
1272                     ? &quot;jshell.diag.modifier.single.fatal&quot;
1273                     : &quot;jshell.diag.modifier.single.ignore&quot;;
1274             String message = state.messageFormat(key, sb.toString().trim());
1275             return new DiagList(new ModifierDiagnostic(fatal, message,
1276                     dis.getStartPosition(modtree), dis.getEndPosition(modtree)));
1277         }
1278     }
1279 
1280     String computeDeclareName(TypeSymbol ts) {
1281         return Util.JSHELL_ANONYMOUS + &quot;$&quot; + Long.toUnsignedString(anonCount++);
1282     }
1283 }
<a name="10" id="anc10"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="10" type="hidden" />
</body>
</html>
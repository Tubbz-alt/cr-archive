<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.jshell/share/classes/jdk/jshell/SourceCodeAnalysisImpl.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2014, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.jshell;
  27 
  28 import com.sun.source.tree.AssignmentTree;
  29 import com.sun.source.tree.ClassTree;
  30 import com.sun.source.tree.CompilationUnitTree;
  31 import com.sun.source.tree.ErroneousTree;
  32 import com.sun.source.tree.ExpressionTree;
  33 import com.sun.source.tree.IdentifierTree;
  34 import com.sun.source.tree.ImportTree;
  35 import com.sun.source.tree.MemberReferenceTree;
  36 import com.sun.source.tree.MemberSelectTree;
  37 import com.sun.source.tree.MethodInvocationTree;
  38 import com.sun.source.tree.MethodTree;
  39 import com.sun.source.tree.NewClassTree;
  40 import com.sun.source.tree.Scope;
  41 import com.sun.source.tree.Tree;
  42 import com.sun.source.tree.Tree.Kind;
  43 import com.sun.source.tree.TypeParameterTree;
  44 import com.sun.source.tree.VariableTree;
  45 import com.sun.source.util.SourcePositions;
  46 import com.sun.source.util.TreePath;
  47 import com.sun.source.util.TreePathScanner;
  48 import com.sun.tools.javac.api.JavacScope;
  49 import com.sun.tools.javac.code.Flags;
  50 import com.sun.tools.javac.code.Symbol.CompletionFailure;
  51 import com.sun.tools.javac.code.Symbol.VarSymbol;
  52 import com.sun.tools.javac.code.Symtab;
  53 import com.sun.tools.javac.code.Type;
  54 import com.sun.tools.javac.code.Type.ClassType;
  55 import jdk.internal.shellsupport.doc.JavadocHelper;
  56 import com.sun.tools.javac.util.Name;
  57 import com.sun.tools.javac.util.Names;
  58 import com.sun.tools.javac.util.Pair;
  59 import jdk.jshell.CompletenessAnalyzer.CaInfo;
  60 import jdk.jshell.TaskFactory.AnalyzeTask;
  61 
  62 import java.util.ArrayList;
  63 import java.util.Collections;
  64 import java.util.Iterator;
  65 import java.util.List;
  66 import java.util.Objects;
  67 import java.util.function.Predicate;
  68 
  69 import javax.lang.model.element.Element;
  70 import javax.lang.model.element.ElementKind;
  71 import javax.lang.model.element.Modifier;
  72 import javax.lang.model.element.TypeElement;
  73 import javax.lang.model.type.DeclaredType;
  74 import javax.lang.model.type.TypeMirror;
  75 
  76 import static jdk.internal.jshell.debug.InternalDebugControl.DBG_COMPA;
  77 
  78 import java.io.IOException;
  79 import java.net.URI;
  80 import java.nio.file.DirectoryStream;
  81 import java.nio.file.FileSystem;
  82 import java.nio.file.FileSystems;
  83 import java.nio.file.FileVisitResult;
  84 import java.nio.file.FileVisitor;
  85 import java.nio.file.Files;
  86 import java.nio.file.Path;
  87 import java.nio.file.Paths;
  88 import java.nio.file.attribute.BasicFileAttributes;
  89 import java.util.Arrays;
  90 import java.util.Collection;
  91 import java.util.Comparator;
  92 import java.util.EnumSet;
  93 import java.util.HashMap;
  94 import java.util.HashSet;
  95 import java.util.LinkedHashSet;
  96 import java.util.Map;
  97 import java.util.NoSuchElementException;
  98 import java.util.Set;
  99 import java.util.concurrent.ExecutorService;
 100 import java.util.concurrent.Executors;
 101 import java.util.function.Function;
 102 import java.util.regex.Matcher;
 103 import java.util.regex.Pattern;
 104 import java.util.stream.Collectors;
 105 
 106 import static java.util.stream.Collectors.collectingAndThen;
 107 import static java.util.stream.Collectors.toCollection;
 108 import static java.util.stream.Collectors.toList;
 109 import static java.util.stream.Collectors.toSet;
 110 
 111 import java.util.stream.Stream;
 112 import java.util.stream.StreamSupport;
 113 
 114 import javax.lang.model.SourceVersion;
 115 
 116 import javax.lang.model.element.ExecutableElement;
 117 import javax.lang.model.element.PackageElement;
 118 import javax.lang.model.element.QualifiedNameable;
 119 import javax.lang.model.element.TypeParameterElement;
 120 import javax.lang.model.element.VariableElement;
 121 import javax.lang.model.type.ArrayType;
 122 import javax.lang.model.type.ExecutableType;
 123 import javax.lang.model.type.TypeKind;
 124 import javax.lang.model.util.ElementFilter;
 125 import javax.lang.model.util.Types;
 126 import javax.tools.JavaFileManager.Location;
 127 import javax.tools.StandardLocation;
 128 
 129 import jdk.jshell.ExpressionToTypeInfo.ExpressionInfo;
 130 import static jdk.jshell.Util.REPL_DOESNOTMATTER_CLASS_NAME;
 131 import static jdk.jshell.SourceCodeAnalysis.Completeness.DEFINITELY_INCOMPLETE;
 132 import static jdk.jshell.TreeDissector.printType;
 133 
 134 import static java.util.stream.Collectors.joining;
 135 
 136 import javax.lang.model.type.IntersectionType;
 137 
 138 /**
 139  * The concrete implementation of SourceCodeAnalysis.
 140  * @author Robert Field
 141  */
 142 class SourceCodeAnalysisImpl extends SourceCodeAnalysis {
 143 
 144     private static final Map&lt;Path, ClassIndex&gt; PATH_TO_INDEX = new HashMap&lt;&gt;();
 145     private static final ExecutorService INDEXER = Executors.newFixedThreadPool(1, r -&gt; {
 146         Thread t = new Thread(r);
 147         t.setDaemon(true);
 148         t.setUncaughtExceptionHandler((thread, ex) -&gt; ex.printStackTrace());
 149         return t;
 150     });
 151 
 152     private final JShell proc;
 153     private final CompletenessAnalyzer ca;
 154     private final List&lt;AutoCloseable&gt; closeables = new ArrayList&lt;&gt;();
 155     private final Map&lt;Path, ClassIndex&gt; currentIndexes = new HashMap&lt;&gt;();
 156     private int indexVersion;
 157     private int classpathVersion;
 158     private final Object suspendLock = new Object();
 159     private int suspend;
 160 
 161     SourceCodeAnalysisImpl(JShell proc) {
 162         this.proc = proc;
 163         this.ca = new CompletenessAnalyzer(proc);
 164 
 165         int cpVersion = classpathVersion = 1;
 166 
 167         INDEXER.submit(() -&gt; refreshIndexes(cpVersion));
 168     }
 169 
 170     @Override
 171     public CompletionInfo analyzeCompletion(String srcInput) {
 172         MaskCommentsAndModifiers mcm = new MaskCommentsAndModifiers(srcInput, false, false);
 173         if (mcm.endsWithOpenToken()) {
 174             proc.debug(DBG_COMPA, &quot;Incomplete (open comment): %s\n&quot;, srcInput);
 175             return new CompletionInfoImpl(DEFINITELY_INCOMPLETE, null, srcInput + &#39;\n&#39;);
 176         }
 177         String cleared = mcm.cleared();
 178         String trimmedInput = Util.trimEnd(cleared);
 179         if (trimmedInput.isEmpty()) {
 180             // Just comment or empty
 181             return new CompletionInfoImpl(Completeness.EMPTY, srcInput, &quot;&quot;);
 182         }
 183         CaInfo info = ca.scan(trimmedInput);
 184         Completeness status = info.status;
 185         int unitEndPos = info.unitEndPos;
 186         if (unitEndPos &gt; srcInput.length()) {
 187             unitEndPos = srcInput.length();
 188         }
 189         int nonCommentNonWhiteLength = trimmedInput.length();
 190         String src = srcInput.substring(0, unitEndPos);
 191         switch (status) {
 192             case COMPLETE: {
 193                 if (unitEndPos == nonCommentNonWhiteLength) {
 194                     // The unit is the whole non-coment/white input plus semicolon
 195                     String compileSource = src
 196                             + mcm.mask().substring(nonCommentNonWhiteLength);
 197                     proc.debug(DBG_COMPA, &quot;Complete: %s\n&quot;, compileSource);
 198                     proc.debug(DBG_COMPA, &quot;   nothing remains.\n&quot;);
 199                     return new CompletionInfoImpl(status, compileSource, &quot;&quot;);
 200                 } else {
 201                     String remain = srcInput.substring(unitEndPos);
 202                     proc.debug(DBG_COMPA, &quot;Complete: %s\n&quot;, src);
 203                     proc.debug(DBG_COMPA, &quot;          remaining: %s\n&quot;, remain);
 204                     return new CompletionInfoImpl(status, src, remain);
 205                 }
 206             }
 207             case COMPLETE_WITH_SEMI: {
 208                 // The unit is the whole non-coment/white input plus semicolon
 209                 String compileSource = src
 210                         + &quot;;&quot;
 211                         + mcm.mask().substring(nonCommentNonWhiteLength);
 212                 proc.debug(DBG_COMPA, &quot;Complete with semi: %s\n&quot;, compileSource);
 213                 proc.debug(DBG_COMPA, &quot;   nothing remains.\n&quot;);
 214                 return new CompletionInfoImpl(status, compileSource, &quot;&quot;);
 215             }
 216             case DEFINITELY_INCOMPLETE:
 217                 proc.debug(DBG_COMPA, &quot;Incomplete: %s\n&quot;, srcInput);
 218                 return new CompletionInfoImpl(status, null, srcInput + &#39;\n&#39;);
 219             case CONSIDERED_INCOMPLETE: {
 220                 // Since the source is potentually valid, construct the complete source
 221                 String compileSource = src
 222                         + &quot;;&quot;
 223                         + mcm.mask().substring(nonCommentNonWhiteLength);
 224                 proc.debug(DBG_COMPA, &quot;Considered incomplete: %s\n&quot;, srcInput);
 225                 return new CompletionInfoImpl(status, compileSource, srcInput + &#39;\n&#39;);
 226             }
 227             case EMPTY:
 228                 proc.debug(DBG_COMPA, &quot;Detected empty: %s\n&quot;, srcInput);
 229                 return new CompletionInfoImpl(status, srcInput, &quot;&quot;);
 230             case UNKNOWN:
 231                 proc.debug(DBG_COMPA, &quot;Detected error: %s\n&quot;, srcInput);
 232                 return new CompletionInfoImpl(status, srcInput, &quot;&quot;);
 233         }
 234         throw new InternalError();
 235     }
 236 
 237     private Tree.Kind guessKind(String code) {
 238         return proc.taskFactory.parse(code, pt -&gt; {
 239             List&lt;? extends Tree&gt; units = pt.units();
 240             if (units.isEmpty()) {
 241                 return Tree.Kind.BLOCK;
 242             }
 243             Tree unitTree = units.get(0);
 244             proc.debug(DBG_COMPA, &quot;Kind: %s -- %s\n&quot;, unitTree.getKind(), unitTree);
 245             return unitTree.getKind();
 246         });
 247     }
 248 
 249     //TODO: would be better handled through a lexer:
 250     private final Pattern JAVA_IDENTIFIER = Pattern.compile(&quot;\\p{javaJavaIdentifierStart}\\p{javaJavaIdentifierPart}*&quot;);
 251 
 252     @Override
 253     public List&lt;Suggestion&gt; completionSuggestions(String code, int cursor, int[] anchor) {
 254         suspendIndexing();
 255         try {
 256             return completionSuggestionsImpl(code, cursor, anchor);
 257         } catch (Throwable exc) {
 258             proc.debug(exc, &quot;Exception thrown in SourceCodeAnalysisImpl.completionSuggestions&quot;);
 259             return Collections.emptyList();
 260         } finally {
 261             resumeIndexing();
 262         }
 263     }
 264 
 265     private List&lt;Suggestion&gt; completionSuggestionsImpl(String code, int cursor, int[] anchor) {
 266         code = code.substring(0, cursor);
 267         Matcher m = JAVA_IDENTIFIER.matcher(code);
 268         String identifier = &quot;&quot;;
 269         while (m.find()) {
 270             if (m.end() == code.length()) {
 271                 cursor = m.start();
 272                 code = code.substring(0, cursor);
 273                 identifier = m.group();
 274             }
 275         }
 276         code = code.substring(0, cursor);
 277         if (code.trim().isEmpty()) { //TODO: comment handling
 278             code += &quot;;&quot;;
 279         }
 280         OuterWrap codeWrap;
 281         switch (guessKind(code)) {
 282             case IMPORT:
 283                 codeWrap = proc.outerMap.wrapImport(Wrap.simpleWrap(code + &quot;any.any&quot;), null);
 284                 break;
 285             case CLASS:
 286             case METHOD:
 287                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(code));
 288                 break;
 289             default:
 290                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
 291                 break;
 292         }
 293         String requiredPrefix = identifier;
 294         return computeSuggestions(codeWrap, cursor, anchor).stream()
 295                 .filter(s -&gt; s.continuation().startsWith(requiredPrefix) &amp;&amp; !s.continuation().equals(REPL_DOESNOTMATTER_CLASS_NAME))
 296                 .sorted(Comparator.comparing(Suggestion::continuation))
 297                 .collect(collectingAndThen(toList(), Collections::unmodifiableList));
 298     }
 299 
 300     private List&lt;Suggestion&gt; computeSuggestions(OuterWrap code, int cursor, int[] anchor) {
 301         return proc.taskFactory.analyze(code, at -&gt; {
 302             SourcePositions sp = at.trees().getSourcePositions();
 303             CompilationUnitTree topLevel = at.firstCuTree();
 304             List&lt;Suggestion&gt; result = new ArrayList&lt;&gt;();
 305             TreePath tp = pathFor(topLevel, sp, code, cursor);
 306             if (tp != null) {
 307                 Scope scope = at.trees().getScope(tp);
 308                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);
 309                 Predicate&lt;Element&gt; smartTypeFilter;
 310                 Predicate&lt;Element&gt; smartFilter;
 311                 Iterable&lt;TypeMirror&gt; targetTypes = findTargetType(at, tp);
 312                 if (targetTypes != null) {
 313                     if (tp.getLeaf().getKind() == Kind.MEMBER_REFERENCE) {
 314                         Types types = at.getTypes();
 315                         smartTypeFilter = t -&gt; {
 316                             if (t.getKind() != ElementKind.METHOD) {
 317                                 return false;
 318                             }
 319                             ExecutableElement ee = (ExecutableElement) t;
 320                             for (TypeMirror type : targetTypes) {
 321                                 if (type.getKind() != TypeKind.DECLARED)
 322                                     continue;
 323                                 DeclaredType d = (DeclaredType) type;
 324                                 List&lt;? extends Element&gt; enclosed =
 325                                         ((TypeElement) d.asElement()).getEnclosedElements();
 326                                 for (ExecutableElement m : ElementFilter.methodsIn(enclosed)) {
 327                                     boolean matches = true;
 328                                     if (!m.getModifiers().contains(Modifier.ABSTRACT)) {
 329                                         continue;
 330                                     }
 331                                     if (m.getParameters().size() != ee.getParameters().size()) {
 332                                         continue;
 333                                     }
 334                                     ExecutableType mInst = (ExecutableType) types.asMemberOf(d, m);
 335                                     List&lt;? extends TypeMirror&gt; expectedParams = mInst.getParameterTypes();
 336                                     if (mInst.getReturnType().getKind() != TypeKind.VOID &amp;&amp;
 337                                         !types.isSubtype(ee.getReturnType(), mInst.getReturnType())) {
 338                                         continue;
 339                                     }
 340                                     for (int i = 0; i &lt; m.getParameters().size(); i++) {
 341                                         if (!types.isSubtype(expectedParams.get(i),
 342                                                              ee.getParameters().get(i).asType())) {
 343                                             matches = false;
 344                                         }
 345                                     }
 346                                     if (matches) {
 347                                         return true;
 348                                     }
 349                                 }
 350                             }
 351                             return false;
 352                         };
 353                     } else {
 354                         smartTypeFilter = el -&gt; {
 355                             TypeMirror resultOf = resultTypeOf(el);
 356                             return Util.stream(targetTypes)
 357                                     .anyMatch(targetType -&gt; at.getTypes().isAssignable(resultOf, targetType));
 358                         };
 359                     }
 360 
 361                     smartFilter = IS_CLASS.negate()
 362                                           .and(IS_INTERFACE.negate())
 363                                           .and(IS_PACKAGE.negate())
 364                                           .and(smartTypeFilter);
 365                 } else {
 366                     smartFilter = TRUE;
 367                     smartTypeFilter = TRUE;
 368                 }
 369                 switch (tp.getLeaf().getKind()) {
 370                     case MEMBER_REFERENCE, MEMBER_SELECT: {
 371                         javax.lang.model.element.Name identifier;
 372                         ExpressionTree expression;
 373                         Function&lt;Boolean, String&gt; paren;
 374                         if (tp.getLeaf().getKind() == Kind.MEMBER_SELECT) {
 375                             MemberSelectTree mst = (MemberSelectTree)tp.getLeaf();
 376                             identifier = mst.getIdentifier();
 377                             expression = mst.getExpression();
 378                             paren = DEFAULT_PAREN;
 379                         } else {
 380                             MemberReferenceTree mst = (MemberReferenceTree)tp.getLeaf();
 381                             identifier = mst.getName();
 382                             expression = mst.getQualifierExpression();
 383                             paren = NO_PAREN;
 384                         }
 385                         if (identifier.contentEquals(&quot;*&quot;))
 386                             break;
 387                         TreePath exprPath = new TreePath(tp, expression);
 388                         TypeMirror site = at.trees().getTypeMirror(exprPath);
 389                         boolean staticOnly = isStaticContext(at, exprPath);
 390                         ImportTree it = findImport(tp);
 391                         boolean isImport = it != null;
 392 
 393                         List&lt;? extends Element&gt; members = membersOf(at, site, staticOnly &amp;&amp; !isImport &amp;&amp; tp.getLeaf().getKind() == Kind.MEMBER_SELECT);
 394                         Predicate&lt;Element&gt; filter = accessibility;
 395 
 396                         if (isNewClass(tp)) { // new xxx.|
 397                             Predicate&lt;Element&gt; constructorFilter = accessibility.and(IS_CONSTRUCTOR)
 398                                 .and(el -&gt; {
 399                                     if (el.getEnclosingElement().getEnclosingElement().getKind() == ElementKind.CLASS) {
 400                                         return el.getEnclosingElement().getModifiers().contains(Modifier.STATIC);
 401                                     }
 402                                     return true;
 403                                 });
 404                             addElements(membersOf(at, members), constructorFilter, smartFilter, result);
 405 
 406                             filter = filter.and(IS_PACKAGE);
 407                         } else if (isThrowsClause(tp)) {
 408                             staticOnly = true;
 409                             filter = filter.and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));
 410                             smartFilter = IS_PACKAGE.negate().and(smartTypeFilter);
 411                         } else if (isImport) {
 412                             paren = NO_PAREN;
 413                             if (!it.isStatic()) {
 414                                 filter = filter.and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));
 415                             }
 416                         } else {
 417                             filter = filter.and(IS_CONSTRUCTOR.negate());
 418                         }
 419 
 420                         filter = filter.and(staticOnly ? STATIC_ONLY : INSTANCE_ONLY);
 421 
 422                         addElements(members, filter, smartFilter, paren, result);
 423                         break;
 424                     }
 425                     case IDENTIFIER:
 426                         if (isNewClass(tp)) {
 427                             Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; listEnclosed =
 428                                     el -&gt; el.getKind() == ElementKind.PACKAGE ? Collections.singletonList(el)
 429                                                                               : el.getEnclosedElements();
 430                             Predicate&lt;Element&gt; filter = accessibility.and(IS_CONSTRUCTOR.or(IS_PACKAGE));
 431                             NewClassTree newClassTree = (NewClassTree)tp.getParentPath().getLeaf();
 432                             ExpressionTree enclosingExpression = newClassTree.getEnclosingExpression();
 433                             if (enclosingExpression != null) { // expr.new IDENT|
 434                                 TypeMirror site = at.trees().getTypeMirror(new TreePath(tp, enclosingExpression));
 435                                 filter = filter.and(el -&gt; el.getEnclosingElement().getKind() == ElementKind.CLASS &amp;&amp; !el.getEnclosingElement().getModifiers().contains(Modifier.STATIC));
 436                                 addElements(membersOf(at, membersOf(at, site, false)), filter, smartFilter, result);
 437                             } else {
 438                                 addScopeElements(at, scope, listEnclosed, filter, smartFilter, result);
 439                             }
 440                             break;
 441                         }
 442                         if (isThrowsClause(tp)) {
 443                             Predicate&lt;Element&gt; accept = accessibility.and(STATIC_ONLY)
 444                                     .and(IS_PACKAGE.or(IS_CLASS).or(IS_INTERFACE));
 445                             addScopeElements(at, scope, IDENTITY, accept, IS_PACKAGE.negate().and(smartTypeFilter), result);
 446                             break;
 447                         }
 448                         ImportTree it = findImport(tp);
 449                         if (it != null) {
 450                             // the context of the identifier is an import, look for
 451                             // package names that start with the identifier.
 452                             // If and when Java allows imports from the default
 453                             // package to the the default package which would allow
 454                             // JShell to change to use the default package, and that
 455                             // change is done, then this should use some variation
 456                             // of membersOf(at, at.getElements().getPackageElement(&quot;&quot;).asType(), false)
 457                             addElements(listPackages(at, &quot;&quot;),
 458                                     it.isStatic()
 459                                             ? STATIC_ONLY.and(accessibility)
 460                                             : accessibility,
 461                                     smartFilter, result);
 462                         }
 463                         break;
 464                     case CLASS: {
 465                         Predicate&lt;Element&gt; accept = accessibility.and(IS_TYPE);
 466                         addScopeElements(at, scope, IDENTITY, accept, smartFilter, result);
 467                         addElements(primitivesOrVoid(at), TRUE, smartFilter, result);
 468                         break;
 469                     }
 470                     case BLOCK:
 471                     case EMPTY_STATEMENT:
 472                     case ERRONEOUS: {
 473                         boolean staticOnly = ReplResolve.isStatic(((JavacScope)scope).getEnv());
 474                         Predicate&lt;Element&gt; accept = accessibility.and(staticOnly ? STATIC_ONLY : TRUE);
 475                         if (isClass(tp)) {
 476                             ClassTree clazz = (ClassTree) tp.getParentPath().getLeaf();
 477                             if (clazz.getExtendsClause() == tp.getLeaf()) {
 478                                 accept = accept.and(IS_TYPE);
 479                                 smartFilter = smartFilter.and(el -&gt; el.getKind() == ElementKind.CLASS);
 480                             } else {
 481                                 Predicate&lt;Element&gt; f = smartFilterFromList(at, tp, clazz.getImplementsClause(), tp.getLeaf());
 482                                 if (f != null) {
 483                                     accept = accept.and(IS_TYPE);
 484                                     smartFilter = f.and(el -&gt; el.getKind() == ElementKind.INTERFACE);
 485                                 }
 486                             }
 487                         } else if (isTypeParameter(tp)) {
 488                             TypeParameterTree tpt = (TypeParameterTree) tp.getParentPath().getLeaf();
 489                             Predicate&lt;Element&gt; f = smartFilterFromList(at, tp, tpt.getBounds(), tp.getLeaf());
 490                             if (f != null) {
 491                                 accept = accept.and(IS_TYPE);
 492                                 smartFilter = f;
 493                                 if (!tpt.getBounds().isEmpty() &amp;&amp; tpt.getBounds().get(0) != tp.getLeaf()) {
 494                                     smartFilter = smartFilter.and(el -&gt; el.getKind() == ElementKind.INTERFACE);
 495                                 }
 496                             }
 497                         } else if (isVariable(tp)) {
 498                             VariableTree var = (VariableTree) tp.getParentPath().getLeaf();
 499                             if (var.getType() == tp.getLeaf()) {
 500                                 accept = accept.and(IS_TYPE);
 501                             }
 502                         }
 503 
 504                         addScopeElements(at, scope, IDENTITY, accept, smartFilter, result);
 505 
 506                         Tree parent = tp.getParentPath().getLeaf();
 507                         switch (parent.getKind()) {
 508                             case VARIABLE:
 509                                 accept = ((VariableTree)parent).getType() == tp.getLeaf() ?
 510                                         IS_VOID.negate() :
 511                                         TRUE;
 512                                 break;
 513                             case PARAMETERIZED_TYPE: // TODO: JEP 218: Generics over Primitive Types
 514                             case TYPE_PARAMETER:
 515                             case CLASS:
 516                             case INTERFACE:
 517                             case ENUM:
 518                                 accept = FALSE;
 519                                 break;
 520                             default:
 521                                 accept = TRUE;
 522                                 break;
 523                         }
 524                         addElements(primitivesOrVoid(at), accept, smartFilter, result);
 525                         break;
 526                     }
 527                 }
 528             }
 529             anchor[0] = cursor;
 530             return result;
 531         });
 532     }
 533 
 534     private static final Set&lt;Kind&gt; CLASS_KINDS = EnumSet.of(
 535             Kind.ANNOTATION_TYPE, Kind.CLASS, Kind.ENUM, Kind.INTERFACE
 536     );
 537 
 538     private Predicate&lt;Element&gt; smartFilterFromList(AnalyzeTask at, TreePath base, Collection&lt;? extends Tree&gt; types, Tree current) {
 539         Set&lt;Element&gt; existingEls = new HashSet&lt;&gt;();
 540 
 541         for (Tree type : types) {
 542             if (type == current) {
 543                 return el -&gt; !existingEls.contains(el);
 544             }
 545             existingEls.add(at.trees().getElement(new TreePath(base, type)));
 546         }
 547 
 548         return null;
 549     }
 550 
 551     @Override
 552     public SnippetWrapper wrapper(Snippet snippet) {
 553         return new SnippetWrapper() {
 554             @Override
 555             public String source() {
 556                 return snippet.source();
 557             }
 558 
 559             @Override
 560             public String wrapped() {
 561                 return snippet.outerWrap().wrapped();
 562             }
 563 
 564             @Override
 565             public String fullClassName() {
 566                 return snippet.classFullName();
 567             }
 568 
 569             @Override
 570             public Snippet.Kind kind() {
 571                 return snippet.kind() == Snippet.Kind.ERRONEOUS
 572                         ? ((ErroneousSnippet) snippet).probableKind()
 573                         : snippet.kind();
 574             }
 575 
 576             @Override
 577             public int sourceToWrappedPosition(int pos) {
 578                 return snippet.outerWrap().snippetIndexToWrapIndex(pos);
 579             }
 580 
 581             @Override
 582             public int wrappedToSourcePosition(int pos) {
 583                 return snippet.outerWrap().wrapIndexToSnippetIndex(pos);
 584             }
 585         };
 586     }
 587 
 588     @Override
 589     public List&lt;SnippetWrapper&gt; wrappers(String input) {
 590         return proc.eval.sourceToSnippetsWithWrappers(input).stream()
 591                 .map(this::wrapper)
 592                 .collect(toList());
 593     }
 594 
 595     @Override
 596     public List&lt;Snippet&gt; sourceToSnippets(String input) {
 597         proc.checkIfAlive();
 598         List&lt;Snippet&gt; snl = proc.eval.toScratchSnippets(input);
 599         for (Snippet sn : snl) {
 600             sn.setId(Snippet.UNASSOCIATED_ID);
 601         }
 602         return snl;
 603     }
 604 
 605     @Override
 606     public Collection&lt;Snippet&gt; dependents(Snippet snippet) {
 607         return proc.maps.getDependents(snippet);
 608     }
 609 
 610     private boolean isStaticContext(AnalyzeTask at, TreePath path) {
 611         switch (path.getLeaf().getKind()) {
 612             case ARRAY_TYPE:
 613             case PRIMITIVE_TYPE:
 614                 return true;
 615             default:
 616                 Element selectEl = at.trees().getElement(path);
 617                 return selectEl != null &amp;&amp; (selectEl.getKind().isClass() || selectEl.getKind().isInterface() || selectEl.getKind() == ElementKind.TYPE_PARAMETER) &amp;&amp; selectEl.asType().getKind() != TypeKind.ERROR;
 618         }
 619     }
 620 
 621     private TreePath pathFor(CompilationUnitTree topLevel, SourcePositions sp, GeneralWrap wrap, int snippetEndPos) {
 622         int wrapEndPos = snippetEndPos == 0
 623                 ? wrap.snippetIndexToWrapIndex(snippetEndPos)
 624                 : wrap.snippetIndexToWrapIndex(snippetEndPos - 1) + 1;
 625         TreePath[] deepest = new TreePath[1];
 626 
 627         new TreePathScanner&lt;Void, Void&gt;() {
 628             @Override
 629             public Void scan(Tree tree, Void p) {
 630                 if (tree == null)
 631                     return null;
 632 
 633                 long start = sp.getStartPosition(topLevel, tree);
 634                 long end = sp.getEndPosition(topLevel, tree);
 635                 long prevEnd = deepest[0] != null ? sp.getEndPosition(topLevel, deepest[0].getLeaf()) : -1;
 636 
 637                 if (start &lt;= wrapEndPos &amp;&amp; wrapEndPos &lt;= end &amp;&amp;
 638                     (start != end || prevEnd != end || deepest[0] == null ||
 639                      deepest[0].getParentPath().getLeaf() != getCurrentPath().getLeaf())) {
 640                     deepest[0] = new TreePath(getCurrentPath(), tree);
 641                     return super.scan(tree, p);
 642                 }
 643 
 644                 return null;
 645             }
 646             @Override
 647             public Void visitErroneous(ErroneousTree node, Void p) {
 648                 return scan(node.getErrorTrees(), null);
 649             }
 650         }.scan(topLevel, null);
 651 
 652         return deepest[0];
 653     }
 654 
 655     private boolean isNewClass(TreePath tp) {
 656         return tp.getParentPath() != null &amp;&amp;
 657                tp.getParentPath().getLeaf().getKind() == Kind.NEW_CLASS &amp;&amp;
 658                ((NewClassTree) tp.getParentPath().getLeaf()).getIdentifier() == tp.getLeaf();
 659     }
 660 
 661     private boolean isThrowsClause(TreePath tp) {
 662         Tree parent = tp.getParentPath().getLeaf();
 663         return parent.getKind() == Kind.METHOD &amp;&amp;
 664                 ((MethodTree)parent).getThrows().contains(tp.getLeaf());
 665     }
 666 
 667     private boolean isClass(TreePath tp) {
 668         return tp.getParentPath() != null &amp;&amp;
 669                CLASS_KINDS.contains(tp.getParentPath().getLeaf().getKind());
 670     }
 671 
 672     private boolean isTypeParameter(TreePath tp) {
 673         return tp.getParentPath() != null &amp;&amp;
 674                tp.getParentPath().getLeaf().getKind() == Kind.TYPE_PARAMETER;
 675     }
 676 
 677     private boolean isVariable(TreePath tp) {
 678         return tp.getParentPath() != null &amp;&amp;
 679                tp.getParentPath().getLeaf().getKind() == Kind.VARIABLE;
 680     }
 681 
 682     private ImportTree findImport(TreePath tp) {
 683         while (tp != null &amp;&amp; tp.getLeaf().getKind() != Kind.IMPORT) {
 684             tp = tp.getParentPath();
 685         }
 686         return tp != null ? (ImportTree)tp.getLeaf() : null;
 687     }
 688 
 689     private Predicate&lt;Element&gt; createAccessibilityFilter(AnalyzeTask at, TreePath tp) {
 690         Scope scope = at.trees().getScope(tp);
 691         return el -&gt; {
 692             switch (el.getKind()) {
 693                 case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE:
 694                     return at.trees().isAccessible(scope, (TypeElement) el);
 695                 case PACKAGE:
 696                 case EXCEPTION_PARAMETER: case PARAMETER: case LOCAL_VARIABLE: case RESOURCE_VARIABLE:
 697                     return true;
 698                 default:
 699                     TypeMirror type = el.getEnclosingElement().asType();
 700                     if (type.getKind() == TypeKind.DECLARED)
 701                         return at.trees().isAccessible(scope, el, (DeclaredType) type);
 702                     else
 703                         return true;
 704             }
 705         };
 706     }
 707 
 708     private final Predicate&lt;Element&gt; TRUE = el -&gt; true;
 709     private final Predicate&lt;Element&gt; FALSE = TRUE.negate();
 710     private final Predicate&lt;Element&gt; IS_STATIC = el -&gt; el.getModifiers().contains(Modifier.STATIC);
 711     private final Predicate&lt;Element&gt; IS_CONSTRUCTOR = el -&gt; el.getKind() == ElementKind.CONSTRUCTOR;
 712     private final Predicate&lt;Element&gt; IS_METHOD = el -&gt; el.getKind() == ElementKind.METHOD;
 713     private final Predicate&lt;Element&gt; IS_PACKAGE = el -&gt; el.getKind() == ElementKind.PACKAGE;
 714     private final Predicate&lt;Element&gt; IS_CLASS = el -&gt; el.getKind().isClass();
 715     private final Predicate&lt;Element&gt; IS_INTERFACE = el -&gt; el.getKind().isInterface();
 716     private final Predicate&lt;Element&gt; IS_TYPE = IS_CLASS.or(IS_INTERFACE).or(el -&gt; el.getKind() == ElementKind.TYPE_PARAMETER);
 717     private final Predicate&lt;Element&gt; IS_VOID = el -&gt; el.asType().getKind() == TypeKind.VOID;
 718     private final Predicate&lt;Element&gt; STATIC_ONLY = el -&gt; {
 719         ElementKind kind = el.getKind();
 720         Element encl = el.getEnclosingElement();
 721         ElementKind enclKind = encl != null ? encl.getKind() : ElementKind.OTHER;
 722 
 723         return IS_STATIC.or(IS_PACKAGE).or(IS_CLASS).or(IS_INTERFACE).test(el) || IS_PACKAGE.test(encl) ||
 724                 (kind == ElementKind.TYPE_PARAMETER &amp;&amp; !enclKind.isClass() &amp;&amp; !enclKind.isInterface());
 725     };
 726     private final Predicate&lt;Element&gt; INSTANCE_ONLY = el -&gt; {
 727         Element encl = el.getEnclosingElement();
 728 
 729         return IS_STATIC.or(IS_CLASS).or(IS_INTERFACE).negate().test(el) ||
 730                 IS_PACKAGE.test(encl);
 731     };
 732     private final Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; IDENTITY = Collections::singletonList;
 733     private final Function&lt;Boolean, String&gt; DEFAULT_PAREN = hasParams -&gt; hasParams ? &quot;(&quot; : &quot;()&quot;;
 734     private final Function&lt;Boolean, String&gt; NO_PAREN = hasParams -&gt; &quot;&quot;;
 735 
 736     private void addElements(Iterable&lt;? extends Element&gt; elements, Predicate&lt;Element&gt; accept, Predicate&lt;Element&gt; smart, List&lt;Suggestion&gt; result) {
 737         addElements(elements, accept, smart, DEFAULT_PAREN, result);
 738     }
 739     private void addElements(Iterable&lt;? extends Element&gt; elements, Predicate&lt;Element&gt; accept, Predicate&lt;Element&gt; smart, Function&lt;Boolean, String&gt; paren, List&lt;Suggestion&gt; result) {
 740         Set&lt;String&gt; hasParams = Util.stream(elements)
 741                 .filter(accept)
 742                 .filter(IS_CONSTRUCTOR.or(IS_METHOD))
 743                 .filter(c -&gt; !((ExecutableElement)c).getParameters().isEmpty())
 744                 .map(this::simpleName)
 745                 .collect(toSet());
 746 
 747         for (Element c : elements) {
 748             if (!accept.test(c))
 749                 continue;
 750             if (c.getKind() == ElementKind.METHOD &amp;&amp;
 751                 c.getSimpleName().contentEquals(Util.DOIT_METHOD_NAME) &amp;&amp;
 752                 ((ExecutableElement) c).getParameters().isEmpty()) {
 753                 continue;
 754             }
 755             String simpleName = simpleName(c);
 756             switch (c.getKind()) {
 757                 case CONSTRUCTOR:
 758                 case METHOD:
 759                     // add trailing open or matched parenthesis, as approriate
 760                     simpleName += paren.apply(hasParams.contains(simpleName));
 761                     break;
 762                 case PACKAGE:
 763                     // add trailing dot to package names
 764                     simpleName += &quot;.&quot;;
 765                     break;
 766             }
 767             result.add(new SuggestionImpl(simpleName, smart.test(c)));
 768         }
 769     }
 770 
 771     private String simpleName(Element el) {
 772         return el.getKind() == ElementKind.CONSTRUCTOR ? el.getEnclosingElement().getSimpleName().toString()
 773                                                        : el.getSimpleName().toString();
 774     }
 775 
 776     private List&lt;? extends Element&gt; membersOf(AnalyzeTask at, TypeMirror site, boolean shouldGenerateDotClassItem) {
 777         if (site  == null)
 778             return Collections.emptyList();
 779 
 780         switch (site.getKind()) {
 781             case INTERSECTION: {
 782                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 783                 for (TypeMirror bound : ((IntersectionType) site).getBounds()) {
 784                     result.addAll(membersOf(at, bound, shouldGenerateDotClassItem));
 785                 }
 786                 return result;
 787             }
 788             case DECLARED: {
 789                 TypeElement element = (TypeElement) at.getTypes().asElement(site);
 790                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 791                 result.addAll(at.getElements().getAllMembers(element));
 792                 if (shouldGenerateDotClassItem) {
 793                     result.add(createDotClassSymbol(at, site));
 794                 }
 795                 result.removeIf(el -&gt; el.getKind() == ElementKind.STATIC_INIT);
 796                 return result;
 797             }
 798             case ERROR: {
 799                 //try current qualified name as a package:
 800                 TypeElement typeElement = (TypeElement) at.getTypes().asElement(site);
 801                 Element enclosingElement = typeElement.getEnclosingElement();
 802                 String parentPackageName = enclosingElement instanceof QualifiedNameable ?
 803                     ((QualifiedNameable)enclosingElement).getQualifiedName().toString() :
 804                     &quot;&quot;;
 805                 Set&lt;PackageElement&gt; packages = listPackages(at, parentPackageName);
 806                 return packages.stream()
 807                                .filter(p -&gt; p.getQualifiedName().equals(typeElement.getQualifiedName()))
 808                                .findAny()
 809                                .map(p -&gt; membersOf(at, p.asType(), false))
 810                                .orElse(Collections.emptyList());
 811             }
 812             case PACKAGE: {
 813                 String packageName = site.toString()/*XXX*/;
 814                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 815                 result.addAll(getEnclosedElements(at.getElements().getPackageElement(packageName)));
 816                 result.addAll(listPackages(at, packageName));
 817                 return result;
 818             }
 819             case BOOLEAN: case BYTE: case SHORT: case CHAR:
 820             case INT: case FLOAT: case LONG: case DOUBLE:
 821             case VOID: {
 822                 return shouldGenerateDotClassItem ?
 823                     Collections.singletonList(createDotClassSymbol(at, site)) :
 824                     Collections.emptyList();
 825             }
 826             case ARRAY: {
 827                 List&lt;Element&gt; result = new ArrayList&lt;&gt;();
 828                 result.add(createArrayLengthSymbol(at, site));
 829                 if (shouldGenerateDotClassItem)
 830                     result.add(createDotClassSymbol(at, site));
 831                 return result;
 832             }
 833             default:
 834                 return Collections.emptyList();
 835         }
 836     }
 837 
 838     private List&lt;? extends Element&gt; membersOf(AnalyzeTask at, List&lt;? extends Element&gt; elements) {
 839         return elements.stream()
 840                 .flatMap(e -&gt; membersOf(at, e.asType(), true).stream())
 841                 .collect(toList());
 842     }
 843 
 844     private List&lt;? extends Element&gt; getEnclosedElements(PackageElement packageEl) {
 845         if (packageEl == null) {
 846             return Collections.emptyList();
 847         }
 848         //workaround for: JDK-8024687
 849         while (true) {
 850             try {
 851                 return packageEl.getEnclosedElements()
 852                                 .stream()
 853                                 .filter(el -&gt; el.asType() != null)
 854                                 .filter(el -&gt; el.asType().getKind() != TypeKind.ERROR)
 855                                 .collect(toList());
 856             } catch (CompletionFailure cf) {
 857                 //ignore...
 858             }
 859         }
 860     }
 861 
 862     private List&lt;? extends Element&gt; primitivesOrVoid(AnalyzeTask at) {
 863         Types types = at.getTypes();
 864         return Stream.of(
 865                 TypeKind.BOOLEAN, TypeKind.BYTE, TypeKind.CHAR,
 866                 TypeKind.DOUBLE, TypeKind.FLOAT, TypeKind.INT,
 867                 TypeKind.LONG, TypeKind.SHORT, TypeKind.VOID)
 868                 .map(tk -&gt; (Type)(tk == TypeKind.VOID ? types.getNoType(tk) : types.getPrimitiveType(tk)))
 869                 .map(Type::asElement)
 870                 .collect(toList());
 871     }
 872 
 873     void classpathChanged() {
 874         synchronized (currentIndexes) {
 875             int cpVersion = ++classpathVersion;
 876 
 877             INDEXER.submit(() -&gt; refreshIndexes(cpVersion));
 878         }
 879     }
 880 
 881     private Set&lt;PackageElement&gt; listPackages(AnalyzeTask at, String enclosingPackage) {
 882         synchronized (currentIndexes) {
 883             return currentIndexes.values()
 884                                  .stream()
 885                                  .flatMap(idx -&gt; idx.packages.stream())
 886                                  .filter(p -&gt; enclosingPackage.isEmpty() || p.startsWith(enclosingPackage + &quot;.&quot;))
 887                                  .map(p -&gt; {
 888                                      int dot = p.indexOf(&#39;.&#39;, enclosingPackage.length() + 1);
 889                                      return dot == (-1) ? p : p.substring(0, dot);
 890                                  })
 891                                  .distinct()
 892                                  .map(p -&gt; createPackageElement(at, p))
 893                                  .collect(Collectors.toSet());
 894         }
 895     }
 896 
 897     private PackageElement createPackageElement(AnalyzeTask at, String packageName) {
 898         Names names = Names.instance(at.getContext());
 899         Symtab syms = Symtab.instance(at.getContext());
 900         PackageElement existing = syms.enterPackage(syms.unnamedModule, names.fromString(packageName));
 901 
 902         return existing;
 903     }
 904 
 905     private Element createArrayLengthSymbol(AnalyzeTask at, TypeMirror site) {
 906         Name length = Names.instance(at.getContext()).length;
 907         Type intType = Symtab.instance(at.getContext()).intType;
 908 
 909         return new VarSymbol(Flags.PUBLIC | Flags.FINAL, length, intType, ((Type) site).tsym);
 910     }
 911 
 912     private Element createDotClassSymbol(AnalyzeTask at, TypeMirror site) {
 913         Name _class = Names.instance(at.getContext())._class;
 914         Type classType = Symtab.instance(at.getContext()).classType;
 915         Type erasedSite = (Type)at.getTypes().erasure(site);
 916         classType = new ClassType(classType.getEnclosingType(), com.sun.tools.javac.util.List.of(erasedSite), classType.asElement());
 917 
 918         return new VarSymbol(Flags.PUBLIC | Flags.STATIC | Flags.FINAL, _class, classType, erasedSite.tsym);
 919     }
 920 
 921     private Iterable&lt;? extends Element&gt; scopeContent(AnalyzeTask at, Scope scope, Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; elementConvertor) {
 922         Iterable&lt;Scope&gt; scopeIterable = () -&gt; new Iterator&lt;Scope&gt;() {
 923             private Scope currentScope = scope;
 924             @Override
 925             public boolean hasNext() {
 926                 return currentScope != null;
 927             }
 928             @Override
 929             public Scope next() {
 930                 if (!hasNext())
 931                     throw new NoSuchElementException();
 932                 try {
 933                     return currentScope;
 934                 } finally {
 935                     currentScope = currentScope.getEnclosingScope();
 936                 }
 937             }
 938         };
 939         @SuppressWarnings(&quot;unchecked&quot;)
 940         List&lt;Element&gt; result = Util.stream(scopeIterable)
 941                              .flatMap(this::localElements)
 942                              .flatMap(el -&gt; Util.stream((Iterable&lt;Element&gt;)elementConvertor.apply(el)))
 943                              .collect(toCollection(ArrayList :: new));
 944         result.addAll(listPackages(at, &quot;&quot;));
 945         return result;
 946     }
 947 
 948     private Stream&lt;Element&gt; localElements(Scope scope) {
 949         //workaround for: JDK-8024687
 950         Iterable&lt;Element&gt; elementsIt = () -&gt; new Iterator&lt;Element&gt;() {
 951             Iterator&lt;? extends Element&gt; it = scope.getLocalElements().iterator();
 952             @Override
 953             public boolean hasNext() {
 954                 while (true) {
 955                     try {
 956                         return it.hasNext();
 957                     } catch (CompletionFailure cf) {
 958                         //ignore...
 959                     }
 960                 }
 961             }
 962             @Override
 963             public Element next() {
 964                 while (true) {
 965                     try {
 966                         return it.next();
 967                     } catch (CompletionFailure cf) {
 968                         //ignore...
 969                     }
 970                 }
 971             }
 972         };
 973         Stream&lt;Element&gt; elements = Util.stream(elementsIt);
 974 
 975         if (scope.getEnclosingScope() != null &amp;&amp;
 976             scope.getEnclosingClass() != scope.getEnclosingScope().getEnclosingClass()) {
 977             elements = Stream.concat(elements, scope.getEnclosingClass().getEnclosedElements().stream());
 978         }
 979 
 980         return elements;
 981     }
 982 
 983     @SuppressWarnings(&quot;fallthrough&quot;)
 984     private Iterable&lt;TypeMirror&gt; findTargetType(AnalyzeTask at, TreePath forPath) {
 985         if (forPath.getParentPath() == null)
 986             return null;
 987 
 988         Tree current = forPath.getLeaf();
 989 
 990         switch (forPath.getParentPath().getLeaf().getKind()) {
 991             case ASSIGNMENT: {
 992                 AssignmentTree tree = (AssignmentTree) forPath.getParentPath().getLeaf();
 993                 if (tree.getExpression() == current)
 994                     return Collections.singletonList(at.trees().getTypeMirror(new TreePath(forPath.getParentPath(), tree.getVariable())));
 995                 break;
 996             }
 997             case VARIABLE: {
 998                 VariableTree tree = (VariableTree) forPath.getParentPath().getLeaf();
 999                 if (tree.getInitializer()== current)
1000                     return Collections.singletonList(at.trees().getTypeMirror(forPath.getParentPath()));
1001                 break;
1002             }
1003             case ERRONEOUS:
1004                 return findTargetType(at, forPath.getParentPath());
1005             case NEW_CLASS: {
1006                 NewClassTree nct = (NewClassTree) forPath.getParentPath().getLeaf();
1007                 List&lt;TypeMirror&gt; actuals = computeActualInvocationTypes(at, nct.getArguments(), forPath);
1008 
1009                 if (actuals != null) {
1010                     Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateConstructors = newClassCandidates(at, forPath.getParentPath());
1011 
1012                     return computeSmartTypesForExecutableType(at, candidateConstructors, actuals);
1013                 } else {
1014                     return findTargetType(at, forPath.getParentPath());
1015                 }
1016             }
1017             case METHOD:
1018                 if (!isThrowsClause(forPath)) {
1019                     break;
1020                 }
1021                 // fall through
1022             case THROW:
1023                 return Collections.singletonList(at.getElements().getTypeElement(&quot;java.lang.Throwable&quot;).asType());
1024             case METHOD_INVOCATION: {
1025                 MethodInvocationTree mit = (MethodInvocationTree) forPath.getParentPath().getLeaf();
1026                 List&lt;TypeMirror&gt; actuals = computeActualInvocationTypes(at, mit.getArguments(), forPath);
1027 
1028                 if (actuals == null)
1029                     return null;
1030 
1031                 Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateMethods = methodCandidates(at, forPath.getParentPath());
1032 
1033                 return computeSmartTypesForExecutableType(at, candidateMethods, actuals);
1034             }
1035         }
1036 
1037         return null;
1038     }
1039 
1040     private List&lt;TypeMirror&gt; computeActualInvocationTypes(AnalyzeTask at, List&lt;? extends ExpressionTree&gt; arguments, TreePath currentArgument) {
1041         if (currentArgument == null)
1042             return null;
1043 
1044         int paramIndex = arguments.indexOf(currentArgument.getLeaf());
1045 
1046         if (paramIndex == (-1))
1047             return null;
1048 
1049         List&lt;TypeMirror&gt; actuals = new ArrayList&lt;&gt;();
1050 
1051         for (ExpressionTree arg : arguments.subList(0, paramIndex)) {
1052             actuals.add(at.trees().getTypeMirror(new TreePath(currentArgument.getParentPath(), arg)));
1053         }
1054 
1055         return actuals;
1056     }
1057 
1058     private List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; filterExecutableTypesByArguments(AnalyzeTask at, Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateMethods, List&lt;TypeMirror&gt; precedingActualTypes) {
1059         List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidate = new ArrayList&lt;&gt;();
1060         int paramIndex = precedingActualTypes.size();
1061 
1062         OUTER:
1063         for (Pair&lt;ExecutableElement, ExecutableType&gt; method : candidateMethods) {
1064             boolean varargInvocation = paramIndex &gt;= method.snd.getParameterTypes().size();
1065 
1066             for (int i = 0; i &lt; paramIndex; i++) {
1067                 TypeMirror actual = precedingActualTypes.get(i);
1068 
1069                 if (this.parameterType(method.fst, method.snd, i, !varargInvocation)
1070                         .noneMatch(formal -&gt; at.getTypes().isAssignable(actual, formal))) {
1071                     continue OUTER;
1072                 }
1073             }
1074             candidate.add(method);
1075         }
1076 
1077         return candidate;
1078     }
1079 
1080     private Stream&lt;TypeMirror&gt; parameterType(ExecutableElement method, ExecutableType methodType, int paramIndex, boolean allowVarArgsArray) {
1081         int paramCount = methodType.getParameterTypes().size();
1082         if (paramIndex &gt;= paramCount &amp;&amp; !method.isVarArgs())
1083             return Stream.empty();
1084         if (paramIndex &lt; paramCount - 1 || !method.isVarArgs())
1085             return Stream.of(methodType.getParameterTypes().get(paramIndex));
1086         TypeMirror varargType = methodType.getParameterTypes().get(paramCount - 1);
1087         TypeMirror elemenType = ((ArrayType) varargType).getComponentType();
1088         if (paramIndex &gt;= paramCount || !allowVarArgsArray)
1089             return Stream.of(elemenType);
1090         return Stream.of(varargType, elemenType);
1091     }
1092 
1093     private List&lt;TypeMirror&gt; computeSmartTypesForExecutableType(AnalyzeTask at, Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateMethods, List&lt;TypeMirror&gt; precedingActualTypes) {
1094         List&lt;TypeMirror&gt; candidate = new ArrayList&lt;&gt;();
1095         int paramIndex = precedingActualTypes.size();
1096 
1097         this.filterExecutableTypesByArguments(at, candidateMethods, precedingActualTypes)
1098             .stream()
1099             .flatMap(method -&gt; parameterType(method.fst, method.snd, paramIndex, true))
1100             .forEach(candidate::add);
1101 
1102         return candidate;
1103     }
1104 
1105 
1106     private TypeMirror resultTypeOf(Element el) {
1107         //TODO: should reflect the type of site!
1108         switch (el.getKind()) {
1109             case METHOD:
1110                 return ((ExecutableElement) el).getReturnType();
1111             case CONSTRUCTOR:
1112             case INSTANCE_INIT: case STATIC_INIT: //TODO: should be filtered out
1113                 return el.getEnclosingElement().asType();
1114             default:
1115                 return el.asType();
1116         }
1117     }
1118 
1119     private void addScopeElements(AnalyzeTask at, Scope scope, Function&lt;Element, Iterable&lt;? extends Element&gt;&gt; elementConvertor, Predicate&lt;Element&gt; filter, Predicate&lt;Element&gt; smartFilter, List&lt;Suggestion&gt; result) {
1120         addElements(scopeContent(at, scope, elementConvertor), filter, smartFilter, result);
1121     }
1122 
1123     private Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; methodCandidates(AnalyzeTask at, TreePath invocation) {
1124         MethodInvocationTree mit = (MethodInvocationTree) invocation.getLeaf();
1125         ExpressionTree select = mit.getMethodSelect();
1126         List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; result = new ArrayList&lt;&gt;();
1127         Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, invocation);
1128 
1129         switch (select.getKind()) {
1130             case MEMBER_SELECT:
1131                 MemberSelectTree mst = (MemberSelectTree) select;
1132                 TreePath tp = new TreePath(new TreePath(invocation, select), mst.getExpression());
1133                 TypeMirror site = at.trees().getTypeMirror(tp);
1134 
1135                 if (site == null || site.getKind() != TypeKind.DECLARED)
1136                     break;
1137 
1138                 Element siteEl = at.getTypes().asElement(site);
1139 
1140                 if (siteEl == null)
1141                     break;
1142 
1143                 if (isStaticContext(at, tp)) {
1144                     accessibility = accessibility.and(STATIC_ONLY);
1145                 }
1146 
1147                 for (ExecutableElement ee : ElementFilter.methodsIn(membersOf(at, siteEl.asType(), false))) {
1148                     if (ee.getSimpleName().contentEquals(mst.getIdentifier())) {
1149                         if (accessibility.test(ee)) {
1150                             result.add(Pair.of(ee, (ExecutableType) at.getTypes().asMemberOf((DeclaredType) site, ee)));
1151                         }
1152                     }
1153                 }
1154                 break;
1155             case IDENTIFIER:
1156                 IdentifierTree it = (IdentifierTree) select;
1157                 for (ExecutableElement ee : ElementFilter.methodsIn(scopeContent(at, at.trees().getScope(invocation), IDENTITY))) {
1158                     if (ee.getSimpleName().contentEquals(it.getName())) {
1159                         if (accessibility.test(ee)) {
1160                             result.add(Pair.of(ee, (ExecutableType) ee.asType())); //XXX: proper site
1161                         }
1162                     }
1163                 }
1164                 break;
1165             default:
1166                 break;
1167         }
1168 
1169         return result;
1170     }
1171 
1172     private Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; newClassCandidates(AnalyzeTask at, TreePath newClassPath) {
1173         NewClassTree nct = (NewClassTree) newClassPath.getLeaf();
1174         Element type = at.trees().getElement(new TreePath(newClassPath.getParentPath(), nct.getIdentifier()));
1175         TypeMirror targetType = at.trees().getTypeMirror(newClassPath);
1176         if (targetType == null || targetType.getKind() != TypeKind.DECLARED) {
1177             Iterable&lt;TypeMirror&gt; targetTypes = findTargetType(at, newClassPath);
1178             if (targetTypes == null)
1179                 targetTypes = Collections.emptyList();
1180             targetType =
1181                     StreamSupport.stream(targetTypes.spliterator(), false)
1182                                  .filter(t -&gt; at.getTypes().asElement(t) == type)
1183                                  .findAny()
1184                                  .orElse(at.getTypes().erasure(type.asType()));
1185         }
1186         List&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidateConstructors = new ArrayList&lt;&gt;();
1187         Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, newClassPath);
1188 
1189         if (targetType != null &amp;&amp;
1190             targetType.getKind() == TypeKind.DECLARED &amp;&amp;
1191             type != null &amp;&amp;
1192             (type.getKind().isClass() || type.getKind().isInterface())) {
1193             for (ExecutableElement constr : ElementFilter.constructorsIn(type.getEnclosedElements())) {
1194                 if (accessibility.test(constr)) {
1195                     ExecutableType constrType =
1196                             (ExecutableType) at.getTypes().asMemberOf((DeclaredType) targetType, constr);
1197                     candidateConstructors.add(Pair.of(constr, constrType));
1198                 }
1199             }
1200         }
1201 
1202         return candidateConstructors;
1203     }
1204 
1205     @Override
1206     public List&lt;Documentation&gt; documentation(String code, int cursor, boolean computeJavadoc) {
1207         suspendIndexing();
1208         try {
1209             return documentationImpl(code, cursor, computeJavadoc);
1210         } catch (Throwable exc) {
1211             proc.debug(exc, &quot;Exception thrown in SourceCodeAnalysisImpl.documentation&quot;);
1212             return Collections.emptyList();
1213         } finally {
1214             resumeIndexing();
1215         }
1216     }
1217 
1218     //tweaked by tests to disable reading parameter names from classfiles so that tests using
1219     //JDK&#39;s classes are stable for both release and fastdebug builds:
1220     private final String[] keepParameterNames = new String[] {
1221         &quot;-parameters&quot;
1222     };
1223 
1224     private List&lt;Documentation&gt; documentationImpl(String code, int cursor, boolean computeJavadoc) {
1225         code = code.substring(0, cursor);
1226         if (code.trim().isEmpty()) { //TODO: comment handling
1227             code += &quot;;&quot;;
1228         }
1229 
1230         if (guessKind(code) == Kind.IMPORT)
1231             return Collections.emptyList();
1232 
1233         OuterWrap codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(code));
1234         return proc.taskFactory.analyze(codeWrap, List.of(keepParameterNames), at -&gt; {
1235             SourcePositions sp = at.trees().getSourcePositions();
1236             CompilationUnitTree topLevel = at.firstCuTree();
1237             TreePath tp = pathFor(topLevel, sp, codeWrap, cursor);
1238 
1239             if (tp == null)
1240                 return Collections.emptyList();
1241 
1242             TreePath prevPath = null;
1243             while (tp != null &amp;&amp; tp.getLeaf().getKind() != Kind.METHOD_INVOCATION &amp;&amp;
1244                    tp.getLeaf().getKind() != Kind.NEW_CLASS &amp;&amp; tp.getLeaf().getKind() != Kind.IDENTIFIER &amp;&amp;
1245                    tp.getLeaf().getKind() != Kind.MEMBER_SELECT) {
1246                 prevPath = tp;
1247                 tp = tp.getParentPath();
1248             }
1249 
1250             if (tp == null)
1251                 return Collections.emptyList();
1252 
1253             Stream&lt;Element&gt; elements;
1254             Iterable&lt;Pair&lt;ExecutableElement, ExecutableType&gt;&gt; candidates;
1255             List&lt;? extends ExpressionTree&gt; arguments;
1256 
1257             if (tp.getLeaf().getKind() == Kind.METHOD_INVOCATION || tp.getLeaf().getKind() == Kind.NEW_CLASS) {
1258                 if (tp.getLeaf().getKind() == Kind.METHOD_INVOCATION) {
1259                     MethodInvocationTree mit = (MethodInvocationTree) tp.getLeaf();
1260                     candidates = methodCandidates(at, tp);
1261                     arguments = mit.getArguments();
1262                 } else {
1263                     NewClassTree nct = (NewClassTree) tp.getLeaf();
1264                     candidates = newClassCandidates(at, tp);
1265                     arguments = nct.getArguments();
1266                 }
1267 
1268                 if (!isEmptyArgumentsContext(arguments)) {
1269                     List&lt;TypeMirror&gt; actuals = computeActualInvocationTypes(at, arguments, prevPath);
1270                     List&lt;TypeMirror&gt; fullActuals = actuals != null ? actuals : Collections.emptyList();
1271 
1272                     candidates =
1273                             this.filterExecutableTypesByArguments(at, candidates, fullActuals)
1274                                 .stream()
1275                                 .filter(method -&gt; parameterType(method.fst, method.snd, fullActuals.size(), true).findAny().isPresent())
1276                                 .collect(Collectors.toList());
1277                 }
1278 
1279                 elements = Util.stream(candidates).map(method -&gt; method.fst);
1280             } else if (tp.getLeaf().getKind() == Kind.IDENTIFIER || tp.getLeaf().getKind() == Kind.MEMBER_SELECT) {
1281                 Element el = at.trees().getElement(tp);
1282 
1283                 if (el == null ||
1284                     el.asType().getKind() == TypeKind.ERROR ||
1285                     (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty())) {
1286                     //erroneous element:
1287                     return Collections.emptyList();
1288                 }
1289 
1290                 Predicate&lt;Element&gt; accessibility = createAccessibilityFilter(at, tp);
1291 
1292                 if (!accessibility.test(el)) {
1293                     //not accessible
1294                     return Collections.emptyList();
1295                 }
1296 
1297                 elements = Stream.of(el);
1298             } else {
1299                 return Collections.emptyList();
1300             }
1301 
1302             List&lt;Documentation&gt; result = Collections.emptyList();
1303 
1304             try (JavadocHelper helper = JavadocHelper.create(at.task, findSources())) {
1305                 result = elements.map(el -&gt; constructDocumentation(at, helper, el, computeJavadoc))
1306                                  .filter(Objects::nonNull)
1307                                  .collect(Collectors.toList());
1308             } catch (IOException ex) {
1309                 proc.debug(ex, &quot;JavadocHelper.close()&quot;);
1310             }
1311 
1312             return result;
1313         });
1314     }
1315 
1316     private Documentation constructDocumentation(AnalyzeTask at, JavadocHelper helper, Element el, boolean computeJavadoc) {
1317         String javadoc = null;
1318         try {
1319             if (hasSyntheticParameterNames(el)) {
1320                 el = helper.getSourceElement(el);
1321             }
1322             if (computeJavadoc) {
1323                 javadoc = helper.getResolvedDocComment(el);
1324             }
1325         } catch (IOException ex) {
1326             proc.debug(ex, &quot;SourceCodeAnalysisImpl.element2String(..., &quot; + el + &quot;)&quot;);
1327         }
1328         String signature = Util.expunge(elementHeader(at, el, !hasSyntheticParameterNames(el), true));
1329         return new DocumentationImpl(signature,  javadoc);
1330     }
1331 
1332     public void close() {
1333         for (AutoCloseable closeable : closeables) {
1334             try {
1335                 closeable.close();
1336             } catch (Exception ex) {
1337                 proc.debug(ex, &quot;SourceCodeAnalysisImpl.close()&quot;);
1338             }
1339         }
1340     }
1341 
1342     private static final class DocumentationImpl implements Documentation {
1343 
1344         private final String signature;
1345         private final String javadoc;
1346 
1347         public DocumentationImpl(String signature, String javadoc) {
1348             this.signature = signature;
1349             this.javadoc = javadoc;
1350         }
1351 
1352         @Override
1353         public String signature() {
1354             return signature;
1355         }
1356 
1357         @Override
1358         public String javadoc() {
1359             return javadoc;
1360         }
1361 
1362     }
1363 
1364     private boolean isEmptyArgumentsContext(List&lt;? extends ExpressionTree&gt; arguments) {
1365         if (arguments.size() == 1) {
1366             Tree firstArgument = arguments.get(0);
1367             return firstArgument.getKind() == Kind.ERRONEOUS;
1368         }
1369         return false;
1370     }
1371 
1372     private boolean hasSyntheticParameterNames(Element el) {
1373         if (el.getKind() != ElementKind.CONSTRUCTOR &amp;&amp; el.getKind() != ElementKind.METHOD)
1374             return false;
1375 
1376         ExecutableElement ee = (ExecutableElement) el;
1377 
1378         if (ee.getParameters().isEmpty())
1379             return false;
1380 
1381         return ee.getParameters()
1382                  .stream()
1383                  .allMatch(param -&gt; param.getSimpleName().toString().startsWith(&quot;arg&quot;));
1384     }
1385 
1386     private static List&lt;Path&gt; availableSourcesOverride; //for tests
1387     private List&lt;Path&gt; availableSources;
1388 
1389     private List&lt;Path&gt; findSources() {
1390         if (availableSources != null) {
1391             return availableSources;
1392         }
1393         if (availableSourcesOverride != null) {
1394             return availableSources = availableSourcesOverride;
1395         }
1396         List&lt;Path&gt; result = new ArrayList&lt;&gt;();
1397         Path home = Paths.get(System.getProperty(&quot;java.home&quot;));
1398         Path srcZip = home.resolve(&quot;lib&quot;).resolve(&quot;src.zip&quot;);
1399         if (!Files.isReadable(srcZip))
1400             srcZip = home.getParent().resolve(&quot;src.zip&quot;);
1401         if (Files.isReadable(srcZip)) {
1402             boolean keepOpen = false;
1403             FileSystem zipFO = null;
1404 
1405             try {
1406                 URI uri = URI.create(&quot;jar:&quot; + srcZip.toUri());
1407                 zipFO = FileSystems.newFileSystem(uri, Collections.emptyMap());
1408                 Path root = zipFO.getRootDirectories().iterator().next();
1409 
1410                 if (Files.exists(root.resolve(&quot;java/lang/Object.java&quot;.replace(&quot;/&quot;, zipFO.getSeparator())))) {
1411                     //non-modular format:
1412                     result.add(srcZip);
1413                 } else if (Files.exists(root.resolve(&quot;java.base/java/lang/Object.java&quot;.replace(&quot;/&quot;, zipFO.getSeparator())))) {
1414                     //modular format:
1415                     try (DirectoryStream&lt;Path&gt; ds = Files.newDirectoryStream(root)) {
1416                         for (Path p : ds) {
1417                             if (Files.isDirectory(p)) {
1418                                 result.add(p);
1419                             }
1420                         }
1421                     }
1422 
1423                     keepOpen = true;
1424                 }
1425             } catch (IOException ex) {
1426                 proc.debug(ex, &quot;SourceCodeAnalysisImpl.findSources()&quot;);
1427             } finally {
1428                 if (zipFO != null) {
1429                     if (keepOpen) {
1430                         closeables.add(zipFO);
1431                     } else {
1432                         try {
1433                             zipFO.close();
1434                         } catch (IOException ex) {
1435                             proc.debug(ex, &quot;SourceCodeAnalysisImpl.findSources()&quot;);
1436                         }
1437                     }
1438                 }
1439             }
1440         }
1441         return availableSources = result;
1442     }
1443 
1444     private String elementHeader(AnalyzeTask at, Element el, boolean includeParameterNames, boolean useFQN) {
1445         switch (el.getKind()) {
1446             case ANNOTATION_TYPE: case CLASS: case ENUM: case INTERFACE: {
1447                 TypeElement type = (TypeElement)el;
1448                 String fullname = type.getQualifiedName().toString();
1449                 Element pkg = at.getElements().getPackageOf(el);
1450                 String name = pkg == null || useFQN ? fullname :
1451                         proc.maps.fullClassNameAndPackageToClass(fullname, ((PackageElement)pkg).getQualifiedName().toString());
1452 
1453                 return name + typeParametersOpt(at, type.getTypeParameters(), includeParameterNames);
1454             }
1455             case TYPE_PARAMETER: {
1456                 TypeParameterElement tp = (TypeParameterElement)el;
1457                 String name = tp.getSimpleName().toString();
1458 
1459                 List&lt;? extends TypeMirror&gt; bounds = tp.getBounds();
1460                 boolean boundIsObject = bounds.isEmpty() ||
1461                         bounds.size() == 1 &amp;&amp; at.getTypes().isSameType(bounds.get(0), Symtab.instance(at.getContext()).objectType);
1462 
1463                 return boundIsObject
1464                         ? name
1465                         : name + &quot; extends &quot; + bounds.stream()
1466                                 .map(bound -&gt; printType(at, proc, bound))
1467                                 .collect(joining(&quot; &amp; &quot;));
1468             }
1469             case FIELD:
1470                 return appendDot(elementHeader(at, el.getEnclosingElement(), includeParameterNames, false)) + el.getSimpleName() + &quot;:&quot; + el.asType();
1471             case ENUM_CONSTANT:
1472                 return appendDot(elementHeader(at, el.getEnclosingElement(), includeParameterNames, false)) + el.getSimpleName();
1473             case EXCEPTION_PARAMETER: case LOCAL_VARIABLE: case PARAMETER: case RESOURCE_VARIABLE:
1474                 return el.getSimpleName() + &quot;:&quot; + el.asType();
1475             case CONSTRUCTOR: case METHOD: {
1476                 StringBuilder header = new StringBuilder();
1477 
1478                 boolean isMethod = el.getKind() == ElementKind.METHOD;
1479                 ExecutableElement method = (ExecutableElement) el;
1480 
1481                 if (isMethod) {
1482                     // return type
1483                     header.append(printType(at, proc, method.getReturnType())).append(&quot; &quot;);
1484                 } else {
1485                     // type parameters for the constructor
1486                     String typeParameters = typeParametersOpt(at, method.getTypeParameters(), includeParameterNames);
1487                     if (!typeParameters.isEmpty()) {
1488                         header.append(typeParameters).append(&quot; &quot;);
1489                     }
1490                 }
1491 
1492                 // receiver type
1493                 String clazz = elementHeader(at, el.getEnclosingElement(), includeParameterNames, false);
1494                 header.append(clazz);
1495 
1496                 if (isMethod) {
1497                     //method name with type parameters
1498                     (clazz.isEmpty() ? header : header.append(&quot;.&quot;))
1499                             .append(typeParametersOpt(at, method.getTypeParameters(), includeParameterNames))
1500                             .append(el.getSimpleName());
1501                 }
1502 
1503                 // arguments
1504                 header.append(&quot;(&quot;);
1505                 String sep = &quot;&quot;;
1506                 for (Iterator&lt;? extends VariableElement&gt; i = method.getParameters().iterator(); i.hasNext();) {
1507                     VariableElement p = i.next();
1508                     header.append(sep);
1509                     if (!i.hasNext() &amp;&amp; method.isVarArgs()) {
1510                         header.append(printType(at, proc, unwrapArrayType(p.asType()))).append(&quot;...&quot;);
1511                     } else {
1512                         header.append(printType(at, proc, p.asType()));
1513                     }
1514                     if (includeParameterNames) {
1515                         header.append(&quot; &quot;);
1516                         header.append(p.getSimpleName());
1517                     }
1518                     sep = &quot;, &quot;;
1519                 }
1520                 header.append(&quot;)&quot;);
1521 
1522                 // throws
1523                 List&lt;? extends TypeMirror&gt; thrownTypes = method.getThrownTypes();
1524                 if (!thrownTypes.isEmpty()) {
1525                     header.append(&quot; throws &quot;)
1526                             .append(thrownTypes.stream()
1527                                     .map(type -&gt; printType(at, proc, type))
1528                                     .collect(joining(&quot;, &quot;)));
1529                 }
1530                 return header.toString();
1531             }
1532             default:
1533                 return el.toString();
1534         }
1535     }
1536     private String appendDot(String fqn) {
1537         return fqn.isEmpty() ? fqn : fqn + &quot;.&quot;;
1538     }
1539     private TypeMirror unwrapArrayType(TypeMirror arrayType) {
1540         if (arrayType.getKind() == TypeKind.ARRAY) {
1541             return ((ArrayType)arrayType).getComponentType();
1542         }
1543         return arrayType;
1544     }
1545     private String typeParametersOpt(AnalyzeTask at, List&lt;? extends TypeParameterElement&gt; typeParameters, boolean includeParameterNames) {
1546         return typeParameters.isEmpty() ? &quot;&quot;
1547                 : typeParameters.stream()
1548                         .map(tp -&gt; elementHeader(at, tp, includeParameterNames, false))
1549                         .collect(joining(&quot;, &quot;, &quot;&lt;&quot;, &quot;&gt;&quot;));
1550     }
1551 
1552     @Override
1553     public String analyzeType(String code, int cursor) {
1554         switch (guessKind(code)) {
1555             case IMPORT: case METHOD: case CLASS: case ENUM:
1556             case INTERFACE: case ANNOTATION_TYPE: case VARIABLE:
1557                 return null;
1558             default:
1559                 break;
1560         }
1561         ExpressionInfo ei = ExpressionToTypeInfo.expressionInfo(code, proc);
1562         return (ei == null || !ei.isNonVoid)
1563                 ? null
1564                 : ei.typeName;
1565     }
1566 
1567     @Override
1568     public QualifiedNames listQualifiedNames(String code, int cursor) {
1569         String codeFin = code.substring(0, cursor);
1570         if (codeFin.trim().isEmpty()) {
1571             return new QualifiedNames(Collections.emptyList(), -1, true, false);
1572         }
1573         OuterWrap codeWrap;
1574         switch (guessKind(codeFin)) {
1575             case IMPORT:
1576                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1577             case METHOD:
1578                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.classMemberWrap(codeFin));
1579                 break;
1580             default:
1581                 codeWrap = proc.outerMap.wrapInTrialClass(Wrap.methodWrap(codeFin));
1582                 break;
1583         }
1584         return proc.taskFactory.analyze(codeWrap, at -&gt; {
1585             SourcePositions sp = at.trees().getSourcePositions();
1586             CompilationUnitTree topLevel = at.firstCuTree();
1587             TreePath tp = pathFor(topLevel, sp, codeWrap, codeFin.length());
1588             if (tp.getLeaf().getKind() != Kind.IDENTIFIER) {
1589                 return new QualifiedNames(Collections.emptyList(), -1, true, false);
1590             }
1591             Scope scope = at.trees().getScope(tp);
1592             TypeMirror type = at.trees().getTypeMirror(tp);
1593             Element el = at.trees().getElement(tp);
1594 
1595             boolean erroneous = (type.getKind() == TypeKind.ERROR &amp;&amp; el.getKind() == ElementKind.CLASS) ||
1596                                 (el.getKind() == ElementKind.PACKAGE &amp;&amp; el.getEnclosedElements().isEmpty());
1597             String simpleName = ((IdentifierTree) tp.getLeaf()).getName().toString();
1598             boolean upToDate;
1599             List&lt;String&gt; result;
1600 
1601             synchronized (currentIndexes) {
1602                 upToDate = classpathVersion == indexVersion;
1603                 result = currentIndexes.values()
1604                                        .stream()
1605                                        .flatMap(idx -&gt; idx.classSimpleName2FQN.getOrDefault(simpleName,
1606                                                                                             Collections.emptyList()).stream())
1607                                        .distinct()
1608                                        .filter(fqn -&gt; isAccessible(at, scope, fqn))
1609                                        .sorted()
1610                                        .collect(Collectors.toList());
1611             }
1612 
1613             return new QualifiedNames(result, simpleName.length(), upToDate, !erroneous);
1614         });
1615     }
1616 
1617     private boolean isAccessible(AnalyzeTask at, Scope scope, String fqn) {
1618         TypeElement type = at.getElements().getTypeElement(fqn);
1619         if (type == null)
1620             return false;
1621         return at.trees().isAccessible(scope, type);
1622     }
1623 
1624     //--------------------
1625     // classpath indexing:
1626     //--------------------
1627 
1628     //the indexing can be suspended when a more important task is running:
1629     private void waitIndexingNotSuspended() {
1630         boolean suspendedNotified = false;
1631         synchronized (suspendLock) {
1632             while (suspend &gt; 0) {
1633                 if (!suspendedNotified) {
1634                     suspendedNotified = true;
1635                 }
1636                 try {
1637                     suspendLock.wait();
1638                 } catch (InterruptedException ex) {
1639                 }
1640             }
1641         }
1642     }
1643 
1644     public void suspendIndexing() {
1645         synchronized (suspendLock) {
1646             suspend++;
1647         }
1648     }
1649 
1650     public void resumeIndexing() {
1651         synchronized (suspendLock) {
1652             if (--suspend == 0) {
1653                 suspendLock.notifyAll();
1654             }
1655         }
1656     }
1657 
1658     //update indexes, either initially or after a classpath change:
1659     private void refreshIndexes(int version) {
1660         try {
1661             Collection&lt;Path&gt; paths = new ArrayList&lt;&gt;();
1662             MemoryFileManager fm = proc.taskFactory.fileManager();
1663 
1664             appendPaths(fm, StandardLocation.PLATFORM_CLASS_PATH, paths);
1665             appendPaths(fm, StandardLocation.CLASS_PATH, paths);
1666             appendPaths(fm, StandardLocation.SOURCE_PATH, paths);
1667 
1668             Map&lt;Path, ClassIndex&gt; newIndexes = new HashMap&lt;&gt;();
1669 
1670             //setup existing/last known data:
1671             for (Path p : paths) {
1672                 ClassIndex index = PATH_TO_INDEX.get(p);
1673                 if (index != null) {
1674                     newIndexes.put(p, index);
1675                 }
1676             }
1677 
1678             synchronized (currentIndexes) {
1679                 //temporary setting old data:
1680                 currentIndexes.clear();
1681                 currentIndexes.putAll(newIndexes);
1682             }
1683 
1684             //update/compute the indexes if needed:
1685             for (Path p : paths) {
1686                 waitIndexingNotSuspended();
1687 
1688                 ClassIndex index = indexForPath(p);
1689                 newIndexes.put(p, index);
1690             }
1691 
1692             synchronized (currentIndexes) {
1693                 currentIndexes.clear();
1694                 currentIndexes.putAll(newIndexes);
1695             }
1696         } catch (Exception ex) {
1697             proc.debug(ex, &quot;SourceCodeAnalysisImpl.refreshIndexes(&quot; + version + &quot;)&quot;);
1698         } finally {
1699             synchronized (currentIndexes) {
1700                 indexVersion = version;
1701             }
1702         }
1703     }
1704 
1705     private void appendPaths(MemoryFileManager fm, Location loc, Collection&lt;Path&gt; paths) {
1706         Iterable&lt;? extends Path&gt; locationPaths = fm.getLocationAsPaths(loc);
1707         if (locationPaths == null)
1708             return ;
1709         for (Path path : locationPaths) {
1710             if (&quot;.&quot;.equals(path.toString())) {
1711                 //skip CWD
1712                 continue;
1713             }
1714 
1715             paths.add(path);
1716         }
1717     }
1718 
1719     //create/update index a given JavaFileManager entry (which may be a JDK installation, a jar/zip file or a directory):
1720     //if an index exists for the given entry, the existing index is kept unless the timestamp is modified
1721     private ClassIndex indexForPath(Path path) {
1722         if (isJRTMarkerFile(path)) {
1723             FileSystem jrtfs = FileSystems.getFileSystem(URI.create(&quot;jrt:/&quot;));
1724             Path modules = jrtfs.getPath(&quot;modules&quot;);
1725             return PATH_TO_INDEX.compute(path, (p, index) -&gt; {
1726                 try {
1727                     long lastModified = Files.getLastModifiedTime(modules).toMillis();
1728                     if (index == null || index.timestamp != lastModified) {
1729                         try (DirectoryStream&lt;Path&gt; stream = Files.newDirectoryStream(modules)) {
1730                             index = doIndex(lastModified, path, stream);
1731                         }
1732                     }
1733                     return index;
1734                 } catch (IOException ex) {
1735                     proc.debug(ex, &quot;SourceCodeAnalysisImpl.indexesForPath(&quot; + path.toString() + &quot;)&quot;);
1736                     return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());
1737                 }
1738             });
1739         } else if (!Files.isDirectory(path)) {
1740             if (Files.exists(path)) {
1741                 return PATH_TO_INDEX.compute(path, (p, index) -&gt; {
1742                     try {
1743                         long lastModified = Files.getLastModifiedTime(p).toMillis();
1744                         if (index == null || index.timestamp != lastModified) {
1745                             ClassLoader cl = SourceCodeAnalysisImpl.class.getClassLoader();
1746 
1747                             try (FileSystem zip = FileSystems.newFileSystem(path, cl)) {
1748                                 index = doIndex(lastModified, path, zip.getRootDirectories());
1749                             }
1750                         }
1751                         return index;
1752                     } catch (IOException ex) {
1753                         proc.debug(ex, &quot;SourceCodeAnalysisImpl.indexesForPath(&quot; + path.toString() + &quot;)&quot;);
1754                         return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());
1755                     }
1756                 });
1757             } else {
1758                 return new ClassIndex(-1, path, Collections.emptySet(), Collections.emptyMap());
1759             }
1760         } else {
1761             return PATH_TO_INDEX.compute(path, (p, index) -&gt; {
1762                 //no persistence for directories, as we cannot check timestamps:
1763                 if (index == null) {
1764                     index = doIndex(-1, path, Arrays.asList(p));
1765                 }
1766                 return index;
1767             });
1768         }
1769     }
1770 
1771     static boolean isJRTMarkerFile(Path path) {
1772         return path.equals(Paths.get(System.getProperty(&quot;java.home&quot;), &quot;lib&quot;, &quot;modules&quot;));
1773     }
1774 
1775     //create an index based on the content of the given dirs; the original JavaFileManager entry is originalPath.
1776     private ClassIndex doIndex(long timestamp, Path originalPath, Iterable&lt;? extends Path&gt; dirs) {
1777         Set&lt;String&gt; packages = new HashSet&lt;&gt;();
1778         Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN = new HashMap&lt;&gt;();
1779 
1780         for (Path d : dirs) {
1781             try {
1782                 Files.walkFileTree(d, new FileVisitor&lt;Path&gt;() {
1783                     int depth;
1784                     @Override
1785                     public FileVisitResult preVisitDirectory(Path dir, BasicFileAttributes attrs) throws IOException {
1786                         waitIndexingNotSuspended();
1787                         if (depth++ == 0)
1788                             return FileVisitResult.CONTINUE;
1789                         String dirName = dir.getFileName().toString();
1790                         String sep = dir.getFileSystem().getSeparator();
1791                         dirName = dirName.endsWith(sep) ? dirName.substring(0, dirName.length() - sep.length())
1792                                                         : dirName;
1793                         if (SourceVersion.isIdentifier(dirName))
1794                             return FileVisitResult.CONTINUE;
1795                         return FileVisitResult.SKIP_SUBTREE;
1796                     }
1797                     @Override
1798                     public FileVisitResult visitFile(Path file, BasicFileAttributes attrs) throws IOException {
1799                         waitIndexingNotSuspended();
1800                         if (file.getFileName().toString().endsWith(&quot;.class&quot;)) {
1801                             String relativePath = d.relativize(file).toString();
1802                             String binaryName = relativePath.substring(0, relativePath.length() - 6).replace(&#39;/&#39;, &#39;.&#39;);
1803                             int packageDot = binaryName.lastIndexOf(&#39;.&#39;);
1804                             if (packageDot &gt; (-1)) {
1805                                 packages.add(binaryName.substring(0, packageDot));
1806                             }
1807                             String typeName = binaryName.replace(&#39;$&#39;, &#39;.&#39;);
1808                             addClassName2Map(classSimpleName2FQN, typeName);
1809                         }
1810                         return FileVisitResult.CONTINUE;
1811                     }
1812                     @Override
1813                     public FileVisitResult visitFileFailed(Path file, IOException exc) throws IOException {
1814                         return FileVisitResult.CONTINUE;
1815                     }
1816                     @Override
1817                     public FileVisitResult postVisitDirectory(Path dir, IOException exc) throws IOException {
1818                         depth--;
1819                         return FileVisitResult.CONTINUE;
1820                     }
1821                 });
1822             } catch (IOException ex) {
1823                 proc.debug(ex, &quot;doIndex(&quot; + d.toString() + &quot;)&quot;);
1824             }
1825         }
1826 
1827         return new ClassIndex(timestamp, originalPath, packages, classSimpleName2FQN);
1828     }
1829 
1830     private static void addClassName2Map(Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN, String typeName) {
1831         int simpleNameDot = typeName.lastIndexOf(&#39;.&#39;);
1832         classSimpleName2FQN.computeIfAbsent(typeName.substring(simpleNameDot + 1), n -&gt; new LinkedHashSet&lt;&gt;())
1833                            .add(typeName);
1834     }
1835 
1836     //holder for indexed data about a given path
1837     public static final class ClassIndex {
1838         public final long timestamp;
1839         public final Path forPath;
1840         public final Set&lt;String&gt; packages;
1841         public final Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN;
1842 
1843         public ClassIndex(long timestamp, Path forPath, Set&lt;String&gt; packages, Map&lt;String, Collection&lt;String&gt;&gt; classSimpleName2FQN) {
1844             this.timestamp = timestamp;
1845             this.forPath = forPath;
1846             this.packages = packages;
1847             this.classSimpleName2FQN = classSimpleName2FQN;
1848         }
1849 
1850     }
1851 
1852     //for tests, to be able to wait until the indexing finishes:
1853     public void waitBackgroundTaskFinished() throws Exception {
1854         boolean upToDate;
1855         synchronized (currentIndexes) {
1856             upToDate = classpathVersion == indexVersion;
1857         }
1858         while (!upToDate) {
1859             INDEXER.submit(() -&gt; {}).get();
1860             synchronized (currentIndexes) {
1861                 upToDate = classpathVersion == indexVersion;
1862             }
1863         }
1864     }
1865 
1866     /**
1867      * A candidate for continuation of the given user&#39;s input.
1868      */
1869     private static class SuggestionImpl implements Suggestion {
1870 
1871         private final String continuation;
1872         private final boolean matchesType;
1873 
1874         /**
1875          * Create a {@code Suggestion} instance.
1876          *
1877          * @param continuation a candidate continuation of the user&#39;s input
1878          * @param matchesType does the candidate match the target type
1879          */
1880         public SuggestionImpl(String continuation, boolean matchesType) {
1881             this.continuation = continuation;
1882             this.matchesType = matchesType;
1883         }
1884 
1885         /**
1886          * The candidate continuation of the given user&#39;s input.
1887          *
1888          * @return the continuation string
1889          */
1890         @Override
1891         public String continuation() {
1892             return continuation;
1893         }
1894 
1895         /**
1896          * Indicates whether input continuation matches the target type and is thus
1897          * more likely to be the desired continuation. A matching continuation is
1898          * preferred.
1899          *
1900          * @return {@code true} if this suggested continuation matches the
1901          * target type; otherwise {@code false}
1902          */
1903         @Override
1904         public boolean matchesType() {
1905             return matchesType;
1906         }
1907     }
1908 
1909     /**
1910      * The result of {@code analyzeCompletion(String input)}.
1911      * Describes the completeness and position of the first snippet in the given input.
1912      */
1913     private static class CompletionInfoImpl implements CompletionInfo {
1914 
1915         private final Completeness completeness;
1916         private final String source;
1917         private final String remaining;
1918 
1919         CompletionInfoImpl(Completeness completeness, String source, String remaining) {
1920             this.completeness = completeness;
1921             this.source = source;
1922             this.remaining = remaining;
1923         }
1924 
1925         /**
1926          * The analyzed completeness of the input.
1927          *
1928          * @return an enum describing the completeness of the input string.
1929          */
1930         @Override
1931         public Completeness completeness() {
1932             return completeness;
1933         }
1934 
1935         /**
1936          * Input remaining after the complete part of the source.
1937          *
1938          * @return the portion of the input string that remains after the
1939          * complete Snippet
1940          */
1941         @Override
1942         public String remaining() {
1943             return remaining;
1944         }
1945 
1946         /**
1947          * Source code for the first Snippet of code input. For example, first
1948          * statement, or first method declaration. Trailing semicolons will be
1949          * added, as needed.
1950          *
1951          * @return the source of the first encountered Snippet
1952          */
1953         @Override
1954         public String source() {
1955             return source;
1956         }
1957     }
1958 
1959 }
    </pre>
  </body>
</html>
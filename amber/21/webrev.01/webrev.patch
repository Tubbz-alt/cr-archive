diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java
@@ -5069,11 +5069,16 @@
                                                   .map(s -> (ClassSymbol) s.tsym)
                                                   .collect(List.collector());
 
             if (sealedSupers.isEmpty()) {
                 if ((c.flags_field & Flags.NON_SEALED) != 0) {
-                    log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype);
+                    boolean hasErrorSuper = types.directSupertypes(c.type)
+                                                 .stream()
+                                                 .anyMatch(s -> s.tsym.kind == Kind.ERR);
+                    if (!hasErrorSuper) {
+                        log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.NonSealedWithNoSealedSupertype);
+                    }
                 }
             } else {
                 if (c.isLocal() && !c.isEnum()) {
                     log.error(TreeInfo.diagnosticPositionFor(c, env.tree), Errors.LocalClassesCantExtendSealed);
                 }
diff a/src/jdk.jshell/share/classes/jdk/jshell/Eval.java b/src/jdk.jshell/share/classes/jdk/jshell/Eval.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/Eval.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/Eval.java
@@ -1213,11 +1213,11 @@
                 return message;
             }
     }
 
     private DiagList modifierDiagnostics(ModifiersTree modtree,
-                                         final TreeDissector dis, boolean isAbstractProhibited) {
+                                         final TreeDissector dis, boolean isNotClass) {
 
         List<Modifier> list = new ArrayList<>();
         boolean fatal = false;
         for (Modifier mod : modtree.getFlags()) {
             switch (mod) {
@@ -1225,22 +1225,28 @@
                 case NATIVE:
                     list.add(mod);
                     fatal = true;
                     break;
                 case ABSTRACT:
-                    if (isAbstractProhibited) {
+                    if (isNotClass) {
                         list.add(mod);
                         fatal = true;
                     }
                     break;
                 case PUBLIC:
                 case PROTECTED:
                 case PRIVATE:
                     // quietly ignore, user cannot see effects one way or the other
                     break;
-                case STATIC:
                 case FINAL:
+                    if (isNotClass) {
+                        //OK to declare a class final, to aid sealed classes
+                        list.add(mod);
+                        break;
+                    }
+                    break;
+                case STATIC:
                     list.add(mod);
                     break;
             }
         }
         if (list.isEmpty()) {
diff a/src/jdk.jshell/share/classes/jdk/jshell/MaskCommentsAndModifiers.java b/src/jdk.jshell/share/classes/jdk/jshell/MaskCommentsAndModifiers.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/MaskCommentsAndModifiers.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/MaskCommentsAndModifiers.java
@@ -35,15 +35,15 @@
  * @author Robert Field
  */
 class MaskCommentsAndModifiers {
 
     private final static Set<String> IGNORED_MODIFIERS =
-            Stream.of( "public", "protected", "private", "static", "final" )
+            Stream.of( "public", "protected", "private", "static" )
                     .collect( Collectors.toSet() );
 
     private final static Set<String> OTHER_MODIFIERS =
-            Stream.of( "abstract", "strictfp", "transient", "volatile", "synchronized", "native", "default" )
+            Stream.of( "abstract", "final", "strictfp", "transient", "volatile", "synchronized", "native", "default" )
                     .collect( Collectors.toSet() );
 
     // Builder to accumulate non-masked characters
     private final StringBuilder sbCleared = new StringBuilder();
 
diff a/src/jdk.jshell/share/classes/jdk/jshell/TreeDependencyScanner.java b/src/jdk.jshell/share/classes/jdk/jshell/TreeDependencyScanner.java
--- a/src/jdk.jshell/share/classes/jdk/jshell/TreeDependencyScanner.java
+++ b/src/jdk.jshell/share/classes/jdk/jshell/TreeDependencyScanner.java
@@ -64,15 +64,17 @@
     }
 
     // -- Differentiate declaration references from body references ---
 
     @Override
+    @SuppressWarnings("preview")
     public Void visitClass(ClassTree node, Set<String> p) {
         scan(node.getModifiers(), p);
         scan(node.getTypeParameters(), p);
         scan(node.getExtendsClause(), p);
         scan(node.getImplementsClause(), p);
+        scan(node.getPermitsClause(), p);
         scan(node.getMembers(), body);
         return null;
     }
 
     @Override
diff a/test/langtools/jdk/jshell/SealedClassesTest.java b/test/langtools/jdk/jshell/SealedClassesTest.java
--- /dev/null
+++ b/test/langtools/jdk/jshell/SealedClassesTest.java
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+
+/*
+ * @test
+ * @summary Test sealed class in jshell
+ * @modules jdk.jshell
+ * @build KullaTesting TestingInputStream ExpectedDiagnostic
+ * @run testng SealedClassesTest
+ */
+
+import javax.lang.model.SourceVersion;
+
+import jdk.jshell.TypeDeclSnippet;
+import jdk.jshell.Snippet.Status;
+
+import org.testng.annotations.BeforeMethod;
+import org.testng.annotations.Test;
+
+import static jdk.jshell.Snippet.Status.VALID;
+
+@Test
+public class SealedClassesTest extends KullaTesting {
+
+    public void testSealed() {
+        TypeDeclSnippet base = classKey(
+                assertEval("sealed class B permits I {}",
+                           ste(MAIN_SNIPPET, Status.NONEXISTENT, Status.RECOVERABLE_NOT_DEFINED, false, null)));
+        assertEval("final class I extends B {}",
+                   added(VALID),
+                   ste(base, Status.RECOVERABLE_NOT_DEFINED, Status.VALID, true, null));
+        assertEval("new I()");
+    }
+
+    public void testNonSealed() {
+        TypeDeclSnippet base = classKey(
+                assertEval("sealed class B permits I {}",
+                           ste(MAIN_SNIPPET, Status.NONEXISTENT, Status.RECOVERABLE_NOT_DEFINED, false, null)));
+        assertEval("non-sealed class I extends B {}",
+                   added(VALID),
+                   ste(base, Status.RECOVERABLE_NOT_DEFINED, Status.VALID, true, null));
+        assertEval("class I2 extends I {}");
+        assertEval("new I2()");
+    }
+
+    @BeforeMethod
+    public void setUp() {
+        setUp(b -> b.compilerOptions("--enable-preview", "-source", String.valueOf(SourceVersion.latest().ordinal()))
+                    .remoteVMOptions("--enable-preview"));
+    }
+}
diff a/test/langtools/tools/javac/sealed/SealedCompilationTests.java b/test/langtools/tools/javac/sealed/SealedCompilationTests.java
--- a/test/langtools/tools/javac/sealed/SealedCompilationTests.java
+++ b/test/langtools/tools/javac/sealed/SealedCompilationTests.java
@@ -53,10 +53,11 @@
 
 import com.sun.tools.javac.util.Assert;
 
 import static org.testng.Assert.assertEquals;
 import static org.testng.Assert.assertTrue;
+import static org.testng.Assert.fail;
 import org.testng.annotations.Test;
 import tools.javac.combo.CompilationTestCase;
 
 import toolbox.ToolBox;
 import toolbox.JavacTask;
@@ -618,9 +619,21 @@
         if (!output.containsAll(expected)) {
             throw new AssertionError("Expected output not found. Expected: " + expected);
         }
     }
 
+    public void testNonSealedErroneousSuper() {
+        assertFail("compiler.err.cant.resolve",
+                   d -> {
+                       if (diags.keys().size() != 1) {
+                           fail("Unexpected errors: " + diags.keys());
+                       }
+                   },
+                   """
+                   non-sealed class C extends Undefined {}
+                   """);
+    }
+
     private Path[] findJavaFiles(Path... paths) throws IOException {
         return tb.findJavaFiles(paths);
     }
 }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/langtools/tools/javac/sealed/SealedCompilationTests.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 /**
 27  * SealedCompilationTests
 28  *
 29  * @test
 30  * @summary Negative compilation tests, and positive compilation (smoke) tests for sealed classes
 31  * @library /lib/combo /tools/lib
 32  * @modules
 33  *     jdk.compiler/com.sun.tools.javac.util
 34  *     jdk.compiler/com.sun.tools.javac.api
 35  *     jdk.compiler/com.sun.tools.javac.main
 36  * @build toolbox.ToolBox toolbox.JavacTask
 37  * @compile --enable-preview -source ${jdk.version} SealedCompilationTests.java
 38  * @run testng/othervm --enable-preview SealedCompilationTests
 39  */
 40 
 41 import java.lang.constant.ClassDesc;
 42 
 43 import java.io.File;
 44 
 45 import java.io.IOException;
 46 import java.nio.file.Files;
 47 import java.nio.file.Path;
 48 import java.nio.file.Paths;
 49 
 50 import java.util.ArrayList;
 51 import java.util.List;
 52 import java.util.Set;
 53 
 54 import com.sun.tools.javac.util.Assert;
 55 
 56 import static org.testng.Assert.assertEquals;
 57 import static org.testng.Assert.assertTrue;
 58 import org.testng.annotations.Test;
 59 import tools.javac.combo.CompilationTestCase;
 60 
 61 import toolbox.ToolBox;
 62 import toolbox.JavacTask;
 63 import toolbox.Task;
 64 import toolbox.Task.OutputKind;
 65 
 66 @Test
 67 public class SealedCompilationTests extends CompilationTestCase {
 68 
 69     ToolBox tb = new ToolBox();
 70 
 71     // When sealed classes become a permanent feature, we don&#39;t need these any more
 72     private static String[] PREVIEW_OPTIONS = {&quot;--enable-preview&quot;, &quot;-source&quot;,
 73                                                Integer.toString(Runtime.version().feature())};
 74 
 75     {
 76         setDefaultFilename(&quot;SealedTest.java&quot;);
 77         setCompileOptions(PREVIEW_OPTIONS);
 78     }
 79 
 80     private static final String NO_SHELL = &quot;&quot;&quot;
 81                  #
 82                  &quot;&quot;&quot;;
 83     private static final String NEST_SHELL = &quot;&quot;&quot;
 84                  class SealedTest {
 85                      #
 86                  }
 87                  &quot;&quot;&quot;;
 88     private static final String AUX_SHELL = &quot;&quot;&quot;
 89                  class SealedTest {
 90                  }
 91                  #
 92                  &quot;&quot;&quot;;
 93     private static final List&lt;String&gt; SHELLS = List.of(NO_SHELL, NEST_SHELL, AUX_SHELL);
 94 
 95     public void testSimpleExtension() {
 96         String CC1 =
 97             &quot;&quot;&quot;
 98             sealed class Sup # { }
 99             # class Sub extends Sup { }
100             &quot;&quot;&quot;;
101 
102         String CC2 =
103                 &quot;&quot;&quot;
104                 sealed class Sup&lt;T&gt; # { }
105                 # class Sub&lt;T&gt; extends Sup&lt;T&gt; { }
106                 &quot;&quot;&quot;;
107         String CC3 =
108                 &quot;&quot;&quot;
109                 sealed class Sup&lt;T&gt; # { }
110                     # class Sub extends Sup&lt;String&gt; { }
111                 &quot;&quot;&quot;;
112         String AC1 =
113             &quot;&quot;&quot;
114             sealed abstract class Sup # { }
115             # class Sub extends Sup { }
116             &quot;&quot;&quot;;
117         String AC2 =
118                 &quot;&quot;&quot;
119                 sealed abstract class Sup&lt;T&gt; # { }
120                     # class Sub&lt;T&gt; extends Sup&lt;T&gt; { }
121                 &quot;&quot;&quot;;
122         String AC3 =
123                 &quot;&quot;&quot;
124                 sealed abstract class Sup&lt;T&gt; # { }
125                     # class Sub extends Sup&lt;String&gt; { }
126                 &quot;&quot;&quot;;
127         String I1 =
128             &quot;&quot;&quot;
129             sealed interface Sup # { }
130             # class Sub implements Sup { }
131             &quot;&quot;&quot;;
132         String I11 =
133                 &quot;&quot;&quot;
134                 sealed interface Sup&lt;T&gt; # { }
135                 # class Sub&lt;T&gt; implements Sup&lt;T&gt; { }
136                 &quot;&quot;&quot;;
137         String I12 =
138                 &quot;&quot;&quot;
139                 sealed interface Sup&lt;T&gt; # { }
140                 # class Sub&lt;T&gt; implements Sup&lt;String&gt; { }
141                 &quot;&quot;&quot;;
142         String I2 =
143             &quot;&quot;&quot;
144             sealed interface Sup # { }
145             # class Sub1 implements Sup { }
146             # class Sub2 implements Sup { }
147             &quot;&quot;&quot;;
148 
149         // Assert that all combinations work:
150         // { class, abs class, interface } x { implicit permits, explicit permits }
151         //                                 x { final, non-sealed subtype }
152         for (String shell : SHELLS)
153             for (String b : List.of(CC1, CC2, CC3, AC1, AC2, AC3, I1, I11, I12))
154                 for (String p : List.of(&quot;&quot;, &quot;permits Sub&quot;))
155                     for (String m : List.of(&quot;final&quot;, &quot;non-sealed&quot;))
156                         assertOK(shell, b, p, m);
157 
158 
159         // Same for type with two subtypes
160         for (String shell : SHELLS)
161             for (String p : List.of(&quot;&quot;, &quot;permits Sub1, Sub2&quot;))
162                 for (String m : List.of(&quot;final&quot;, &quot;non-sealed&quot;))
163                     assertOK(shell, expandMarkers(I2, p, m, m));
164 
165         // Expect failure if there is no explicit final / sealed / non-sealed
166         for (String shell : SHELLS)
167             for (String b : List.of(CC1, CC2, CC3, AC1, AC2, AC3, I1, I11, I12))
168                 for (String p : List.of(&quot;&quot;, &quot;permits Sub&quot;))
169                     for (String m : List.of(&quot;&quot;))
170                         assertFail(&quot;compiler.err.non.sealed.sealed.or.final.expected&quot;, shell, expandMarkers(b, p, m));
171     }
172 
173     public void testSealedAndRecords() {
174         String P =
175             &quot;&quot;&quot;
176             sealed interface Sup # { }
177             record A(int a) implements Sup { }
178             record B(int b) implements Sup { }
179             record C(int c) implements Sup { }
180             &quot;&quot;&quot;;
181 
182         for (String shell : SHELLS)
183             for (String b : List.of(P))
184                 for (String p : List.of(&quot;&quot;, &quot;permits A, B, C&quot;))
185                     assertOK(shell, b, p);
186     }
187 
188     // Test that a type that explicitly permits one type, can&#39;t be extended by another
189     public void testBadExtension() {
190         String CC2 =
191                 &quot;&quot;&quot;
192                 sealed class Sup permits Sub1 { }
193                 final class Sub1 extends Sup { }
194                 final class Sub2 extends Sup { }
195                 &quot;&quot;&quot;;
196         String AC2 =
197                 &quot;&quot;&quot;
198                 sealed abstract class Sup permits Sub1 { }
199                 final class Sub1 extends Sup { }
200                 final class Sub2 extends Sup { }
201                 &quot;&quot;&quot;;
202         String I2c =
203                 &quot;&quot;&quot;
204                 sealed interface Sup permits Sub1 { }
205                 final class Sub1 implements Sup { }
206                 final class Sub2 implements Sup { }
207                 &quot;&quot;&quot;;
208         String I2i =
209                 &quot;&quot;&quot;
210                 sealed interface Sup permits Sub1 { }
211                 non-sealed interface Sub1 extends Sup { }
212                 non-sealed interface Sub2 extends Sup { }
213                 &quot;&quot;&quot;;
214 
215         for (String shell : SHELLS)
216             for (String b : List.of(CC2, AC2, I2c, I2i))
217                 assertFail(&quot;compiler.err.cant.inherit.from.sealed&quot;, shell, b);
218     }
219 
220     public void testRestrictedKeyword() {
221         for (String s : List.of(
222                 &quot;class SealedTest { String sealed; }&quot;,
223                 &quot;class SealedTest { int sealed = 0; int non = 0; int ns = non-sealed; }&quot;,
224                 &quot;class SealedTest { void test(String sealed) { } }&quot;,
225                 &quot;class SealedTest { void sealed(String sealed) { } }&quot;,
226                 &quot;class SealedTest { void test() { String sealed = null; } }&quot;,
227                 &quot;class sealed {}&quot;)) {
228             assertOK(s);
229         }
230     }
231 
232     public void testRejectPermitsInNonSealedClass() {
233         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
234                 &quot;class SealedTest {\n&quot; +
235                 &quot;    class NotSealed permits Sub {}\n&quot; +
236                 &quot;    class Sub extends NotSealed {}\n&quot; +
237                 &quot;}&quot;);
238         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
239                 &quot;class SealedTest {\n&quot; +
240                 &quot;    interface NotSealed permits Sub {}\n&quot; +
241                 &quot;    class Sub implements NotSealed {}\n&quot; +
242                 &quot;}&quot;);
243     }
244 
245     public void testTypeInPermitsIsSameClassOrSuper() {
246         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
247                 &quot;&quot;&quot;
248                 sealed class Sealed permits Sealed {}
249                 &quot;&quot;&quot;
250                 );
251         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
252                 &quot;&quot;&quot;
253                 interface I {}
254                 sealed class Sealed implements I permits I {}
255                 &quot;&quot;&quot;
256                 );
257         assertFail(&quot;compiler.err.invalid.permits.clause&quot;,
258                 &quot;&quot;&quot;
259                 interface I {}
260                 interface I2 extends I {}
261                 sealed class Sealed implements I2 permits I {}
262                 &quot;&quot;&quot;
263                 );
264     }
265 
266     /* It is a compile-time error if a class declaration has more than one of the class modifiers
267      * sealed, non-sealed and final
268      */
269     public void testBadModifiers() {
270         assertFail(&quot;compiler.err.non.sealed.with.no.sealed.supertype&quot;,
271                 &quot;class SealedTest { non-sealed class NoSealedSuper {} }&quot;);
272         assertFail(&quot;compiler.err.mod.not.allowed.here&quot;,
273                    &quot;class SealedTest { sealed public void m() {} }&quot;);
274         for (String s : List.of(
275                 &quot;class SealedTest { sealed non-sealed class Super {} }&quot;,
276                 &quot;class SealedTest { final non-sealed class Super {} }&quot;,
277                 &quot;class SealedTest { final sealed class Super {} }&quot;,
278                 &quot;class SealedTest { final sealed non-sealed class Super {} }&quot;,
279                 &quot;class SealedTest {\n&quot; +
280                 &quot;    sealed class Super {}\n&quot; +
281                 &quot;    sealed non-sealed class Sub extends Super {}\n&quot; +
282                 &quot;}&quot;))
283             assertFail(&quot;compiler.err.illegal.combination.of.modifiers&quot;, s);
284     }
285 
286     public void testAnonymousAndLambdaCantExtendSealed() {
287         for (String s : List.of(
288                 &quot;&quot;&quot;
289                 sealed interface I1 extends Runnable {
290                     public static I1 i = () -&gt; {};
291                 }
292                 &quot;&quot;&quot;
293                 ))
294             assertFail(&quot;compiler.err.cant.inherit.from.sealed&quot;, s);
295 
296         for (String s : List.of(
297                 &quot;&quot;&quot;
298                 sealed interface I2 extends Runnable {
299                     public static void foo() { new I2() { public void run() { } }; }
300                 }
301                 final class C implements I2 {
302                     @Override public void run() {}
303                 }
304                 &quot;&quot;&quot;
305                 ))
306                 assertFail(&quot;compiler.err.local.classes.cant.extend.sealed&quot;, s);
307     }
308 
309     public void testNoLocalSealedClasses() {
310         for (String s : List.of(
311                 &quot;&quot;&quot;
312                 sealed class C {
313                     void m() {
314                         sealed class D { }
315                     }
316                 }
317                 &quot;&quot;&quot;,
318                 &quot;&quot;&quot;
319                 sealed class C {
320                     void m() {
321                         non-sealed class D { }
322                     }
323                 }
324                 &quot;&quot;&quot;))
325             assertFail(&quot;compiler.err.sealed.or.non.sealed.local.classes.not.allowed&quot;, s);
326     }
327 
328     public void testLocalCantExtendSealed() {
329         for (String s : List.of(
330                 &quot;&quot;&quot;
331                 sealed class C {
332                     void m() {
333                         final class D extends C { }
334                     }
335                 }
336                 &quot;&quot;&quot;))
337             assertFail(&quot;compiler.err.local.classes.cant.extend.sealed&quot;, s);
338     }
339 
340     public void testSealedInterfaceAndAbstracClasses() {
341         for (String s : List.of(
342                 &quot;&quot;&quot;
343                 sealed interface I {}
344                 &quot;&quot;&quot;,
345                 &quot;&quot;&quot;
346                 sealed abstract class AC {}
347                 &quot;&quot;&quot;,
348                 &quot;&quot;&quot;
349                 sealed class C {}
350                 &quot;&quot;&quot;))
351             assertFail(&quot;compiler.err.sealed.class.must.have.subclasses&quot;, s);
352 
353         for (String s : List.of(
354                 &quot;&quot;&quot;
355                 sealed interface I {}
356 
357                 non-sealed interface I2 extends I {}
358                 &quot;&quot;&quot;,
359                 &quot;&quot;&quot;
360                 sealed interface I {}
361 
362                 sealed interface I2 extends I {}
363 
364                 non-sealed interface I3 extends I2 {}
365                 &quot;&quot;&quot;,
366                 &quot;&quot;&quot;
367                 sealed interface I permits I2 {}
368 
369                 non-sealed interface I2 extends I {}
370                 &quot;&quot;&quot;,
371                 &quot;&quot;&quot;
372                 sealed interface I permits I2 {}
373 
374                 sealed interface I2 extends I permits I3 {}
375 
376                 non-sealed interface I3 extends I2 {}
377                 &quot;&quot;&quot;
378                 ))
379             assertOK(s);
380     }
381 
382     public void testEnumsCantBeSealedOrNonSealed() {
383         for (String s : List.of(
384                 &quot;&quot;&quot;
385                 sealed interface I {}
386 
387                 sealed enum E implements I {E1}
388                 &quot;&quot;&quot;,
389                 &quot;&quot;&quot;
390                 sealed interface I {}
391 
392                 non-sealed enum E implements I {E1}
393                 &quot;&quot;&quot;))
394             assertFail(&quot;compiler.err.mod.not.allowed.here&quot;, s);
395     }
396 
397     public void testEnumsCanImplementSealedInterfaces() {
398         for (String s : List.of(
399                 &quot;&quot;&quot;
400                 sealed interface I {}
401 
402                 enum E implements I {E1}
403                 &quot;&quot;&quot;))
404             assertOK(s);
405     }
406 
407     public void testClassesCanExtendNonSealed() {
408         for (String s : List.of(
409                 &quot;&quot;&quot;
410                 sealed class C {}
411 
412                 non-sealed class Sub extends C {}
413 
414                 class Sub2 extends Sub {}
415                 &quot;&quot;&quot;)) {
416             assertOK(s);
417         }
418     }
419 
420     public void testEmptyPermits() {
421         for (String s : List.of(
422             &quot;&quot;&quot;
423             sealed class C permits {}
424             non-sealed class Sub extends C {}
425             &quot;&quot;&quot;)) {
426             assertFail(&quot;compiler.err.illegal.start.of.type&quot;, s);
427         }
428     }
429 
430     public void testTypeVarInPermits() {
431         for (String s : List.of(
432             &quot;&quot;&quot;
433             class Outer&lt;T&gt; {
434                 sealed class C permits T  {}
435             }
436             &quot;&quot;&quot;)) {
437             assertFail(&quot;compiler.err.invalid.permits.clause&quot;, s);
438         }
439     }
440 
441     public void testRepeatedTypeInPermits() {
442         for (String s : List.of(
443             &quot;&quot;&quot;
444             sealed class C permits Sub, Sub {}
445 
446             final class Sub extends C {}
447             &quot;&quot;&quot;)) {
448             assertFail(&quot;compiler.err.invalid.permits.clause&quot;, s);
449         }
450     }
451 
452     public void testSubtypeDoesntExtendSealed() {
453         for (String s : List.of(
454             &quot;&quot;&quot;
455             sealed class C permits Sub {}
456 
457             final class Sub {}
458             &quot;&quot;&quot;,
459             &quot;&quot;&quot;
460             sealed interface I permits Sub {}
461 
462             final class Sub {}
463             &quot;&quot;&quot;,
464             &quot;&quot;&quot;
465             sealed class C permits Sub1, Sub2 {}
466 
467             sealed class Sub1 extends C permits Sub2 {}
468 
469             final class Sub2 extends Sub1 {}
470             &quot;&quot;&quot;
471             )) {
472             assertFail(&quot;compiler.err.invalid.permits.clause&quot;, s);
473         }
474     }
475 
476     public void testAPIForPrimitiveAndArrayClasses() {
477         for (Class&lt;?&gt; c : new Class[]{byte.class, byte[].class, short.class, short[].class, int.class, int[].class, long.class, long[].class,
478             float.class, float[].class, double.class, double[].class, char.class, char[].class, boolean.class, boolean[].class, void.class,
479             String[].class}) {
480             Assert.check(!c.isSealed());
481             Assert.check(c.getPermittedSubclasses().length == 0);
482         }
483     }
484 
485     public void testPrinting() throws Exception {
486         Path base = Paths.get(&quot;testPrinting&quot;);
487         Path src = base.resolve(&quot;src&quot;);
488         Path test = src.resolve(&quot;Test&quot;);
489 
490         tb.writeJavaFiles(test,
491             &quot;&quot;&quot;
492             sealed class SealedClassNoPermits {}
493 
494             final class FinalSubClass extends SealedClassNoPermits {}
495 
496             non-sealed class NonSealedSubClass extends SealedClassNoPermits {}
497 
498             sealed interface SealedInterfaceNoPermits {}
499 
500             non-sealed interface NonSealedInterface extends SealedInterfaceNoPermits {}
501 
502             final class FinalSubClass2 implements SealedInterfaceNoPermits {}
503 
504 
505             sealed class SealedClassWithPermits permits SealedClassWithPermits, NonSealedSubClass2 {}
506 
507             final class FinalSubClass3 extends SealedClassWithPermits {}
508 
509             non-sealed class NonSealedSubClass2 extends SealedClassWithPermits {}
510 
511             sealed interface SealedInterfaceWithPermits permits NonSealedInterface2, FinalSubClass4 {}
512 
513             non-sealed interface NonSealedInterface2 extends SealedInterfaceWithPermits {}
514 
515             final class FinalSubClass4 implements SealedInterfaceWithPermits {}
516 
517 
518             enum SealedEnum {
519                 E {}
520             }
521 
522             enum Enum {
523                 E
524             }
525             &quot;&quot;&quot;
526         );
527 
528         Path out = base.resolve(&quot;out&quot;);
529 
530         Files.createDirectories(out);
531 
532         List&lt;String&gt; output = new JavacTask(tb)
533             .outdir(out)
534             .options(&quot;--enable-preview&quot;, &quot;-source&quot;, Integer.toString(Runtime.version().feature()), &quot;-Xprint&quot;)
535             .files(findJavaFiles(test))
536             .run()
537             .writeAll()
538             .getOutputLines(OutputKind.STDOUT);
539 
540         List&lt;String&gt; expected = List.of(
541             &quot;&quot;,
542             &quot;sealed class SealedClassNoPermits permits FinalSubClass, NonSealedSubClass {&quot;,
543             &quot;&quot;,
544             &quot;  SealedClassNoPermits();&quot;,
545             &quot;}&quot;,
546             &quot;&quot;,
547             &quot;final class FinalSubClass extends SealedClassNoPermits {&quot;,
548             &quot;&quot;,
549             &quot;  FinalSubClass();&quot;,
550             &quot;}&quot;,
551             &quot;&quot;,
552             &quot;non-sealed class NonSealedSubClass extends SealedClassNoPermits {&quot;,
553             &quot;&quot;,
554             &quot;  NonSealedSubClass();&quot;,
555             &quot;}&quot;,
556             &quot;&quot;,
557             &quot;sealed interface SealedInterfaceNoPermits permits NonSealedInterface, FinalSubClass2 {&quot;,
558             &quot;}&quot;,
559             &quot;&quot;,
560             &quot;non-sealed interface NonSealedInterface extends SealedInterfaceNoPermits {&quot;,
561             &quot;}&quot;,
562             &quot;&quot;,
563             &quot;final class FinalSubClass2 implements SealedInterfaceNoPermits {&quot;,
564             &quot;&quot;,
565             &quot;  FinalSubClass2();&quot;,
566             &quot;}&quot;,
567             &quot;&quot;,
568             &quot;sealed class SealedClassWithPermits permits SealedClassWithPermits, NonSealedSubClass2 {&quot;,
569             &quot;&quot;,
570             &quot;  SealedClassWithPermits();&quot;,
571             &quot;}&quot;,
572             &quot;&quot;,
573             &quot;final class FinalSubClass3 extends SealedClassWithPermits {&quot;,
574             &quot;&quot;,
575             &quot;  FinalSubClass3();&quot;,
576             &quot;}&quot;,
577             &quot;&quot;,
578             &quot;non-sealed class NonSealedSubClass2 extends SealedClassWithPermits {&quot;,
579             &quot;&quot;,
580             &quot;  NonSealedSubClass2();&quot;,
581             &quot;}&quot;,
582             &quot;&quot;,
583             &quot;sealed interface SealedInterfaceWithPermits permits NonSealedInterface2, FinalSubClass4 {&quot;,
584             &quot;}&quot;,
585             &quot;&quot;,
586             &quot;non-sealed interface NonSealedInterface2 extends SealedInterfaceWithPermits {&quot;,
587             &quot;}&quot;,
588             &quot;&quot;,
589             &quot;final class FinalSubClass4 implements SealedInterfaceWithPermits {&quot;,
590             &quot;&quot;,
591             &quot;  FinalSubClass4();&quot;,
592             &quot;}&quot;,
593             &quot;&quot;,
594             &quot;sealed enum SealedEnum {&quot;,
595             &quot;&quot;,
596             &quot;  E;&quot;,
597             &quot;&quot;,
598             &quot;&quot;,
599             &quot;  public static SealedEnum[] values();&quot;,
600             &quot;&quot;,
601             &quot;  public static SealedEnum valueOf(java.lang.String name);&quot;,
602             &quot;&quot;,
603             &quot;  private SealedEnum();&quot;,
604             &quot;}&quot;,
605             &quot;&quot;,
606             &quot;enum Enum {&quot;,
607             &quot;&quot;,
608             &quot;  E;&quot;,
609             &quot;&quot;,
610             &quot;&quot;,
611             &quot;  public static Enum[] values();&quot;,
612             &quot;&quot;,
613             &quot;  public static Enum valueOf(java.lang.String name);&quot;,
614             &quot;&quot;,
615             &quot;  private Enum();&quot;,
616             &quot;}&quot;
617         );
618         if (!output.containsAll(expected)) {
619             throw new AssertionError(&quot;Expected output not found. Expected: &quot; + expected);
620         }
621     }
622 
623     private Path[] findJavaFiles(Path... paths) throws IOException {
624         return tb.findJavaFiles(paths);
625     }
626 }
    </pre>
  </body>
</html>
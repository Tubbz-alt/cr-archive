<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/langtools/jdk/jshell/ErrorTranslationTest.java</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2015, 2016, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 /*
 25  * @test
 26  * @bug 8188225 8243557
 27  * @summary Tests for shell error translation
 28  * @modules jdk.compiler/com.sun.tools.javac.api
 29  *          jdk.compiler/com.sun.tools.javac.main
 30  *          jdk.jdeps/com.sun.tools.javap
 31  *          jdk.jshell/jdk.internal.jshell.tool
 32  * @library /tools/lib
 33  * @build KullaTesting TestingInputStream ExpectedDiagnostic toolbox.ToolBox Compiler
 34  * @run testng ErrorTranslationTest
 35  */
 36 
 37 import java.nio.file.Path;
 38 import java.util.ArrayList;
 39 import java.util.List;
 40 import java.util.function.Consumer;
 41 
 42 import javax.tools.Diagnostic;
 43 
 44 import org.testng.annotations.Test;
 45 
 46 import static org.testng.Assert.assertEquals;
 47 import static org.testng.Assert.assertTrue;
 48 
 49 @Test
 50 public class ErrorTranslationTest extends ReplToolTesting {
 51 
 52     @Test(enabled = false) // TODO 8080353
 53     public void testErrors() {
 54         test(
 55                 a -&gt; assertDiagnostic(a, &quot;abstract void f();&quot;, newExpectedDiagnostic(0, 8, 0, -1, -1, Diagnostic.Kind.ERROR)),
 56                 a -&gt; assertDiagnostic(a, &quot;native void f();&quot;, newExpectedDiagnostic(0, 6, 0, -1, -1, Diagnostic.Kind.ERROR)),
 57                 a -&gt; assertDiagnostic(a, &quot;static void f();&quot;, newExpectedDiagnostic(0, 16, 0, -1, -1, Diagnostic.Kind.ERROR)),
 58                 a -&gt; assertDiagnostic(a, &quot;synchronized void f();&quot;, newExpectedDiagnostic(0, 12, 0, -1, -1, Diagnostic.Kind.ERROR)),
 59                 a -&gt; assertDiagnostic(a, &quot;default void f();&quot;, newExpectedDiagnostic(0, 7, 0, -1, -1, Diagnostic.Kind.ERROR))
 60         );
 61     }
 62 
 63     public void testlvtiErrors() {
 64         test(
 65                 a -&gt; assertDiagnostic(a, &quot;var broken = () -&gt; {};&quot;, newExpectedDiagnostic(0, 22, 0, -1, -1, Diagnostic.Kind.ERROR)),
 66                 a -&gt; assertDiagnostic(a, &quot;void t () { var broken = () -&gt; {}; }&quot;, newExpectedDiagnostic(12, 34, 0, -1, -1, Diagnostic.Kind.ERROR))
 67         );
 68     }
 69 
 70     public void testExceptionErrors() {
 71         test(
 72                 a -&gt; assertDiagnostic(a, &quot;try { } catch (IllegalStateException | java.io.IOException ex) { }&quot;, newExpectedDiagnostic(39, 58, -1, -1, -1, Diagnostic.Kind.ERROR))
 73         );
 74     }
 75 
 76     public void testWarnings() {
 77         List&lt;ReplTest&gt; list = new ArrayList&lt;&gt;();
 78         ExpectedDiagnostic[] diagnostics = new ExpectedDiagnostic[]{
 79                 newExpectedDiagnostic(0, 6, 0, -1, -1, Diagnostic.Kind.WARNING),
 80                 newExpectedDiagnostic(0, 5, 0, -1, -1, Diagnostic.Kind.WARNING)};
 81         String[] mods = {&quot;static&quot;, &quot;final&quot;};
 82         for (int i = 0; i &lt; mods.length; ++i) {
 83             for (String code : new String[] {&quot;class A {}&quot;, &quot;void f() {}&quot;, &quot;int a;&quot;}) {
 84                 final int finalI = i;
<a name="1" id="anc1"></a>


 85                 list.add(a -&gt; assertDiagnostic(a, mods[finalI] + &quot; &quot; + code, diagnostics[finalI]));
 86             }
 87         }
 88         test(list.toArray(new ReplTest[list.size()]));
 89     }
 90 
 91     @Test(enabled = false) // TODO 8132147
 92     public void stressTest() {
 93         Compiler compiler = new Compiler();
 94         Path oome = compiler.getPath(&quot;OOME.repl&quot;);
 95         Path soe = compiler.getPath(&quot;SOE.repl&quot;);
 96         compiler.writeToFile(oome,
 97                 &quot;List&lt;byte[]&gt; list = new ArrayList&lt;&gt;();\n&quot;,
 98                 &quot;while (true) {\n&quot; +
 99                 &quot;   list.add(new byte[1000000]);\n&quot; +
100                 &quot;}&quot;);
101         compiler.writeToFile(soe,
102                 &quot;void f() { f(); }&quot;,
103                 &quot;f();&quot;);
104         List&lt;ReplTest&gt; tests = new ArrayList&lt;&gt;();
105         for (int i = 0; i &lt; 25; ++i) {
106             tests.add(a -&gt; assertCommandCheckOutput(a, &quot;/o &quot; + soe.toString(),
107                     assertStartsWith(&quot;|  java.lang.StackOverflowError thrown&quot;)));
108             tests.add(a -&gt; assertCommandCheckOutput(a, &quot;/o &quot; + oome.toString(),
109                     assertStartsWith(&quot;|  java.lang.OutOfMemoryError thrown: Java heap space&quot;)));
110         }
111         test(tests.toArray(new ReplTest[tests.size()]));
112     }
113 
114     private ExpectedDiagnostic newExpectedDiagnostic(long startPosition, long endPosition, long position,
115                                                      long lineNumber, long columnNumber, Diagnostic.Kind kind) {
116         return new ExpectedDiagnostic(&quot;&quot;, startPosition, endPosition, position, lineNumber, columnNumber, kind);
117     }
118 
119     private void assertDiagnostic(boolean after, String cmd, ExpectedDiagnostic expectedDiagnostic) {
120         assertCommandCheckOutput(after, cmd, assertDiagnostic(cmd, expectedDiagnostic));
121     }
122 
123     private Consumer&lt;String&gt; assertDiagnostic(String expectedSource, ExpectedDiagnostic expectedDiagnostic) {
124         int start = (int) expectedDiagnostic.getStartPosition();
125         int end = (int) expectedDiagnostic.getEndPosition();
126         String expectedMarkingLine = createMarkingLine(start, end);
127         return s -&gt; {
128             String[] lines = s.split(&quot;\n&quot;);
129             if (lines.length &lt;= 3) {
130                 throw new AssertionError(&quot;Not enough lines: &quot; + s);
131             }
132             String kind = getKind(expectedDiagnostic.getKind());
133             assertEquals(lines[0], kind);
134             boolean found = false;
135             for (int i = 0; i &lt; lines.length; i++) {
136                 if (lines[i].endsWith(expectedSource)) {
137                     assertEquals(lines[i + 1], expectedMarkingLine, &quot;Input: &quot; + expectedSource + &quot;, marking line: &quot;);
138                     found = true;
139                 }
140             }
141             if (!found) {
142                 throw new AssertionError(&quot;Did not find: &quot; + expectedSource + &quot; in: &quot; + s);
143             }
144         };
145     }
146 
147     private String createMarkingLine(int start, int end) {
148         assertTrue(end &gt;= start, String.format(&quot;End position %d is less than start position %d&quot;, end, start));
149         StringBuilder sb = new StringBuilder();
150         sb.append(&quot;|  &quot;);
151         for (int i = 0; i &lt; start; ++i) {
152             sb.append(&#39; &#39;);
153         }
154         sb.append(&#39;^&#39;);
155         for (int i = 1; i &lt; end - start - 1; ++i) {
156             sb.append(&#39;-&#39;);
157         }
158         if (start &lt; end) {
159             sb.append(&#39;^&#39;);
160         }
161         return sb.toString();
162     }
163 
164     public String getKind(Diagnostic.Kind kind) {
165         switch (kind) {
166             case WARNING:
167                 return &quot;|  Warning:&quot;;
168             case ERROR:
169                 return &quot;|  Error:&quot;;
170             default:
171                 throw new AssertionError(&quot;Unsupported kind: &quot; + kind);
172         }
173     }
174 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/NetworkConfiguration.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="LockFreeLogger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Platform.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/NetworkConfiguration.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintStream;
 28 import java.io.UncheckedIOException;
 29 import java.net.Inet4Address;
 30 import java.net.Inet6Address;
 31 import java.net.InetAddress;
 32 import java.net.NetworkInterface;
 33 import java.util.Arrays;
<span class="line-modified"> 34 import java.util.HashMap;</span>
 35 import java.util.LinkedList;
 36 import java.util.List;
 37 import java.util.Map;

 38 import java.util.stream.Collectors;
 39 import java.util.stream.Stream;
 40 import java.security.AccessController;
 41 import java.security.PrivilegedAction;
 42 
 43 import static java.net.NetworkInterface.getNetworkInterfaces;
 44 import static java.util.Collections.list;
 45 
 46 /**
 47  * Helper class for retrieving network interfaces and local addresses
 48  * suitable for testing.
 49  */
 50 public class NetworkConfiguration {
 51 
 52     private Map&lt;NetworkInterface,List&lt;Inet4Address&gt;&gt; ip4Interfaces;
 53     private Map&lt;NetworkInterface,List&lt;Inet6Address&gt;&gt; ip6Interfaces;
 54     private final boolean isIPv6Available;
 55     private boolean has_testableipv6address = false;
 56     private boolean has_sitelocaladdress = false;
 57     private boolean has_linklocaladdress = false;
</pre>
<hr />
<pre>
 70                 // On Solaris or AIX, a configuration with only local or loopback
 71                 // addresses does not fully enable IPv6 operations.
 72                 // E.g. IPv6 multicasting does not work.
 73                 // So, don&#39;t set has_testableipv6address if we only find these.
 74                 .filter(addr -&gt; Platform.isSolaris() || Platform.isAix() ?
 75                     !(addr.isAnyLocalAddress() || addr.isLoopbackAddress()) : true)
 76                 .forEach(ia -&gt; {
 77                     has_testableipv6address = true;
 78                     if (ia.isLinkLocalAddress()) has_linklocaladdress = true;
 79                     if (ia.isSiteLocalAddress()) has_sitelocaladdress = true;
 80 
 81                     if (!ia.isLinkLocalAddress() &amp;&amp;
 82                         !ia.isSiteLocalAddress() &amp;&amp;
 83                         !ia.isLoopbackAddress()) {
 84                         has_globaladdress = true;
 85                     }
 86                 });
 87         });
 88     }
 89 
<span class="line-modified"> 90     private static boolean isNotExcludedInterface(NetworkInterface nif) {</span>
<span class="line-modified"> 91         if (Platform.isOSX() &amp;&amp; nif.getName().contains(&quot;awdl&quot;)) {</span>
<span class="line-modified"> 92             return false;</span>













 93         }

 94         if (Platform.isWindows()) {
 95             String dName = nif.getDisplayName();
 96             if (dName != null &amp;&amp; dName.contains(&quot;Teredo&quot;)) {
 97                 return false;
 98             }
 99         }
100         return true;
101     }
102 
103     private static boolean isNotLoopback(NetworkInterface nif) {
104         try {
105             return !nif.isLoopback();
106         } catch (IOException e) {
107             throw new UncheckedIOException(e);
108         }
109     }
110 
111     private boolean hasIp4Addresses(NetworkInterface nif) {
112         return ip4Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
113     }
114 
115     private boolean hasIp6Addresses(NetworkInterface nif) {
116         return ip6Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
117     }
118 






119     private boolean supportsIp4Multicast(NetworkInterface nif) {
120         try {
121             if (!nif.supportsMulticast()) {
122                 return false;
123             }
124 
125             // On AIX there is a bug:
126             // When IPv6 is enabled on the system, the JDK opens sockets as AF_INET6.
127             // If there&#39;s an interface configured with IPv4 addresses only, it should
128             // be able to become the network interface for a multicast socket (that
129             // could be in both, IPv4 or IPv6 space). But both possible setsockopt
130             // calls for either IPV6_MULTICAST_IF or IP_MULTICAST_IF return
131             // EADDRNOTAVAIL. So we must skip such interfaces here.
132             if (Platform.isAix() &amp;&amp; isIPv6Available() &amp;&amp; !hasIp6Addresses(nif)) {
133                 return false;
134             }
135 








136             return hasIp4Addresses(nif);
137         } catch (IOException e) {
138             throw new UncheckedIOException(e);
139         }
140     }
141 
142     private boolean supportsIp6Multicast(NetworkInterface nif) {
143         try {
144             if (!nif.supportsMulticast()) {
145                 return false;
146             }
147 








148             return hasIp6Addresses(nif);
149         } catch (IOException e) {
150             throw new UncheckedIOException(e);
151         }
152     }
153 
154     /**
155      * Returns whether IPv6 is available at all.
156      * This should resemble the result of native ipv6_available() in net_util.c
157      */
158     public boolean isIPv6Available() {
159         return isIPv6Available;
160     }
161 
162     /**
163      * Does any (usable) IPv6 address exist in the network configuration?
164      */
165     public boolean hasTestableIPv6Address() {
166         return has_testableipv6address;
167     }
</pre>
<hr />
<pre>
184      * Does any global IPv6 address exist?
185      */
186     public boolean has_globaladdress() {
187         return has_globaladdress;
188     }
189 
190     /**
191      * Returns a stream of interfaces suitable for functional tests.
192      */
193     public Stream&lt;NetworkInterface&gt; interfaces() {
194         return Stream.concat(ip4Interfaces(), ip6Interfaces())
195                      .distinct();
196     }
197 
198     /**
199      * Returns a stream of interfaces suitable for IPv4 functional tests.
200      */
201     public Stream&lt;NetworkInterface&gt; ip4Interfaces() {
202         return ip4Interfaces.keySet()
203                             .stream()
<span class="line-modified">204                             .filter(NetworkConfiguration::isNotExcludedInterface)</span>
205                             .filter(this::hasIp4Addresses);
206     }
207 
208     /**
209      * Returns a stream of interfaces suitable for IPv6 functional tests.
210      */
211     public Stream&lt;NetworkInterface&gt; ip6Interfaces() {
212         return ip6Interfaces.keySet()
213                             .stream()
<span class="line-modified">214                             .filter(NetworkConfiguration::isNotExcludedInterface)</span>
215                             .filter(this::hasIp6Addresses);
216     }
217 
218     /**
219      * Returns a stream of interfaces suitable for functional tests.
220      */
221     public Stream&lt;NetworkInterface&gt; multicastInterfaces(boolean includeLoopback) {
222         return Stream
223             .concat(ip4MulticastInterfaces(includeLoopback),
224                     ip6MulticastInterfaces(includeLoopback))
225             .distinct();
226     }
227 
228     /**
229      * Returns a stream of interfaces suitable for IPv4 multicast tests.
230      *
231      * The loopback interface will not be included.
232      */
233     public Stream&lt;NetworkInterface&gt; ip4MulticastInterfaces() {
234         return ip4MulticastInterfaces(false);
</pre>
<hr />
<pre>
292         return ip4Interfaces.get(nif).stream();
293     }
294 
295     /**
296      * Returns all IPv6 addresses for the given interface.
297      */
298     public Stream&lt;Inet6Address&gt; ip6Addresses(NetworkInterface nif) {
299         return ip6Interfaces.get(nif).stream();
300     }
301 
302     @Override
303     public String toString() {
304         return interfaces().map(NetworkConfiguration::interfaceInformation)
305                            .collect(Collectors.joining());
306     }
307 
308     /**
309      * Return a NetworkConfiguration instance.
310      */
311     public static NetworkConfiguration probe() throws IOException {
<span class="line-modified">312         Map&lt;NetworkInterface, List&lt;Inet4Address&gt;&gt; ip4Interfaces = new HashMap&lt;&gt;();</span>
<span class="line-modified">313         Map&lt;NetworkInterface, List&lt;Inet6Address&gt;&gt; ip6Interfaces = new HashMap&lt;&gt;();</span>
314 
315         List&lt;NetworkInterface&gt; nifs = list(getNetworkInterfaces());
316         for (NetworkInterface nif : nifs) {
317             // ignore interfaces that are down
318             if (!nif.isUp() || nif.isPointToPoint()) {
319                 continue;
320             }
321 
322             List&lt;Inet4Address&gt; ip4Addresses = new LinkedList&lt;&gt;();
323             List&lt;Inet6Address&gt; ip6Addresses = new LinkedList&lt;&gt;();
324             ip4Interfaces.put(nif, ip4Addresses);
325             ip6Interfaces.put(nif, ip6Addresses);
326             for (InetAddress addr : list(nif.getInetAddresses())) {
327                 if (addr instanceof Inet4Address) {
328                     ip4Addresses.add((Inet4Address) addr);
329                 } else if (addr instanceof Inet6Address) {
330                     ip6Addresses.add((Inet6Address) addr);
331                 }
332             }
333         }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.IOException;
 27 import java.io.PrintStream;
 28 import java.io.UncheckedIOException;
 29 import java.net.Inet4Address;
 30 import java.net.Inet6Address;
 31 import java.net.InetAddress;
 32 import java.net.NetworkInterface;
 33 import java.util.Arrays;
<span class="line-modified"> 34 import java.util.LinkedHashMap;</span>
 35 import java.util.LinkedList;
 36 import java.util.List;
 37 import java.util.Map;
<span class="line-added"> 38 import java.util.function.Predicate;</span>
 39 import java.util.stream.Collectors;
 40 import java.util.stream.Stream;
 41 import java.security.AccessController;
 42 import java.security.PrivilegedAction;
 43 
 44 import static java.net.NetworkInterface.getNetworkInterfaces;
 45 import static java.util.Collections.list;
 46 
 47 /**
 48  * Helper class for retrieving network interfaces and local addresses
 49  * suitable for testing.
 50  */
 51 public class NetworkConfiguration {
 52 
 53     private Map&lt;NetworkInterface,List&lt;Inet4Address&gt;&gt; ip4Interfaces;
 54     private Map&lt;NetworkInterface,List&lt;Inet6Address&gt;&gt; ip6Interfaces;
 55     private final boolean isIPv6Available;
 56     private boolean has_testableipv6address = false;
 57     private boolean has_sitelocaladdress = false;
 58     private boolean has_linklocaladdress = false;
</pre>
<hr />
<pre>
 71                 // On Solaris or AIX, a configuration with only local or loopback
 72                 // addresses does not fully enable IPv6 operations.
 73                 // E.g. IPv6 multicasting does not work.
 74                 // So, don&#39;t set has_testableipv6address if we only find these.
 75                 .filter(addr -&gt; Platform.isSolaris() || Platform.isAix() ?
 76                     !(addr.isAnyLocalAddress() || addr.isLoopbackAddress()) : true)
 77                 .forEach(ia -&gt; {
 78                     has_testableipv6address = true;
 79                     if (ia.isLinkLocalAddress()) has_linklocaladdress = true;
 80                     if (ia.isSiteLocalAddress()) has_sitelocaladdress = true;
 81 
 82                     if (!ia.isLinkLocalAddress() &amp;&amp;
 83                         !ia.isSiteLocalAddress() &amp;&amp;
 84                         !ia.isLoopbackAddress()) {
 85                         has_globaladdress = true;
 86                     }
 87                 });
 88         });
 89     }
 90 
<span class="line-modified"> 91     private static boolean isIPv6LinkLocal(InetAddress a) {</span>
<span class="line-modified"> 92         return Inet6Address.class.isInstance(a) &amp;&amp; a.isLinkLocalAddress();</span>
<span class="line-modified"> 93     }</span>
<span class="line-added"> 94 </span>
<span class="line-added"> 95     public static boolean isTestable(NetworkInterface nif) {</span>
<span class="line-added"> 96         if (Platform.isOSX()) {</span>
<span class="line-added"> 97             if (nif.getName().contains(&quot;awdl&quot;)) {</span>
<span class="line-added"> 98                 return false; // exclude awdl</span>
<span class="line-added"> 99             }</span>
<span class="line-added">100             // filter out interfaces that only have link-local IPv6 addresses</span>
<span class="line-added">101             // on macOS interfaces like &#39;en6&#39; fall in this category and</span>
<span class="line-added">102             // need to be skipped</span>
<span class="line-added">103             return nif.inetAddresses()</span>
<span class="line-added">104                     .filter(Predicate.not(NetworkConfiguration::isIPv6LinkLocal))</span>
<span class="line-added">105                     .findAny()</span>
<span class="line-added">106                     .isPresent();</span>
107         }
<span class="line-added">108 </span>
109         if (Platform.isWindows()) {
110             String dName = nif.getDisplayName();
111             if (dName != null &amp;&amp; dName.contains(&quot;Teredo&quot;)) {
112                 return false;
113             }
114         }
115         return true;
116     }
117 
118     private static boolean isNotLoopback(NetworkInterface nif) {
119         try {
120             return !nif.isLoopback();
121         } catch (IOException e) {
122             throw new UncheckedIOException(e);
123         }
124     }
125 
126     private boolean hasIp4Addresses(NetworkInterface nif) {
127         return ip4Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
128     }
129 
130     private boolean hasIp6Addresses(NetworkInterface nif) {
131         return ip6Interfaces.get(nif).stream().anyMatch(a -&gt; !a.isAnyLocalAddress());
132     }
133 
<span class="line-added">134     public static boolean hasNonLinkLocalAddress(NetworkInterface nif) {</span>
<span class="line-added">135         return nif.inetAddresses()</span>
<span class="line-added">136                 .filter(Predicate.not(InetAddress::isLinkLocalAddress))</span>
<span class="line-added">137                 .findAny().isPresent();</span>
<span class="line-added">138     }</span>
<span class="line-added">139 </span>
140     private boolean supportsIp4Multicast(NetworkInterface nif) {
141         try {
142             if (!nif.supportsMulticast()) {
143                 return false;
144             }
145 
146             // On AIX there is a bug:
147             // When IPv6 is enabled on the system, the JDK opens sockets as AF_INET6.
148             // If there&#39;s an interface configured with IPv4 addresses only, it should
149             // be able to become the network interface for a multicast socket (that
150             // could be in both, IPv4 or IPv6 space). But both possible setsockopt
151             // calls for either IPV6_MULTICAST_IF or IP_MULTICAST_IF return
152             // EADDRNOTAVAIL. So we must skip such interfaces here.
153             if (Platform.isAix() &amp;&amp; isIPv6Available() &amp;&amp; !hasIp6Addresses(nif)) {
154                 return false;
155             }
156 
<span class="line-added">157             if (Platform.isOSX()) {</span>
<span class="line-added">158                 // multicasting may not work on interfaces that only</span>
<span class="line-added">159                 // have link local addresses</span>
<span class="line-added">160                 if (!hasNonLinkLocalAddress(nif)) {</span>
<span class="line-added">161                     return false;</span>
<span class="line-added">162                 }</span>
<span class="line-added">163             }</span>
<span class="line-added">164 </span>
165             return hasIp4Addresses(nif);
166         } catch (IOException e) {
167             throw new UncheckedIOException(e);
168         }
169     }
170 
171     private boolean supportsIp6Multicast(NetworkInterface nif) {
172         try {
173             if (!nif.supportsMulticast()) {
174                 return false;
175             }
176 
<span class="line-added">177             if (Platform.isOSX()) {</span>
<span class="line-added">178                 // multicasting may not work on interfaces that only</span>
<span class="line-added">179                 // have link local addresses</span>
<span class="line-added">180                 if (!hasNonLinkLocalAddress(nif)) {</span>
<span class="line-added">181                     return false;</span>
<span class="line-added">182                 }</span>
<span class="line-added">183             }</span>
<span class="line-added">184 </span>
185             return hasIp6Addresses(nif);
186         } catch (IOException e) {
187             throw new UncheckedIOException(e);
188         }
189     }
190 
191     /**
192      * Returns whether IPv6 is available at all.
193      * This should resemble the result of native ipv6_available() in net_util.c
194      */
195     public boolean isIPv6Available() {
196         return isIPv6Available;
197     }
198 
199     /**
200      * Does any (usable) IPv6 address exist in the network configuration?
201      */
202     public boolean hasTestableIPv6Address() {
203         return has_testableipv6address;
204     }
</pre>
<hr />
<pre>
221      * Does any global IPv6 address exist?
222      */
223     public boolean has_globaladdress() {
224         return has_globaladdress;
225     }
226 
227     /**
228      * Returns a stream of interfaces suitable for functional tests.
229      */
230     public Stream&lt;NetworkInterface&gt; interfaces() {
231         return Stream.concat(ip4Interfaces(), ip6Interfaces())
232                      .distinct();
233     }
234 
235     /**
236      * Returns a stream of interfaces suitable for IPv4 functional tests.
237      */
238     public Stream&lt;NetworkInterface&gt; ip4Interfaces() {
239         return ip4Interfaces.keySet()
240                             .stream()
<span class="line-modified">241                             .filter(NetworkConfiguration::isTestable)</span>
242                             .filter(this::hasIp4Addresses);
243     }
244 
245     /**
246      * Returns a stream of interfaces suitable for IPv6 functional tests.
247      */
248     public Stream&lt;NetworkInterface&gt; ip6Interfaces() {
249         return ip6Interfaces.keySet()
250                             .stream()
<span class="line-modified">251                             .filter(NetworkConfiguration::isTestable)</span>
252                             .filter(this::hasIp6Addresses);
253     }
254 
255     /**
256      * Returns a stream of interfaces suitable for functional tests.
257      */
258     public Stream&lt;NetworkInterface&gt; multicastInterfaces(boolean includeLoopback) {
259         return Stream
260             .concat(ip4MulticastInterfaces(includeLoopback),
261                     ip6MulticastInterfaces(includeLoopback))
262             .distinct();
263     }
264 
265     /**
266      * Returns a stream of interfaces suitable for IPv4 multicast tests.
267      *
268      * The loopback interface will not be included.
269      */
270     public Stream&lt;NetworkInterface&gt; ip4MulticastInterfaces() {
271         return ip4MulticastInterfaces(false);
</pre>
<hr />
<pre>
329         return ip4Interfaces.get(nif).stream();
330     }
331 
332     /**
333      * Returns all IPv6 addresses for the given interface.
334      */
335     public Stream&lt;Inet6Address&gt; ip6Addresses(NetworkInterface nif) {
336         return ip6Interfaces.get(nif).stream();
337     }
338 
339     @Override
340     public String toString() {
341         return interfaces().map(NetworkConfiguration::interfaceInformation)
342                            .collect(Collectors.joining());
343     }
344 
345     /**
346      * Return a NetworkConfiguration instance.
347      */
348     public static NetworkConfiguration probe() throws IOException {
<span class="line-modified">349         Map&lt;NetworkInterface, List&lt;Inet4Address&gt;&gt; ip4Interfaces = new LinkedHashMap&lt;&gt;();</span>
<span class="line-modified">350         Map&lt;NetworkInterface, List&lt;Inet6Address&gt;&gt; ip6Interfaces = new LinkedHashMap&lt;&gt;();</span>
351 
352         List&lt;NetworkInterface&gt; nifs = list(getNetworkInterfaces());
353         for (NetworkInterface nif : nifs) {
354             // ignore interfaces that are down
355             if (!nif.isUp() || nif.isPointToPoint()) {
356                 continue;
357             }
358 
359             List&lt;Inet4Address&gt; ip4Addresses = new LinkedList&lt;&gt;();
360             List&lt;Inet6Address&gt; ip6Addresses = new LinkedList&lt;&gt;();
361             ip4Interfaces.put(nif, ip4Addresses);
362             ip6Interfaces.put(nif, ip6Addresses);
363             for (InetAddress addr : list(nif.getInetAddresses())) {
364                 if (addr instanceof Inet4Address) {
365                     ip4Addresses.add((Inet4Address) addr);
366                 } else if (addr instanceof Inet6Address) {
367                     ip6Addresses.add((Inet6Address) addr);
368                 }
369             }
370         }
</pre>
</td>
</tr>
</table>
<center><a href="LockFreeLogger.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="Platform.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
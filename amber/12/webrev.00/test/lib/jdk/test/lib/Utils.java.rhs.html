<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames test/lib/jdk/test/lib/Utils.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
    <script type="text/javascript" src="../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2013, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.lang.annotation.Annotation;
<a name="1" id="anc1"></a><span class="line-added"> 29 import java.net.Inet6Address;</span>
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.MalformedURLException;
 33 import java.net.ServerSocket;
 34 import java.net.URL;
 35 import java.net.URLClassLoader;
 36 import java.net.UnknownHostException;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.nio.file.Paths;
 40 import java.nio.file.attribute.FileAttribute;
 41 import java.nio.channels.SocketChannel;
 42 import java.util.ArrayList;
 43 import java.util.Arrays;
 44 import java.util.Collection;
 45 import java.util.Collections;
 46 import java.util.Iterator;
 47 import java.util.Map;
 48 import java.util.HashMap;
<a name="2" id="anc2"></a><span class="line-added"> 49 import java.util.LinkedList;</span>
 50 import java.util.List;
 51 import java.util.Objects;
 52 import java.util.Random;
 53 import java.util.function.BooleanSupplier;
 54 import java.util.concurrent.TimeUnit;
 55 import java.util.function.Consumer;
 56 import java.util.function.Function;
 57 import java.util.regex.Matcher;
 58 import java.util.regex.Pattern;
 59 
 60 import static jdk.test.lib.Asserts.assertTrue;
 61 import jdk.test.lib.process.ProcessTools;
 62 import jdk.test.lib.process.OutputAnalyzer;
 63 
 64 /**
 65  * Common library for various test helper functions.
 66  */
 67 public final class Utils {
 68 
 69     /**
 70      * Returns the value of &#39;test.class.path&#39; system property.
 71      */
 72     public static final String TEST_CLASS_PATH = System.getProperty(&quot;test.class.path&quot;, &quot;.&quot;);
 73 
 74     /**
 75      * Returns the sequence used by operating system to separate lines.
 76      */
 77     public static final String NEW_LINE = System.getProperty(&quot;line.separator&quot;);
 78 
 79     /**
 80      * Returns the value of &#39;test.vm.opts&#39; system property.
 81      */
 82     public static final String VM_OPTIONS = System.getProperty(&quot;test.vm.opts&quot;, &quot;&quot;).trim();
 83 
 84     /**
 85      * Returns the value of &#39;test.java.opts&#39; system property.
 86      */
 87     public static final String JAVA_OPTIONS = System.getProperty(&quot;test.java.opts&quot;, &quot;&quot;).trim();
 88 
 89     /**
 90      * Returns the value of &#39;test.src&#39; system property.
 91      */
 92     public static final String TEST_SRC = System.getProperty(&quot;test.src&quot;, &quot;&quot;).trim();
 93 
 94     /**
 95      * Returns the value of &#39;test.root&#39; system property.
 96      */
 97     public static final String TEST_ROOT = System.getProperty(&quot;test.root&quot;, &quot;&quot;).trim();
 98 
 99     /*
100      * Returns the value of &#39;test.jdk&#39; system property
101      */
102     public static final String TEST_JDK = System.getProperty(&quot;test.jdk&quot;);
103 
104     /*
105      * Returns the value of &#39;compile.jdk&#39; system property
106      */
107     public static final String COMPILE_JDK = System.getProperty(&quot;compile.jdk&quot;, TEST_JDK);
108 
109     /**
110      * Returns the value of &#39;test.classes&#39; system property
111      */
112     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
113 
114     /**
115      * Defines property name for seed value.
116      */
117     public static final String SEED_PROPERTY_NAME = &quot;jdk.test.lib.random.seed&quot;;
118 
119     /* (non-javadoc)
120      * Random generator with (or without) predefined seed. Depends on
121      * &quot;jdk.test.lib.random.seed&quot; property value.
122      */
123     private static volatile Random RANDOM_GENERATOR;
124 
<a name="3" id="anc3"></a><span class="line-added">125     /**</span>
<span class="line-added">126      * Maximum number of attempts to get free socket</span>
<span class="line-added">127      */</span>
<span class="line-added">128     private static final int MAX_SOCKET_TRIES = 10;</span>
<span class="line-added">129 </span>
130     /**
131      * Contains the seed value used for {@link java.util.Random} creation.
132      */
133     public static final long SEED = Long.getLong(SEED_PROPERTY_NAME, new Random().nextLong());
134     /**
135      * Returns the value of &#39;test.timeout.factor&#39; system property
136      * converted to {@code double}.
137      */
138     public static final double TIMEOUT_FACTOR;
139     static {
140         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
141         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
142     }
143 
144     /**
145      * Returns the value of JTREG default test timeout in milliseconds
146      * converted to {@code long}.
147      */
148     public static final long DEFAULT_TEST_TIMEOUT = TimeUnit.SECONDS.toMillis(120);
149 
150     private Utils() {
151         // Private constructor to prevent class instantiation
152     }
153 
154     /**
155      * Returns the list of VM options with -J prefix.
156      *
157      * @return The list of VM options with -J prefix
158      */
159     public static List&lt;String&gt; getForwardVmOptions() {
160         String[] opts = safeSplitString(VM_OPTIONS);
161         for (int i = 0; i &lt; opts.length; i++) {
162             opts[i] = &quot;-J&quot; + opts[i];
163         }
164         return Arrays.asList(opts);
165     }
166 
167     /**
168      * Returns the default JTReg arguments for a jvm running a test.
169      * This is the combination of JTReg arguments test.vm.opts and test.java.opts.
170      * @return An array of options, or an empty array if no options.
171      */
172     public static String[] getTestJavaOpts() {
173         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
174         Collections.addAll(opts, safeSplitString(VM_OPTIONS));
175         Collections.addAll(opts, safeSplitString(JAVA_OPTIONS));
176         return opts.toArray(new String[0]);
177     }
178 
179     /**
180      * Combines given arguments with default JTReg arguments for a jvm running a test.
181      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
182      * @return The combination of JTReg test java options and user args.
183      */
184     public static String[] prependTestJavaOpts(String... userArgs) {
185         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
186         Collections.addAll(opts, getTestJavaOpts());
187         Collections.addAll(opts, userArgs);
188         return opts.toArray(new String[0]);
189     }
190 
191     /**
192      * Combines given arguments with default JTReg arguments for a jvm running a test.
193      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
194      * @return The combination of JTReg test java options and user args.
195      */
196     public static String[] appendTestJavaOpts(String... userArgs) {
197         List&lt;String&gt; opts = new ArrayList&lt;String&gt;();
198         Collections.addAll(opts, userArgs);
199         Collections.addAll(opts, getTestJavaOpts());
200         return opts.toArray(new String[0]);
201     }
202 
203     /**
204      * Combines given arguments with default JTReg arguments for a jvm running a test.
205      * This is the combination of JTReg arguments test.vm.opts and test.java.opts
206      * @return The combination of JTReg test java options and user args.
207      */
208     public static String[] addTestJavaOpts(String... userArgs) {
209         return prependTestJavaOpts(userArgs);
210     }
211 
212     /**
213      * Removes any options specifying which GC to use, for example &quot;-XX:+UseG1GC&quot;.
214      * Removes any options matching: -XX:(+/-)Use*GC
215      * Used when a test need to set its own GC version. Then any
216      * GC specified by the framework must first be removed.
217      * @return A copy of given opts with all GC options removed.
218      */
219     private static final Pattern useGcPattern = Pattern.compile(
220             &quot;(?:\\-XX\\:[\\+\\-]Use.+GC)&quot;);
221     public static List&lt;String&gt; removeGcOpts(List&lt;String&gt; opts) {
222         List&lt;String&gt; optsWithoutGC = new ArrayList&lt;String&gt;();
223         for (String opt : opts) {
224             if (useGcPattern.matcher(opt).matches()) {
225                 System.out.println(&quot;removeGcOpts: removed &quot; + opt);
226             } else {
227                 optsWithoutGC.add(opt);
228             }
229         }
230         return optsWithoutGC;
231     }
232 
233     /**
234      * Returns the default JTReg arguments for a jvm running a test without
235      * options that matches regular expressions in {@code filters}.
236      * This is the combination of JTReg arguments test.vm.opts and test.java.opts.
237      * @param filters Regular expressions used to filter out options.
238      * @return An array of options, or an empty array if no options.
239      */
240     public static String[] getFilteredTestJavaOpts(String... filters) {
241         String options[] = getTestJavaOpts();
242 
243         if (filters.length == 0) {
244             return options;
245         }
246 
247         List&lt;String&gt; filteredOptions = new ArrayList&lt;String&gt;(options.length);
248         Pattern patterns[] = new Pattern[filters.length];
249         for (int i = 0; i &lt; filters.length; i++) {
250             patterns[i] = Pattern.compile(filters[i]);
251         }
252 
253         for (String option : options) {
254             boolean matched = false;
255             for (int i = 0; i &lt; patterns.length &amp;&amp; !matched; i++) {
256                 Matcher matcher = patterns[i].matcher(option);
257                 matched = matcher.find();
258             }
259             if (!matched) {
260                 filteredOptions.add(option);
261             }
262         }
263 
264         return filteredOptions.toArray(new String[filteredOptions.size()]);
265     }
266 
267     /**
268      * Splits a string by white space.
269      * Works like String.split(), but returns an empty array
270      * if the string is null or empty.
271      */
272     private static String[] safeSplitString(String s) {
273         if (s == null || s.trim().isEmpty()) {
274             return new String[] {};
275         }
276         return s.trim().split(&quot;\\s+&quot;);
277     }
278 
279     /**
280      * @return The full command line for the ProcessBuilder.
281      */
282     public static String getCommandLine(ProcessBuilder pb) {
283         StringBuilder cmd = new StringBuilder();
284         for (String s : pb.command()) {
285             cmd.append(s).append(&quot; &quot;);
286         }
287         return cmd.toString();
288     }
289 
290     /**
291      * Returns the socket address of an endpoint that refuses connections. The
292      * endpoint is an InetSocketAddress where the address is the loopback address
293      * and the port is a system port (1-1023 range).
294      * This method is a better choice than getFreePort for tests that need
295      * an endpoint that refuses connections.
296      */
297     public static InetSocketAddress refusingEndpoint() {
298         InetAddress lb = InetAddress.getLoopbackAddress();
299         int port = 1;
300         while (port &lt; 1024) {
301             InetSocketAddress sa = new InetSocketAddress(lb, port);
302             try {
303                 SocketChannel.open(sa).close();
304             } catch (IOException ioe) {
305                 return sa;
306             }
307             port++;
308         }
309         throw new RuntimeException(&quot;Unable to find system port that is refusing connections&quot;);
310     }
311 
<a name="4" id="anc4"></a><span class="line-added">312     /**</span>
<span class="line-added">313      * Returns local addresses with symbolic and numeric scopes</span>
<span class="line-added">314      */</span>
<span class="line-added">315     public static List&lt;InetAddress&gt; getAddressesWithSymbolicAndNumericScopes() {</span>
<span class="line-added">316         List&lt;InetAddress&gt; result = new LinkedList&lt;&gt;();</span>
<span class="line-added">317         try {</span>
<span class="line-added">318             NetworkConfiguration conf = NetworkConfiguration.probe();</span>
<span class="line-added">319             conf.ip4Addresses().forEach(result::add);</span>
<span class="line-added">320             // Java reports link local addresses with symbolic scope,</span>
<span class="line-added">321             // but on Windows java.net.NetworkInterface generates its own scope names</span>
<span class="line-added">322             // which are incompatible with native Windows routines.</span>
<span class="line-added">323             // So on Windows test only addresses with numeric scope.</span>
<span class="line-added">324             // On other platforms test both symbolic and numeric scopes.</span>
<span class="line-added">325             conf.ip6Addresses().forEach(addr6 -&gt; {</span>
<span class="line-added">326                 try {</span>
<span class="line-added">327                     result.add(Inet6Address.getByAddress(null, addr6.getAddress(), addr6.getScopeId()));</span>
<span class="line-added">328                 } catch (UnknownHostException e) {</span>
<span class="line-added">329                     // cannot happen!</span>
<span class="line-added">330                     throw new RuntimeException(&quot;Unexpected&quot;, e);</span>
<span class="line-added">331                 }</span>
<span class="line-added">332                 if (!Platform.isWindows()) {</span>
<span class="line-added">333                     result.add(addr6);</span>
<span class="line-added">334                 }</span>
<span class="line-added">335             });</span>
<span class="line-added">336         } catch (IOException e) {</span>
<span class="line-added">337             // cannot happen!</span>
<span class="line-added">338             throw new RuntimeException(&quot;Unexpected&quot;, e);</span>
<span class="line-added">339         }</span>
<span class="line-added">340         return result;</span>
<span class="line-added">341     }</span>
<span class="line-added">342 </span>
343     /**
344      * Returns the free port on the local host.
345      *
346      * @return The port number
347      * @throws IOException if an I/O error occurs when opening the socket
348      */
349     public static int getFreePort() throws IOException {
350         try (ServerSocket serverSocket =
351                 new ServerSocket(0, 5, InetAddress.getLoopbackAddress());) {
352             return serverSocket.getLocalPort();
353         }
354     }
355 
<a name="5" id="anc5"></a><span class="line-added">356     /**</span>
<span class="line-added">357      * Returns the free unreserved port on the local host.</span>
<span class="line-added">358      *</span>
<span class="line-added">359      * @param reservedPorts reserved ports</span>
<span class="line-added">360      * @return The port number or -1 if failed to find a free port</span>
<span class="line-added">361      */</span>
<span class="line-added">362     public static int findUnreservedFreePort(int... reservedPorts) {</span>
<span class="line-added">363         int numTries = 0;</span>
<span class="line-added">364         while (numTries++ &lt; MAX_SOCKET_TRIES) {</span>
<span class="line-added">365             int port = -1;</span>
<span class="line-added">366             try {</span>
<span class="line-added">367                 port = getFreePort();</span>
<span class="line-added">368             } catch (IOException e) {</span>
<span class="line-added">369                 e.printStackTrace();</span>
<span class="line-added">370             }</span>
<span class="line-added">371             if (port &gt; 0 &amp;&amp; !isReserved(port, reservedPorts)) {</span>
<span class="line-added">372                 return port;</span>
<span class="line-added">373             }</span>
<span class="line-added">374         }</span>
<span class="line-added">375         return -1;</span>
<span class="line-added">376     }</span>
<span class="line-added">377 </span>
<span class="line-added">378     private static boolean isReserved(int port, int[] reservedPorts) {</span>
<span class="line-added">379         for (int p : reservedPorts) {</span>
<span class="line-added">380             if (p == port) {</span>
<span class="line-added">381                 return true;</span>
<span class="line-added">382             }</span>
<span class="line-added">383         }</span>
<span class="line-added">384         return false;</span>
<span class="line-added">385     }</span>
<span class="line-added">386 </span>
387     /**
388      * Returns the name of the local host.
389      *
390      * @return The host name
391      * @throws UnknownHostException if IP address of a host could not be determined
392      */
393     public static String getHostname() throws UnknownHostException {
394         InetAddress inetAddress = InetAddress.getLocalHost();
395         String hostName = inetAddress.getHostName();
396 
397         assertTrue((hostName != null &amp;&amp; !hostName.isEmpty()),
398                 &quot;Cannot get hostname&quot;);
399 
400         return hostName;
401     }
402 
403     /**
404      * Uses &quot;jcmd -l&quot; to search for a jvm pid. This function will wait
405      * forever (until jtreg timeout) for the pid to be found.
406      * @param key Regular expression to search for
407      * @return The found pid.
408      */
409     public static int waitForJvmPid(String key) throws Throwable {
410         final long iterationSleepMillis = 250;
411         System.out.println(&quot;waitForJvmPid: Waiting for key &#39;&quot; + key + &quot;&#39;&quot;);
412         System.out.flush();
413         while (true) {
414             int pid = tryFindJvmPid(key);
415             if (pid &gt;= 0) {
416                 return pid;
417             }
418             Thread.sleep(iterationSleepMillis);
419         }
420     }
421 
422     /**
423      * Searches for a jvm pid in the output from &quot;jcmd -l&quot;.
424      *
425      * Example output from jcmd is:
426      * 12498 sun.tools.jcmd.JCmd -l
427      * 12254 /tmp/jdk8/tl/jdk/JTwork/classes/com/sun/tools/attach/Application.jar
428      *
429      * @param key A regular expression to search for.
430      * @return The found pid, or -1 if not found.
431      * @throws Exception If multiple matching jvms are found.
432      */
433     public static int tryFindJvmPid(String key) throws Throwable {
434         OutputAnalyzer output = null;
435         try {
436             JDKToolLauncher jcmdLauncher = JDKToolLauncher.create(&quot;jcmd&quot;);
437             jcmdLauncher.addToolArg(&quot;-l&quot;);
438             output = ProcessTools.executeProcess(jcmdLauncher.getCommand());
439             output.shouldHaveExitValue(0);
440 
441             // Search for a line starting with numbers (pid), follwed by the key.
442             Pattern pattern = Pattern.compile(&quot;([0-9]+)\\s.*(&quot; + key + &quot;).*\\r?\\n&quot;);
443             Matcher matcher = pattern.matcher(output.getStdout());
444 
445             int pid = -1;
446             if (matcher.find()) {
447                 pid = Integer.parseInt(matcher.group(1));
448                 System.out.println(&quot;findJvmPid.pid: &quot; + pid);
449                 if (matcher.find()) {
450                     throw new Exception(&quot;Found multiple JVM pids for key: &quot; + key);
451                 }
452             }
453             return pid;
454         } catch (Throwable t) {
455             System.out.println(String.format(&quot;Utils.findJvmPid(%s) failed: %s&quot;, key, t));
456             throw t;
457         }
458     }
459 
460     /**
461      * Adjusts the provided timeout value for the TIMEOUT_FACTOR
462      * @param tOut the timeout value to be adjusted
463      * @return The timeout value adjusted for the value of &quot;test.timeout.factor&quot;
464      *         system property
465      */
466     public static long adjustTimeout(long tOut) {
467         return Math.round(tOut * Utils.TIMEOUT_FACTOR);
468     }
469 
470     /**
471      * Return the contents of the named file as a single String,
472      * or null if not found.
473      * @param filename name of the file to read
474      * @return String contents of file, or null if file not found.
475      * @throws  IOException
476      *          if an I/O error occurs reading from the file or a malformed or
477      *          unmappable byte sequence is read
478      */
479     public static String fileAsString(String filename) throws IOException {
480         Path filePath = Paths.get(filename);
481         if (!Files.exists(filePath)) return null;
482         return new String(Files.readAllBytes(filePath));
483     }
484 
485     private static final char[] hexArray = new char[]{&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;, &#39;E&#39;, &#39;F&#39;};
486 
487     /**
488      * Returns hex view of byte array
489      *
490      * @param bytes byte array to process
491      * @return space separated hexadecimal string representation of bytes
492      */
493      public static String toHexString(byte[] bytes) {
494          char[] hexView = new char[bytes.length * 3 - 1];
495          for (int i = 0; i &lt; bytes.length - 1; i++) {
496              hexView[i * 3] = hexArray[(bytes[i] &gt;&gt; 4) &amp; 0x0F];
497              hexView[i * 3 + 1] = hexArray[bytes[i] &amp; 0x0F];
498              hexView[i * 3 + 2] = &#39; &#39;;
499          }
500          hexView[hexView.length - 2] = hexArray[(bytes[bytes.length - 1] &gt;&gt; 4) &amp; 0x0F];
501          hexView[hexView.length - 1] = hexArray[bytes[bytes.length - 1] &amp; 0x0F];
502          return new String(hexView);
503      }
504 
505      /**
506       * Returns byte array of hex view
507       *
508       * @param hex hexadecimal string representation
509       * @return byte array
510       */
511      public static byte[] toByteArray(String hex) {
512          int length = hex.length();
513          byte[] bytes = new byte[length / 2];
514          for (int i = 0; i &lt; length; i += 2) {
515              bytes[i / 2] = (byte) ((Character.digit(hex.charAt(i), 16) &lt;&lt; 4)
516                      + Character.digit(hex.charAt(i + 1), 16));
517          }
518          return bytes;
519      }
520 
521     /**
522      * Returns {@link java.util.Random} generator initialized with particular seed.
523      * The seed could be provided via system property {@link Utils#SEED_PROPERTY_NAME}
524      * In case no seed is provided, the method uses a random number.
525      * The used seed printed to stdout.
526      * @return {@link java.util.Random} generator with particular seed.
527      */
528     public static Random getRandomInstance() {
529         if (RANDOM_GENERATOR == null) {
530             synchronized (Utils.class) {
531                 if (RANDOM_GENERATOR == null) {
532                     RANDOM_GENERATOR = new Random(SEED);
533                     System.out.printf(&quot;For random generator using seed: %d%n&quot;, SEED);
534                     System.out.printf(&quot;To re-run test with same seed value please add \&quot;-D%s=%d\&quot; to command line.%n&quot;, SEED_PROPERTY_NAME, SEED);
535                 }
536             }
537         }
538         return RANDOM_GENERATOR;
539     }
540 
541     /**
542      * Returns random element of non empty collection
543      *
544      * @param &lt;T&gt; a type of collection element
545      * @param collection collection of elements
546      * @return random element of collection
547      * @throws IllegalArgumentException if collection is empty
548      */
549     public static &lt;T&gt; T getRandomElement(Collection&lt;T&gt; collection)
550             throws IllegalArgumentException {
551         if (collection.isEmpty()) {
552             throw new IllegalArgumentException(&quot;Empty collection&quot;);
553         }
554         Random random = getRandomInstance();
555         int elementIndex = 1 + random.nextInt(collection.size() - 1);
556         Iterator&lt;T&gt; iterator = collection.iterator();
557         while (--elementIndex != 0) {
558             iterator.next();
559         }
560         return iterator.next();
561     }
562 
563     /**
564      * Returns random element of non empty array
565      *
566      * @param &lt;T&gt; a type of array element
567      * @param array array of elements
568      * @return random element of array
569      * @throws IllegalArgumentException if array is empty
570      */
571     public static &lt;T&gt; T getRandomElement(T[] array)
572             throws IllegalArgumentException {
573         if (array == null || array.length == 0) {
574             throw new IllegalArgumentException(&quot;Empty or null array&quot;);
575         }
576         Random random = getRandomInstance();
577         return array[random.nextInt(array.length)];
578     }
579 
580     /**
581      * Wait for condition to be true
582      *
583      * @param condition, a condition to wait for
584      */
585     public static final void waitForCondition(BooleanSupplier condition) {
586         waitForCondition(condition, -1L, 100L);
587     }
588 
589     /**
590      * Wait until timeout for condition to be true
591      *
592      * @param condition, a condition to wait for
593      * @param timeout a time in milliseconds to wait for condition to be true
594      * specifying -1 will wait forever
595      * @return condition value, to determine if wait was successful
596      */
597     public static final boolean waitForCondition(BooleanSupplier condition,
598             long timeout) {
599         return waitForCondition(condition, timeout, 100L);
600     }
601 
602     /**
603      * Wait until timeout for condition to be true for specified time
604      *
605      * @param condition, a condition to wait for
606      * @param timeout a time in milliseconds to wait for condition to be true,
607      * specifying -1 will wait forever
608      * @param sleepTime a time to sleep value in milliseconds
609      * @return condition value, to determine if wait was successful
610      */
611     public static final boolean waitForCondition(BooleanSupplier condition,
612             long timeout, long sleepTime) {
613         long startTime = System.currentTimeMillis();
614         while (!(condition.getAsBoolean() || (timeout != -1L
615                 &amp;&amp; ((System.currentTimeMillis() - startTime) &gt; timeout)))) {
616             try {
617                 Thread.sleep(sleepTime);
618             } catch (InterruptedException e) {
619                 Thread.currentThread().interrupt();
620                 throw new Error(e);
621             }
622         }
623         return condition.getAsBoolean();
624     }
625 
626     /**
627      * Interface same as java.lang.Runnable but with
628      * method {@code run()} able to throw any Throwable.
629      */
630     public static interface ThrowingRunnable {
631         void run() throws Throwable;
632     }
633 
634     /**
635      * Filters out an exception that may be thrown by the given
636      * test according to the given filter.
637      *
638      * @param test - method that is invoked and checked for exception.
639      * @param filter - function that checks if the thrown exception matches
640      *                 criteria given in the filter&#39;s implementation.
641      * @return - exception that matches the filter if it has been thrown or
642      *           {@code null} otherwise.
643      * @throws Throwable - if test has thrown an exception that does not
644      *                     match the filter.
645      */
646     public static Throwable filterException(ThrowingRunnable test,
647             Function&lt;Throwable, Boolean&gt; filter) throws Throwable {
648         try {
649             test.run();
650         } catch (Throwable t) {
651             if (filter.apply(t)) {
652                 return t;
653             } else {
654                 throw t;
655             }
656         }
657         return null;
658     }
659 
660     /**
661      * Ensures a requested class is loaded
662      * @param aClass class to load
663      */
664     public static void ensureClassIsLoaded(Class&lt;?&gt; aClass) {
665         if (aClass == null) {
666             throw new Error(&quot;Requested null class&quot;);
667         }
668         try {
669             Class.forName(aClass.getName(), /* initialize = */ true,
670                     ClassLoader.getSystemClassLoader());
671         } catch (ClassNotFoundException e) {
672             throw new Error(&quot;Class not found&quot;, e);
673         }
674     }
675     /**
676      * @param parent a class loader to be the parent for the returned one
677      * @return an UrlClassLoader with urls made of the &#39;test.class.path&#39; jtreg
678      *         property and with the given parent
679      */
680     public static URLClassLoader getTestClassPathURLClassLoader(ClassLoader parent) {
681         URL[] urls = Arrays.stream(TEST_CLASS_PATH.split(File.pathSeparator))
682                 .map(Paths::get)
683                 .map(Path::toUri)
684                 .map(x -&gt; {
685                     try {
686                         return x.toURL();
687                     } catch (MalformedURLException ex) {
688                         throw new Error(&quot;Test issue. JTREG property&quot;
689                                 + &quot; &#39;test.class.path&#39;&quot;
690                                 + &quot; is not defined correctly&quot;, ex);
691                     }
692                 }).toArray(URL[]::new);
693         return new URLClassLoader(urls, parent);
694     }
695 
696     /**
697      * Runs runnable and checks that it throws expected exception. If exceptionException is null it means
698      * that we expect no exception to be thrown.
699      * @param runnable what we run
700      * @param expectedException expected exception
701      */
702     public static void runAndCheckException(ThrowingRunnable runnable, Class&lt;? extends Throwable&gt; expectedException) {
703         runAndCheckException(runnable, t -&gt; {
704             if (t == null) {
705                 if (expectedException != null) {
706                     throw new AssertionError(&quot;Didn&#39;t get expected exception &quot; + expectedException.getSimpleName());
707                 }
708             } else {
709                 String message = &quot;Got unexpected exception &quot; + t.getClass().getSimpleName();
710                 if (expectedException == null) {
711                     throw new AssertionError(message, t);
712                 } else if (!expectedException.isAssignableFrom(t.getClass())) {
713                     message += &quot; instead of &quot; + expectedException.getSimpleName();
714                     throw new AssertionError(message, t);
715                 }
716             }
717         });
718     }
719 
720     /**
721      * Runs runnable and makes some checks to ensure that it throws expected exception.
722      * @param runnable what we run
723      * @param checkException a consumer which checks that we got expected exception and raises a new exception otherwise
724      */
725     public static void runAndCheckException(ThrowingRunnable runnable, Consumer&lt;Throwable&gt; checkException) {
726         Throwable throwable = null;
727         try {
728             runnable.run();
729         } catch (Throwable t) {
730             throwable = t;
731         }
732         checkException.accept(throwable);
733     }
734 
735     /**
736      * Converts to VM type signature
737      *
738      * @param type Java type to convert
739      * @return string representation of VM type
740      */
741     public static String toJVMTypeSignature(Class&lt;?&gt; type) {
742         if (type.isPrimitive()) {
743             if (type == boolean.class) {
744                 return &quot;Z&quot;;
745             } else if (type == byte.class) {
746                 return &quot;B&quot;;
747             } else if (type == char.class) {
748                 return &quot;C&quot;;
749             } else if (type == double.class) {
750                 return &quot;D&quot;;
751             } else if (type == float.class) {
752                 return &quot;F&quot;;
753             } else if (type == int.class) {
754                 return &quot;I&quot;;
755             } else if (type == long.class) {
756                 return &quot;J&quot;;
757             } else if (type == short.class) {
758                 return &quot;S&quot;;
759             } else if (type == void.class) {
760                 return &quot;V&quot;;
761             } else {
762                 throw new Error(&quot;Unsupported type: &quot; + type);
763             }
764         }
765         String result = type.getName().replaceAll(&quot;\\.&quot;, &quot;/&quot;);
766         if (!type.isArray()) {
767             return &quot;L&quot; + result + &quot;;&quot;;
768         }
769         return result;
770     }
771 
772     public static Object[] getNullValues(Class&lt;?&gt;... types) {
773         Object[] result = new Object[types.length];
774         int i = 0;
775         for (Class&lt;?&gt; type : types) {
776             result[i++] = NULL_VALUES.get(type);
777         }
778         return result;
779     }
780     private static Map&lt;Class&lt;?&gt;, Object&gt; NULL_VALUES = new HashMap&lt;&gt;();
781     static {
782         NULL_VALUES.put(boolean.class, false);
783         NULL_VALUES.put(byte.class, (byte) 0);
784         NULL_VALUES.put(short.class, (short) 0);
785         NULL_VALUES.put(char.class, &#39;\0&#39;);
786         NULL_VALUES.put(int.class, 0);
787         NULL_VALUES.put(long.class, 0L);
788         NULL_VALUES.put(float.class, 0.0f);
789         NULL_VALUES.put(double.class, 0.0d);
790     }
791 
792     /**
793      * Returns mandatory property value
794      * @param propName is a name of property to request
795      * @return a String with requested property value
796      */
797     public static String getMandatoryProperty(String propName) {
798         Objects.requireNonNull(propName, &quot;Requested null property&quot;);
799         String prop = System.getProperty(propName);
800         Objects.requireNonNull(prop,
801                 String.format(&quot;A mandatory property &#39;%s&#39; isn&#39;t set&quot;, propName));
802         return prop;
803     }
804 
805     /*
806      * Run uname with specified arguments.
807      */
808     public static OutputAnalyzer uname(String... args) throws Throwable {
809         String[] cmds = new String[args.length + 1];
810         cmds[0] = &quot;uname&quot;;
811         System.arraycopy(args, 0, cmds, 1, args.length);
812         return ProcessTools.executeCommand(cmds);
813     }
814 
815     /*
816      * Returns the system distro.
817      */
818     public static String distro() {
819         try {
820             return uname(&quot;-v&quot;).asLines().get(0);
821         } catch (Throwable t) {
822             throw new RuntimeException(&quot;Failed to determine distro.&quot;, t);
823         }
824     }
825 
826     // This method is intended to be called from a jtreg test.
827     // It will identify the name of the test by means of stack walking.
828     // It can handle both jtreg tests and a testng tests wrapped inside jtreg tests.
829     // For jtreg tests the name of the test will be searched by stack-walking
830     // until the method main() is found; the class containing that method is the
831     // main test class and will be returned as the name of the test.
832     // Special handling is used for testng tests.
833     @SuppressWarnings(&quot;unchecked&quot;)
834     public static String getTestName() {
835         String result = null;
836         // If we are using testng, then we should be able to load the &quot;Test&quot; annotation.
837         Class&lt;? extends Annotation&gt; testClassAnnotation;
838 
839         try {
840             testClassAnnotation = (Class&lt;? extends Annotation&gt;)Class.forName(&quot;org.testng.annotations.Test&quot;);
841         } catch (ClassNotFoundException e) {
842             testClassAnnotation = null;
843         }
844 
845         StackTraceElement[] elms = (new Throwable()).getStackTrace();
846         for (StackTraceElement n: elms) {
847             String className = n.getClassName();
848 
849             // If this is a &quot;main&quot; method, then use its class name, but only
850             // if we are not using testng.
851             if (testClassAnnotation == null &amp;&amp; &quot;main&quot;.equals(n.getMethodName())) {
852                 result = className;
853                 break;
854             }
855 
856             // If this is a testng test, the test will have no &quot;main&quot; method. We can
857             // detect a testng test class by looking for the org.testng.annotations.Test
858             // annotation. If present, then use the name of this class.
859             if (testClassAnnotation != null) {
860                 try {
861                     Class&lt;?&gt; c = Class.forName(className);
862                     if (c.isAnnotationPresent(testClassAnnotation)) {
863                         result = className;
864                         break;
865                     }
866                 } catch (ClassNotFoundException e) {
867                     throw new RuntimeException(&quot;Unexpected exception: &quot; + e, e);
868                 }
869             }
870         }
871 
872         if (result == null) {
873             throw new RuntimeException(&quot;Couldn&#39;t find main test class in stack trace&quot;);
874         }
875 
876         return result;
877     }
878 
879     /**
880      * Creates an empty file in &quot;user.dir&quot; if the property set.
881      * &lt;p&gt;
882      * This method is meant as a replacement for {@code Files#createTempFile(String, String, FileAttribute...)}
883      * that doesn&#39;t leave files behind in /tmp directory of the test machine
884      * &lt;p&gt;
885      * If the property &quot;user.dir&quot; is not set, &quot;.&quot; will be used.
886      *
887      * @param prefix
888      * @param suffix
889      * @param attrs
890      * @return the path to the newly created file that did not exist before this
891      *         method was invoked
892      * @throws IOException
893      *
894      * @see {@link Files#createTempFile(String, String, FileAttribute...)}
895      */
896     public static Path createTempFile(String prefix, String suffix, FileAttribute&lt;?&gt;... attrs) throws IOException {
897         Path dir = Paths.get(System.getProperty(&quot;user.dir&quot;, &quot;.&quot;));
898         return Files.createTempFile(dir, prefix, suffix);
899     }
900 
901     /**
902      * Creates an empty directory in &quot;user.dir&quot; or &quot;.&quot;
903      * &lt;p&gt;
904      * This method is meant as a replacement for {@code Files#createTempDirectory(String, String, FileAttribute...)}
905      * that doesn&#39;t leave files behind in /tmp directory of the test machine
906      * &lt;p&gt;
907      * If the property &quot;user.dir&quot; is not set, &quot;.&quot; will be used.
908      *
909      * @param prefix
910      * @param attrs
911      * @return the path to the newly created directory
912      * @throws IOException
913      *
914      * @see {@link Files#createTempDirectory(String, String, FileAttribute...)}
915      */
916     public static Path createTempDirectory(String prefix, FileAttribute&lt;?&gt;... attrs) throws IOException {
917         Path dir = Paths.get(System.getProperty(&quot;user.dir&quot;, &quot;.&quot;));
918         return Files.createTempDirectory(dir, prefix);
919     }
920 }
<a name="6" id="anc6"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="6" type="hidden" />
</body>
</html>
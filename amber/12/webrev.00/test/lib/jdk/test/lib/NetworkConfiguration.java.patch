diff a/test/lib/jdk/test/lib/NetworkConfiguration.java b/test/lib/jdk/test/lib/NetworkConfiguration.java
--- a/test/lib/jdk/test/lib/NetworkConfiguration.java
+++ b/test/lib/jdk/test/lib/NetworkConfiguration.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.
@@ -29,14 +29,15 @@
 import java.net.Inet4Address;
 import java.net.Inet6Address;
 import java.net.InetAddress;
 import java.net.NetworkInterface;
 import java.util.Arrays;
-import java.util.HashMap;
+import java.util.LinkedHashMap;
 import java.util.LinkedList;
 import java.util.List;
 import java.util.Map;
+import java.util.function.Predicate;
 import java.util.stream.Collectors;
 import java.util.stream.Stream;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
@@ -85,14 +86,28 @@
                     }
                 });
         });
     }
 
-    private static boolean isNotExcludedInterface(NetworkInterface nif) {
-        if (Platform.isOSX() && nif.getName().contains("awdl")) {
-            return false;
+    private static boolean isIPv6LinkLocal(InetAddress a) {
+        return Inet6Address.class.isInstance(a) && a.isLinkLocalAddress();
+    }
+
+    public static boolean isTestable(NetworkInterface nif) {
+        if (Platform.isOSX()) {
+            if (nif.getName().contains("awdl")) {
+                return false; // exclude awdl
+            }
+            // filter out interfaces that only have link-local IPv6 addresses
+            // on macOS interfaces like 'en6' fall in this category and
+            // need to be skipped
+            return nif.inetAddresses()
+                    .filter(Predicate.not(NetworkConfiguration::isIPv6LinkLocal))
+                    .findAny()
+                    .isPresent();
         }
+
         if (Platform.isWindows()) {
             String dName = nif.getDisplayName();
             if (dName != null && dName.contains("Teredo")) {
                 return false;
             }
@@ -114,10 +129,16 @@
 
     private boolean hasIp6Addresses(NetworkInterface nif) {
         return ip6Interfaces.get(nif).stream().anyMatch(a -> !a.isAnyLocalAddress());
     }
 
+    public static boolean hasNonLinkLocalAddress(NetworkInterface nif) {
+        return nif.inetAddresses()
+                .filter(Predicate.not(InetAddress::isLinkLocalAddress))
+                .findAny().isPresent();
+    }
+
     private boolean supportsIp4Multicast(NetworkInterface nif) {
         try {
             if (!nif.supportsMulticast()) {
                 return false;
             }
@@ -131,10 +152,18 @@
             // EADDRNOTAVAIL. So we must skip such interfaces here.
             if (Platform.isAix() && isIPv6Available() && !hasIp6Addresses(nif)) {
                 return false;
             }
 
+            if (Platform.isOSX()) {
+                // multicasting may not work on interfaces that only
+                // have link local addresses
+                if (!hasNonLinkLocalAddress(nif)) {
+                    return false;
+                }
+            }
+
             return hasIp4Addresses(nif);
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
@@ -143,10 +172,18 @@
         try {
             if (!nif.supportsMulticast()) {
                 return false;
             }
 
+            if (Platform.isOSX()) {
+                // multicasting may not work on interfaces that only
+                // have link local addresses
+                if (!hasNonLinkLocalAddress(nif)) {
+                    return false;
+                }
+            }
+
             return hasIp6Addresses(nif);
         } catch (IOException e) {
             throw new UncheckedIOException(e);
         }
     }
@@ -199,21 +236,21 @@
      * Returns a stream of interfaces suitable for IPv4 functional tests.
      */
     public Stream<NetworkInterface> ip4Interfaces() {
         return ip4Interfaces.keySet()
                             .stream()
-                            .filter(NetworkConfiguration::isNotExcludedInterface)
+                            .filter(NetworkConfiguration::isTestable)
                             .filter(this::hasIp4Addresses);
     }
 
     /**
      * Returns a stream of interfaces suitable for IPv6 functional tests.
      */
     public Stream<NetworkInterface> ip6Interfaces() {
         return ip6Interfaces.keySet()
                             .stream()
-                            .filter(NetworkConfiguration::isNotExcludedInterface)
+                            .filter(NetworkConfiguration::isTestable)
                             .filter(this::hasIp6Addresses);
     }
 
     /**
      * Returns a stream of interfaces suitable for functional tests.
@@ -307,12 +344,12 @@
 
     /**
      * Return a NetworkConfiguration instance.
      */
     public static NetworkConfiguration probe() throws IOException {
-        Map<NetworkInterface, List<Inet4Address>> ip4Interfaces = new HashMap<>();
-        Map<NetworkInterface, List<Inet6Address>> ip6Interfaces = new HashMap<>();
+        Map<NetworkInterface, List<Inet4Address>> ip4Interfaces = new LinkedHashMap<>();
+        Map<NetworkInterface, List<Inet6Address>> ip6Interfaces = new LinkedHashMap<>();
 
         List<NetworkInterface> nifs = list(getNetworkInterfaces());
         for (NetworkInterface nif : nifs) {
             // ignore interfaces that are down
             if (!nif.isUp() || nif.isPointToPoint()) {

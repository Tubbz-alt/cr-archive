<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff test/lib/jdk/test/lib/Utils.java</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="SA/SATestUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="apps/LingeredApp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>test/lib/jdk/test/lib/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.lang.annotation.Annotation;

 29 import java.net.InetAddress;
 30 import java.net.InetSocketAddress;
 31 import java.net.MalformedURLException;
 32 import java.net.ServerSocket;
 33 import java.net.URL;
 34 import java.net.URLClassLoader;
 35 import java.net.UnknownHostException;
 36 import java.nio.file.Files;
 37 import java.nio.file.Path;
 38 import java.nio.file.Paths;
 39 import java.nio.file.attribute.FileAttribute;
 40 import java.nio.channels.SocketChannel;
 41 import java.util.ArrayList;
 42 import java.util.Arrays;
 43 import java.util.Collection;
 44 import java.util.Collections;
 45 import java.util.Iterator;
 46 import java.util.Map;
 47 import java.util.HashMap;

 48 import java.util.List;
 49 import java.util.Objects;
 50 import java.util.Random;
 51 import java.util.function.BooleanSupplier;
 52 import java.util.concurrent.TimeUnit;
 53 import java.util.function.Consumer;
 54 import java.util.function.Function;
 55 import java.util.regex.Matcher;
 56 import java.util.regex.Pattern;
 57 
 58 import static jdk.test.lib.Asserts.assertTrue;
 59 import jdk.test.lib.process.ProcessTools;
 60 import jdk.test.lib.process.OutputAnalyzer;
 61 
 62 /**
 63  * Common library for various test helper functions.
 64  */
 65 public final class Utils {
 66 
 67     /**
</pre>
<hr />
<pre>
103      * Returns the value of &#39;compile.jdk&#39; system property
104      */
105     public static final String COMPILE_JDK = System.getProperty(&quot;compile.jdk&quot;, TEST_JDK);
106 
107     /**
108      * Returns the value of &#39;test.classes&#39; system property
109      */
110     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
111 
112     /**
113      * Defines property name for seed value.
114      */
115     public static final String SEED_PROPERTY_NAME = &quot;jdk.test.lib.random.seed&quot;;
116 
117     /* (non-javadoc)
118      * Random generator with (or without) predefined seed. Depends on
119      * &quot;jdk.test.lib.random.seed&quot; property value.
120      */
121     private static volatile Random RANDOM_GENERATOR;
122 





123     /**
124      * Contains the seed value used for {@link java.util.Random} creation.
125      */
126     public static final long SEED = Long.getLong(SEED_PROPERTY_NAME, new Random().nextLong());
127     /**
128      * Returns the value of &#39;test.timeout.factor&#39; system property
129      * converted to {@code double}.
130      */
131     public static final double TIMEOUT_FACTOR;
132     static {
133         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
134         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
135     }
136 
137     /**
138      * Returns the value of JTREG default test timeout in milliseconds
139      * converted to {@code long}.
140      */
141     public static final long DEFAULT_TEST_TIMEOUT = TimeUnit.SECONDS.toMillis(120);
142 
</pre>
<hr />
<pre>
285      * endpoint is an InetSocketAddress where the address is the loopback address
286      * and the port is a system port (1-1023 range).
287      * This method is a better choice than getFreePort for tests that need
288      * an endpoint that refuses connections.
289      */
290     public static InetSocketAddress refusingEndpoint() {
291         InetAddress lb = InetAddress.getLoopbackAddress();
292         int port = 1;
293         while (port &lt; 1024) {
294             InetSocketAddress sa = new InetSocketAddress(lb, port);
295             try {
296                 SocketChannel.open(sa).close();
297             } catch (IOException ioe) {
298                 return sa;
299             }
300             port++;
301         }
302         throw new RuntimeException(&quot;Unable to find system port that is refusing connections&quot;);
303     }
304 































305     /**
306      * Returns the free port on the local host.
307      *
308      * @return The port number
309      * @throws IOException if an I/O error occurs when opening the socket
310      */
311     public static int getFreePort() throws IOException {
312         try (ServerSocket serverSocket =
313                 new ServerSocket(0, 5, InetAddress.getLoopbackAddress());) {
314             return serverSocket.getLocalPort();
315         }
316     }
317 































318     /**
319      * Returns the name of the local host.
320      *
321      * @return The host name
322      * @throws UnknownHostException if IP address of a host could not be determined
323      */
324     public static String getHostname() throws UnknownHostException {
325         InetAddress inetAddress = InetAddress.getLocalHost();
326         String hostName = inetAddress.getHostName();
327 
328         assertTrue((hostName != null &amp;&amp; !hostName.isEmpty()),
329                 &quot;Cannot get hostname&quot;);
330 
331         return hostName;
332     }
333 
334     /**
335      * Uses &quot;jcmd -l&quot; to search for a jvm pid. This function will wait
336      * forever (until jtreg timeout) for the pid to be found.
337      * @param key Regular expression to search for
</pre>
</td>
<td>
<hr />
<pre>
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  */
 23 
 24 package jdk.test.lib;
 25 
 26 import java.io.File;
 27 import java.io.IOException;
 28 import java.lang.annotation.Annotation;
<span class="line-added"> 29 import java.net.Inet6Address;</span>
 30 import java.net.InetAddress;
 31 import java.net.InetSocketAddress;
 32 import java.net.MalformedURLException;
 33 import java.net.ServerSocket;
 34 import java.net.URL;
 35 import java.net.URLClassLoader;
 36 import java.net.UnknownHostException;
 37 import java.nio.file.Files;
 38 import java.nio.file.Path;
 39 import java.nio.file.Paths;
 40 import java.nio.file.attribute.FileAttribute;
 41 import java.nio.channels.SocketChannel;
 42 import java.util.ArrayList;
 43 import java.util.Arrays;
 44 import java.util.Collection;
 45 import java.util.Collections;
 46 import java.util.Iterator;
 47 import java.util.Map;
 48 import java.util.HashMap;
<span class="line-added"> 49 import java.util.LinkedList;</span>
 50 import java.util.List;
 51 import java.util.Objects;
 52 import java.util.Random;
 53 import java.util.function.BooleanSupplier;
 54 import java.util.concurrent.TimeUnit;
 55 import java.util.function.Consumer;
 56 import java.util.function.Function;
 57 import java.util.regex.Matcher;
 58 import java.util.regex.Pattern;
 59 
 60 import static jdk.test.lib.Asserts.assertTrue;
 61 import jdk.test.lib.process.ProcessTools;
 62 import jdk.test.lib.process.OutputAnalyzer;
 63 
 64 /**
 65  * Common library for various test helper functions.
 66  */
 67 public final class Utils {
 68 
 69     /**
</pre>
<hr />
<pre>
105      * Returns the value of &#39;compile.jdk&#39; system property
106      */
107     public static final String COMPILE_JDK = System.getProperty(&quot;compile.jdk&quot;, TEST_JDK);
108 
109     /**
110      * Returns the value of &#39;test.classes&#39; system property
111      */
112     public static final String TEST_CLASSES = System.getProperty(&quot;test.classes&quot;, &quot;.&quot;);
113 
114     /**
115      * Defines property name for seed value.
116      */
117     public static final String SEED_PROPERTY_NAME = &quot;jdk.test.lib.random.seed&quot;;
118 
119     /* (non-javadoc)
120      * Random generator with (or without) predefined seed. Depends on
121      * &quot;jdk.test.lib.random.seed&quot; property value.
122      */
123     private static volatile Random RANDOM_GENERATOR;
124 
<span class="line-added">125     /**</span>
<span class="line-added">126      * Maximum number of attempts to get free socket</span>
<span class="line-added">127      */</span>
<span class="line-added">128     private static final int MAX_SOCKET_TRIES = 10;</span>
<span class="line-added">129 </span>
130     /**
131      * Contains the seed value used for {@link java.util.Random} creation.
132      */
133     public static final long SEED = Long.getLong(SEED_PROPERTY_NAME, new Random().nextLong());
134     /**
135      * Returns the value of &#39;test.timeout.factor&#39; system property
136      * converted to {@code double}.
137      */
138     public static final double TIMEOUT_FACTOR;
139     static {
140         String toFactor = System.getProperty(&quot;test.timeout.factor&quot;, &quot;1.0&quot;);
141         TIMEOUT_FACTOR = Double.parseDouble(toFactor);
142     }
143 
144     /**
145      * Returns the value of JTREG default test timeout in milliseconds
146      * converted to {@code long}.
147      */
148     public static final long DEFAULT_TEST_TIMEOUT = TimeUnit.SECONDS.toMillis(120);
149 
</pre>
<hr />
<pre>
292      * endpoint is an InetSocketAddress where the address is the loopback address
293      * and the port is a system port (1-1023 range).
294      * This method is a better choice than getFreePort for tests that need
295      * an endpoint that refuses connections.
296      */
297     public static InetSocketAddress refusingEndpoint() {
298         InetAddress lb = InetAddress.getLoopbackAddress();
299         int port = 1;
300         while (port &lt; 1024) {
301             InetSocketAddress sa = new InetSocketAddress(lb, port);
302             try {
303                 SocketChannel.open(sa).close();
304             } catch (IOException ioe) {
305                 return sa;
306             }
307             port++;
308         }
309         throw new RuntimeException(&quot;Unable to find system port that is refusing connections&quot;);
310     }
311 
<span class="line-added">312     /**</span>
<span class="line-added">313      * Returns local addresses with symbolic and numeric scopes</span>
<span class="line-added">314      */</span>
<span class="line-added">315     public static List&lt;InetAddress&gt; getAddressesWithSymbolicAndNumericScopes() {</span>
<span class="line-added">316         List&lt;InetAddress&gt; result = new LinkedList&lt;&gt;();</span>
<span class="line-added">317         try {</span>
<span class="line-added">318             NetworkConfiguration conf = NetworkConfiguration.probe();</span>
<span class="line-added">319             conf.ip4Addresses().forEach(result::add);</span>
<span class="line-added">320             // Java reports link local addresses with symbolic scope,</span>
<span class="line-added">321             // but on Windows java.net.NetworkInterface generates its own scope names</span>
<span class="line-added">322             // which are incompatible with native Windows routines.</span>
<span class="line-added">323             // So on Windows test only addresses with numeric scope.</span>
<span class="line-added">324             // On other platforms test both symbolic and numeric scopes.</span>
<span class="line-added">325             conf.ip6Addresses().forEach(addr6 -&gt; {</span>
<span class="line-added">326                 try {</span>
<span class="line-added">327                     result.add(Inet6Address.getByAddress(null, addr6.getAddress(), addr6.getScopeId()));</span>
<span class="line-added">328                 } catch (UnknownHostException e) {</span>
<span class="line-added">329                     // cannot happen!</span>
<span class="line-added">330                     throw new RuntimeException(&quot;Unexpected&quot;, e);</span>
<span class="line-added">331                 }</span>
<span class="line-added">332                 if (!Platform.isWindows()) {</span>
<span class="line-added">333                     result.add(addr6);</span>
<span class="line-added">334                 }</span>
<span class="line-added">335             });</span>
<span class="line-added">336         } catch (IOException e) {</span>
<span class="line-added">337             // cannot happen!</span>
<span class="line-added">338             throw new RuntimeException(&quot;Unexpected&quot;, e);</span>
<span class="line-added">339         }</span>
<span class="line-added">340         return result;</span>
<span class="line-added">341     }</span>
<span class="line-added">342 </span>
343     /**
344      * Returns the free port on the local host.
345      *
346      * @return The port number
347      * @throws IOException if an I/O error occurs when opening the socket
348      */
349     public static int getFreePort() throws IOException {
350         try (ServerSocket serverSocket =
351                 new ServerSocket(0, 5, InetAddress.getLoopbackAddress());) {
352             return serverSocket.getLocalPort();
353         }
354     }
355 
<span class="line-added">356     /**</span>
<span class="line-added">357      * Returns the free unreserved port on the local host.</span>
<span class="line-added">358      *</span>
<span class="line-added">359      * @param reservedPorts reserved ports</span>
<span class="line-added">360      * @return The port number or -1 if failed to find a free port</span>
<span class="line-added">361      */</span>
<span class="line-added">362     public static int findUnreservedFreePort(int... reservedPorts) {</span>
<span class="line-added">363         int numTries = 0;</span>
<span class="line-added">364         while (numTries++ &lt; MAX_SOCKET_TRIES) {</span>
<span class="line-added">365             int port = -1;</span>
<span class="line-added">366             try {</span>
<span class="line-added">367                 port = getFreePort();</span>
<span class="line-added">368             } catch (IOException e) {</span>
<span class="line-added">369                 e.printStackTrace();</span>
<span class="line-added">370             }</span>
<span class="line-added">371             if (port &gt; 0 &amp;&amp; !isReserved(port, reservedPorts)) {</span>
<span class="line-added">372                 return port;</span>
<span class="line-added">373             }</span>
<span class="line-added">374         }</span>
<span class="line-added">375         return -1;</span>
<span class="line-added">376     }</span>
<span class="line-added">377 </span>
<span class="line-added">378     private static boolean isReserved(int port, int[] reservedPorts) {</span>
<span class="line-added">379         for (int p : reservedPorts) {</span>
<span class="line-added">380             if (p == port) {</span>
<span class="line-added">381                 return true;</span>
<span class="line-added">382             }</span>
<span class="line-added">383         }</span>
<span class="line-added">384         return false;</span>
<span class="line-added">385     }</span>
<span class="line-added">386 </span>
387     /**
388      * Returns the name of the local host.
389      *
390      * @return The host name
391      * @throws UnknownHostException if IP address of a host could not be determined
392      */
393     public static String getHostname() throws UnknownHostException {
394         InetAddress inetAddress = InetAddress.getLocalHost();
395         String hostName = inetAddress.getHostName();
396 
397         assertTrue((hostName != null &amp;&amp; !hostName.isEmpty()),
398                 &quot;Cannot get hostname&quot;);
399 
400         return hostName;
401     }
402 
403     /**
404      * Uses &quot;jcmd -l&quot; to search for a jvm pid. This function will wait
405      * forever (until jtreg timeout) for the pid to be found.
406      * @param key Regular expression to search for
</pre>
</td>
</tr>
</table>
<center><a href="SA/SATestUtils.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="apps/LingeredApp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
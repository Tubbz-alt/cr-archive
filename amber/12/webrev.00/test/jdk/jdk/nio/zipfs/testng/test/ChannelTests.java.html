<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New test/jdk/jdk/nio/zipfs/testng/test/ChannelTests.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 package test;
  25 
  26 import org.testng.annotations.Test;
  27 import util.ZipFsBaseTest;
  28 
  29 import java.io.ByteArrayOutputStream;
  30 import java.io.IOException;
  31 import java.nio.ByteBuffer;
  32 import java.nio.channels.ClosedChannelException;
  33 import java.nio.channels.FileChannel;
  34 import java.nio.channels.FileLock;
  35 import java.nio.channels.SeekableByteChannel;
  36 import java.nio.file.*;
  37 import java.util.Arrays;
  38 import java.util.Map;
  39 import java.util.Random;
  40 import java.util.Set;
  41 import java.util.zip.ZipEntry;
  42 
  43 import static java.nio.charset.StandardCharsets.UTF_8;
  44 import static java.nio.file.StandardOpenOption.*;
  45 import static org.testng.Assert.*;
  46 
  47 /**
  48  * @test
  49  * @bug 8242006
  50  * @summary Improve FileChannel and SeekableByteChannel Zip FS test coverage
  51  * @modules jdk.zipfs
  52  * @run testng test.ChannelTests
  53  */
  54 public class ChannelTests extends ZipFsBaseTest {
  55 
  56     // Size of the ByteBuffer to use for reading/writing
  57     public static final int BYTEBUFFER_SIZE = 8192;
  58     // Values used to create the entries to be copied into/from a Zip file
  59     private static final String GRAND_SLAMS_HEADER = &quot;The Grand Slams Are:&quot;
  60             + System.lineSeparator();
  61     private static final String AUSTRALIAN_OPEN = &quot;Australian Open&quot;
  62             + System.lineSeparator();
  63     private static final String FRENCH_OPEN = &quot;French Open&quot; + System.lineSeparator();
  64     private static final String WIMBLEDON = &quot;Wimbledon&quot; + System.lineSeparator();
  65     private static final String US_OPEN = &quot;U.S. Open&quot; + System.lineSeparator();
  66     private static final String GRAND_SLAMS = AUSTRALIAN_OPEN
  67             + FRENCH_OPEN
  68             + WIMBLEDON
  69             + US_OPEN;
  70     private static final String THE_SLAMS = GRAND_SLAMS_HEADER
  71             + GRAND_SLAMS;
  72     private static final String FIFTH_MAJOR = &quot;Indian Wells is the 5th Major&quot;
  73             + System.lineSeparator();
  74     private static final Random RANDOM = new Random();
  75 
  76     /**
  77      * Validate SeekableByteChannel can be used to copy an OS file to
  78      * a Zip file
  79      *
  80      * @param env         Zip FS properties to use when creating the Zip file
  81      * @param compression The compression used when writing the entries
  82      * @throws Exception If an error occurs
  83      */
  84     @Test(dataProvider = &quot;zipfsMap&quot;)
  85     public void sbcFromOSToZipTest(final Map&lt;String, String&gt; env,
  86                                    final int compression) throws Exception {
  87         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, FIFTH_MAJOR);
  88         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
  89         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
  90         Files.deleteIfExists(osFile);
  91         Files.deleteIfExists(zipFile);
  92         Files.writeString(osFile, FIFTH_MAJOR);
  93         // Create a Zip entry from an OS file
  94         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
  95             sbcCopy(osFile, zipfs.getPath(e00.name));
  96         }
  97         // Check to see if the entries match
  98         verify(zipFile, e00);
  99         Files.deleteIfExists(osFile);
 100         Files.deleteIfExists(zipFile);
 101     }
 102 
 103     /**
 104      * Validate SeekableByteChannel can be used to copy an entry from
 105      * a Zip file to an OS file
 106      *
 107      * @param env         Zip FS properties to use when creating the Zip file
 108      * @param compression The compression used when writing the entries
 109      * @throws Exception If an error occurs
 110      */
 111     @Test(dataProvider = &quot;zipfsMap&quot;)
 112     public void sbcFromZipToOSTest(final Map&lt;String, String&gt; env,
 113                                    final int compression) throws Exception {
 114         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 115         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 116         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 117         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 118         Files.deleteIfExists(zipFile);
 119         Files.deleteIfExists(osFile);
 120         zip(zipFile, env, e0, e1);
 121         verify(zipFile, e0, e1);
 122         // Create an OS file from a Zip entry
 123         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 124             sbcCopy(zipfs.getPath(e0.name), osFile);
 125         }
 126         // Check to see if the file exists and the bytes match
 127         assertTrue(Files.isRegularFile(osFile));
 128         assertEquals(Files.readAllBytes(osFile), e0.bytes);
 129         Files.deleteIfExists(zipFile);
 130         Files.deleteIfExists(osFile);
 131     }
 132 
 133     /**
 134      * Validate SeekableByteChannel can be used to copy an entry from
 135      * one Zip file to another Zip file
 136      *
 137      * @param env         Zip FS properties to use when creating the Zip file
 138      * @param compression The compression used when writing the entries
 139      * @throws Exception If an error occurs
 140      */
 141     @Test(dataProvider = &quot;zipfsMap&quot;)
 142     public void sbcFromZipToZipTest(final Map&lt;String, String&gt; env,
 143                                     final int compression) throws Exception {
 144         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 145         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 146         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 147         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 148         Files.deleteIfExists(zipFile);
 149         Files.deleteIfExists(zipFile2);
 150         zip(zipFile, env, e0, e1);
 151         verify(zipFile, e0, e1);
 152         // Copy entries from one Zip file to another using SeekableByteChannel
 153         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 154              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
 155             sbcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
 156             sbcCopy(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
 157         }
 158         // Check to see if the entries match
 159         verify(zipFile2, e0, e1);
 160         Files.deleteIfExists(zipFile);
 161         Files.deleteIfExists(zipFile2);
 162     }
 163 
 164     /**
 165      * Validate SeekableByteChannel can be used to copy an entry within
 166      * a Zip file with the correct compression
 167      *
 168      * @param env                 Zip FS properties to use when creating the Zip file
 169      * @param compression         The compression used when writing the initial entries
 170      * @param expectedCompression The compression to be used when copying the entry
 171      * @throws Exception If an error occurs
 172      */
 173     @Test(dataProvider = &quot;copyMoveMap&quot;)
 174     public void sbcChangeCompressionTest(final Map&lt;String, String&gt; env,
 175                                          final int compression,
 176                                          final int expectedCompression) throws Exception {
 177         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 178         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 179         Entry e00 = Entry.of(&quot;Entry-00&quot;, expectedCompression, THE_SLAMS);
 180         // Compression method to use when copying the entry
 181         String targetCompression = expectedCompression == ZipEntry.STORED ? &quot;true&quot; : &quot;false&quot;;
 182         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 183         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 184         Files.deleteIfExists(zipFile);
 185         Files.deleteIfExists(zipFile2);
 186         // Create the initial Zip files
 187         zip(zipFile, env, e0, e1);
 188         zip(zipFile2, env, e0, e1);
 189         verify(zipFile, e0, e1);
 190         // Copy the entry from one Zip file to another using SeekableByteChannel
 191         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 192              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2,
 193                      Map.of(&quot;noCompression&quot;, targetCompression))) {
 194             sbcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e00.name));
 195         }
 196         // Check to see if the entries match
 197         verify(zipFile2, e0, e1, e00);
 198         Files.deleteIfExists(zipFile);
 199         Files.deleteIfExists(zipFile2);
 200     }
 201 
 202     /**
 203      * Validate SeekableByteChannel::read can be used to read a Zip entry
 204      *
 205      * @param env         Zip FS properties to use when creating the Zip file
 206      * @param compression The compression used when writing the entries
 207      * @throws Exception If an error occurs
 208      */
 209     @Test(dataProvider = &quot;zipfsMap&quot;)
 210     public void sbcReadTest(final Map&lt;String, String&gt; env,
 211                             final int compression) throws Exception {
 212         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 213         Files.deleteIfExists(zipFile);
 214         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 215         zip(zipFile, env, e0);
 216         // Read an entry
 217         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 218              SeekableByteChannel sbc =
 219                      Files.newByteChannel(zipfs.getPath(e0.name),
 220                      Set.of(READ))) {
 221             ByteBuffer buf = ByteBuffer.allocate((int) sbc.size());
 222             int bytesRead = sbc.read(buf);
 223             // Check to see if the expected bytes were read
 224             byte[] result = Arrays.copyOfRange(buf.array(), 0, bytesRead);
 225             assertEquals(THE_SLAMS.getBytes(UTF_8), result);
 226         }
 227         Files.deleteIfExists(zipFile);
 228     }
 229 
 230     /**
 231      * Validate SeekableByteChannel::write can be used to create a Zip entry
 232      *
 233      * @param env         Zip FS properties to use when creating the Zip file
 234      * @param compression The compression used when writing the entries
 235      * @throws Exception If an error occurs
 236      */
 237     @Test(dataProvider = &quot;zipfsMap&quot;)
 238     public void sbcWriteTest(final Map&lt;String, String&gt; env,
 239                              final int compression) throws Exception {
 240         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 241         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 242         Files.deleteIfExists(zipFile);
 243         // Create the Zip entry
 244         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 245              SeekableByteChannel sbc =
 246                      Files.newByteChannel(zipfs.getPath(e0.name),
 247                      Set.of(CREATE, WRITE))) {
 248             ByteBuffer bb = ByteBuffer.wrap(THE_SLAMS.getBytes(UTF_8));
 249             sbc.write(bb);
 250         }
 251         // Verify the entry
 252         verify(zipFile, e0);
 253         Files.deleteIfExists(zipFile);
 254     }
 255 
 256     /**
 257      * Validate SeekableByteChannel can be used to append to an entry
 258      * in a Zip file
 259      *
 260      * @param env         Zip FS properties to use when creating the Zip file
 261      * @param compression The compression used when writing the entries
 262      * @throws Exception If an error occurs
 263      */
 264     @Test(dataProvider = &quot;zipfsMap&quot;)
 265     public void sbcAppendTest(final Map&lt;String, String&gt; env,
 266                               final int compression) throws Exception {
 267         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 268         Files.deleteIfExists(zipFile);
 269         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 270         zip(zipFile, env, e0);
 271         // Update a Zip entry by appending to it
 272         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 273              SeekableByteChannel sbc =
 274                      Files.newByteChannel(zipfs.getPath(e0.name),
 275                              Set.of(WRITE, APPEND))) {
 276             ByteBuffer bb = ByteBuffer.wrap(FIFTH_MAJOR.getBytes());
 277             sbc.write(bb);
 278         }
 279         // Check to see if the entries match
 280         verify(zipFile, e0.content(THE_SLAMS + FIFTH_MAJOR));
 281         Files.deleteIfExists(zipFile);
 282     }
 283 
 284     /**
 285      * Validate UnsupportedOperationException is thrown when
 286      * SeekableByteChannel::truncate is invoked
 287      * Note: Feature Request: JDK-8241959 has been created to support this
 288      * functionality
 289      *
 290      * @param env         Zip FS properties to use when creating the Zip file
 291      * @param compression The compression used when writing the entries
 292      * @throws Exception If an error occurs
 293      */
 294     @Test(dataProvider = &quot;zipfsMap&quot;)
 295     public void sbcTruncateTest(final Map&lt;String, String&gt; env,
 296                                 final int compression) throws Exception {
 297         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 298         Files.deleteIfExists(zipFile);
 299         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 300         zip(zipFile, env, e0);
 301         // Verify that a UnsupportedOperationException is thrown
 302         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 303              SeekableByteChannel sbc =
 304                      Files.newByteChannel(zipfs.getPath(e0.name), Set.of(WRITE))) {
 305             assertThrows(UnsupportedOperationException.class, () -&gt;
 306                     sbc.truncate(GRAND_SLAMS_HEADER.length()));
 307         }
 308         Files.deleteIfExists(zipFile);
 309     }
 310 
 311     /**
 312      * Validate FileAlreadyExistsException is thrown when
 313      * Files::newByteChannel is invoked with the CREATE_NEW option along with
 314      * either the WRITE or APPEND option and the entry already exists
 315      *
 316      * @param env         Zip FS properties to use when creating the Zip file
 317      * @param compression The compression used when writing the entries
 318      * @throws Exception If an error occurs
 319      */
 320     @Test(dataProvider = &quot;zipfsMap&quot;)
 321     public void sbcFAETest(final Map&lt;String, String&gt; env,
 322                            final int compression) throws Exception {
 323         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 324         Files.deleteIfExists(zipFile);
 325         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 326         zip(zipFile, env, e0);
 327         // Validate that a FileAlreadyExistsException is thrown
 328         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 329             assertThrows(FileAlreadyExistsException.class, () -&gt;
 330                     Files.newByteChannel(zipfs.getPath(e0.name),
 331                             Set.of(CREATE_NEW, WRITE)));
 332             assertThrows(FileAlreadyExistsException.class, () -&gt;
 333                     Files.newByteChannel(zipfs.getPath(e0.name),
 334                             Set.of(CREATE_NEW, APPEND)));
 335         }
 336         Files.deleteIfExists(zipFile);
 337     }
 338 
 339     /**
 340      * Validate when SeekableByteChannel::close is called more than once, that
 341      * no error occurs
 342      * &lt;p&gt;
 343      * Note: this is currently disabled due to bug JDK-8241883
 344      *
 345      * @param env         Zip FS properties to use when creating the Zip file
 346      * @param compression The compression used when writing the entries
 347      * @throws Exception If an error occurs
 348      */
 349     @Test(dataProvider = &quot;zipfsMap&quot;, enabled = false)
 350     public void sbcCloseTest(final Map&lt;String, String&gt; env,
 351                              final int compression) throws Exception {
 352         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 353         Files.deleteIfExists(zipFile);
 354         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 355         zip(zipFile, env, e0);
 356         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 357             SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name),
 358                     Set.of(READ, WRITE));
 359             sbc.close();
 360             sbc.close();
 361             assertFalse(sbc.isOpen());
 362         }
 363         Files.deleteIfExists(zipFile);
 364     }
 365 
 366     /**
 367      * Validate ClosedChannelException is thrown when a SeekableByteChannel
 368      * method is invoked after calling SeekableByteChannel::close
 369      *
 370      * @param env         Zip FS properties to use when creating the Zip file
 371      * @param compression The compression used when writing the entries
 372      * @throws Exception If an error occurs
 373      */
 374     @Test(dataProvider = &quot;zipfsMap&quot;)
 375     public void sbcCCETest(final Map&lt;String, String&gt; env,
 376                            final int compression) throws Exception {
 377         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 378         Files.deleteIfExists(zipFile);
 379         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 380         zip(zipFile, env, e0);
 381         ByteBuffer bb = ByteBuffer.wrap(&quot;First Serve&quot;.getBytes(UTF_8));
 382         // Check that ClosedChannelException is thrown if the channel is closed
 383         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 384             SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name),
 385                     Set.of(READ, WRITE));
 386             sbc.close();
 387             assertThrows(ClosedChannelException.class, sbc::position);
 388             assertThrows(ClosedChannelException.class, () -&gt; sbc.position(1));
 389             assertThrows(ClosedChannelException.class, () -&gt; sbc.read(bb));
 390             assertThrows(ClosedChannelException.class, sbc::size);
 391             assertThrows(ClosedChannelException.class, () -&gt; sbc.truncate(2));
 392             assertThrows(ClosedChannelException.class, () -&gt; sbc.write(bb));
 393         }
 394         Files.deleteIfExists(zipFile);
 395     }
 396 
 397     /**
 398      * Validate SeekableByteChannel::size can be used to obtain the size
 399      * of a Zip entry
 400      * Note:  If the file is opened for writing, the test will fail unless data
 401      * has been written.  See: JDK-8241949
 402      * @param env         Zip FS properties to use when creating the Zip file
 403      * @param compression The compression used when writing the entries
 404      * @throws Exception If an error occurs
 405      */
 406     @Test(dataProvider = &quot;zipfsMap&quot;)
 407     public void sbcSizeTest(final Map&lt;String, String&gt; env,
 408                             final int compression) throws Exception {
 409         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 410         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 411         Files.deleteIfExists(zipFile);
 412         zip(zipFile, env, e0);
 413         // Open the file and validate the size
 414         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 415              SeekableByteChannel sbc = Files.newByteChannel(
 416                      zipfs.getPath(e0.name), Set.of(READ))) {
 417             assertEquals(sbc.size(), THE_SLAMS.length());
 418         }
 419         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 420              SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name))) {
 421             assertEquals(sbc.size(), THE_SLAMS.length());
 422         }
 423         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 424              SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(&quot;Entry-01&quot;)
 425                      , Set.of(CREATE, WRITE))) {
 426             sbc.write(ByteBuffer.wrap(FIFTH_MAJOR.getBytes(UTF_8)));
 427             assertEquals(sbc.size(), FIFTH_MAJOR.length());
 428         }
 429         Files.deleteIfExists(zipFile);
 430     }
 431 
 432     /**
 433      * Validate SeekableByteChannel::isOpen returns true when the file
 434      * is open and false after SeekableByteChannel::close is called
 435      *
 436      * @param env         Zip FS properties to use when creating the Zip file
 437      * @param compression The compression used when writing the entries
 438      * @throws Exception If an error occurs
 439      */
 440     @Test(dataProvider = &quot;zipfsMap&quot;)
 441     public void sbcOpenClosedTest(final Map&lt;String, String&gt; env,
 442                                   final int compression) throws Exception {
 443         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 444         Files.deleteIfExists(zipFile);
 445         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 446         zip(zipFile, env, e0);
 447         // Validate SeekableByteChannel::isOpen
 448         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 449              SeekableByteChannel sbc = Files.newByteChannel(zipfs.getPath(e0.name),
 450                      Set.of(READ))) {
 451             assertTrue(sbc.isOpen());
 452             sbc.close();
 453             assertFalse(sbc.isOpen());
 454         }
 455         Files.deleteIfExists(zipFile);
 456     }
 457 
 458     /**
 459      * Validate SeekableByteChannel::position returns the expected position
 460      * Note: due to bug JDK-8241882, the position will not exceed the file size
 461      * in the test
 462      *
 463      * @param env         Zip FS properties to use when creating the Zip file
 464      * @param compression The compression used when writing the entries
 465      * @throws Exception If an error occurs
 466      */
 467     @Test(dataProvider = &quot;zipfsMap&quot;)
 468     public void sbcPositionTest(final Map&lt;String, String&gt; env,
 469                                 final int compression) throws Exception {
 470         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 471         Files.deleteIfExists(zipFile);
 472         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 473         zip(zipFile, env, e0);
 474         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 475              SeekableByteChannel sbc =
 476                      Files.newByteChannel(zipfs.getPath(e0.name), Set.of(READ))) {
 477             int fSize = (int) sbc.size();
 478             // Specify the seed to use
 479             int seed = fSize + 1;
 480             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
 481             sbc.read(bb);
 482             for (var i = 0; i &lt; fSize; i++) {
 483                 long pos = RANDOM.nextInt(seed);
 484                 sbc.position(pos);
 485                 assertEquals(sbc.position(), pos);
 486             }
 487         }
 488         Files.deleteIfExists(zipFile);
 489     }
 490 
 491     // ### FileChannel Tests ###
 492 
 493     /**
 494      * Validate a FileChannel can be used to copy an OS file to
 495      * a Zip file
 496      *
 497      * @param env         Zip FS properties to use when creating the Zip file
 498      * @param compression The compression used when writing the entries
 499      * @throws Exception If an error occurs
 500      */
 501     @Test(dataProvider = &quot;zipfsMap&quot;)
 502     public void fcFromOSToZipTest(final Map&lt;String, String&gt; env,
 503                                   final int compression) throws Exception {
 504         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 505         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 506         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 507         Files.deleteIfExists(osFile);
 508         Files.deleteIfExists(zipFile);
 509         Files.writeString(osFile, THE_SLAMS);
 510         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 511             fcCopy(osFile, zipfs.getPath(e0.name));
 512         }
 513         // Verify the entry was copied
 514         verify(zipFile, e0);
 515         Files.deleteIfExists(osFile);
 516         Files.deleteIfExists(zipFile);
 517     }
 518 
 519     /**
 520      * Validate a FileChannel can be used to copy an entry from
 521      * a Zip file to an OS file
 522      *
 523      * @param env         Zip FS properties to use when creating the Zip file
 524      * @param compression The compression used when writing the entries
 525      * @throws Exception If an error occurs
 526      */
 527     @Test(dataProvider = &quot;zipfsMap&quot;)
 528     public void fcFromZipToOSTest(final Map&lt;String, String&gt; env,
 529                                   final int compression) throws Exception {
 530         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 531         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 532         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 533         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 534         Files.deleteIfExists(zipFile);
 535         Files.deleteIfExists(osFile);
 536         zip(zipFile, env, e0, e1);
 537         verify(zipFile, e0, e1);
 538         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 539             fcCopy(zipfs.getPath(e0.name), osFile);
 540         }
 541         // Check to see if the file exists and the bytes match
 542         assertTrue(Files.isRegularFile(osFile));
 543         assertEquals(Files.readAllBytes(osFile), e0.bytes);
 544         Files.deleteIfExists(zipFile);
 545         Files.deleteIfExists(osFile);
 546     }
 547 
 548     /**
 549      * Validate a FileChannel can be used to copy an entry from
 550      * a Zip file to another Zip file
 551      *
 552      * @param env         Zip FS properties to use when creating the Zip file
 553      * @param compression The compression used when writing the entries
 554      * @throws Exception If an error occurs
 555      */
 556     @Test(dataProvider = &quot;zipfsMap&quot;)
 557     public void fcFromZipToZipTest(final Map&lt;String, String&gt; env,
 558                                    final int compression) throws Exception {
 559         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 560         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 561         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 562         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 563         Files.deleteIfExists(zipFile);
 564         Files.deleteIfExists(zipFile2);
 565         zip(zipFile, env, e0, e1);
 566         verify(zipFile, e0, e1);
 567         // Copy entries from one Zip file to another using FileChannel
 568         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 569              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
 570             fcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
 571             fcCopy(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
 572         }
 573         // Check to see if the entries match
 574         verify(zipFile2, e0, e1);
 575         Files.deleteIfExists(zipFile);
 576         Files.deleteIfExists(zipFile2);
 577     }
 578 
 579     /**
 580      * Validate a FileChannel can be used to copy an entry within
 581      * a Zip file with the correct compression
 582      *
 583      * @param env                 Zip FS properties to use when creating the Zip file
 584      * @param compression         The compression used when writing the initial entries
 585      * @param expectedCompression The compression to be used when copying the entry
 586      * @throws Exception If an error occurs
 587      */
 588     @Test(dataProvider = &quot;copyMoveMap&quot;)
 589     public void fcChangeCompressionTest(final Map&lt;String, String&gt; env,
 590                                         final int compression,
 591                                         final int expectedCompression) throws Exception {
 592         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 593         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
 594         Entry e00 = Entry.of(&quot;Entry-00&quot;, expectedCompression, THE_SLAMS);
 595         // Compression method to use when copying the entry
 596         String targetCompression = expectedCompression == ZipEntry.STORED ? &quot;true&quot; : &quot;false&quot;;
 597         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 598         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 599         Files.deleteIfExists(zipFile);
 600         Files.deleteIfExists(zipFile2);
 601         // Create the initial Zip files
 602         zip(zipFile, env, e0, e1);
 603         zip(zipFile2, env, e0, e1);
 604         verify(zipFile, e0, e1);
 605         // Copy the entry from one Zip file to another
 606         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 607              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2,
 608                      Map.of(&quot;noCompression&quot;, targetCompression))) {
 609             fcCopy(zipfs.getPath(e0.name), zipfs2.getPath(e00.name));
 610         }
 611         // Check to see if the entries match
 612         verify(zipFile2, e0, e1, e00);
 613         Files.deleteIfExists(zipFile);
 614         Files.deleteIfExists(zipFile2);
 615     }
 616 
 617     /**
 618      * Validate a FileChannel can be used to append an entry
 619      * in a Zip file
 620      *
 621      * @param env         Zip FS properties to use when creating the Zip file
 622      * @param compression The compression used when writing the entries
 623      * @throws Exception If an error occurs
 624      */
 625     @Test(dataProvider = &quot;zipfsMap&quot;)
 626     public void fcAppendTest(final Map&lt;String, String&gt; env,
 627                              final int compression) throws Exception {
 628         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 629         Files.deleteIfExists(zipFile);
 630         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 631         zip(zipFile, env, e0);
 632         // Update the Zip entry by appending to it
 633         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 634              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 635                      Set.of(WRITE, APPEND))) {
 636             ByteBuffer bb = ByteBuffer.wrap(FIFTH_MAJOR.getBytes());
 637             fc.write(bb);
 638         }
 639         // Check to see if the entries match
 640         verify(zipFile, e0.content(THE_SLAMS + FIFTH_MAJOR));
 641         Files.deleteIfExists(zipFile);
 642     }
 643 
 644     /**
 645      * Validate FileChannel::truncate will truncate the file at the specified
 646      * position
 647      *
 648      * @param env         Zip FS properties to use when creating the Zip file
 649      * @param compression The compression used when writing the entries
 650      * @throws Exception If an error occurs
 651      */
 652     @Test(dataProvider = &quot;zipfsMap&quot;)
 653     public void fcTruncateTest(final Map&lt;String, String&gt; env,
 654                                final int compression) throws Exception {
 655         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 656         Files.deleteIfExists(zipFile);
 657         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 658         zip(zipFile, env, e0);
 659         // Truncate the Zip entry
 660         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 661              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 662                      Set.of(WRITE))) {
 663             fc.truncate(GRAND_SLAMS_HEADER.length());
 664         }
 665         // Check to see if the entries match
 666         verify(zipFile, e0.content(GRAND_SLAMS_HEADER));
 667         Files.deleteIfExists(zipFile);
 668     }
 669 
 670     /**
 671      * Validate FileChannel::map throws an UnsupportedOperationException
 672      *
 673      * @param env         Zip FS properties to use when creating the Zip file
 674      * @param compression The compression used when writing the entries
 675      * @throws Exception If an error occurs
 676      */
 677     @Test(dataProvider = &quot;zipfsMap&quot;)
 678     public void fcMapTest(final Map&lt;String, String&gt; env,
 679                           final int compression) throws Exception {
 680         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 681         Files.deleteIfExists(zipFile);
 682         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 683         zip(zipFile, env, e0);
 684         // Check UnsupportedOperationException is thrown
 685         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 686              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 687                      Set.of(READ))) {
 688             assertThrows(UnsupportedOperationException.class, () -&gt;
 689                     fc.map(FileChannel.MapMode.READ_ONLY, 0, fc.size()));
 690             assertThrows(UnsupportedOperationException.class, () -&gt;
 691                     fc.map(FileChannel.MapMode.READ_WRITE, 0, fc.size()));
 692             assertThrows(UnsupportedOperationException.class, () -&gt;
 693                     fc.map(FileChannel.MapMode.PRIVATE, 0, fc.size()));
 694         }
 695         Files.deleteIfExists(zipFile);
 696     }
 697 
 698     /**
 699      * Validate FileChannel::isOpen returns true when the file is open
 700      * and false after FileChannel::close is called
 701      *
 702      * @param env         Zip FS properties to use when creating the Zip file
 703      * @param compression The compression used when writing the entries
 704      * @throws Exception If an error occurs
 705      */
 706     @Test(dataProvider = &quot;zipfsMap&quot;)
 707     public void fcOpenClosedTest(final Map&lt;String, String&gt; env,
 708                                  final int compression) throws Exception {
 709         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 710         Files.deleteIfExists(zipFile);
 711         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 712         zip(zipFile, env, e0);
 713         // Validate FileChannel::isOpen
 714         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 715              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 716                      Set.of(READ))) {
 717             assertTrue(fc.isOpen());
 718             fc.close();
 719             assertFalse(fc.isOpen());
 720         }
 721         Files.deleteIfExists(zipFile);
 722     }
 723 
 724     /**
 725      * Validate FileAlreadyExistsException is thrown when
 726      * FileChannel::open is invoked with the CREATE_NEW option and the Zip
 727      * entry already exists
 728      *
 729      * @param env         Zip FS properties to use when creating the Zip file
 730      * @param compression The compression used when writing the entries
 731      * @throws Exception If an error occurs
 732      */
 733     @Test(dataProvider = &quot;zipfsMap&quot;)
 734     public void fcFAETest(final Map&lt;String, String&gt; env,
 735                           final int compression) throws Exception {
 736         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 737         Files.deleteIfExists(zipFile);
 738         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 739         zip(zipFile, env, e0);
 740         // Check FileAlreadyExistsException is thrown
 741         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 742             assertThrows(FileAlreadyExistsException.class, () -&gt;
 743                     FileChannel.open(zipfs.getPath(e0.name), Set.of(CREATE_NEW, WRITE)));
 744         }
 745         Files.deleteIfExists(zipFile);
 746     }
 747 
 748 
 749     /**
 750      * Validate when FileChannel::close is called more than once, that
 751      * no error occurs
 752      *
 753      * @param env         Zip FS properties to use when creating the Zip file
 754      * @param compression The compression used when writing the entries
 755      * @throws Exception If an error occurs
 756      */
 757     @Test(dataProvider = &quot;zipfsMap&quot;)
 758     public void fcCloseTest(final Map&lt;String, String&gt; env,
 759                              final int compression) throws Exception {
 760         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 761         Files.deleteIfExists(zipFile);
 762         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 763         zip(zipFile, env, e0);
 764         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 765             FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 766                     Set.of(READ, WRITE));
 767             fc.close();
 768             fc.close();
 769             assertFalse(fc.isOpen());
 770         }
 771         Files.deleteIfExists(zipFile);
 772     }
 773 
 774     /**
 775      * Validate ClosedChannelException is thrown when
 776      * FileChannel::close is invoked and another FileChannel method is invoked
 777      *
 778      * @param env         Zip FS properties to use when creating the Zip file
 779      * @param compression The compression used when writing the entries
 780      * @throws Exception If an error occurs
 781      */
 782     @Test(dataProvider = &quot;zipfsMap&quot;)
 783     public void fcCCETest(final Map&lt;String, String&gt; env,
 784                           final int compression) throws Exception {
 785         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 786         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 787         Files.deleteIfExists(osFile);
 788         Files.deleteIfExists(zipFile);
 789         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 790         zip(zipFile, env, e0);
 791         // Create the ByteBuffer array to be used
 792         ByteBuffer[] bb = {
 793                 ByteBuffer.wrap(&quot;First Serve&quot;.getBytes(UTF_8)),
 794                 ByteBuffer.wrap(&quot;Fault&quot;.getBytes(UTF_8)),
 795                 ByteBuffer.wrap(&quot;Double Fault&quot;.getBytes(UTF_8))
 796         };
 797         // Check ClosedChannelException is thrown if the channel is closed
 798         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 799              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
 800             fc.close();
 801             assertThrows(ClosedChannelException.class, () -&gt; fc.force(false));
 802             assertThrows(ClosedChannelException.class, fc::lock);
 803             assertThrows(ClosedChannelException.class, () -&gt; fc.lock(0, 0, false));
 804             assertThrows(ClosedChannelException.class, fc::position);
 805             assertThrows(ClosedChannelException.class, () -&gt; fc.position(1));
 806             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb));
 807             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb, 1, 2));
 808             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb[0]));
 809             assertThrows(ClosedChannelException.class, () -&gt; fc.read(bb[0], 1));
 810             assertThrows(ClosedChannelException.class, fc::size);
 811             assertThrows(ClosedChannelException.class, fc::tryLock);
 812             assertThrows(ClosedChannelException.class, () -&gt;
 813                     fc.tryLock(0, 1, false));
 814             assertThrows(ClosedChannelException.class, () -&gt; fc.truncate(2));
 815             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb));
 816             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb[0]));
 817             // Note does not check closed 1st when file not opened with &quot;WRITE&quot;
 818             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb[0], 1));
 819             assertThrows(ClosedChannelException.class, () -&gt; fc.write(bb, 1, 2));
 820             try (
 821                     FileChannel out = FileChannel.open(osFile, Set.of(CREATE_NEW, WRITE))) {
 822                 assertThrows(ClosedChannelException.class, () -&gt;
 823                         fc.transferTo(0, fc.size(), out));
 824                 // Check when &#39;fc&#39; is closed
 825                 assertThrows(ClosedChannelException.class, () -&gt;
 826                         out.transferFrom(fc, 0, fc.size()));
 827                 fc.close();
 828                 // Check when &#39;out&#39; is closed
 829                 assertThrows(ClosedChannelException.class, () -&gt;
 830                         out.transferFrom(fc, 0, fc.size()));
 831             }
 832         }
 833         Files.deleteIfExists(zipFile);
 834         Files.deleteIfExists(osFile);
 835     }
 836 
 837     /**
 838      * Validate FileChannel::read can read an entry from a Zip file
 839      *
 840      * @param env         Zip FS properties to use when creating the Zip file
 841      * @param compression The compression used when writing the entries
 842      * @throws Exception If an error occurs
 843      */
 844     @Test(dataProvider = &quot;zipfsMap&quot;)
 845     public void fcReadTest(final Map&lt;String, String&gt; env,
 846                            final int compression) throws Exception {
 847         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 848         Files.deleteIfExists(zipFile);
 849         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 850         zip(zipFile, env, e0);
 851         // Read an entry
 852         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 853              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 854                      Set.of(READ))) {
 855             ByteBuffer buf = ByteBuffer.allocate((int) fc.size());
 856             int bytesRead = fc.read(buf);
 857             // Check to see if the expected bytes were read
 858             byte[] result = Arrays.copyOfRange(buf.array(), 0, bytesRead);
 859             assertEquals(THE_SLAMS.getBytes(UTF_8), result);
 860         }
 861         Files.deleteIfExists(zipFile);
 862     }
 863 
 864     /**
 865      * Validate FileChannel::read can read an entry from a Zip file
 866      *  when specifying a starting position
 867      *
 868      * @param env         Zip FS properties to use when creating the Zip file
 869      * @param compression The compression used when writing the entries
 870      * @throws Exception If an error occurs
 871      */
 872     @Test(dataProvider = &quot;zipfsMap&quot;)
 873     public void fcReadPosTest(final Map&lt;String, String&gt; env,
 874                               final int compression) throws Exception {
 875         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 876         Files.deleteIfExists(zipFile);
 877         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 878         zip(zipFile, env, e0);
 879         // Read an entry specifying a starting position within the file
 880         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 881              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 882                      Set.of(READ))) {
 883             ByteBuffer buf = ByteBuffer.allocate((int) fc.size());
 884             int bytesRead = fc.read(buf, GRAND_SLAMS_HEADER.length());
 885             // Check to see if the expected bytes were read
 886             byte[] result = Arrays.copyOfRange(buf.array(), 0, bytesRead);
 887             assertEquals(GRAND_SLAMS.getBytes(UTF_8), result);
 888         }
 889         Files.deleteIfExists(zipFile);
 890     }
 891 
 892     /**
 893      * Validate FileChannel::read  can be used with a ByteBuffer array to
 894      * read an entry from a Zip file
 895      *
 896      * @param env         Zip FS properties to use when creating the Zip file
 897      * @param compression The compression used when writing the entries
 898      * @throws Exception If an error occurs
 899      */
 900     @Test(dataProvider = &quot;zipfsMap&quot;)
 901     public void fcReadArrayTest(final Map&lt;String, String&gt; env,
 902                                 final int compression) throws Exception {
 903         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 904         Files.deleteIfExists(zipFile);
 905         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 906         zip(zipFile, env, e0);
 907         // Create the ByteBuffer array that will be updated
 908         ByteBuffer[] bb = {
 909                 ByteBuffer.allocate(GRAND_SLAMS_HEADER.length()),
 910                 ByteBuffer.allocate(AUSTRALIAN_OPEN.length()),
 911                 ByteBuffer.allocate(FRENCH_OPEN.length()),
 912                 ByteBuffer.allocate(WIMBLEDON.length()),
 913                 ByteBuffer.allocate(US_OPEN.length()),
 914         };
 915         // Read an entry with a ByteBuffer array
 916         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 917              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 918                      Set.of(READ))) {
 919             fc.read(bb);
 920             // Convert the ByteBuffer array into a single byte array
 921             ByteArrayOutputStream bos = new ByteArrayOutputStream();
 922             for (ByteBuffer b : bb) {
 923                 bos.write(b.array());
 924             }
 925             // Check to see if the returned byte array is what is expected
 926             assertEquals(e0.bytes, bos.toByteArray());
 927         }
 928         Files.deleteIfExists(zipFile);
 929     }
 930 
 931     /**
 932      * Validate FileChannel::read can be used to update specific offset(s)
 933      * of a ByteBuffer array when reading a Zip entry
 934      *
 935      * @param env         Zip FS properties to use when creating the Zip file
 936      * @param compression The compression used when writing the entries
 937      * @throws Exception If an error occurs
 938      */
 939     @Test(dataProvider = &quot;zipfsMap&quot;)
 940     public void fcReadArrayWithOffsetTest(final Map&lt;String, String&gt; env,
 941                                           final int compression) throws Exception {
 942         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
 943         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 944         Files.deleteIfExists(zipFile);
 945         zip(zipFile, env, e0);
 946         // Initial values that will be replaced by the AUSTRALIAN_OPEN and FRENCH_OPEN
 947         // values via FileChannel::read
 948         String newValue = &quot;Homeward Bound!&quot; + System.lineSeparator();
 949         String newValue2 = &quot;Sybase Open&quot; + System.lineSeparator();
 950         // Create the ByteBuffer array that will be updated
 951         ByteBuffer[] bb = {
 952                 ByteBuffer.wrap((newValue)
 953                         .getBytes(UTF_8)),
 954                 ByteBuffer.wrap((newValue2)
 955                         .getBytes(UTF_8)),
 956                 ByteBuffer.wrap((WIMBLEDON)
 957                         .getBytes(UTF_8)),
 958                 ByteBuffer.wrap((US_OPEN)
 959                         .getBytes(UTF_8))
 960         };
 961         // Read the Zip entry replacing the data in offset 0 and 1
 962         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
 963              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
 964                      Set.of(READ))) {
 965             fc.position(GRAND_SLAMS_HEADER.length());
 966             fc.read(bb, 0, 2);
 967         }
 968         // Convert the ByteBuffer array into a single byte array
 969         ByteArrayOutputStream bos = new ByteArrayOutputStream();
 970         for (ByteBuffer b : bb) {
 971             bos.write(b.array());
 972         }
 973         // Check to see if the returned byte array is what is expected
 974         assertEquals(GRAND_SLAMS.getBytes(UTF_8), bos.toByteArray());
 975         Files.deleteIfExists(zipFile);
 976     }
 977 
 978     /**
 979      * Validate FileChannel::transferTo can be used to copy an OS file to
 980      * a Zip file
 981      *
 982      * @param env         Zip FS properties to use when creating the Zip file
 983      * @param compression The compression used when writing the entries
 984      * @throws Exception If an error occurs
 985      */
 986     @Test(dataProvider = &quot;zipfsMap&quot;)
 987     public void fcTransferToZipTest(final Map&lt;String, String&gt; env,
 988                                     final int compression) throws Exception {
 989         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
 990         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
 991         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
 992         Files.deleteIfExists(osFile);
 993         Files.deleteIfExists(zipFile);
 994         Files.writeString(osFile, THE_SLAMS);
 995         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
 996             fcTransferTo(osFile, zipfs.getPath(e00.name));
 997         }
 998         // Verify the entry was copied
 999         verify(zipFile, e00);
1000         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1001         Files.deleteIfExists(osFile);
1002         Files.deleteIfExists(zipFile);
1003     }
1004 
1005     /**
1006      * Validate FileChannel::transferTo can be used to copy a Zip entry to
1007      * an OS File
1008      *
1009      * @param env         Zip FS properties to use when creating the Zip file
1010      * @param compression The compression used when writing the entries
1011      * @throws Exception If an error occurs
1012      */
1013     @Test(dataProvider = &quot;zipfsMap&quot;)
1014     public void fcTransferToOsTest(final Map&lt;String, String&gt; env,
1015                                    final int compression) throws Exception {
1016         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
1017         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
1018         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1019         Files.deleteIfExists(osFile);
1020         Files.deleteIfExists(zipFile);
1021         zip(zipFile, env, e00);
1022         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
1023             fcTransferTo(zipfs.getPath(e00.name), osFile);
1024         }
1025         // Verify the entry was copied
1026         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1027         Files.deleteIfExists(osFile);
1028         Files.deleteIfExists(zipFile);
1029     }
1030 
1031     /**
1032      * Validate FileChannel::transferTo can be used to copy a Zip entry to
1033      * another Zip file
1034      *
1035      * @param env         Zip FS properties to use when creating the Zip file
1036      * @param compression The compression used when writing the entries
1037      * @throws Exception If an error occurs
1038      */
1039     @Test(dataProvider = &quot;zipfsMap&quot;)
1040     public void fcTransferToZipToZipTest(final Map&lt;String, String&gt; env,
1041                                          final int compression) throws Exception {
1042         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1043         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
1044         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1045         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1046         Files.deleteIfExists(zipFile);
1047         Files.deleteIfExists(zipFile2);
1048         zip(zipFile, env, e0, e1);
1049         verify(zipFile, e0, e1);
1050         // Copy entries from one Zip file to another using FileChannel
1051         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1052              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
1053             fcTransferTo(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
1054             fcTransferTo(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
1055         }
1056         // Check to see if the entries match
1057         verify(zipFile2, e0, e1);
1058         Files.deleteIfExists(zipFile);
1059         Files.deleteIfExists(zipFile2);
1060     }
1061 
1062     /**
1063      * Validate FileChannel::transferFrom can be used to copy an OS File to
1064      * a Zip entry
1065      *
1066      * @param env         Zip FS properties to use when creating the Zip file
1067      * @param compression The compression used when writing the entries
1068      * @throws Exception If an error occurs
1069      */
1070     @Test(dataProvider = &quot;zipfsMap&quot;)
1071     public void fcTransferFromOsTest(final Map&lt;String, String&gt; env,
1072                                      final int compression) throws Exception {
1073         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
1074         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
1075         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1076         Files.deleteIfExists(osFile);
1077         Files.deleteIfExists(zipFile);
1078         Files.writeString(osFile, THE_SLAMS);
1079         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
1080             fcTransferFrom(osFile, zipfs.getPath(e00.name));
1081         }
1082         // Verify the entry was copied
1083         zip(zipFile, env, e00);
1084         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1085         Files.deleteIfExists(osFile);
1086         Files.deleteIfExists(zipFile);
1087     }
1088 
1089     /**
1090      * Validate FileChannel::transferFrom can be used to copy a Zip entry to
1091      * an OS File
1092      *
1093      * @param env         Zip FS properties to use when creating the Zip file
1094      * @param compression The compression used when writing the entries
1095      * @throws Exception If an error occurs
1096      */
1097     @Test(dataProvider = &quot;zipfsMap&quot;)
1098     public void fcTransferFromZipTest(final Map&lt;String, String&gt; env,
1099                                       final int compression) throws Exception {
1100         Entry e00 = Entry.of(&quot;Entry-00&quot;, compression, THE_SLAMS);
1101         Path osFile = generatePath(HERE, &quot;test&quot;, &quot;.txt&quot;);
1102         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1103         Files.deleteIfExists(osFile);
1104         Files.deleteIfExists(zipFile);
1105         zip(zipFile, env, e00);
1106         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env)) {
1107             fcTransferFrom(zipfs.getPath(e00.name), osFile);
1108         }
1109         // Verify the bytes match
1110         assertEquals(Files.readAllBytes(osFile), e00.bytes);
1111         Files.deleteIfExists(osFile);
1112         Files.deleteIfExists(zipFile);
1113     }
1114 
1115     /**
1116      * Validate FileChannel::transferFrom can be used to copy a Zip entry
1117      * to another Zip file
1118      *
1119      * @param env         Zip FS properties to use when creating the Zip file
1120      * @param compression The compression used when writing the entries
1121      * @throws Exception If an error occurs
1122      */
1123     @Test(dataProvider = &quot;zipfsMap&quot;)
1124     public void fcTransferFromZipToZipTest(final Map&lt;String, String&gt; env,
1125                                            final int compression) throws Exception {
1126         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1127         Entry e1 = Entry.of(&quot;Entry-1&quot;, compression, FIFTH_MAJOR);
1128         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1129         Path zipFile2 = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1130         Files.deleteIfExists(zipFile);
1131         Files.deleteIfExists(zipFile2);
1132         zip(zipFile, env, e0, e1);
1133         verify(zipFile, e0, e1);
1134         // Copy entries from one Zip file to another using FileChannel
1135         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1136              FileSystem zipfs2 = FileSystems.newFileSystem(zipFile2, env)) {
1137             fcTransferFrom(zipfs.getPath(e0.name), zipfs2.getPath(e0.name));
1138             fcTransferFrom(zipfs.getPath(e1.name), zipfs2.getPath(e1.name));
1139         }
1140         // Check to see if the entries match
1141         verify(zipFile2, e0, e1);
1142         Files.deleteIfExists(zipFile);
1143         Files.deleteIfExists(zipFile2);
1144     }
1145 
1146     /**
1147      * Validate FileChannel::write can be used to create a Zip entry
1148      *
1149      * @param env         Zip FS properties to use when creating the Zip file
1150      * @param compression The compression used when writing the entries
1151      * @throws Exception If an error occurs
1152      */
1153     @Test(dataProvider = &quot;zipfsMap&quot;)
1154     public void fcWriteTest(final Map&lt;String, String&gt; env,
1155                             final int compression) throws Exception {
1156         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1157         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1158         Files.deleteIfExists(zipFile);
1159         // Create the Zip entry
1160         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1161              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1162                      Set.of(CREATE, WRITE))) {
1163             ByteBuffer bb = ByteBuffer.wrap(THE_SLAMS.getBytes(UTF_8));
1164             fc.write(bb);
1165         }
1166         // Verify the entry was updated
1167         verify(zipFile, e0);
1168         Files.deleteIfExists(zipFile);
1169     }
1170 
1171     /**
1172      * Validate FileChannel::write can be used to update a Zip entry
1173      * when specifying a starting position
1174      *
1175      * @param env         Zip FS properties to use when creating the Zip file
1176      * @param compression The compression used when writing the entries
1177      * @throws Exception If an error occurs
1178      */
1179     @Test(dataProvider = &quot;zipfsMap&quot;)
1180     public void fcWritePosTest(final Map&lt;String, String&gt; env,
1181                                final int compression) throws Exception {
1182         // Use this value to replace the value specified for AUSTRALIAN_OPEN
1183         String NewValue = &quot;Homeward Bound!&quot; + System.lineSeparator();
1184         // Expected results after updating the file
1185         String updatedFile = GRAND_SLAMS_HEADER
1186                 + NewValue
1187                 + FRENCH_OPEN
1188                 + WIMBLEDON
1189                 + US_OPEN;
1190         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1191         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1192         Files.deleteIfExists(zipFile);
1193         zip(zipFile, env, e0);
1194         // Update the Zip entry at the specified position
1195         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1196              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1197                      Set.of(READ, WRITE))) {
1198             ByteBuffer bb = ByteBuffer.wrap(NewValue.getBytes(UTF_8));
1199             fc.write(bb, GRAND_SLAMS_HEADER.length());
1200         }
1201         // Verify the entry was updated
1202         verify(zipFile, e0.content(updatedFile));
1203         Files.deleteIfExists(zipFile);
1204     }
1205 
1206     /**
1207      * Validate FileChannel::write using a ByteBuffer array
1208      * can be used to create a Zip entry
1209      *
1210      * @param env         Zip FS properties to use when creating the Zip file
1211      * @param compression The compression used when writing the entries
1212      * @throws Exception If an error occurs
1213      */
1214     @Test(dataProvider = &quot;zipfsMap&quot;)
1215     public void fcWriteArrayTest(final Map&lt;String, String&gt; env,
1216                                  final int compression) throws Exception {
1217         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1218         Files.deleteIfExists(zipFile);
1219         // Entry added to the Zip file
1220         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, GRAND_SLAMS);
1221         // Create the ByteBuffer array that will be used to create the Zip entry
1222         ByteBuffer[] bb = {
1223                 ByteBuffer.wrap(AUSTRALIAN_OPEN.getBytes(UTF_8)),
1224                 ByteBuffer.wrap(FRENCH_OPEN.getBytes(UTF_8)),
1225                 ByteBuffer.wrap(WIMBLEDON.getBytes(UTF_8)),
1226                 ByteBuffer.wrap(US_OPEN.getBytes(UTF_8))
1227         };
1228         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1229              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1230                      Set.of(CREATE, WRITE))) {
1231             fc.write(bb);
1232             assertEquals(fc.size(), GRAND_SLAMS.length());
1233         }
1234         // Verify the entry was created
1235         verify(zipFile, e0);
1236         Files.deleteIfExists(zipFile);
1237     }
1238 
1239     /**
1240      * Validate FileChannel::write specifying a ByteBuffer array
1241      *  with an offset can be used to create a Zip entry
1242      *
1243      * @param env         Zip FS properties to use when creating the Zip file
1244      * @param compression The compression used when writing the entries
1245      * @throws Exception If an error occurs
1246      */
1247     @Test(dataProvider = &quot;zipfsMap&quot;)
1248     public void fcWriteArrayWithOffsetTest(final Map&lt;String, String&gt; env,
1249                                            final int compression) throws Exception {
1250 
1251         // Use this value to replace the value specified for AUSTRALIAN_OPEN
1252         String newValue = &quot;Homeward Bound!&quot; + System.lineSeparator();
1253         // Use this value to replace the value specified for FRENCH_OPEN
1254         String newValue2 = &quot;Sybase Open&quot; + System.lineSeparator();
1255         // Expected results after updating the file
1256         String updatedFile = GRAND_SLAMS_HEADER
1257                 + newValue
1258                 + newValue2
1259                 + WIMBLEDON
1260                 + US_OPEN;
1261         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1262         Files.deleteIfExists(zipFile);
1263         // Initial Zip entry
1264         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1265         zip(zipFile, env, e0);
1266         // Create the ByteBuffer array that will be used to update the Zip entry
1267         ByteBuffer[] bb = {
1268                 ByteBuffer.wrap(newValue.getBytes(UTF_8)),
1269                 ByteBuffer.wrap(newValue2.getBytes(UTF_8)),
1270                 ByteBuffer.wrap(&quot;!!!Should not Write!!!!&quot;.getBytes(UTF_8))
1271         };
1272         // Move to the file position and then write the updates to the file
1273         // specifying the ByteBuffer offset &amp; length
1274         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1275              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1276                      Set.of(CREATE, WRITE))) {
1277             // Skip past the header
1278             fc.position(GRAND_SLAMS_HEADER.length());
1279             // Replace the original values
1280             fc.write(bb, 0, 2);
1281             assertEquals(fc.size(), THE_SLAMS.length());
1282         }
1283         // Verify the entry was updated
1284         verify(zipFile, e0.content(updatedFile));
1285         Files.deleteIfExists(zipFile);
1286     }
1287 
1288     /**
1289      * Validate FileChannel::force can be used when writing a Zip entry
1290      *
1291      * @param env         Zip FS properties to use when creating the Zip file
1292      * @param compression The compression used when writing the entries
1293      * @throws Exception If an error occurs
1294      */
1295     @Test(dataProvider = &quot;zipfsMap&quot;)
1296     public void fcForceWriteTest(final Map&lt;String, String&gt; env,
1297                             final int compression) throws Exception {
1298         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1299         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1300         Files.deleteIfExists(zipFile);
1301         // Check that no errors occur when using FileChannel::force
1302         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1303              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name),
1304                      Set.of(CREATE, WRITE))) {
1305             fc.force(false);
1306             fc.write(ByteBuffer.wrap(GRAND_SLAMS_HEADER.getBytes(UTF_8)));
1307             fc.force(true);
1308             fc.write(ByteBuffer.wrap(GRAND_SLAMS.getBytes(UTF_8)));
1309         }
1310         // Verify the entry was updated
1311         verify(zipFile, e0);
1312         Files.deleteIfExists(zipFile);
1313     }
1314 
1315     /**
1316      * Validate FileChannel::position returns the expected position
1317      *
1318      * @param env         Zip FS properties to use when creating the Zip file
1319      * @param compression The compression used when writing the entries
1320      * @throws Exception If an error occurs
1321      */
1322     @Test(dataProvider = &quot;zipfsMap&quot;)
1323     public void fcPositionTest(final Map&lt;String, String&gt; env,
1324                                 final int compression) throws Exception {
1325         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1326         Files.deleteIfExists(zipFile);
1327         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1328         zip(zipFile, env, e0);
1329         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1330              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ))) {
1331             int fSize = (int) fc.size();
1332             // Specify the seed to use
1333             int seed = fSize + 10;
1334             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
1335             fc.read(bb);
1336             for (var i = 0; i &lt; fSize; i++) {
1337                 long pos = RANDOM.nextInt(seed);
1338                 fc.position(pos);
1339                 assertEquals(fc.position(), pos);
1340             }
1341         }
1342         Files.deleteIfExists(zipFile);
1343     }
1344 
1345     /**
1346      * Validate FileChannel::size can be used to obtain the size of a Zip entry
1347      *
1348      * @param env         Zip FS properties to use when creating the Zip file
1349      * @param compression The compression used when writing the entries
1350      * @throws Exception If an error occurs
1351      */
1352     @Test(dataProvider = &quot;zipfsMap&quot;)
1353     public void fcSizeTest(final Map&lt;String, String&gt; env,
1354                            final int compression) throws Exception {
1355         Path osFile = Path.of(&quot;GrandSlams.txt&quot;);
1356         Files.deleteIfExists(osFile);
1357         Files.writeString(osFile, THE_SLAMS);
1358         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1359         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1360         Files.deleteIfExists(zipFile);
1361         zip(zipFile, env, e0);
1362         // Validate the file sizes match
1363         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1364              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name))) {
1365             assertEquals(fc.size(), THE_SLAMS.length());
1366         }
1367         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1368              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ))) {
1369             assertEquals(fc.size(), THE_SLAMS.length());
1370         }
1371         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1372              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
1373             assertEquals(fc.size(), THE_SLAMS.length());
1374         }
1375         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1376              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(WRITE))) {
1377             assertEquals(fc.size(), THE_SLAMS.length());
1378         }
1379         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1380              FileChannel fc = FileChannel.open(zipfs.getPath(e0.name), Set.of(APPEND))) {
1381             assertEquals(fc.size(), THE_SLAMS.length());
1382         }
1383         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1384              FileChannel fc = FileChannel.open(zipfs.getPath(&quot;Entry-01&quot;),
1385                      Set.of(CREATE, WRITE))) {
1386             fc.write(ByteBuffer.wrap(FIFTH_MAJOR.getBytes(UTF_8)));
1387             assertEquals(fc.size(), FIFTH_MAJOR.length());
1388         }
1389         Files.deleteIfExists(zipFile);
1390         Files.deleteIfExists(osFile);
1391     }
1392 
1393     /**
1394      * Validate FileChannel::lock returns a valid lock
1395      *
1396      * @param env         Zip FS properties to use when creating the Zip file
1397      * @param compression The compression used when writing the entries
1398      * @throws Exception If an error occurs
1399      */
1400     @Test(dataProvider = &quot;zipfsMap&quot;)
1401     public void fcLockTest(final Map&lt;String, String&gt; env,
1402                            final int compression) throws Exception {
1403         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1404         Files.deleteIfExists(zipFile);
1405         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1406         zip(zipFile, env, e0);
1407         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1408              FileChannel in = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
1409             FileLock lock = in.lock();
1410             assertNotNull(lock);
1411             assertTrue(lock.isValid());
1412             lock.close();
1413             assertFalse(lock.isValid());
1414             // Acquire another lock specifying an offset and size
1415             lock = in.lock(0, 10, false);
1416             assertNotNull(lock);
1417             assertTrue(lock.isValid());
1418             lock.close();
1419             assertFalse(lock.isValid());
1420         }
1421         Files.deleteIfExists(zipFile);
1422     }
1423 
1424     /**
1425      * Validate FileChannel::tryLock returns a valid lock
1426      *
1427      * @param env         Zip FS properties to use when creating the Zip file
1428      * @param compression The compression used when writing the entries
1429      * @throws Exception If an error occurs
1430      */
1431     @Test(dataProvider = &quot;zipfsMap&quot;)
1432     public void fcTryLockTest(final Map&lt;String, String&gt; env,
1433                               final int compression) throws Exception {
1434         Path zipFile = generatePath(HERE, &quot;test&quot;, &quot;.zip&quot;);
1435         Files.deleteIfExists(zipFile);
1436         Entry e0 = Entry.of(&quot;Entry-0&quot;, compression, THE_SLAMS);
1437         zip(zipFile, env, e0);
1438         try (FileSystem zipfs = FileSystems.newFileSystem(zipFile, env);
1439              FileChannel in = FileChannel.open(zipfs.getPath(e0.name), Set.of(READ, WRITE))) {
1440             FileLock lock = in.tryLock();
1441             assertNotNull(lock);
1442             assertTrue(lock.isValid());
1443             lock.close();
1444             assertFalse(lock.isValid());
1445             // Acquire another lock specifying an offset and size
1446             lock = in.tryLock(0, 10, false);
1447             assertNotNull(lock);
1448             assertTrue(lock.isValid());
1449             lock.close();
1450             assertFalse(lock.isValid());
1451         }
1452         Files.deleteIfExists(zipFile);
1453     }
1454 
1455     /**
1456      * Use a SeekableByteChannel to copy an entry from one file to another
1457      *
1458      * @param src Path of file to read from
1459      * @param dst Path of file to write to
1460      * @throws IOException if an error occurs
1461      */
1462     private static void sbcCopy(Path src, Path dst) throws IOException {
1463         try (SeekableByteChannel in = Files.newByteChannel(src, Set.of(READ));
1464              SeekableByteChannel out = Files.newByteChannel(dst,
1465                      Set.of(CREATE_NEW, WRITE))) {
1466             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
1467             while (in.read(bb) &gt;= 0) {
1468                 bb.flip();
1469                 out.write(bb);
1470                 bb.clear();
1471             }
1472         }
1473     }
1474 
1475     /**
1476      * Use a FileChannel to copy an entry from one file to another
1477      *
1478      * @param src Path of file to read from
1479      * @param dst Path of file to write to
1480      * @throws IOException if an error occurs
1481      */
1482     private static void fcCopy(Path src, Path dst) throws IOException {
1483         try (FileChannel srcFc = FileChannel.open(src, Set.of(READ));
1484              FileChannel dstFc = FileChannel.open(dst, Set.of(CREATE_NEW, WRITE))) {
1485             ByteBuffer bb = ByteBuffer.allocate(BYTEBUFFER_SIZE);
1486             while (srcFc.read(bb) &gt;= 0) {
1487                 bb.flip();
1488                 dstFc.write(bb);
1489                 bb.clear();
1490             }
1491         }
1492     }
1493 
1494     /**
1495      * Use FileChannel::transferTo to copy an entry from one file to another
1496      *
1497      * @param src Path of file to read from
1498      * @param dst Path of file to write to
1499      * @throws IOException if an error occurs
1500      */
1501     private static void fcTransferTo(Path src, Path dst) throws IOException {
1502         try (FileChannel in = FileChannel.open(src, Set.of(READ));
1503              FileChannel out = FileChannel.open(dst, Set.of(CREATE_NEW, WRITE))) {
1504             in.transferTo(0, in.size(), out);
1505         }
1506     }
1507 
1508     /**
1509      * Use FileChannel::transferFrom to copy an entry from one file to another
1510      *
1511      * @param from Path of file to read from
1512      * @param to   Path of file to write to
1513      * @throws IOException if an error occurs
1514      */
1515     private static void fcTransferFrom(Path from, Path to) throws IOException {
1516         try (FileChannel in = FileChannel.open(from, Set.of(READ));
1517              FileChannel out = FileChannel.open(to, Set.of(CREATE_NEW, WRITE))) {
1518             out.transferFrom(in, 0, in.size());
1519         }
1520     }
1521 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old test/jdk/java/net/httpclient/http2/server/Http2TestServerConnection.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 import java.io.BufferedInputStream;
  25 import java.io.BufferedOutputStream;
  26 import java.io.Closeable;
  27 import java.io.IOException;
  28 import java.io.UncheckedIOException;
  29 import java.io.InputStream;
  30 import java.io.OutputStream;
  31 import java.net.Socket;
  32 import java.net.URI;
  33 import java.net.InetAddress;
  34 import javax.net.ssl.*;
  35 import java.net.URISyntaxException;
  36 import java.net.http.HttpHeaders;
  37 import java.nio.ByteBuffer;
  38 import java.util.*;
  39 import java.util.concurrent.CompletableFuture;
  40 import java.util.concurrent.ExecutorService;
  41 import java.util.concurrent.ConcurrentLinkedQueue;
  42 import java.util.function.Consumer;
  43 import jdk.internal.net.http.common.HttpHeadersBuilder;
  44 import jdk.internal.net.http.frame.*;
  45 import jdk.internal.net.http.hpack.Decoder;
  46 import jdk.internal.net.http.hpack.DecodingCallback;
  47 import jdk.internal.net.http.hpack.Encoder;
  48 import sun.net.www.http.ChunkedInputStream;
  49 import sun.net.www.http.HttpClient;
  50 import static jdk.internal.net.http.frame.SettingsFrame.HEADER_TABLE_SIZE;
  51 
  52 /**
  53  * Represents one HTTP2 connection, either plaintext upgraded from HTTP/1.1
  54  * or HTTPS opened using &quot;h2&quot; ALPN.
  55  */
  56 public class Http2TestServerConnection {
  57     final Http2TestServer server;
  58     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
  59     final Map&lt;Integer, Queue&gt; streams; // input q per stream
  60     final Map&lt;Integer, BodyOutputStream&gt; outStreams; // output q per stream
  61     final HashSet&lt;Integer&gt; pushStreams;
  62     final Queue&lt;Http2Frame&gt; outputQ;
  63     volatile int nextstream;
  64     final Socket socket;
  65     final Http2TestExchangeSupplier exchangeSupplier;
  66     final InputStream is;
  67     final OutputStream os;
  68     volatile Encoder hpackOut;
  69     volatile Decoder hpackIn;
  70     volatile SettingsFrame clientSettings;
  71     final SettingsFrame serverSettings;
  72     final ExecutorService exec;
  73     final boolean secure;
  74     final Properties properties;
  75     volatile boolean stopping;
  76     volatile int nextPushStreamId = 2;
  77     ConcurrentLinkedQueue&lt;PingRequest&gt; pings = new ConcurrentLinkedQueue&lt;&gt;();
  78 
  79     final static ByteBuffer EMPTY_BUFFER = ByteBuffer.allocate(0);
  80     final static byte[] EMPTY_BARRAY = new byte[0];
  81     final Random random;
  82 
  83     final static byte[] clientPreface = &quot;PRI * HTTP/2.0\r\n\r\nSM\r\n\r\n&quot;.getBytes();
  84 
  85     static class Sentinel extends Http2Frame {
  86         Sentinel() { super(-1,-1);}
  87     }
  88 
  89     static final Sentinel sentinel = new Sentinel();
  90 
  91     class PingRequest {
  92         final byte[] pingData;
  93         final long pingStamp;
  94         final CompletableFuture&lt;Long&gt; response;
  95 
  96         PingRequest() {
  97             pingData = new byte[8];
  98             random.nextBytes(pingData);
  99             pingStamp = System.currentTimeMillis();
 100             response = new CompletableFuture&lt;&gt;();
 101         }
 102 
 103         PingFrame frame() {
 104             return new PingFrame(0, pingData);
 105         }
 106 
 107         CompletableFuture&lt;Long&gt; response() {
 108             return response;
 109         }
 110 
 111         void success() {
 112             response.complete(System.currentTimeMillis() - pingStamp);
 113         }
 114 
 115         void fail(Throwable t) {
 116             response.completeExceptionally(t);
 117         }
 118     }
 119 
 120     Http2TestServerConnection(Http2TestServer server,
 121                               Socket socket,
 122                               Http2TestExchangeSupplier exchangeSupplier,
 123                               Properties properties)
 124         throws IOException
 125     {
 126         if (socket instanceof SSLSocket) {
 127             handshake(server.serverName(), (SSLSocket)socket);
 128         }
 129         System.err.println(&quot;TestServer: New connection from &quot; + socket);
 130         this.server = server;
 131         this.exchangeSupplier = exchangeSupplier;
 132         this.streams = Collections.synchronizedMap(new HashMap&lt;&gt;());
 133         this.outStreams = Collections.synchronizedMap(new HashMap&lt;&gt;());
 134         this.outputQ = new Queue&lt;&gt;(sentinel);
 135         this.random = new Random();
 136         this.socket = socket;
 137         this.properties = properties;
 138         this.socket.setTcpNoDelay(true);
 139         this.serverSettings = getServerSettingProperties();
 140         this.exec = server.exec;
 141         this.secure = server.secure;
 142         this.pushStreams = new HashSet&lt;&gt;();
 143         is = new BufferedInputStream(socket.getInputStream());
 144         os = new BufferedOutputStream(socket.getOutputStream());
 145     }
 146 
 147     static final String propPrefix = &quot;http2server.settings.&quot;;
 148 
 149     static final String[][] propIDs = {
 150         {&quot;header_table_size&quot;, Integer.toString(SettingsFrame.HEADER_TABLE_SIZE)},
 151         {&quot;enable_push&quot;, Integer.toString(SettingsFrame.ENABLE_PUSH)},
 152         {&quot;max_concurrent_streams&quot;, Integer.toString(SettingsFrame.MAX_CONCURRENT_STREAMS)},
 153         {&quot;initial_window_size&quot;, Integer.toString(SettingsFrame.INITIAL_WINDOW_SIZE)},
 154         {&quot;max_frame_size&quot;, Integer.toString(SettingsFrame.MAX_FRAME_SIZE)},
 155         {&quot;max_header_list_size&quot;, Integer.toString(SettingsFrame.MAX_HEADER_LIST_SIZE)}
 156     };
 157 
 158     private SettingsFrame getServerSettingProperties() {
 159         SettingsFrame s = SettingsFrame.defaultRFCSettings();
 160         if (properties == null)
 161             return s;
 162         for (int i=0; i&lt;propIDs.length; i++) {
 163             String key = propIDs[i][0];
 164             String numS = propIDs[i][1];
 165             String prop = properties.getProperty(propPrefix + key);
 166             if (prop != null) {
 167                 try {
 168                     System.err.println(&quot;TestServer: setting &quot; + key + &quot; property to: &quot; +
 169                         prop);
 170                     int num = Integer.parseInt(numS);
 171                     System.err.println(&quot;TestServer: num = &quot; + num);
 172                     s.setParameter(num, Integer.parseInt(prop));
 173                 } catch (NumberFormatException e) {/* ignore errors */}
 174             }
 175         }
 176         return s;
 177     }
 178 
 179     /**
 180      * Sends a PING frame on this connection, and completes the returned
 181      * CF when the PING ack is received. The CF is given
 182      * an integer, whose value is the number of milliseconds
 183      * between PING and ACK.
 184      */
 185     CompletableFuture&lt;Long&gt; sendPing() {
 186         PingRequest ping = null;
 187         try {
 188             ping = new PingRequest();
 189             pings.add(ping);
 190             outputQ.put(ping.frame());
 191         } catch (Throwable t) {
 192             ping.fail(t);
 193         }
 194         return ping.response();
 195     }
 196 
 197     void goAway(int error) throws IOException {
 198         int laststream = nextstream &gt;= 3 ? nextstream - 2 : 1;
 199 
 200         GoAwayFrame go = new GoAwayFrame(laststream, error);
 201         outputQ.put(go);
 202     }
 203 
 204     /**
 205      * Returns the first PingRequest from Queue
 206      */
 207     private PingRequest getNextRequest() {
 208         return pings.poll();
 209     }
 210 
 211     /**
 212      * Handles incoming Ping, which could be an ack
 213      * or a client originated Ping
 214      */
 215     void handlePing(PingFrame ping) throws IOException {
 216         if (ping.streamid() != 0) {
 217             System.err.println(&quot;Invalid ping received&quot;);
 218             close(ErrorFrame.PROTOCOL_ERROR);
 219             return;
 220         }
 221         if (ping.getFlag(PingFrame.ACK)) {
 222             // did we send a Ping?
 223             PingRequest request = getNextRequest();
 224             if (request == null) {
 225                 System.err.println(&quot;Invalid ping ACK received&quot;);
 226                 close(ErrorFrame.PROTOCOL_ERROR);
 227                 return;
 228             } else if (!Arrays.equals(request.pingData, ping.getData())) {
 229                 request.fail(new RuntimeException(&quot;Wrong ping data in ACK&quot;));
 230             } else {
 231                 request.success();
 232             }
 233         } else {
 234             // client originated PING. Just send it back with ACK set
 235             ping.setFlag(PingFrame.ACK);
 236             outputQ.put(ping);
 237         }
 238     }
 239 
 240     private static boolean compareIPAddrs(InetAddress addr1, String host) {
 241         try {
 242             InetAddress addr2 = InetAddress.getByName(host);
 243             return addr1.equals(addr2);
 244         } catch (IOException e) {
 245             throw new UncheckedIOException(e);
 246         }
 247     }
 248 
 249     private static void handshake(String name, SSLSocket sock) throws IOException {
 250         if (name == null) {
 251             // no name set. No need to check
 252             return;
 253         } else if (name.equals(&quot;localhost&quot;)) {
 254             name = &quot;localhost&quot;;
 255         }
 256         final String fname = name;
 257         final InetAddress addr1 = InetAddress.getByName(name);
 258         SSLParameters params = sock.getSSLParameters();
 259         SNIMatcher matcher = new SNIMatcher(StandardConstants.SNI_HOST_NAME) {
 260             public boolean matches (SNIServerName n) {
 261                 String host = ((SNIHostName)n).getAsciiName();
 262                 if (host.equals(&quot;localhost&quot;))
 263                     host = &quot;localhost&quot;;
 264                 boolean cmp = host.equalsIgnoreCase(fname);
 265                 if (cmp)
 266                     return true;
 267                 return compareIPAddrs(addr1, host);
 268             }
 269         };
 270         List&lt;SNIMatcher&gt; list = List.of(matcher);
 271         params.setSNIMatchers(list);
 272         sock.setSSLParameters(params);
 273         sock.getSession(); // blocks until handshake done
 274     }
 275 
 276     void closeIncoming() {
 277         close(-1);
 278     }
 279 
 280     void close(int error) {
 281         if (stopping)
 282             return;
 283         stopping = true;
 284         System.err.printf(&quot;Server connection to %s stopping. %d streams\n&quot;,
 285             socket.getRemoteSocketAddress().toString(), streams.size());
 286         streams.forEach((i, q) -&gt; {
 287             q.orderlyClose();
 288         });
 289         try {
 290             if (error != -1)
 291                 goAway(error);
 292             outputQ.orderlyClose();
 293             socket.close();
 294         } catch (Exception e) {
 295         }
 296     }
 297 
 298     private void readPreface() throws IOException {
 299         int len = clientPreface.length;
 300         byte[] bytes = new byte[len];
 301         is.readNBytes(bytes, 0, len);
 302         if (Arrays.compare(clientPreface, bytes) != 0) {
 303             throw new IOException(&quot;Invalid preface: &quot; + new String(bytes, 0, len));
 304         }
 305     }
 306 
 307     Http1InitialRequest doUpgrade() throws IOException {
 308         Http1InitialRequest upgrade = readHttp1Request();
 309         String h2c = getHeader(upgrade.headers, &quot;Upgrade&quot;);
 310         if (h2c == null || !h2c.equals(&quot;h2c&quot;)) {
 311             System.err.println(&quot;Server:HEADERS: &quot; + upgrade);
 312             throw new IOException(&quot;Bad upgrade 1 &quot; + h2c);
 313         }
 314 
 315         sendHttp1Response(101, &quot;Switching Protocols&quot;, &quot;Connection&quot;, &quot;Upgrade&quot;,
 316                 &quot;Upgrade&quot;, &quot;h2c&quot;);
 317 
 318         sendSettingsFrame();
 319         readPreface();
 320 
 321         String clientSettingsString = getHeader(upgrade.headers, &quot;HTTP2-Settings&quot;);
 322         clientSettings = getSettingsFromString(clientSettingsString);
 323 
 324         return upgrade;
 325     }
 326 
 327     /**
 328      * Decodes the given, Client, settings payload provided in base64 HTTP1
 329      * header value.
 330      */
 331     private SettingsFrame getSettingsFromString(String s) throws IOException {
 332         Base64.Decoder decoder = Base64.getUrlDecoder();
 333         byte[] payload = decoder.decode(s);
 334         ByteBuffer bb1 = ByteBuffer.wrap(payload);
 335         // simulate header of Settings Frame
 336         ByteBuffer bb0 = ByteBuffer.wrap(
 337                 new byte[] {0, 0, (byte)payload.length, 4, 0, 0, 0, 0, 0});
 338         List&lt;Http2Frame&gt; frames = new ArrayList&lt;&gt;();
 339         FramesDecoder reader = new FramesDecoder(frames::add);
 340         reader.decode(bb0);
 341         reader.decode(bb1);
 342         if (frames.size()!=1)
 343             throw new IOException(&quot;Expected 1 frame got &quot;+frames.size()) ;
 344         Http2Frame frame = frames.get(0);
 345         if (!(frame instanceof SettingsFrame))
 346             throw new IOException(&quot;Expected SettingsFrame&quot;);
 347         return (SettingsFrame)frame;
 348     }
 349 
 350     public int getMaxFrameSize() {
 351         return clientSettings.getParameter(SettingsFrame.MAX_FRAME_SIZE);
 352     }
 353 
 354     void run() throws Exception {
 355         Http1InitialRequest upgrade = null;
 356         if (!secure) {
 357             upgrade = doUpgrade();
 358         } else {
 359             readPreface();
 360             sendSettingsFrame(true);
 361             clientSettings = (SettingsFrame) readFrame();
 362             if (clientSettings.getFlag(SettingsFrame.ACK)) {
 363                 // we received the ack to our frame first
 364                 clientSettings = (SettingsFrame) readFrame();
 365             }
 366             nextstream = 1;
 367         }
 368 
 369         // Uncomment if needed, but very noisy
 370         //System.out.println(&quot;ServerSettings: &quot; + serverSettings);
 371         //System.out.println(&quot;ClientSettings: &quot; + clientSettings);
 372 
 373         hpackOut = new Encoder(serverSettings.getParameter(HEADER_TABLE_SIZE));
 374         hpackIn = new Decoder(clientSettings.getParameter(HEADER_TABLE_SIZE));
 375 
 376         if (!secure) {
 377             createPrimordialStream(upgrade);
 378             nextstream = 3;
 379         }
 380 
 381         (new ConnectionThread(&quot;readLoop&quot;, this::readLoop)).start();
 382         (new ConnectionThread(&quot;writeLoop&quot;, this::writeLoop)).start();
 383     }
 384 
 385     class ConnectionThread extends Thread {
 386         final Runnable r;
 387         ConnectionThread(String name, Runnable r) {
 388             setName(name);
 389             setDaemon(true);
 390             this.r = r;
 391         }
 392 
 393         public void run() {
 394             r.run();
 395         }
 396     }
 397 
 398     private void writeFrame(Http2Frame frame) throws IOException {
 399         List&lt;ByteBuffer&gt; bufs = new FramesEncoder().encodeFrame(frame);
 400         //System.err.println(&quot;TestServer: Writing frame &quot; + frame.toString());
 401         int c = 0;
 402         for (ByteBuffer buf : bufs) {
 403             byte[] ba = buf.array();
 404             int start = buf.arrayOffset() + buf.position();
 405             c += buf.remaining();
 406             os.write(ba, start, buf.remaining());
 407 
 408 //            System.out.println(&quot;writing byte at a time&quot;);
 409 //            while (buf.hasRemaining()) {
 410 //                byte b = buf.get();
 411 //                os.write(b);
 412 //                os.flush();
 413 //                try {
 414 //                    Thread.sleep(1);
 415 //                } catch(InterruptedException e) {
 416 //                    UncheckedIOException uie = new UncheckedIOException(new IOException(&quot;&quot;));
 417 //                    uie.addSuppressed(e);
 418 //                    throw uie;
 419 //                }
 420 //            }
 421         }
 422         os.flush();
 423         //System.err.printf(&quot;TestServer: wrote %d bytes\n&quot;, c);
 424     }
 425 
 426     private void handleCommonFrame(Http2Frame f) throws IOException {
 427         if (f instanceof SettingsFrame) {
 428             SettingsFrame sf = (SettingsFrame) f;
 429             if (sf.getFlag(SettingsFrame.ACK)) // ignore
 430             {
 431                 return;
 432             }
 433             // otherwise acknowledge it
 434             clientSettings = sf;
 435             SettingsFrame frame = new SettingsFrame();
 436             frame.setFlag(SettingsFrame.ACK);
 437             frame.streamid(0);
 438             outputQ.put(frame);
 439             return;
 440         } else if (f instanceof GoAwayFrame) {
 441             System.err.println(&quot;Closing: &quot;+ f.toString());
 442             close(ErrorFrame.NO_ERROR);
 443         } else if (f instanceof PingFrame) {
 444             handlePing((PingFrame)f);
 445         } else
 446             throw new UnsupportedOperationException(&quot;Not supported yet: &quot; + f.toString());
 447     }
 448 
 449     void sendWindowUpdates(int len, int streamid) throws IOException {
 450         if (len == 0)
 451             return;
 452         WindowUpdateFrame wup = new WindowUpdateFrame(streamid, len);
 453         outputQ.put(wup);
 454         wup = new WindowUpdateFrame(0 , len);
 455         outputQ.put(wup);
 456     }
 457 
 458     HttpHeaders decodeHeaders(List&lt;HeaderFrame&gt; frames) throws IOException {
 459         HttpHeadersBuilder headersBuilder = createNewHeadersBuilder();
 460 
 461         DecodingCallback cb = (name, value) -&gt; {
 462             headersBuilder.addHeader(name.toString(), value.toString());
 463         };
 464 
 465         for (HeaderFrame frame : frames) {
 466             List&lt;ByteBuffer&gt; buffers = frame.getHeaderBlock();
 467             for (ByteBuffer buffer : buffers) {
 468                 hpackIn.decode(buffer, false, cb);
 469             }
 470         }
 471         hpackIn.decode(EMPTY_BUFFER, true, cb);
 472         return headersBuilder.build();
 473     }
 474 
 475     String getRequestLine(String request) {
 476         int eol = request.indexOf(CRLF);
 477         return request.substring(0, eol);
 478     }
 479 
 480     String getHeaders(String request) {
 481         int start = request.indexOf(CRLF);
 482         int end = request.indexOf(CRLFCRLF);
 483         if (start == -1 || end == -1) {
 484             throw new RuntimeException(&quot;Malformed request&quot;);
 485         }
 486         return request.substring(start,end);
 487     }
 488 
 489     static void addHeaders(String headersString, HttpHeadersBuilder headersBuilder) {
 490         String[] hh = headersString.split(CRLF);
 491         for (String header : hh) {
 492             int colon = header.indexOf(&#39;:&#39;);
 493             if (colon == -1)
 494                 continue;
 495             String name = header.substring(0, colon);
 496             String value = header.substring(colon+1);
 497             while (value.startsWith(&quot; &quot;))
 498                 value = value.substring(1);
 499             headersBuilder.addHeader(name, value);
 500         }
 501     }
 502 
 503     // First stream (1) comes from a plaintext HTTP/1.1 request
 504     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
 505     void createPrimordialStream(Http1InitialRequest request) throws IOException {
 506         HttpHeadersBuilder headersBuilder = createNewHeadersBuilder();
 507         String requestLine = getRequestLine(request.headers);
 508         String[] tokens = requestLine.split(&quot; &quot;);
 509         if (!tokens[2].equals(&quot;HTTP/1.1&quot;)) {
 510             throw new IOException(&quot;bad request line&quot;);
 511         }
 512         URI uri;
 513         try {
 514             uri = new URI(tokens[1]);
 515         } catch (URISyntaxException e) {
 516             throw new IOException(e);
 517         }
 518         String host = getHeader(request.headers, &quot;Host&quot;);
 519         if (host == null) {
 520             throw new IOException(&quot;missing Host&quot;);
 521         }
 522 
 523         headersBuilder.setHeader(&quot;:method&quot;, tokens[0]);
 524         headersBuilder.setHeader(&quot;:scheme&quot;, &quot;http&quot;); // always in this case
 525         headersBuilder.setHeader(&quot;:authority&quot;, host);
 526         String path = uri.getRawPath();
 527         if (uri.getRawQuery() != null)
 528             path = path + &quot;?&quot; + uri.getRawQuery();
 529         headersBuilder.setHeader(&quot;:path&quot;, path);
 530 
 531         Queue q = new Queue(sentinel);
 532         byte[] body = getRequestBody(request);
 533         addHeaders(getHeaders(request.headers), headersBuilder);
 534         headersBuilder.setHeader(&quot;Content-length&quot;, Integer.toString(body.length));
 535         HttpHeaders headers = headersBuilder.build();
 536 
 537         addRequestBodyToQueue(body, q);
 538         streams.put(1, q);
 539         exec.submit(() -&gt; {
 540             handleRequest(headers, q, 1, true /*complete request has been read*/);
 541         });
 542     }
 543 
 544     // all other streams created here
 545     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
 546     void createStream(HeaderFrame frame) throws IOException {
 547         List&lt;HeaderFrame&gt; frames = new LinkedList&lt;&gt;();
 548         frames.add(frame);
 549         int streamid = frame.streamid();
 550         if (streamid != nextstream) {
 551             throw new IOException(&quot;unexpected stream id&quot;);
 552         }
 553         nextstream += 2;
 554 
 555         boolean endStream = false;
 556         if (frame.getFlag(HeaderFrame.END_STREAM)) {
 557             endStream = true;
 558         }
 559 
 560         while (!frame.getFlag(HeaderFrame.END_HEADERS)) {
 561             Http2Frame f = readFrame();
 562             if (!(f instanceof HeaderFrame)) {
 563                 handleCommonFrame(f); // should only be error frames
 564             } else {
 565                 frame = (HeaderFrame) f;
 566                 if (frame.getFlag(HeaderFrame.END_STREAM)) {
 567                     endStream = true;
 568                 }
 569                 frames.add(frame);
 570             }
 571         }
 572         boolean endStreamReceived = endStream;
 573         HttpHeaders headers = decodeHeaders(frames);
 574 
 575         // Strict to assert Client correctness. Not all servers are as strict,
 576         // but some are known to be.
 577         Optional&lt;?&gt; disallowedHeader = headers.firstValue(&quot;Upgrade&quot;);
 578         if (disallowedHeader.isPresent()) {
 579             throw new IOException(&quot;Unexpected Upgrade in headers:&quot; + headers);
 580         }
 581         disallowedHeader = headers.firstValue(&quot;HTTP2-Settings&quot;);
 582         if (disallowedHeader.isPresent())
 583             throw new IOException(&quot;Unexpected HTTP2-Settings in headers:&quot; + headers);
 584 
 585 
 586         Queue q = new Queue(sentinel);
 587         streams.put(streamid, q);
 588         exec.submit(() -&gt; {
 589             handleRequest(headers, q, streamid, endStreamReceived);
 590         });
 591     }
 592 
 593     // runs in own thread. Handles request from start to finish. Incoming frames
 594     // for this stream/request delivered on Q
 595 
 596     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
 597     void handleRequest(HttpHeaders headers,
 598                        Queue queue,
 599                        int streamid,
 600                        boolean endStreamReceived)
 601     {
 602         String method = headers.firstValue(&quot;:method&quot;).orElse(&quot;&quot;);
 603         //System.out.println(&quot;method = &quot; + method);
 604         String path = headers.firstValue(&quot;:path&quot;).orElse(&quot;&quot;);
 605         //System.out.println(&quot;path = &quot; + path);
 606         String scheme = headers.firstValue(&quot;:scheme&quot;).orElse(&quot;&quot;);
 607         //System.out.println(&quot;scheme = &quot; + scheme);
 608         String authority = headers.firstValue(&quot;:authority&quot;).orElse(&quot;&quot;);
 609         //System.out.println(&quot;authority = &quot; + authority);
 610         System.err.printf(&quot;TestServer: %s %s\n&quot;, method, path);
 611         int winsize = clientSettings.getParameter(
 612                 SettingsFrame.INITIAL_WINDOW_SIZE);
 613         //System.err.println (&quot;Stream window size = &quot; + winsize);
 614 
 615         final InputStream bis;
 616         if (endStreamReceived &amp;&amp; queue.size() == 0) {
 617             System.err.println(&quot;Server: got END_STREAM for stream &quot; + streamid);
 618             bis = NullInputStream.INSTANCE;
 619         } else {
 620             System.err.println(&quot;Server: creating input stream for stream &quot; + streamid);
 621             bis = new BodyInputStream(queue, streamid, this);
 622         }
 623         try (bis;
 624              BodyOutputStream bos = new BodyOutputStream(streamid, winsize, this))
 625         {
 626             outStreams.put(streamid, bos);
 627             String us = scheme + &quot;://&quot; + authority + path;
 628             URI uri = new URI(us);
 629             boolean pushAllowed = clientSettings.getParameter(SettingsFrame.ENABLE_PUSH) == 1;
 630             HttpHeadersBuilder rspheadersBuilder = createNewHeadersBuilder();
 631             Http2TestExchange exchange = exchangeSupplier.get(streamid, method,
 632                     headers, rspheadersBuilder, uri, bis, getSSLSession(),
 633                     bos, this, pushAllowed);
 634 
 635             // give to user
 636             Http2Handler handler = server.getHandlerFor(uri.getPath());
 637             try {
 638                 handler.handle(exchange);
 639             } catch (IOException closed) {
 640                 if (bos.closed) {
 641                     Queue q = streams.get(streamid);
 642                     if (q != null &amp;&amp; (q.isClosed() || q.isClosing())) {
 643                         System.err.println(&quot;TestServer: Stream &quot; + streamid + &quot; closed: &quot; + closed);
 644                         return;
 645                     }
 646                 }
 647                 throw closed;
 648             }
 649 
 650             // everything happens in the exchange from here. Hopefully will
 651             // return though.
 652         } catch (Throwable e) {
 653             System.err.println(&quot;TestServer: handleRequest exception: &quot; + e);
 654             e.printStackTrace();
 655             close(-1);
 656         }
 657     }
 658 
 659     protected HttpHeadersBuilder createNewHeadersBuilder() {
 660         return new HttpHeadersBuilder();
 661     }
 662 
 663     private SSLSession getSSLSession() {
 664         if (! (socket instanceof SSLSocket))
 665             return null;
 666         SSLSocket ssl = (SSLSocket)socket;
 667         return ssl.getSession();
 668     }
 669     // Runs in own thread
 670 
 671     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
 672     void readLoop() {
 673         try {
 674             while (!stopping) {
 675                 Http2Frame frame = readFrameImpl();
 676                 if (frame == null) {
 677                     closeIncoming();
 678                     return;
 679                 }
 680                 //System.err.printf(&quot;TestServer: received frame %s\n&quot;, frame);
 681                 int stream = frame.streamid();
 682                 if (stream == 0) {
 683                     if (frame.type() == WindowUpdateFrame.TYPE) {
 684                         WindowUpdateFrame wup = (WindowUpdateFrame) frame;
 685                         updateConnectionWindow(wup.getUpdate());
 686                     } else {
 687                         // other common frame types
 688                         handleCommonFrame(frame);
 689                     }
 690                 } else {
 691                     Queue q = streams.get(stream);
 692                     if (frame.type() == HeadersFrame.TYPE) {
 693                         if (q != null) {
 694                             System.err.println(&quot;HEADERS frame for existing stream! Error.&quot;);
 695                             // TODO: close connection
 696                             continue;
 697                         } else {
 698                             createStream((HeadersFrame) frame);
 699                         }
 700                     } else {
 701                         if (q == null &amp;&amp; !pushStreams.contains(stream)) {
 702                             System.err.printf(&quot;Non Headers frame received with&quot;+
 703                                     &quot; non existing stream (%d) &quot;, frame.streamid());
 704                             System.err.println(frame);
 705                             continue;
 706                         }
 707                         if (frame.type() == WindowUpdateFrame.TYPE) {
 708                             WindowUpdateFrame wup = (WindowUpdateFrame) frame;
 709                             synchronized (updaters) {
 710                                 Consumer&lt;Integer&gt; r = updaters.get(stream);
 711                                 r.accept(wup.getUpdate());
 712                             }
 713                         } else if (frame.type() == ResetFrame.TYPE) {
 714                             // do orderly close on input q
 715                             // and close the output q immediately
 716                             // This should mean depending on what the
 717                             // handler is doing: either an EOF on read
 718                             // or an IOException if writing the response.
 719                             if (q != null) {
 720                                 q.orderlyClose();
 721                                 BodyOutputStream oq = outStreams.get(stream);
 722                                 if (oq != null)
 723                                     oq.closeInternal();
 724                             } else if (pushStreams.contains(stream)) {
 725                                 // we could interrupt the pushStream&#39;s output
 726                                 // but the continuation, even after a reset
 727                                 // should be handle gracefully by the client
 728                                 // anyway.
 729                             } else {
 730                                 System.err.println(&quot;TestServer: Unexpected frame on: &quot; + stream);
 731                                 System.err.println(frame);
 732                                 throw new IOException(&quot;Unexpected frame&quot;);
 733                             }
 734                         } else {
 735                             q.put(frame);
 736                         }
 737                     }
 738                 }
 739             }
 740         } catch (Throwable e) {
 741             if (!stopping) {
 742                 System.err.println(&quot;Http server reader thread shutdown&quot;);
 743                 e.printStackTrace();
 744             }
 745             close(ErrorFrame.PROTOCOL_ERROR);
 746         }
 747     }
 748 
 749     /** Encodes an group of headers, without any ordering guarantees. */
 750     List&lt;ByteBuffer&gt; encodeHeaders(HttpHeaders headers) {
 751         List&lt;ByteBuffer&gt; buffers = new LinkedList&lt;&gt;();
 752 
 753         ByteBuffer buf = getBuffer();
 754         boolean encoded;
 755         for (Map.Entry&lt;String, List&lt;String&gt;&gt; entry : headers.map().entrySet()) {
 756             List&lt;String&gt; values = entry.getValue();
 757             String key = entry.getKey().toLowerCase();
 758             for (String value : values) {
 759                 do {
 760                     hpackOut.header(key, value);
 761                     encoded = hpackOut.encode(buf);
 762                     if (!encoded) {
 763                         buf.flip();
 764                         buffers.add(buf);
 765                         buf = getBuffer();
 766                     }
 767                 } while (!encoded);
 768             }
 769         }
 770         buf.flip();
 771         buffers.add(buf);
 772         return buffers;
 773     }
 774 
 775     /** Encodes an ordered list of headers. */
 776     List&lt;ByteBuffer&gt; encodeHeadersOrdered(List&lt;Map.Entry&lt;String,String&gt;&gt; headers) {
 777         List&lt;ByteBuffer&gt; buffers = new LinkedList&lt;&gt;();
 778 
 779         ByteBuffer buf = getBuffer();
 780         boolean encoded;
 781         for (Map.Entry&lt;String, String&gt; entry : headers) {
 782             String value = entry.getValue();
 783             String key = entry.getKey().toLowerCase();
 784             do {
 785                 hpackOut.header(key, value);
 786                 encoded = hpackOut.encode(buf);
 787                 if (!encoded) {
 788                     buf.flip();
 789                     buffers.add(buf);
 790                     buf = getBuffer();
 791                 }
 792             } while (!encoded);
 793         }
 794         buf.flip();
 795         buffers.add(buf);
 796         return buffers;
 797     }
 798 
 799     static void closeIgnore(Closeable c) {
 800         try {
 801             c.close();
 802         } catch (IOException e) {}
 803     }
 804 
 805     // Runs in own thread
 806     void writeLoop() {
 807         try {
 808             while (!stopping) {
 809                 Http2Frame frame;
 810                 try {
 811                     frame = outputQ.take();
 812                     if (stopping)
 813                         break;
 814                 } catch(IOException x) {
 815                     if (stopping &amp;&amp; x.getCause() instanceof InterruptedException) {
 816                         break;
 817                     } else throw x;
 818                 }
 819                 if (frame instanceof ResponseHeaders) {
 820                     ResponseHeaders rh = (ResponseHeaders)frame;
 821                     HeadersFrame hf = new HeadersFrame(rh.streamid(), rh.getFlags(), encodeHeaders(rh.headers));
 822                     writeFrame(hf);
 823                 } else if (frame instanceof OutgoingPushPromise) {
 824                     handlePush((OutgoingPushPromise)frame);
 825                 } else
 826                     writeFrame(frame);
 827             }
 828             System.err.println(&quot;TestServer: Connection writer stopping&quot;);
 829         } catch (Throwable e) {
 830             e.printStackTrace();
 831             /*close();
 832             if (!stopping) {
 833                 e.printStackTrace();
 834                 System.err.println(&quot;TestServer: writeLoop exception: &quot; + e);
 835             }*/
 836         }
 837     }
 838 
 839     private void handlePush(OutgoingPushPromise op) throws IOException {
 840         int promisedStreamid = nextPushStreamId;
 841         PushPromiseFrame pp = new PushPromiseFrame(op.parentStream,
 842                                                    HeaderFrame.END_HEADERS,
 843                                                    promisedStreamid,
 844                                                    encodeHeaders(op.headers),
 845                                                    0);
 846         pushStreams.add(promisedStreamid);
 847         nextPushStreamId += 2;
 848         pp.streamid(op.parentStream);
 849         writeFrame(pp);
 850         final InputStream ii = op.is;
 851         final BodyOutputStream oo = new BodyOutputStream(
 852                 promisedStreamid,
 853                 clientSettings.getParameter(
 854                         SettingsFrame.INITIAL_WINDOW_SIZE), this);
 855         outStreams.put(promisedStreamid, oo);
 856         oo.goodToGo();
 857         exec.submit(() -&gt; {
 858             try {
 859                 ResponseHeaders oh = getPushResponse(promisedStreamid);
 860                 outputQ.put(oh);
 861                 ii.transferTo(oo);
 862             } catch (Throwable ex) {
 863                 System.err.printf(&quot;TestServer: pushing response error: %s\n&quot;,
 864                         ex.toString());
 865             } finally {
 866                 closeIgnore(ii);
 867                 closeIgnore(oo);
 868             }
 869         });
 870 
 871     }
 872 
 873     // returns a minimal response with status 200
 874     // that is the response to the push promise just sent
 875     private ResponseHeaders getPushResponse(int streamid) {
 876         HttpHeadersBuilder hb = createNewHeadersBuilder();
 877         hb.addHeader(&quot;:status&quot;, &quot;200&quot;);
 878         ResponseHeaders oh = new ResponseHeaders(hb.build());
 879         oh.streamid(streamid);
 880         oh.setFlag(HeaderFrame.END_HEADERS);
 881         return oh;
 882     }
 883 
 884     private ByteBuffer getBuffer() {
 885         return ByteBuffer.allocate(8 * 1024);
 886     }
 887 
 888     private Http2Frame readFrame() throws IOException {
 889         Http2Frame f = readFrameImpl();
 890         if (f == null)
 891             throw new IOException(&quot;connection closed&quot;);
 892         return f;
 893     }
 894 
 895     // does not throw an exception for EOF
 896     private Http2Frame readFrameImpl() throws IOException {
 897         try {
 898             byte[] buf = new byte[9];
 899             int ret;
 900             ret=is.readNBytes(buf, 0, 9);
 901             if (ret == 0) {
 902                 return null;
 903             } else if (ret != 9) {
 904                 throw new IOException(&quot;readFrame: connection closed&quot;);
 905             }
 906             int len = 0;
 907             for (int i = 0; i &lt; 3; i++) {
 908                 int n = buf[i] &amp; 0xff;
 909                 //System.err.println(&quot;n = &quot; + n);
 910                 len = (len &lt;&lt; 8) + n;
 911             }
 912             byte[] rest = new byte[len];
 913             int n = is.readNBytes(rest, 0, len);
 914             if (n != len)
 915                 throw new IOException(&quot;Error reading frame&quot;);
 916             List&lt;Http2Frame&gt; frames = new ArrayList&lt;&gt;();
 917             FramesDecoder reader = new FramesDecoder(frames::add);
 918             reader.decode(ByteBuffer.wrap(buf));
 919             reader.decode(ByteBuffer.wrap(rest));
 920             if (frames.size()!=1)
 921                 throw new IOException(&quot;Expected 1 frame got &quot;+frames.size()) ;
 922 
 923             return frames.get(0);
 924         } catch (IOException ee) {
 925             if (stopping)
 926                 return null;
 927             throw ee;
 928         }
 929     }
 930 
 931     void sendSettingsFrame() throws IOException {
 932         sendSettingsFrame(false);
 933     }
 934 
 935     void sendSettingsFrame(boolean now) throws IOException {
 936         if (now) {
 937             writeFrame(serverSettings);
 938         } else {
 939             outputQ.put(serverSettings);
 940         }
 941     }
 942 
 943     String readUntil(String end) throws IOException {
 944         int number = end.length();
 945         int found = 0;
 946         StringBuilder sb = new StringBuilder();
 947         while (found &lt; number) {
 948             char expected = end.charAt(found);
 949             int c = is.read();
 950             if (c == -1) {
 951                 throw new IOException(&quot;Connection closed&quot;);
 952             }
 953             char c0 = (char) c;
 954             sb.append(c0);
 955             if (c0 != expected) {
 956                 found = 0;
 957                 continue;
 958             }
 959             found++;
 960         }
 961         return sb.toString();
 962     }
 963 
 964     private int getContentLength(String headers) {
 965         return getIntHeader(headers, &quot;Content-length&quot;);
 966     }
 967 
 968     private int getIntHeader(String headers, String name) {
 969         String val = getHeader(headers, name);
 970         if (val == null) {
 971             return -1;
 972         }
 973         return Integer.parseInt(val);
 974     }
 975 
 976     private String getHeader(String headers, String name) {
 977         String headers1 = headers.toLowerCase(); // not efficient
 978         name = CRLF + name.toLowerCase();
 979         int start = headers1.indexOf(name);
 980         if (start == -1) {
 981             return null;
 982         }
 983         start += 2;
 984         int end = headers1.indexOf(CRLF, start);
 985         String line = headers.substring(start, end);
 986         start = line.indexOf(&#39;:&#39;);
 987         if (start == -1) {
 988             return null;
 989         }
 990         return line.substring(start + 1).trim();
 991     }
 992 
 993     final static String CRLF = &quot;\r\n&quot;;
 994     final static String CRLFCRLF = &quot;\r\n\r\n&quot;;
 995 
 996     static class Http1InitialRequest {
 997         final String headers;
 998         final byte[] body;
 999         Http1InitialRequest(String headers, byte[] body) {
1000             this.headers = headers;
1001             this.body = body.clone();
1002         }
1003     }
1004 
1005     Http1InitialRequest readHttp1Request() throws IOException {
1006         String headers = readUntil(CRLF + CRLF);
1007         int clen = getContentLength(headers);
1008         String te = getHeader(headers, &quot;Transfer-encoding&quot;);
1009         byte[] buf = new byte[0];
1010         try {
1011             if (clen &gt;= 0) {
1012                 // HTTP/1.1 fixed length content ( may be 0 ), read it
1013                 buf = new byte[clen];
1014                 is.readNBytes(buf, 0, clen);
1015             } else if (&quot;chunked&quot;.equalsIgnoreCase(te)) {
1016                 //  HTTP/1.1 chunked data, read it
1017                 buf = readChunkedInputStream(is);
1018             }
1019             return new Http1InitialRequest(headers, buf);
1020         } catch (IOException e) {
1021             System.err.println(&quot;TestServer: headers read: [ &quot; + headers + &quot; ]&quot;);
1022             throw e;
1023         }
1024     }
1025 
1026     // This is a quick hack to get a chunked input stream reader.
1027     private static byte[] readChunkedInputStream(InputStream is) throws IOException {
1028         ChunkedInputStream cis = new ChunkedInputStream(is, new HttpClient() {}, null);
1029         return cis.readAllBytes();
1030     }
1031 
1032     void sendHttp1Response(int code, String msg, String... headers) throws IOException {
1033         StringBuilder sb = new StringBuilder();
1034         sb.append(&quot;HTTP/1.1 &quot;)
1035                 .append(code)
1036                 .append(&#39; &#39;)
1037                 .append(msg)
1038                 .append(CRLF);
1039         int numheaders = headers.length;
1040         for (int i = 0; i &lt; numheaders; i += 2) {
1041             sb.append(headers[i])
1042                     .append(&quot;: &quot;)
1043                     .append(headers[i + 1])
1044                     .append(CRLF);
1045         }
1046         sb.append(CRLF);
1047         String s = sb.toString();
1048         os.write(s.getBytes(&quot;US-ASCII&quot;));
1049         os.flush();
1050     }
1051 
1052     private void unexpectedFrame(Http2Frame frame) {
1053         System.err.println(&quot;OOPS. Unexpected&quot;);
1054         assert false;
1055     }
1056 
1057     final static ByteBuffer[] bbarray = new ByteBuffer[0];
1058 
1059     // wrapper around a BlockingQueue that throws an exception when it&#39;s closed
1060     // Each stream has one of these
1061 
1062     byte[] getRequestBody(Http1InitialRequest request) {
1063         return request.body;
1064     }
1065 
1066     @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})
1067     void addRequestBodyToQueue(byte[] body, Queue q) throws IOException {
1068         ByteBuffer buf = ByteBuffer.wrap(body);
1069         DataFrame df = new DataFrame(1, DataFrame.END_STREAM, buf);
1070         // only used for primordial stream
1071         q.put(df);
1072     }
1073 
1074     // window updates done in main reader thread because they may
1075     // be used to unblock BodyOutputStreams waiting for WUPs
1076 
1077     HashMap&lt;Integer,Consumer&lt;Integer&gt;&gt; updaters = new HashMap&lt;&gt;();
1078 
1079     void registerStreamWindowUpdater(int streamid, Consumer&lt;Integer&gt; r) {
1080         synchronized(updaters) {
1081             updaters.put(streamid, r);
1082         }
1083     }
1084 
1085     int sendWindow = 64 * 1024 - 1; // connection level send window
1086 
1087     /**
1088      * BodyOutputStreams call this to get the connection window first.
1089      *
1090      * @param amount
1091      */
1092     synchronized void obtainConnectionWindow(int amount) throws InterruptedException {
1093         while (amount &gt; 0) {
1094             int n = Math.min(amount, sendWindow);
1095             amount -= n;
1096             sendWindow -= n;
1097             if (amount &gt; 0)
1098                 wait();
1099         }
1100     }
1101 
1102     synchronized void updateConnectionWindow(int amount) {
1103         sendWindow += amount;
1104         notifyAll();
1105     }
1106 
1107     // simplified output headers class. really just a type safe container
1108     // for the hashmap.
1109 
1110     static class ResponseHeaders extends Http2Frame {
1111         HttpHeaders headers;
1112 
1113         ResponseHeaders(HttpHeaders headers) {
1114             super(0, 0);
1115             this.headers = headers;
1116         }
1117 
1118     }
1119 
1120     static class NullInputStream extends InputStream {
1121         static final NullInputStream INSTANCE = new NullInputStream();
1122         private NullInputStream() {}
1123         public int read()      { return -1; }
1124         public int available() { return 0;  }
1125     }
1126 }
    </pre>
  </body>
</html>
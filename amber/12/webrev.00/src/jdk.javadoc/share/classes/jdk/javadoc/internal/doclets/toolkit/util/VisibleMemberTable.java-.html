<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import javax.lang.model.element.Element;
  29 import javax.lang.model.element.ExecutableElement;
  30 import javax.lang.model.element.TypeElement;
  31 import javax.lang.model.element.VariableElement;
  32 import javax.lang.model.type.TypeKind;
  33 import javax.lang.model.type.TypeMirror;
  34 import javax.lang.model.util.Elements;
  35 import javax.lang.model.util.SimpleElementVisitor14;
  36 import java.lang.ref.SoftReference;
  37 import java.util.ArrayList;
  38 import java.util.Collections;
  39 import java.util.EnumMap;
  40 import java.util.EnumSet;
  41 import java.util.HashMap;
  42 import java.util.LinkedHashMap;
  43 import java.util.LinkedHashSet;
  44 import java.util.List;
  45 import java.util.Map;
  46 import java.util.Set;
  47 import java.util.function.Predicate;
  48 import java.util.stream.Collectors;
  49 
  50 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
  51 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
  52 import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
  53 
  54 /**
  55  * This class computes the main data structure for the doclet&#39;s
  56  * operations. Essentially, the implementation encapsulating the
  57  * javax.lang.models view of what can be documented about a
  58  * type element&#39;s members.
  59  * &lt;p&gt;
  60  * The general operations are as follows:
  61  * &lt;p&gt;
  62  * Members: these are the members from jx.l.m&#39;s view but
  63  * are structured along the kinds of this class.
  64  * &lt;p&gt;
  65  * Extra Members: these are members enclosed in an undocumented
  66  * package-private type element, and may not be linkable (or documented),
  67  * however, the members of such a type element may be documented, as if
  68  * declared in the sub type, only if the enclosing type is not being
  69  * documented by a filter such as -public, -protected, etc.
  70  * &lt;p&gt;
  71  * Visible Members: these are the members that are &quot;visible&quot;
  72  * and available and should be documented, in a type element.
  73  * &lt;p&gt;
  74  * The basic rule for computation: when considering a type element,
  75  * besides its immediate direct types and interfaces, the computation
  76  * should not expand to any other type in the inheritance hierarchy.
  77  * &lt;p&gt;
  78  * This table generates all the data structures it needs for each
  79  * type, as its own view, and will present some form of this to the
  80  * doclet as and when required to.
  81  *
  82  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  83  * If you write code that depends on this, you do so at your own risk.
  84  * This code and its internal interfaces are subject to change or
  85  * deletion without notice.&lt;/b&gt;
  86  *
  87  */
  88 
  89 public class VisibleMemberTable {
  90 
  91     public enum Kind {
  92         INNER_CLASSES,
  93         ENUM_CONSTANTS,
  94         FIELDS,
  95         CONSTRUCTORS,
  96         METHODS,
  97         ANNOTATION_TYPE_FIELDS,
  98         ANNOTATION_TYPE_MEMBER_OPTIONAL,
  99         ANNOTATION_TYPE_MEMBER_REQUIRED,
 100         PROPERTIES;
 101 
 102         public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
 103         public static final EnumSet&lt;Kind&gt; detailSet = EnumSet.range(ENUM_CONSTANTS, METHODS);
 104     }
 105 
 106     final TypeElement te;
 107     final TypeElement parent;
 108 
 109     final BaseConfiguration config;
 110     final BaseOptions options;
 111     final Utils utils;
 112     final VisibleMemberCache mcache;
 113 
 114     private List&lt;VisibleMemberTable&gt; allSuperclasses;
 115     private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
 116     private List&lt;VisibleMemberTable&gt; parents;
 117 
 118 
 119     private Map&lt;Kind, List&lt;Element&gt;&gt; extraMembers = new EnumMap&lt;&gt;(Kind.class);
 120     private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
 121     private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
 122 
 123     // Keeps track of method overrides
 124     Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
 125             = new LinkedHashMap&lt;&gt;();
 126 
 127     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
 128                                  VisibleMemberCache mcache) {
 129         config = configuration;
 130         utils = configuration.utils;
 131         options = configuration.getOptions();
 132         te = typeElement;
 133         parent = utils.getSuperClass(te);
 134         this.mcache = mcache;
 135         allSuperclasses = new ArrayList&lt;&gt;();
 136         allSuperinterfaces = new ArrayList&lt;&gt;();
 137         parents = new ArrayList&lt;&gt;();
 138     }
 139 
 140     private synchronized void ensureInitialized() {
 141         if (visibleMembers != null)
 142             return;
 143 
 144         visibleMembers = new EnumMap&lt;&gt;(Kind.class);
 145         for (Kind kind : Kind.values()) {
 146             visibleMembers.put(kind, new ArrayList&lt;&gt;());
 147         }
 148         computeParents();
 149         computeVisibleMembers();
 150     }
 151 
 152     List&lt;? extends Element&gt; getExtraMembers(Kind kind) {
 153         ensureInitialized();
 154         return visibleMembers.getOrDefault(kind, Collections.emptyList());
 155     }
 156 
 157     List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
 158         ensureInitialized();
 159         return allSuperclasses;
 160     }
 161 
 162     List&lt;VisibleMemberTable&gt; getAllSuperinterfaces() {
 163         ensureInitialized();
 164         return allSuperinterfaces;
 165     }
 166 
 167     /**
 168      * Returns a list of all visible enclosed members of a type element,
 169      * and inherited members.
 170      * &lt;p&gt;
 171      * Notes:
 172      * a. The list may or may not contain simple overridden methods.
 173      * A simple overridden method is one that overrides a super method
 174      * with no specification changes as indicated by the existence of a
 175      * sole &amp;commat;inheritDoc or devoid of any API comments.
 176      * &lt;p&gt;
 177      * b.The list may contain (extra) members, inherited by inaccessible
 178      * super types, primarily package private types. These members are
 179      * required to be documented in the subtype when the super type is
 180      * not documented.
 181      *
 182      * @param kind the member kind
 183      * @return a list of all visible members
 184      */
 185     public List&lt;? extends Element&gt; getAllVisibleMembers(Kind kind) {
 186         ensureInitialized();
 187         return visibleMembers.getOrDefault(kind, Collections.emptyList());
 188     }
 189 
 190     /**
 191      * Returns a list of visible enclosed members of a specified kind,
 192      * filtered by the specified predicate.
 193      * @param kind the member kind
 194      * @param p the predicate used to filter the output
 195      * @return a list of visible enclosed members
 196      */
 197     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind, Predicate&lt;Element&gt; p) {
 198         ensureInitialized();
 199 
 200         return visibleMembers.getOrDefault(kind, Collections.emptyList()).stream()
 201                 .filter(p)
 202                 .collect(Collectors.toList());
 203     }
 204 
 205     /**
 206      * Returns a list of all enclosed members including any extra members.
 207      * Typically called by various builders.
 208      *
 209      * @param kind the member kind
 210      * @return a list of visible enclosed members
 211      */
 212     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
 213         Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
 214             TypeElement encl = utils.getEnclosingTypeElement(e);
 215             return encl == te || utils.isUndocumentedEnclosure(encl);
 216         };
 217         return getVisibleMembers(kind, declaredAndLeafMembers);
 218     }
 219 
 220     /**
 221      * Returns a list of visible enclosed members of given kind,
 222      * declared in this type element, and does not include
 223      * any inherited members or extra members.
 224      *
 225      * @return a list of visible enclosed members in this type
 226      */
 227     public List&lt;? extends Element&gt; getMembers(Kind kind) {
 228         Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
 229         return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
 230     }
 231 
 232     /**
 233      * Returns the overridden method, if it is simply overriding or the
 234      * method is a member of a package private type, this method is
 235      * primarily used to determine the location of a possible comment.
 236      *
 237      * @param e the method to check
 238      * @return the method found or null
 239      */
 240     public ExecutableElement getOverriddenMethod(ExecutableElement e) {
 241         ensureInitialized();
 242 
 243         OverridingMethodInfo found = overriddenMethodTable.get(e);
 244         if (found != null
 245                 &amp;&amp; (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {
 246             return found.overrider;
 247         }
 248         return null;
 249     }
 250 
 251     /**
 252      * Returns the simply overridden method.
 253      * @param e the method to check
 254      * @return the overridden method or null
 255      */
 256     public ExecutableElement getSimplyOverriddenMethod(ExecutableElement e) {
 257         ensureInitialized();
 258 
 259         OverridingMethodInfo found = overriddenMethodTable.get(e);
 260         if (found != null &amp;&amp; found.simpleOverride) {
 261             return found.overrider;
 262         }
 263         return null;
 264     }
 265 
 266     /**
 267      * Returns a set of visible type elements in this type element&#39;s lineage.
 268      * &lt;p&gt;
 269      * This method returns the super-types in the inheritance
 270      * order C, B, A, j.l.O. The super-interfaces however are
 271      * alpha sorted and appended to the resulting set.
 272      *
 273      * @return the list of visible classes in this map.
 274      */
 275     public Set&lt;TypeElement&gt; getVisibleTypeElements() {
 276         ensureInitialized();
 277         Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;();
 278 
 279         // Add this type element first.
 280         result.add(te);
 281 
 282         // Add the super classes.
 283         allSuperclasses.stream()
 284                 .map(vmt -&gt; vmt.te)
 285                 .forEach(result::add);
 286 
 287         // ... and finally the sorted super interfaces.
 288         allSuperinterfaces.stream()
 289                 .map(vmt -&gt; vmt.te)
 290                 .sorted(utils.makeGeneralPurposeComparator())
 291                 .forEach(result::add);
 292 
 293         return result;
 294     }
 295 
 296     /**
 297      * Returns true if this table contains visible members.
 298      *
 299      * @return true if visible members are present.
 300      */
 301     public boolean hasVisibleMembers() {
 302         for (Kind kind : Kind.values()) {
 303             if (hasVisibleMembers(kind))
 304                 return true;
 305         }
 306         return false;
 307     }
 308 
 309     /**
 310      * Returns true if this table contains visible members of
 311      * the specified kind, including inherited members.
 312      *
 313      * @return true if visible members are present.
 314      */
 315     public boolean hasVisibleMembers(Kind kind) {
 316         ensureInitialized();
 317         List&lt;Element&gt; elements = visibleMembers.get(kind);
 318         return elements != null &amp;&amp; !elements.isEmpty();
 319     }
 320 
 321     /**
 322      * Returns the property field associated with the property method.
 323      * @param propertyMethod the identifying property method
 324      * @return the field or null if absent
 325      */
 326     public VariableElement getPropertyField(ExecutableElement propertyMethod) {
 327         ensureInitialized();
 328         PropertyMembers pm =  propertyMap.get(propertyMethod);
 329         return pm == null ? null : pm.field;
 330     }
 331 
 332     /**
 333      * Returns the getter method associated with the property method.
 334      * @param propertyMethod the identifying property method
 335      * @return the getter or null if absent
 336      */
 337     public ExecutableElement getPropertyGetter(ExecutableElement propertyMethod) {
 338         ensureInitialized();
 339         PropertyMembers pm =  propertyMap.get(propertyMethod);
 340         return pm == null ? null : pm.getter;
 341     }
 342 
 343     /**
 344      * Returns the setter method associated with the property method.
 345      * @param propertyMethod the identifying property method
 346      * @return the setter or null if absent
 347      */
 348     public ExecutableElement getPropertySetter(ExecutableElement propertyMethod) {
 349         ensureInitialized();
 350         PropertyMembers pm =  propertyMap.get(propertyMethod);
 351         return pm == null ? null : pm.setter;
 352     }
 353 
 354     private void computeParents() {
 355         for (TypeMirror intfType : te.getInterfaces()) {
 356             TypeElement intfc = utils.asTypeElement(intfType);
 357             if (intfc != null) {
 358                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
 359                 allSuperinterfaces.add(vmt);
 360                 parents.add(vmt);
 361                 allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 362             }
 363         }
 364 
 365         if (parent != null) {
 366             VisibleMemberTable vmt = mcache.getVisibleMemberTable(parent);
 367             allSuperclasses.add(vmt);
 368             allSuperclasses.addAll(vmt.getAllSuperclasses());
 369             // Add direct super interfaces of a super class, if any.
 370             allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
 371             parents.add(vmt);
 372         }
 373     }
 374 
 375     private void computeVisibleMembers() {
 376 
 377         // Note: these have some baggage, and are redundant,
 378         // allow this to be GC&#39;ed.
 379         LocalMemberTable lmt = new LocalMemberTable();
 380 
 381         for (Kind k : Kind.values()) {
 382             computeLeafMembers(lmt, k);
 383             computeVisibleMembers(lmt, k);
 384         }
 385         // All members have been computed, compute properties.
 386         computeVisibleProperties(lmt);
 387     }
 388 
 389     private void computeLeafMembers(LocalMemberTable lmt, Kind kind) {
 390         List&lt;Element&gt; list = new ArrayList&lt;&gt;();
 391         if (utils.isUndocumentedEnclosure(te)) {
 392             list.addAll(lmt.getOrderedMembers(kind));
 393         }
 394         parents.forEach(pvmt -&gt; list.addAll(pvmt.getExtraMembers(kind)));
 395         extraMembers.put(kind, Collections.unmodifiableList(list));
 396     }
 397 
 398     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
 399         switch (kind) {
 400             case FIELDS: case INNER_CLASSES:
 401                 computeVisibleFieldsAndInnerClasses(lmt, kind);
 402                 return;
 403 
 404             case METHODS:
 405                 computeVisibleMethods(lmt);
 406                 return;
 407 
 408             // Defer properties related computations for later.
 409             case PROPERTIES:
 410                 return;
 411 
 412             default:
 413                 List&lt;Element&gt; list = lmt.getOrderedMembers(kind).stream()
 414                         .filter(this::mustDocument)
 415                         .collect(Collectors.toList());
 416                 visibleMembers.put(kind, Collections.unmodifiableList(list));
 417                 break;
 418         }
 419     }
 420 
 421     private boolean mustDocument(Element e) {
 422         return !utils.hasHiddenTag(e) &amp;&amp; utils.shouldDocument(e);
 423     }
 424 
 425     private boolean allowInheritedMembers(Element e, Kind kind, LocalMemberTable lmt) {
 426         return isInherited(e) &amp;&amp; !isMemberHidden(e, kind, lmt);
 427     }
 428 
 429     private boolean isInherited(Element e) {
 430         if (utils.isPrivate(e))
 431             return false;
 432 
 433         if (utils.isPackagePrivate(e))
 434             // Allowed iff this type-element is in the same package as the element
 435             return utils.containingPackage(e).equals(utils.containingPackage(te));
 436 
 437         return true;
 438     }
 439 
 440     private boolean isMemberHidden(Element inheritedMember, Kind kind, LocalMemberTable lmt) {
 441         Elements elementUtils = config.docEnv.getElementUtils();
 442         switch(kind) {
 443             default:
 444                 List&lt;Element&gt; list = lmt.getMembers(inheritedMember, kind);
 445                 if (list.isEmpty())
 446                     return false;
 447                 return elementUtils.hides(list.get(0), inheritedMember);
 448             case METHODS: case CONSTRUCTORS: // Handled elsewhere.
 449                 throw new IllegalArgumentException(&quot;incorrect kind&quot;);
 450         }
 451     }
 452 
 453     private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
 454         Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
 455         for (VisibleMemberTable pvmt : parents) {
 456             result.addAll(pvmt.getExtraMembers(kind));
 457             result.addAll(pvmt.getAllVisibleMembers(kind));
 458         }
 459 
 460         // Filter out members in the inherited list that are hidden
 461         // by this type or should not be inherited at all.
 462         List&lt;Element&gt; list = result.stream()
 463                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))
 464                 .collect(Collectors.toList());
 465 
 466         // Prefix local results first
 467         list.addAll(0, lmt.getOrderedMembers(kind));
 468 
 469         // Filter out elements that should not be documented
 470         list = list.stream()
 471                 .filter(this::mustDocument)
 472                 .collect(Collectors.toList());
 473 
 474         visibleMembers.put(kind, Collections.unmodifiableList(list));
 475     }
 476 
 477     private void computeVisibleMethods(LocalMemberTable lmt) {
 478         Set&lt;Element&gt; inheritedMethods = new LinkedHashSet&lt;&gt;();
 479         Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; overriddenByTable = new HashMap&lt;&gt;();
 480         for (VisibleMemberTable pvmt : parents) {
 481             // Merge the lineage overrides into local table
 482             pvmt.overriddenMethodTable.entrySet().forEach(e -&gt; {
 483                 OverridingMethodInfo p = e.getValue();
 484                 if (!p.simpleOverride) { // consider only real overrides
 485                     List&lt;ExecutableElement&gt; list = overriddenByTable.computeIfAbsent(p.overrider,
 486                             k -&gt; new ArrayList&lt;&gt;());
 487                     list.add(e.getKey());
 488                 }
 489             });
 490             inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));
 491 
 492             // Copy the extra members (if any) from the lineage.
 493             if (!utils.shouldDocument(pvmt.te)) {
 494                 List&lt;? extends Element&gt; extraMethods = pvmt.getExtraMembers(Kind.METHODS);
 495 
 496                 if (lmt.getOrderedMembers(Kind.METHODS).isEmpty()) {
 497                     inheritedMethods.addAll(extraMethods);
 498                     continue;
 499                 }
 500 
 501                 // Check if an extra-method ought to percolate through.
 502                 for (Element extraMethod : extraMethods) {
 503                     boolean found = false;
 504 
 505                     List&lt;Element&gt; lmethods = lmt.getMembers(extraMethod, Kind.METHODS);
 506                     for (Element lmethod : lmethods) {
 507                         ExecutableElement method = (ExecutableElement)lmethod;
 508                         found = utils.elementUtils.overrides(method,
 509                                 (ExecutableElement)extraMethod, te);
 510                         if (found)
 511                             break;
 512                     }
 513                     if (!found)
 514                         inheritedMethods.add(extraMethod);
 515                 }
 516             }
 517         }
 518 
 519         // Filter out inherited methods that:
 520         // a. cannot override (private instance members)
 521         // b. are overridden and should not be visible in this type
 522         // c. are hidden in the type being considered
 523         // see allowInheritedMethods, which performs the above actions
 524         List&lt;Element&gt; list = inheritedMethods.stream()
 525                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))
 526                 .collect(Collectors.toList());
 527 
 528         // Filter out the local methods, that do not override or simply
 529         // overrides a super method, or those methods that should not
 530         // be visible.
 531         Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
 532             OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
 533             return p == null || !p.simpleOverride;
 534         };
 535         List&lt;Element&gt; mlist = lmt.getOrderedMembers(Kind.METHODS);
 536         List&lt;Element&gt; llist = mlist.stream()
 537                 .map(m -&gt; (ExecutableElement)m)
 538                 .filter(isVisible)
 539                 .collect(Collectors.toList());
 540 
 541         // Merge the above lists, making sure the local methods precede
 542         // the others
 543         list.addAll(0, llist);
 544 
 545         // Final filtration of elements
 546         list = list.stream()
 547                 .filter(this::mustDocument)
 548                 .collect(Collectors.toList());
 549 
 550         visibleMembers.put(Kind.METHODS, Collections.unmodifiableList(list));
 551 
 552         // Copy over overridden tables from the lineage, and finish up.
 553         for (VisibleMemberTable pvmt : parents) {
 554             overriddenMethodTable.putAll(pvmt.overriddenMethodTable);
 555         }
 556         overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);
 557     }
 558 
 559     boolean isEnclosureInterface(Element e) {
 560         TypeElement enclosing = utils.getEnclosingTypeElement(e);
 561         return utils.isInterface(enclosing);
 562     }
 563 
 564     boolean allowInheritedMethods(ExecutableElement inheritedMethod,
 565                                   Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; inheritedOverriddenTable,
 566                                   LocalMemberTable lmt) {
 567         if (!isInherited(inheritedMethod))
 568             return false;
 569 
 570         final boolean haveStatic = utils.isStatic(inheritedMethod);
 571         final boolean inInterface = isEnclosureInterface(inheritedMethod);
 572 
 573         // Static methods in interfaces are never documented.
 574         if (haveStatic &amp;&amp; inInterface) {
 575             return false;
 576         }
 577 
 578         // Multiple-Inheritance: remove the interface method that may have
 579         // been overridden by another interface method in the hierarchy
 580         //
 581         // Note: The following approach is very simplistic and is compatible
 582         // with old VMM. A future enhancement, may include a contention breaker,
 583         // to correctly eliminate those methods that are merely definitions
 584         // in favor of concrete overriding methods, for instance those that have
 585         // API documentation and are not abstract OR default methods.
 586         if (inInterface) {
 587             List&lt;ExecutableElement&gt; list = inheritedOverriddenTable.get(inheritedMethod);
 588             if (list != null) {
 589                 boolean found = list.stream()
 590                         .anyMatch(this::isEnclosureInterface);
 591                 if (found)
 592                     return false;
 593             }
 594         }
 595 
 596         Elements elementUtils = config.docEnv.getElementUtils();
 597 
 598         // Check the local methods in this type.
 599         List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
 600         for (Element le : lMethods) {
 601             ExecutableElement lMethod = (ExecutableElement) le;
 602             // Ignore private methods or those methods marked with
 603             // a &quot;hidden&quot; tag.
 604             if (utils.isPrivate(lMethod))
 605                 continue;
 606 
 607             // Remove methods that are &quot;hidden&quot;, in JLS terms.
 608             if (haveStatic &amp;&amp; utils.isStatic(lMethod) &amp;&amp;
 609                     elementUtils.hides(lMethod, inheritedMethod)) {
 610                 return false;
 611             }
 612 
 613             // Check for overriding methods.
 614             if (elementUtils.overrides(lMethod, inheritedMethod,
 615                     utils.getEnclosingTypeElement(lMethod))) {
 616 
 617                 // Disallow package-private super methods to leak in
 618                 TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
 619                 if (utils.isUndocumentedEnclosure(encl)) {
 620                     overriddenMethodTable.computeIfAbsent(lMethod,
 621                             l -&gt; new OverridingMethodInfo(inheritedMethod, false));
 622                     return false;
 623                 }
 624 
 625                 TypeMirror inheritedMethodReturn = inheritedMethod.getReturnType();
 626                 TypeMirror lMethodReturn = lMethod.getReturnType();
 627                 boolean covariantReturn =
 628                         lMethodReturn.getKind() == TypeKind.DECLARED
 629                         &amp;&amp; inheritedMethodReturn.getKind() == TypeKind.DECLARED
 630                         &amp;&amp; !utils.typeUtils.isSameType(lMethodReturn, inheritedMethodReturn)
 631                         &amp;&amp; utils.typeUtils.isSubtype(lMethodReturn, inheritedMethodReturn);
 632                 boolean simpleOverride = covariantReturn ? false : utils.isSimpleOverride(lMethod);
 633                 overriddenMethodTable.computeIfAbsent(lMethod,
 634                         l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
 635                 return simpleOverride;
 636             }
 637         }
 638         return true;
 639     }
 640 
 641     /*
 642      * This class encapsulates the details of local members, orderedMembers
 643      * contains the members in the declaration order, additionally a
 644      * HashMap is maintained for performance optimization to lookup
 645      * members. As a future enhancement is perhaps to consolidate the ordering
 646      * into a Map, capturing the insertion order, thereby eliminating an
 647      * ordered list.
 648      */
 649     class LocalMemberTable {
 650 
 651         // Maintains declaration order
 652         private final Map&lt;Kind, List&lt;Element&gt;&gt; orderedMembers;
 653 
 654         // Performance optimization
 655         private final Map&lt;Kind, Map&lt;String, List&lt;Element&gt;&gt;&gt; memberMap;
 656 
 657         LocalMemberTable() {
 658             orderedMembers = new EnumMap&lt;&gt;(Kind.class);
 659             memberMap = new EnumMap&lt;&gt;(Kind.class);
 660 
 661             List&lt;? extends Element&gt; elements = te.getEnclosedElements();
 662             for (Element e : elements) {
 663                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {
 664                     continue;
 665                 }
 666                 switch (e.getKind()) {
 667                     case CLASS:
 668                     case INTERFACE:
 669                     case ENUM:
 670                     case ANNOTATION_TYPE:
 671                     case RECORD:
 672                         addMember(e, Kind.INNER_CLASSES);
 673                         break;
 674                     case FIELD:
 675                         addMember(e, Kind.FIELDS);
 676                         addMember(e, Kind.ANNOTATION_TYPE_FIELDS);
 677                         break;
 678                     case METHOD:
 679                         ExecutableElement ee = (ExecutableElement)e;
 680                         if (utils.isAnnotationType(te)) {
 681                             addMember(e, ee.getDefaultValue() == null
 682                                     ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
 683                                     : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
 684                         }
 685                         addMember(e, Kind.METHODS);
 686                         break;
 687                     case CONSTRUCTOR:
 688                             addMember(e, Kind.CONSTRUCTORS);
 689                         break;
 690                     case ENUM_CONSTANT:
 691                         addMember(e, Kind.ENUM_CONSTANTS);
 692                         break;
 693                 }
 694             }
 695 
 696             // Freeze the data structures
 697             for (Kind kind : Kind.values()) {
 698                 orderedMembers.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableList(v));
 699                 orderedMembers.computeIfAbsent(kind, t -&gt; Collections.emptyList());
 700 
 701                 memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
 702                 memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
 703             }
 704         }
 705 
 706         @SuppressWarnings(&quot;preview&quot;)
 707         String getMemberKey(Element e) {
 708             return new SimpleElementVisitor14&lt;String, Void&gt;() {
 709                 @Override
 710                 public String visitExecutable(ExecutableElement e, Void aVoid) {
 711                     return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
 712                 }
 713 
 714                 @Override
 715                 protected String defaultAction(Element e, Void aVoid) {
 716                     return e.getSimpleName().toString();
 717                 }
 718             }.visit(e);
 719         }
 720 
 721         void addMember(Element e, Kind kind) {
 722             List&lt;Element&gt; list = orderedMembers.computeIfAbsent(kind, k -&gt; new ArrayList&lt;&gt;());
 723             list.add(e);
 724 
 725             Map&lt;String, List&lt;Element&gt;&gt; map = memberMap.computeIfAbsent(kind, k -&gt; new HashMap&lt;&gt;());
 726             list = map.computeIfAbsent(getMemberKey(e), l -&gt; new ArrayList&lt;&gt;());
 727             list.add(e);
 728         }
 729 
 730         List&lt;Element&gt; getOrderedMembers(Kind kind) {
 731             return orderedMembers.get(kind);
 732         }
 733 
 734         List&lt;Element&gt; getMembers(Element e, Kind kind) {
 735             String key = getMemberKey(e);
 736             return getMembers(key, kind);
 737         }
 738 
 739         List&lt;Element&gt; getMembers(String key, Kind kind) {
 740             Map &lt;String, List&lt;Element&gt;&gt; map = memberMap.get(kind);
 741             return map.getOrDefault(key, Collections.emptyList());
 742         }
 743 
 744         List&lt;Element&gt; getPropertyMethods(String methodName, int argcount) {
 745             return getMembers(methodName + &quot;:&quot; + argcount, Kind.METHODS).stream()
 746                     .filter(m -&gt; (utils.isPublic(m) || utils.isProtected(m)))
 747                     .collect(Collectors.toList());
 748         }
 749     }
 750 
 751     /**
 752      * The properties triad for a property method.
 753      */
 754     static class PropertyMembers {
 755         final VariableElement field;
 756         final ExecutableElement getter;
 757         final ExecutableElement setter;
 758 
 759         PropertyMembers(VariableElement field, ExecutableElement getter, ExecutableElement setter) {
 760             this.field = field;
 761             this.getter = getter;
 762             this.setter = setter;
 763         }
 764 
 765         public String toString() {
 766             return (&quot;field: &quot; + field + &quot;, getter: &quot; + getter + &quot;, setter: &quot; + setter);
 767         }
 768     }
 769 
 770     /*
 771      * JavaFX convention notes.
 772      * A JavaFX property-method is a method, which ends with &quot;Property&quot; in
 773      * its name, takes no parameters and typically returns a subtype of javafx.beans.
 774      * ReadOnlyProperty, in the strictest sense. However, it may not always
 775      * be possible for the doclet to have access to j.b.ReadOnlyProperty,
 776      * for this reason the strict check is disabled via an undocumented flag.
 777      *
 778      * Note, a method should not be considered as a property-method,
 779      * if it satisfied the previously stated conditions AND if the
 780      * method begins with &quot;set&quot;, &quot;get&quot; or &quot;is&quot;.
 781      *
 782      * Supposing we have  {@code BooleanProperty acmeProperty()}, then the
 783      * property-name  is &quot;acme&quot;.
 784      *
 785      * Property field, one may or may not exist and could be private, and
 786      * should match the property-method.
 787      *
 788      * A property-setter is a method starting with &quot;set&quot;, and the
 789      * first character of the upper-cased starting character of the property name, the
 790      * method must take 1 argument and must return a &lt;code&gt;void&lt;/code&gt;.
 791      *
 792      * Using the above example {@code void setAcme(Something s)} can be
 793      * considered as a property-setter of the property &quot;acme&quot;.
 794      *
 795      * A property-getter is a method  starting with &quot;get&quot; and the first character
 796      * upper-cased property-name, having no parameters. A method that does not take any
 797      * parameters and starting with &quot;is&quot; and an upper-cased property-name,
 798      * returning a primitive type boolean or BooleanProperty can also be
 799      * considered as a getter, however there must be only one getter for every property.
 800      *
 801      * For example {@code Object getAcme()} is a property-getter, and
 802      * {@code boolean isFoo()}
 803      */
 804     private void computeVisibleProperties(LocalMemberTable lmt) {
 805         if (!options.javafx())
 806             return;
 807 
 808         PropertyUtils pUtils = config.propertyUtils;
 809         List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
 810                 .stream()
 811                 .map(m -&gt; (ExecutableElement)m)
 812                 .filter(pUtils::isPropertyMethod)
 813                 .collect(Collectors.toList());
 814 
 815         visibleMembers.put(Kind.PROPERTIES, Collections.unmodifiableList(list));
 816 
 817         List&lt;ExecutableElement&gt; propertyMethods = list.stream()
 818                 .filter(e -&gt; utils.getEnclosingTypeElement(e) == te)
 819                 .collect(Collectors.toList());
 820 
 821         // Compute additional properties related sundries.
 822         for (ExecutableElement propertyMethod : propertyMethods) {
 823             String baseName = pUtils.getBaseName(propertyMethod);
 824             List&lt;Element&gt; flist = lmt.getMembers(baseName, Kind.FIELDS);
 825             Element field = flist.isEmpty() ? null : flist.get(0);
 826 
 827             Element getter = null, setter = null;
 828             List&lt;Element&gt; found = lmt.getPropertyMethods(pUtils.getGetName(propertyMethod), 0);
 829             if (!found.isEmpty()) {
 830                 // Getters have zero params, no overloads! pick the first.
 831                 getter = found.get(0);
 832             }
 833             if (getter == null) {
 834                 // Check if isProperty methods are present ?
 835                 found = lmt.getPropertyMethods(pUtils.getIsName(propertyMethod), 0);
 836                 if (!found.isEmpty()) {
 837                     String propertyTypeName = propertyMethod.getReturnType().toString();
 838                     // Check if the return type of property method matches an isProperty method.
 839                     if (pUtils.hasIsMethod(propertyMethod)) {
 840                         // Getters have zero params, no overloads!, pick the first.
 841                         getter = found.get(0);
 842                     }
 843                 }
 844             }
 845             found = lmt.getPropertyMethods(pUtils.getSetName(propertyMethod), 1);
 846             if (found != null) {
 847                 for (Element e : found) {
 848                     if (pUtils.isValidSetterMethod((ExecutableElement)e)) {
 849                         setter = e;
 850                         break;
 851                     }
 852                 }
 853             }
 854 
 855             propertyMap.put(propertyMethod, new PropertyMembers((VariableElement)field,
 856                     (ExecutableElement)getter, (ExecutableElement)setter));
 857 
 858             // Debugging purposes
 859             // System.out.println(&quot;te: &quot; + te + &quot;: &quot; + utils.getEnclosingTypeElement(propertyMethod) +
 860             //        &quot;:&quot; + propertyMethod.toString() + &quot;-&gt;&quot; + propertyMap.get(propertyMethod));
 861         }
 862     }
 863 
 864 
 865     // Future cleanups
 866 
 867     Map&lt;ExecutableElement, SoftReference&lt;ImplementedMethods&gt;&gt; implementMethodsFinders = new HashMap&lt;&gt;();
 868 
 869     private ImplementedMethods getImplementedMethodsFinder(ExecutableElement method) {
 870         SoftReference&lt;ImplementedMethods&gt; imf = implementMethodsFinders.get(method);
 871         // IMF does not exist or referent was gc&#39;ed away ?
 872         if (imf == null || imf.get() == null) {
 873             imf = new SoftReference&lt;&gt;(new ImplementedMethods(method));
 874             implementMethodsFinders.put(method, imf);
 875         }
 876         return imf.get();
 877     }
 878 
 879     public List&lt;ExecutableElement&gt; getImplementedMethods(ExecutableElement method) {
 880         ImplementedMethods imf = getImplementedMethodsFinder(method);
 881         return imf.getImplementedMethods().stream()
 882                 .filter(m -&gt; getSimplyOverriddenMethod(m) == null)
 883                 .collect(Collectors.toList());
 884     }
 885 
 886     public TypeMirror getImplementedMethodHolder(ExecutableElement method,
 887                                                  ExecutableElement implementedMethod) {
 888         ImplementedMethods imf = getImplementedMethodsFinder(method);
 889         return imf.getMethodHolder(implementedMethod);
 890     }
 891 
 892     private class ImplementedMethods {
 893 
 894         private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
 895         private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
 896         private final TypeElement typeElement;
 897         private final ExecutableElement method;
 898 
 899         public ImplementedMethods(ExecutableElement method) {
 900             this.method = method;
 901             typeElement = utils.getEnclosingTypeElement(method);
 902             Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
 903             /*
 904              * Search for the method in the list of interfaces. If found check if it is
 905              * overridden by any other subinterface method which this class
 906              * implements. If it is not overridden, add it in the method list.
 907              * Do this recursively for all the extended interfaces for each interface
 908              * from the list.
 909              */
 910             for (TypeMirror interfaceType : intfacs) {
 911                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
 912                 if (found != null) {
 913                     removeOverriddenMethod(found);
 914                     if (!overridingMethodFound(found)) {
 915                         methlist.add(found);
 916                         interfaces.put(found, interfaceType);
 917                     }
 918                 }
 919             }
 920         }
 921 
 922         /**
 923          * Return the list of interface methods which the method passed in the
 924          * constructor is implementing. The search/build order is as follows:
 925          * &lt;pre&gt;
 926          * 1. Search in all the immediate interfaces which this method&#39;s class is
 927          *    implementing. Do it recursively for the superinterfaces as well.
 928          * 2. Traverse all the superclasses and search recursively in the
 929          *    interfaces which those superclasses implement.
 930          *&lt;/pre&gt;
 931          *
 932          * @return SortedSet&lt;ExecutableElement&gt; of implemented methods.
 933          */
 934         List&lt;ExecutableElement&gt; getImplementedMethods() {
 935             return methlist;
 936         }
 937 
 938         TypeMirror getMethodHolder(ExecutableElement ee) {
 939             return interfaces.get(ee);
 940         }
 941 
 942         /**
 943          * Search in the method list and check if it contains a method which
 944          * is overridden by the method as parameter.  If found, remove the
 945          * overridden method from the method list.
 946          *
 947          * @param method Is this method overriding a method in the method list.
 948          */
 949         private void removeOverriddenMethod(ExecutableElement method) {
 950             TypeElement overriddenClass = utils.overriddenClass(method);
 951             if (overriddenClass != null) {
 952                 for (int i = 0; i &lt; methlist.size(); i++) {
 953                     TypeElement te = utils.getEnclosingTypeElement(methlist.get(i));
 954                     if (te == overriddenClass || utils.isSubclassOf(overriddenClass, te)) {
 955                         methlist.remove(i);  // remove overridden method
 956                         return;
 957                     }
 958                 }
 959             }
 960         }
 961 
 962         /**
 963          * Search in the already found methods&#39; list and check if it contains
 964          * a method which is overriding the method parameter or is the method
 965          * parameter itself.
 966          *
 967          * @param method method to be searched
 968          */
 969         private boolean overridingMethodFound(ExecutableElement method) {
 970             TypeElement containingClass = utils.getEnclosingTypeElement(method);
 971             for (ExecutableElement listmethod : methlist) {
 972                 if (containingClass == utils.getEnclosingTypeElement(listmethod)) {
 973                     // it&#39;s the same method.
 974                     return true;
 975                 }
 976                 TypeElement te = utils.overriddenClass(listmethod);
 977                 if (te == null) {
 978                     continue;
 979                 }
 980                 if (te == containingClass || utils.isSubclassOf(te, containingClass)) {
 981                     return true;
 982                 }
 983             }
 984             return false;
 985         }
 986     }
 987 
 988     /**
 989      * A simple container to encapsulate an overriding method
 990      * and the type of override.
 991      */
 992     static class OverridingMethodInfo {
 993         final ExecutableElement overrider;
 994         final boolean simpleOverride;
 995 
 996         public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
 997             this.overrider = overrider;
 998             this.simpleOverride = simpleOverride;
 999         }
1000 
1001         @Override
1002         public String toString() {
1003             return &quot;OverridingMethodInfo[&quot; + overrider + &quot;,simple:&quot; + simpleOverride + &quot;]&quot;;
1004         }
1005     }
1006 }
    </pre>
  </body>
</html>
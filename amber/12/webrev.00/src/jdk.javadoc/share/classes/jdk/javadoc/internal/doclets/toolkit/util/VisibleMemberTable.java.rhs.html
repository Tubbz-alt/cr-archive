<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/VisibleMemberTable.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2018, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.javadoc.internal.doclets.toolkit.util;
 27 
 28 import javax.lang.model.element.Element;
 29 import javax.lang.model.element.ExecutableElement;
 30 import javax.lang.model.element.TypeElement;
 31 import javax.lang.model.element.VariableElement;
 32 import javax.lang.model.type.TypeKind;
 33 import javax.lang.model.type.TypeMirror;
 34 import javax.lang.model.util.Elements;
 35 import javax.lang.model.util.SimpleElementVisitor14;
 36 import java.lang.ref.SoftReference;
 37 import java.util.ArrayList;
 38 import java.util.Collections;
 39 import java.util.EnumMap;
 40 import java.util.EnumSet;
 41 import java.util.HashMap;
 42 import java.util.LinkedHashMap;
 43 import java.util.LinkedHashSet;
 44 import java.util.List;
 45 import java.util.Map;
 46 import java.util.Set;
 47 import java.util.function.Predicate;
 48 import java.util.stream.Collectors;
 49 
 50 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 51 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 52 import jdk.javadoc.internal.doclets.toolkit.PropertyUtils;
 53 
 54 /**
 55  * This class computes the main data structure for the doclet&#39;s
 56  * operations. Essentially, the implementation encapsulating the
 57  * javax.lang.models view of what can be documented about a
 58  * type element&#39;s members.
 59  * &lt;p&gt;
 60  * The general operations are as follows:
 61  * &lt;p&gt;
 62  * Members: these are the members from jx.l.m&#39;s view but
 63  * are structured along the kinds of this class.
 64  * &lt;p&gt;
 65  * Extra Members: these are members enclosed in an undocumented
 66  * package-private type element, and may not be linkable (or documented),
 67  * however, the members of such a type element may be documented, as if
 68  * declared in the sub type, only if the enclosing type is not being
 69  * documented by a filter such as -public, -protected, etc.
 70  * &lt;p&gt;
 71  * Visible Members: these are the members that are &quot;visible&quot;
 72  * and available and should be documented, in a type element.
 73  * &lt;p&gt;
 74  * The basic rule for computation: when considering a type element,
 75  * besides its immediate direct types and interfaces, the computation
 76  * should not expand to any other type in the inheritance hierarchy.
 77  * &lt;p&gt;
 78  * This table generates all the data structures it needs for each
 79  * type, as its own view, and will present some form of this to the
 80  * doclet as and when required to.
 81  *
 82  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 83  * If you write code that depends on this, you do so at your own risk.
 84  * This code and its internal interfaces are subject to change or
 85  * deletion without notice.&lt;/b&gt;
 86  *
 87  */
 88 
 89 public class VisibleMemberTable {
 90 
 91     public enum Kind {
 92         INNER_CLASSES,
 93         ENUM_CONSTANTS,
 94         FIELDS,
 95         CONSTRUCTORS,
 96         METHODS,
<a name="1" id="anc1"></a>
 97         ANNOTATION_TYPE_MEMBER_OPTIONAL,
 98         ANNOTATION_TYPE_MEMBER_REQUIRED,
 99         PROPERTIES;
100 
101         public static final EnumSet&lt;Kind&gt; summarySet = EnumSet.range(INNER_CLASSES, METHODS);
102         public static final EnumSet&lt;Kind&gt; detailSet = EnumSet.range(ENUM_CONSTANTS, METHODS);
103     }
104 
105     final TypeElement te;
106     final TypeElement parent;
107 
108     final BaseConfiguration config;
109     final BaseOptions options;
110     final Utils utils;
111     final VisibleMemberCache mcache;
112 
113     private List&lt;VisibleMemberTable&gt; allSuperclasses;
114     private List&lt;VisibleMemberTable&gt; allSuperinterfaces;
115     private List&lt;VisibleMemberTable&gt; parents;
116 
<a name="2" id="anc2"></a>

117     private Map&lt;Kind, List&lt;Element&gt;&gt; visibleMembers = null;
118     private Map&lt;ExecutableElement, PropertyMembers&gt; propertyMap = new HashMap&lt;&gt;();
119 
120     // Keeps track of method overrides
121     Map&lt;ExecutableElement, OverridingMethodInfo&gt; overriddenMethodTable
122             = new LinkedHashMap&lt;&gt;();
123 
124     protected VisibleMemberTable(TypeElement typeElement, BaseConfiguration configuration,
125                                  VisibleMemberCache mcache) {
126         config = configuration;
127         utils = configuration.utils;
128         options = configuration.getOptions();
129         te = typeElement;
130         parent = utils.getSuperClass(te);
131         this.mcache = mcache;
132         allSuperclasses = new ArrayList&lt;&gt;();
133         allSuperinterfaces = new ArrayList&lt;&gt;();
134         parents = new ArrayList&lt;&gt;();
135     }
136 
137     private synchronized void ensureInitialized() {
138         if (visibleMembers != null)
139             return;
140 
141         visibleMembers = new EnumMap&lt;&gt;(Kind.class);
142         for (Kind kind : Kind.values()) {
143             visibleMembers.put(kind, new ArrayList&lt;&gt;());
144         }
145         computeParents();
146         computeVisibleMembers();
147     }
148 
<a name="3" id="anc3"></a>




149     List&lt;VisibleMemberTable&gt; getAllSuperclasses() {
150         ensureInitialized();
151         return allSuperclasses;
152     }
153 
154     List&lt;VisibleMemberTable&gt; getAllSuperinterfaces() {
155         ensureInitialized();
156         return allSuperinterfaces;
157     }
158 
159     /**
160      * Returns a list of all visible enclosed members of a type element,
161      * and inherited members.
162      * &lt;p&gt;
163      * Notes:
164      * a. The list may or may not contain simple overridden methods.
165      * A simple overridden method is one that overrides a super method
166      * with no specification changes as indicated by the existence of a
167      * sole &amp;commat;inheritDoc or devoid of any API comments.
168      * &lt;p&gt;
169      * b.The list may contain (extra) members, inherited by inaccessible
170      * super types, primarily package private types. These members are
171      * required to be documented in the subtype when the super type is
172      * not documented.
173      *
174      * @param kind the member kind
175      * @return a list of all visible members
176      */
177     public List&lt;? extends Element&gt; getAllVisibleMembers(Kind kind) {
178         ensureInitialized();
179         return visibleMembers.getOrDefault(kind, Collections.emptyList());
180     }
181 
182     /**
183      * Returns a list of visible enclosed members of a specified kind,
184      * filtered by the specified predicate.
185      * @param kind the member kind
186      * @param p the predicate used to filter the output
187      * @return a list of visible enclosed members
188      */
189     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind, Predicate&lt;Element&gt; p) {
190         ensureInitialized();
191 
192         return visibleMembers.getOrDefault(kind, Collections.emptyList()).stream()
193                 .filter(p)
194                 .collect(Collectors.toList());
195     }
196 
197     /**
198      * Returns a list of all enclosed members including any extra members.
199      * Typically called by various builders.
200      *
201      * @param kind the member kind
202      * @return a list of visible enclosed members
203      */
204     public List&lt;? extends Element&gt; getVisibleMembers(Kind kind) {
205         Predicate&lt;Element&gt; declaredAndLeafMembers = e -&gt; {
206             TypeElement encl = utils.getEnclosingTypeElement(e);
207             return encl == te || utils.isUndocumentedEnclosure(encl);
208         };
209         return getVisibleMembers(kind, declaredAndLeafMembers);
210     }
211 
212     /**
213      * Returns a list of visible enclosed members of given kind,
214      * declared in this type element, and does not include
215      * any inherited members or extra members.
216      *
217      * @return a list of visible enclosed members in this type
218      */
219     public List&lt;? extends Element&gt; getMembers(Kind kind) {
220         Predicate&lt;Element&gt; onlyLocallyDeclaredMembers = e -&gt; utils.getEnclosingTypeElement(e) == te;
221         return getVisibleMembers(kind, onlyLocallyDeclaredMembers);
222     }
223 
224     /**
225      * Returns the overridden method, if it is simply overriding or the
226      * method is a member of a package private type, this method is
227      * primarily used to determine the location of a possible comment.
228      *
229      * @param e the method to check
230      * @return the method found or null
231      */
232     public ExecutableElement getOverriddenMethod(ExecutableElement e) {
233         ensureInitialized();
234 
235         OverridingMethodInfo found = overriddenMethodTable.get(e);
236         if (found != null
237                 &amp;&amp; (found.simpleOverride || utils.isUndocumentedEnclosure(utils.getEnclosingTypeElement(e)))) {
238             return found.overrider;
239         }
240         return null;
241     }
242 
243     /**
244      * Returns the simply overridden method.
245      * @param e the method to check
246      * @return the overridden method or null
247      */
248     public ExecutableElement getSimplyOverriddenMethod(ExecutableElement e) {
249         ensureInitialized();
250 
251         OverridingMethodInfo found = overriddenMethodTable.get(e);
252         if (found != null &amp;&amp; found.simpleOverride) {
253             return found.overrider;
254         }
255         return null;
256     }
257 
258     /**
259      * Returns a set of visible type elements in this type element&#39;s lineage.
260      * &lt;p&gt;
261      * This method returns the super-types in the inheritance
262      * order C, B, A, j.l.O. The super-interfaces however are
263      * alpha sorted and appended to the resulting set.
264      *
265      * @return the list of visible classes in this map.
266      */
267     public Set&lt;TypeElement&gt; getVisibleTypeElements() {
268         ensureInitialized();
269         Set&lt;TypeElement&gt; result = new LinkedHashSet&lt;&gt;();
270 
271         // Add this type element first.
272         result.add(te);
273 
274         // Add the super classes.
275         allSuperclasses.stream()
276                 .map(vmt -&gt; vmt.te)
277                 .forEach(result::add);
278 
279         // ... and finally the sorted super interfaces.
280         allSuperinterfaces.stream()
281                 .map(vmt -&gt; vmt.te)
<a name="4" id="anc4"></a><span class="line-modified">282                 .sorted(utils.comparators.makeGeneralPurposeComparator())</span>
283                 .forEach(result::add);
284 
285         return result;
286     }
287 
288     /**
289      * Returns true if this table contains visible members.
290      *
291      * @return true if visible members are present.
292      */
293     public boolean hasVisibleMembers() {
294         for (Kind kind : Kind.values()) {
295             if (hasVisibleMembers(kind))
296                 return true;
297         }
298         return false;
299     }
300 
301     /**
302      * Returns true if this table contains visible members of
303      * the specified kind, including inherited members.
304      *
305      * @return true if visible members are present.
306      */
307     public boolean hasVisibleMembers(Kind kind) {
308         ensureInitialized();
309         List&lt;Element&gt; elements = visibleMembers.get(kind);
310         return elements != null &amp;&amp; !elements.isEmpty();
311     }
312 
313     /**
314      * Returns the property field associated with the property method.
315      * @param propertyMethod the identifying property method
316      * @return the field or null if absent
317      */
318     public VariableElement getPropertyField(ExecutableElement propertyMethod) {
319         ensureInitialized();
320         PropertyMembers pm =  propertyMap.get(propertyMethod);
321         return pm == null ? null : pm.field;
322     }
323 
324     /**
325      * Returns the getter method associated with the property method.
326      * @param propertyMethod the identifying property method
327      * @return the getter or null if absent
328      */
329     public ExecutableElement getPropertyGetter(ExecutableElement propertyMethod) {
330         ensureInitialized();
331         PropertyMembers pm =  propertyMap.get(propertyMethod);
332         return pm == null ? null : pm.getter;
333     }
334 
335     /**
336      * Returns the setter method associated with the property method.
337      * @param propertyMethod the identifying property method
338      * @return the setter or null if absent
339      */
340     public ExecutableElement getPropertySetter(ExecutableElement propertyMethod) {
341         ensureInitialized();
342         PropertyMembers pm =  propertyMap.get(propertyMethod);
343         return pm == null ? null : pm.setter;
344     }
345 
346     private void computeParents() {
<a name="5" id="anc5"></a><span class="line-added">347         // suppress parents of annotation types</span>
<span class="line-added">348         if (utils.isAnnotationType(te)) {</span>
<span class="line-added">349             return;</span>
<span class="line-added">350         }</span>
<span class="line-added">351 </span>
352         for (TypeMirror intfType : te.getInterfaces()) {
353             TypeElement intfc = utils.asTypeElement(intfType);
354             if (intfc != null) {
355                 VisibleMemberTable vmt = mcache.getVisibleMemberTable(intfc);
356                 allSuperinterfaces.add(vmt);
357                 parents.add(vmt);
358                 allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
359             }
360         }
361 
362         if (parent != null) {
363             VisibleMemberTable vmt = mcache.getVisibleMemberTable(parent);
364             allSuperclasses.add(vmt);
365             allSuperclasses.addAll(vmt.getAllSuperclasses());
366             // Add direct super interfaces of a super class, if any.
367             allSuperinterfaces.addAll(vmt.getAllSuperinterfaces());
368             parents.add(vmt);
369         }
370     }
371 
372     private void computeVisibleMembers() {
373 
374         // Note: these have some baggage, and are redundant,
375         // allow this to be GC&#39;ed.
376         LocalMemberTable lmt = new LocalMemberTable();
377 
378         for (Kind k : Kind.values()) {
<a name="6" id="anc6"></a>
379             computeVisibleMembers(lmt, k);
380         }
381         // All members have been computed, compute properties.
382         computeVisibleProperties(lmt);
383     }
384 
<a name="7" id="anc7"></a>







385 
386     void computeVisibleMembers(LocalMemberTable lmt, Kind kind) {
387         switch (kind) {
388             case FIELDS: case INNER_CLASSES:
389                 computeVisibleFieldsAndInnerClasses(lmt, kind);
390                 return;
391 
392             case METHODS:
393                 computeVisibleMethods(lmt);
394                 return;
395 
396             // Defer properties related computations for later.
397             case PROPERTIES:
398                 return;
399 
400             default:
401                 List&lt;Element&gt; list = lmt.getOrderedMembers(kind).stream()
402                         .filter(this::mustDocument)
403                         .collect(Collectors.toList());
404                 visibleMembers.put(kind, Collections.unmodifiableList(list));
405                 break;
406         }
407     }
408 
409     private boolean mustDocument(Element e) {
410         return !utils.hasHiddenTag(e) &amp;&amp; utils.shouldDocument(e);
411     }
412 
413     private boolean allowInheritedMembers(Element e, Kind kind, LocalMemberTable lmt) {
414         return isInherited(e) &amp;&amp; !isMemberHidden(e, kind, lmt);
415     }
416 
417     private boolean isInherited(Element e) {
418         if (utils.isPrivate(e))
419             return false;
420 
421         if (utils.isPackagePrivate(e))
422             // Allowed iff this type-element is in the same package as the element
423             return utils.containingPackage(e).equals(utils.containingPackage(te));
424 
425         return true;
426     }
427 
428     private boolean isMemberHidden(Element inheritedMember, Kind kind, LocalMemberTable lmt) {
429         Elements elementUtils = config.docEnv.getElementUtils();
430         switch(kind) {
431             default:
432                 List&lt;Element&gt; list = lmt.getMembers(inheritedMember, kind);
433                 if (list.isEmpty())
434                     return false;
435                 return elementUtils.hides(list.get(0), inheritedMember);
436             case METHODS: case CONSTRUCTORS: // Handled elsewhere.
437                 throw new IllegalArgumentException(&quot;incorrect kind&quot;);
438         }
439     }
440 
441     private void computeVisibleFieldsAndInnerClasses(LocalMemberTable lmt, Kind kind) {
442         Set&lt;Element&gt; result = new LinkedHashSet&lt;&gt;();
443         for (VisibleMemberTable pvmt : parents) {
<a name="8" id="anc8"></a>
444             result.addAll(pvmt.getAllVisibleMembers(kind));
445         }
446 
447         // Filter out members in the inherited list that are hidden
448         // by this type or should not be inherited at all.
449         List&lt;Element&gt; list = result.stream()
450                 .filter(e -&gt; allowInheritedMembers(e, kind, lmt))
451                 .collect(Collectors.toList());
452 
453         // Prefix local results first
454         list.addAll(0, lmt.getOrderedMembers(kind));
455 
456         // Filter out elements that should not be documented
457         list = list.stream()
458                 .filter(this::mustDocument)
459                 .collect(Collectors.toList());
460 
461         visibleMembers.put(kind, Collections.unmodifiableList(list));
462     }
463 
464     private void computeVisibleMethods(LocalMemberTable lmt) {
465         Set&lt;Element&gt; inheritedMethods = new LinkedHashSet&lt;&gt;();
466         Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; overriddenByTable = new HashMap&lt;&gt;();
467         for (VisibleMemberTable pvmt : parents) {
468             // Merge the lineage overrides into local table
469             pvmt.overriddenMethodTable.entrySet().forEach(e -&gt; {
470                 OverridingMethodInfo p = e.getValue();
471                 if (!p.simpleOverride) { // consider only real overrides
472                     List&lt;ExecutableElement&gt; list = overriddenByTable.computeIfAbsent(p.overrider,
473                             k -&gt; new ArrayList&lt;&gt;());
474                     list.add(e.getKey());
475                 }
476             });
477             inheritedMethods.addAll(pvmt.getAllVisibleMembers(Kind.METHODS));
<a name="9" id="anc9"></a>

























478         }
479 
480         // Filter out inherited methods that:
481         // a. cannot override (private instance members)
482         // b. are overridden and should not be visible in this type
483         // c. are hidden in the type being considered
484         // see allowInheritedMethods, which performs the above actions
485         List&lt;Element&gt; list = inheritedMethods.stream()
486                 .filter(e -&gt; allowInheritedMethods((ExecutableElement) e, overriddenByTable, lmt))
487                 .collect(Collectors.toList());
488 
489         // Filter out the local methods, that do not override or simply
490         // overrides a super method, or those methods that should not
491         // be visible.
492         Predicate&lt;ExecutableElement&gt; isVisible = m -&gt; {
493             OverridingMethodInfo p = overriddenMethodTable.getOrDefault(m, null);
494             return p == null || !p.simpleOverride;
495         };
<a name="10" id="anc10"></a><span class="line-modified">496         List&lt;Element&gt; localList = lmt.getOrderedMembers(Kind.METHODS)</span>
<span class="line-modified">497                 .stream()</span>
498                 .map(m -&gt; (ExecutableElement)m)
499                 .filter(isVisible)
500                 .collect(Collectors.toList());
501 
<a name="11" id="anc11"></a><span class="line-modified">502         // Merge the above lists, making sure the local methods precede the others</span>
<span class="line-modified">503         list.addAll(0, localList);</span>

504 
505         // Final filtration of elements
506         list = list.stream()
507                 .filter(this::mustDocument)
508                 .collect(Collectors.toList());
509 
510         visibleMembers.put(Kind.METHODS, Collections.unmodifiableList(list));
511 
512         // Copy over overridden tables from the lineage, and finish up.
513         for (VisibleMemberTable pvmt : parents) {
514             overriddenMethodTable.putAll(pvmt.overriddenMethodTable);
515         }
516         overriddenMethodTable = Collections.unmodifiableMap(overriddenMethodTable);
517     }
518 
519     boolean isEnclosureInterface(Element e) {
520         TypeElement enclosing = utils.getEnclosingTypeElement(e);
521         return utils.isInterface(enclosing);
522     }
523 
524     boolean allowInheritedMethods(ExecutableElement inheritedMethod,
525                                   Map&lt;ExecutableElement, List&lt;ExecutableElement&gt;&gt; inheritedOverriddenTable,
526                                   LocalMemberTable lmt) {
527         if (!isInherited(inheritedMethod))
528             return false;
529 
530         final boolean haveStatic = utils.isStatic(inheritedMethod);
531         final boolean inInterface = isEnclosureInterface(inheritedMethod);
532 
533         // Static methods in interfaces are never documented.
534         if (haveStatic &amp;&amp; inInterface) {
535             return false;
536         }
537 
538         // Multiple-Inheritance: remove the interface method that may have
539         // been overridden by another interface method in the hierarchy
540         //
541         // Note: The following approach is very simplistic and is compatible
542         // with old VMM. A future enhancement, may include a contention breaker,
543         // to correctly eliminate those methods that are merely definitions
544         // in favor of concrete overriding methods, for instance those that have
545         // API documentation and are not abstract OR default methods.
546         if (inInterface) {
547             List&lt;ExecutableElement&gt; list = inheritedOverriddenTable.get(inheritedMethod);
548             if (list != null) {
549                 boolean found = list.stream()
550                         .anyMatch(this::isEnclosureInterface);
551                 if (found)
552                     return false;
553             }
554         }
555 
556         Elements elementUtils = config.docEnv.getElementUtils();
557 
558         // Check the local methods in this type.
559         List&lt;Element&gt; lMethods = lmt.getMembers(inheritedMethod, Kind.METHODS);
560         for (Element le : lMethods) {
561             ExecutableElement lMethod = (ExecutableElement) le;
562             // Ignore private methods or those methods marked with
563             // a &quot;hidden&quot; tag.
564             if (utils.isPrivate(lMethod))
565                 continue;
566 
567             // Remove methods that are &quot;hidden&quot;, in JLS terms.
568             if (haveStatic &amp;&amp; utils.isStatic(lMethod) &amp;&amp;
569                     elementUtils.hides(lMethod, inheritedMethod)) {
570                 return false;
571             }
572 
573             // Check for overriding methods.
574             if (elementUtils.overrides(lMethod, inheritedMethod,
575                     utils.getEnclosingTypeElement(lMethod))) {
576 
577                 // Disallow package-private super methods to leak in
578                 TypeElement encl = utils.getEnclosingTypeElement(inheritedMethod);
579                 if (utils.isUndocumentedEnclosure(encl)) {
580                     overriddenMethodTable.computeIfAbsent(lMethod,
581                             l -&gt; new OverridingMethodInfo(inheritedMethod, false));
582                     return false;
583                 }
584 
585                 TypeMirror inheritedMethodReturn = inheritedMethod.getReturnType();
586                 TypeMirror lMethodReturn = lMethod.getReturnType();
587                 boolean covariantReturn =
588                         lMethodReturn.getKind() == TypeKind.DECLARED
589                         &amp;&amp; inheritedMethodReturn.getKind() == TypeKind.DECLARED
590                         &amp;&amp; !utils.typeUtils.isSameType(lMethodReturn, inheritedMethodReturn)
591                         &amp;&amp; utils.typeUtils.isSubtype(lMethodReturn, inheritedMethodReturn);
592                 boolean simpleOverride = covariantReturn ? false : utils.isSimpleOverride(lMethod);
593                 overriddenMethodTable.computeIfAbsent(lMethod,
594                         l -&gt; new OverridingMethodInfo(inheritedMethod, simpleOverride));
595                 return simpleOverride;
596             }
597         }
598         return true;
599     }
600 
601     /*
602      * This class encapsulates the details of local members, orderedMembers
603      * contains the members in the declaration order, additionally a
604      * HashMap is maintained for performance optimization to lookup
605      * members. As a future enhancement is perhaps to consolidate the ordering
606      * into a Map, capturing the insertion order, thereby eliminating an
607      * ordered list.
608      */
609     class LocalMemberTable {
610 
611         // Maintains declaration order
612         private final Map&lt;Kind, List&lt;Element&gt;&gt; orderedMembers;
613 
614         // Performance optimization
615         private final Map&lt;Kind, Map&lt;String, List&lt;Element&gt;&gt;&gt; memberMap;
616 
617         LocalMemberTable() {
618             orderedMembers = new EnumMap&lt;&gt;(Kind.class);
619             memberMap = new EnumMap&lt;&gt;(Kind.class);
620 
621             List&lt;? extends Element&gt; elements = te.getEnclosedElements();
622             for (Element e : elements) {
623                 if (options.noDeprecated() &amp;&amp; utils.isDeprecated(e)) {
624                     continue;
625                 }
626                 switch (e.getKind()) {
627                     case CLASS:
628                     case INTERFACE:
629                     case ENUM:
630                     case ANNOTATION_TYPE:
631                     case RECORD:
632                         addMember(e, Kind.INNER_CLASSES);
633                         break;
634                     case FIELD:
635                         addMember(e, Kind.FIELDS);
<a name="12" id="anc12"></a>
636                         break;
637                     case METHOD:
<a name="13" id="anc13"></a>
638                         if (utils.isAnnotationType(te)) {
<a name="14" id="anc14"></a><span class="line-added">639                             ExecutableElement ee = (ExecutableElement) e;</span>
640                             addMember(e, ee.getDefaultValue() == null
641                                     ? Kind.ANNOTATION_TYPE_MEMBER_REQUIRED
642                                     : Kind.ANNOTATION_TYPE_MEMBER_OPTIONAL);
<a name="15" id="anc15"></a><span class="line-added">643                         } else {</span>
<span class="line-added">644                             addMember(e, Kind.METHODS);</span>
645                         }
<a name="16" id="anc16"></a>
646                         break;
647                     case CONSTRUCTOR:
648                             addMember(e, Kind.CONSTRUCTORS);
649                         break;
650                     case ENUM_CONSTANT:
651                         addMember(e, Kind.ENUM_CONSTANTS);
652                         break;
653                 }
654             }
655 
656             // Freeze the data structures
657             for (Kind kind : Kind.values()) {
658                 orderedMembers.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableList(v));
659                 orderedMembers.computeIfAbsent(kind, t -&gt; Collections.emptyList());
660 
661                 memberMap.computeIfPresent(kind, (k, v) -&gt; Collections.unmodifiableMap(v));
662                 memberMap.computeIfAbsent(kind, t -&gt; Collections.emptyMap());
663             }
664         }
665 
666         @SuppressWarnings(&quot;preview&quot;)
667         String getMemberKey(Element e) {
668             return new SimpleElementVisitor14&lt;String, Void&gt;() {
669                 @Override
670                 public String visitExecutable(ExecutableElement e, Void aVoid) {
671                     return e.getSimpleName() + &quot;:&quot; + e.getParameters().size();
672                 }
673 
674                 @Override
675                 protected String defaultAction(Element e, Void aVoid) {
676                     return e.getSimpleName().toString();
677                 }
678             }.visit(e);
679         }
680 
681         void addMember(Element e, Kind kind) {
682             List&lt;Element&gt; list = orderedMembers.computeIfAbsent(kind, k -&gt; new ArrayList&lt;&gt;());
683             list.add(e);
684 
685             Map&lt;String, List&lt;Element&gt;&gt; map = memberMap.computeIfAbsent(kind, k -&gt; new HashMap&lt;&gt;());
686             list = map.computeIfAbsent(getMemberKey(e), l -&gt; new ArrayList&lt;&gt;());
687             list.add(e);
688         }
689 
690         List&lt;Element&gt; getOrderedMembers(Kind kind) {
691             return orderedMembers.get(kind);
692         }
693 
694         List&lt;Element&gt; getMembers(Element e, Kind kind) {
695             String key = getMemberKey(e);
696             return getMembers(key, kind);
697         }
698 
699         List&lt;Element&gt; getMembers(String key, Kind kind) {
700             Map &lt;String, List&lt;Element&gt;&gt; map = memberMap.get(kind);
701             return map.getOrDefault(key, Collections.emptyList());
702         }
703 
704         List&lt;Element&gt; getPropertyMethods(String methodName, int argcount) {
705             return getMembers(methodName + &quot;:&quot; + argcount, Kind.METHODS).stream()
706                     .filter(m -&gt; (utils.isPublic(m) || utils.isProtected(m)))
707                     .collect(Collectors.toList());
708         }
709     }
710 
711     /**
712      * The properties triad for a property method.
713      */
714     static class PropertyMembers {
715         final VariableElement field;
716         final ExecutableElement getter;
717         final ExecutableElement setter;
718 
719         PropertyMembers(VariableElement field, ExecutableElement getter, ExecutableElement setter) {
720             this.field = field;
721             this.getter = getter;
722             this.setter = setter;
723         }
724 
725         public String toString() {
726             return (&quot;field: &quot; + field + &quot;, getter: &quot; + getter + &quot;, setter: &quot; + setter);
727         }
728     }
729 
730     /*
731      * JavaFX convention notes.
732      * A JavaFX property-method is a method, which ends with &quot;Property&quot; in
733      * its name, takes no parameters and typically returns a subtype of javafx.beans.
734      * ReadOnlyProperty, in the strictest sense. However, it may not always
735      * be possible for the doclet to have access to j.b.ReadOnlyProperty,
736      * for this reason the strict check is disabled via an undocumented flag.
737      *
738      * Note, a method should not be considered as a property-method,
739      * if it satisfied the previously stated conditions AND if the
740      * method begins with &quot;set&quot;, &quot;get&quot; or &quot;is&quot;.
741      *
742      * Supposing we have  {@code BooleanProperty acmeProperty()}, then the
743      * property-name  is &quot;acme&quot;.
744      *
745      * Property field, one may or may not exist and could be private, and
746      * should match the property-method.
747      *
748      * A property-setter is a method starting with &quot;set&quot;, and the
749      * first character of the upper-cased starting character of the property name, the
750      * method must take 1 argument and must return a &lt;code&gt;void&lt;/code&gt;.
751      *
752      * Using the above example {@code void setAcme(Something s)} can be
753      * considered as a property-setter of the property &quot;acme&quot;.
754      *
755      * A property-getter is a method  starting with &quot;get&quot; and the first character
756      * upper-cased property-name, having no parameters. A method that does not take any
757      * parameters and starting with &quot;is&quot; and an upper-cased property-name,
758      * returning a primitive type boolean or BooleanProperty can also be
759      * considered as a getter, however there must be only one getter for every property.
760      *
761      * For example {@code Object getAcme()} is a property-getter, and
762      * {@code boolean isFoo()}
763      */
764     private void computeVisibleProperties(LocalMemberTable lmt) {
765         if (!options.javafx())
766             return;
767 
768         PropertyUtils pUtils = config.propertyUtils;
769         List&lt;ExecutableElement&gt; list = visibleMembers.getOrDefault(Kind.METHODS, Collections.emptyList())
770                 .stream()
771                 .map(m -&gt; (ExecutableElement)m)
772                 .filter(pUtils::isPropertyMethod)
773                 .collect(Collectors.toList());
774 
775         visibleMembers.put(Kind.PROPERTIES, Collections.unmodifiableList(list));
776 
777         List&lt;ExecutableElement&gt; propertyMethods = list.stream()
778                 .filter(e -&gt; utils.getEnclosingTypeElement(e) == te)
779                 .collect(Collectors.toList());
780 
781         // Compute additional properties related sundries.
782         for (ExecutableElement propertyMethod : propertyMethods) {
783             String baseName = pUtils.getBaseName(propertyMethod);
784             List&lt;Element&gt; flist = lmt.getMembers(baseName, Kind.FIELDS);
785             Element field = flist.isEmpty() ? null : flist.get(0);
786 
787             Element getter = null, setter = null;
788             List&lt;Element&gt; found = lmt.getPropertyMethods(pUtils.getGetName(propertyMethod), 0);
789             if (!found.isEmpty()) {
790                 // Getters have zero params, no overloads! pick the first.
791                 getter = found.get(0);
792             }
793             if (getter == null) {
794                 // Check if isProperty methods are present ?
795                 found = lmt.getPropertyMethods(pUtils.getIsName(propertyMethod), 0);
796                 if (!found.isEmpty()) {
797                     String propertyTypeName = propertyMethod.getReturnType().toString();
798                     // Check if the return type of property method matches an isProperty method.
799                     if (pUtils.hasIsMethod(propertyMethod)) {
800                         // Getters have zero params, no overloads!, pick the first.
801                         getter = found.get(0);
802                     }
803                 }
804             }
805             found = lmt.getPropertyMethods(pUtils.getSetName(propertyMethod), 1);
806             if (found != null) {
807                 for (Element e : found) {
808                     if (pUtils.isValidSetterMethod((ExecutableElement)e)) {
809                         setter = e;
810                         break;
811                     }
812                 }
813             }
814 
815             propertyMap.put(propertyMethod, new PropertyMembers((VariableElement)field,
816                     (ExecutableElement)getter, (ExecutableElement)setter));
817 
818             // Debugging purposes
819             // System.out.println(&quot;te: &quot; + te + &quot;: &quot; + utils.getEnclosingTypeElement(propertyMethod) +
820             //        &quot;:&quot; + propertyMethod.toString() + &quot;-&gt;&quot; + propertyMap.get(propertyMethod));
821         }
822     }
823 
824 
825     // Future cleanups
826 
827     Map&lt;ExecutableElement, SoftReference&lt;ImplementedMethods&gt;&gt; implementMethodsFinders = new HashMap&lt;&gt;();
828 
829     private ImplementedMethods getImplementedMethodsFinder(ExecutableElement method) {
830         SoftReference&lt;ImplementedMethods&gt; imf = implementMethodsFinders.get(method);
831         // IMF does not exist or referent was gc&#39;ed away ?
832         if (imf == null || imf.get() == null) {
833             imf = new SoftReference&lt;&gt;(new ImplementedMethods(method));
834             implementMethodsFinders.put(method, imf);
835         }
836         return imf.get();
837     }
838 
839     public List&lt;ExecutableElement&gt; getImplementedMethods(ExecutableElement method) {
840         ImplementedMethods imf = getImplementedMethodsFinder(method);
841         return imf.getImplementedMethods().stream()
842                 .filter(m -&gt; getSimplyOverriddenMethod(m) == null)
843                 .collect(Collectors.toList());
844     }
845 
846     public TypeMirror getImplementedMethodHolder(ExecutableElement method,
847                                                  ExecutableElement implementedMethod) {
848         ImplementedMethods imf = getImplementedMethodsFinder(method);
849         return imf.getMethodHolder(implementedMethod);
850     }
851 
852     private class ImplementedMethods {
853 
854         private final Map&lt;ExecutableElement, TypeMirror&gt; interfaces = new HashMap&lt;&gt;();
855         private final List&lt;ExecutableElement&gt; methlist = new ArrayList&lt;&gt;();
<a name="17" id="anc17"></a>

856 
857         public ImplementedMethods(ExecutableElement method) {
<a name="18" id="anc18"></a><span class="line-modified">858             TypeElement typeElement = utils.getEnclosingTypeElement(method);</span>

859             Set&lt;TypeMirror&gt; intfacs = utils.getAllInterfaces(typeElement);
860             /*
861              * Search for the method in the list of interfaces. If found check if it is
862              * overridden by any other subinterface method which this class
863              * implements. If it is not overridden, add it in the method list.
864              * Do this recursively for all the extended interfaces for each interface
865              * from the list.
866              */
867             for (TypeMirror interfaceType : intfacs) {
868                 ExecutableElement found = utils.findMethod(utils.asTypeElement(interfaceType), method);
869                 if (found != null) {
870                     removeOverriddenMethod(found);
871                     if (!overridingMethodFound(found)) {
872                         methlist.add(found);
873                         interfaces.put(found, interfaceType);
874                     }
875                 }
876             }
877         }
878 
879         /**
880          * Return the list of interface methods which the method passed in the
881          * constructor is implementing. The search/build order is as follows:
882          * &lt;pre&gt;
883          * 1. Search in all the immediate interfaces which this method&#39;s class is
884          *    implementing. Do it recursively for the superinterfaces as well.
885          * 2. Traverse all the superclasses and search recursively in the
886          *    interfaces which those superclasses implement.
887          *&lt;/pre&gt;
888          *
889          * @return SortedSet&lt;ExecutableElement&gt; of implemented methods.
890          */
891         List&lt;ExecutableElement&gt; getImplementedMethods() {
892             return methlist;
893         }
894 
895         TypeMirror getMethodHolder(ExecutableElement ee) {
896             return interfaces.get(ee);
897         }
898 
899         /**
900          * Search in the method list and check if it contains a method which
901          * is overridden by the method as parameter.  If found, remove the
902          * overridden method from the method list.
903          *
904          * @param method Is this method overriding a method in the method list.
905          */
906         private void removeOverriddenMethod(ExecutableElement method) {
907             TypeElement overriddenClass = utils.overriddenClass(method);
908             if (overriddenClass != null) {
909                 for (int i = 0; i &lt; methlist.size(); i++) {
910                     TypeElement te = utils.getEnclosingTypeElement(methlist.get(i));
911                     if (te == overriddenClass || utils.isSubclassOf(overriddenClass, te)) {
912                         methlist.remove(i);  // remove overridden method
913                         return;
914                     }
915                 }
916             }
917         }
918 
919         /**
920          * Search in the already found methods&#39; list and check if it contains
921          * a method which is overriding the method parameter or is the method
922          * parameter itself.
923          *
924          * @param method method to be searched
925          */
926         private boolean overridingMethodFound(ExecutableElement method) {
927             TypeElement containingClass = utils.getEnclosingTypeElement(method);
928             for (ExecutableElement listmethod : methlist) {
929                 if (containingClass == utils.getEnclosingTypeElement(listmethod)) {
930                     // it&#39;s the same method.
931                     return true;
932                 }
933                 TypeElement te = utils.overriddenClass(listmethod);
934                 if (te == null) {
935                     continue;
936                 }
937                 if (te == containingClass || utils.isSubclassOf(te, containingClass)) {
938                     return true;
939                 }
940             }
941             return false;
942         }
943     }
944 
945     /**
946      * A simple container to encapsulate an overriding method
947      * and the type of override.
948      */
949     static class OverridingMethodInfo {
950         final ExecutableElement overrider;
951         final boolean simpleOverride;
952 
953         public OverridingMethodInfo(ExecutableElement overrider, boolean simpleOverride) {
954             this.overrider = overrider;
955             this.simpleOverride = simpleOverride;
956         }
957 
958         @Override
959         public String toString() {
960             return &quot;OverridingMethodInfo[&quot; + overrider + &quot;,simple:&quot; + simpleOverride + &quot;]&quot;;
961         }
962     }
963 }
<a name="19" id="anc19"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="19" type="hidden" />
</body>
</html>
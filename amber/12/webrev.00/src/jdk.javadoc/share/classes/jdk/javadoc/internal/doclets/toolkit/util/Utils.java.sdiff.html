<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="TypeElementCatalog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/toolkit/util/Utils.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;
<span class="line-removed">  40 import java.util.Comparator;</span>
  41 import java.util.Deque;
  42 import java.util.EnumSet;
  43 import java.util.HashMap;
  44 import java.util.HashSet;
  45 import java.util.Iterator;
  46 import java.util.LinkedHashMap;
  47 import java.util.LinkedHashSet;
  48 import java.util.List;
  49 import java.util.Locale;
  50 import java.util.Map;
  51 import java.util.Map.Entry;
  52 import java.util.Objects;
  53 import java.util.Set;
  54 import java.util.SortedSet;
  55 import java.util.TreeMap;
  56 import java.util.TreeSet;
  57 import java.util.function.Predicate;
  58 import java.util.stream.Collectors;
  59 
  60 import javax.lang.model.SourceVersion;
</pre>
<hr />
<pre>
  78 import javax.lang.model.type.NoType;
  79 import javax.lang.model.type.PrimitiveType;
  80 import javax.lang.model.type.TypeMirror;
  81 import javax.lang.model.type.TypeVariable;
  82 import javax.lang.model.type.WildcardType;
  83 import javax.lang.model.util.ElementFilter;
  84 import javax.lang.model.util.ElementKindVisitor14;
  85 import javax.lang.model.util.Elements;
  86 import javax.lang.model.util.SimpleElementVisitor14;
  87 import javax.lang.model.util.SimpleTypeVisitor9;
  88 import javax.lang.model.util.TypeKindVisitor9;
  89 import javax.lang.model.util.Types;
  90 import javax.tools.FileObject;
  91 import javax.tools.JavaFileManager;
  92 import javax.tools.JavaFileManager.Location;
  93 import javax.tools.StandardLocation;
  94 
  95 import com.sun.source.doctree.DocCommentTree;
  96 import com.sun.source.doctree.DocTree;
  97 import com.sun.source.doctree.DocTree.Kind;

  98 import com.sun.source.doctree.ParamTree;
<span class="line-modified">  99 import com.sun.source.doctree.SerialFieldTree;</span>

 100 import com.sun.source.doctree.UnknownBlockTagTree;
 101 import com.sun.source.tree.CompilationUnitTree;
 102 import com.sun.source.tree.LineMap;
 103 import com.sun.source.util.DocSourcePositions;
 104 import com.sun.source.util.DocTrees;
 105 import com.sun.source.util.TreePath;
 106 import com.sun.tools.javac.model.JavacTypes;
<span class="line-removed"> 107 import jdk.javadoc.internal.doclets.formats.html.SearchIndexItem;</span>
 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;
<span class="line-removed"> 111 import jdk.javadoc.internal.doclets.toolkit.Messages;</span>
 112 import jdk.javadoc.internal.doclets.toolkit.Resources;
 113 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 115 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 116 import jdk.javadoc.internal.tool.DocEnvImpl;
 117 
 118 import static javax.lang.model.element.ElementKind.*;
 119 import static javax.lang.model.element.Modifier.*;
 120 import static javax.lang.model.type.TypeKind.*;
 121 
 122 import static com.sun.source.doctree.DocTree.Kind.*;
 123 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 124 
 125 /**
 126  * Utilities Class for Doclets.
 127  *
 128  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 129  *  If you write code that depends on this, you do so at your own risk.
 130  *  This code and its internal interfaces are subject to change or
 131  *  deletion without notice.&lt;/b&gt;
 132  */
 133 public class Utils {
 134     public final BaseConfiguration configuration;
 135     private final BaseOptions options;
<span class="line-removed"> 136     private final Messages messages;</span>
 137     private final Resources resources;
 138     public final DocTrees docTrees;
 139     public final Elements elementUtils;
 140     public final Types typeUtils;

 141     private final JavaScriptScanner javaScriptScanner;
 142 
 143     public Utils(BaseConfiguration c) {
 144         configuration = c;
 145         options = configuration.getOptions();
<span class="line-removed"> 146         messages = configuration.getMessages();</span>
 147         resources = configuration.getDocResources();
 148         elementUtils = c.docEnv.getElementUtils();
 149         typeUtils = c.docEnv.getTypeUtils();
 150         docTrees = c.docEnv.getDocTrees();
 151         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();

 152     }
 153 
 154     // our own little symbol table
 155     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 156 
 157     public TypeMirror getSymbol(String signature) {
 158         TypeMirror type = symtab.get(signature);
 159         if (type == null) {
 160             TypeElement typeElement = elementUtils.getTypeElement(signature);
 161             if (typeElement == null)
 162                 return null;
 163             type = typeElement.asType();
 164             if (type == null)
 165                 return null;
 166             symtab.put(signature, type);
 167         }
 168         return type;
 169     }
 170 
 171     public TypeMirror getObjectType() {
</pre>
<hr />
<pre>
 199     public TypeMirror getDeprecatedType() {
 200         return getSymbol(&quot;java.lang.Deprecated&quot;);
 201     }
 202 
 203     public TypeMirror getFunctionalInterface() {
 204         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 205     }
 206 
 207     /**
 208      * Return array of class members whose documentation is to be generated.
 209      * If the member is deprecated do not include such a member in the
 210      * returned array.
 211      *
 212      * @param  members    Array of members to choose from.
 213      * @return List       List of eligible members for whom
 214      *                    documentation is getting generated.
 215      */
 216     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 217         return members.stream()
 218                       .filter(member -&gt; !isDeprecated(member))
<span class="line-modified"> 219                       .sorted(makeGeneralPurposeComparator())</span>
 220                       .collect(Collectors.toCollection(ArrayList::new));
 221     }
 222 
 223     /**
 224      * Search for the given method in the given class.
 225      *
 226      * @param  te        Class to search into.
 227      * @param  method    Method to be searched.
 228      * @return ExecutableElement Method found, null otherwise.
 229      */
 230     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 231         for (Element m : getMethods(te)) {
 232             if (executableMembersEqual(method, (ExecutableElement) m)) {
 233                 return (ExecutableElement) m;
 234             }
 235         }
 236         return null;
 237     }
 238 
 239     /**
</pre>
<hr />
<pre>
 644         switch(kind) {
 645               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 646               case LOCAL_VARIABLE: case PARAMETER:
 647               case RESOURCE_VARIABLE:
 648                   return true;
 649               default:
 650                   return false;
 651         }
 652     }
 653 
 654     public boolean isTypeElement(Element e) {
 655         switch (e.getKind()) {
 656             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 657                 return true;
 658             default:
 659                 return false;
 660         }
 661     }
 662 
 663     /**
<span class="line-modified"> 664      * Get the signature. It is the parameter list, type is qualified.</span>

 665      * For instance, for a method {@code mymethod(String x, int y)},
 666      * it will return {@code (java.lang.String,int)}.
 667      *
<span class="line-modified"> 668      * @param e</span>
<span class="line-modified"> 669      * @return String</span>

 670      */
<span class="line-modified"> 671     public String signature(ExecutableElement e) {</span>
<span class="line-modified"> 672         return makeSignature(e, true);</span>
 673     }
 674 
 675     /**
<span class="line-modified"> 676      * Get flat signature.  All types are not qualified.</span>
<span class="line-modified"> 677      * Return a String, which is the flat signature of this member.</span>
<span class="line-removed"> 678      * It is the parameter list, type is not qualified.</span>
 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.




 681      */
<span class="line-modified"> 682     public String flatSignature(ExecutableElement e) {</span>
<span class="line-modified"> 683         return makeSignature(e, false);</span>
 684     }
 685 
<span class="line-modified"> 686     public String makeSignature(ExecutableElement e, boolean full) {</span>
<span class="line-modified"> 687         return makeSignature(e, full, false);</span>
 688     }
 689 
<span class="line-modified"> 690     public String makeSignature(ExecutableElement e, boolean full, boolean ignoreTypeParameters) {</span>
 691         StringBuilder result = new StringBuilder();
 692         result.append(&quot;(&quot;);
<span class="line-modified"> 693         Iterator&lt;? extends VariableElement&gt; iterator = e.getParameters().iterator();</span>

 694         while (iterator.hasNext()) {
<span class="line-modified"> 695             VariableElement next = iterator.next();</span>
<span class="line-removed"> 696             TypeMirror type = next.asType();</span>
 697             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 698             if (iterator.hasNext()) {
 699                 result.append(&quot;, &quot;);
 700             }
 701         }
 702         if (e.isVarArgs()) {
 703             int len = result.length();
 704             result.replace(len - 2, len, &quot;...&quot;);
 705         }
 706         result.append(&quot;)&quot;);
 707         return result.toString();
 708     }
 709 
 710     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 711         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 712             final StringBuilder sb = new StringBuilder();
 713 
 714             @Override
 715             public StringBuilder visitArray(ArrayType t, Void p) {
 716                 TypeMirror componentType = t.getComponentType();
</pre>
<hr />
<pre>
 909                 t = getSuperType(asTypeElement(t))) {
 910             TypeElement te = asTypeElement(t);
 911             if (te == null) {
 912                 return null;
 913             }
 914             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 915             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 916                 ExecutableElement ee = (ExecutableElement)e;
 917                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 918                         !isSimpleOverride(ee)) {
 919                     return ee;
 920                 }
 921             }
 922             if (t.equals(getObjectType()))
 923                 return null;
 924         }
 925         return null;
 926     }
 927 
 928     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
<span class="line-modified"> 929         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
 930         typeElements.forEach(set::add);
 931         return set;
 932     }
 933 
 934     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 935         return getBlockTags(member, SERIAL_DATA);
 936     }
 937 
 938     public FileObject getFileObject(TypeElement te) {
 939         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 940     }
 941 
 942     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 943         return getDeclaredType(Collections.emptyList(), enclosing, target);
 944     }
 945 
 946     /**
 947      * Finds the declaration of the enclosing&#39;s type parameter.
 948      *
 949      * @param values
</pre>
<hr />
<pre>
1557         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1558             return false;
1559 
1560         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1561         return fullBody.isEmpty() ||
1562                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1563     }
1564 
1565     /**
1566      * In case of JavaFX mode on, filters out classes that are private,
1567      * package private, these are not documented in JavaFX mode, also
1568      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1569      *
1570      * @param classlist a collection of TypeElements
1571      * @param javafx set to true if in JavaFX mode.
1572      * @return list of filtered classes.
1573      */
1574     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1575             boolean javafx) {
1576         SortedSet&lt;TypeElement&gt; filteredOutClasses =
<span class="line-modified">1577                 new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
1578         if (!javafx) {
1579             for (Element te : classlist) {
1580                 if (!hasHiddenTag(te)) {
1581                     filteredOutClasses.add((TypeElement)te);
1582                 }
1583             }
1584             return filteredOutClasses;
1585         }
1586         for (Element e : classlist) {
1587             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1588                 continue;
1589             }
1590             filteredOutClasses.add((TypeElement)e);
1591         }
1592         return filteredOutClasses;
1593     }
1594 
1595     /**
1596      * Compares two elements.
1597      * @param e1 first Element
</pre>
<hr />
<pre>
1624     public int compareStrings(String s1, String s2) {
1625         return compareStrings(true, s1, s2);
1626     }
1627 
1628     /**
1629      * A general purpose case sensitive String comparator, which
1630      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1631      *
1632      * @param s1 first String to compare.
1633      * @param s2 second String to compare.
1634      * @return a negative integer, zero, or a positive integer as the first
1635      *         argument is less than, equal to, or greater than the second.
1636      */
1637     public int compareCaseCompare(String s1, String s2) {
1638         return compareStrings(false, s1, s2);
1639     }
1640 
1641     private DocCollator tertiaryCollator = null;
1642     private DocCollator secondaryCollator = null;
1643 
<span class="line-modified">1644     private int compareStrings(boolean caseSensitive, String s1, String s2) {</span>
1645         if (caseSensitive) {
1646             if (tertiaryCollator == null) {
1647                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1648             }
1649             return tertiaryCollator.compare(s1, s2);
1650         }
1651         if (secondaryCollator == null) {
1652             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1653         }
1654         return secondaryCollator.compare(s1, s2);
1655     }
1656 


































1657     private static class DocCollator {
1658         private final Map&lt;String, CollationKey&gt; keys;
1659         private final Collator instance;
1660         private final int MAX_SIZE = 1000;
1661         private DocCollator(Locale locale, int strength) {
1662             instance = createCollator(locale);
1663             instance.setStrength(strength);
1664 
1665             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1666                 private static final long serialVersionUID = 1L;
1667                 @Override
1668                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1669                     return size() &gt; MAX_SIZE;
1670                 }
1671             };
1672         }
1673 
1674         CollationKey getKey(String s) {
1675             return keys.computeIfAbsent(s, instance :: getCollationKey);
1676         }
</pre>
<hr />
<pre>
1678         public int compare(String s1, String s2) {
1679             return getKey(s1).compareTo(getKey(s2));
1680         }
1681 
1682         private Collator createCollator(Locale locale) {
1683             Collator baseCollator = Collator.getInstance(locale);
1684             if (baseCollator instanceof RuleBasedCollator) {
1685                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1686                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1687                 try {
1688                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1689                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1690                 } catch (ParseException e) {
1691                     throw new RuntimeException(e);
1692                 }
1693             }
1694             return baseCollator;
1695         }
1696     }
1697 
<span class="line-removed">1698     private Comparator&lt;Element&gt; moduleComparator = null;</span>
<span class="line-removed">1699     /**</span>
<span class="line-removed">1700      * Comparator for ModuleElements, simply compares the fully qualified names</span>
<span class="line-removed">1701      * @return a Comparator</span>
<span class="line-removed">1702      */</span>
<span class="line-removed">1703     public Comparator&lt;Element&gt; makeModuleComparator() {</span>
<span class="line-removed">1704         if (moduleComparator == null) {</span>
<span class="line-removed">1705             moduleComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1706                 @Override</span>
<span class="line-removed">1707                 public int compare(Element mod1, Element mod2) {</span>
<span class="line-removed">1708                     return compareFullyQualifiedNames(mod1, mod2);</span>
<span class="line-removed">1709                 }</span>
<span class="line-removed">1710             };</span>
<span class="line-removed">1711         }</span>
<span class="line-removed">1712         return moduleComparator;</span>
<span class="line-removed">1713     }</span>
<span class="line-removed">1714 </span>
<span class="line-removed">1715     private Comparator&lt;Element&gt; allClassesComparator = null;</span>
<span class="line-removed">1716     /**</span>
<span class="line-removed">1717      * Returns a Comparator for all classes, compares the simple names of</span>
<span class="line-removed">1718      * TypeElement, if equal then the fully qualified names.</span>
<span class="line-removed">1719      *</span>
<span class="line-removed">1720      * @return Comparator</span>
<span class="line-removed">1721      */</span>
<span class="line-removed">1722     public Comparator&lt;Element&gt; makeAllClassesComparator() {</span>
<span class="line-removed">1723         if (allClassesComparator == null) {</span>
<span class="line-removed">1724             allClassesComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1725                 @Override</span>
<span class="line-removed">1726                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1727                     int result = compareNames(e1, e2);</span>
<span class="line-removed">1728                     if (result == 0)</span>
<span class="line-removed">1729                         result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1730 </span>
<span class="line-removed">1731                     return result;</span>
<span class="line-removed">1732                 }</span>
<span class="line-removed">1733             };</span>
<span class="line-removed">1734         }</span>
<span class="line-removed">1735         return allClassesComparator;</span>
<span class="line-removed">1736     }</span>
<span class="line-removed">1737 </span>
<span class="line-removed">1738     private Comparator&lt;Element&gt; packageComparator = null;</span>
<span class="line-removed">1739     /**</span>
<span class="line-removed">1740      * Returns a Comparator for packages, by comparing the fully qualified names.</span>
<span class="line-removed">1741      *</span>
<span class="line-removed">1742      * @return a Comparator</span>
<span class="line-removed">1743      */</span>
<span class="line-removed">1744     public Comparator&lt;Element&gt; makePackageComparator() {</span>
<span class="line-removed">1745         if (packageComparator == null) {</span>
<span class="line-removed">1746             packageComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1747                 @Override</span>
<span class="line-removed">1748                 public int compare(Element pkg1, Element pkg2) {</span>
<span class="line-removed">1749                     return compareFullyQualifiedNames(pkg1, pkg2);</span>
<span class="line-removed">1750                 }</span>
<span class="line-removed">1751             };</span>
<span class="line-removed">1752         }</span>
<span class="line-removed">1753         return packageComparator;</span>
<span class="line-removed">1754     }</span>
<span class="line-removed">1755 </span>
<span class="line-removed">1756     private Comparator&lt;Element&gt; deprecatedComparator = null;</span>
<span class="line-removed">1757     /**</span>
<span class="line-removed">1758      * Returns a Comparator for deprecated items listed on deprecated list page, by comparing the</span>
<span class="line-removed">1759      * fully qualified names.</span>
<span class="line-removed">1760      *</span>
<span class="line-removed">1761      * @return a Comparator</span>
<span class="line-removed">1762      */</span>
<span class="line-removed">1763     public Comparator&lt;Element&gt; makeDeprecatedComparator() {</span>
<span class="line-removed">1764         if (deprecatedComparator == null) {</span>
<span class="line-removed">1765             deprecatedComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1766                 @Override</span>
<span class="line-removed">1767                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1768                     return compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1769                 }</span>
<span class="line-removed">1770             };</span>
<span class="line-removed">1771         }</span>
<span class="line-removed">1772         return deprecatedComparator;</span>
<span class="line-removed">1773     }</span>
<span class="line-removed">1774 </span>
<span class="line-removed">1775     private Comparator&lt;SerialFieldTree&gt; serialFieldTreeComparator = null;</span>
<span class="line-removed">1776     /**</span>
<span class="line-removed">1777      * Returns a Comparator for SerialFieldTree.</span>
<span class="line-removed">1778      * @return a Comparator</span>
<span class="line-removed">1779      */</span>
<span class="line-removed">1780     public Comparator&lt;SerialFieldTree&gt; makeSerialFieldTreeComparator() {</span>
<span class="line-removed">1781         if (serialFieldTreeComparator == null) {</span>
<span class="line-removed">1782             serialFieldTreeComparator = (SerialFieldTree o1, SerialFieldTree o2) -&gt; {</span>
<span class="line-removed">1783                 String s1 = o1.getName().toString();</span>
<span class="line-removed">1784                 String s2 = o2.getName().toString();</span>
<span class="line-removed">1785                 return s1.compareTo(s2);</span>
<span class="line-removed">1786             };</span>
<span class="line-removed">1787         }</span>
<span class="line-removed">1788         return serialFieldTreeComparator;</span>
<span class="line-removed">1789     }</span>
<span class="line-removed">1790 </span>
<span class="line-removed">1791     /**</span>
<span class="line-removed">1792      * Returns a general purpose comparator.</span>
<span class="line-removed">1793      * @return a Comparator</span>
<span class="line-removed">1794      */</span>
<span class="line-removed">1795     public Comparator&lt;Element&gt; makeGeneralPurposeComparator() {</span>
<span class="line-removed">1796         return makeClassUseComparator();</span>
<span class="line-removed">1797     }</span>
<span class="line-removed">1798 </span>
<span class="line-removed">1799     private Comparator&lt;Element&gt; overrideUseComparator = null;</span>
<span class="line-removed">1800 </span>
<span class="line-removed">1801     /**</span>
<span class="line-removed">1802      * Returns a Comparator for overrides and implements,</span>
<span class="line-removed">1803      * used primarily on methods, compares the name first,</span>
<span class="line-removed">1804      * then compares the simple names of the enclosing</span>
<span class="line-removed">1805      * TypeElement and the fully qualified name of the enclosing TypeElement.</span>
<span class="line-removed">1806      * @return a Comparator</span>
<span class="line-removed">1807      */</span>
<span class="line-removed">1808     public Comparator&lt;Element&gt; makeOverrideUseComparator() {</span>
<span class="line-removed">1809         if (overrideUseComparator == null) {</span>
<span class="line-removed">1810             overrideUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1811                 @Override</span>
<span class="line-removed">1812                 public int compare(Element o1, Element o2) {</span>
<span class="line-removed">1813                     int result = compareStrings(getSimpleName(o1), getSimpleName(o2));</span>
<span class="line-removed">1814                     if (result != 0) {</span>
<span class="line-removed">1815                         return result;</span>
<span class="line-removed">1816                     }</span>
<span class="line-removed">1817                     if (!isTypeElement(o1) &amp;&amp; !isTypeElement(o2) &amp;&amp; !isPackage(o1) &amp;&amp; !isPackage(o2)) {</span>
<span class="line-removed">1818                         TypeElement t1 = getEnclosingTypeElement(o1);</span>
<span class="line-removed">1819                         TypeElement t2 = getEnclosingTypeElement(o2);</span>
<span class="line-removed">1820                         result = compareStrings(getSimpleName(t1), getSimpleName(t2));</span>
<span class="line-removed">1821                         if (result != 0)</span>
<span class="line-removed">1822                             return result;</span>
<span class="line-removed">1823                     }</span>
<span class="line-removed">1824                     result = compareStrings(getFullyQualifiedName(o1), getFullyQualifiedName(o2));</span>
<span class="line-removed">1825                     if (result != 0)</span>
<span class="line-removed">1826                         return result;</span>
<span class="line-removed">1827                     return compareElementKinds(o1, o2);</span>
<span class="line-removed">1828                 }</span>
<span class="line-removed">1829             };</span>
<span class="line-removed">1830         }</span>
<span class="line-removed">1831         return overrideUseComparator;</span>
<span class="line-removed">1832     }</span>
<span class="line-removed">1833 </span>
<span class="line-removed">1834     private Comparator&lt;Element&gt; indexUseComparator = null;</span>
<span class="line-removed">1835     /**</span>
<span class="line-removed">1836      *  Returns a Comparator for index file presentations, and are sorted as follows.</span>
<span class="line-removed">1837      *  If comparing modules and/or packages then simply compare the qualified names,</span>
<span class="line-removed">1838      *  if comparing a module or a package with a type/member then compare the</span>
<span class="line-removed">1839      *  FullyQualifiedName of the module or a package with the SimpleName of the entity,</span>
<span class="line-removed">1840      *  otherwise:</span>
<span class="line-removed">1841      *  1. compare the ElementKind ex: Module, Package, Interface etc.</span>
<span class="line-removed">1842      *  2a. if equal and if the type is of ExecutableElement(Constructor, Methods),</span>
<span class="line-removed">1843      *      a case insensitive comparison of parameter the type signatures</span>
<span class="line-removed">1844      *  2b. if equal, case sensitive comparison of the type signatures</span>
<span class="line-removed">1845      *  3. finally, if equal, compare the FQNs of the entities</span>
<span class="line-removed">1846      * @return a comparator for index file use</span>
<span class="line-removed">1847      */</span>
<span class="line-removed">1848     public Comparator&lt;Element&gt; makeIndexUseComparator() {</span>
<span class="line-removed">1849         if (indexUseComparator == null) {</span>
<span class="line-removed">1850             indexUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">1851                 /**</span>
<span class="line-removed">1852                  * Compares two elements.</span>
<span class="line-removed">1853                  *</span>
<span class="line-removed">1854                  * @param e1 - an element.</span>
<span class="line-removed">1855                  * @param e2 - an element.</span>
<span class="line-removed">1856                  * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">1857                  * argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">1858                  */</span>
<span class="line-removed">1859                 @Override</span>
<span class="line-removed">1860                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">1861                     int result;</span>
<span class="line-removed">1862                     // first, compare names as appropriate</span>
<span class="line-removed">1863                     if ((isModule(e1) || isPackage(e1)) &amp;&amp; (isModule(e2) || isPackage(e2))) {</span>
<span class="line-removed">1864                         result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1865                     } else if (isModule(e1) || isPackage(e1)) {</span>
<span class="line-removed">1866                         result = compareStrings(getFullyQualifiedName(e1), getSimpleName(e2));</span>
<span class="line-removed">1867                     } else if (isModule(e2) || isPackage(e2)) {</span>
<span class="line-removed">1868                         result = compareStrings(getSimpleName(e1), getFullyQualifiedName(e2));</span>
<span class="line-removed">1869                     } else {</span>
<span class="line-removed">1870                         result = compareNames(e1, e2);</span>
<span class="line-removed">1871                     }</span>
<span class="line-removed">1872                     if (result != 0) {</span>
<span class="line-removed">1873                         return result;</span>
<span class="line-removed">1874                     }</span>
<span class="line-removed">1875                     // if names are the same, compare element kinds</span>
<span class="line-removed">1876                     result = compareElementKinds(e1, e2);</span>
<span class="line-removed">1877                     if (result != 0) {</span>
<span class="line-removed">1878                         return result;</span>
<span class="line-removed">1879                     }</span>
<span class="line-removed">1880                     // if element kinds are the same, and are methods,</span>
<span class="line-removed">1881                     // compare the method parameters</span>
<span class="line-removed">1882                     if (hasParameters(e1)) {</span>
<span class="line-removed">1883                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">1884                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
<span class="line-removed">1885                         result = compareParameters(false, parameters1, parameters2);</span>
<span class="line-removed">1886                         if (result != 0) {</span>
<span class="line-removed">1887                             return result;</span>
<span class="line-removed">1888                         }</span>
<span class="line-removed">1889                         result = compareParameters(true, parameters1, parameters2);</span>
<span class="line-removed">1890                         if (result != 0) {</span>
<span class="line-removed">1891                             return result;</span>
<span class="line-removed">1892                         }</span>
<span class="line-removed">1893                     }</span>
<span class="line-removed">1894                     // else fall back on fully qualified names</span>
<span class="line-removed">1895                     return compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">1896                 }</span>
<span class="line-removed">1897             };</span>
<span class="line-removed">1898         }</span>
<span class="line-removed">1899         return indexUseComparator;</span>
<span class="line-removed">1900     }</span>
<span class="line-removed">1901 </span>
<span class="line-removed">1902     private Comparator&lt;TypeMirror&gt; typeMirrorClassUseComparator = null;</span>
<span class="line-removed">1903     /**</span>
<span class="line-removed">1904      * Compares the FullyQualifiedNames of two TypeMirrors</span>
<span class="line-removed">1905      * @return</span>
<span class="line-removed">1906      */</span>
<span class="line-removed">1907     public Comparator&lt;TypeMirror&gt; makeTypeMirrorClassUseComparator() {</span>
<span class="line-removed">1908         if (typeMirrorClassUseComparator == null) {</span>
<span class="line-removed">1909             typeMirrorClassUseComparator = (TypeMirror type1, TypeMirror type2) -&gt; {</span>
<span class="line-removed">1910                 String s1 = getQualifiedTypeName(type1);</span>
<span class="line-removed">1911                 String s2 = getQualifiedTypeName(type2);</span>
<span class="line-removed">1912                 return compareStrings(s1, s2);</span>
<span class="line-removed">1913             };</span>
<span class="line-removed">1914         }</span>
<span class="line-removed">1915         return typeMirrorClassUseComparator;</span>
<span class="line-removed">1916     }</span>
<span class="line-removed">1917 </span>
<span class="line-removed">1918     private Comparator&lt;TypeMirror&gt; typeMirrorIndexUseComparator = null;</span>
<span class="line-removed">1919     /**</span>
<span class="line-removed">1920      * Compares the SimpleNames of TypeMirrors if equal then the</span>
<span class="line-removed">1921      * FullyQualifiedNames of TypeMirrors.</span>
<span class="line-removed">1922      *</span>
<span class="line-removed">1923      * @return</span>
<span class="line-removed">1924      */</span>
<span class="line-removed">1925     public Comparator&lt;TypeMirror&gt; makeTypeMirrorIndexUseComparator() {</span>
<span class="line-removed">1926         if (typeMirrorIndexUseComparator == null) {</span>
<span class="line-removed">1927             typeMirrorIndexUseComparator = (TypeMirror t1, TypeMirror t2) -&gt; {</span>
<span class="line-removed">1928                 int result = compareStrings(getTypeName(t1, false), getTypeName(t2, false));</span>
<span class="line-removed">1929                 if (result != 0)</span>
<span class="line-removed">1930                     return result;</span>
<span class="line-removed">1931                 return compareStrings(getQualifiedTypeName(t1), getQualifiedTypeName(t2));</span>
<span class="line-removed">1932             };</span>
<span class="line-removed">1933         }</span>
<span class="line-removed">1934         return typeMirrorIndexUseComparator;</span>
<span class="line-removed">1935     }</span>
<span class="line-removed">1936 </span>
1937     /**
1938      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1939      * getQualified name, returns  the qualified name of the Reference type
1940      * otherwise the primitive name.
1941      * @param t the type whose name is to be obtained.
1942      * @return the fully qualified name of Reference type or the primitive name
1943      */
1944     public String getQualifiedTypeName(TypeMirror t) {
1945         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1946             @Override
1947             public String visitDeclared(DeclaredType t, Void p) {
1948                 return getFullyQualifiedName(t.asElement());
1949             }
1950 
1951             @Override
1952             public String visitArray(ArrayType t, Void p) {
1953                return visit(t.getComponentType());
1954             }
1955 
1956             @Override
</pre>
<hr />
<pre>
1989                 return e.getQualifiedName().toString();
1990             }
1991 
1992             @Override
1993             public String visitPackage(PackageElement e, Void p) {
1994                 return e.getQualifiedName().toString();
1995             }
1996 
1997             @Override
1998             public String visitType(TypeElement e, Void p) {
1999                 return e.getQualifiedName().toString();
2000             }
2001 
2002             @Override
2003             protected String defaultAction(Element e, Void p) {
2004                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
2005             }
2006         }.visit(e);
2007     }
2008 
<span class="line-removed">2009     private Comparator&lt;Element&gt; classUseComparator = null;</span>
<span class="line-removed">2010 </span>
<span class="line-removed">2011     /**</span>
<span class="line-removed">2012      * Comparator for ClassUse presentations, and sorts as follows:</span>
<span class="line-removed">2013      * 1. member names</span>
<span class="line-removed">2014      * 2. then fully qualified member names</span>
<span class="line-removed">2015      * 3. then parameter types if applicable</span>
<span class="line-removed">2016      * 4. finally the element kinds ie. package, class, interface etc.</span>
<span class="line-removed">2017      * @return a comparator to sort classes and members for class use</span>
<span class="line-removed">2018      */</span>
<span class="line-removed">2019     public Comparator&lt;Element&gt; makeClassUseComparator() {</span>
<span class="line-removed">2020         if (classUseComparator == null) {</span>
<span class="line-removed">2021             classUseComparator = new Utils.ElementComparator() {</span>
<span class="line-removed">2022                 /**</span>
<span class="line-removed">2023                  * Compares two Elements.</span>
<span class="line-removed">2024                  *</span>
<span class="line-removed">2025                  * @param e1 - an element.</span>
<span class="line-removed">2026                  * @param e2 - an element.</span>
<span class="line-removed">2027                  * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2028                  * argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2029                  */</span>
<span class="line-removed">2030                 @Override</span>
<span class="line-removed">2031                 public int compare(Element e1, Element e2) {</span>
<span class="line-removed">2032                     int result = compareNames(e1, e2);</span>
<span class="line-removed">2033                     if (result != 0) {</span>
<span class="line-removed">2034                         return result;</span>
<span class="line-removed">2035                     }</span>
<span class="line-removed">2036                     result = compareFullyQualifiedNames(e1, e2);</span>
<span class="line-removed">2037                     if (result != 0) {</span>
<span class="line-removed">2038                         return result;</span>
<span class="line-removed">2039                     }</span>
<span class="line-removed">2040                     if (hasParameters(e1) &amp;&amp; hasParameters(e2)) {</span>
<span class="line-removed">2041                         List&lt;? extends VariableElement&gt; parameters1 = ((ExecutableElement)e1).getParameters();</span>
<span class="line-removed">2042                         List&lt;? extends VariableElement&gt; parameters2 = ((ExecutableElement)e2).getParameters();</span>
<span class="line-removed">2043                         result = compareParameters(false, parameters1, parameters2);</span>
<span class="line-removed">2044                         if (result != 0) {</span>
<span class="line-removed">2045                             return result;</span>
<span class="line-removed">2046                         }</span>
<span class="line-removed">2047                         result = compareParameters(true, parameters1, parameters2);</span>
<span class="line-removed">2048                     }</span>
<span class="line-removed">2049                     if (result != 0) {</span>
<span class="line-removed">2050                         return result;</span>
<span class="line-removed">2051                     }</span>
<span class="line-removed">2052                     return compareElementKinds(e1, e2);</span>
<span class="line-removed">2053                 }</span>
<span class="line-removed">2054             };</span>
<span class="line-removed">2055         }</span>
<span class="line-removed">2056         return classUseComparator;</span>
<span class="line-removed">2057     }</span>
<span class="line-removed">2058 </span>
<span class="line-removed">2059     /**</span>
<span class="line-removed">2060      * A general purpose comparator to sort Element entities, basically provides the building blocks</span>
<span class="line-removed">2061      * for creating specific comparators for an use-case.</span>
<span class="line-removed">2062      */</span>
<span class="line-removed">2063     private abstract class ElementComparator implements Comparator&lt;Element&gt; {</span>
<span class="line-removed">2064         public ElementComparator() { }</span>
<span class="line-removed">2065 </span>
<span class="line-removed">2066         /**</span>
<span class="line-removed">2067          * compares two parameter arrays by first comparing the length of the arrays, and</span>
<span class="line-removed">2068          * then each Type of the parameter in the array.</span>
<span class="line-removed">2069          * @param params1 the first parameter array.</span>
<span class="line-removed">2070          * @param params2 the first parameter array.</span>
<span class="line-removed">2071          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2072          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2073          */</span>
<span class="line-removed">2074         protected int compareParameters(boolean caseSensitive, List&lt;? extends VariableElement&gt; params1,</span>
<span class="line-removed">2075                                                                List&lt;? extends VariableElement&gt; params2) {</span>
<span class="line-removed">2076 </span>
<span class="line-removed">2077             return compareStrings(caseSensitive, getParametersAsString(params1),</span>
<span class="line-removed">2078                                                  getParametersAsString(params2));</span>
<span class="line-removed">2079         }</span>
<span class="line-removed">2080 </span>
<span class="line-removed">2081         String getParametersAsString(List&lt;? extends VariableElement&gt; params) {</span>
<span class="line-removed">2082             StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">2083             for (VariableElement param : params) {</span>
<span class="line-removed">2084                 TypeMirror t = param.asType();</span>
<span class="line-removed">2085                 // prefix P for primitive and R for reference types, thus items will</span>
<span class="line-removed">2086                 // be ordered lexically and correctly.</span>
<span class="line-removed">2087                 sb.append(getTypeCode(t)).append(&quot;-&quot;).append(t).append(&quot;-&quot;);</span>
<span class="line-removed">2088             }</span>
<span class="line-removed">2089             return sb.toString();</span>
<span class="line-removed">2090         }</span>
<span class="line-removed">2091 </span>
<span class="line-removed">2092         private String getTypeCode(TypeMirror t) {</span>
<span class="line-removed">2093             return new SimpleTypeVisitor9&lt;String, Void&gt;() {</span>
<span class="line-removed">2094 </span>
<span class="line-removed">2095                 @Override</span>
<span class="line-removed">2096                 public String visitPrimitive(PrimitiveType t, Void p) {</span>
<span class="line-removed">2097                     return &quot;P&quot;;</span>
<span class="line-removed">2098                 }</span>
<span class="line-removed">2099                 @Override</span>
<span class="line-removed">2100                 public String visitArray(ArrayType t, Void p) {</span>
<span class="line-removed">2101                     return visit(t.getComponentType());</span>
<span class="line-removed">2102                 }</span>
<span class="line-removed">2103                 @Override</span>
<span class="line-removed">2104                 protected String defaultAction(TypeMirror e, Void p) {</span>
<span class="line-removed">2105                     return &quot;R&quot;;</span>
<span class="line-removed">2106                 }</span>
<span class="line-removed">2107 </span>
<span class="line-removed">2108             }.visit(t);</span>
<span class="line-removed">2109         }</span>
<span class="line-removed">2110 </span>
<span class="line-removed">2111         /**</span>
<span class="line-removed">2112          * Compares two Elements, typically the name of a method,</span>
<span class="line-removed">2113          * field or constructor.</span>
<span class="line-removed">2114          * @param e1 the first Element.</span>
<span class="line-removed">2115          * @param e2 the second Element.</span>
<span class="line-removed">2116          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2117          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2118          */</span>
<span class="line-removed">2119         protected int compareNames(Element e1, Element e2) {</span>
<span class="line-removed">2120             return compareStrings(getSimpleName(e1), getSimpleName(e2));</span>
<span class="line-removed">2121         }</span>
<span class="line-removed">2122 </span>
<span class="line-removed">2123         /**</span>
<span class="line-removed">2124          * Compares the fully qualified names of the entities</span>
<span class="line-removed">2125          * @param e1 the first Element.</span>
<span class="line-removed">2126          * @param e2 the first Element.</span>
<span class="line-removed">2127          * @return a negative integer, zero, or a positive integer as the first</span>
<span class="line-removed">2128          *         argument is less than, equal to, or greater than the second.</span>
<span class="line-removed">2129          */</span>
<span class="line-removed">2130         protected int compareFullyQualifiedNames(Element e1, Element e2) {</span>
<span class="line-removed">2131             // add simplename to be compatible</span>
<span class="line-removed">2132             String thisElement = getFullyQualifiedName(e1);</span>
<span class="line-removed">2133             String thatElement = getFullyQualifiedName(e2);</span>
<span class="line-removed">2134             return compareStrings(thisElement, thatElement);</span>
<span class="line-removed">2135         }</span>
<span class="line-removed">2136 </span>
<span class="line-removed">2137         protected int compareElementKinds(Element e1, Element e2) {</span>
<span class="line-removed">2138             return Integer.compare(getKindIndex(e1), getKindIndex(e2));</span>
<span class="line-removed">2139         }</span>
<span class="line-removed">2140 </span>
<span class="line-removed">2141         private int getKindIndex(Element e) {</span>
<span class="line-removed">2142             switch (e.getKind()) {</span>
<span class="line-removed">2143                 case MODULE:            return 0;</span>
<span class="line-removed">2144                 case PACKAGE:           return 1;</span>
<span class="line-removed">2145                 case CLASS:             return 2;</span>
<span class="line-removed">2146                 case ENUM:              return 3;</span>
<span class="line-removed">2147                 case ENUM_CONSTANT:     return 4;</span>
<span class="line-removed">2148                 case RECORD:            return 5;</span>
<span class="line-removed">2149                 case INTERFACE:         return 6;</span>
<span class="line-removed">2150                 case ANNOTATION_TYPE:   return 7;</span>
<span class="line-removed">2151                 case FIELD:             return 8;</span>
<span class="line-removed">2152                 case CONSTRUCTOR:       return 9;</span>
<span class="line-removed">2153                 case METHOD:            return 10;</span>
<span class="line-removed">2154                 default: throw new IllegalArgumentException(e.getKind().toString());</span>
<span class="line-removed">2155             }</span>
<span class="line-removed">2156         }</span>
<span class="line-removed">2157 </span>
<span class="line-removed">2158         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2159         boolean hasParameters(Element e) {</span>
<span class="line-removed">2160             return new SimpleElementVisitor14&lt;Boolean, Void&gt;() {</span>
<span class="line-removed">2161                 @Override</span>
<span class="line-removed">2162                 public Boolean visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-removed">2163                     return true;</span>
<span class="line-removed">2164                 }</span>
<span class="line-removed">2165 </span>
<span class="line-removed">2166                 @Override</span>
<span class="line-removed">2167                 protected Boolean defaultAction(Element e, Void p) {</span>
<span class="line-removed">2168                     return false;</span>
<span class="line-removed">2169                 }</span>
<span class="line-removed">2170 </span>
<span class="line-removed">2171             }.visit(e);</span>
<span class="line-removed">2172         }</span>
<span class="line-removed">2173 </span>
<span class="line-removed">2174         /**</span>
<span class="line-removed">2175          * The fully qualified names of the entities, used solely by the comparator.</span>
<span class="line-removed">2176          *</span>
<span class="line-removed">2177          * @return a negative integer, zero, or a positive integer as the first argument is less</span>
<span class="line-removed">2178          * than, equal to, or greater than the second.</span>
<span class="line-removed">2179          */</span>
<span class="line-removed">2180         @SuppressWarnings(&quot;preview&quot;)</span>
<span class="line-removed">2181         private String getFullyQualifiedName(Element e) {</span>
<span class="line-removed">2182             return new SimpleElementVisitor14&lt;String, Void&gt;() {</span>
<span class="line-removed">2183                 @Override</span>
<span class="line-removed">2184                 public String visitModule(ModuleElement e, Void p) {</span>
<span class="line-removed">2185                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2186                 }</span>
<span class="line-removed">2187 </span>
<span class="line-removed">2188                 @Override</span>
<span class="line-removed">2189                 public String visitPackage(PackageElement e, Void p) {</span>
<span class="line-removed">2190                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2191                 }</span>
<span class="line-removed">2192 </span>
<span class="line-removed">2193                 @Override</span>
<span class="line-removed">2194                 public String visitExecutable(ExecutableElement e, Void p) {</span>
<span class="line-removed">2195                     // For backward compatibility</span>
<span class="line-removed">2196                     return getFullyQualifiedName(e.getEnclosingElement())</span>
<span class="line-removed">2197                             + &quot;.&quot; + e.getSimpleName().toString();</span>
<span class="line-removed">2198                 }</span>
<span class="line-removed">2199 </span>
<span class="line-removed">2200                 @Override</span>
<span class="line-removed">2201                 public String visitType(TypeElement e, Void p) {</span>
<span class="line-removed">2202                     return e.getQualifiedName().toString();</span>
<span class="line-removed">2203                 }</span>
<span class="line-removed">2204 </span>
<span class="line-removed">2205                 @Override</span>
<span class="line-removed">2206                 protected String defaultAction(Element e, Void p) {</span>
<span class="line-removed">2207                     return getEnclosingTypeElement(e).getQualifiedName().toString()</span>
<span class="line-removed">2208                             + &quot;.&quot; + e.getSimpleName().toString();</span>
<span class="line-removed">2209                 }</span>
<span class="line-removed">2210             }.visit(e);</span>
<span class="line-removed">2211         }</span>
<span class="line-removed">2212     }</span>
<span class="line-removed">2213 </span>
<span class="line-removed">2214     /**</span>
<span class="line-removed">2215      * Returns a Comparator for SearchIndexItems representing types. Items are</span>
<span class="line-removed">2216      * compared by short name, or full string representation if names are equal.</span>
<span class="line-removed">2217      *</span>
<span class="line-removed">2218      * @return a Comparator</span>
<span class="line-removed">2219      */</span>
<span class="line-removed">2220     public Comparator&lt;SearchIndexItem&gt; makeTypeSearchIndexComparator() {</span>
<span class="line-removed">2221         return (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {</span>
<span class="line-removed">2222             int result = compareStrings(sii1.getSimpleName(), sii2.getSimpleName());</span>
<span class="line-removed">2223             if (result == 0) {</span>
<span class="line-removed">2224                 // TreeSet needs this to be consistent with equal so we do</span>
<span class="line-removed">2225                 // a plain comparison of string representations as fallback.</span>
<span class="line-removed">2226                 result = sii1.toString().compareTo(sii2.toString());</span>
<span class="line-removed">2227             }</span>
<span class="line-removed">2228             return result;</span>
<span class="line-removed">2229         };</span>
<span class="line-removed">2230     }</span>
<span class="line-removed">2231 </span>
<span class="line-removed">2232     private Comparator&lt;SearchIndexItem&gt; genericSearchIndexComparator = null;</span>
<span class="line-removed">2233     /**</span>
<span class="line-removed">2234      * Returns a Comparator for SearchIndexItems representing modules, packages, or members.</span>
<span class="line-removed">2235      * Items are compared by label (member name plus signature for members, package name for</span>
<span class="line-removed">2236      * packages, and module name for modules). If labels are equal then full string</span>
<span class="line-removed">2237      * representation is compared.</span>
<span class="line-removed">2238      *</span>
<span class="line-removed">2239      * @return a Comparator</span>
<span class="line-removed">2240      */</span>
<span class="line-removed">2241     public Comparator&lt;SearchIndexItem&gt; makeGenericSearchIndexComparator() {</span>
<span class="line-removed">2242         if (genericSearchIndexComparator == null) {</span>
<span class="line-removed">2243             genericSearchIndexComparator = (SearchIndexItem sii1, SearchIndexItem sii2) -&gt; {</span>
<span class="line-removed">2244                 int result = compareStrings(sii1.getLabel(), sii2.getLabel());</span>
<span class="line-removed">2245                 if (result == 0) {</span>
<span class="line-removed">2246                     // TreeSet needs this to be consistent with equal so we do</span>
<span class="line-removed">2247                     // a plain comparison of string representations as fallback.</span>
<span class="line-removed">2248                     result = sii1.toString().compareTo(sii2.toString());</span>
<span class="line-removed">2249                 }</span>
<span class="line-removed">2250                 return result;</span>
<span class="line-removed">2251             };</span>
<span class="line-removed">2252         }</span>
<span class="line-removed">2253         return genericSearchIndexComparator;</span>
<span class="line-removed">2254     }</span>
2255 
2256     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
2257         List&lt;TypeElement&gt; out = getInterfaces(pkg);
2258         out.addAll(getClasses(pkg));
2259         out.addAll(getEnums(pkg));
2260         out.addAll(getAnnotationTypes(pkg));
2261         out.addAll(getRecords(pkg));
2262         return out;
2263     }
2264 
2265     // Element related methods
2266     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
2267         List&lt;Element&gt; members = getAnnotationFields(aClass);
2268         members.addAll(getAnnotationMethods(aClass));
2269         return members;
2270     }
2271 
2272     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
2273         return getItems0(aClass, true, FIELD);
2274     }
</pre>
<hr />
<pre>
2331         if (member == null || member.getKind() != ENUM_CONSTANT) {
2332             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
2333         }
2334         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
2335     }
2336 
2337     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
2338     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
2339         if (modulePackageMap == null) {
2340             modulePackageMap = new HashMap&lt;&gt;();
2341             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
2342             pkgs.forEach(pkg -&gt; {
2343                 ModuleElement mod = elementUtils.getModuleOf(pkg);
2344                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
2345             });
2346         }
2347         return modulePackageMap;
2348     }
2349 
2350     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
<span class="line-modified">2351         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(makeModuleComparator());</span>
2352         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
2353         // get all the requires for the element in question
2354         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
2355             ModuleElement dep = rd.getDependency();
2356             // add the dependency to work queue
2357             if (!result.containsKey(dep)) {
2358                 if (rd.isTransitive()) {
2359                     queue.addLast(dep);
2360                 }
2361             }
2362             // add all exports for the primary module
2363             result.put(rd.getDependency(), getModifiers(rd));
2364         }
2365 
2366         // add only requires public for subsequent module dependencies
2367         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
2368             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
2369                 ModuleElement dep = rd.getDependency();
2370                 if (!result.containsKey(dep)) {
2371                     if (rd.isTransitive()) {
</pre>
<hr />
<pre>
2437         return convertToTypeElement(getItems(e, false, INTERFACE));
2438     }
2439 
2440     public List&lt;Element&gt; getEnumConstants(Element e) {
2441         return getItems(e, true, ENUM_CONSTANT);
2442     }
2443 
2444     public List&lt;TypeElement&gt; getEnums(Element e) {
2445         return convertToTypeElement(getItems(e, true, ENUM));
2446     }
2447 
2448     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2449         return convertToTypeElement(getItems(e, false, ENUM));
2450     }
2451 
2452     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2453         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2454         clist.addAll(getInterfacesUnfiltered(e));
2455         clist.addAll(getAnnotationTypesUnfiltered(e));
2456         clist.addAll(getRecordsUnfiltered(e));
<span class="line-modified">2457         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
2458         oset.addAll(clist);
2459         return oset;
2460     }
2461 
2462     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2463     /**
2464      * Returns a list containing classes and interfaces,
2465      * including annotation types.
2466      * @param e Element
2467      * @return List
2468      */
2469     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2470         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2471         if (oset != null)
2472             return oset;
2473         List&lt;TypeElement&gt; clist = getClasses(e);
2474         clist.addAll(getInterfaces(e));
2475         clist.addAll(getAnnotationTypes(e));
2476         clist.addAll(getEnums(e));
2477         clist.addAll(getRecords(e));
<span class="line-modified">2478         oset = new TreeSet&lt;&gt;(makeGeneralPurposeComparator());</span>
2479         oset.addAll(clist);
2480         cachedClasses.put(e, oset);
2481         return oset;
2482     }
2483 
2484     /*
2485      * Get all the elements unfiltered and filter them finally based
2486      * on its visibility, this works differently from the other getters.
2487      */
2488     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2489         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2490         for (TypeElement te : getClassesUnfiltered(e)) {
2491             if (!filter || configuration.docEnv.isSelected(te)) {
2492                 olist.add(te);
2493             }
2494         }
2495         for (TypeElement te : getInterfacesUnfiltered(e)) {
2496             if (!filter || configuration.docEnv.isSelected(te)) {
2497                 olist.add(te);
2498             }
</pre>
</td>
<td>
<hr />
<pre>
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.javadoc.internal.doclets.toolkit.util;
  27 
  28 import java.lang.annotation.Documented;
  29 import java.lang.ref.SoftReference;
  30 import java.net.URI;
  31 import java.text.CollationKey;
  32 import java.text.Collator;
  33 import java.text.ParseException;
  34 import java.text.RuleBasedCollator;
  35 import java.util.ArrayDeque;
  36 import java.util.ArrayList;
  37 import java.util.Arrays;
  38 import java.util.Collection;
  39 import java.util.Collections;

  40 import java.util.Deque;
  41 import java.util.EnumSet;
  42 import java.util.HashMap;
  43 import java.util.HashSet;
  44 import java.util.Iterator;
  45 import java.util.LinkedHashMap;
  46 import java.util.LinkedHashSet;
  47 import java.util.List;
  48 import java.util.Locale;
  49 import java.util.Map;
  50 import java.util.Map.Entry;
  51 import java.util.Objects;
  52 import java.util.Set;
  53 import java.util.SortedSet;
  54 import java.util.TreeMap;
  55 import java.util.TreeSet;
  56 import java.util.function.Predicate;
  57 import java.util.stream.Collectors;
  58 
  59 import javax.lang.model.SourceVersion;
</pre>
<hr />
<pre>
  77 import javax.lang.model.type.NoType;
  78 import javax.lang.model.type.PrimitiveType;
  79 import javax.lang.model.type.TypeMirror;
  80 import javax.lang.model.type.TypeVariable;
  81 import javax.lang.model.type.WildcardType;
  82 import javax.lang.model.util.ElementFilter;
  83 import javax.lang.model.util.ElementKindVisitor14;
  84 import javax.lang.model.util.Elements;
  85 import javax.lang.model.util.SimpleElementVisitor14;
  86 import javax.lang.model.util.SimpleTypeVisitor9;
  87 import javax.lang.model.util.TypeKindVisitor9;
  88 import javax.lang.model.util.Types;
  89 import javax.tools.FileObject;
  90 import javax.tools.JavaFileManager;
  91 import javax.tools.JavaFileManager.Location;
  92 import javax.tools.StandardLocation;
  93 
  94 import com.sun.source.doctree.DocCommentTree;
  95 import com.sun.source.doctree.DocTree;
  96 import com.sun.source.doctree.DocTree.Kind;
<span class="line-added">  97 import com.sun.source.doctree.EndElementTree;</span>
  98 import com.sun.source.doctree.ParamTree;
<span class="line-modified">  99 import com.sun.source.doctree.StartElementTree;</span>
<span class="line-added"> 100 import com.sun.source.doctree.TextTree;</span>
 101 import com.sun.source.doctree.UnknownBlockTagTree;
 102 import com.sun.source.tree.CompilationUnitTree;
 103 import com.sun.source.tree.LineMap;
 104 import com.sun.source.util.DocSourcePositions;
 105 import com.sun.source.util.DocTrees;
 106 import com.sun.source.util.TreePath;
 107 import com.sun.tools.javac.model.JavacTypes;

 108 import jdk.javadoc.internal.doclets.toolkit.BaseConfiguration;
 109 import jdk.javadoc.internal.doclets.toolkit.BaseOptions;
 110 import jdk.javadoc.internal.doclets.toolkit.CommentUtils.DocCommentDuo;

 111 import jdk.javadoc.internal.doclets.toolkit.Resources;
 112 import jdk.javadoc.internal.doclets.toolkit.WorkArounds;
 113 import jdk.javadoc.internal.doclets.toolkit.taglets.BaseTaglet;
 114 import jdk.javadoc.internal.doclets.toolkit.taglets.Taglet;
 115 import jdk.javadoc.internal.tool.DocEnvImpl;
 116 
 117 import static javax.lang.model.element.ElementKind.*;
 118 import static javax.lang.model.element.Modifier.*;
 119 import static javax.lang.model.type.TypeKind.*;
 120 
 121 import static com.sun.source.doctree.DocTree.Kind.*;
 122 import static jdk.javadoc.internal.doclets.toolkit.builders.ConstantsSummaryBuilder.MAX_CONSTANT_VALUE_INDEX_LENGTH;
 123 
 124 /**
 125  * Utilities Class for Doclets.
 126  *
 127  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
 128  *  If you write code that depends on this, you do so at your own risk.
 129  *  This code and its internal interfaces are subject to change or
 130  *  deletion without notice.&lt;/b&gt;
 131  */
 132 public class Utils {
 133     public final BaseConfiguration configuration;
 134     private final BaseOptions options;

 135     private final Resources resources;
 136     public final DocTrees docTrees;
 137     public final Elements elementUtils;
 138     public final Types typeUtils;
<span class="line-added"> 139     public final Comparators comparators;</span>
 140     private final JavaScriptScanner javaScriptScanner;
 141 
 142     public Utils(BaseConfiguration c) {
 143         configuration = c;
 144         options = configuration.getOptions();

 145         resources = configuration.getDocResources();
 146         elementUtils = c.docEnv.getElementUtils();
 147         typeUtils = c.docEnv.getTypeUtils();
 148         docTrees = c.docEnv.getDocTrees();
 149         javaScriptScanner = c.isAllowScriptInComments() ? null : new JavaScriptScanner();
<span class="line-added"> 150         comparators = new Comparators(this);</span>
 151     }
 152 
 153     // our own little symbol table
 154     private HashMap&lt;String, TypeMirror&gt; symtab = new HashMap&lt;&gt;();
 155 
 156     public TypeMirror getSymbol(String signature) {
 157         TypeMirror type = symtab.get(signature);
 158         if (type == null) {
 159             TypeElement typeElement = elementUtils.getTypeElement(signature);
 160             if (typeElement == null)
 161                 return null;
 162             type = typeElement.asType();
 163             if (type == null)
 164                 return null;
 165             symtab.put(signature, type);
 166         }
 167         return type;
 168     }
 169 
 170     public TypeMirror getObjectType() {
</pre>
<hr />
<pre>
 198     public TypeMirror getDeprecatedType() {
 199         return getSymbol(&quot;java.lang.Deprecated&quot;);
 200     }
 201 
 202     public TypeMirror getFunctionalInterface() {
 203         return getSymbol(&quot;java.lang.FunctionalInterface&quot;);
 204     }
 205 
 206     /**
 207      * Return array of class members whose documentation is to be generated.
 208      * If the member is deprecated do not include such a member in the
 209      * returned array.
 210      *
 211      * @param  members    Array of members to choose from.
 212      * @return List       List of eligible members for whom
 213      *                    documentation is getting generated.
 214      */
 215     public List&lt;Element&gt; excludeDeprecatedMembers(List&lt;? extends Element&gt; members) {
 216         return members.stream()
 217                       .filter(member -&gt; !isDeprecated(member))
<span class="line-modified"> 218                       .sorted(comparators.makeGeneralPurposeComparator())</span>
 219                       .collect(Collectors.toCollection(ArrayList::new));
 220     }
 221 
 222     /**
 223      * Search for the given method in the given class.
 224      *
 225      * @param  te        Class to search into.
 226      * @param  method    Method to be searched.
 227      * @return ExecutableElement Method found, null otherwise.
 228      */
 229     public ExecutableElement findMethod(TypeElement te, ExecutableElement method) {
 230         for (Element m : getMethods(te)) {
 231             if (executableMembersEqual(method, (ExecutableElement) m)) {
 232                 return (ExecutableElement) m;
 233             }
 234         }
 235         return null;
 236     }
 237 
 238     /**
</pre>
<hr />
<pre>
 643         switch(kind) {
 644               case ENUM_CONSTANT: case EXCEPTION_PARAMETER: case FIELD:
 645               case LOCAL_VARIABLE: case PARAMETER:
 646               case RESOURCE_VARIABLE:
 647                   return true;
 648               default:
 649                   return false;
 650         }
 651     }
 652 
 653     public boolean isTypeElement(Element e) {
 654         switch (e.getKind()) {
 655             case CLASS: case ENUM: case INTERFACE: case ANNOTATION_TYPE: case RECORD:
 656                 return true;
 657             default:
 658                 return false;
 659         }
 660     }
 661 
 662     /**
<span class="line-modified"> 663      * Get the signature of an executable element with qualified parameter types</span>
<span class="line-added"> 664      * in the context of type element {@code site}.</span>
 665      * For instance, for a method {@code mymethod(String x, int y)},
 666      * it will return {@code (java.lang.String,int)}.
 667      *
<span class="line-modified"> 668      * @param e the executable element</span>
<span class="line-modified"> 669      * @param site the contextual site</span>
<span class="line-added"> 670      * @return String signature with qualified parameter types</span>
 671      */
<span class="line-modified"> 672     public String signature(ExecutableElement e, TypeElement site) {</span>
<span class="line-modified"> 673         return makeSignature(e, site, true);</span>
 674     }
 675 
 676     /**
<span class="line-modified"> 677      * Get the flat signature of an executable element with simple (unqualified)</span>
<span class="line-modified"> 678      * parameter types in the context of type element {@code site}.</span>

 679      * For instance, for a method {@code mymethod(String x, int y)},
 680      * it will return {@code (String, int)}.
<span class="line-added"> 681      *</span>
<span class="line-added"> 682      * @param e the executable element</span>
<span class="line-added"> 683      * @param site the contextual site</span>
<span class="line-added"> 684      * @return String signature with simple (unqualified) parameter types</span>
 685      */
<span class="line-modified"> 686     public String flatSignature(ExecutableElement e, TypeElement site) {</span>
<span class="line-modified"> 687         return makeSignature(e, site, false);</span>
 688     }
 689 
<span class="line-modified"> 690     public String makeSignature(ExecutableElement e, TypeElement site, boolean full) {</span>
<span class="line-modified"> 691         return makeSignature(e, site, full, false);</span>
 692     }
 693 
<span class="line-modified"> 694     public String makeSignature(ExecutableElement e, TypeElement site, boolean full, boolean ignoreTypeParameters) {</span>
 695         StringBuilder result = new StringBuilder();
 696         result.append(&quot;(&quot;);
<span class="line-modified"> 697         ExecutableType executableType = asInstantiatedMethodType(site, e);</span>
<span class="line-added"> 698         Iterator&lt;? extends TypeMirror&gt; iterator = executableType.getParameterTypes().iterator();</span>
 699         while (iterator.hasNext()) {
<span class="line-modified"> 700             TypeMirror type = iterator.next();</span>

 701             result.append(getTypeSignature(type, full, ignoreTypeParameters));
 702             if (iterator.hasNext()) {
 703                 result.append(&quot;, &quot;);
 704             }
 705         }
 706         if (e.isVarArgs()) {
 707             int len = result.length();
 708             result.replace(len - 2, len, &quot;...&quot;);
 709         }
 710         result.append(&quot;)&quot;);
 711         return result.toString();
 712     }
 713 
 714     public String getTypeSignature(TypeMirror t, boolean qualifiedName, boolean noTypeParameters) {
 715         return new SimpleTypeVisitor9&lt;StringBuilder, Void&gt;() {
 716             final StringBuilder sb = new StringBuilder();
 717 
 718             @Override
 719             public StringBuilder visitArray(ArrayType t, Void p) {
 720                 TypeMirror componentType = t.getComponentType();
</pre>
<hr />
<pre>
 913                 t = getSuperType(asTypeElement(t))) {
 914             TypeElement te = asTypeElement(t);
 915             if (te == null) {
 916                 return null;
 917             }
 918             VisibleMemberTable vmt = configuration.getVisibleMemberTable(te);
 919             for (Element e : vmt.getMembers(VisibleMemberTable.Kind.METHODS)) {
 920                 ExecutableElement ee = (ExecutableElement)e;
 921                 if (configuration.workArounds.overrides(method, ee, origin) &amp;&amp;
 922                         !isSimpleOverride(ee)) {
 923                     return ee;
 924                 }
 925             }
 926             if (t.equals(getObjectType()))
 927                 return null;
 928         }
 929         return null;
 930     }
 931 
 932     public SortedSet&lt;TypeElement&gt; getTypeElementsAsSortedSet(Iterable&lt;TypeElement&gt; typeElements) {
<span class="line-modified"> 933         SortedSet&lt;TypeElement&gt; set = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
 934         typeElements.forEach(set::add);
 935         return set;
 936     }
 937 
 938     public List&lt;? extends DocTree&gt; getSerialDataTrees(ExecutableElement member) {
 939         return getBlockTags(member, SERIAL_DATA);
 940     }
 941 
 942     public FileObject getFileObject(TypeElement te) {
 943         return docTrees.getPath(te).getCompilationUnit().getSourceFile();
 944     }
 945 
 946     public TypeMirror getDeclaredType(TypeElement enclosing, TypeMirror target) {
 947         return getDeclaredType(Collections.emptyList(), enclosing, target);
 948     }
 949 
 950     /**
 951      * Finds the declaration of the enclosing&#39;s type parameter.
 952      *
 953      * @param values
</pre>
<hr />
<pre>
1561         if (!getBlockTags(m).isEmpty() || isDeprecated(m))
1562             return false;
1563 
1564         List&lt;? extends DocTree&gt; fullBody = getFullBody(m);
1565         return fullBody.isEmpty() ||
1566                 (fullBody.size() == 1 &amp;&amp; fullBody.get(0).getKind().equals(Kind.INHERIT_DOC));
1567     }
1568 
1569     /**
1570      * In case of JavaFX mode on, filters out classes that are private,
1571      * package private, these are not documented in JavaFX mode, also
1572      * remove those classes that have &amp;#64;hidden or &amp;#64;treatAsPrivate comment tag.
1573      *
1574      * @param classlist a collection of TypeElements
1575      * @param javafx set to true if in JavaFX mode.
1576      * @return list of filtered classes.
1577      */
1578     public SortedSet&lt;TypeElement&gt; filterOutPrivateClasses(Iterable&lt;TypeElement&gt; classlist,
1579             boolean javafx) {
1580         SortedSet&lt;TypeElement&gt; filteredOutClasses =
<span class="line-modified">1581                 new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
1582         if (!javafx) {
1583             for (Element te : classlist) {
1584                 if (!hasHiddenTag(te)) {
1585                     filteredOutClasses.add((TypeElement)te);
1586                 }
1587             }
1588             return filteredOutClasses;
1589         }
1590         for (Element e : classlist) {
1591             if (isPrivate(e) || isPackagePrivate(e) || hasHiddenTag(e)) {
1592                 continue;
1593             }
1594             filteredOutClasses.add((TypeElement)e);
1595         }
1596         return filteredOutClasses;
1597     }
1598 
1599     /**
1600      * Compares two elements.
1601      * @param e1 first Element
</pre>
<hr />
<pre>
1628     public int compareStrings(String s1, String s2) {
1629         return compareStrings(true, s1, s2);
1630     }
1631 
1632     /**
1633      * A general purpose case sensitive String comparator, which
1634      * compares two Strings using a Collator strength of &quot;SECONDARY&quot;.
1635      *
1636      * @param s1 first String to compare.
1637      * @param s2 second String to compare.
1638      * @return a negative integer, zero, or a positive integer as the first
1639      *         argument is less than, equal to, or greater than the second.
1640      */
1641     public int compareCaseCompare(String s1, String s2) {
1642         return compareStrings(false, s1, s2);
1643     }
1644 
1645     private DocCollator tertiaryCollator = null;
1646     private DocCollator secondaryCollator = null;
1647 
<span class="line-modified">1648     int compareStrings(boolean caseSensitive, String s1, String s2) {</span>
1649         if (caseSensitive) {
1650             if (tertiaryCollator == null) {
1651                 tertiaryCollator = new DocCollator(configuration.locale, Collator.TERTIARY);
1652             }
1653             return tertiaryCollator.compare(s1, s2);
1654         }
1655         if (secondaryCollator == null) {
1656             secondaryCollator = new DocCollator(configuration.locale, Collator.SECONDARY);
1657         }
1658         return secondaryCollator.compare(s1, s2);
1659     }
1660 
<span class="line-added">1661     public String getHTMLTitle(Element element) {</span>
<span class="line-added">1662         List&lt;? extends DocTree&gt; preamble = getPreamble(element);</span>
<span class="line-added">1663         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">1664         boolean titleFound = false;</span>
<span class="line-added">1665         loop:</span>
<span class="line-added">1666         for (DocTree dt : preamble) {</span>
<span class="line-added">1667             switch (dt.getKind()) {</span>
<span class="line-added">1668                 case START_ELEMENT:</span>
<span class="line-added">1669                     StartElementTree nodeStart = (StartElementTree)dt;</span>
<span class="line-added">1670                     if (Utils.toLowerCase(nodeStart.getName().toString()).equals(&quot;title&quot;)) {</span>
<span class="line-added">1671                         titleFound = true;</span>
<span class="line-added">1672                     }</span>
<span class="line-added">1673                     break;</span>
<span class="line-added">1674 </span>
<span class="line-added">1675                 case END_ELEMENT:</span>
<span class="line-added">1676                     EndElementTree nodeEnd = (EndElementTree)dt;</span>
<span class="line-added">1677                     if (Utils.toLowerCase(nodeEnd.getName().toString()).equals(&quot;title&quot;)) {</span>
<span class="line-added">1678                         break loop;</span>
<span class="line-added">1679                     }</span>
<span class="line-added">1680                     break;</span>
<span class="line-added">1681 </span>
<span class="line-added">1682                 case TEXT:</span>
<span class="line-added">1683                     TextTree nodeText = (TextTree)dt;</span>
<span class="line-added">1684                     if (titleFound)</span>
<span class="line-added">1685                         sb.append(nodeText.getBody());</span>
<span class="line-added">1686                     break;</span>
<span class="line-added">1687 </span>
<span class="line-added">1688                 default:</span>
<span class="line-added">1689                     // do nothing</span>
<span class="line-added">1690             }</span>
<span class="line-added">1691         }</span>
<span class="line-added">1692         return sb.toString().trim();</span>
<span class="line-added">1693     }</span>
<span class="line-added">1694 </span>
1695     private static class DocCollator {
1696         private final Map&lt;String, CollationKey&gt; keys;
1697         private final Collator instance;
1698         private final int MAX_SIZE = 1000;
1699         private DocCollator(Locale locale, int strength) {
1700             instance = createCollator(locale);
1701             instance.setStrength(strength);
1702 
1703             keys = new LinkedHashMap&lt;String, CollationKey&gt;(MAX_SIZE + 1, 0.75f, true) {
1704                 private static final long serialVersionUID = 1L;
1705                 @Override
1706                 protected boolean removeEldestEntry(Entry&lt;String, CollationKey&gt; eldest) {
1707                     return size() &gt; MAX_SIZE;
1708                 }
1709             };
1710         }
1711 
1712         CollationKey getKey(String s) {
1713             return keys.computeIfAbsent(s, instance :: getCollationKey);
1714         }
</pre>
<hr />
<pre>
1716         public int compare(String s1, String s2) {
1717             return getKey(s1).compareTo(getKey(s2));
1718         }
1719 
1720         private Collator createCollator(Locale locale) {
1721             Collator baseCollator = Collator.getInstance(locale);
1722             if (baseCollator instanceof RuleBasedCollator) {
1723                 // Extend collator to sort signatures with additional args and var-args in a well-defined order:
1724                 // () &lt; (int) &lt; (int, int) &lt; (int...)
1725                 try {
1726                     return new RuleBasedCollator(((RuleBasedCollator) baseCollator).getRules()
1727                             + &quot;&amp; &#39;)&#39; &lt; &#39;,&#39; &lt; &#39;.&#39;,&#39;[&#39;&quot;);
1728                 } catch (ParseException e) {
1729                     throw new RuntimeException(e);
1730                 }
1731             }
1732             return baseCollator;
1733         }
1734     }
1735 















































































































































































































































1736     /**
1737      * Get the qualified type name of a TypeMirror compatible with the Element&#39;s
1738      * getQualified name, returns  the qualified name of the Reference type
1739      * otherwise the primitive name.
1740      * @param t the type whose name is to be obtained.
1741      * @return the fully qualified name of Reference type or the primitive name
1742      */
1743     public String getQualifiedTypeName(TypeMirror t) {
1744         return new SimpleTypeVisitor9&lt;String, Void&gt;() {
1745             @Override
1746             public String visitDeclared(DeclaredType t, Void p) {
1747                 return getFullyQualifiedName(t.asElement());
1748             }
1749 
1750             @Override
1751             public String visitArray(ArrayType t, Void p) {
1752                return visit(t.getComponentType());
1753             }
1754 
1755             @Override
</pre>
<hr />
<pre>
1788                 return e.getQualifiedName().toString();
1789             }
1790 
1791             @Override
1792             public String visitPackage(PackageElement e, Void p) {
1793                 return e.getQualifiedName().toString();
1794             }
1795 
1796             @Override
1797             public String visitType(TypeElement e, Void p) {
1798                 return e.getQualifiedName().toString();
1799             }
1800 
1801             @Override
1802             protected String defaultAction(Element e, Void p) {
1803                 return outer ? visit(e.getEnclosingElement()) : e.getSimpleName().toString();
1804             }
1805         }.visit(e);
1806     }
1807 






















































































































































































































































1808 
1809     public Iterable&lt;TypeElement&gt; getEnclosedTypeElements(PackageElement pkg) {
1810         List&lt;TypeElement&gt; out = getInterfaces(pkg);
1811         out.addAll(getClasses(pkg));
1812         out.addAll(getEnums(pkg));
1813         out.addAll(getAnnotationTypes(pkg));
1814         out.addAll(getRecords(pkg));
1815         return out;
1816     }
1817 
1818     // Element related methods
1819     public List&lt;Element&gt; getAnnotationMembers(TypeElement aClass) {
1820         List&lt;Element&gt; members = getAnnotationFields(aClass);
1821         members.addAll(getAnnotationMethods(aClass));
1822         return members;
1823     }
1824 
1825     public List&lt;Element&gt; getAnnotationFields(TypeElement aClass) {
1826         return getItems0(aClass, true, FIELD);
1827     }
</pre>
<hr />
<pre>
1884         if (member == null || member.getKind() != ENUM_CONSTANT) {
1885             throw new IllegalArgumentException(&quot;must be an enum constant: &quot; + member);
1886         }
1887         return member.getEnclosingElement().getEnclosedElements().indexOf(member);
1888     }
1889 
1890     private Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; modulePackageMap = null;
1891     public Map&lt;ModuleElement, Set&lt;PackageElement&gt;&gt; getModulePackageMap() {
1892         if (modulePackageMap == null) {
1893             modulePackageMap = new HashMap&lt;&gt;();
1894             Set&lt;PackageElement&gt; pkgs = configuration.getIncludedPackageElements();
1895             pkgs.forEach(pkg -&gt; {
1896                 ModuleElement mod = elementUtils.getModuleOf(pkg);
1897                 modulePackageMap.computeIfAbsent(mod, m -&gt; new HashSet&lt;&gt;()).add(pkg);
1898             });
1899         }
1900         return modulePackageMap;
1901     }
1902 
1903     public Map&lt;ModuleElement, String&gt; getDependentModules(ModuleElement mdle) {
<span class="line-modified">1904         Map&lt;ModuleElement, String&gt; result = new TreeMap&lt;&gt;(comparators.makeModuleComparator());</span>
1905         Deque&lt;ModuleElement&gt; queue = new ArrayDeque&lt;&gt;();
1906         // get all the requires for the element in question
1907         for (RequiresDirective rd : ElementFilter.requiresIn(mdle.getDirectives())) {
1908             ModuleElement dep = rd.getDependency();
1909             // add the dependency to work queue
1910             if (!result.containsKey(dep)) {
1911                 if (rd.isTransitive()) {
1912                     queue.addLast(dep);
1913                 }
1914             }
1915             // add all exports for the primary module
1916             result.put(rd.getDependency(), getModifiers(rd));
1917         }
1918 
1919         // add only requires public for subsequent module dependencies
1920         for (ModuleElement m = queue.poll(); m != null; m = queue.poll()) {
1921             for (RequiresDirective rd : ElementFilter.requiresIn(m.getDirectives())) {
1922                 ModuleElement dep = rd.getDependency();
1923                 if (!result.containsKey(dep)) {
1924                     if (rd.isTransitive()) {
</pre>
<hr />
<pre>
1990         return convertToTypeElement(getItems(e, false, INTERFACE));
1991     }
1992 
1993     public List&lt;Element&gt; getEnumConstants(Element e) {
1994         return getItems(e, true, ENUM_CONSTANT);
1995     }
1996 
1997     public List&lt;TypeElement&gt; getEnums(Element e) {
1998         return convertToTypeElement(getItems(e, true, ENUM));
1999     }
2000 
2001     public List&lt;TypeElement&gt; getEnumsUnfiltered(Element e) {
2002         return convertToTypeElement(getItems(e, false, ENUM));
2003     }
2004 
2005     public SortedSet&lt;TypeElement&gt; getAllClassesUnfiltered(Element e) {
2006         List&lt;TypeElement&gt; clist = getClassesUnfiltered(e);
2007         clist.addAll(getInterfacesUnfiltered(e));
2008         clist.addAll(getAnnotationTypesUnfiltered(e));
2009         clist.addAll(getRecordsUnfiltered(e));
<span class="line-modified">2010         SortedSet&lt;TypeElement&gt; oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
2011         oset.addAll(clist);
2012         return oset;
2013     }
2014 
2015     private final HashMap&lt;Element, SortedSet&lt;TypeElement&gt;&gt; cachedClasses = new HashMap&lt;&gt;();
2016     /**
2017      * Returns a list containing classes and interfaces,
2018      * including annotation types.
2019      * @param e Element
2020      * @return List
2021      */
2022     public SortedSet&lt;TypeElement&gt; getAllClasses(Element e) {
2023         SortedSet&lt;TypeElement&gt; oset = cachedClasses.get(e);
2024         if (oset != null)
2025             return oset;
2026         List&lt;TypeElement&gt; clist = getClasses(e);
2027         clist.addAll(getInterfaces(e));
2028         clist.addAll(getAnnotationTypes(e));
2029         clist.addAll(getEnums(e));
2030         clist.addAll(getRecords(e));
<span class="line-modified">2031         oset = new TreeSet&lt;&gt;(comparators.makeGeneralPurposeComparator());</span>
2032         oset.addAll(clist);
2033         cachedClasses.put(e, oset);
2034         return oset;
2035     }
2036 
2037     /*
2038      * Get all the elements unfiltered and filter them finally based
2039      * on its visibility, this works differently from the other getters.
2040      */
2041     private List&lt;TypeElement&gt; getInnerClasses(Element e, boolean filter) {
2042         List&lt;TypeElement&gt; olist = new ArrayList&lt;&gt;();
2043         for (TypeElement te : getClassesUnfiltered(e)) {
2044             if (!filter || configuration.docEnv.isSelected(te)) {
2045                 olist.add(te);
2046             }
2047         }
2048         for (TypeElement te : getInterfacesUnfiltered(e)) {
2049             if (!filter || configuration.docEnv.isSelected(te)) {
2050                 olist.add(te);
2051             }
</pre>
</td>
</tr>
</table>
<center><a href="TypeElementCatalog.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="VisibleMemberTable.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="HtmlDoclet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.javadoc/share/classes/jdk/javadoc/internal/doclets/formats/html/HtmlDocletWriter.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;
<span class="line-removed">  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlAttr;</span>
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  82 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified">  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTag;</span>
  84 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  89 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;
<span class="line-removed">  90 import jdk.javadoc.internal.doclets.toolkit.AnnotationTypeWriter;</span>
  91 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  92 import jdk.javadoc.internal.doclets.toolkit.Content;
  93 import jdk.javadoc.internal.doclets.toolkit.Messages;
  94 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  95 import jdk.javadoc.internal.doclets.toolkit.Resources;
  96 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  97 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;

  98 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 104 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 105 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 106 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 107 
 108 import static com.sun.source.doctree.DocTree.Kind.CODE;
 109 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK;
 111 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 112 import static com.sun.source.doctree.DocTree.Kind.SEE;
 113 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 114 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 115 
 116 
 117 /**
</pre>
<hr />
<pre>
 152      * The global configuration information for this run.
 153      */
 154     public final HtmlConfiguration configuration;
 155 
 156     protected final SearchIndexItems searchItems;
 157 
 158     protected final HtmlOptions options;
 159 
 160     protected final Utils utils;
 161 
 162     protected final Contents contents;
 163 
 164     protected final Messages messages;
 165 
 166     protected final Resources resources;
 167 
 168     protected final Links links;
 169 
 170     protected final DocPaths docPaths;
 171 


 172     /**
 173      * To check whether annotation heading is printed or not.
 174      */
 175     protected boolean printedAnnotationHeading = false;
 176 
 177     /**
 178      * To check whether annotation field heading is printed or not.
 179      */
 180     protected boolean printedAnnotationFieldHeading = false;
 181 
 182     /**
 183      * To check whether the repeated annotations is documented or not.
 184      */
 185     private boolean isAnnotationDocumented = false;
 186 
 187     /**
 188      * To check whether the container annotations is documented or not.
 189      */
 190     private boolean isContainerDocumented = false;
 191 
</pre>
<hr />
<pre>
 202      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 203      * to avoid generating duplicates.)
 204      */
 205     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 206 
 207     /**
 208      * Creates an {@code HtmlDocletWriter}.
 209      *
 210      * @param configuration the configuration for this doclet
 211      * @param path the file to be generated.
 212      */
 213     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 214         this.configuration = configuration;
 215         this.searchItems = configuration.searchItems;
 216         this.options = configuration.getOptions();
 217         this.contents = configuration.contents;
 218         this.messages = configuration.messages;
 219         this.resources = configuration.docResources;
 220         this.links = new Links(path);
 221         this.utils = configuration.utils;

 222         this.path = path;
 223         this.pathToRoot = path.parent().invert();
 224         this.filename = path.basename();
 225         this.docPaths = configuration.docPaths;
 226         this.mainBodyScript = new Script();
 227 
 228         messages.notice(&quot;doclet.Generating_0&quot;,
 229             DocFile.createFileForOutput(configuration, path).getPath());
 230     }
 231 
 232     /**
 233      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 234      * as -header, -footer, -top and -bottom, and when converting a relative
 235      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 236      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 237      * comments.)
 238      * &lt;p&gt;
 239      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 240      * destination directory from the directory where the file is being
 241      * written, looping to handle all such tags in htmlstr.
</pre>
<hr />
<pre>
 269                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 270                 buf.append(options.docrootParent());
 271                 prevEnd += 3;
 272             } else {
 273                 // Insert relative path where {@docRoot} was located
 274                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 275             }
 276             // Append slash if next character is not a slash
 277             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 278                 buf.append(&#39;/&#39;);
 279             }
 280         } while (docrootMatcher.find());
 281         buf.append(htmlstr.substring(prevEnd));
 282         return buf.toString();
 283     }
 284     //where:
 285         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 286         private static final Pattern docrootPattern =
 287                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 288 
<span class="line-removed"> 289     /**</span>
<span class="line-removed"> 290      * Get the script to show or hide the All classes link.</span>
<span class="line-removed"> 291      *</span>
<span class="line-removed"> 292      * @param id id of the element to show or hide</span>
<span class="line-removed"> 293      * @return a content tree for the script</span>
<span class="line-removed"> 294      */</span>
<span class="line-removed"> 295     public Content getAllClassesLinkScript(String id) {</span>
<span class="line-removed"> 296         Script script = new Script(&quot;&lt;!--\n&quot; +</span>
<span class="line-removed"> 297                 &quot;  allClassesLink = document.getElementById(&quot;)</span>
<span class="line-removed"> 298                 .appendStringLiteral(id)</span>
<span class="line-removed"> 299                 .append(&quot;);\n&quot; +</span>
<span class="line-removed"> 300                 &quot;  if(window==top) {\n&quot; +</span>
<span class="line-removed"> 301                 &quot;    allClassesLink.style.display = \&quot;block\&quot;;\n&quot; +</span>
<span class="line-removed"> 302                 &quot;  }\n&quot; +</span>
<span class="line-removed"> 303                 &quot;  else {\n&quot; +</span>
<span class="line-removed"> 304                 &quot;    allClassesLink.style.display = \&quot;none\&quot;;\n&quot; +</span>
<span class="line-removed"> 305                 &quot;  }\n&quot; +</span>
<span class="line-removed"> 306                 &quot;  //--&gt;\n&quot;);</span>
<span class="line-removed"> 307         Content div = HtmlTree.DIV(script.asContent());</span>
<span class="line-removed"> 308         Content div_noscript = HtmlTree.DIV(contents.noScriptMessage);</span>
<span class="line-removed"> 309         Content noScript = HtmlTree.NOSCRIPT(div_noscript);</span>
<span class="line-removed"> 310         div.add(noScript);</span>
<span class="line-removed"> 311         return div;</span>
<span class="line-removed"> 312     }</span>
 313 
 314     /**
 315      * Add method information.
 316      *
 317      * @param method the method to be documented
 318      * @param dl the content tree to which the method information will be added
 319      */
 320     private void addMethodInfo(ExecutableElement method, Content dl) {
 321         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 322         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 323         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 324         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 325         // Check whether there is any implementation or overridden info to be
 326         // printed. If no overridden or implementation info needs to be
 327         // printed, do not print this section.
 328         if ((!intfacs.isEmpty()
 329                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 330                 || overriddenMethod != null) {
 331             MethodWriterImpl.addImplementsInfo(this, method, dl);
 332             if (overriddenMethod != null) {
</pre>
<hr />
<pre>
 447     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 448                                   String description,
 449                                   Content extraHeadContent,
 450                                   List&lt;DocPath&gt; localStylesheets,
 451                                   Content body)
 452             throws DocFileIOException {
 453         Content htmlComment = contents.newPage;
 454         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 455         additionalStylesheets.addAll(localStylesheets);
 456         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 457                 .setTimestamp(!options.noTimestamp())
 458                 .setDescription(description)
 459                 .setGenerator(getGenerator(getClass()))
 460                 .setTitle(winTitle)
 461                 .setCharset(options.charset())
 462                 .addKeywords(metakeywords)
 463                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 464                 .setIndex(options.createIndex(), mainBodyScript)
 465                 .addContent(extraHeadContent);
 466 
<span class="line-modified"> 467         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head.toContent(), body);</span>
 468         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 469         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 470     }
 471 
 472     /**
 473      * Get the window title.
 474      *
 475      * @param title the title string to construct the complete window title
 476      * @return the window title string
 477      */
 478     public String getWindowTitle(String title) {
 479         if (options.windowTitle().length() &gt; 0) {
 480             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 481         }
 482         return title;
 483     }
 484 
 485     /**
 486      * Get user specified header and the footer.
 487      *
</pre>
<hr />
<pre>
 998             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 999                 .label(label)
1000                 .where(links.getName(getAnchor(emd))));
1001         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
1002             return getLink(new LinkInfoImpl(configuration, context, typeElement)
1003                 .label(label).where(links.getName(element.getSimpleName().toString())));
1004         } else {
1005             return label;
1006         }
1007     }
1008 
1009     public String getAnchor(ExecutableElement executableElement) {
1010         return getAnchor(executableElement, false);
1011     }
1012 
1013     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
1014         if (isProperty) {
1015             return executableElement.getSimpleName().toString();
1016         }
1017         String member = anchorName(executableElement);
<span class="line-modified">1018         String erasedSignature = utils.makeSignature(executableElement, true, true);</span>
1019         return member + erasedSignature;
1020     }
1021 
1022     public String anchorName(Element member) {
1023         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1024             return &quot;&lt;init&gt;&quot;;
1025         } else {
1026             return utils.getSimpleName(member);
1027         }
1028     }
1029 
1030     public Content seeTagToContent(Element element, DocTree see) {
1031         Kind kind = see.getKind();
1032         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1033             return new ContentBuilder();
1034         }
1035 
1036         CommentHelper ch = utils.getCommentHelper(element);
1037         String tagName = ch.getTagName(see);
1038         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
</pre>
<hr />
<pre>
1127                 // inherits it automatically.
1128                 if (this instanceof ClassWriterImpl) {
1129                     containing = ((ClassWriterImpl) this).getTypeElement();
1130                 } else if (!utils.isPublic(containing)) {
1131                     messages.warning(
1132                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1133                         tagName, utils.getFullyQualifiedName(containing));
1134                 } else {
1135                     messages.warning(
1136                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1137                         tagName, seetext);
1138                 }
1139             }
1140             if (configuration.currentTypeElement != containing) {
1141                 refMemName = (utils.isConstructor(refMem))
1142                         ? refMemName
1143                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1144             }
1145             if (utils.isExecutableElement(refMem)) {
1146                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
<span class="line-modified">1147                     refMemName += utils.makeSignature((ExecutableElement)refMem, true);</span>
1148                 }
1149                 if (overriddenMethod != null) {
1150                     // The method to actually link.
1151                     refMem = overriddenMethod;
1152                 }
1153             }
1154 
1155             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1156 
1157             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1158                     refMem, (label.isEmpty() ? text: label), false);
1159         }
1160     }
1161 
1162     private Content plainOrCode(boolean plain, Content body) {
1163         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1164     }
1165 
1166     /**
1167      * Add the inline comment.
</pre>
<hr />
<pre>
1340      * inline tags along the way.  Called wherever text can contain
1341      * an inline tag, such as in comments or in free-form text arguments
1342      * to block tags.
1343      *
1344      * @param holderTag       specific tag where comment resides
1345      * @param element         specific element where comment resides
1346      * @param trees           array of text tags and inline tags (often alternating)
1347      *                        present in the text of interest for this element
1348      * @param isFirstSentence true if text is first sentence
1349      * @param inSummary       if the comment tags are added into the summary section
1350      * @return a Content object
1351      */
1352     public Content commentTagsToContent(DocTree holderTag,
1353                                         Element element,
1354                                         List&lt;? extends DocTree&gt; trees,
1355                                         boolean isFirstSentence,
1356                                         boolean inSummary)
1357     {
1358         final Content result = new ContentBuilder() {
1359             @Override
<span class="line-modified">1360             public void add(CharSequence text) {</span>
<span class="line-modified">1361                 super.add(utils.normalizeNewlines(text));</span>
1362             }
1363         };
1364         CommentHelper ch = utils.getCommentHelper(element);
1365         // Array of all possible inline tags for this javadoc run
1366         configuration.tagletManager.checkTags(element, trees, true);
1367         commentRemoved = false;
1368 
1369         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1370             boolean isFirstNode = !iterator.hasPrevious();
1371             DocTree tag = iterator.next();
1372             boolean isLastNode  = !iterator.hasNext();
1373 
1374             if (isFirstSentence) {
1375                 // Ignore block tags
1376                 if (ignoreNonInlineTag(tag))
1377                     continue;
1378 
1379                 // Ignore any trailing whitespace OR whitespace after removed html comment
1380                 if ((isLastNode || commentRemoved)
1381                         &amp;&amp; tag.getKind() == TEXT
</pre>
<hr />
<pre>
1615                     if (output != null) {
1616                         result.add(output);
1617                     }
1618                     return false;
1619                 }
1620 
1621             }.visit(tag, null);
1622             commentRemoved = false;
1623             if (allDone)
1624                 break;
1625         }
1626         return result;
1627     }
1628 
1629     /**
1630      * Return true if relative links should not be redirected.
1631      *
1632      * @return Return true if a relative link should not be redirected.
1633      */
1634     private boolean shouldNotRedirectRelativeLinks() {
<span class="line-modified">1635         return  this instanceof AnnotationTypeWriter ||</span>
<span class="line-removed">1636                 this instanceof ClassWriter ||</span>
1637                 this instanceof PackageSummaryWriter;
1638     }
1639 
1640     /**
1641      * Suppose a piece of documentation has a relative link.  When you copy
1642      * that documentation to another place such as the index or class-use page,
1643      * that relative link will no longer work.  We should redirect those links
1644      * so that they will work again.
1645      * &lt;p&gt;
1646      * Here is the algorithm used to fix the link:
1647      * &lt;p&gt;
1648      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1649      * &lt;p&gt;
1650      * For example, suppose DocletEnvironment has this link:
1651      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1652      * &lt;p&gt;
1653      * If this link appeared in the index, we would redirect
1654      * the link like this:
1655      *
1656      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
</pre>
<hr />
<pre>
2102                 sb.append(&quot;, &quot;);
2103             }
2104             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2105                     .append(&quot;: &quot;)
2106                     .append(name);
2107         }
2108         return sb.toString();
2109     }
2110 
2111     static String getGenerator(Class&lt;?&gt; clazz) {
2112         return &quot;javadoc/&quot; + clazz.getSimpleName();
2113     }
2114 
2115     /**
2116      * Returns an HtmlTree for the BODY tag.
2117      *
2118      * @param title title for the window
2119      * @return an HtmlTree for the BODY tag
2120      */
2121     public HtmlTree getBody(String title) {
<span class="line-modified">2122         HtmlTree body = new HtmlTree(HtmlTag.BODY);</span>
<span class="line-removed">2123         body.put(HtmlAttr.CLASS, getBodyClass());</span>
2124 
2125         this.winTitle = title;
2126         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2127         // and package-frame
2128         body.add(mainBodyScript.asContent());
2129         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2130         body.add(noScript);
2131         return body;
2132     }
2133 
<span class="line-modified">2134     public String getBodyClass() {</span>
<span class="line-modified">2135         return getClass().getSimpleName()</span>
2136                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2137                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
<span class="line-modified">2138                 .replaceAll(&quot;(.)([A-Z])&quot;, &quot;$1-$2&quot;)</span>
<span class="line-modified">2139                 .replaceAll(&quot;(?i)^(module|package|class)$&quot;, &quot;$1-declaration&quot;)</span>
<span class="line-modified">2140                 .toLowerCase(Locale.US);</span>
2141     }
2142 
2143     Script getMainBodyScript() {
2144         return mainBodyScript;
2145     }
2146 
2147     /**
2148      * Returns the path of module/package specific stylesheets for the element.
2149      * @param element module/Package element
2150      * @return list of path of module/package specific stylesheets
2151      * @throws DocFileIOException
2152      */
2153     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2154         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2155         DocPath basePath = null;
2156         if (element instanceof PackageElement) {
2157             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2158             basePath = docPaths.forPackage((PackageElement)element);
2159         } else if (element instanceof ModuleElement) {
2160             basePath = DocPaths.forModule((ModuleElement)element);
</pre>
</td>
<td>
<hr />
<pre>
  60 import com.sun.source.doctree.DocRootTree;
  61 import com.sun.source.doctree.DocTree;
  62 import com.sun.source.doctree.DocTree.Kind;
  63 import com.sun.source.doctree.EndElementTree;
  64 import com.sun.source.doctree.EntityTree;
  65 import com.sun.source.doctree.ErroneousTree;
  66 import com.sun.source.doctree.IndexTree;
  67 import com.sun.source.doctree.InheritDocTree;
  68 import com.sun.source.doctree.LinkTree;
  69 import com.sun.source.doctree.LiteralTree;
  70 import com.sun.source.doctree.SeeTree;
  71 import com.sun.source.doctree.StartElementTree;
  72 import com.sun.source.doctree.SummaryTree;
  73 import com.sun.source.doctree.SystemPropertyTree;
  74 import com.sun.source.doctree.TextTree;
  75 import com.sun.source.util.SimpleDocTreeVisitor;
  76 import jdk.javadoc.internal.doclets.formats.html.markup.ContentBuilder;
  77 import jdk.javadoc.internal.doclets.formats.html.markup.Entity;
  78 import jdk.javadoc.internal.doclets.formats.html.markup.FixedStringContent;
  79 import jdk.javadoc.internal.doclets.formats.html.markup.Head;

  80 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlDocument;
  81 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlStyle;
<span class="line-modified">  82 import jdk.javadoc.internal.doclets.formats.html.markup.TagName;</span>
  83 import jdk.javadoc.internal.doclets.formats.html.markup.HtmlTree;
  84 import jdk.javadoc.internal.doclets.formats.html.markup.Links;
  85 import jdk.javadoc.internal.doclets.formats.html.markup.RawHtml;
  86 import jdk.javadoc.internal.doclets.formats.html.markup.Script;
  87 import jdk.javadoc.internal.doclets.formats.html.markup.StringContent;
  88 import jdk.javadoc.internal.doclets.formats.html.markup.TableHeader;

  89 import jdk.javadoc.internal.doclets.toolkit.ClassWriter;
  90 import jdk.javadoc.internal.doclets.toolkit.Content;
  91 import jdk.javadoc.internal.doclets.toolkit.Messages;
  92 import jdk.javadoc.internal.doclets.toolkit.PackageSummaryWriter;
  93 import jdk.javadoc.internal.doclets.toolkit.Resources;
  94 import jdk.javadoc.internal.doclets.toolkit.taglets.DocRootTaglet;
  95 import jdk.javadoc.internal.doclets.toolkit.taglets.TagletWriter;
<span class="line-added">  96 import jdk.javadoc.internal.doclets.toolkit.util.Comparators;</span>
  97 import jdk.javadoc.internal.doclets.toolkit.util.CommentHelper;
  98 import jdk.javadoc.internal.doclets.toolkit.util.DocFile;
  99 import jdk.javadoc.internal.doclets.toolkit.util.DocFileIOException;
 100 import jdk.javadoc.internal.doclets.toolkit.util.DocLink;
 101 import jdk.javadoc.internal.doclets.toolkit.util.DocPath;
 102 import jdk.javadoc.internal.doclets.toolkit.util.DocPaths;
 103 import jdk.javadoc.internal.doclets.toolkit.util.DocletConstants;
 104 import jdk.javadoc.internal.doclets.toolkit.util.Utils;
 105 import jdk.javadoc.internal.doclets.toolkit.util.VisibleMemberTable;
 106 
 107 import static com.sun.source.doctree.DocTree.Kind.CODE;
 108 import static com.sun.source.doctree.DocTree.Kind.COMMENT;
 109 import static com.sun.source.doctree.DocTree.Kind.LINK;
 110 import static com.sun.source.doctree.DocTree.Kind.LINK_PLAIN;
 111 import static com.sun.source.doctree.DocTree.Kind.SEE;
 112 import static com.sun.source.doctree.DocTree.Kind.TEXT;
 113 import static jdk.javadoc.internal.doclets.toolkit.util.CommentHelper.SPACER;
 114 
 115 
 116 /**
</pre>
<hr />
<pre>
 151      * The global configuration information for this run.
 152      */
 153     public final HtmlConfiguration configuration;
 154 
 155     protected final SearchIndexItems searchItems;
 156 
 157     protected final HtmlOptions options;
 158 
 159     protected final Utils utils;
 160 
 161     protected final Contents contents;
 162 
 163     protected final Messages messages;
 164 
 165     protected final Resources resources;
 166 
 167     protected final Links links;
 168 
 169     protected final DocPaths docPaths;
 170 
<span class="line-added"> 171     protected final Comparators comparators;</span>
<span class="line-added"> 172 </span>
 173     /**
 174      * To check whether annotation heading is printed or not.
 175      */
 176     protected boolean printedAnnotationHeading = false;
 177 
 178     /**
 179      * To check whether annotation field heading is printed or not.
 180      */
 181     protected boolean printedAnnotationFieldHeading = false;
 182 
 183     /**
 184      * To check whether the repeated annotations is documented or not.
 185      */
 186     private boolean isAnnotationDocumented = false;
 187 
 188     /**
 189      * To check whether the container annotations is documented or not.
 190      */
 191     private boolean isContainerDocumented = false;
 192 
</pre>
<hr />
<pre>
 203      * (Ideally, javadoc should be tracking all id&#39;s generated in a file
 204      * to avoid generating duplicates.)
 205      */
 206     Map&lt;String, Integer&gt; indexAnchorTable = new HashMap&lt;&gt;();
 207 
 208     /**
 209      * Creates an {@code HtmlDocletWriter}.
 210      *
 211      * @param configuration the configuration for this doclet
 212      * @param path the file to be generated.
 213      */
 214     public HtmlDocletWriter(HtmlConfiguration configuration, DocPath path) {
 215         this.configuration = configuration;
 216         this.searchItems = configuration.searchItems;
 217         this.options = configuration.getOptions();
 218         this.contents = configuration.contents;
 219         this.messages = configuration.messages;
 220         this.resources = configuration.docResources;
 221         this.links = new Links(path);
 222         this.utils = configuration.utils;
<span class="line-added"> 223         this.comparators = utils.comparators;</span>
 224         this.path = path;
 225         this.pathToRoot = path.parent().invert();
 226         this.filename = path.basename();
 227         this.docPaths = configuration.docPaths;
 228         this.mainBodyScript = new Script();
 229 
 230         messages.notice(&quot;doclet.Generating_0&quot;,
 231             DocFile.createFileForOutput(configuration, path).getPath());
 232     }
 233 
 234     /**
 235      * Replace {&amp;#064;docRoot} tag used in options that accept HTML text, such
 236      * as -header, -footer, -top and -bottom, and when converting a relative
 237      * HREF where commentTagsToString inserts a {&amp;#064;docRoot} where one was
 238      * missing.  (Also see DocRootTaglet for {&amp;#064;docRoot} tags in doc
 239      * comments.)
 240      * &lt;p&gt;
 241      * Replace {&amp;#064;docRoot} tag in htmlstr with the relative path to the
 242      * destination directory from the directory where the file is being
 243      * written, looping to handle all such tags in htmlstr.
</pre>
<hr />
<pre>
 271                 // Insert the absolute link if {@docRoot} is followed by &quot;/..&quot;.
 272                 buf.append(options.docrootParent());
 273                 prevEnd += 3;
 274             } else {
 275                 // Insert relative path where {@docRoot} was located
 276                 buf.append(pathToRoot.isEmpty() ? &quot;.&quot; : pathToRoot.getPath());
 277             }
 278             // Append slash if next character is not a slash
 279             if (prevEnd &lt; htmlstr.length() &amp;&amp; htmlstr.charAt(prevEnd) != &#39;/&#39;) {
 280                 buf.append(&#39;/&#39;);
 281             }
 282         } while (docrootMatcher.find());
 283         buf.append(htmlstr.substring(prevEnd));
 284         return buf.toString();
 285     }
 286     //where:
 287         // Note: {@docRoot} is not case sensitive when passed in with a command-line option:
 288         private static final Pattern docrootPattern =
 289                 Pattern.compile(Pattern.quote(&quot;{@docroot}&quot;), Pattern.CASE_INSENSITIVE);
 290 
























 291 
 292     /**
 293      * Add method information.
 294      *
 295      * @param method the method to be documented
 296      * @param dl the content tree to which the method information will be added
 297      */
 298     private void addMethodInfo(ExecutableElement method, Content dl) {
 299         TypeElement enclosing = utils.getEnclosingTypeElement(method);
 300         List&lt;? extends TypeMirror&gt; intfacs = enclosing.getInterfaces();
 301         ExecutableElement overriddenMethod = utils.overriddenMethod(method);
 302         VisibleMemberTable vmt = configuration.getVisibleMemberTable(enclosing);
 303         // Check whether there is any implementation or overridden info to be
 304         // printed. If no overridden or implementation info needs to be
 305         // printed, do not print this section.
 306         if ((!intfacs.isEmpty()
 307                 &amp;&amp; vmt.getImplementedMethods(method).isEmpty() == false)
 308                 || overriddenMethod != null) {
 309             MethodWriterImpl.addImplementsInfo(this, method, dl);
 310             if (overriddenMethod != null) {
</pre>
<hr />
<pre>
 425     public void printHtmlDocument(List&lt;String&gt; metakeywords,
 426                                   String description,
 427                                   Content extraHeadContent,
 428                                   List&lt;DocPath&gt; localStylesheets,
 429                                   Content body)
 430             throws DocFileIOException {
 431         Content htmlComment = contents.newPage;
 432         List&lt;DocPath&gt; additionalStylesheets = configuration.getAdditionalStylesheets();
 433         additionalStylesheets.addAll(localStylesheets);
 434         Head head = new Head(path, configuration.docletVersion, configuration.startTime)
 435                 .setTimestamp(!options.noTimestamp())
 436                 .setDescription(description)
 437                 .setGenerator(getGenerator(getClass()))
 438                 .setTitle(winTitle)
 439                 .setCharset(options.charset())
 440                 .addKeywords(metakeywords)
 441                 .setStylesheets(configuration.getMainStylesheet(), additionalStylesheets)
 442                 .setIndex(options.createIndex(), mainBodyScript)
 443                 .addContent(extraHeadContent);
 444 
<span class="line-modified"> 445         Content htmlTree = HtmlTree.HTML(configuration.getLocale().getLanguage(), head, body);</span>
 446         HtmlDocument htmlDocument = new HtmlDocument(htmlComment, htmlTree);
 447         htmlDocument.write(DocFile.createFileForOutput(configuration, path));
 448     }
 449 
 450     /**
 451      * Get the window title.
 452      *
 453      * @param title the title string to construct the complete window title
 454      * @return the window title string
 455      */
 456     public String getWindowTitle(String title) {
 457         if (options.windowTitle().length() &gt; 0) {
 458             title += &quot; (&quot; + options.windowTitle() + &quot;)&quot;;
 459         }
 460         return title;
 461     }
 462 
 463     /**
 464      * Get user specified header and the footer.
 465      *
</pre>
<hr />
<pre>
 976             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 977                 .label(label)
 978                 .where(links.getName(getAnchor(emd))));
 979         } else if (utils.isVariableElement(element) || utils.isTypeElement(element)) {
 980             return getLink(new LinkInfoImpl(configuration, context, typeElement)
 981                 .label(label).where(links.getName(element.getSimpleName().toString())));
 982         } else {
 983             return label;
 984         }
 985     }
 986 
 987     public String getAnchor(ExecutableElement executableElement) {
 988         return getAnchor(executableElement, false);
 989     }
 990 
 991     public String getAnchor(ExecutableElement executableElement, boolean isProperty) {
 992         if (isProperty) {
 993             return executableElement.getSimpleName().toString();
 994         }
 995         String member = anchorName(executableElement);
<span class="line-modified"> 996         String erasedSignature = utils.makeSignature(executableElement, null, true, true);</span>
 997         return member + erasedSignature;
 998     }
 999 
1000     public String anchorName(Element member) {
1001         if (member.getKind() == ElementKind.CONSTRUCTOR) {
1002             return &quot;&lt;init&gt;&quot;;
1003         } else {
1004             return utils.getSimpleName(member);
1005         }
1006     }
1007 
1008     public Content seeTagToContent(Element element, DocTree see) {
1009         Kind kind = see.getKind();
1010         if (!(kind == LINK || kind == SEE || kind == LINK_PLAIN)) {
1011             return new ContentBuilder();
1012         }
1013 
1014         CommentHelper ch = utils.getCommentHelper(element);
1015         String tagName = ch.getTagName(see);
1016         String seetext = replaceDocRootDir(utils.normalizeNewlines(ch.getText(see)).toString());
</pre>
<hr />
<pre>
1105                 // inherits it automatically.
1106                 if (this instanceof ClassWriterImpl) {
1107                     containing = ((ClassWriterImpl) this).getTypeElement();
1108                 } else if (!utils.isPublic(containing)) {
1109                     messages.warning(
1110                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_accessible&quot;,
1111                         tagName, utils.getFullyQualifiedName(containing));
1112                 } else {
1113                     messages.warning(
1114                         ch.getDocTreePath(see), &quot;doclet.see.class_or_package_not_found&quot;,
1115                         tagName, seetext);
1116                 }
1117             }
1118             if (configuration.currentTypeElement != containing) {
1119                 refMemName = (utils.isConstructor(refMem))
1120                         ? refMemName
1121                         : utils.getSimpleName(containing) + &quot;.&quot; + refMemName;
1122             }
1123             if (utils.isExecutableElement(refMem)) {
1124                 if (refMemName.indexOf(&#39;(&#39;) &lt; 0) {
<span class="line-modified">1125                     refMemName += utils.makeSignature((ExecutableElement) refMem, null, true);</span>
1126                 }
1127                 if (overriddenMethod != null) {
1128                     // The method to actually link.
1129                     refMem = overriddenMethod;
1130                 }
1131             }
1132 
1133             text = plainOrCode(kind == LINK_PLAIN, new StringContent(refMemName));
1134 
1135             return getDocLink(LinkInfoImpl.Kind.SEE_TAG, containing,
1136                     refMem, (label.isEmpty() ? text: label), false);
1137         }
1138     }
1139 
1140     private Content plainOrCode(boolean plain, Content body) {
1141         return (plain || body.isEmpty()) ? body : HtmlTree.CODE(body);
1142     }
1143 
1144     /**
1145      * Add the inline comment.
</pre>
<hr />
<pre>
1318      * inline tags along the way.  Called wherever text can contain
1319      * an inline tag, such as in comments or in free-form text arguments
1320      * to block tags.
1321      *
1322      * @param holderTag       specific tag where comment resides
1323      * @param element         specific element where comment resides
1324      * @param trees           array of text tags and inline tags (often alternating)
1325      *                        present in the text of interest for this element
1326      * @param isFirstSentence true if text is first sentence
1327      * @param inSummary       if the comment tags are added into the summary section
1328      * @return a Content object
1329      */
1330     public Content commentTagsToContent(DocTree holderTag,
1331                                         Element element,
1332                                         List&lt;? extends DocTree&gt; trees,
1333                                         boolean isFirstSentence,
1334                                         boolean inSummary)
1335     {
1336         final Content result = new ContentBuilder() {
1337             @Override
<span class="line-modified">1338             public ContentBuilder add(CharSequence text) {</span>
<span class="line-modified">1339                 return super.add(utils.normalizeNewlines(text));</span>
1340             }
1341         };
1342         CommentHelper ch = utils.getCommentHelper(element);
1343         // Array of all possible inline tags for this javadoc run
1344         configuration.tagletManager.checkTags(element, trees, true);
1345         commentRemoved = false;
1346 
1347         for (ListIterator&lt;? extends DocTree&gt; iterator = trees.listIterator(); iterator.hasNext();) {
1348             boolean isFirstNode = !iterator.hasPrevious();
1349             DocTree tag = iterator.next();
1350             boolean isLastNode  = !iterator.hasNext();
1351 
1352             if (isFirstSentence) {
1353                 // Ignore block tags
1354                 if (ignoreNonInlineTag(tag))
1355                     continue;
1356 
1357                 // Ignore any trailing whitespace OR whitespace after removed html comment
1358                 if ((isLastNode || commentRemoved)
1359                         &amp;&amp; tag.getKind() == TEXT
</pre>
<hr />
<pre>
1593                     if (output != null) {
1594                         result.add(output);
1595                     }
1596                     return false;
1597                 }
1598 
1599             }.visit(tag, null);
1600             commentRemoved = false;
1601             if (allDone)
1602                 break;
1603         }
1604         return result;
1605     }
1606 
1607     /**
1608      * Return true if relative links should not be redirected.
1609      *
1610      * @return Return true if a relative link should not be redirected.
1611      */
1612     private boolean shouldNotRedirectRelativeLinks() {
<span class="line-modified">1613         return  this instanceof ClassWriter ||</span>

1614                 this instanceof PackageSummaryWriter;
1615     }
1616 
1617     /**
1618      * Suppose a piece of documentation has a relative link.  When you copy
1619      * that documentation to another place such as the index or class-use page,
1620      * that relative link will no longer work.  We should redirect those links
1621      * so that they will work again.
1622      * &lt;p&gt;
1623      * Here is the algorithm used to fix the link:
1624      * &lt;p&gt;
1625      * {@literal &lt;relative link&gt; =&gt; docRoot + &lt;relative path to file&gt; + &lt;relative link&gt; }
1626      * &lt;p&gt;
1627      * For example, suppose DocletEnvironment has this link:
1628      * {@literal &lt;a href=&quot;package-summary.html&quot;&gt;The package Page&lt;/a&gt; }
1629      * &lt;p&gt;
1630      * If this link appeared in the index, we would redirect
1631      * the link like this:
1632      *
1633      * {@literal &lt;a href=&quot;./jdk/javadoc/doclet/package-summary.html&quot;&gt;The package Page&lt;/a&gt;}
</pre>
<hr />
<pre>
2079                 sb.append(&quot;, &quot;);
2080             }
2081             sb.append(e.getKind().toString().toLowerCase(Locale.US).replace(&quot;_&quot;, &quot; &quot;))
2082                     .append(&quot;: &quot;)
2083                     .append(name);
2084         }
2085         return sb.toString();
2086     }
2087 
2088     static String getGenerator(Class&lt;?&gt; clazz) {
2089         return &quot;javadoc/&quot; + clazz.getSimpleName();
2090     }
2091 
2092     /**
2093      * Returns an HtmlTree for the BODY tag.
2094      *
2095      * @param title title for the window
2096      * @return an HtmlTree for the BODY tag
2097      */
2098     public HtmlTree getBody(String title) {
<span class="line-modified">2099         HtmlTree body = new HtmlTree(TagName.BODY).setStyle(getBodyStyle());</span>

2100 
2101         this.winTitle = title;
2102         // Don&#39;t print windowtitle script for overview-frame, allclasses-frame
2103         // and package-frame
2104         body.add(mainBodyScript.asContent());
2105         Content noScript = HtmlTree.NOSCRIPT(HtmlTree.DIV(contents.noScriptMessage));
2106         body.add(noScript);
2107         return body;
2108     }
2109 
<span class="line-modified">2110     public HtmlStyle getBodyStyle() {</span>
<span class="line-modified">2111         String kind = getClass().getSimpleName()</span>
2112                 .replaceAll(&quot;(Writer)?(Impl)?$&quot;, &quot;&quot;)
2113                 .replaceAll(&quot;AnnotationType&quot;, &quot;Class&quot;)
<span class="line-modified">2114                 .replaceAll(&quot;^(Module|Package|Class)$&quot;, &quot;$1Declaration&quot;);</span>
<span class="line-modified">2115         String page = kind.substring(0, 1).toLowerCase(Locale.US) + kind.substring(1) + &quot;Page&quot;;</span>
<span class="line-modified">2116         return HtmlStyle.valueOf(page);</span>
2117     }
2118 
2119     Script getMainBodyScript() {
2120         return mainBodyScript;
2121     }
2122 
2123     /**
2124      * Returns the path of module/package specific stylesheets for the element.
2125      * @param element module/Package element
2126      * @return list of path of module/package specific stylesheets
2127      * @throws DocFileIOException
2128      */
2129     List&lt;DocPath&gt; getLocalStylesheets(Element element) throws DocFileIOException {
2130         List&lt;DocPath&gt; stylesheets = new ArrayList&lt;&gt;();
2131         DocPath basePath = null;
2132         if (element instanceof PackageElement) {
2133             stylesheets.addAll(getModuleStylesheets((PackageElement)element));
2134             basePath = docPaths.forPackage((PackageElement)element);
2135         } else if (element instanceof ModuleElement) {
2136             basePath = DocPaths.forModule((ModuleElement)element);
</pre>
</td>
</tr>
</table>
<center><a href="HtmlDoclet.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="HtmlSerialFieldWriter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
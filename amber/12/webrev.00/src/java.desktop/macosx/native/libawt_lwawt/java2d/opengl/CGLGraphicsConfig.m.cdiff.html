<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/java.desktop/macosx/native/libawt_lwawt/java2d/opengl/CGLGraphicsConfig.m</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CGLGraphicsConfig.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../share/classes/com/sun/imageio/plugins/gif/GIFImageReader.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.desktop/macosx/native/libawt_lwawt/java2d/opengl/CGLGraphicsConfig.m</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.  Oracle designates this
</pre>
<hr />
<pre>
<span class="line-old-header">*** 32,13 ***</span>
  #import &lt;stdlib.h&gt;
  #import &lt;string.h&gt;
  #import &lt;ApplicationServices/ApplicationServices.h&gt;
  #import &lt;JavaNativeFoundation/JavaNativeFoundation.h&gt;
  
<span class="line-removed">- #pragma mark -</span>
<span class="line-removed">- #pragma mark &quot;--- Mac OS X specific methods for GL pipeline ---&quot;</span>
<span class="line-removed">- </span>
  /**
   * Disposes all memory and resources associated with the given
   * CGLGraphicsConfigInfo (including its native OGLContext data).
   */
  void
<span class="line-new-header">--- 32,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 75,13 ***</span>
      }
  
      free(cglinfo);
  }
  
<span class="line-removed">- #pragma mark -</span>
<span class="line-removed">- #pragma mark &quot;--- CGLGraphicsConfig methods ---&quot;</span>
<span class="line-removed">- </span>
  /**
   * This is a globally shared context used when creating textures.  When any
   * new contexts are created, they specify this context as the &quot;share list&quot;
   * context, which means any texture objects created when this shared context
   * is current will be available to any other context in any other thread.
<span class="line-new-header">--- 72,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 110,237 ***</span>
          return JNI_FALSE;
      }
      return JNI_TRUE;
  }
  
<span class="line-removed">- </span>
  /**
<span class="line-modified">!  * Determines whether the CGL pipeline can be used for a given GraphicsConfig</span>
<span class="line-modified">!  * provided its screen number and visual ID.  If the minimum requirements are</span>
<span class="line-modified">!  * met, the native CGLGraphicsConfigInfo structure is initialized for this</span>
<span class="line-modified">!  * GraphicsConfig with the necessary information (pixel format, etc.)</span>
<span class="line-removed">-  * and a pointer to this structure is returned as a jlong.  If</span>
   * initialization fails at any point, zero is returned, indicating that CGL
<span class="line-modified">!  * cannot be used for this GraphicsConfig (we should fallback on an existing</span>
<span class="line-modified">!  * 2D pipeline).</span>
   */
  JNIEXPORT jlong JNICALL
  Java_sun_java2d_opengl_CGLGraphicsConfig_getCGLConfigInfo
<span class="line-modified">!     (JNIEnv *env, jclass cglgc,</span>
<span class="line-removed">-      jint displayID, jint pixfmt, jint swapInterval)</span>
  {
<span class="line-modified">!   jlong ret = 0L;</span>
<span class="line-modified">!   JNF_COCOA_ENTER(env);</span>
<span class="line-modified">!   NSMutableArray * retArray = [NSMutableArray arrayWithCapacity:3];</span>
<span class="line-modified">!   [retArray addObject: [NSNumber numberWithInt: (int)displayID]];</span>
<span class="line-modified">!   [retArray addObject: [NSNumber numberWithInt: (int)pixfmt]];</span>
<span class="line-modified">!   [retArray addObject: [NSNumber numberWithInt: (int)swapInterval]];</span>
<span class="line-modified">!   if ([NSThread isMainThread]) {</span>
<span class="line-modified">!       [GraphicsConfigUtil _getCGLConfigInfo: retArray];</span>
<span class="line-modified">!   } else {</span>
<span class="line-modified">!       [GraphicsConfigUtil performSelectorOnMainThread: @selector(_getCGLConfigInfo:) withObject: retArray waitUntilDone: YES];</span>
<span class="line-modified">!   }</span>
<span class="line-modified">!   NSNumber * num = (NSNumber *)[retArray objectAtIndex: 0];</span>
<span class="line-modified">!   ret = (jlong)[num longValue];</span>
<span class="line-modified">!   JNF_COCOA_EXIT(env);</span>
<span class="line-modified">!   return ret;</span>
<span class="line-modified">! }</span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! </span>
<span class="line-modified">! @implementation GraphicsConfigUtil</span>
<span class="line-modified">! + (void) _getCGLConfigInfo: (NSMutableArray *)argValue {</span>
<span class="line-modified">!     AWT_ASSERT_APPKIT_THREAD;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     jint displayID = (jint)[(NSNumber *)[argValue objectAtIndex: 0] intValue];</span>
<span class="line-modified">!     jint swapInterval = (jint)[(NSNumber *)[argValue objectAtIndex: 2] intValue];</span>
<span class="line-modified">!     JNIEnv *env = [ThreadUtilities getJNIEnvUncached];</span>
<span class="line-modified">!     [argValue removeAllObjects];</span>
<span class="line-modified">! </span>
<span class="line-modified">!     J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo&quot;);</span>
<span class="line-modified">! </span>
<span class="line-removed">-     NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span>
  
<span class="line-modified">!     if (sharedContext == NULL) {</span>
  
<span class="line-modified">!         NSOpenGLPixelFormatAttribute attrs[] = {</span>
<span class="line-modified">!             NSOpenGLPFAAllowOfflineRenderers,</span>
<span class="line-modified">!             NSOpenGLPFAClosestPolicy,</span>
<span class="line-modified">!             NSOpenGLPFAWindow,</span>
<span class="line-modified">!             NSOpenGLPFAPixelBuffer,</span>
<span class="line-modified">!             NSOpenGLPFADoubleBuffer,</span>
<span class="line-modified">!             NSOpenGLPFAColorSize, 32,</span>
<span class="line-modified">!             NSOpenGLPFAAlphaSize, 8,</span>
<span class="line-modified">!             NSOpenGLPFADepthSize, 16,</span>
<span class="line-modified">!             0</span>
<span class="line-modified">!         };</span>
  
<span class="line-modified">!         sharedPixelFormat =</span>
<span class="line-modified">!             [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];</span>
<span class="line-modified">!         if (sharedPixelFormat == nil) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, </span>
<span class="line-modified">!                           &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLPixelFormat is NULL&quot;);</span>
<span class="line-modified">!                 </span>
<span class="line-removed">-            [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-removed">-            return;</span>
          }
  
<span class="line-modified">!         sharedContext =</span>
              [[NSOpenGLContext alloc]
<span class="line-modified">!                 initWithFormat:sharedPixelFormat</span>
<span class="line-modified">!                 shareContext: NULL];</span>
<span class="line-modified">!         if (sharedContext == nil) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLContext is NULL&quot;);</span>
<span class="line-removed">-             [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
              return;
          }
<span class="line-removed">-     }</span>
  
  #if USE_NSVIEW_FOR_SCRATCH
<span class="line-modified">!     NSRect contentRect = NSMakeRect(0, 0, 64, 64);</span>
<span class="line-removed">-     NSWindow *window =</span>
<span class="line-removed">-         [[NSWindow alloc]</span>
<span class="line-removed">-             initWithContentRect: contentRect</span>
<span class="line-removed">-             styleMask: NSBorderlessWindowMask</span>
<span class="line-removed">-             backing: NSBackingStoreBuffered</span>
<span class="line-removed">-             defer: false];</span>
<span class="line-removed">-     if (window == nil) {</span>
<span class="line-removed">-         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: NSWindow is NULL&quot;);</span>
<span class="line-removed">-         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     NSView *scratchSurface =</span>
<span class="line-removed">-         [[NSView alloc]</span>
<span class="line-removed">-             initWithFrame: contentRect];</span>
<span class="line-removed">-     if (scratchSurface == nil) {</span>
<span class="line-removed">-         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: NSView is NULL&quot;);</span>
<span class="line-removed">-         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     [window setContentView: scratchSurface];</span>
  #else
<span class="line-modified">!     NSOpenGLPixelBuffer *scratchSurface =</span>
<span class="line-modified">!         [[NSOpenGLPixelBuffer alloc]</span>
<span class="line-modified">!             initWithTextureTarget:GL_TEXTURE_2D</span>
<span class="line-modified">!             textureInternalFormat:GL_RGB</span>
<span class="line-modified">!             textureMaxMipMapLevel:0</span>
<span class="line-removed">-             pixelsWide:64</span>
<span class="line-removed">-             pixelsHigh:64];</span>
  #endif
  
<span class="line-modified">!     NSOpenGLContext *context =</span>
<span class="line-modified">!         [[NSOpenGLContext alloc]</span>
<span class="line-modified">!             initWithFormat: sharedPixelFormat</span>
<span class="line-modified">!             shareContext: sharedContext];</span>
<span class="line-modified">!     if (context == nil) {</span>
<span class="line-modified">!         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: NSOpenGLContext is NULL&quot;);</span>
<span class="line-modified">!         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-modified">!         return;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     GLint contextVirtualScreen = [context currentVirtualScreen];</span>
<span class="line-modified">! #if USE_NSVIEW_FOR_SCRATCH</span>
<span class="line-removed">-     [context setView: scratchSurface];</span>
<span class="line-removed">- #else</span>
<span class="line-removed">-     [context</span>
<span class="line-removed">-         setPixelBuffer: scratchSurface</span>
<span class="line-removed">-         cubeMapFace:0</span>
<span class="line-removed">-         mipMapLevel:0</span>
<span class="line-removed">-         currentVirtualScreen: contextVirtualScreen];</span>
<span class="line-removed">- #endif</span>
<span class="line-removed">-     [context makeCurrentContext];</span>
  
<span class="line-modified">!     // get version and extension strings</span>
<span class="line-modified">!     const unsigned char *versionstr = j2d_glGetString(GL_VERSION);</span>
<span class="line-modified">!     if (!OGLContext_IsVersionSupported(versionstr)) {</span>
<span class="line-modified">!         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: OpenGL 1.2 is required&quot;);</span>
<span class="line-modified">!         [NSOpenGLContext clearCurrentContext];</span>
<span class="line-modified">!         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-removed">-     J2dRlsTraceLn1(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo: OpenGL version=%s&quot;, versionstr);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     jint caps = CAPS_EMPTY;</span>
<span class="line-removed">-     OGLContext_GetExtensionInfo(env, &amp;caps);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     GLint value = 0;</span>
<span class="line-removed">-     [sharedPixelFormat</span>
<span class="line-removed">-         getValues: &amp;value</span>
<span class="line-removed">-         forAttribute: NSOpenGLPFADoubleBuffer</span>
<span class="line-removed">-         forVirtualScreen: contextVirtualScreen];</span>
<span class="line-removed">-     if (value != 0) {</span>
<span class="line-removed">-         caps |= CAPS_DOUBLEBUFFERED;</span>
<span class="line-removed">-     }</span>
  
<span class="line-modified">!     J2dRlsTraceLn1(J2D_TRACE_INFO,</span>
<span class="line-modified">!                    &quot;CGLGraphicsConfig_getCGLConfigInfo: db=%d&quot;,</span>
<span class="line-modified">!                    (caps &amp; CAPS_DOUBLEBUFFERED) != 0);</span>
  
<span class="line-modified">!     // remove before shipping (?)</span>
  #if 1
<span class="line-removed">-     [sharedPixelFormat</span>
<span class="line-removed">-         getValues: &amp;value</span>
<span class="line-removed">-         forAttribute: NSOpenGLPFAAccelerated</span>
<span class="line-removed">-         forVirtualScreen: contextVirtualScreen];</span>
<span class="line-removed">-     if (value == 0) {</span>
          [sharedPixelFormat
              getValues: &amp;value
<span class="line-modified">!             forAttribute: NSOpenGLPFARendererID</span>
              forVirtualScreen: contextVirtualScreen];
<span class="line-modified">!         fprintf(stderr, &quot;WARNING: GL pipe is running in software mode (Renderer ID=0x%x)\n&quot;, (int)value);</span>
<span class="line-modified">!     }</span>
  #endif
  
<span class="line-modified">!     // 0: the buffers are swapped with no regard to the vertical refresh rate</span>
<span class="line-modified">!     // 1: the buffers are swapped only during the vertical retrace</span>
<span class="line-modified">!     GLint params = swapInterval;</span>
<span class="line-modified">!     [context setValues: &amp;params forParameter: NSOpenGLCPSwapInterval];</span>
<span class="line-modified">! </span>
<span class="line-modified">!     CGLCtxInfo *ctxinfo = (CGLCtxInfo *)malloc(sizeof(CGLCtxInfo));</span>
<span class="line-modified">!     if (ctxinfo == NULL) {</span>
<span class="line-modified">!         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGC_InitOGLContext: could not allocate memory for ctxinfo&quot;);</span>
<span class="line-modified">!         [NSOpenGLContext clearCurrentContext];</span>
<span class="line-modified">!         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-modified">!     memset(ctxinfo, 0, sizeof(CGLCtxInfo));</span>
<span class="line-modified">!     ctxinfo-&gt;context = context;</span>
<span class="line-modified">!     ctxinfo-&gt;scratchSurface = scratchSurface;</span>
<span class="line-modified">! </span>
<span class="line-modified">!     OGLContext *oglc = (OGLContext *)malloc(sizeof(OGLContext));</span>
<span class="line-modified">!     if (oglc == 0L) {</span>
<span class="line-modified">!         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGC_InitOGLContext: could not allocate memory for oglc&quot;);</span>
<span class="line-modified">!         [NSOpenGLContext clearCurrentContext];</span>
<span class="line-modified">!         free(ctxinfo);</span>
<span class="line-modified">!         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-removed">-         return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     memset(oglc, 0, sizeof(OGLContext));</span>
<span class="line-removed">-     oglc-&gt;ctxInfo = ctxinfo;</span>
<span class="line-removed">-     oglc-&gt;caps = caps;</span>
  
<span class="line-removed">-     // create the CGLGraphicsConfigInfo record for this config</span>
<span class="line-removed">-     CGLGraphicsConfigInfo *cglinfo = (CGLGraphicsConfigInfo *)malloc(sizeof(CGLGraphicsConfigInfo));</span>
<span class="line-removed">-     if (cglinfo == NULL) {</span>
<span class="line-removed">-         J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: could not allocate memory for cglinfo&quot;);</span>
          [NSOpenGLContext clearCurrentContext];
<span class="line-modified">!         free(oglc);</span>
<span class="line-modified">!         free(ctxinfo);</span>
<span class="line-modified">!         [argValue addObject: [NSNumber numberWithLong: 0L]];</span>
<span class="line-modified">!         return;</span>
<span class="line-modified">!     }</span>
<span class="line-removed">-     memset(cglinfo, 0, sizeof(CGLGraphicsConfigInfo));</span>
<span class="line-removed">-     cglinfo-&gt;screen = displayID;</span>
<span class="line-removed">-     cglinfo-&gt;pixfmt = sharedPixelFormat;</span>
<span class="line-removed">-     cglinfo-&gt;context = oglc;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     [NSOpenGLContext clearCurrentContext];</span>
<span class="line-removed">-     [argValue addObject: [NSNumber numberWithLong:ptr_to_jlong(cglinfo)]];</span>
<span class="line-removed">-     [pool drain];</span>
  }
<span class="line-removed">- @end //GraphicsConfigUtil</span>
  
  JNIEXPORT jint JNICALL
  Java_sun_java2d_opengl_CGLGraphicsConfig_getOGLCapabilities
      (JNIEnv *env, jclass cglgc, jlong configInfo)
  {
<span class="line-new-header">--- 104,195 ---</span>
          return JNI_FALSE;
      }
      return JNI_TRUE;
  }
  
  /**
<span class="line-modified">!  * Determines whether the CGL pipeline can be used for a given GraphicsConfig.</span>
<span class="line-modified">!  * If the minimum requirements are met, the native CGLGraphicsConfigInfo</span>
<span class="line-modified">!  * structure is initialized for this GraphicsConfig with the necessary</span>
<span class="line-modified">!  * information and a pointer to this structure is returned as a jlong. If</span>
   * initialization fails at any point, zero is returned, indicating that CGL
<span class="line-modified">!  * cannot be used for this GraphicsConfig (we should fallback on an existing 2D</span>
<span class="line-modified">!  * pipeline).</span>
   */
  JNIEXPORT jlong JNICALL
  Java_sun_java2d_opengl_CGLGraphicsConfig_getCGLConfigInfo
<span class="line-modified">!     (JNIEnv *env, jclass cglgc)</span>
  {
<span class="line-modified">!     __block jlong ret = 0L;</span>
<span class="line-modified">!     JNF_COCOA_ENTER(env);</span>
<span class="line-modified">!     [ThreadUtilities performOnMainThreadWaiting:YES block:^(){</span>
<span class="line-modified">!         JNIEnv *env = [ThreadUtilities getJNIEnvUncached];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         J2dRlsTraceLn(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo&quot;);</span>
<span class="line-modified">! </span>
<span class="line-modified">!         NSAutoreleasePool* pool = [[NSAutoreleasePool alloc] init];</span>
<span class="line-modified">! </span>
<span class="line-modified">!         if (sharedContext == NULL) {</span>
<span class="line-modified">! </span>
<span class="line-modified">!             NSOpenGLPixelFormatAttribute attrs[] = {</span>
<span class="line-modified">!                 NSOpenGLPFAAllowOfflineRenderers,</span>
<span class="line-modified">!                 NSOpenGLPFAClosestPolicy,</span>
<span class="line-modified">!                 NSOpenGLPFAWindow,</span>
<span class="line-modified">!                 NSOpenGLPFAPixelBuffer,</span>
<span class="line-modified">!                 NSOpenGLPFADoubleBuffer,</span>
<span class="line-modified">!                 NSOpenGLPFAColorSize, 32,</span>
<span class="line-modified">!                 NSOpenGLPFAAlphaSize, 8,</span>
<span class="line-modified">!                 NSOpenGLPFADepthSize, 16,</span>
<span class="line-modified">!                 0</span>
<span class="line-modified">!             };</span>
<span class="line-modified">! </span>
<span class="line-modified">!             sharedPixelFormat =</span>
<span class="line-modified">!                 [[NSOpenGLPixelFormat alloc] initWithAttributes:attrs];</span>
<span class="line-modified">!             if (sharedPixelFormat == nil) {</span>
<span class="line-modified">!                 J2dRlsTraceLn(J2D_TRACE_ERROR,</span>
<span class="line-modified">!                               &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLPixelFormat is NULL&quot;);</span>
<span class="line-modified">!                return;</span>
<span class="line-modified">!             }</span>
  
<span class="line-modified">!             sharedContext =</span>
<span class="line-added">+                 [[NSOpenGLContext alloc]</span>
<span class="line-added">+                     initWithFormat:sharedPixelFormat</span>
<span class="line-added">+                     shareContext: NULL];</span>
<span class="line-added">+             if (sharedContext == nil) {</span>
<span class="line-added">+                 J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: shared NSOpenGLContext is NULL&quot;);</span>
<span class="line-added">+                 return;</span>
<span class="line-added">+             }</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">! #if USE_NSVIEW_FOR_SCRATCH</span>
<span class="line-modified">!         NSRect contentRect = NSMakeRect(0, 0, 64, 64);</span>
<span class="line-modified">!         NSWindow *window =</span>
<span class="line-modified">!             [[NSWindow alloc]</span>
<span class="line-modified">!                 initWithContentRect: contentRect</span>
<span class="line-modified">!                 styleMask: NSBorderlessWindowMask</span>
<span class="line-modified">!                 backing: NSBackingStoreBuffered</span>
<span class="line-modified">!                 defer: false];</span>
<span class="line-modified">!         if (window == nil) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: NSWindow is NULL&quot;);</span>
<span class="line-modified">!             return;</span>
<span class="line-added">+         }</span>
  
<span class="line-modified">!         NSView *scratchSurface =</span>
<span class="line-modified">!             [[NSView alloc]</span>
<span class="line-modified">!                 initWithFrame: contentRect];</span>
<span class="line-modified">!         if (scratchSurface == nil) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: NSView is NULL&quot;);</span>
<span class="line-modified">!             return;</span>
          }
<span class="line-added">+         [window setContentView: scratchSurface];</span>
<span class="line-added">+ #else</span>
<span class="line-added">+         NSOpenGLPixelBuffer *scratchSurface =</span>
<span class="line-added">+             [[NSOpenGLPixelBuffer alloc]</span>
<span class="line-added">+                 initWithTextureTarget:GL_TEXTURE_2D</span>
<span class="line-added">+                 textureInternalFormat:GL_RGB</span>
<span class="line-added">+                 textureMaxMipMapLevel:0</span>
<span class="line-added">+                 pixelsWide:64</span>
<span class="line-added">+                 pixelsHigh:64];</span>
<span class="line-added">+ #endif</span>
  
<span class="line-modified">!         NSOpenGLContext *context =</span>
              [[NSOpenGLContext alloc]
<span class="line-modified">!                 initWithFormat: sharedPixelFormat</span>
<span class="line-modified">!                 shareContext: sharedContext];</span>
<span class="line-modified">!         if (context == nil) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: NSOpenGLContext is NULL&quot;);</span>
              return;
          }
  
<span class="line-added">+         GLint contextVirtualScreen = [context currentVirtualScreen];</span>
  #if USE_NSVIEW_FOR_SCRATCH
<span class="line-modified">!         [context setView: scratchSurface];</span>
  #else
<span class="line-modified">!         [context</span>
<span class="line-modified">!             setPixelBuffer: scratchSurface</span>
<span class="line-modified">!             cubeMapFace:0</span>
<span class="line-modified">!             mipMapLevel:0</span>
<span class="line-modified">!             currentVirtualScreen: contextVirtualScreen];</span>
  #endif
<span class="line-added">+         [context makeCurrentContext];</span>
  
<span class="line-modified">!         // get version and extension strings</span>
<span class="line-modified">!         const unsigned char *versionstr = j2d_glGetString(GL_VERSION);</span>
<span class="line-modified">!         if (!OGLContext_IsVersionSupported(versionstr)) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: OpenGL 1.2 is required&quot;);</span>
<span class="line-modified">!             [NSOpenGLContext clearCurrentContext];</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         J2dRlsTraceLn1(J2D_TRACE_INFO, &quot;CGLGraphicsConfig_getCGLConfigInfo: OpenGL version=%s&quot;, versionstr);</span>
  
<span class="line-modified">!         jint caps = CAPS_EMPTY;</span>
<span class="line-modified">!         OGLContext_GetExtensionInfo(env, &amp;caps);</span>
  
<span class="line-modified">!         GLint value = 0;</span>
<span class="line-modified">!         [sharedPixelFormat</span>
<span class="line-modified">!             getValues: &amp;value</span>
<span class="line-modified">!             forAttribute: NSOpenGLPFADoubleBuffer</span>
<span class="line-modified">!             forVirtualScreen: contextVirtualScreen];</span>
<span class="line-modified">!         if (value != 0) {</span>
<span class="line-modified">!             caps |= CAPS_DOUBLEBUFFERED;</span>
<span class="line-modified">!         }</span>
  
<span class="line-modified">!         J2dRlsTraceLn1(J2D_TRACE_INFO,</span>
<span class="line-modified">!                        &quot;CGLGraphicsConfig_getCGLConfigInfo: db=%d&quot;,</span>
<span class="line-modified">!                        (caps &amp; CAPS_DOUBLEBUFFERED) != 0);</span>
  
<span class="line-modified">!         // remove before shipping (?)</span>
  #if 1
          [sharedPixelFormat
              getValues: &amp;value
<span class="line-modified">!             forAttribute: NSOpenGLPFAAccelerated</span>
              forVirtualScreen: contextVirtualScreen];
<span class="line-modified">!         if (value == 0) {</span>
<span class="line-modified">!             [sharedPixelFormat</span>
<span class="line-added">+                 getValues: &amp;value</span>
<span class="line-added">+                 forAttribute: NSOpenGLPFARendererID</span>
<span class="line-added">+                 forVirtualScreen: contextVirtualScreen];</span>
<span class="line-added">+             fprintf(stderr, &quot;WARNING: GL pipe is running in software mode (Renderer ID=0x%x)\n&quot;, (int)value);</span>
<span class="line-added">+         }</span>
  #endif
<span class="line-added">+         CGLCtxInfo *ctxinfo = (CGLCtxInfo *)malloc(sizeof(CGLCtxInfo));</span>
<span class="line-added">+         if (ctxinfo == NULL) {</span>
<span class="line-added">+             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGC_InitOGLContext: could not allocate memory for ctxinfo&quot;);</span>
<span class="line-added">+             [NSOpenGLContext clearCurrentContext];</span>
<span class="line-added">+             return;</span>
<span class="line-added">+         }</span>
<span class="line-added">+         memset(ctxinfo, 0, sizeof(CGLCtxInfo));</span>
<span class="line-added">+         ctxinfo-&gt;context = context;</span>
<span class="line-added">+         ctxinfo-&gt;scratchSurface = scratchSurface;</span>
  
<span class="line-modified">!         OGLContext *oglc = (OGLContext *)malloc(sizeof(OGLContext));</span>
<span class="line-modified">!         if (oglc == 0L) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGC_InitOGLContext: could not allocate memory for oglc&quot;);</span>
<span class="line-modified">!             [NSOpenGLContext clearCurrentContext];</span>
<span class="line-modified">!             free(ctxinfo);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         memset(oglc, 0, sizeof(OGLContext));</span>
<span class="line-modified">!         oglc-&gt;ctxInfo = ctxinfo;</span>
<span class="line-modified">!         oglc-&gt;caps = caps;</span>
<span class="line-modified">! </span>
<span class="line-modified">!         // create the CGLGraphicsConfigInfo record for this config</span>
<span class="line-modified">!         CGLGraphicsConfigInfo *cglinfo = (CGLGraphicsConfigInfo *)malloc(sizeof(CGLGraphicsConfigInfo));</span>
<span class="line-modified">!         if (cglinfo == NULL) {</span>
<span class="line-modified">!             J2dRlsTraceLn(J2D_TRACE_ERROR, &quot;CGLGraphicsConfig_getCGLConfigInfo: could not allocate memory for cglinfo&quot;);</span>
<span class="line-modified">!             [NSOpenGLContext clearCurrentContext];</span>
<span class="line-modified">!             free(oglc);</span>
<span class="line-modified">!             free(ctxinfo);</span>
<span class="line-modified">!             return;</span>
<span class="line-modified">!         }</span>
<span class="line-modified">!         memset(cglinfo, 0, sizeof(CGLGraphicsConfigInfo));</span>
<span class="line-modified">!         cglinfo-&gt;context = oglc;</span>
  
          [NSOpenGLContext clearCurrentContext];
<span class="line-modified">!         ret = ptr_to_jlong(cglinfo);</span>
<span class="line-modified">!         [pool drain];</span>
<span class="line-modified">!     }];</span>
<span class="line-modified">!     JNF_COCOA_EXIT(env);</span>
<span class="line-modified">!     return ret;</span>
  }
  
  JNIEXPORT jint JNICALL
  Java_sun_java2d_opengl_CGLGraphicsConfig_getOGLCapabilities
      (JNIEnv *env, jclass cglgc, jlong configInfo)
  {
</pre>
<center><a href="CGLGraphicsConfig.h.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../share/classes/com/sun/imageio/plugins/gif/GIFImageReader.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.util.Iterator;
  29 
  30 import com.sun.source.tree.CaseTree;
  31 import com.sun.source.tree.CaseTree.CaseKind;
  32 import com.sun.source.tree.ModuleTree.ModuleKind;
  33 import com.sun.tools.javac.code.*;
  34 import com.sun.tools.javac.code.Attribute.UnresolvedClass;
  35 import com.sun.tools.javac.code.Symbol.*;
  36 import com.sun.tools.javac.code.Type.*;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  39 
  40 import com.sun.tools.javac.tree.JCTree.*;
  41 
  42 import static com.sun.tools.javac.code.Flags.*;
  43 import static com.sun.tools.javac.code.Kinds.Kind.*;
  44 import static com.sun.tools.javac.code.TypeTag.*;
<a name="1" id="anc1"></a>




  45 
  46 /** Factory class for trees.
  47  *
  48  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  49  *  If you write code that depends on this, you do so at your own risk.
  50  *  This code and its internal interfaces are subject to change or
  51  *  deletion without notice.&lt;/b&gt;
  52  */
  53 public class TreeMaker implements JCTree.Factory {
  54 
  55     /** The context key for the tree factory. */
  56     protected static final Context.Key&lt;TreeMaker&gt; treeMakerKey = new Context.Key&lt;&gt;();
  57 
  58     /** Get the TreeMaker instance. */
  59     public static TreeMaker instance(Context context) {
  60         TreeMaker instance = context.get(treeMakerKey);
  61         if (instance == null)
  62             instance = new TreeMaker(context);
  63         return instance;
  64     }
  65 
  66     /** The position at which subsequent trees will be created.
  67      */
  68     public int pos = Position.NOPOS;
  69 
  70     /** The toplevel tree to which created trees belong.
  71      */
  72     public JCCompilationUnit toplevel;
  73 
  74     /** The current name table. */
  75     Names names;
  76 
  77     Types types;
  78 
  79     /** The current symbol table. */
  80     Symtab syms;
  81 
  82     /** Create a tree maker with null toplevel and NOPOS as initial position.
  83      */
  84     protected TreeMaker(Context context) {
  85         context.put(treeMakerKey, this);
  86         this.pos = Position.NOPOS;
  87         this.toplevel = null;
  88         this.names = Names.instance(context);
  89         this.syms = Symtab.instance(context);
  90         this.types = Types.instance(context);
  91     }
  92 
  93     /** Create a tree maker with a given toplevel and FIRSTPOS as initial position.
  94      */
  95     protected TreeMaker(JCCompilationUnit toplevel, Names names, Types types, Symtab syms) {
  96         this.pos = Position.FIRSTPOS;
  97         this.toplevel = toplevel;
  98         this.names = names;
  99         this.types = types;
 100         this.syms = syms;
 101     }
 102 
 103     /** Create a new tree maker for a given toplevel.
 104      */
 105     public TreeMaker forToplevel(JCCompilationUnit toplevel) {
 106         return new TreeMaker(toplevel, names, types, syms);
 107     }
 108 
 109     /** Reassign current position.
 110      */
 111     public TreeMaker at(int pos) {
 112         this.pos = pos;
 113         return this;
 114     }
 115 
 116     /** Reassign current position.
 117      */
 118     public TreeMaker at(DiagnosticPosition pos) {
 119         this.pos = (pos == null ? Position.NOPOS : pos.getStartPosition());
 120         return this;
 121     }
 122 
 123     /**
 124      * Create given tree node at current position.
 125      * @param defs a list of PackageDef, ClassDef, Import, and Skip
 126      */
 127     public JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs) {
 128         for (JCTree node : defs)
 129             Assert.check(node instanceof JCClassDecl
 130                 || node instanceof JCPackageDecl
 131                 || node instanceof JCImport
 132                 || node instanceof JCModuleDecl
 133                 || node instanceof JCSkip
 134                 || node instanceof JCErroneous
 135                 || (node instanceof JCExpressionStatement
 136                     &amp;&amp; ((JCExpressionStatement)node).expr instanceof JCErroneous),
 137                     () -&gt; node.getClass().getSimpleName());
 138         JCCompilationUnit tree = new JCCompilationUnit(defs);
 139         tree.pos = pos;
 140         return tree;
 141     }
 142 
 143     public JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
 144                                      JCExpression pid) {
 145         Assert.checkNonNull(annotations);
 146         Assert.checkNonNull(pid);
 147         JCPackageDecl tree = new JCPackageDecl(annotations, pid);
 148         tree.pos = pos;
 149         return tree;
 150     }
 151 
 152     public JCImport Import(JCTree qualid, boolean importStatic) {
 153         JCImport tree = new JCImport(qualid, importStatic);
 154         tree.pos = pos;
 155         return tree;
 156     }
 157 
 158     public JCClassDecl ClassDef(JCModifiers mods,
 159                                 Name name,
 160                                 List&lt;JCTypeParameter&gt; typarams,
 161                                 JCExpression extending,
 162                                 List&lt;JCExpression&gt; implementing,
 163                                 List&lt;JCTree&gt; defs)
 164     {
 165         JCClassDecl tree = new JCClassDecl(mods,
 166                                      name,
 167                                      typarams,
 168                                      extending,
 169                                      implementing,
 170                                      defs,
 171                                      null);
 172         tree.pos = pos;
 173         return tree;
 174     }
 175 
 176     public JCMethodDecl MethodDef(JCModifiers mods,
 177                                Name name,
 178                                JCExpression restype,
 179                                List&lt;JCTypeParameter&gt; typarams,
 180                                List&lt;JCVariableDecl&gt; params,
 181                                List&lt;JCExpression&gt; thrown,
 182                                JCBlock body,
 183                                JCExpression defaultValue) {
 184         return MethodDef(
 185                 mods, name, restype, typarams, null, params,
 186                 thrown, body, defaultValue);
 187     }
 188 
 189     public JCMethodDecl MethodDef(JCModifiers mods,
 190                                Name name,
 191                                JCExpression restype,
 192                                List&lt;JCTypeParameter&gt; typarams,
 193                                JCVariableDecl recvparam,
 194                                List&lt;JCVariableDecl&gt; params,
 195                                List&lt;JCExpression&gt; thrown,
 196                                JCBlock body,
 197                                JCExpression defaultValue)
 198     {
 199         JCMethodDecl tree = new JCMethodDecl(mods,
 200                                        name,
 201                                        restype,
 202                                        typarams,
 203                                        recvparam,
 204                                        params,
 205                                        thrown,
 206                                        body,
 207                                        defaultValue,
 208                                        null);
 209         tree.pos = pos;
 210         return tree;
 211     }
 212 
 213     public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {
 214         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null);
 215         tree.pos = pos;
 216         return tree;
 217     }
 218 
 219     public JCVariableDecl ReceiverVarDef(JCModifiers mods, JCExpression name, JCExpression vartype) {
 220         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype);
 221         tree.pos = pos;
 222         return tree;
 223     }
 224 
 225     public JCSkip Skip() {
 226         JCSkip tree = new JCSkip();
 227         tree.pos = pos;
 228         return tree;
 229     }
 230 
 231     public JCBlock Block(long flags, List&lt;JCStatement&gt; stats) {
 232         JCBlock tree = new JCBlock(flags, stats);
 233         tree.pos = pos;
 234         return tree;
 235     }
 236 
 237     public JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond) {
 238         JCDoWhileLoop tree = new JCDoWhileLoop(body, cond);
 239         tree.pos = pos;
 240         return tree;
 241     }
 242 
 243     public JCWhileLoop WhileLoop(JCExpression cond, JCStatement body) {
 244         JCWhileLoop tree = new JCWhileLoop(cond, body);
 245         tree.pos = pos;
 246         return tree;
 247     }
 248 
 249     public JCForLoop ForLoop(List&lt;JCStatement&gt; init,
 250                            JCExpression cond,
 251                            List&lt;JCExpressionStatement&gt; step,
 252                            JCStatement body)
 253     {
 254         JCForLoop tree = new JCForLoop(init, cond, step, body);
 255         tree.pos = pos;
 256         return tree;
 257     }
 258 
 259     public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
 260         JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);
 261         tree.pos = pos;
 262         return tree;
 263     }
 264 
 265     public JCLabeledStatement Labelled(Name label, JCStatement body) {
 266         JCLabeledStatement tree = new JCLabeledStatement(label, body);
 267         tree.pos = pos;
 268         return tree;
 269     }
 270 
 271     public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases) {
 272         JCSwitch tree = new JCSwitch(selector, cases);
 273         tree.pos = pos;
 274         return tree;
 275     }
 276 
 277     public JCCase Case(CaseKind caseKind, List&lt;JCPattern&gt; pats,
 278                        List&lt;JCStatement&gt; stats, JCTree body) {
 279         JCCase tree = new JCCase(caseKind, pats, stats, body);
 280         tree.pos = pos;
 281         return tree;
 282     }
 283 
 284     public JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
 285         JCSwitchExpression tree = new JCSwitchExpression(selector, cases);
 286         tree.pos = pos;
 287         return tree;
 288     }
 289 
 290     public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
 291         JCSynchronized tree = new JCSynchronized(lock, body);
 292         tree.pos = pos;
 293         return tree;
 294     }
 295 
 296     public JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer) {
 297         return Try(List.nil(), body, catchers, finalizer);
 298     }
 299 
 300     public JCTry Try(List&lt;JCTree&gt; resources,
 301                      JCBlock body,
 302                      List&lt;JCCatch&gt; catchers,
 303                      JCBlock finalizer) {
 304         JCTry tree = new JCTry(resources, body, catchers, finalizer);
 305         tree.pos = pos;
 306         return tree;
 307     }
 308 
 309     public JCCatch Catch(JCVariableDecl param, JCBlock body) {
 310         JCCatch tree = new JCCatch(param, body);
 311         tree.pos = pos;
 312         return tree;
 313     }
 314 
 315     public JCConditional Conditional(JCExpression cond,
 316                                    JCExpression thenpart,
 317                                    JCExpression elsepart)
 318     {
 319         JCConditional tree = new JCConditional(cond, thenpart, elsepart);
 320         tree.pos = pos;
 321         return tree;
 322     }
 323 
 324     public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
 325         JCIf tree = new JCIf(cond, thenpart, elsepart);
 326         tree.pos = pos;
 327         return tree;
 328     }
 329 
 330     public JCExpressionStatement Exec(JCExpression expr) {
 331         JCExpressionStatement tree = new JCExpressionStatement(expr);
 332         tree.pos = pos;
 333         return tree;
 334     }
 335 
 336     public JCBreak Break(Name label) {
 337         JCBreak tree = new JCBreak(label, null);
 338         tree.pos = pos;
 339         return tree;
 340     }
 341 
 342     public JCYield Yield(JCExpression value) {
 343         JCYield tree = new JCYield(value, null);
 344         tree.pos = pos;
 345         return tree;
 346     }
 347 
 348     public JCContinue Continue(Name label) {
 349         JCContinue tree = new JCContinue(label, null);
 350         tree.pos = pos;
 351         return tree;
 352     }
 353 
 354     public JCReturn Return(JCExpression expr) {
 355         JCReturn tree = new JCReturn(expr);
 356         tree.pos = pos;
 357         return tree;
 358     }
 359 
 360     public JCThrow Throw(JCExpression expr) {
 361         JCThrow tree = new JCThrow(expr);
 362         tree.pos = pos;
 363         return tree;
 364     }
 365 
 366     public JCAssert Assert(JCExpression cond, JCExpression detail) {
 367         JCAssert tree = new JCAssert(cond, detail);
 368         tree.pos = pos;
 369         return tree;
 370     }
 371 
 372     public JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
 373                        JCExpression fn,
 374                        List&lt;JCExpression&gt; args)
 375     {
 376         JCMethodInvocation tree = new JCMethodInvocation(typeargs, fn, args);
 377         tree.pos = pos;
 378         return tree;
 379     }
 380 
 381     public JCNewClass NewClass(JCExpression encl,
 382                              List&lt;JCExpression&gt; typeargs,
 383                              JCExpression clazz,
 384                              List&lt;JCExpression&gt; args,
 385                              JCClassDecl def)
 386     {
 387         return SpeculativeNewClass(encl, typeargs, clazz, args, def, false);
 388     }
 389 
 390     public JCNewClass SpeculativeNewClass(JCExpression encl,
 391                              List&lt;JCExpression&gt; typeargs,
 392                              JCExpression clazz,
 393                              List&lt;JCExpression&gt; args,
 394                              JCClassDecl def,
 395                              boolean classDefRemoved)
 396     {
 397         JCNewClass tree = classDefRemoved ?
 398                 new JCNewClass(encl, typeargs, clazz, args, def) {
 399                     @Override
 400                     public boolean classDeclRemoved() {
 401                         return true;
 402                     }
 403                 } :
 404                 new JCNewClass(encl, typeargs, clazz, args, def);
 405         tree.pos = pos;
 406         return tree;
 407     }
 408 
 409     public JCNewArray NewArray(JCExpression elemtype,
 410                              List&lt;JCExpression&gt; dims,
 411                              List&lt;JCExpression&gt; elems)
 412     {
 413         JCNewArray tree = new JCNewArray(elemtype, dims, elems);
 414         tree.pos = pos;
 415         return tree;
 416     }
 417 
 418     public JCLambda Lambda(List&lt;JCVariableDecl&gt; params,
 419                            JCTree body)
 420     {
 421         JCLambda tree = new JCLambda(params, body);
 422         tree.pos = pos;
 423         return tree;
 424     }
 425 
 426     public JCParens Parens(JCExpression expr) {
 427         JCParens tree = new JCParens(expr);
 428         tree.pos = pos;
 429         return tree;
 430     }
 431 
 432     public JCAssign Assign(JCExpression lhs, JCExpression rhs) {
 433         JCAssign tree = new JCAssign(lhs, rhs);
 434         tree.pos = pos;
 435         return tree;
 436     }
 437 
 438     public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs) {
 439         JCAssignOp tree = new JCAssignOp(opcode, lhs, rhs, null);
 440         tree.pos = pos;
 441         return tree;
 442     }
 443 
 444     public JCUnary Unary(JCTree.Tag opcode, JCExpression arg) {
 445         JCUnary tree = new JCUnary(opcode, arg);
 446         tree.pos = pos;
 447         return tree;
 448     }
 449 
 450     public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
 451         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
 452         tree.pos = pos;
 453         return tree;
 454     }
 455 
 456     public JCTypeCast TypeCast(JCTree clazz, JCExpression expr) {
 457         JCTypeCast tree = new JCTypeCast(clazz, expr);
 458         tree.pos = pos;
 459         return tree;
 460     }
 461 
 462     public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
 463         JCInstanceOf tree = new JCInstanceOf(expr, clazz);
 464         tree.pos = pos;
 465         return tree;
 466     }
 467 
 468     public JCAnyPattern AnyPattern() {
 469         JCAnyPattern tree = new JCAnyPattern();
 470         tree.pos = pos;
 471         return tree;
 472     }
 473 
 474     public JCBindingPattern BindingPattern(Name name, JCTree vartype) {
 475         JCBindingPattern tree = new JCBindingPattern(name, null, vartype);
 476         tree.pos = pos;
 477         return tree;
 478     }
 479 
<a name="2" id="anc2"></a><span class="line-modified"> 480     public JCDeconstructionPattern DeconstructionPattern(JCExpression deconstructor, List&lt;JCPattern&gt; nested) {</span>
<span class="line-modified"> 481         JCDeconstructionPattern tree = new JCDeconstructionPattern(deconstructor, nested);</span>
 482         tree.pos = pos;
 483         return tree;
 484     }
 485 
 486     public JCLiteralPattern LiteralPattern(JCExpression cexp) {
 487         JCLiteralPattern tree = new JCLiteralPattern(cexp);
 488         tree.pos = pos;
 489         return tree;
 490     }
 491 
 492     public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
 493         JCArrayAccess tree = new JCArrayAccess(indexed, index);
 494         tree.pos = pos;
 495         return tree;
 496     }
 497 
 498     public JCFieldAccess Select(JCExpression selected, Name selector) {
 499         JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
 500         tree.pos = pos;
 501         return tree;
 502     }
 503 
 504     public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
 505             JCExpression expr, List&lt;JCExpression&gt; typeargs) {
 506         JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
 507         tree.pos = pos;
 508         return tree;
 509     }
 510 
 511     public JCIdent Ident(Name name) {
 512         JCIdent tree = new JCIdent(name, null);
 513         tree.pos = pos;
 514         return tree;
 515     }
 516 
 517     public JCLiteral Literal(TypeTag tag, Object value) {
 518         JCLiteral tree = new JCLiteral(tag, value);
 519         tree.pos = pos;
 520         return tree;
 521     }
 522 
 523     public JCPrimitiveTypeTree TypeIdent(TypeTag typetag) {
 524         JCPrimitiveTypeTree tree = new JCPrimitiveTypeTree(typetag);
 525         tree.pos = pos;
 526         return tree;
 527     }
 528 
 529     public JCArrayTypeTree TypeArray(JCExpression elemtype) {
 530         JCArrayTypeTree tree = new JCArrayTypeTree(elemtype);
 531         tree.pos = pos;
 532         return tree;
 533     }
 534 
 535     public JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
 536         JCTypeApply tree = new JCTypeApply(clazz, arguments);
 537         tree.pos = pos;
 538         return tree;
 539     }
 540 
 541     public JCTypeUnion TypeUnion(List&lt;JCExpression&gt; components) {
 542         JCTypeUnion tree = new JCTypeUnion(components);
 543         tree.pos = pos;
 544         return tree;
 545     }
 546 
 547     public JCTypeIntersection TypeIntersection(List&lt;JCExpression&gt; components) {
 548         JCTypeIntersection tree = new JCTypeIntersection(components);
 549         tree.pos = pos;
 550         return tree;
 551     }
 552 
 553     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds) {
 554         return TypeParameter(name, bounds, List.nil());
 555     }
 556 
 557     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annos) {
 558         JCTypeParameter tree = new JCTypeParameter(name, bounds, annos);
 559         tree.pos = pos;
 560         return tree;
 561     }
 562 
 563     public JCWildcard Wildcard(TypeBoundKind kind, JCTree type) {
 564         JCWildcard tree = new JCWildcard(kind, type);
 565         tree.pos = pos;
 566         return tree;
 567     }
 568 
 569     public TypeBoundKind TypeBoundKind(BoundKind kind) {
 570         TypeBoundKind tree = new TypeBoundKind(kind);
 571         tree.pos = pos;
 572         return tree;
 573     }
 574 
 575     public JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 576         JCAnnotation tree = new JCAnnotation(Tag.ANNOTATION, annotationType, args);
 577         tree.pos = pos;
 578         return tree;
 579     }
 580 
 581     public JCAnnotation TypeAnnotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 582         JCAnnotation tree = new JCAnnotation(Tag.TYPE_ANNOTATION, annotationType, args);
 583         tree.pos = pos;
 584         return tree;
 585     }
 586 
 587     public JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
 588         JCModifiers tree = new JCModifiers(flags, annotations);
 589         boolean noFlags = (flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0;
 590         tree.pos = (noFlags &amp;&amp; annotations.isEmpty()) ? Position.NOPOS : pos;
 591         return tree;
 592     }
 593 
 594     public JCModifiers Modifiers(long flags) {
 595         return Modifiers(flags, List.nil());
 596     }
 597 
 598     @Override
 599     public JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind,
 600             JCExpression qualid, List&lt;JCDirective&gt; directives) {
 601         JCModuleDecl tree = new JCModuleDecl(mods, kind, qualid, directives);
 602         tree.pos = pos;
 603         return tree;
 604     }
 605 
 606     @Override
 607     public JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 608         JCExports tree = new JCExports(qualId, moduleNames);
 609         tree.pos = pos;
 610         return tree;
 611     }
 612 
 613     @Override
 614     public JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 615         JCOpens tree = new JCOpens(qualId, moduleNames);
 616         tree.pos = pos;
 617         return tree;
 618     }
 619 
 620     @Override
 621     public JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
 622         JCProvides tree = new JCProvides(serviceName, implNames);
 623         tree.pos = pos;
 624         return tree;
 625     }
 626 
 627     @Override
 628     public JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId) {
 629         JCRequires tree = new JCRequires(isTransitive, isStaticPhase, qualId);
 630         tree.pos = pos;
 631         return tree;
 632     }
 633 
 634     @Override
 635     public JCUses Uses(JCExpression qualId) {
 636         JCUses tree = new JCUses(qualId);
 637         tree.pos = pos;
 638         return tree;
 639     }
 640 
 641     public JCAnnotatedType AnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
 642         JCAnnotatedType tree = new JCAnnotatedType(annotations, underlyingType);
 643         tree.pos = pos;
 644         return tree;
 645     }
 646 
 647     public JCErroneous Erroneous() {
 648         return Erroneous(List.nil());
 649     }
 650 
 651     public JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs) {
 652         JCErroneous tree = new JCErroneous(errs);
 653         tree.pos = pos;
 654         return tree;
 655     }
 656 
<a name="3" id="anc3"></a><span class="line-modified"> 657     public LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {</span>
 658         LetExpr tree = new LetExpr(defs, expr);
 659         tree.pos = pos;
 660         return tree;
 661     }
 662 
 663 /* ***************************************************************************
 664  * Derived building blocks.
 665  ****************************************************************************/
 666 
 667     public JCClassDecl AnonymousClassDef(JCModifiers mods,
 668                                          List&lt;JCTree&gt; defs)
 669     {
 670         return ClassDef(mods,
 671                         names.empty,
 672                         List.nil(),
 673                         null,
 674                         List.nil(),
 675                         defs);
 676     }
 677 
 678     public LetExpr LetExpr(JCVariableDecl def, JCExpression expr) {
 679         LetExpr tree = new LetExpr(List.of(def), expr);
 680         tree.pos = pos;
 681         return tree;
 682     }
 683 
 684     /** Create an identifier from a symbol.
 685      */
 686     public JCIdent Ident(Symbol sym) {
 687         return (JCIdent)new JCIdent((sym.name != names.empty)
 688                                 ? sym.name
 689                                 : sym.flatName(), sym)
 690             .setPos(pos)
 691             .setType(sym.type);
 692     }
 693 
 694     /** Create a selection node from a qualifier tree and a symbol.
 695      *  @param base   The qualifier tree.
 696      */
 697     public JCExpression Select(JCExpression base, Symbol sym) {
 698         return new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);
 699     }
 700 
 701     /** Create a qualified identifier from a symbol, adding enough qualifications
 702      *  to make the reference unique.
 703      */
 704     public JCExpression QualIdent(Symbol sym) {
 705         return isUnqualifiable(sym)
 706             ? Ident(sym)
 707             : Select(QualIdent(sym.owner), sym);
 708     }
 709 
 710     /** Create an identifier that refers to the variable declared in given variable
 711      *  declaration.
 712      */
 713     public JCExpression Ident(JCVariableDecl param) {
 714         return Ident(param.sym);
 715     }
 716 
 717     /** Create a list of identifiers referring to the variables declared
 718      *  in given list of variable declarations.
 719      */
 720     public List&lt;JCExpression&gt; Idents(List&lt;JCVariableDecl&gt; params) {
 721         ListBuffer&lt;JCExpression&gt; ids = new ListBuffer&lt;&gt;();
 722         for (List&lt;JCVariableDecl&gt; l = params; l.nonEmpty(); l = l.tail)
 723             ids.append(Ident(l.head));
 724         return ids.toList();
 725     }
 726 
 727     /** Create a tree representing `this&#39;, given its type.
 728      */
 729     public JCExpression This(Type t) {
 730         return Ident(new VarSymbol(FINAL, names._this, t, t.tsym));
 731     }
 732 
 733     /** Create a tree representing qualified `this&#39; given its type
 734      */
 735     public JCExpression QualThis(Type t) {
 736         return Select(Type(t), new VarSymbol(FINAL, names._this, t, t.tsym));
 737     }
 738 
 739     /** Create a tree representing a class literal.
 740      */
 741     public JCExpression ClassLiteral(ClassSymbol clazz) {
 742         return ClassLiteral(clazz.type);
 743     }
 744 
 745     /** Create a tree representing a class literal.
 746      */
 747     public JCExpression ClassLiteral(Type t) {
 748         VarSymbol lit = new VarSymbol(STATIC | PUBLIC | FINAL,
 749                                       names._class,
 750                                       t,
 751                                       t.tsym);
 752         return Select(Type(t), lit);
 753     }
 754 
 755     /** Create a tree representing `super&#39;, given its type and owner.
 756      */
 757     public JCIdent Super(Type t, TypeSymbol owner) {
 758         return Ident(new VarSymbol(FINAL, names._super, t, owner));
 759     }
 760 
 761     /**
 762      * Create a method invocation from a method tree and a list of
 763      * argument trees.
 764      */
 765     public JCMethodInvocation App(JCExpression meth, List&lt;JCExpression&gt; args) {
 766         return Apply(null, meth, args).setType(meth.type.getReturnType());
 767     }
 768 
 769     /**
 770      * Create a no-arg method invocation from a method tree
 771      */
 772     public JCMethodInvocation App(JCExpression meth) {
 773         return Apply(null, meth, List.nil()).setType(meth.type.getReturnType());
 774     }
 775 
 776     /** Create a method invocation from a method tree and a list of argument trees.
 777      */
 778     public JCExpression Create(Symbol ctor, List&lt;JCExpression&gt; args) {
 779         Type t = ctor.owner.erasure(types);
 780         JCNewClass newclass = NewClass(null, null, Type(t), args, null);
 781         newclass.constructor = ctor;
 782         newclass.setType(t);
 783         return newclass;
 784     }
 785 
 786     /** Create a tree representing given type.
 787      */
 788     public JCExpression Type(Type t) {
 789         if (t == null) return null;
 790         JCExpression tp;
 791         switch (t.getTag()) {
 792         case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
 793         case DOUBLE: case BOOLEAN: case VOID:
 794             tp = TypeIdent(t.getTag());
 795             break;
 796         case TYPEVAR:
 797             tp = Ident(t.tsym);
 798             break;
 799         case WILDCARD: {
 800             WildcardType a = ((WildcardType) t);
 801             tp = Wildcard(TypeBoundKind(a.kind), a.kind == BoundKind.UNBOUND ? null : Type(a.type));
 802             break;
 803         }
 804         case CLASS:
 805             switch (t.getKind()) {
 806             case UNION: {
 807                 UnionClassType tu = (UnionClassType)t;
 808                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 809                 for (Type ta : tu.getAlternativeTypes()) {
 810                     la.add(Type(ta));
 811                 }
 812                 tp = TypeUnion(la.toList());
 813                 break;
 814             }
 815             case INTERSECTION: {
 816                 IntersectionClassType it = (IntersectionClassType)t;
 817                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 818                 for (Type ta : it.getExplicitComponents()) {
 819                     la.add(Type(ta));
 820                 }
 821                 tp = TypeIntersection(la.toList());
 822                 break;
 823             }
 824             default: {
 825                 Type outer = t.getEnclosingType();
 826                 JCExpression clazz = outer.hasTag(CLASS) &amp;&amp; t.tsym.owner.kind == TYP
 827                         ? Select(Type(outer), t.tsym)
 828                         : QualIdent(t.tsym);
 829                 tp = t.getTypeArguments().isEmpty()
 830                         ? clazz
 831                         : TypeApply(clazz, Types(t.getTypeArguments()));
 832                 break;
 833             }
 834             }
 835             break;
 836         case ARRAY:
 837             tp = TypeArray(Type(types.elemtype(t)));
 838             break;
 839         case ERROR:
 840             tp = TypeIdent(ERROR);
 841             break;
 842         default:
 843             throw new AssertionError(&quot;unexpected type: &quot; + t);
 844         }
 845         return tp.setType(t);
 846     }
 847 
 848     /** Create a list of trees representing given list of types.
 849      */
 850     public List&lt;JCExpression&gt; Types(List&lt;Type&gt; ts) {
 851         ListBuffer&lt;JCExpression&gt; lb = new ListBuffer&lt;&gt;();
 852         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 853             lb.append(Type(l.head));
 854         return lb.toList();
 855     }
 856 
 857     /** Create a variable definition from a variable symbol and an initializer
 858      *  expression.
 859      */
 860     public JCVariableDecl VarDef(VarSymbol v, JCExpression init) {
 861         return (JCVariableDecl)
 862             new JCVariableDecl(
 863                 Modifiers(v.flags(), Annotations(v.getRawAttributes())),
 864                 v.name,
 865                 Type(v.type),
 866                 init,
 867                 v).setPos(pos).setType(v.type);
 868     }
 869 
 870     /** Create annotation trees from annotations.
 871      */
 872     public List&lt;JCAnnotation&gt; Annotations(List&lt;Attribute.Compound&gt; attributes) {
 873         if (attributes == null) return List.nil();
 874         ListBuffer&lt;JCAnnotation&gt; result = new ListBuffer&lt;&gt;();
 875         for (List&lt;Attribute.Compound&gt; i = attributes; i.nonEmpty(); i=i.tail) {
 876             Attribute a = i.head;
 877             result.append(Annotation(a));
 878         }
 879         return result.toList();
 880     }
 881 
 882     public JCLiteral Literal(Object value) {
 883         JCLiteral result = null;
 884         if (value instanceof String) {
 885             result = Literal(CLASS, value).
 886                 setType(syms.stringType.constType(value));
 887         } else if (value instanceof Integer) {
 888             result = Literal(INT, value).
 889                 setType(syms.intType.constType(value));
 890         } else if (value instanceof Long) {
 891             result = Literal(LONG, value).
 892                 setType(syms.longType.constType(value));
 893         } else if (value instanceof Byte) {
 894             result = Literal(BYTE, value).
 895                 setType(syms.byteType.constType(value));
 896         } else if (value instanceof Character) {
 897             int v = (int) (((Character) value).toString().charAt(0));
 898             result = Literal(CHAR, v).
 899                 setType(syms.charType.constType(v));
 900         } else if (value instanceof Double) {
 901             result = Literal(DOUBLE, value).
 902                 setType(syms.doubleType.constType(value));
 903         } else if (value instanceof Float) {
 904             result = Literal(FLOAT, value).
 905                 setType(syms.floatType.constType(value));
 906         } else if (value instanceof Short) {
 907             result = Literal(SHORT, value).
 908                 setType(syms.shortType.constType(value));
 909         } else if (value instanceof Boolean) {
 910             int v = ((Boolean) value) ? 1 : 0;
 911             result = Literal(BOOLEAN, v).
 912                 setType(syms.booleanType.constType(v));
 913         } else {
 914             throw new AssertionError(value);
 915         }
 916         return result;
 917     }
 918 
 919     class AnnotationBuilder implements Attribute.Visitor {
 920         JCExpression result = null;
 921         public void visitConstant(Attribute.Constant v) {
 922             result = Literal(v.type.getTag(), v.value);
 923         }
 924         public void visitClass(Attribute.Class clazz) {
 925             result = ClassLiteral(clazz.classType).setType(syms.classType);
 926         }
 927         public void visitEnum(Attribute.Enum e) {
 928             result = QualIdent(e.value);
 929         }
 930         public void visitError(Attribute.Error e) {
 931             if (e instanceof UnresolvedClass) {
 932                 result = ClassLiteral(((UnresolvedClass) e).classType).setType(syms.classType);
 933             } else {
 934                 result = Erroneous();
 935             }
 936         }
 937         public void visitCompound(Attribute.Compound compound) {
 938             if (compound instanceof Attribute.TypeCompound) {
 939                 result = visitTypeCompoundInternal((Attribute.TypeCompound) compound);
 940             } else {
 941                 result = visitCompoundInternal(compound);
 942             }
 943         }
 944         public JCAnnotation visitCompoundInternal(Attribute.Compound compound) {
 945             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 946             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 947                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 948                 JCExpression valueTree = translate(pair.snd);
 949                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 950             }
 951             return Annotation(Type(compound.type), args.toList());
 952         }
 953         public JCAnnotation visitTypeCompoundInternal(Attribute.TypeCompound compound) {
 954             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 955             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 956                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 957                 JCExpression valueTree = translate(pair.snd);
 958                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 959             }
 960             return TypeAnnotation(Type(compound.type), args.toList());
 961         }
 962         public void visitArray(Attribute.Array array) {
 963             ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
 964             for (int i = 0; i &lt; array.values.length; i++)
 965                 elems.append(translate(array.values[i]));
 966             result = NewArray(null, List.nil(), elems.toList()).setType(array.type);
 967         }
 968         JCExpression translate(Attribute a) {
 969             a.accept(this);
 970             return result;
 971         }
 972         JCAnnotation translate(Attribute.Compound a) {
 973             return visitCompoundInternal(a);
 974         }
 975         JCAnnotation translate(Attribute.TypeCompound a) {
 976             return visitTypeCompoundInternal(a);
 977         }
 978     }
 979 
 980     AnnotationBuilder annotationBuilder = new AnnotationBuilder();
 981 
 982     /** Create an annotation tree from an attribute.
 983      */
 984     public JCAnnotation Annotation(Attribute a) {
 985         return annotationBuilder.translate((Attribute.Compound)a);
 986     }
 987 
 988     public JCAnnotation TypeAnnotation(Attribute a) {
 989         return annotationBuilder.translate((Attribute.TypeCompound) a);
 990     }
 991 
 992     /** Create a method definition from a method symbol and a method body.
 993      */
 994     public JCMethodDecl MethodDef(MethodSymbol m, JCBlock body) {
 995         return MethodDef(m, m.type, body);
 996     }
 997 
 998     /** Create a method definition from a method symbol, method type
 999      *  and a method body.
1000      */
1001     public JCMethodDecl MethodDef(MethodSymbol m, Type mtype, JCBlock body) {
1002         return (JCMethodDecl)
1003             new JCMethodDecl(
1004                 Modifiers(m.flags(), Annotations(m.getRawAttributes())),
1005                 m.name,
1006                 Type(mtype.getReturnType()),
1007                 TypeParams(mtype.getTypeArguments()),
1008                 null, // receiver type
1009                 Params(mtype.getParameterTypes(), m),
1010                 Types(mtype.getThrownTypes()),
1011                 body,
1012                 null,
1013                 m).setPos(pos).setType(mtype);
1014     }
1015 
1016     /** Create a type parameter tree from its name and type.
1017      */
1018     public JCTypeParameter TypeParam(Name name, TypeVar tvar) {
1019         return (JCTypeParameter)
1020             TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);
1021     }
1022 
1023     /** Create a list of type parameter trees from a list of type variables.
1024      */
1025     public List&lt;JCTypeParameter&gt; TypeParams(List&lt;Type&gt; typarams) {
1026         ListBuffer&lt;JCTypeParameter&gt; tparams = new ListBuffer&lt;&gt;();
1027         for (List&lt;Type&gt; l = typarams; l.nonEmpty(); l = l.tail)
1028             tparams.append(TypeParam(l.head.tsym.name, (TypeVar)l.head));
1029         return tparams.toList();
1030     }
1031 
1032     /** Create a value parameter tree from its name, type, and owner.
1033      */
1034     public JCVariableDecl Param(Name name, Type argtype, Symbol owner) {
1035         return VarDef(new VarSymbol(PARAMETER, name, argtype, owner), null);
1036     }
1037 
1038     /** Create a a list of value parameter trees x0, ..., xn from a list of
1039      *  their types and an their owner.
1040      */
1041     public List&lt;JCVariableDecl&gt; Params(List&lt;Type&gt; argtypes, Symbol owner) {
1042         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
1043         MethodSymbol mth = (owner.kind == MTH) ? ((MethodSymbol)owner) : null;
1044         if (mth != null &amp;&amp; mth.params != null &amp;&amp; argtypes.length() == mth.params.length()) {
1045             for (VarSymbol param : ((MethodSymbol)owner).params)
1046                 params.append(VarDef(param, null));
1047         } else {
1048             int i = 0;
1049             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1050                 params.append(Param(paramName(i++), l.head, owner));
1051         }
1052         return params.toList();
1053     }
1054 
1055     /** Wrap a method invocation in an expression statement or return statement,
1056      *  depending on whether the method invocation expression&#39;s type is void.
1057      */
1058     public JCStatement Call(JCExpression apply) {
1059         return apply.type.hasTag(VOID) ? Exec(apply) : Return(apply);
1060     }
1061 
1062     /** Construct an assignment from a variable symbol and a right hand side.
1063      */
1064     public JCStatement Assignment(Symbol v, JCExpression rhs) {
1065         return Exec(Assign(Ident(v), rhs).setType(v.type));
1066     }
1067 
1068     /** Construct an index expression from a variable and an expression.
1069      */
1070     public JCArrayAccess Indexed(Symbol v, JCExpression index) {
1071         JCArrayAccess tree = new JCArrayAccess(QualIdent(v), index);
1072         tree.type = ((ArrayType)v.type).elemtype;
1073         return tree;
1074     }
1075 
1076     /** Make an attributed type cast expression.
1077      */
1078     public JCTypeCast TypeCast(Type type, JCExpression expr) {
1079         return (JCTypeCast)TypeCast(Type(type), expr).setType(type);
1080     }
1081 
1082 /* ***************************************************************************
1083  * Helper methods.
1084  ****************************************************************************/
1085 
1086     /** Can given symbol be referred to in unqualified form?
1087      */
1088     boolean isUnqualifiable(Symbol sym) {
1089         if (sym.name == names.empty ||
1090             sym.owner == null ||
1091             sym.owner == syms.rootPackage ||
1092             sym.owner.kind == MTH || sym.owner.kind == VAR) {
1093             return true;
1094         } else if (sym.kind == TYP &amp;&amp; toplevel != null) {
1095             Iterator&lt;Symbol&gt; it = toplevel.namedImportScope.getSymbolsByName(sym.name).iterator();
1096             if (it.hasNext()) {
1097                 Symbol s = it.next();
1098                 return
1099                   s == sym &amp;&amp;
1100                   !it.hasNext();
1101             }
1102             it = toplevel.packge.members().getSymbolsByName(sym.name).iterator();
1103             if (it.hasNext()) {
1104                 Symbol s = it.next();
1105                 return
1106                   s == sym &amp;&amp;
1107                   !it.hasNext();
1108             }
1109             it = toplevel.starImportScope.getSymbolsByName(sym.name).iterator();
1110             if (it.hasNext()) {
1111                 Symbol s = it.next();
1112                 return
1113                   s == sym &amp;&amp;
1114                   !it.hasNext();
1115             }
1116         }
1117         return false;
1118     }
1119 
1120     /** The name of synthetic parameter number `i&#39;.
1121      */
1122     public Name paramName(int i)   { return names.fromString(&quot;x&quot; + i); }
1123 
1124     /** The name of synthetic type parameter number `i&#39;.
1125      */
1126     public Name typaramName(int i) { return names.fromString(&quot;A&quot; + i); }
1127 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
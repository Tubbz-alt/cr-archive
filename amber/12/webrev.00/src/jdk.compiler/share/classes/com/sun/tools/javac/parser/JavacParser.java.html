<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
 236      *     mode |= NOINVOCATION : method invocations are not allowed
 237      */
 238     protected static final int EXPR = 0x1;
 239     protected static final int TYPE = 0x2;
 240     protected static final int NOPARAMS = 0x4;
 241     protected static final int TYPEARG = 0x8;
 242     protected static final int DIAMOND = 0x10;
 243     protected static final int NOLAMBDA = 0x20;
 244     protected static final int NOINVOCATION = 0x40;
 245 
 246     protected void selectExprMode() {
 247         mode = (mode &amp; (NOLAMBDA | NOINVOCATION)) | EXPR;
 248     }
 249 
 250     protected void selectTypeMode() {
 251         mode = (mode &amp; (NOLAMBDA|NOINVOCATION)) | TYPE;
 252     }
 253 
 254     /** The current mode.
 255      */
 256     protected int mode = 0;
 257 
 258     /** The mode of the term that was parsed last.
 259      */
 260     protected int lastmode = 0;
 261 
 262     /* ---------- token management -------------- */
 263 
 264     protected Token token;
 265 
 266     public Token token() {
 267         return token;
 268     }
 269 
 270     public void nextToken() {
 271         S.nextToken();
 272         token = S.token();
 273     }
 274 
 275     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 276         return peekToken(0, tk);
 277     }
 278 
 279     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 280         return tk.accepts(S.token(lookahead + 1).kind);
 281     }
 282 
 283     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 284         return peekToken(0, tk1, tk2);
 285     }
 286 
 287     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 288         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 289                 tk2.accepts(S.token(lookahead + 2).kind);
 290     }
 291 
 292     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 293         return peekToken(0, tk1, tk2, tk3);
 294     }
 295 
 296     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 297         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 298                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 299                 tk3.accepts(S.token(lookahead + 3).kind);
 300     }
 301 
 302     @SuppressWarnings(&quot;unchecked&quot;)
 303     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 304         return peekToken(0, kinds);
 305     }
 306 
 307     @SuppressWarnings(&quot;unchecked&quot;)
 308     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 309         for (; lookahead &lt; kinds.length ; lookahead++) {
 310             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 311                 return false;
 312             }
 313         }
 314         return true;
 315     }
 316 
 317     /* ---------- error recovery -------------- */
 318 
 319     private JCErroneous errorTree;
 320 
 321     /** Skip forward until a suitable stop token is found.
 322      */
 323     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 324          while (true) {
 325              switch (token.kind) {
 326                 case SEMI:
 327                     nextToken();
 328                     return;
 329                 case PUBLIC:
 330                 case FINAL:
 331                 case ABSTRACT:
 332                 case MONKEYS_AT:
 333                 case EOF:
 334                 case CLASS:
 335                 case INTERFACE:
 336                 case ENUM:
 337                     return;
 338                 case IMPORT:
 339                     if (stopAtImport)
 340                         return;
 341                     break;
 342                 case LBRACE:
 343                 case RBRACE:
 344                 case PRIVATE:
 345                 case PROTECTED:
 346                 case STATIC:
 347                 case TRANSIENT:
 348                 case NATIVE:
 349                 case VOLATILE:
 350                 case SYNCHRONIZED:
 351                 case STRICTFP:
 352                 case LT:
 353                 case BYTE:
 354                 case SHORT:
 355                 case CHAR:
 356                 case INT:
 357                 case LONG:
 358                 case FLOAT:
 359                 case DOUBLE:
 360                 case BOOLEAN:
 361                 case VOID:
 362                     if (stopAtMemberDecl)
 363                         return;
 364                     break;
 365                 case UNDERSCORE:
 366                 case IDENTIFIER:
 367                    if (stopAtIdentifier)
 368                         return;
 369                     break;
 370                 case CASE:
 371                 case DEFAULT:
 372                 case IF:
 373                 case FOR:
 374                 case WHILE:
 375                 case DO:
 376                 case TRY:
 377                 case SWITCH:
 378                 case RETURN:
 379                 case THROW:
 380                 case BREAK:
 381                 case CONTINUE:
 382                 case ELSE:
 383                 case FINALLY:
 384                 case CATCH:
 385                 case THIS:
 386                 case SUPER:
 387                 case NEW:
 388                     if (stopAtStatement)
 389                         return;
 390                     break;
 391                 case ASSERT:
 392                     if (stopAtStatement)
 393                         return;
 394                     break;
 395             }
 396             nextToken();
 397         }
 398     }
 399 
 400     protected JCErroneous syntaxError(int pos, Error errorKey) {
 401         return syntaxError(pos, List.nil(), errorKey);
 402     }
 403 
 404     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 405         setErrorEndPos(pos);
 406         JCErroneous err = F.at(pos).Erroneous(errs);
 407         reportSyntaxError(err, errorKey);
 408         if (errs != null) {
 409             JCTree last = errs.last();
 410             if (last != null)
 411                 storeEnd(last, pos);
 412         }
 413         return toP(err);
 414     }
 415 
 416     private static final int RECOVERY_THRESHOLD = 50;
 417     private int errorPos = Position.NOPOS;
 418     private int count = 0;
 419 
 420     /**
 421      * Report a syntax using the given the position parameter and arguments,
 422      * unless one was already reported at the same position.
 423      */
 424     protected void reportSyntaxError(int pos, Error errorKey) {
 425         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 426         reportSyntaxError(diag, errorKey);
 427     }
 428 
 429     /**
 430      * Report a syntax error using the given DiagnosticPosition object and
 431      * arguments, unless one was already reported at the same position.
 432      */
 433     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 434         int pos = diagPos.getPreferredPosition();
 435         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 436             if (token.kind == EOF) {
 437                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 438             } else {
 439                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 440             }
 441         }
 442         S.errPos(pos);
 443         if (token.pos == errorPos) {
 444             //check for a possible infinite loop in parsing:
 445             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 446         } else {
 447             count = 0;
 448             errorPos = token.pos;
 449         }
 450     }
 451 
 452     /** If next input token matches given token, skip it, otherwise report
 453      *  an error.
 454      */
 455     public void accept(TokenKind tk) {
 456         accept(tk, Errors::Expected);
 457     }
 458 
 459     /** If next input token matches given token, skip it, otherwise report
 460      *  an error.
 461      */
 462     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 463         if (token.kind == tk) {
 464             nextToken();
 465         } else {
 466             setErrorEndPos(token.pos);
 467             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 468         }
 469     }
 470 
 471     /** Report an illegal start of expression/type error at given position.
 472      */
 473     JCExpression illegal(int pos) {
 474         setErrorEndPos(pos);
 475         if ((mode &amp; EXPR) != 0)
 476             return syntaxError(pos, Errors.IllegalStartOfExpr);
 477         else
 478             return syntaxError(pos, Errors.IllegalStartOfType);
 479 
 480     }
 481 
 482     /** Report an illegal start of expression/type error at current position.
 483      */
 484     JCExpression illegal() {
 485         return illegal(token.pos);
 486     }
 487 
 488     /** Diagnose a modifier flag from the set, if any. */
 489     protected void checkNoMods(long mods) {
 490         if (mods != 0) {
 491             long lowestMod = mods &amp; -mods;
 492             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 493         }
 494     }
 495 
 496 /* ---------- doc comments --------- */
 497 
 498     /** A table to store all documentation comments
 499      *  indexed by the tree nodes they refer to.
 500      *  defined only if option flag keepDocComment is set.
 501      */
 502     private final DocCommentTable docComments;
 503 
 504     /** Make an entry into docComments hashtable,
 505      *  provided flag keepDocComments is set and given doc comment is non-null.
 506      *  @param tree   The tree to be used as index in the hashtable
 507      *  @param dc     The doc comment to associate with the tree, or null.
 508      */
 509     protected void attach(JCTree tree, Comment dc) {
 510         if (keepDocComments &amp;&amp; dc != null) {
 511 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 512             docComments.putComment(tree, dc);
 513         }
 514     }
 515 
 516 /* -------- source positions ------- */
 517 
 518     protected void setErrorEndPos(int errPos) {
 519         endPosTable.setErrorEndPos(errPos);
 520     }
 521 
 522     protected void storeEnd(JCTree tree, int endpos) {
 523         endPosTable.storeEnd(tree, endpos);
 524     }
 525 
 526     protected &lt;T extends JCTree&gt; T to(T t) {
 527         return endPosTable.to(t);
 528     }
 529 
 530     protected &lt;T extends JCTree&gt; T toP(T t) {
 531         return endPosTable.toP(t);
 532     }
 533 
 534     /** Get the start position for a tree node.  The start position is
 535      * defined to be the position of the first character of the first
 536      * token of the node&#39;s source text.
 537      * @param tree  The tree node
 538      */
 539     public int getStartPos(JCTree tree) {
 540         return TreeInfo.getStartPos(tree);
 541     }
 542 
 543     /**
 544      * Get the end position for a tree node.  The end position is
 545      * defined to be the position of the last character of the last
 546      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 547      * positions are not generated or the position is otherwise not
 548      * found.
 549      * @param tree  The tree node
 550      */
 551     public int getEndPos(JCTree tree) {
 552         return endPosTable.getEndPos(tree);
 553     }
 554 
 555 
 556 
 557 /* ---------- parsing -------------- */
 558 
 559     /**
 560      * Ident = IDENTIFIER
 561      */
 562     public Name ident() {
 563         return ident(false);
 564     }
 565 
 566     protected Name ident(boolean advanceOnErrors) {
 567         if (token.kind == IDENTIFIER) {
 568             Name name = token.name();
 569             nextToken();
 570             return name;
 571         } else if (token.kind == ASSERT) {
 572             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 573             nextToken();
 574             return names.error;
 575         } else if (token.kind == ENUM) {
 576             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 577             nextToken();
 578             return names.error;
 579         } else if (token.kind == THIS) {
 580             if (allowThisIdent) {
 581                 // Make sure we&#39;re using a supported source version.
 582                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 583                 Name name = token.name();
 584                 nextToken();
 585                 return name;
 586             } else {
 587                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 588                 nextToken();
 589                 return names.error;
 590             }
 591         } else if (token.kind == UNDERSCORE) {
 592             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 593                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 594             } else {
 595                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 596             }
 597             Name name = token.name();
 598             nextToken();
 599             return name;
 600         } else {
 601             accept(IDENTIFIER);
 602             if (advanceOnErrors) {
 603                 nextToken();
 604             }
 605             return names.error;
 606         }
 607     }
 608 
 609     /**
 610      * Qualident = Ident { DOT [Annotations] Ident }
 611      */
 612     public JCExpression qualident(boolean allowAnnos) {
 613         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 614         while (token.kind == DOT) {
 615             int pos = token.pos;
 616             nextToken();
 617             List&lt;JCAnnotation&gt; tyannos = null;
 618             if (allowAnnos) {
 619                 tyannos = typeAnnotationsOpt();
 620             }
 621             t = toP(F.at(pos).Select(t, ident()));
 622             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 623                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 624             }
 625         }
 626         return t;
 627     }
 628 
 629     JCExpression literal(Name prefix) {
 630         return literal(prefix, token.pos);
 631     }
 632 
 633     /**
 634      * Literal =
 635      *     INTLITERAL
 636      *   | LONGLITERAL
 637      *   | FLOATLITERAL
 638      *   | DOUBLELITERAL
 639      *   | CHARLITERAL
 640      *   | STRINGLITERAL
 641      *   | TRUE
 642      *   | FALSE
 643      *   | NULL
 644      */
 645     JCExpression literal(Name prefix, int pos) {
 646         JCExpression t = errorTree;
 647         switch (token.kind) {
 648         case INTLITERAL:
 649             try {
 650                 t = F.at(pos).Literal(
 651                     TypeTag.INT,
 652                     Convert.string2int(strval(prefix), token.radix()));
 653             } catch (NumberFormatException ex) {
 654                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 655             }
 656             break;
 657         case LONGLITERAL:
 658             try {
 659                 t = F.at(pos).Literal(
 660                     TypeTag.LONG,
 661                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 662             } catch (NumberFormatException ex) {
 663                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 664             }
 665             break;
 666         case FLOATLITERAL: {
 667             String proper = token.radix() == 16 ?
 668                     (&quot;0x&quot;+ token.stringVal()) :
 669                     token.stringVal();
 670             Float n;
 671             try {
 672                 n = Float.valueOf(proper);
 673             } catch (NumberFormatException ex) {
 674                 // error already reported in scanner
 675                 n = Float.NaN;
 676             }
 677             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 678                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 679             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 680                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 681             else
 682                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 683             break;
 684         }
 685         case DOUBLELITERAL: {
 686             String proper = token.radix() == 16 ?
 687                     (&quot;0x&quot;+ token.stringVal()) :
 688                     token.stringVal();
 689             Double n;
 690             try {
 691                 n = Double.valueOf(proper);
 692             } catch (NumberFormatException ex) {
 693                 // error already reported in scanner
 694                 n = Double.NaN;
 695             }
 696             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 697                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 698             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 699                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 700             else
 701                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 702             break;
 703         }
 704         case CHARLITERAL:
 705             t = F.at(pos).Literal(
 706                 TypeTag.CHAR,
 707                 token.stringVal().charAt(0) + 0);
 708             break;
 709         case STRINGLITERAL:
 710             t = F.at(pos).Literal(
 711                 TypeTag.CLASS,
 712                 token.stringVal());
 713             break;
 714         case TRUE: case FALSE:
 715             t = F.at(pos).Literal(
 716                 TypeTag.BOOLEAN,
 717                 (token.kind == TRUE ? 1 : 0));
 718             break;
 719         case NULL:
 720             t = F.at(pos).Literal(
 721                 TypeTag.BOT,
 722                 null);
 723             break;
 724         default:
 725             Assert.error();
 726         }
 727         if (t == errorTree)
 728             t = F.at(pos).Erroneous();
 729         storeEnd(t, token.endPos);
 730         nextToken();
 731         return t;
 732     }
 733     //where
 734         boolean isZero(String s) {
 735             char[] cs = s.toCharArray();
 736             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 737             int i = ((base==16) ? 2 : 0);
 738             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 739             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 740         }
 741 
 742         String strval(Name prefix) {
 743             String s = token.stringVal();
 744             return prefix.isEmpty() ? s : prefix + s;
 745         }
 746 
 747     /** terms can be either expressions or types.
 748      */
 749     public JCExpression parseExpression() {
 750         return term(EXPR);
 751     }
 752 
 753 
 754     /** parses patterns.
 755      */
 756 
 757     public JCPattern parsePattern() {
 758         int pos = token.pos;
 759         if (token.kind == UNDERSCORE) {
 760             nextToken();
 761             return toP(F.at(pos).AnyPattern());
 762         } else if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 763             nextToken();
 764             return toP(F.at(pos).BindingPattern(ident(), null));
 765         } else {
 766             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 767             if (token.kind == LPAREN) {
 768                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 769                 do {
 770                     nextToken();
 771                     JCPattern nestedPattern = parsePattern();
 772                     nested.append(nestedPattern);
 773                 } while (token.kind == COMMA);
 774                 accept(RPAREN);
 775                 return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));
 776             } else if (token.kind == IDENTIFIER) {
 777                 return toP(F.at(pos).BindingPattern(ident(), e));
 778             } else {
 779                 return toP(F.at(pos).LiteralPattern(e));
 780             }
 781         }
 782     }
 783 
 784     /**
 785      * parses (optional) type annotations followed by a type. If the
 786      * annotations are present before the type and are not consumed during array
 787      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 788      * these annotations and the underlying type. Otherwise, it returns the
 789      * underlying type.
 790      *
 791      * &lt;p&gt;
 792      *
 793      * Note that this method sets {@code mode} to {@code TYPE} first, before
 794      * parsing annotations.
 795      */
 796     public JCExpression parseType() {
 797         return parseType(false);
 798     }
 799 
 800     public JCExpression parseType(boolean allowVar) {
 801         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 802         return parseType(allowVar, annotations);
 803     }
 804 
 805     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 806         JCExpression result = unannotatedType(allowVar);
 807 
 808         if (annotations.nonEmpty()) {
 809             result = insertAnnotationsToMostInner(result, annotations, false);
 810         }
 811 
 812         return result;
 813     }
 814 
 815     public JCExpression unannotatedType(boolean allowVar) {
 816         JCExpression result = term(TYPE);
 817         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 818 
 819         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 820             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 821         }
 822 
 823         return result;
 824     }
 825 
 826 
 827 
 828     protected JCExpression term(int newmode) {
 829         int prevmode = mode;
 830         mode = newmode;
 831         JCExpression t = term();
 832         lastmode = mode;
 833         mode = prevmode;
 834         return t;
 835     }
 836 
 837     /**
 838      *  {@literal
 839      *  Expression = Expression1 [ExpressionRest]
 840      *  ExpressionRest = [AssignmentOperator Expression1]
 841      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 842      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 843      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 844      *  Type = Type1
 845      *  TypeNoParams = TypeNoParams1
 846      *  StatementExpression = Expression
 847      *  ConstantExpression = Expression
 848      *  }
 849      */
 850     JCExpression term() {
 851         JCExpression t = term1();
 852         if ((mode &amp; EXPR) != 0 &amp;&amp;
 853             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 854             return termRest(t);
 855         else
 856             return t;
 857     }
 858 
 859     JCExpression termRest(JCExpression t) {
 860         switch (token.kind) {
 861         case EQ: {
 862             int pos = token.pos;
 863             nextToken();
 864             selectExprMode();
 865             JCExpression t1 = term();
 866             return toP(F.at(pos).Assign(t, t1));
 867         }
 868         case PLUSEQ:
 869         case SUBEQ:
 870         case STAREQ:
 871         case SLASHEQ:
 872         case PERCENTEQ:
 873         case AMPEQ:
 874         case BAREQ:
 875         case CARETEQ:
 876         case LTLTEQ:
 877         case GTGTEQ:
 878         case GTGTGTEQ:
 879             int pos = token.pos;
 880             TokenKind tk = token.kind;
 881             nextToken();
 882             selectExprMode();
 883             JCExpression t1 = term();
 884             return F.at(pos).Assignop(optag(tk), t, t1);
 885         default:
 886             return t;
 887         }
 888     }
 889 
 890     /** Expression1   = Expression2 [Expression1Rest]
 891      *  Type1         = Type2
 892      *  TypeNoParams1 = TypeNoParams2
 893      */
 894     JCExpression term1() {
 895         JCExpression t = term2();
 896         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 897             selectExprMode();
 898             return term1Rest(t);
 899         } else {
 900             return t;
 901         }
 902     }
 903 
 904     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 905      */
 906     JCExpression term1Rest(JCExpression t) {
 907         if (token.kind == QUES) {
 908             int pos = token.pos;
 909             nextToken();
 910             JCExpression t1 = term();
 911             accept(COLON);
 912             JCExpression t2 = term1();
 913             return F.at(pos).Conditional(t, t1, t2);
 914         } else {
 915             return t;
 916         }
 917     }
 918 
 919     /** Expression2   = Expression3 [Expression2Rest]
 920      *  Type2         = Type3
 921      *  TypeNoParams2 = TypeNoParams3
 922      */
 923     JCExpression term2() {
 924         JCExpression t = term3();
 925         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 926             selectExprMode();
 927             return term2Rest(t, TreeInfo.orPrec);
 928         } else {
 929             return t;
 930         }
 931     }
 932 
 933     /*  Expression2Rest = {infixop Expression3}
 934      *                  | Expression3 instanceof Type
 935      *                  | Expression3 instanceof Pattern
 936      *  infixop         = &quot;||&quot;
 937      *                  | &quot;&amp;&amp;&quot;
 938      *                  | &quot;|&quot;
 939      *                  | &quot;^&quot;
 940      *                  | &quot;&amp;&quot;
 941      *                  | &quot;==&quot; | &quot;!=&quot;
 942      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 943      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 944      *                  | &quot;+&quot; | &quot;-&quot;
 945      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 946      */
 947     JCExpression term2Rest(JCExpression t, int minprec) {
 948         JCExpression[] odStack = newOdStack();
 949         Token[] opStack = newOpStack();
 950 
 951         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 952         int top = 0;
 953         odStack[0] = t;
 954         int startPos = token.pos;
 955         Token topOp = Tokens.DUMMY;
 956         while (prec(token.kind) &gt;= minprec) {
 957             opStack[top] = topOp;
 958 
 959             if (token.kind == INSTANCEOF) {
 960                 int pos = token.pos;
 961                 nextToken();
 962                 JCTree pattern = parseType(true);
 963                 if (token.kind == IDENTIFIER) {
 964                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 965                     Source source = restrictedTypeNameStartingAtSource(((JCIdent) pattern).name, pattern.pos, true);
 966                     if (pattern.hasTag(IDENT) &amp;&amp; source != null) {
 967                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(((JCIdent) pattern).name, source));
 968                         pattern = null;
 969                     }
 970                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 971                 } else if (token.kind == LPAREN) {
 972                     checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);
 973                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 974                     do {
 975                         nextToken();
 976                         JCPattern nestedPattern = parsePattern();
 977                         nested.append(nestedPattern);
 978                     } while (token.kind == COMMA);
 979                     accept(RPAREN);
 980                     pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));
 981                 }
 982                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 983             } else {
 984                 topOp = token;
 985                 nextToken();
 986                 top++;
 987                 odStack[top] = term3();
 988             }
 989             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 990                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 991                 top--;
 992                 topOp = opStack[top];
 993             }
 994         }
 995         Assert.check(top == 0);
 996         t = odStack[0];
 997 
 998         if (t.hasTag(JCTree.Tag.PLUS)) {
 999             t = foldStrings(t);
1000         }
1001 
1002         odStackSupply.add(odStack);
1003         opStackSupply.add(opStack);
1004         return t;
1005     }
1006     //where
1007         /** If tree is a concatenation of string literals, replace it
1008          *  by a single literal representing the concatenated string.
1009          */
1010         protected JCExpression foldStrings(JCExpression tree) {
1011             if (!allowStringFolding)
1012                 return tree;
1013             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
1014             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
1015             boolean needsFolding = false;
1016             JCExpression curr = tree;
1017             while (true) {
1018                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1019                     JCBinary op = (JCBinary)curr;
1020                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1021                     curr = op.lhs;
1022                 } else {
1023                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1024                     break; //last one!
1025                 }
1026             }
1027             if (needsFolding) {
1028                 List&lt;JCExpression&gt; ops = opStack.toList();
1029                 JCExpression res = ops.head;
1030                 for (JCExpression op : ops.tail) {
1031                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1032                     storeEnd(res, getEndPos(op));
1033                 }
1034                 return res;
1035             } else {
1036                 return tree;
1037             }
1038         }
1039 
1040         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1041                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1042             JCLiteral str = stringLiteral(tree);
1043             if (str != null) {
1044                 litBuf.prepend(str);
1045                 return last &amp;&amp; merge(litBuf, opStack);
1046             } else {
1047                 boolean res = merge(litBuf, opStack);
1048                 litBuf.clear();
1049                 opStack.prepend(tree);
1050                 return res;
1051             }
1052         }
1053 
1054         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1055             if (litBuf.isEmpty()) {
1056                 return false;
1057             } else if (litBuf.size() == 1) {
1058                 opStack.prepend(litBuf.first());
1059                 return false;
1060             } else {
1061                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1062                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1063                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1064                 opStack.prepend(t);
1065                 return true;
1066             }
1067         }
1068 
1069         private JCLiteral stringLiteral(JCTree tree) {
1070             if (tree.hasTag(LITERAL)) {
1071                 JCLiteral lit = (JCLiteral)tree;
1072                 if (lit.typetag == TypeTag.CLASS) {
1073                     return lit;
1074                 }
1075             }
1076             return null;
1077         }
1078 
1079 
1080         /** optimization: To save allocating a new operand/operator stack
1081          *  for every binary operation, we use supplys.
1082          */
1083         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1084         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1085 
1086         private JCExpression[] newOdStack() {
1087             if (odStackSupply.isEmpty())
1088                 return new JCExpression[infixPrecedenceLevels + 1];
1089             return odStackSupply.remove(odStackSupply.size() - 1);
1090         }
1091 
1092         private Token[] newOpStack() {
1093             if (opStackSupply.isEmpty())
1094                 return new Token[infixPrecedenceLevels + 1];
1095             return opStackSupply.remove(opStackSupply.size() - 1);
1096         }
1097 
1098     /**
1099      *  Expression3    = PrefixOp Expression3
1100      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1101      *                 | Primary {Selector} {PostfixOp}
1102      *
1103      *  {@literal
1104      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1105      *                 | Literal
1106      *                 | [TypeArguments] THIS [Arguments]
1107      *                 | [TypeArguments] SUPER SuperSuffix
1108      *                 | NEW [TypeArguments] Creator
1109      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1110      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1111      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1112      *                 | Expression3 MemberReferenceSuffix
1113      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1114      *                   | Arguments
1115      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1116      *                   ]
1117      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1118      *  }
1119      *
1120      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1121      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1122      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1123      *                 | BasicType
1124      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1125      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1126      *                 | &quot;.&quot; THIS
1127      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1128      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1129      *                 | &quot;[&quot; Expression &quot;]&quot;
1130      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1131      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1132      */
1133     protected JCExpression term3() {
1134         int pos = token.pos;
1135         JCExpression t;
1136         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1137         switch (token.kind) {
1138         case QUES:
1139             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1140                 selectTypeMode();
1141                 return typeArgument();
1142             } else
1143                 return illegal();
1144         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1145             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1146                 TokenKind tk = token.kind;
1147                 nextToken();
1148                 selectExprMode();
1149                 if (tk == SUB &amp;&amp;
1150                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1151                     token.radix() == 10) {
1152                     selectExprMode();
1153                     t = literal(names.hyphen, pos);
1154                 } else {
1155                     t = term3();
1156                     return F.at(pos).Unary(unoptag(tk), t);
1157                 }
1158             } else return illegal();
1159             break;
1160         case LPAREN:
1161             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1162                 ParensResult pres = analyzeParens();
1163                 switch (pres) {
1164                     case CAST:
1165                        accept(LPAREN);
1166                        selectTypeMode();
1167                        int pos1 = pos;
1168                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1169                        while (token.kind == AMP) {
1170                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1171                            accept(AMP);
1172                            targets = targets.prepend(parseType());
1173                        }
1174                        if (targets.length() &gt; 1) {
1175                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1176                        }
1177                        accept(RPAREN);
1178                        selectExprMode();
1179                        JCExpression t1 = term3();
1180                        return F.at(pos).TypeCast(t, t1);
1181                     case IMPLICIT_LAMBDA:
1182                     case EXPLICIT_LAMBDA:
1183                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1184                         break;
1185                     default: //PARENS
1186                         accept(LPAREN);
1187                         selectExprMode();
1188                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1189                         accept(RPAREN);
1190                         t = toP(F.at(pos).Parens(t));
1191                         break;
1192                 }
1193             } else {
1194                 return illegal();
1195             }
1196             break;
1197         case THIS:
1198             if ((mode &amp; EXPR) != 0) {
1199                 selectExprMode();
1200                 t = to(F.at(pos).Ident(names._this));
1201                 nextToken();
1202                 if (typeArgs == null)
1203                     t = argumentsOpt(null, t);
1204                 else
1205                     t = arguments(typeArgs, t);
1206                 typeArgs = null;
1207             } else return illegal();
1208             break;
1209         case SUPER:
1210             if ((mode &amp; EXPR) != 0) {
1211                 selectExprMode();
1212                 t = to(F.at(pos).Ident(names._super));
1213                 t = superSuffix(typeArgs, t);
1214                 typeArgs = null;
1215             } else return illegal();
1216             break;
1217         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1218         case CHARLITERAL: case STRINGLITERAL:
1219         case TRUE: case FALSE: case NULL:
1220             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1221                 selectExprMode();
1222                 t = literal(names.empty);
1223             } else return illegal();
1224             break;
1225         case NEW:
1226             if (typeArgs != null) return illegal();
1227             if ((mode &amp; EXPR) != 0) {
1228                 selectExprMode();
1229                 nextToken();
1230                 if (token.kind == LT) typeArgs = typeArguments(false);
1231                 t = creator(pos, typeArgs);
1232                 typeArgs = null;
1233             } else return illegal();
1234             break;
1235         case MONKEYS_AT:
1236             // Only annotated cast types and method references are valid
1237             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1238             if (typeAnnos.isEmpty()) {
1239                 // else there would be no &#39;@&#39;
1240                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1241             }
1242 
1243             JCExpression expr = term3();
1244 
1245             if ((mode &amp; TYPE) == 0) {
1246                 // Type annotations on class literals no longer legal
1247                 switch (expr.getTag()) {
1248                 case REFERENCE: {
1249                     JCMemberReference mref = (JCMemberReference) expr;
1250                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1251                     t = mref;
1252                     break;
1253                 }
1254                 case SELECT: {
1255                     JCFieldAccess sel = (JCFieldAccess) expr;
1256 
1257                     if (sel.name != names._class) {
1258                         return illegal();
1259                     } else {
1260                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1261                         return expr;
1262                     }
1263                 }
1264                 default:
1265                     return illegal(typeAnnos.head.pos);
1266                 }
1267 
1268             } else {
1269                 // Type annotations targeting a cast
1270                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1271             }
1272             break;
1273         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1274             if (typeArgs != null) return illegal();
1275             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1276                 t = lambdaExpressionOrStatement(false, false, pos);
1277             } else {
1278                 t = toP(F.at(token.pos).Ident(ident()));
1279                 loop: while (true) {
1280                     pos = token.pos;
1281                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1282 
1283                     // need to report an error later if LBRACKET is for array
1284                     // index access rather than array creation level
1285                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1286                         return illegal(annos.head.pos);
1287 
1288                     switch (token.kind) {
1289                     case LBRACKET:
1290                         nextToken();
1291                         if (token.kind == RBRACKET) {
1292                             nextToken();
1293                             t = bracketsOpt(t);
1294                             t = toP(F.at(pos).TypeArray(t));
1295                             if (annos.nonEmpty()) {
1296                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1297                             }
1298                             t = bracketsSuffix(t);
1299                         } else {
1300                             if ((mode &amp; EXPR) != 0) {
1301                                 selectExprMode();
1302                                 JCExpression t1 = term();
1303                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1304                                 t = to(F.at(pos).Indexed(t, t1));
1305                             }
1306                             accept(RBRACKET);
1307                         }
1308                         break loop;
1309                     case LPAREN:
1310                         if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOINVOCATION) == 0) {
1311                             selectExprMode();
1312                             t = arguments(typeArgs, t);
1313                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1314                             typeArgs = null;
1315                         }
1316                         break loop;
1317                     case DOT:
1318                         nextToken();
1319                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1320                             return illegal();
1321                         }
1322                         int oldmode = mode;
1323                         mode &amp;= ~NOPARAMS;
1324                         typeArgs = typeArgumentsOpt(EXPR);
1325                         mode = oldmode;
1326                         if ((mode &amp; EXPR) != 0) {
1327                             switch (token.kind) {
1328                             case CLASS:
1329                                 if (typeArgs != null) return illegal();
1330                                 selectExprMode();
1331                                 t = to(F.at(pos).Select(t, names._class));
1332                                 nextToken();
1333                                 break loop;
1334                             case THIS:
1335                                 if (typeArgs != null) return illegal();
1336                                 selectExprMode();
1337                                 t = to(F.at(pos).Select(t, names._this));
1338                                 nextToken();
1339                                 break loop;
1340                             case SUPER:
1341                                 selectExprMode();
1342                                 t = to(F.at(pos).Select(t, names._super));
1343                                 t = superSuffix(typeArgs, t);
1344                                 typeArgs = null;
1345                                 break loop;
1346                             case NEW:
1347                                 if (typeArgs != null) return illegal();
1348                                 selectExprMode();
1349                                 int pos1 = token.pos;
1350                                 nextToken();
1351                                 if (token.kind == LT) typeArgs = typeArguments(false);
1352                                 t = innerCreator(pos1, typeArgs, t);
1353                                 typeArgs = null;
1354                                 break loop;
1355                             }
1356                         }
1357 
1358                         List&lt;JCAnnotation&gt; tyannos = null;
1359                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1360                             tyannos = typeAnnotationsOpt();
1361                         }
1362                         // typeArgs saved for next loop iteration.
1363                         t = toP(F.at(pos).Select(t, ident()));
1364                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1365                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1366                         }
1367                         break;
1368                     case ELLIPSIS:
1369                         if (this.permitTypeAnnotationsPushBack) {
1370                             this.typeAnnotationsPushedBack = annos;
1371                         } else if (annos.nonEmpty()) {
1372                             // Don&#39;t return here -- error recovery attempt
1373                             illegal(annos.head.pos);
1374                         }
1375                         break loop;
1376                     case LT:
1377                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1378                             //this is an unbound method reference whose qualifier
1379                             //is a generic type i.e. A&lt;S&gt;::m
1380                             int pos1 = token.pos;
1381                             accept(LT);
1382                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1383                             args.append(typeArgument());
1384                             while (token.kind == COMMA) {
1385                                 nextToken();
1386                                 args.append(typeArgument());
1387                             }
1388                             accept(GT);
1389                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1390                             while (token.kind == DOT) {
1391                                 nextToken();
1392                                 selectTypeMode();
1393                                 t = toP(F.at(token.pos).Select(t, ident()));
1394                                 t = typeArgumentsOpt(t);
1395                             }
1396                             t = bracketsOpt(t);
1397                             if (token.kind != COLCOL) {
1398                                 //method reference expected here
1399                                 t = illegal();
1400                             }
1401                             selectExprMode();
1402                             return term3Rest(t, typeArgs);
1403                         }
1404                         break loop;
1405                     default:
1406                         break loop;
1407                     }
1408                 }
1409             }
1410             if (typeArgs != null) illegal();
1411             t = typeArgumentsOpt(t);
1412             break;
1413         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1414         case DOUBLE: case BOOLEAN:
1415             if (typeArgs != null) illegal();
1416             t = bracketsSuffix(bracketsOpt(basicType()));
1417             break;
1418         case VOID:
1419             if (typeArgs != null) illegal();
1420             if ((mode &amp; EXPR) != 0) {
1421                 nextToken();
1422                 if (token.kind == DOT) {
1423                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1424                     t = bracketsSuffix(ti);
1425                 } else {
1426                     return illegal(pos);
1427                 }
1428             } else {
1429                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1430                 // a void type (like other primitive types) to the next phase.
1431                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1432                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1433                 nextToken();
1434                 return ti;
1435                 //return illegal();
1436             }
1437             break;
1438         case SWITCH:
1439             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1440             allowYieldStatement = true;
1441             int switchPos = token.pos;
1442             nextToken();
1443             JCExpression selector = parExpression();
1444             accept(LBRACE);
1445             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1446             while (true) {
1447                 pos = token.pos;
1448                 switch (token.kind) {
1449                 case CASE:
1450                 case DEFAULT:
1451                     cases.appendList(switchExpressionStatementGroup());
1452                     break;
1453                 case RBRACE: case EOF:
1454                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1455                                                                                cases.toList()));
1456                     e.endpos = token.pos;
1457                     accept(RBRACE);
1458                     return e;
1459                 default:
1460                     nextToken(); // to ensure progress
1461                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1462                 }
1463             }
1464         default:
1465             return illegal();
1466         }
1467         return term3Rest(t, typeArgs);
1468     }
1469 
1470     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1471         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1472         int casePos = token.pos;
1473         ListBuffer&lt;JCPattern&gt; pats = new ListBuffer&lt;&gt;();
1474 
1475         if (token.kind == DEFAULT) {
1476             nextToken();
1477         } else {
1478             accept(CASE);
1479             while (true) {
1480                 pats.append(parsePattern());
1481                 if (token.kind != COMMA) break;
1482                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1483                 nextToken();
1484             };
1485         }
1486         List&lt;JCStatement&gt; stats = null;
1487         JCTree body = null;
1488         CaseTree.CaseKind kind;
1489         switch (token.kind) {
1490             case ARROW:
1491                 checkSourceLevel(Feature.SWITCH_RULE);
1492                 nextToken();
1493                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1494                     stats = List.of(parseStatement());
1495                     body = stats.head;
1496                     kind = JCCase.RULE;
1497                 } else {
1498                     JCExpression value = parseExpression();
1499                     stats = List.of(to(F.at(value).Yield(value)));
1500                     body = value;
1501                     kind = JCCase.RULE;
1502                     accept(SEMI);
1503                 }
1504                 break;
1505             default:
1506                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1507                 stats = blockStatements();
1508                 kind = JCCase.STATEMENT;
1509                 break;
1510         }
1511         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1512         return caseExprs.toList();
1513     }
1514 
1515     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1516         if (typeArgs != null) illegal();
1517         while (true) {
1518             int pos1 = token.pos;
1519             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1520 
1521             if (token.kind == LBRACKET) {
1522                 nextToken();
1523                 if ((mode &amp; TYPE) != 0) {
1524                     int oldmode = mode;
1525                     selectTypeMode();
1526                     if (token.kind == RBRACKET) {
1527                         nextToken();
1528                         t = bracketsOpt(t);
1529                         t = toP(F.at(pos1).TypeArray(t));
1530                         if (token.kind == COLCOL) {
1531                             selectExprMode();
1532                             continue;
1533                         }
1534                         if (annos.nonEmpty()) {
1535                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1536                         }
1537                         return t;
1538                     }
1539                     mode = oldmode;
1540                 }
1541                 if ((mode &amp; EXPR) != 0) {
1542                     selectExprMode();
1543                     JCExpression t1 = term();
1544                     t = to(F.at(pos1).Indexed(t, t1));
1545                 }
1546                 accept(RBRACKET);
1547             } else if (token.kind == DOT) {
1548                 nextToken();
1549                 typeArgs = typeArgumentsOpt(EXPR);
1550                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1551                     selectExprMode();
1552                     t = to(F.at(pos1).Select(t, names._super));
1553                     nextToken();
1554                     t = arguments(typeArgs, t);
1555                     typeArgs = null;
1556                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1557                     if (typeArgs != null) return illegal();
1558                     selectExprMode();
1559                     int pos2 = token.pos;
1560                     nextToken();
1561                     if (token.kind == LT) typeArgs = typeArguments(false);
1562                     t = innerCreator(pos2, typeArgs, t);
1563                     typeArgs = null;
1564                 } else {
1565                     List&lt;JCAnnotation&gt; tyannos = null;
1566                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1567                         // is the mode check needed?
1568                         tyannos = typeAnnotationsOpt();
1569                     }
1570                     t = toP(F.at(pos1).Select(t, ident(true)));
1571                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1572                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1573                     }
1574                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1575                     typeArgs = null;
1576                 }
1577             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1578                 selectExprMode();
1579                 if (typeArgs != null) return illegal();
1580                 accept(COLCOL);
1581                 t = memberReferenceSuffix(pos1, t);
1582             } else {
1583                 if (!annos.isEmpty()) {
1584                     if (permitTypeAnnotationsPushBack)
1585                         typeAnnotationsPushedBack = annos;
1586                     else
1587                         return illegal(annos.head.pos);
1588                 }
1589                 break;
1590             }
1591         }
1592         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1593             selectExprMode();
1594             t = to(F.at(token.pos).Unary(
1595                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1596             nextToken();
1597         }
1598         return toP(t);
1599     }
1600 
1601     /**
1602      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1603      * method reference or a binary expression. To disambiguate, look for a
1604      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1605      */
1606     @SuppressWarnings(&quot;fallthrough&quot;)
1607     boolean isUnboundMemberRef() {
1608         int pos = 0, depth = 0;
1609         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1610             switch (t.kind) {
1611                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1612                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1613                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1614                 case DOUBLE: case BOOLEAN: case CHAR:
1615                 case MONKEYS_AT:
1616                     break;
1617 
1618                 case LPAREN:
1619                     // skip annotation values
1620                     int nesting = 0;
1621                     for (; ; pos++) {
1622                         TokenKind tk2 = S.token(pos).kind;
1623                         switch (tk2) {
1624                             case EOF:
1625                                 return false;
1626                             case LPAREN:
1627                                 nesting++;
1628                                 break;
1629                             case RPAREN:
1630                                 nesting--;
1631                                 if (nesting == 0) {
1632                                     continue outer;
1633                                 }
1634                                 break;
1635                         }
1636                     }
1637 
1638                 case LT:
1639                     depth++; break;
1640                 case GTGTGT:
1641                     depth--;
1642                 case GTGT:
1643                     depth--;
1644                 case GT:
1645                     depth--;
1646                     if (depth == 0) {
1647                         TokenKind nextKind = S.token(pos + 1).kind;
1648                         return
1649                             nextKind == TokenKind.DOT ||
1650                             nextKind == TokenKind.LBRACKET ||
1651                             nextKind == TokenKind.COLCOL;
1652                     }
1653                     break;
1654                 default:
1655                     return false;
1656             }
1657         }
1658     }
1659 
1660     /**
1661      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1662      * method reference or a binary expression. To disambiguate, look for a
1663      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1664      */
1665     @SuppressWarnings(&quot;fallthrough&quot;)
1666     ParensResult analyzeParens() {
1667         int depth = 0;
1668         boolean type = false;
1669         ParensResult defaultResult = ParensResult.PARENS;
1670         outer: for (int lookahead = 0; ; lookahead++) {
1671             TokenKind tk = S.token(lookahead).kind;
1672             switch (tk) {
1673                 case COMMA:
1674                     type = true;
1675                 case EXTENDS: case SUPER: case DOT: case AMP:
1676                     //skip
1677                     break;
1678                 case QUES:
1679                     if (peekToken(lookahead, EXTENDS) ||
1680                             peekToken(lookahead, SUPER)) {
1681                         //wildcards
1682                         type = true;
1683                     }
1684                     break;
1685                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1686                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1687                     if (peekToken(lookahead, RPAREN)) {
1688                         //Type, &#39;)&#39; -&gt; cast
1689                         return ParensResult.CAST;
1690                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1691                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1692                         return ParensResult.EXPLICIT_LAMBDA;
1693                     }
1694                     break;
1695                 case LPAREN:
1696                     if (lookahead != 0) {
1697                         // &#39;(&#39; in a non-starting position -&gt; parens
1698                         return ParensResult.PARENS;
1699                     } else if (peekToken(lookahead, RPAREN)) {
1700                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1701                         return ParensResult.EXPLICIT_LAMBDA;
1702                     }
1703                     break;
1704                 case RPAREN:
1705                     // if we have seen something that looks like a type,
1706                     // then it&#39;s a cast expression
1707                     if (type) return ParensResult.CAST;
1708                     // otherwise, disambiguate cast vs. parenthesized expression
1709                     // based on subsequent token.
1710                     switch (S.token(lookahead + 1).kind) {
1711                         /*case PLUSPLUS: case SUBSUB: */
1712                         case BANG: case TILDE:
1713                         case LPAREN: case THIS: case SUPER:
1714                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1715                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1716                         case TRUE: case FALSE: case NULL:
1717                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1718                         case SWITCH:
1719                         case BYTE: case SHORT: case CHAR: case INT:
1720                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1721                             return ParensResult.CAST;
1722                         default:
1723                             return defaultResult;
1724                     }
1725                 case UNDERSCORE:
1726                 case ASSERT:
1727                 case ENUM:
1728                 case IDENTIFIER:
1729                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1730                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1731                         return ParensResult.EXPLICIT_LAMBDA;
1732                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1733                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1734                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1735                                                       : ParensResult.PARENS;
1736                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1737                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1738                     }
1739                     type = false;
1740                     break;
1741                 case FINAL:
1742                 case ELLIPSIS:
1743                     //those can only appear in explicit lambdas
1744                     return ParensResult.EXPLICIT_LAMBDA;
1745                 case MONKEYS_AT:
1746                     type = true;
1747                     lookahead += 1; //skip &#39;@&#39;
1748                     while (peekToken(lookahead, DOT)) {
1749                         lookahead += 2;
1750                     }
1751                     if (peekToken(lookahead, LPAREN)) {
1752                         lookahead++;
1753                         //skip annotation values
1754                         int nesting = 0;
1755                         for (; ; lookahead++) {
1756                             TokenKind tk2 = S.token(lookahead).kind;
1757                             switch (tk2) {
1758                                 case EOF:
1759                                     return ParensResult.PARENS;
1760                                 case LPAREN:
1761                                     nesting++;
1762                                     break;
1763                                 case RPAREN:
1764                                     nesting--;
1765                                     if (nesting == 0) {
1766                                         continue outer;
1767                                     }
1768                                 break;
1769                             }
1770                         }
1771                     }
1772                     break;
1773                 case LBRACKET:
1774                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1775                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1776                         return ParensResult.EXPLICIT_LAMBDA;
1777                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1778                             peekToken(lookahead, RBRACKET, AMP)) {
1779                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1780                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1781                         return ParensResult.CAST;
1782                     } else if (peekToken(lookahead, RBRACKET)) {
1783                         //consume the &#39;]&#39; and skip
1784                         type = true;
1785                         lookahead++;
1786                         break;
1787                     } else {
1788                         return ParensResult.PARENS;
1789                     }
1790                 case LT:
1791                     depth++; break;
1792                 case GTGTGT:
1793                     depth--;
1794                 case GTGT:
1795                     depth--;
1796                 case GT:
1797                     depth--;
1798                     if (depth == 0) {
1799                         if (peekToken(lookahead, RPAREN) ||
1800                                 peekToken(lookahead, AMP)) {
1801                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1802                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1803                             return ParensResult.CAST;
1804                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1805                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1806                                 peekToken(lookahead, ELLIPSIS)) {
1807                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1808                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1809                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1810                             return ParensResult.EXPLICIT_LAMBDA;
1811                         }
1812                         //it looks a type, but could still be (i) a cast to generic type,
1813                         //(ii) an unbound method reference or (iii) an explicit lambda
1814                         type = true;
1815                         break;
1816                     } else if (depth &lt; 0) {
1817                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1818                         return ParensResult.PARENS;
1819                     }
1820                     break;
1821                 default:
1822                     //this includes EOF
1823                     return defaultResult;
1824             }
1825         }
1826     }
1827 
1828     /** Accepts all identifier-like tokens */
1829     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1830 
1831     enum ParensResult {
1832         CAST,
1833         EXPLICIT_LAMBDA,
1834         IMPLICIT_LAMBDA,
1835         PARENS
1836     }
1837 
1838     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1839         List&lt;JCVariableDecl&gt; params = explicitParams ?
1840                 formalParameters(true, false) :
1841                 implicitParameters(hasParens);
1842         if (explicitParams) {
1843             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1844             for (JCVariableDecl param: params) {
1845                 Name restrictedTypeName;
1846                 if (param.vartype != null &amp;&amp;
1847                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1848                         param.vartype.hasTag(TYPEARRAY)) {
1849                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1850                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1851                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1852                 }
1853                 lambdaClassifier.addParameter(param);
1854                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1855                     break;
1856                 }
1857             }
1858             if (lambdaClassifier.diagFragment != null) {
1859                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1860             }
1861             for (JCVariableDecl param: params) {
1862                 if (param.vartype != null
1863                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1864                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1865                     param.startPos = TreeInfo.getStartPos(param.vartype);
1866                     param.vartype = null;
1867                 }
1868             }
1869         }
1870         return lambdaExpressionOrStatementRest(params, pos);
1871     }
1872 
1873     enum LambdaParameterKind {
1874         VAR(0),
1875         EXPLICIT(1),
1876         IMPLICIT(2),
1877         ERROR(-1);
1878 
1879         private final int index;
1880 
1881         LambdaParameterKind(int index) {
1882             this.index = index;
1883         }
1884     }
1885 
1886     private final static Fragment[][] decisionTable = new Fragment[][] {
1887         /*              VAR                              EXPLICIT                         IMPLICIT  */
1888         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1889         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1890         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1891     };
1892 
1893     class LambdaClassifier {
1894 
1895         LambdaParameterKind kind;
1896         Fragment diagFragment;
1897         List&lt;JCVariableDecl&gt; params;
1898 
1899         void addParameter(JCVariableDecl param) {
1900             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1901                 if (restrictedTypeName(param.vartype, false) != null) {
1902                     reduce(LambdaParameterKind.VAR);
1903                 } else {
1904                     reduce(LambdaParameterKind.EXPLICIT);
1905                 }
1906             }
1907             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1908                 param.vartype != null &amp;&amp; param.name == names.empty) {
1909                 reduce(LambdaParameterKind.IMPLICIT);
1910             }
1911         }
1912 
1913         private void reduce(LambdaParameterKind newKind) {
1914             if (kind == null) {
1915                 kind = newKind;
1916             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1917                 LambdaParameterKind currentKind = kind;
1918                 kind = LambdaParameterKind.ERROR;
1919                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1920                         newKind.index == LambdaParameterKind.VAR.index;
1921                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1922                         decisionTable[currentKind.index][newKind.index] : null;
1923             }
1924         }
1925 
1926         LambdaParameterKind result() {
1927             return kind;
1928         }
1929     }
1930 
1931     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1932         checkSourceLevel(Feature.LAMBDA);
1933         accept(ARROW);
1934 
1935         return token.kind == LBRACE ?
1936             lambdaStatement(args, pos, token.pos) :
1937             lambdaExpression(args, pos);
1938     }
1939 
1940     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1941         JCBlock block = block(pos2, 0);
1942         return toP(F.at(pos).Lambda(args, block));
1943     }
1944 
1945     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1946         JCTree expr = parseExpression();
1947         return toP(F.at(pos).Lambda(args, expr));
1948     }
1949 
1950     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1951      */
1952     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1953         nextToken();
1954         if (token.kind == LPAREN || typeArgs != null) {
1955             t = arguments(typeArgs, t);
1956         } else if (token.kind == COLCOL) {
1957             if (typeArgs != null) return illegal();
1958             t = memberReferenceSuffix(t);
1959         } else {
1960             int pos = token.pos;
1961             accept(DOT);
1962             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1963             t = toP(F.at(pos).Select(t, ident()));
1964             t = argumentsOpt(typeArgs, t);
1965         }
1966         return t;
1967     }
1968 
1969     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1970      */
1971     JCPrimitiveTypeTree basicType() {
1972         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1973         nextToken();
1974         return t;
1975     }
1976 
1977     /** ArgumentsOpt = [ Arguments ]
1978      */
1979     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1980         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1981             selectExprMode();
1982             return arguments(typeArgs, t);
1983         } else {
1984             return t;
1985         }
1986     }
1987 
1988     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1989      */
1990     List&lt;JCExpression&gt; arguments() {
1991         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1992         if (token.kind == LPAREN) {
1993             nextToken();
1994             if (token.kind != RPAREN) {
1995                 args.append(parseExpression());
1996                 while (token.kind == COMMA) {
1997                     nextToken();
1998                     args.append(parseExpression());
1999                 }
2000             }
2001             accept(RPAREN);
2002         } else {
2003             syntaxError(token.pos, Errors.Expected(LPAREN));
2004         }
2005         return args.toList();
2006     }
2007 
2008     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2009         int pos = token.pos;
2010         List&lt;JCExpression&gt; args = arguments();
2011         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2012         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2013                                                                     ((JCIdent) t).name)) {
2014             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2015             mi = F.Erroneous(List.of(mi));
2016         }
2017         return toP(mi);
2018     }
2019 
2020     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2021         if (name == names.yield) {
2022             if (allowYieldStatement) {
2023                 return true;
2024             } else {
2025                 log.warning(pos, Warnings.InvalidYield);
2026             }
2027         }
2028         return false;
2029     }
2030 
2031     /**  TypeArgumentsOpt = [ TypeArguments ]
2032      */
2033     JCExpression typeArgumentsOpt(JCExpression t) {
2034         if (token.kind == LT &amp;&amp;
2035             (mode &amp; TYPE) != 0 &amp;&amp;
2036             (mode &amp; NOPARAMS) == 0) {
2037             selectTypeMode();
2038             return typeArguments(t, false);
2039         } else {
2040             return t;
2041         }
2042     }
2043     List&lt;JCExpression&gt; typeArgumentsOpt() {
2044         return typeArgumentsOpt(TYPE);
2045     }
2046 
2047     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2048         if (token.kind == LT) {
2049             if ((mode &amp; useMode) == 0 ||
2050                 (mode &amp; NOPARAMS) != 0) {
2051                 illegal();
2052             }
2053             mode = useMode;
2054             return typeArguments(false);
2055         }
2056         return null;
2057     }
2058 
2059     /**
2060      *  {@literal
2061      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2062      *  }
2063      */
2064     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2065         if (token.kind == LT) {
2066             nextToken();
2067             if (token.kind == GT &amp;&amp; diamondAllowed) {
2068                 checkSourceLevel(Feature.DIAMOND);
2069                 mode |= DIAMOND;
2070                 nextToken();
2071                 return List.nil();
2072             } else {
2073                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2074                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2075                 while (token.kind == COMMA) {
2076                     nextToken();
2077                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2078                 }
2079                 switch (token.kind) {
2080 
2081                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2082                 case GTGTGT: case GTGT:
2083                     token = S.split();
2084                     break;
2085                 case GT:
2086                     nextToken();
2087                     break;
2088                 default:
2089                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2090                     break;
2091                 }
2092                 return args.toList();
2093             }
2094         } else {
2095             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2096         }
2097     }
2098 
2099     /**
2100      *  {@literal
2101      *  TypeArgument = Type
2102      *               | [Annotations] &quot;?&quot;
2103      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2104      *               | [Annotations] &quot;?&quot; SUPER Type
2105      *  }
2106      */
2107     JCExpression typeArgument() {
2108         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2109         if (token.kind != QUES) return parseType(false, annotations);
2110         int pos = token.pos;
2111         nextToken();
2112         JCExpression result;
2113         if (token.kind == EXTENDS) {
2114             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2115             nextToken();
2116             JCExpression bound = parseType();
2117             result = F.at(pos).Wildcard(t, bound);
2118         } else if (token.kind == SUPER) {
2119             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2120             nextToken();
2121             JCExpression bound = parseType();
2122             result = F.at(pos).Wildcard(t, bound);
2123         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2124             //error recovery
2125             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2126             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2127             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2128             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2129             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2130             result = err;
2131         } else {
2132             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2133             result = toP(F.at(pos).Wildcard(t, null));
2134         }
2135         if (!annotations.isEmpty()) {
2136             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2137         }
2138         return result;
2139     }
2140 
2141     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2142         int pos = token.pos;
2143         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2144         return toP(F.at(pos).TypeApply(t, args));
2145     }
2146 
2147     /**
2148      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2149      *
2150      * &lt;p&gt;
2151      *
2152      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2153      * the expression &lt;code&gt;t&lt;/code&gt;.
2154      */
2155     private JCExpression bracketsOpt(JCExpression t,
2156             List&lt;JCAnnotation&gt; annotations) {
2157         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2158 
2159         if (token.kind == LBRACKET) {
2160             int pos = token.pos;
2161             nextToken();
2162             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2163         } else if (!nextLevelAnnotations.isEmpty()) {
2164             if (permitTypeAnnotationsPushBack) {
2165                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2166             } else {
2167                 return illegal(nextLevelAnnotations.head.pos);
2168             }
2169         }
2170 
2171         if (!annotations.isEmpty()) {
2172             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2173         }
2174         return t;
2175     }
2176 
2177     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2178      */
2179     private JCExpression bracketsOpt(JCExpression t) {
2180         return bracketsOpt(t, List.nil());
2181     }
2182 
2183     private JCExpression bracketsOptCont(JCExpression t, int pos,
2184             List&lt;JCAnnotation&gt; annotations) {
2185         accept(RBRACKET);
2186         t = bracketsOpt(t);
2187         t = toP(F.at(pos).TypeArray(t));
2188         if (annotations.nonEmpty()) {
2189             t = toP(F.at(pos).AnnotatedType(annotations, t));
2190         }
2191         return t;
2192     }
2193 
2194     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2195      *  BracketsSuffixType =
2196      */
2197     JCExpression bracketsSuffix(JCExpression t) {
2198         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2199             selectExprMode();
2200             int pos = token.pos;
2201             nextToken();
2202             accept(CLASS);
2203             if (token.pos == endPosTable.errorEndPos) {
2204                 // error recovery
2205                 Name name;
2206                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2207                     name = token.name();
2208                     nextToken();
2209                 } else {
2210                     name = names.error;
2211                 }
2212                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2213             } else {
2214                 Tag tag = t.getTag();
2215                 // Type annotations are illegal on class literals. Annotated non array class literals
2216                 // are complained about directly in term3(), Here check for type annotations on dimensions
2217                 // taking care to handle some interior dimension(s) being annotated.
2218                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2219                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2220                 t = toP(F.at(pos).Select(t, names._class));
2221             }
2222         } else if ((mode &amp; TYPE) != 0) {
2223             if (token.kind != COLCOL) {
2224                 selectTypeMode();
2225             }
2226         } else if (token.kind != COLCOL) {
2227             syntaxError(token.pos, Errors.DotClassExpected);
2228         }
2229         return t;
2230     }
2231 
2232     /**
2233      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2234      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2235      */
2236     JCExpression memberReferenceSuffix(JCExpression t) {
2237         int pos1 = token.pos;
2238         accept(COLCOL);
2239         return memberReferenceSuffix(pos1, t);
2240     }
2241 
2242     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2243         checkSourceLevel(Feature.METHOD_REFERENCES);
2244         selectExprMode();
2245         List&lt;JCExpression&gt; typeArgs = null;
2246         if (token.kind == LT) {
2247             typeArgs = typeArguments(false);
2248         }
2249         Name refName;
2250         ReferenceMode refMode;
2251         if (token.kind == NEW) {
2252             refMode = ReferenceMode.NEW;
2253             refName = names.init;
2254             nextToken();
2255         } else {
2256             refMode = ReferenceMode.INVOKE;
2257             refName = ident();
2258         }
2259         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2260     }
2261 
2262     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2263      */
2264     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2265         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2266 
2267         switch (token.kind) {
2268         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2269         case DOUBLE: case BOOLEAN:
2270             if (typeArgs == null) {
2271                 if (newAnnotations.isEmpty()) {
2272                     return arrayCreatorRest(newpos, basicType());
2273                 } else {
2274                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2275                 }
2276             }
2277             break;
2278         default:
2279         }
2280         JCExpression t = qualident(true);
2281 
2282         int oldmode = mode;
2283         selectTypeMode();
2284         boolean diamondFound = false;
2285         int lastTypeargsPos = -1;
2286         if (token.kind == LT) {
2287             lastTypeargsPos = token.pos;
2288             t = typeArguments(t, true);
2289             diamondFound = (mode &amp; DIAMOND) != 0;
2290         }
2291         while (token.kind == DOT) {
2292             if (diamondFound) {
2293                 //cannot select after a diamond
2294                 illegal();
2295             }
2296             int pos = token.pos;
2297             nextToken();
2298             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2299             t = toP(F.at(pos).Select(t, ident()));
2300 
2301             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2302                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2303             }
2304 
2305             if (token.kind == LT) {
2306                 lastTypeargsPos = token.pos;
2307                 t = typeArguments(t, true);
2308                 diamondFound = (mode &amp; DIAMOND) != 0;
2309             }
2310         }
2311         mode = oldmode;
2312         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2313             // handle type annotations for non primitive arrays
2314             if (newAnnotations.nonEmpty()) {
2315                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2316             }
2317 
2318             JCExpression e = arrayCreatorRest(newpos, t);
2319             if (diamondFound) {
2320                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2321                 return toP(F.at(newpos).Erroneous(List.of(e)));
2322             }
2323             else if (typeArgs != null) {
2324                 int pos = newpos;
2325                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2326                     // note: this should always happen but we should
2327                     // not rely on this as the parser is continuously
2328                     // modified to improve error recovery.
2329                     pos = typeArgs.head.pos;
2330                 }
2331                 setErrorEndPos(S.prevToken().endPos);
2332                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2333                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2334                 return toP(err);
2335             }
2336             return e;
2337         } else if (token.kind == LPAREN) {
2338             // handle type annotations for instantiations and anonymous classes
2339             if (newAnnotations.nonEmpty()) {
2340                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2341             }
2342             return classCreatorRest(newpos, null, typeArgs, t);
2343         } else {
2344             setErrorEndPos(token.pos);
2345             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2346             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2347             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2348         }
2349     }
2350 
2351     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2352      */
2353     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2354         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2355 
2356         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2357 
2358         if (newAnnotations.nonEmpty()) {
2359             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2360         }
2361 
2362         if (token.kind == LT) {
2363             int oldmode = mode;
2364             t = typeArguments(t, true);
2365             mode = oldmode;
2366         }
2367         return classCreatorRest(newpos, encl, typeArgs, t);
2368     }
2369 
2370     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2371      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2372      */
2373     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2374         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2375 
2376         accept(LBRACKET);
2377         if (token.kind == RBRACKET) {
2378             accept(RBRACKET);
2379             elemtype = bracketsOpt(elemtype, annos);
2380             if (token.kind == LBRACE) {
2381                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2382                 if (annos.nonEmpty()) {
2383                     // when an array initializer is present then
2384                     // the parsed annotations should target the
2385                     // new array tree
2386                     // bracketsOpt inserts the annotation in
2387                     // elemtype, and it needs to be corrected
2388                     //
2389                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2390                     assert annotated.annotations == annos;
2391                     na.annotations = annotated.annotations;
2392                     na.elemtype = annotated.underlyingType;
2393                 }
2394                 return na;
2395             } else {
2396                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2397                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2398             }
2399         } else {
2400             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2401 
2402             // maintain array dimension type annotations
2403             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2404             dimAnnotations.append(annos);
2405 
2406             dims.append(parseExpression());
2407             accept(RBRACKET);
2408             while (token.kind == LBRACKET
2409                     || token.kind == MONKEYS_AT) {
2410                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2411                 int pos = token.pos;
2412                 nextToken();
2413                 if (token.kind == RBRACKET) {
2414                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2415                 } else {
2416                     if (token.kind == RBRACKET) { // no dimension
2417                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2418                     } else {
2419                         dimAnnotations.append(maybeDimAnnos);
2420                         dims.append(parseExpression());
2421                         accept(RBRACKET);
2422                     }
2423                 }
2424             }
2425 
2426             List&lt;JCExpression&gt; elems = null;
2427             int errpos = token.pos;
2428 
2429             if (token.kind == LBRACE) {
2430                 elems = arrayInitializerElements(newpos, elemtype);
2431             }
2432 
2433             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2434             na.dimAnnotations = dimAnnotations.toList();
2435 
2436             if (elems != null) {
2437                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2438             }
2439 
2440             return na;
2441         }
2442     }
2443 
2444     /** ClassCreatorRest = Arguments [ClassBody]
2445      */
2446     JCNewClass classCreatorRest(int newpos,
2447                                   JCExpression encl,
2448                                   List&lt;JCExpression&gt; typeArgs,
2449                                   JCExpression t)
2450     {
2451         List&lt;JCExpression&gt; args = arguments();
2452         JCClassDecl body = null;
2453         if (token.kind == LBRACE) {
2454             int pos = token.pos;
2455             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2456             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2457             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2458         }
2459         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2460     }
2461 
2462     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2463      */
2464     JCExpression arrayInitializer(int newpos, JCExpression t) {
2465         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2466         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2467     }
2468 
2469     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2470         accept(LBRACE);
2471         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2472         if (token.kind == COMMA) {
2473             nextToken();
2474         } else if (token.kind != RBRACE) {
2475             elems.append(variableInitializer());
2476             while (token.kind == COMMA) {
2477                 nextToken();
2478                 if (token.kind == RBRACE) break;
2479                 elems.append(variableInitializer());
2480             }
2481         }
2482         accept(RBRACE);
2483         return elems.toList();
2484     }
2485 
2486     /** VariableInitializer = ArrayInitializer | Expression
2487      */
2488     public JCExpression variableInitializer() {
2489         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2490     }
2491 
2492     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2493      */
2494     JCExpression parExpression() {
2495         int pos = token.pos;
2496         accept(LPAREN);
2497         JCExpression t = parseExpression();
2498         accept(RPAREN);
2499         return toP(F.at(pos).Parens(t));
2500     }
2501 
2502     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2503      */
2504     JCBlock block(int pos, long flags) {
2505         accept(LBRACE);
2506         List&lt;JCStatement&gt; stats = blockStatements();
2507         JCBlock t = F.at(pos).Block(flags, stats);
2508         while (token.kind == CASE || token.kind == DEFAULT) {
2509             syntaxError(token.pos, Errors.Orphaned(token.kind));
2510             switchBlockStatementGroups();
2511         }
2512         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2513         // usually but not necessarily the last char of the last token.
2514         t.endpos = token.pos;
2515         accept(RBRACE);
2516         return toP(t);
2517     }
2518 
2519     public JCBlock block() {
2520         return block(token.pos, 0);
2521     }
2522 
2523     /** BlockStatements = { BlockStatement }
2524      *  BlockStatement  = LocalVariableDeclarationStatement
2525      *                  | ClassOrInterfaceOrEnumDeclaration
2526      *                  | [Ident &quot;:&quot;] Statement
2527      *  LocalVariableDeclarationStatement
2528      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2529      */
2530     @SuppressWarnings(&quot;fallthrough&quot;)
2531     List&lt;JCStatement&gt; blockStatements() {
2532         //todo: skip to anchor on error(?)
2533         int lastErrPos = -1;
2534         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2535         while (true) {
2536             List&lt;JCStatement&gt; stat = blockStatement();
2537             if (stat.isEmpty()) {
2538                 return stats.toList();
2539             } else {
2540                 // error recovery
2541                 if (token.pos == lastErrPos)
2542                     return stats.toList();
2543                 if (token.pos &lt;= endPosTable.errorEndPos) {
2544                     skip(false, true, true, true);
2545                     lastErrPos = token.pos;
2546                 }
2547                 stats.addAll(stat);
2548             }
2549         }
2550     }
2551 
2552     /*
2553      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2554      * this method will also recognize variable and class declarations (which are
2555      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2556      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2557      * and an error will be produced by this method.
2558      */
2559     JCStatement parseStatementAsBlock() {
2560         int pos = token.pos;
2561         List&lt;JCStatement&gt; stats = blockStatement();
2562         if (stats.isEmpty()) {
2563             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2564             return toP(F.at(pos).Exec(e));
2565         } else {
2566             JCStatement first = stats.head;
2567             Error error = null;
2568             switch (first.getTag()) {
2569             case CLASSDEF:
2570                 error = Errors.ClassNotAllowed;
2571                 break;
2572             case VARDEF:
2573                 error = Errors.VariableNotAllowed;
2574                 break;
2575             }
2576             if (error != null) {
2577                 log.error(DiagnosticFlag.SYNTAX, first, error);
2578                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2579                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2580             }
2581             return first;
2582         }
2583     }
2584 
2585     /**This method parses a statement appearing inside a block.
2586      */
2587     @SuppressWarnings(&quot;fallthrough&quot;)
2588     List&lt;JCStatement&gt; blockStatement() {
2589         //todo: skip to anchor on error(?)
2590         Comment dc;
2591         int pos = token.pos;
2592         switch (token.kind) {
2593         case RBRACE: case CASE: case DEFAULT: case EOF:
2594             return List.nil();
2595         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2596         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2597         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2598         case ASSERT:
2599             return List.of(parseSimpleStatement());
2600         case MONKEYS_AT:
2601         case FINAL: {
2602             dc = token.comment(CommentStyle.JAVADOC);
2603             JCModifiers mods = modifiersOpt();
2604             if (token.kind == INTERFACE ||
2605                 token.kind == CLASS ||
2606                 token.kind == ENUM ||
2607                 isRecordStart()) {
2608                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2609             } else {
2610                 JCExpression t = parseType(true);
2611                 return localVariableDeclarations(mods, t);
2612             }
2613         }
2614         case ABSTRACT: case STRICTFP: {
2615             dc = token.comment(CommentStyle.JAVADOC);
2616             JCModifiers mods = modifiersOpt();
2617             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2618         }
2619         case INTERFACE:
2620         case CLASS:
2621             dc = token.comment(CommentStyle.JAVADOC);
2622             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2623         case ENUM:
2624             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2625             dc = token.comment(CommentStyle.JAVADOC);
2626             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2627         case IDENTIFIER:
2628             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2629                 Token next = S.token(1);
2630                 boolean isYieldStatement;
2631                 switch (next.kind) {
2632                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2633                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2634                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2635                     case NEW: case SWITCH: case THIS: case SUPER:
2636                         isYieldStatement = true;
2637                         break;
2638                     case PLUSPLUS: case SUBSUB:
2639                         isYieldStatement = S.token(2).kind != SEMI;
2640                         break;
2641                     case LPAREN:
2642                         int lookahead = 2;
2643                         int balance = 1;
2644                         boolean hasComma = false;
2645                         Token l;
2646                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2647                             switch (l.kind) {
2648                                 case LPAREN: balance++; break;
2649                                 case RPAREN: balance--; break;
2650                                 case COMMA: if (balance == 1) hasComma = true; break;
2651                             }
2652                             lookahead++;
2653                         }
2654                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2655                         break;
2656                     case SEMI: //error recovery - this is not a valid statement:
2657                         isYieldStatement = true;
2658                         break;
2659                     default:
2660                         isYieldStatement = false;
2661                         break;
2662                 }
2663 
2664                 if (isYieldStatement) {
2665                     nextToken();
2666                     JCExpression t = term(EXPR);
2667                     accept(SEMI);
2668                     return List.of(toP(F.at(pos).Yield(t)));
2669                 }
2670 
2671                 //else intentional fall-through
2672             }
2673         }
2674         if (isRecordStart() &amp;&amp; allowRecords) {
2675             dc = token.comment(CommentStyle.JAVADOC);
2676             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2677         } else {
2678             Token prevToken = token;
2679             JCExpression t = term(EXPR | TYPE);
2680             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2681                 nextToken();
2682                 JCStatement stat = parseStatementAsBlock();
2683                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2684             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2685                 pos = token.pos;
2686                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2687                 F.at(pos);
2688                 return localVariableDeclarations(mods, t);
2689             } else {
2690                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2691                 t = checkExprStat(t);
2692                 accept(SEMI);
2693                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2694                 return List.of(expr);
2695             }
2696         }
2697     }
2698     //where
2699         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2700             ListBuffer&lt;JCStatement&gt; stats =
2701                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2702             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2703             accept(SEMI);
2704             storeEnd(stats.last(), S.prevToken().endPos);
2705             return stats.toList();
2706         }
2707 
2708     /** Statement =
2709      *       Block
2710      *     | IF ParExpression Statement [ELSE Statement]
2711      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2712      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2713      *     | WHILE ParExpression Statement
2714      *     | DO Statement WHILE ParExpression &quot;;&quot;
2715      *     | TRY Block ( Catches | [Catches] FinallyPart )
2716      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2717      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2718      *     | SYNCHRONIZED ParExpression Block
2719      *     | RETURN [Expression] &quot;;&quot;
2720      *     | THROW Expression &quot;;&quot;
2721      *     | BREAK [Ident] &quot;;&quot;
2722      *     | CONTINUE [Ident] &quot;;&quot;
2723      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2724      *     | &quot;;&quot;
2725      */
2726     public JCStatement parseSimpleStatement() {
2727         int pos = token.pos;
2728         switch (token.kind) {
2729         case LBRACE:
2730             return block();
2731         case IF: {
2732             nextToken();
2733             JCExpression cond = parExpression();
2734             JCStatement thenpart = parseStatementAsBlock();
2735             JCStatement elsepart = null;
2736             if (token.kind == ELSE) {
2737                 nextToken();
2738                 elsepart = parseStatementAsBlock();
2739             }
2740             return F.at(pos).If(cond, thenpart, elsepart);
2741         }
2742         case FOR: {
2743             nextToken();
2744             accept(LPAREN);
2745             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2746             if (inits.length() == 1 &amp;&amp;
2747                 inits.head.hasTag(VARDEF) &amp;&amp;
2748                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2749                 token.kind == COLON) {
2750                 JCVariableDecl var = (JCVariableDecl)inits.head;
2751                 accept(COLON);
2752                 JCExpression expr = parseExpression();
2753                 accept(RPAREN);
2754                 JCStatement body = parseStatementAsBlock();
2755                 return F.at(pos).ForeachLoop(var, expr, body);
2756             } else {
2757                 accept(SEMI);
2758                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2759                 accept(SEMI);
2760                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2761                 accept(RPAREN);
2762                 JCStatement body = parseStatementAsBlock();
2763                 return F.at(pos).ForLoop(inits, cond, steps, body);
2764             }
2765         }
2766         case WHILE: {
2767             nextToken();
2768             JCExpression cond = parExpression();
2769             JCStatement body = parseStatementAsBlock();
2770             return F.at(pos).WhileLoop(cond, body);
2771         }
2772         case DO: {
2773             nextToken();
2774             JCStatement body = parseStatementAsBlock();
2775             accept(WHILE);
2776             JCExpression cond = parExpression();
2777             accept(SEMI);
2778             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2779             return t;
2780         }
2781         case TRY: {
2782             nextToken();
2783             List&lt;JCTree&gt; resources = List.nil();
2784             if (token.kind == LPAREN) {
2785                 nextToken();
2786                 resources = resources();
2787                 accept(RPAREN);
2788             }
2789             JCBlock body = block();
2790             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2791             JCBlock finalizer = null;
2792             if (token.kind == CATCH || token.kind == FINALLY) {
2793                 while (token.kind == CATCH) catchers.append(catchClause());
2794                 if (token.kind == FINALLY) {
2795                     nextToken();
2796                     finalizer = block();
2797                 }
2798             } else {
2799                 if (resources.isEmpty()) {
2800                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2801                 }
2802             }
2803             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2804         }
2805         case SWITCH: {
2806             nextToken();
2807             JCExpression selector = parExpression();
2808             accept(LBRACE);
2809             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2810             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2811             accept(RBRACE);
2812             return t;
2813         }
2814         case SYNCHRONIZED: {
2815             nextToken();
2816             JCExpression lock = parExpression();
2817             JCBlock body = block();
2818             return F.at(pos).Synchronized(lock, body);
2819         }
2820         case RETURN: {
2821             nextToken();
2822             JCExpression result = token.kind == SEMI ? null : parseExpression();
2823             accept(SEMI);
2824             JCReturn t = toP(F.at(pos).Return(result));
2825             return t;
2826         }
2827         case THROW: {
2828             nextToken();
2829             JCExpression exc = parseExpression();
2830             accept(SEMI);
2831             JCThrow t = toP(F.at(pos).Throw(exc));
2832             return t;
2833         }
2834         case BREAK: {
2835             nextToken();
2836             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2837             accept(SEMI);
2838             JCBreak t = toP(F.at(pos).Break(label));
2839             return t;
2840         }
2841         case CONTINUE: {
2842             nextToken();
2843             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2844             accept(SEMI);
2845             JCContinue t =  toP(F.at(pos).Continue(label));
2846             return t;
2847         }
2848         case SEMI:
2849             nextToken();
2850             return toP(F.at(pos).Skip());
2851         case ELSE:
2852             int elsePos = token.pos;
2853             nextToken();
2854             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2855         case FINALLY:
2856             int finallyPos = token.pos;
2857             nextToken();
2858             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2859         case CATCH:
2860             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2861         case ASSERT: {
2862             nextToken();
2863             JCExpression assertion = parseExpression();
2864             JCExpression message = null;
2865             if (token.kind == COLON) {
2866                 nextToken();
2867                 message = parseExpression();
2868             }
2869             accept(SEMI);
2870             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2871             return t;
2872         }
2873         default:
2874             Assert.error();
2875             return null;
2876         }
2877     }
2878 
2879     @Override
2880     public JCStatement parseStatement() {
2881         return parseStatementAsBlock();
2882     }
2883 
2884     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2885         int errPos = S.errPos();
2886         JCTree stm = action.doRecover(this);
2887         S.errPos(errPos);
2888         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2889     }
2890 
2891     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2892      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2893      */
2894     protected JCCatch catchClause() {
2895         int pos = token.pos;
2896         accept(CATCH);
2897         accept(LPAREN);
2898         JCModifiers mods = optFinal(Flags.PARAMETER);
2899         List&lt;JCExpression&gt; catchTypes = catchTypes();
2900         JCExpression paramType = catchTypes.size() &gt; 1 ?
2901                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2902                 catchTypes.head;
2903         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2904         accept(RPAREN);
2905         JCBlock body = block();
2906         return F.at(pos).Catch(formal, body);
2907     }
2908 
2909     List&lt;JCExpression&gt; catchTypes() {
2910         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2911         catchTypes.add(parseType());
2912         while (token.kind == BAR) {
2913             nextToken();
2914             // Instead of qualident this is now parseType.
2915             // But would that allow too much, e.g. arrays or generics?
2916             catchTypes.add(parseType());
2917         }
2918         return catchTypes.toList();
2919     }
2920 
2921     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2922      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2923      *  SwitchLabel = CASE Pattern &quot;:&quot; | DEFAULT &quot;:&quot;
2924      */
2925     List&lt;JCCase&gt; switchBlockStatementGroups() {
2926         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2927         while (true) {
2928             int pos = token.pos;
2929             switch (token.kind) {
2930             case CASE:
2931             case DEFAULT:
2932                 cases.appendList(switchBlockStatementGroup());
2933                 break;
2934             case RBRACE: case EOF:
2935                 return cases.toList();
2936             default:
2937                 nextToken(); // to ensure progress
2938                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2939             }
2940         }
2941     }
2942 
2943     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2944         int pos = token.pos;
2945         List&lt;JCStatement&gt; stats;
2946         JCCase c;
2947         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2948         switch (token.kind) {
2949         case CASE: {
2950             nextToken();
2951             ListBuffer&lt;JCPattern&gt; pats = new ListBuffer&lt;&gt;();
2952             while (true) {
2953                 pats.append(parsePattern());
2954                 if (token.kind != COMMA) break;
2955                 nextToken();
2956                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2957             };
2958             CaseTree.CaseKind caseKind;
2959             JCTree body = null;
2960             if (token.kind == ARROW) {
2961                 checkSourceLevel(Feature.SWITCH_RULE);
2962                 accept(ARROW);
2963                 caseKind = JCCase.RULE;
2964                 JCStatement statement = parseStatementAsBlock();
2965                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2966                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2967                 }
2968                 stats = List.of(statement);
2969                 body = stats.head;
2970             } else {
2971                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2972                 caseKind = JCCase.STATEMENT;
2973                 stats = blockStatements();
2974             }
2975             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2976             if (stats.isEmpty())
2977                 storeEnd(c, S.prevToken().endPos);
2978             return cases.append(c).toList();
2979         }
2980         case DEFAULT: {
2981             nextToken();
2982             CaseTree.CaseKind caseKind;
2983             JCTree body = null;
2984             if (token.kind == ARROW) {
2985                 checkSourceLevel(Feature.SWITCH_RULE);
2986                 accept(ARROW);
2987                 caseKind = JCCase.RULE;
2988                 JCStatement statement = parseStatementAsBlock();
2989                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2990                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2991                 }
2992                 stats = List.of(statement);
2993                 body = stats.head;
2994             } else {
2995                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2996                 caseKind = JCCase.STATEMENT;
2997                 stats = blockStatements();
2998             }
2999             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3000             if (stats.isEmpty())
3001                 storeEnd(c, S.prevToken().endPos);
3002             return cases.append(c).toList();
3003         }
3004         }
3005         throw new AssertionError(&quot;should not reach here&quot;);
3006     }
3007 
3008     /** MoreStatementExpressions = { COMMA StatementExpression }
3009      */
3010     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3011                                                                     JCExpression first,
3012                                                                     T stats) {
3013         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3014         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3015         while (token.kind == COMMA) {
3016             nextToken();
3017             pos = token.pos;
3018             JCExpression t = parseExpression();
3019             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3020             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3021         }
3022         return stats;
3023     }
3024 
3025     /** ForInit = StatementExpression MoreStatementExpressions
3026      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3027      */
3028     List&lt;JCStatement&gt; forInit() {
3029         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3030         int pos = token.pos;
3031         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3032             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3033         } else {
3034             JCExpression t = term(EXPR | TYPE);
3035             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3036                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
3037             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3038                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3039                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3040             } else {
3041                 return moreStatementExpressions(pos, t, stats).toList();
3042             }
3043         }
3044     }
3045 
3046     /** ForUpdate = StatementExpression MoreStatementExpressions
3047      */
3048     List&lt;JCExpressionStatement&gt; forUpdate() {
3049         return moreStatementExpressions(token.pos,
3050                                         parseExpression(),
3051                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3052     }
3053 
3054     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3055      *
3056      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3057      */
3058     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3059         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3060         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3061         int prevmode = mode;
3062         while (token.kind == MONKEYS_AT) {
3063             int pos = token.pos;
3064             nextToken();
3065             buf.append(annotation(pos, kind));
3066         }
3067         lastmode = mode;
3068         mode = prevmode;
3069         List&lt;JCAnnotation&gt; annotations = buf.toList();
3070 
3071         return annotations;
3072     }
3073 
3074     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3075         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3076         return annotations;
3077     }
3078 
3079     /** ModifiersOpt = { Modifier }
3080      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3081      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3082      *           | &quot;@&quot; Annotation
3083      */
3084     protected JCModifiers modifiersOpt() {
3085         return modifiersOpt(null);
3086     }
3087     protected JCModifiers modifiersOpt(JCModifiers partial) {
3088         long flags;
3089         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3090         int pos;
3091         if (partial == null) {
3092             flags = 0;
3093             pos = token.pos;
3094         } else {
3095             flags = partial.flags;
3096             annotations.appendList(partial.annotations);
3097             pos = partial.pos;
3098         }
3099         if (token.deprecatedFlag()) {
3100             flags |= Flags.DEPRECATED;
3101         }
3102         int lastPos;
3103     loop:
3104         while (true) {
3105             long flag;
3106             switch (token.kind) {
3107             case PRIVATE     : flag = Flags.PRIVATE; break;
3108             case PROTECTED   : flag = Flags.PROTECTED; break;
3109             case PUBLIC      : flag = Flags.PUBLIC; break;
3110             case STATIC      : flag = Flags.STATIC; break;
3111             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3112             case FINAL       : flag = Flags.FINAL; break;
3113             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3114             case NATIVE      : flag = Flags.NATIVE; break;
3115             case VOLATILE    : flag = Flags.VOLATILE; break;
3116             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3117             case STRICTFP    : flag = Flags.STRICTFP; break;
3118             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3119             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3120             case ERROR       : flag = 0; nextToken(); break;
3121             default: break loop;
3122             }
3123             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3124             lastPos = token.pos;
3125             nextToken();
3126             if (flag == Flags.ANNOTATION) {
3127                 if (token.kind != INTERFACE) {
3128                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3129                     // if first modifier is an annotation, set pos to annotation&#39;s.
3130                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3131                         pos = ann.pos;
3132                     annotations.append(ann);
3133                     flag = 0;
3134                 }
3135             }
3136             flags |= flag;
3137         }
3138         switch (token.kind) {
3139         case ENUM: flags |= Flags.ENUM; break;
3140         case INTERFACE: flags |= Flags.INTERFACE; break;
3141         default: break;
3142         }
3143 
3144         /* A modifiers tree with no modifier tokens or annotations
3145          * has no text position. */
3146         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3147             pos = Position.NOPOS;
3148 
3149         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3150         if (pos != Position.NOPOS)
3151             storeEnd(mods, S.prevToken().endPos);
3152         return mods;
3153     }
3154 
3155     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3156      *
3157      * @param pos position of &quot;@&quot; token
3158      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3159      */
3160     JCAnnotation annotation(int pos, Tag kind) {
3161         // accept(AT); // AT consumed by caller
3162         if (kind == Tag.TYPE_ANNOTATION) {
3163             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3164         }
3165         JCTree ident = qualident(false);
3166         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3167         JCAnnotation ann;
3168         if (kind == Tag.ANNOTATION) {
3169             ann = F.at(pos).Annotation(ident, fieldValues);
3170         } else if (kind == Tag.TYPE_ANNOTATION) {
3171             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3172         } else {
3173             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3174         }
3175 
3176         storeEnd(ann, S.prevToken().endPos);
3177         return ann;
3178     }
3179 
3180     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3181         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3182     }
3183 
3184     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3185     List&lt;JCExpression&gt; annotationFieldValues() {
3186         accept(LPAREN);
3187         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3188         if (token.kind != RPAREN) {
3189             buf.append(annotationFieldValue());
3190             while (token.kind == COMMA) {
3191                 nextToken();
3192                 buf.append(annotationFieldValue());
3193             }
3194         }
3195         accept(RPAREN);
3196         return buf.toList();
3197     }
3198 
3199     /** AnnotationFieldValue    = AnnotationValue
3200      *                          | Identifier &quot;=&quot; AnnotationValue
3201      */
3202     JCExpression annotationFieldValue() {
3203         if (LAX_IDENTIFIER.accepts(token.kind)) {
3204             selectExprMode();
3205             JCExpression t1 = term1();
3206             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3207                 int pos = token.pos;
3208                 accept(EQ);
3209                 JCExpression v = annotationValue();
3210                 return toP(F.at(pos).Assign(t1, v));
3211             } else {
3212                 return t1;
3213             }
3214         }
3215         return annotationValue();
3216     }
3217 
3218     /* AnnotationValue          = ConditionalExpression
3219      *                          | Annotation
3220      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3221      */
3222     JCExpression annotationValue() {
3223         int pos;
3224         switch (token.kind) {
3225         case MONKEYS_AT:
3226             pos = token.pos;
3227             nextToken();
3228             return annotation(pos, Tag.ANNOTATION);
3229         case LBRACE:
3230             pos = token.pos;
3231             accept(LBRACE);
3232             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3233             if (token.kind == COMMA) {
3234                 nextToken();
3235             } else if (token.kind != RBRACE) {
3236                 buf.append(annotationValue());
3237                 while (token.kind == COMMA) {
3238                     nextToken();
3239                     if (token.kind == RBRACE) break;
3240                     buf.append(annotationValue());
3241                 }
3242             }
3243             accept(RBRACE);
3244             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3245         default:
3246             selectExprMode();
3247             return term1();
3248         }
3249     }
3250 
3251     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3252      */
3253     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3254                                                                          JCExpression type,
3255                                                                          T vdefs,
3256                                                                          boolean localDecl)
3257     {
3258         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3259     }
3260 
3261     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3262      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3263      *
3264      *  @param reqInit  Is an initializer always required?
3265      *  @param dc       The documentation comment for the variable declarations, or null.
3266      */
3267     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3268                                                                      JCModifiers mods,
3269                                                                      JCExpression type,
3270                                                                      Name name,
3271                                                                      boolean reqInit,
3272                                                                      Comment dc,
3273                                                                      T vdefs,
3274                                                                      boolean localDecl)
3275     {
3276         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3277         vdefs.append(head);
3278         while (token.kind == COMMA) {
3279             // All but last of multiple declarators subsume a comma
3280             storeEnd((JCTree)vdefs.last(), token.endPos);
3281             nextToken();
3282             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3283         }
3284         return vdefs;
3285     }
3286 
3287     /** VariableDeclarator = Ident VariableDeclaratorRest
3288      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3289      */
3290     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3291         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3292     }
3293 
3294     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3295      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3296      *
3297      *  @param reqInit  Is an initializer always required?
3298      *  @param dc       The documentation comment for the variable declarations, or null.
3299      */
3300     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3301                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3302         type = bracketsOpt(type);
3303         JCExpression init = null;
3304         if (token.kind == EQ) {
3305             nextToken();
3306             init = variableInitializer();
3307         }
3308         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3309         JCTree elemType = TreeInfo.innermostType(type, true);
3310         int startPos = Position.NOPOS;
3311         if (elemType.hasTag(IDENT)) {
3312             Name typeName = ((JCIdent)elemType).name;
3313             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3314                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3315                     //error - &#39;var&#39; and arrays
3316                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3317                 } else {
3318                     if(compound)
3319                         //error - &#39;var&#39; in compound local var decl
3320                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3321                     startPos = TreeInfo.getStartPos(mods);
3322                     if (startPos == Position.NOPOS)
3323                         startPos = TreeInfo.getStartPos(type);
3324                     //implicit type
3325                     type = null;
3326                 }
3327             }
3328         }
3329         JCVariableDecl result =
3330             toP(F.at(pos).VarDef(mods, name, type, init));
3331         attach(result, dc);
3332         result.startPos = startPos;
3333         return result;
3334     }
3335 
3336     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3337         switch (e.getTag()) {
3338             case IDENT:
3339                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3340             case TYPEARRAY:
3341                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3342             default:
3343                 return null;
3344         }
3345     }
3346 
3347     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3348         if (name == names.var) {
3349             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3350                 return Source.JDK10;
3351             } else if (shouldWarn) {
3352                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3353             }
3354         }
3355         if (name == names.yield) {
3356             if (allowYieldStatement) {
3357                 return Source.JDK14;
3358             } else if (shouldWarn) {
3359                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3360             }
3361         }
3362         if (name == names.record) {
3363             if (allowRecords) {
3364                 return Source.JDK14;
3365             } else if (shouldWarn) {
3366                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3367             }
3368         }
3369         return null;
3370     }
3371 
3372     /** VariableDeclaratorId = Ident BracketsOpt
3373      */
3374     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3375         return variableDeclaratorId(mods, type, false);
3376     }
3377     //where
3378     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3379         int pos = token.pos;
3380         Name name;
3381         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3382             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3383             name = token.name();
3384             nextToken();
3385         } else {
3386             if (allowThisIdent ||
3387                 !lambdaParameter ||
3388                 LAX_IDENTIFIER.accepts(token.kind) ||
3389                 mods.flags != Flags.PARAMETER ||
3390                 mods.annotations.nonEmpty()) {
3391                 JCExpression pn = qualident(false);
3392                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3393                     name = ((JCIdent)pn).name;
3394                 } else {
3395                     if (allowThisIdent) {
3396                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3397                             log.error(token.pos, Errors.VarargsAndReceiver);
3398                         }
3399                         if (token.kind == LBRACKET) {
3400                             log.error(token.pos, Errors.ArrayAndReceiver);
3401                         }
3402                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3403                             log.error(token.pos, Errors.WrongReceiver);
3404                         }
3405                     }
3406                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3407                 }
3408             } else {
3409                 /** if it is a lambda parameter and the token kind is not an identifier,
3410                  *  and there are no modifiers or annotations, then this means that the compiler
3411                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3412                  *  var or explicit parameters. So we assign the error name to the parameter name
3413                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3414                  *  a higher level.
3415                  */
3416                 name = names.empty;
3417             }
3418         }
3419         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3420                 token.kind == LBRACKET) {
3421             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3422         }
3423         type = bracketsOpt(type);
3424 
3425         return toP(F.at(pos).VarDef(mods, name, type, null));
3426     }
3427 
3428     /** Resources = Resource { &quot;;&quot; Resources }
3429      */
3430     List&lt;JCTree&gt; resources() {
3431         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3432         defs.append(resource());
3433         while (token.kind == SEMI) {
3434             // All but last of multiple declarators must subsume a semicolon
3435             storeEnd(defs.last(), token.endPos);
3436             int semiColonPos = token.pos;
3437             nextToken();
3438             if (token.kind == RPAREN) { // Optional trailing semicolon
3439                                        // after last resource
3440                 break;
3441             }
3442             defs.append(resource());
3443         }
3444         return defs.toList();
3445     }
3446 
3447     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3448      *           | Expression
3449      */
3450     protected JCTree resource() {
3451         int startPos = token.pos;
3452         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3453             JCModifiers mods = optFinal(Flags.FINAL);
3454             JCExpression t = parseType(true);
3455             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3456         }
3457         JCExpression t = term(EXPR | TYPE);
3458         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3459             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3460             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3461         } else {
3462             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3463             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3464                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3465             }
3466 
3467             return t;
3468         }
3469     }
3470 
3471     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3472      */
3473     public JCTree.JCCompilationUnit parseCompilationUnit() {
3474         Token firstToken = token;
3475         JCModifiers mods = null;
3476         boolean consumedToplevelDoc = false;
3477         boolean seenImport = false;
3478         boolean seenPackage = false;
3479         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3480         if (token.kind == MONKEYS_AT)
3481             mods = modifiersOpt();
3482 
3483         if (token.kind == PACKAGE) {
3484             int packagePos = token.pos;
3485             List&lt;JCAnnotation&gt; annotations = List.nil();
3486             seenPackage = true;
3487             if (mods != null) {
3488                 checkNoMods(mods.flags);
3489                 annotations = mods.annotations;
3490                 mods = null;
3491             }
3492             nextToken();
3493             JCExpression pid = qualident(false);
3494             accept(SEMI);
3495             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3496             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3497             consumedToplevelDoc = true;
3498             defs.append(pd);
3499         }
3500 
3501         boolean checkForImports = true;
3502         boolean firstTypeDecl = true;
3503         while (token.kind != EOF) {
3504             if (token.pos &lt;= endPosTable.errorEndPos) {
3505                 // error recovery
3506                 skip(checkForImports, false, false, false);
3507                 if (token.kind == EOF)
3508                     break;
3509             }
3510             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3511                 seenImport = true;
3512                 defs.append(importDeclaration());
3513             } else {
3514                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3515                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3516                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3517                     consumedToplevelDoc = true;
3518                 }
3519                 if (mods != null || token.kind != SEMI)
3520                     mods = modifiersOpt(mods);
3521                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3522                     ModuleKind kind = ModuleKind.STRONG;
3523                     if (token.name() == names.open) {
3524                         kind = ModuleKind.OPEN;
3525                         nextToken();
3526                     }
3527                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3528                         if (mods != null) {
3529                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3530                         }
3531                         defs.append(moduleDecl(mods, kind, docComment));
3532                         consumedToplevelDoc = true;
3533                         break;
3534                     } else if (kind != ModuleKind.STRONG) {
3535                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3536                     }
3537                 }
3538                 JCTree def = typeDeclaration(mods, docComment);
3539                 if (def instanceof JCExpressionStatement)
3540                     def = ((JCExpressionStatement)def).expr;
3541                 defs.append(def);
3542                 if (def instanceof JCClassDecl)
3543                     checkForImports = false;
3544                 mods = null;
3545                 firstTypeDecl = false;
3546             }
3547         }
3548         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3549         if (!consumedToplevelDoc)
3550             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3551         if (defs.isEmpty())
3552             storeEnd(toplevel, S.prevToken().endPos);
3553         if (keepDocComments)
3554             toplevel.docComments = docComments;
3555         if (keepLineMap)
3556             toplevel.lineMap = S.getLineMap();
3557         this.endPosTable.setParser(null); // remove reference to parser
3558         toplevel.endPositions = this.endPosTable;
3559         return toplevel;
3560     }
3561 
3562     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3563         int pos = token.pos;
3564         checkSourceLevel(Feature.MODULES);
3565 
3566         nextToken();
3567         JCExpression name = qualident(false);
3568         List&lt;JCDirective&gt; directives = null;
3569 
3570         accept(LBRACE);
3571         directives = moduleDirectiveList();
3572         accept(RBRACE);
3573         accept(EOF);
3574 
3575         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3576         attach(result, dc);
3577         return result;
3578     }
3579 
3580     List&lt;JCDirective&gt; moduleDirectiveList() {
3581         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3582         while (token.kind == IDENTIFIER) {
3583             int pos = token.pos;
3584             if (token.name() == names.requires) {
3585                 nextToken();
3586                 boolean isTransitive = false;
3587                 boolean isStaticPhase = false;
3588             loop:
3589                 while (true) {
3590                     switch (token.kind) {
3591                         case IDENTIFIER:
3592                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3593                                 Token t1 = S.token(1);
3594                                 if (t1.kind == SEMI || t1.kind == DOT) {
3595                                     break loop;
3596                                 }
3597                                 isTransitive = true;
3598                                 break;
3599                             } else {
3600                                 break loop;
3601                             }
3602                         case STATIC:
3603                             if (isStaticPhase) {
3604                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3605                             }
3606                             isStaticPhase = true;
3607                             break;
3608                         default:
3609                             break loop;
3610                     }
3611                     nextToken();
3612                 }
3613                 JCExpression moduleName = qualident(false);
3614                 accept(SEMI);
3615                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3616             } else if (token.name() == names.exports || token.name() == names.opens) {
3617                 boolean exports = token.name() == names.exports;
3618                 nextToken();
3619                 JCExpression pkgName = qualident(false);
3620                 List&lt;JCExpression&gt; moduleNames = null;
3621                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3622                     nextToken();
3623                     moduleNames = qualidentList(false);
3624                 }
3625                 accept(SEMI);
3626                 JCDirective d;
3627                 if (exports) {
3628                     d = F.at(pos).Exports(pkgName, moduleNames);
3629                 } else {
3630                     d = F.at(pos).Opens(pkgName, moduleNames);
3631                 }
3632                 defs.append(toP(d));
3633             } else if (token.name() == names.provides) {
3634                 nextToken();
3635                 JCExpression serviceName = qualident(false);
3636                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3637                     nextToken();
3638                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3639                     accept(SEMI);
3640                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3641                 } else {
3642                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3643                     skip(false, false, false, false);
3644                 }
3645             } else if (token.name() == names.uses) {
3646                 nextToken();
3647                 JCExpression service = qualident(false);
3648                 accept(SEMI);
3649                 defs.append(toP(F.at(pos).Uses(service)));
3650             } else {
3651                 setErrorEndPos(pos);
3652                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3653                 break;
3654             }
3655         }
3656         return defs.toList();
3657     }
3658 
3659     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3660      */
3661     protected JCTree importDeclaration() {
3662         int pos = token.pos;
3663         nextToken();
3664         boolean importStatic = false;
3665         if (token.kind == STATIC) {
3666             importStatic = true;
3667             nextToken();
3668         }
3669         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3670         do {
3671             int pos1 = token.pos;
3672             accept(DOT);
3673             if (token.kind == STAR) {
3674                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3675                 nextToken();
3676                 break;
3677             } else {
3678                 pid = toP(F.at(pos1).Select(pid, ident()));
3679             }
3680         } while (token.kind == DOT);
3681         accept(SEMI);
3682         return toP(F.at(pos).Import(pid, importStatic));
3683     }
3684 
3685     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3686      *                  | &quot;;&quot;
3687      */
3688     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3689         int pos = token.pos;
3690         if (mods == null &amp;&amp; token.kind == SEMI) {
3691             nextToken();
3692             return toP(F.at(pos).Skip());
3693         } else {
3694             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3695         }
3696     }
3697 
3698     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3699      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3700      *  @param mods     Any modifiers starting the class or interface declaration
3701      *  @param dc       The documentation comment for the class, or null.
3702      */
3703     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3704         if (token.kind == CLASS) {
3705             return classDeclaration(mods, dc);
3706         } if (isRecordStart()) {
3707             return recordDeclaration(mods, dc);
3708         } else if (token.kind == INTERFACE) {
3709             return interfaceDeclaration(mods, dc);
3710         } else if (token.kind == ENUM) {
3711             return enumDeclaration(mods, dc);
3712         } else {
3713             int pos = token.pos;
3714             List&lt;JCTree&gt; errs;
3715             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3716                 checkSourceLevel(Feature.RECORDS);
3717                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3718                 return toP(F.Exec(erroneousTree));
3719             } else {
3720                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3721                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3722                     setErrorEndPos(token.pos);
3723                 } else {
3724                     errs = List.of(mods);
3725                 }
3726                 final JCErroneous erroneousTree;
3727                 if (parseModuleInfo) {
3728                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3729                 } else {
3730                     if (allowRecords) {
3731                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3732                     } else {
3733                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3734                     }
3735                 }
3736                 return toP(F.Exec(erroneousTree));
3737             }
3738         }
3739     }
3740 
3741     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3742      *                     [IMPLEMENTS TypeList] ClassBody
3743      *  @param mods    The modifiers starting the class declaration
3744      *  @param dc       The documentation comment for the class, or null.
3745      */
3746     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3747         int pos = token.pos;
3748         accept(CLASS);
3749         Name name = typeName();
3750 
3751         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3752 
3753         JCExpression extending = null;
3754         if (token.kind == EXTENDS) {
3755             nextToken();
3756             extending = parseType();
3757         }
3758         List&lt;JCExpression&gt; implementing = List.nil();
3759         if (token.kind == IMPLEMENTS) {
3760             nextToken();
3761             implementing = typeList();
3762         }
3763         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3764         JCClassDecl result = toP(F.at(pos).ClassDef(
3765             mods, name, typarams, extending, implementing, defs));
3766         attach(result, dc);
3767         return result;
3768     }
3769 
3770     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3771         int pos = token.pos;
3772         nextToken();
3773         mods.flags |= Flags.RECORD;
3774         Name name = typeName();
3775 
3776         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3777 
3778         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3779 
3780         List&lt;JCExpression&gt; implementing = List.nil();
3781         if (token.kind == IMPLEMENTS) {
3782             nextToken();
3783             implementing = typeList();
3784         }
3785         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3786         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3787         for (JCVariableDecl field : headerFields) {
3788             fields.add(field);
3789         }
3790         for (JCTree def : defs) {
3791             if (def.hasTag(METHODDEF)) {
3792                 JCMethodDecl methDef = (JCMethodDecl) def;
3793                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3794                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3795                     for (JCVariableDecl param : headerFields) {
3796                         tmpParams.add(F.at(param)
3797                                 // we will get flags plus annotations from the record component
3798                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3799                                 param.name, param.vartype, null));
3800                     }
3801                     methDef.params = tmpParams.toList();
3802                 }
3803             }
3804         }
3805         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3806             JCVariableDecl field = fields.get(i);
3807             defs = defs.prepend(field);
3808         }
3809         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3810         attach(result, dc);
3811         return result;
3812     }
3813 
3814     Name typeName() {
3815         int pos = token.pos;
3816         Name name = ident();
3817         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3818         if (source != null) {
3819             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3820         }
3821         return name;
3822     }
3823 
3824     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3825      *                         [EXTENDS TypeList] InterfaceBody
3826      *  @param mods    The modifiers starting the interface declaration
3827      *  @param dc       The documentation comment for the interface, or null.
3828      */
3829     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3830         int pos = token.pos;
3831         accept(INTERFACE);
3832 
3833         Name name = typeName();
3834 
3835         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3836 
3837         List&lt;JCExpression&gt; extending = List.nil();
3838         if (token.kind == EXTENDS) {
3839             nextToken();
3840             extending = typeList();
3841         }
3842         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3843         JCClassDecl result = toP(F.at(pos).ClassDef(
3844             mods, name, typarams, null, extending, defs));
3845         attach(result, dc);
3846         return result;
3847     }
3848 
3849     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3850      *  @param mods    The modifiers starting the enum declaration
3851      *  @param dc       The documentation comment for the enum, or null.
3852      */
3853     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3854         int pos = token.pos;
3855         accept(ENUM);
3856 
3857         Name name = typeName();
3858 
3859         List&lt;JCExpression&gt; implementing = List.nil();
3860         if (token.kind == IMPLEMENTS) {
3861             nextToken();
3862             implementing = typeList();
3863         }
3864 
3865         List&lt;JCTree&gt; defs = enumBody(name);
3866         mods.flags |= Flags.ENUM;
3867         JCClassDecl result = toP(F.at(pos).
3868             ClassDef(mods, name, List.nil(),
3869                      null, implementing, defs));
3870         attach(result, dc);
3871         return result;
3872     }
3873 
3874     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3875      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3876      */
3877     List&lt;JCTree&gt; enumBody(Name enumName) {
3878         accept(LBRACE);
3879         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3880         boolean wasSemi = false;
3881         boolean hasStructuralErrors = false;
3882         boolean wasError = false;
3883         if (token.kind == COMMA) {
3884             nextToken();
3885             if (token.kind == SEMI) {
3886                 wasSemi = true;
3887                 nextToken();
3888             } else if (token.kind != RBRACE) {
3889                 reportSyntaxError(S.prevToken().endPos,
3890                                   Errors.Expected2(RBRACE, SEMI));
3891                 wasError = true;
3892             }
3893         }
3894         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3895             if (token.kind == SEMI) {
3896                 accept(SEMI);
3897                 wasSemi = true;
3898                 if (token.kind == RBRACE || token.kind == EOF) break;
3899             }
3900             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3901             if (memberType == EnumeratorEstimate.UNKNOWN) {
3902                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3903                                      : EnumeratorEstimate.ENUMERATOR;
3904             }
3905             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3906                 wasError = false;
3907                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3908                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3909                     hasStructuralErrors = true;
3910                 }
3911                 defs.append(enumeratorDeclaration(enumName));
3912                 if (token.pos &lt;= endPosTable.errorEndPos) {
3913                     // error recovery
3914                    skip(false, true, true, false);
3915                 } else {
3916                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
3917                         if (token.kind == COMMA) {
3918                             nextToken();
3919                         } else {
3920                             setErrorEndPos(token.pos);
3921                             reportSyntaxError(S.prevToken().endPos,
3922                                               Errors.Expected3(COMMA, RBRACE, SEMI));
3923                             wasError = true;
3924                         }
3925                     }
3926                 }
3927             } else {
3928                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
3929                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
3930                     hasStructuralErrors = true;
3931                 }
3932                 wasError = false;
3933                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
3934                                                                 false, false));
3935                 if (token.pos &lt;= endPosTable.errorEndPos) {
3936                     // error recovery
3937                    skip(false, true, true, false);
3938                 }
3939             }
3940         }
3941         accept(RBRACE);
3942         return defs.toList();
3943     }
3944 
3945     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
3946         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {
3947             Token next = S.token(1);
3948             switch (next.kind) {
3949                 case LPAREN: case LBRACE: case COMMA: case SEMI:
3950                     return EnumeratorEstimate.ENUMERATOR;
3951             }
3952         }
3953         switch (token.kind) {
3954             case IDENTIFIER: case MONKEYS_AT: case LT:
3955                 return EnumeratorEstimate.UNKNOWN;
3956             default:
3957                 return EnumeratorEstimate.MEMBER;
3958         }
3959     }
3960 
3961     private enum EnumeratorEstimate {
3962         ENUMERATOR,
3963         MEMBER,
3964         UNKNOWN;
3965     }
3966 
3967     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3968      */
3969     JCTree enumeratorDeclaration(Name enumName) {
3970         Comment dc = token.comment(CommentStyle.JAVADOC);
3971         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3972         if (token.deprecatedFlag()) {
3973             flags |= Flags.DEPRECATED;
3974         }
3975         int pos = token.pos;
3976         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3977         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3978         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3979         int identPos = token.pos;
3980         Name name = ident();
3981         int createPos = token.pos;
3982         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3983             ? arguments() : List.nil();
3984         JCClassDecl body = null;
3985         if (token.kind == LBRACE) {
3986             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
3987             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
3988             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3989         }
3990         if (args.isEmpty() &amp;&amp; body == null)
3991             createPos = identPos;
3992         JCIdent ident = F.at(identPos).Ident(enumName);
3993         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
3994         if (createPos != identPos)
3995             storeEnd(create, S.prevToken().endPos);
3996         ident = F.at(identPos).Ident(enumName);
3997         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
3998         attach(result, dc);
3999         return result;
4000     }
4001 
4002     /** TypeList = Type {&quot;,&quot; Type}
4003      */
4004     List&lt;JCExpression&gt; typeList() {
4005         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4006         ts.append(parseType());
4007         while (token.kind == COMMA) {
4008             nextToken();
4009             ts.append(parseType());
4010         }
4011         return ts.toList();
4012     }
4013 
4014     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4015      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4016      */
4017     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4018         accept(LBRACE);
4019         if (token.pos &lt;= endPosTable.errorEndPos) {
4020             // error recovery
4021             skip(false, true, false, false);
4022             if (token.kind == LBRACE)
4023                 nextToken();
4024         }
4025         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4026         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4027             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4028             if (token.pos &lt;= endPosTable.errorEndPos) {
4029                // error recovery
4030                skip(false, true, true, false);
4031            }
4032         }
4033         accept(RBRACE);
4034         return defs.toList();
4035     }
4036 
4037     /** ClassBodyDeclaration =
4038      *      &quot;;&quot;
4039      *    | [STATIC] Block
4040      *    | ModifiersOpt
4041      *      ( Type Ident
4042      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4043      *      | VOID Ident VoidMethodDeclaratorRest
4044      *      | TypeParameters [Annotations]
4045      *        ( Type Ident MethodDeclaratorRest
4046      *        | VOID Ident VoidMethodDeclaratorRest
4047      *        )
4048      *      | Ident ConstructorDeclaratorRest
4049      *      | TypeParameters Ident ConstructorDeclaratorRest
4050      *      | ClassOrInterfaceOrEnumDeclaration
4051      *      )
4052      *  InterfaceBodyDeclaration =
4053      *      &quot;;&quot;
4054      *    | ModifiersOpt
4055      *      ( Type Ident
4056      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4057      *      | VOID Ident MethodDeclaratorRest
4058      *      | TypeParameters [Annotations]
4059      *        ( Type Ident MethodDeclaratorRest
4060      *        | VOID Ident VoidMethodDeclaratorRest
4061      *        )
4062      *      | ClassOrInterfaceOrEnumDeclaration
4063      *      )
4064      *
4065      */
4066     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4067         if (token.kind == SEMI) {
4068             nextToken();
4069             return List.nil();
4070         } else {
4071             Comment dc = token.comment(CommentStyle.JAVADOC);
4072             int pos = token.pos;
4073             JCModifiers mods = modifiersOpt();
4074             if (token.kind == CLASS ||
4075                 allowRecords &amp;&amp; isRecordStart() ||
4076                 token.kind == INTERFACE ||
4077                 token.kind == ENUM) {
4078                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4079             } else if (token.kind == LBRACE &amp;&amp;
4080                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4081                        mods.annotations.isEmpty()) {
4082                 if (isInterface) {
4083                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4084                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4085                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4086                 }
4087                 return List.of(block(pos, mods.flags));
4088             } else {
4089                 pos = token.pos;
4090                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4091                 // if there are type parameters but no modifiers, save the start
4092                 // position of the method in the modifiers.
4093                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4094                     mods.pos = pos;
4095                     storeEnd(mods, pos);
4096                 }
4097                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4098 
4099                 if (annosAfterParams.nonEmpty()) {
4100                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4101                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4102                     if (mods.pos == Position.NOPOS)
4103                         mods.pos = mods.annotations.head.pos;
4104                 }
4105 
4106                 Token tk = token;
4107                 pos = token.pos;
4108                 JCExpression type;
4109                 boolean isVoid = token.kind == VOID;
4110                 if (isVoid) {
4111                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4112                     nextToken();
4113                 } else {
4114                     // method returns types are un-annotated types
4115                     type = unannotatedType(false);
4116                 }
4117                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4118                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4119                     if (isInterface || tk.name() != className)
4120                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4121                     else if (annosAfterParams.nonEmpty())
4122                         illegal(annosAfterParams.head.pos);
4123                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4124                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4125                     }
4126                     return List.of(methodDeclaratorRest(
4127                         pos, mods, null, names.init, typarams,
4128                         isInterface, true, isRecord, dc));
4129                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4130                     // trying to define a compact constructor with a throws clause
4131                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4132                             Errors.InvalidCanonicalConstructorInRecord(
4133                                     Fragments.Compact,
4134                                     className,
4135                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4136                     skip(false, true, false, false);
4137                     return List.of(methodDeclaratorRest(
4138                             pos, mods, null, names.init, typarams,
4139                             isInterface, true, isRecord, dc));
4140                 } else {
4141                     pos = token.pos;
4142                     Name name = ident();
4143                     if (token.kind == LPAREN) {
4144                         return List.of(methodDeclaratorRest(
4145                             pos, mods, type, name, typarams,
4146                             isInterface, isVoid, false, dc));
4147                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4148                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4149                         List&lt;JCTree&gt; defs =
4150                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4151                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4152                         accept(SEMI);
4153                         storeEnd(defs.last(), S.prevToken().endPos);
4154                         return defs;
4155                     } else {
4156                             int errPos = pos;
4157                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4158                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4159                             accept(SEMI);
4160                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4161                         }
4162                     } else {
4163                         pos = token.pos;
4164                         List&lt;JCTree&gt; err;
4165                         if (isVoid || typarams.nonEmpty()) {
4166                             JCMethodDecl m =
4167                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4168                                                             List.nil(), List.nil(), null, null));
4169                             attach(m, dc);
4170                             err = List.of(m);
4171                         } else {
4172                             err = List.nil();
4173                         }
4174                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4175                     }
4176                 }
4177             }
4178         }
4179     }
4180 
4181     protected boolean isRecordStart() {
4182      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4183             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4184              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4185              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4186           checkSourceLevel(Feature.RECORDS);
4187           return true;
4188     } else {
4189        return false;
4190    }
4191 }
4192 
4193     /** MethodDeclaratorRest =
4194      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4195      *  VoidMethodDeclaratorRest =
4196      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4197      *  ConstructorDeclaratorRest =
4198      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4199      */
4200     protected JCTree methodDeclaratorRest(int pos,
4201                               JCModifiers mods,
4202                               JCExpression type,
4203                               Name name,
4204                               List&lt;JCTypeParameter&gt; typarams,
4205                               boolean isInterface, boolean isVoid,
4206                               boolean isRecord,
4207                               Comment dc) {
4208         if (isInterface) {
4209             if ((mods.flags &amp; Flags.STATIC) != 0) {
4210                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4211             }
4212             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4213                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4214             }
4215         }
4216         JCVariableDecl prevReceiverParam = this.receiverParam;
4217         try {
4218             this.receiverParam = null;
4219             // Parsing formalParameters sets the receiverParam, if present
4220             List&lt;JCVariableDecl&gt; params = List.nil();
4221             List&lt;JCExpression&gt; thrown = List.nil();
4222             if (!isRecord || name != names.init || token.kind == LPAREN) {
4223                 params = formalParameters();
4224                 if (!isVoid) type = bracketsOpt(type);
4225                 if (token.kind == THROWS) {
4226                     nextToken();
4227                     thrown = qualidentList(true);
4228                 }
4229             }
4230             JCBlock body = null;
4231             JCExpression defaultValue;
4232             if (token.kind == LBRACE) {
4233                 body = block();
4234                 defaultValue = null;
4235             } else {
4236                 if (token.kind == DEFAULT) {
4237                     accept(DEFAULT);
4238                     defaultValue = annotationValue();
4239                 } else {
4240                     defaultValue = null;
4241                 }
4242                 accept(SEMI);
4243                 if (token.pos &lt;= endPosTable.errorEndPos) {
4244                     // error recovery
4245                     skip(false, true, false, false);
4246                     if (token.kind == LBRACE) {
4247                         body = block();
4248                     }
4249                 }
4250             }
4251 
4252             JCMethodDecl result =
4253                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4254                                             receiverParam, params, thrown,
4255                                             body, defaultValue));
4256             attach(result, dc);
4257             return result;
4258         } finally {
4259             this.receiverParam = prevReceiverParam;
4260         }
4261     }
4262 
4263     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4264      */
4265     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4266         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4267 
4268         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4269         JCExpression qi = qualident(allowAnnos);
4270         if (!typeAnnos.isEmpty()) {
4271             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4272             ts.append(at);
4273         } else {
4274             ts.append(qi);
4275         }
4276         while (token.kind == COMMA) {
4277             nextToken();
4278 
4279             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4280             qi = qualident(allowAnnos);
4281             if (!typeAnnos.isEmpty()) {
4282                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4283                 ts.append(at);
4284             } else {
4285                 ts.append(qi);
4286             }
4287         }
4288         return ts.toList();
4289     }
4290 
4291     /**
4292      *  {@literal
4293      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4294      *  }
4295      */
4296     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4297         if (token.kind == LT) {
4298             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4299             nextToken();
4300             typarams.append(typeParameter());
4301             while (token.kind == COMMA) {
4302                 nextToken();
4303                 typarams.append(typeParameter());
4304             }
4305             accept(GT);
4306             return typarams.toList();
4307         } else {
4308             return List.nil();
4309         }
4310     }
4311 
4312     /**
4313      *  {@literal
4314      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4315      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4316      *  TypeVariable = Ident
4317      *  }
4318      */
4319     JCTypeParameter typeParameter() {
4320         int pos = token.pos;
4321         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4322         Name name = typeName();
4323         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4324         if (token.kind == EXTENDS) {
4325             nextToken();
4326             bounds.append(parseType());
4327             while (token.kind == AMP) {
4328                 nextToken();
4329                 bounds.append(parseType());
4330             }
4331         }
4332         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4333     }
4334 
4335     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4336      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4337      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4338      */
4339     List&lt;JCVariableDecl&gt; formalParameters() {
4340         return formalParameters(false, false);
4341     }
4342     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4343         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4344         JCVariableDecl lastParam;
4345         accept(LPAREN);
4346         if (token.kind != RPAREN) {
4347             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4348             lastParam = formalParameter(lambdaParameters, recordComponents);
4349             if (lastParam.nameexpr != null) {
4350                 this.receiverParam = lastParam;
4351             } else {
4352                 params.append(lastParam);
4353             }
4354             this.allowThisIdent = false;
4355             while (token.kind == COMMA) {
4356                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4357                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4358                 }
4359                 nextToken();
4360                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4361             }
4362         }
4363         if (token.kind == RPAREN) {
4364             nextToken();
4365         } else {
4366             setErrorEndPos(token.pos);
4367             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4368         }
4369         return params.toList();
4370     }
4371 
4372     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4373         if (hasParens) {
4374             accept(LPAREN);
4375         }
4376         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4377         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4378             params.append(implicitParameter());
4379             while (token.kind == COMMA) {
4380                 nextToken();
4381                 params.append(implicitParameter());
4382             }
4383         }
4384         if (hasParens) {
4385             accept(RPAREN);
4386         }
4387         return params.toList();
4388     }
4389 
4390     JCModifiers optFinal(long flags) {
4391         JCModifiers mods = modifiersOpt();
4392         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4393         mods.flags |= flags;
4394         return mods;
4395     }
4396 
4397     /**
4398      * Inserts the annotations (and possibly a new array level)
4399      * to the left-most type in an array or nested type.
4400      *
4401      * When parsing a type like {@code @B Outer.Inner @A []}, the
4402      * {@code @A} annotation should target the array itself, while
4403      * {@code @B} targets the nested type {@code Outer}.
4404      *
4405      * Currently the parser parses the annotation first, then
4406      * the array, and then inserts the annotation to the left-most
4407      * nested type.
4408      *
4409      * When {@code createNewLevel} is true, then a new array
4410      * level is inserted as the most inner type, and have the
4411      * annotations target it.  This is useful in the case of
4412      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4413      * first parses the type {@code String @A []} then inserts
4414      * a new array level with {@code @B} annotation.
4415      */
4416     private JCExpression insertAnnotationsToMostInner(
4417             JCExpression type, List&lt;JCAnnotation&gt; annos,
4418             boolean createNewLevel) {
4419         int origEndPos = getEndPos(type);
4420         JCExpression mostInnerType = type;
4421         JCArrayTypeTree mostInnerArrayType = null;
4422         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4423             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4424             mostInnerType = mostInnerArrayType.elemtype;
4425         }
4426 
4427         if (createNewLevel) {
4428             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4429         }
4430 
4431         JCExpression mostInnerTypeToReturn = mostInnerType;
4432         if (annos.nonEmpty()) {
4433             JCExpression lastToModify = mostInnerType;
4434 
4435             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4436                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4437                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4438                     lastToModify = mostInnerType;
4439                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4440                 }
4441                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4442                     lastToModify = mostInnerType;
4443                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4444                 }
4445             }
4446 
4447             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4448 
4449             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4450                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4451             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4452                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4453             } else {
4454                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4455                 mostInnerTypeToReturn = mostInnerType;
4456             }
4457         }
4458 
4459         if (mostInnerArrayType == null) {
4460             return mostInnerTypeToReturn;
4461         } else {
4462             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4463             storeEnd(type, origEndPos);
4464             return type;
4465         }
4466     }
4467 
4468     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4469      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4470      */
4471     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4472         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4473         if (recordComponent &amp;&amp; mods.flags != 0) {
4474             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4475         }
4476         if (recordComponent) {
4477             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4478         }
4479         // need to distinguish between vararg annos and array annos
4480         // look at typeAnnotationsPushedBack comment
4481         this.permitTypeAnnotationsPushBack = true;
4482         JCExpression type = parseType(lambdaParameter);
4483         this.permitTypeAnnotationsPushBack = false;
4484 
4485         if (token.kind == ELLIPSIS) {
4486             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4487             typeAnnotationsPushedBack = List.nil();
4488             mods.flags |= Flags.VARARGS;
4489             // insert var arg type annotations
4490             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4491             nextToken();
4492         } else {
4493             // if not a var arg, then typeAnnotationsPushedBack should be null
4494             if (typeAnnotationsPushedBack.nonEmpty()) {
4495                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4496             }
4497             typeAnnotationsPushedBack = List.nil();
4498         }
4499         return variableDeclaratorId(mods, type, lambdaParameter);
4500     }
4501 
4502     protected JCVariableDecl implicitParameter() {
4503         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4504         return variableDeclaratorId(mods, null, true);
4505     }
4506 
4507 /* ---------- auxiliary methods -------------- */
4508     /** Check that given tree is a legal expression statement.
4509      */
4510     protected JCExpression checkExprStat(JCExpression t) {
4511         if (!TreeInfo.isExpressionStatement(t)) {
4512             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4513             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4514             return ret;
4515         } else {
4516             return t;
4517         }
4518     }
4519 
4520     /** Return precedence of operator represented by token,
4521      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4522      */
4523     static int prec(TokenKind token) {
4524         JCTree.Tag oc = optag(token);
4525         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4526     }
4527 
4528     /**
4529      * Return the lesser of two positions, making allowance for either one
4530      * being unset.
4531      */
4532     static int earlier(int pos1, int pos2) {
4533         if (pos1 == Position.NOPOS)
4534             return pos2;
4535         if (pos2 == Position.NOPOS)
4536             return pos1;
4537         return (pos1 &lt; pos2 ? pos1 : pos2);
4538     }
4539 
4540     /** Return operation tag of binary operator represented by token,
4541      *  No_TAG if token is not a binary operator.
4542      */
4543     static JCTree.Tag optag(TokenKind token) {
4544         switch (token) {
4545         case BARBAR:
4546             return OR;
4547         case AMPAMP:
4548             return AND;
4549         case BAR:
4550             return BITOR;
4551         case BAREQ:
4552             return BITOR_ASG;
4553         case CARET:
4554             return BITXOR;
4555         case CARETEQ:
4556             return BITXOR_ASG;
4557         case AMP:
4558             return BITAND;
4559         case AMPEQ:
4560             return BITAND_ASG;
4561         case EQEQ:
4562             return JCTree.Tag.EQ;
4563         case BANGEQ:
4564             return NE;
4565         case LT:
4566             return JCTree.Tag.LT;
4567         case GT:
4568             return JCTree.Tag.GT;
4569         case LTEQ:
4570             return LE;
4571         case GTEQ:
4572             return GE;
4573         case LTLT:
4574             return SL;
4575         case LTLTEQ:
4576             return SL_ASG;
4577         case GTGT:
4578             return SR;
4579         case GTGTEQ:
4580             return SR_ASG;
4581         case GTGTGT:
4582             return USR;
4583         case GTGTGTEQ:
4584             return USR_ASG;
4585         case PLUS:
4586             return JCTree.Tag.PLUS;
4587         case PLUSEQ:
4588             return PLUS_ASG;
4589         case SUB:
4590             return MINUS;
4591         case SUBEQ:
4592             return MINUS_ASG;
4593         case STAR:
4594             return MUL;
4595         case STAREQ:
4596             return MUL_ASG;
4597         case SLASH:
4598             return DIV;
4599         case SLASHEQ:
4600             return DIV_ASG;
4601         case PERCENT:
4602             return MOD;
4603         case PERCENTEQ:
4604             return MOD_ASG;
4605         case INSTANCEOF:
4606             return TYPETEST;
4607         default:
4608             return NO_TAG;
4609         }
4610     }
4611 
4612     /** Return operation tag of unary operator represented by token,
4613      *  No_TAG if token is not a binary operator.
4614      */
4615     static JCTree.Tag unoptag(TokenKind token) {
4616         switch (token) {
4617         case PLUS:
4618             return POS;
4619         case SUB:
4620             return NEG;
4621         case BANG:
4622             return NOT;
4623         case TILDE:
4624             return COMPL;
4625         case PLUSPLUS:
4626             return PREINC;
4627         case SUBSUB:
4628             return PREDEC;
4629         default:
4630             return NO_TAG;
4631         }
4632     }
4633 
4634     /** Return type tag of basic type represented by token,
4635      *  NONE if token is not a basic type identifier.
4636      */
4637     static TypeTag typetag(TokenKind token) {
4638         switch (token) {
4639         case BYTE:
4640             return TypeTag.BYTE;
4641         case CHAR:
4642             return TypeTag.CHAR;
4643         case SHORT:
4644             return TypeTag.SHORT;
4645         case INT:
4646             return TypeTag.INT;
4647         case LONG:
4648             return TypeTag.LONG;
4649         case FLOAT:
4650             return TypeTag.FLOAT;
4651         case DOUBLE:
4652             return TypeTag.DOUBLE;
4653         case BOOLEAN:
4654             return TypeTag.BOOLEAN;
4655         default:
4656             return TypeTag.NONE;
4657         }
4658     }
4659 
4660     void checkSourceLevel(Feature feature) {
4661         checkSourceLevel(token.pos, feature);
4662     }
4663 
4664     protected void checkSourceLevel(int pos, Feature feature) {
4665         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4666             //preview feature without --preview flag, error
4667             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4668         } else if (!feature.allowedInSource(source)) {
4669             //incompatible source level, error
4670             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4671         } else if (preview.isPreview(feature)) {
4672             //use of preview feature, warn
4673             preview.warnPreview(pos, feature);
4674         }
4675     }
4676 
4677     /*
4678      * a functional source tree and end position mappings
4679      */
4680     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4681 
4682         private final IntHashTable endPosMap;
4683 
4684         SimpleEndPosTable(JavacParser parser) {
4685             super(parser);
4686             endPosMap = new IntHashTable();
4687         }
4688 
4689         public void storeEnd(JCTree tree, int endpos) {
4690             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4691                                  endPosMap.lookup(tree));
4692         }
4693 
4694         protected &lt;T extends JCTree&gt; T to(T t) {
4695             storeEnd(t, parser.token.endPos);
4696             return t;
4697         }
4698 
4699         protected &lt;T extends JCTree&gt; T toP(T t) {
4700             storeEnd(t, parser.S.prevToken().endPos);
4701             return t;
4702         }
4703 
4704         public int getEndPos(JCTree tree) {
4705             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4706             // As long as Position.NOPOS==-1, this just returns value.
4707             return (value == -1) ? Position.NOPOS : value;
4708         }
4709 
4710         public int replaceTree(JCTree oldTree, JCTree newTree) {
4711             int pos = endPosMap.remove(oldTree);
4712             if (pos != -1) {
4713                 storeEnd(newTree, pos);
4714                 return pos;
4715             }
4716             return Position.NOPOS;
4717         }
4718     }
4719 
4720     /*
4721      * a default skeletal implementation without any mapping overhead.
4722      */
4723     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4724 
4725         EmptyEndPosTable(JavacParser parser) {
4726             super(parser);
4727         }
4728 
4729         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4730 
4731         protected &lt;T extends JCTree&gt; T to(T t) {
4732             return t;
4733         }
4734 
4735         protected &lt;T extends JCTree&gt; T toP(T t) {
4736             return t;
4737         }
4738 
4739         public int getEndPos(JCTree tree) {
4740             return Position.NOPOS;
4741         }
4742 
4743         public int replaceTree(JCTree oldTree, JCTree newTree) {
4744             return Position.NOPOS;
4745         }
4746 
4747     }
4748 
4749     protected static abstract class AbstractEndPosTable implements EndPosTable {
4750         /**
4751          * The current parser.
4752          */
4753         protected JavacParser parser;
4754 
4755         /**
4756          * Store the last error position.
4757          */
4758         public int errorEndPos = Position.NOPOS;
4759 
4760         public AbstractEndPosTable(JavacParser parser) {
4761             this.parser = parser;
4762         }
4763 
4764         /**
4765          * Store current token&#39;s ending position for a tree, the value of which
4766          * will be the greater of last error position and the ending position of
4767          * the current token.
4768          * @param t The tree.
4769          */
4770         protected abstract &lt;T extends JCTree&gt; T to(T t);
4771 
4772         /**
4773          * Store current token&#39;s ending position for a tree, the value of which
4774          * will be the greater of last error position and the ending position of
4775          * the previous token.
4776          * @param t The tree.
4777          */
4778         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4779 
4780         /**
4781          * Set the error position during the parsing phases, the value of which
4782          * will be set only if it is greater than the last stored error position.
4783          * @param errPos The error position
4784          */
4785         public void setErrorEndPos(int errPos) {
4786             if (errPos &gt; errorEndPos) {
4787                 errorEndPos = errPos;
4788             }
4789         }
4790 
4791         public void setParser(JavacParser parser) {
4792             this.parser = parser;
4793         }
4794     }
4795 }
    </pre>
  </body>
</html>
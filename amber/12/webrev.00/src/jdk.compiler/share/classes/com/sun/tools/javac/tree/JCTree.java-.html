<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.io.IOException;
  29 import java.io.StringWriter;
  30 import java.util.*;
  31 import java.util.stream.Collectors;
  32 
  33 import javax.lang.model.element.Modifier;
  34 import javax.lang.model.type.TypeKind;
  35 import javax.tools.JavaFileObject;
  36 
  37 import com.sun.source.tree.*;
  38 import com.sun.tools.javac.code.*;
  39 import com.sun.tools.javac.code.Directive.RequiresDirective;
  40 import com.sun.tools.javac.code.Scope.*;
  41 import com.sun.tools.javac.code.Symbol.*;
  42 import com.sun.tools.javac.util.*;
  43 import com.sun.tools.javac.util.DefinedBy.Api;
  44 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  45 import com.sun.tools.javac.util.List;
  46 
  47 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  48 
  49 import javax.tools.JavaFileManager.Location;
  50 
  51 import com.sun.source.tree.CaseTree.CaseKind;
  52 import com.sun.source.tree.ModuleTree.ModuleKind;
  53 import com.sun.tools.javac.code.Directive.ExportsDirective;
  54 import com.sun.tools.javac.code.Directive.OpensDirective;
  55 import com.sun.tools.javac.code.Type.ModuleType;
  56 
  57 /**
  58  * Root class for abstract syntax tree nodes. It provides definitions
  59  * for specific tree nodes as subclasses nested inside.
  60  *
  61  * &lt;p&gt;Each subclass is highly standardized.  It generally contains
  62  * only tree fields for the syntactic subcomponents of the node.  Some
  63  * classes that represent identifier uses or definitions also define a
  64  * Symbol field that denotes the represented identifier.  Classes for
  65  * non-local jumps also carry the jump target as a field.  The root
  66  * class Tree itself defines fields for the tree&#39;s type and position.
  67  * No other fields are kept in a tree node; instead parameters are
  68  * passed to methods accessing the node.
  69  *
  70  * &lt;p&gt;Except for the methods defined by com.sun.source, the only
  71  * method defined in subclasses is `visit&#39; which applies a given
  72  * visitor to the tree. The actual tree processing is done by visitor
  73  * classes in other packages. The abstract class Visitor, as well as
  74  * an Factory interface for trees, are defined as inner classes in
  75  * Tree.
  76  *
  77  * &lt;p&gt;To avoid ambiguities with the Tree API in com.sun.source all sub
  78  * classes should, by convention, start with JC (javac).
  79  *
  80  * &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  81  * If you write code that depends on this, you do so at your own risk.
  82  * This code and its internal interfaces are subject to change or
  83  * deletion without notice.&lt;/b&gt;
  84  *
  85  * @see TreeMaker
  86  * @see TreeInfo
  87  * @see TreeTranslator
  88  * @see Pretty
  89  */
  90 public abstract class JCTree implements Tree, Cloneable, DiagnosticPosition {
  91 
  92     /* Tree tag values, identifying kinds of trees */
  93     public enum Tag {
  94         /** For methods that return an invalid tag if a given condition is not met
  95          */
  96         NO_TAG,
  97 
  98         /** Toplevel nodes, of type TopLevel, representing entire source files.
  99         */
 100         TOPLEVEL,
 101 
 102         /** Package level definitions.
 103          */
 104         PACKAGEDEF,
 105 
 106         /** Import clauses, of type Import.
 107          */
 108         IMPORT,
 109 
 110         /** Class definitions, of type ClassDef.
 111          */
 112         CLASSDEF,
 113 
 114         /** Method definitions, of type MethodDef.
 115          */
 116         METHODDEF,
 117 
 118         /** Variable definitions, of type VarDef.
 119          */
 120         VARDEF,
 121 
 122         /** The no-op statement &quot;;&quot;, of type Skip
 123          */
 124         SKIP,
 125 
 126         /** Blocks, of type Block.
 127          */
 128         BLOCK,
 129 
 130         /** Do-while loops, of type DoLoop.
 131          */
 132         DOLOOP,
 133 
 134         /** While-loops, of type WhileLoop.
 135          */
 136         WHILELOOP,
 137 
 138         /** For-loops, of type ForLoop.
 139          */
 140         FORLOOP,
 141 
 142         /** Foreach-loops, of type ForeachLoop.
 143          */
 144         FOREACHLOOP,
 145 
 146         /** Labelled statements, of type Labelled.
 147          */
 148         LABELLED,
 149 
 150         /** Switch statements, of type Switch.
 151          */
 152         SWITCH,
 153 
 154         /** Case parts in switch statements/expressions, of type Case.
 155          */
 156         CASE,
 157 
 158         /** Switch expression statements, of type Switch.
 159          */
 160         SWITCH_EXPRESSION,
 161 
 162         /** Synchronized statements, of type Synchronized.
 163          */
 164         SYNCHRONIZED,
 165 
 166         /** Try statements, of type Try.
 167          */
 168         TRY,
 169 
 170         /** Catch clauses in try statements, of type Catch.
 171          */
 172         CATCH,
 173 
 174         /** Conditional expressions, of type Conditional.
 175          */
 176         CONDEXPR,
 177 
 178         /** Conditional statements, of type If.
 179          */
 180         IF,
 181 
 182         /** Expression statements, of type Exec.
 183          */
 184         EXEC,
 185 
 186         /** Break statements, of type Break.
 187          */
 188         BREAK,
 189 
 190         /** Yield statements, of type Yield.
 191          */
 192         YIELD,
 193 
 194         /** Continue statements, of type Continue.
 195          */
 196         CONTINUE,
 197 
 198         /** Return statements, of type Return.
 199          */
 200         RETURN,
 201 
 202         /** Throw statements, of type Throw.
 203          */
 204         THROW,
 205 
 206         /** Assert statements, of type Assert.
 207          */
 208         ASSERT,
 209 
 210         /** Method invocation expressions, of type Apply.
 211          */
 212         APPLY,
 213 
 214         /** Class instance creation expressions, of type NewClass.
 215          */
 216         NEWCLASS,
 217 
 218         /** Array creation expressions, of type NewArray.
 219          */
 220         NEWARRAY,
 221 
 222         /** Lambda expression, of type Lambda.
 223          */
 224         LAMBDA,
 225 
 226         /** Parenthesized subexpressions, of type Parens.
 227          */
 228         PARENS,
 229 
 230         /** Assignment expressions, of type Assign.
 231          */
 232         ASSIGN,
 233 
 234         /** Type cast expressions, of type TypeCast.
 235          */
 236         TYPECAST,
 237 
 238         /** Type test expressions, of type TypeTest.
 239          */
 240         TYPETEST,
 241 
 242         /** Patterns.
 243          */
 244         ANYPATTERN,
 245 
 246         BINDINGPATTERN,
 247 
 248         DECONSTRUCTIONPATTERN,
 249         LITERALPATTERN,
 250 
 251         /** Indexed array expressions, of type Indexed.
 252          */
 253         INDEXED,
 254 
 255         /** Selections, of type Select.
 256          */
 257         SELECT,
 258 
 259         /** Member references, of type Reference.
 260          */
 261         REFERENCE,
 262 
 263         /** Simple identifiers, of type Ident.
 264          */
 265         IDENT,
 266 
 267         /** Literals, of type Literal.
 268          */
 269         LITERAL,
 270 
 271         /** Basic type identifiers, of type TypeIdent.
 272          */
 273         TYPEIDENT,
 274 
 275         /** Array types, of type TypeArray.
 276          */
 277         TYPEARRAY,
 278 
 279         /** Parameterized types, of type TypeApply.
 280          */
 281         TYPEAPPLY,
 282 
 283         /** Union types, of type TypeUnion.
 284          */
 285         TYPEUNION,
 286 
 287         /** Intersection types, of type TypeIntersection.
 288          */
 289         TYPEINTERSECTION,
 290 
 291         /** Formal type parameters, of type TypeParameter.
 292          */
 293         TYPEPARAMETER,
 294 
 295         /** Type argument.
 296          */
 297         WILDCARD,
 298 
 299         /** Bound kind: extends, super, exact, or unbound
 300          */
 301         TYPEBOUNDKIND,
 302 
 303         /** metadata: Annotation.
 304          */
 305         ANNOTATION,
 306 
 307         /** metadata: Type annotation.
 308          */
 309         TYPE_ANNOTATION,
 310 
 311         /** metadata: Modifiers
 312          */
 313         MODIFIERS,
 314 
 315         /** An annotated type tree.
 316          */
 317         ANNOTATED_TYPE,
 318 
 319         /** Error trees, of type Erroneous.
 320          */
 321         ERRONEOUS,
 322 
 323         /** Unary operators, of type Unary.
 324          */
 325         POS,                             // +
 326         NEG,                             // -
 327         NOT,                             // !
 328         COMPL,                           // ~
 329         PREINC,                          // ++ _
 330         PREDEC,                          // -- _
 331         POSTINC,                         // _ ++
 332         POSTDEC,                         // _ --
 333 
 334         /** unary operator for null reference checks, only used internally.
 335          */
 336         NULLCHK,
 337 
 338         /** Binary operators, of type Binary.
 339          */
 340         OR,                              // ||
 341         AND,                             // &amp;&amp;
 342         BITOR,                           // |
 343         BITXOR,                          // ^
 344         BITAND,                          // &amp;
 345         EQ,                              // ==
 346         NE,                              // !=
 347         LT,                              // &lt;
 348         GT,                              // &gt;
 349         LE,                              // &lt;=
 350         GE,                              // &gt;=
 351         SL,                              // &lt;&lt;
 352         SR,                              // &gt;&gt;
 353         USR,                             // &gt;&gt;&gt;
 354         PLUS,                            // +
 355         MINUS,                           // -
 356         MUL,                             // *
 357         DIV,                             // /
 358         MOD,                             // %
 359 
 360         /** Assignment operators, of type Assignop.
 361          */
 362         BITOR_ASG(BITOR),                // |=
 363         BITXOR_ASG(BITXOR),              // ^=
 364         BITAND_ASG(BITAND),              // &amp;=
 365 
 366         SL_ASG(SL),                      // &lt;&lt;=
 367         SR_ASG(SR),                      // &gt;&gt;=
 368         USR_ASG(USR),                    // &gt;&gt;&gt;=
 369         PLUS_ASG(PLUS),                  // +=
 370         MINUS_ASG(MINUS),                // -=
 371         MUL_ASG(MUL),                    // *=
 372         DIV_ASG(DIV),                    // /=
 373         MOD_ASG(MOD),                    // %=
 374 
 375         MODULEDEF,
 376         EXPORTS,
 377         OPENS,
 378         PROVIDES,
 379         REQUIRES,
 380         USES,
 381 
 382         /** A synthetic let expression, of type LetExpr.
 383          */
 384         LETEXPR;                         // ala scheme
 385 
 386         private final Tag noAssignTag;
 387 
 388         private static final int numberOfOperators = MOD.ordinal() - POS.ordinal() + 1;
 389 
 390         private Tag(Tag noAssignTag) {
 391             this.noAssignTag = noAssignTag;
 392         }
 393 
 394         private Tag() {
 395             this(null);
 396         }
 397 
 398         public static int getNumberOfOperators() {
 399             return numberOfOperators;
 400         }
 401 
 402         public Tag noAssignOp() {
 403             if (noAssignTag != null)
 404                 return noAssignTag;
 405             throw new AssertionError(&quot;noAssignOp() method is not available for non assignment tags&quot;);
 406         }
 407 
 408         public boolean isPostUnaryOp() {
 409             return (this == POSTINC || this == POSTDEC);
 410         }
 411 
 412         public boolean isIncOrDecUnaryOp() {
 413             return (this == PREINC || this == PREDEC || this == POSTINC || this == POSTDEC);
 414         }
 415 
 416         public boolean isAssignop() {
 417             return noAssignTag != null;
 418         }
 419 
 420         public int operatorIndex() {
 421             return (this.ordinal() - POS.ordinal());
 422         }
 423     }
 424 
 425     /* The (encoded) position in the source file. @see util.Position.
 426      */
 427     public int pos;
 428 
 429     /* The type of this node.
 430      */
 431     public Type type;
 432 
 433     /* The tag of this node -- one of the constants declared above.
 434      */
 435     public abstract Tag getTag();
 436 
 437     /* Returns true if the tag of this node is equals to tag.
 438      */
 439     public boolean hasTag(Tag tag) {
 440         return tag == getTag();
 441     }
 442 
 443     /** Convert a tree to a pretty-printed string. */
 444     @Override
 445     public String toString() {
 446         StringWriter s = new StringWriter();
 447         try {
 448             new Pretty(s, false).printExpr(this);
 449         }
 450         catch (IOException e) {
 451             // should never happen, because StringWriter is defined
 452             // never to throw any IOExceptions
 453             throw new AssertionError(e);
 454         }
 455         return s.toString();
 456     }
 457 
 458     /** Set position field and return this tree.
 459      */
 460     public JCTree setPos(int pos) {
 461         this.pos = pos;
 462         return this;
 463     }
 464 
 465     /** Set type field and return this tree.
 466      */
 467     public JCTree setType(Type type) {
 468         this.type = type;
 469         return this;
 470     }
 471 
 472     /** Visit this tree with a given visitor.
 473      */
 474     public abstract void accept(Visitor v);
 475 
 476     @DefinedBy(Api.COMPILER_TREE)
 477     public abstract &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d);
 478 
 479     /** Return a shallow copy of this tree.
 480      */
 481     @Override
 482     public Object clone() {
 483         try {
 484             return super.clone();
 485         } catch(CloneNotSupportedException e) {
 486             throw new RuntimeException(e);
 487         }
 488     }
 489 
 490     /** Get a default position for this tree node.
 491      */
 492     public DiagnosticPosition pos() {
 493         return this;
 494     }
 495 
 496     // for default DiagnosticPosition
 497     public JCTree getTree() {
 498         return this;
 499     }
 500 
 501     // for default DiagnosticPosition
 502     public int getStartPosition() {
 503         return TreeInfo.getStartPos(this);
 504     }
 505 
 506     // for default DiagnosticPosition
 507     public int getPreferredPosition() {
 508         return pos;
 509     }
 510 
 511     // for default DiagnosticPosition
 512     public int getEndPosition(EndPosTable endPosTable) {
 513         return TreeInfo.getEndPos(this, endPosTable);
 514     }
 515 
 516     /**
 517      * Everything in one source file is kept in a {@linkplain JCCompilationUnit} structure.
 518      */
 519     public static class JCCompilationUnit extends JCTree implements CompilationUnitTree {
 520         /** All definitions in this file (ClassDef, Import, and Skip) */
 521         public List&lt;JCTree&gt; defs;
 522         /** The source file name. */
 523         public JavaFileObject sourcefile;
 524         /** The module to which this compilation unit belongs. */
 525         public ModuleSymbol modle;
 526         /** The location in which this compilation unit was found. */
 527         public Location locn;
 528         /** The package to which this compilation unit belongs. */
 529         public PackageSymbol packge;
 530         /** A scope containing top level classes. */
 531         public WriteableScope toplevelScope;
 532         /** A scope for all named imports. */
 533         public NamedImportScope namedImportScope;
 534         /** A scope for all import-on-demands. */
 535         public StarImportScope starImportScope;
 536         /** Line starting positions, defined only if option -g is set. */
 537         public Position.LineMap lineMap = null;
 538         /** A table that stores all documentation comments indexed by the tree
 539          * nodes they refer to. defined only if option -s is set. */
 540         public DocCommentTable docComments = null;
 541         /* An object encapsulating ending positions of source ranges indexed by
 542          * the tree nodes they belong to. Defined only if option -Xjcov is set. */
 543         public EndPosTable endPositions = null;
 544         protected JCCompilationUnit(List&lt;JCTree&gt; defs) {
 545             this.defs = defs;
 546         }
 547         @Override
 548         public void accept(Visitor v) { v.visitTopLevel(this); }
 549 
 550         @DefinedBy(Api.COMPILER_TREE)
 551         public Kind getKind() { return Kind.COMPILATION_UNIT; }
 552 
 553         public JCModuleDecl getModuleDecl() {
 554             for (JCTree tree : defs) {
 555                 if (tree.hasTag(MODULEDEF)) {
 556                     return (JCModuleDecl) tree;
 557                 }
 558             }
 559 
 560             return null;
 561         }
 562 
 563         @DefinedBy(Api.COMPILER_TREE)
 564         public JCPackageDecl getPackage() {
 565             // PackageDecl must be the first entry if it exists
 566             if (!defs.isEmpty() &amp;&amp; defs.head.hasTag(PACKAGEDEF))
 567                 return (JCPackageDecl)defs.head;
 568             return null;
 569         }
 570         @DefinedBy(Api.COMPILER_TREE)
 571         public List&lt;JCAnnotation&gt; getPackageAnnotations() {
 572             JCPackageDecl pd = getPackage();
 573             return pd != null ? pd.getAnnotations() : List.nil();
 574         }
 575         @DefinedBy(Api.COMPILER_TREE)
 576         public ExpressionTree getPackageName() {
 577             JCPackageDecl pd = getPackage();
 578             return pd != null ? pd.getPackageName() : null;
 579         }
 580 
 581         @DefinedBy(Api.COMPILER_TREE)
 582         public List&lt;JCImport&gt; getImports() {
 583             ListBuffer&lt;JCImport&gt; imports = new ListBuffer&lt;&gt;();
 584             for (JCTree tree : defs) {
 585                 if (tree.hasTag(IMPORT))
 586                     imports.append((JCImport)tree);
 587                 else if (!tree.hasTag(PACKAGEDEF) &amp;&amp; !tree.hasTag(SKIP))
 588                     break;
 589             }
 590             return imports.toList();
 591         }
 592         @DefinedBy(Api.COMPILER_TREE)
 593         public JavaFileObject getSourceFile() {
 594             return sourcefile;
 595         }
 596         @DefinedBy(Api.COMPILER_TREE)
 597         public Position.LineMap getLineMap() {
 598             return lineMap;
 599         }
 600         @DefinedBy(Api.COMPILER_TREE)
 601         public List&lt;JCTree&gt; getTypeDecls() {
 602             List&lt;JCTree&gt; typeDefs;
 603             for (typeDefs = defs; !typeDefs.isEmpty(); typeDefs = typeDefs.tail)
 604                 if (!typeDefs.head.hasTag(PACKAGEDEF) &amp;&amp; !typeDefs.head.hasTag(IMPORT))
 605                     break;
 606             return typeDefs;
 607         }
 608         @Override @DefinedBy(Api.COMPILER_TREE)
 609         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 610             return v.visitCompilationUnit(this, d);
 611         }
 612 
 613         @Override
 614         public Tag getTag() {
 615             return TOPLEVEL;
 616         }
 617     }
 618 
 619     /**
 620      * Package definition.
 621      */
 622     public static class JCPackageDecl extends JCTree implements PackageTree {
 623         public List&lt;JCAnnotation&gt; annotations;
 624         /** The tree representing the package clause. */
 625         public JCExpression pid;
 626         public PackageSymbol packge;
 627         public JCPackageDecl(List&lt;JCAnnotation&gt; annotations, JCExpression pid) {
 628             this.annotations = annotations;
 629             this.pid = pid;
 630         }
 631         @Override
 632         public void accept(Visitor v) { v.visitPackageDef(this); }
 633         @DefinedBy(Api.COMPILER_TREE)
 634         public Kind getKind() {
 635             return Kind.PACKAGE;
 636         }
 637         @DefinedBy(Api.COMPILER_TREE)
 638         public List&lt;JCAnnotation&gt; getAnnotations() {
 639             return annotations;
 640         }
 641         @DefinedBy(Api.COMPILER_TREE)
 642         public JCExpression getPackageName() {
 643             return pid;
 644         }
 645         @Override @DefinedBy(Api.COMPILER_TREE)
 646         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 647             return v.visitPackage(this, d);
 648         }
 649         @Override
 650         public Tag getTag() {
 651             return PACKAGEDEF;
 652         }
 653     }
 654 
 655     /**
 656      * An import clause.
 657      */
 658     public static class JCImport extends JCTree implements ImportTree {
 659         public boolean staticImport;
 660         /** The imported class(es). */
 661         public JCTree qualid;
 662         public com.sun.tools.javac.code.Scope importScope;
 663         protected JCImport(JCTree qualid, boolean importStatic) {
 664             this.qualid = qualid;
 665             this.staticImport = importStatic;
 666         }
 667         @Override
 668         public void accept(Visitor v) { v.visitImport(this); }
 669 
 670         @DefinedBy(Api.COMPILER_TREE)
 671         public boolean isStatic() { return staticImport; }
 672         @DefinedBy(Api.COMPILER_TREE)
 673         public JCTree getQualifiedIdentifier() { return qualid; }
 674 
 675         @DefinedBy(Api.COMPILER_TREE)
 676         public Kind getKind() { return Kind.IMPORT; }
 677         @Override @DefinedBy(Api.COMPILER_TREE)
 678         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 679             return v.visitImport(this, d);
 680         }
 681 
 682         @Override
 683         public Tag getTag() {
 684             return IMPORT;
 685         }
 686     }
 687 
 688     public static abstract class JCStatement extends JCTree implements StatementTree {
 689         @Override
 690         public JCStatement setType(Type type) {
 691             super.setType(type);
 692             return this;
 693         }
 694         @Override
 695         public JCStatement setPos(int pos) {
 696             super.setPos(pos);
 697             return this;
 698         }
 699     }
 700 
 701     public static abstract class JCExpression extends JCTree implements ExpressionTree {
 702         @Override
 703         public JCExpression setType(Type type) {
 704             super.setType(type);
 705             return this;
 706         }
 707         @Override
 708         public JCExpression setPos(int pos) {
 709             super.setPos(pos);
 710             return this;
 711         }
 712 
 713         public boolean isPoly() { return false; }
 714         public boolean isStandalone() { return true; }
 715     }
 716 
 717     /**
 718      * Common supertype for all poly expression trees (lambda, method references,
 719      * conditionals, method and constructor calls)
 720      */
 721     public static abstract class JCPolyExpression extends JCExpression {
 722 
 723         /**
 724          * A poly expression can only be truly &#39;poly&#39; in certain contexts
 725          */
 726         public enum PolyKind {
 727             /** poly expression to be treated as a standalone expression */
 728             STANDALONE,
 729             /** true poly expression */
 730             POLY
 731         }
 732 
 733         /** is this poly expression a &#39;true&#39; poly expression? */
 734         public PolyKind polyKind;
 735 
 736         @Override public boolean isPoly() { return polyKind == PolyKind.POLY; }
 737         @Override public boolean isStandalone() { return polyKind == PolyKind.STANDALONE; }
 738     }
 739 
 740     /**
 741      * Common supertype for all functional expression trees (lambda and method references)
 742      */
 743     public static abstract class JCFunctionalExpression extends JCPolyExpression {
 744 
 745         public JCFunctionalExpression() {
 746             //a functional expression is always a &#39;true&#39; poly
 747             polyKind = PolyKind.POLY;
 748         }
 749 
 750         /** list of target types inferred for this functional expression. */
 751         public Type target;
 752 
 753         public Type getDescriptorType(Types types) {
 754             return target != null ? types.findDescriptorType(target) : types.createErrorType(null);
 755         }
 756     }
 757 
 758     /**
 759      * A class definition.
 760      */
 761     public static class JCClassDecl extends JCStatement implements ClassTree {
 762         /** the modifiers */
 763         public JCModifiers mods;
 764         /** the name of the class */
 765         public Name name;
 766         /** formal class parameters */
 767         public List&lt;JCTypeParameter&gt; typarams;
 768         /** the classes this class extends */
 769         public JCExpression extending;
 770         /** the interfaces implemented by this class */
 771         public List&lt;JCExpression&gt; implementing;
 772         /** all variables and methods defined in this class */
 773         public List&lt;JCTree&gt; defs;
 774         /** the symbol */
 775         public ClassSymbol sym;
 776         protected JCClassDecl(JCModifiers mods,
 777                            Name name,
 778                            List&lt;JCTypeParameter&gt; typarams,
 779                            JCExpression extending,
 780                            List&lt;JCExpression&gt; implementing,
 781                            List&lt;JCTree&gt; defs,
 782                            ClassSymbol sym)
 783         {
 784             this.mods = mods;
 785             this.name = name;
 786             this.typarams = typarams;
 787             this.extending = extending;
 788             this.implementing = implementing;
 789             this.defs = defs;
 790             this.sym = sym;
 791         }
 792         @Override
 793         public void accept(Visitor v) { v.visitClassDef(this); }
 794 
 795         @SuppressWarnings(&quot;preview&quot;)
 796         @DefinedBy(Api.COMPILER_TREE)
 797         public Kind getKind() {
 798             if ((mods.flags &amp; Flags.ANNOTATION) != 0)
 799                 return Kind.ANNOTATION_TYPE;
 800             else if ((mods.flags &amp; Flags.INTERFACE) != 0)
 801                 return Kind.INTERFACE;
 802             else if ((mods.flags &amp; Flags.ENUM) != 0)
 803                 return Kind.ENUM;
 804             else if ((mods.flags &amp; Flags.RECORD) != 0)
 805                 return Kind.RECORD;
 806             else
 807                 return Kind.CLASS;
 808         }
 809 
 810         @DefinedBy(Api.COMPILER_TREE)
 811         public JCModifiers getModifiers() { return mods; }
 812         @DefinedBy(Api.COMPILER_TREE)
 813         public Name getSimpleName() { return name; }
 814         @DefinedBy(Api.COMPILER_TREE)
 815         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 816             return typarams;
 817         }
 818         @DefinedBy(Api.COMPILER_TREE)
 819         public JCExpression getExtendsClause() { return extending; }
 820         @DefinedBy(Api.COMPILER_TREE)
 821         public List&lt;JCExpression&gt; getImplementsClause() {
 822             return implementing;
 823         }
 824         @DefinedBy(Api.COMPILER_TREE)
 825         public List&lt;JCTree&gt; getMembers() {
 826             return defs;
 827         }
 828         @Override @DefinedBy(Api.COMPILER_TREE)
 829         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 830             return v.visitClass(this, d);
 831         }
 832 
 833         @Override
 834         public Tag getTag() {
 835             return CLASSDEF;
 836         }
 837     }
 838 
 839     /**
 840      * A method definition.
 841      */
 842     public static class JCMethodDecl extends JCTree implements MethodTree {
 843         /** method modifiers */
 844         public JCModifiers mods;
 845         /** method name */
 846         public Name name;
 847         /** type of method return value */
 848         public JCExpression restype;
 849         /** type parameters */
 850         public List&lt;JCTypeParameter&gt; typarams;
 851         /** receiver parameter */
 852         public JCVariableDecl recvparam;
 853         /** value parameters */
 854         public List&lt;JCVariableDecl&gt; params;
 855         /** exceptions thrown by this method */
 856         public List&lt;JCExpression&gt; thrown;
 857         /** statements in the method */
 858         public JCBlock body;
 859         /** default value, for annotation types */
 860         public JCExpression defaultValue;
 861         /** method symbol */
 862         public MethodSymbol sym;
 863         /** does this method completes normally */
 864         public boolean completesNormally;
 865 
 866         protected JCMethodDecl(JCModifiers mods,
 867                             Name name,
 868                             JCExpression restype,
 869                             List&lt;JCTypeParameter&gt; typarams,
 870                             JCVariableDecl recvparam,
 871                             List&lt;JCVariableDecl&gt; params,
 872                             List&lt;JCExpression&gt; thrown,
 873                             JCBlock body,
 874                             JCExpression defaultValue,
 875                             MethodSymbol sym)
 876         {
 877             this.mods = mods;
 878             this.name = name;
 879             this.restype = restype;
 880             this.typarams = typarams;
 881             this.params = params;
 882             this.recvparam = recvparam;
 883             // TODO: do something special if the given type is null?
 884             // receiver != null ? receiver : List.&lt;JCTypeAnnotation&gt;nil());
 885             this.thrown = thrown;
 886             this.body = body;
 887             this.defaultValue = defaultValue;
 888             this.sym = sym;
 889         }
 890         @Override
 891         public void accept(Visitor v) { v.visitMethodDef(this); }
 892 
 893         @DefinedBy(Api.COMPILER_TREE)
 894         public Kind getKind() { return Kind.METHOD; }
 895         @DefinedBy(Api.COMPILER_TREE)
 896         public JCModifiers getModifiers() { return mods; }
 897         @DefinedBy(Api.COMPILER_TREE)
 898         public Name getName() { return name; }
 899         @DefinedBy(Api.COMPILER_TREE)
 900         public JCTree getReturnType() { return restype; }
 901         @DefinedBy(Api.COMPILER_TREE)
 902         public List&lt;JCTypeParameter&gt; getTypeParameters() {
 903             return typarams;
 904         }
 905         @DefinedBy(Api.COMPILER_TREE)
 906         public List&lt;JCVariableDecl&gt; getParameters() {
 907             return params;
 908         }
 909         @DefinedBy(Api.COMPILER_TREE)
 910         public JCVariableDecl getReceiverParameter() { return recvparam; }
 911         @DefinedBy(Api.COMPILER_TREE)
 912         public List&lt;JCExpression&gt; getThrows() {
 913             return thrown;
 914         }
 915         @DefinedBy(Api.COMPILER_TREE)
 916         public JCBlock getBody() { return body; }
 917         @DefinedBy(Api.COMPILER_TREE)
 918         public JCTree getDefaultValue() { // for annotation types
 919             return defaultValue;
 920         }
 921         @Override @DefinedBy(Api.COMPILER_TREE)
 922         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 923             return v.visitMethod(this, d);
 924         }
 925 
 926         @Override
 927         public Tag getTag() {
 928             return METHODDEF;
 929         }
 930   }
 931 
 932     /**
 933      * A variable definition.
 934      */
 935     public static class JCVariableDecl extends JCStatement implements VariableTree {
 936         /** variable modifiers */
 937         public JCModifiers mods;
 938         /** variable name */
 939         public Name name;
 940         /** variable name expression */
 941         public JCExpression nameexpr;
 942         /** type of the variable */
 943         public JCExpression vartype;
 944         /** variable&#39;s initial value */
 945         public JCExpression init;
 946         /** symbol */
 947         public VarSymbol sym;
 948         /** explicit start pos */
 949         public int startPos = Position.NOPOS;
 950 
 951         protected JCVariableDecl(JCModifiers mods,
 952                          Name name,
 953                          JCExpression vartype,
 954                          JCExpression init,
 955                          VarSymbol sym) {
 956             this.mods = mods;
 957             this.name = name;
 958             this.vartype = vartype;
 959             this.init = init;
 960             this.sym = sym;
 961         }
 962 
 963         protected JCVariableDecl(JCModifiers mods,
 964                          JCExpression nameexpr,
 965                          JCExpression vartype) {
 966             this(mods, null, vartype, null, null);
 967             this.nameexpr = nameexpr;
 968             if (nameexpr.hasTag(Tag.IDENT)) {
 969                 this.name = ((JCIdent)nameexpr).name;
 970             } else {
 971                 // Only other option is qualified name x.y.this;
 972                 this.name = ((JCFieldAccess)nameexpr).name;
 973             }
 974         }
 975 
 976         public boolean isImplicitlyTyped() {
 977             return vartype == null;
 978         }
 979 
 980         @Override
 981         public void accept(Visitor v) { v.visitVarDef(this); }
 982 
 983         @DefinedBy(Api.COMPILER_TREE)
 984         public Kind getKind() { return Kind.VARIABLE; }
 985         @DefinedBy(Api.COMPILER_TREE)
 986         public JCModifiers getModifiers() { return mods; }
 987         @DefinedBy(Api.COMPILER_TREE)
 988         public Name getName() { return name; }
 989         @DefinedBy(Api.COMPILER_TREE)
 990         public JCExpression getNameExpression() { return nameexpr; }
 991         @DefinedBy(Api.COMPILER_TREE)
 992         public JCTree getType() { return vartype; }
 993         @DefinedBy(Api.COMPILER_TREE)
 994         public JCExpression getInitializer() {
 995             return init;
 996         }
 997         @Override @DefinedBy(Api.COMPILER_TREE)
 998         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
 999             return v.visitVariable(this, d);
1000         }
1001 
1002         @Override
1003         public Tag getTag() {
1004             return VARDEF;
1005         }
1006     }
1007 
1008     /**
1009      * A no-op statement &quot;;&quot;.
1010      */
1011     public static class JCSkip extends JCStatement implements EmptyStatementTree {
1012         protected JCSkip() {
1013         }
1014         @Override
1015         public void accept(Visitor v) { v.visitSkip(this); }
1016 
1017         @DefinedBy(Api.COMPILER_TREE)
1018         public Kind getKind() { return Kind.EMPTY_STATEMENT; }
1019         @Override @DefinedBy(Api.COMPILER_TREE)
1020         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1021             return v.visitEmptyStatement(this, d);
1022         }
1023 
1024         @Override
1025         public Tag getTag() {
1026             return SKIP;
1027         }
1028     }
1029 
1030     /**
1031      * A statement block.
1032      */
1033     public static class JCBlock extends JCStatement implements BlockTree {
1034         /** flags */
1035         public long flags;
1036         /** statements */
1037         public List&lt;JCStatement&gt; stats;
1038         /** Position of closing brace, optional. */
1039         public int endpos = Position.NOPOS;
1040         protected JCBlock(long flags, List&lt;JCStatement&gt; stats) {
1041             this.stats = stats;
1042             this.flags = flags;
1043         }
1044         @Override
1045         public void accept(Visitor v) { v.visitBlock(this); }
1046 
1047         @DefinedBy(Api.COMPILER_TREE)
1048         public Kind getKind() { return Kind.BLOCK; }
1049         @DefinedBy(Api.COMPILER_TREE)
1050         public List&lt;JCStatement&gt; getStatements() {
1051             return stats;
1052         }
1053         @DefinedBy(Api.COMPILER_TREE)
1054         public boolean isStatic() { return (flags &amp; Flags.STATIC) != 0; }
1055         @Override @DefinedBy(Api.COMPILER_TREE)
1056         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1057             return v.visitBlock(this, d);
1058         }
1059 
1060         @Override
1061         public Tag getTag() {
1062             return BLOCK;
1063         }
1064     }
1065 
1066     /**
1067      * A do loop
1068      */
1069     public static class JCDoWhileLoop extends JCStatement implements DoWhileLoopTree {
1070         public JCStatement body;
1071         public JCExpression cond;
1072         protected JCDoWhileLoop(JCStatement body, JCExpression cond) {
1073             this.body = body;
1074             this.cond = cond;
1075         }
1076         @Override
1077         public void accept(Visitor v) { v.visitDoLoop(this); }
1078 
1079         @DefinedBy(Api.COMPILER_TREE)
1080         public Kind getKind() { return Kind.DO_WHILE_LOOP; }
1081         @DefinedBy(Api.COMPILER_TREE)
1082         public JCExpression getCondition() { return cond; }
1083         @DefinedBy(Api.COMPILER_TREE)
1084         public JCStatement getStatement() { return body; }
1085         @Override @DefinedBy(Api.COMPILER_TREE)
1086         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1087             return v.visitDoWhileLoop(this, d);
1088         }
1089 
1090         @Override
1091         public Tag getTag() {
1092             return DOLOOP;
1093         }
1094     }
1095 
1096     /**
1097      * A while loop
1098      */
1099     public static class JCWhileLoop extends JCStatement implements WhileLoopTree {
1100         public JCExpression cond;
1101         public JCStatement body;
1102         protected JCWhileLoop(JCExpression cond, JCStatement body) {
1103             this.cond = cond;
1104             this.body = body;
1105         }
1106         @Override
1107         public void accept(Visitor v) { v.visitWhileLoop(this); }
1108 
1109         @DefinedBy(Api.COMPILER_TREE)
1110         public Kind getKind() { return Kind.WHILE_LOOP; }
1111         @DefinedBy(Api.COMPILER_TREE)
1112         public JCExpression getCondition() { return cond; }
1113         @DefinedBy(Api.COMPILER_TREE)
1114         public JCStatement getStatement() { return body; }
1115         @Override @DefinedBy(Api.COMPILER_TREE)
1116         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1117             return v.visitWhileLoop(this, d);
1118         }
1119 
1120         @Override
1121         public Tag getTag() {
1122             return WHILELOOP;
1123         }
1124     }
1125 
1126     /**
1127      * A for loop.
1128      */
1129     public static class JCForLoop extends JCStatement implements ForLoopTree {
1130         public List&lt;JCStatement&gt; init;
1131         public JCExpression cond;
1132         public List&lt;JCExpressionStatement&gt; step;
1133         public JCStatement body;
1134         protected JCForLoop(List&lt;JCStatement&gt; init,
1135                           JCExpression cond,
1136                           List&lt;JCExpressionStatement&gt; update,
1137                           JCStatement body)
1138         {
1139             this.init = init;
1140             this.cond = cond;
1141             this.step = update;
1142             this.body = body;
1143         }
1144         @Override
1145         public void accept(Visitor v) { v.visitForLoop(this); }
1146 
1147         @DefinedBy(Api.COMPILER_TREE)
1148         public Kind getKind() { return Kind.FOR_LOOP; }
1149         @DefinedBy(Api.COMPILER_TREE)
1150         public JCExpression getCondition() { return cond; }
1151         @DefinedBy(Api.COMPILER_TREE)
1152         public JCStatement getStatement() { return body; }
1153         @DefinedBy(Api.COMPILER_TREE)
1154         public List&lt;JCStatement&gt; getInitializer() {
1155             return init;
1156         }
1157         @DefinedBy(Api.COMPILER_TREE)
1158         public List&lt;JCExpressionStatement&gt; getUpdate() {
1159             return step;
1160         }
1161         @Override @DefinedBy(Api.COMPILER_TREE)
1162         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1163             return v.visitForLoop(this, d);
1164         }
1165 
1166         @Override
1167         public Tag getTag() {
1168             return FORLOOP;
1169         }
1170     }
1171 
1172     /**
1173      * The enhanced for loop.
1174      */
1175     public static class JCEnhancedForLoop extends JCStatement implements EnhancedForLoopTree {
1176         public JCVariableDecl var;
1177         public JCExpression expr;
1178         public JCStatement body;
1179         protected JCEnhancedForLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
1180             this.var = var;
1181             this.expr = expr;
1182             this.body = body;
1183         }
1184         @Override
1185         public void accept(Visitor v) { v.visitForeachLoop(this); }
1186 
1187         @DefinedBy(Api.COMPILER_TREE)
1188         public Kind getKind() { return Kind.ENHANCED_FOR_LOOP; }
1189         @DefinedBy(Api.COMPILER_TREE)
1190         public JCVariableDecl getVariable() { return var; }
1191         @DefinedBy(Api.COMPILER_TREE)
1192         public JCExpression getExpression() { return expr; }
1193         @DefinedBy(Api.COMPILER_TREE)
1194         public JCStatement getStatement() { return body; }
1195         @Override @DefinedBy(Api.COMPILER_TREE)
1196         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1197             return v.visitEnhancedForLoop(this, d);
1198         }
1199         @Override
1200         public Tag getTag() {
1201             return FOREACHLOOP;
1202         }
1203     }
1204 
1205     /**
1206      * A labelled expression or statement.
1207      */
1208     public static class JCLabeledStatement extends JCStatement implements LabeledStatementTree {
1209         public Name label;
1210         public JCStatement body;
1211         protected JCLabeledStatement(Name label, JCStatement body) {
1212             this.label = label;
1213             this.body = body;
1214         }
1215         @Override
1216         public void accept(Visitor v) { v.visitLabelled(this); }
1217         @DefinedBy(Api.COMPILER_TREE)
1218         public Kind getKind() { return Kind.LABELED_STATEMENT; }
1219         @DefinedBy(Api.COMPILER_TREE)
1220         public Name getLabel() { return label; }
1221         @DefinedBy(Api.COMPILER_TREE)
1222         public JCStatement getStatement() { return body; }
1223         @Override @DefinedBy(Api.COMPILER_TREE)
1224         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1225             return v.visitLabeledStatement(this, d);
1226         }
1227         @Override
1228         public Tag getTag() {
1229             return LABELLED;
1230         }
1231     }
1232 
1233     public interface GenericSwitch {
1234         public enum SwitchKind {
1235             ORDINARY,
1236             STRING,
1237             ENUM,
1238             MATCHING;
1239         }
1240         public SwitchKind getSwitchKind();
1241         public void setSelector(JCExpression selector);
1242         public void setCases(List&lt;JCCase&gt; cases);
1243     }
1244     /**
1245      * A &quot;switch ( ) { }&quot; construction.
1246      */
1247     public static class JCSwitch extends JCStatement implements SwitchTree, GenericSwitch {
1248         public JCExpression selector;
1249         public List&lt;JCCase&gt; cases;
1250         public SwitchKind kind;
1251         protected JCSwitch(JCExpression selector, List&lt;JCCase&gt; cases) {
1252             this.selector = selector;
1253             this.cases = cases;
1254         }
1255         @Override
1256         public void accept(Visitor v) { v.visitSwitch(this); }
1257 
1258         @DefinedBy(Api.COMPILER_TREE)
1259         public Kind getKind() { return Kind.SWITCH; }
1260         @DefinedBy(Api.COMPILER_TREE)
1261         public JCExpression getExpression() { return selector; }
1262         @DefinedBy(Api.COMPILER_TREE)
1263         public List&lt;JCCase&gt; getCases() { return cases; }
1264         @Override @DefinedBy(Api.COMPILER_TREE)
1265         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1266             return v.visitSwitch(this, d);
1267         }
1268         @Override
1269         public Tag getTag() {
1270             return SWITCH;
1271         }
1272         @Override
1273         public SwitchKind getSwitchKind() {
1274             return kind;
1275         }
1276         @Override
1277         public void setSelector(JCExpression selector) {
1278             this.selector = selector;
1279         }
1280         @Override
1281         public void setCases(List&lt;JCCase&gt; cases) {
1282             this.cases = cases;
1283         }
1284     }
1285 
1286     /**
1287      * A &quot;case  :&quot; of a switch.
1288      */
1289     public static class JCCase extends JCStatement implements CaseTree {
1290         //as CaseKind is deprecated for removal (as it is part of a preview feature),
1291         //using indirection through these fields to avoid unnecessary @SuppressWarnings:
1292         public static final CaseKind STATEMENT = CaseKind.STATEMENT;
1293         public static final CaseKind RULE = CaseKind.RULE;
1294         public final CaseKind caseKind;
1295         public List&lt;JCPattern&gt; pats;
1296         public List&lt;JCStatement&gt; stats;
1297         public JCTree body;
1298         public boolean completesNormally;
1299         protected JCCase(CaseKind caseKind, List&lt;JCPattern&gt; pats,
1300                          List&lt;JCStatement&gt; stats, JCTree body) {
1301             Assert.checkNonNull(pats);
1302             Assert.check(pats.isEmpty() || pats.head != null);
1303             this.caseKind = caseKind;
1304             this.pats = pats;
1305             this.stats = stats;
1306             this.body = body;
1307         }
1308         @Override
1309         public void accept(Visitor v) { v.visitCase(this); }
1310 
1311         @Override @DefinedBy(Api.COMPILER_TREE)
1312         public Kind getKind() { return Kind.CASE; }
1313         @DefinedBy(Api.COMPILER_TREE)
1314         @Deprecated
1315         public JCExpression getExpression() {
1316             return pats.nonEmpty() ? pats.head.constExpression() : null;
1317         }
1318         @Override @DefinedBy(Api.COMPILER_TREE)
1319         public java.util.List&lt;JCExpression&gt; getExpressions() {
1320             return pats.stream()
1321                        .map(pat -&gt; pat.constExpression())
1322                        .collect(Collectors.toList());
1323         }
1324         public List&lt;JCPattern&gt; getPatterns() { return pats; }
1325         @Override @DefinedBy(Api.COMPILER_TREE)
1326         public List&lt;JCStatement&gt; getStatements() {
1327             return caseKind == CaseKind.STATEMENT ? stats : null;
1328         }
1329         @Override @DefinedBy(Api.COMPILER_TREE)
1330         public JCTree getBody() { return body; }
1331         @Override @DefinedBy(Api.COMPILER_TREE)
1332         public CaseKind getCaseKind() {
1333             return caseKind;
1334         }
1335         @Override @DefinedBy(Api.COMPILER_TREE)
1336         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1337             return v.visitCase(this, d);
1338         }
1339         @Override
1340         public Tag getTag() {
1341             return CASE;
1342         }
1343     }
1344 
1345     /**
1346      * A &quot;switch ( ) { }&quot; construction.
1347      */
1348     public static class JCSwitchExpression extends JCPolyExpression implements SwitchExpressionTree, GenericSwitch {
1349         public JCExpression selector;
1350         public List&lt;JCCase&gt; cases;
1351         public SwitchKind kind;
1352         /** Position of closing brace, optional. */
1353         public int endpos = Position.NOPOS;
1354         protected JCSwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
1355             this.selector = selector;
1356             this.cases = cases;
1357         }
1358         @Override
1359         public void accept(Visitor v) { v.visitSwitchExpression(this); }
1360 
1361         @DefinedBy(Api.COMPILER_TREE)
1362         public Kind getKind() { return Kind.SWITCH_EXPRESSION; }
1363         @DefinedBy(Api.COMPILER_TREE)
1364         public JCExpression getExpression() { return selector; }
1365         @DefinedBy(Api.COMPILER_TREE)
1366         public List&lt;JCCase&gt; getCases() { return cases; }
1367         @Override @DefinedBy(Api.COMPILER_TREE)
1368         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1369             return v.visitSwitchExpression(this, d);
1370         }
1371         @Override
1372         public Tag getTag() {
1373             return SWITCH_EXPRESSION;
1374         }
1375         @Override
1376         public SwitchKind getSwitchKind() {
1377             return kind;
1378         }
1379         @Override
1380         public void setSelector(JCExpression selector) {
1381             this.selector = selector;
1382         }
1383         @Override
1384         public void setCases(List&lt;JCCase&gt; cases) {
1385             this.cases = cases;
1386         }
1387     }
1388 
1389     /**
1390      * A synchronized block.
1391      */
1392     public static class JCSynchronized extends JCStatement implements SynchronizedTree {
1393         public JCExpression lock;
1394         public JCBlock body;
1395         protected JCSynchronized(JCExpression lock, JCBlock body) {
1396             this.lock = lock;
1397             this.body = body;
1398         }
1399         @Override
1400         public void accept(Visitor v) { v.visitSynchronized(this); }
1401 
1402         @DefinedBy(Api.COMPILER_TREE)
1403         public Kind getKind() { return Kind.SYNCHRONIZED; }
1404         @DefinedBy(Api.COMPILER_TREE)
1405         public JCExpression getExpression() { return lock; }
1406         @DefinedBy(Api.COMPILER_TREE)
1407         public JCBlock getBlock() { return body; }
1408         @Override @DefinedBy(Api.COMPILER_TREE)
1409         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1410             return v.visitSynchronized(this, d);
1411         }
1412         @Override
1413         public Tag getTag() {
1414             return SYNCHRONIZED;
1415         }
1416     }
1417 
1418     /**
1419      * A &quot;try { } catch ( ) { } finally { }&quot; block.
1420      */
1421     public static class JCTry extends JCStatement implements TryTree {
1422         public JCBlock body;
1423         public List&lt;JCCatch&gt; catchers;
1424         public JCBlock finalizer;
1425         public List&lt;JCTree&gt; resources;
1426         public boolean finallyCanCompleteNormally;
1427         protected JCTry(List&lt;JCTree&gt; resources,
1428                         JCBlock body,
1429                         List&lt;JCCatch&gt; catchers,
1430                         JCBlock finalizer) {
1431             this.body = body;
1432             this.catchers = catchers;
1433             this.finalizer = finalizer;
1434             this.resources = resources;
1435         }
1436         @Override
1437         public void accept(Visitor v) { v.visitTry(this); }
1438 
1439         @DefinedBy(Api.COMPILER_TREE)
1440         public Kind getKind() { return Kind.TRY; }
1441         @DefinedBy(Api.COMPILER_TREE)
1442         public JCBlock getBlock() { return body; }
1443         @DefinedBy(Api.COMPILER_TREE)
1444         public List&lt;JCCatch&gt; getCatches() {
1445             return catchers;
1446         }
1447         @DefinedBy(Api.COMPILER_TREE)
1448         public JCBlock getFinallyBlock() { return finalizer; }
1449         @Override @DefinedBy(Api.COMPILER_TREE)
1450         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1451             return v.visitTry(this, d);
1452         }
1453         @Override @DefinedBy(Api.COMPILER_TREE)
1454         public List&lt;JCTree&gt; getResources() {
1455             return resources;
1456         }
1457         @Override
1458         public Tag getTag() {
1459             return TRY;
1460         }
1461     }
1462 
1463     /**
1464      * A catch block.
1465      */
1466     public static class JCCatch extends JCTree implements CatchTree {
1467         public JCVariableDecl param;
1468         public JCBlock body;
1469         protected JCCatch(JCVariableDecl param, JCBlock body) {
1470             this.param = param;
1471             this.body = body;
1472         }
1473         @Override
1474         public void accept(Visitor v) { v.visitCatch(this); }
1475 
1476         @DefinedBy(Api.COMPILER_TREE)
1477         public Kind getKind() { return Kind.CATCH; }
1478         @DefinedBy(Api.COMPILER_TREE)
1479         public JCVariableDecl getParameter() { return param; }
1480         @DefinedBy(Api.COMPILER_TREE)
1481         public JCBlock getBlock() { return body; }
1482         @Override @DefinedBy(Api.COMPILER_TREE)
1483         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1484             return v.visitCatch(this, d);
1485         }
1486         @Override
1487         public Tag getTag() {
1488             return CATCH;
1489         }
1490     }
1491 
1492     /**
1493      * A ( ) ? ( ) : ( ) conditional expression
1494      */
1495     public static class JCConditional extends JCPolyExpression implements ConditionalExpressionTree {
1496         public JCExpression cond;
1497         public JCExpression truepart;
1498         public JCExpression falsepart;
1499         protected JCConditional(JCExpression cond,
1500                               JCExpression truepart,
1501                               JCExpression falsepart)
1502         {
1503             this.cond = cond;
1504             this.truepart = truepart;
1505             this.falsepart = falsepart;
1506         }
1507         @Override
1508         public void accept(Visitor v) { v.visitConditional(this); }
1509 
1510         @DefinedBy(Api.COMPILER_TREE)
1511         public Kind getKind() { return Kind.CONDITIONAL_EXPRESSION; }
1512         @DefinedBy(Api.COMPILER_TREE)
1513         public JCExpression getCondition() { return cond; }
1514         @DefinedBy(Api.COMPILER_TREE)
1515         public JCExpression getTrueExpression() { return truepart; }
1516         @DefinedBy(Api.COMPILER_TREE)
1517         public JCExpression getFalseExpression() { return falsepart; }
1518         @Override @DefinedBy(Api.COMPILER_TREE)
1519         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1520             return v.visitConditionalExpression(this, d);
1521         }
1522         @Override
1523         public Tag getTag() {
1524             return CONDEXPR;
1525         }
1526     }
1527 
1528     /**
1529      * An &quot;if ( ) { } else { }&quot; block
1530      */
1531     public static class JCIf extends JCStatement implements IfTree {
1532         public JCExpression cond;
1533         public JCStatement thenpart;
1534         public JCStatement elsepart;
1535         protected JCIf(JCExpression cond,
1536                      JCStatement thenpart,
1537                      JCStatement elsepart)
1538         {
1539             this.cond = cond;
1540             this.thenpart = thenpart;
1541             this.elsepart = elsepart;
1542         }
1543         @Override
1544         public void accept(Visitor v) { v.visitIf(this); }
1545 
1546         @DefinedBy(Api.COMPILER_TREE)
1547         public Kind getKind() { return Kind.IF; }
1548         @DefinedBy(Api.COMPILER_TREE)
1549         public JCExpression getCondition() { return cond; }
1550         @DefinedBy(Api.COMPILER_TREE)
1551         public JCStatement getThenStatement() { return thenpart; }
1552         @DefinedBy(Api.COMPILER_TREE)
1553         public JCStatement getElseStatement() { return elsepart; }
1554         @Override @DefinedBy(Api.COMPILER_TREE)
1555         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1556             return v.visitIf(this, d);
1557         }
1558         @Override
1559         public Tag getTag() {
1560             return IF;
1561         }
1562     }
1563 
1564     /**
1565      * an expression statement
1566      */
1567     public static class JCExpressionStatement extends JCStatement implements ExpressionStatementTree {
1568         /** expression structure */
1569         public JCExpression expr;
1570         protected JCExpressionStatement(JCExpression expr)
1571         {
1572             this.expr = expr;
1573         }
1574         @Override
1575         public void accept(Visitor v) { v.visitExec(this); }
1576 
1577         @DefinedBy(Api.COMPILER_TREE)
1578         public Kind getKind() { return Kind.EXPRESSION_STATEMENT; }
1579         @DefinedBy(Api.COMPILER_TREE)
1580         public JCExpression getExpression() { return expr; }
1581         @Override @DefinedBy(Api.COMPILER_TREE)
1582         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1583             return v.visitExpressionStatement(this, d);
1584         }
1585         @Override
1586         public Tag getTag() {
1587             return EXEC;
1588         }
1589 
1590         /** Convert a expression-statement tree to a pretty-printed string. */
1591         @Override
1592         public String toString() {
1593             StringWriter s = new StringWriter();
1594             try {
1595                 new Pretty(s, false).printStat(this);
1596             }
1597             catch (IOException e) {
1598                 // should never happen, because StringWriter is defined
1599                 // never to throw any IOExceptions
1600                 throw new AssertionError(e);
1601             }
1602             return s.toString();
1603         }
1604     }
1605 
1606     /**
1607      * A break from a loop or switch.
1608      */
1609     public static class JCBreak extends JCStatement implements BreakTree {
1610         public Name label;
1611         public JCTree target;
1612         protected JCBreak(Name label, JCTree target) {
1613             this.label = label;
1614             this.target = target;
1615         }
1616         @Override
1617         public void accept(Visitor v) { v.visitBreak(this); }
1618         public boolean isValueBreak() {
1619             return target != null &amp;&amp; target.hasTag(SWITCH_EXPRESSION);
1620         }
1621 
1622         @DefinedBy(Api.COMPILER_TREE)
1623         public Kind getKind() { return Kind.BREAK; }
1624         @DefinedBy(Api.COMPILER_TREE)
1625         public Name getLabel() {
1626             return label;
1627         }
1628         @Override @DefinedBy(Api.COMPILER_TREE)
1629         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1630             return v.visitBreak(this, d);
1631         }
1632         @Override
1633         public Tag getTag() {
1634             return BREAK;
1635         }
1636     }
1637 
1638     /**
1639      * A break-with from a switch expression.
1640      */
1641     public static class JCYield extends JCStatement implements YieldTree {
1642         public JCExpression value;
1643         public JCTree target;
1644         protected JCYield(JCExpression value, JCTree target) {
1645             this.value = value;
1646             this.target = target;
1647         }
1648         @Override
1649         public void accept(Visitor v) { v.visitYield(this); }
1650         @DefinedBy(Api.COMPILER_TREE)
1651         public Kind getKind() { return Kind.YIELD; }
1652         @DefinedBy(Api.COMPILER_TREE)
1653         public JCExpression getValue() { return value; }
1654         @Override @DefinedBy(Api.COMPILER_TREE)
1655         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1656             return v.visitYield(this, d);
1657         }
1658         @Override
1659         public Tag getTag() {
1660             return YIELD;
1661         }
1662     }
1663 
1664     /**
1665      * A continue of a loop.
1666      */
1667     public static class JCContinue extends JCStatement implements ContinueTree {
1668         public Name label;
1669         public JCTree target;
1670         protected JCContinue(Name label, JCTree target) {
1671             this.label = label;
1672             this.target = target;
1673         }
1674         @Override
1675         public void accept(Visitor v) { v.visitContinue(this); }
1676 
1677         @DefinedBy(Api.COMPILER_TREE)
1678         public Kind getKind() { return Kind.CONTINUE; }
1679         @DefinedBy(Api.COMPILER_TREE)
1680         public Name getLabel() { return label; }
1681         @Override @DefinedBy(Api.COMPILER_TREE)
1682         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1683             return v.visitContinue(this, d);
1684         }
1685         @Override
1686         public Tag getTag() {
1687             return CONTINUE;
1688         }
1689     }
1690 
1691     /**
1692      * A return statement.
1693      */
1694     public static class JCReturn extends JCStatement implements ReturnTree {
1695         public JCExpression expr;
1696         protected JCReturn(JCExpression expr) {
1697             this.expr = expr;
1698         }
1699         @Override
1700         public void accept(Visitor v) { v.visitReturn(this); }
1701 
1702         @DefinedBy(Api.COMPILER_TREE)
1703         public Kind getKind() { return Kind.RETURN; }
1704         @DefinedBy(Api.COMPILER_TREE)
1705         public JCExpression getExpression() { return expr; }
1706         @Override @DefinedBy(Api.COMPILER_TREE)
1707         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1708             return v.visitReturn(this, d);
1709         }
1710         @Override
1711         public Tag getTag() {
1712             return RETURN;
1713         }
1714     }
1715 
1716     /**
1717      * A throw statement.
1718      */
1719     public static class JCThrow extends JCStatement implements ThrowTree {
1720         public JCExpression expr;
1721         protected JCThrow(JCExpression expr) {
1722             this.expr = expr;
1723         }
1724         @Override
1725         public void accept(Visitor v) { v.visitThrow(this); }
1726 
1727         @DefinedBy(Api.COMPILER_TREE)
1728         public Kind getKind() { return Kind.THROW; }
1729         @DefinedBy(Api.COMPILER_TREE)
1730         public JCExpression getExpression() { return expr; }
1731         @Override @DefinedBy(Api.COMPILER_TREE)
1732         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1733             return v.visitThrow(this, d);
1734         }
1735         @Override
1736         public Tag getTag() {
1737             return THROW;
1738         }
1739     }
1740 
1741     /**
1742      * An assert statement.
1743      */
1744     public static class JCAssert extends JCStatement implements AssertTree {
1745         public JCExpression cond;
1746         public JCExpression detail;
1747         protected JCAssert(JCExpression cond, JCExpression detail) {
1748             this.cond = cond;
1749             this.detail = detail;
1750         }
1751         @Override
1752         public void accept(Visitor v) { v.visitAssert(this); }
1753 
1754         @DefinedBy(Api.COMPILER_TREE)
1755         public Kind getKind() { return Kind.ASSERT; }
1756         @DefinedBy(Api.COMPILER_TREE)
1757         public JCExpression getCondition() { return cond; }
1758         @DefinedBy(Api.COMPILER_TREE)
1759         public JCExpression getDetail() { return detail; }
1760         @Override @DefinedBy(Api.COMPILER_TREE)
1761         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1762             return v.visitAssert(this, d);
1763         }
1764         @Override
1765         public Tag getTag() {
1766             return ASSERT;
1767         }
1768     }
1769 
1770     /**
1771      * A method invocation
1772      */
1773     public static class JCMethodInvocation extends JCPolyExpression implements MethodInvocationTree {
1774         public List&lt;JCExpression&gt; typeargs;
1775         public JCExpression meth;
1776         public List&lt;JCExpression&gt; args;
1777         public Type varargsElement;
1778         protected JCMethodInvocation(List&lt;JCExpression&gt; typeargs,
1779                         JCExpression meth,
1780                         List&lt;JCExpression&gt; args)
1781         {
1782             this.typeargs = (typeargs == null) ? List.nil()
1783                                                : typeargs;
1784             this.meth = meth;
1785             this.args = args;
1786         }
1787         @Override
1788         public void accept(Visitor v) { v.visitApply(this); }
1789 
1790         @DefinedBy(Api.COMPILER_TREE)
1791         public Kind getKind() { return Kind.METHOD_INVOCATION; }
1792         @DefinedBy(Api.COMPILER_TREE)
1793         public List&lt;JCExpression&gt; getTypeArguments() {
1794             return typeargs;
1795         }
1796         @DefinedBy(Api.COMPILER_TREE)
1797         public JCExpression getMethodSelect() { return meth; }
1798         @DefinedBy(Api.COMPILER_TREE)
1799         public List&lt;JCExpression&gt; getArguments() {
1800             return args;
1801         }
1802         @Override @DefinedBy(Api.COMPILER_TREE)
1803         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1804             return v.visitMethodInvocation(this, d);
1805         }
1806         @Override
1807         public JCMethodInvocation setType(Type type) {
1808             super.setType(type);
1809             return this;
1810         }
1811         @Override
1812         public Tag getTag() {
1813             return(APPLY);
1814         }
1815     }
1816 
1817     /**
1818      * A new(...) operation.
1819      */
1820     public static class JCNewClass extends JCPolyExpression implements NewClassTree {
1821         public JCExpression encl;
1822         public List&lt;JCExpression&gt; typeargs;
1823         public JCExpression clazz;
1824         public List&lt;JCExpression&gt; args;
1825         public JCClassDecl def;
1826         public Symbol constructor;
1827         public Type varargsElement;
1828         public Type constructorType;
1829         protected JCNewClass(JCExpression encl,
1830                            List&lt;JCExpression&gt; typeargs,
1831                            JCExpression clazz,
1832                            List&lt;JCExpression&gt; args,
1833                            JCClassDecl def)
1834         {
1835             this.encl = encl;
1836             this.typeargs = (typeargs == null) ? List.nil()
1837                                                : typeargs;
1838             this.clazz = clazz;
1839             this.args = args;
1840             this.def = def;
1841         }
1842         @Override
1843         public void accept(Visitor v) { v.visitNewClass(this); }
1844 
1845         @DefinedBy(Api.COMPILER_TREE)
1846         public Kind getKind() { return Kind.NEW_CLASS; }
1847         @DefinedBy(Api.COMPILER_TREE)
1848         public JCExpression getEnclosingExpression() { // expr.new C&lt; ... &gt; ( ... )
1849             return encl;
1850         }
1851         @DefinedBy(Api.COMPILER_TREE)
1852         public List&lt;JCExpression&gt; getTypeArguments() {
1853             return typeargs;
1854         }
1855         @DefinedBy(Api.COMPILER_TREE)
1856         public JCExpression getIdentifier() { return clazz; }
1857         @DefinedBy(Api.COMPILER_TREE)
1858         public List&lt;JCExpression&gt; getArguments() {
1859             return args;
1860         }
1861         @DefinedBy(Api.COMPILER_TREE)
1862         public JCClassDecl getClassBody() { return def; }
1863         @Override @DefinedBy(Api.COMPILER_TREE)
1864         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1865             return v.visitNewClass(this, d);
1866         }
1867         @Override
1868         public Tag getTag() {
1869             return NEWCLASS;
1870         }
1871 
1872         public boolean classDeclRemoved() {
1873             return false;
1874         }
1875     }
1876 
1877     /**
1878      * A new[...] operation.
1879      */
1880     public static class JCNewArray extends JCExpression implements NewArrayTree {
1881         public JCExpression elemtype;
1882         public List&lt;JCExpression&gt; dims;
1883         // type annotations on inner-most component
1884         public List&lt;JCAnnotation&gt; annotations;
1885         // type annotations on dimensions
1886         public List&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations;
1887         public List&lt;JCExpression&gt; elems;
1888         protected JCNewArray(JCExpression elemtype,
1889                            List&lt;JCExpression&gt; dims,
1890                            List&lt;JCExpression&gt; elems)
1891         {
1892             this.elemtype = elemtype;
1893             this.dims = dims;
1894             this.annotations = List.nil();
1895             this.dimAnnotations = List.nil();
1896             this.elems = elems;
1897         }
1898         @Override
1899         public void accept(Visitor v) { v.visitNewArray(this); }
1900 
1901         @DefinedBy(Api.COMPILER_TREE)
1902         public Kind getKind() { return Kind.NEW_ARRAY; }
1903         @DefinedBy(Api.COMPILER_TREE)
1904         public JCExpression getType() { return elemtype; }
1905         @DefinedBy(Api.COMPILER_TREE)
1906         public List&lt;JCExpression&gt; getDimensions() {
1907             return dims;
1908         }
1909         @DefinedBy(Api.COMPILER_TREE)
1910         public List&lt;JCExpression&gt; getInitializers() {
1911             return elems;
1912         }
1913         @Override @DefinedBy(Api.COMPILER_TREE)
1914         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
1915             return v.visitNewArray(this, d);
1916         }
1917         @Override
1918         public Tag getTag() {
1919             return NEWARRAY;
1920         }
1921 
1922         @Override @DefinedBy(Api.COMPILER_TREE)
1923         public List&lt;JCAnnotation&gt; getAnnotations() {
1924             return annotations;
1925         }
1926 
1927         @Override @DefinedBy(Api.COMPILER_TREE)
1928         public List&lt;List&lt;JCAnnotation&gt;&gt; getDimAnnotations() {
1929             return dimAnnotations;
1930         }
1931     }
1932 
1933     /**
1934      * A lambda expression.
1935      */
1936     public static class JCLambda extends JCFunctionalExpression implements LambdaExpressionTree {
1937 
1938         public enum ParameterKind {
1939             IMPLICIT,
1940             EXPLICIT
1941         }
1942 
1943         public List&lt;JCVariableDecl&gt; params;
1944         public JCTree body;
1945         public boolean canCompleteNormally = true;
1946         public ParameterKind paramKind;
1947 
1948         public JCLambda(List&lt;JCVariableDecl&gt; params,
1949                         JCTree body) {
1950             this.params = params;
1951             this.body = body;
1952             if (params.isEmpty() ||
1953                 params.head.vartype != null) {
1954                 paramKind = ParameterKind.EXPLICIT;
1955             } else {
1956                 paramKind = ParameterKind.IMPLICIT;
1957             }
1958         }
1959         @Override
1960         public Tag getTag() {
1961             return LAMBDA;
1962         }
1963         @Override
1964         public void accept(Visitor v) {
1965             v.visitLambda(this);
1966         }
1967         @Override @DefinedBy(Api.COMPILER_TREE)
1968         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
1969             return v.visitLambdaExpression(this, d);
1970         }
1971         @DefinedBy(Api.COMPILER_TREE)
1972         public Kind getKind() {
1973             return Kind.LAMBDA_EXPRESSION;
1974         }
1975         @DefinedBy(Api.COMPILER_TREE)
1976         public JCTree getBody() {
1977             return body;
1978         }
1979         @DefinedBy(Api.COMPILER_TREE)
1980         public java.util.List&lt;? extends VariableTree&gt; getParameters() {
1981             return params;
1982         }
1983         @Override
1984         public JCLambda setType(Type type) {
1985             super.setType(type);
1986             return this;
1987         }
1988         @Override @DefinedBy(Api.COMPILER_TREE)
1989         public BodyKind getBodyKind() {
1990             return body.hasTag(BLOCK) ?
1991                     BodyKind.STATEMENT :
1992                     BodyKind.EXPRESSION;
1993         }
1994     }
1995 
1996     /**
1997      * A parenthesized subexpression ( ... )
1998      */
1999     public static class JCParens extends JCExpression implements ParenthesizedTree {
2000         public JCExpression expr;
2001         protected JCParens(JCExpression expr) {
2002             this.expr = expr;
2003         }
2004         @Override
2005         public void accept(Visitor v) { v.visitParens(this); }
2006 
2007         @DefinedBy(Api.COMPILER_TREE)
2008         public Kind getKind() { return Kind.PARENTHESIZED; }
2009         @DefinedBy(Api.COMPILER_TREE)
2010         public JCExpression getExpression() { return expr; }
2011         @Override @DefinedBy(Api.COMPILER_TREE)
2012         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2013             return v.visitParenthesized(this, d);
2014         }
2015         @Override
2016         public Tag getTag() {
2017             return PARENS;
2018         }
2019     }
2020 
2021     /**
2022      * A assignment with &quot;=&quot;.
2023      */
2024     public static class JCAssign extends JCExpression implements AssignmentTree {
2025         public JCExpression lhs;
2026         public JCExpression rhs;
2027         protected JCAssign(JCExpression lhs, JCExpression rhs) {
2028             this.lhs = lhs;
2029             this.rhs = rhs;
2030         }
2031         @Override
2032         public void accept(Visitor v) { v.visitAssign(this); }
2033 
2034         @DefinedBy(Api.COMPILER_TREE)
2035         public Kind getKind() { return Kind.ASSIGNMENT; }
2036         @DefinedBy(Api.COMPILER_TREE)
2037         public JCExpression getVariable() { return lhs; }
2038         @DefinedBy(Api.COMPILER_TREE)
2039         public JCExpression getExpression() { return rhs; }
2040         @Override @DefinedBy(Api.COMPILER_TREE)
2041         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2042             return v.visitAssignment(this, d);
2043         }
2044         @Override
2045         public Tag getTag() {
2046             return ASSIGN;
2047         }
2048     }
2049 
2050     public static abstract class JCOperatorExpression extends JCExpression {
2051         public enum OperandPos {
2052             LEFT,
2053             RIGHT
2054         }
2055 
2056         protected Tag opcode;
2057         public OperatorSymbol operator;
2058 
2059         public OperatorSymbol getOperator() {
2060             return operator;
2061         }
2062 
2063         @Override
2064         public Tag getTag() {
2065             return opcode;
2066         }
2067 
2068         public abstract JCExpression getOperand(OperandPos pos);
2069     }
2070 
2071     /**
2072      * An assignment with &quot;+=&quot;, &quot;|=&quot; ...
2073      */
2074     public static class JCAssignOp extends JCOperatorExpression implements CompoundAssignmentTree {
2075         public JCExpression lhs;
2076         public JCExpression rhs;
2077         protected JCAssignOp(Tag opcode, JCTree lhs, JCTree rhs, OperatorSymbol operator) {
2078             this.opcode = opcode;
2079             this.lhs = (JCExpression)lhs;
2080             this.rhs = (JCExpression)rhs;
2081             this.operator = operator;
2082         }
2083         @Override
2084         public void accept(Visitor v) { v.visitAssignop(this); }
2085 
2086         @DefinedBy(Api.COMPILER_TREE)
2087         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2088         @DefinedBy(Api.COMPILER_TREE)
2089         public JCExpression getVariable() { return lhs; }
2090         @DefinedBy(Api.COMPILER_TREE)
2091         public JCExpression getExpression() { return rhs; }
2092         @Override @DefinedBy(Api.COMPILER_TREE)
2093         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2094             return v.visitCompoundAssignment(this, d);
2095         }
2096         @Override
2097         public JCExpression getOperand(OperandPos pos) {
2098             return pos == OperandPos.LEFT ? lhs : rhs;
2099         }
2100     }
2101 
2102     /**
2103      * A unary operation.
2104      */
2105     public static class JCUnary extends JCOperatorExpression implements UnaryTree {
2106         public JCExpression arg;
2107         protected JCUnary(Tag opcode, JCExpression arg) {
2108             this.opcode = opcode;
2109             this.arg = arg;
2110         }
2111         @Override
2112         public void accept(Visitor v) { v.visitUnary(this); }
2113 
2114         @DefinedBy(Api.COMPILER_TREE)
2115         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2116         @DefinedBy(Api.COMPILER_TREE)
2117         public JCExpression getExpression() { return arg; }
2118         @Override @DefinedBy(Api.COMPILER_TREE)
2119         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2120             return v.visitUnary(this, d);
2121         }
2122         public void setTag(Tag tag) {
2123             opcode = tag;
2124         }
2125         @Override
2126         public JCExpression getOperand(OperandPos pos) {
2127             return arg;
2128         }
2129     }
2130 
2131     /**
2132      * A binary operation.
2133      */
2134     public static class JCBinary extends JCOperatorExpression implements BinaryTree {
2135         public JCExpression lhs;
2136         public JCExpression rhs;
2137         protected JCBinary(Tag opcode,
2138                          JCExpression lhs,
2139                          JCExpression rhs,
2140                          OperatorSymbol operator) {
2141             this.opcode = opcode;
2142             this.lhs = lhs;
2143             this.rhs = rhs;
2144             this.operator = operator;
2145         }
2146         @Override
2147         public void accept(Visitor v) { v.visitBinary(this); }
2148 
2149         @DefinedBy(Api.COMPILER_TREE)
2150         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2151         @DefinedBy(Api.COMPILER_TREE)
2152         public JCExpression getLeftOperand() { return lhs; }
2153         @DefinedBy(Api.COMPILER_TREE)
2154         public JCExpression getRightOperand() { return rhs; }
2155         @Override @DefinedBy(Api.COMPILER_TREE)
2156         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2157             return v.visitBinary(this, d);
2158         }
2159         @Override
2160         public JCExpression getOperand(OperandPos pos) {
2161             return pos == OperandPos.LEFT ? lhs : rhs;
2162         }
2163     }
2164 
2165     /**
2166      * A type cast.
2167      */
2168     public static class JCTypeCast extends JCExpression implements TypeCastTree {
2169         public JCTree clazz;
2170         public JCExpression expr;
2171         protected JCTypeCast(JCTree clazz, JCExpression expr) {
2172             this.clazz = clazz;
2173             this.expr = expr;
2174         }
2175         @Override
2176         public void accept(Visitor v) { v.visitTypeCast(this); }
2177 
2178         @DefinedBy(Api.COMPILER_TREE)
2179         public Kind getKind() { return Kind.TYPE_CAST; }
2180         @DefinedBy(Api.COMPILER_TREE)
2181         public JCTree getType() { return clazz; }
2182         @DefinedBy(Api.COMPILER_TREE)
2183         public JCExpression getExpression() { return expr; }
2184         @Override @DefinedBy(Api.COMPILER_TREE)
2185         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2186             return v.visitTypeCast(this, d);
2187         }
2188         @Override
2189         public Tag getTag() {
2190             return TYPECAST;
2191         }
2192     }
2193 
2194     /**
2195      * A type test.
2196      */
2197     public static class JCInstanceOf extends JCExpression implements InstanceOfTree {
2198         public JCExpression expr;
2199         public JCTree pattern;
2200         protected JCInstanceOf(JCExpression expr, JCTree pattern) {
2201             this.expr = expr;
2202             this.pattern = pattern;
2203         }
2204         @Override
2205         public void accept(Visitor v) { v.visitTypeTest(this); }
2206 
2207         @DefinedBy(Api.COMPILER_TREE)
2208         public Kind getKind() { return Kind.INSTANCE_OF; }
2209         @DefinedBy(Api.COMPILER_TREE)
2210         public JCTree getType() { return pattern instanceof JCPattern ? pattern.hasTag(BINDINGPATTERN) ? ((JCBindingPattern) pattern).vartype : null : pattern; }
2211 
2212         @Override @DefinedBy(Api.COMPILER_TREE)
2213         public JCPattern getPattern() {
2214             return pattern instanceof JCPattern ? (JCPattern) pattern : null;
2215         }
2216 
2217         @DefinedBy(Api.COMPILER_TREE)
2218         public JCExpression getExpression() { return expr; }
2219         @Override @DefinedBy(Api.COMPILER_TREE)
2220         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2221             return v.visitInstanceOf(this, d);
2222         }
2223         @Override
2224         public Tag getTag() {
2225             return TYPETEST;
2226         }
2227     }
2228 
2229     /**
2230      * Pattern matching forms.
2231      */
2232     public static abstract class JCPattern extends JCTree
2233             implements PatternTree {
2234         public JCExpression constExpression() {
2235             return null;
2236         }
2237     }
2238 
2239     public static class JCAnyPattern extends JCPattern
2240             implements AnyPatternTree {
2241 
2242         protected JCAnyPattern() {
2243         }
2244 
2245         @Override
2246         public void accept(Visitor v) {
2247             v.visitAnyPattern(this);
2248         }
2249 
2250         @DefinedBy(Api.COMPILER_TREE)
2251         public Kind getKind() {
2252             return Kind.ANY_PATTERN;
2253         }
2254 
2255         @Override
2256         @DefinedBy(Api.COMPILER_TREE)
2257         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2258             return v.visitAnyPattern(this, d);
2259         }
2260 
2261         @Override
2262         public Tag getTag() {
2263             return ANYPATTERN;
2264         }
2265     }
2266 
2267     public static class JCBindingPattern extends JCPattern
2268             implements BindingPatternTree {
2269         public Name name;
2270         public BindingSymbol symbol;
2271         public JCTree vartype;
2272 
2273         protected JCBindingPattern(Name name, BindingSymbol symbol, JCTree vartype) {
2274             this.name = name;
2275             this.symbol = symbol;
2276             this.vartype = vartype;
2277         }
2278 
2279         @DefinedBy(Api.COMPILER_TREE)
2280         public Name getBinding() {
2281             return name;
2282         }
2283 
2284         @Override @DefinedBy(Api.COMPILER_TREE)
2285         public Tree getType() {
2286             return vartype;
2287         }
2288 
2289         @Override
2290         public void accept(Visitor v) {
2291             v.visitBindingPattern(this);
2292         }
2293 
2294         @DefinedBy(Api.COMPILER_TREE)
2295         public Kind getKind() {
2296             return Kind.BINDING_PATTERN;
2297         }
2298 
2299         @Override
2300         @DefinedBy(Api.COMPILER_TREE)
2301         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2302             return v.visitBindingPattern(this, d);
2303         }
2304 
2305         @Override
2306         public Tag getTag() {
2307             return BINDINGPATTERN;
2308         }
2309     }
2310 
2311     public static class JCDeconstructionPattern extends JCPattern
2312             implements DeconstructionPatternTree {
2313         public Name name; //possibly null
2314 //        public BindingSymbol symbol;
2315         public JCExpression deconstructor;
2316         public List&lt;JCPattern&gt; nested;
2317         public Symbol extractorResolver; //TODO: MethodSymbol?; TODO: rename to pattern(Sym?)
2318         public List&lt;Type&gt; innerTypes;
2319 
2320         protected JCDeconstructionPattern(Name name, JCExpression deconstructor, List&lt;JCPattern&gt; nested) {
2321             this.name = name;
2322             this.deconstructor = deconstructor;
2323             this.nested = nested;
2324         }
2325 
2326         @DefinedBy(Api.COMPILER_TREE)
2327         public Name getBinding() {
2328             return name;
2329         }
2330 
2331         @Override @DefinedBy(Api.COMPILER_TREE)
2332         public Tree getDeconstructor() {
2333             return deconstructor;
2334         }
2335 
2336         @Override @DefinedBy(Api.COMPILER_TREE)
2337         public List&lt;? extends JCPattern&gt; getNestedPatterns() {
2338             return nested;
2339         }
2340 
2341         @Override
2342         public void accept(Visitor v) {
2343             v.visitDeconstructionPattern(this);
2344         }
2345 
2346         @DefinedBy(Api.COMPILER_TREE)
2347         public Kind getKind() {
2348             return Kind.DECONSTRUCTION_PATTERN;
2349         }
2350 
2351         @Override
2352         @DefinedBy(Api.COMPILER_TREE)
2353         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2354             return v.visitDeconstructionPattern(this, d);
2355         }
2356 
2357         @Override
2358         public Tag getTag() {
2359             return DECONSTRUCTIONPATTERN;
2360         }
2361     }
2362 
2363     public static class JCLiteralPattern extends JCPattern
2364             implements LiteralPatternTree {
2365 
2366         public JCExpression value;
2367         public LiteralPatternKind patternKind;
2368 
2369         protected JCLiteralPattern(JCExpression value) {
2370             Assert.checkNonNull(value);
2371             this.value = value;
2372         }
2373 
2374         @Override
2375         public void accept(Visitor v) {
2376             v.visitLiteralPattern(this);
2377         }
2378 
2379         @DefinedBy(Api.COMPILER_TREE)
2380         public Kind getKind() {
2381             return Kind.LITERAL_PATTERN;
2382         }
2383 
2384         @DefinedBy(Api.COMPILER_TREE)
2385         public JCExpression getValue() {
2386             return value;
2387         }
2388 
2389         @Override
2390         @DefinedBy(Api.COMPILER_TREE)
2391         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2392             return v.visitLiteralPattern(this, d);
2393         }
2394 
2395         @Override
2396         public Tag getTag() {
2397             return LITERALPATTERN;
2398         }
2399 
2400         @Override
2401         public JCExpression constExpression() {
2402             return value;
2403         }
2404 
2405         public enum LiteralPatternKind {
2406             CONSTANTEXPRESSIONORNULL,
2407             TYPE
2408         }
2409     }
2410 
2411     /**
2412      * An array selection
2413      */
2414     public static class JCArrayAccess extends JCExpression implements ArrayAccessTree {
2415         public JCExpression indexed;
2416         public JCExpression index;
2417         protected JCArrayAccess(JCExpression indexed, JCExpression index) {
2418             this.indexed = indexed;
2419             this.index = index;
2420         }
2421         @Override
2422         public void accept(Visitor v) { v.visitIndexed(this); }
2423 
2424         @DefinedBy(Api.COMPILER_TREE)
2425         public Kind getKind() { return Kind.ARRAY_ACCESS; }
2426         @DefinedBy(Api.COMPILER_TREE)
2427         public JCExpression getExpression() { return indexed; }
2428         @DefinedBy(Api.COMPILER_TREE)
2429         public JCExpression getIndex() { return index; }
2430         @Override @DefinedBy(Api.COMPILER_TREE)
2431         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2432             return v.visitArrayAccess(this, d);
2433         }
2434         @Override
2435         public Tag getTag() {
2436             return INDEXED;
2437         }
2438     }
2439 
2440     /**
2441      * Selects through packages and classes
2442      */
2443     public static class JCFieldAccess extends JCExpression implements MemberSelectTree {
2444         /** selected Tree hierarchy */
2445         public JCExpression selected;
2446         /** name of field to select thru */
2447         public Name name;
2448         /** symbol of the selected class */
2449         public Symbol sym;
2450         protected JCFieldAccess(JCExpression selected, Name name, Symbol sym) {
2451             this.selected = selected;
2452             this.name = name;
2453             this.sym = sym;
2454         }
2455         @Override
2456         public void accept(Visitor v) { v.visitSelect(this); }
2457 
2458         @DefinedBy(Api.COMPILER_TREE)
2459         public Kind getKind() { return Kind.MEMBER_SELECT; }
2460         @DefinedBy(Api.COMPILER_TREE)
2461         public JCExpression getExpression() { return selected; }
2462         @Override @DefinedBy(Api.COMPILER_TREE)
2463         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2464             return v.visitMemberSelect(this, d);
2465         }
2466         @DefinedBy(Api.COMPILER_TREE)
2467         public Name getIdentifier() { return name; }
2468         @Override
2469         public Tag getTag() {
2470             return SELECT;
2471         }
2472     }
2473 
2474     /**
2475      * Selects a member expression.
2476      */
2477     public static class JCMemberReference extends JCFunctionalExpression implements MemberReferenceTree {
2478 
2479         public ReferenceMode mode;
2480         public ReferenceKind kind;
2481         public Name name;
2482         public JCExpression expr;
2483         public List&lt;JCExpression&gt; typeargs;
2484         public Symbol sym;
2485         public Type varargsElement;
2486         public PolyKind refPolyKind;
2487         public boolean ownerAccessible;
2488         private OverloadKind overloadKind;
2489         public Type referentType;
2490 
2491         public enum OverloadKind {
2492             OVERLOADED,
2493             UNOVERLOADED,
2494             ERROR
2495         }
2496 
2497         /**
2498          * Javac-dependent classification for member references, based
2499          * on relevant properties w.r.t. code-generation
2500          */
2501         public enum ReferenceKind {
2502             /** super # instMethod */
2503             SUPER(ReferenceMode.INVOKE, false),
2504             /** Type # instMethod */
2505             UNBOUND(ReferenceMode.INVOKE, true),
2506             /** Type # staticMethod */
2507             STATIC(ReferenceMode.INVOKE, false),
2508             /** Expr # instMethod */
2509             BOUND(ReferenceMode.INVOKE, false),
2510             /** Inner # new */
2511             IMPLICIT_INNER(ReferenceMode.NEW, false),
2512             /** Toplevel # new */
2513             TOPLEVEL(ReferenceMode.NEW, false),
2514             /** ArrayType # new */
2515             ARRAY_CTOR(ReferenceMode.NEW, false);
2516 
2517             final ReferenceMode mode;
2518             final boolean unbound;
2519 
2520             private ReferenceKind(ReferenceMode mode, boolean unbound) {
2521                 this.mode = mode;
2522                 this.unbound = unbound;
2523             }
2524 
2525             public boolean isUnbound() {
2526                 return unbound;
2527             }
2528         }
2529 
2530         public JCMemberReference(ReferenceMode mode, Name name, JCExpression expr, List&lt;JCExpression&gt; typeargs) {
2531             this.mode = mode;
2532             this.name = name;
2533             this.expr = expr;
2534             this.typeargs = typeargs;
2535         }
2536         @Override
2537         public void accept(Visitor v) { v.visitReference(this); }
2538 
2539         @DefinedBy(Api.COMPILER_TREE)
2540         public Kind getKind() { return Kind.MEMBER_REFERENCE; }
2541         @Override @DefinedBy(Api.COMPILER_TREE)
2542         public ReferenceMode getMode() { return mode; }
2543         @Override @DefinedBy(Api.COMPILER_TREE)
2544         public JCExpression getQualifierExpression() { return expr; }
2545         @Override @DefinedBy(Api.COMPILER_TREE)
2546         public Name getName() { return name; }
2547         @Override @DefinedBy(Api.COMPILER_TREE)
2548         public List&lt;JCExpression&gt; getTypeArguments() { return typeargs; }
2549 
2550         @Override @DefinedBy(Api.COMPILER_TREE)
2551         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2552             return v.visitMemberReference(this, d);
2553         }
2554         @Override
2555         public Tag getTag() {
2556             return REFERENCE;
2557         }
2558         public boolean hasKind(ReferenceKind kind) {
2559             return this.kind == kind;
2560         }
2561 
2562         /**
2563          * @return the overloadKind
2564          */
2565         public OverloadKind getOverloadKind() {
2566             return overloadKind;
2567         }
2568 
2569         /**
2570          * @param overloadKind the overloadKind to set
2571          */
2572         public void setOverloadKind(OverloadKind overloadKind) {
2573             this.overloadKind = overloadKind;
2574         }
2575     }
2576 
2577     /**
2578      * An identifier
2579      */
2580     public static class JCIdent extends JCExpression implements IdentifierTree {
2581         /** the name */
2582         public Name name;
2583         /** the symbol */
2584         public Symbol sym;
2585         protected JCIdent(Name name, Symbol sym) {
2586             this.name = name;
2587             this.sym = sym;
2588         }
2589         @Override
2590         public void accept(Visitor v) { v.visitIdent(this); }
2591 
2592         @DefinedBy(Api.COMPILER_TREE)
2593         public Kind getKind() { return Kind.IDENTIFIER; }
2594         @DefinedBy(Api.COMPILER_TREE)
2595         public Name getName() { return name; }
2596         @Override @DefinedBy(Api.COMPILER_TREE)
2597         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2598             return v.visitIdentifier(this, d);
2599         }
2600         @Override
2601         public Tag getTag() {
2602             return IDENT;
2603         }
2604     }
2605 
2606     /**
2607      * A constant value given literally.
2608      */
2609     public static class JCLiteral extends JCExpression implements LiteralTree {
2610         public TypeTag typetag;
2611         /** value representation */
2612         public Object value;
2613         protected JCLiteral(TypeTag typetag, Object value) {
2614             this.typetag = typetag;
2615             this.value = value;
2616         }
2617         @Override
2618         public void accept(Visitor v) { v.visitLiteral(this); }
2619 
2620         @DefinedBy(Api.COMPILER_TREE)
2621         public Kind getKind() {
2622             return typetag.getKindLiteral();
2623         }
2624 
2625         @DefinedBy(Api.COMPILER_TREE)
2626         public Object getValue() {
2627             switch (typetag) {
2628                 case BOOLEAN:
2629                     int bi = (Integer) value;
2630                     return (bi != 0);
2631                 case CHAR:
2632                     int ci = (Integer) value;
2633                     char c = (char) ci;
2634                     if (c != ci)
2635                         throw new AssertionError(&quot;bad value for char literal&quot;);
2636                     return c;
2637                 default:
2638                     return value;
2639             }
2640         }
2641         @Override @DefinedBy(Api.COMPILER_TREE)
2642         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2643             return v.visitLiteral(this, d);
2644         }
2645         @Override
2646         public JCLiteral setType(Type type) {
2647             super.setType(type);
2648             return this;
2649         }
2650         @Override
2651         public Tag getTag() {
2652             return LITERAL;
2653         }
2654     }
2655 
2656     /**
2657      * Identifies a basic type.
2658      * @see TypeTag
2659      */
2660     public static class JCPrimitiveTypeTree extends JCExpression implements PrimitiveTypeTree {
2661         /** the basic type id */
2662         public TypeTag typetag;
2663         protected JCPrimitiveTypeTree(TypeTag typetag) {
2664             this.typetag = typetag;
2665         }
2666         @Override
2667         public void accept(Visitor v) { v.visitTypeIdent(this); }
2668 
2669         @DefinedBy(Api.COMPILER_TREE)
2670         public Kind getKind() { return Kind.PRIMITIVE_TYPE; }
2671         @DefinedBy(Api.COMPILER_TREE)
2672         public TypeKind getPrimitiveTypeKind() {
2673             return typetag.getPrimitiveTypeKind();
2674         }
2675 
2676         @Override @DefinedBy(Api.COMPILER_TREE)
2677         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2678             return v.visitPrimitiveType(this, d);
2679         }
2680         @Override
2681         public Tag getTag() {
2682             return TYPEIDENT;
2683         }
2684     }
2685 
2686     /**
2687      * An array type, A[]
2688      */
2689     public static class JCArrayTypeTree extends JCExpression implements ArrayTypeTree {
2690         public JCExpression elemtype;
2691         protected JCArrayTypeTree(JCExpression elemtype) {
2692             this.elemtype = elemtype;
2693         }
2694         @Override
2695         public void accept(Visitor v) { v.visitTypeArray(this); }
2696 
2697         @DefinedBy(Api.COMPILER_TREE)
2698         public Kind getKind() { return Kind.ARRAY_TYPE; }
2699         @DefinedBy(Api.COMPILER_TREE)
2700         public JCTree getType() { return elemtype; }
2701         @Override @DefinedBy(Api.COMPILER_TREE)
2702         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2703             return v.visitArrayType(this, d);
2704         }
2705         @Override
2706         public Tag getTag() {
2707             return TYPEARRAY;
2708         }
2709     }
2710 
2711     /**
2712      * A parameterized type, {@literal T&lt;...&gt;}
2713      */
2714     public static class JCTypeApply extends JCExpression implements ParameterizedTypeTree {
2715         public JCExpression clazz;
2716         public List&lt;JCExpression&gt; arguments;
2717         protected JCTypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
2718             this.clazz = clazz;
2719             this.arguments = arguments;
2720         }
2721         @Override
2722         public void accept(Visitor v) { v.visitTypeApply(this); }
2723 
2724         @DefinedBy(Api.COMPILER_TREE)
2725         public Kind getKind() { return Kind.PARAMETERIZED_TYPE; }
2726         @DefinedBy(Api.COMPILER_TREE)
2727         public JCTree getType() { return clazz; }
2728         @DefinedBy(Api.COMPILER_TREE)
2729         public List&lt;JCExpression&gt; getTypeArguments() {
2730             return arguments;
2731         }
2732         @Override @DefinedBy(Api.COMPILER_TREE)
2733         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2734             return v.visitParameterizedType(this, d);
2735         }
2736         @Override
2737         public Tag getTag() {
2738             return TYPEAPPLY;
2739         }
2740     }
2741 
2742     /**
2743      * A union type, T1 | T2 | ... Tn (used in multicatch statements)
2744      */
2745     public static class JCTypeUnion extends JCExpression implements UnionTypeTree {
2746 
2747         public List&lt;JCExpression&gt; alternatives;
2748 
2749         protected JCTypeUnion(List&lt;JCExpression&gt; components) {
2750             this.alternatives = components;
2751         }
2752         @Override
2753         public void accept(Visitor v) { v.visitTypeUnion(this); }
2754 
2755         @DefinedBy(Api.COMPILER_TREE)
2756         public Kind getKind() { return Kind.UNION_TYPE; }
2757 
2758         @DefinedBy(Api.COMPILER_TREE)
2759         public List&lt;JCExpression&gt; getTypeAlternatives() {
2760             return alternatives;
2761         }
2762         @Override @DefinedBy(Api.COMPILER_TREE)
2763         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2764             return v.visitUnionType(this, d);
2765         }
2766         @Override
2767         public Tag getTag() {
2768             return TYPEUNION;
2769         }
2770     }
2771 
2772     /**
2773      * An intersection type, {@code T1 &amp; T2 &amp; ... Tn} (used in cast expressions)
2774      */
2775     public static class JCTypeIntersection extends JCExpression implements IntersectionTypeTree {
2776 
2777         public List&lt;JCExpression&gt; bounds;
2778 
2779         protected JCTypeIntersection(List&lt;JCExpression&gt; bounds) {
2780             this.bounds = bounds;
2781         }
2782         @Override
2783         public void accept(Visitor v) { v.visitTypeIntersection(this); }
2784 
2785         @DefinedBy(Api.COMPILER_TREE)
2786         public Kind getKind() { return Kind.INTERSECTION_TYPE; }
2787 
2788         @DefinedBy(Api.COMPILER_TREE)
2789         public List&lt;JCExpression&gt; getBounds() {
2790             return bounds;
2791         }
2792         @Override @DefinedBy(Api.COMPILER_TREE)
2793         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2794             return v.visitIntersectionType(this, d);
2795         }
2796         @Override
2797         public Tag getTag() {
2798             return TYPEINTERSECTION;
2799         }
2800     }
2801 
2802     /**
2803      * A formal class parameter.
2804      */
2805     public static class JCTypeParameter extends JCTree implements TypeParameterTree {
2806         /** name */
2807         public Name name;
2808         /** bounds */
2809         public List&lt;JCExpression&gt; bounds;
2810         /** type annotations on type parameter */
2811         public List&lt;JCAnnotation&gt; annotations;
2812         protected JCTypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annotations) {
2813             this.name = name;
2814             this.bounds = bounds;
2815             this.annotations = annotations;
2816         }
2817         @Override
2818         public void accept(Visitor v) { v.visitTypeParameter(this); }
2819 
2820         @DefinedBy(Api.COMPILER_TREE)
2821         public Kind getKind() { return Kind.TYPE_PARAMETER; }
2822         @DefinedBy(Api.COMPILER_TREE)
2823         public Name getName() { return name; }
2824         @DefinedBy(Api.COMPILER_TREE)
2825         public List&lt;JCExpression&gt; getBounds() {
2826             return bounds;
2827         }
2828         @DefinedBy(Api.COMPILER_TREE)
2829         public List&lt;JCAnnotation&gt; getAnnotations() {
2830             return annotations;
2831         }
2832         @Override @DefinedBy(Api.COMPILER_TREE)
2833         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2834             return v.visitTypeParameter(this, d);
2835         }
2836         @Override
2837         public Tag getTag() {
2838             return TYPEPARAMETER;
2839         }
2840     }
2841 
2842     public static class JCWildcard extends JCExpression implements WildcardTree {
2843         public TypeBoundKind kind;
2844         public JCTree inner;
2845         protected JCWildcard(TypeBoundKind kind, JCTree inner) {
2846             this.kind = Assert.checkNonNull(kind);
2847             this.inner = inner;
2848         }
2849         @Override
2850         public void accept(Visitor v) { v.visitWildcard(this); }
2851 
2852         @DefinedBy(Api.COMPILER_TREE)
2853         public Kind getKind() {
2854             switch (kind.kind) {
2855             case UNBOUND:
2856                 return Kind.UNBOUNDED_WILDCARD;
2857             case EXTENDS:
2858                 return Kind.EXTENDS_WILDCARD;
2859             case SUPER:
2860                 return Kind.SUPER_WILDCARD;
2861             default:
2862                 throw new AssertionError(&quot;Unknown wildcard bound &quot; + kind);
2863             }
2864         }
2865         @DefinedBy(Api.COMPILER_TREE)
2866         public JCTree getBound() { return inner; }
2867         @Override @DefinedBy(Api.COMPILER_TREE)
2868         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2869             return v.visitWildcard(this, d);
2870         }
2871         @Override
2872         public Tag getTag() {
2873             return Tag.WILDCARD;
2874         }
2875     }
2876 
2877     public static class TypeBoundKind extends JCTree {
2878         public BoundKind kind;
2879         protected TypeBoundKind(BoundKind kind) {
2880             this.kind = kind;
2881         }
2882         @Override
2883         public void accept(Visitor v) { v.visitTypeBoundKind(this); }
2884 
2885         @DefinedBy(Api.COMPILER_TREE)
2886         public Kind getKind() {
2887             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2888         }
2889         @Override @DefinedBy(Api.COMPILER_TREE)
2890         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2891             throw new AssertionError(&quot;TypeBoundKind is not part of a public API&quot;);
2892         }
2893         @Override
2894         public Tag getTag() {
2895             return TYPEBOUNDKIND;
2896         }
2897     }
2898 
2899     public static class JCAnnotation extends JCExpression implements AnnotationTree {
2900         // Either Tag.ANNOTATION or Tag.TYPE_ANNOTATION
2901         private Tag tag;
2902 
2903         public JCTree annotationType;
2904         public List&lt;JCExpression&gt; args;
2905         public Attribute.Compound attribute;
2906 
2907         protected JCAnnotation(Tag tag, JCTree annotationType, List&lt;JCExpression&gt; args) {
2908             this.tag = tag;
2909             this.annotationType = annotationType;
2910             this.args = args;
2911         }
2912 
2913         @Override
2914         public void accept(Visitor v) { v.visitAnnotation(this); }
2915 
2916         @DefinedBy(Api.COMPILER_TREE)
2917         public Kind getKind() { return TreeInfo.tagToKind(getTag()); }
2918 
2919         @DefinedBy(Api.COMPILER_TREE)
2920         public JCTree getAnnotationType() { return annotationType; }
2921         @DefinedBy(Api.COMPILER_TREE)
2922         public List&lt;JCExpression&gt; getArguments() {
2923             return args;
2924         }
2925         @Override @DefinedBy(Api.COMPILER_TREE)
2926         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2927             return v.visitAnnotation(this, d);
2928         }
2929         @Override
2930         public Tag getTag() {
2931             return tag;
2932         }
2933     }
2934 
2935     public static class JCModifiers extends JCTree implements com.sun.source.tree.ModifiersTree {
2936         public long flags;
2937         public List&lt;JCAnnotation&gt; annotations;
2938         protected JCModifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
2939             this.flags = flags;
2940             this.annotations = annotations;
2941         }
2942         @Override
2943         public void accept(Visitor v) { v.visitModifiers(this); }
2944 
2945         @DefinedBy(Api.COMPILER_TREE)
2946         public Kind getKind() { return Kind.MODIFIERS; }
2947         @DefinedBy(Api.COMPILER_TREE)
2948         public Set&lt;Modifier&gt; getFlags() {
2949             return Flags.asModifierSet(flags);
2950         }
2951         @DefinedBy(Api.COMPILER_TREE)
2952         public List&lt;JCAnnotation&gt; getAnnotations() {
2953             return annotations;
2954         }
2955         @Override @DefinedBy(Api.COMPILER_TREE)
2956         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2957             return v.visitModifiers(this, d);
2958         }
2959         @Override
2960         public Tag getTag() {
2961             return MODIFIERS;
2962         }
2963     }
2964 
2965     public static class JCAnnotatedType extends JCExpression implements com.sun.source.tree.AnnotatedTypeTree {
2966         // type annotations
2967         public List&lt;JCAnnotation&gt; annotations;
2968         public JCExpression underlyingType;
2969 
2970         protected JCAnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
2971             Assert.check(annotations != null &amp;&amp; annotations.nonEmpty());
2972             this.annotations = annotations;
2973             this.underlyingType = underlyingType;
2974         }
2975         @Override
2976         public void accept(Visitor v) { v.visitAnnotatedType(this); }
2977 
2978         @DefinedBy(Api.COMPILER_TREE)
2979         public Kind getKind() { return Kind.ANNOTATED_TYPE; }
2980         @DefinedBy(Api.COMPILER_TREE)
2981         public List&lt;JCAnnotation&gt; getAnnotations() {
2982             return annotations;
2983         }
2984         @DefinedBy(Api.COMPILER_TREE)
2985         public JCExpression getUnderlyingType() {
2986             return underlyingType;
2987         }
2988         @Override @DefinedBy(Api.COMPILER_TREE)
2989         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
2990             return v.visitAnnotatedType(this, d);
2991         }
2992         @Override
2993         public Tag getTag() {
2994             return ANNOTATED_TYPE;
2995         }
2996     }
2997 
2998     public static abstract class JCDirective extends JCTree
2999         implements DirectiveTree {
3000     }
3001 
3002     public static class JCModuleDecl extends JCTree implements ModuleTree {
3003         public JCModifiers mods;
3004         public ModuleType type;
3005         private final ModuleKind kind;
3006         public JCExpression qualId;
3007         public List&lt;JCDirective&gt; directives;
3008         public ModuleSymbol sym;
3009 
3010         protected JCModuleDecl(JCModifiers mods, ModuleKind kind,
3011                 JCExpression qualId, List&lt;JCDirective&gt; directives) {
3012             this.mods = mods;
3013             this.kind = kind;
3014             this.qualId = qualId;
3015             this.directives = directives;
3016         }
3017 
3018         @Override
3019         public void accept(Visitor v) { v.visitModuleDef(this); }
3020 
3021         @Override @DefinedBy(Api.COMPILER_TREE)
3022         public Kind getKind() {
3023             return Kind.MODULE;
3024         }
3025 
3026         @Override @DefinedBy(Api.COMPILER_TREE)
3027         public List&lt;? extends AnnotationTree&gt; getAnnotations() {
3028             return mods.annotations;
3029         }
3030 
3031         @Override @DefinedBy(Api.COMPILER_TREE)
3032         public ModuleKind getModuleType() {
3033             return kind;
3034         }
3035 
3036         @Override @DefinedBy(Api.COMPILER_TREE)
3037         public JCExpression getName() {
3038             return qualId;
3039         }
3040 
3041         @Override @DefinedBy(Api.COMPILER_TREE)
3042         public List&lt;JCDirective&gt; getDirectives() {
3043             return directives;
3044         }
3045 
3046         @Override @DefinedBy(Api.COMPILER_TREE)
3047         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3048             return v.visitModule(this, d);
3049         }
3050 
3051         @Override
3052         public Tag getTag() {
3053             return MODULEDEF;
3054         }
3055     }
3056 
3057     public static class JCExports extends JCDirective
3058             implements ExportsTree {
3059         public JCExpression qualid;
3060         public List&lt;JCExpression&gt; moduleNames;
3061         public ExportsDirective directive;
3062 
3063         protected JCExports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
3064             this.qualid = qualId;
3065             this.moduleNames = moduleNames;
3066         }
3067 
3068         @Override
3069         public void accept(Visitor v) { v.visitExports(this); }
3070 
3071         @Override @DefinedBy(Api.COMPILER_TREE)
3072         public Kind getKind() {
3073             return Kind.EXPORTS;
3074         }
3075 
3076         @Override @DefinedBy(Api.COMPILER_TREE)
3077         public JCExpression getPackageName() {
3078             return qualid;
3079         }
3080 
3081         @Override @DefinedBy(Api.COMPILER_TREE)
3082         public List&lt;JCExpression&gt; getModuleNames() {
3083             return moduleNames;
3084         }
3085 
3086         @Override @DefinedBy(Api.COMPILER_TREE)
3087         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3088             return v.visitExports(this, d);
3089         }
3090 
3091         @Override
3092         public Tag getTag() {
3093             return Tag.EXPORTS;
3094         }
3095     }
3096 
3097     public static class JCOpens extends JCDirective
3098             implements OpensTree {
3099         public JCExpression qualid;
3100         public List&lt;JCExpression&gt; moduleNames;
3101         public OpensDirective directive;
3102 
3103         protected JCOpens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
3104             this.qualid = qualId;
3105             this.moduleNames = moduleNames;
3106         }
3107 
3108         @Override
3109         public void accept(Visitor v) { v.visitOpens(this); }
3110 
3111         @Override @DefinedBy(Api.COMPILER_TREE)
3112         public Kind getKind() {
3113             return Kind.OPENS;
3114         }
3115 
3116         @Override @DefinedBy(Api.COMPILER_TREE)
3117         public JCExpression getPackageName() {
3118             return qualid;
3119         }
3120 
3121         @Override @DefinedBy(Api.COMPILER_TREE)
3122         public List&lt;JCExpression&gt; getModuleNames() {
3123             return moduleNames;
3124         }
3125 
3126         @Override @DefinedBy(Api.COMPILER_TREE)
3127         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3128             return v.visitOpens(this, d);
3129         }
3130 
3131         @Override
3132         public Tag getTag() {
3133             return Tag.OPENS;
3134         }
3135     }
3136 
3137     public static class JCProvides extends JCDirective
3138             implements ProvidesTree {
3139         public JCExpression serviceName;
3140         public List&lt;JCExpression&gt; implNames;
3141 
3142         protected JCProvides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
3143             this.serviceName = serviceName;
3144             this.implNames = implNames;
3145         }
3146 
3147         @Override
3148         public void accept(Visitor v) { v.visitProvides(this); }
3149 
3150         @Override @DefinedBy(Api.COMPILER_TREE)
3151         public Kind getKind() {
3152             return Kind.PROVIDES;
3153         }
3154 
3155         @Override @DefinedBy(Api.COMPILER_TREE)
3156         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3157             return v.visitProvides(this, d);
3158         }
3159 
3160         @Override @DefinedBy(Api.COMPILER_TREE)
3161         public JCExpression getServiceName() {
3162             return serviceName;
3163         }
3164 
3165         @Override @DefinedBy(Api.COMPILER_TREE)
3166         public List&lt;JCExpression&gt; getImplementationNames() {
3167             return implNames;
3168         }
3169 
3170         @Override
3171         public Tag getTag() {
3172             return PROVIDES;
3173         }
3174     }
3175 
3176     public static class JCRequires extends JCDirective
3177             implements RequiresTree {
3178         public boolean isTransitive;
3179         public boolean isStaticPhase;
3180         public JCExpression moduleName;
3181         public RequiresDirective directive;
3182 
3183         protected JCRequires(boolean isTransitive, boolean isStaticPhase, JCExpression moduleName) {
3184             this.isTransitive = isTransitive;
3185             this.isStaticPhase = isStaticPhase;
3186             this.moduleName = moduleName;
3187         }
3188 
3189         @Override
3190         public void accept(Visitor v) { v.visitRequires(this); }
3191 
3192         @Override @DefinedBy(Api.COMPILER_TREE)
3193         public Kind getKind() {
3194             return Kind.REQUIRES;
3195         }
3196 
3197         @Override @DefinedBy(Api.COMPILER_TREE)
3198         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3199             return v.visitRequires(this, d);
3200         }
3201 
3202         @Override @DefinedBy(Api.COMPILER_TREE)
3203         public boolean isTransitive() {
3204             return isTransitive;
3205         }
3206 
3207         @Override @DefinedBy(Api.COMPILER_TREE)
3208         public boolean isStatic() {
3209             return isStaticPhase;
3210         }
3211 
3212         @Override @DefinedBy(Api.COMPILER_TREE)
3213         public JCExpression getModuleName() {
3214             return moduleName;
3215         }
3216 
3217         @Override
3218         public Tag getTag() {
3219             return REQUIRES;
3220         }
3221     }
3222 
3223     public static class JCUses extends JCDirective
3224             implements UsesTree {
3225         public JCExpression qualid;
3226 
3227         protected JCUses(JCExpression qualId) {
3228             this.qualid = qualId;
3229         }
3230 
3231         @Override
3232         public void accept(Visitor v) { v.visitUses(this); }
3233 
3234         @Override @DefinedBy(Api.COMPILER_TREE)
3235         public Kind getKind() {
3236             return Kind.USES;
3237         }
3238 
3239         @Override @DefinedBy(Api.COMPILER_TREE)
3240         public JCExpression getServiceName() {
3241             return qualid;
3242         }
3243 
3244         @Override @DefinedBy(Api.COMPILER_TREE)
3245         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
3246             return v.visitUses(this, d);
3247         }
3248 
3249         @Override
3250         public Tag getTag() {
3251             return USES;
3252         }
3253     }
3254 
3255     public static class JCErroneous extends JCExpression
3256             implements ErroneousTree {
3257         public List&lt;? extends JCTree&gt; errs;
3258         protected JCErroneous(List&lt;? extends JCTree&gt; errs) {
3259             this.errs = errs;
3260         }
3261         @Override
3262         public void accept(Visitor v) { v.visitErroneous(this); }
3263 
3264         @DefinedBy(Api.COMPILER_TREE)
3265         public Kind getKind() { return Kind.ERRONEOUS; }
3266 
3267         @DefinedBy(Api.COMPILER_TREE)
3268         public List&lt;? extends JCTree&gt; getErrorTrees() {
3269             return errs;
3270         }
3271 
3272         @Override @DefinedBy(Api.COMPILER_TREE)
3273         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3274             return v.visitErroneous(this, d);
3275         }
3276         @Override
3277         public Tag getTag() {
3278             return ERRONEOUS;
3279         }
3280     }
3281 
3282     /** (let int x = 3; in x+2) */
3283     public static class LetExpr extends JCExpression {
3284         public List&lt;? extends JCStatement&gt; defs;
3285         public JCExpression expr;
3286         /**true if a expr should be run through Gen.genCond:*/
3287         public boolean needsCond;
3288         protected LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr) {
3289             this.defs = defs;
3290             this.expr = expr;
3291         }
3292         @Override
3293         public void accept(Visitor v) { v.visitLetExpr(this); }
3294 
3295         @DefinedBy(Api.COMPILER_TREE)
3296         public Kind getKind() {
3297             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3298         }
3299         @Override @DefinedBy(Api.COMPILER_TREE)
3300         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3301             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3302         }
3303         @Override
3304         public Tag getTag() {
3305             return LETEXPR;
3306         }
3307     }
3308 
3309     /** An interface for tree factories
3310      */
3311     public interface Factory {
3312         JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs);
3313         JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
3314                                   JCExpression pid);
3315         JCImport Import(JCTree qualid, boolean staticImport);
3316         JCClassDecl ClassDef(JCModifiers mods,
3317                           Name name,
3318                           List&lt;JCTypeParameter&gt; typarams,
3319                           JCExpression extending,
3320                           List&lt;JCExpression&gt; implementing,
3321                           List&lt;JCTree&gt; defs);
3322         JCMethodDecl MethodDef(JCModifiers mods,
3323                             Name name,
3324                             JCExpression restype,
3325                             List&lt;JCTypeParameter&gt; typarams,
3326                             JCVariableDecl recvparam,
3327                             List&lt;JCVariableDecl&gt; params,
3328                             List&lt;JCExpression&gt; thrown,
3329                             JCBlock body,
3330                             JCExpression defaultValue);
3331         JCVariableDecl VarDef(JCModifiers mods,
3332                       Name name,
3333                       JCExpression vartype,
3334                       JCExpression init);
3335         JCSkip Skip();
3336         JCBlock Block(long flags, List&lt;JCStatement&gt; stats);
3337         JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond);
3338         JCWhileLoop WhileLoop(JCExpression cond, JCStatement body);
3339         JCForLoop ForLoop(List&lt;JCStatement&gt; init,
3340                         JCExpression cond,
3341                         List&lt;JCExpressionStatement&gt; step,
3342                         JCStatement body);
3343         JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body);
3344         JCLabeledStatement Labelled(Name label, JCStatement body);
3345         JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases);
3346         JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases);
3347         JCCase Case(CaseKind caseKind, List&lt;JCPattern&gt; pat,
3348                     List&lt;JCStatement&gt; stats, JCTree body);
3349         JCSynchronized Synchronized(JCExpression lock, JCBlock body);
3350         JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer);
3351         JCTry Try(List&lt;JCTree&gt; resources,
3352                   JCBlock body,
3353                   List&lt;JCCatch&gt; catchers,
3354                   JCBlock finalizer);
3355         JCCatch Catch(JCVariableDecl param, JCBlock body);
3356         JCConditional Conditional(JCExpression cond,
3357                                 JCExpression thenpart,
3358                                 JCExpression elsepart);
3359         JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart);
3360         JCExpressionStatement Exec(JCExpression expr);
3361         JCBreak Break(Name label);
3362         JCYield Yield(JCExpression value);
3363         JCContinue Continue(Name label);
3364         JCReturn Return(JCExpression expr);
3365         JCThrow Throw(JCExpression expr);
3366         JCAssert Assert(JCExpression cond, JCExpression detail);
3367         JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
3368                     JCExpression fn,
3369                     List&lt;JCExpression&gt; args);
3370         JCNewClass NewClass(JCExpression encl,
3371                           List&lt;JCExpression&gt; typeargs,
3372                           JCExpression clazz,
3373                           List&lt;JCExpression&gt; args,
3374                           JCClassDecl def);
3375         JCNewArray NewArray(JCExpression elemtype,
3376                           List&lt;JCExpression&gt; dims,
3377                           List&lt;JCExpression&gt; elems);
3378         JCParens Parens(JCExpression expr);
3379         JCAssign Assign(JCExpression lhs, JCExpression rhs);
3380         JCAssignOp Assignop(Tag opcode, JCTree lhs, JCTree rhs);
3381         JCUnary Unary(Tag opcode, JCExpression arg);
3382         JCBinary Binary(Tag opcode, JCExpression lhs, JCExpression rhs);
3383         JCTypeCast TypeCast(JCTree expr, JCExpression type);
3384         JCInstanceOf TypeTest(JCExpression expr, JCTree clazz);
3385         JCBindingPattern BindingPattern(Name name, JCTree vartype);
3386         JCLiteralPattern LiteralPattern(JCExpression cexp);
3387         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3388         JCFieldAccess Select(JCExpression selected, Name selector);
3389         JCIdent Ident(Name idname);
3390         JCLiteral Literal(TypeTag tag, Object value);
3391         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3392         JCArrayTypeTree TypeArray(JCExpression elemtype);
3393         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3394         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3395         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3396         TypeBoundKind TypeBoundKind(BoundKind kind);
3397         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3398         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3399         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3400         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3401         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3402         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3403         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3404         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3405         JCUses Uses(JCExpression qualId);
3406         LetExpr LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr);
3407     }
3408 
3409     /** A generic visitor class for trees.
3410      */
3411     public static abstract class Visitor {
3412         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3413         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3414         public void visitImport(JCImport that)               { visitTree(that); }
3415         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3416         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3417         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3418         public void visitSkip(JCSkip that)                   { visitTree(that); }
3419         public void visitBlock(JCBlock that)                 { visitTree(that); }
3420         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3421         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3422         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3423         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3424         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3425         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3426         public void visitCase(JCCase that)                   { visitTree(that); }
3427         public void visitSwitchExpression(JCSwitchExpression that)               { visitTree(that); }
3428         public void visitSynchronized(JCSynchronized that)   { visitTree(that); }
3429         public void visitTry(JCTry that)                     { visitTree(that); }
3430         public void visitCatch(JCCatch that)                 { visitTree(that); }
3431         public void visitConditional(JCConditional that)     { visitTree(that); }
3432         public void visitIf(JCIf that)                       { visitTree(that); }
3433         public void visitExec(JCExpressionStatement that)    { visitTree(that); }
3434         public void visitBreak(JCBreak that)                 { visitTree(that); }
3435         public void visitYield(JCYield that)                 { visitTree(that); }
3436         public void visitContinue(JCContinue that)           { visitTree(that); }
3437         public void visitReturn(JCReturn that)               { visitTree(that); }
3438         public void visitThrow(JCThrow that)                 { visitTree(that); }
3439         public void visitAssert(JCAssert that)               { visitTree(that); }
3440         public void visitApply(JCMethodInvocation that)      { visitTree(that); }
3441         public void visitNewClass(JCNewClass that)           { visitTree(that); }
3442         public void visitNewArray(JCNewArray that)           { visitTree(that); }
3443         public void visitLambda(JCLambda that)               { visitTree(that); }
3444         public void visitParens(JCParens that)               { visitTree(that); }
3445         public void visitAssign(JCAssign that)               { visitTree(that); }
3446         public void visitAssignop(JCAssignOp that)           { visitTree(that); }
3447         public void visitUnary(JCUnary that)                 { visitTree(that); }
3448         public void visitBinary(JCBinary that)               { visitTree(that); }
3449         public void visitTypeCast(JCTypeCast that)           { visitTree(that); }
3450         public void visitTypeTest(JCInstanceOf that)         { visitTree(that); }
3451         public void visitAnyPattern(JCAnyPattern that)       { visitTree(that); }
3452         public void visitBindingPattern(JCBindingPattern that) { visitTree(that); }
3453         public void visitDeconstructionPattern(JCDeconstructionPattern that) { visitTree(that); }
3454         public void visitLiteralPattern(JCLiteralPattern that) { visitTree(that); }
3455         public void visitIndexed(JCArrayAccess that)         { visitTree(that); }
3456         public void visitSelect(JCFieldAccess that)          { visitTree(that); }
3457         public void visitReference(JCMemberReference that)   { visitTree(that); }
3458         public void visitIdent(JCIdent that)                 { visitTree(that); }
3459         public void visitLiteral(JCLiteral that)             { visitTree(that); }
3460         public void visitTypeIdent(JCPrimitiveTypeTree that) { visitTree(that); }
3461         public void visitTypeArray(JCArrayTypeTree that)     { visitTree(that); }
3462         public void visitTypeApply(JCTypeApply that)         { visitTree(that); }
3463         public void visitTypeUnion(JCTypeUnion that)         { visitTree(that); }
3464         public void visitTypeIntersection(JCTypeIntersection that)  { visitTree(that); }
3465         public void visitTypeParameter(JCTypeParameter that) { visitTree(that); }
3466         public void visitWildcard(JCWildcard that)           { visitTree(that); }
3467         public void visitTypeBoundKind(TypeBoundKind that)   { visitTree(that); }
3468         public void visitAnnotation(JCAnnotation that)       { visitTree(that); }
3469         public void visitModifiers(JCModifiers that)         { visitTree(that); }
3470         public void visitAnnotatedType(JCAnnotatedType that) { visitTree(that); }
3471         public void visitErroneous(JCErroneous that)         { visitTree(that); }
3472         public void visitModuleDef(JCModuleDecl that)        { visitTree(that); }
3473         public void visitExports(JCExports that)             { visitTree(that); }
3474         public void visitOpens(JCOpens that)                 { visitTree(that); }
3475         public void visitProvides(JCProvides that)           { visitTree(that); }
3476         public void visitRequires(JCRequires that)           { visitTree(that); }
3477         public void visitUses(JCUses that)                   { visitTree(that); }
3478         public void visitLetExpr(LetExpr that)               { visitTree(that); }
3479 
3480         public void visitTree(JCTree that)                   { Assert.error(); }
3481     }
3482 
3483 }
    </pre>
  </body>
</html>
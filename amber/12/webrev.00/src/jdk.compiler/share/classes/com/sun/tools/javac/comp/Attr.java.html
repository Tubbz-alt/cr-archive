<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.compiler/share/classes/com/sun/tools/javac/comp/Attr.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.comp;
  27 
  28 import sun.invoke.util.BytecodeName;
  29 
  30 import java.util.*;
  31 import java.util.function.BiConsumer;
  32 import java.util.stream.Stream;
  33 
  34 import javax.lang.model.element.ElementKind;
  35 import javax.tools.JavaFileObject;
  36 
  37 import com.sun.source.tree.CaseTree;
  38 import com.sun.source.tree.CaseTree.CaseKind;
  39 import com.sun.source.tree.IdentifierTree;
  40 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  41 import com.sun.source.tree.MemberSelectTree;
  42 import com.sun.source.tree.TreeVisitor;
  43 import com.sun.source.util.SimpleTreeVisitor;
  44 import com.sun.tools.javac.code.*;
  45 import com.sun.tools.javac.code.Lint.LintCategory;
  46 import com.sun.tools.javac.code.Scope.WriteableScope;
  47 import com.sun.tools.javac.code.Source.Feature;
  48 import com.sun.tools.javac.code.Symbol.*;
  49 import com.sun.tools.javac.code.Type.*;
  50 import com.sun.tools.javac.code.TypeMetadata.Annotations;
  51 import com.sun.tools.javac.code.Types.FunctionDescriptorLookupError;
  52 import com.sun.tools.javac.comp.ArgumentAttr.LocalCacheContext;
  53 import com.sun.tools.javac.comp.Check.CheckContext;
  54 import com.sun.tools.javac.comp.DeferredAttr.AttrMode;
  55 import com.sun.tools.javac.comp.MatchBindingsComputer.MatchBindings;
  56 import com.sun.tools.javac.jvm.*;
  57 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.Diamond;
  58 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArg;
  59 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.DiamondInvalidArgs;
  60 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  61 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  62 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  63 import com.sun.tools.javac.tree.*;
  64 import com.sun.tools.javac.tree.JCTree.*;
  65 import com.sun.tools.javac.tree.JCTree.JCLiteralPattern.LiteralPatternKind;
  66 import com.sun.tools.javac.tree.JCTree.JCPolyExpression.*;
  67 import com.sun.tools.javac.util.*;
  68 import com.sun.tools.javac.util.DefinedBy.Api;
  69 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  70 import com.sun.tools.javac.util.JCDiagnostic.Error;
  71 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  72 import com.sun.tools.javac.util.JCDiagnostic.Warning;
  73 import com.sun.tools.javac.util.List;
  74 
  75 import static com.sun.tools.javac.code.Flags.*;
  76 import static com.sun.tools.javac.code.Flags.ANNOTATION;
  77 import static com.sun.tools.javac.code.Flags.BLOCK;
  78 import static com.sun.tools.javac.code.Kinds.*;
  79 import static com.sun.tools.javac.code.Kinds.Kind.*;
  80 import static com.sun.tools.javac.code.TypeTag.*;
  81 import static com.sun.tools.javac.code.TypeTag.WILDCARD;
  82 import com.sun.tools.javac.tree.JCTree.GenericSwitch.SwitchKind;
  83 import com.sun.tools.javac.comp.Analyzer.AnalyzerMode;
  84 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  85 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  86 
  87 /** This is the main context-dependent analysis phase in GJC. It
  88  *  encompasses name resolution, type checking and constant folding as
  89  *  subtasks. Some subtasks involve auxiliary classes.
  90  *  @see Check
  91  *  @see Resolve
  92  *  @see ConstFold
  93  *  @see Infer
  94  *
  95  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  96  *  If you write code that depends on this, you do so at your own risk.
  97  *  This code and its internal interfaces are subject to change or
  98  *  deletion without notice.&lt;/b&gt;
  99  */
 100 public class Attr extends JCTree.Visitor {
 101     protected static final Context.Key&lt;Attr&gt; attrKey = new Context.Key&lt;&gt;();
 102 
 103     final Names names;
 104     final Log log;
 105     final Symtab syms;
 106     final Resolve rs;
 107     final Operators operators;
 108     final Infer infer;
 109     final Analyzer analyzer;
 110     final DeferredAttr deferredAttr;
 111     final Check chk;
 112     final Flow flow;
 113     final MemberEnter memberEnter;
 114     final TypeEnter typeEnter;
 115     final TreeMaker make;
 116     final ConstFold cfolder;
 117     final Enter enter;
 118     final Target target;
 119     final Types types;
 120     final Preview preview;
 121     final JCDiagnostic.Factory diags;
 122     final TypeAnnotations typeAnnotations;
 123     final DeferredLintHandler deferredLintHandler;
 124     final TypeEnvs typeEnvs;
 125     final Dependencies dependencies;
 126     final Annotate annotate;
 127     final ArgumentAttr argumentAttr;
 128     final ClassReader reader;
 129     final MatchBindingsComputer matchBindingsComputer;
 130 
 131     public static Attr instance(Context context) {
 132         Attr instance = context.get(attrKey);
 133         if (instance == null)
 134             instance = new Attr(context);
 135         return instance;
 136     }
 137 
 138     protected Attr(Context context) {
 139         context.put(attrKey, this);
 140 
 141         names = Names.instance(context);
 142         log = Log.instance(context);
 143         syms = Symtab.instance(context);
 144         rs = Resolve.instance(context);
 145         operators = Operators.instance(context);
 146         chk = Check.instance(context);
 147         flow = Flow.instance(context);
 148         memberEnter = MemberEnter.instance(context);
 149         typeEnter = TypeEnter.instance(context);
 150         make = TreeMaker.instance(context);
 151         enter = Enter.instance(context);
 152         infer = Infer.instance(context);
 153         analyzer = Analyzer.instance(context);
 154         deferredAttr = DeferredAttr.instance(context);
 155         cfolder = ConstFold.instance(context);
 156         target = Target.instance(context);
 157         types = Types.instance(context);
 158         preview = Preview.instance(context);
 159         diags = JCDiagnostic.Factory.instance(context);
 160         annotate = Annotate.instance(context);
 161         typeAnnotations = TypeAnnotations.instance(context);
 162         deferredLintHandler = DeferredLintHandler.instance(context);
 163         typeEnvs = TypeEnvs.instance(context);
 164         dependencies = Dependencies.instance(context);
 165         argumentAttr = ArgumentAttr.instance(context);
 166         reader = ClassReader.instance(context);
 167         matchBindingsComputer = MatchBindingsComputer.instance(context);
 168 
 169         Options options = Options.instance(context);
 170 
 171         Source source = Source.instance(context);
 172         allowPoly = Feature.POLY.allowedInSource(source);
 173         allowTypeAnnos = Feature.TYPE_ANNOTATIONS.allowedInSource(source);
 174         allowLambda = Feature.LAMBDA.allowedInSource(source);
 175         allowDefaultMethods = Feature.DEFAULT_METHODS.allowedInSource(source);
 176         allowStaticInterfaceMethods = Feature.STATIC_INTERFACE_METHODS.allowedInSource(source);
 177         allowReifiableTypesInInstanceof =
 178                 Feature.REIFIABLE_TYPES_INSTANCEOF.allowedInSource(source) &amp;&amp;
 179                 (!preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF) || preview.isEnabled());
 180         sourceName = source.name;
 181         useBeforeDeclarationWarning = options.isSet(&quot;useBeforeDeclarationWarning&quot;);
 182 
 183         statInfo = new ResultInfo(KindSelector.NIL, Type.noType);
 184         varAssignmentInfo = new ResultInfo(KindSelector.ASG, Type.noType);
 185         unknownExprInfo = new ResultInfo(KindSelector.VAL, Type.noType);
 186         methodAttrInfo = new MethodAttrInfo();
 187         unknownTypeInfo = new ResultInfo(KindSelector.TYP, Type.noType);
 188         unknownTypeExprInfo = new ResultInfo(KindSelector.VAL_TYP, Type.noType);
 189         recoveryInfo = new RecoveryInfo(deferredAttr.emptyDeferredAttrContext);
 190     }
 191 
 192     /** Switch: support target-typing inference
 193      */
 194     boolean allowPoly;
 195 
 196     /** Switch: support type annotations.
 197      */
 198     boolean allowTypeAnnos;
 199 
 200     /** Switch: support lambda expressions ?
 201      */
 202     boolean allowLambda;
 203 
 204     /** Switch: support default methods ?
 205      */
 206     boolean allowDefaultMethods;
 207 
 208     /** Switch: static interface methods enabled?
 209      */
 210     boolean allowStaticInterfaceMethods;
 211 
 212     /** Switch: reifiable types in instanceof enabled?
 213      */
 214     boolean allowReifiableTypesInInstanceof;
 215 
 216     /**
 217      * Switch: warn about use of variable before declaration?
 218      * RFE: 6425594
 219      */
 220     boolean useBeforeDeclarationWarning;
 221 
 222     /**
 223      * Switch: name of source level; used for error reporting.
 224      */
 225     String sourceName;
 226 
 227     /** Check kind and type of given tree against protokind and prototype.
 228      *  If check succeeds, store type in tree and return it.
 229      *  If check fails, store errType in tree and return it.
 230      *  No checks are performed if the prototype is a method type.
 231      *  It is not necessary in this case since we know that kind and type
 232      *  are correct.
 233      *
 234      *  @param tree     The tree whose kind and type is checked
 235      *  @param found    The computed type of the tree
 236      *  @param ownkind  The computed kind of the tree
 237      *  @param resultInfo  The expected result of the tree
 238      */
 239     Type check(final JCTree tree,
 240                final Type found,
 241                final KindSelector ownkind,
 242                final ResultInfo resultInfo) {
 243         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
 244         Type owntype;
 245         boolean shouldCheck = !found.hasTag(ERROR) &amp;&amp;
 246                 !resultInfo.pt.hasTag(METHOD) &amp;&amp;
 247                 !resultInfo.pt.hasTag(FORALL);
 248         if (shouldCheck &amp;&amp; !ownkind.subset(resultInfo.pkind)) {
 249             log.error(tree.pos(),
 250                       Errors.UnexpectedType(resultInfo.pkind.kindNames(),
 251                                             ownkind.kindNames()));
 252             owntype = types.createErrorType(found);
 253         } else if (allowPoly &amp;&amp; inferenceContext.free(found)) {
 254             //delay the check if there are inference variables in the found type
 255             //this means we are dealing with a partially inferred poly expression
 256             owntype = shouldCheck ? resultInfo.pt : found;
 257             if (resultInfo.checkMode.installPostInferenceHook()) {
 258                 inferenceContext.addFreeTypeListener(List.of(found),
 259                         instantiatedContext -&gt; {
 260                             ResultInfo pendingResult =
 261                                     resultInfo.dup(inferenceContext.asInstType(resultInfo.pt));
 262                             check(tree, inferenceContext.asInstType(found), ownkind, pendingResult);
 263                         });
 264             }
 265         } else {
 266             owntype = shouldCheck ?
 267             resultInfo.check(tree, found) :
 268             found;
 269         }
 270         if (resultInfo.checkMode.updateTreeType()) {
 271             tree.type = owntype;
 272         }
 273         return owntype;
 274     }
 275 
 276     /** Is given blank final variable assignable, i.e. in a scope where it
 277      *  may be assigned to even though it is final?
 278      *  @param v      The blank final variable.
 279      *  @param env    The current environment.
 280      */
 281     boolean isAssignableAsBlankFinal(VarSymbol v, Env&lt;AttrContext&gt; env) {
 282         Symbol owner = env.info.scope.owner;
 283            // owner refers to the innermost variable, method or
 284            // initializer block declaration at this point.
 285         return
 286             v.owner == owner
 287             ||
 288             ((owner.name == names.init ||    // i.e. we are in a constructor
 289               owner.kind == VAR ||           // i.e. we are in a variable initializer
 290               (owner.flags() &amp; BLOCK) != 0)  // i.e. we are in an initializer block
 291              &amp;&amp;
 292              v.owner == owner.owner
 293              &amp;&amp;
 294              ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env));
 295     }
 296 
 297     /** Check that variable can be assigned to.
 298      *  @param pos    The current source code position.
 299      *  @param v      The assigned variable
 300      *  @param base   If the variable is referred to in a Select, the part
 301      *                to the left of the `.&#39;, null otherwise.
 302      *  @param env    The current environment.
 303      */
 304     void checkAssignable(DiagnosticPosition pos, VarSymbol v, JCTree base, Env&lt;AttrContext&gt; env) {
 305         if (v.name == names._this) {
 306             log.error(pos, Errors.CantAssignValToThis);
 307         } else if ((v.flags() &amp; FINAL) != 0 &amp;&amp;
 308             ((v.flags() &amp; HASINIT) != 0
 309              ||
 310              !((base == null ||
 311                TreeInfo.isThisQualifier(base)) &amp;&amp;
 312                isAssignableAsBlankFinal(v, env)))) {
 313             if (v.isResourceVariable()) { //TWR resource
 314                 log.error(pos, Errors.TryResourceMayNotBeAssigned(v));
 315             } else if ((v.flags() &amp; MATCH_BINDING) != 0) {
 316                 log.error(pos, Errors.PatternBindingMayNotBeAssigned(v));
 317             } else {
 318                 log.error(pos, Errors.CantAssignValToFinalVar(v));
 319             }
 320         }
 321     }
 322 
 323     /** Does tree represent a static reference to an identifier?
 324      *  It is assumed that tree is either a SELECT or an IDENT.
 325      *  We have to weed out selects from non-type names here.
 326      *  @param tree    The candidate tree.
 327      */
 328     boolean isStaticReference(JCTree tree) {
 329         if (tree.hasTag(SELECT)) {
 330             Symbol lsym = TreeInfo.symbol(((JCFieldAccess) tree).selected);
 331             if (lsym == null || lsym.kind != TYP) {
 332                 return false;
 333             }
 334         }
 335         return true;
 336     }
 337 
 338     /** Is this symbol a type?
 339      */
 340     static boolean isType(Symbol sym) {
 341         return sym != null &amp;&amp; sym.kind == TYP;
 342     }
 343 
 344     /** The current `this&#39; symbol.
 345      *  @param env    The current environment.
 346      */
 347     Symbol thisSym(DiagnosticPosition pos, Env&lt;AttrContext&gt; env) {
 348         return rs.resolveSelf(pos, env, env.enclClass.sym, names._this);
 349     }
 350 
 351     /** Attribute a parsed identifier.
 352      * @param tree Parsed identifier name
 353      * @param topLevel The toplevel to use
 354      */
 355     public Symbol attribIdent(JCTree tree, JCCompilationUnit topLevel) {
 356         Env&lt;AttrContext&gt; localEnv = enter.topLevelEnv(topLevel);
 357         localEnv.enclClass = make.ClassDef(make.Modifiers(0),
 358                                            syms.errSymbol.name,
 359                                            null, null, null, null);
 360         localEnv.enclClass.sym = syms.errSymbol;
 361         return attribIdent(tree, localEnv);
 362     }
 363 
 364     /** Attribute a parsed identifier.
 365      * @param tree Parsed identifier name
 366      * @param env The env to use
 367      */
 368     public Symbol attribIdent(JCTree tree, Env&lt;AttrContext&gt; env) {
 369         return tree.accept(identAttributer, env);
 370     }
 371     // where
 372         private TreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; identAttributer = new IdentAttributer();
 373         private class IdentAttributer extends SimpleTreeVisitor&lt;Symbol,Env&lt;AttrContext&gt;&gt; {
 374             @Override @DefinedBy(Api.COMPILER_TREE)
 375             public Symbol visitMemberSelect(MemberSelectTree node, Env&lt;AttrContext&gt; env) {
 376                 Symbol site = visit(node.getExpression(), env);
 377                 if (site.kind == ERR || site.kind == ABSENT_TYP || site.kind == HIDDEN)
 378                     return site;
 379                 Name name = (Name)node.getIdentifier();
 380                 if (site.kind == PCK) {
 381                     env.toplevel.packge = (PackageSymbol)site;
 382                     return rs.findIdentInPackage(null, env, (TypeSymbol)site, name,
 383                             KindSelector.TYP_PCK);
 384                 } else {
 385                     env.enclClass.sym = (ClassSymbol)site;
 386                     return rs.findMemberType(env, site.asType(), name, (TypeSymbol)site);
 387                 }
 388             }
 389 
 390             @Override @DefinedBy(Api.COMPILER_TREE)
 391             public Symbol visitIdentifier(IdentifierTree node, Env&lt;AttrContext&gt; env) {
 392                 return rs.findIdent(null, env, (Name)node.getName(), KindSelector.TYP_PCK);
 393             }
 394         }
 395 
 396     public Type coerce(Type etype, Type ttype) {
 397         return cfolder.coerce(etype, ttype);
 398     }
 399 
 400     public Type attribType(JCTree node, TypeSymbol sym) {
 401         Env&lt;AttrContext&gt; env = typeEnvs.get(sym);
 402         Env&lt;AttrContext&gt; localEnv = env.dup(node, env.info.dup());
 403         return attribTree(node, localEnv, unknownTypeInfo);
 404     }
 405 
 406     public Type attribImportQualifier(JCImport tree, Env&lt;AttrContext&gt; env) {
 407         // Attribute qualifying package or class.
 408         JCFieldAccess s = (JCFieldAccess)tree.qualid;
 409         return attribTree(s.selected, env,
 410                           new ResultInfo(tree.staticImport ?
 411                                          KindSelector.TYP : KindSelector.TYP_PCK,
 412                        Type.noType));
 413     }
 414 
 415     public Env&lt;AttrContext&gt; attribExprToTree(JCTree expr, Env&lt;AttrContext&gt; env, JCTree tree) {
 416         return attribToTree(expr, env, tree, unknownExprInfo);
 417     }
 418 
 419     public Env&lt;AttrContext&gt; attribStatToTree(JCTree stmt, Env&lt;AttrContext&gt; env, JCTree tree) {
 420         return attribToTree(stmt, env, tree, statInfo);
 421     }
 422 
 423     private Env&lt;AttrContext&gt; attribToTree(JCTree root, Env&lt;AttrContext&gt; env, JCTree tree, ResultInfo resultInfo) {
 424         breakTree = tree;
 425         JavaFileObject prev = log.useSource(env.toplevel.sourcefile);
 426         try {
 427             deferredAttr.attribSpeculative(root, env, resultInfo,
 428                     null, DeferredAttr.AttributionMode.ANALYZER,
 429                     argumentAttr.withLocalCacheContext());
 430         } catch (BreakAttr b) {
 431             return b.env;
 432         } catch (AssertionError ae) {
 433             if (ae.getCause() instanceof BreakAttr) {
 434                 return ((BreakAttr)(ae.getCause())).env;
 435             } else {
 436                 throw ae;
 437             }
 438         } finally {
 439             breakTree = null;
 440             log.useSource(prev);
 441         }
 442         return env;
 443     }
 444 
 445     private JCTree breakTree = null;
 446 
 447     private static class BreakAttr extends RuntimeException {
 448         static final long serialVersionUID = -6924771130405446405L;
 449         private transient Env&lt;AttrContext&gt; env;
 450         private BreakAttr(Env&lt;AttrContext&gt; env) {
 451             this.env = env;
 452         }
 453     }
 454 
 455     /**
 456      * Mode controlling behavior of Attr.Check
 457      */
 458     enum CheckMode {
 459 
 460         NORMAL,
 461 
 462         /**
 463          * Mode signalling &#39;fake check&#39; - skip tree update. A side-effect of this mode is
 464          * that the captured var cache in {@code InferenceContext} will be used in read-only
 465          * mode when performing inference checks.
 466          */
 467         NO_TREE_UPDATE {
 468             @Override
 469             public boolean updateTreeType() {
 470                 return false;
 471             }
 472         },
 473         /**
 474          * Mode signalling that caller will manage free types in tree decorations.
 475          */
 476         NO_INFERENCE_HOOK {
 477             @Override
 478             public boolean installPostInferenceHook() {
 479                 return false;
 480             }
 481         };
 482 
 483         public boolean updateTreeType() {
 484             return true;
 485         }
 486         public boolean installPostInferenceHook() {
 487             return true;
 488         }
 489     }
 490 
 491 
 492     class ResultInfo {
 493         final KindSelector pkind;
 494         final Type pt;
 495         final CheckContext checkContext;
 496         final CheckMode checkMode;
 497 
 498         ResultInfo(KindSelector pkind, Type pt) {
 499             this(pkind, pt, chk.basicHandler, CheckMode.NORMAL);
 500         }
 501 
 502         ResultInfo(KindSelector pkind, Type pt, CheckMode checkMode) {
 503             this(pkind, pt, chk.basicHandler, checkMode);
 504         }
 505 
 506         protected ResultInfo(KindSelector pkind,
 507                              Type pt, CheckContext checkContext) {
 508             this(pkind, pt, checkContext, CheckMode.NORMAL);
 509         }
 510 
 511         protected ResultInfo(KindSelector pkind,
 512                              Type pt, CheckContext checkContext, CheckMode checkMode) {
 513             this.pkind = pkind;
 514             this.pt = pt;
 515             this.checkContext = checkContext;
 516             this.checkMode = checkMode;
 517         }
 518 
 519         /**
 520          * Should {@link Attr#attribTree} use the {@ArgumentAttr} visitor instead of this one?
 521          * @param tree The tree to be type-checked.
 522          * @return true if {@ArgumentAttr} should be used.
 523          */
 524         protected boolean needsArgumentAttr(JCTree tree) { return false; }
 525 
 526         protected Type check(final DiagnosticPosition pos, final Type found) {
 527             return chk.checkType(pos, found, pt, checkContext);
 528         }
 529 
 530         protected ResultInfo dup(Type newPt) {
 531             return new ResultInfo(pkind, newPt, checkContext, checkMode);
 532         }
 533 
 534         protected ResultInfo dup(CheckContext newContext) {
 535             return new ResultInfo(pkind, pt, newContext, checkMode);
 536         }
 537 
 538         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 539             return new ResultInfo(pkind, newPt, newContext, checkMode);
 540         }
 541 
 542         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 543             return new ResultInfo(pkind, newPt, newContext, newMode);
 544         }
 545 
 546         protected ResultInfo dup(CheckMode newMode) {
 547             return new ResultInfo(pkind, pt, checkContext, newMode);
 548         }
 549 
 550         @Override
 551         public String toString() {
 552             if (pt != null) {
 553                 return pt.toString();
 554             } else {
 555                 return &quot;&quot;;
 556             }
 557         }
 558     }
 559 
 560     class MethodAttrInfo extends ResultInfo {
 561         public MethodAttrInfo() {
 562             this(chk.basicHandler);
 563         }
 564 
 565         public MethodAttrInfo(CheckContext checkContext) {
 566             super(KindSelector.VAL, Infer.anyPoly, checkContext);
 567         }
 568 
 569         @Override
 570         protected boolean needsArgumentAttr(JCTree tree) {
 571             return true;
 572         }
 573 
 574         protected ResultInfo dup(Type newPt) {
 575             throw new IllegalStateException();
 576         }
 577 
 578         protected ResultInfo dup(CheckContext newContext) {
 579             return new MethodAttrInfo(newContext);
 580         }
 581 
 582         protected ResultInfo dup(Type newPt, CheckContext newContext) {
 583             throw new IllegalStateException();
 584         }
 585 
 586         protected ResultInfo dup(Type newPt, CheckContext newContext, CheckMode newMode) {
 587             throw new IllegalStateException();
 588         }
 589 
 590         protected ResultInfo dup(CheckMode newMode) {
 591             throw new IllegalStateException();
 592         }
 593     }
 594 
 595     class RecoveryInfo extends ResultInfo {
 596 
 597         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext) {
 598             this(deferredAttrContext, Type.recoveryType);
 599         }
 600 
 601         public RecoveryInfo(final DeferredAttr.DeferredAttrContext deferredAttrContext, Type pt) {
 602             super(KindSelector.VAL, pt, new Check.NestedCheckContext(chk.basicHandler) {
 603                 @Override
 604                 public DeferredAttr.DeferredAttrContext deferredAttrContext() {
 605                     return deferredAttrContext;
 606                 }
 607                 @Override
 608                 public boolean compatible(Type found, Type req, Warner warn) {
 609                     return true;
 610                 }
 611                 @Override
 612                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
 613                     if (pt == Type.recoveryType) {
 614                         chk.basicHandler.report(pos, details);
 615                     }
 616                 }
 617             });
 618         }
 619     }
 620 
 621     final ResultInfo statInfo;
 622     final ResultInfo varAssignmentInfo;
 623     final ResultInfo methodAttrInfo;
 624     final ResultInfo unknownExprInfo;
 625     final ResultInfo unknownTypeInfo;
 626     final ResultInfo unknownTypeExprInfo;
 627     final ResultInfo recoveryInfo;
 628 
 629     Type pt() {
 630         return resultInfo.pt;
 631     }
 632 
 633     KindSelector pkind() {
 634         return resultInfo.pkind;
 635     }
 636 
 637 /* ************************************************************************
 638  * Visitor methods
 639  *************************************************************************/
 640 
 641     /** Visitor argument: the current environment.
 642      */
 643     Env&lt;AttrContext&gt; env;
 644 
 645     /** Visitor argument: the currently expected attribution result.
 646      */
 647     ResultInfo resultInfo;
 648 
 649     /** Visitor result: the computed type.
 650      */
 651     Type result;
 652 
 653     MatchBindings matchBindings = MatchBindingsComputer.EMPTY;
 654 
 655     /** Visitor method: attribute a tree, catching any completion failure
 656      *  exceptions. Return the tree&#39;s type.
 657      *
 658      *  @param tree    The tree to be visited.
 659      *  @param env     The environment visitor argument.
 660      *  @param resultInfo   The result info visitor argument.
 661      */
 662     Type attribTree(JCTree tree, Env&lt;AttrContext&gt; env, ResultInfo resultInfo) {
 663         Env&lt;AttrContext&gt; prevEnv = this.env;
 664         ResultInfo prevResult = this.resultInfo;
 665         try {
 666             this.env = env;
 667             this.resultInfo = resultInfo;
 668             if (resultInfo.needsArgumentAttr(tree)) {
 669                 result = argumentAttr.attribArg(tree, env);
 670             } else {
 671                 tree.accept(this);
 672             }
 673             matchBindings = matchBindingsComputer.finishBindings(tree,
 674                                                                  matchBindings);
 675             if (tree == breakTree &amp;&amp;
 676                     resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
 677                 breakTreeFound(copyEnv(env));
 678             }
 679             return result;
 680         } catch (CompletionFailure ex) {
 681             tree.type = syms.errType;
 682             return chk.completionError(tree.pos(), ex);
 683         } finally {
 684             this.env = prevEnv;
 685             this.resultInfo = prevResult;
 686         }
 687     }
 688 
 689     protected void breakTreeFound(Env&lt;AttrContext&gt; env) {
 690         throw new BreakAttr(env);
 691     }
 692 
 693     Env&lt;AttrContext&gt; copyEnv(Env&lt;AttrContext&gt; env) {
 694         Env&lt;AttrContext&gt; newEnv =
 695                 env.dup(env.tree, env.info.dup(copyScope(env.info.scope)));
 696         if (newEnv.outer != null) {
 697             newEnv.outer = copyEnv(newEnv.outer);
 698         }
 699         return newEnv;
 700     }
 701 
 702     WriteableScope copyScope(WriteableScope sc) {
 703         WriteableScope newScope = WriteableScope.create(sc.owner);
 704         List&lt;Symbol&gt; elemsList = List.nil();
 705         for (Symbol sym : sc.getSymbols()) {
 706             elemsList = elemsList.prepend(sym);
 707         }
 708         for (Symbol s : elemsList) {
 709             newScope.enter(s);
 710         }
 711         return newScope;
 712     }
 713 
 714     /** Derived visitor method: attribute an expression tree.
 715      */
 716     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 717         return attribTree(tree, env, new ResultInfo(KindSelector.VAL, !pt.hasTag(ERROR) ? pt : Type.noType));
 718     }
 719 
 720     /** Derived visitor method: attribute an expression tree with
 721      *  no constraints on the computed type.
 722      */
 723     public Type attribExpr(JCTree tree, Env&lt;AttrContext&gt; env) {
 724         return attribTree(tree, env, unknownExprInfo);
 725     }
 726 
 727     /** Derived visitor method: attribute a type tree.
 728      */
 729     public Type attribType(JCTree tree, Env&lt;AttrContext&gt; env) {
 730         Type result = attribType(tree, env, Type.noType);
 731         return result;
 732     }
 733 
 734     /** Derived visitor method: attribute a type tree.
 735      */
 736     Type attribType(JCTree tree, Env&lt;AttrContext&gt; env, Type pt) {
 737         Type result = attribTree(tree, env, new ResultInfo(KindSelector.TYP, pt));
 738         return result;
 739     }
 740 
 741     /** Derived visitor method: attribute a statement or definition tree.
 742      */
 743     public Type attribStat(JCTree tree, Env&lt;AttrContext&gt; env) {
 744         Env&lt;AttrContext&gt; analyzeEnv = analyzer.copyEnvIfNeeded(tree, env);
 745         Type result = attribTree(tree, env, statInfo);
 746         analyzer.analyzeIfNeeded(tree, analyzeEnv);
 747         return result;
 748     }
 749 
 750     /** Attribute a list of expressions, returning a list of types.
 751      */
 752     List&lt;Type&gt; attribExprs(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, Type pt) {
 753         ListBuffer&lt;Type&gt; ts = new ListBuffer&lt;&gt;();
 754         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 755             ts.append(attribExpr(l.head, env, pt));
 756         return ts.toList();
 757     }
 758 
 759     /** Attribute a list of statements, returning nothing.
 760      */
 761     &lt;T extends JCTree&gt; void attribStats(List&lt;T&gt; trees, Env&lt;AttrContext&gt; env) {
 762         for (List&lt;T&gt; l = trees; l.nonEmpty(); l = l.tail)
 763             attribStat(l.head, env);
 764     }
 765 
 766     /** Attribute the arguments in a method call, returning the method kind.
 767      */
 768     KindSelector attribArgs(KindSelector initialKind, List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env, ListBuffer&lt;Type&gt; argtypes) {
 769         KindSelector kind = initialKind;
 770         for (JCExpression arg : trees) {
 771             Type argtype = chk.checkNonVoid(arg, attribTree(arg, env, allowPoly ? methodAttrInfo : unknownExprInfo));
 772             if (argtype.hasTag(DEFERRED)) {
 773                 kind = KindSelector.of(KindSelector.POLY, kind);
 774             }
 775             argtypes.append(argtype);
 776         }
 777         return kind;
 778     }
 779 
 780     /** Attribute a type argument list, returning a list of types.
 781      *  Caller is responsible for calling checkRefTypes.
 782      */
 783     List&lt;Type&gt; attribAnyTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 784         ListBuffer&lt;Type&gt; argtypes = new ListBuffer&lt;&gt;();
 785         for (List&lt;JCExpression&gt; l = trees; l.nonEmpty(); l = l.tail)
 786             argtypes.append(attribType(l.head, env));
 787         return argtypes.toList();
 788     }
 789 
 790     /** Attribute a type argument list, returning a list of types.
 791      *  Check that all the types are references.
 792      */
 793     List&lt;Type&gt; attribTypes(List&lt;JCExpression&gt; trees, Env&lt;AttrContext&gt; env) {
 794         List&lt;Type&gt; types = attribAnyTypes(trees, env);
 795         return chk.checkRefTypes(trees, types);
 796     }
 797 
 798     /**
 799      * Attribute type variables (of generic classes or methods).
 800      * Compound types are attributed later in attribBounds.
 801      * @param typarams the type variables to enter
 802      * @param env      the current environment
 803      */
 804     void attribTypeVariables(List&lt;JCTypeParameter&gt; typarams, Env&lt;AttrContext&gt; env, boolean checkCyclic) {
 805         for (JCTypeParameter tvar : typarams) {
 806             TypeVar a = (TypeVar)tvar.type;
 807             a.tsym.flags_field |= UNATTRIBUTED;
 808             a.setUpperBound(Type.noType);
 809             if (!tvar.bounds.isEmpty()) {
 810                 List&lt;Type&gt; bounds = List.of(attribType(tvar.bounds.head, env));
 811                 for (JCExpression bound : tvar.bounds.tail)
 812                     bounds = bounds.prepend(attribType(bound, env));
 813                 types.setBounds(a, bounds.reverse());
 814             } else {
 815                 // if no bounds are given, assume a single bound of
 816                 // java.lang.Object.
 817                 types.setBounds(a, List.of(syms.objectType));
 818             }
 819             a.tsym.flags_field &amp;= ~UNATTRIBUTED;
 820         }
 821         if (checkCyclic) {
 822             for (JCTypeParameter tvar : typarams) {
 823                 chk.checkNonCyclic(tvar.pos(), (TypeVar)tvar.type);
 824             }
 825         }
 826     }
 827 
 828     /**
 829      * Attribute the type references in a list of annotations.
 830      */
 831     void attribAnnotationTypes(List&lt;JCAnnotation&gt; annotations,
 832                                Env&lt;AttrContext&gt; env) {
 833         for (List&lt;JCAnnotation&gt; al = annotations; al.nonEmpty(); al = al.tail) {
 834             JCAnnotation a = al.head;
 835             attribType(a.annotationType, env);
 836         }
 837     }
 838 
 839     /**
 840      * Attribute a &quot;lazy constant value&quot;.
 841      *  @param env         The env for the const value
 842      *  @param variable    The initializer for the const value
 843      *  @param type        The expected type, or null
 844      *  @see VarSymbol#setLazyConstValue
 845      */
 846     public Object attribLazyConstantValue(Env&lt;AttrContext&gt; env,
 847                                       JCVariableDecl variable,
 848                                       Type type) {
 849 
 850         DiagnosticPosition prevLintPos
 851                 = deferredLintHandler.setPos(variable.pos());
 852 
 853         final JavaFileObject prevSource = log.useSource(env.toplevel.sourcefile);
 854         try {
 855             Type itype = attribExpr(variable.init, env, type);
 856             if (variable.isImplicitlyTyped()) {
 857                 //fixup local variable type
 858                 type = variable.type = variable.sym.type = chk.checkLocalVarType(variable, itype.baseType(), variable.name);
 859             }
 860             if (itype.constValue() != null) {
 861                 return coerce(itype, type).constValue();
 862             } else {
 863                 return null;
 864             }
 865         } finally {
 866             log.useSource(prevSource);
 867             deferredLintHandler.setPos(prevLintPos);
 868         }
 869     }
 870 
 871     /** Attribute type reference in an `extends&#39; or `implements&#39; clause.
 872      *  Supertypes of anonymous inner classes are usually already attributed.
 873      *
 874      *  @param tree              The tree making up the type reference.
 875      *  @param env               The environment current at the reference.
 876      *  @param classExpected     true if only a class is expected here.
 877      *  @param interfaceExpected true if only an interface is expected here.
 878      */
 879     Type attribBase(JCTree tree,
 880                     Env&lt;AttrContext&gt; env,
 881                     boolean classExpected,
 882                     boolean interfaceExpected,
 883                     boolean checkExtensible) {
 884         Type t = tree.type != null ?
 885             tree.type :
 886             attribType(tree, env);
 887         return checkBase(t, tree, env, classExpected, interfaceExpected, checkExtensible);
 888     }
 889     Type checkBase(Type t,
 890                    JCTree tree,
 891                    Env&lt;AttrContext&gt; env,
 892                    boolean classExpected,
 893                    boolean interfaceExpected,
 894                    boolean checkExtensible) {
 895         final DiagnosticPosition pos = tree.hasTag(TYPEAPPLY) ?
 896                 (((JCTypeApply) tree).clazz).pos() : tree.pos();
 897         if (t.tsym.isAnonymous()) {
 898             log.error(pos, Errors.CantInheritFromAnon);
 899             return types.createErrorType(t);
 900         }
 901         if (t.isErroneous())
 902             return t;
 903         if (t.hasTag(TYPEVAR) &amp;&amp; !classExpected &amp;&amp; !interfaceExpected) {
 904             // check that type variable is already visible
 905             if (t.getUpperBound() == null) {
 906                 log.error(pos, Errors.IllegalForwardRef);
 907                 return types.createErrorType(t);
 908             }
 909         } else {
 910             t = chk.checkClassType(pos, t, checkExtensible);
 911         }
 912         if (interfaceExpected &amp;&amp; (t.tsym.flags() &amp; INTERFACE) == 0) {
 913             log.error(pos, Errors.IntfExpectedHere);
 914             // return errType is necessary since otherwise there might
 915             // be undetected cycles which cause attribution to loop
 916             return types.createErrorType(t);
 917         } else if (checkExtensible &amp;&amp;
 918                    classExpected &amp;&amp;
 919                    (t.tsym.flags() &amp; INTERFACE) != 0) {
 920             log.error(pos, Errors.NoIntfExpectedHere);
 921             return types.createErrorType(t);
 922         }
 923         if (checkExtensible &amp;&amp;
 924             ((t.tsym.flags() &amp; FINAL) != 0)) {
 925             log.error(pos,
 926                       Errors.CantInheritFromFinal(t.tsym));
 927         }
 928         chk.checkNonCyclic(pos, t);
 929         return t;
 930     }
 931 
 932     Type attribIdentAsEnumType(Env&lt;AttrContext&gt; env, JCIdent id) {
 933         Assert.check((env.enclClass.sym.flags() &amp; ENUM) != 0);
 934         id.type = env.info.scope.owner.enclClass().type;
 935         id.sym = env.info.scope.owner.enclClass();
 936         return id.type;
 937     }
 938 
 939     public void visitClassDef(JCClassDecl tree) {
 940         Optional&lt;ArgumentAttr.LocalCacheContext&gt; localCacheContext =
 941                 Optional.ofNullable(env.info.attributionMode.isSpeculative ?
 942                         argumentAttr.withLocalCacheContext() : null);
 943         try {
 944             // Local and anonymous classes have not been entered yet, so we need to
 945             // do it now.
 946             if (env.info.scope.owner.kind.matches(KindSelector.VAL_MTH)) {
 947                 enter.classEnter(tree, env);
 948             } else {
 949                 // If this class declaration is part of a class level annotation,
 950                 // as in @MyAnno(new Object() {}) class MyClass {}, enter it in
 951                 // order to simplify later steps and allow for sensible error
 952                 // messages.
 953                 if (env.tree.hasTag(NEWCLASS) &amp;&amp; TreeInfo.isInAnnotation(env, tree))
 954                     enter.classEnter(tree, env);
 955             }
 956 
 957             ClassSymbol c = tree.sym;
 958             if (c == null) {
 959                 // exit in case something drastic went wrong during enter.
 960                 result = null;
 961             } else {
 962                 // make sure class has been completed:
 963                 c.complete();
 964 
 965                 // If this class appears as an anonymous class
 966                 // in a superclass constructor call
 967                 // disable implicit outer instance from being passed.
 968                 // (This would be an illegal access to &quot;this before super&quot;).
 969                 if (env.info.isSelfCall &amp;&amp;
 970                         env.tree.hasTag(NEWCLASS)) {
 971                     c.flags_field |= NOOUTERTHIS;
 972                 }
 973                 attribClass(tree.pos(), c);
 974                 result = tree.type = c.type;
 975             }
 976         } finally {
 977             localCacheContext.ifPresent(LocalCacheContext::leave);
 978         }
 979     }
 980 
 981     public void visitMethodDef(JCMethodDecl tree) {
 982         MethodSymbol m = tree.sym;
 983         boolean isDefaultMethod = (m.flags() &amp; DEFAULT) != 0;
 984 
 985         Lint lint = env.info.lint.augment(m);
 986         Lint prevLint = chk.setLint(lint);
 987         MethodSymbol prevMethod = chk.setMethod(m);
 988         try {
 989             deferredLintHandler.flush(tree.pos());
 990             chk.checkDeprecatedAnnotation(tree.pos(), m);
 991 
 992 
 993             // Create a new environment with local scope
 994             // for attributing the method.
 995             Env&lt;AttrContext&gt; localEnv = memberEnter.methodEnv(tree, env);
 996             localEnv.info.lint = lint;
 997 
 998             attribStats(tree.typarams, localEnv);
 999 
1000             // If we override any other methods, check that we do so properly.
1001             // JLS ???
1002             if (m.isStatic()) {
1003                 chk.checkHideClashes(tree.pos(), env.enclClass.type, m);
1004             } else {
1005                 chk.checkOverrideClashes(tree.pos(), env.enclClass.type, m);
1006             }
1007             chk.checkOverride(env, tree, m);
1008 
1009             if (isDefaultMethod &amp;&amp; types.overridesObjectMethod(m.enclClass(), m)) {
1010                 log.error(tree, Errors.DefaultOverridesObjectMember(m.name, Kinds.kindName(m.location()), m.location()));
1011             }
1012 
1013             // Enter all type parameters into the local method scope.
1014             for (List&lt;JCTypeParameter&gt; l = tree.typarams; l.nonEmpty(); l = l.tail)
1015                 localEnv.info.scope.enterIfAbsent(l.head.type.tsym);
1016 
1017             ClassSymbol owner = env.enclClass.sym;
1018             if ((owner.flags() &amp; ANNOTATION) != 0 &amp;&amp;
1019                     (tree.params.nonEmpty() ||
1020                     tree.recvparam != null))
1021                 log.error(tree.params.nonEmpty() ?
1022                         tree.params.head.pos() :
1023                         tree.recvparam.pos(),
1024                         Errors.IntfAnnotationMembersCantHaveParams);
1025 
1026             // Attribute all value parameters.
1027             for (List&lt;JCVariableDecl&gt; l = tree.params; l.nonEmpty(); l = l.tail) {
1028                 attribStat(l.head, localEnv);
1029             }
1030 
1031             chk.checkVarargsMethodDecl(localEnv, tree);
1032 
1033             // Check that type parameters are well-formed.
1034             chk.validate(tree.typarams, localEnv);
1035 
1036             // Check that result type is well-formed.
1037             if (tree.restype != null &amp;&amp; !tree.restype.type.hasTag(VOID))
1038                 chk.validate(tree.restype, localEnv);
1039 
1040             // Check that receiver type is well-formed.
1041             if (tree.recvparam != null) {
1042                 // Use a new environment to check the receiver parameter.
1043                 // Otherwise I get &quot;might not have been initialized&quot; errors.
1044                 // Is there a better way?
1045                 Env&lt;AttrContext&gt; newEnv = memberEnter.methodEnv(tree, env);
1046                 attribType(tree.recvparam, newEnv);
1047                 chk.validate(tree.recvparam, newEnv);
1048             }
1049 
1050             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP) {
1051                 // lets find if this method is an accessor
1052                 Optional&lt;? extends RecordComponent&gt; recordComponent = env.enclClass.sym.getRecordComponents().stream()
1053                         .filter(rc -&gt; rc.accessor == tree.sym &amp;&amp; (rc.accessor.flags_field &amp; GENERATED_MEMBER) == 0).findFirst();
1054                 if (recordComponent.isPresent()) {
1055                     // the method is a user defined accessor lets check that everything is fine
1056                     if (!tree.sym.isPublic()) {
1057                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.MethodMustBePublic));
1058                     }
1059                     if (!types.isSameType(tree.sym.type.getReturnType(), recordComponent.get().type)) {
1060                         log.error(tree, Errors.InvalidAccessorMethodInRecord(env.enclClass.sym,
1061                                 Fragments.AccessorReturnTypeDoesntMatch(tree.sym, recordComponent.get())));
1062                     }
1063                     if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1064                         log.error(tree,
1065                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodCantThrowException));
1066                     }
1067                     if (!tree.typarams.isEmpty()) {
1068                         log.error(tree,
1069                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeGeneric));
1070                     }
1071                     if (tree.sym.isStatic()) {
1072                         log.error(tree,
1073                                 Errors.InvalidAccessorMethodInRecord(env.enclClass.sym, Fragments.AccessorMethodMustNotBeStatic));
1074                     }
1075                 }
1076 
1077                 if (tree.name == names.init) {
1078                     // if this a constructor other than the canonical one
1079                     if ((tree.sym.flags_field &amp; RECORD) == 0) {
1080                         JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1081                         if (app == null ||
1082                                 TreeInfo.name(app.meth) != names._this ||
1083                                 !checkFirstConstructorStat(app, tree, false)) {
1084                             log.error(tree, Errors.FirstStatementMustBeCallToAnotherConstructor);
1085                         }
1086                     } else {
1087                         // but if it is the canonical:
1088 
1089                         // if user generated, then it shouldn&#39;t explicitly invoke any other constructor
1090                         if ((tree.sym.flags_field &amp; GENERATEDCONSTR) == 0) {
1091                             JCMethodInvocation app = TreeInfo.firstConstructorCall(tree);
1092                             if (app != null &amp;&amp;
1093                                     (TreeInfo.name(app.meth) == names._this ||
1094                                             TreeInfo.name(app.meth) == names._super) &amp;&amp;
1095                                     checkFirstConstructorStat(app, tree, false)) {
1096                                 log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1097                                         Fragments.Canonical, tree.sym.name,
1098                                         Fragments.CanonicalMustNotContainExplicitConstructorInvocation));
1099                             }
1100                         }
1101 
1102                         // also we want to check that no type variables have been defined
1103                         if (!tree.typarams.isEmpty()) {
1104                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1105                                     Fragments.Canonical, tree.sym.name, Fragments.CanonicalMustNotDeclareTypeVariables));
1106                         }
1107 
1108                         /* and now we need to check that the constructor&#39;s arguments are exactly the same as those of the
1109                          * record components
1110                          */
1111                         List&lt;Type&gt; recordComponentTypes = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.type);
1112                         for (JCVariableDecl param: tree.params) {
1113                             if (!types.isSameType(param.type, recordComponentTypes.head)) {
1114                                 log.error(param, Errors.InvalidCanonicalConstructorInRecord(
1115                                         Fragments.Canonical, tree.sym.name, Fragments.TypeMustBeIdenticalToCorrespondingRecordComponentType));
1116                             }
1117                             recordComponentTypes = recordComponentTypes.tail;
1118                         }
1119                     }
1120                 }
1121             }
1122 
1123             // annotation method checks
1124             if ((owner.flags() &amp; ANNOTATION) != 0) {
1125                 // annotation method cannot have throws clause
1126                 if (tree.thrown.nonEmpty()) {
1127                     log.error(tree.thrown.head.pos(),
1128                               Errors.ThrowsNotAllowedInIntfAnnotation);
1129                 }
1130                 // annotation method cannot declare type-parameters
1131                 if (tree.typarams.nonEmpty()) {
1132                     log.error(tree.typarams.head.pos(),
1133                               Errors.IntfAnnotationMembersCantHaveTypeParams);
1134                 }
1135                 // validate annotation method&#39;s return type (could be an annotation type)
1136                 chk.validateAnnotationType(tree.restype);
1137                 // ensure that annotation method does not clash with members of Object/Annotation
1138                 chk.validateAnnotationMethod(tree.pos(), m);
1139             }
1140 
1141             for (List&lt;JCExpression&gt; l = tree.thrown; l.nonEmpty(); l = l.tail)
1142                 chk.checkType(l.head.pos(), l.head.type, syms.throwableType);
1143 
1144             if (tree.body == null) {
1145                 // Empty bodies are only allowed for
1146                 // abstract, native, or interface methods, or for methods
1147                 // in a retrofit signature class.
1148                 if (tree.defaultValue != null) {
1149                     if ((owner.flags() &amp; ANNOTATION) == 0)
1150                         log.error(tree.pos(),
1151                                   Errors.DefaultAllowedInIntfAnnotationMember);
1152                 }
1153                 if (isDefaultMethod || (tree.sym.flags() &amp; (ABSTRACT | NATIVE)) == 0)
1154                     log.error(tree.pos(), Errors.MissingMethBodyOrDeclAbstract);
1155             } else if ((tree.sym.flags() &amp; (ABSTRACT|DEFAULT|PRIVATE)) == ABSTRACT) {
1156                 if ((owner.flags() &amp; INTERFACE) != 0) {
1157                     log.error(tree.body.pos(), Errors.IntfMethCantHaveBody);
1158                 } else {
1159                     log.error(tree.pos(), Errors.AbstractMethCantHaveBody);
1160                 }
1161             } else if ((tree.mods.flags &amp; NATIVE) != 0) {
1162                 log.error(tree.pos(), Errors.NativeMethCantHaveBody);
1163             } else {
1164                 // Add an implicit super() call unless an explicit call to
1165                 // super(...) or this(...) is given
1166                 // or we are compiling class java.lang.Object.
1167                 if (tree.name == names.init &amp;&amp; owner.type != syms.objectType) {
1168                     JCBlock body = tree.body;
1169                     if (body.stats.isEmpty() ||
1170                             TreeInfo.getConstructorInvocationName(body.stats, names) == names.empty) {
1171                         JCStatement supCall = make.at(body.pos).Exec(make.Apply(List.nil(),
1172                                 make.Ident(names._super), make.Idents(List.nil())));
1173                         body.stats = body.stats.prepend(supCall);
1174                     } else if ((env.enclClass.sym.flags() &amp; ENUM) != 0 &amp;&amp;
1175                             (tree.mods.flags &amp; GENERATEDCONSTR) == 0 &amp;&amp;
1176                             TreeInfo.isSuperCall(body.stats.head)) {
1177                         // enum constructors are not allowed to call super
1178                         // directly, so make sure there aren&#39;t any super calls
1179                         // in enum constructors, except in the compiler
1180                         // generated one.
1181                         log.error(tree.body.stats.head.pos(),
1182                                   Errors.CallToSuperNotAllowedInEnumCtor(env.enclClass.sym));
1183                     }
1184                     if (env.enclClass.sym.isRecord() &amp;&amp; (tree.sym.flags_field &amp; RECORD) != 0) { // we are seeing the canonical constructor
1185                         List&lt;Name&gt; recordComponentNames = TreeInfo.recordFields(env.enclClass).map(vd -&gt; vd.sym.name);
1186                         List&lt;Name&gt; initParamNames = tree.sym.params.map(p -&gt; p.name);
1187                         if (!initParamNames.equals(recordComponentNames)) {
1188                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1189                                     Fragments.Canonical, env.enclClass.sym.name, Fragments.CanonicalWithNameMismatch));
1190                         }
1191                         if (!tree.sym.isPublic()) {
1192                             log.error(tree, Errors.InvalidCanonicalConstructorInRecord(
1193                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1194                                     env.enclClass.sym.name, Fragments.CanonicalConstructorMustBePublic));
1195                         }
1196                         if (tree.sym.type.asMethodType().thrown != null &amp;&amp; !tree.sym.type.asMethodType().thrown.isEmpty()) {
1197                             log.error(tree,
1198                                     Errors.InvalidCanonicalConstructorInRecord(
1199                                             TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical,
1200                                             env.enclClass.sym.name,
1201                                             Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(
1202                                                     TreeInfo.isCompactConstructor(tree) ? Fragments.Compact : Fragments.Canonical)));
1203                         }
1204                     }
1205                 }
1206 
1207                 // Attribute all type annotations in the body
1208                 annotate.queueScanTreeAndTypeAnnotate(tree.body, localEnv, m, null);
1209                 annotate.flush();
1210 
1211                 // Attribute method body.
1212                 attribStat(tree.body, localEnv);
1213             }
1214 
1215             localEnv.info.scope.leave();
1216             result = tree.type = m.type;
1217         } finally {
1218             chk.setLint(prevLint);
1219             chk.setMethod(prevMethod);
1220         }
1221     }
1222 
1223     public void visitVarDef(JCVariableDecl tree) {
1224         // Local variables have not been entered yet, so we need to do it now:
1225         if (env.info.scope.owner.kind == MTH || env.info.scope.owner.kind == VAR) {
1226             if (tree.sym != null) {
1227                 // parameters have already been entered
1228                 env.info.scope.enter(tree.sym);
1229             } else {
1230                 if (tree.isImplicitlyTyped() &amp;&amp; (tree.getModifiers().flags &amp; PARAMETER) == 0) {
1231                     if (tree.init == null) {
1232                         //cannot use &#39;var&#39; without initializer
1233                         log.error(tree, Errors.CantInferLocalVarType(tree.name, Fragments.LocalMissingInit));
1234                         tree.vartype = make.Erroneous();
1235                     } else {
1236                         Fragment msg = canInferLocalVarType(tree);
1237                         if (msg != null) {
1238                             //cannot use &#39;var&#39; with initializer which require an explicit target
1239                             //(e.g. lambda, method reference, array initializer).
1240                             log.error(tree, Errors.CantInferLocalVarType(tree.name, msg));
1241                             tree.vartype = make.Erroneous();
1242                         }
1243                     }
1244                 }
1245                 try {
1246                     annotate.blockAnnotations();
1247                     memberEnter.memberEnter(tree, env);
1248                 } finally {
1249                     annotate.unblockAnnotations();
1250                 }
1251             }
1252         } else {
1253             if (tree.init != null) {
1254                 // Field initializer expression need to be entered.
1255                 annotate.queueScanTreeAndTypeAnnotate(tree.init, env, tree.sym, tree.pos());
1256                 annotate.flush();
1257             }
1258         }
1259 
1260         VarSymbol v = tree.sym;
1261         Lint lint = env.info.lint.augment(v);
1262         Lint prevLint = chk.setLint(lint);
1263 
1264         // Check that the variable&#39;s declared type is well-formed.
1265         boolean isImplicitLambdaParameter = env.tree.hasTag(LAMBDA) &amp;&amp;
1266                 ((JCLambda)env.tree).paramKind == JCLambda.ParameterKind.IMPLICIT &amp;&amp;
1267                 (tree.sym.flags() &amp; PARAMETER) != 0;
1268         chk.validate(tree.vartype, env, !isImplicitLambdaParameter &amp;&amp; !tree.isImplicitlyTyped());
1269 
1270         try {
1271             v.getConstValue(); // ensure compile-time constant initializer is evaluated
1272             deferredLintHandler.flush(tree.pos());
1273             chk.checkDeprecatedAnnotation(tree.pos(), v);
1274 
1275             if (tree.init != null) {
1276                 if ((v.flags_field &amp; FINAL) == 0 ||
1277                     !memberEnter.needsLazyConstValue(tree.init)) {
1278                     // Not a compile-time constant
1279                     // Attribute initializer in a new environment
1280                     // with the declared variable as owner.
1281                     // Check that initializer conforms to variable&#39;s declared type.
1282                     Env&lt;AttrContext&gt; initEnv = memberEnter.initEnv(tree, env);
1283                     initEnv.info.lint = lint;
1284                     // In order to catch self-references, we set the variable&#39;s
1285                     // declaration position to maximal possible value, effectively
1286                     // marking the variable as undefined.
1287                     initEnv.info.enclVar = v;
1288                     attribExpr(tree.init, initEnv, v.type);
1289                     if (tree.isImplicitlyTyped()) {
1290                         //fixup local variable type
1291                         v.type = chk.checkLocalVarType(tree, tree.init.type.baseType(), tree.name);
1292                     }
1293                 }
1294                 if (tree.isImplicitlyTyped()) {
1295                     setSyntheticVariableType(tree, v.type);
1296                 }
1297             }
1298             result = tree.type = v.type;
1299             if (env.enclClass.sym.isRecord() &amp;&amp; tree.sym.owner.kind == TYP &amp;&amp; !v.isStatic()) {
1300                 if (isNonArgsMethodInObject(v.name)) {
1301                     log.error(tree, Errors.IllegalRecordComponentName(v));
1302                 }
1303             }
1304         }
1305         finally {
1306             chk.setLint(prevLint);
1307         }
1308     }
1309 
1310     private boolean isNonArgsMethodInObject(Name name) {
1311         for (Symbol s : syms.objectType.tsym.members().getSymbolsByName(name, s -&gt; s.kind == MTH)) {
1312             if (s.type.getParameterTypes().isEmpty()) {
1313                 return true;
1314             }
1315         }
1316         return false;
1317     }
1318 
1319     Fragment canInferLocalVarType(JCVariableDecl tree) {
1320         LocalInitScanner lis = new LocalInitScanner();
1321         lis.scan(tree.init);
1322         return lis.badInferenceMsg;
1323     }
1324 
1325     static class LocalInitScanner extends TreeScanner {
1326         Fragment badInferenceMsg = null;
1327         boolean needsTarget = true;
1328 
1329         @Override
1330         public void visitNewArray(JCNewArray tree) {
1331             if (tree.elemtype == null &amp;&amp; needsTarget) {
1332                 badInferenceMsg = Fragments.LocalArrayMissingTarget;
1333             }
1334         }
1335 
1336         @Override
1337         public void visitLambda(JCLambda tree) {
1338             if (needsTarget) {
1339                 badInferenceMsg = Fragments.LocalLambdaMissingTarget;
1340             }
1341         }
1342 
1343         @Override
1344         public void visitTypeCast(JCTypeCast tree) {
1345             boolean prevNeedsTarget = needsTarget;
1346             try {
1347                 needsTarget = false;
1348                 super.visitTypeCast(tree);
1349             } finally {
1350                 needsTarget = prevNeedsTarget;
1351             }
1352         }
1353 
1354         @Override
1355         public void visitReference(JCMemberReference tree) {
1356             if (needsTarget) {
1357                 badInferenceMsg = Fragments.LocalMrefMissingTarget;
1358             }
1359         }
1360 
1361         @Override
1362         public void visitNewClass(JCNewClass tree) {
1363             boolean prevNeedsTarget = needsTarget;
1364             try {
1365                 needsTarget = false;
1366                 super.visitNewClass(tree);
1367             } finally {
1368                 needsTarget = prevNeedsTarget;
1369             }
1370         }
1371 
1372         @Override
1373         public void visitApply(JCMethodInvocation tree) {
1374             boolean prevNeedsTarget = needsTarget;
1375             try {
1376                 needsTarget = false;
1377                 super.visitApply(tree);
1378             } finally {
1379                 needsTarget = prevNeedsTarget;
1380             }
1381         }
1382     }
1383 
1384     public void visitSkip(JCSkip tree) {
1385         result = null;
1386     }
1387 
1388     public void visitBlock(JCBlock tree) {
1389         if (env.info.scope.owner.kind == TYP || env.info.scope.owner.kind == ERR) {
1390             // Block is a static or instance initializer;
1391             // let the owner of the environment be a freshly
1392             // created BLOCK-method.
1393             Symbol fakeOwner =
1394                 new MethodSymbol(tree.flags | BLOCK |
1395                     env.info.scope.owner.flags() &amp; STRICTFP, names.empty, null,
1396                     env.info.scope.owner);
1397             final Env&lt;AttrContext&gt; localEnv =
1398                 env.dup(tree, env.info.dup(env.info.scope.dupUnshared(fakeOwner)));
1399 
1400             if ((tree.flags &amp; STATIC) != 0) localEnv.info.staticLevel++;
1401             // Attribute all type annotations in the block
1402             annotate.queueScanTreeAndTypeAnnotate(tree, localEnv, localEnv.info.scope.owner, null);
1403             annotate.flush();
1404             attribStats(tree.stats, localEnv);
1405 
1406             {
1407                 // Store init and clinit type annotations with the ClassSymbol
1408                 // to allow output in Gen.normalizeDefs.
1409                 ClassSymbol cs = (ClassSymbol)env.info.scope.owner;
1410                 List&lt;Attribute.TypeCompound&gt; tas = localEnv.info.scope.owner.getRawTypeAttributes();
1411                 if ((tree.flags &amp; STATIC) != 0) {
1412                     cs.appendClassInitTypeAttributes(tas);
1413                 } else {
1414                     cs.appendInitTypeAttributes(tas);
1415                 }
1416             }
1417         } else {
1418             // Create a new local environment with a local scope.
1419             Env&lt;AttrContext&gt; localEnv =
1420                 env.dup(tree, env.info.dup(env.info.scope.dup()));
1421             try {
1422                 attribStats(tree.stats, localEnv);
1423             } finally {
1424                 localEnv.info.scope.leave();
1425             }
1426         }
1427         result = null;
1428     }
1429 
1430     public void visitDoLoop(JCDoWhileLoop tree) {
1431         attribStat(tree.body, env.dup(tree));
1432         attribExpr(tree.cond, env, syms.booleanType);
1433         if (!breaksOutOf(tree, tree.body)) {
1434             //include condition&#39;s body when false after the while, if cannot get out of the loop
1435             MatchBindings condBindings = matchBindings;
1436             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1437             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1438         }
1439         result = null;
1440     }
1441 
1442     public void visitWhileLoop(JCWhileLoop tree) {
1443         attribExpr(tree.cond, env, syms.booleanType);
1444         MatchBindings condBindings = matchBindings;
1445         // include condition&#39;s bindings when true in the body:
1446         Env&lt;AttrContext&gt; whileEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1447         try {
1448             attribStat(tree.body, whileEnv.dup(tree));
1449         } finally {
1450             whileEnv.info.scope.leave();
1451         }
1452         if (!breaksOutOf(tree, tree.body)) {
1453             //include condition&#39;s bindings when false after the while, if cannot get out of the loop
1454             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1455             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1456         }
1457         result = null;
1458     }
1459 
1460     private boolean breaksOutOf(JCTree loop, JCTree body) {
1461         preFlow(body);
1462         return flow.breaksOutOf(env, loop, body, make);
1463     }
1464 
1465     public void visitForLoop(JCForLoop tree) {
1466         Env&lt;AttrContext&gt; loopEnv =
1467             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1468         MatchBindings condBindings = MatchBindingsComputer.EMPTY;
1469         try {
1470             attribStats(tree.init, loopEnv);
1471             if (tree.cond != null) {
1472                 attribExpr(tree.cond, loopEnv, syms.booleanType);
1473                 // include condition&#39;s bindings when true in the body and step:
1474                 condBindings = matchBindings;
1475             }
1476             Env&lt;AttrContext&gt; bodyEnv = bindingEnv(loopEnv, condBindings.bindingsWhenTrue);
1477             try {
1478                 bodyEnv.tree = tree; // before, we were not in loop!
1479                 attribStats(tree.step, bodyEnv);
1480                 attribStat(tree.body, bodyEnv);
1481             } finally {
1482                 bodyEnv.info.scope.leave();
1483             }
1484             result = null;
1485         }
1486         finally {
1487             loopEnv.info.scope.leave(); // all injected match bindings vanish here.
1488         }
1489         if (!breaksOutOf(tree, tree.body)) {
1490             //include condition&#39;s body when false after the while, if cannot get out of the loop
1491             condBindings.bindingsWhenFalse.forEach(env.info.scope::enter);
1492             condBindings.bindingsWhenFalse.forEach(BindingSymbol::preserveBinding);
1493         }
1494     }
1495 
1496     public void visitForeachLoop(JCEnhancedForLoop tree) {
1497         Env&lt;AttrContext&gt; loopEnv =
1498             env.dup(env.tree, env.info.dup(env.info.scope.dup()));
1499         try {
1500             //the Formal Parameter of a for-each loop is not in the scope when
1501             //attributing the for-each expression; we mimic this by attributing
1502             //the for-each expression first (against original scope).
1503             Type exprType = types.cvarUpperBound(attribExpr(tree.expr, loopEnv));
1504             chk.checkNonVoid(tree.pos(), exprType);
1505             Type elemtype = types.elemtype(exprType); // perhaps expr is an array?
1506             if (elemtype == null) {
1507                 // or perhaps expr implements Iterable&lt;T&gt;?
1508                 Type base = types.asSuper(exprType, syms.iterableType.tsym);
1509                 if (base == null) {
1510                     log.error(tree.expr.pos(),
1511                               Errors.ForeachNotApplicableToType(exprType,
1512                                                                 Fragments.TypeReqArrayOrIterable));
1513                     elemtype = types.createErrorType(exprType);
1514                 } else {
1515                     List&lt;Type&gt; iterableParams = base.allparams();
1516                     elemtype = iterableParams.isEmpty()
1517                         ? syms.objectType
1518                         : types.wildUpperBound(iterableParams.head);
1519                 }
1520             }
1521             if (tree.var.isImplicitlyTyped()) {
1522                 Type inferredType = chk.checkLocalVarType(tree.var, elemtype, tree.var.name);
1523                 setSyntheticVariableType(tree.var, inferredType);
1524             }
1525             attribStat(tree.var, loopEnv);
1526             chk.checkType(tree.expr.pos(), elemtype, tree.var.sym.type);
1527             loopEnv.tree = tree; // before, we were not in loop!
1528             attribStat(tree.body, loopEnv);
1529             result = null;
1530         }
1531         finally {
1532             loopEnv.info.scope.leave();
1533         }
1534     }
1535 
1536     public void visitLabelled(JCLabeledStatement tree) {
1537         // Check that label is not used in an enclosing statement
1538         Env&lt;AttrContext&gt; env1 = env;
1539         while (env1 != null &amp;&amp; !env1.tree.hasTag(CLASSDEF)) {
1540             if (env1.tree.hasTag(LABELLED) &amp;&amp;
1541                 ((JCLabeledStatement) env1.tree).label == tree.label) {
1542                 log.error(tree.pos(),
1543                           Errors.LabelAlreadyInUse(tree.label));
1544                 break;
1545             }
1546             env1 = env1.next;
1547         }
1548 
1549         attribStat(tree.body, env.dup(tree));
1550         result = null;
1551     }
1552 
1553     public void visitSwitch(JCSwitch tree) {
1554         handleSwitch(tree, tree.selector, tree.cases, (t, k) -&gt; ((JCSwitch) t).kind = k, (c, caseEnv) -&gt; {
1555             attribStats(c.stats, caseEnv);
1556         });
1557         result = null;
1558     }
1559 
1560     public void visitSwitchExpression(JCSwitchExpression tree) {
1561         tree.polyKind = (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly) ?
1562                 PolyKind.STANDALONE : PolyKind.POLY;
1563 
1564         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1565             //this means we are returning a poly conditional from void-compatible lambda expression
1566             resultInfo.checkContext.report(tree, diags.fragment(Fragments.SwitchExpressionTargetCantBeVoid));
1567             result = tree.type = types.createErrorType(resultInfo.pt);
1568             return;
1569         }
1570 
1571         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1572                 unknownExprInfo :
1573                 resultInfo.dup(switchExpressionContext(resultInfo.checkContext));
1574 
1575         ListBuffer&lt;DiagnosticPosition&gt; caseTypePositions = new ListBuffer&lt;&gt;();
1576         ListBuffer&lt;Type&gt; caseTypes = new ListBuffer&lt;&gt;();
1577 
1578         handleSwitch(tree, tree.selector, tree.cases, (t, k) -&gt; ((JCSwitchExpression) t).kind = k, (c, caseEnv) -&gt; {
1579             caseEnv.info.yieldResult = condInfo;
1580             attribStats(c.stats, caseEnv);
1581             new TreeScanner() {
1582                 @Override
1583                 public void visitYield(JCYield brk) {
1584                     if (brk.target == tree) {
1585                         caseTypePositions.append(brk.value != null ? brk.value.pos() : brk.pos());
1586                         caseTypes.append(brk.value != null ? brk.value.type : syms.errType);
1587                     }
1588                     super.visitYield(brk);
1589                 }
1590 
1591                 @Override public void visitClassDef(JCClassDecl tree) {}
1592                 @Override public void visitLambda(JCLambda tree) {}
1593             }.scan(c.stats);
1594         });
1595 
1596         if (tree.cases.isEmpty()) {
1597             log.error(tree.pos(),
1598                       Errors.SwitchExpressionEmpty);
1599         } else if (caseTypes.isEmpty()) {
1600             log.error(tree.pos(),
1601                       Errors.SwitchExpressionNoResultExpressions);
1602         }
1603 
1604         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ? condType(caseTypePositions.toList(), caseTypes.toList()) : pt();
1605 
1606         result = tree.type = check(tree, owntype, KindSelector.VAL, resultInfo);
1607     }
1608     //where:
1609         CheckContext switchExpressionContext(CheckContext checkContext) {
1610             return new Check.NestedCheckContext(checkContext) {
1611                 //this will use enclosing check context to check compatibility of
1612                 //subexpression against target type; if we are in a method check context,
1613                 //depending on whether boxing is allowed, we could have incompatibilities
1614                 @Override
1615                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
1616                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInSwitchExpression(details)));
1617                 }
1618             };
1619         }
1620 
1621     private void handleSwitch(JCTree switchTree,
1622                               JCExpression selector,
1623                               List&lt;JCCase&gt; cases,
1624                               BiConsumer&lt;JCTree, SwitchKind&gt; kindSetter,
1625                               BiConsumer&lt;JCCase, Env&lt;AttrContext&gt;&gt; attribCase) {
1626         Type seltype = attribExpr(selector, env);
1627 
1628         Env&lt;AttrContext&gt; switchEnv =
1629             env.dup(switchTree, env.info.dup(env.info.scope.dup()));
1630 
1631         try {
1632             boolean hasPatternCases = cases.stream()
1633                                            .flatMap(c -&gt; c.pats.stream())
1634                                            .anyMatch(pat -&gt; pat.constExpression() == null); //XXX: null handling???
1635             SwitchKind kind;
1636             if (hasPatternCases) {
1637                 //TODO: check source level
1638                 kind = SwitchKind.MATCHING;
1639             } else if ((seltype.tsym.flags() &amp; Flags.ENUM) != 0) {
1640                 kind = SwitchKind.ENUM;
1641             } else if (types.isSameType(seltype, syms.stringType)) {
1642                 kind = SwitchKind.STRING;
1643             } else if (!types.isAssignable(seltype, syms.intType) &amp;&amp;
1644                        !types.isSameType(seltype, syms.voidType)) {
1645                 //TODO: check source level
1646                 kind = SwitchKind.MATCHING;
1647             } else {
1648                 seltype = chk.checkType(selector.pos(), seltype, syms.intType);
1649                 kind = SwitchKind.ORDINARY;
1650             }
1651             kindSetter.accept(switchTree, kind);
1652             // Attribute all cases and
1653             // check that there are no duplicate case labels or default clauses.
1654             Set&lt;Object&gt; labels = new HashSet&lt;&gt;(); // The set of case labels.
1655             boolean hasDefault = false;      // Is there a default label?
1656             MatchBindings prevBindings = null;
1657             @SuppressWarnings(&quot;removal&quot;)
1658             CaseKind caseKind = null;
1659             boolean wasError = false;
1660             for (List&lt;JCCase&gt; l = cases; l.nonEmpty(); l = l.tail) {
1661                 JCCase c = l.head;
1662                 if (caseKind == null) {
1663                     caseKind = c.caseKind;
1664                 } else if (caseKind != c.caseKind &amp;&amp; !wasError) {
1665                     log.error(c.pos(),
1666                               Errors.SwitchMixingCaseTypes);
1667                     wasError = true;
1668                 }
1669                 MatchBindings currentBindings = prevBindings;
1670                 if (c.getPatterns().nonEmpty()) {
1671                     for (JCPattern pat : c.getPatterns()) {
1672                         if (TreeInfo.isNull(pat)) {
1673                             log.error(pat.pos(),
1674                                       Errors.SwitchNullNotAllowed);
1675                             continue;
1676                         }
1677                         switch (kind) {
1678                             case MATCHING:
1679                                 ResultInfo castInfo = unknownExprInfo;
1680                                 if (pat.getTag() == BINDINGPATTERN) {
1681                                     JCBindingPattern bindingPattern = (JCBindingPattern) pat;
1682                                     if (bindingPattern.vartype == null)
1683                                         castInfo = castInfo(seltype);
1684                                 }
1685                                 Type patType = attribTree(pat, switchEnv, castInfo);
1686                                 chk.checkCastable(selector.pos(), seltype, patType);
1687                                 if (pat.getTag() == LITERALPATTERN &amp;&amp; !labels.add(patType.constValue())) {
1688                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1689                                 }
1690                                 break;
1691                             case ENUM:
1692                                 Symbol sym = enumConstant(pat.constExpression(), seltype);
1693                                 if (sym == null) {
1694                                     log.error(pat.constExpression().pos(), Errors.EnumLabelMustBeUnqualifiedEnum);
1695                                 } else if (!labels.add(sym)) {
1696                                     log.error(c.pos(), Errors.DuplicateCaseLabel);
1697                                 }
1698                                 break;
1699                             default:
1700                                 Type pattype = attribExpr(pat.constExpression(), switchEnv, seltype);
1701                                 if (!pattype.hasTag(ERROR)) {
1702                                     if (pattype.constValue() == null) {
1703                                         log.error(pat.constExpression().pos(),
1704                                                   (kind == SwitchKind.STRING ? Errors.StringConstReq
1705                                                                                   : Errors.ConstExprReq));
1706                                     } else if (!labels.add(pattype.constValue())) {
1707                                         log.error(c.pos(), Errors.DuplicateCaseLabel);
1708                                     }
1709                                 }
1710                                 break;
1711                         }
1712                         currentBindings = matchBindingsComputer.switchCase(pat, currentBindings, matchBindings);
1713                     }
1714                 } else {
1715                     if (hasDefault) {
1716                         log.error(c.pos(), Errors.DuplicateDefaultLabel);
1717                     } else {
1718                         hasDefault = true;
1719                     }
1720                     currentBindings = MatchBindingsComputer.EMPTY;
1721                 }
1722 
1723                 Env&lt;AttrContext&gt; caseEnv = bindingEnv(switchEnv, currentBindings.bindingsWhenTrue);
1724 
1725                 caseEnv.tree = c;
1726 
1727                 try {
1728                     attribCase.accept(c, caseEnv);
1729                 } finally {
1730                     caseEnv.info.scope.leave();
1731                 }
1732 
1733                 addVars(c.stats, switchEnv.info.scope);
1734 
1735                 c.completesNormally = flow.aliveAfter(caseEnv, c, make);
1736                 prevBindings = c.completesNormally ? matchBindings : null;
1737             }
1738         } finally {
1739             switchEnv.info.scope.leave();
1740         }
1741     }
1742     // where
1743         /** Add any variables defined in stats to the switch scope. */
1744         private static void addVars(List&lt;JCStatement&gt; stats, WriteableScope switchScope) {
1745             for (;stats.nonEmpty(); stats = stats.tail) {
1746                 JCTree stat = stats.head;
1747                 if (stat.hasTag(VARDEF))
1748                     switchScope.enter(((JCVariableDecl) stat).sym);
1749             }
1750         }
1751     // where
1752     /** Return the selected enumeration constant symbol, or null. */
1753     private Symbol enumConstant(JCTree tree, Type enumType) {
1754         if (tree.hasTag(IDENT)) {
1755             JCIdent ident = (JCIdent)tree;
1756             Name name = ident.name;
1757             for (Symbol sym : enumType.tsym.members().getSymbolsByName(name)) {
1758                 if (sym.kind == VAR) {
1759                     Symbol s = ident.sym = sym;
1760                     ((VarSymbol)s).getConstValue(); // ensure initializer is evaluated
1761                     ident.type = s.type;
1762                     return ((s.flags_field &amp; Flags.ENUM) == 0)
1763                         ? null : s;
1764                 }
1765             }
1766         }
1767         return null;
1768     }
1769 
1770     ResultInfo castInfo(Type target) {
1771         return target.isErroneous()
1772                 ? unknownExprInfo
1773                 : new ResultInfo(KindSelector.VAL, target,
1774                         new Check.NestedCheckContext(resultInfo.checkContext) {
1775                             @Override
1776                             public boolean compatible(Type found, Type req, Warner warn) {
1777                                 return types.isCastable(found, req, warn);
1778                             }
1779                 });
1780     }
1781 
1782 
1783     public void visitSynchronized(JCSynchronized tree) {
1784         chk.checkRefType(tree.pos(), attribExpr(tree.lock, env));
1785         attribStat(tree.body, env);
1786         result = null;
1787     }
1788 
1789     public void visitTry(JCTry tree) {
1790         // Create a new local environment with a local
1791         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup(env.info.scope.dup()));
1792         try {
1793             boolean isTryWithResource = tree.resources.nonEmpty();
1794             // Create a nested environment for attributing the try block if needed
1795             Env&lt;AttrContext&gt; tryEnv = isTryWithResource ?
1796                 env.dup(tree, localEnv.info.dup(localEnv.info.scope.dup())) :
1797                 localEnv;
1798             try {
1799                 // Attribute resource declarations
1800                 for (JCTree resource : tree.resources) {
1801                     CheckContext twrContext = new Check.NestedCheckContext(resultInfo.checkContext) {
1802                         @Override
1803                         public void report(DiagnosticPosition pos, JCDiagnostic details) {
1804                             chk.basicHandler.report(pos, diags.fragment(Fragments.TryNotApplicableToType(details)));
1805                         }
1806                     };
1807                     ResultInfo twrResult =
1808                         new ResultInfo(KindSelector.VAR,
1809                                        syms.autoCloseableType,
1810                                        twrContext);
1811                     if (resource.hasTag(VARDEF)) {
1812                         attribStat(resource, tryEnv);
1813                         twrResult.check(resource, resource.type);
1814 
1815                         //check that resource type cannot throw InterruptedException
1816                         checkAutoCloseable(resource.pos(), localEnv, resource.type);
1817 
1818                         VarSymbol var = ((JCVariableDecl) resource).sym;
1819                         var.setData(ElementKind.RESOURCE_VARIABLE);
1820                     } else {
1821                         attribTree(resource, tryEnv, twrResult);
1822                     }
1823                 }
1824                 // Attribute body
1825                 attribStat(tree.body, tryEnv);
1826             } finally {
1827                 if (isTryWithResource)
1828                     tryEnv.info.scope.leave();
1829             }
1830 
1831             // Attribute catch clauses
1832             for (List&lt;JCCatch&gt; l = tree.catchers; l.nonEmpty(); l = l.tail) {
1833                 JCCatch c = l.head;
1834                 Env&lt;AttrContext&gt; catchEnv =
1835                     localEnv.dup(c, localEnv.info.dup(localEnv.info.scope.dup()));
1836                 try {
1837                     Type ctype = attribStat(c.param, catchEnv);
1838                     if (TreeInfo.isMultiCatch(c)) {
1839                         //multi-catch parameter is implicitly marked as final
1840                         c.param.sym.flags_field |= FINAL | UNION;
1841                     }
1842                     if (c.param.sym.kind == VAR) {
1843                         c.param.sym.setData(ElementKind.EXCEPTION_PARAMETER);
1844                     }
1845                     chk.checkType(c.param.vartype.pos(),
1846                                   chk.checkClassType(c.param.vartype.pos(), ctype),
1847                                   syms.throwableType);
1848                     attribStat(c.body, catchEnv);
1849                 } finally {
1850                     catchEnv.info.scope.leave();
1851                 }
1852             }
1853 
1854             // Attribute finalizer
1855             if (tree.finalizer != null) attribStat(tree.finalizer, localEnv);
1856             result = null;
1857         }
1858         finally {
1859             localEnv.info.scope.leave();
1860         }
1861     }
1862 
1863     void checkAutoCloseable(DiagnosticPosition pos, Env&lt;AttrContext&gt; env, Type resource) {
1864         if (!resource.isErroneous() &amp;&amp;
1865             types.asSuper(resource, syms.autoCloseableType.tsym) != null &amp;&amp;
1866             !types.isSameType(resource, syms.autoCloseableType)) { // Don&#39;t emit warning for AutoCloseable itself
1867             Symbol close = syms.noSymbol;
1868             Log.DiagnosticHandler discardHandler = new Log.DiscardDiagnosticHandler(log);
1869             try {
1870                 close = rs.resolveQualifiedMethod(pos,
1871                         env,
1872                         types.skipTypeVars(resource, false),
1873                         names.close,
1874                         List.nil(),
1875                         List.nil());
1876             }
1877             finally {
1878                 log.popDiagnosticHandler(discardHandler);
1879             }
1880             if (close.kind == MTH &amp;&amp;
1881                     close.overrides(syms.autoCloseableClose, resource.tsym, types, true) &amp;&amp;
1882                     chk.isHandled(syms.interruptedExceptionType, types.memberType(resource, close).getThrownTypes()) &amp;&amp;
1883                     env.info.lint.isEnabled(LintCategory.TRY)) {
1884                 log.warning(LintCategory.TRY, pos, Warnings.TryResourceThrowsInterruptedExc(resource));
1885             }
1886         }
1887     }
1888 
1889     public void visitConditional(JCConditional tree) {
1890         Type condtype = attribExpr(tree.cond, env, syms.booleanType);
1891         MatchBindings condBindings = matchBindings;
1892 
1893         tree.polyKind = (!allowPoly ||
1894                 pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType &amp;&amp; pt() != Infer.anyPoly ||
1895                 isBooleanOrNumeric(env, tree)) ?
1896                 PolyKind.STANDALONE : PolyKind.POLY;
1897 
1898         if (tree.polyKind == PolyKind.POLY &amp;&amp; resultInfo.pt.hasTag(VOID)) {
1899             //this means we are returning a poly conditional from void-compatible lambda expression
1900             resultInfo.checkContext.report(tree, diags.fragment(Fragments.ConditionalTargetCantBeVoid));
1901             result = tree.type = types.createErrorType(resultInfo.pt);
1902             return;
1903         }
1904 
1905         ResultInfo condInfo = tree.polyKind == PolyKind.STANDALONE ?
1906                 unknownExprInfo :
1907                 resultInfo.dup(conditionalContext(resultInfo.checkContext));
1908 
1909 
1910         // x ? y : z
1911         // include x&#39;s bindings when true in y
1912         // include x&#39;s bindings when false in z
1913 
1914         Type truetype;
1915         Env&lt;AttrContext&gt; trueEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
1916         try {
1917             truetype = attribTree(tree.truepart, trueEnv, condInfo);
1918         } finally {
1919             trueEnv.info.scope.leave();
1920         }
1921 
1922         MatchBindings trueBindings = matchBindings;
1923 
1924         Type falsetype;
1925         Env&lt;AttrContext&gt; falseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
1926         try {
1927             falsetype = attribTree(tree.falsepart, falseEnv, condInfo);
1928         } finally {
1929             falseEnv.info.scope.leave();
1930         }
1931 
1932         MatchBindings falseBindings = matchBindings;
1933 
1934         Type owntype = (tree.polyKind == PolyKind.STANDALONE) ?
1935                 condType(List.of(tree.truepart.pos(), tree.falsepart.pos()),
1936                          List.of(truetype, falsetype)) : pt();
1937         if (condtype.constValue() != null &amp;&amp;
1938                 truetype.constValue() != null &amp;&amp;
1939                 falsetype.constValue() != null &amp;&amp;
1940                 !owntype.hasTag(NONE)) {
1941             //constant folding
1942             owntype = cfolder.coerce(condtype.isTrue() ? truetype : falsetype, owntype);
1943         }
1944         result = check(tree, owntype, KindSelector.VAL, resultInfo);
1945         matchBindings = matchBindingsComputer.conditional(tree, condBindings, trueBindings, falseBindings);
1946     }
1947     //where
1948         private boolean isBooleanOrNumeric(Env&lt;AttrContext&gt; env, JCExpression tree) {
1949             switch (tree.getTag()) {
1950                 case LITERAL: return ((JCLiteral)tree).typetag.isSubRangeOf(DOUBLE) ||
1951                               ((JCLiteral)tree).typetag == BOOLEAN ||
1952                               ((JCLiteral)tree).typetag == BOT;
1953                 case LAMBDA: case REFERENCE: return false;
1954                 case PARENS: return isBooleanOrNumeric(env, ((JCParens)tree).expr);
1955                 case CONDEXPR:
1956                     JCConditional condTree = (JCConditional)tree;
1957                     return isBooleanOrNumeric(env, condTree.truepart) &amp;&amp;
1958                             isBooleanOrNumeric(env, condTree.falsepart);
1959                 case APPLY:
1960                     JCMethodInvocation speculativeMethodTree =
1961                             (JCMethodInvocation)deferredAttr.attribSpeculative(
1962                                     tree, env, unknownExprInfo,
1963                                     argumentAttr.withLocalCacheContext());
1964                     Symbol msym = TreeInfo.symbol(speculativeMethodTree.meth);
1965                     Type receiverType = speculativeMethodTree.meth.hasTag(IDENT) ?
1966                             env.enclClass.type :
1967                             ((JCFieldAccess)speculativeMethodTree.meth).selected.type;
1968                     Type owntype = types.memberType(receiverType, msym).getReturnType();
1969                     return primitiveOrBoxed(owntype);
1970                 case NEWCLASS:
1971                     JCExpression className =
1972                             removeClassParams.translate(((JCNewClass)tree).clazz);
1973                     JCExpression speculativeNewClassTree =
1974                             (JCExpression)deferredAttr.attribSpeculative(
1975                                     className, env, unknownTypeInfo,
1976                                     argumentAttr.withLocalCacheContext());
1977                     return primitiveOrBoxed(speculativeNewClassTree.type);
1978                 default:
1979                     Type speculativeType = deferredAttr.attribSpeculative(tree, env, unknownExprInfo,
1980                             argumentAttr.withLocalCacheContext()).type;
1981                     return primitiveOrBoxed(speculativeType);
1982             }
1983         }
1984         //where
1985             boolean primitiveOrBoxed(Type t) {
1986                 return (!t.hasTag(TYPEVAR) &amp;&amp; types.unboxedTypeOrType(t).isPrimitive());
1987             }
1988 
1989             TreeTranslator removeClassParams = new TreeTranslator() {
1990                 @Override
1991                 public void visitTypeApply(JCTypeApply tree) {
1992                     result = translate(tree.clazz);
1993                 }
1994             };
1995 
1996         CheckContext conditionalContext(CheckContext checkContext) {
1997             return new Check.NestedCheckContext(checkContext) {
1998                 //this will use enclosing check context to check compatibility of
1999                 //subexpression against target type; if we are in a method check context,
2000                 //depending on whether boxing is allowed, we could have incompatibilities
2001                 @Override
2002                 public void report(DiagnosticPosition pos, JCDiagnostic details) {
2003                     enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleTypeInConditional(details)));
2004                 }
2005             };
2006         }
2007 
2008         /** Compute the type of a conditional expression, after
2009          *  checking that it exists.  See JLS 15.25. Does not take into
2010          *  account the special case where condition and both arms
2011          *  are constants.
2012          *
2013          *  @param pos      The source position to be used for error
2014          *                  diagnostics.
2015          *  @param thentype The type of the expression&#39;s then-part.
2016          *  @param elsetype The type of the expression&#39;s else-part.
2017          */
2018         Type condType(List&lt;DiagnosticPosition&gt; positions, List&lt;Type&gt; condTypes) {
2019             if (condTypes.isEmpty()) {
2020                 return syms.objectType; //TODO: how to handle?
2021             }
2022             Type first = condTypes.head;
2023             // If same type, that is the result
2024             if (condTypes.tail.stream().allMatch(t -&gt; types.isSameType(first, t)))
2025                 return first.baseType();
2026 
2027             List&lt;Type&gt; unboxedTypes = condTypes.stream()
2028                                                .map(t -&gt; t.isPrimitive() ? t : types.unboxedType(t))
2029                                                .collect(List.collector());
2030 
2031             // Otherwise, if both arms can be converted to a numeric
2032             // type, return the least numeric type that fits both arms
2033             // (i.e. return larger of the two, or return int if one
2034             // arm is short, the other is char).
2035             if (unboxedTypes.stream().allMatch(t -&gt; t.isPrimitive())) {
2036                 // If one arm has an integer subrange type (i.e., byte,
2037                 // short, or char), and the other is an integer constant
2038                 // that fits into the subrange, return the subrange type.
2039                 for (Type type : unboxedTypes) {
2040                     if (!type.getTag().isStrictSubRangeOf(INT)) {
2041                         continue;
2042                     }
2043                     if (unboxedTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; t.hasTag(INT) &amp;&amp; types.isAssignable(t, type)))
2044                         return type.baseType();
2045                 }
2046 
2047                 for (TypeTag tag : primitiveTags) {
2048                     Type candidate = syms.typeOfTag[tag.ordinal()];
2049                     if (unboxedTypes.stream().allMatch(t -&gt; types.isSubtype(t, candidate))) {
2050                         return candidate;
2051                     }
2052                 }
2053             }
2054 
2055             // Those were all the cases that could result in a primitive
2056             condTypes = condTypes.stream()
2057                                  .map(t -&gt; t.isPrimitive() ? types.boxedClass(t).type : t)
2058                                  .collect(List.collector());
2059 
2060             for (Type type : condTypes) {
2061                 if (condTypes.stream().filter(t -&gt; t != type).allMatch(t -&gt; types.isAssignable(t, type)))
2062                     return type.baseType();
2063             }
2064 
2065             Iterator&lt;DiagnosticPosition&gt; posIt = positions.iterator();
2066 
2067             condTypes = condTypes.stream()
2068                                  .map(t -&gt; chk.checkNonVoid(posIt.next(), t))
2069                                  .collect(List.collector());
2070 
2071             // both are known to be reference types.  The result is
2072             // lub(thentype,elsetype). This cannot fail, as it will
2073             // always be possible to infer &quot;Object&quot; if nothing better.
2074             return types.lub(condTypes.stream().map(t -&gt; t.baseType()).collect(List.collector()));
2075         }
2076 
2077     final static TypeTag[] primitiveTags = new TypeTag[]{
2078         BYTE,
2079         CHAR,
2080         SHORT,
2081         INT,
2082         LONG,
2083         FLOAT,
2084         DOUBLE,
2085         BOOLEAN,
2086     };
2087 
2088     Env&lt;AttrContext&gt; bindingEnv(Env&lt;AttrContext&gt; env, List&lt;BindingSymbol&gt; bindings) {
2089         Env&lt;AttrContext&gt; env1 = env.dup(env.tree, env.info.dup(env.info.scope.dup()));
2090         bindings.forEach(env1.info.scope::enter);
2091         return env1;
2092     }
2093 
2094     public void visitIf(JCIf tree) {
2095         attribExpr(tree.cond, env, syms.booleanType);
2096 
2097         // if (x) { y } [ else z ]
2098         // include x&#39;s bindings when true in y
2099         // include x&#39;s bindings when false in z
2100 
2101         MatchBindings condBindings = matchBindings;
2102         Env&lt;AttrContext&gt; thenEnv = bindingEnv(env, condBindings.bindingsWhenTrue);
2103 
2104         try {
2105             attribStat(tree.thenpart, thenEnv);
2106         } finally {
2107             thenEnv.info.scope.leave();
2108         }
2109 
2110         preFlow(tree.thenpart);
2111         boolean aliveAfterThen = flow.aliveAfter(env, tree.thenpart, make);
2112         boolean aliveAfterElse;
2113 
2114         if (tree.elsepart != null) {
2115             Env&lt;AttrContext&gt; elseEnv = bindingEnv(env, condBindings.bindingsWhenFalse);
2116             try {
2117                 attribStat(tree.elsepart, elseEnv);
2118             } finally {
2119                 elseEnv.info.scope.leave();
2120             }
2121             preFlow(tree.elsepart);
2122             aliveAfterElse = flow.aliveAfter(env, tree.elsepart, make);
2123         } else {
2124             aliveAfterElse = true;
2125         }
2126 
2127         chk.checkEmptyIf(tree);
2128 
2129         List&lt;BindingSymbol&gt; afterIfBindings = List.nil();
2130 
2131         if (aliveAfterThen &amp;&amp; !aliveAfterElse) {
2132             afterIfBindings = condBindings.bindingsWhenTrue;
2133         } else if (aliveAfterElse &amp;&amp; !aliveAfterThen) {
2134             afterIfBindings = condBindings.bindingsWhenFalse;
2135         }
2136 
2137         afterIfBindings.forEach(env.info.scope::enter);
2138         afterIfBindings.forEach(BindingSymbol::preserveBinding);
2139 
2140         result = null;
2141     }
2142 
2143         void preFlow(JCTree tree) {
2144             new PostAttrAnalyzer() {
2145                 @Override
2146                 public void scan(JCTree tree) {
2147                     if (tree == null ||
2148                             (tree.type != null &amp;&amp;
2149                             tree.type == Type.stuckType)) {
2150                         //don&#39;t touch stuck expressions!
2151                         return;
2152                     }
2153                     super.scan(tree);
2154                 }
2155             }.scan(tree);
2156         }
2157 
2158     public void visitExec(JCExpressionStatement tree) {
2159         //a fresh environment is required for 292 inference to work properly ---
2160         //see Infer.instantiatePolymorphicSignatureInstance()
2161         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2162         attribExpr(tree.expr, localEnv);
2163         result = null;
2164     }
2165 
2166     public void visitBreak(JCBreak tree) {
2167         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2168         result = null;
2169     }
2170 
2171     public void visitYield(JCYield tree) {
2172         if (env.info.yieldResult != null) {
2173             attribTree(tree.value, env, env.info.yieldResult);
2174             tree.target = findJumpTarget(tree.pos(), tree.getTag(), names.empty, env);
2175         } else {
2176             log.error(tree.pos(), tree.value.hasTag(PARENS)
2177                     ? Errors.NoSwitchExpressionQualify
2178                     : Errors.NoSwitchExpression);
2179             attribTree(tree.value, env, unknownExprInfo);
2180         }
2181         result = null;
2182     }
2183 
2184     public void visitContinue(JCContinue tree) {
2185         tree.target = findJumpTarget(tree.pos(), tree.getTag(), tree.label, env);
2186         result = null;
2187     }
2188     //where
2189         /** Return the target of a break, continue or yield statement,
2190          *  if it exists, report an error if not.
2191          *  Note: The target of a labelled break or continue is the
2192          *  (non-labelled) statement tree referred to by the label,
2193          *  not the tree representing the labelled statement itself.
2194          *
2195          *  @param pos     The position to be used for error diagnostics
2196          *  @param tag     The tag of the jump statement. This is either
2197          *                 Tree.BREAK or Tree.CONTINUE.
2198          *  @param label   The label of the jump statement, or null if no
2199          *                 label is given.
2200          *  @param env     The environment current at the jump statement.
2201          */
2202         private JCTree findJumpTarget(DiagnosticPosition pos,
2203                                                    JCTree.Tag tag,
2204                                                    Name label,
2205                                                    Env&lt;AttrContext&gt; env) {
2206             Pair&lt;JCTree, Error&gt; jumpTarget = findJumpTargetNoError(tag, label, env);
2207 
2208             if (jumpTarget.snd != null) {
2209                 log.error(pos, jumpTarget.snd);
2210             }
2211 
2212             return jumpTarget.fst;
2213         }
2214         /** Return the target of a break or continue statement, if it exists,
2215          *  report an error if not.
2216          *  Note: The target of a labelled break or continue is the
2217          *  (non-labelled) statement tree referred to by the label,
2218          *  not the tree representing the labelled statement itself.
2219          *
2220          *  @param tag     The tag of the jump statement. This is either
2221          *                 Tree.BREAK or Tree.CONTINUE.
2222          *  @param label   The label of the jump statement, or null if no
2223          *                 label is given.
2224          *  @param env     The environment current at the jump statement.
2225          */
2226         private Pair&lt;JCTree, JCDiagnostic.Error&gt; findJumpTargetNoError(JCTree.Tag tag,
2227                                                                        Name label,
2228                                                                        Env&lt;AttrContext&gt; env) {
2229             // Search environments outwards from the point of jump.
2230             Env&lt;AttrContext&gt; env1 = env;
2231             JCDiagnostic.Error pendingError = null;
2232             LOOP:
2233             while (env1 != null) {
2234                 switch (env1.tree.getTag()) {
2235                     case LABELLED:
2236                         JCLabeledStatement labelled = (JCLabeledStatement)env1.tree;
2237                         if (label == labelled.label) {
2238                             // If jump is a continue, check that target is a loop.
2239                             if (tag == CONTINUE) {
2240                                 if (!labelled.body.hasTag(DOLOOP) &amp;&amp;
2241                                         !labelled.body.hasTag(WHILELOOP) &amp;&amp;
2242                                         !labelled.body.hasTag(FORLOOP) &amp;&amp;
2243                                         !labelled.body.hasTag(FOREACHLOOP)) {
2244                                     pendingError = Errors.NotLoopLabel(label);
2245                                 }
2246                                 // Found labelled statement target, now go inwards
2247                                 // to next non-labelled tree.
2248                                 return Pair.of(TreeInfo.referencedStatement(labelled), pendingError);
2249                             } else {
2250                                 return Pair.of(labelled, pendingError);
2251                             }
2252                         }
2253                         break;
2254                     case DOLOOP:
2255                     case WHILELOOP:
2256                     case FORLOOP:
2257                     case FOREACHLOOP:
2258                         if (label == null) return Pair.of(env1.tree, pendingError);
2259                         break;
2260                     case SWITCH:
2261                         if (label == null &amp;&amp; tag == BREAK) return Pair.of(env1.tree, null);
2262                         break;
2263                     case SWITCH_EXPRESSION:
2264                         if (tag == YIELD) {
2265                             return Pair.of(env1.tree, null);
2266                         } else if (tag == BREAK) {
2267                             pendingError = Errors.BreakOutsideSwitchExpression;
2268                         } else {
2269                             pendingError = Errors.ContinueOutsideSwitchExpression;
2270                         }
2271                         break;
2272                     case LAMBDA:
2273                     case METHODDEF:
2274                     case CLASSDEF:
2275                         break LOOP;
2276                     default:
2277                 }
2278                 env1 = env1.next;
2279             }
2280             if (label != null)
2281                 return Pair.of(null, Errors.UndefLabel(label));
2282             else if (pendingError != null)
2283                 return Pair.of(null, pendingError);
2284             else if (tag == CONTINUE)
2285                 return Pair.of(null, Errors.ContOutsideLoop);
2286             else
2287                 return Pair.of(null, Errors.BreakOutsideSwitchLoop);
2288         }
2289 
2290     public void visitReturn(JCReturn tree) {
2291         // Check that there is an enclosing method which is
2292         // nested within than the enclosing class.
2293         if (env.info.returnResult == null) {
2294             log.error(tree.pos(), Errors.RetOutsideMeth);
2295         } else if (env.info.yieldResult != null) {
2296             log.error(tree.pos(), Errors.ReturnOutsideSwitchExpression);
2297         } else if (!env.info.isLambda &amp;&amp;
2298                 !env.info.isNewClass &amp;&amp;
2299                 env.enclMethod != null &amp;&amp;
2300                 TreeInfo.isCompactConstructor(env.enclMethod)) {
2301             log.error(env.enclMethod,
2302                     Errors.InvalidCanonicalConstructorInRecord(Fragments.Compact, env.enclMethod.sym.name, Fragments.CanonicalCantHaveReturnStatement));
2303         } else {
2304             // Attribute return expression, if it exists, and check that
2305             // it conforms to result type of enclosing method.
2306             if (tree.expr != null) {
2307                 if (env.info.returnResult.pt.hasTag(VOID)) {
2308                     env.info.returnResult.checkContext.report(tree.expr.pos(),
2309                               diags.fragment(Fragments.UnexpectedRetVal));
2310                 }
2311                 attribTree(tree.expr, env, env.info.returnResult);
2312             } else if (!env.info.returnResult.pt.hasTag(VOID) &amp;&amp;
2313                     !env.info.returnResult.pt.hasTag(NONE)) {
2314                 env.info.returnResult.checkContext.report(tree.pos(),
2315                               diags.fragment(Fragments.MissingRetVal(env.info.returnResult.pt)));
2316             }
2317         }
2318         result = null;
2319     }
2320 
2321     public void visitThrow(JCThrow tree) {
2322         Type owntype = attribExpr(tree.expr, env, allowPoly ? Type.noType : syms.throwableType);
2323         if (allowPoly) {
2324             chk.checkType(tree, owntype, syms.throwableType);
2325         }
2326         result = null;
2327     }
2328 
2329     public void visitAssert(JCAssert tree) {
2330         attribExpr(tree.cond, env, syms.booleanType);
2331         if (tree.detail != null) {
2332             chk.checkNonVoid(tree.detail.pos(), attribExpr(tree.detail, env));
2333         }
2334         result = null;
2335     }
2336 
2337      /** Visitor method for method invocations.
2338      *  NOTE: The method part of an application will have in its type field
2339      *        the return type of the method, not the method&#39;s type itself!
2340      */
2341     public void visitApply(JCMethodInvocation tree) {
2342         // The local environment of a method application is
2343         // a new environment nested in the current one.
2344         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2345 
2346         // The types of the actual method arguments.
2347         List&lt;Type&gt; argtypes;
2348 
2349         // The types of the actual method type arguments.
2350         List&lt;Type&gt; typeargtypes = null;
2351 
2352         Name methName = TreeInfo.name(tree.meth);
2353 
2354         boolean isConstructorCall =
2355             methName == names._this || methName == names._super;
2356 
2357         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2358         if (isConstructorCall) {
2359             // We are seeing a ...this(...) or ...super(...) call.
2360             // Check that this is the first statement in a constructor.
2361             if (checkFirstConstructorStat(tree, env.enclMethod, true)) {
2362 
2363                 // Record the fact
2364                 // that this is a constructor call (using isSelfCall).
2365                 localEnv.info.isSelfCall = true;
2366 
2367                 // Attribute arguments, yielding list of argument types.
2368                 KindSelector kind = attribArgs(KindSelector.MTH, tree.args, localEnv, argtypesBuf);
2369                 argtypes = argtypesBuf.toList();
2370                 typeargtypes = attribTypes(tree.typeargs, localEnv);
2371 
2372                 // Variable `site&#39; points to the class in which the called
2373                 // constructor is defined.
2374                 Type site = env.enclClass.sym.type;
2375                 if (methName == names._super) {
2376                     if (site == syms.objectType) {
2377                         log.error(tree.meth.pos(), Errors.NoSuperclass(site));
2378                         site = types.createErrorType(syms.objectType);
2379                     } else {
2380                         site = types.supertype(site);
2381                     }
2382                 }
2383 
2384                 if (site.hasTag(CLASS)) {
2385                     Type encl = site.getEnclosingType();
2386                     while (encl != null &amp;&amp; encl.hasTag(TYPEVAR))
2387                         encl = encl.getUpperBound();
2388                     if (encl.hasTag(CLASS)) {
2389                         // we are calling a nested class
2390 
2391                         if (tree.meth.hasTag(SELECT)) {
2392                             JCTree qualifier = ((JCFieldAccess) tree.meth).selected;
2393 
2394                             // We are seeing a prefixed call, of the form
2395                             //     &lt;expr&gt;.super(...).
2396                             // Check that the prefix expression conforms
2397                             // to the outer instance type of the class.
2398                             chk.checkRefType(qualifier.pos(),
2399                                              attribExpr(qualifier, localEnv,
2400                                                         encl));
2401                         } else if (methName == names._super) {
2402                             // qualifier omitted; check for existence
2403                             // of an appropriate implicit qualifier.
2404                             rs.resolveImplicitThis(tree.meth.pos(),
2405                                                    localEnv, site, true);
2406                         }
2407                     } else if (tree.meth.hasTag(SELECT)) {
2408                         log.error(tree.meth.pos(),
2409                                   Errors.IllegalQualNotIcls(site.tsym));
2410                     }
2411 
2412                     // if we&#39;re calling a java.lang.Enum constructor,
2413                     // prefix the implicit String and int parameters
2414                     if (site.tsym == syms.enumSym)
2415                         argtypes = argtypes.prepend(syms.intType).prepend(syms.stringType);
2416 
2417                     // Resolve the called constructor under the assumption
2418                     // that we are referring to a superclass instance of the
2419                     // current instance (JLS ???).
2420                     boolean selectSuperPrev = localEnv.info.selectSuper;
2421                     localEnv.info.selectSuper = true;
2422                     localEnv.info.pendingResolutionPhase = null;
2423                     Symbol sym = rs.resolveConstructor(
2424                         tree.meth.pos(), localEnv, site, argtypes, typeargtypes);
2425                     localEnv.info.selectSuper = selectSuperPrev;
2426 
2427                     // Set method symbol to resolved constructor...
2428                     TreeInfo.setSymbol(tree.meth, sym);
2429 
2430                     // ...and check that it is legal in the current context.
2431                     // (this will also set the tree&#39;s type)
2432                     Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2433                     checkId(tree.meth, site, sym, localEnv,
2434                             new ResultInfo(kind, mpt));
2435                 }
2436                 // Otherwise, `site&#39; is an error type and we do nothing
2437             }
2438             result = tree.type = syms.voidType;
2439         } else {
2440             // Otherwise, we are seeing a regular method call.
2441             // Attribute the arguments, yielding list of argument types, ...
2442             KindSelector kind = attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2443             argtypes = argtypesBuf.toList();
2444             typeargtypes = attribAnyTypes(tree.typeargs, localEnv);
2445 
2446             // ... and attribute the method using as a prototype a methodtype
2447             // whose formal argument types is exactly the list of actual
2448             // arguments (this will also set the method symbol).
2449             Type mpt = newMethodTemplate(resultInfo.pt, argtypes, typeargtypes);
2450             localEnv.info.pendingResolutionPhase = null;
2451             Type mtype = attribTree(tree.meth, localEnv, new ResultInfo(kind, mpt, resultInfo.checkContext));
2452 
2453             // Compute the result type.
2454             Type restype = mtype.getReturnType();
2455             if (restype.hasTag(WILDCARD))
2456                 throw new AssertionError(mtype);
2457 
2458             Type qualifier = (tree.meth.hasTag(SELECT))
2459                     ? ((JCFieldAccess) tree.meth).selected.type
2460                     : env.enclClass.sym.type;
2461             Symbol msym = TreeInfo.symbol(tree.meth);
2462             restype = adjustMethodReturnType(msym, qualifier, methName, argtypes, restype);
2463 
2464             chk.checkRefTypes(tree.typeargs, typeargtypes);
2465 
2466             // Check that value of resulting type is admissible in the
2467             // current context.  Also, capture the return type
2468             Type capturedRes = resultInfo.checkContext.inferenceContext().cachedCapture(tree, restype, true);
2469             result = check(tree, capturedRes, KindSelector.VAL, resultInfo);
2470         }
2471         chk.validate(tree.typeargs, localEnv);
2472     }
2473     //where
2474         Type adjustMethodReturnType(Symbol msym, Type qualifierType, Name methodName, List&lt;Type&gt; argtypes, Type restype) {
2475             if (msym != null &amp;&amp;
2476                     msym.owner == syms.objectType.tsym &amp;&amp;
2477                     methodName == names.getClass &amp;&amp;
2478                     argtypes.isEmpty()) {
2479                 // as a special case, x.getClass() has type Class&lt;? extends |X|&gt;
2480                 return new ClassType(restype.getEnclosingType(),
2481                         List.of(new WildcardType(types.erasure(qualifierType),
2482                                 BoundKind.EXTENDS,
2483                                 syms.boundClass)),
2484                         restype.tsym,
2485                         restype.getMetadata());
2486             } else if (msym != null &amp;&amp;
2487                     msym.owner == syms.arrayClass &amp;&amp;
2488                     methodName == names.clone &amp;&amp;
2489                     types.isArray(qualifierType)) {
2490                 // as a special case, array.clone() has a result that is
2491                 // the same as static type of the array being cloned
2492                 return qualifierType;
2493             } else {
2494                 return restype;
2495             }
2496         }
2497 
2498         /** Check that given application node appears as first statement
2499          *  in a constructor call.
2500          *  @param tree          The application node
2501          *  @param enclMethod    The enclosing method of the application.
2502          *  @param error         Should an error be issued?
2503          */
2504         boolean checkFirstConstructorStat(JCMethodInvocation tree, JCMethodDecl enclMethod, boolean error) {
2505             if (enclMethod != null &amp;&amp; enclMethod.name == names.init) {
2506                 JCBlock body = enclMethod.body;
2507                 if (body.stats.head.hasTag(EXEC) &amp;&amp;
2508                     ((JCExpressionStatement) body.stats.head).expr == tree)
2509                     return true;
2510             }
2511             if (error) {
2512                 log.error(tree.pos(),
2513                         Errors.CallMustBeFirstStmtInCtor(TreeInfo.name(tree.meth)));
2514             }
2515             return false;
2516         }
2517 
2518         /** Obtain a method type with given argument types.
2519          */
2520         Type newMethodTemplate(Type restype, List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes) {
2521             MethodType mt = new MethodType(argtypes, restype, List.nil(), syms.methodClass);
2522             return (typeargtypes == null) ? mt : (Type)new ForAll(typeargtypes, mt);
2523         }
2524 
2525     public void visitNewClass(final JCNewClass tree) {
2526         Type owntype = types.createErrorType(tree.type);
2527 
2528         // The local environment of a class creation is
2529         // a new environment nested in the current one.
2530         Env&lt;AttrContext&gt; localEnv = env.dup(tree, env.info.dup());
2531 
2532         // The anonymous inner class definition of the new expression,
2533         // if one is defined by it.
2534         JCClassDecl cdef = tree.def;
2535 
2536         // If enclosing class is given, attribute it, and
2537         // complete class name to be fully qualified
2538         JCExpression clazz = tree.clazz; // Class field following new
2539         JCExpression clazzid;            // Identifier in class field
2540         JCAnnotatedType annoclazzid;     // Annotated type enclosing clazzid
2541         annoclazzid = null;
2542 
2543         if (clazz.hasTag(TYPEAPPLY)) {
2544             clazzid = ((JCTypeApply) clazz).clazz;
2545             if (clazzid.hasTag(ANNOTATED_TYPE)) {
2546                 annoclazzid = (JCAnnotatedType) clazzid;
2547                 clazzid = annoclazzid.underlyingType;
2548             }
2549         } else {
2550             if (clazz.hasTag(ANNOTATED_TYPE)) {
2551                 annoclazzid = (JCAnnotatedType) clazz;
2552                 clazzid = annoclazzid.underlyingType;
2553             } else {
2554                 clazzid = clazz;
2555             }
2556         }
2557 
2558         JCExpression clazzid1 = clazzid; // The same in fully qualified form
2559 
2560         if (tree.encl != null) {
2561             // We are seeing a qualified new, of the form
2562             //    &lt;expr&gt;.new C &lt;...&gt; (...) ...
2563             // In this case, we let clazz stand for the name of the
2564             // allocated class C prefixed with the type of the qualifier
2565             // expression, so that we can
2566             // resolve it with standard techniques later. I.e., if
2567             // &lt;expr&gt; has type T, then &lt;expr&gt;.new C &lt;...&gt; (...)
2568             // yields a clazz T.C.
2569             Type encltype = chk.checkRefType(tree.encl.pos(),
2570                                              attribExpr(tree.encl, env));
2571             // TODO 308: in &lt;expr&gt;.new C, do we also want to add the type annotations
2572             // from expr to the combined type, or not? Yes, do this.
2573             clazzid1 = make.at(clazz.pos).Select(make.Type(encltype),
2574                                                  ((JCIdent) clazzid).name);
2575 
2576             EndPosTable endPosTable = this.env.toplevel.endPositions;
2577             endPosTable.storeEnd(clazzid1, tree.getEndPosition(endPosTable));
2578             if (clazz.hasTag(ANNOTATED_TYPE)) {
2579                 JCAnnotatedType annoType = (JCAnnotatedType) clazz;
2580                 List&lt;JCAnnotation&gt; annos = annoType.annotations;
2581 
2582                 if (annoType.underlyingType.hasTag(TYPEAPPLY)) {
2583                     clazzid1 = make.at(tree.pos).
2584                         TypeApply(clazzid1,
2585                                   ((JCTypeApply) clazz).arguments);
2586                 }
2587 
2588                 clazzid1 = make.at(tree.pos).
2589                     AnnotatedType(annos, clazzid1);
2590             } else if (clazz.hasTag(TYPEAPPLY)) {
2591                 clazzid1 = make.at(tree.pos).
2592                     TypeApply(clazzid1,
2593                               ((JCTypeApply) clazz).arguments);
2594             }
2595 
2596             clazz = clazzid1;
2597         }
2598 
2599         // Attribute clazz expression and store
2600         // symbol + type back into the attributed tree.
2601         Type clazztype;
2602 
2603         try {
2604             env.info.isNewClass = true;
2605             clazztype = TreeInfo.isEnumInit(env.tree) ?
2606                 attribIdentAsEnumType(env, (JCIdent)clazz) :
2607                 attribType(clazz, env);
2608         } finally {
2609             env.info.isNewClass = false;
2610         }
2611 
2612         clazztype = chk.checkDiamond(tree, clazztype);
2613         chk.validate(clazz, localEnv);
2614         if (tree.encl != null) {
2615             // We have to work in this case to store
2616             // symbol + type back into the attributed tree.
2617             tree.clazz.type = clazztype;
2618             TreeInfo.setSymbol(clazzid, TreeInfo.symbol(clazzid1));
2619             clazzid.type = ((JCIdent) clazzid).sym.type;
2620             if (annoclazzid != null) {
2621                 annoclazzid.type = clazzid.type;
2622             }
2623             if (!clazztype.isErroneous()) {
2624                 if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2625                     log.error(tree.encl.pos(), Errors.AnonClassImplIntfNoQualForNew);
2626                 } else if (clazztype.tsym.isStatic()) {
2627                     log.error(tree.encl.pos(), Errors.QualifiedNewOfStaticClass(clazztype.tsym));
2628                 }
2629             }
2630         } else if (!clazztype.tsym.isInterface() &amp;&amp;
2631                    clazztype.getEnclosingType().hasTag(CLASS)) {
2632             // Check for the existence of an apropos outer instance
2633             rs.resolveImplicitThis(tree.pos(), env, clazztype);
2634         }
2635 
2636         // Attribute constructor arguments.
2637         ListBuffer&lt;Type&gt; argtypesBuf = new ListBuffer&lt;&gt;();
2638         final KindSelector pkind =
2639             attribArgs(KindSelector.VAL, tree.args, localEnv, argtypesBuf);
2640         List&lt;Type&gt; argtypes = argtypesBuf.toList();
2641         List&lt;Type&gt; typeargtypes = attribTypes(tree.typeargs, localEnv);
2642 
2643         if (clazztype.hasTag(CLASS) || clazztype.hasTag(ERROR)) {
2644             // Enums may not be instantiated except implicitly
2645             if ((clazztype.tsym.flags_field &amp; Flags.ENUM) != 0 &amp;&amp;
2646                 (!env.tree.hasTag(VARDEF) ||
2647                  (((JCVariableDecl) env.tree).mods.flags &amp; Flags.ENUM) == 0 ||
2648                  ((JCVariableDecl) env.tree).init != tree))
2649                 log.error(tree.pos(), Errors.EnumCantBeInstantiated);
2650 
2651             boolean isSpeculativeDiamondInferenceRound = TreeInfo.isDiamond(tree) &amp;&amp;
2652                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
2653             boolean skipNonDiamondPath = false;
2654             // Check that class is not abstract
2655             if (cdef == null &amp;&amp; !isSpeculativeDiamondInferenceRound &amp;&amp; // class body may be nulled out in speculative tree copy
2656                 (clazztype.tsym.flags() &amp; (ABSTRACT | INTERFACE)) != 0) {
2657                 log.error(tree.pos(),
2658                           Errors.AbstractCantBeInstantiated(clazztype.tsym));
2659                 skipNonDiamondPath = true;
2660             } else if (cdef != null &amp;&amp; clazztype.tsym.isInterface()) {
2661                 // Check that no constructor arguments are given to
2662                 // anonymous classes implementing an interface
2663                 if (!argtypes.isEmpty())
2664                     log.error(tree.args.head.pos(), Errors.AnonClassImplIntfNoArgs);
2665 
2666                 if (!typeargtypes.isEmpty())
2667                     log.error(tree.typeargs.head.pos(), Errors.AnonClassImplIntfNoTypeargs);
2668 
2669                 // Error recovery: pretend no arguments were supplied.
2670                 argtypes = List.nil();
2671                 typeargtypes = List.nil();
2672                 skipNonDiamondPath = true;
2673             }
2674             if (TreeInfo.isDiamond(tree)) {
2675                 ClassType site = new ClassType(clazztype.getEnclosingType(),
2676                             clazztype.tsym.type.getTypeArguments(),
2677                                                clazztype.tsym,
2678                                                clazztype.getMetadata());
2679 
2680                 Env&lt;AttrContext&gt; diamondEnv = localEnv.dup(tree);
2681                 diamondEnv.info.selectSuper = cdef != null || tree.classDeclRemoved();
2682                 diamondEnv.info.pendingResolutionPhase = null;
2683 
2684                 //if the type of the instance creation expression is a class type
2685                 //apply method resolution inference (JLS 15.12.2.7). The return type
2686                 //of the resolved constructor will be a partially instantiated type
2687                 Symbol constructor = rs.resolveDiamond(tree.pos(),
2688                             diamondEnv,
2689                             site,
2690                             argtypes,
2691                             typeargtypes);
2692                 tree.constructor = constructor.baseSymbol();
2693 
2694                 final TypeSymbol csym = clazztype.tsym;
2695                 ResultInfo diamondResult = new ResultInfo(pkind, newMethodTemplate(resultInfo.pt, argtypes, typeargtypes),
2696                         diamondContext(tree, csym, resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
2697                 Type constructorType = tree.constructorType = types.createErrorType(clazztype);
2698                 constructorType = checkId(tree, site,
2699                         constructor,
2700                         diamondEnv,
2701                         diamondResult);
2702 
2703                 tree.clazz.type = types.createErrorType(clazztype);
2704                 if (!constructorType.isErroneous()) {
2705                     tree.clazz.type = clazz.type = constructorType.getReturnType();
2706                     tree.constructorType = types.createMethodTypeWithReturn(constructorType, syms.voidType);
2707                 }
2708                 clazztype = chk.checkClassType(tree.clazz, tree.clazz.type, true);
2709             }
2710 
2711             // Resolve the called constructor under the assumption
2712             // that we are referring to a superclass instance of the
2713             // current instance (JLS ???).
2714             else if (!skipNonDiamondPath) {
2715                 //the following code alters some of the fields in the current
2716                 //AttrContext - hence, the current context must be dup&#39;ed in
2717                 //order to avoid downstream failures
2718                 Env&lt;AttrContext&gt; rsEnv = localEnv.dup(tree);
2719                 rsEnv.info.selectSuper = cdef != null;
2720                 rsEnv.info.pendingResolutionPhase = null;
2721                 tree.constructor = rs.resolveConstructor(
2722                     tree.pos(), rsEnv, clazztype, argtypes, typeargtypes);
2723                 if (cdef == null) { //do not check twice!
2724                     tree.constructorType = checkId(tree,
2725                             clazztype,
2726                             tree.constructor,
2727                             rsEnv,
2728                             new ResultInfo(pkind, newMethodTemplate(syms.voidType, argtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2729                     if (rsEnv.info.lastResolveVarargs())
2730                         Assert.check(tree.constructorType.isErroneous() || tree.varargsElement != null);
2731                 }
2732             }
2733 
2734             if (cdef != null) {
2735                 visitAnonymousClassDefinition(tree, clazz, clazztype, cdef, localEnv, argtypes, typeargtypes, pkind);
2736                 return;
2737             }
2738 
2739             if (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH)
2740                 owntype = clazztype;
2741         }
2742         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2743         InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2744         if (tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType)) {
2745             //we need to wait for inference to finish and then replace inference vars in the constructor type
2746             inferenceContext.addFreeTypeListener(List.of(tree.constructorType),
2747                     instantiatedContext -&gt; {
2748                         tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2749                     });
2750         }
2751         chk.validate(tree.typeargs, localEnv);
2752     }
2753 
2754         // where
2755         private void visitAnonymousClassDefinition(JCNewClass tree, JCExpression clazz, Type clazztype,
2756                                                    JCClassDecl cdef, Env&lt;AttrContext&gt; localEnv,
2757                                                    List&lt;Type&gt; argtypes, List&lt;Type&gt; typeargtypes,
2758                                                    KindSelector pkind) {
2759             // We are seeing an anonymous class instance creation.
2760             // In this case, the class instance creation
2761             // expression
2762             //
2763             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2764             //
2765             // is represented internally as
2766             //
2767             //    E . new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) ( class &lt;empty-name&gt; { ... } )  .
2768             //
2769             // This expression is then *transformed* as follows:
2770             //
2771             // (1) add an extends or implements clause
2772             // (2) add a constructor.
2773             //
2774             // For instance, if C is a class, and ET is the type of E,
2775             // the expression
2776             //
2777             //    E.new &lt;typeargs1&gt;C&lt;typargs2&gt;(args) { ... }
2778             //
2779             // is translated to (where X is a fresh name and typarams is the
2780             // parameter list of the super constructor):
2781             //
2782             //   new &lt;typeargs1&gt;X(&lt;*nullchk*&gt;E, args) where
2783             //     X extends C&lt;typargs2&gt; {
2784             //       &lt;typarams&gt; X(ET e, args) {
2785             //         e.&lt;typeargs1&gt;super(args)
2786             //       }
2787             //       ...
2788             //     }
2789             InferenceContext inferenceContext = resultInfo.checkContext.inferenceContext();
2790             final boolean isDiamond = TreeInfo.isDiamond(tree);
2791             if (isDiamond
2792                     &amp;&amp; ((tree.constructorType != null &amp;&amp; inferenceContext.free(tree.constructorType))
2793                     || (tree.clazz.type != null &amp;&amp; inferenceContext.free(tree.clazz.type)))) {
2794                 final ResultInfo resultInfoForClassDefinition = this.resultInfo;
2795                 inferenceContext.addFreeTypeListener(List.of(tree.constructorType, tree.clazz.type),
2796                         instantiatedContext -&gt; {
2797                             tree.constructorType = instantiatedContext.asInstType(tree.constructorType);
2798                             tree.clazz.type = clazz.type = instantiatedContext.asInstType(clazz.type);
2799                             ResultInfo prevResult = this.resultInfo;
2800                             try {
2801                                 this.resultInfo = resultInfoForClassDefinition;
2802                                 visitAnonymousClassDefinition(tree, clazz, clazz.type, cdef,
2803                                                             localEnv, argtypes, typeargtypes, pkind);
2804                             } finally {
2805                                 this.resultInfo = prevResult;
2806                             }
2807                         });
2808             } else {
2809                 if (isDiamond &amp;&amp; clazztype.hasTag(CLASS)) {
2810                     List&lt;Type&gt; invalidDiamondArgs = chk.checkDiamondDenotable((ClassType)clazztype);
2811                     if (!clazztype.isErroneous() &amp;&amp; invalidDiamondArgs.nonEmpty()) {
2812                         // One or more types inferred in the previous steps is non-denotable.
2813                         Fragment fragment = Diamond(clazztype.tsym);
2814                         log.error(tree.clazz.pos(),
2815                                 Errors.CantApplyDiamond1(
2816                                         fragment,
2817                                         invalidDiamondArgs.size() &gt; 1 ?
2818                                                 DiamondInvalidArgs(invalidDiamondArgs, fragment) :
2819                                                 DiamondInvalidArg(invalidDiamondArgs, fragment)));
2820                     }
2821                     // For &lt;&gt;(){}, inferred types must also be accessible.
2822                     for (Type t : clazztype.getTypeArguments()) {
2823                         rs.checkAccessibleType(env, t);
2824                     }
2825                 }
2826 
2827                 // If we already errored, be careful to avoid a further avalanche. ErrorType answers
2828                 // false for isInterface call even when the original type is an interface.
2829                 boolean implementing = clazztype.tsym.isInterface() ||
2830                         clazztype.isErroneous() &amp;&amp; !clazztype.getOriginalType().hasTag(NONE) &amp;&amp;
2831                         clazztype.getOriginalType().tsym.isInterface();
2832 
2833                 if (implementing) {
2834                     cdef.implementing = List.of(clazz);
2835                 } else {
2836                     cdef.extending = clazz;
2837                 }
2838 
2839                 if (resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
2840                     isSerializable(clazztype)) {
2841                     localEnv.info.isSerializable = true;
2842                 }
2843 
2844                 attribStat(cdef, localEnv);
2845 
2846                 List&lt;Type&gt; finalargtypes;
2847                 // If an outer instance is given,
2848                 // prefix it to the constructor arguments
2849                 // and delete it from the new expression
2850                 if (tree.encl != null &amp;&amp; !clazztype.tsym.isInterface()) {
2851                     finalargtypes = argtypes.prepend(tree.encl.type);
2852                 } else {
2853                     finalargtypes = argtypes;
2854                 }
2855 
2856                 // Reassign clazztype and recompute constructor. As this necessarily involves
2857                 // another attribution pass for deferred types in the case of &lt;&gt;, replicate
2858                 // them. Original arguments have right decorations already.
2859                 if (isDiamond &amp;&amp; pkind.contains(KindSelector.POLY)) {
2860                     finalargtypes = finalargtypes.map(deferredAttr.deferredCopier);
2861                 }
2862 
2863                 clazztype = clazztype.hasTag(ERROR) ? types.createErrorType(cdef.sym.type)
2864                                                     : cdef.sym.type;
2865                 Symbol sym = tree.constructor = rs.resolveConstructor(
2866                         tree.pos(), localEnv, clazztype, finalargtypes, typeargtypes);
2867                 Assert.check(!sym.kind.isResolutionError());
2868                 tree.constructor = sym;
2869                 tree.constructorType = checkId(tree,
2870                         clazztype,
2871                         tree.constructor,
2872                         localEnv,
2873                         new ResultInfo(pkind, newMethodTemplate(syms.voidType, finalargtypes, typeargtypes), CheckMode.NO_TREE_UPDATE));
2874             }
2875             Type owntype = (tree.constructor != null &amp;&amp; tree.constructor.kind == MTH) ?
2876                                 clazztype : types.createErrorType(tree.type);
2877             result = check(tree, owntype, KindSelector.VAL, resultInfo.dup(CheckMode.NO_INFERENCE_HOOK));
2878             chk.validate(tree.typeargs, localEnv);
2879         }
2880 
2881         CheckContext diamondContext(JCNewClass clazz, TypeSymbol tsym, CheckContext checkContext) {
2882             return new Check.NestedCheckContext(checkContext) {
2883                 @Override
2884                 public void report(DiagnosticPosition _unused, JCDiagnostic details) {
2885                     enclosingContext.report(clazz.clazz,
2886                             diags.fragment(Fragments.CantApplyDiamond1(Fragments.Diamond(tsym), details)));
2887                 }
2888             };
2889         }
2890 
2891     /** Make an attributed null check tree.
2892      */
2893     public JCExpression makeNullCheck(JCExpression arg) {
2894         // optimization: new Outer() can never be null; skip null check
2895         if (arg.getTag() == NEWCLASS)
2896             return arg;
2897         // optimization: X.this is never null; skip null check
2898         Name name = TreeInfo.name(arg);
2899         if (name == names._this || name == names._super) return arg;
2900 
2901         JCTree.Tag optag = NULLCHK;
2902         JCUnary tree = make.at(arg.pos).Unary(optag, arg);
2903         tree.operator = operators.resolveUnary(arg, optag, arg.type);
2904         tree.type = arg.type;
2905         return tree;
2906     }
2907 
2908     public void visitNewArray(JCNewArray tree) {
2909         Type owntype = types.createErrorType(tree.type);
2910         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
2911         Type elemtype;
2912         if (tree.elemtype != null) {
2913             elemtype = attribType(tree.elemtype, localEnv);
2914             chk.validate(tree.elemtype, localEnv);
2915             owntype = elemtype;
2916             for (List&lt;JCExpression&gt; l = tree.dims; l.nonEmpty(); l = l.tail) {
2917                 attribExpr(l.head, localEnv, syms.intType);
2918                 owntype = new ArrayType(owntype, syms.arrayClass);
2919             }
2920         } else {
2921             // we are seeing an untyped aggregate { ... }
2922             // this is allowed only if the prototype is an array
2923             if (pt().hasTag(ARRAY)) {
2924                 elemtype = types.elemtype(pt());
2925             } else {
2926                 if (!pt().hasTag(ERROR) &amp;&amp;
2927                         (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2928                     log.error(tree.pos(),
2929                               Errors.IllegalInitializerForType(pt()));
2930                 }
2931                 elemtype = types.createErrorType(pt());
2932             }
2933         }
2934         if (tree.elems != null) {
2935             attribExprs(tree.elems, localEnv, elemtype);
2936             owntype = new ArrayType(elemtype, syms.arrayClass);
2937         }
2938         if (!types.isReifiable(elemtype))
2939             log.error(tree.pos(), Errors.GenericArrayCreation);
2940         result = check(tree, owntype, KindSelector.VAL, resultInfo);
2941     }
2942 
2943     /*
2944      * A lambda expression can only be attributed when a target-type is available.
2945      * In addition, if the target-type is that of a functional interface whose
2946      * descriptor contains inference variables in argument position the lambda expression
2947      * is &#39;stuck&#39; (see DeferredAttr).
2948      */
2949     @Override
2950     public void visitLambda(final JCLambda that) {
2951         boolean wrongContext = false;
2952         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
2953             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
2954                 //lambda only allowed in assignment or method invocation/cast context
2955                 log.error(that.pos(), Errors.UnexpectedLambda);
2956             }
2957             resultInfo = recoveryInfo;
2958             wrongContext = true;
2959         }
2960         //create an environment for attribution of the lambda expression
2961         final Env&lt;AttrContext&gt; localEnv = lambdaEnv(that, env);
2962         boolean needsRecovery =
2963                 resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK;
2964         try {
2965             if (needsRecovery &amp;&amp; isSerializable(pt())) {
2966                 localEnv.info.isSerializable = true;
2967                 localEnv.info.isSerializableLambda = true;
2968             }
2969             localEnv.info.isLambda = true;
2970             List&lt;Type&gt; explicitParamTypes = null;
2971             if (that.paramKind == JCLambda.ParameterKind.EXPLICIT) {
2972                 //attribute lambda parameters
2973                 attribStats(that.params, localEnv);
2974                 explicitParamTypes = TreeInfo.types(that.params);
2975             }
2976 
2977             TargetInfo targetInfo = getTargetInfo(that, resultInfo, explicitParamTypes);
2978             Type currentTarget = targetInfo.target;
2979             Type lambdaType = targetInfo.descriptor;
2980 
2981             if (currentTarget.isErroneous()) {
2982                 result = that.type = currentTarget;
2983                 return;
2984             }
2985 
2986             setFunctionalInfo(localEnv, that, pt(), lambdaType, currentTarget, resultInfo.checkContext);
2987 
2988             if (lambdaType.hasTag(FORALL)) {
2989                 //lambda expression target desc cannot be a generic method
2990                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
2991                                                                     kindName(currentTarget.tsym),
2992                                                                     currentTarget.tsym);
2993                 resultInfo.checkContext.report(that, diags.fragment(msg));
2994                 result = that.type = types.createErrorType(pt());
2995                 return;
2996             }
2997 
2998             if (that.paramKind == JCLambda.ParameterKind.IMPLICIT) {
2999                 //add param type info in the AST
3000                 List&lt;Type&gt; actuals = lambdaType.getParameterTypes();
3001                 List&lt;JCVariableDecl&gt; params = that.params;
3002 
3003                 boolean arityMismatch = false;
3004 
3005                 while (params.nonEmpty()) {
3006                     if (actuals.isEmpty()) {
3007                         //not enough actuals to perform lambda parameter inference
3008                         arityMismatch = true;
3009                     }
3010                     //reset previously set info
3011                     Type argType = arityMismatch ?
3012                             syms.errType :
3013                             actuals.head;
3014                     if (params.head.isImplicitlyTyped()) {
3015                         setSyntheticVariableType(params.head, argType);
3016                     }
3017                     params.head.sym = null;
3018                     actuals = actuals.isEmpty() ?
3019                             actuals :
3020                             actuals.tail;
3021                     params = params.tail;
3022                 }
3023 
3024                 //attribute lambda parameters
3025                 attribStats(that.params, localEnv);
3026 
3027                 if (arityMismatch) {
3028                     resultInfo.checkContext.report(that, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3029                         result = that.type = types.createErrorType(currentTarget);
3030                         return;
3031                 }
3032             }
3033 
3034             //from this point on, no recovery is needed; if we are in assignment context
3035             //we will be able to attribute the whole lambda body, regardless of errors;
3036             //if we are in a &#39;check&#39; method context, and the lambda is not compatible
3037             //with the target-type, it will be recovered anyway in Attr.checkId
3038             needsRecovery = false;
3039 
3040             ResultInfo bodyResultInfo = localEnv.info.returnResult =
3041                     lambdaBodyResult(that, lambdaType, resultInfo);
3042 
3043             if (that.getBodyKind() == JCLambda.BodyKind.EXPRESSION) {
3044                 attribTree(that.getBody(), localEnv, bodyResultInfo);
3045             } else {
3046                 JCBlock body = (JCBlock)that.body;
3047                 if (body == breakTree &amp;&amp;
3048                         resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3049                     breakTreeFound(copyEnv(localEnv));
3050                 }
3051                 attribStats(body.stats, localEnv);
3052             }
3053 
3054             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3055 
3056             boolean isSpeculativeRound =
3057                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3058 
3059             preFlow(that);
3060             flow.analyzeLambda(env, that, make, isSpeculativeRound);
3061 
3062             that.type = currentTarget; //avoids recovery at this stage
3063             checkLambdaCompatible(that, lambdaType, resultInfo.checkContext);
3064 
3065             if (!isSpeculativeRound) {
3066                 //add thrown types as bounds to the thrown types free variables if needed:
3067                 if (resultInfo.checkContext.inferenceContext().free(lambdaType.getThrownTypes())) {
3068                     List&lt;Type&gt; inferredThrownTypes = flow.analyzeLambdaThrownTypes(env, that, make);
3069                     if(!checkExConstraints(inferredThrownTypes, lambdaType.getThrownTypes(), resultInfo.checkContext.inferenceContext())) {
3070                         log.error(that, Errors.IncompatibleThrownTypesInMref(lambdaType.getThrownTypes()));
3071                     }
3072                 }
3073 
3074                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), lambdaType, currentTarget);
3075             }
3076             result = wrongContext ? that.type = types.createErrorType(pt())
3077                                   : check(that, currentTarget, KindSelector.VAL, resultInfo);
3078         } catch (Types.FunctionDescriptorLookupError ex) {
3079             JCDiagnostic cause = ex.getDiagnostic();
3080             resultInfo.checkContext.report(that, cause);
3081             result = that.type = types.createErrorType(pt());
3082             return;
3083         } catch (CompletionFailure cf) {
3084             chk.completionError(that.pos(), cf);
3085         } catch (Throwable t) {
3086             //when an unexpected exception happens, avoid attempts to attribute the same tree again
3087             //as that would likely cause the same exception again.
3088             needsRecovery = false;
3089             throw t;
3090         } finally {
3091             localEnv.info.scope.leave();
3092             if (needsRecovery) {
3093                 attribTree(that, env, recoveryInfo);
3094             }
3095         }
3096     }
3097     //where
3098         class TargetInfo {
3099             Type target;
3100             Type descriptor;
3101 
3102             public TargetInfo(Type target, Type descriptor) {
3103                 this.target = target;
3104                 this.descriptor = descriptor;
3105             }
3106         }
3107 
3108         TargetInfo getTargetInfo(JCPolyExpression that, ResultInfo resultInfo, List&lt;Type&gt; explicitParamTypes) {
3109             Type lambdaType;
3110             Type currentTarget = resultInfo.pt;
3111             if (resultInfo.pt != Type.recoveryType) {
3112                 /* We need to adjust the target. If the target is an
3113                  * intersection type, for example: SAM &amp; I1 &amp; I2 ...
3114                  * the target will be updated to SAM
3115                  */
3116                 currentTarget = targetChecker.visit(currentTarget, that);
3117                 if (!currentTarget.isIntersection()) {
3118                     if (explicitParamTypes != null) {
3119                         currentTarget = infer.instantiateFunctionalInterface(that,
3120                                 currentTarget, explicitParamTypes, resultInfo.checkContext);
3121                     }
3122                     currentTarget = types.removeWildcards(currentTarget);
3123                     lambdaType = types.findDescriptorType(currentTarget);
3124                 } else {
3125                     IntersectionClassType ict = (IntersectionClassType)currentTarget;
3126                     ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
3127                     for (Type bound : ict.getExplicitComponents()) {
3128                         if (explicitParamTypes != null) {
3129                             try {
3130                                 bound = infer.instantiateFunctionalInterface(that,
3131                                         bound, explicitParamTypes, resultInfo.checkContext);
3132                             } catch (FunctionDescriptorLookupError t) {
3133                                 // do nothing
3134                             }
3135                         }
3136                         bound = types.removeWildcards(bound);
3137                         components.add(bound);
3138                     }
3139                     currentTarget = types.makeIntersectionType(components.toList());
3140                     currentTarget.tsym.flags_field |= INTERFACE;
3141                     lambdaType = types.findDescriptorType(currentTarget);
3142                 }
3143 
3144             } else {
3145                 currentTarget = Type.recoveryType;
3146                 lambdaType = fallbackDescriptorType(that);
3147             }
3148             if (that.hasTag(LAMBDA) &amp;&amp; lambdaType.hasTag(FORALL)) {
3149                 //lambda expression target desc cannot be a generic method
3150                 Fragment msg = Fragments.InvalidGenericLambdaTarget(lambdaType,
3151                                                                     kindName(currentTarget.tsym),
3152                                                                     currentTarget.tsym);
3153                 resultInfo.checkContext.report(that, diags.fragment(msg));
3154                 currentTarget = types.createErrorType(pt());
3155             }
3156             return new TargetInfo(currentTarget, lambdaType);
3157         }
3158 
3159         void preFlow(JCLambda tree) {
3160             new PostAttrAnalyzer() {
3161                 @Override
3162                 public void scan(JCTree tree) {
3163                     if (tree == null ||
3164                             (tree.type != null &amp;&amp;
3165                             tree.type == Type.stuckType)) {
3166                         //don&#39;t touch stuck expressions!
3167                         return;
3168                     }
3169                     super.scan(tree);
3170                 }
3171 
3172                 @Override
3173                 public void visitClassDef(JCClassDecl that) {
3174                     // or class declaration trees!
3175                 }
3176 
3177                 public void visitLambda(JCLambda that) {
3178                     // or lambda expressions!
3179                 }
3180             }.scan(tree.body);
3181         }
3182 
3183         Types.MapVisitor&lt;DiagnosticPosition&gt; targetChecker = new Types.MapVisitor&lt;DiagnosticPosition&gt;() {
3184 
3185             @Override
3186             public Type visitClassType(ClassType t, DiagnosticPosition pos) {
3187                 return t.isIntersection() ?
3188                         visitIntersectionClassType((IntersectionClassType)t, pos) : t;
3189             }
3190 
3191             public Type visitIntersectionClassType(IntersectionClassType ict, DiagnosticPosition pos) {
3192                 types.findDescriptorSymbol(makeNotionalInterface(ict, pos));
3193                 return ict;
3194             }
3195 
3196             private TypeSymbol makeNotionalInterface(IntersectionClassType ict, DiagnosticPosition pos) {
3197                 ListBuffer&lt;Type&gt; targs = new ListBuffer&lt;&gt;();
3198                 ListBuffer&lt;Type&gt; supertypes = new ListBuffer&lt;&gt;();
3199                 for (Type i : ict.interfaces_field) {
3200                     if (i.isParameterized()) {
3201                         targs.appendList(i.tsym.type.allparams());
3202                     }
3203                     supertypes.append(i.tsym.type);
3204                 }
3205                 IntersectionClassType notionalIntf = types.makeIntersectionType(supertypes.toList());
3206                 notionalIntf.allparams_field = targs.toList();
3207                 notionalIntf.tsym.flags_field |= INTERFACE;
3208                 return notionalIntf.tsym;
3209             }
3210         };
3211 
3212         private Type fallbackDescriptorType(JCExpression tree) {
3213             switch (tree.getTag()) {
3214                 case LAMBDA:
3215                     JCLambda lambda = (JCLambda)tree;
3216                     List&lt;Type&gt; argtypes = List.nil();
3217                     for (JCVariableDecl param : lambda.params) {
3218                         argtypes = param.vartype != null &amp;&amp; param.vartype.type != null ?
3219                                 argtypes.append(param.vartype.type) :
3220                                 argtypes.append(syms.errType);
3221                     }
3222                     return new MethodType(argtypes, Type.recoveryType,
3223                             List.of(syms.throwableType), syms.methodClass);
3224                 case REFERENCE:
3225                     return new MethodType(List.nil(), Type.recoveryType,
3226                             List.of(syms.throwableType), syms.methodClass);
3227                 default:
3228                     Assert.error(&quot;Cannot get here!&quot;);
3229             }
3230             return null;
3231         }
3232 
3233         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3234                 final InferenceContext inferenceContext, final Type... ts) {
3235             checkAccessibleTypes(pos, env, inferenceContext, List.from(ts));
3236         }
3237 
3238         private void checkAccessibleTypes(final DiagnosticPosition pos, final Env&lt;AttrContext&gt; env,
3239                 final InferenceContext inferenceContext, final List&lt;Type&gt; ts) {
3240             if (inferenceContext.free(ts)) {
3241                 inferenceContext.addFreeTypeListener(ts,
3242                         solvedContext -&gt; checkAccessibleTypes(pos, env, solvedContext, solvedContext.asInstTypes(ts)));
3243             } else {
3244                 for (Type t : ts) {
3245                     rs.checkAccessibleType(env, t);
3246                 }
3247             }
3248         }
3249 
3250         /**
3251          * Lambda/method reference have a special check context that ensures
3252          * that i.e. a lambda return type is compatible with the expected
3253          * type according to both the inherited context and the assignment
3254          * context.
3255          */
3256         class FunctionalReturnContext extends Check.NestedCheckContext {
3257 
3258             FunctionalReturnContext(CheckContext enclosingContext) {
3259                 super(enclosingContext);
3260             }
3261 
3262             @Override
3263             public boolean compatible(Type found, Type req, Warner warn) {
3264                 //return type must be compatible in both current context and assignment context
3265                 return chk.basicHandler.compatible(inferenceContext().asUndetVar(found), inferenceContext().asUndetVar(req), warn);
3266             }
3267 
3268             @Override
3269             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3270                 enclosingContext.report(pos, diags.fragment(Fragments.IncompatibleRetTypeInLambda(details)));
3271             }
3272         }
3273 
3274         class ExpressionLambdaReturnContext extends FunctionalReturnContext {
3275 
3276             JCExpression expr;
3277             boolean expStmtExpected;
3278 
3279             ExpressionLambdaReturnContext(JCExpression expr, CheckContext enclosingContext) {
3280                 super(enclosingContext);
3281                 this.expr = expr;
3282             }
3283 
3284             @Override
3285             public void report(DiagnosticPosition pos, JCDiagnostic details) {
3286                 if (expStmtExpected) {
3287                     enclosingContext.report(pos, diags.fragment(Fragments.StatExprExpected));
3288                 } else {
3289                     super.report(pos, details);
3290                 }
3291             }
3292 
3293             @Override
3294             public boolean compatible(Type found, Type req, Warner warn) {
3295                 //a void return is compatible with an expression statement lambda
3296                 if (req.hasTag(VOID)) {
3297                     expStmtExpected = true;
3298                     return TreeInfo.isExpressionStatement(expr);
3299                 } else {
3300                     return super.compatible(found, req, warn);
3301                 }
3302             }
3303         }
3304 
3305         ResultInfo lambdaBodyResult(JCLambda that, Type descriptor, ResultInfo resultInfo) {
3306             FunctionalReturnContext funcContext = that.getBodyKind() == JCLambda.BodyKind.EXPRESSION ?
3307                     new ExpressionLambdaReturnContext((JCExpression)that.getBody(), resultInfo.checkContext) :
3308                     new FunctionalReturnContext(resultInfo.checkContext);
3309 
3310             return descriptor.getReturnType() == Type.recoveryType ?
3311                     recoveryInfo :
3312                     new ResultInfo(KindSelector.VAL,
3313                             descriptor.getReturnType(), funcContext);
3314         }
3315 
3316         /**
3317         * Lambda compatibility. Check that given return types, thrown types, parameter types
3318         * are compatible with the expected functional interface descriptor. This means that:
3319         * (i) parameter types must be identical to those of the target descriptor; (ii) return
3320         * types must be compatible with the return type of the expected descriptor.
3321         */
3322         void checkLambdaCompatible(JCLambda tree, Type descriptor, CheckContext checkContext) {
3323             Type returnType = checkContext.inferenceContext().asUndetVar(descriptor.getReturnType());
3324 
3325             //return values have already been checked - but if lambda has no return
3326             //values, we must ensure that void/value compatibility is correct;
3327             //this amounts at checking that, if a lambda body can complete normally,
3328             //the descriptor&#39;s return type must be void
3329             if (tree.getBodyKind() == JCLambda.BodyKind.STATEMENT &amp;&amp; tree.canCompleteNormally &amp;&amp;
3330                     !returnType.hasTag(VOID) &amp;&amp; returnType != Type.recoveryType) {
3331                 Fragment msg =
3332                         Fragments.IncompatibleRetTypeInLambda(Fragments.MissingRetVal(returnType));
3333                 checkContext.report(tree,
3334                                     diags.fragment(msg));
3335             }
3336 
3337             List&lt;Type&gt; argTypes = checkContext.inferenceContext().asUndetVars(descriptor.getParameterTypes());
3338             if (!types.isSameTypes(argTypes, TreeInfo.types(tree.params))) {
3339                 checkContext.report(tree, diags.fragment(Fragments.IncompatibleArgTypesInLambda));
3340             }
3341         }
3342 
3343         /* Map to hold &#39;fake&#39; clinit methods. If a lambda is used to initialize a
3344          * static field and that lambda has type annotations, these annotations will
3345          * also be stored at these fake clinit methods.
3346          *
3347          * LambdaToMethod also use fake clinit methods so they can be reused.
3348          * Also as LTM is a phase subsequent to attribution, the methods from
3349          * clinits can be safely removed by LTM to save memory.
3350          */
3351         private Map&lt;ClassSymbol, MethodSymbol&gt; clinits = new HashMap&lt;&gt;();
3352 
3353         public MethodSymbol removeClinit(ClassSymbol sym) {
3354             return clinits.remove(sym);
3355         }
3356 
3357         /* This method returns an environment to be used to attribute a lambda
3358          * expression.
3359          *
3360          * The owner of this environment is a method symbol. If the current owner
3361          * is not a method, for example if the lambda is used to initialize
3362          * a field, then if the field is:
3363          *
3364          * - an instance field, we use the first constructor.
3365          * - a static field, we create a fake clinit method.
3366          */
3367         public Env&lt;AttrContext&gt; lambdaEnv(JCLambda that, Env&lt;AttrContext&gt; env) {
3368             Env&lt;AttrContext&gt; lambdaEnv;
3369             Symbol owner = env.info.scope.owner;
3370             if (owner.kind == VAR &amp;&amp; owner.owner.kind == TYP) {
3371                 //field initializer
3372                 ClassSymbol enclClass = owner.enclClass();
3373                 Symbol newScopeOwner = env.info.scope.owner;
3374                 /* if the field isn&#39;t static, then we can get the first constructor
3375                  * and use it as the owner of the environment. This is what
3376                  * LTM code is doing to look for type annotations so we are fine.
3377                  */
3378                 if ((owner.flags() &amp; STATIC) == 0) {
3379                     for (Symbol s : enclClass.members_field.getSymbolsByName(names.init)) {
3380                         newScopeOwner = s;
3381                         break;
3382                     }
3383                 } else {
3384                     /* if the field is static then we need to create a fake clinit
3385                      * method, this method can later be reused by LTM.
3386                      */
3387                     MethodSymbol clinit = clinits.get(enclClass);
3388                     if (clinit == null) {
3389                         Type clinitType = new MethodType(List.nil(),
3390                                 syms.voidType, List.nil(), syms.methodClass);
3391                         clinit = new MethodSymbol(STATIC | SYNTHETIC | PRIVATE,
3392                                 names.clinit, clinitType, enclClass);
3393                         clinit.params = List.nil();
3394                         clinits.put(enclClass, clinit);
3395                     }
3396                     newScopeOwner = clinit;
3397                 }
3398                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dupUnshared(newScopeOwner)));
3399             } else {
3400                 lambdaEnv = env.dup(that, env.info.dup(env.info.scope.dup()));
3401             }
3402             lambdaEnv.info.yieldResult = null;
3403             return lambdaEnv;
3404         }
3405 
3406     @Override
3407     public void visitReference(final JCMemberReference that) {
3408         if (pt().isErroneous() || (pt().hasTag(NONE) &amp;&amp; pt() != Type.recoveryType)) {
3409             if (pt().hasTag(NONE) &amp;&amp; (env.info.enclVar == null || !env.info.enclVar.type.isErroneous())) {
3410                 //method reference only allowed in assignment or method invocation/cast context
3411                 log.error(that.pos(), Errors.UnexpectedMref);
3412             }
3413             result = that.type = types.createErrorType(pt());
3414             return;
3415         }
3416         final Env&lt;AttrContext&gt; localEnv = env.dup(that);
3417         try {
3418             //attribute member reference qualifier - if this is a constructor
3419             //reference, the expected kind must be a type
3420             Type exprType = attribTree(that.expr, env, memberReferenceQualifierResult(that));
3421 
3422             if (that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3423                 exprType = chk.checkConstructorRefType(that.expr, exprType);
3424                 if (!exprType.isErroneous() &amp;&amp;
3425                     exprType.isRaw() &amp;&amp;
3426                     that.typeargs != null) {
3427                     log.error(that.expr.pos(),
3428                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3429                                                  Fragments.MrefInferAndExplicitParams));
3430                     exprType = types.createErrorType(exprType);
3431                 }
3432             }
3433 
3434             if (exprType.isErroneous()) {
3435                 //if the qualifier expression contains problems,
3436                 //give up attribution of method reference
3437                 result = that.type = exprType;
3438                 return;
3439             }
3440 
3441             if (TreeInfo.isStaticSelector(that.expr, names)) {
3442                 //if the qualifier is a type, validate it; raw warning check is
3443                 //omitted as we don&#39;t know at this stage as to whether this is a
3444                 //raw selector (because of inference)
3445                 chk.validate(that.expr, env, false);
3446             } else {
3447                 Symbol lhsSym = TreeInfo.symbol(that.expr);
3448                 localEnv.info.selectSuper = lhsSym != null &amp;&amp; lhsSym.name == names._super;
3449             }
3450             //attrib type-arguments
3451             List&lt;Type&gt; typeargtypes = List.nil();
3452             if (that.typeargs != null) {
3453                 typeargtypes = attribTypes(that.typeargs, localEnv);
3454             }
3455 
3456             boolean isTargetSerializable =
3457                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3458                     isSerializable(pt());
3459             TargetInfo targetInfo = getTargetInfo(that, resultInfo, null);
3460             Type currentTarget = targetInfo.target;
3461             Type desc = targetInfo.descriptor;
3462 
3463             setFunctionalInfo(localEnv, that, pt(), desc, currentTarget, resultInfo.checkContext);
3464             List&lt;Type&gt; argtypes = desc.getParameterTypes();
3465             Resolve.MethodCheck referenceCheck = rs.resolveMethodCheck;
3466 
3467             if (resultInfo.checkContext.inferenceContext().free(argtypes)) {
3468                 referenceCheck = rs.new MethodReferenceCheck(resultInfo.checkContext.inferenceContext());
3469             }
3470 
3471             Pair&lt;Symbol, Resolve.ReferenceLookupHelper&gt; refResult = null;
3472             List&lt;Type&gt; saved_undet = resultInfo.checkContext.inferenceContext().save();
3473             try {
3474                 refResult = rs.resolveMemberReference(localEnv, that, that.expr.type,
3475                         that.name, argtypes, typeargtypes, targetInfo.descriptor, referenceCheck,
3476                         resultInfo.checkContext.inferenceContext(), rs.basicReferenceChooser);
3477             } finally {
3478                 resultInfo.checkContext.inferenceContext().rollback(saved_undet);
3479             }
3480 
3481             Symbol refSym = refResult.fst;
3482             Resolve.ReferenceLookupHelper lookupHelper = refResult.snd;
3483 
3484             /** this switch will need to go away and be replaced by the new RESOLUTION_TARGET testing
3485              *  JDK-8075541
3486              */
3487             if (refSym.kind != MTH) {
3488                 boolean targetError;
3489                 switch (refSym.kind) {
3490                     case ABSENT_MTH:
3491                     case MISSING_ENCL:
3492                         targetError = false;
3493                         break;
3494                     case WRONG_MTH:
3495                     case WRONG_MTHS:
3496                     case AMBIGUOUS:
3497                     case HIDDEN:
3498                     case STATICERR:
3499                         targetError = true;
3500                         break;
3501                     default:
3502                         Assert.error(&quot;unexpected result kind &quot; + refSym.kind);
3503                         targetError = false;
3504                 }
3505 
3506                 JCDiagnostic detailsDiag = ((Resolve.ResolveError)refSym.baseSymbol())
3507                         .getDiagnostic(JCDiagnostic.DiagnosticType.FRAGMENT,
3508                                 that, exprType.tsym, exprType, that.name, argtypes, typeargtypes);
3509 
3510                 JCDiagnostic diag = diags.create(log.currentSource(), that,
3511                         targetError ?
3512                             Fragments.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag) :
3513                             Errors.InvalidMref(Kinds.kindName(that.getMode()), detailsDiag));
3514 
3515                 if (targetError &amp;&amp; currentTarget == Type.recoveryType) {
3516                     //a target error doesn&#39;t make sense during recovery stage
3517                     //as we don&#39;t know what actual parameter types are
3518                     result = that.type = currentTarget;
3519                     return;
3520                 } else {
3521                     if (targetError) {
3522                         resultInfo.checkContext.report(that, diag);
3523                     } else {
3524                         log.report(diag);
3525                     }
3526                     result = that.type = types.createErrorType(currentTarget);
3527                     return;
3528                 }
3529             }
3530 
3531             that.sym = refSym.isConstructor() ? refSym.baseSymbol() : refSym;
3532             that.kind = lookupHelper.referenceKind(that.sym);
3533             that.ownerAccessible = rs.isAccessible(localEnv, that.sym.enclClass());
3534 
3535             if (desc.getReturnType() == Type.recoveryType) {
3536                 // stop here
3537                 result = that.type = currentTarget;
3538                 return;
3539             }
3540 
3541             if (!env.info.attributionMode.isSpeculative &amp;&amp; that.getMode() == JCMemberReference.ReferenceMode.NEW) {
3542                 Type enclosingType = exprType.getEnclosingType();
3543                 if (enclosingType != null &amp;&amp; enclosingType.hasTag(CLASS)) {
3544                     // Check for the existence of an appropriate outer instance
3545                     rs.resolveImplicitThis(that.pos(), env, exprType);
3546                 }
3547             }
3548 
3549             if (resultInfo.checkContext.deferredAttrContext().mode == AttrMode.CHECK) {
3550 
3551                 if (that.getMode() == ReferenceMode.INVOKE &amp;&amp;
3552                         TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3553                         that.kind.isUnbound() &amp;&amp;
3554                         lookupHelper.site.isRaw()) {
3555                     chk.checkRaw(that.expr, localEnv);
3556                 }
3557 
3558                 if (that.sym.isStatic() &amp;&amp; TreeInfo.isStaticSelector(that.expr, names) &amp;&amp;
3559                         exprType.getTypeArguments().nonEmpty()) {
3560                     //static ref with class type-args
3561                     log.error(that.expr.pos(),
3562                               Errors.InvalidMref(Kinds.kindName(that.getMode()),
3563                                                  Fragments.StaticMrefWithTargs));
3564                     result = that.type = types.createErrorType(currentTarget);
3565                     return;
3566                 }
3567 
3568                 if (!refSym.isStatic() &amp;&amp; that.kind == JCMemberReference.ReferenceKind.SUPER) {
3569                     // Check that super-qualified symbols are not abstract (JLS)
3570                     rs.checkNonAbstract(that.pos(), that.sym);
3571                 }
3572 
3573                 if (isTargetSerializable) {
3574                     chk.checkAccessFromSerializableElement(that, true);
3575                 }
3576             }
3577 
3578             ResultInfo checkInfo =
3579                     resultInfo.dup(newMethodTemplate(
3580                         desc.getReturnType().hasTag(VOID) ? Type.noType : desc.getReturnType(),
3581                         that.kind.isUnbound() ? argtypes.tail : argtypes, typeargtypes),
3582                         new FunctionalReturnContext(resultInfo.checkContext), CheckMode.NO_TREE_UPDATE);
3583 
3584             Type refType = checkId(that, lookupHelper.site, refSym, localEnv, checkInfo);
3585 
3586             if (that.kind.isUnbound() &amp;&amp;
3587                     resultInfo.checkContext.inferenceContext().free(argtypes.head)) {
3588                 //re-generate inference constraints for unbound receiver
3589                 if (!types.isSubtype(resultInfo.checkContext.inferenceContext().asUndetVar(argtypes.head), exprType)) {
3590                     //cannot happen as this has already been checked - we just need
3591                     //to regenerate the inference constraints, as that has been lost
3592                     //as a result of the call to inferenceContext.save()
3593                     Assert.error(&quot;Can&#39;t get here&quot;);
3594                 }
3595             }
3596 
3597             if (!refType.isErroneous()) {
3598                 refType = types.createMethodTypeWithReturn(refType,
3599                         adjustMethodReturnType(refSym, lookupHelper.site, that.name, checkInfo.pt.getParameterTypes(), refType.getReturnType()));
3600             }
3601 
3602             //go ahead with standard method reference compatibility check - note that param check
3603             //is a no-op (as this has been taken care during method applicability)
3604             boolean isSpeculativeRound =
3605                     resultInfo.checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.SPECULATIVE;
3606 
3607             that.type = currentTarget; //avoids recovery at this stage
3608             checkReferenceCompatible(that, desc, refType, resultInfo.checkContext, isSpeculativeRound);
3609             if (!isSpeculativeRound) {
3610                 checkAccessibleTypes(that, localEnv, resultInfo.checkContext.inferenceContext(), desc, currentTarget);
3611             }
3612             result = check(that, currentTarget, KindSelector.VAL, resultInfo);
3613         } catch (Types.FunctionDescriptorLookupError ex) {
3614             JCDiagnostic cause = ex.getDiagnostic();
3615             resultInfo.checkContext.report(that, cause);
3616             result = that.type = types.createErrorType(pt());
3617             return;
3618         }
3619     }
3620     //where
3621         ResultInfo memberReferenceQualifierResult(JCMemberReference tree) {
3622             //if this is a constructor reference, the expected kind must be a type
3623             return new ResultInfo(tree.getMode() == ReferenceMode.INVOKE ?
3624                                   KindSelector.VAL_TYP : KindSelector.TYP,
3625                                   Type.noType);
3626         }
3627 
3628 
3629     @SuppressWarnings(&quot;fallthrough&quot;)
3630     void checkReferenceCompatible(JCMemberReference tree, Type descriptor, Type refType, CheckContext checkContext, boolean speculativeAttr) {
3631         InferenceContext inferenceContext = checkContext.inferenceContext();
3632         Type returnType = inferenceContext.asUndetVar(descriptor.getReturnType());
3633 
3634         Type resType;
3635         switch (tree.getMode()) {
3636             case NEW:
3637                 if (!tree.expr.type.isRaw()) {
3638                     resType = tree.expr.type;
3639                     break;
3640                 }
3641             default:
3642                 resType = refType.getReturnType();
3643         }
3644 
3645         Type incompatibleReturnType = resType;
3646 
3647         if (returnType.hasTag(VOID)) {
3648             incompatibleReturnType = null;
3649         }
3650 
3651         if (!returnType.hasTag(VOID) &amp;&amp; !resType.hasTag(VOID)) {
3652             if (resType.isErroneous() ||
3653                     new FunctionalReturnContext(checkContext).compatible(resType, returnType,
3654                             checkContext.checkWarner(tree, resType, returnType))) {
3655                 incompatibleReturnType = null;
3656             }
3657         }
3658 
3659         if (incompatibleReturnType != null) {
3660             Fragment msg =
3661                     Fragments.IncompatibleRetTypeInMref(Fragments.InconvertibleTypes(resType, descriptor.getReturnType()));
3662             checkContext.report(tree, diags.fragment(msg));
3663         } else {
3664             if (inferenceContext.free(refType)) {
3665                 // we need to wait for inference to finish and then replace inference vars in the referent type
3666                 inferenceContext.addFreeTypeListener(List.of(refType),
3667                         instantiatedContext -&gt; {
3668                             tree.referentType = instantiatedContext.asInstType(refType);
3669                         });
3670             } else {
3671                 tree.referentType = refType;
3672             }
3673         }
3674 
3675         if (!speculativeAttr) {
3676             if (!checkExConstraints(refType.getThrownTypes(), descriptor.getThrownTypes(), inferenceContext)) {
3677                 log.error(tree, Errors.IncompatibleThrownTypesInMref(refType.getThrownTypes()));
3678             }
3679         }
3680     }
3681 
3682     boolean checkExConstraints(
3683             List&lt;Type&gt; thrownByFuncExpr,
3684             List&lt;Type&gt; thrownAtFuncType,
3685             InferenceContext inferenceContext) {
3686         /** 18.2.5: Otherwise, let E1, ..., En be the types in the function type&#39;s throws clause that
3687          *  are not proper types
3688          */
3689         List&lt;Type&gt; nonProperList = thrownAtFuncType.stream()
3690                 .filter(e -&gt; inferenceContext.free(e)).collect(List.collector());
3691         List&lt;Type&gt; properList = thrownAtFuncType.diff(nonProperList);
3692 
3693         /** Let X1,...,Xm be the checked exception types that the lambda body can throw or
3694          *  in the throws clause of the invocation type of the method reference&#39;s compile-time
3695          *  declaration
3696          */
3697         List&lt;Type&gt; checkedList = thrownByFuncExpr.stream()
3698                 .filter(e -&gt; chk.isChecked(e)).collect(List.collector());
3699 
3700         /** If n = 0 (the function type&#39;s throws clause consists only of proper types), then
3701          *  if there exists some i (1 &lt;= i &lt;= m) such that Xi is not a subtype of any proper type
3702          *  in the throws clause, the constraint reduces to false; otherwise, the constraint
3703          *  reduces to true
3704          */
3705         ListBuffer&lt;Type&gt; uncaughtByProperTypes = new ListBuffer&lt;&gt;();
3706         for (Type checked : checkedList) {
3707             boolean isSubtype = false;
3708             for (Type proper : properList) {
3709                 if (types.isSubtype(checked, proper)) {
3710                     isSubtype = true;
3711                     break;
3712                 }
3713             }
3714             if (!isSubtype) {
3715                 uncaughtByProperTypes.add(checked);
3716             }
3717         }
3718 
3719         if (nonProperList.isEmpty() &amp;&amp; !uncaughtByProperTypes.isEmpty()) {
3720             return false;
3721         }
3722 
3723         /** If n &gt; 0, the constraint reduces to a set of subtyping constraints:
3724          *  for all i (1 &lt;= i &lt;= m), if Xi is not a subtype of any proper type in the
3725          *  throws clause, then the constraints include, for all j (1 &lt;= j &lt;= n), &lt;Xi &lt;: Ej&gt;
3726          */
3727         List&lt;Type&gt; nonProperAsUndet = inferenceContext.asUndetVars(nonProperList);
3728         uncaughtByProperTypes.forEach(checkedEx -&gt; {
3729             nonProperAsUndet.forEach(nonProper -&gt; {
3730                 types.isSubtype(checkedEx, nonProper);
3731             });
3732         });
3733 
3734         /** In addition, for all j (1 &lt;= j &lt;= n), the constraint reduces to the bound throws Ej
3735          */
3736         nonProperAsUndet.stream()
3737                 .filter(t -&gt; t.hasTag(UNDETVAR))
3738                 .forEach(t -&gt; ((UndetVar)t).setThrow());
3739         return true;
3740     }
3741 
3742     /**
3743      * Set functional type info on the underlying AST. Note: as the target descriptor
3744      * might contain inference variables, we might need to register an hook in the
3745      * current inference context.
3746      */
3747     private void setFunctionalInfo(final Env&lt;AttrContext&gt; env, final JCFunctionalExpression fExpr,
3748             final Type pt, final Type descriptorType, final Type primaryTarget, final CheckContext checkContext) {
3749         if (checkContext.inferenceContext().free(descriptorType)) {
3750             checkContext.inferenceContext().addFreeTypeListener(List.of(pt, descriptorType),
3751                     inferenceContext -&gt; setFunctionalInfo(env, fExpr, pt, inferenceContext.asInstType(descriptorType),
3752                     inferenceContext.asInstType(primaryTarget), checkContext));
3753         } else {
3754             if (pt.hasTag(CLASS)) {
3755                 fExpr.target = primaryTarget;
3756             }
3757             if (checkContext.deferredAttrContext().mode == DeferredAttr.AttrMode.CHECK &amp;&amp;
3758                     pt != Type.recoveryType) {
3759                 //check that functional interface class is well-formed
3760                 try {
3761                     /* Types.makeFunctionalInterfaceClass() may throw an exception
3762                      * when it&#39;s executed post-inference. See the listener code
3763                      * above.
3764                      */
3765                     ClassSymbol csym = types.makeFunctionalInterfaceClass(env,
3766                             names.empty, fExpr.target, ABSTRACT);
3767                     if (csym != null) {
3768                         chk.checkImplementations(env.tree, csym, csym);
3769                         try {
3770                             //perform an additional functional interface check on the synthetic class,
3771                             //as there may be spurious errors for raw targets - because of existing issues
3772                             //with membership and inheritance (see JDK-8074570).
3773                             csym.flags_field |= INTERFACE;
3774                             types.findDescriptorType(csym.type);
3775                         } catch (FunctionDescriptorLookupError err) {
3776                             resultInfo.checkContext.report(fExpr,
3777                                     diags.fragment(Fragments.NoSuitableFunctionalIntfInst(fExpr.target)));
3778                         }
3779                     }
3780                 } catch (Types.FunctionDescriptorLookupError ex) {
3781                     JCDiagnostic cause = ex.getDiagnostic();
3782                     resultInfo.checkContext.report(env.tree, cause);
3783                 }
3784             }
3785         }
3786     }
3787 
3788     public void visitParens(JCParens tree) {
3789         Type owntype = attribTree(tree.expr, env, resultInfo);
3790         result = check(tree, owntype, pkind(), resultInfo);
3791         Symbol sym = TreeInfo.symbol(tree);
3792         if (sym != null &amp;&amp; sym.kind.matches(KindSelector.TYP_PCK))
3793             log.error(tree.pos(), Errors.IllegalParenthesizedExpression);
3794     }
3795 
3796     public void visitAssign(JCAssign tree) {
3797         Type owntype = attribTree(tree.lhs, env.dup(tree), varAssignmentInfo);
3798         Type capturedType = capture(owntype);
3799         attribExpr(tree.rhs, env, owntype);
3800         result = check(tree, capturedType, KindSelector.VAL, resultInfo);
3801     }
3802 
3803     public void visitAssignop(JCAssignOp tree) {
3804         // Attribute arguments.
3805         Type owntype = attribTree(tree.lhs, env, varAssignmentInfo);
3806         Type operand = attribExpr(tree.rhs, env);
3807         // Find operator.
3808         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), owntype, operand);
3809         if (operator != operators.noOpSymbol &amp;&amp;
3810                 !owntype.isErroneous() &amp;&amp;
3811                 !operand.isErroneous()) {
3812             chk.checkDivZero(tree.rhs.pos(), operator, operand);
3813             chk.checkCastable(tree.rhs.pos(),
3814                               operator.type.getReturnType(),
3815                               owntype);
3816         }
3817         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3818     }
3819 
3820     public void visitUnary(JCUnary tree) {
3821         // Attribute arguments.
3822         Type argtype = (tree.getTag().isIncOrDecUnaryOp())
3823             ? attribTree(tree.arg, env, varAssignmentInfo)
3824             : chk.checkNonVoid(tree.arg.pos(), attribExpr(tree.arg, env));
3825 
3826         // Find operator.
3827         Symbol operator = tree.operator = operators.resolveUnary(tree, tree.getTag(), argtype);
3828         Type owntype = types.createErrorType(tree.type);
3829         if (operator != operators.noOpSymbol &amp;&amp;
3830                 !argtype.isErroneous()) {
3831             owntype = (tree.getTag().isIncOrDecUnaryOp())
3832                 ? tree.arg.type
3833                 : operator.type.getReturnType();
3834             int opc = ((OperatorSymbol)operator).opcode;
3835 
3836             // If the argument is constant, fold it.
3837             if (argtype.constValue() != null) {
3838                 Type ctype = cfolder.fold1(opc, argtype);
3839                 if (ctype != null) {
3840                     owntype = cfolder.coerce(ctype, owntype);
3841                 }
3842             }
3843         }
3844         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3845         matchBindings = matchBindingsComputer.unary(tree, matchBindings);
3846     }
3847 
3848     public void visitBinary(JCBinary tree) {
3849         // Attribute arguments.
3850         Type left = chk.checkNonVoid(tree.lhs.pos(), attribExpr(tree.lhs, env));
3851         // x &amp;&amp; y
3852         // include x&#39;s bindings when true in y
3853 
3854         // x || y
3855         // include x&#39;s bindings when false in y
3856 
3857         MatchBindings lhsBindings = matchBindings;
3858         List&lt;BindingSymbol&gt; propagatedBindings;
3859         switch (tree.getTag()) {
3860             case AND:
3861                 propagatedBindings = lhsBindings.bindingsWhenTrue;
3862                 break;
3863             case OR:
3864                 propagatedBindings = lhsBindings.bindingsWhenFalse;
3865                 break;
3866             default:
3867                 propagatedBindings = List.nil();
3868                 break;
3869         }
3870         Env&lt;AttrContext&gt; rhsEnv = bindingEnv(env, propagatedBindings);
3871         Type right;
3872         try {
3873             right = chk.checkNonVoid(tree.rhs.pos(), attribExpr(tree.rhs, rhsEnv));
3874         } finally {
3875             rhsEnv.info.scope.leave();
3876         }
3877 
3878         matchBindings = matchBindingsComputer.binary(tree, lhsBindings, matchBindings);
3879 
3880         // Find operator.
3881         Symbol operator = tree.operator = operators.resolveBinary(tree, tree.getTag(), left, right);
3882         Type owntype = types.createErrorType(tree.type);
3883         if (operator != operators.noOpSymbol &amp;&amp;
3884                 !left.isErroneous() &amp;&amp;
3885                 !right.isErroneous()) {
3886             owntype = operator.type.getReturnType();
3887             int opc = ((OperatorSymbol)operator).opcode;
3888             // If both arguments are constants, fold them.
3889             if (left.constValue() != null &amp;&amp; right.constValue() != null) {
3890                 Type ctype = cfolder.fold2(opc, left, right);
3891                 if (ctype != null) {
3892                     owntype = cfolder.coerce(ctype, owntype);
3893                 }
3894             }
3895 
3896             // Check that argument types of a reference ==, != are
3897             // castable to each other, (JLS 15.21).  Note: unboxing
3898             // comparisons will not have an acmp* opc at this point.
3899             if ((opc == ByteCodes.if_acmpeq || opc == ByteCodes.if_acmpne)) {
3900                 if (!types.isCastable(left, right, new Warner(tree.pos()))) {
3901                     log.error(tree.pos(), Errors.IncomparableTypes(left, right));
3902                 }
3903             }
3904 
3905             chk.checkDivZero(tree.rhs.pos(), operator, right);
3906         }
3907         result = check(tree, owntype, KindSelector.VAL, resultInfo);
3908     }
3909 
3910     public void visitTypeCast(final JCTypeCast tree) {
3911         Type clazztype = attribType(tree.clazz, env);
3912         chk.validate(tree.clazz, env, false);
3913         //a fresh environment is required for 292 inference to work properly ---
3914         //see Infer.instantiatePolymorphicSignatureInstance()
3915         Env&lt;AttrContext&gt; localEnv = env.dup(tree);
3916         //should we propagate the target type?
3917         final ResultInfo castInfo;
3918         JCExpression expr = TreeInfo.skipParens(tree.expr);
3919         boolean isPoly = allowPoly &amp;&amp; (expr.hasTag(LAMBDA) || expr.hasTag(REFERENCE));
3920         if (isPoly) {
3921             //expression is a poly - we need to propagate target type info
3922             castInfo = castInfo(clazztype);
3923         } else {
3924             //standalone cast - target-type info is not propagated
3925             castInfo = unknownExprInfo;
3926         }
3927         Type exprtype = attribTree(tree.expr, localEnv, castInfo);
3928         Type owntype = isPoly ? clazztype : chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3929         if (exprtype.constValue() != null)
3930             owntype = cfolder.coerce(exprtype, owntype);
3931         result = check(tree, capture(owntype), KindSelector.VAL, resultInfo);
3932         if (!isPoly)
3933             chk.checkRedundantCast(localEnv, tree);
3934     }
3935 
3936     public void visitTypeTest(JCInstanceOf tree) {
3937         Type exprtype = chk.checkNullOrRefType(
3938                 tree.expr.pos(), attribExpr(tree.expr, env));
3939         Type clazztype;
3940         JCTree typeTree;
3941         if (tree.pattern.getTag() == BINDINGPATTERN) {
3942             attribTree(tree.pattern, env, unknownExprInfo);
3943             clazztype = tree.pattern.type;
3944             JCBindingPattern pattern = (JCBindingPattern) tree.pattern;
3945             typeTree = pattern.vartype;
3946             if (!clazztype.hasTag(TYPEVAR)) {
3947                 clazztype = chk.checkClassOrArrayType(pattern.vartype.pos(), clazztype);
3948             }
3949         } else {
3950             clazztype = attribType(tree.pattern, env);
3951             typeTree = tree.pattern;
3952         }
3953         if (!clazztype.hasTag(TYPEVAR)) {
3954             clazztype = chk.checkClassOrArrayType(typeTree.pos(), clazztype);
3955         }
3956         if (!clazztype.isErroneous() &amp;&amp; !types.isReifiable(clazztype)) {
3957             boolean valid = false;
3958             if (allowReifiableTypesInInstanceof) {
3959                 if (preview.isPreview(Feature.REIFIABLE_TYPES_INSTANCEOF)) {
3960                     preview.warnPreview(tree.expr.pos(), Feature.REIFIABLE_TYPES_INSTANCEOF);
3961                 }
3962                 valid = verifyCastable(tree.expr.pos(), exprtype, clazztype);
3963             } else {
3964                 log.error(typeTree.pos(), Errors.IllegalGenericTypeForInstof);
3965             }
3966             if (!valid) {
3967                 clazztype = types.createErrorType(clazztype);
3968             }
3969         }
3970         chk.validate(typeTree, env, false);
3971         chk.checkCastable(tree.expr.pos(), exprtype, clazztype);
3972         result = check(tree, syms.booleanType, KindSelector.VAL, resultInfo);
3973     }
3974 
3975     @Override
3976     public void visitAnyPattern(JCAnyPattern tree) {
3977         tree.type = resultInfo.pt;
3978         result = tree.type;
3979     }
3980 
3981     public void visitBindingPattern(JCBindingPattern tree) {
3982         if (tree.vartype != null) {
3983             ResultInfo varInfo = new ResultInfo(KindSelector.TYP, resultInfo.pt, resultInfo.checkContext);
3984             tree.type = attribTree(tree.vartype, env, varInfo);
3985         } else {
3986             tree.type = resultInfo.pt;
3987         }
3988         VarSymbol v = tree.symbol = new BindingSymbol(tree.name, tree.vartype != null ? tree.vartype.type : (tree.type.hasTag(BOT) ? syms.objectType : tree.type), env.info.scope.owner);
3989         if (chk.checkUnique(tree.pos(), v, env.info.scope)) {
3990             chk.checkTransparentVar(tree.pos(), v, env.info.scope);
3991         }
3992         if (tree.vartype != null) {
3993             annotate.queueScanTreeAndTypeAnnotate(tree.vartype, env, v, tree.pos());
3994             annotate.flush();
3995         }
3996         result = tree.type;
3997         matchBindings = new MatchBindings(List.of(tree.symbol), List.nil());
3998     }
3999 
4000     @Override
4001     public void visitDeconstructionPattern(JCDeconstructionPattern tree) {
4002         Type site = tree.type = attribType(tree.deconstructor, env);
4003         ListBuffer&lt;Type&gt; components = new ListBuffer&lt;&gt;();
4004         Map&lt;JCPattern, MatchBindings&gt; nestedBindings = new HashMap&lt;&gt;();
4005         for (JCPattern n : tree.nested) {
4006             if ((n.hasTag(BINDINGPATTERN) &amp;&amp; ((JCBindingPattern) n).vartype == null) || n.hasTag(ANYPATTERN)) {
4007                 components.append(Type.noType);
4008             } else {
4009                 components.append(attribExpr(n, env));
4010                 nestedBindings.put(n, matchBindings);
4011             }
4012         }
4013         Iterable&lt;Symbol&gt; patterns = site.tsym.members().getSymbols(sym -&gt; sym.kind == Kind.MTH &amp;&amp; sym.name.startsWith(names.fromString(&quot;\\%pattern\\%&quot;)));
4014         List&lt;Pair&lt;MethodSymbol, List&lt;Type&gt;&gt;&gt; foundPatterns = List.nil();
4015         for (Symbol pattern : patterns) {
4016             String[] parts = BytecodeName.toSourceName(pattern.name.toString()).split(&quot;\\$&quot;, 4);
4017             if (!parts[2].contentEquals(site.tsym.name))
4018                 continue;
4019             ListBuffer&lt;Type&gt; patternComponents = new ListBuffer&lt;&gt;();
4020             byte[] sig = Convert.string2utf(parts[3]);
4021             int[] idx = {1};
4022             while (sig[idx[0]] != &#39;)&#39;) {//TODO: handle errors
4023                 patternComponents.append(reader.decodeType(env.toplevel.modle, sig, idx));
4024             }
4025             if (isSubTypesIgnoreNone(components.toList(), patternComponents.toList())) {
4026                 //found a pattern:
4027                 foundPatterns = foundPatterns.prepend(Pair.of((MethodSymbol) pattern, patternComponents.toList()));
4028             }
4029         }
4030         ListBuffer&lt;BindingSymbol&gt; outBindings = new ListBuffer&lt;&gt;();
4031         if (foundPatterns.size() == 1) {
4032             tree.extractorResolver = foundPatterns.head.fst;
4033             List&lt;Type&gt; currentTypes;
4034             tree.innerTypes = currentTypes = foundPatterns.head.snd;
4035             //fix var/any patterns:
4036             for (JCPattern nestedPattern : tree.nested) {
4037                 MatchBindings currentBindings;
4038                 if (nestedPattern.type == null) {
4039                     attribExpr(nestedPattern, env, currentTypes.head);
4040                     currentBindings = matchBindings;
4041                 } else {
4042                     currentBindings = nestedBindings.get(nestedPattern);
4043                     Assert.checkNonNull(currentBindings);
4044                 }
4045                 Assert.check(currentBindings.bindingsWhenFalse.isEmpty());
4046                 outBindings.appendList(currentBindings.bindingsWhenTrue);
4047                 currentTypes = currentTypes.tail;
4048             }
4049         } else {
4050             //TODO: error:
4051         }
4052 //        //TODO: some checks....
4053         result = tree.type;
4054         matchBindings = new MatchBindings(outBindings.toList(), List.nil());
4055     }
4056 
4057     private boolean isSubTypesIgnoreNone(List&lt;Type&gt; ts, List&lt;Type&gt; ss) {
4058         while (ts.tail != null &amp;&amp; ss.tail != null &amp;&amp;
4059                (ts.head == Type.noType || types.isSubtype(ts.head, ss.head))) {
4060             ts = ts.tail;
4061             ss = ss.tail;
4062         }
4063         return ts.tail == null &amp;&amp; ss.tail == null;
4064     }
4065 
4066     private boolean verifyCastable(DiagnosticPosition pos, Type exprtype, Type clazztype) {
4067         Warner warner = new Warner();
4068         if (!chk.checkCastable(pos, exprtype, clazztype, chk.basicHandler, warner)) {
4069             return false;
4070         } else if (warner.hasLint(LintCategory.UNCHECKED)) {
4071             log.error(pos,
4072                       Errors.InstanceofReifiableNotSafe(exprtype, clazztype));
4073             return false;
4074         } else {
4075             return true;
4076         }
4077     }
4078 
4079     public void visitLiteralPattern(JCLiteralPattern tree) {
4080         Type patType = attribTree(tree.value, env, resultInfo);
4081 
4082         if (tree.value.hasTag(IDENT)) {
4083             // Pattern is an identifier
4084             JCIdent ident = (JCIdent)tree.value;
4085             if (ident.sym.kind==TYP) {
4086                 tree.patternKind = LiteralPatternKind.TYPE;
4087             } else {
4088                 tree.patternKind = LiteralPatternKind.CONSTANTEXPRESSIONORNULL;
4089             }
4090         } else if (tree.value.hasTag(SELECT)) {
4091             // Pattern is a compound name
4092             JCFieldAccess ident = (JCFieldAccess)tree.value;
4093             if (ident.sym.kind==TYP) {
4094                 tree.patternKind = LiteralPatternKind.TYPE;
4095             } else {
4096                 tree.patternKind = LiteralPatternKind.CONSTANTEXPRESSIONORNULL;
4097             }
4098         } else {
4099             // Pattern must be null literal or a constant expression
4100             tree.patternKind = LiteralPatternKind.CONSTANTEXPRESSIONORNULL;
4101             if (!patType.isErroneous() &amp;&amp; !patType.hasTag(BOT) &amp;&amp; patType.constValue() == null) {
4102                 log.error(tree.pos(), Errors.ConstExprReq);
4103             }
4104         }
4105         tree.type = patType;
4106     }
4107 
4108     public void visitIndexed(JCArrayAccess tree) {
4109         Type owntype = types.createErrorType(tree.type);
4110         Type atype = attribExpr(tree.indexed, env);
4111         attribExpr(tree.index, env, syms.intType);
4112         if (types.isArray(atype))
4113             owntype = types.elemtype(atype);
4114         else if (!atype.hasTag(ERROR))
4115             log.error(tree.pos(), Errors.ArrayReqButFound(atype));
4116         if (!pkind().contains(KindSelector.VAL))
4117             owntype = capture(owntype);
4118         result = check(tree, owntype, KindSelector.VAR, resultInfo);
4119     }
4120 
4121     public void visitIdent(JCIdent tree) {
4122         Symbol sym;
4123 
4124         // Find symbol
4125         if (pt().hasTag(METHOD) || pt().hasTag(FORALL)) {
4126             // If we are looking for a method, the prototype `pt&#39; will be a
4127             // method type with the type of the call&#39;s arguments as parameters.
4128             env.info.pendingResolutionPhase = null;
4129             sym = rs.resolveMethod(tree.pos(), env, tree.name, pt().getParameterTypes(), pt().getTypeArguments());
4130         } else if (tree.sym != null &amp;&amp; tree.sym.kind != VAR) {
4131             sym = tree.sym;
4132         } else {
4133             sym = rs.resolveIdent(tree.pos(), env, tree.name, pkind());
4134         }
4135         tree.sym = sym;
4136 
4137         // (1) Also find the environment current for the class where
4138         //     sym is defined (`symEnv&#39;).
4139         // Only for pre-tiger versions (1.4 and earlier):
4140         // (2) Also determine whether we access symbol out of an anonymous
4141         //     class in a this or super call.  This is illegal for instance
4142         //     members since such classes don&#39;t carry a this$n link.
4143         //     (`noOuterThisPath&#39;).
4144         Env&lt;AttrContext&gt; symEnv = env;
4145         boolean noOuterThisPath = false;
4146         if (env.enclClass.sym.owner.kind != PCK &amp;&amp; // we are in an inner class
4147             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4148             sym.owner.kind == TYP &amp;&amp;
4149             tree.name != names._this &amp;&amp; tree.name != names._super) {
4150 
4151             // Find environment in which identifier is defined.
4152             while (symEnv.outer != null &amp;&amp;
4153                    !sym.isMemberOf(symEnv.enclClass.sym, types)) {
4154                 if ((symEnv.enclClass.sym.flags() &amp; NOOUTERTHIS) != 0)
4155                     noOuterThisPath = false;
4156                 symEnv = symEnv.outer;
4157             }
4158         }
4159 
4160         // If symbol is a variable, ...
4161         if (sym.kind == VAR) {
4162             VarSymbol v = (VarSymbol)sym;
4163 
4164             // ..., evaluate its initializer, if it has one, and check for
4165             // illegal forward reference.
4166             checkInit(tree, env, v, false);
4167 
4168             // If we are expecting a variable (as opposed to a value), check
4169             // that the variable is assignable in the current environment.
4170             if (KindSelector.ASG.subset(pkind()))
4171                 checkAssignable(tree.pos(), v, null, env);
4172         }
4173 
4174         // In a constructor body,
4175         // if symbol is a field or instance method, check that it is
4176         // not accessed before the supertype constructor is called.
4177         if ((symEnv.info.isSelfCall || noOuterThisPath) &amp;&amp;
4178             sym.kind.matches(KindSelector.VAL_MTH) &amp;&amp;
4179             sym.owner.kind == TYP &amp;&amp;
4180             (sym.flags() &amp; STATIC) == 0) {
4181             chk.earlyRefError(tree.pos(), sym.kind == VAR ?
4182                                           sym : thisSym(tree.pos(), env));
4183         }
4184         Env&lt;AttrContext&gt; env1 = env;
4185         if (sym.kind != ERR &amp;&amp; sym.kind != TYP &amp;&amp;
4186             sym.owner != null &amp;&amp; sym.owner != env1.enclClass.sym) {
4187             // If the found symbol is inaccessible, then it is
4188             // accessed through an enclosing instance.  Locate this
4189             // enclosing instance:
4190             while (env1.outer != null &amp;&amp; !rs.isAccessible(env, env1.enclClass.sym.type, sym))
4191                 env1 = env1.outer;
4192         }
4193 
4194         if (env.info.isSerializable) {
4195             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4196         }
4197 
4198         result = checkId(tree, env1.enclClass.sym.type, sym, env, resultInfo);
4199     }
4200 
4201     public void visitSelect(JCFieldAccess tree) {
4202         // Determine the expected kind of the qualifier expression.
4203         KindSelector skind = KindSelector.NIL;
4204         if (tree.name == names._this || tree.name == names._super ||
4205                 tree.name == names._class)
4206         {
4207             skind = KindSelector.TYP;
4208         } else {
4209             if (pkind().contains(KindSelector.PCK))
4210                 skind = KindSelector.of(skind, KindSelector.PCK);
4211             if (pkind().contains(KindSelector.TYP))
4212                 skind = KindSelector.of(skind, KindSelector.TYP, KindSelector.PCK);
4213             if (pkind().contains(KindSelector.VAL_MTH))
4214                 skind = KindSelector.of(skind, KindSelector.VAL, KindSelector.TYP);
4215         }
4216 
4217         // Attribute the qualifier expression, and determine its symbol (if any).
4218         Type site = attribTree(tree.selected, env, new ResultInfo(skind, Type.noType));
4219         if (!pkind().contains(KindSelector.TYP_PCK))
4220             site = capture(site); // Capture field access
4221 
4222         // don&#39;t allow T.class T[].class, etc
4223         if (skind == KindSelector.TYP) {
4224             Type elt = site;
4225             while (elt.hasTag(ARRAY))
4226                 elt = ((ArrayType)elt).elemtype;
4227             if (elt.hasTag(TYPEVAR)) {
4228                 log.error(tree.pos(), Errors.TypeVarCantBeDeref);
4229                 result = tree.type = types.createErrorType(tree.name, site.tsym, site);
4230                 tree.sym = tree.type.tsym;
4231                 return ;
4232             }
4233         }
4234 
4235         // If qualifier symbol is a type or `super&#39;, assert `selectSuper&#39;
4236         // for the selection. This is relevant for determining whether
4237         // protected symbols are accessible.
4238         Symbol sitesym = TreeInfo.symbol(tree.selected);
4239         boolean selectSuperPrev = env.info.selectSuper;
4240         env.info.selectSuper =
4241             sitesym != null &amp;&amp;
4242             sitesym.name == names._super;
4243 
4244         // Determine the symbol represented by the selection.
4245         env.info.pendingResolutionPhase = null;
4246         Symbol sym = selectSym(tree, sitesym, site, env, resultInfo);
4247         if (sym.kind == VAR &amp;&amp; sym.name != names._super &amp;&amp; env.info.defaultSuperCallSite != null) {
4248             log.error(tree.selected.pos(), Errors.NotEnclClass(site.tsym));
4249             sym = syms.errSymbol;
4250         }
4251         if (sym.exists() &amp;&amp; !isType(sym) &amp;&amp; pkind().contains(KindSelector.TYP_PCK)) {
4252             site = capture(site);
4253             sym = selectSym(tree, sitesym, site, env, resultInfo);
4254         }
4255         boolean varArgs = env.info.lastResolveVarargs();
4256         tree.sym = sym;
4257 
4258         if (site.hasTag(TYPEVAR) &amp;&amp; !isType(sym) &amp;&amp; sym.kind != ERR) {
4259             site = types.skipTypeVars(site, true);
4260         }
4261 
4262         // If that symbol is a variable, ...
4263         if (sym.kind == VAR) {
4264             VarSymbol v = (VarSymbol)sym;
4265 
4266             // ..., evaluate its initializer, if it has one, and check for
4267             // illegal forward reference.
4268             checkInit(tree, env, v, true);
4269 
4270             // If we are expecting a variable (as opposed to a value), check
4271             // that the variable is assignable in the current environment.
4272             if (KindSelector.ASG.subset(pkind()))
4273                 checkAssignable(tree.pos(), v, tree.selected, env);
4274         }
4275 
4276         if (sitesym != null &amp;&amp;
4277                 sitesym.kind == VAR &amp;&amp;
4278                 ((VarSymbol)sitesym).isResourceVariable() &amp;&amp;
4279                 sym.kind == MTH &amp;&amp;
4280                 sym.name.equals(names.close) &amp;&amp;
4281                 sym.overrides(syms.autoCloseableClose, sitesym.type.tsym, types, true) &amp;&amp;
4282                 env.info.lint.isEnabled(LintCategory.TRY)) {
4283             log.warning(LintCategory.TRY, tree, Warnings.TryExplicitCloseCall);
4284         }
4285 
4286         // Disallow selecting a type from an expression
4287         if (isType(sym) &amp;&amp; (sitesym == null || !sitesym.kind.matches(KindSelector.TYP_PCK))) {
4288             tree.type = check(tree.selected, pt(),
4289                               sitesym == null ?
4290                                       KindSelector.VAL : sitesym.kind.toSelector(),
4291                               new ResultInfo(KindSelector.TYP_PCK, pt()));
4292         }
4293 
4294         if (isType(sitesym)) {
4295             if (sym.name == names._this) {
4296                 // If `C&#39; is the currently compiled class, check that
4297                 // C.this&#39; does not appear in a call to a super(...)
4298                 if (env.info.isSelfCall &amp;&amp;
4299                     site.tsym == env.enclClass.sym) {
4300                     chk.earlyRefError(tree.pos(), sym);
4301                 }
4302             } else {
4303                 // Check if type-qualified fields or methods are static (JLS)
4304                 if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4305                     sym.name != names._super &amp;&amp;
4306                     (sym.kind == VAR || sym.kind == MTH)) {
4307                     rs.accessBase(rs.new StaticError(sym),
4308                               tree.pos(), site, sym.name, true);
4309                 }
4310             }
4311             if (!allowStaticInterfaceMethods &amp;&amp; sitesym.isInterface() &amp;&amp;
4312                     sym.isStatic() &amp;&amp; sym.kind == MTH) {
4313                 log.error(DiagnosticFlag.SOURCE_LEVEL, tree.pos(), Feature.STATIC_INTERFACE_METHODS_INVOKE.error(sourceName));
4314             }
4315         } else if (sym.kind != ERR &amp;&amp;
4316                    (sym.flags() &amp; STATIC) != 0 &amp;&amp;
4317                    sym.name != names._class) {
4318             // If the qualified item is not a type and the selected item is static, report
4319             // a warning. Make allowance for the class of an array type e.g. Object[].class)
4320             chk.warnStatic(tree, Warnings.StaticNotQualifiedByType(sym.kind.kindName(), sym.owner));
4321         }
4322 
4323         // If we are selecting an instance member via a `super&#39;, ...
4324         if (env.info.selectSuper &amp;&amp; (sym.flags() &amp; STATIC) == 0) {
4325 
4326             // Check that super-qualified symbols are not abstract (JLS)
4327             rs.checkNonAbstract(tree.pos(), sym);
4328 
4329             if (site.isRaw()) {
4330                 // Determine argument types for site.
4331                 Type site1 = types.asSuper(env.enclClass.sym.type, site.tsym);
4332                 if (site1 != null) site = site1;
4333             }
4334         }
4335 
4336         if (env.info.isSerializable) {
4337             chk.checkAccessFromSerializableElement(tree, env.info.isSerializableLambda);
4338         }
4339 
4340         env.info.selectSuper = selectSuperPrev;
4341         result = checkId(tree, site, sym, env, resultInfo);
4342     }
4343     //where
4344         /** Determine symbol referenced by a Select expression,
4345          *
4346          *  @param tree   The select tree.
4347          *  @param site   The type of the selected expression,
4348          *  @param env    The current environment.
4349          *  @param resultInfo The current result.
4350          */
4351         private Symbol selectSym(JCFieldAccess tree,
4352                                  Symbol location,
4353                                  Type site,
4354                                  Env&lt;AttrContext&gt; env,
4355                                  ResultInfo resultInfo) {
4356             DiagnosticPosition pos = tree.pos();
4357             Name name = tree.name;
4358             switch (site.getTag()) {
4359             case PACKAGE:
4360                 return rs.accessBase(
4361                     rs.findIdentInPackage(pos, env, site.tsym, name, resultInfo.pkind),
4362                     pos, location, site, name, true);
4363             case ARRAY:
4364             case CLASS:
4365                 if (resultInfo.pt.hasTag(METHOD) || resultInfo.pt.hasTag(FORALL)) {
4366                     return rs.resolveQualifiedMethod(
4367                         pos, env, location, site, name, resultInfo.pt.getParameterTypes(), resultInfo.pt.getTypeArguments());
4368                 } else if (name == names._this || name == names._super) {
4369                     return rs.resolveSelf(pos, env, site.tsym, name);
4370                 } else if (name == names._class) {
4371                     // In this case, we have already made sure in
4372                     // visitSelect that qualifier expression is a type.
4373                     return syms.getClassField(site, types);
4374                 } else {
4375                     // We are seeing a plain identifier as selector.
4376                     Symbol sym = rs.findIdentInType(pos, env, site, name, resultInfo.pkind);
4377                         sym = rs.accessBase(sym, pos, location, site, name, true);
4378                     return sym;
4379                 }
4380             case WILDCARD:
4381                 throw new AssertionError(tree);
4382             case TYPEVAR:
4383                 // Normally, site.getUpperBound() shouldn&#39;t be null.
4384                 // It should only happen during memberEnter/attribBase
4385                 // when determining the super type which *must* be
4386                 // done before attributing the type variables.  In
4387                 // other words, we are seeing this illegal program:
4388                 // class B&lt;T&gt; extends A&lt;T.foo&gt; {}
4389                 Symbol sym = (site.getUpperBound() != null)
4390                     ? selectSym(tree, location, capture(site.getUpperBound()), env, resultInfo)
4391                     : null;
4392                 if (sym == null) {
4393                     log.error(pos, Errors.TypeVarCantBeDeref);
4394                     return syms.errSymbol;
4395                 } else {
4396                     Symbol sym2 = (sym.flags() &amp; Flags.PRIVATE) != 0 ?
4397                         rs.new AccessError(env, site, sym) :
4398                                 sym;
4399                     rs.accessBase(sym2, pos, location, site, name, true);
4400                     return sym;
4401                 }
4402             case ERROR:
4403                 // preserve identifier names through errors
4404                 return types.createErrorType(name, site.tsym, site).tsym;
4405             default:
4406                 // The qualifier expression is of a primitive type -- only
4407                 // .class is allowed for these.
4408                 if (name == names._class) {
4409                     // In this case, we have already made sure in Select that
4410                     // qualifier expression is a type.
4411                     return syms.getClassField(site, types);
4412                 } else {
4413                     log.error(pos, Errors.CantDeref(site));
4414                     return syms.errSymbol;
4415                 }
4416             }
4417         }
4418 
4419         /** Determine type of identifier or select expression and check that
4420          *  (1) the referenced symbol is not deprecated
4421          *  (2) the symbol&#39;s type is safe (@see checkSafe)
4422          *  (3) if symbol is a variable, check that its type and kind are
4423          *      compatible with the prototype and protokind.
4424          *  (4) if symbol is an instance field of a raw type,
4425          *      which is being assigned to, issue an unchecked warning if its
4426          *      type changes under erasure.
4427          *  (5) if symbol is an instance method of a raw type, issue an
4428          *      unchecked warning if its argument types change under erasure.
4429          *  If checks succeed:
4430          *    If symbol is a constant, return its constant type
4431          *    else if symbol is a method, return its result type
4432          *    otherwise return its type.
4433          *  Otherwise return errType.
4434          *
4435          *  @param tree       The syntax tree representing the identifier
4436          *  @param site       If this is a select, the type of the selected
4437          *                    expression, otherwise the type of the current class.
4438          *  @param sym        The symbol representing the identifier.
4439          *  @param env        The current environment.
4440          *  @param resultInfo    The expected result
4441          */
4442         Type checkId(JCTree tree,
4443                      Type site,
4444                      Symbol sym,
4445                      Env&lt;AttrContext&gt; env,
4446                      ResultInfo resultInfo) {
4447             return (resultInfo.pt.hasTag(FORALL) || resultInfo.pt.hasTag(METHOD)) ?
4448                     checkMethodIdInternal(tree, site, sym, env, resultInfo) :
4449                     checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4450         }
4451 
4452         Type checkMethodIdInternal(JCTree tree,
4453                      Type site,
4454                      Symbol sym,
4455                      Env&lt;AttrContext&gt; env,
4456                      ResultInfo resultInfo) {
4457             if (resultInfo.pkind.contains(KindSelector.POLY)) {
4458                 Type pt = resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.SPECULATIVE, sym, env.info.pendingResolutionPhase));
4459                 Type owntype = checkIdInternal(tree, site, sym, pt, env, resultInfo);
4460                 resultInfo.pt.map(deferredAttr.new RecoveryDeferredTypeMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4461                 return owntype;
4462             } else {
4463                 return checkIdInternal(tree, site, sym, resultInfo.pt, env, resultInfo);
4464             }
4465         }
4466 
4467         Type checkIdInternal(JCTree tree,
4468                      Type site,
4469                      Symbol sym,
4470                      Type pt,
4471                      Env&lt;AttrContext&gt; env,
4472                      ResultInfo resultInfo) {
4473             if (pt.isErroneous()) {
4474                 return types.createErrorType(site);
4475             }
4476             Type owntype; // The computed type of this identifier occurrence.
4477             switch (sym.kind) {
4478             case TYP:
4479                 // For types, the computed type equals the symbol&#39;s type,
4480                 // except for two situations:
4481                 owntype = sym.type;
4482                 if (owntype.hasTag(CLASS)) {
4483                     chk.checkForBadAuxiliaryClassAccess(tree.pos(), env, (ClassSymbol)sym);
4484                     Type ownOuter = owntype.getEnclosingType();
4485 
4486                     // (a) If the symbol&#39;s type is parameterized, erase it
4487                     // because no type parameters were given.
4488                     // We recover generic outer type later in visitTypeApply.
4489                     if (owntype.tsym.type.getTypeArguments().nonEmpty()) {
4490                         owntype = types.erasure(owntype);
4491                     }
4492 
4493                     // (b) If the symbol&#39;s type is an inner class, then
4494                     // we have to interpret its outer type as a superclass
4495                     // of the site type. Example:
4496                     //
4497                     // class Tree&lt;A&gt; { class Visitor { ... } }
4498                     // class PointTree extends Tree&lt;Point&gt; { ... }
4499                     // ...PointTree.Visitor...
4500                     //
4501                     // Then the type of the last expression above is
4502                     // Tree&lt;Point&gt;.Visitor.
4503                     else if (ownOuter.hasTag(CLASS) &amp;&amp; site != ownOuter) {
4504                         Type normOuter = site;
4505                         if (normOuter.hasTag(CLASS)) {
4506                             normOuter = types.asEnclosingSuper(site, ownOuter.tsym);
4507                         }
4508                         if (normOuter == null) // perhaps from an import
4509                             normOuter = types.erasure(ownOuter);
4510                         if (normOuter != ownOuter)
4511                             owntype = new ClassType(
4512                                 normOuter, List.nil(), owntype.tsym,
4513                                 owntype.getMetadata());
4514                     }
4515                 }
4516                 break;
4517             case VAR:
4518                 VarSymbol v = (VarSymbol)sym;
4519 
4520                 if (env.info.enclVar != null
4521                         &amp;&amp; v.type.hasTag(NONE)) {
4522                     //self reference to implicitly typed variable declaration
4523                     log.error(TreeInfo.positionFor(v, env.enclClass), Errors.CantInferLocalVarType(v.name, Fragments.LocalSelfRef));
4524                     return v.type = types.createErrorType(v.type);
4525                 }
4526 
4527                 // Test (4): if symbol is an instance field of a raw type,
4528                 // which is being assigned to, issue an unchecked warning if
4529                 // its type changes under erasure.
4530                 if (KindSelector.ASG.subset(pkind()) &amp;&amp;
4531                     v.owner.kind == TYP &amp;&amp;
4532                     (v.flags() &amp; STATIC) == 0 &amp;&amp;
4533                     (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4534                     Type s = types.asOuterSuper(site, v.owner);
4535                     if (s != null &amp;&amp;
4536                         s.isRaw() &amp;&amp;
4537                         !types.isSameType(v.type, v.erasure(types))) {
4538                         chk.warnUnchecked(tree.pos(), Warnings.UncheckedAssignToVar(v, s));
4539                     }
4540                 }
4541                 // The computed type of a variable is the type of the
4542                 // variable symbol, taken as a member of the site type.
4543                 owntype = (sym.owner.kind == TYP &amp;&amp;
4544                            sym.name != names._this &amp;&amp; sym.name != names._super)
4545                     ? types.memberType(site, sym)
4546                     : sym.type;
4547 
4548                 // If the variable is a constant, record constant value in
4549                 // computed type.
4550                 if (v.getConstValue() != null &amp;&amp; isStaticReference(tree))
4551                     owntype = owntype.constType(v.getConstValue());
4552 
4553                 if (resultInfo.pkind == KindSelector.VAL) {
4554                     owntype = capture(owntype); // capture &quot;names as expressions&quot;
4555                 }
4556                 break;
4557             case MTH: {
4558                 owntype = checkMethod(site, sym,
4559                         new ResultInfo(resultInfo.pkind, resultInfo.pt.getReturnType(), resultInfo.checkContext, resultInfo.checkMode),
4560                         env, TreeInfo.args(env.tree), resultInfo.pt.getParameterTypes(),
4561                         resultInfo.pt.getTypeArguments());
4562                 break;
4563             }
4564             case PCK: case ERR:
4565                 owntype = sym.type;
4566                 break;
4567             default:
4568                 throw new AssertionError(&quot;unexpected kind: &quot; + sym.kind +
4569                                          &quot; in tree &quot; + tree);
4570             }
4571 
4572             // Emit a `deprecation&#39; warning if symbol is deprecated.
4573             // (for constructors (but not for constructor references), the error
4574             // was given when the constructor was resolved)
4575 
4576             if (sym.name != names.init || tree.hasTag(REFERENCE)) {
4577                 chk.checkDeprecated(tree.pos(), env.info.scope.owner, sym);
4578                 chk.checkSunAPI(tree.pos(), sym);
4579                 chk.checkProfile(tree.pos(), sym);
4580                 chk.checkPreview(tree.pos(), sym);
4581             }
4582 
4583             // If symbol is a variable, check that its type and
4584             // kind are compatible with the prototype and protokind.
4585             return check(tree, owntype, sym.kind.toSelector(), resultInfo);
4586         }
4587 
4588         /** Check that variable is initialized and evaluate the variable&#39;s
4589          *  initializer, if not yet done. Also check that variable is not
4590          *  referenced before it is defined.
4591          *  @param tree    The tree making up the variable reference.
4592          *  @param env     The current environment.
4593          *  @param v       The variable&#39;s symbol.
4594          */
4595         private void checkInit(JCTree tree,
4596                                Env&lt;AttrContext&gt; env,
4597                                VarSymbol v,
4598                                boolean onlyWarning) {
4599             // A forward reference is diagnosed if the declaration position
4600             // of the variable is greater than the current tree position
4601             // and the tree and variable definition occur in the same class
4602             // definition.  Note that writes don&#39;t count as references.
4603             // This check applies only to class and instance
4604             // variables.  Local variables follow different scope rules,
4605             // and are subject to definite assignment checking.
4606             Env&lt;AttrContext&gt; initEnv = enclosingInitEnv(env);
4607             if (initEnv != null &amp;&amp;
4608                 (initEnv.info.enclVar == v || v.pos &gt; tree.pos) &amp;&amp;
4609                 v.owner.kind == TYP &amp;&amp;
4610                 v.owner == env.info.scope.owner.enclClass() &amp;&amp;
4611                 ((v.flags() &amp; STATIC) != 0) == Resolve.isStatic(env) &amp;&amp;
4612                 (!env.tree.hasTag(ASSIGN) ||
4613                  TreeInfo.skipParens(((JCAssign) env.tree).lhs) != tree)) {
4614                 if (!onlyWarning || isStaticEnumField(v)) {
4615                     Error errkey = (initEnv.info.enclVar == v) ?
4616                                 Errors.IllegalSelfRef : Errors.IllegalForwardRef;
4617                     log.error(tree.pos(), errkey);
4618                 } else if (useBeforeDeclarationWarning) {
4619                     Warning warnkey = (initEnv.info.enclVar == v) ?
4620                                 Warnings.SelfRef(v) : Warnings.ForwardRef(v);
4621                     log.warning(tree.pos(), warnkey);
4622                 }
4623             }
4624 
4625             v.getConstValue(); // ensure initializer is evaluated
4626 
4627             checkEnumInitializer(tree, env, v);
4628         }
4629 
4630         /**
4631          * Returns the enclosing init environment associated with this env (if any). An init env
4632          * can be either a field declaration env or a static/instance initializer env.
4633          */
4634         Env&lt;AttrContext&gt; enclosingInitEnv(Env&lt;AttrContext&gt; env) {
4635             while (true) {
4636                 switch (env.tree.getTag()) {
4637                     case VARDEF:
4638                         JCVariableDecl vdecl = (JCVariableDecl)env.tree;
4639                         if (vdecl.sym.owner.kind == TYP) {
4640                             //field
4641                             return env;
4642                         }
4643                         break;
4644                     case BLOCK:
4645                         if (env.next.tree.hasTag(CLASSDEF)) {
4646                             //instance/static initializer
4647                             return env;
4648                         }
4649                         break;
4650                     case METHODDEF:
4651                     case CLASSDEF:
4652                     case TOPLEVEL:
4653                         return null;
4654                 }
4655                 Assert.checkNonNull(env.next);
4656                 env = env.next;
4657             }
4658         }
4659 
4660         /**
4661          * Check for illegal references to static members of enum.  In
4662          * an enum type, constructors and initializers may not
4663          * reference its static members unless they are constant.
4664          *
4665          * @param tree    The tree making up the variable reference.
4666          * @param env     The current environment.
4667          * @param v       The variable&#39;s symbol.
4668          * @jls 8.9 Enum Types
4669          */
4670         private void checkEnumInitializer(JCTree tree, Env&lt;AttrContext&gt; env, VarSymbol v) {
4671             // JLS:
4672             //
4673             // &quot;It is a compile-time error to reference a static field
4674             // of an enum type that is not a compile-time constant
4675             // (15.28) from constructors, instance initializer blocks,
4676             // or instance variable initializer expressions of that
4677             // type. It is a compile-time error for the constructors,
4678             // instance initializer blocks, or instance variable
4679             // initializer expressions of an enum constant e to refer
4680             // to itself or to an enum constant of the same type that
4681             // is declared to the right of e.&quot;
4682             if (isStaticEnumField(v)) {
4683                 ClassSymbol enclClass = env.info.scope.owner.enclClass();
4684 
4685                 if (enclClass == null || enclClass.owner == null)
4686                     return;
4687 
4688                 // See if the enclosing class is the enum (or a
4689                 // subclass thereof) declaring v.  If not, this
4690                 // reference is OK.
4691                 if (v.owner != enclClass &amp;&amp; !types.isSubtype(enclClass.type, v.owner.type))
4692                     return;
4693 
4694                 // If the reference isn&#39;t from an initializer, then
4695                 // the reference is OK.
4696                 if (!Resolve.isInitializer(env))
4697                     return;
4698 
4699                 log.error(tree.pos(), Errors.IllegalEnumStaticRef);
4700             }
4701         }
4702 
4703         /** Is the given symbol a static, non-constant field of an Enum?
4704          *  Note: enum literals should not be regarded as such
4705          */
4706         private boolean isStaticEnumField(VarSymbol v) {
4707             return Flags.isEnum(v.owner) &amp;&amp;
4708                    Flags.isStatic(v) &amp;&amp;
4709                    !Flags.isConstant(v) &amp;&amp;
4710                    v.name != names._class;
4711         }
4712 
4713     /**
4714      * Check that method arguments conform to its instantiation.
4715      **/
4716     public Type checkMethod(Type site,
4717                             final Symbol sym,
4718                             ResultInfo resultInfo,
4719                             Env&lt;AttrContext&gt; env,
4720                             final List&lt;JCExpression&gt; argtrees,
4721                             List&lt;Type&gt; argtypes,
4722                             List&lt;Type&gt; typeargtypes) {
4723         // Test (5): if symbol is an instance method of a raw type, issue
4724         // an unchecked warning if its argument types change under erasure.
4725         if ((sym.flags() &amp; STATIC) == 0 &amp;&amp;
4726             (site.hasTag(CLASS) || site.hasTag(TYPEVAR))) {
4727             Type s = types.asOuterSuper(site, sym.owner);
4728             if (s != null &amp;&amp; s.isRaw() &amp;&amp;
4729                 !types.isSameTypes(sym.type.getParameterTypes(),
4730                                    sym.erasure(types).getParameterTypes())) {
4731                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedCallMbrOfRawType(sym, s));
4732             }
4733         }
4734 
4735         if (env.info.defaultSuperCallSite != null) {
4736             for (Type sup : types.interfaces(env.enclClass.type).prepend(types.supertype((env.enclClass.type)))) {
4737                 if (!sup.tsym.isSubClass(sym.enclClass(), types) ||
4738                         types.isSameType(sup, env.info.defaultSuperCallSite)) continue;
4739                 List&lt;MethodSymbol&gt; icand_sup =
4740                         types.interfaceCandidates(sup, (MethodSymbol)sym);
4741                 if (icand_sup.nonEmpty() &amp;&amp;
4742                         icand_sup.head != sym &amp;&amp;
4743                         icand_sup.head.overrides(sym, icand_sup.head.enclClass(), types, true)) {
4744                     log.error(env.tree.pos(),
4745                               Errors.IllegalDefaultSuperCall(env.info.defaultSuperCallSite, Fragments.OverriddenDefault(sym, sup)));
4746                     break;
4747                 }
4748             }
4749             env.info.defaultSuperCallSite = null;
4750         }
4751 
4752         if (sym.isStatic() &amp;&amp; site.isInterface() &amp;&amp; env.tree.hasTag(APPLY)) {
4753             JCMethodInvocation app = (JCMethodInvocation)env.tree;
4754             if (app.meth.hasTag(SELECT) &amp;&amp;
4755                     !TreeInfo.isStaticSelector(((JCFieldAccess)app.meth).selected, names)) {
4756                 log.error(env.tree.pos(), Errors.IllegalStaticIntfMethCall(site));
4757             }
4758         }
4759 
4760         // Compute the identifier&#39;s instantiated type.
4761         // For methods, we need to compute the instance type by
4762         // Resolve.instantiate from the symbol&#39;s type as well as
4763         // any type arguments and value arguments.
4764         Warner noteWarner = new Warner();
4765         try {
4766             Type owntype = rs.checkMethod(
4767                     env,
4768                     site,
4769                     sym,
4770                     resultInfo,
4771                     argtypes,
4772                     typeargtypes,
4773                     noteWarner);
4774 
4775             DeferredAttr.DeferredTypeMap&lt;Void&gt; checkDeferredMap =
4776                 deferredAttr.new DeferredTypeMap&lt;&gt;(DeferredAttr.AttrMode.CHECK, sym, env.info.pendingResolutionPhase);
4777 
4778             argtypes = argtypes.map(checkDeferredMap);
4779 
4780             if (noteWarner.hasNonSilentLint(LintCategory.UNCHECKED)) {
4781                 chk.warnUnchecked(env.tree.pos(), Warnings.UncheckedMethInvocationApplied(kindName(sym),
4782                         sym.name,
4783                         rs.methodArguments(sym.type.getParameterTypes()),
4784                         rs.methodArguments(argtypes.map(checkDeferredMap)),
4785                         kindName(sym.location()),
4786                         sym.location()));
4787                 if (resultInfo.pt != Infer.anyPoly ||
4788                         !owntype.hasTag(METHOD) ||
4789                         !owntype.isPartial()) {
4790                     //if this is not a partially inferred method type, erase return type. Otherwise,
4791                     //erasure is carried out in PartiallyInferredMethodType.check().
4792                     owntype = new MethodType(owntype.getParameterTypes(),
4793                             types.erasure(owntype.getReturnType()),
4794                             types.erasure(owntype.getThrownTypes()),
4795                             syms.methodClass);
4796                 }
4797             }
4798 
4799             PolyKind pkind = (sym.type.hasTag(FORALL) &amp;&amp;
4800                  sym.type.getReturnType().containsAny(((ForAll)sym.type).tvars)) ?
4801                  PolyKind.POLY : PolyKind.STANDALONE;
4802             TreeInfo.setPolyKind(env.tree, pkind);
4803 
4804             return (resultInfo.pt == Infer.anyPoly) ?
4805                     owntype :
4806                     chk.checkMethod(owntype, sym, env, argtrees, argtypes, env.info.lastResolveVarargs(),
4807                             resultInfo.checkContext.inferenceContext());
4808         } catch (Infer.InferenceException ex) {
4809             //invalid target type - propagate exception outwards or report error
4810             //depending on the current check context
4811             resultInfo.checkContext.report(env.tree.pos(), ex.getDiagnostic());
4812             return types.createErrorType(site);
4813         } catch (Resolve.InapplicableMethodException ex) {
4814             final JCDiagnostic diag = ex.getDiagnostic();
4815             Resolve.InapplicableSymbolError errSym = rs.new InapplicableSymbolError(null) {
4816                 @Override
4817                 protected Pair&lt;Symbol, JCDiagnostic&gt; errCandidate() {
4818                     return new Pair&lt;&gt;(sym, diag);
4819                 }
4820             };
4821             List&lt;Type&gt; argtypes2 = argtypes.map(
4822                     rs.new ResolveDeferredRecoveryMap(AttrMode.CHECK, sym, env.info.pendingResolutionPhase));
4823             JCDiagnostic errDiag = errSym.getDiagnostic(JCDiagnostic.DiagnosticType.ERROR,
4824                     env.tree, sym, site, sym.name, argtypes2, typeargtypes);
4825             log.report(errDiag);
4826             return types.createErrorType(site);
4827         }
4828     }
4829 
4830     public void visitLiteral(JCLiteral tree) {
4831         result = check(tree, litType(tree.typetag).constType(tree.value),
4832                 KindSelector.VAL, resultInfo);
4833     }
4834     //where
4835     /** Return the type of a literal with given type tag.
4836      */
4837     Type litType(TypeTag tag) {
4838         return (tag == CLASS) ? syms.stringType : syms.typeOfTag[tag.ordinal()];
4839     }
4840 
4841     public void visitTypeIdent(JCPrimitiveTypeTree tree) {
4842         result = check(tree, syms.typeOfTag[tree.typetag.ordinal()], KindSelector.TYP, resultInfo);
4843     }
4844 
4845     public void visitTypeArray(JCArrayTypeTree tree) {
4846         Type etype = attribType(tree.elemtype, env);
4847         Type type = new ArrayType(etype, syms.arrayClass);
4848         result = check(tree, type, KindSelector.TYP, resultInfo);
4849     }
4850 
4851     /** Visitor method for parameterized types.
4852      *  Bound checking is left until later, since types are attributed
4853      *  before supertype structure is completely known
4854      */
4855     public void visitTypeApply(JCTypeApply tree) {
4856         Type owntype = types.createErrorType(tree.type);
4857 
4858         // Attribute functor part of application and make sure it&#39;s a class.
4859         Type clazztype = chk.checkClassType(tree.clazz.pos(), attribType(tree.clazz, env));
4860 
4861         // Attribute type parameters
4862         List&lt;Type&gt; actuals = attribTypes(tree.arguments, env);
4863 
4864         if (clazztype.hasTag(CLASS)) {
4865             List&lt;Type&gt; formals = clazztype.tsym.type.getTypeArguments();
4866             if (actuals.isEmpty()) //diamond
4867                 actuals = formals;
4868 
4869             if (actuals.length() == formals.length()) {
4870                 List&lt;Type&gt; a = actuals;
4871                 List&lt;Type&gt; f = formals;
4872                 while (a.nonEmpty()) {
4873                     a.head = a.head.withTypeVar(f.head);
4874                     a = a.tail;
4875                     f = f.tail;
4876                 }
4877                 // Compute the proper generic outer
4878                 Type clazzOuter = clazztype.getEnclosingType();
4879                 if (clazzOuter.hasTag(CLASS)) {
4880                     Type site;
4881                     JCExpression clazz = TreeInfo.typeIn(tree.clazz);
4882                     if (clazz.hasTag(IDENT)) {
4883                         site = env.enclClass.sym.type;
4884                     } else if (clazz.hasTag(SELECT)) {
4885                         site = ((JCFieldAccess) clazz).selected.type;
4886                     } else throw new AssertionError(&quot;&quot;+tree);
4887                     if (clazzOuter.hasTag(CLASS) &amp;&amp; site != clazzOuter) {
4888                         if (site.hasTag(CLASS))
4889                             site = types.asOuterSuper(site, clazzOuter.tsym);
4890                         if (site == null)
4891                             site = types.erasure(clazzOuter);
4892                         clazzOuter = site;
4893                     }
4894                 }
4895                 owntype = new ClassType(clazzOuter, actuals, clazztype.tsym,
4896                                         clazztype.getMetadata());
4897             } else {
4898                 if (formals.length() != 0) {
4899                     log.error(tree.pos(),
4900                               Errors.WrongNumberTypeArgs(Integer.toString(formals.length())));
4901                 } else {
4902                     log.error(tree.pos(), Errors.TypeDoesntTakeParams(clazztype.tsym));
4903                 }
4904                 owntype = types.createErrorType(tree.type);
4905             }
4906         }
4907         result = check(tree, owntype, KindSelector.TYP, resultInfo);
4908     }
4909 
4910     public void visitTypeUnion(JCTypeUnion tree) {
4911         ListBuffer&lt;Type&gt; multicatchTypes = new ListBuffer&lt;&gt;();
4912         ListBuffer&lt;Type&gt; all_multicatchTypes = null; // lazy, only if needed
4913         for (JCExpression typeTree : tree.alternatives) {
4914             Type ctype = attribType(typeTree, env);
4915             ctype = chk.checkType(typeTree.pos(),
4916                           chk.checkClassType(typeTree.pos(), ctype),
4917                           syms.throwableType);
4918             if (!ctype.isErroneous()) {
4919                 //check that alternatives of a union type are pairwise
4920                 //unrelated w.r.t. subtyping
4921                 if (chk.intersects(ctype,  multicatchTypes.toList())) {
4922                     for (Type t : multicatchTypes) {
4923                         boolean sub = types.isSubtype(ctype, t);
4924                         boolean sup = types.isSubtype(t, ctype);
4925                         if (sub || sup) {
4926                             //assume &#39;a&#39; &lt;: &#39;b&#39;
4927                             Type a = sub ? ctype : t;
4928                             Type b = sub ? t : ctype;
4929                             log.error(typeTree.pos(), Errors.MulticatchTypesMustBeDisjoint(a, b));
4930                         }
4931                     }
4932                 }
4933                 multicatchTypes.append(ctype);
4934                 if (all_multicatchTypes != null)
4935                     all_multicatchTypes.append(ctype);
4936             } else {
4937                 if (all_multicatchTypes == null) {
4938                     all_multicatchTypes = new ListBuffer&lt;&gt;();
4939                     all_multicatchTypes.appendList(multicatchTypes);
4940                 }
4941                 all_multicatchTypes.append(ctype);
4942             }
4943         }
4944         Type t = check(tree, types.lub(multicatchTypes.toList()),
4945                 KindSelector.TYP, resultInfo.dup(CheckMode.NO_TREE_UPDATE));
4946         if (t.hasTag(CLASS)) {
4947             List&lt;Type&gt; alternatives =
4948                 ((all_multicatchTypes == null) ? multicatchTypes : all_multicatchTypes).toList();
4949             t = new UnionClassType((ClassType) t, alternatives);
4950         }
4951         tree.type = result = t;
4952     }
4953 
4954     public void visitTypeIntersection(JCTypeIntersection tree) {
4955         attribTypes(tree.bounds, env);
4956         tree.type = result = checkIntersection(tree, tree.bounds);
4957     }
4958 
4959     public void visitTypeParameter(JCTypeParameter tree) {
4960         TypeVar typeVar = (TypeVar) tree.type;
4961 
4962         if (tree.annotations != null &amp;&amp; tree.annotations.nonEmpty()) {
4963             annotate.annotateTypeParameterSecondStage(tree, tree.annotations);
4964         }
4965 
4966         if (!typeVar.getUpperBound().isErroneous()) {
4967             //fixup type-parameter bound computed in &#39;attribTypeVariables&#39;
4968             typeVar.setUpperBound(checkIntersection(tree, tree.bounds));
4969         }
4970     }
4971 
4972     Type checkIntersection(JCTree tree, List&lt;JCExpression&gt; bounds) {
4973         Set&lt;Type&gt; boundSet = new HashSet&lt;&gt;();
4974         if (bounds.nonEmpty()) {
4975             // accept class or interface or typevar as first bound.
4976             bounds.head.type = checkBase(bounds.head.type, bounds.head, env, false, false, false);
4977             boundSet.add(types.erasure(bounds.head.type));
4978             if (bounds.head.type.isErroneous()) {
4979                 return bounds.head.type;
4980             }
4981             else if (bounds.head.type.hasTag(TYPEVAR)) {
4982                 // if first bound was a typevar, do not accept further bounds.
4983                 if (bounds.tail.nonEmpty()) {
4984                     log.error(bounds.tail.head.pos(),
4985                               Errors.TypeVarMayNotBeFollowedByOtherBounds);
4986                     return bounds.head.type;
4987                 }
4988             } else {
4989                 // if first bound was a class or interface, accept only interfaces
4990                 // as further bounds.
4991                 for (JCExpression bound : bounds.tail) {
4992                     bound.type = checkBase(bound.type, bound, env, false, true, false);
4993                     if (bound.type.isErroneous()) {
4994                         bounds = List.of(bound);
4995                     }
4996                     else if (bound.type.hasTag(CLASS)) {
4997                         chk.checkNotRepeated(bound.pos(), types.erasure(bound.type), boundSet);
4998                     }
4999                 }
5000             }
5001         }
5002 
5003         if (bounds.length() == 0) {
5004             return syms.objectType;
5005         } else if (bounds.length() == 1) {
5006             return bounds.head.type;
5007         } else {
5008             Type owntype = types.makeIntersectionType(TreeInfo.types(bounds));
5009             // ... the variable&#39;s bound is a class type flagged COMPOUND
5010             // (see comment for TypeVar.bound).
5011             // In this case, generate a class tree that represents the
5012             // bound class, ...
5013             JCExpression extending;
5014             List&lt;JCExpression&gt; implementing;
5015             if (!bounds.head.type.isInterface()) {
5016                 extending = bounds.head;
5017                 implementing = bounds.tail;
5018             } else {
5019                 extending = null;
5020                 implementing = bounds;
5021             }
5022             JCClassDecl cd = make.at(tree).ClassDef(
5023                 make.Modifiers(PUBLIC | ABSTRACT),
5024                 names.empty, List.nil(),
5025                 extending, implementing, List.nil());
5026 
5027             ClassSymbol c = (ClassSymbol)owntype.tsym;
5028             Assert.check((c.flags() &amp; COMPOUND) != 0);
5029             cd.sym = c;
5030             c.sourcefile = env.toplevel.sourcefile;
5031 
5032             // ... and attribute the bound class
5033             c.flags_field |= UNATTRIBUTED;
5034             Env&lt;AttrContext&gt; cenv = enter.classEnv(cd, env);
5035             typeEnvs.put(c, cenv);
5036             attribClass(c);
5037             return owntype;
5038         }
5039     }
5040 
5041     public void visitWildcard(JCWildcard tree) {
5042         //- System.err.println(&quot;visitWildcard(&quot;+tree+&quot;);&quot;);//DEBUG
5043         Type type = (tree.kind.kind == BoundKind.UNBOUND)
5044             ? syms.objectType
5045             : attribType(tree.inner, env);
5046         result = check(tree, new WildcardType(chk.checkRefType(tree.pos(), type),
5047                                               tree.kind.kind,
5048                                               syms.boundClass),
5049                 KindSelector.TYP, resultInfo);
5050     }
5051 
5052     public void visitAnnotation(JCAnnotation tree) {
5053         Assert.error(&quot;should be handled in annotate&quot;);
5054     }
5055 
5056     public void visitAnnotatedType(JCAnnotatedType tree) {
5057         attribAnnotationTypes(tree.annotations, env);
5058         Type underlyingType = attribType(tree.underlyingType, env);
5059         Type annotatedType = underlyingType.annotatedType(Annotations.TO_BE_SET);
5060 
5061         if (!env.info.isNewClass)
5062             annotate.annotateTypeSecondStage(tree, tree.annotations, annotatedType);
5063         result = tree.type = annotatedType;
5064     }
5065 
5066     public void visitErroneous(JCErroneous tree) {
5067         if (tree.errs != null)
5068             for (JCTree err : tree.errs)
5069                 attribTree(err, env, new ResultInfo(KindSelector.ERR, pt()));
5070         result = tree.type = syms.errType;
5071     }
5072 
5073     /** Default visitor method for all other trees.
5074      */
5075     public void visitTree(JCTree tree) {
5076         throw new AssertionError();
5077     }
5078 
5079     /**
5080      * Attribute an env for either a top level tree or class or module declaration.
5081      */
5082     public void attrib(Env&lt;AttrContext&gt; env) {
5083         switch (env.tree.getTag()) {
5084             case MODULEDEF:
5085                 attribModule(env.tree.pos(), ((JCModuleDecl)env.tree).sym);
5086                 break;
5087             case TOPLEVEL:
5088                 attribTopLevel(env);
5089                 break;
5090             case PACKAGEDEF:
5091                 attribPackage(env.tree.pos(), ((JCPackageDecl) env.tree).packge);
5092                 break;
5093             default:
5094                 attribClass(env.tree.pos(), env.enclClass.sym);
5095         }
5096     }
5097 
5098     /**
5099      * Attribute a top level tree. These trees are encountered when the
5100      * package declaration has annotations.
5101      */
5102     public void attribTopLevel(Env&lt;AttrContext&gt; env) {
5103         JCCompilationUnit toplevel = env.toplevel;
5104         try {
5105             annotate.flush();
5106         } catch (CompletionFailure ex) {
5107             chk.completionError(toplevel.pos(), ex);
5108         }
5109     }
5110 
5111     public void attribPackage(DiagnosticPosition pos, PackageSymbol p) {
5112         try {
5113             annotate.flush();
5114             attribPackage(p);
5115         } catch (CompletionFailure ex) {
5116             chk.completionError(pos, ex);
5117         }
5118     }
5119 
5120     void attribPackage(PackageSymbol p) {
5121         Env&lt;AttrContext&gt; env = typeEnvs.get(p);
5122         chk.checkDeprecatedAnnotation(((JCPackageDecl) env.tree).pid.pos(), p);
5123     }
5124 
5125     public void attribModule(DiagnosticPosition pos, ModuleSymbol m) {
5126         try {
5127             annotate.flush();
5128             attribModule(m);
5129         } catch (CompletionFailure ex) {
5130             chk.completionError(pos, ex);
5131         }
5132     }
5133 
5134     void attribModule(ModuleSymbol m) {
5135         // Get environment current at the point of module definition.
5136         Env&lt;AttrContext&gt; env = enter.typeEnvs.get(m);
5137         attribStat(env.tree, env);
5138     }
5139 
5140     /** Main method: attribute class definition associated with given class symbol.
5141      *  reporting completion failures at the given position.
5142      *  @param pos The source position at which completion errors are to be
5143      *             reported.
5144      *  @param c   The class symbol whose definition will be attributed.
5145      */
5146     public void attribClass(DiagnosticPosition pos, ClassSymbol c) {
5147         try {
5148             annotate.flush();
5149             attribClass(c);
5150         } catch (CompletionFailure ex) {
5151             chk.completionError(pos, ex);
5152         }
5153     }
5154 
5155     /** Attribute class definition associated with given class symbol.
5156      *  @param c   The class symbol whose definition will be attributed.
5157      */
5158     void attribClass(ClassSymbol c) throws CompletionFailure {
5159         if (c.type.hasTag(ERROR)) return;
5160 
5161         // Check for cycles in the inheritance graph, which can arise from
5162         // ill-formed class files.
5163         chk.checkNonCyclic(null, c.type);
5164 
5165         Type st = types.supertype(c.type);
5166         if ((c.flags_field &amp; Flags.COMPOUND) == 0) {
5167             // First, attribute superclass.
5168             if (st.hasTag(CLASS))
5169                 attribClass((ClassSymbol)st.tsym);
5170 
5171             // Next attribute owner, if it is a class.
5172             if (c.owner.kind == TYP &amp;&amp; c.owner.type.hasTag(CLASS))
5173                 attribClass((ClassSymbol)c.owner);
5174         }
5175 
5176         // The previous operations might have attributed the current class
5177         // if there was a cycle. So we test first whether the class is still
5178         // UNATTRIBUTED.
5179         if ((c.flags_field &amp; UNATTRIBUTED) != 0) {
5180             c.flags_field &amp;= ~UNATTRIBUTED;
5181 
5182             // Get environment current at the point of class definition.
5183             Env&lt;AttrContext&gt; env = typeEnvs.get(c);
5184 
5185             // The info.lint field in the envs stored in typeEnvs is deliberately uninitialized,
5186             // because the annotations were not available at the time the env was created. Therefore,
5187             // we look up the environment chain for the first enclosing environment for which the
5188             // lint value is set. Typically, this is the parent env, but might be further if there
5189             // are any envs created as a result of TypeParameter nodes.
5190             Env&lt;AttrContext&gt; lintEnv = env;
5191             while (lintEnv.info.lint == null)
5192                 lintEnv = lintEnv.next;
5193 
5194             // Having found the enclosing lint value, we can initialize the lint value for this class
5195             env.info.lint = lintEnv.info.lint.augment(c);
5196 
5197             Lint prevLint = chk.setLint(env.info.lint);
5198             JavaFileObject prev = log.useSource(c.sourcefile);
5199             ResultInfo prevReturnRes = env.info.returnResult;
5200 
5201             try {
5202                 deferredLintHandler.flush(env.tree);
5203                 env.info.returnResult = null;
5204                 // java.lang.Enum may not be subclassed by a non-enum
5205                 if (st.tsym == syms.enumSym &amp;&amp;
5206                     ((c.flags_field &amp; (Flags.ENUM|Flags.COMPOUND)) == 0))
5207                     log.error(env.tree.pos(), Errors.EnumNoSubclassing);
5208 
5209                 // Enums may not be extended by source-level classes
5210                 if (st.tsym != null &amp;&amp;
5211                     ((st.tsym.flags_field &amp; Flags.ENUM) != 0) &amp;&amp;
5212                     ((c.flags_field &amp; (Flags.ENUM | Flags.COMPOUND)) == 0)) {
5213                     log.error(env.tree.pos(), Errors.EnumTypesNotExtensible);
5214                 }
5215 
5216                 if (isSerializable(c.type)) {
5217                     env.info.isSerializable = true;
5218                 }
5219 
5220                 attribClassBody(env, c);
5221 
5222                 chk.checkDeprecatedAnnotation(env.tree.pos(), c);
5223                 chk.checkClassOverrideEqualsAndHashIfNeeded(env.tree.pos(), c);
5224                 chk.checkFunctionalInterface((JCClassDecl) env.tree, c);
5225                 chk.checkLeaksNotAccessible(env, (JCClassDecl) env.tree);
5226             } finally {
5227                 env.info.returnResult = prevReturnRes;
5228                 log.useSource(prev);
5229                 chk.setLint(prevLint);
5230             }
5231 
5232         }
5233     }
5234 
5235     public void visitImport(JCImport tree) {
5236         // nothing to do
5237     }
5238 
5239     public void visitModuleDef(JCModuleDecl tree) {
5240         tree.sym.completeUsesProvides();
5241         ModuleSymbol msym = tree.sym;
5242         Lint lint = env.outer.info.lint = env.outer.info.lint.augment(msym);
5243         Lint prevLint = chk.setLint(lint);
5244         chk.checkModuleName(tree);
5245         chk.checkDeprecatedAnnotation(tree, msym);
5246 
5247         try {
5248             deferredLintHandler.flush(tree.pos());
5249         } finally {
5250             chk.setLint(prevLint);
5251         }
5252     }
5253 
5254     /** Finish the attribution of a class. */
5255     private void attribClassBody(Env&lt;AttrContext&gt; env, ClassSymbol c) {
5256         JCClassDecl tree = (JCClassDecl)env.tree;
5257         Assert.check(c == tree.sym);
5258 
5259         // Validate type parameters, supertype and interfaces.
5260         attribStats(tree.typarams, env);
5261         if (!c.isAnonymous()) {
5262             //already checked if anonymous
5263             chk.validate(tree.typarams, env);
5264             chk.validate(tree.extending, env);
5265             chk.validate(tree.implementing, env);
5266         }
5267 
5268         c.markAbstractIfNeeded(types);
5269 
5270         // If this is a non-abstract class, check that it has no abstract
5271         // methods or unimplemented methods of an implemented interface.
5272         if ((c.flags() &amp; (ABSTRACT | INTERFACE)) == 0) {
5273             chk.checkAllDefined(tree.pos(), c);
5274         }
5275 
5276         if ((c.flags() &amp; ANNOTATION) != 0) {
5277             if (tree.implementing.nonEmpty())
5278                 log.error(tree.implementing.head.pos(),
5279                           Errors.CantExtendIntfAnnotation);
5280             if (tree.typarams.nonEmpty()) {
5281                 log.error(tree.typarams.head.pos(),
5282                           Errors.IntfAnnotationCantHaveTypeParams(c));
5283             }
5284 
5285             // If this annotation type has a @Repeatable, validate
5286             Attribute.Compound repeatable = c.getAnnotationTypeMetadata().getRepeatable();
5287             // If this annotation type has a @Repeatable, validate
5288             if (repeatable != null) {
5289                 // get diagnostic position for error reporting
5290                 DiagnosticPosition cbPos = getDiagnosticPosition(tree, repeatable.type);
5291                 Assert.checkNonNull(cbPos);
5292 
5293                 chk.validateRepeatable(c, repeatable, cbPos);
5294             }
5295         } else {
5296             // Check that all extended classes and interfaces
5297             // are compatible (i.e. no two define methods with same arguments
5298             // yet different return types).  (JLS 8.4.6.3)
5299             chk.checkCompatibleSupertypes(tree.pos(), c.type);
5300             if (allowDefaultMethods) {
5301                 chk.checkDefaultMethodClashes(tree.pos(), c.type);
5302             }
5303         }
5304 
5305         // Check that class does not import the same parameterized interface
5306         // with two different argument lists.
5307         chk.checkClassBounds(tree.pos(), c.type);
5308 
5309         tree.type = c.type;
5310 
5311         for (List&lt;JCTypeParameter&gt; l = tree.typarams;
5312              l.nonEmpty(); l = l.tail) {
5313              Assert.checkNonNull(env.info.scope.findFirst(l.head.name));
5314         }
5315 
5316         // Check that a generic class doesn&#39;t extend Throwable
5317         if (!c.type.allparams().isEmpty() &amp;&amp; types.isSubtype(c.type, syms.throwableType))
5318             log.error(tree.extending.pos(), Errors.GenericThrowable);
5319 
5320         // Check that all methods which implement some
5321         // method conform to the method they implement.
5322         chk.checkImplementations(tree);
5323 
5324         //check that a resource implementing AutoCloseable cannot throw InterruptedException
5325         checkAutoCloseable(tree.pos(), env, c.type);
5326 
5327         for (List&lt;JCTree&gt; l = tree.defs; l.nonEmpty(); l = l.tail) {
5328             // Attribute declaration
5329             attribStat(l.head, env);
5330             // Check that declarations in inner classes are not static (JLS 8.1.2)
5331             // Make an exception for static constants.
5332             if (c.owner.kind != PCK &amp;&amp;
5333                 ((c.flags() &amp; STATIC) == 0 || c.name == names.empty) &amp;&amp;
5334                 (TreeInfo.flags(l.head) &amp; (STATIC | INTERFACE)) != 0) {
5335                 Symbol sym = null;
5336                 if (l.head.hasTag(VARDEF)) sym = ((JCVariableDecl) l.head).sym;
5337                 if (sym == null ||
5338                     sym.kind != VAR ||
5339                     ((VarSymbol) sym).getConstValue() == null)
5340                     log.error(l.head.pos(), Errors.IclsCantHaveStaticDecl(c));
5341             }
5342         }
5343 
5344         // Check for cycles among non-initial constructors.
5345         chk.checkCyclicConstructors(tree);
5346 
5347         // Check for cycles among annotation elements.
5348         chk.checkNonCyclicElements(tree);
5349 
5350         // Check for proper use of serialVersionUID
5351         if (env.info.lint.isEnabled(LintCategory.SERIAL)
5352                 &amp;&amp; isSerializable(c.type)
5353                 &amp;&amp; (c.flags() &amp; (Flags.ENUM | Flags.INTERFACE)) == 0
5354                 &amp;&amp; !c.isAnonymous()) {
5355             checkSerialVersionUID(tree, c);
5356         }
5357         if (allowTypeAnnos) {
5358             // Correctly organize the positions of the type annotations
5359             typeAnnotations.organizeTypeAnnotationsBodies(tree);
5360 
5361             // Check type annotations applicability rules
5362             validateTypeAnnotations(tree, false);
5363         }
5364     }
5365         // where
5366         /** get a diagnostic position for an attribute of Type t, or null if attribute missing */
5367         private DiagnosticPosition getDiagnosticPosition(JCClassDecl tree, Type t) {
5368             for(List&lt;JCAnnotation&gt; al = tree.mods.annotations; !al.isEmpty(); al = al.tail) {
5369                 if (types.isSameType(al.head.annotationType.type, t))
5370                     return al.head.pos();
5371             }
5372 
5373             return null;
5374         }
5375 
5376         /** check if a type is a subtype of Serializable, if that is available. */
5377         boolean isSerializable(Type t) {
5378             try {
5379                 syms.serializableType.complete();
5380             }
5381             catch (CompletionFailure e) {
5382                 return false;
5383             }
5384             return types.isSubtype(t, syms.serializableType);
5385         }
5386 
5387         /** Check that an appropriate serialVersionUID member is defined. */
5388         private void checkSerialVersionUID(JCClassDecl tree, ClassSymbol c) {
5389 
5390             // check for presence of serialVersionUID
5391             VarSymbol svuid = null;
5392             for (Symbol sym : c.members().getSymbolsByName(names.serialVersionUID)) {
5393                 if (sym.kind == VAR) {
5394                     svuid = (VarSymbol)sym;
5395                     break;
5396                 }
5397             }
5398 
5399             if (svuid == null) {
5400                 log.warning(LintCategory.SERIAL,
5401                         tree.pos(), Warnings.MissingSVUID(c));
5402                 return;
5403             }
5404 
5405             // check that it is static final
5406             if ((svuid.flags() &amp; (STATIC | FINAL)) !=
5407                 (STATIC | FINAL))
5408                 log.warning(LintCategory.SERIAL,
5409                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ImproperSVUID(c));
5410 
5411             // check that it is long
5412             else if (!svuid.type.hasTag(LONG))
5413                 log.warning(LintCategory.SERIAL,
5414                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.LongSVUID(c));
5415 
5416             // check constant
5417             else if (svuid.getConstValue() == null)
5418                 log.warning(LintCategory.SERIAL,
5419                         TreeInfo.diagnosticPositionFor(svuid, tree), Warnings.ConstantSVUID(c));
5420         }
5421 
5422     private Type capture(Type type) {
5423         return types.capture(type);
5424     }
5425 
5426     private void setSyntheticVariableType(JCVariableDecl tree, Type type) {
5427         if (type.isErroneous()) {
5428             tree.vartype = make.at(Position.NOPOS).Erroneous();
5429         } else {
5430             tree.vartype = make.at(Position.NOPOS).Type(type);
5431         }
5432     }
5433 
5434     public void validateTypeAnnotations(JCTree tree, boolean sigOnly) {
5435         tree.accept(new TypeAnnotationsValidator(sigOnly));
5436     }
5437     //where
5438     private final class TypeAnnotationsValidator extends TreeScanner {
5439 
5440         private final boolean sigOnly;
5441         public TypeAnnotationsValidator(boolean sigOnly) {
5442             this.sigOnly = sigOnly;
5443         }
5444 
5445         public void visitAnnotation(JCAnnotation tree) {
5446             chk.validateTypeAnnotation(tree, false);
5447             super.visitAnnotation(tree);
5448         }
5449         public void visitAnnotatedType(JCAnnotatedType tree) {
5450             if (!tree.underlyingType.type.isErroneous()) {
5451                 super.visitAnnotatedType(tree);
5452             }
5453         }
5454         public void visitTypeParameter(JCTypeParameter tree) {
5455             chk.validateTypeAnnotations(tree.annotations, true);
5456             scan(tree.bounds);
5457             // Don&#39;t call super.
5458             // This is needed because above we call validateTypeAnnotation with
5459             // false, which would forbid annotations on type parameters.
5460             // super.visitTypeParameter(tree);
5461         }
5462         public void visitMethodDef(JCMethodDecl tree) {
5463             if (tree.recvparam != null &amp;&amp;
5464                     !tree.recvparam.vartype.type.isErroneous()) {
5465                 checkForDeclarationAnnotations(tree.recvparam.mods.annotations,
5466                         tree.recvparam.vartype.type.tsym);
5467             }
5468             if (tree.restype != null &amp;&amp; tree.restype.type != null) {
5469                 validateAnnotatedType(tree.restype, tree.restype.type);
5470             }
5471             if (sigOnly) {
5472                 scan(tree.mods);
5473                 scan(tree.restype);
5474                 scan(tree.typarams);
5475                 scan(tree.recvparam);
5476                 scan(tree.params);
5477                 scan(tree.thrown);
5478             } else {
5479                 scan(tree.defaultValue);
5480                 scan(tree.body);
5481             }
5482         }
5483         public void visitVarDef(final JCVariableDecl tree) {
5484             //System.err.println(&quot;validateTypeAnnotations.visitVarDef &quot; + tree);
5485             if (tree.sym != null &amp;&amp; tree.sym.type != null &amp;&amp; !tree.isImplicitlyTyped())
5486                 validateAnnotatedType(tree.vartype, tree.sym.type);
5487             scan(tree.mods);
5488             scan(tree.vartype);
5489             if (!sigOnly) {
5490                 scan(tree.init);
5491             }
5492         }
5493         public void visitTypeCast(JCTypeCast tree) {
5494             if (tree.clazz != null &amp;&amp; tree.clazz.type != null)
5495                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5496             super.visitTypeCast(tree);
5497         }
5498         public void visitTypeTest(JCInstanceOf tree) {
5499             if (tree.pattern != null &amp;&amp; !(tree.pattern instanceof JCPattern) &amp;&amp; tree.pattern.type != null)
5500                 validateAnnotatedType(tree.pattern, tree.pattern.type);
5501             super.visitTypeTest(tree);
5502         }
5503         public void visitNewClass(JCNewClass tree) {
5504             if (tree.clazz != null &amp;&amp; tree.clazz.type != null) {
5505                 if (tree.clazz.hasTag(ANNOTATED_TYPE)) {
5506                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.clazz).annotations,
5507                             tree.clazz.type.tsym);
5508                 }
5509                 if (tree.def != null) {
5510                     checkForDeclarationAnnotations(tree.def.mods.annotations, tree.clazz.type.tsym);
5511                 }
5512 
5513                 validateAnnotatedType(tree.clazz, tree.clazz.type);
5514             }
5515             super.visitNewClass(tree);
5516         }
5517         public void visitNewArray(JCNewArray tree) {
5518             if (tree.elemtype != null &amp;&amp; tree.elemtype.type != null) {
5519                 if (tree.elemtype.hasTag(ANNOTATED_TYPE)) {
5520                     checkForDeclarationAnnotations(((JCAnnotatedType) tree.elemtype).annotations,
5521                             tree.elemtype.type.tsym);
5522                 }
5523                 validateAnnotatedType(tree.elemtype, tree.elemtype.type);
5524             }
5525             super.visitNewArray(tree);
5526         }
5527         public void visitClassDef(JCClassDecl tree) {
5528             //System.err.println(&quot;validateTypeAnnotations.visitClassDef &quot; + tree);
5529             if (sigOnly) {
5530                 scan(tree.mods);
5531                 scan(tree.typarams);
5532                 scan(tree.extending);
5533                 scan(tree.implementing);
5534             }
5535             for (JCTree member : tree.defs) {
5536                 if (member.hasTag(Tag.CLASSDEF)) {
5537                     continue;
5538                 }
5539                 scan(member);
5540             }
5541         }
5542         public void visitBlock(JCBlock tree) {
5543             if (!sigOnly) {
5544                 scan(tree.stats);
5545             }
5546         }
5547 
5548         /* I would want to model this after
5549          * com.sun.tools.javac.comp.Check.Validator.visitSelectInternal(JCFieldAccess)
5550          * and override visitSelect and visitTypeApply.
5551          * However, we only set the annotated type in the top-level type
5552          * of the symbol.
5553          * Therefore, we need to override each individual location where a type
5554          * can occur.
5555          */
5556         private void validateAnnotatedType(final JCTree errtree, final Type type) {
5557             //System.err.println(&quot;Attr.validateAnnotatedType: &quot; + errtree + &quot; type: &quot; + type);
5558 
5559             if (type.isPrimitiveOrVoid()) {
5560                 return;
5561             }
5562 
5563             JCTree enclTr = errtree;
5564             Type enclTy = type;
5565 
5566             boolean repeat = true;
5567             while (repeat) {
5568                 if (enclTr.hasTag(TYPEAPPLY)) {
5569                     List&lt;Type&gt; tyargs = enclTy.getTypeArguments();
5570                     List&lt;JCExpression&gt; trargs = ((JCTypeApply)enclTr).getTypeArguments();
5571                     if (trargs.length() &gt; 0) {
5572                         // Nothing to do for diamonds
5573                         if (tyargs.length() == trargs.length()) {
5574                             for (int i = 0; i &lt; tyargs.length(); ++i) {
5575                                 validateAnnotatedType(trargs.get(i), tyargs.get(i));
5576                             }
5577                         }
5578                         // If the lengths don&#39;t match, it&#39;s either a diamond
5579                         // or some nested type that redundantly provides
5580                         // type arguments in the tree.
5581                     }
5582 
5583                     // Look at the clazz part of a generic type
5584                     enclTr = ((JCTree.JCTypeApply)enclTr).clazz;
5585                 }
5586 
5587                 if (enclTr.hasTag(SELECT)) {
5588                     enclTr = ((JCTree.JCFieldAccess)enclTr).getExpression();
5589                     if (enclTy != null &amp;&amp;
5590                             !enclTy.hasTag(NONE)) {
5591                         enclTy = enclTy.getEnclosingType();
5592                     }
5593                 } else if (enclTr.hasTag(ANNOTATED_TYPE)) {
5594                     JCAnnotatedType at = (JCTree.JCAnnotatedType) enclTr;
5595                     if (enclTy == null || enclTy.hasTag(NONE)) {
5596                         if (at.getAnnotations().size() == 1) {
5597                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping1(at.getAnnotations().head.attribute));
5598                         } else {
5599                             ListBuffer&lt;Attribute.Compound&gt; comps = new ListBuffer&lt;&gt;();
5600                             for (JCAnnotation an : at.getAnnotations()) {
5601                                 comps.add(an.attribute);
5602                             }
5603                             log.error(at.underlyingType.pos(), Errors.CantTypeAnnotateScoping(comps.toList()));
5604                         }
5605                         repeat = false;
5606                     }
5607                     enclTr = at.underlyingType;
5608                     // enclTy doesn&#39;t need to be changed
5609                 } else if (enclTr.hasTag(IDENT)) {
5610                     repeat = false;
5611                 } else if (enclTr.hasTag(JCTree.Tag.WILDCARD)) {
5612                     JCWildcard wc = (JCWildcard) enclTr;
5613                     if (wc.getKind() == JCTree.Kind.EXTENDS_WILDCARD ||
5614                             wc.getKind() == JCTree.Kind.SUPER_WILDCARD) {
5615                         validateAnnotatedType(wc.getBound(), wc.getBound().type);
5616                     } else {
5617                         // Nothing to do for UNBOUND
5618                     }
5619                     repeat = false;
5620                 } else if (enclTr.hasTag(TYPEARRAY)) {
5621                     JCArrayTypeTree art = (JCArrayTypeTree) enclTr;
5622                     validateAnnotatedType(art.getType(), art.elemtype.type);
5623                     repeat = false;
5624                 } else if (enclTr.hasTag(TYPEUNION)) {
5625                     JCTypeUnion ut = (JCTypeUnion) enclTr;
5626                     for (JCTree t : ut.getTypeAlternatives()) {
5627                         validateAnnotatedType(t, t.type);
5628                     }
5629                     repeat = false;
5630                 } else if (enclTr.hasTag(TYPEINTERSECTION)) {
5631                     JCTypeIntersection it = (JCTypeIntersection) enclTr;
5632                     for (JCTree t : it.getBounds()) {
5633                         validateAnnotatedType(t, t.type);
5634                     }
5635                     repeat = false;
5636                 } else if (enclTr.getKind() == JCTree.Kind.PRIMITIVE_TYPE ||
5637                            enclTr.getKind() == JCTree.Kind.ERRONEOUS) {
5638                     repeat = false;
5639                 } else {
5640                     Assert.error(&quot;Unexpected tree: &quot; + enclTr + &quot; with kind: &quot; + enclTr.getKind() +
5641                             &quot; within: &quot;+ errtree + &quot; with kind: &quot; + errtree.getKind());
5642                 }
5643             }
5644         }
5645 
5646         private void checkForDeclarationAnnotations(List&lt;? extends JCAnnotation&gt; annotations,
5647                 Symbol sym) {
5648             // Ensure that no declaration annotations are present.
5649             // Note that a tree type might be an AnnotatedType with
5650             // empty annotations, if only declaration annotations were given.
5651             // This method will raise an error for such a type.
5652             for (JCAnnotation ai : annotations) {
5653                 if (!ai.type.isErroneous() &amp;&amp;
5654                         typeAnnotations.annotationTargetType(ai.attribute, sym) == TypeAnnotations.AnnotationType.DECLARATION) {
5655                     log.error(ai.pos(), Errors.AnnotationTypeNotApplicableToType(ai.type));
5656                 }
5657             }
5658         }
5659     }
5660 
5661     // &lt;editor-fold desc=&quot;post-attribution visitor&quot;&gt;
5662 
5663     /**
5664      * Handle missing types/symbols in an AST. This routine is useful when
5665      * the compiler has encountered some errors (which might have ended up
5666      * terminating attribution abruptly); if the compiler is used in fail-over
5667      * mode (e.g. by an IDE) and the AST contains semantic errors, this routine
5668      * prevents NPE to be propagated during subsequent compilation steps.
5669      */
5670     public void postAttr(JCTree tree) {
5671         new PostAttrAnalyzer().scan(tree);
5672     }
5673 
5674     class PostAttrAnalyzer extends TreeScanner {
5675 
5676         private void initTypeIfNeeded(JCTree that) {
5677             if (that.type == null) {
5678                 if (that.hasTag(METHODDEF)) {
5679                     that.type = dummyMethodType((JCMethodDecl)that);
5680                 } else {
5681                     that.type = syms.unknownType;
5682                 }
5683             }
5684         }
5685 
5686         /* Construct a dummy method type. If we have a method declaration,
5687          * and the declared return type is void, then use that return type
5688          * instead of UNKNOWN to avoid spurious error messages in lambda
5689          * bodies (see:JDK-8041704).
5690          */
5691         private Type dummyMethodType(JCMethodDecl md) {
5692             Type restype = syms.unknownType;
5693             if (md != null &amp;&amp; md.restype != null &amp;&amp; md.restype.hasTag(TYPEIDENT)) {
5694                 JCPrimitiveTypeTree prim = (JCPrimitiveTypeTree)md.restype;
5695                 if (prim.typetag == VOID)
5696                     restype = syms.voidType;
5697             }
5698             return new MethodType(List.nil(), restype,
5699                                   List.nil(), syms.methodClass);
5700         }
5701         private Type dummyMethodType() {
5702             return dummyMethodType(null);
5703         }
5704 
5705         @Override
5706         public void scan(JCTree tree) {
5707             if (tree == null) return;
5708             if (tree instanceof JCExpression) {
5709                 initTypeIfNeeded(tree);
5710             }
5711             super.scan(tree);
5712         }
5713 
5714         @Override
5715         public void visitIdent(JCIdent that) {
5716             if (that.sym == null) {
5717                 that.sym = syms.unknownSymbol;
5718             }
5719         }
5720 
5721         @Override
5722         public void visitSelect(JCFieldAccess that) {
5723             if (that.sym == null) {
5724                 that.sym = syms.unknownSymbol;
5725             }
5726             super.visitSelect(that);
5727         }
5728 
5729         @Override
5730         public void visitClassDef(JCClassDecl that) {
5731             initTypeIfNeeded(that);
5732             if (that.sym == null) {
5733                 that.sym = new ClassSymbol(0, that.name, that.type, syms.noSymbol);
5734             }
5735             super.visitClassDef(that);
5736         }
5737 
5738         @Override
5739         public void visitMethodDef(JCMethodDecl that) {
5740             initTypeIfNeeded(that);
5741             if (that.sym == null) {
5742                 that.sym = new MethodSymbol(0, that.name, that.type, syms.noSymbol);
5743             }
5744             super.visitMethodDef(that);
5745         }
5746 
5747         @Override
5748         public void visitVarDef(JCVariableDecl that) {
5749             initTypeIfNeeded(that);
5750             if (that.sym == null) {
5751                 that.sym = new VarSymbol(0, that.name, that.type, syms.noSymbol);
5752                 that.sym.adr = 0;
5753             }
5754             if (that.vartype == null) {
5755                 that.vartype = make.at(Position.NOPOS).Erroneous();
5756             }
5757             super.visitVarDef(that);
5758         }
5759 
5760         @Override
5761         public void visitBindingPattern(JCBindingPattern that) {
5762             if (that.symbol == null) {
5763                 that.symbol = new BindingSymbol(that.name, that.type, syms.noSymbol);
5764                 that.symbol.adr = 0;
5765             }
5766             super.visitBindingPattern(that);
5767         }
5768 
5769         @Override
5770         public void visitNewClass(JCNewClass that) {
5771             if (that.constructor == null) {
5772                 that.constructor = new MethodSymbol(0, names.init,
5773                         dummyMethodType(), syms.noSymbol);
5774             }
5775             if (that.constructorType == null) {
5776                 that.constructorType = syms.unknownType;
5777             }
5778             super.visitNewClass(that);
5779         }
5780 
5781         @Override
5782         public void visitAssignop(JCAssignOp that) {
5783             if (that.operator == null) {
5784                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5785                         -1, syms.noSymbol);
5786             }
5787             super.visitAssignop(that);
5788         }
5789 
5790         @Override
5791         public void visitBinary(JCBinary that) {
5792             if (that.operator == null) {
5793                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5794                         -1, syms.noSymbol);
5795             }
5796             super.visitBinary(that);
5797         }
5798 
5799         @Override
5800         public void visitUnary(JCUnary that) {
5801             if (that.operator == null) {
5802                 that.operator = new OperatorSymbol(names.empty, dummyMethodType(),
5803                         -1, syms.noSymbol);
5804             }
5805             super.visitUnary(that);
5806         }
5807 
5808         @Override
5809         public void visitReference(JCMemberReference that) {
5810             super.visitReference(that);
5811             if (that.sym == null) {
5812                 that.sym = new MethodSymbol(0, names.empty, dummyMethodType(),
5813                         syms.noSymbol);
5814             }
5815         }
5816     }
5817     // &lt;/editor-fold&gt;
5818 
5819     public void setPackageSymbols(JCExpression pid, Symbol pkg) {
5820         new TreeScanner() {
5821             Symbol packge = pkg;
5822             @Override
5823             public void visitIdent(JCIdent that) {
5824                 that.sym = packge;
5825             }
5826 
5827             @Override
5828             public void visitSelect(JCFieldAccess that) {
5829                 that.sym = packge;
5830                 packge = packge.owner;
5831                 super.visitSelect(that);
5832             }
5833         }.scan(pid);
5834     }
5835 
5836 }
    </pre>
  </body>
</html>
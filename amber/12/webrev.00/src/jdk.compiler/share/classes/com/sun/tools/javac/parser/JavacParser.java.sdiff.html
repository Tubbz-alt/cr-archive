<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed

 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
<span class="line-modified"> 243     protected static final int NOINVOCATION = 0x20;</span>
 244 
 245     protected void selectExprMode() {
<span class="line-modified"> 246         //TODO: copy NOINVOCATION</span>
<span class="line-removed"> 247         mode = (mode &amp; NOLAMBDA) | EXPR;</span>
 248     }
 249 
 250     protected void selectTypeMode() {
<span class="line-modified"> 251         //TODO: copy NOINVOCATION</span>
<span class="line-removed"> 252         mode = (mode &amp; NOLAMBDA) | TYPE;</span>
 253     }
 254 
 255     /** The current mode.
 256      */
 257     protected int mode = 0;
 258 
 259     /** The mode of the term that was parsed last.
 260      */
 261     protected int lastmode = 0;
 262 
 263     /* ---------- token management -------------- */
 264 
 265     protected Token token;
 266 
 267     public Token token() {
 268         return token;
 269     }
 270 
 271     public void nextToken() {
 272         S.nextToken();
</pre>
<hr />
<pre>
 755     /** parses patterns.
 756      */
 757 
 758     public JCPattern parsePattern() {
 759         int pos = token.pos;
 760         if (token.kind == UNDERSCORE) {
 761             nextToken();
 762             return toP(F.at(pos).AnyPattern());
 763         } else if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 764             nextToken();
 765             return toP(F.at(pos).BindingPattern(ident(), null));
 766         } else {
 767             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 768             if (token.kind == LPAREN) {
 769                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 770                 do {
 771                     nextToken();
 772                     JCPattern nestedPattern = parsePattern();
 773                     nested.append(nestedPattern);
 774                 } while (token.kind == COMMA);
<span class="line-removed"> 775                 Name name = null;</span>
<span class="line-removed"> 776                 if (token.kind == IDENTIFIER) {</span>
<span class="line-removed"> 777                     name = ident();</span>
<span class="line-removed"> 778                 }</span>
 779                 accept(RPAREN);
<span class="line-modified"> 780                 return toP(F.at(pos).DeconstructionPattern(name, e, nested.toList()));</span>
 781             } else if (token.kind == IDENTIFIER) {
 782                 return toP(F.at(pos).BindingPattern(ident(), e));
 783             } else {
 784                 return toP(F.at(pos).LiteralPattern(e));
 785             }
 786         }
 787     }
 788 
 789     /**
 790      * parses (optional) type annotations followed by a type. If the
 791      * annotations are present before the type and are not consumed during array
 792      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 793      * these annotations and the underlying type. Otherwise, it returns the
 794      * underlying type.
 795      *
 796      * &lt;p&gt;
 797      *
 798      * Note that this method sets {@code mode} to {@code TYPE} first, before
 799      * parsing annotations.
 800      */
</pre>
<hr />
<pre>
 950      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 951      */
 952     JCExpression term2Rest(JCExpression t, int minprec) {
 953         JCExpression[] odStack = newOdStack();
 954         Token[] opStack = newOpStack();
 955 
 956         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 957         int top = 0;
 958         odStack[0] = t;
 959         int startPos = token.pos;
 960         Token topOp = Tokens.DUMMY;
 961         while (prec(token.kind) &gt;= minprec) {
 962             opStack[top] = topOp;
 963 
 964             if (token.kind == INSTANCEOF) {
 965                 int pos = token.pos;
 966                 nextToken();
 967                 JCTree pattern = parseType(true);
 968                 if (token.kind == IDENTIFIER) {
 969                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
<span class="line-modified"> 970                     if (pattern.hasTag(IDENT) &amp;&amp; isRestrictedTypeName(((JCIdent) pattern).name, pattern.pos, true)) {</span>
<span class="line-modified"> 971                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(((JCIdent) pattern).name, ((JCIdent) pattern).name == names.var ? Source.JDK10 : Source.JDK13));</span>

 972                         pattern = null;
 973                     }
 974                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 975                 } else if (token.kind == LPAREN) {

 976                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 977                     do {
 978                         nextToken();
 979                         JCPattern nestedPattern = parsePattern();
 980                         nested.append(nestedPattern);
 981                     } while (token.kind == COMMA);
<span class="line-removed"> 982                     Name name = null;</span>
<span class="line-removed"> 983                     if (token.kind == IDENTIFIER) {</span>
<span class="line-removed"> 984                         name = ident();</span>
<span class="line-removed"> 985                     }</span>
 986                     accept(RPAREN);
<span class="line-modified"> 987                     pattern = toP(F.at(pos).DeconstructionPattern(name, (JCExpression) pattern, nested.toList()));</span>
 988                 }
 989                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 990             } else {
 991                 topOp = token;
 992                 nextToken();
 993                 top++;
 994                 odStack[top] = term3();
 995             }
 996             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 997                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 998                 top--;
 999                 topOp = opStack[top];
1000             }
1001         }
1002         Assert.check(top == 0);
1003         t = odStack[0];
1004 
1005         if (t.hasTag(JCTree.Tag.PLUS)) {
1006             t = foldStrings(t);
1007         }
</pre>
<hr />
<pre>
2620         }
2621         case ABSTRACT: case STRICTFP: {
2622             dc = token.comment(CommentStyle.JAVADOC);
2623             JCModifiers mods = modifiersOpt();
2624             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2625         }
2626         case INTERFACE:
2627         case CLASS:
2628             dc = token.comment(CommentStyle.JAVADOC);
2629             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2630         case ENUM:
2631             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2632             dc = token.comment(CommentStyle.JAVADOC);
2633             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2634         case IDENTIFIER:
2635             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2636                 Token next = S.token(1);
2637                 boolean isYieldStatement;
2638                 switch (next.kind) {
2639                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<span class="line-modified">2640                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2641                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2642                     case NEW: case SWITCH: case THIS: case SUPER:
2643                         isYieldStatement = true;
2644                         break;
2645                     case PLUSPLUS: case SUBSUB:
2646                         isYieldStatement = S.token(2).kind != SEMI;
2647                         break;
2648                     case LPAREN:
2649                         int lookahead = 2;
2650                         int balance = 1;
2651                         boolean hasComma = false;
2652                         Token l;
2653                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2654                             switch (l.kind) {
2655                                 case LPAREN: balance++; break;
2656                                 case RPAREN: balance--; break;
2657                                 case COMMA: if (balance == 1) hasComma = true; break;
2658                             }
2659                             lookahead++;
2660                         }
</pre>
</td>
<td>
<hr />
<pre>
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
<span class="line-added"> 236      *     mode |= NOINVOCATION : method invocations are not allowed</span>
 237      */
 238     protected static final int EXPR = 0x1;
 239     protected static final int TYPE = 0x2;
 240     protected static final int NOPARAMS = 0x4;
 241     protected static final int TYPEARG = 0x8;
 242     protected static final int DIAMOND = 0x10;
 243     protected static final int NOLAMBDA = 0x20;
<span class="line-modified"> 244     protected static final int NOINVOCATION = 0x40;</span>
 245 
 246     protected void selectExprMode() {
<span class="line-modified"> 247         mode = (mode &amp; (NOLAMBDA | NOINVOCATION)) | EXPR;</span>

 248     }
 249 
 250     protected void selectTypeMode() {
<span class="line-modified"> 251         mode = (mode &amp; (NOLAMBDA|NOINVOCATION)) | TYPE;</span>

 252     }
 253 
 254     /** The current mode.
 255      */
 256     protected int mode = 0;
 257 
 258     /** The mode of the term that was parsed last.
 259      */
 260     protected int lastmode = 0;
 261 
 262     /* ---------- token management -------------- */
 263 
 264     protected Token token;
 265 
 266     public Token token() {
 267         return token;
 268     }
 269 
 270     public void nextToken() {
 271         S.nextToken();
</pre>
<hr />
<pre>
 754     /** parses patterns.
 755      */
 756 
 757     public JCPattern parsePattern() {
 758         int pos = token.pos;
 759         if (token.kind == UNDERSCORE) {
 760             nextToken();
 761             return toP(F.at(pos).AnyPattern());
 762         } else if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 763             nextToken();
 764             return toP(F.at(pos).BindingPattern(ident(), null));
 765         } else {
 766             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 767             if (token.kind == LPAREN) {
 768                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 769                 do {
 770                     nextToken();
 771                     JCPattern nestedPattern = parsePattern();
 772                     nested.append(nestedPattern);
 773                 } while (token.kind == COMMA);




 774                 accept(RPAREN);
<span class="line-modified"> 775                 return toP(F.at(pos).DeconstructionPattern(e, nested.toList()));</span>
 776             } else if (token.kind == IDENTIFIER) {
 777                 return toP(F.at(pos).BindingPattern(ident(), e));
 778             } else {
 779                 return toP(F.at(pos).LiteralPattern(e));
 780             }
 781         }
 782     }
 783 
 784     /**
 785      * parses (optional) type annotations followed by a type. If the
 786      * annotations are present before the type and are not consumed during array
 787      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 788      * these annotations and the underlying type. Otherwise, it returns the
 789      * underlying type.
 790      *
 791      * &lt;p&gt;
 792      *
 793      * Note that this method sets {@code mode} to {@code TYPE} first, before
 794      * parsing annotations.
 795      */
</pre>
<hr />
<pre>
 945      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 946      */
 947     JCExpression term2Rest(JCExpression t, int minprec) {
 948         JCExpression[] odStack = newOdStack();
 949         Token[] opStack = newOpStack();
 950 
 951         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 952         int top = 0;
 953         odStack[0] = t;
 954         int startPos = token.pos;
 955         Token topOp = Tokens.DUMMY;
 956         while (prec(token.kind) &gt;= minprec) {
 957             opStack[top] = topOp;
 958 
 959             if (token.kind == INSTANCEOF) {
 960                 int pos = token.pos;
 961                 nextToken();
 962                 JCTree pattern = parseType(true);
 963                 if (token.kind == IDENTIFIER) {
 964                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
<span class="line-modified"> 965                     Source source = restrictedTypeNameStartingAtSource(((JCIdent) pattern).name, pattern.pos, true);</span>
<span class="line-modified"> 966                     if (pattern.hasTag(IDENT) &amp;&amp; source != null) {</span>
<span class="line-added"> 967                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(((JCIdent) pattern).name, source));</span>
 968                         pattern = null;
 969                     }
 970                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 971                 } else if (token.kind == LPAREN) {
<span class="line-added"> 972                     checkSourceLevel(Feature.DECONSTRUCTION_PATTERNS);</span>
 973                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 974                     do {
 975                         nextToken();
 976                         JCPattern nestedPattern = parsePattern();
 977                         nested.append(nestedPattern);
 978                     } while (token.kind == COMMA);




 979                     accept(RPAREN);
<span class="line-modified"> 980                     pattern = toP(F.at(pattern).DeconstructionPattern((JCExpression) pattern, nested.toList()));</span>
 981                 }
 982                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 983             } else {
 984                 topOp = token;
 985                 nextToken();
 986                 top++;
 987                 odStack[top] = term3();
 988             }
 989             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 990                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 991                 top--;
 992                 topOp = opStack[top];
 993             }
 994         }
 995         Assert.check(top == 0);
 996         t = odStack[0];
 997 
 998         if (t.hasTag(JCTree.Tag.PLUS)) {
 999             t = foldStrings(t);
1000         }
</pre>
<hr />
<pre>
2613         }
2614         case ABSTRACT: case STRICTFP: {
2615             dc = token.comment(CommentStyle.JAVADOC);
2616             JCModifiers mods = modifiersOpt();
2617             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2618         }
2619         case INTERFACE:
2620         case CLASS:
2621             dc = token.comment(CommentStyle.JAVADOC);
2622             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2623         case ENUM:
2624             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2625             dc = token.comment(CommentStyle.JAVADOC);
2626             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2627         case IDENTIFIER:
2628             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2629                 Token next = S.token(1);
2630                 boolean isYieldStatement;
2631                 switch (next.kind) {
2632                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
<span class="line-modified">2633                     case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:</span>
2634                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2635                     case NEW: case SWITCH: case THIS: case SUPER:
2636                         isYieldStatement = true;
2637                         break;
2638                     case PLUSPLUS: case SUBSUB:
2639                         isYieldStatement = S.token(2).kind != SEMI;
2640                         break;
2641                     case LPAREN:
2642                         int lookahead = 2;
2643                         int balance = 1;
2644                         boolean hasComma = false;
2645                         Token l;
2646                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2647                             switch (l.kind) {
2648                                 case LPAREN: balance++; break;
2649                                 case RPAREN: balance--; break;
2650                                 case COMMA: if (balance == 1) hasComma = true; break;
2651                             }
2652                             lookahead++;
2653                         }
</pre>
</td>
</tr>
</table>
<center><a href="JavaTokenizer.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="../processing/JavacProcessingEnvironment.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
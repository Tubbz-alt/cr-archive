<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1999, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.parser;
  27 
  28 import java.util.*;
  29 import java.util.function.Function;
  30 import java.util.stream.Collectors;
  31 
  32 import com.sun.source.tree.CaseTree;
  33 import com.sun.source.tree.MemberReferenceTree.ReferenceMode;
  34 import com.sun.source.tree.ModuleTree.ModuleKind;
  35 
  36 import com.sun.tools.javac.code.*;
  37 import com.sun.tools.javac.code.Source.Feature;
  38 import com.sun.tools.javac.parser.Tokens.*;
  39 import com.sun.tools.javac.parser.Tokens.Comment.CommentStyle;
  40 import com.sun.tools.javac.resources.CompilerProperties.Errors;
  41 import com.sun.tools.javac.resources.CompilerProperties.Fragments;
  42 import com.sun.tools.javac.resources.CompilerProperties.Warnings;
  43 import com.sun.tools.javac.tree.*;
  44 import com.sun.tools.javac.tree.JCTree.*;
  45 import com.sun.tools.javac.util.*;
  46 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticFlag;
  47 import com.sun.tools.javac.util.JCDiagnostic.Error;
  48 import com.sun.tools.javac.util.JCDiagnostic.Fragment;
  49 import com.sun.tools.javac.util.List;
  50 
  51 import static com.sun.tools.javac.parser.Tokens.TokenKind.*;
  52 import static com.sun.tools.javac.parser.Tokens.TokenKind.ASSERT;
  53 import static com.sun.tools.javac.parser.Tokens.TokenKind.CASE;
  54 import static com.sun.tools.javac.parser.Tokens.TokenKind.CATCH;
  55 import static com.sun.tools.javac.parser.Tokens.TokenKind.EQ;
  56 import static com.sun.tools.javac.parser.Tokens.TokenKind.GT;
  57 import static com.sun.tools.javac.parser.Tokens.TokenKind.IMPORT;
  58 import static com.sun.tools.javac.parser.Tokens.TokenKind.LT;
  59 import static com.sun.tools.javac.tree.JCTree.Tag.*;
  60 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.ImplicitAndExplicitNotAllowed;
  61 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndExplicitNotAllowed;
  62 import static com.sun.tools.javac.resources.CompilerProperties.Fragments.VarAndImplicitNotAllowed;
  63 
  64 /** The parser maps a token sequence into an abstract syntax
  65  *  tree. It operates by recursive descent, with code derived
  66  *  systematically from an LL(1) grammar. For efficiency reasons, an
  67  *  operator precedence scheme is used for parsing binary operation
  68  *  expressions.
  69  *
  70  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  71  *  If you write code that depends on this, you do so at your own risk.
  72  *  This code and its internal interfaces are subject to change or
  73  *  deletion without notice.&lt;/b&gt;
  74  */
  75 public class JavacParser implements Parser {
  76 
  77     /** The number of precedence levels of infix operators.
  78      */
  79     private static final int infixPrecedenceLevels = 10;
  80 
  81     /** Is the parser instantiated to parse a module-info file ?
  82      */
  83     private final boolean parseModuleInfo;
  84 
  85     /** The scanner used for lexical analysis.
  86      */
  87     protected Lexer S;
  88 
  89     /** The factory to be used for abstract syntax tree construction.
  90      */
  91     protected TreeMaker F;
  92 
  93     /** The log to be used for error diagnostics.
  94      */
  95     private Log log;
  96 
  97     /** The Source language setting. */
  98     private Source source;
  99 
 100     /** The Preview language setting. */
 101     private Preview preview;
 102 
 103     /** The name table. */
 104     private Names names;
 105 
 106     /** End position mappings container */
 107     protected final AbstractEndPosTable endPosTable;
 108 
 109     // Because of javac&#39;s limited lookahead, some contexts are ambiguous in
 110     // the presence of type annotations even though they are not ambiguous
 111     // in the absence of type annotations.  Consider this code:
 112     //   void m(String [] m) { }
 113     //   void m(String ... m) { }
 114     // After parsing &quot;String&quot;, javac calls bracketsOpt which immediately
 115     // returns if the next character is not &#39;[&#39;.  Similarly, javac can see
 116     // if the next token is ... and in that case parse an ellipsis.  But in
 117     // the presence of type annotations:
 118     //   void m(String @A [] m) { }
 119     //   void m(String @A ... m) { }
 120     // no finite lookahead is enough to determine whether to read array
 121     // levels or an ellipsis.  Furthermore, if you call bracketsOpt, then
 122     // bracketsOpt first reads all the leading annotations and only then
 123     // discovers that it needs to fail.  bracketsOpt needs a way to push
 124     // back the extra annotations that it read.  (But, bracketsOpt should
 125     // not *always* be allowed to push back extra annotations that it finds
 126     // -- in most contexts, any such extra annotation is an error.
 127     //
 128     // The following two variables permit type annotations that have
 129     // already been read to be stored for later use.  Alternate
 130     // implementations are possible but would cause much larger changes to
 131     // the parser.
 132 
 133     /** Type annotations that have already been read but have not yet been used. **/
 134     private List&lt;JCAnnotation&gt; typeAnnotationsPushedBack = List.nil();
 135 
 136     /**
 137      * If the parser notices extra annotations, then it either immediately
 138      * issues an error (if this variable is false) or places the extra
 139      * annotations in variable typeAnnotationsPushedBack (if this variable
 140      * is true).
 141      */
 142     private boolean permitTypeAnnotationsPushBack = false;
 143 
 144     interface ErrorRecoveryAction {
 145         JCTree doRecover(JavacParser parser);
 146     }
 147 
 148     enum BasicErrorRecoveryAction implements ErrorRecoveryAction {
 149         BLOCK_STMT {public JCTree doRecover(JavacParser parser) { return parser.parseStatementAsBlock(); }},
 150         CATCH_CLAUSE {public JCTree doRecover(JavacParser parser) { return parser.catchClause(); }}
 151     }
 152 
 153     /** Construct a parser from a given scanner, tree factory and log.
 154      */
 155     protected JavacParser(ParserFactory fac,
 156                           Lexer S,
 157                           boolean keepDocComments,
 158                           boolean keepLineMap,
 159                           boolean keepEndPositions) {
 160         this(fac, S, keepDocComments, keepLineMap, keepEndPositions, false);
 161 
 162     }
 163     /** Construct a parser from a given scanner, tree factory and log.
 164      */
 165     protected JavacParser(ParserFactory fac,
 166                      Lexer S,
 167                      boolean keepDocComments,
 168                      boolean keepLineMap,
 169                      boolean keepEndPositions,
 170                      boolean parseModuleInfo) {
 171         this.S = S;
 172         nextToken(); // prime the pump
 173         this.F = fac.F;
 174         this.log = fac.log;
 175         this.names = fac.names;
 176         this.source = fac.source;
 177         this.preview = fac.preview;
 178         this.allowStringFolding = fac.options.getBoolean(&quot;allowStringFolding&quot;, true);
 179         this.keepDocComments = keepDocComments;
 180         this.parseModuleInfo = parseModuleInfo;
 181         docComments = newDocCommentTable(keepDocComments, fac);
 182         this.keepLineMap = keepLineMap;
 183         this.errorTree = F.Erroneous();
 184         endPosTable = newEndPosTable(keepEndPositions);
 185         this.allowYieldStatement = (!preview.isPreview(Feature.SWITCH_EXPRESSION) || preview.isEnabled()) &amp;&amp;
 186                 Feature.SWITCH_EXPRESSION.allowedInSource(source);
 187         this.allowRecords = (!preview.isPreview(Feature.RECORDS) || preview.isEnabled()) &amp;&amp;
 188                 Feature.RECORDS.allowedInSource(source);
 189     }
 190 
 191     protected AbstractEndPosTable newEndPosTable(boolean keepEndPositions) {
 192         return  keepEndPositions
 193                 ? new SimpleEndPosTable(this)
 194                 : new EmptyEndPosTable(this);
 195     }
 196 
 197     protected DocCommentTable newDocCommentTable(boolean keepDocComments, ParserFactory fac) {
 198         return keepDocComments ? new LazyDocCommentTable(fac) : null;
 199     }
 200 
 201     /** Switch: should we fold strings?
 202      */
 203     boolean allowStringFolding;
 204 
 205     /** Switch: should we keep docComments?
 206      */
 207     boolean keepDocComments;
 208 
 209     /** Switch: should we keep line table?
 210      */
 211     boolean keepLineMap;
 212 
 213     /** Switch: is &quot;this&quot; allowed as an identifier?
 214      * This is needed to parse receiver types.
 215      */
 216     boolean allowThisIdent;
 217 
 218     /** Switch: is yield statement allowed in this source level?
 219      */
 220     boolean allowYieldStatement;
 221 
 222     /** Switch: are records allowed in this source level?
 223      */
 224     boolean allowRecords;
 225 
 226     /** The type of the method receiver, as specified by a first &quot;this&quot; parameter.
 227      */
 228     JCVariableDecl receiverParam;
 229 
 230     /** When terms are parsed, the mode determines which is expected:
 231      *     mode = EXPR        : an expression
 232      *     mode = TYPE        : a type
 233      *     mode = NOPARAMS    : no parameters allowed for type
 234      *     mode = TYPEARG     : type argument
 235      *     mode |= NOLAMBDA   : lambdas are not allowed
 236      */
 237     protected static final int EXPR = 0x1;
 238     protected static final int TYPE = 0x2;
 239     protected static final int NOPARAMS = 0x4;
 240     protected static final int TYPEARG = 0x8;
 241     protected static final int DIAMOND = 0x10;
 242     protected static final int NOLAMBDA = 0x20;
 243     protected static final int NOINVOCATION = 0x20;
 244 
 245     protected void selectExprMode() {
 246         //TODO: copy NOINVOCATION
 247         mode = (mode &amp; NOLAMBDA) | EXPR;
 248     }
 249 
 250     protected void selectTypeMode() {
 251         //TODO: copy NOINVOCATION
 252         mode = (mode &amp; NOLAMBDA) | TYPE;
 253     }
 254 
 255     /** The current mode.
 256      */
 257     protected int mode = 0;
 258 
 259     /** The mode of the term that was parsed last.
 260      */
 261     protected int lastmode = 0;
 262 
 263     /* ---------- token management -------------- */
 264 
 265     protected Token token;
 266 
 267     public Token token() {
 268         return token;
 269     }
 270 
 271     public void nextToken() {
 272         S.nextToken();
 273         token = S.token();
 274     }
 275 
 276     protected boolean peekToken(Filter&lt;TokenKind&gt; tk) {
 277         return peekToken(0, tk);
 278     }
 279 
 280     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk) {
 281         return tk.accepts(S.token(lookahead + 1).kind);
 282     }
 283 
 284     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 285         return peekToken(0, tk1, tk2);
 286     }
 287 
 288     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2) {
 289         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 290                 tk2.accepts(S.token(lookahead + 2).kind);
 291     }
 292 
 293     protected boolean peekToken(Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 294         return peekToken(0, tk1, tk2, tk3);
 295     }
 296 
 297     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt; tk1, Filter&lt;TokenKind&gt; tk2, Filter&lt;TokenKind&gt; tk3) {
 298         return tk1.accepts(S.token(lookahead + 1).kind) &amp;&amp;
 299                 tk2.accepts(S.token(lookahead + 2).kind) &amp;&amp;
 300                 tk3.accepts(S.token(lookahead + 3).kind);
 301     }
 302 
 303     @SuppressWarnings(&quot;unchecked&quot;)
 304     protected boolean peekToken(Filter&lt;TokenKind&gt;... kinds) {
 305         return peekToken(0, kinds);
 306     }
 307 
 308     @SuppressWarnings(&quot;unchecked&quot;)
 309     protected boolean peekToken(int lookahead, Filter&lt;TokenKind&gt;... kinds) {
 310         for (; lookahead &lt; kinds.length ; lookahead++) {
 311             if (!kinds[lookahead].accepts(S.token(lookahead + 1).kind)) {
 312                 return false;
 313             }
 314         }
 315         return true;
 316     }
 317 
 318     /* ---------- error recovery -------------- */
 319 
 320     private JCErroneous errorTree;
 321 
 322     /** Skip forward until a suitable stop token is found.
 323      */
 324     protected void skip(boolean stopAtImport, boolean stopAtMemberDecl, boolean stopAtIdentifier, boolean stopAtStatement) {
 325          while (true) {
 326              switch (token.kind) {
 327                 case SEMI:
 328                     nextToken();
 329                     return;
 330                 case PUBLIC:
 331                 case FINAL:
 332                 case ABSTRACT:
 333                 case MONKEYS_AT:
 334                 case EOF:
 335                 case CLASS:
 336                 case INTERFACE:
 337                 case ENUM:
 338                     return;
 339                 case IMPORT:
 340                     if (stopAtImport)
 341                         return;
 342                     break;
 343                 case LBRACE:
 344                 case RBRACE:
 345                 case PRIVATE:
 346                 case PROTECTED:
 347                 case STATIC:
 348                 case TRANSIENT:
 349                 case NATIVE:
 350                 case VOLATILE:
 351                 case SYNCHRONIZED:
 352                 case STRICTFP:
 353                 case LT:
 354                 case BYTE:
 355                 case SHORT:
 356                 case CHAR:
 357                 case INT:
 358                 case LONG:
 359                 case FLOAT:
 360                 case DOUBLE:
 361                 case BOOLEAN:
 362                 case VOID:
 363                     if (stopAtMemberDecl)
 364                         return;
 365                     break;
 366                 case UNDERSCORE:
 367                 case IDENTIFIER:
 368                    if (stopAtIdentifier)
 369                         return;
 370                     break;
 371                 case CASE:
 372                 case DEFAULT:
 373                 case IF:
 374                 case FOR:
 375                 case WHILE:
 376                 case DO:
 377                 case TRY:
 378                 case SWITCH:
 379                 case RETURN:
 380                 case THROW:
 381                 case BREAK:
 382                 case CONTINUE:
 383                 case ELSE:
 384                 case FINALLY:
 385                 case CATCH:
 386                 case THIS:
 387                 case SUPER:
 388                 case NEW:
 389                     if (stopAtStatement)
 390                         return;
 391                     break;
 392                 case ASSERT:
 393                     if (stopAtStatement)
 394                         return;
 395                     break;
 396             }
 397             nextToken();
 398         }
 399     }
 400 
 401     protected JCErroneous syntaxError(int pos, Error errorKey) {
 402         return syntaxError(pos, List.nil(), errorKey);
 403     }
 404 
 405     protected JCErroneous syntaxError(int pos, List&lt;JCTree&gt; errs, Error errorKey) {
 406         setErrorEndPos(pos);
 407         JCErroneous err = F.at(pos).Erroneous(errs);
 408         reportSyntaxError(err, errorKey);
 409         if (errs != null) {
 410             JCTree last = errs.last();
 411             if (last != null)
 412                 storeEnd(last, pos);
 413         }
 414         return toP(err);
 415     }
 416 
 417     private static final int RECOVERY_THRESHOLD = 50;
 418     private int errorPos = Position.NOPOS;
 419     private int count = 0;
 420 
 421     /**
 422      * Report a syntax using the given the position parameter and arguments,
 423      * unless one was already reported at the same position.
 424      */
 425     protected void reportSyntaxError(int pos, Error errorKey) {
 426         JCDiagnostic.DiagnosticPosition diag = new JCDiagnostic.SimpleDiagnosticPosition(pos);
 427         reportSyntaxError(diag, errorKey);
 428     }
 429 
 430     /**
 431      * Report a syntax error using the given DiagnosticPosition object and
 432      * arguments, unless one was already reported at the same position.
 433      */
 434     protected void reportSyntaxError(JCDiagnostic.DiagnosticPosition diagPos, Error errorKey) {
 435         int pos = diagPos.getPreferredPosition();
 436         if (pos &gt; S.errPos() || pos == Position.NOPOS) {
 437             if (token.kind == EOF) {
 438                 log.error(DiagnosticFlag.SYNTAX, diagPos, Errors.PrematureEof);
 439             } else {
 440                 log.error(DiagnosticFlag.SYNTAX, diagPos, errorKey);
 441             }
 442         }
 443         S.errPos(pos);
 444         if (token.pos == errorPos) {
 445             //check for a possible infinite loop in parsing:
 446             Assert.check(count++ &lt; RECOVERY_THRESHOLD);
 447         } else {
 448             count = 0;
 449             errorPos = token.pos;
 450         }
 451     }
 452 
 453     /** If next input token matches given token, skip it, otherwise report
 454      *  an error.
 455      */
 456     public void accept(TokenKind tk) {
 457         accept(tk, Errors::Expected);
 458     }
 459 
 460     /** If next input token matches given token, skip it, otherwise report
 461      *  an error.
 462      */
 463     public void accept(TokenKind tk, Function&lt;TokenKind, Error&gt; errorProvider) {
 464         if (token.kind == tk) {
 465             nextToken();
 466         } else {
 467             setErrorEndPos(token.pos);
 468             reportSyntaxError(S.prevToken().endPos, errorProvider.apply(tk));
 469         }
 470     }
 471 
 472     /** Report an illegal start of expression/type error at given position.
 473      */
 474     JCExpression illegal(int pos) {
 475         setErrorEndPos(pos);
 476         if ((mode &amp; EXPR) != 0)
 477             return syntaxError(pos, Errors.IllegalStartOfExpr);
 478         else
 479             return syntaxError(pos, Errors.IllegalStartOfType);
 480 
 481     }
 482 
 483     /** Report an illegal start of expression/type error at current position.
 484      */
 485     JCExpression illegal() {
 486         return illegal(token.pos);
 487     }
 488 
 489     /** Diagnose a modifier flag from the set, if any. */
 490     protected void checkNoMods(long mods) {
 491         if (mods != 0) {
 492             long lowestMod = mods &amp; -mods;
 493             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ModNotAllowedHere(Flags.asFlagSet(lowestMod)));
 494         }
 495     }
 496 
 497 /* ---------- doc comments --------- */
 498 
 499     /** A table to store all documentation comments
 500      *  indexed by the tree nodes they refer to.
 501      *  defined only if option flag keepDocComment is set.
 502      */
 503     private final DocCommentTable docComments;
 504 
 505     /** Make an entry into docComments hashtable,
 506      *  provided flag keepDocComments is set and given doc comment is non-null.
 507      *  @param tree   The tree to be used as index in the hashtable
 508      *  @param dc     The doc comment to associate with the tree, or null.
 509      */
 510     protected void attach(JCTree tree, Comment dc) {
 511         if (keepDocComments &amp;&amp; dc != null) {
 512 //          System.out.println(&quot;doc comment = &quot;);System.out.println(dc);//DEBUG
 513             docComments.putComment(tree, dc);
 514         }
 515     }
 516 
 517 /* -------- source positions ------- */
 518 
 519     protected void setErrorEndPos(int errPos) {
 520         endPosTable.setErrorEndPos(errPos);
 521     }
 522 
 523     protected void storeEnd(JCTree tree, int endpos) {
 524         endPosTable.storeEnd(tree, endpos);
 525     }
 526 
 527     protected &lt;T extends JCTree&gt; T to(T t) {
 528         return endPosTable.to(t);
 529     }
 530 
 531     protected &lt;T extends JCTree&gt; T toP(T t) {
 532         return endPosTable.toP(t);
 533     }
 534 
 535     /** Get the start position for a tree node.  The start position is
 536      * defined to be the position of the first character of the first
 537      * token of the node&#39;s source text.
 538      * @param tree  The tree node
 539      */
 540     public int getStartPos(JCTree tree) {
 541         return TreeInfo.getStartPos(tree);
 542     }
 543 
 544     /**
 545      * Get the end position for a tree node.  The end position is
 546      * defined to be the position of the last character of the last
 547      * token of the node&#39;s source text.  Returns Position.NOPOS if end
 548      * positions are not generated or the position is otherwise not
 549      * found.
 550      * @param tree  The tree node
 551      */
 552     public int getEndPos(JCTree tree) {
 553         return endPosTable.getEndPos(tree);
 554     }
 555 
 556 
 557 
 558 /* ---------- parsing -------------- */
 559 
 560     /**
 561      * Ident = IDENTIFIER
 562      */
 563     public Name ident() {
 564         return ident(false);
 565     }
 566 
 567     protected Name ident(boolean advanceOnErrors) {
 568         if (token.kind == IDENTIFIER) {
 569             Name name = token.name();
 570             nextToken();
 571             return name;
 572         } else if (token.kind == ASSERT) {
 573             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.AssertAsIdentifier);
 574             nextToken();
 575             return names.error;
 576         } else if (token.kind == ENUM) {
 577             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.EnumAsIdentifier);
 578             nextToken();
 579             return names.error;
 580         } else if (token.kind == THIS) {
 581             if (allowThisIdent) {
 582                 // Make sure we&#39;re using a supported source version.
 583                 checkSourceLevel(Feature.TYPE_ANNOTATIONS);
 584                 Name name = token.name();
 585                 nextToken();
 586                 return name;
 587             } else {
 588                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ThisAsIdentifier);
 589                 nextToken();
 590                 return names.error;
 591             }
 592         } else if (token.kind == UNDERSCORE) {
 593             if (Feature.UNDERSCORE_IDENTIFIER.allowedInSource(source)) {
 594                 log.warning(token.pos, Warnings.UnderscoreAsIdentifier);
 595             } else {
 596                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.UnderscoreAsIdentifier);
 597             }
 598             Name name = token.name();
 599             nextToken();
 600             return name;
 601         } else {
 602             accept(IDENTIFIER);
 603             if (advanceOnErrors) {
 604                 nextToken();
 605             }
 606             return names.error;
 607         }
 608     }
 609 
 610     /**
 611      * Qualident = Ident { DOT [Annotations] Ident }
 612      */
 613     public JCExpression qualident(boolean allowAnnos) {
 614         JCExpression t = toP(F.at(token.pos).Ident(ident()));
 615         while (token.kind == DOT) {
 616             int pos = token.pos;
 617             nextToken();
 618             List&lt;JCAnnotation&gt; tyannos = null;
 619             if (allowAnnos) {
 620                 tyannos = typeAnnotationsOpt();
 621             }
 622             t = toP(F.at(pos).Select(t, ident()));
 623             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
 624                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
 625             }
 626         }
 627         return t;
 628     }
 629 
 630     JCExpression literal(Name prefix) {
 631         return literal(prefix, token.pos);
 632     }
 633 
 634     /**
 635      * Literal =
 636      *     INTLITERAL
 637      *   | LONGLITERAL
 638      *   | FLOATLITERAL
 639      *   | DOUBLELITERAL
 640      *   | CHARLITERAL
 641      *   | STRINGLITERAL
 642      *   | TRUE
 643      *   | FALSE
 644      *   | NULL
 645      */
 646     JCExpression literal(Name prefix, int pos) {
 647         JCExpression t = errorTree;
 648         switch (token.kind) {
 649         case INTLITERAL:
 650             try {
 651                 t = F.at(pos).Literal(
 652                     TypeTag.INT,
 653                     Convert.string2int(strval(prefix), token.radix()));
 654             } catch (NumberFormatException ex) {
 655                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 656             }
 657             break;
 658         case LONGLITERAL:
 659             try {
 660                 t = F.at(pos).Literal(
 661                     TypeTag.LONG,
 662                     Long.valueOf(Convert.string2long(strval(prefix), token.radix())));
 663             } catch (NumberFormatException ex) {
 664                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.IntNumberTooLarge(strval(prefix)));
 665             }
 666             break;
 667         case FLOATLITERAL: {
 668             String proper = token.radix() == 16 ?
 669                     (&quot;0x&quot;+ token.stringVal()) :
 670                     token.stringVal();
 671             Float n;
 672             try {
 673                 n = Float.valueOf(proper);
 674             } catch (NumberFormatException ex) {
 675                 // error already reported in scanner
 676                 n = Float.NaN;
 677             }
 678             if (n.floatValue() == 0.0f &amp;&amp; !isZero(proper))
 679                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 680             else if (n.floatValue() == Float.POSITIVE_INFINITY)
 681                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 682             else
 683                 t = F.at(pos).Literal(TypeTag.FLOAT, n);
 684             break;
 685         }
 686         case DOUBLELITERAL: {
 687             String proper = token.radix() == 16 ?
 688                     (&quot;0x&quot;+ token.stringVal()) :
 689                     token.stringVal();
 690             Double n;
 691             try {
 692                 n = Double.valueOf(proper);
 693             } catch (NumberFormatException ex) {
 694                 // error already reported in scanner
 695                 n = Double.NaN;
 696             }
 697             if (n.doubleValue() == 0.0d &amp;&amp; !isZero(proper))
 698                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooSmall);
 699             else if (n.doubleValue() == Double.POSITIVE_INFINITY)
 700                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.FpNumberTooLarge);
 701             else
 702                 t = F.at(pos).Literal(TypeTag.DOUBLE, n);
 703             break;
 704         }
 705         case CHARLITERAL:
 706             t = F.at(pos).Literal(
 707                 TypeTag.CHAR,
 708                 token.stringVal().charAt(0) + 0);
 709             break;
 710         case STRINGLITERAL:
 711             t = F.at(pos).Literal(
 712                 TypeTag.CLASS,
 713                 token.stringVal());
 714             break;
 715         case TRUE: case FALSE:
 716             t = F.at(pos).Literal(
 717                 TypeTag.BOOLEAN,
 718                 (token.kind == TRUE ? 1 : 0));
 719             break;
 720         case NULL:
 721             t = F.at(pos).Literal(
 722                 TypeTag.BOT,
 723                 null);
 724             break;
 725         default:
 726             Assert.error();
 727         }
 728         if (t == errorTree)
 729             t = F.at(pos).Erroneous();
 730         storeEnd(t, token.endPos);
 731         nextToken();
 732         return t;
 733     }
 734     //where
 735         boolean isZero(String s) {
 736             char[] cs = s.toCharArray();
 737             int base = ((cs.length &gt; 1 &amp;&amp; Character.toLowerCase(cs[1]) == &#39;x&#39;) ? 16 : 10);
 738             int i = ((base==16) ? 2 : 0);
 739             while (i &lt; cs.length &amp;&amp; (cs[i] == &#39;0&#39; || cs[i] == &#39;.&#39;)) i++;
 740             return !(i &lt; cs.length &amp;&amp; (Character.digit(cs[i], base) &gt; 0));
 741         }
 742 
 743         String strval(Name prefix) {
 744             String s = token.stringVal();
 745             return prefix.isEmpty() ? s : prefix + s;
 746         }
 747 
 748     /** terms can be either expressions or types.
 749      */
 750     public JCExpression parseExpression() {
 751         return term(EXPR);
 752     }
 753 
 754 
 755     /** parses patterns.
 756      */
 757 
 758     public JCPattern parsePattern() {
 759         int pos = token.pos;
 760         if (token.kind == UNDERSCORE) {
 761             nextToken();
 762             return toP(F.at(pos).AnyPattern());
 763         } else if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.var) {
 764             nextToken();
 765             return toP(F.at(pos).BindingPattern(ident(), null));
 766         } else {
 767             JCExpression e = term(EXPR | TYPE | NOLAMBDA | NOINVOCATION);
 768             if (token.kind == LPAREN) {
 769                 ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 770                 do {
 771                     nextToken();
 772                     JCPattern nestedPattern = parsePattern();
 773                     nested.append(nestedPattern);
 774                 } while (token.kind == COMMA);
 775                 Name name = null;
 776                 if (token.kind == IDENTIFIER) {
 777                     name = ident();
 778                 }
 779                 accept(RPAREN);
 780                 return toP(F.at(pos).DeconstructionPattern(name, e, nested.toList()));
 781             } else if (token.kind == IDENTIFIER) {
 782                 return toP(F.at(pos).BindingPattern(ident(), e));
 783             } else {
 784                 return toP(F.at(pos).LiteralPattern(e));
 785             }
 786         }
 787     }
 788 
 789     /**
 790      * parses (optional) type annotations followed by a type. If the
 791      * annotations are present before the type and are not consumed during array
 792      * parsing, this method returns a {@link JCAnnotatedType} consisting of
 793      * these annotations and the underlying type. Otherwise, it returns the
 794      * underlying type.
 795      *
 796      * &lt;p&gt;
 797      *
 798      * Note that this method sets {@code mode} to {@code TYPE} first, before
 799      * parsing annotations.
 800      */
 801     public JCExpression parseType() {
 802         return parseType(false);
 803     }
 804 
 805     public JCExpression parseType(boolean allowVar) {
 806         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
 807         return parseType(allowVar, annotations);
 808     }
 809 
 810     public JCExpression parseType(boolean allowVar, List&lt;JCAnnotation&gt; annotations) {
 811         JCExpression result = unannotatedType(allowVar);
 812 
 813         if (annotations.nonEmpty()) {
 814             result = insertAnnotationsToMostInner(result, annotations, false);
 815         }
 816 
 817         return result;
 818     }
 819 
 820     public JCExpression unannotatedType(boolean allowVar) {
 821         JCExpression result = term(TYPE);
 822         Name restrictedTypeName = restrictedTypeName(result, !allowVar);
 823 
 824         if (restrictedTypeName != null &amp;&amp; (!allowVar || restrictedTypeName != names.var)) {
 825             syntaxError(result.pos, Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
 826         }
 827 
 828         return result;
 829     }
 830 
 831 
 832 
 833     protected JCExpression term(int newmode) {
 834         int prevmode = mode;
 835         mode = newmode;
 836         JCExpression t = term();
 837         lastmode = mode;
 838         mode = prevmode;
 839         return t;
 840     }
 841 
 842     /**
 843      *  {@literal
 844      *  Expression = Expression1 [ExpressionRest]
 845      *  ExpressionRest = [AssignmentOperator Expression1]
 846      *  AssignmentOperator = &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; |
 847      *                       &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; |
 848      *                       &quot;%=&quot; | &quot;&lt;&lt;=&quot; | &quot;&gt;&gt;=&quot; | &quot;&gt;&gt;&gt;=&quot;
 849      *  Type = Type1
 850      *  TypeNoParams = TypeNoParams1
 851      *  StatementExpression = Expression
 852      *  ConstantExpression = Expression
 853      *  }
 854      */
 855     JCExpression term() {
 856         JCExpression t = term1();
 857         if ((mode &amp; EXPR) != 0 &amp;&amp;
 858             (token.kind == EQ || PLUSEQ.compareTo(token.kind) &lt;= 0 &amp;&amp; token.kind.compareTo(GTGTGTEQ) &lt;= 0))
 859             return termRest(t);
 860         else
 861             return t;
 862     }
 863 
 864     JCExpression termRest(JCExpression t) {
 865         switch (token.kind) {
 866         case EQ: {
 867             int pos = token.pos;
 868             nextToken();
 869             selectExprMode();
 870             JCExpression t1 = term();
 871             return toP(F.at(pos).Assign(t, t1));
 872         }
 873         case PLUSEQ:
 874         case SUBEQ:
 875         case STAREQ:
 876         case SLASHEQ:
 877         case PERCENTEQ:
 878         case AMPEQ:
 879         case BAREQ:
 880         case CARETEQ:
 881         case LTLTEQ:
 882         case GTGTEQ:
 883         case GTGTGTEQ:
 884             int pos = token.pos;
 885             TokenKind tk = token.kind;
 886             nextToken();
 887             selectExprMode();
 888             JCExpression t1 = term();
 889             return F.at(pos).Assignop(optag(tk), t, t1);
 890         default:
 891             return t;
 892         }
 893     }
 894 
 895     /** Expression1   = Expression2 [Expression1Rest]
 896      *  Type1         = Type2
 897      *  TypeNoParams1 = TypeNoParams2
 898      */
 899     JCExpression term1() {
 900         JCExpression t = term2();
 901         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == QUES) {
 902             selectExprMode();
 903             return term1Rest(t);
 904         } else {
 905             return t;
 906         }
 907     }
 908 
 909     /** Expression1Rest = [&quot;?&quot; Expression &quot;:&quot; Expression1]
 910      */
 911     JCExpression term1Rest(JCExpression t) {
 912         if (token.kind == QUES) {
 913             int pos = token.pos;
 914             nextToken();
 915             JCExpression t1 = term();
 916             accept(COLON);
 917             JCExpression t2 = term1();
 918             return F.at(pos).Conditional(t, t1, t2);
 919         } else {
 920             return t;
 921         }
 922     }
 923 
 924     /** Expression2   = Expression3 [Expression2Rest]
 925      *  Type2         = Type3
 926      *  TypeNoParams2 = TypeNoParams3
 927      */
 928     JCExpression term2() {
 929         JCExpression t = term3();
 930         if ((mode &amp; EXPR) != 0 &amp;&amp; prec(token.kind) &gt;= TreeInfo.orPrec) {
 931             selectExprMode();
 932             return term2Rest(t, TreeInfo.orPrec);
 933         } else {
 934             return t;
 935         }
 936     }
 937 
 938     /*  Expression2Rest = {infixop Expression3}
 939      *                  | Expression3 instanceof Type
 940      *                  | Expression3 instanceof Pattern
 941      *  infixop         = &quot;||&quot;
 942      *                  | &quot;&amp;&amp;&quot;
 943      *                  | &quot;|&quot;
 944      *                  | &quot;^&quot;
 945      *                  | &quot;&amp;&quot;
 946      *                  | &quot;==&quot; | &quot;!=&quot;
 947      *                  | &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot;
 948      *                  | &quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot; | &quot;&gt;&gt;&gt;&quot;
 949      *                  | &quot;+&quot; | &quot;-&quot;
 950      *                  | &quot;*&quot; | &quot;/&quot; | &quot;%&quot;
 951      */
 952     JCExpression term2Rest(JCExpression t, int minprec) {
 953         JCExpression[] odStack = newOdStack();
 954         Token[] opStack = newOpStack();
 955 
 956         // optimization, was odStack = new Tree[...]; opStack = new Tree[...];
 957         int top = 0;
 958         odStack[0] = t;
 959         int startPos = token.pos;
 960         Token topOp = Tokens.DUMMY;
 961         while (prec(token.kind) &gt;= minprec) {
 962             opStack[top] = topOp;
 963 
 964             if (token.kind == INSTANCEOF) {
 965                 int pos = token.pos;
 966                 nextToken();
 967                 JCTree pattern = parseType(true);
 968                 if (token.kind == IDENTIFIER) {
 969                     checkSourceLevel(token.pos, Feature.PATTERN_MATCHING_IN_INSTANCEOF);
 970                     if (pattern.hasTag(IDENT) &amp;&amp; isRestrictedTypeName(((JCIdent) pattern).name, pattern.pos, true)) {
 971                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(((JCIdent) pattern).name, ((JCIdent) pattern).name == names.var ? Source.JDK10 : Source.JDK13));
 972                         pattern = null;
 973                     }
 974                     pattern = toP(F.at(token.pos).BindingPattern(ident(), pattern));
 975                 } else if (token.kind == LPAREN) {
 976                     ListBuffer&lt;JCPattern&gt; nested = new ListBuffer&lt;&gt;();
 977                     do {
 978                         nextToken();
 979                         JCPattern nestedPattern = parsePattern();
 980                         nested.append(nestedPattern);
 981                     } while (token.kind == COMMA);
 982                     Name name = null;
 983                     if (token.kind == IDENTIFIER) {
 984                         name = ident();
 985                     }
 986                     accept(RPAREN);
 987                     pattern = toP(F.at(pos).DeconstructionPattern(name, (JCExpression) pattern, nested.toList()));
 988                 }
 989                 odStack[top] = F.at(pos).TypeTest(odStack[top], pattern);
 990             } else {
 991                 topOp = token;
 992                 nextToken();
 993                 top++;
 994                 odStack[top] = term3();
 995             }
 996             while (top &gt; 0 &amp;&amp; prec(topOp.kind) &gt;= prec(token.kind)) {
 997                 odStack[top - 1] = F.at(topOp.pos).Binary(optag(topOp.kind), odStack[top - 1], odStack[top]);
 998                 top--;
 999                 topOp = opStack[top];
1000             }
1001         }
1002         Assert.check(top == 0);
1003         t = odStack[0];
1004 
1005         if (t.hasTag(JCTree.Tag.PLUS)) {
1006             t = foldStrings(t);
1007         }
1008 
1009         odStackSupply.add(odStack);
1010         opStackSupply.add(opStack);
1011         return t;
1012     }
1013     //where
1014         /** If tree is a concatenation of string literals, replace it
1015          *  by a single literal representing the concatenated string.
1016          */
1017         protected JCExpression foldStrings(JCExpression tree) {
1018             if (!allowStringFolding)
1019                 return tree;
1020             ListBuffer&lt;JCExpression&gt; opStack = new ListBuffer&lt;&gt;();
1021             ListBuffer&lt;JCLiteral&gt; litBuf = new ListBuffer&lt;&gt;();
1022             boolean needsFolding = false;
1023             JCExpression curr = tree;
1024             while (true) {
1025                 if (curr.hasTag(JCTree.Tag.PLUS)) {
1026                     JCBinary op = (JCBinary)curr;
1027                     needsFolding |= foldIfNeeded(op.rhs, litBuf, opStack, false);
1028                     curr = op.lhs;
1029                 } else {
1030                     needsFolding |= foldIfNeeded(curr, litBuf, opStack, true);
1031                     break; //last one!
1032                 }
1033             }
1034             if (needsFolding) {
1035                 List&lt;JCExpression&gt; ops = opStack.toList();
1036                 JCExpression res = ops.head;
1037                 for (JCExpression op : ops.tail) {
1038                     res = F.at(op.getStartPosition()).Binary(optag(TokenKind.PLUS), res, op);
1039                     storeEnd(res, getEndPos(op));
1040                 }
1041                 return res;
1042             } else {
1043                 return tree;
1044             }
1045         }
1046 
1047         private boolean foldIfNeeded(JCExpression tree, ListBuffer&lt;JCLiteral&gt; litBuf,
1048                                                 ListBuffer&lt;JCExpression&gt; opStack, boolean last) {
1049             JCLiteral str = stringLiteral(tree);
1050             if (str != null) {
1051                 litBuf.prepend(str);
1052                 return last &amp;&amp; merge(litBuf, opStack);
1053             } else {
1054                 boolean res = merge(litBuf, opStack);
1055                 litBuf.clear();
1056                 opStack.prepend(tree);
1057                 return res;
1058             }
1059         }
1060 
1061         boolean merge(ListBuffer&lt;JCLiteral&gt; litBuf, ListBuffer&lt;JCExpression&gt; opStack) {
1062             if (litBuf.isEmpty()) {
1063                 return false;
1064             } else if (litBuf.size() == 1) {
1065                 opStack.prepend(litBuf.first());
1066                 return false;
1067             } else {
1068                 JCExpression t = F.at(litBuf.first().getStartPosition()).Literal(TypeTag.CLASS,
1069                         litBuf.stream().map(lit -&gt; (String)lit.getValue()).collect(Collectors.joining()));
1070                 storeEnd(t, litBuf.last().getEndPosition(endPosTable));
1071                 opStack.prepend(t);
1072                 return true;
1073             }
1074         }
1075 
1076         private JCLiteral stringLiteral(JCTree tree) {
1077             if (tree.hasTag(LITERAL)) {
1078                 JCLiteral lit = (JCLiteral)tree;
1079                 if (lit.typetag == TypeTag.CLASS) {
1080                     return lit;
1081                 }
1082             }
1083             return null;
1084         }
1085 
1086 
1087         /** optimization: To save allocating a new operand/operator stack
1088          *  for every binary operation, we use supplys.
1089          */
1090         ArrayList&lt;JCExpression[]&gt; odStackSupply = new ArrayList&lt;&gt;();
1091         ArrayList&lt;Token[]&gt; opStackSupply = new ArrayList&lt;&gt;();
1092 
1093         private JCExpression[] newOdStack() {
1094             if (odStackSupply.isEmpty())
1095                 return new JCExpression[infixPrecedenceLevels + 1];
1096             return odStackSupply.remove(odStackSupply.size() - 1);
1097         }
1098 
1099         private Token[] newOpStack() {
1100             if (opStackSupply.isEmpty())
1101                 return new Token[infixPrecedenceLevels + 1];
1102             return opStackSupply.remove(opStackSupply.size() - 1);
1103         }
1104 
1105     /**
1106      *  Expression3    = PrefixOp Expression3
1107      *                 | &quot;(&quot; Expr | TypeNoParams &quot;)&quot; Expression3
1108      *                 | Primary {Selector} {PostfixOp}
1109      *
1110      *  {@literal
1111      *  Primary        = &quot;(&quot; Expression &quot;)&quot;
1112      *                 | Literal
1113      *                 | [TypeArguments] THIS [Arguments]
1114      *                 | [TypeArguments] SUPER SuperSuffix
1115      *                 | NEW [TypeArguments] Creator
1116      *                 | &quot;(&quot; Arguments &quot;)&quot; &quot;-&gt;&quot; ( Expression | Block )
1117      *                 | Ident &quot;-&gt;&quot; ( Expression | Block )
1118      *                 | [Annotations] Ident { &quot;.&quot; [Annotations] Ident }
1119      *                 | Expression3 MemberReferenceSuffix
1120      *                   [ [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt &quot;.&quot; CLASS | Expression &quot;]&quot; )
1121      *                   | Arguments
1122      *                   | &quot;.&quot; ( CLASS | THIS | [TypeArguments] SUPER Arguments | NEW [TypeArguments] InnerCreator )
1123      *                   ]
1124      *                 | BasicType BracketsOpt &quot;.&quot; CLASS
1125      *  }
1126      *
1127      *  PrefixOp       = &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;+&quot; | &quot;-&quot;
1128      *  PostfixOp      = &quot;++&quot; | &quot;--&quot;
1129      *  Type3          = Ident { &quot;.&quot; Ident } [TypeArguments] {TypeSelector} BracketsOpt
1130      *                 | BasicType
1131      *  TypeNoParams3  = Ident { &quot;.&quot; Ident } BracketsOpt
1132      *  Selector       = &quot;.&quot; [TypeArguments] Ident [Arguments]
1133      *                 | &quot;.&quot; THIS
1134      *                 | &quot;.&quot; [TypeArguments] SUPER SuperSuffix
1135      *                 | &quot;.&quot; NEW [TypeArguments] InnerCreator
1136      *                 | &quot;[&quot; Expression &quot;]&quot;
1137      *  TypeSelector   = &quot;.&quot; Ident [TypeArguments]
1138      *  SuperSuffix    = Arguments | &quot;.&quot; Ident [Arguments]
1139      */
1140     protected JCExpression term3() {
1141         int pos = token.pos;
1142         JCExpression t;
1143         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt(EXPR);
1144         switch (token.kind) {
1145         case QUES:
1146             if ((mode &amp; TYPE) != 0 &amp;&amp; (mode &amp; (TYPEARG|NOPARAMS)) == TYPEARG) {
1147                 selectTypeMode();
1148                 return typeArgument();
1149             } else
1150                 return illegal();
1151         case PLUSPLUS: case SUBSUB: case BANG: case TILDE: case PLUS: case SUB:
1152             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1153                 TokenKind tk = token.kind;
1154                 nextToken();
1155                 selectExprMode();
1156                 if (tk == SUB &amp;&amp;
1157                     (token.kind == INTLITERAL || token.kind == LONGLITERAL) &amp;&amp;
1158                     token.radix() == 10) {
1159                     selectExprMode();
1160                     t = literal(names.hyphen, pos);
1161                 } else {
1162                     t = term3();
1163                     return F.at(pos).Unary(unoptag(tk), t);
1164                 }
1165             } else return illegal();
1166             break;
1167         case LPAREN:
1168             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1169                 ParensResult pres = analyzeParens();
1170                 switch (pres) {
1171                     case CAST:
1172                        accept(LPAREN);
1173                        selectTypeMode();
1174                        int pos1 = pos;
1175                        List&lt;JCExpression&gt; targets = List.of(t = parseType());
1176                        while (token.kind == AMP) {
1177                            checkSourceLevel(Feature.INTERSECTION_TYPES_IN_CAST);
1178                            accept(AMP);
1179                            targets = targets.prepend(parseType());
1180                        }
1181                        if (targets.length() &gt; 1) {
1182                            t = toP(F.at(pos1).TypeIntersection(targets.reverse()));
1183                        }
1184                        accept(RPAREN);
1185                        selectExprMode();
1186                        JCExpression t1 = term3();
1187                        return F.at(pos).TypeCast(t, t1);
1188                     case IMPLICIT_LAMBDA:
1189                     case EXPLICIT_LAMBDA:
1190                         t = lambdaExpressionOrStatement(true, pres == ParensResult.EXPLICIT_LAMBDA, pos);
1191                         break;
1192                     default: //PARENS
1193                         accept(LPAREN);
1194                         selectExprMode();
1195                         t = termRest(term1Rest(term2Rest(term3(), TreeInfo.orPrec)));
1196                         accept(RPAREN);
1197                         t = toP(F.at(pos).Parens(t));
1198                         break;
1199                 }
1200             } else {
1201                 return illegal();
1202             }
1203             break;
1204         case THIS:
1205             if ((mode &amp; EXPR) != 0) {
1206                 selectExprMode();
1207                 t = to(F.at(pos).Ident(names._this));
1208                 nextToken();
1209                 if (typeArgs == null)
1210                     t = argumentsOpt(null, t);
1211                 else
1212                     t = arguments(typeArgs, t);
1213                 typeArgs = null;
1214             } else return illegal();
1215             break;
1216         case SUPER:
1217             if ((mode &amp; EXPR) != 0) {
1218                 selectExprMode();
1219                 t = to(F.at(pos).Ident(names._super));
1220                 t = superSuffix(typeArgs, t);
1221                 typeArgs = null;
1222             } else return illegal();
1223             break;
1224         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
1225         case CHARLITERAL: case STRINGLITERAL:
1226         case TRUE: case FALSE: case NULL:
1227             if (typeArgs == null &amp;&amp; (mode &amp; EXPR) != 0) {
1228                 selectExprMode();
1229                 t = literal(names.empty);
1230             } else return illegal();
1231             break;
1232         case NEW:
1233             if (typeArgs != null) return illegal();
1234             if ((mode &amp; EXPR) != 0) {
1235                 selectExprMode();
1236                 nextToken();
1237                 if (token.kind == LT) typeArgs = typeArguments(false);
1238                 t = creator(pos, typeArgs);
1239                 typeArgs = null;
1240             } else return illegal();
1241             break;
1242         case MONKEYS_AT:
1243             // Only annotated cast types and method references are valid
1244             List&lt;JCAnnotation&gt; typeAnnos = typeAnnotationsOpt();
1245             if (typeAnnos.isEmpty()) {
1246                 // else there would be no &#39;@&#39;
1247                 throw new AssertionError(&quot;Expected type annotations, but found none!&quot;);
1248             }
1249 
1250             JCExpression expr = term3();
1251 
1252             if ((mode &amp; TYPE) == 0) {
1253                 // Type annotations on class literals no longer legal
1254                 switch (expr.getTag()) {
1255                 case REFERENCE: {
1256                     JCMemberReference mref = (JCMemberReference) expr;
1257                     mref.expr = toP(F.at(pos).AnnotatedType(typeAnnos, mref.expr));
1258                     t = mref;
1259                     break;
1260                 }
1261                 case SELECT: {
1262                     JCFieldAccess sel = (JCFieldAccess) expr;
1263 
1264                     if (sel.name != names._class) {
1265                         return illegal();
1266                     } else {
1267                         log.error(token.pos, Errors.NoAnnotationsOnDotClass);
1268                         return expr;
1269                     }
1270                 }
1271                 default:
1272                     return illegal(typeAnnos.head.pos);
1273                 }
1274 
1275             } else {
1276                 // Type annotations targeting a cast
1277                 t = insertAnnotationsToMostInner(expr, typeAnnos, false);
1278             }
1279             break;
1280         case UNDERSCORE: case IDENTIFIER: case ASSERT: case ENUM:
1281             if (typeArgs != null) return illegal();
1282             if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOLAMBDA) == 0 &amp;&amp; peekToken(ARROW)) {
1283                 t = lambdaExpressionOrStatement(false, false, pos);
1284             } else {
1285                 t = toP(F.at(token.pos).Ident(ident()));
1286                 loop: while (true) {
1287                     pos = token.pos;
1288                     final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1289 
1290                     // need to report an error later if LBRACKET is for array
1291                     // index access rather than array creation level
1292                     if (!annos.isEmpty() &amp;&amp; token.kind != LBRACKET &amp;&amp; token.kind != ELLIPSIS)
1293                         return illegal(annos.head.pos);
1294 
1295                     switch (token.kind) {
1296                     case LBRACKET:
1297                         nextToken();
1298                         if (token.kind == RBRACKET) {
1299                             nextToken();
1300                             t = bracketsOpt(t);
1301                             t = toP(F.at(pos).TypeArray(t));
1302                             if (annos.nonEmpty()) {
1303                                 t = toP(F.at(pos).AnnotatedType(annos, t));
1304                             }
1305                             t = bracketsSuffix(t);
1306                         } else {
1307                             if ((mode &amp; EXPR) != 0) {
1308                                 selectExprMode();
1309                                 JCExpression t1 = term();
1310                                 if (!annos.isEmpty()) t = illegal(annos.head.pos);
1311                                 t = to(F.at(pos).Indexed(t, t1));
1312                             }
1313                             accept(RBRACKET);
1314                         }
1315                         break loop;
1316                     case LPAREN:
1317                         if ((mode &amp; EXPR) != 0 &amp;&amp; (mode &amp; NOINVOCATION) == 0) {
1318                             selectExprMode();
1319                             t = arguments(typeArgs, t);
1320                             if (!annos.isEmpty()) t = illegal(annos.head.pos);
1321                             typeArgs = null;
1322                         }
1323                         break loop;
1324                     case DOT:
1325                         nextToken();
1326                         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; typeArgs != null) {
1327                             return illegal();
1328                         }
1329                         int oldmode = mode;
1330                         mode &amp;= ~NOPARAMS;
1331                         typeArgs = typeArgumentsOpt(EXPR);
1332                         mode = oldmode;
1333                         if ((mode &amp; EXPR) != 0) {
1334                             switch (token.kind) {
1335                             case CLASS:
1336                                 if (typeArgs != null) return illegal();
1337                                 selectExprMode();
1338                                 t = to(F.at(pos).Select(t, names._class));
1339                                 nextToken();
1340                                 break loop;
1341                             case THIS:
1342                                 if (typeArgs != null) return illegal();
1343                                 selectExprMode();
1344                                 t = to(F.at(pos).Select(t, names._this));
1345                                 nextToken();
1346                                 break loop;
1347                             case SUPER:
1348                                 selectExprMode();
1349                                 t = to(F.at(pos).Select(t, names._super));
1350                                 t = superSuffix(typeArgs, t);
1351                                 typeArgs = null;
1352                                 break loop;
1353                             case NEW:
1354                                 if (typeArgs != null) return illegal();
1355                                 selectExprMode();
1356                                 int pos1 = token.pos;
1357                                 nextToken();
1358                                 if (token.kind == LT) typeArgs = typeArguments(false);
1359                                 t = innerCreator(pos1, typeArgs, t);
1360                                 typeArgs = null;
1361                                 break loop;
1362                             }
1363                         }
1364 
1365                         List&lt;JCAnnotation&gt; tyannos = null;
1366                         if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1367                             tyannos = typeAnnotationsOpt();
1368                         }
1369                         // typeArgs saved for next loop iteration.
1370                         t = toP(F.at(pos).Select(t, ident()));
1371                         if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1372                             t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1373                         }
1374                         break;
1375                     case ELLIPSIS:
1376                         if (this.permitTypeAnnotationsPushBack) {
1377                             this.typeAnnotationsPushedBack = annos;
1378                         } else if (annos.nonEmpty()) {
1379                             // Don&#39;t return here -- error recovery attempt
1380                             illegal(annos.head.pos);
1381                         }
1382                         break loop;
1383                     case LT:
1384                         if ((mode &amp; TYPE) == 0 &amp;&amp; isUnboundMemberRef()) {
1385                             //this is an unbound method reference whose qualifier
1386                             //is a generic type i.e. A&lt;S&gt;::m
1387                             int pos1 = token.pos;
1388                             accept(LT);
1389                             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1390                             args.append(typeArgument());
1391                             while (token.kind == COMMA) {
1392                                 nextToken();
1393                                 args.append(typeArgument());
1394                             }
1395                             accept(GT);
1396                             t = toP(F.at(pos1).TypeApply(t, args.toList()));
1397                             while (token.kind == DOT) {
1398                                 nextToken();
1399                                 selectTypeMode();
1400                                 t = toP(F.at(token.pos).Select(t, ident()));
1401                                 t = typeArgumentsOpt(t);
1402                             }
1403                             t = bracketsOpt(t);
1404                             if (token.kind != COLCOL) {
1405                                 //method reference expected here
1406                                 t = illegal();
1407                             }
1408                             selectExprMode();
1409                             return term3Rest(t, typeArgs);
1410                         }
1411                         break loop;
1412                     default:
1413                         break loop;
1414                     }
1415                 }
1416             }
1417             if (typeArgs != null) illegal();
1418             t = typeArgumentsOpt(t);
1419             break;
1420         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
1421         case DOUBLE: case BOOLEAN:
1422             if (typeArgs != null) illegal();
1423             t = bracketsSuffix(bracketsOpt(basicType()));
1424             break;
1425         case VOID:
1426             if (typeArgs != null) illegal();
1427             if ((mode &amp; EXPR) != 0) {
1428                 nextToken();
1429                 if (token.kind == DOT) {
1430                     JCPrimitiveTypeTree ti = toP(F.at(pos).TypeIdent(TypeTag.VOID));
1431                     t = bracketsSuffix(ti);
1432                 } else {
1433                     return illegal(pos);
1434                 }
1435             } else {
1436                 // Support the corner case of myMethodHandle.&lt;void&gt;invoke() by passing
1437                 // a void type (like other primitive types) to the next phase.
1438                 // The error will be reported in Attr.attribTypes or Attr.visitApply.
1439                 JCPrimitiveTypeTree ti = to(F.at(pos).TypeIdent(TypeTag.VOID));
1440                 nextToken();
1441                 return ti;
1442                 //return illegal();
1443             }
1444             break;
1445         case SWITCH:
1446             checkSourceLevel(Feature.SWITCH_EXPRESSION);
1447             allowYieldStatement = true;
1448             int switchPos = token.pos;
1449             nextToken();
1450             JCExpression selector = parExpression();
1451             accept(LBRACE);
1452             ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
1453             while (true) {
1454                 pos = token.pos;
1455                 switch (token.kind) {
1456                 case CASE:
1457                 case DEFAULT:
1458                     cases.appendList(switchExpressionStatementGroup());
1459                     break;
1460                 case RBRACE: case EOF:
1461                     JCSwitchExpression e = to(F.at(switchPos).SwitchExpression(selector,
1462                                                                                cases.toList()));
1463                     e.endpos = token.pos;
1464                     accept(RBRACE);
1465                     return e;
1466                 default:
1467                     nextToken(); // to ensure progress
1468                     syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
1469                 }
1470             }
1471         default:
1472             return illegal();
1473         }
1474         return term3Rest(t, typeArgs);
1475     }
1476 
1477     private List&lt;JCCase&gt; switchExpressionStatementGroup() {
1478         ListBuffer&lt;JCCase&gt; caseExprs = new ListBuffer&lt;&gt;();
1479         int casePos = token.pos;
1480         ListBuffer&lt;JCPattern&gt; pats = new ListBuffer&lt;&gt;();
1481 
1482         if (token.kind == DEFAULT) {
1483             nextToken();
1484         } else {
1485             accept(CASE);
1486             while (true) {
1487                 pats.append(parsePattern());
1488                 if (token.kind != COMMA) break;
1489                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
1490                 nextToken();
1491             };
1492         }
1493         List&lt;JCStatement&gt; stats = null;
1494         JCTree body = null;
1495         CaseTree.CaseKind kind;
1496         switch (token.kind) {
1497             case ARROW:
1498                 checkSourceLevel(Feature.SWITCH_RULE);
1499                 nextToken();
1500                 if (token.kind == TokenKind.THROW || token.kind == TokenKind.LBRACE) {
1501                     stats = List.of(parseStatement());
1502                     body = stats.head;
1503                     kind = JCCase.RULE;
1504                 } else {
1505                     JCExpression value = parseExpression();
1506                     stats = List.of(to(F.at(value).Yield(value)));
1507                     body = value;
1508                     kind = JCCase.RULE;
1509                     accept(SEMI);
1510                 }
1511                 break;
1512             default:
1513                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
1514                 stats = blockStatements();
1515                 kind = JCCase.STATEMENT;
1516                 break;
1517         }
1518         caseExprs.append(toP(F.at(casePos).Case(kind, pats.toList(), stats, body)));
1519         return caseExprs.toList();
1520     }
1521 
1522     JCExpression term3Rest(JCExpression t, List&lt;JCExpression&gt; typeArgs) {
1523         if (typeArgs != null) illegal();
1524         while (true) {
1525             int pos1 = token.pos;
1526             final List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
1527 
1528             if (token.kind == LBRACKET) {
1529                 nextToken();
1530                 if ((mode &amp; TYPE) != 0) {
1531                     int oldmode = mode;
1532                     selectTypeMode();
1533                     if (token.kind == RBRACKET) {
1534                         nextToken();
1535                         t = bracketsOpt(t);
1536                         t = toP(F.at(pos1).TypeArray(t));
1537                         if (token.kind == COLCOL) {
1538                             selectExprMode();
1539                             continue;
1540                         }
1541                         if (annos.nonEmpty()) {
1542                             t = toP(F.at(pos1).AnnotatedType(annos, t));
1543                         }
1544                         return t;
1545                     }
1546                     mode = oldmode;
1547                 }
1548                 if ((mode &amp; EXPR) != 0) {
1549                     selectExprMode();
1550                     JCExpression t1 = term();
1551                     t = to(F.at(pos1).Indexed(t, t1));
1552                 }
1553                 accept(RBRACKET);
1554             } else if (token.kind == DOT) {
1555                 nextToken();
1556                 typeArgs = typeArgumentsOpt(EXPR);
1557                 if (token.kind == SUPER &amp;&amp; (mode &amp; EXPR) != 0) {
1558                     selectExprMode();
1559                     t = to(F.at(pos1).Select(t, names._super));
1560                     nextToken();
1561                     t = arguments(typeArgs, t);
1562                     typeArgs = null;
1563                 } else if (token.kind == NEW &amp;&amp; (mode &amp; EXPR) != 0) {
1564                     if (typeArgs != null) return illegal();
1565                     selectExprMode();
1566                     int pos2 = token.pos;
1567                     nextToken();
1568                     if (token.kind == LT) typeArgs = typeArguments(false);
1569                     t = innerCreator(pos2, typeArgs, t);
1570                     typeArgs = null;
1571                 } else {
1572                     List&lt;JCAnnotation&gt; tyannos = null;
1573                     if ((mode &amp; TYPE) != 0 &amp;&amp; token.kind == MONKEYS_AT) {
1574                         // is the mode check needed?
1575                         tyannos = typeAnnotationsOpt();
1576                     }
1577                     t = toP(F.at(pos1).Select(t, ident(true)));
1578                     if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
1579                         t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
1580                     }
1581                     t = argumentsOpt(typeArgs, typeArgumentsOpt(t));
1582                     typeArgs = null;
1583                 }
1584             } else if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == COLCOL) {
1585                 selectExprMode();
1586                 if (typeArgs != null) return illegal();
1587                 accept(COLCOL);
1588                 t = memberReferenceSuffix(pos1, t);
1589             } else {
1590                 if (!annos.isEmpty()) {
1591                     if (permitTypeAnnotationsPushBack)
1592                         typeAnnotationsPushedBack = annos;
1593                     else
1594                         return illegal(annos.head.pos);
1595                 }
1596                 break;
1597             }
1598         }
1599         while ((token.kind == PLUSPLUS || token.kind == SUBSUB) &amp;&amp; (mode &amp; EXPR) != 0) {
1600             selectExprMode();
1601             t = to(F.at(token.pos).Unary(
1602                   token.kind == PLUSPLUS ? POSTINC : POSTDEC, t));
1603             nextToken();
1604         }
1605         return toP(t);
1606     }
1607 
1608     /**
1609      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1610      * method reference or a binary expression. To disambiguate, look for a
1611      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1612      */
1613     @SuppressWarnings(&quot;fallthrough&quot;)
1614     boolean isUnboundMemberRef() {
1615         int pos = 0, depth = 0;
1616         outer: for (Token t = S.token(pos) ; ; t = S.token(++pos)) {
1617             switch (t.kind) {
1618                 case IDENTIFIER: case UNDERSCORE: case QUES: case EXTENDS: case SUPER:
1619                 case DOT: case RBRACKET: case LBRACKET: case COMMA:
1620                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1621                 case DOUBLE: case BOOLEAN: case CHAR:
1622                 case MONKEYS_AT:
1623                     break;
1624 
1625                 case LPAREN:
1626                     // skip annotation values
1627                     int nesting = 0;
1628                     for (; ; pos++) {
1629                         TokenKind tk2 = S.token(pos).kind;
1630                         switch (tk2) {
1631                             case EOF:
1632                                 return false;
1633                             case LPAREN:
1634                                 nesting++;
1635                                 break;
1636                             case RPAREN:
1637                                 nesting--;
1638                                 if (nesting == 0) {
1639                                     continue outer;
1640                                 }
1641                                 break;
1642                         }
1643                     }
1644 
1645                 case LT:
1646                     depth++; break;
1647                 case GTGTGT:
1648                     depth--;
1649                 case GTGT:
1650                     depth--;
1651                 case GT:
1652                     depth--;
1653                     if (depth == 0) {
1654                         TokenKind nextKind = S.token(pos + 1).kind;
1655                         return
1656                             nextKind == TokenKind.DOT ||
1657                             nextKind == TokenKind.LBRACKET ||
1658                             nextKind == TokenKind.COLCOL;
1659                     }
1660                     break;
1661                 default:
1662                     return false;
1663             }
1664         }
1665     }
1666 
1667     /**
1668      * If we see an identifier followed by a &#39;&amp;lt;&#39; it could be an unbound
1669      * method reference or a binary expression. To disambiguate, look for a
1670      * matching &#39;&amp;gt;&#39; and see if the subsequent terminal is either &#39;.&#39; or &#39;::&#39;.
1671      */
1672     @SuppressWarnings(&quot;fallthrough&quot;)
1673     ParensResult analyzeParens() {
1674         int depth = 0;
1675         boolean type = false;
1676         ParensResult defaultResult = ParensResult.PARENS;
1677         outer: for (int lookahead = 0; ; lookahead++) {
1678             TokenKind tk = S.token(lookahead).kind;
1679             switch (tk) {
1680                 case COMMA:
1681                     type = true;
1682                 case EXTENDS: case SUPER: case DOT: case AMP:
1683                     //skip
1684                     break;
1685                 case QUES:
1686                     if (peekToken(lookahead, EXTENDS) ||
1687                             peekToken(lookahead, SUPER)) {
1688                         //wildcards
1689                         type = true;
1690                     }
1691                     break;
1692                 case BYTE: case SHORT: case INT: case LONG: case FLOAT:
1693                 case DOUBLE: case BOOLEAN: case CHAR: case VOID:
1694                     if (peekToken(lookahead, RPAREN)) {
1695                         //Type, &#39;)&#39; -&gt; cast
1696                         return ParensResult.CAST;
1697                     } else if (peekToken(lookahead, LAX_IDENTIFIER)) {
1698                         //Type, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1699                         return ParensResult.EXPLICIT_LAMBDA;
1700                     }
1701                     break;
1702                 case LPAREN:
1703                     if (lookahead != 0) {
1704                         // &#39;(&#39; in a non-starting position -&gt; parens
1705                         return ParensResult.PARENS;
1706                     } else if (peekToken(lookahead, RPAREN)) {
1707                         // &#39;(&#39;, &#39;)&#39; -&gt; explicit lambda
1708                         return ParensResult.EXPLICIT_LAMBDA;
1709                     }
1710                     break;
1711                 case RPAREN:
1712                     // if we have seen something that looks like a type,
1713                     // then it&#39;s a cast expression
1714                     if (type) return ParensResult.CAST;
1715                     // otherwise, disambiguate cast vs. parenthesized expression
1716                     // based on subsequent token.
1717                     switch (S.token(lookahead + 1).kind) {
1718                         /*case PLUSPLUS: case SUBSUB: */
1719                         case BANG: case TILDE:
1720                         case LPAREN: case THIS: case SUPER:
1721                         case INTLITERAL: case LONGLITERAL: case FLOATLITERAL:
1722                         case DOUBLELITERAL: case CHARLITERAL: case STRINGLITERAL:
1723                         case TRUE: case FALSE: case NULL:
1724                         case NEW: case IDENTIFIER: case ASSERT: case ENUM: case UNDERSCORE:
1725                         case SWITCH:
1726                         case BYTE: case SHORT: case CHAR: case INT:
1727                         case LONG: case FLOAT: case DOUBLE: case BOOLEAN: case VOID:
1728                             return ParensResult.CAST;
1729                         default:
1730                             return defaultResult;
1731                     }
1732                 case UNDERSCORE:
1733                 case ASSERT:
1734                 case ENUM:
1735                 case IDENTIFIER:
1736                     if (peekToken(lookahead, LAX_IDENTIFIER)) {
1737                         // Identifier, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1738                         return ParensResult.EXPLICIT_LAMBDA;
1739                     } else if (peekToken(lookahead, RPAREN, ARROW)) {
1740                         // Identifier, &#39;)&#39; &#39;-&gt;&#39; -&gt; implicit lambda
1741                         return (mode &amp; NOLAMBDA) == 0 ? ParensResult.IMPLICIT_LAMBDA
1742                                                       : ParensResult.PARENS;
1743                     } else if (depth == 0 &amp;&amp; peekToken(lookahead, COMMA)) {
1744                         defaultResult = ParensResult.IMPLICIT_LAMBDA;
1745                     }
1746                     type = false;
1747                     break;
1748                 case FINAL:
1749                 case ELLIPSIS:
1750                     //those can only appear in explicit lambdas
1751                     return ParensResult.EXPLICIT_LAMBDA;
1752                 case MONKEYS_AT:
1753                     type = true;
1754                     lookahead += 1; //skip &#39;@&#39;
1755                     while (peekToken(lookahead, DOT)) {
1756                         lookahead += 2;
1757                     }
1758                     if (peekToken(lookahead, LPAREN)) {
1759                         lookahead++;
1760                         //skip annotation values
1761                         int nesting = 0;
1762                         for (; ; lookahead++) {
1763                             TokenKind tk2 = S.token(lookahead).kind;
1764                             switch (tk2) {
1765                                 case EOF:
1766                                     return ParensResult.PARENS;
1767                                 case LPAREN:
1768                                     nesting++;
1769                                     break;
1770                                 case RPAREN:
1771                                     nesting--;
1772                                     if (nesting == 0) {
1773                                         continue outer;
1774                                     }
1775                                 break;
1776                             }
1777                         }
1778                     }
1779                     break;
1780                 case LBRACKET:
1781                     if (peekToken(lookahead, RBRACKET, LAX_IDENTIFIER)) {
1782                         // &#39;[&#39;, &#39;]&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39; -&gt; explicit lambda
1783                         return ParensResult.EXPLICIT_LAMBDA;
1784                     } else if (peekToken(lookahead, RBRACKET, RPAREN) ||
1785                             peekToken(lookahead, RBRACKET, AMP)) {
1786                         // &#39;[&#39;, &#39;]&#39;, &#39;)&#39; -&gt; cast
1787                         // &#39;[&#39;, &#39;]&#39;, &#39;&amp;&#39; -&gt; cast (intersection type)
1788                         return ParensResult.CAST;
1789                     } else if (peekToken(lookahead, RBRACKET)) {
1790                         //consume the &#39;]&#39; and skip
1791                         type = true;
1792                         lookahead++;
1793                         break;
1794                     } else {
1795                         return ParensResult.PARENS;
1796                     }
1797                 case LT:
1798                     depth++; break;
1799                 case GTGTGT:
1800                     depth--;
1801                 case GTGT:
1802                     depth--;
1803                 case GT:
1804                     depth--;
1805                     if (depth == 0) {
1806                         if (peekToken(lookahead, RPAREN) ||
1807                                 peekToken(lookahead, AMP)) {
1808                             // &#39;&gt;&#39;, &#39;)&#39; -&gt; cast
1809                             // &#39;&gt;&#39;, &#39;&amp;&#39; -&gt; cast
1810                             return ParensResult.CAST;
1811                         } else if (peekToken(lookahead, LAX_IDENTIFIER, COMMA) ||
1812                                 peekToken(lookahead, LAX_IDENTIFIER, RPAREN, ARROW) ||
1813                                 peekToken(lookahead, ELLIPSIS)) {
1814                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;,&#39; -&gt; explicit lambda
1815                             // &#39;&gt;&#39;, Identifier/&#39;_&#39;/&#39;assert&#39;/&#39;enum&#39;, &#39;)&#39;, &#39;-&gt;&#39; -&gt; explicit lambda
1816                             // &#39;&gt;&#39;, &#39;...&#39; -&gt; explicit lambda
1817                             return ParensResult.EXPLICIT_LAMBDA;
1818                         }
1819                         //it looks a type, but could still be (i) a cast to generic type,
1820                         //(ii) an unbound method reference or (iii) an explicit lambda
1821                         type = true;
1822                         break;
1823                     } else if (depth &lt; 0) {
1824                         //unbalanced &#39;&lt;&#39;, &#39;&gt;&#39; - not a generic type
1825                         return ParensResult.PARENS;
1826                     }
1827                     break;
1828                 default:
1829                     //this includes EOF
1830                     return defaultResult;
1831             }
1832         }
1833     }
1834 
1835     /** Accepts all identifier-like tokens */
1836     protected Filter&lt;TokenKind&gt; LAX_IDENTIFIER = t -&gt; t == IDENTIFIER || t == UNDERSCORE || t == ASSERT || t == ENUM;
1837 
1838     enum ParensResult {
1839         CAST,
1840         EXPLICIT_LAMBDA,
1841         IMPLICIT_LAMBDA,
1842         PARENS
1843     }
1844 
1845     JCExpression lambdaExpressionOrStatement(boolean hasParens, boolean explicitParams, int pos) {
1846         List&lt;JCVariableDecl&gt; params = explicitParams ?
1847                 formalParameters(true, false) :
1848                 implicitParameters(hasParens);
1849         if (explicitParams) {
1850             LambdaClassifier lambdaClassifier = new LambdaClassifier();
1851             for (JCVariableDecl param: params) {
1852                 Name restrictedTypeName;
1853                 if (param.vartype != null &amp;&amp;
1854                         (restrictedTypeName = restrictedTypeName(param.vartype, false)) != null &amp;&amp;
1855                         param.vartype.hasTag(TYPEARRAY)) {
1856                     log.error(DiagnosticFlag.SYNTAX, param.pos,
1857                         Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source)
1858                             ? Errors.RestrictedTypeNotAllowedArray(restrictedTypeName) : Errors.RestrictedTypeNotAllowedHere(restrictedTypeName));
1859                 }
1860                 lambdaClassifier.addParameter(param);
1861                 if (lambdaClassifier.result() == LambdaParameterKind.ERROR) {
1862                     break;
1863                 }
1864             }
1865             if (lambdaClassifier.diagFragment != null) {
1866                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidLambdaParameterDeclaration(lambdaClassifier.diagFragment));
1867             }
1868             for (JCVariableDecl param: params) {
1869                 if (param.vartype != null
1870                         &amp;&amp; restrictedTypeName(param.vartype, true) != null) {
1871                     checkSourceLevel(param.pos, Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS);
1872                     param.startPos = TreeInfo.getStartPos(param.vartype);
1873                     param.vartype = null;
1874                 }
1875             }
1876         }
1877         return lambdaExpressionOrStatementRest(params, pos);
1878     }
1879 
1880     enum LambdaParameterKind {
1881         VAR(0),
1882         EXPLICIT(1),
1883         IMPLICIT(2),
1884         ERROR(-1);
1885 
1886         private final int index;
1887 
1888         LambdaParameterKind(int index) {
1889             this.index = index;
1890         }
1891     }
1892 
1893     private final static Fragment[][] decisionTable = new Fragment[][] {
1894         /*              VAR                              EXPLICIT                         IMPLICIT  */
1895         /* VAR      */ {null,                            VarAndExplicitNotAllowed,        VarAndImplicitNotAllowed},
1896         /* EXPLICIT */ {VarAndExplicitNotAllowed,        null,                            ImplicitAndExplicitNotAllowed},
1897         /* IMPLICIT */ {VarAndImplicitNotAllowed,        ImplicitAndExplicitNotAllowed,   null},
1898     };
1899 
1900     class LambdaClassifier {
1901 
1902         LambdaParameterKind kind;
1903         Fragment diagFragment;
1904         List&lt;JCVariableDecl&gt; params;
1905 
1906         void addParameter(JCVariableDecl param) {
1907             if (param.vartype != null &amp;&amp; param.name != names.empty) {
1908                 if (restrictedTypeName(param.vartype, false) != null) {
1909                     reduce(LambdaParameterKind.VAR);
1910                 } else {
1911                     reduce(LambdaParameterKind.EXPLICIT);
1912                 }
1913             }
1914             if (param.vartype == null &amp;&amp; param.name != names.empty ||
1915                 param.vartype != null &amp;&amp; param.name == names.empty) {
1916                 reduce(LambdaParameterKind.IMPLICIT);
1917             }
1918         }
1919 
1920         private void reduce(LambdaParameterKind newKind) {
1921             if (kind == null) {
1922                 kind = newKind;
1923             } else if (kind != newKind &amp;&amp; kind != LambdaParameterKind.ERROR) {
1924                 LambdaParameterKind currentKind = kind;
1925                 kind = LambdaParameterKind.ERROR;
1926                 boolean varIndex = currentKind.index == LambdaParameterKind.VAR.index ||
1927                         newKind.index == LambdaParameterKind.VAR.index;
1928                 diagFragment = Feature.VAR_SYNTAX_IMPLICIT_LAMBDAS.allowedInSource(source) || !varIndex ?
1929                         decisionTable[currentKind.index][newKind.index] : null;
1930             }
1931         }
1932 
1933         LambdaParameterKind result() {
1934             return kind;
1935         }
1936     }
1937 
1938     JCExpression lambdaExpressionOrStatementRest(List&lt;JCVariableDecl&gt; args, int pos) {
1939         checkSourceLevel(Feature.LAMBDA);
1940         accept(ARROW);
1941 
1942         return token.kind == LBRACE ?
1943             lambdaStatement(args, pos, token.pos) :
1944             lambdaExpression(args, pos);
1945     }
1946 
1947     JCExpression lambdaStatement(List&lt;JCVariableDecl&gt; args, int pos, int pos2) {
1948         JCBlock block = block(pos2, 0);
1949         return toP(F.at(pos).Lambda(args, block));
1950     }
1951 
1952     JCExpression lambdaExpression(List&lt;JCVariableDecl&gt; args, int pos) {
1953         JCTree expr = parseExpression();
1954         return toP(F.at(pos).Lambda(args, expr));
1955     }
1956 
1957     /** SuperSuffix = Arguments | &quot;.&quot; [TypeArguments] Ident [Arguments]
1958      */
1959     JCExpression superSuffix(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1960         nextToken();
1961         if (token.kind == LPAREN || typeArgs != null) {
1962             t = arguments(typeArgs, t);
1963         } else if (token.kind == COLCOL) {
1964             if (typeArgs != null) return illegal();
1965             t = memberReferenceSuffix(t);
1966         } else {
1967             int pos = token.pos;
1968             accept(DOT);
1969             typeArgs = (token.kind == LT) ? typeArguments(false) : null;
1970             t = toP(F.at(pos).Select(t, ident()));
1971             t = argumentsOpt(typeArgs, t);
1972         }
1973         return t;
1974     }
1975 
1976     /** BasicType = BYTE | SHORT | CHAR | INT | LONG | FLOAT | DOUBLE | BOOLEAN
1977      */
1978     JCPrimitiveTypeTree basicType() {
1979         JCPrimitiveTypeTree t = to(F.at(token.pos).TypeIdent(typetag(token.kind)));
1980         nextToken();
1981         return t;
1982     }
1983 
1984     /** ArgumentsOpt = [ Arguments ]
1985      */
1986     JCExpression argumentsOpt(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
1987         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == LPAREN || typeArgs != null) {
1988             selectExprMode();
1989             return arguments(typeArgs, t);
1990         } else {
1991             return t;
1992         }
1993     }
1994 
1995     /** Arguments = &quot;(&quot; [Expression { COMMA Expression }] &quot;)&quot;
1996      */
1997     List&lt;JCExpression&gt; arguments() {
1998         ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
1999         if (token.kind == LPAREN) {
2000             nextToken();
2001             if (token.kind != RPAREN) {
2002                 args.append(parseExpression());
2003                 while (token.kind == COMMA) {
2004                     nextToken();
2005                     args.append(parseExpression());
2006                 }
2007             }
2008             accept(RPAREN);
2009         } else {
2010             syntaxError(token.pos, Errors.Expected(LPAREN));
2011         }
2012         return args.toList();
2013     }
2014 
2015     JCExpression arguments(List&lt;JCExpression&gt; typeArgs, JCExpression t) {
2016         int pos = token.pos;
2017         List&lt;JCExpression&gt; args = arguments();
2018         JCExpression mi = F.at(pos).Apply(typeArgs, t, args);
2019         if (t.hasTag(IDENT) &amp;&amp; isInvalidUnqualifiedMethodIdentifier(((JCIdent) t).pos,
2020                                                                     ((JCIdent) t).name)) {
2021             log.error(DiagnosticFlag.SYNTAX, t, Errors.InvalidYield);
2022             mi = F.Erroneous(List.of(mi));
2023         }
2024         return toP(mi);
2025     }
2026 
2027     boolean isInvalidUnqualifiedMethodIdentifier(int pos, Name name) {
2028         if (name == names.yield) {
2029             if (allowYieldStatement) {
2030                 return true;
2031             } else {
2032                 log.warning(pos, Warnings.InvalidYield);
2033             }
2034         }
2035         return false;
2036     }
2037 
2038     /**  TypeArgumentsOpt = [ TypeArguments ]
2039      */
2040     JCExpression typeArgumentsOpt(JCExpression t) {
2041         if (token.kind == LT &amp;&amp;
2042             (mode &amp; TYPE) != 0 &amp;&amp;
2043             (mode &amp; NOPARAMS) == 0) {
2044             selectTypeMode();
2045             return typeArguments(t, false);
2046         } else {
2047             return t;
2048         }
2049     }
2050     List&lt;JCExpression&gt; typeArgumentsOpt() {
2051         return typeArgumentsOpt(TYPE);
2052     }
2053 
2054     List&lt;JCExpression&gt; typeArgumentsOpt(int useMode) {
2055         if (token.kind == LT) {
2056             if ((mode &amp; useMode) == 0 ||
2057                 (mode &amp; NOPARAMS) != 0) {
2058                 illegal();
2059             }
2060             mode = useMode;
2061             return typeArguments(false);
2062         }
2063         return null;
2064     }
2065 
2066     /**
2067      *  {@literal
2068      *  TypeArguments  = &quot;&lt;&quot; TypeArgument {&quot;,&quot; TypeArgument} &quot;&gt;&quot;
2069      *  }
2070      */
2071     List&lt;JCExpression&gt; typeArguments(boolean diamondAllowed) {
2072         if (token.kind == LT) {
2073             nextToken();
2074             if (token.kind == GT &amp;&amp; diamondAllowed) {
2075                 checkSourceLevel(Feature.DIAMOND);
2076                 mode |= DIAMOND;
2077                 nextToken();
2078                 return List.nil();
2079             } else {
2080                 ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
2081                 args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2082                 while (token.kind == COMMA) {
2083                     nextToken();
2084                     args.append(((mode &amp; EXPR) == 0) ? typeArgument() : parseType());
2085                 }
2086                 switch (token.kind) {
2087 
2088                 case GTGTGTEQ: case GTGTEQ: case GTEQ:
2089                 case GTGTGT: case GTGT:
2090                     token = S.split();
2091                     break;
2092                 case GT:
2093                     nextToken();
2094                     break;
2095                 default:
2096                     args.append(syntaxError(token.pos, Errors.Expected(GT)));
2097                     break;
2098                 }
2099                 return args.toList();
2100             }
2101         } else {
2102             return List.of(syntaxError(token.pos, Errors.Expected(LT)));
2103         }
2104     }
2105 
2106     /**
2107      *  {@literal
2108      *  TypeArgument = Type
2109      *               | [Annotations] &quot;?&quot;
2110      *               | [Annotations] &quot;?&quot; EXTENDS Type {&quot;&amp;&quot; Type}
2111      *               | [Annotations] &quot;?&quot; SUPER Type
2112      *  }
2113      */
2114     JCExpression typeArgument() {
2115         List&lt;JCAnnotation&gt; annotations = typeAnnotationsOpt();
2116         if (token.kind != QUES) return parseType(false, annotations);
2117         int pos = token.pos;
2118         nextToken();
2119         JCExpression result;
2120         if (token.kind == EXTENDS) {
2121             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.EXTENDS));
2122             nextToken();
2123             JCExpression bound = parseType();
2124             result = F.at(pos).Wildcard(t, bound);
2125         } else if (token.kind == SUPER) {
2126             TypeBoundKind t = to(F.at(pos).TypeBoundKind(BoundKind.SUPER));
2127             nextToken();
2128             JCExpression bound = parseType();
2129             result = F.at(pos).Wildcard(t, bound);
2130         } else if (LAX_IDENTIFIER.accepts(token.kind)) {
2131             //error recovery
2132             TypeBoundKind t = F.at(Position.NOPOS).TypeBoundKind(BoundKind.UNBOUND);
2133             JCExpression wc = toP(F.at(pos).Wildcard(t, null));
2134             JCIdent id = toP(F.at(token.pos).Ident(ident()));
2135             JCErroneous err = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(wc, id));
2136             reportSyntaxError(err, Errors.Expected3(GT, EXTENDS, SUPER));
2137             result = err;
2138         } else {
2139             TypeBoundKind t = toP(F.at(pos).TypeBoundKind(BoundKind.UNBOUND));
2140             result = toP(F.at(pos).Wildcard(t, null));
2141         }
2142         if (!annotations.isEmpty()) {
2143             result = toP(F.at(annotations.head.pos).AnnotatedType(annotations,result));
2144         }
2145         return result;
2146     }
2147 
2148     JCTypeApply typeArguments(JCExpression t, boolean diamondAllowed) {
2149         int pos = token.pos;
2150         List&lt;JCExpression&gt; args = typeArguments(diamondAllowed);
2151         return toP(F.at(pos).TypeApply(t, args));
2152     }
2153 
2154     /**
2155      * BracketsOpt = { [Annotations] &quot;[&quot; &quot;]&quot; }*
2156      *
2157      * &lt;p&gt;
2158      *
2159      * &lt;code&gt;annotations&lt;/code&gt; is the list of annotations targeting
2160      * the expression &lt;code&gt;t&lt;/code&gt;.
2161      */
2162     private JCExpression bracketsOpt(JCExpression t,
2163             List&lt;JCAnnotation&gt; annotations) {
2164         List&lt;JCAnnotation&gt; nextLevelAnnotations = typeAnnotationsOpt();
2165 
2166         if (token.kind == LBRACKET) {
2167             int pos = token.pos;
2168             nextToken();
2169             t = bracketsOptCont(t, pos, nextLevelAnnotations);
2170         } else if (!nextLevelAnnotations.isEmpty()) {
2171             if (permitTypeAnnotationsPushBack) {
2172                 this.typeAnnotationsPushedBack = nextLevelAnnotations;
2173             } else {
2174                 return illegal(nextLevelAnnotations.head.pos);
2175             }
2176         }
2177 
2178         if (!annotations.isEmpty()) {
2179             t = toP(F.at(token.pos).AnnotatedType(annotations, t));
2180         }
2181         return t;
2182     }
2183 
2184     /** BracketsOpt = [ &quot;[&quot; &quot;]&quot; { [Annotations] &quot;[&quot; &quot;]&quot;} ]
2185      */
2186     private JCExpression bracketsOpt(JCExpression t) {
2187         return bracketsOpt(t, List.nil());
2188     }
2189 
2190     private JCExpression bracketsOptCont(JCExpression t, int pos,
2191             List&lt;JCAnnotation&gt; annotations) {
2192         accept(RBRACKET);
2193         t = bracketsOpt(t);
2194         t = toP(F.at(pos).TypeArray(t));
2195         if (annotations.nonEmpty()) {
2196             t = toP(F.at(pos).AnnotatedType(annotations, t));
2197         }
2198         return t;
2199     }
2200 
2201     /** BracketsSuffixExpr = &quot;.&quot; CLASS
2202      *  BracketsSuffixType =
2203      */
2204     JCExpression bracketsSuffix(JCExpression t) {
2205         if ((mode &amp; EXPR) != 0 &amp;&amp; token.kind == DOT) {
2206             selectExprMode();
2207             int pos = token.pos;
2208             nextToken();
2209             accept(CLASS);
2210             if (token.pos == endPosTable.errorEndPos) {
2211                 // error recovery
2212                 Name name;
2213                 if (LAX_IDENTIFIER.accepts(token.kind)) {
2214                     name = token.name();
2215                     nextToken();
2216                 } else {
2217                     name = names.error;
2218                 }
2219                 t = F.at(pos).Erroneous(List.&lt;JCTree&gt;of(toP(F.at(pos).Select(t, name))));
2220             } else {
2221                 Tag tag = t.getTag();
2222                 // Type annotations are illegal on class literals. Annotated non array class literals
2223                 // are complained about directly in term3(), Here check for type annotations on dimensions
2224                 // taking care to handle some interior dimension(s) being annotated.
2225                 if ((tag == TYPEARRAY &amp;&amp; TreeInfo.containsTypeAnnotation(t)) || tag == ANNOTATED_TYPE)
2226                     syntaxError(token.pos, Errors.NoAnnotationsOnDotClass);
2227                 t = toP(F.at(pos).Select(t, names._class));
2228             }
2229         } else if ((mode &amp; TYPE) != 0) {
2230             if (token.kind != COLCOL) {
2231                 selectTypeMode();
2232             }
2233         } else if (token.kind != COLCOL) {
2234             syntaxError(token.pos, Errors.DotClassExpected);
2235         }
2236         return t;
2237     }
2238 
2239     /**
2240      * MemberReferenceSuffix = &quot;::&quot; [TypeArguments] Ident
2241      *                       | &quot;::&quot; [TypeArguments] &quot;new&quot;
2242      */
2243     JCExpression memberReferenceSuffix(JCExpression t) {
2244         int pos1 = token.pos;
2245         accept(COLCOL);
2246         return memberReferenceSuffix(pos1, t);
2247     }
2248 
2249     JCExpression memberReferenceSuffix(int pos1, JCExpression t) {
2250         checkSourceLevel(Feature.METHOD_REFERENCES);
2251         selectExprMode();
2252         List&lt;JCExpression&gt; typeArgs = null;
2253         if (token.kind == LT) {
2254             typeArgs = typeArguments(false);
2255         }
2256         Name refName;
2257         ReferenceMode refMode;
2258         if (token.kind == NEW) {
2259             refMode = ReferenceMode.NEW;
2260             refName = names.init;
2261             nextToken();
2262         } else {
2263             refMode = ReferenceMode.INVOKE;
2264             refName = ident();
2265         }
2266         return toP(F.at(t.getStartPosition()).Reference(refMode, refName, t, typeArgs));
2267     }
2268 
2269     /** Creator = [Annotations] Qualident [TypeArguments] ( ArrayCreatorRest | ClassCreatorRest )
2270      */
2271     JCExpression creator(int newpos, List&lt;JCExpression&gt; typeArgs) {
2272         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2273 
2274         switch (token.kind) {
2275         case BYTE: case SHORT: case CHAR: case INT: case LONG: case FLOAT:
2276         case DOUBLE: case BOOLEAN:
2277             if (typeArgs == null) {
2278                 if (newAnnotations.isEmpty()) {
2279                     return arrayCreatorRest(newpos, basicType());
2280                 } else {
2281                     return arrayCreatorRest(newpos, toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, basicType())));
2282                 }
2283             }
2284             break;
2285         default:
2286         }
2287         JCExpression t = qualident(true);
2288 
2289         int oldmode = mode;
2290         selectTypeMode();
2291         boolean diamondFound = false;
2292         int lastTypeargsPos = -1;
2293         if (token.kind == LT) {
2294             lastTypeargsPos = token.pos;
2295             t = typeArguments(t, true);
2296             diamondFound = (mode &amp; DIAMOND) != 0;
2297         }
2298         while (token.kind == DOT) {
2299             if (diamondFound) {
2300                 //cannot select after a diamond
2301                 illegal();
2302             }
2303             int pos = token.pos;
2304             nextToken();
2305             List&lt;JCAnnotation&gt; tyannos = typeAnnotationsOpt();
2306             t = toP(F.at(pos).Select(t, ident()));
2307 
2308             if (tyannos != null &amp;&amp; tyannos.nonEmpty()) {
2309                 t = toP(F.at(tyannos.head.pos).AnnotatedType(tyannos, t));
2310             }
2311 
2312             if (token.kind == LT) {
2313                 lastTypeargsPos = token.pos;
2314                 t = typeArguments(t, true);
2315                 diamondFound = (mode &amp; DIAMOND) != 0;
2316             }
2317         }
2318         mode = oldmode;
2319         if (token.kind == LBRACKET || token.kind == MONKEYS_AT) {
2320             // handle type annotations for non primitive arrays
2321             if (newAnnotations.nonEmpty()) {
2322                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2323             }
2324 
2325             JCExpression e = arrayCreatorRest(newpos, t);
2326             if (diamondFound) {
2327                 reportSyntaxError(lastTypeargsPos, Errors.CannotCreateArrayWithDiamond);
2328                 return toP(F.at(newpos).Erroneous(List.of(e)));
2329             }
2330             else if (typeArgs != null) {
2331                 int pos = newpos;
2332                 if (!typeArgs.isEmpty() &amp;&amp; typeArgs.head.pos != Position.NOPOS) {
2333                     // note: this should always happen but we should
2334                     // not rely on this as the parser is continuously
2335                     // modified to improve error recovery.
2336                     pos = typeArgs.head.pos;
2337                 }
2338                 setErrorEndPos(S.prevToken().endPos);
2339                 JCErroneous err = F.at(pos).Erroneous(typeArgs.prepend(e));
2340                 reportSyntaxError(err, Errors.CannotCreateArrayWithTypeArguments);
2341                 return toP(err);
2342             }
2343             return e;
2344         } else if (token.kind == LPAREN) {
2345             // handle type annotations for instantiations and anonymous classes
2346             if (newAnnotations.nonEmpty()) {
2347                 t = insertAnnotationsToMostInner(t, newAnnotations, false);
2348             }
2349             return classCreatorRest(newpos, null, typeArgs, t);
2350         } else {
2351             setErrorEndPos(token.pos);
2352             reportSyntaxError(token.pos, Errors.Expected2(LPAREN, LBRACKET));
2353             t = toP(F.at(newpos).NewClass(null, typeArgs, t, List.nil(), null));
2354             return toP(F.at(newpos).Erroneous(List.&lt;JCTree&gt;of(t)));
2355         }
2356     }
2357 
2358     /** InnerCreator = [Annotations] Ident [TypeArguments] ClassCreatorRest
2359      */
2360     JCExpression innerCreator(int newpos, List&lt;JCExpression&gt; typeArgs, JCExpression encl) {
2361         List&lt;JCAnnotation&gt; newAnnotations = typeAnnotationsOpt();
2362 
2363         JCExpression t = toP(F.at(token.pos).Ident(ident()));
2364 
2365         if (newAnnotations.nonEmpty()) {
2366             t = toP(F.at(newAnnotations.head.pos).AnnotatedType(newAnnotations, t));
2367         }
2368 
2369         if (token.kind == LT) {
2370             int oldmode = mode;
2371             t = typeArguments(t, true);
2372             mode = oldmode;
2373         }
2374         return classCreatorRest(newpos, encl, typeArgs, t);
2375     }
2376 
2377     /** ArrayCreatorRest = [Annotations] &quot;[&quot; ( &quot;]&quot; BracketsOpt ArrayInitializer
2378      *                         | Expression &quot;]&quot; {[Annotations]  &quot;[&quot; Expression &quot;]&quot;} BracketsOpt )
2379      */
2380     JCExpression arrayCreatorRest(int newpos, JCExpression elemtype) {
2381         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
2382 
2383         accept(LBRACKET);
2384         if (token.kind == RBRACKET) {
2385             accept(RBRACKET);
2386             elemtype = bracketsOpt(elemtype, annos);
2387             if (token.kind == LBRACE) {
2388                 JCNewArray na = (JCNewArray)arrayInitializer(newpos, elemtype);
2389                 if (annos.nonEmpty()) {
2390                     // when an array initializer is present then
2391                     // the parsed annotations should target the
2392                     // new array tree
2393                     // bracketsOpt inserts the annotation in
2394                     // elemtype, and it needs to be corrected
2395                     //
2396                     JCAnnotatedType annotated = (JCAnnotatedType)elemtype;
2397                     assert annotated.annotations == annos;
2398                     na.annotations = annotated.annotations;
2399                     na.elemtype = annotated.underlyingType;
2400                 }
2401                 return na;
2402             } else {
2403                 JCExpression t = toP(F.at(newpos).NewArray(elemtype, List.nil(), null));
2404                 return syntaxError(token.pos, List.of(t), Errors.ArrayDimensionMissing);
2405             }
2406         } else {
2407             ListBuffer&lt;JCExpression&gt; dims = new ListBuffer&lt;&gt;();
2408 
2409             // maintain array dimension type annotations
2410             ListBuffer&lt;List&lt;JCAnnotation&gt;&gt; dimAnnotations = new ListBuffer&lt;&gt;();
2411             dimAnnotations.append(annos);
2412 
2413             dims.append(parseExpression());
2414             accept(RBRACKET);
2415             while (token.kind == LBRACKET
2416                     || token.kind == MONKEYS_AT) {
2417                 List&lt;JCAnnotation&gt; maybeDimAnnos = typeAnnotationsOpt();
2418                 int pos = token.pos;
2419                 nextToken();
2420                 if (token.kind == RBRACKET) {
2421                     elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2422                 } else {
2423                     if (token.kind == RBRACKET) { // no dimension
2424                         elemtype = bracketsOptCont(elemtype, pos, maybeDimAnnos);
2425                     } else {
2426                         dimAnnotations.append(maybeDimAnnos);
2427                         dims.append(parseExpression());
2428                         accept(RBRACKET);
2429                     }
2430                 }
2431             }
2432 
2433             List&lt;JCExpression&gt; elems = null;
2434             int errpos = token.pos;
2435 
2436             if (token.kind == LBRACE) {
2437                 elems = arrayInitializerElements(newpos, elemtype);
2438             }
2439 
2440             JCNewArray na = toP(F.at(newpos).NewArray(elemtype, dims.toList(), elems));
2441             na.dimAnnotations = dimAnnotations.toList();
2442 
2443             if (elems != null) {
2444                 return syntaxError(errpos, List.of(na), Errors.IllegalArrayCreationBothDimensionAndInitialization);
2445             }
2446 
2447             return na;
2448         }
2449     }
2450 
2451     /** ClassCreatorRest = Arguments [ClassBody]
2452      */
2453     JCNewClass classCreatorRest(int newpos,
2454                                   JCExpression encl,
2455                                   List&lt;JCExpression&gt; typeArgs,
2456                                   JCExpression t)
2457     {
2458         List&lt;JCExpression&gt; args = arguments();
2459         JCClassDecl body = null;
2460         if (token.kind == LBRACE) {
2461             int pos = token.pos;
2462             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
2463             JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2464             body = toP(F.at(pos).AnonymousClassDef(mods, defs));
2465         }
2466         return toP(F.at(newpos).NewClass(encl, typeArgs, t, args, body));
2467     }
2468 
2469     /** ArrayInitializer = &quot;{&quot; [VariableInitializer {&quot;,&quot; VariableInitializer}] [&quot;,&quot;] &quot;}&quot;
2470      */
2471     JCExpression arrayInitializer(int newpos, JCExpression t) {
2472         List&lt;JCExpression&gt; elems = arrayInitializerElements(newpos, t);
2473         return toP(F.at(newpos).NewArray(t, List.nil(), elems));
2474     }
2475 
2476     List&lt;JCExpression&gt; arrayInitializerElements(int newpos, JCExpression t) {
2477         accept(LBRACE);
2478         ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
2479         if (token.kind == COMMA) {
2480             nextToken();
2481         } else if (token.kind != RBRACE) {
2482             elems.append(variableInitializer());
2483             while (token.kind == COMMA) {
2484                 nextToken();
2485                 if (token.kind == RBRACE) break;
2486                 elems.append(variableInitializer());
2487             }
2488         }
2489         accept(RBRACE);
2490         return elems.toList();
2491     }
2492 
2493     /** VariableInitializer = ArrayInitializer | Expression
2494      */
2495     public JCExpression variableInitializer() {
2496         return token.kind == LBRACE ? arrayInitializer(token.pos, null) : parseExpression();
2497     }
2498 
2499     /** ParExpression = &quot;(&quot; Expression &quot;)&quot;
2500      */
2501     JCExpression parExpression() {
2502         int pos = token.pos;
2503         accept(LPAREN);
2504         JCExpression t = parseExpression();
2505         accept(RPAREN);
2506         return toP(F.at(pos).Parens(t));
2507     }
2508 
2509     /** Block = &quot;{&quot; BlockStatements &quot;}&quot;
2510      */
2511     JCBlock block(int pos, long flags) {
2512         accept(LBRACE);
2513         List&lt;JCStatement&gt; stats = blockStatements();
2514         JCBlock t = F.at(pos).Block(flags, stats);
2515         while (token.kind == CASE || token.kind == DEFAULT) {
2516             syntaxError(token.pos, Errors.Orphaned(token.kind));
2517             switchBlockStatementGroups();
2518         }
2519         // the Block node has a field &quot;endpos&quot; for first char of last token, which is
2520         // usually but not necessarily the last char of the last token.
2521         t.endpos = token.pos;
2522         accept(RBRACE);
2523         return toP(t);
2524     }
2525 
2526     public JCBlock block() {
2527         return block(token.pos, 0);
2528     }
2529 
2530     /** BlockStatements = { BlockStatement }
2531      *  BlockStatement  = LocalVariableDeclarationStatement
2532      *                  | ClassOrInterfaceOrEnumDeclaration
2533      *                  | [Ident &quot;:&quot;] Statement
2534      *  LocalVariableDeclarationStatement
2535      *                  = { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators &quot;;&quot;
2536      */
2537     @SuppressWarnings(&quot;fallthrough&quot;)
2538     List&lt;JCStatement&gt; blockStatements() {
2539         //todo: skip to anchor on error(?)
2540         int lastErrPos = -1;
2541         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
2542         while (true) {
2543             List&lt;JCStatement&gt; stat = blockStatement();
2544             if (stat.isEmpty()) {
2545                 return stats.toList();
2546             } else {
2547                 // error recovery
2548                 if (token.pos == lastErrPos)
2549                     return stats.toList();
2550                 if (token.pos &lt;= endPosTable.errorEndPos) {
2551                     skip(false, true, true, true);
2552                     lastErrPos = token.pos;
2553                 }
2554                 stats.addAll(stat);
2555             }
2556         }
2557     }
2558 
2559     /*
2560      * Parse a Statement (JLS 14.5). As an enhancement to improve error recovery,
2561      * this method will also recognize variable and class declarations (which are
2562      * not legal for a Statement) by delegating the parsing to BlockStatement (JLS 14.2).
2563      * If any illegal declarations are found, they will be wrapped in an erroneous tree,
2564      * and an error will be produced by this method.
2565      */
2566     JCStatement parseStatementAsBlock() {
2567         int pos = token.pos;
2568         List&lt;JCStatement&gt; stats = blockStatement();
2569         if (stats.isEmpty()) {
2570             JCErroneous e = syntaxError(pos, Errors.IllegalStartOfStmt);
2571             return toP(F.at(pos).Exec(e));
2572         } else {
2573             JCStatement first = stats.head;
2574             Error error = null;
2575             switch (first.getTag()) {
2576             case CLASSDEF:
2577                 error = Errors.ClassNotAllowed;
2578                 break;
2579             case VARDEF:
2580                 error = Errors.VariableNotAllowed;
2581                 break;
2582             }
2583             if (error != null) {
2584                 log.error(DiagnosticFlag.SYNTAX, first, error);
2585                 List&lt;JCBlock&gt; blist = List.of(F.at(first.pos).Block(0, stats));
2586                 return toP(F.at(pos).Exec(F.at(first.pos).Erroneous(blist)));
2587             }
2588             return first;
2589         }
2590     }
2591 
2592     /**This method parses a statement appearing inside a block.
2593      */
2594     @SuppressWarnings(&quot;fallthrough&quot;)
2595     List&lt;JCStatement&gt; blockStatement() {
2596         //todo: skip to anchor on error(?)
2597         Comment dc;
2598         int pos = token.pos;
2599         switch (token.kind) {
2600         case RBRACE: case CASE: case DEFAULT: case EOF:
2601             return List.nil();
2602         case LBRACE: case IF: case FOR: case WHILE: case DO: case TRY:
2603         case SWITCH: case SYNCHRONIZED: case RETURN: case THROW: case BREAK:
2604         case CONTINUE: case SEMI: case ELSE: case FINALLY: case CATCH:
2605         case ASSERT:
2606             return List.of(parseSimpleStatement());
2607         case MONKEYS_AT:
2608         case FINAL: {
2609             dc = token.comment(CommentStyle.JAVADOC);
2610             JCModifiers mods = modifiersOpt();
2611             if (token.kind == INTERFACE ||
2612                 token.kind == CLASS ||
2613                 token.kind == ENUM ||
2614                 isRecordStart()) {
2615                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2616             } else {
2617                 JCExpression t = parseType(true);
2618                 return localVariableDeclarations(mods, t);
2619             }
2620         }
2621         case ABSTRACT: case STRICTFP: {
2622             dc = token.comment(CommentStyle.JAVADOC);
2623             JCModifiers mods = modifiersOpt();
2624             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
2625         }
2626         case INTERFACE:
2627         case CLASS:
2628             dc = token.comment(CommentStyle.JAVADOC);
2629             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2630         case ENUM:
2631             log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.LocalEnum);
2632             dc = token.comment(CommentStyle.JAVADOC);
2633             return List.of(classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(), dc));
2634         case IDENTIFIER:
2635             if (token.name() == names.yield &amp;&amp; allowYieldStatement) {
2636                 Token next = S.token(1);
2637                 boolean isYieldStatement;
2638                 switch (next.kind) {
2639                     case PLUS: case SUB: case STRINGLITERAL: case CHARLITERAL:
2640                     case INTLITERAL: case FLOATLITERAL: case DOUBLELITERAL:
2641                     case NULL: case IDENTIFIER: case TRUE: case FALSE:
2642                     case NEW: case SWITCH: case THIS: case SUPER:
2643                         isYieldStatement = true;
2644                         break;
2645                     case PLUSPLUS: case SUBSUB:
2646                         isYieldStatement = S.token(2).kind != SEMI;
2647                         break;
2648                     case LPAREN:
2649                         int lookahead = 2;
2650                         int balance = 1;
2651                         boolean hasComma = false;
2652                         Token l;
2653                         while ((l = S.token(lookahead)).kind != EOF &amp;&amp; balance != 0) {
2654                             switch (l.kind) {
2655                                 case LPAREN: balance++; break;
2656                                 case RPAREN: balance--; break;
2657                                 case COMMA: if (balance == 1) hasComma = true; break;
2658                             }
2659                             lookahead++;
2660                         }
2661                         isYieldStatement = (!hasComma &amp;&amp; lookahead != 3) || l.kind == ARROW;
2662                         break;
2663                     case SEMI: //error recovery - this is not a valid statement:
2664                         isYieldStatement = true;
2665                         break;
2666                     default:
2667                         isYieldStatement = false;
2668                         break;
2669                 }
2670 
2671                 if (isYieldStatement) {
2672                     nextToken();
2673                     JCExpression t = term(EXPR);
2674                     accept(SEMI);
2675                     return List.of(toP(F.at(pos).Yield(t)));
2676                 }
2677 
2678                 //else intentional fall-through
2679             }
2680         }
2681         if (isRecordStart() &amp;&amp; allowRecords) {
2682             dc = token.comment(CommentStyle.JAVADOC);
2683             return List.of(recordDeclaration(F.at(pos).Modifiers(0), dc));
2684         } else {
2685             Token prevToken = token;
2686             JCExpression t = term(EXPR | TYPE);
2687             if (token.kind == COLON &amp;&amp; t.hasTag(IDENT)) {
2688                 nextToken();
2689                 JCStatement stat = parseStatementAsBlock();
2690                 return List.of(F.at(pos).Labelled(prevToken.name(), stat));
2691             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
2692                 pos = token.pos;
2693                 JCModifiers mods = F.at(Position.NOPOS).Modifiers(0);
2694                 F.at(pos);
2695                 return localVariableDeclarations(mods, t);
2696             } else {
2697                 // This Exec is an &quot;ExpressionStatement&quot;; it subsumes the terminating semicolon
2698                 t = checkExprStat(t);
2699                 accept(SEMI);
2700                 JCExpressionStatement expr = toP(F.at(pos).Exec(t));
2701                 return List.of(expr);
2702             }
2703         }
2704     }
2705     //where
2706         private List&lt;JCStatement&gt; localVariableDeclarations(JCModifiers mods, JCExpression type) {
2707             ListBuffer&lt;JCStatement&gt; stats =
2708                     variableDeclarators(mods, type, new ListBuffer&lt;&gt;(), true);
2709             // A &quot;LocalVariableDeclarationStatement&quot; subsumes the terminating semicolon
2710             accept(SEMI);
2711             storeEnd(stats.last(), S.prevToken().endPos);
2712             return stats.toList();
2713         }
2714 
2715     /** Statement =
2716      *       Block
2717      *     | IF ParExpression Statement [ELSE Statement]
2718      *     | FOR &quot;(&quot; ForInitOpt &quot;;&quot; [Expression] &quot;;&quot; ForUpdateOpt &quot;)&quot; Statement
2719      *     | FOR &quot;(&quot; FormalParameter : Expression &quot;)&quot; Statement
2720      *     | WHILE ParExpression Statement
2721      *     | DO Statement WHILE ParExpression &quot;;&quot;
2722      *     | TRY Block ( Catches | [Catches] FinallyPart )
2723      *     | TRY &quot;(&quot; ResourceSpecification &quot;;&quot;opt &quot;)&quot; Block [Catches] [FinallyPart]
2724      *     | SWITCH ParExpression &quot;{&quot; SwitchBlockStatementGroups &quot;}&quot;
2725      *     | SYNCHRONIZED ParExpression Block
2726      *     | RETURN [Expression] &quot;;&quot;
2727      *     | THROW Expression &quot;;&quot;
2728      *     | BREAK [Ident] &quot;;&quot;
2729      *     | CONTINUE [Ident] &quot;;&quot;
2730      *     | ASSERT Expression [ &quot;:&quot; Expression ] &quot;;&quot;
2731      *     | &quot;;&quot;
2732      */
2733     public JCStatement parseSimpleStatement() {
2734         int pos = token.pos;
2735         switch (token.kind) {
2736         case LBRACE:
2737             return block();
2738         case IF: {
2739             nextToken();
2740             JCExpression cond = parExpression();
2741             JCStatement thenpart = parseStatementAsBlock();
2742             JCStatement elsepart = null;
2743             if (token.kind == ELSE) {
2744                 nextToken();
2745                 elsepart = parseStatementAsBlock();
2746             }
2747             return F.at(pos).If(cond, thenpart, elsepart);
2748         }
2749         case FOR: {
2750             nextToken();
2751             accept(LPAREN);
2752             List&lt;JCStatement&gt; inits = token.kind == SEMI ? List.nil() : forInit();
2753             if (inits.length() == 1 &amp;&amp;
2754                 inits.head.hasTag(VARDEF) &amp;&amp;
2755                 ((JCVariableDecl) inits.head).init == null &amp;&amp;
2756                 token.kind == COLON) {
2757                 JCVariableDecl var = (JCVariableDecl)inits.head;
2758                 accept(COLON);
2759                 JCExpression expr = parseExpression();
2760                 accept(RPAREN);
2761                 JCStatement body = parseStatementAsBlock();
2762                 return F.at(pos).ForeachLoop(var, expr, body);
2763             } else {
2764                 accept(SEMI);
2765                 JCExpression cond = token.kind == SEMI ? null : parseExpression();
2766                 accept(SEMI);
2767                 List&lt;JCExpressionStatement&gt; steps = token.kind == RPAREN ? List.nil() : forUpdate();
2768                 accept(RPAREN);
2769                 JCStatement body = parseStatementAsBlock();
2770                 return F.at(pos).ForLoop(inits, cond, steps, body);
2771             }
2772         }
2773         case WHILE: {
2774             nextToken();
2775             JCExpression cond = parExpression();
2776             JCStatement body = parseStatementAsBlock();
2777             return F.at(pos).WhileLoop(cond, body);
2778         }
2779         case DO: {
2780             nextToken();
2781             JCStatement body = parseStatementAsBlock();
2782             accept(WHILE);
2783             JCExpression cond = parExpression();
2784             accept(SEMI);
2785             JCDoWhileLoop t = toP(F.at(pos).DoLoop(body, cond));
2786             return t;
2787         }
2788         case TRY: {
2789             nextToken();
2790             List&lt;JCTree&gt; resources = List.nil();
2791             if (token.kind == LPAREN) {
2792                 nextToken();
2793                 resources = resources();
2794                 accept(RPAREN);
2795             }
2796             JCBlock body = block();
2797             ListBuffer&lt;JCCatch&gt; catchers = new ListBuffer&lt;&gt;();
2798             JCBlock finalizer = null;
2799             if (token.kind == CATCH || token.kind == FINALLY) {
2800                 while (token.kind == CATCH) catchers.append(catchClause());
2801                 if (token.kind == FINALLY) {
2802                     nextToken();
2803                     finalizer = block();
2804                 }
2805             } else {
2806                 if (resources.isEmpty()) {
2807                     log.error(DiagnosticFlag.SYNTAX, pos, Errors.TryWithoutCatchFinallyOrResourceDecls);
2808                 }
2809             }
2810             return F.at(pos).Try(resources, body, catchers.toList(), finalizer);
2811         }
2812         case SWITCH: {
2813             nextToken();
2814             JCExpression selector = parExpression();
2815             accept(LBRACE);
2816             List&lt;JCCase&gt; cases = switchBlockStatementGroups();
2817             JCSwitch t = to(F.at(pos).Switch(selector, cases));
2818             accept(RBRACE);
2819             return t;
2820         }
2821         case SYNCHRONIZED: {
2822             nextToken();
2823             JCExpression lock = parExpression();
2824             JCBlock body = block();
2825             return F.at(pos).Synchronized(lock, body);
2826         }
2827         case RETURN: {
2828             nextToken();
2829             JCExpression result = token.kind == SEMI ? null : parseExpression();
2830             accept(SEMI);
2831             JCReturn t = toP(F.at(pos).Return(result));
2832             return t;
2833         }
2834         case THROW: {
2835             nextToken();
2836             JCExpression exc = parseExpression();
2837             accept(SEMI);
2838             JCThrow t = toP(F.at(pos).Throw(exc));
2839             return t;
2840         }
2841         case BREAK: {
2842             nextToken();
2843             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2844             accept(SEMI);
2845             JCBreak t = toP(F.at(pos).Break(label));
2846             return t;
2847         }
2848         case CONTINUE: {
2849             nextToken();
2850             Name label = LAX_IDENTIFIER.accepts(token.kind) ? ident() : null;
2851             accept(SEMI);
2852             JCContinue t =  toP(F.at(pos).Continue(label));
2853             return t;
2854         }
2855         case SEMI:
2856             nextToken();
2857             return toP(F.at(pos).Skip());
2858         case ELSE:
2859             int elsePos = token.pos;
2860             nextToken();
2861             return doRecover(elsePos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.ElseWithoutIf);
2862         case FINALLY:
2863             int finallyPos = token.pos;
2864             nextToken();
2865             return doRecover(finallyPos, BasicErrorRecoveryAction.BLOCK_STMT, Errors.FinallyWithoutTry);
2866         case CATCH:
2867             return doRecover(token.pos, BasicErrorRecoveryAction.CATCH_CLAUSE, Errors.CatchWithoutTry);
2868         case ASSERT: {
2869             nextToken();
2870             JCExpression assertion = parseExpression();
2871             JCExpression message = null;
2872             if (token.kind == COLON) {
2873                 nextToken();
2874                 message = parseExpression();
2875             }
2876             accept(SEMI);
2877             JCAssert t = toP(F.at(pos).Assert(assertion, message));
2878             return t;
2879         }
2880         default:
2881             Assert.error();
2882             return null;
2883         }
2884     }
2885 
2886     @Override
2887     public JCStatement parseStatement() {
2888         return parseStatementAsBlock();
2889     }
2890 
2891     private JCStatement doRecover(int startPos, ErrorRecoveryAction action, Error errorKey) {
2892         int errPos = S.errPos();
2893         JCTree stm = action.doRecover(this);
2894         S.errPos(errPos);
2895         return toP(F.Exec(syntaxError(startPos, List.of(stm), errorKey)));
2896     }
2897 
2898     /** CatchClause     = CATCH &quot;(&quot; FormalParameter &quot;)&quot; Block
2899      * TODO: the &quot;FormalParameter&quot; is not correct, it uses the special &quot;catchTypes&quot; rule below.
2900      */
2901     protected JCCatch catchClause() {
2902         int pos = token.pos;
2903         accept(CATCH);
2904         accept(LPAREN);
2905         JCModifiers mods = optFinal(Flags.PARAMETER);
2906         List&lt;JCExpression&gt; catchTypes = catchTypes();
2907         JCExpression paramType = catchTypes.size() &gt; 1 ?
2908                 toP(F.at(catchTypes.head.getStartPosition()).TypeUnion(catchTypes)) :
2909                 catchTypes.head;
2910         JCVariableDecl formal = variableDeclaratorId(mods, paramType);
2911         accept(RPAREN);
2912         JCBlock body = block();
2913         return F.at(pos).Catch(formal, body);
2914     }
2915 
2916     List&lt;JCExpression&gt; catchTypes() {
2917         ListBuffer&lt;JCExpression&gt; catchTypes = new ListBuffer&lt;&gt;();
2918         catchTypes.add(parseType());
2919         while (token.kind == BAR) {
2920             nextToken();
2921             // Instead of qualident this is now parseType.
2922             // But would that allow too much, e.g. arrays or generics?
2923             catchTypes.add(parseType());
2924         }
2925         return catchTypes.toList();
2926     }
2927 
2928     /** SwitchBlockStatementGroups = { SwitchBlockStatementGroup }
2929      *  SwitchBlockStatementGroup = SwitchLabel BlockStatements
2930      *  SwitchLabel = CASE Pattern &quot;:&quot; | DEFAULT &quot;:&quot;
2931      */
2932     List&lt;JCCase&gt; switchBlockStatementGroups() {
2933         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;&gt;();
2934         while (true) {
2935             int pos = token.pos;
2936             switch (token.kind) {
2937             case CASE:
2938             case DEFAULT:
2939                 cases.appendList(switchBlockStatementGroup());
2940                 break;
2941             case RBRACE: case EOF:
2942                 return cases.toList();
2943             default:
2944                 nextToken(); // to ensure progress
2945                 syntaxError(pos, Errors.Expected3(CASE, DEFAULT, RBRACE));
2946             }
2947         }
2948     }
2949 
2950     protected List&lt;JCCase&gt; switchBlockStatementGroup() {
2951         int pos = token.pos;
2952         List&lt;JCStatement&gt; stats;
2953         JCCase c;
2954         ListBuffer&lt;JCCase&gt; cases = new ListBuffer&lt;JCCase&gt;();
2955         switch (token.kind) {
2956         case CASE: {
2957             nextToken();
2958             ListBuffer&lt;JCPattern&gt; pats = new ListBuffer&lt;&gt;();
2959             while (true) {
2960                 pats.append(parsePattern());
2961                 if (token.kind != COMMA) break;
2962                 nextToken();
2963                 checkSourceLevel(Feature.SWITCH_MULTIPLE_CASE_LABELS);
2964             };
2965             CaseTree.CaseKind caseKind;
2966             JCTree body = null;
2967             if (token.kind == ARROW) {
2968                 checkSourceLevel(Feature.SWITCH_RULE);
2969                 accept(ARROW);
2970                 caseKind = JCCase.RULE;
2971                 JCStatement statement = parseStatementAsBlock();
2972                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2973                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2974                 }
2975                 stats = List.of(statement);
2976                 body = stats.head;
2977             } else {
2978                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
2979                 caseKind = JCCase.STATEMENT;
2980                 stats = blockStatements();
2981             }
2982             c = F.at(pos).Case(caseKind, pats.toList(), stats, body);
2983             if (stats.isEmpty())
2984                 storeEnd(c, S.prevToken().endPos);
2985             return cases.append(c).toList();
2986         }
2987         case DEFAULT: {
2988             nextToken();
2989             CaseTree.CaseKind caseKind;
2990             JCTree body = null;
2991             if (token.kind == ARROW) {
2992                 checkSourceLevel(Feature.SWITCH_RULE);
2993                 accept(ARROW);
2994                 caseKind = JCCase.RULE;
2995                 JCStatement statement = parseStatementAsBlock();
2996                 if (!statement.hasTag(EXEC) &amp;&amp; !statement.hasTag(BLOCK) &amp;&amp; !statement.hasTag(Tag.THROW)) {
2997                     log.error(statement.pos(), Errors.SwitchCaseUnexpectedStatement);
2998                 }
2999                 stats = List.of(statement);
3000                 body = stats.head;
3001             } else {
3002                 accept(COLON, tk -&gt; Errors.Expected2(COLON, ARROW));
3003                 caseKind = JCCase.STATEMENT;
3004                 stats = blockStatements();
3005             }
3006             c = F.at(pos).Case(caseKind, List.nil(), stats, body);
3007             if (stats.isEmpty())
3008                 storeEnd(c, S.prevToken().endPos);
3009             return cases.append(c).toList();
3010         }
3011         }
3012         throw new AssertionError(&quot;should not reach here&quot;);
3013     }
3014 
3015     /** MoreStatementExpressions = { COMMA StatementExpression }
3016      */
3017     &lt;T extends ListBuffer&lt;? super JCExpressionStatement&gt;&gt; T moreStatementExpressions(int pos,
3018                                                                     JCExpression first,
3019                                                                     T stats) {
3020         // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3021         stats.append(toP(F.at(pos).Exec(checkExprStat(first))));
3022         while (token.kind == COMMA) {
3023             nextToken();
3024             pos = token.pos;
3025             JCExpression t = parseExpression();
3026             // This Exec is a &quot;StatementExpression&quot;; it subsumes no terminating token
3027             stats.append(toP(F.at(pos).Exec(checkExprStat(t))));
3028         }
3029         return stats;
3030     }
3031 
3032     /** ForInit = StatementExpression MoreStatementExpressions
3033      *           |  { FINAL | &#39;@&#39; Annotation } Type VariableDeclarators
3034      */
3035     List&lt;JCStatement&gt; forInit() {
3036         ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
3037         int pos = token.pos;
3038         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3039             return variableDeclarators(optFinal(0), parseType(true), stats, true).toList();
3040         } else {
3041             JCExpression t = term(EXPR | TYPE);
3042             if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3043                 return variableDeclarators(modifiersOpt(), t, stats, true).toList();
3044             } else if ((lastmode &amp; TYPE) != 0 &amp;&amp; token.kind == COLON) {
3045                 log.error(DiagnosticFlag.SYNTAX, pos, Errors.BadInitializer(&quot;for-loop&quot;));
3046                 return List.of((JCStatement)F.at(pos).VarDef(modifiersOpt(), names.error, t, null));
3047             } else {
3048                 return moreStatementExpressions(pos, t, stats).toList();
3049             }
3050         }
3051     }
3052 
3053     /** ForUpdate = StatementExpression MoreStatementExpressions
3054      */
3055     List&lt;JCExpressionStatement&gt; forUpdate() {
3056         return moreStatementExpressions(token.pos,
3057                                         parseExpression(),
3058                                         new ListBuffer&lt;JCExpressionStatement&gt;()).toList();
3059     }
3060 
3061     /** AnnotationsOpt = { &#39;@&#39; Annotation }
3062      *
3063      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3064      */
3065     protected List&lt;JCAnnotation&gt; annotationsOpt(Tag kind) {
3066         if (token.kind != MONKEYS_AT) return List.nil(); // optimization
3067         ListBuffer&lt;JCAnnotation&gt; buf = new ListBuffer&lt;&gt;();
3068         int prevmode = mode;
3069         while (token.kind == MONKEYS_AT) {
3070             int pos = token.pos;
3071             nextToken();
3072             buf.append(annotation(pos, kind));
3073         }
3074         lastmode = mode;
3075         mode = prevmode;
3076         List&lt;JCAnnotation&gt; annotations = buf.toList();
3077 
3078         return annotations;
3079     }
3080 
3081     List&lt;JCAnnotation&gt; typeAnnotationsOpt() {
3082         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.TYPE_ANNOTATION);
3083         return annotations;
3084     }
3085 
3086     /** ModifiersOpt = { Modifier }
3087      *  Modifier = PUBLIC | PROTECTED | PRIVATE | STATIC | ABSTRACT | FINAL
3088      *           | NATIVE | SYNCHRONIZED | TRANSIENT | VOLATILE | &quot;@&quot;
3089      *           | &quot;@&quot; Annotation
3090      */
3091     protected JCModifiers modifiersOpt() {
3092         return modifiersOpt(null);
3093     }
3094     protected JCModifiers modifiersOpt(JCModifiers partial) {
3095         long flags;
3096         ListBuffer&lt;JCAnnotation&gt; annotations = new ListBuffer&lt;&gt;();
3097         int pos;
3098         if (partial == null) {
3099             flags = 0;
3100             pos = token.pos;
3101         } else {
3102             flags = partial.flags;
3103             annotations.appendList(partial.annotations);
3104             pos = partial.pos;
3105         }
3106         if (token.deprecatedFlag()) {
3107             flags |= Flags.DEPRECATED;
3108         }
3109         int lastPos;
3110     loop:
3111         while (true) {
3112             long flag;
3113             switch (token.kind) {
3114             case PRIVATE     : flag = Flags.PRIVATE; break;
3115             case PROTECTED   : flag = Flags.PROTECTED; break;
3116             case PUBLIC      : flag = Flags.PUBLIC; break;
3117             case STATIC      : flag = Flags.STATIC; break;
3118             case TRANSIENT   : flag = Flags.TRANSIENT; break;
3119             case FINAL       : flag = Flags.FINAL; break;
3120             case ABSTRACT    : flag = Flags.ABSTRACT; break;
3121             case NATIVE      : flag = Flags.NATIVE; break;
3122             case VOLATILE    : flag = Flags.VOLATILE; break;
3123             case SYNCHRONIZED: flag = Flags.SYNCHRONIZED; break;
3124             case STRICTFP    : flag = Flags.STRICTFP; break;
3125             case MONKEYS_AT  : flag = Flags.ANNOTATION; break;
3126             case DEFAULT     : checkSourceLevel(Feature.DEFAULT_METHODS); flag = Flags.DEFAULT; break;
3127             case ERROR       : flag = 0; nextToken(); break;
3128             default: break loop;
3129             }
3130             if ((flags &amp; flag) != 0) log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3131             lastPos = token.pos;
3132             nextToken();
3133             if (flag == Flags.ANNOTATION) {
3134                 if (token.kind != INTERFACE) {
3135                     JCAnnotation ann = annotation(lastPos, Tag.ANNOTATION);
3136                     // if first modifier is an annotation, set pos to annotation&#39;s.
3137                     if (flags == 0 &amp;&amp; annotations.isEmpty())
3138                         pos = ann.pos;
3139                     annotations.append(ann);
3140                     flag = 0;
3141                 }
3142             }
3143             flags |= flag;
3144         }
3145         switch (token.kind) {
3146         case ENUM: flags |= Flags.ENUM; break;
3147         case INTERFACE: flags |= Flags.INTERFACE; break;
3148         default: break;
3149         }
3150 
3151         /* A modifiers tree with no modifier tokens or annotations
3152          * has no text position. */
3153         if ((flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0 &amp;&amp; annotations.isEmpty())
3154             pos = Position.NOPOS;
3155 
3156         JCModifiers mods = F.at(pos).Modifiers(flags, annotations.toList());
3157         if (pos != Position.NOPOS)
3158             storeEnd(mods, S.prevToken().endPos);
3159         return mods;
3160     }
3161 
3162     /** Annotation              = &quot;@&quot; Qualident [ &quot;(&quot; AnnotationFieldValues &quot;)&quot; ]
3163      *
3164      * @param pos position of &quot;@&quot; token
3165      * @param kind Whether to parse an ANNOTATION or TYPE_ANNOTATION
3166      */
3167     JCAnnotation annotation(int pos, Tag kind) {
3168         // accept(AT); // AT consumed by caller
3169         if (kind == Tag.TYPE_ANNOTATION) {
3170             checkSourceLevel(Feature.TYPE_ANNOTATIONS);
3171         }
3172         JCTree ident = qualident(false);
3173         List&lt;JCExpression&gt; fieldValues = annotationFieldValuesOpt();
3174         JCAnnotation ann;
3175         if (kind == Tag.ANNOTATION) {
3176             ann = F.at(pos).Annotation(ident, fieldValues);
3177         } else if (kind == Tag.TYPE_ANNOTATION) {
3178             ann = F.at(pos).TypeAnnotation(ident, fieldValues);
3179         } else {
3180             throw new AssertionError(&quot;Unhandled annotation kind: &quot; + kind);
3181         }
3182 
3183         storeEnd(ann, S.prevToken().endPos);
3184         return ann;
3185     }
3186 
3187     List&lt;JCExpression&gt; annotationFieldValuesOpt() {
3188         return (token.kind == LPAREN) ? annotationFieldValues() : List.nil();
3189     }
3190 
3191     /** AnnotationFieldValues   = &quot;(&quot; [ AnnotationFieldValue { &quot;,&quot; AnnotationFieldValue } ] &quot;)&quot; */
3192     List&lt;JCExpression&gt; annotationFieldValues() {
3193         accept(LPAREN);
3194         ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3195         if (token.kind != RPAREN) {
3196             buf.append(annotationFieldValue());
3197             while (token.kind == COMMA) {
3198                 nextToken();
3199                 buf.append(annotationFieldValue());
3200             }
3201         }
3202         accept(RPAREN);
3203         return buf.toList();
3204     }
3205 
3206     /** AnnotationFieldValue    = AnnotationValue
3207      *                          | Identifier &quot;=&quot; AnnotationValue
3208      */
3209     JCExpression annotationFieldValue() {
3210         if (LAX_IDENTIFIER.accepts(token.kind)) {
3211             selectExprMode();
3212             JCExpression t1 = term1();
3213             if (t1.hasTag(IDENT) &amp;&amp; token.kind == EQ) {
3214                 int pos = token.pos;
3215                 accept(EQ);
3216                 JCExpression v = annotationValue();
3217                 return toP(F.at(pos).Assign(t1, v));
3218             } else {
3219                 return t1;
3220             }
3221         }
3222         return annotationValue();
3223     }
3224 
3225     /* AnnotationValue          = ConditionalExpression
3226      *                          | Annotation
3227      *                          | &quot;{&quot; [ AnnotationValue { &quot;,&quot; AnnotationValue } ] [&quot;,&quot;] &quot;}&quot;
3228      */
3229     JCExpression annotationValue() {
3230         int pos;
3231         switch (token.kind) {
3232         case MONKEYS_AT:
3233             pos = token.pos;
3234             nextToken();
3235             return annotation(pos, Tag.ANNOTATION);
3236         case LBRACE:
3237             pos = token.pos;
3238             accept(LBRACE);
3239             ListBuffer&lt;JCExpression&gt; buf = new ListBuffer&lt;&gt;();
3240             if (token.kind == COMMA) {
3241                 nextToken();
3242             } else if (token.kind != RBRACE) {
3243                 buf.append(annotationValue());
3244                 while (token.kind == COMMA) {
3245                     nextToken();
3246                     if (token.kind == RBRACE) break;
3247                     buf.append(annotationValue());
3248                 }
3249             }
3250             accept(RBRACE);
3251             return toP(F.at(pos).NewArray(null, List.nil(), buf.toList()));
3252         default:
3253             selectExprMode();
3254             return term1();
3255         }
3256     }
3257 
3258     /** VariableDeclarators = VariableDeclarator { &quot;,&quot; VariableDeclarator }
3259      */
3260     public &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclarators(JCModifiers mods,
3261                                                                          JCExpression type,
3262                                                                          T vdefs,
3263                                                                          boolean localDecl)
3264     {
3265         return variableDeclaratorsRest(token.pos, mods, type, ident(), false, null, vdefs, localDecl);
3266     }
3267 
3268     /** VariableDeclaratorsRest = VariableDeclaratorRest { &quot;,&quot; VariableDeclarator }
3269      *  ConstantDeclaratorsRest = ConstantDeclaratorRest { &quot;,&quot; ConstantDeclarator }
3270      *
3271      *  @param reqInit  Is an initializer always required?
3272      *  @param dc       The documentation comment for the variable declarations, or null.
3273      */
3274     protected &lt;T extends ListBuffer&lt;? super JCVariableDecl&gt;&gt; T variableDeclaratorsRest(int pos,
3275                                                                      JCModifiers mods,
3276                                                                      JCExpression type,
3277                                                                      Name name,
3278                                                                      boolean reqInit,
3279                                                                      Comment dc,
3280                                                                      T vdefs,
3281                                                                      boolean localDecl)
3282     {
3283         JCVariableDecl head = variableDeclaratorRest(pos, mods, type, name, reqInit, dc, localDecl, false);
3284         vdefs.append(head);
3285         while (token.kind == COMMA) {
3286             // All but last of multiple declarators subsume a comma
3287             storeEnd((JCTree)vdefs.last(), token.endPos);
3288             nextToken();
3289             vdefs.append(variableDeclarator(mods, type, reqInit, dc, localDecl));
3290         }
3291         return vdefs;
3292     }
3293 
3294     /** VariableDeclarator = Ident VariableDeclaratorRest
3295      *  ConstantDeclarator = Ident ConstantDeclaratorRest
3296      */
3297     JCVariableDecl variableDeclarator(JCModifiers mods, JCExpression type, boolean reqInit, Comment dc, boolean localDecl) {
3298         return variableDeclaratorRest(token.pos, mods, type, ident(), reqInit, dc, localDecl, true);
3299     }
3300 
3301     /** VariableDeclaratorRest = BracketsOpt [&quot;=&quot; VariableInitializer]
3302      *  ConstantDeclaratorRest = BracketsOpt &quot;=&quot; VariableInitializer
3303      *
3304      *  @param reqInit  Is an initializer always required?
3305      *  @param dc       The documentation comment for the variable declarations, or null.
3306      */
3307     JCVariableDecl variableDeclaratorRest(int pos, JCModifiers mods, JCExpression type, Name name,
3308                                   boolean reqInit, Comment dc, boolean localDecl, boolean compound) {
3309         type = bracketsOpt(type);
3310         JCExpression init = null;
3311         if (token.kind == EQ) {
3312             nextToken();
3313             init = variableInitializer();
3314         }
3315         else if (reqInit) syntaxError(token.pos, Errors.Expected(EQ));
3316         JCTree elemType = TreeInfo.innermostType(type, true);
3317         int startPos = Position.NOPOS;
3318         if (elemType.hasTag(IDENT)) {
3319             Name typeName = ((JCIdent)elemType).name;
3320             if (restrictedTypeNameStartingAtSource(typeName, pos, !compound &amp;&amp; localDecl) != null) {
3321                 if (type.hasTag(TYPEARRAY) &amp;&amp; !compound) {
3322                     //error - &#39;var&#39; and arrays
3323                     reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedArray(typeName));
3324                 } else {
3325                     if(compound)
3326                         //error - &#39;var&#39; in compound local var decl
3327                         reportSyntaxError(pos, Errors.RestrictedTypeNotAllowedCompound(typeName));
3328                     startPos = TreeInfo.getStartPos(mods);
3329                     if (startPos == Position.NOPOS)
3330                         startPos = TreeInfo.getStartPos(type);
3331                     //implicit type
3332                     type = null;
3333                 }
3334             }
3335         }
3336         JCVariableDecl result =
3337             toP(F.at(pos).VarDef(mods, name, type, init));
3338         attach(result, dc);
3339         result.startPos = startPos;
3340         return result;
3341     }
3342 
3343     Name restrictedTypeName(JCExpression e, boolean shouldWarn) {
3344         switch (e.getTag()) {
3345             case IDENT:
3346                 return restrictedTypeNameStartingAtSource(((JCIdent)e).name, e.pos, shouldWarn) != null ? ((JCIdent)e).name : null;
3347             case TYPEARRAY:
3348                 return restrictedTypeName(((JCArrayTypeTree)e).elemtype, shouldWarn);
3349             default:
3350                 return null;
3351         }
3352     }
3353 
3354     Source restrictedTypeNameStartingAtSource(Name name, int pos, boolean shouldWarn) {
3355         if (name == names.var) {
3356             if (Feature.LOCAL_VARIABLE_TYPE_INFERENCE.allowedInSource(source)) {
3357                 return Source.JDK10;
3358             } else if (shouldWarn) {
3359                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK10));
3360             }
3361         }
3362         if (name == names.yield) {
3363             if (allowYieldStatement) {
3364                 return Source.JDK14;
3365             } else if (shouldWarn) {
3366                 log.warning(pos, Warnings.RestrictedTypeNotAllowed(name, Source.JDK14));
3367             }
3368         }
3369         if (name == names.record) {
3370             if (allowRecords) {
3371                 return Source.JDK14;
3372             } else if (shouldWarn) {
3373                 log.warning(pos, Warnings.RestrictedTypeNotAllowedPreview(name, Source.JDK14));
3374             }
3375         }
3376         return null;
3377     }
3378 
3379     /** VariableDeclaratorId = Ident BracketsOpt
3380      */
3381     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type) {
3382         return variableDeclaratorId(mods, type, false);
3383     }
3384     //where
3385     JCVariableDecl variableDeclaratorId(JCModifiers mods, JCExpression type, boolean lambdaParameter) {
3386         int pos = token.pos;
3387         Name name;
3388         if (lambdaParameter &amp;&amp; token.kind == UNDERSCORE) {
3389             log.error(pos, Errors.UnderscoreAsIdentifierInLambda);
3390             name = token.name();
3391             nextToken();
3392         } else {
3393             if (allowThisIdent ||
3394                 !lambdaParameter ||
3395                 LAX_IDENTIFIER.accepts(token.kind) ||
3396                 mods.flags != Flags.PARAMETER ||
3397                 mods.annotations.nonEmpty()) {
3398                 JCExpression pn = qualident(false);
3399                 if (pn.hasTag(Tag.IDENT) &amp;&amp; ((JCIdent)pn).name != names._this) {
3400                     name = ((JCIdent)pn).name;
3401                 } else {
3402                     if (allowThisIdent) {
3403                         if ((mods.flags &amp; Flags.VARARGS) != 0) {
3404                             log.error(token.pos, Errors.VarargsAndReceiver);
3405                         }
3406                         if (token.kind == LBRACKET) {
3407                             log.error(token.pos, Errors.ArrayAndReceiver);
3408                         }
3409                         if (pn.hasTag(Tag.SELECT) &amp;&amp; ((JCFieldAccess)pn).name != names._this) {
3410                             log.error(token.pos, Errors.WrongReceiver);
3411                         }
3412                     }
3413                     return toP(F.at(pos).ReceiverVarDef(mods, pn, type));
3414                 }
3415             } else {
3416                 /** if it is a lambda parameter and the token kind is not an identifier,
3417                  *  and there are no modifiers or annotations, then this means that the compiler
3418                  *  supposed the lambda to be explicit but it can contain a mix of implicit,
3419                  *  var or explicit parameters. So we assign the error name to the parameter name
3420                  *  instead of issuing an error and analyze the lambda parameters as a whole at
3421                  *  a higher level.
3422                  */
3423                 name = names.empty;
3424             }
3425         }
3426         if ((mods.flags &amp; Flags.VARARGS) != 0 &amp;&amp;
3427                 token.kind == LBRACKET) {
3428             log.error(token.pos, Errors.VarargsAndOldArraySyntax);
3429         }
3430         type = bracketsOpt(type);
3431 
3432         return toP(F.at(pos).VarDef(mods, name, type, null));
3433     }
3434 
3435     /** Resources = Resource { &quot;;&quot; Resources }
3436      */
3437     List&lt;JCTree&gt; resources() {
3438         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3439         defs.append(resource());
3440         while (token.kind == SEMI) {
3441             // All but last of multiple declarators must subsume a semicolon
3442             storeEnd(defs.last(), token.endPos);
3443             int semiColonPos = token.pos;
3444             nextToken();
3445             if (token.kind == RPAREN) { // Optional trailing semicolon
3446                                        // after last resource
3447                 break;
3448             }
3449             defs.append(resource());
3450         }
3451         return defs.toList();
3452     }
3453 
3454     /** Resource = VariableModifiersOpt Type VariableDeclaratorId &quot;=&quot; Expression
3455      *           | Expression
3456      */
3457     protected JCTree resource() {
3458         int startPos = token.pos;
3459         if (token.kind == FINAL || token.kind == MONKEYS_AT) {
3460             JCModifiers mods = optFinal(Flags.FINAL);
3461             JCExpression t = parseType(true);
3462             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3463         }
3464         JCExpression t = term(EXPR | TYPE);
3465         if ((lastmode &amp; TYPE) != 0 &amp;&amp; LAX_IDENTIFIER.accepts(token.kind)) {
3466             JCModifiers mods = toP(F.at(startPos).Modifiers(Flags.FINAL));
3467             return variableDeclaratorRest(token.pos, mods, t, ident(), true, null, true, false);
3468         } else {
3469             checkSourceLevel(Feature.EFFECTIVELY_FINAL_VARIABLES_IN_TRY_WITH_RESOURCES);
3470             if (!t.hasTag(IDENT) &amp;&amp; !t.hasTag(SELECT)) {
3471                 log.error(t.pos(), Errors.TryWithResourcesExprNeedsVar);
3472             }
3473 
3474             return t;
3475         }
3476     }
3477 
3478     /** CompilationUnit = [ { &quot;@&quot; Annotation } PACKAGE Qualident &quot;;&quot;] {ImportDeclaration} {TypeDeclaration}
3479      */
3480     public JCTree.JCCompilationUnit parseCompilationUnit() {
3481         Token firstToken = token;
3482         JCModifiers mods = null;
3483         boolean consumedToplevelDoc = false;
3484         boolean seenImport = false;
3485         boolean seenPackage = false;
3486         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3487         if (token.kind == MONKEYS_AT)
3488             mods = modifiersOpt();
3489 
3490         if (token.kind == PACKAGE) {
3491             int packagePos = token.pos;
3492             List&lt;JCAnnotation&gt; annotations = List.nil();
3493             seenPackage = true;
3494             if (mods != null) {
3495                 checkNoMods(mods.flags);
3496                 annotations = mods.annotations;
3497                 mods = null;
3498             }
3499             nextToken();
3500             JCExpression pid = qualident(false);
3501             accept(SEMI);
3502             JCPackageDecl pd = toP(F.at(packagePos).PackageDecl(annotations, pid));
3503             attach(pd, firstToken.comment(CommentStyle.JAVADOC));
3504             consumedToplevelDoc = true;
3505             defs.append(pd);
3506         }
3507 
3508         boolean checkForImports = true;
3509         boolean firstTypeDecl = true;
3510         while (token.kind != EOF) {
3511             if (token.pos &lt;= endPosTable.errorEndPos) {
3512                 // error recovery
3513                 skip(checkForImports, false, false, false);
3514                 if (token.kind == EOF)
3515                     break;
3516             }
3517             if (checkForImports &amp;&amp; mods == null &amp;&amp; token.kind == IMPORT) {
3518                 seenImport = true;
3519                 defs.append(importDeclaration());
3520             } else {
3521                 Comment docComment = token.comment(CommentStyle.JAVADOC);
3522                 if (firstTypeDecl &amp;&amp; !seenImport &amp;&amp; !seenPackage) {
3523                     docComment = firstToken.comment(CommentStyle.JAVADOC);
3524                     consumedToplevelDoc = true;
3525                 }
3526                 if (mods != null || token.kind != SEMI)
3527                     mods = modifiersOpt(mods);
3528                 if (firstTypeDecl &amp;&amp; token.kind == IDENTIFIER) {
3529                     ModuleKind kind = ModuleKind.STRONG;
3530                     if (token.name() == names.open) {
3531                         kind = ModuleKind.OPEN;
3532                         nextToken();
3533                     }
3534                     if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.module) {
3535                         if (mods != null) {
3536                             checkNoMods(mods.flags &amp; ~Flags.DEPRECATED);
3537                         }
3538                         defs.append(moduleDecl(mods, kind, docComment));
3539                         consumedToplevelDoc = true;
3540                         break;
3541                     } else if (kind != ModuleKind.STRONG) {
3542                         reportSyntaxError(token.pos, Errors.ExpectedModule);
3543                     }
3544                 }
3545                 JCTree def = typeDeclaration(mods, docComment);
3546                 if (def instanceof JCExpressionStatement)
3547                     def = ((JCExpressionStatement)def).expr;
3548                 defs.append(def);
3549                 if (def instanceof JCClassDecl)
3550                     checkForImports = false;
3551                 mods = null;
3552                 firstTypeDecl = false;
3553             }
3554         }
3555         JCTree.JCCompilationUnit toplevel = F.at(firstToken.pos).TopLevel(defs.toList());
3556         if (!consumedToplevelDoc)
3557             attach(toplevel, firstToken.comment(CommentStyle.JAVADOC));
3558         if (defs.isEmpty())
3559             storeEnd(toplevel, S.prevToken().endPos);
3560         if (keepDocComments)
3561             toplevel.docComments = docComments;
3562         if (keepLineMap)
3563             toplevel.lineMap = S.getLineMap();
3564         this.endPosTable.setParser(null); // remove reference to parser
3565         toplevel.endPositions = this.endPosTable;
3566         return toplevel;
3567     }
3568 
3569     JCModuleDecl moduleDecl(JCModifiers mods, ModuleKind kind, Comment dc) {
3570         int pos = token.pos;
3571         checkSourceLevel(Feature.MODULES);
3572 
3573         nextToken();
3574         JCExpression name = qualident(false);
3575         List&lt;JCDirective&gt; directives = null;
3576 
3577         accept(LBRACE);
3578         directives = moduleDirectiveList();
3579         accept(RBRACE);
3580         accept(EOF);
3581 
3582         JCModuleDecl result = toP(F.at(pos).ModuleDef(mods, kind, name, directives));
3583         attach(result, dc);
3584         return result;
3585     }
3586 
3587     List&lt;JCDirective&gt; moduleDirectiveList() {
3588         ListBuffer&lt;JCDirective&gt; defs = new ListBuffer&lt;&gt;();
3589         while (token.kind == IDENTIFIER) {
3590             int pos = token.pos;
3591             if (token.name() == names.requires) {
3592                 nextToken();
3593                 boolean isTransitive = false;
3594                 boolean isStaticPhase = false;
3595             loop:
3596                 while (true) {
3597                     switch (token.kind) {
3598                         case IDENTIFIER:
3599                             if (token.name() == names.transitive &amp;&amp; !isTransitive) {
3600                                 Token t1 = S.token(1);
3601                                 if (t1.kind == SEMI || t1.kind == DOT) {
3602                                     break loop;
3603                                 }
3604                                 isTransitive = true;
3605                                 break;
3606                             } else {
3607                                 break loop;
3608                             }
3609                         case STATIC:
3610                             if (isStaticPhase) {
3611                                 log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.RepeatedModifier);
3612                             }
3613                             isStaticPhase = true;
3614                             break;
3615                         default:
3616                             break loop;
3617                     }
3618                     nextToken();
3619                 }
3620                 JCExpression moduleName = qualident(false);
3621                 accept(SEMI);
3622                 defs.append(toP(F.at(pos).Requires(isTransitive, isStaticPhase, moduleName)));
3623             } else if (token.name() == names.exports || token.name() == names.opens) {
3624                 boolean exports = token.name() == names.exports;
3625                 nextToken();
3626                 JCExpression pkgName = qualident(false);
3627                 List&lt;JCExpression&gt; moduleNames = null;
3628                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.to) {
3629                     nextToken();
3630                     moduleNames = qualidentList(false);
3631                 }
3632                 accept(SEMI);
3633                 JCDirective d;
3634                 if (exports) {
3635                     d = F.at(pos).Exports(pkgName, moduleNames);
3636                 } else {
3637                     d = F.at(pos).Opens(pkgName, moduleNames);
3638                 }
3639                 defs.append(toP(d));
3640             } else if (token.name() == names.provides) {
3641                 nextToken();
3642                 JCExpression serviceName = qualident(false);
3643                 if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.with) {
3644                     nextToken();
3645                     List&lt;JCExpression&gt; implNames = qualidentList(false);
3646                     accept(SEMI);
3647                     defs.append(toP(F.at(pos).Provides(serviceName, implNames)));
3648                 } else {
3649                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.ExpectedStr(&quot;&#39;&quot; + names.with + &quot;&#39;&quot;));
3650                     skip(false, false, false, false);
3651                 }
3652             } else if (token.name() == names.uses) {
3653                 nextToken();
3654                 JCExpression service = qualident(false);
3655                 accept(SEMI);
3656                 defs.append(toP(F.at(pos).Uses(service)));
3657             } else {
3658                 setErrorEndPos(pos);
3659                 reportSyntaxError(pos, Errors.InvalidModuleDirective);
3660                 break;
3661             }
3662         }
3663         return defs.toList();
3664     }
3665 
3666     /** ImportDeclaration = IMPORT [ STATIC ] Ident { &quot;.&quot; Ident } [ &quot;.&quot; &quot;*&quot; ] &quot;;&quot;
3667      */
3668     protected JCTree importDeclaration() {
3669         int pos = token.pos;
3670         nextToken();
3671         boolean importStatic = false;
3672         if (token.kind == STATIC) {
3673             importStatic = true;
3674             nextToken();
3675         }
3676         JCExpression pid = toP(F.at(token.pos).Ident(ident()));
3677         do {
3678             int pos1 = token.pos;
3679             accept(DOT);
3680             if (token.kind == STAR) {
3681                 pid = to(F.at(pos1).Select(pid, names.asterisk));
3682                 nextToken();
3683                 break;
3684             } else {
3685                 pid = toP(F.at(pos1).Select(pid, ident()));
3686             }
3687         } while (token.kind == DOT);
3688         accept(SEMI);
3689         return toP(F.at(pos).Import(pid, importStatic));
3690     }
3691 
3692     /** TypeDeclaration = ClassOrInterfaceOrEnumDeclaration
3693      *                  | &quot;;&quot;
3694      */
3695     JCTree typeDeclaration(JCModifiers mods, Comment docComment) {
3696         int pos = token.pos;
3697         if (mods == null &amp;&amp; token.kind == SEMI) {
3698             nextToken();
3699             return toP(F.at(pos).Skip());
3700         } else {
3701             return classOrRecordOrInterfaceOrEnumDeclaration(modifiersOpt(mods), docComment);
3702         }
3703     }
3704 
3705     /** ClassOrInterfaceOrEnumDeclaration = ModifiersOpt
3706      *           (ClassDeclaration | InterfaceDeclaration | EnumDeclaration)
3707      *  @param mods     Any modifiers starting the class or interface declaration
3708      *  @param dc       The documentation comment for the class, or null.
3709      */
3710     protected JCStatement classOrRecordOrInterfaceOrEnumDeclaration(JCModifiers mods, Comment dc) {
3711         if (token.kind == CLASS) {
3712             return classDeclaration(mods, dc);
3713         } if (isRecordStart()) {
3714             return recordDeclaration(mods, dc);
3715         } else if (token.kind == INTERFACE) {
3716             return interfaceDeclaration(mods, dc);
3717         } else if (token.kind == ENUM) {
3718             return enumDeclaration(mods, dc);
3719         } else {
3720             int pos = token.pos;
3721             List&lt;JCTree&gt; errs;
3722             if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp; preview.isEnabled()) {
3723                 checkSourceLevel(Feature.RECORDS);
3724                 JCErroneous erroneousTree = syntaxError(token.pos, List.of(mods), Errors.RecordHeaderExpected);
3725                 return toP(F.Exec(erroneousTree));
3726             } else {
3727                 if (LAX_IDENTIFIER.accepts(token.kind)) {
3728                     errs = List.of(mods, toP(F.at(pos).Ident(ident())));
3729                     setErrorEndPos(token.pos);
3730                 } else {
3731                     errs = List.of(mods);
3732                 }
3733                 final JCErroneous erroneousTree;
3734                 if (parseModuleInfo) {
3735                     erroneousTree = syntaxError(pos, errs, Errors.ExpectedModuleOrOpen);
3736                 } else {
3737                     if (allowRecords) {
3738                         erroneousTree = syntaxError(pos, errs, Errors.Expected4(CLASS, INTERFACE, ENUM, &quot;record&quot;));
3739                     } else {
3740                         erroneousTree = syntaxError(pos, errs, Errors.Expected3(CLASS, INTERFACE, ENUM));
3741                     }
3742                 }
3743                 return toP(F.Exec(erroneousTree));
3744             }
3745         }
3746     }
3747 
3748     /** ClassDeclaration = CLASS Ident TypeParametersOpt [EXTENDS Type]
3749      *                     [IMPLEMENTS TypeList] ClassBody
3750      *  @param mods    The modifiers starting the class declaration
3751      *  @param dc       The documentation comment for the class, or null.
3752      */
3753     protected JCClassDecl classDeclaration(JCModifiers mods, Comment dc) {
3754         int pos = token.pos;
3755         accept(CLASS);
3756         Name name = typeName();
3757 
3758         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3759 
3760         JCExpression extending = null;
3761         if (token.kind == EXTENDS) {
3762             nextToken();
3763             extending = parseType();
3764         }
3765         List&lt;JCExpression&gt; implementing = List.nil();
3766         if (token.kind == IMPLEMENTS) {
3767             nextToken();
3768             implementing = typeList();
3769         }
3770         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, false);
3771         JCClassDecl result = toP(F.at(pos).ClassDef(
3772             mods, name, typarams, extending, implementing, defs));
3773         attach(result, dc);
3774         return result;
3775     }
3776 
3777     protected JCClassDecl recordDeclaration(JCModifiers mods, Comment dc) {
3778         int pos = token.pos;
3779         nextToken();
3780         mods.flags |= Flags.RECORD;
3781         Name name = typeName();
3782 
3783         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3784 
3785         List&lt;JCVariableDecl&gt; headerFields = formalParameters(false, true);
3786 
3787         List&lt;JCExpression&gt; implementing = List.nil();
3788         if (token.kind == IMPLEMENTS) {
3789             nextToken();
3790             implementing = typeList();
3791         }
3792         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, false, true);
3793         java.util.List&lt;JCVariableDecl&gt; fields = new ArrayList&lt;&gt;();
3794         for (JCVariableDecl field : headerFields) {
3795             fields.add(field);
3796         }
3797         for (JCTree def : defs) {
3798             if (def.hasTag(METHODDEF)) {
3799                 JCMethodDecl methDef = (JCMethodDecl) def;
3800                 if (methDef.name == names.init &amp;&amp; methDef.params.isEmpty() &amp;&amp; (methDef.mods.flags &amp; Flags.COMPACT_RECORD_CONSTRUCTOR) != 0) {
3801                     ListBuffer&lt;JCVariableDecl&gt; tmpParams = new ListBuffer&lt;&gt;();
3802                     for (JCVariableDecl param : headerFields) {
3803                         tmpParams.add(F.at(param)
3804                                 // we will get flags plus annotations from the record component
3805                                 .VarDef(F.Modifiers(Flags.PARAMETER | param.mods.flags &amp; Flags.VARARGS, param.mods.annotations),
3806                                 param.name, param.vartype, null));
3807                     }
3808                     methDef.params = tmpParams.toList();
3809                 }
3810             }
3811         }
3812         for (int i = fields.size() - 1; i &gt;= 0; i--) {
3813             JCVariableDecl field = fields.get(i);
3814             defs = defs.prepend(field);
3815         }
3816         JCClassDecl result = toP(F.at(pos).ClassDef(mods, name, typarams, null, implementing, defs));
3817         attach(result, dc);
3818         return result;
3819     }
3820 
3821     Name typeName() {
3822         int pos = token.pos;
3823         Name name = ident();
3824         Source source = restrictedTypeNameStartingAtSource(name, pos, true);
3825         if (source != null) {
3826             reportSyntaxError(pos, Errors.RestrictedTypeNotAllowed(name, source));
3827         }
3828         return name;
3829     }
3830 
3831     /** InterfaceDeclaration = INTERFACE Ident TypeParametersOpt
3832      *                         [EXTENDS TypeList] InterfaceBody
3833      *  @param mods    The modifiers starting the interface declaration
3834      *  @param dc       The documentation comment for the interface, or null.
3835      */
3836     protected JCClassDecl interfaceDeclaration(JCModifiers mods, Comment dc) {
3837         int pos = token.pos;
3838         accept(INTERFACE);
3839 
3840         Name name = typeName();
3841 
3842         List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
3843 
3844         List&lt;JCExpression&gt; extending = List.nil();
3845         if (token.kind == EXTENDS) {
3846             nextToken();
3847             extending = typeList();
3848         }
3849         List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(name, true, false);
3850         JCClassDecl result = toP(F.at(pos).ClassDef(
3851             mods, name, typarams, null, extending, defs));
3852         attach(result, dc);
3853         return result;
3854     }
3855 
3856     /** EnumDeclaration = ENUM Ident [IMPLEMENTS TypeList] EnumBody
3857      *  @param mods    The modifiers starting the enum declaration
3858      *  @param dc       The documentation comment for the enum, or null.
3859      */
3860     protected JCClassDecl enumDeclaration(JCModifiers mods, Comment dc) {
3861         int pos = token.pos;
3862         accept(ENUM);
3863 
3864         Name name = typeName();
3865 
3866         List&lt;JCExpression&gt; implementing = List.nil();
3867         if (token.kind == IMPLEMENTS) {
3868             nextToken();
3869             implementing = typeList();
3870         }
3871 
3872         List&lt;JCTree&gt; defs = enumBody(name);
3873         mods.flags |= Flags.ENUM;
3874         JCClassDecl result = toP(F.at(pos).
3875             ClassDef(mods, name, List.nil(),
3876                      null, implementing, defs));
3877         attach(result, dc);
3878         return result;
3879     }
3880 
3881     /** EnumBody = &quot;{&quot; { EnumeratorDeclarationList } [&quot;,&quot;]
3882      *                  [ &quot;;&quot; {ClassBodyDeclaration} ] &quot;}&quot;
3883      */
3884     List&lt;JCTree&gt; enumBody(Name enumName) {
3885         accept(LBRACE);
3886         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
3887         boolean wasSemi = false;
3888         boolean hasStructuralErrors = false;
3889         boolean wasError = false;
3890         if (token.kind == COMMA) {
3891             nextToken();
3892             if (token.kind == SEMI) {
3893                 wasSemi = true;
3894                 nextToken();
3895             } else if (token.kind != RBRACE) {
3896                 reportSyntaxError(S.prevToken().endPos,
3897                                   Errors.Expected2(RBRACE, SEMI));
3898                 wasError = true;
3899             }
3900         }
3901         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
3902             if (token.kind == SEMI) {
3903                 accept(SEMI);
3904                 wasSemi = true;
3905                 if (token.kind == RBRACE || token.kind == EOF) break;
3906             }
3907             EnumeratorEstimate memberType = estimateEnumeratorOrMember(enumName);
3908             if (memberType == EnumeratorEstimate.UNKNOWN) {
3909                 memberType = wasSemi ? EnumeratorEstimate.MEMBER
3910                                      : EnumeratorEstimate.ENUMERATOR;
3911             }
3912             if (memberType == EnumeratorEstimate.ENUMERATOR) {
3913                 wasError = false;
3914                 if (wasSemi &amp;&amp; !hasStructuralErrors) {
3915                     reportSyntaxError(token.pos, Errors.EnumConstantNotExpected);
3916                     hasStructuralErrors = true;
3917                 }
3918                 defs.append(enumeratorDeclaration(enumName));
3919                 if (token.pos &lt;= endPosTable.errorEndPos) {
3920                     // error recovery
3921                    skip(false, true, true, false);
3922                 } else {
3923                     if (token.kind != RBRACE &amp;&amp; token.kind != SEMI &amp;&amp; token.kind != EOF) {
3924                         if (token.kind == COMMA) {
3925                             nextToken();
3926                         } else {
3927                             setErrorEndPos(token.pos);
3928                             reportSyntaxError(S.prevToken().endPos,
3929                                               Errors.Expected3(COMMA, RBRACE, SEMI));
3930                             wasError = true;
3931                         }
3932                     }
3933                 }
3934             } else {
3935                 if (!wasSemi &amp;&amp; !hasStructuralErrors &amp;&amp; !wasError) {
3936                     reportSyntaxError(token.pos, Errors.EnumConstantExpected);
3937                     hasStructuralErrors = true;
3938                 }
3939                 wasError = false;
3940                 defs.appendList(classOrInterfaceOrRecordBodyDeclaration(enumName,
3941                                                                 false, false));
3942                 if (token.pos &lt;= endPosTable.errorEndPos) {
3943                     // error recovery
3944                    skip(false, true, true, false);
3945                 }
3946             }
3947         }
3948         accept(RBRACE);
3949         return defs.toList();
3950     }
3951 
3952     private EnumeratorEstimate estimateEnumeratorOrMember(Name enumName) {
3953         if (token.kind == TokenKind.IDENTIFIER &amp;&amp; token.name() != enumName) {
3954             Token next = S.token(1);
3955             switch (next.kind) {
3956                 case LPAREN: case LBRACE: case COMMA: case SEMI:
3957                     return EnumeratorEstimate.ENUMERATOR;
3958             }
3959         }
3960         switch (token.kind) {
3961             case IDENTIFIER: case MONKEYS_AT: case LT:
3962                 return EnumeratorEstimate.UNKNOWN;
3963             default:
3964                 return EnumeratorEstimate.MEMBER;
3965         }
3966     }
3967 
3968     private enum EnumeratorEstimate {
3969         ENUMERATOR,
3970         MEMBER,
3971         UNKNOWN;
3972     }
3973 
3974     /** EnumeratorDeclaration = AnnotationsOpt [TypeArguments] IDENTIFIER [ Arguments ] [ &quot;{&quot; ClassBody &quot;}&quot; ]
3975      */
3976     JCTree enumeratorDeclaration(Name enumName) {
3977         Comment dc = token.comment(CommentStyle.JAVADOC);
3978         int flags = Flags.PUBLIC|Flags.STATIC|Flags.FINAL|Flags.ENUM;
3979         if (token.deprecatedFlag()) {
3980             flags |= Flags.DEPRECATED;
3981         }
3982         int pos = token.pos;
3983         List&lt;JCAnnotation&gt; annotations = annotationsOpt(Tag.ANNOTATION);
3984         JCModifiers mods = F.at(annotations.isEmpty() ? Position.NOPOS : pos).Modifiers(flags, annotations);
3985         List&lt;JCExpression&gt; typeArgs = typeArgumentsOpt();
3986         int identPos = token.pos;
3987         Name name = ident();
3988         int createPos = token.pos;
3989         List&lt;JCExpression&gt; args = (token.kind == LPAREN)
3990             ? arguments() : List.nil();
3991         JCClassDecl body = null;
3992         if (token.kind == LBRACE) {
3993             JCModifiers mods1 = F.at(Position.NOPOS).Modifiers(Flags.ENUM);
3994             List&lt;JCTree&gt; defs = classInterfaceOrRecordBody(names.empty, false, false);
3995             body = toP(F.at(identPos).AnonymousClassDef(mods1, defs));
3996         }
3997         if (args.isEmpty() &amp;&amp; body == null)
3998             createPos = identPos;
3999         JCIdent ident = F.at(identPos).Ident(enumName);
4000         JCNewClass create = F.at(createPos).NewClass(null, typeArgs, ident, args, body);
4001         if (createPos != identPos)
4002             storeEnd(create, S.prevToken().endPos);
4003         ident = F.at(identPos).Ident(enumName);
4004         JCTree result = toP(F.at(pos).VarDef(mods, name, ident, create));
4005         attach(result, dc);
4006         return result;
4007     }
4008 
4009     /** TypeList = Type {&quot;,&quot; Type}
4010      */
4011     List&lt;JCExpression&gt; typeList() {
4012         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4013         ts.append(parseType());
4014         while (token.kind == COMMA) {
4015             nextToken();
4016             ts.append(parseType());
4017         }
4018         return ts.toList();
4019     }
4020 
4021     /** ClassBody     = &quot;{&quot; {ClassBodyDeclaration} &quot;}&quot;
4022      *  InterfaceBody = &quot;{&quot; {InterfaceBodyDeclaration} &quot;}&quot;
4023      */
4024     List&lt;JCTree&gt; classInterfaceOrRecordBody(Name className, boolean isInterface, boolean isRecord) {
4025         accept(LBRACE);
4026         if (token.pos &lt;= endPosTable.errorEndPos) {
4027             // error recovery
4028             skip(false, true, false, false);
4029             if (token.kind == LBRACE)
4030                 nextToken();
4031         }
4032         ListBuffer&lt;JCTree&gt; defs = new ListBuffer&lt;&gt;();
4033         while (token.kind != RBRACE &amp;&amp; token.kind != EOF) {
4034             defs.appendList(classOrInterfaceOrRecordBodyDeclaration(className, isInterface, isRecord));
4035             if (token.pos &lt;= endPosTable.errorEndPos) {
4036                // error recovery
4037                skip(false, true, true, false);
4038            }
4039         }
4040         accept(RBRACE);
4041         return defs.toList();
4042     }
4043 
4044     /** ClassBodyDeclaration =
4045      *      &quot;;&quot;
4046      *    | [STATIC] Block
4047      *    | ModifiersOpt
4048      *      ( Type Ident
4049      *        ( VariableDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4050      *      | VOID Ident VoidMethodDeclaratorRest
4051      *      | TypeParameters [Annotations]
4052      *        ( Type Ident MethodDeclaratorRest
4053      *        | VOID Ident VoidMethodDeclaratorRest
4054      *        )
4055      *      | Ident ConstructorDeclaratorRest
4056      *      | TypeParameters Ident ConstructorDeclaratorRest
4057      *      | ClassOrInterfaceOrEnumDeclaration
4058      *      )
4059      *  InterfaceBodyDeclaration =
4060      *      &quot;;&quot;
4061      *    | ModifiersOpt
4062      *      ( Type Ident
4063      *        ( ConstantDeclaratorsRest &quot;;&quot; | MethodDeclaratorRest )
4064      *      | VOID Ident MethodDeclaratorRest
4065      *      | TypeParameters [Annotations]
4066      *        ( Type Ident MethodDeclaratorRest
4067      *        | VOID Ident VoidMethodDeclaratorRest
4068      *        )
4069      *      | ClassOrInterfaceOrEnumDeclaration
4070      *      )
4071      *
4072      */
4073     protected List&lt;JCTree&gt; classOrInterfaceOrRecordBodyDeclaration(Name className, boolean isInterface, boolean isRecord) {
4074         if (token.kind == SEMI) {
4075             nextToken();
4076             return List.nil();
4077         } else {
4078             Comment dc = token.comment(CommentStyle.JAVADOC);
4079             int pos = token.pos;
4080             JCModifiers mods = modifiersOpt();
4081             if (token.kind == CLASS ||
4082                 allowRecords &amp;&amp; isRecordStart() ||
4083                 token.kind == INTERFACE ||
4084                 token.kind == ENUM) {
4085                 return List.of(classOrRecordOrInterfaceOrEnumDeclaration(mods, dc));
4086             } else if (token.kind == LBRACE &amp;&amp;
4087                        (mods.flags &amp; Flags.StandardFlags &amp; ~Flags.STATIC) == 0 &amp;&amp;
4088                        mods.annotations.isEmpty()) {
4089                 if (isInterface) {
4090                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InitializerNotAllowed);
4091                 } else if (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) == 0) {
4092                     log.error(DiagnosticFlag.SYNTAX, token.pos, Errors.InstanceInitializerNotAllowedInRecords);
4093                 }
4094                 return List.of(block(pos, mods.flags));
4095             } else {
4096                 pos = token.pos;
4097                 List&lt;JCTypeParameter&gt; typarams = typeParametersOpt();
4098                 // if there are type parameters but no modifiers, save the start
4099                 // position of the method in the modifiers.
4100                 if (typarams.nonEmpty() &amp;&amp; mods.pos == Position.NOPOS) {
4101                     mods.pos = pos;
4102                     storeEnd(mods, pos);
4103                 }
4104                 List&lt;JCAnnotation&gt; annosAfterParams = annotationsOpt(Tag.ANNOTATION);
4105 
4106                 if (annosAfterParams.nonEmpty()) {
4107                     checkSourceLevel(annosAfterParams.head.pos, Feature.ANNOTATIONS_AFTER_TYPE_PARAMS);
4108                     mods.annotations = mods.annotations.appendList(annosAfterParams);
4109                     if (mods.pos == Position.NOPOS)
4110                         mods.pos = mods.annotations.head.pos;
4111                 }
4112 
4113                 Token tk = token;
4114                 pos = token.pos;
4115                 JCExpression type;
4116                 boolean isVoid = token.kind == VOID;
4117                 if (isVoid) {
4118                     type = to(F.at(pos).TypeIdent(TypeTag.VOID));
4119                     nextToken();
4120                 } else {
4121                     // method returns types are un-annotated types
4122                     type = unannotatedType(false);
4123                 }
4124                 if ((token.kind == LPAREN &amp;&amp; !isInterface ||
4125                         isRecord &amp;&amp; token.kind == LBRACE) &amp;&amp; type.hasTag(IDENT)) {
4126                     if (isInterface || tk.name() != className)
4127                         log.error(DiagnosticFlag.SYNTAX, pos, Errors.InvalidMethDeclRetTypeReq);
4128                     else if (annosAfterParams.nonEmpty())
4129                         illegal(annosAfterParams.head.pos);
4130                     if (isRecord &amp;&amp; token.kind == LBRACE) {
4131                         mods.flags |= Flags.COMPACT_RECORD_CONSTRUCTOR;
4132                     }
4133                     return List.of(methodDeclaratorRest(
4134                         pos, mods, null, names.init, typarams,
4135                         isInterface, true, isRecord, dc));
4136                 } else if (isRecord &amp;&amp; type.hasTag(IDENT) &amp;&amp; token.kind == THROWS) {
4137                     // trying to define a compact constructor with a throws clause
4138                     log.error(DiagnosticFlag.SYNTAX, token.pos,
4139                             Errors.InvalidCanonicalConstructorInRecord(
4140                                     Fragments.Compact,
4141                                     className,
4142                                     Fragments.ThrowsClauseNotAllowedForCanonicalConstructor(Fragments.Compact)));
4143                     skip(false, true, false, false);
4144                     return List.of(methodDeclaratorRest(
4145                             pos, mods, null, names.init, typarams,
4146                             isInterface, true, isRecord, dc));
4147                 } else {
4148                     pos = token.pos;
4149                     Name name = ident();
4150                     if (token.kind == LPAREN) {
4151                         return List.of(methodDeclaratorRest(
4152                             pos, mods, type, name, typarams,
4153                             isInterface, isVoid, false, dc));
4154                     } else if (!isVoid &amp;&amp; typarams.isEmpty()) {
4155                         if (!isRecord || (isRecord &amp;&amp; (mods.flags &amp; Flags.STATIC) != 0)) {
4156                         List&lt;JCTree&gt; defs =
4157                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4158                                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4159                         accept(SEMI);
4160                         storeEnd(defs.last(), S.prevToken().endPos);
4161                         return defs;
4162                     } else {
4163                             int errPos = pos;
4164                             variableDeclaratorsRest(pos, mods, type, name, isInterface, dc,
4165                                     new ListBuffer&lt;JCTree&gt;(), false).toList();
4166                             accept(SEMI);
4167                             return List.of(syntaxError(errPos, null, Errors.RecordCannotDeclareInstanceFields));
4168                         }
4169                     } else {
4170                         pos = token.pos;
4171                         List&lt;JCTree&gt; err;
4172                         if (isVoid || typarams.nonEmpty()) {
4173                             JCMethodDecl m =
4174                                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4175                                                             List.nil(), List.nil(), null, null));
4176                             attach(m, dc);
4177                             err = List.of(m);
4178                         } else {
4179                             err = List.nil();
4180                         }
4181                         return List.of(syntaxError(token.pos, err, Errors.Expected(LPAREN)));
4182                     }
4183                 }
4184             }
4185         }
4186     }
4187 
4188     protected boolean isRecordStart() {
4189      if (token.kind == IDENTIFIER &amp;&amp; token.name() == names.record &amp;&amp;
4190             (peekToken(TokenKind.IDENTIFIER, TokenKind.LPAREN) ||
4191              peekToken(TokenKind.IDENTIFIER, TokenKind.EOF) ||
4192              peekToken(TokenKind.IDENTIFIER, TokenKind.LT))) {
4193           checkSourceLevel(Feature.RECORDS);
4194           return true;
4195     } else {
4196        return false;
4197    }
4198 }
4199 
4200     /** MethodDeclaratorRest =
4201      *      FormalParameters BracketsOpt [THROWS TypeList] ( MethodBody | [DEFAULT AnnotationValue] &quot;;&quot;)
4202      *  VoidMethodDeclaratorRest =
4203      *      FormalParameters [THROWS TypeList] ( MethodBody | &quot;;&quot;)
4204      *  ConstructorDeclaratorRest =
4205      *      &quot;(&quot; FormalParameterListOpt &quot;)&quot; [THROWS TypeList] MethodBody
4206      */
4207     protected JCTree methodDeclaratorRest(int pos,
4208                               JCModifiers mods,
4209                               JCExpression type,
4210                               Name name,
4211                               List&lt;JCTypeParameter&gt; typarams,
4212                               boolean isInterface, boolean isVoid,
4213                               boolean isRecord,
4214                               Comment dc) {
4215         if (isInterface) {
4216             if ((mods.flags &amp; Flags.STATIC) != 0) {
4217                 checkSourceLevel(Feature.STATIC_INTERFACE_METHODS);
4218             }
4219             if ((mods.flags &amp; Flags.PRIVATE) != 0) {
4220                 checkSourceLevel(Feature.PRIVATE_INTERFACE_METHODS);
4221             }
4222         }
4223         JCVariableDecl prevReceiverParam = this.receiverParam;
4224         try {
4225             this.receiverParam = null;
4226             // Parsing formalParameters sets the receiverParam, if present
4227             List&lt;JCVariableDecl&gt; params = List.nil();
4228             List&lt;JCExpression&gt; thrown = List.nil();
4229             if (!isRecord || name != names.init || token.kind == LPAREN) {
4230                 params = formalParameters();
4231                 if (!isVoid) type = bracketsOpt(type);
4232                 if (token.kind == THROWS) {
4233                     nextToken();
4234                     thrown = qualidentList(true);
4235                 }
4236             }
4237             JCBlock body = null;
4238             JCExpression defaultValue;
4239             if (token.kind == LBRACE) {
4240                 body = block();
4241                 defaultValue = null;
4242             } else {
4243                 if (token.kind == DEFAULT) {
4244                     accept(DEFAULT);
4245                     defaultValue = annotationValue();
4246                 } else {
4247                     defaultValue = null;
4248                 }
4249                 accept(SEMI);
4250                 if (token.pos &lt;= endPosTable.errorEndPos) {
4251                     // error recovery
4252                     skip(false, true, false, false);
4253                     if (token.kind == LBRACE) {
4254                         body = block();
4255                     }
4256                 }
4257             }
4258 
4259             JCMethodDecl result =
4260                     toP(F.at(pos).MethodDef(mods, name, type, typarams,
4261                                             receiverParam, params, thrown,
4262                                             body, defaultValue));
4263             attach(result, dc);
4264             return result;
4265         } finally {
4266             this.receiverParam = prevReceiverParam;
4267         }
4268     }
4269 
4270     /** QualidentList = [Annotations] Qualident {&quot;,&quot; [Annotations] Qualident}
4271      */
4272     List&lt;JCExpression&gt; qualidentList(boolean allowAnnos) {
4273         ListBuffer&lt;JCExpression&gt; ts = new ListBuffer&lt;&gt;();
4274 
4275         List&lt;JCAnnotation&gt; typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4276         JCExpression qi = qualident(allowAnnos);
4277         if (!typeAnnos.isEmpty()) {
4278             JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4279             ts.append(at);
4280         } else {
4281             ts.append(qi);
4282         }
4283         while (token.kind == COMMA) {
4284             nextToken();
4285 
4286             typeAnnos = allowAnnos ? typeAnnotationsOpt() : List.nil();
4287             qi = qualident(allowAnnos);
4288             if (!typeAnnos.isEmpty()) {
4289                 JCExpression at = insertAnnotationsToMostInner(qi, typeAnnos, false);
4290                 ts.append(at);
4291             } else {
4292                 ts.append(qi);
4293             }
4294         }
4295         return ts.toList();
4296     }
4297 
4298     /**
4299      *  {@literal
4300      *  TypeParametersOpt = [&quot;&lt;&quot; TypeParameter {&quot;,&quot; TypeParameter} &quot;&gt;&quot;]
4301      *  }
4302      */
4303     protected List&lt;JCTypeParameter&gt; typeParametersOpt() {
4304         if (token.kind == LT) {
4305             ListBuffer&lt;JCTypeParameter&gt; typarams = new ListBuffer&lt;&gt;();
4306             nextToken();
4307             typarams.append(typeParameter());
4308             while (token.kind == COMMA) {
4309                 nextToken();
4310                 typarams.append(typeParameter());
4311             }
4312             accept(GT);
4313             return typarams.toList();
4314         } else {
4315             return List.nil();
4316         }
4317     }
4318 
4319     /**
4320      *  {@literal
4321      *  TypeParameter = [Annotations] TypeVariable [TypeParameterBound]
4322      *  TypeParameterBound = EXTENDS Type {&quot;&amp;&quot; Type}
4323      *  TypeVariable = Ident
4324      *  }
4325      */
4326     JCTypeParameter typeParameter() {
4327         int pos = token.pos;
4328         List&lt;JCAnnotation&gt; annos = typeAnnotationsOpt();
4329         Name name = typeName();
4330         ListBuffer&lt;JCExpression&gt; bounds = new ListBuffer&lt;&gt;();
4331         if (token.kind == EXTENDS) {
4332             nextToken();
4333             bounds.append(parseType());
4334             while (token.kind == AMP) {
4335                 nextToken();
4336                 bounds.append(parseType());
4337             }
4338         }
4339         return toP(F.at(pos).TypeParameter(name, bounds.toList(), annos));
4340     }
4341 
4342     /** FormalParameters = &quot;(&quot; [ FormalParameterList ] &quot;)&quot;
4343      *  FormalParameterList = [ FormalParameterListNovarargs , ] LastFormalParameter
4344      *  FormalParameterListNovarargs = [ FormalParameterListNovarargs , ] FormalParameter
4345      */
4346     List&lt;JCVariableDecl&gt; formalParameters() {
4347         return formalParameters(false, false);
4348     }
4349     List&lt;JCVariableDecl&gt; formalParameters(boolean lambdaParameters, boolean recordComponents) {
4350         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4351         JCVariableDecl lastParam;
4352         accept(LPAREN);
4353         if (token.kind != RPAREN) {
4354             this.allowThisIdent = !lambdaParameters &amp;&amp; !recordComponents;
4355             lastParam = formalParameter(lambdaParameters, recordComponents);
4356             if (lastParam.nameexpr != null) {
4357                 this.receiverParam = lastParam;
4358             } else {
4359                 params.append(lastParam);
4360             }
4361             this.allowThisIdent = false;
4362             while (token.kind == COMMA) {
4363                 if ((lastParam.mods.flags &amp; Flags.VARARGS) != 0) {
4364                     log.error(DiagnosticFlag.SYNTAX, lastParam, Errors.VarargsMustBeLast);
4365                 }
4366                 nextToken();
4367                 params.append(lastParam = formalParameter(lambdaParameters, recordComponents));
4368             }
4369         }
4370         if (token.kind == RPAREN) {
4371             nextToken();
4372         } else {
4373             setErrorEndPos(token.pos);
4374             reportSyntaxError(S.prevToken().endPos, Errors.Expected3(COMMA, RPAREN, LBRACKET));
4375         }
4376         return params.toList();
4377     }
4378 
4379     List&lt;JCVariableDecl&gt; implicitParameters(boolean hasParens) {
4380         if (hasParens) {
4381             accept(LPAREN);
4382         }
4383         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
4384         if (token.kind != RPAREN &amp;&amp; token.kind != ARROW) {
4385             params.append(implicitParameter());
4386             while (token.kind == COMMA) {
4387                 nextToken();
4388                 params.append(implicitParameter());
4389             }
4390         }
4391         if (hasParens) {
4392             accept(RPAREN);
4393         }
4394         return params.toList();
4395     }
4396 
4397     JCModifiers optFinal(long flags) {
4398         JCModifiers mods = modifiersOpt();
4399         checkNoMods(mods.flags &amp; ~(Flags.FINAL | Flags.DEPRECATED));
4400         mods.flags |= flags;
4401         return mods;
4402     }
4403 
4404     /**
4405      * Inserts the annotations (and possibly a new array level)
4406      * to the left-most type in an array or nested type.
4407      *
4408      * When parsing a type like {@code @B Outer.Inner @A []}, the
4409      * {@code @A} annotation should target the array itself, while
4410      * {@code @B} targets the nested type {@code Outer}.
4411      *
4412      * Currently the parser parses the annotation first, then
4413      * the array, and then inserts the annotation to the left-most
4414      * nested type.
4415      *
4416      * When {@code createNewLevel} is true, then a new array
4417      * level is inserted as the most inner type, and have the
4418      * annotations target it.  This is useful in the case of
4419      * varargs, e.g. {@code String @A [] @B ...}, as the parser
4420      * first parses the type {@code String @A []} then inserts
4421      * a new array level with {@code @B} annotation.
4422      */
4423     private JCExpression insertAnnotationsToMostInner(
4424             JCExpression type, List&lt;JCAnnotation&gt; annos,
4425             boolean createNewLevel) {
4426         int origEndPos = getEndPos(type);
4427         JCExpression mostInnerType = type;
4428         JCArrayTypeTree mostInnerArrayType = null;
4429         while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEARRAY)) {
4430             mostInnerArrayType = (JCArrayTypeTree) TreeInfo.typeIn(mostInnerType);
4431             mostInnerType = mostInnerArrayType.elemtype;
4432         }
4433 
4434         if (createNewLevel) {
4435             mostInnerType = to(F.at(token.pos).TypeArray(mostInnerType));
4436         }
4437 
4438         JCExpression mostInnerTypeToReturn = mostInnerType;
4439         if (annos.nonEmpty()) {
4440             JCExpression lastToModify = mostInnerType;
4441 
4442             while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT) ||
4443                     TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4444                 while (TreeInfo.typeIn(mostInnerType).hasTag(SELECT)) {
4445                     lastToModify = mostInnerType;
4446                     mostInnerType = ((JCFieldAccess) TreeInfo.typeIn(mostInnerType)).getExpression();
4447                 }
4448                 while (TreeInfo.typeIn(mostInnerType).hasTag(TYPEAPPLY)) {
4449                     lastToModify = mostInnerType;
4450                     mostInnerType = ((JCTypeApply) TreeInfo.typeIn(mostInnerType)).clazz;
4451                 }
4452             }
4453 
4454             mostInnerType = F.at(annos.head.pos).AnnotatedType(annos, mostInnerType);
4455 
4456             if (TreeInfo.typeIn(lastToModify).hasTag(TYPEAPPLY)) {
4457                 ((JCTypeApply) TreeInfo.typeIn(lastToModify)).clazz = mostInnerType;
4458             } else if (TreeInfo.typeIn(lastToModify).hasTag(SELECT)) {
4459                 ((JCFieldAccess) TreeInfo.typeIn(lastToModify)).selected = mostInnerType;
4460             } else {
4461                 // We never saw a SELECT or TYPEAPPLY, return the annotated type.
4462                 mostInnerTypeToReturn = mostInnerType;
4463             }
4464         }
4465 
4466         if (mostInnerArrayType == null) {
4467             return mostInnerTypeToReturn;
4468         } else {
4469             mostInnerArrayType.elemtype = mostInnerTypeToReturn;
4470             storeEnd(type, origEndPos);
4471             return type;
4472         }
4473     }
4474 
4475     /** FormalParameter = { FINAL | &#39;@&#39; Annotation } Type VariableDeclaratorId
4476      *  LastFormalParameter = { FINAL | &#39;@&#39; Annotation } Type &#39;...&#39; Ident | FormalParameter
4477      */
4478     protected JCVariableDecl formalParameter(boolean lambdaParameter, boolean recordComponent) {
4479         JCModifiers mods = !recordComponent ? optFinal(Flags.PARAMETER) : modifiersOpt();
4480         if (recordComponent &amp;&amp; mods.flags != 0) {
4481             log.error(mods.pos, Errors.RecordCantDeclareFieldModifiers);
4482         }
4483         if (recordComponent) {
4484             mods.flags |= Flags.RECORD | Flags.FINAL | Flags.PRIVATE | Flags.GENERATED_MEMBER;
4485         }
4486         // need to distinguish between vararg annos and array annos
4487         // look at typeAnnotationsPushedBack comment
4488         this.permitTypeAnnotationsPushBack = true;
4489         JCExpression type = parseType(lambdaParameter);
4490         this.permitTypeAnnotationsPushBack = false;
4491 
4492         if (token.kind == ELLIPSIS) {
4493             List&lt;JCAnnotation&gt; varargsAnnos = typeAnnotationsPushedBack;
4494             typeAnnotationsPushedBack = List.nil();
4495             mods.flags |= Flags.VARARGS;
4496             // insert var arg type annotations
4497             type = insertAnnotationsToMostInner(type, varargsAnnos, true);
4498             nextToken();
4499         } else {
4500             // if not a var arg, then typeAnnotationsPushedBack should be null
4501             if (typeAnnotationsPushedBack.nonEmpty()) {
4502                 reportSyntaxError(typeAnnotationsPushedBack.head.pos, Errors.IllegalStartOfType);
4503             }
4504             typeAnnotationsPushedBack = List.nil();
4505         }
4506         return variableDeclaratorId(mods, type, lambdaParameter);
4507     }
4508 
4509     protected JCVariableDecl implicitParameter() {
4510         JCModifiers mods = F.at(token.pos).Modifiers(Flags.PARAMETER);
4511         return variableDeclaratorId(mods, null, true);
4512     }
4513 
4514 /* ---------- auxiliary methods -------------- */
4515     /** Check that given tree is a legal expression statement.
4516      */
4517     protected JCExpression checkExprStat(JCExpression t) {
4518         if (!TreeInfo.isExpressionStatement(t)) {
4519             JCExpression ret = F.at(t.pos).Erroneous(List.&lt;JCTree&gt;of(t));
4520             log.error(DiagnosticFlag.SYNTAX, ret, Errors.NotStmt);
4521             return ret;
4522         } else {
4523             return t;
4524         }
4525     }
4526 
4527     /** Return precedence of operator represented by token,
4528      *  -1 if token is not a binary operator. @see TreeInfo.opPrec
4529      */
4530     static int prec(TokenKind token) {
4531         JCTree.Tag oc = optag(token);
4532         return (oc != NO_TAG) ? TreeInfo.opPrec(oc) : -1;
4533     }
4534 
4535     /**
4536      * Return the lesser of two positions, making allowance for either one
4537      * being unset.
4538      */
4539     static int earlier(int pos1, int pos2) {
4540         if (pos1 == Position.NOPOS)
4541             return pos2;
4542         if (pos2 == Position.NOPOS)
4543             return pos1;
4544         return (pos1 &lt; pos2 ? pos1 : pos2);
4545     }
4546 
4547     /** Return operation tag of binary operator represented by token,
4548      *  No_TAG if token is not a binary operator.
4549      */
4550     static JCTree.Tag optag(TokenKind token) {
4551         switch (token) {
4552         case BARBAR:
4553             return OR;
4554         case AMPAMP:
4555             return AND;
4556         case BAR:
4557             return BITOR;
4558         case BAREQ:
4559             return BITOR_ASG;
4560         case CARET:
4561             return BITXOR;
4562         case CARETEQ:
4563             return BITXOR_ASG;
4564         case AMP:
4565             return BITAND;
4566         case AMPEQ:
4567             return BITAND_ASG;
4568         case EQEQ:
4569             return JCTree.Tag.EQ;
4570         case BANGEQ:
4571             return NE;
4572         case LT:
4573             return JCTree.Tag.LT;
4574         case GT:
4575             return JCTree.Tag.GT;
4576         case LTEQ:
4577             return LE;
4578         case GTEQ:
4579             return GE;
4580         case LTLT:
4581             return SL;
4582         case LTLTEQ:
4583             return SL_ASG;
4584         case GTGT:
4585             return SR;
4586         case GTGTEQ:
4587             return SR_ASG;
4588         case GTGTGT:
4589             return USR;
4590         case GTGTGTEQ:
4591             return USR_ASG;
4592         case PLUS:
4593             return JCTree.Tag.PLUS;
4594         case PLUSEQ:
4595             return PLUS_ASG;
4596         case SUB:
4597             return MINUS;
4598         case SUBEQ:
4599             return MINUS_ASG;
4600         case STAR:
4601             return MUL;
4602         case STAREQ:
4603             return MUL_ASG;
4604         case SLASH:
4605             return DIV;
4606         case SLASHEQ:
4607             return DIV_ASG;
4608         case PERCENT:
4609             return MOD;
4610         case PERCENTEQ:
4611             return MOD_ASG;
4612         case INSTANCEOF:
4613             return TYPETEST;
4614         default:
4615             return NO_TAG;
4616         }
4617     }
4618 
4619     /** Return operation tag of unary operator represented by token,
4620      *  No_TAG if token is not a binary operator.
4621      */
4622     static JCTree.Tag unoptag(TokenKind token) {
4623         switch (token) {
4624         case PLUS:
4625             return POS;
4626         case SUB:
4627             return NEG;
4628         case BANG:
4629             return NOT;
4630         case TILDE:
4631             return COMPL;
4632         case PLUSPLUS:
4633             return PREINC;
4634         case SUBSUB:
4635             return PREDEC;
4636         default:
4637             return NO_TAG;
4638         }
4639     }
4640 
4641     /** Return type tag of basic type represented by token,
4642      *  NONE if token is not a basic type identifier.
4643      */
4644     static TypeTag typetag(TokenKind token) {
4645         switch (token) {
4646         case BYTE:
4647             return TypeTag.BYTE;
4648         case CHAR:
4649             return TypeTag.CHAR;
4650         case SHORT:
4651             return TypeTag.SHORT;
4652         case INT:
4653             return TypeTag.INT;
4654         case LONG:
4655             return TypeTag.LONG;
4656         case FLOAT:
4657             return TypeTag.FLOAT;
4658         case DOUBLE:
4659             return TypeTag.DOUBLE;
4660         case BOOLEAN:
4661             return TypeTag.BOOLEAN;
4662         default:
4663             return TypeTag.NONE;
4664         }
4665     }
4666 
4667     void checkSourceLevel(Feature feature) {
4668         checkSourceLevel(token.pos, feature);
4669     }
4670 
4671     protected void checkSourceLevel(int pos, Feature feature) {
4672         if (preview.isPreview(feature) &amp;&amp; !preview.isEnabled()) {
4673             //preview feature without --preview flag, error
4674             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, preview.disabledError(feature));
4675         } else if (!feature.allowedInSource(source)) {
4676             //incompatible source level, error
4677             log.error(DiagnosticFlag.SOURCE_LEVEL, pos, feature.error(source.name));
4678         } else if (preview.isPreview(feature)) {
4679             //use of preview feature, warn
4680             preview.warnPreview(pos, feature);
4681         }
4682     }
4683 
4684     /*
4685      * a functional source tree and end position mappings
4686      */
4687     protected static class SimpleEndPosTable extends AbstractEndPosTable {
4688 
4689         private final IntHashTable endPosMap;
4690 
4691         SimpleEndPosTable(JavacParser parser) {
4692             super(parser);
4693             endPosMap = new IntHashTable();
4694         }
4695 
4696         public void storeEnd(JCTree tree, int endpos) {
4697             endPosMap.putAtIndex(tree, errorEndPos &gt; endpos ? errorEndPos : endpos,
4698                                  endPosMap.lookup(tree));
4699         }
4700 
4701         protected &lt;T extends JCTree&gt; T to(T t) {
4702             storeEnd(t, parser.token.endPos);
4703             return t;
4704         }
4705 
4706         protected &lt;T extends JCTree&gt; T toP(T t) {
4707             storeEnd(t, parser.S.prevToken().endPos);
4708             return t;
4709         }
4710 
4711         public int getEndPos(JCTree tree) {
4712             int value = endPosMap.getFromIndex(endPosMap.lookup(tree));
4713             // As long as Position.NOPOS==-1, this just returns value.
4714             return (value == -1) ? Position.NOPOS : value;
4715         }
4716 
4717         public int replaceTree(JCTree oldTree, JCTree newTree) {
4718             int pos = endPosMap.remove(oldTree);
4719             if (pos != -1) {
4720                 storeEnd(newTree, pos);
4721                 return pos;
4722             }
4723             return Position.NOPOS;
4724         }
4725     }
4726 
4727     /*
4728      * a default skeletal implementation without any mapping overhead.
4729      */
4730     protected static class EmptyEndPosTable extends AbstractEndPosTable {
4731 
4732         EmptyEndPosTable(JavacParser parser) {
4733             super(parser);
4734         }
4735 
4736         public void storeEnd(JCTree tree, int endpos) { /* empty */ }
4737 
4738         protected &lt;T extends JCTree&gt; T to(T t) {
4739             return t;
4740         }
4741 
4742         protected &lt;T extends JCTree&gt; T toP(T t) {
4743             return t;
4744         }
4745 
4746         public int getEndPos(JCTree tree) {
4747             return Position.NOPOS;
4748         }
4749 
4750         public int replaceTree(JCTree oldTree, JCTree newTree) {
4751             return Position.NOPOS;
4752         }
4753 
4754     }
4755 
4756     protected static abstract class AbstractEndPosTable implements EndPosTable {
4757         /**
4758          * The current parser.
4759          */
4760         protected JavacParser parser;
4761 
4762         /**
4763          * Store the last error position.
4764          */
4765         public int errorEndPos = Position.NOPOS;
4766 
4767         public AbstractEndPosTable(JavacParser parser) {
4768             this.parser = parser;
4769         }
4770 
4771         /**
4772          * Store current token&#39;s ending position for a tree, the value of which
4773          * will be the greater of last error position and the ending position of
4774          * the current token.
4775          * @param t The tree.
4776          */
4777         protected abstract &lt;T extends JCTree&gt; T to(T t);
4778 
4779         /**
4780          * Store current token&#39;s ending position for a tree, the value of which
4781          * will be the greater of last error position and the ending position of
4782          * the previous token.
4783          * @param t The tree.
4784          */
4785         protected abstract &lt;T extends JCTree&gt; T toP(T t);
4786 
4787         /**
4788          * Set the error position during the parsing phases, the value of which
4789          * will be set only if it is greater than the last stored error position.
4790          * @param errPos The error position
4791          */
4792         public void setErrorEndPos(int errPos) {
4793             if (errPos &gt; errorEndPos) {
4794                 errorEndPos = errPos;
4795             }
4796         }
4797 
4798         public void setParser(JavacParser parser) {
4799             this.parser = parser;
4800         }
4801     }
4802 }
    </pre>
  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;
 30 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;
 31 import com.sun.tools.javac.code.Symbol;
 32 import com.sun.tools.javac.code.Symbol.BindingSymbol;
 33 import com.sun.tools.javac.code.Symbol.VarSymbol;
 34 import com.sun.tools.javac.code.Symtab;
 35 import com.sun.tools.javac.code.Types;
 36 import com.sun.tools.javac.tree.JCTree.JCAssign;
 37 import com.sun.tools.javac.tree.JCTree.JCBinary;
 38 import com.sun.tools.javac.tree.JCTree.JCConditional;
 39 import com.sun.tools.javac.tree.JCTree.JCExpression;
 40 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 41 import com.sun.tools.javac.tree.JCTree.JCIdent;
 42 import com.sun.tools.javac.tree.JCTree.JCIf;
 43 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 44 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 45 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 46 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 47 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 48 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 49 import com.sun.tools.javac.tree.JCTree.Tag;
 50 import com.sun.tools.javac.tree.TreeMaker;
 51 import com.sun.tools.javac.tree.TreeTranslator;
 52 import com.sun.tools.javac.util.Assert;
 53 import com.sun.tools.javac.util.Context;
 54 import com.sun.tools.javac.util.ListBuffer;
 55 import com.sun.tools.javac.util.Log;
 56 import com.sun.tools.javac.util.Names;
 57 import com.sun.tools.javac.util.Options;
 58 
 59 import java.util.Map;
 60 import java.util.Map.Entry;
 61 
 62 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 63 import com.sun.tools.javac.code.Type;
 64 import com.sun.tools.javac.code.Type.ClassType;
 65 import com.sun.tools.javac.code.Type.MethodType;
 66 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
 67 import static com.sun.tools.javac.code.TypeTag.BOT;
 68 import com.sun.tools.javac.jvm.ClassFile;
 69 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 70 import com.sun.tools.javac.jvm.Target;
 71 import com.sun.tools.javac.tree.JCTree.GenericSwitch.SwitchKind;
 72 import com.sun.tools.javac.tree.JCTree.JCAssignOp;
 73 import com.sun.tools.javac.tree.JCTree;
 74 import com.sun.tools.javac.tree.JCTree.JCBlock;
 75 import com.sun.tools.javac.tree.JCTree.JCBreak;
 76 import com.sun.tools.javac.tree.JCTree.JCCase;
 77 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 78 import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;
 79 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 80 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 81 import com.sun.tools.javac.tree.JCTree.JCLiteralPattern;
 82 import com.sun.tools.javac.tree.JCTree.JCPattern;
 83 import com.sun.tools.javac.tree.JCTree.JCLambda;
 84 import com.sun.tools.javac.tree.JCTree.JCStatement;
 85 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 86 import com.sun.tools.javac.tree.JCTree.LetExpr;
 87 import static com.sun.tools.javac.tree.JCTree.Tag.SWITCH;
 88 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 89 import com.sun.tools.javac.util.List;
 90 import java.util.HashMap;
 91 
 92 /**
 93  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 94  */
 95 public class TransPatterns extends TreeTranslator {
 96 
 97     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 98 
 99     public static TransPatterns instance(Context context) {
100         TransPatterns instance = context.get(transPatternsKey);
101         if (instance == null)
102             instance = new TransPatterns(context);
103         return instance;
104     }
105 
106     private final Symtab syms;
107     private final Types types;
108     private final Operators operators;
109     private final Log log;
110     private final ConstFold constFold;
111     private final Names names;
112     private final Resolve rs;
113     private final Target target;
114     private TreeMaker make;
115     private Env&lt;AttrContext&gt; env;
116 
117     BindingContext bindingContext = new BindingContext() {
118         @Override
119         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
120             return null;
121         }
122 
123         @Override
124         VarSymbol getBindingFor(BindingSymbol varSymbol) {
125             return null;
126         }
127 
128         @Override
129         JCStatement decorateStatement(JCStatement stat) {
130             return stat;
131         }
132 
133         @Override
134         JCExpression decorateExpression(JCExpression expr) {
135             return expr;
136         }
137 
138         @Override
139         BindingContext pop() {
140             //do nothing
141             return this;
142         }
143 
144         @Override
145         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
146             return false;
147         }
148     };
149 
150     JCLabeledStatement pendingMatchLabel = null;
151 
152     boolean debugTransPatterns;
153 
154     private JCClassDecl currentClass;
155     private List&lt;JCTree&gt; condyableMethods = List.nil();
156     private MethodSymbol nullBootstrap; //hack: for ofConstant(null).
157     private JCMethodDecl nullBootstrapTree;
158     private MethodSymbol currentMethodSym = null;
159 
160     protected TransPatterns(Context context) {
161         context.put(transPatternsKey, this);
162         syms = Symtab.instance(context);
163         make = TreeMaker.instance(context);
164         types = Types.instance(context);
165         operators = Operators.instance(context);
166         log = Log.instance(context);
167         constFold = ConstFold.instance(context);
168         names = Names.instance(context);
169         rs = Resolve.instance(context);
170         target = Target.instance(context);
171         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
172     }
173 
174     @Override
175     public void visitTypeTest(JCInstanceOf tree) {
176         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN) || tree.pattern.hasTag(Tag.LITERALPATTERN)) {
177             //E instanceof T N
178             //=&gt;
179             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))
180             JCPattern patt = (JCPattern) tree.pattern;
181             ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
182             Type tempType = tree.expr.type.hasTag(BOT) ?
183                     syms.objectType
184                     : tree.expr.type;
185             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
186                     names.fromString(&quot;&quot; + tree.pos + target.syntheticNameChar() + &quot;temp&quot;), //XXX: use a better name if possible: pattSym.name
187                     tempType,
188                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!
189             JCExpression translatedExpr = translate(tree.expr);
190             statements.append(make.at(tree.pos).VarDef(temp, translatedExpr));
191             ListBuffer&lt;VarSymbol&gt; bindingVars = new ListBuffer&lt;&gt;();
192             Symbol.DynamicVarSymbol extractor = preparePatternExtractor(patt, tree.expr.type, bindingVars);
193             JCIdent qualifier = make.Ident(patt.type.tsym);
194             qualifier.sym = extractor;
195             qualifier.type = extractor.type;
196             VarSymbol e = new VarSymbol(0,
197                     names.fromString(&quot;$e$&quot; + tree.pos),
198                     syms.patternHandleType,
199                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!
200             statements.add(make.VarDef(e, qualifier));
201             
202             VarSymbol tryMatch = new VarSymbol(0,
203                     names.fromString(&quot;$tryMatch$&quot; + tree.pos),
204                     syms.methodHandleType,
205                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!
206             MethodSymbol tryMatchMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;tryMatch&quot;), List.nil(), List.nil());
207             statements.append(make.VarDef(tryMatch, makeApply(make.Ident(e), tryMatchMethod, List.nil())));
208             VarSymbol carrierMatch = new VarSymbol(0,
209                     names.fromString(&quot;$carrier$&quot; + tree.pos),
210                     syms.objectType,
211                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!
212             MethodSymbol invokeMethodObject = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
213             statements.append(make.VarDef(carrierMatch, makeApply(make.Ident(tryMatch), invokeMethodObject, List.of(translate(tree.expr)))));
214             result = makeBinary(Tag.NE, make.Ident(carrierMatch), makeNull());
215 
216             int idx = 0;
217             for (VarSymbol bindingVar : bindingVars) {
218                 if (bindingVar != syms.lengthVar) {
219                     VarSymbol component = new VarSymbol(0,
220                             names.fromString(&quot;$component$&quot; + tree.pos + &quot;$&quot; + idx),
221                             syms.methodHandleType,
222                             currentMethodSym); //XXX: currentMethodSym may not exist!!!!
223                     MethodSymbol componentMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;component&quot;), List.of(syms.intType), List.nil());
224                     statements.append(make.VarDef(component, makeApply(make.Ident(e), componentMethod, List.of(make.Literal(idx)))));
225                     Type componentType = types.erasure(bindingVar.type.baseType());
226                     JCTree oldNextTree = env.next.tree;
227                     JCTree oldTree = env.tree;
228                     MethodSymbol invokeMethodForComponent;
229                     try {
230                         env.next.tree = make.TypeCast(componentType, (JCExpression) (env.tree = make.Erroneous()));
231                         invokeMethodForComponent = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
232                     } finally {
233                         env.next.tree = oldNextTree;
234                         env.tree = oldTree;
235                     }
236                     Type castTargetType = bindingVar.erasure(types);
237                     JCAssign bindingInit = (JCAssign)make.at(tree.pos).Assign(
238                             make.Ident(bindingVar), convert(makeApply(make.Ident(component), invokeMethodForComponent, List.of(make.Ident(carrierMatch))), castTargetType)).setType(bindingVar.erasure(types));
239                     JCExpression assignBoolExpr = make.at(tree.pos).LetExpr(List.of(make.Exec(bindingInit)), make.Literal(true)).setType(syms.booleanType);
240                     result = makeBinary(Tag.AND, (JCExpression)result, assignBoolExpr);
241                 }
242                 idx++;
243             }
244             result = make.at(tree.pos).LetExpr(statements.toList(), (JCExpression)result).setType(syms.booleanType);
245             ((LetExpr) result).needsCond = true;
246         } else {
247             super.visitTypeTest(tree);
248         }
249     }
250     
251     private Symbol.DynamicVarSymbol preparePatternExtractor(JCPattern patt, Type target, ListBuffer&lt;VarSymbol&gt; bindingVars) {
252         if (target == syms.botType) {
253             target = syms.objectType;
254         }
255         if (patt.hasTag(Tag.BINDINGPATTERN)) {
256             Type tempType = patt.type.hasTag(BOT) ?
257                     syms.objectType
258                     : patt.type;
259             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
260                                                               List.of(tempType),
261                                                               syms.classType.tsym));
262 
263             if (!tempType.isPrimitive()) {
264                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
265                                                                      List.of(target),
266                                                                      syms.classType.tsym));
267             }
268 
269             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
270                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
271 
272             VarSymbol binding = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
273             
274             if (binding != null) {
275                 bindingVars.append(binding);
276             }
277 
278             if (tempType.isPrimitive()) {
279                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
280             } else {
281                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
282             }
283         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
284             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
285             Type tempType = patt.type.hasTag(BOT) ?
286                     syms.objectType
287                     : patt.type;
288             Type indyType = syms.objectType;
289             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
290                                                 syms.stringType,
291                                                 new ClassType(syms.classType.getEnclosingType(),
292                                                               List.of(syms.patternHandleType),
293                                                               syms.classType.tsym),
294                                                 new ClassType(syms.classType.getEnclosingType(),
295                                                               List.of(tempType),
296                                                               syms.classType.tsym),
297                                                 syms.methodTypeType,
298                                                 syms.stringType,
299                                                 syms.intType);
300             
301             Symbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
302                     names.fromString(&quot;ofNamed&quot;), bsm_staticArgs, List.nil());
303 
304             Symbol.DynamicVarSymbol outter = new Symbol.DynamicVarSymbol(names.fromString(&quot;ofNamed&quot;),
305                     syms.noSymbol,
306                     new Symbol.MethodHandleSymbol(ofType),
307                     indyType,
308                     new LoadableConstant[] {(ClassType) tempType,
309                                             new MethodType(dpatt.innerTypes, syms.voidType, List.nil(), syms.methodClass),
310                                             LoadableConstant.String(dpatt.extractorResolver.name.toString()),
311                                             LoadableConstant.Int(ClassFile.REF_newInvokeSpecial)});
312 
313             DynamicVarSymbol[] params = new DynamicVarSymbol[((JCDeconstructionPattern) patt).getNestedPatterns().size() + 1];
314             params[0] = outter;
315             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
316             ListBuffer&lt;VarSymbol&gt;[] nestedBindings = new ListBuffer[((JCDeconstructionPattern) patt).getNestedPatterns().size()];
317 
318             for (int i = 0; i &lt; ((JCDeconstructionPattern) patt).getNestedPatterns().size(); i++) {
319                 JCPattern nested = ((JCDeconstructionPattern) patt).getNestedPatterns().get(i);
320                 params[i + 1] = preparePatternExtractor(nested, nested.type, nestedBindings[i] = new ListBuffer&lt;&gt;());
321                 if (nested.hasTag(Tag.BINDINGPATTERN)) {
322                     bindingVars.appendList(nestedBindings[i].toList());
323                     nestedBindings[i].clear();
324                 } else {
325                     bindingVars.append(syms.lengthVar);
326                 }
327             }
328             
329             for (ListBuffer&lt;VarSymbol&gt; nested : nestedBindings) {
330                 if (nested.isEmpty())
331                     continue;
332                 bindingVars.appendList(nested.toList());
333             }
334 
335             List&lt;Type&gt; bsm_staticArgsNested = List.of(syms.patternHandleType,
336                                                       types.makeArrayType(syms.patternHandleType));
337 
338             MethodSymbol ofNested = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
339                     names.fromString(&quot;nested&quot;), bsm_staticArgsNested, List.nil());
340             
341             return makeCondyable(patt.pos(), ofNested, params);
342         } else if (patt.hasTag(Tag.ANYPATTERN)) {
343             Type tempType = patt.type.hasTag(BOT) ?
344                     syms.objectType
345                     : patt.type;
346             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
347                                                               List.of(tempType),
348                                                               syms.classType.tsym));
349             
350             if (!tempType.isPrimitive()) {
351                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
352                                                                      List.of(target),
353                                                                      syms.classType.tsym));
354             }
355 
356             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
357                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
358 
359             if (tempType.isPrimitive()) {
360                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
361             } else {
362                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
363             }
364         } else if (patt.hasTag(Tag.LITERALPATTERN)) {
365             JCLiteralPattern lpatt = (JCLiteralPattern) patt;
366             boolean adapt = types.boxedTypeOrType(target) == target;
367             List&lt;Type&gt; bsm_staticArgs = List.of(syms.objectType);
368             
369             if (adapt) {
370                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
371                                                                      List.of(target),
372                                                                      syms.classType.tsym));
373             }
374 
375             MethodSymbol ofConstant = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
376                     names.fromString(&quot;ofConstant&quot;), bsm_staticArgs, List.nil());
377 
378             LoadableConstant lc;
379             Object constValue = lpatt.value.type.constValue();
380             if (constValue instanceof Double) {
381                 lc = LoadableConstant.Double((Double) constValue);
382             } else if (constValue instanceof Float) {
383                 lc = LoadableConstant.Float((Float) constValue);
384             } else  if (constValue instanceof Integer) {
385                 lc = LoadableConstant.Int((Integer) constValue);
386             } else if (constValue instanceof Long) {
387                 lc = LoadableConstant.Long((Long) constValue);
388             } else if (constValue instanceof String) {
389                 lc = LoadableConstant.String((String) constValue);
390             } else if (constValue == null) {
391                 lc = nullBootstrap();
392             } else {
393                 Assert.error(constValue.getClass().getName());
394                 throw new InternalError();
395             }
396 
397             if (adapt) {
398                 return makeCondyable(patt.pos(), ofConstant, new LoadableConstant[] {lc, (ClassType) target});
399             } else {
400                 return makeCondyable(patt.pos(), ofConstant, new LoadableConstant[] {lc});
401             }
402         } else {
403             throw new IllegalStateException();
404         }
405     }
406 
407     private Symbol.DynamicVarSymbol makeCondyable(DiagnosticPosition pos, MethodSymbol targetMethod, LoadableConstant[] parameters) {
408         Assert.checkNonNull(currentClass);
409 
410         List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
411                                             syms.stringType,
412                                             new ClassType(syms.classType.getEnclosingType(),
413                                                           List.of(syms.patternHandlesType),
414                                                           syms.classType.tsym));
415         bsm_staticArgs = bsm_staticArgs.appendList(targetMethod.type.getParameterTypes());
416 
417         MethodType indyType = new MethodType(bsm_staticArgs, targetMethod.type.getReturnType(), List.nil(), syms.methodClass);
418 
419         MethodSymbol condyable = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC, names.fromString(&quot;$condyable$&quot; + pos.getPreferredPosition()), indyType, currentClass.sym);
420 
421         if ((targetMethod.flags() &amp; Flags.VARARGS) != 0) {
422             condyable.flags_field |= Flags.VARARGS;
423         }
424 
425         currentClass.sym.members().enter(condyable);
426 
427         condyableMethods = condyableMethods.prepend(
428                 make.MethodDef(condyable,
429                                condyable.externalType(types),
430                                make.Block(0, List.of(make.Return(make.Apply(List.nil(), make.QualIdent(targetMethod), condyable.params().stream().skip(3).map(p -&gt; make.Ident(p)).collect(List.collector())).setType(syms.patternHandleType))))));
431 
432         return new Symbol.DynamicVarSymbol(condyable.name,
433                                            syms.noSymbol,
434                                            new MethodHandleSymbol(condyable),
435                                            targetMethod.type.getReturnType(),
436                                            parameters);
437     }
438 
439     private Symbol.DynamicVarSymbol loadPrimitiveClass(DiagnosticPosition pos, Type primitive) {
440         Assert.checkNonNull(currentClass);
441         final Type.ClassType primitiveClass = new ClassType(syms.classType.getEnclosingType(),
442                 List.of(primitive),
443                 syms.classType.tsym);
444 
445         List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
446                                             syms.stringType, primitiveClass);
447         VarSymbol TYPE = rs.resolveInternalField(pos, env, types.boxedTypeOrType(primitive),
448                 names.fromString(&quot;TYPE&quot;));
449         MethodType indyType = new MethodType(bsm_staticArgs, primitiveClass, List.nil(), syms.methodClass);
450 
451         MethodSymbol loadPrimitiveClass = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC, names.fromString(&quot;$primitiveClass$&quot; + pos.getPreferredPosition()), indyType, currentClass.sym);
452 
453         currentClass.sym.members().enter(loadPrimitiveClass);
454 
455         condyableMethods = condyableMethods.prepend(
456                 make.MethodDef(loadPrimitiveClass,
457                                loadPrimitiveClass.externalType(types),
458                                make.Block(0, List.of(make.Return(make.QualIdent(TYPE))))));
459 
460         return new Symbol.DynamicVarSymbol(loadPrimitiveClass.name,
461                                            syms.noSymbol,
462                                            new MethodHandleSymbol(loadPrimitiveClass),
463                                            primitiveClass,
464                                            new LoadableConstant[] {});
465     }
466 
467     private Symbol.DynamicVarSymbol nullBootstrap() {
468         Assert.checkNonNull(currentClass);
469 
470         if (nullBootstrap == null) {
471             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
472                                                 syms.stringType,
473                                                 new ClassType(syms.classType.getEnclosingType(),
474                                                               List.of(syms.objectType),
475                                                               syms.classType.tsym));
476 
477             MethodType indyType = new MethodType(bsm_staticArgs, syms.objectType, List.nil(), syms.methodClass);
478 
479             nullBootstrap = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC, names.fromString(&quot;$null$bootstrap&quot;), indyType, currentClass.sym);
480 
481             currentClass.sym.members().enter(nullBootstrap);
482 
483             nullBootstrapTree = make.MethodDef(nullBootstrap,
484                                                nullBootstrap.externalType(types),
485                                                make.Block(0, List.of(make.Return(make.Literal(BOT, null).setType(syms.botType)))));
486         }
487 
488         return new Symbol.DynamicVarSymbol(nullBootstrap.name,
489                                            syms.noSymbol,
490                                            new MethodHandleSymbol(nullBootstrap),
491                                            syms.objectType,
492                                            new LoadableConstant[0]);
493     }
494 
495     private JCExpression makeApply(JCExpression site, Symbol method, List&lt;JCExpression&gt; params) {
496         JCFieldAccess acc = make.Select(site, method.name);
497         acc.sym = method;
498         acc.type = method.type;
499         return make.Apply(List.nil(), acc, params).setType(acc.type.getReturnType());
500     }
501 
502     //from Lower:
503     /** Make an attributed tree representing a literal. This will be an
504      *  Ident node in the case of boolean literals, a Literal node in all
505      *  other cases.
506      *  @param type       The literal&#39;s type.
507      *  @param value      The literal&#39;s value.
508      */
509     JCExpression makeLit(Type type, Object value) {
510         return make.Literal(type.getTag(), value).setType(type.constType(value));
511     }
512 
513     /** Make an attributed tree representing null.
514      */
515     JCExpression makeNull() {
516         return makeLit(syms.botType, null);
517     }
518     
519     /** Make an attributed assignop expression.
520      *  @param optag    The operators tree tag.
521      *  @param lhs      The operator&#39;s left argument.
522      *  @param rhs      The operator&#39;s right argument.
523      */
524     JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
525         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
526         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
527         tree.type = lhs.type;
528         return tree;
529     }
530     
531 //    JCNewArray makeArray(Type type, JCExpression... elements) {
532 //        JCNewArray newArray = make.NewArray(make.Type(types.erasure(type)),
533 //                                          List.nil(),
534 //                                          List.from(elements));
535 //        newArray.type = types.makeArrayType(newArray.elemtype.type);
536 //        return newArray;
537 //    }
538 
539     @Override
540     public void visitBinary(JCBinary tree) {
541         bindingContext = new BasicBindingContext();
542         try {
543             super.visitBinary(tree);
544             result = bindingContext.decorateExpression(tree);
545         } finally {
546             bindingContext.pop();
547         }
548     }
549 
550     @Override
551     public void visitBreak(JCBreak tree) {
552         if (tree.target.hasTag(SWITCH) &amp;&amp; ((JCSwitch) tree.target).kind == SwitchKind.MATCHING) {
553             Assert.checkNonNull(pendingMatchLabel);
554             tree.target = pendingMatchLabel;
555             result = tree;
556         } else {
557             super.visitBreak(tree);
558         }
559     }
560 
561     @Override
562     public void visitConditional(JCConditional tree) {
563         bindingContext = new BasicBindingContext();
564         try {
565             super.visitConditional(tree);
566             result = bindingContext.decorateExpression(tree);
567         } finally {
568             bindingContext.pop();
569         }
570     }
571 
572     @Override
573     public void visitIf(JCIf tree) {
574         bindingContext = new BasicBindingContext();
575         try {
576             super.visitIf(tree);
577             result = bindingContext.decorateStatement(tree);
578         } finally {
579             bindingContext.pop();
580         }
581     }
582 
583     @Override
584     public void visitForLoop(JCForLoop tree) {
585         bindingContext = new BasicBindingContext();
586         try {
587             super.visitForLoop(tree);
588             result = bindingContext.decorateStatement(tree);
589         } finally {
590             bindingContext.pop();
591         }
592     }
593 
594     @Override
595     public void visitWhileLoop(JCWhileLoop tree) {
596         bindingContext = new BasicBindingContext();
597         try {
598             super.visitWhileLoop(tree);
599             result = bindingContext.decorateStatement(tree);
600         } finally {
601             bindingContext.pop();
602         }
603     }
604 
605     @Override
606     public void visitDoLoop(JCDoWhileLoop tree) {
607         bindingContext = new BasicBindingContext();
608         try {
609             super.visitDoLoop(tree);
610             result = bindingContext.decorateStatement(tree);
611         } finally {
612             bindingContext.pop();
613         }
614     }
615 
616     @Override
617     public void visitSwitch(JCSwitch tree) {
618         if (tree.kind == SwitchKind.MATCHING) {
619             JCLabeledStatement prevMatchLabel = pendingMatchLabel;
620             try {
621                 pendingMatchLabel = make.Labelled(names.fromString(&quot;match$&quot; + tree.pos), null);
622                 VarSymbol fallthroughSym = new VarSymbol(0, names.fromString(&quot;fallthrough$&quot; + tree.pos), syms.booleanType, currentMethodSym);
623 
624                 boolean hasFallThrough = false;
625                 boolean wasFallThrough = false;
626 
627                 List&lt;JCStatement&gt; resultStatements = List.nil();
628 
629                 for (JCCase clause : tree.cases) {
630                     Assert.check(clause.pats.size() &lt;= 1);
631                     final JCExpression jcMatches = clause.pats.nonEmpty() ? make.TypeTest(tree.selector, clause.pats.head) : make.Literal(BOOLEAN, 1);
632                     jcMatches.setType(syms.booleanType);
633                     JCStatement body;
634                     List&lt;JCStatement&gt; stats = clause.stats;
635                     if (clause.completesNormally) {
636                         stats = stats.append(make.at(tree.pos).Exec(make.Assign(make.Ident(fallthroughSym), make.Literal(BOOLEAN, 1).setType(syms.booleanType)).setType(syms.booleanType)));
637                     }
638                     body = make.Block(0, stats);
639                     JCStatement translatedIf = translate(make.If(jcMatches, body, null));
640                     JCIf testStatement = translatedIf.hasTag(Tag.IF) ? (JCIf)translatedIf : (JCIf) ((JCBlock)translatedIf).stats.tail.head;
641 
642                     if (wasFallThrough) {
643                         testStatement.cond = makeBinary(Tag.OR,
644                                 make.Ident(fallthroughSym),
645                                 testStatement.cond);
646                     }
647 
648                     hasFallThrough |= wasFallThrough = clause.completesNormally;
649                     resultStatements = resultStatements.append(translatedIf);
650                 }
651                 if (hasFallThrough) {
652                     resultStatements = resultStatements.prepend(make.at(tree.pos)
653                                                                     .VarDef(fallthroughSym,
654                                                                             make.Literal(BOOLEAN, 0).setType(syms.booleanType)));
655                 }
656                 pendingMatchLabel.body = make.Block(0, resultStatements);
657                 result = pendingMatchLabel;
658             } finally {
659                 pendingMatchLabel = prevMatchLabel;
660             }
661         } else {
662             super.visitSwitch(tree);
663         }
664     }
665 
666     @Override
667     public void visitClassDef(JCTree.JCClassDecl tree) {
668         JCClassDecl prevCurrentClass = currentClass;
669         List&lt;JCTree&gt; prevCondyableMethods = condyableMethods;
670         MethodSymbol prevNullBootstrap = nullBootstrap;
671         JCMethodDecl prevNullBootstrapTree = nullBootstrapTree;
672         try {
673             currentClass = tree;
674             condyableMethods = List.nil();
675             nullBootstrap = null;
676             nullBootstrapTree = null;
677             super.visitClassDef(tree);
678         } finally {
679             currentClass.defs = currentClass.defs.prependList(condyableMethods);
680             if (nullBootstrapTree != null) {
681                 currentClass.defs = currentClass.defs.prepend(nullBootstrapTree);
682             }
683             currentClass = prevCurrentClass;
684             condyableMethods = prevCondyableMethods;
685             nullBootstrap = prevNullBootstrap;
686             nullBootstrapTree = prevNullBootstrapTree;
687         }
688     }
689 
690     @Override
691     public void visitMethodDef(JCMethodDecl tree) {
692         MethodSymbol prevMethodSym = currentMethodSym;
693         try {
694             currentMethodSym = tree.sym;
695             super.visitMethodDef(tree);
696         } finally {
697             currentMethodSym = prevMethodSym;
698         }
699     }
700 
701     @Override
702     public void visitIdent(JCIdent tree) {
703         VarSymbol bindingVar = null;
704         if ((tree.sym.flags() &amp; Flags.MATCH_BINDING) != 0) {
705             bindingVar = bindingContext.getBindingFor((BindingSymbol)tree.sym);
706         }
707         if (bindingVar == null) {
708             super.visitIdent(tree);
709         } else {
710             result = make.at(tree.pos).Ident(bindingVar);
711         }
712     }
713 
714     @Override
715     public void visitBlock(JCBlock tree) {
716         ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
717         bindingContext = new BindingDeclarationFenceBindingContext() {
718             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
719                 //{
720                 //    if (E instanceof T N) {
721                 //        return ;
722                 //    }
723                 //    //use of N:
724                 //}
725                 //=&gt;
726                 //{
727                 //    T N;
728                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
729                 //        return ;
730                 //    }
731                 //    //use of N:
732                 //}
733                 hoistedVarMap.put(binding, var.sym);
734                 statements.append(var);
735                 return true;
736             }
737         };
738         try {
739             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
740                 statements.append(translate(l.head));
741             }
742 
743             tree.stats = statements.toList();
744             result = tree;
745         } finally {
746             bindingContext.pop();
747         }
748     }
749 
750     @Override
751     public void visitLambda(JCLambda tree) {
752         BindingContext prevContent = bindingContext;
753         try {
754             bindingContext = new BindingDeclarationFenceBindingContext();
755             super.visitLambda(tree);
756         } finally {
757             bindingContext = prevContent;
758         }
759     }
760 
761     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
762         try {
763             this.make = make;
764             this.env = env;
765             translate(cdef);
766         } finally {
767             // note that recursive invocations of this method fail hard
768             this.make = null;
769             this.env = null;
770         }
771 
772         return cdef;
773     }
774 
775     /** Make an instanceof expression.
776      *  @param lhs      The expression.
777      *  @param type     The type to be tested.
778      */
779 
780     JCInstanceOf makeTypeTest(JCExpression lhs, JCExpression type) {
781         JCInstanceOf tree = make.TypeTest(lhs, type);
782         tree.type = syms.booleanType;
783         return tree;
784     }
785 
786     /** Make an attributed binary expression (copied from Lower).
787      *  @param optag    The operators tree tag.
788      *  @param lhs      The operator&#39;s left argument.
789      *  @param rhs      The operator&#39;s right argument.
790      */
791     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
792         JCBinary tree = make.Binary(optag, lhs, rhs);
793         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
794         tree.type = tree.operator.type.getReturnType();
795         return tree;
796     }
797 
798     JCExpression convert(JCExpression expr, Type target) {
799         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
800         result.type = target;
801         return result;
802     }
803 
804     abstract class BindingContext {
805         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
806         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
807         abstract JCStatement decorateStatement(JCStatement stat);
808         abstract JCExpression decorateExpression(JCExpression expr);
809         abstract BindingContext pop();
810         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
811     }
812 
813     class BasicBindingContext extends BindingContext {
814         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
815         BindingContext parent;
816 
817         public BasicBindingContext() {
818             this.parent = bindingContext;
819             this.hoistedVarMap = new HashMap&lt;&gt;();
820         }
821 
822         @Override
823         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
824             VarSymbol res = parent.bindingDeclared(varSymbol);
825             if (res == null) {
826                 res = new VarSymbol(varSymbol.flags() &amp; ~Flags.MATCH_BINDING, varSymbol.name, varSymbol.type, varSymbol.owner);
827                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
828                 hoistedVarMap.put(varSymbol, res);
829             }
830             return res;
831         }
832 
833         @Override
834         VarSymbol getBindingFor(BindingSymbol varSymbol) {
835             VarSymbol res = parent.getBindingFor(varSymbol);
836             if (res != null) {
837                 return res;
838             }
839             return hoistedVarMap.entrySet().stream()
840                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
841                     .findFirst()
842                     .map(e -&gt; e.getValue()).orElse(null);
843         }
844 
845         @Override
846         JCStatement decorateStatement(JCStatement stat) {
847             if (hoistedVarMap.isEmpty()) return stat;
848             //if (E instanceof T N) {
849             //     //use N
850             //}
851             //=&gt;
852             //{
853             //    T N;
854             //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
855             //        //use N
856             //    }
857             //}
858             ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
859             for (Entry&lt;BindingSymbol, VarSymbol&gt; e : hoistedVarMap.entrySet()) {
860                 JCVariableDecl decl = makeHoistedVarDecl(stat.pos, e.getValue());
861                 if (!e.getKey().isPreserved() ||
862                     !parent.tryPrepend(e.getKey(), decl)) {
863                     stats.add(decl);
864                 }
865             }
866             if (stats.nonEmpty()) {
867                 stats.add(stat);
868                 stat = make.at(stat.pos).Block(0, stats.toList());
869             }
870             return stat;
871         }
872 
873         @Override
874         JCExpression decorateExpression(JCExpression expr) {
875             //E instanceof T N &amp;&amp; /*use of N*/
876             //=&gt;
877             //(let T N; (let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp)) &amp;&amp; /*use of N*/)
878             for (VarSymbol vsym : hoistedVarMap.values()) {
879                 expr = make.at(expr.pos).LetExpr(makeHoistedVarDecl(expr.pos, vsym), expr).setType(expr.type);
880             }
881             return expr;
882         }
883 
884         @Override
885         BindingContext pop() {
886             return bindingContext = parent;
887         }
888 
889         @Override
890         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
891             return false;
892         }
893 
894         private JCVariableDecl makeHoistedVarDecl(int pos, VarSymbol varSymbol) {
895             return make.at(pos).VarDef(varSymbol, null);
896         }
897     }
898 
899     private class BindingDeclarationFenceBindingContext extends BasicBindingContext {
900 
901         @Override
902         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
903             return null;
904         }
905 
906     }
907 }
    </pre>
  </body>
</html>
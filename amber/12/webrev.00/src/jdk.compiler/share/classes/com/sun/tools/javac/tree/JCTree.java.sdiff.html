<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../resources/compiler.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pretty.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/tree/JCTree.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
2293 
2294         @DefinedBy(Api.COMPILER_TREE)
2295         public Kind getKind() {
2296             return Kind.BINDING_PATTERN;
2297         }
2298 
2299         @Override
2300         @DefinedBy(Api.COMPILER_TREE)
2301         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2302             return v.visitBindingPattern(this, d);
2303         }
2304 
2305         @Override
2306         public Tag getTag() {
2307             return BINDINGPATTERN;
2308         }
2309     }
2310 
2311     public static class JCDeconstructionPattern extends JCPattern
2312             implements DeconstructionPatternTree {
<span class="line-removed">2313         public Name name; //possibly null</span>
<span class="line-removed">2314 //        public BindingSymbol symbol;</span>
2315         public JCExpression deconstructor;
2316         public List&lt;JCPattern&gt; nested;
2317         public Symbol extractorResolver; //TODO: MethodSymbol?; TODO: rename to pattern(Sym?)
2318         public List&lt;Type&gt; innerTypes;
2319 
<span class="line-modified">2320         protected JCDeconstructionPattern(Name name, JCExpression deconstructor, List&lt;JCPattern&gt; nested) {</span>
<span class="line-removed">2321             this.name = name;</span>
2322             this.deconstructor = deconstructor;
2323             this.nested = nested;
2324         }
2325 
2326         @DefinedBy(Api.COMPILER_TREE)
2327         public Name getBinding() {
<span class="line-modified">2328             return name;</span>
2329         }
2330 
2331         @Override @DefinedBy(Api.COMPILER_TREE)
2332         public Tree getDeconstructor() {
2333             return deconstructor;
2334         }
2335 
2336         @Override @DefinedBy(Api.COMPILER_TREE)
2337         public List&lt;? extends JCPattern&gt; getNestedPatterns() {
2338             return nested;
2339         }
2340 
2341         @Override
2342         public void accept(Visitor v) {
2343             v.visitDeconstructionPattern(this);
2344         }
2345 
2346         @DefinedBy(Api.COMPILER_TREE)
2347         public Kind getKind() {
2348             return Kind.DECONSTRUCTION_PATTERN;
</pre>
<hr />
<pre>
3264         @DefinedBy(Api.COMPILER_TREE)
3265         public Kind getKind() { return Kind.ERRONEOUS; }
3266 
3267         @DefinedBy(Api.COMPILER_TREE)
3268         public List&lt;? extends JCTree&gt; getErrorTrees() {
3269             return errs;
3270         }
3271 
3272         @Override @DefinedBy(Api.COMPILER_TREE)
3273         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3274             return v.visitErroneous(this, d);
3275         }
3276         @Override
3277         public Tag getTag() {
3278             return ERRONEOUS;
3279         }
3280     }
3281 
3282     /** (let int x = 3; in x+2) */
3283     public static class LetExpr extends JCExpression {
<span class="line-modified">3284         public List&lt;? extends JCStatement&gt; defs;</span>
3285         public JCExpression expr;
3286         /**true if a expr should be run through Gen.genCond:*/
3287         public boolean needsCond;
<span class="line-modified">3288         protected LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr) {</span>
3289             this.defs = defs;
3290             this.expr = expr;
3291         }
3292         @Override
3293         public void accept(Visitor v) { v.visitLetExpr(this); }
3294 
3295         @DefinedBy(Api.COMPILER_TREE)
3296         public Kind getKind() {
3297             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3298         }
3299         @Override @DefinedBy(Api.COMPILER_TREE)
3300         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3301             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3302         }
3303         @Override
3304         public Tag getTag() {
3305             return LETEXPR;
3306         }
3307     }
3308 
</pre>
<hr />
<pre>
3386         JCLiteralPattern LiteralPattern(JCExpression cexp);
3387         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3388         JCFieldAccess Select(JCExpression selected, Name selector);
3389         JCIdent Ident(Name idname);
3390         JCLiteral Literal(TypeTag tag, Object value);
3391         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3392         JCArrayTypeTree TypeArray(JCExpression elemtype);
3393         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3394         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3395         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3396         TypeBoundKind TypeBoundKind(BoundKind kind);
3397         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3398         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3399         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3400         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3401         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3402         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3403         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3404         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3405         JCUses Uses(JCExpression qualId);
<span class="line-modified">3406         LetExpr LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr);</span>
3407     }
3408 
3409     /** A generic visitor class for trees.
3410      */
3411     public static abstract class Visitor {
3412         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3413         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3414         public void visitImport(JCImport that)               { visitTree(that); }
3415         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3416         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3417         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3418         public void visitSkip(JCSkip that)                   { visitTree(that); }
3419         public void visitBlock(JCBlock that)                 { visitTree(that); }
3420         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3421         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3422         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3423         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3424         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3425         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3426         public void visitCase(JCCase that)                   { visitTree(that); }
</pre>
</td>
<td>
<hr />
<pre>
2293 
2294         @DefinedBy(Api.COMPILER_TREE)
2295         public Kind getKind() {
2296             return Kind.BINDING_PATTERN;
2297         }
2298 
2299         @Override
2300         @DefinedBy(Api.COMPILER_TREE)
2301         public &lt;R, D&gt; R accept(TreeVisitor&lt;R, D&gt; v, D d) {
2302             return v.visitBindingPattern(this, d);
2303         }
2304 
2305         @Override
2306         public Tag getTag() {
2307             return BINDINGPATTERN;
2308         }
2309     }
2310 
2311     public static class JCDeconstructionPattern extends JCPattern
2312             implements DeconstructionPatternTree {


2313         public JCExpression deconstructor;
2314         public List&lt;JCPattern&gt; nested;
2315         public Symbol extractorResolver; //TODO: MethodSymbol?; TODO: rename to pattern(Sym?)
2316         public List&lt;Type&gt; innerTypes;
2317 
<span class="line-modified">2318         protected JCDeconstructionPattern(JCExpression deconstructor, List&lt;JCPattern&gt; nested) {</span>

2319             this.deconstructor = deconstructor;
2320             this.nested = nested;
2321         }
2322 
2323         @DefinedBy(Api.COMPILER_TREE)
2324         public Name getBinding() {
<span class="line-modified">2325             return null;</span>
2326         }
2327 
2328         @Override @DefinedBy(Api.COMPILER_TREE)
2329         public Tree getDeconstructor() {
2330             return deconstructor;
2331         }
2332 
2333         @Override @DefinedBy(Api.COMPILER_TREE)
2334         public List&lt;? extends JCPattern&gt; getNestedPatterns() {
2335             return nested;
2336         }
2337 
2338         @Override
2339         public void accept(Visitor v) {
2340             v.visitDeconstructionPattern(this);
2341         }
2342 
2343         @DefinedBy(Api.COMPILER_TREE)
2344         public Kind getKind() {
2345             return Kind.DECONSTRUCTION_PATTERN;
</pre>
<hr />
<pre>
3261         @DefinedBy(Api.COMPILER_TREE)
3262         public Kind getKind() { return Kind.ERRONEOUS; }
3263 
3264         @DefinedBy(Api.COMPILER_TREE)
3265         public List&lt;? extends JCTree&gt; getErrorTrees() {
3266             return errs;
3267         }
3268 
3269         @Override @DefinedBy(Api.COMPILER_TREE)
3270         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3271             return v.visitErroneous(this, d);
3272         }
3273         @Override
3274         public Tag getTag() {
3275             return ERRONEOUS;
3276         }
3277     }
3278 
3279     /** (let int x = 3; in x+2) */
3280     public static class LetExpr extends JCExpression {
<span class="line-modified">3281         public List&lt;JCStatement&gt; defs;</span>
3282         public JCExpression expr;
3283         /**true if a expr should be run through Gen.genCond:*/
3284         public boolean needsCond;
<span class="line-modified">3285         protected LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr) {</span>
3286             this.defs = defs;
3287             this.expr = expr;
3288         }
3289         @Override
3290         public void accept(Visitor v) { v.visitLetExpr(this); }
3291 
3292         @DefinedBy(Api.COMPILER_TREE)
3293         public Kind getKind() {
3294             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3295         }
3296         @Override @DefinedBy(Api.COMPILER_TREE)
3297         public &lt;R,D&gt; R accept(TreeVisitor&lt;R,D&gt; v, D d) {
3298             throw new AssertionError(&quot;LetExpr is not part of a public API&quot;);
3299         }
3300         @Override
3301         public Tag getTag() {
3302             return LETEXPR;
3303         }
3304     }
3305 
</pre>
<hr />
<pre>
3383         JCLiteralPattern LiteralPattern(JCExpression cexp);
3384         JCArrayAccess Indexed(JCExpression indexed, JCExpression index);
3385         JCFieldAccess Select(JCExpression selected, Name selector);
3386         JCIdent Ident(Name idname);
3387         JCLiteral Literal(TypeTag tag, Object value);
3388         JCPrimitiveTypeTree TypeIdent(TypeTag typetag);
3389         JCArrayTypeTree TypeArray(JCExpression elemtype);
3390         JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments);
3391         JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds);
3392         JCWildcard Wildcard(TypeBoundKind kind, JCTree type);
3393         TypeBoundKind TypeBoundKind(BoundKind kind);
3394         JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args);
3395         JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations);
3396         JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs);
3397         JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind, JCExpression qualId, List&lt;JCDirective&gt; directives);
3398         JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3399         JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames);
3400         JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames);
3401         JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId);
3402         JCUses Uses(JCExpression qualId);
<span class="line-modified">3403         LetExpr LetExpr(List&lt;JCStatement&gt; defs, JCExpression expr);</span>
3404     }
3405 
3406     /** A generic visitor class for trees.
3407      */
3408     public static abstract class Visitor {
3409         public void visitTopLevel(JCCompilationUnit that)    { visitTree(that); }
3410         public void visitPackageDef(JCPackageDecl that)      { visitTree(that); }
3411         public void visitImport(JCImport that)               { visitTree(that); }
3412         public void visitClassDef(JCClassDecl that)          { visitTree(that); }
3413         public void visitMethodDef(JCMethodDecl that)        { visitTree(that); }
3414         public void visitVarDef(JCVariableDecl that)         { visitTree(that); }
3415         public void visitSkip(JCSkip that)                   { visitTree(that); }
3416         public void visitBlock(JCBlock that)                 { visitTree(that); }
3417         public void visitDoLoop(JCDoWhileLoop that)          { visitTree(that); }
3418         public void visitWhileLoop(JCWhileLoop that)         { visitTree(that); }
3419         public void visitForLoop(JCForLoop that)             { visitTree(that); }
3420         public void visitForeachLoop(JCEnhancedForLoop that) { visitTree(that); }
3421         public void visitLabelled(JCLabeledStatement that)   { visitTree(that); }
3422         public void visitSwitch(JCSwitch that)               { visitTree(that); }
3423         public void visitCase(JCCase that)                   { visitTree(that); }
</pre>
</td>
</tr>
</table>
<center><a href="../resources/compiler.properties.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="Pretty.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
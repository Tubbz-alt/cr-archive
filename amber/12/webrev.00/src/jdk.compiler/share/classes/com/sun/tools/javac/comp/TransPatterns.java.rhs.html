<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>  1 /*
  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;
 30 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;
 31 import com.sun.tools.javac.code.Symbol;
 32 import com.sun.tools.javac.code.Symbol.BindingSymbol;
<a name="1" id="anc1"></a><span class="line-added"> 33 import com.sun.tools.javac.code.Symbol.ClassSymbol;</span>
 34 import com.sun.tools.javac.code.Symbol.VarSymbol;
 35 import com.sun.tools.javac.code.Symtab;
 36 import com.sun.tools.javac.code.Types;
 37 import com.sun.tools.javac.tree.JCTree.JCAssign;
 38 import com.sun.tools.javac.tree.JCTree.JCBinary;
 39 import com.sun.tools.javac.tree.JCTree.JCConditional;
 40 import com.sun.tools.javac.tree.JCTree.JCExpression;
 41 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 42 import com.sun.tools.javac.tree.JCTree.JCIdent;
 43 import com.sun.tools.javac.tree.JCTree.JCIf;
 44 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 45 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 46 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 47 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 48 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 49 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 50 import com.sun.tools.javac.tree.JCTree.Tag;
 51 import com.sun.tools.javac.tree.TreeMaker;
 52 import com.sun.tools.javac.tree.TreeTranslator;
 53 import com.sun.tools.javac.util.Assert;
 54 import com.sun.tools.javac.util.Context;
 55 import com.sun.tools.javac.util.ListBuffer;
 56 import com.sun.tools.javac.util.Log;
 57 import com.sun.tools.javac.util.Names;
 58 import com.sun.tools.javac.util.Options;
 59 
 60 import java.util.Map;
 61 import java.util.Map.Entry;
<a name="2" id="anc2"></a><span class="line-added"> 62 import java.util.LinkedHashMap;</span>
 63 
 64 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 65 import com.sun.tools.javac.code.Type;
 66 import com.sun.tools.javac.code.Type.ClassType;
 67 import com.sun.tools.javac.code.Type.MethodType;
 68 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
 69 import static com.sun.tools.javac.code.TypeTag.BOT;
 70 import com.sun.tools.javac.jvm.ClassFile;
 71 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 72 import com.sun.tools.javac.jvm.Target;
 73 import com.sun.tools.javac.tree.JCTree.GenericSwitch.SwitchKind;
 74 import com.sun.tools.javac.tree.JCTree.JCAssignOp;
 75 import com.sun.tools.javac.tree.JCTree;
 76 import com.sun.tools.javac.tree.JCTree.JCBlock;
 77 import com.sun.tools.javac.tree.JCTree.JCBreak;
 78 import com.sun.tools.javac.tree.JCTree.JCCase;
 79 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 80 import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;
 81 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 82 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 83 import com.sun.tools.javac.tree.JCTree.JCLiteralPattern;
 84 import com.sun.tools.javac.tree.JCTree.JCPattern;
 85 import com.sun.tools.javac.tree.JCTree.JCLambda;
 86 import com.sun.tools.javac.tree.JCTree.JCStatement;
 87 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 88 import com.sun.tools.javac.tree.JCTree.LetExpr;
 89 import static com.sun.tools.javac.tree.JCTree.Tag.SWITCH;
 90 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 91 import com.sun.tools.javac.util.List;
<a name="3" id="anc3"></a>
 92 
 93 /**
 94  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 95  */
 96 public class TransPatterns extends TreeTranslator {
 97 
 98     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 99 
100     public static TransPatterns instance(Context context) {
101         TransPatterns instance = context.get(transPatternsKey);
102         if (instance == null)
103             instance = new TransPatterns(context);
104         return instance;
105     }
106 
107     private final Symtab syms;
108     private final Types types;
109     private final Operators operators;
110     private final Log log;
111     private final ConstFold constFold;
112     private final Names names;
113     private final Resolve rs;
114     private final Target target;
115     private TreeMaker make;
116     private Env&lt;AttrContext&gt; env;
117 
118     BindingContext bindingContext = new BindingContext() {
119         @Override
120         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
121             return null;
122         }
123 
124         @Override
125         VarSymbol getBindingFor(BindingSymbol varSymbol) {
126             return null;
127         }
128 
129         @Override
130         JCStatement decorateStatement(JCStatement stat) {
131             return stat;
132         }
133 
134         @Override
135         JCExpression decorateExpression(JCExpression expr) {
136             return expr;
137         }
138 
139         @Override
140         BindingContext pop() {
141             //do nothing
142             return this;
143         }
144 
145         @Override
146         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
147             return false;
148         }
149     };
150 
151     JCLabeledStatement pendingMatchLabel = null;
152 
153     boolean debugTransPatterns;
154 
155     private JCClassDecl currentClass;
<a name="4" id="anc4"></a><span class="line-added">156     private Symbol currentOwnerSym = null;</span>
157     private List&lt;JCTree&gt; condyableMethods = List.nil();
158     private MethodSymbol nullBootstrap; //hack: for ofConstant(null).
159     private JCMethodDecl nullBootstrapTree;
160     private MethodSymbol currentMethodSym = null;
161 
162     protected TransPatterns(Context context) {
163         context.put(transPatternsKey, this);
164         syms = Symtab.instance(context);
165         make = TreeMaker.instance(context);
166         types = Types.instance(context);
167         operators = Operators.instance(context);
168         log = Log.instance(context);
169         constFold = ConstFold.instance(context);
170         names = Names.instance(context);
171         rs = Resolve.instance(context);
172         target = Target.instance(context);
173         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
174     }
175 
176     @Override
177     public void visitTypeTest(JCInstanceOf tree) {
178         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN) || tree.pattern.hasTag(Tag.LITERALPATTERN)) {
179             //E instanceof T N
<a name="5" id="anc5"></a><span class="line-added">180             //E instanceof T(PATT1, PATT2, ...)</span>
181             //=&gt;
182             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))
183             JCPattern patt = (JCPattern) tree.pattern;
184             ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
185             Type tempType = tree.expr.type.hasTag(BOT) ?
186                     syms.objectType
187                     : tree.expr.type;
188             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
<a name="6" id="anc6"></a><span class="line-modified">189                     names.fromString(target.syntheticNameChar() + &quot;e&quot; + target.syntheticNameChar()),</span>
190                     tempType,
<a name="7" id="anc7"></a><span class="line-modified">191                     currentOwnerSym);</span>
192             JCExpression translatedExpr = translate(tree.expr);
193             statements.append(make.at(tree.pos).VarDef(temp, translatedExpr));
194             ListBuffer&lt;VarSymbol&gt; bindingVars = new ListBuffer&lt;&gt;();
195             Symbol.DynamicVarSymbol extractor = preparePatternExtractor(patt, tree.expr.type, bindingVars);
196             JCIdent qualifier = make.Ident(patt.type.tsym);
197             qualifier.sym = extractor;
198             qualifier.type = extractor.type;
199             VarSymbol e = new VarSymbol(0,
200                     names.fromString(&quot;$e$&quot; + tree.pos),
201                     syms.patternHandleType,
<a name="8" id="anc8"></a><span class="line-modified">202                     currentOwnerSym);</span>
203             statements.add(make.VarDef(e, qualifier));
<a name="9" id="anc9"></a><span class="line-modified">204 </span>
205             VarSymbol tryMatch = new VarSymbol(0,
206                     names.fromString(&quot;$tryMatch$&quot; + tree.pos),
207                     syms.methodHandleType,
<a name="10" id="anc10"></a><span class="line-modified">208                     currentOwnerSym);</span>
209             MethodSymbol tryMatchMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;tryMatch&quot;), List.nil(), List.nil());
210             statements.append(make.VarDef(tryMatch, makeApply(make.Ident(e), tryMatchMethod, List.nil())));
211             VarSymbol carrierMatch = new VarSymbol(0,
212                     names.fromString(&quot;$carrier$&quot; + tree.pos),
213                     syms.objectType,
<a name="11" id="anc11"></a><span class="line-modified">214                     currentOwnerSym);</span>
215             MethodSymbol invokeMethodObject = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
216             statements.append(make.VarDef(carrierMatch, makeApply(make.Ident(tryMatch), invokeMethodObject, List.of(translate(tree.expr)))));
217             result = makeBinary(Tag.NE, make.Ident(carrierMatch), makeNull());
218 
219             int idx = 0;
220             for (VarSymbol bindingVar : bindingVars) {
221                 if (bindingVar != syms.lengthVar) {
222                     VarSymbol component = new VarSymbol(0,
223                             names.fromString(&quot;$component$&quot; + tree.pos + &quot;$&quot; + idx),
224                             syms.methodHandleType,
<a name="12" id="anc12"></a><span class="line-modified">225                             currentOwnerSym);</span>
226                     MethodSymbol componentMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;component&quot;), List.of(syms.intType), List.nil());
227                     statements.append(make.VarDef(component, makeApply(make.Ident(e), componentMethod, List.of(make.Literal(idx)))));
228                     Type componentType = types.erasure(bindingVar.type.baseType());
229                     JCTree oldNextTree = env.next.tree;
230                     JCTree oldTree = env.tree;
231                     MethodSymbol invokeMethodForComponent;
232                     try {
233                         env.next.tree = make.TypeCast(componentType, (JCExpression) (env.tree = make.Erroneous()));
234                         invokeMethodForComponent = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
235                     } finally {
236                         env.next.tree = oldNextTree;
237                         env.tree = oldTree;
238                     }
239                     Type castTargetType = bindingVar.erasure(types);
240                     JCAssign bindingInit = (JCAssign)make.at(tree.pos).Assign(
241                             make.Ident(bindingVar), convert(makeApply(make.Ident(component), invokeMethodForComponent, List.of(make.Ident(carrierMatch))), castTargetType)).setType(bindingVar.erasure(types));
242                     JCExpression assignBoolExpr = make.at(tree.pos).LetExpr(List.of(make.Exec(bindingInit)), make.Literal(true)).setType(syms.booleanType);
243                     result = makeBinary(Tag.AND, (JCExpression)result, assignBoolExpr);
244                 }
245                 idx++;
246             }
247             result = make.at(tree.pos).LetExpr(statements.toList(), (JCExpression)result).setType(syms.booleanType);
248             ((LetExpr) result).needsCond = true;
249         } else {
250             super.visitTypeTest(tree);
251         }
252     }
<a name="13" id="anc13"></a><span class="line-modified">253 </span>
254     private Symbol.DynamicVarSymbol preparePatternExtractor(JCPattern patt, Type target, ListBuffer&lt;VarSymbol&gt; bindingVars) {
255         if (target == syms.botType) {
256             target = syms.objectType;
257         }
258         if (patt.hasTag(Tag.BINDINGPATTERN)) {
259             Type tempType = patt.type.hasTag(BOT) ?
260                     syms.objectType
261                     : patt.type;
262             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
263                                                               List.of(tempType),
264                                                               syms.classType.tsym));
265 
266             if (!tempType.isPrimitive()) {
267                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
268                                                                      List.of(target),
269                                                                      syms.classType.tsym));
270             }
271 
272             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
273                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
274 
275             VarSymbol binding = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
<a name="14" id="anc14"></a><span class="line-modified">276 </span>
277             if (binding != null) {
278                 bindingVars.append(binding);
279             }
280 
281             if (tempType.isPrimitive()) {
282                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
283             } else {
284                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
285             }
286         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
<a name="15" id="anc15"></a><span class="line-added">287             //type test already done, finish handling of deconstruction patterns (&quot;T(PATT1, PATT2, ...)&quot;)</span>
<span class="line-added">288             //=&gt;</span>
<span class="line-added">289             //&lt;PATT1-handling&gt; &amp;&amp; &lt;PATT2-handling&gt; &amp;&amp; ...</span>
290             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
291             Type tempType = patt.type.hasTag(BOT) ?
292                     syms.objectType
293                     : patt.type;
294             Type indyType = syms.objectType;
295             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
296                                                 syms.stringType,
297                                                 new ClassType(syms.classType.getEnclosingType(),
298                                                               List.of(syms.patternHandleType),
299                                                               syms.classType.tsym),
300                                                 new ClassType(syms.classType.getEnclosingType(),
301                                                               List.of(tempType),
302                                                               syms.classType.tsym),
303                                                 syms.methodTypeType,
304                                                 syms.stringType,
305                                                 syms.intType);
<a name="16" id="anc16"></a><span class="line-modified">306 </span>
307             Symbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
308                     names.fromString(&quot;ofNamed&quot;), bsm_staticArgs, List.nil());
309 
310             Symbol.DynamicVarSymbol outter = new Symbol.DynamicVarSymbol(names.fromString(&quot;ofNamed&quot;),
311                     syms.noSymbol,
312                     new Symbol.MethodHandleSymbol(ofType),
313                     indyType,
314                     new LoadableConstant[] {(ClassType) tempType,
315                                             new MethodType(dpatt.innerTypes, syms.voidType, List.nil(), syms.methodClass),
316                                             LoadableConstant.String(dpatt.extractorResolver.name.toString()),
317                                             LoadableConstant.Int(ClassFile.REF_newInvokeSpecial)});
318 
319             DynamicVarSymbol[] params = new DynamicVarSymbol[((JCDeconstructionPattern) patt).getNestedPatterns().size() + 1];
320             params[0] = outter;
321             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
322             ListBuffer&lt;VarSymbol&gt;[] nestedBindings = new ListBuffer[((JCDeconstructionPattern) patt).getNestedPatterns().size()];
323 
324             for (int i = 0; i &lt; ((JCDeconstructionPattern) patt).getNestedPatterns().size(); i++) {
325                 JCPattern nested = ((JCDeconstructionPattern) patt).getNestedPatterns().get(i);
326                 params[i + 1] = preparePatternExtractor(nested, nested.type, nestedBindings[i] = new ListBuffer&lt;&gt;());
327                 if (nested.hasTag(Tag.BINDINGPATTERN)) {
328                     bindingVars.appendList(nestedBindings[i].toList());
329                     nestedBindings[i].clear();
330                 } else {
331                     bindingVars.append(syms.lengthVar);
332                 }
333             }
<a name="17" id="anc17"></a><span class="line-modified">334 </span>
335             for (ListBuffer&lt;VarSymbol&gt; nested : nestedBindings) {
336                 if (nested.isEmpty())
337                     continue;
338                 bindingVars.appendList(nested.toList());
339             }
340 
341             List&lt;Type&gt; bsm_staticArgsNested = List.of(syms.patternHandleType,
342                                                       types.makeArrayType(syms.patternHandleType));
343 
344             MethodSymbol ofNested = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
345                     names.fromString(&quot;nested&quot;), bsm_staticArgsNested, List.nil());
<a name="18" id="anc18"></a><span class="line-modified">346 </span>
347             return makeCondyable(patt.pos(), ofNested, params);
348         } else if (patt.hasTag(Tag.ANYPATTERN)) {
349             Type tempType = patt.type.hasTag(BOT) ?
350                     syms.objectType
351                     : patt.type;
352             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
353                                                               List.of(tempType),
354                                                               syms.classType.tsym));
<a name="19" id="anc19"></a><span class="line-modified">355 </span>
356             if (!tempType.isPrimitive()) {
357                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
358                                                                      List.of(target),
359                                                                      syms.classType.tsym));
360             }
361 
362             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
363                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
364 
365             if (tempType.isPrimitive()) {
366                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
367             } else {
368                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
369             }
370         } else if (patt.hasTag(Tag.LITERALPATTERN)) {
371             JCLiteralPattern lpatt = (JCLiteralPattern) patt;
372             boolean adapt = types.boxedTypeOrType(target) == target;
373             List&lt;Type&gt; bsm_staticArgs = List.of(syms.objectType);
<a name="20" id="anc20"></a><span class="line-modified">374 </span>
375             if (adapt) {
376                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
377                                                                      List.of(target),
378                                                                      syms.classType.tsym));
379             }
380 
381             MethodSymbol ofConstant = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
382                     names.fromString(&quot;ofConstant&quot;), bsm_staticArgs, List.nil());
383 
384             LoadableConstant lc;
385             Object constValue = lpatt.value.type.constValue();
386             if (constValue instanceof Double) {
387                 lc = LoadableConstant.Double((Double) constValue);
388             } else if (constValue instanceof Float) {
389                 lc = LoadableConstant.Float((Float) constValue);
390             } else  if (constValue instanceof Integer) {
391                 lc = LoadableConstant.Int((Integer) constValue);
392             } else if (constValue instanceof Long) {
393                 lc = LoadableConstant.Long((Long) constValue);
394             } else if (constValue instanceof String) {
395                 lc = LoadableConstant.String((String) constValue);
396             } else if (constValue == null) {
397                 lc = nullBootstrap();
398             } else {
399                 Assert.error(constValue.getClass().getName());
400                 throw new InternalError();
401             }
402 
403             if (adapt) {
404                 return makeCondyable(patt.pos(), ofConstant, new LoadableConstant[] {lc, (ClassType) target});
405             } else {
406                 return makeCondyable(patt.pos(), ofConstant, new LoadableConstant[] {lc});
407             }
408         } else {
409             throw new IllegalStateException();
410         }
411     }
412 
413     private Symbol.DynamicVarSymbol makeCondyable(DiagnosticPosition pos, MethodSymbol targetMethod, LoadableConstant[] parameters) {
414         Assert.checkNonNull(currentClass);
415 
416         List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
417                                             syms.stringType,
418                                             new ClassType(syms.classType.getEnclosingType(),
419                                                           List.of(syms.patternHandlesType),
420                                                           syms.classType.tsym));
421         bsm_staticArgs = bsm_staticArgs.appendList(targetMethod.type.getParameterTypes());
422 
423         MethodType indyType = new MethodType(bsm_staticArgs, targetMethod.type.getReturnType(), List.nil(), syms.methodClass);
424 
425         MethodSymbol condyable = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC, names.fromString(&quot;$condyable$&quot; + pos.getPreferredPosition()), indyType, currentClass.sym);
426 
427         if ((targetMethod.flags() &amp; Flags.VARARGS) != 0) {
428             condyable.flags_field |= Flags.VARARGS;
429         }
430 
431         currentClass.sym.members().enter(condyable);
432 
433         condyableMethods = condyableMethods.prepend(
434                 make.MethodDef(condyable,
435                                condyable.externalType(types),
436                                make.Block(0, List.of(make.Return(make.Apply(List.nil(), make.QualIdent(targetMethod), condyable.params().stream().skip(3).map(p -&gt; make.Ident(p)).collect(List.collector())).setType(syms.patternHandleType))))));
437 
438         return new Symbol.DynamicVarSymbol(condyable.name,
439                                            syms.noSymbol,
440                                            new MethodHandleSymbol(condyable),
441                                            targetMethod.type.getReturnType(),
442                                            parameters);
443     }
444 
445     private Symbol.DynamicVarSymbol loadPrimitiveClass(DiagnosticPosition pos, Type primitive) {
446         Assert.checkNonNull(currentClass);
447         final Type.ClassType primitiveClass = new ClassType(syms.classType.getEnclosingType(),
448                 List.of(primitive),
449                 syms.classType.tsym);
450 
451         List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
452                                             syms.stringType, primitiveClass);
453         VarSymbol TYPE = rs.resolveInternalField(pos, env, types.boxedTypeOrType(primitive),
454                 names.fromString(&quot;TYPE&quot;));
455         MethodType indyType = new MethodType(bsm_staticArgs, primitiveClass, List.nil(), syms.methodClass);
456 
457         MethodSymbol loadPrimitiveClass = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC, names.fromString(&quot;$primitiveClass$&quot; + pos.getPreferredPosition()), indyType, currentClass.sym);
458 
459         currentClass.sym.members().enter(loadPrimitiveClass);
460 
461         condyableMethods = condyableMethods.prepend(
462                 make.MethodDef(loadPrimitiveClass,
463                                loadPrimitiveClass.externalType(types),
464                                make.Block(0, List.of(make.Return(make.QualIdent(TYPE))))));
465 
466         return new Symbol.DynamicVarSymbol(loadPrimitiveClass.name,
467                                            syms.noSymbol,
468                                            new MethodHandleSymbol(loadPrimitiveClass),
469                                            primitiveClass,
470                                            new LoadableConstant[] {});
471     }
472 
473     private Symbol.DynamicVarSymbol nullBootstrap() {
474         Assert.checkNonNull(currentClass);
475 
476         if (nullBootstrap == null) {
477             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
478                                                 syms.stringType,
479                                                 new ClassType(syms.classType.getEnclosingType(),
480                                                               List.of(syms.objectType),
481                                                               syms.classType.tsym));
482 
483             MethodType indyType = new MethodType(bsm_staticArgs, syms.objectType, List.nil(), syms.methodClass);
484 
485             nullBootstrap = new MethodSymbol(Flags.STATIC | Flags.SYNTHETIC, names.fromString(&quot;$null$bootstrap&quot;), indyType, currentClass.sym);
486 
487             currentClass.sym.members().enter(nullBootstrap);
488 
489             nullBootstrapTree = make.MethodDef(nullBootstrap,
490                                                nullBootstrap.externalType(types),
491                                                make.Block(0, List.of(make.Return(make.Literal(BOT, null).setType(syms.botType)))));
492         }
493 
494         return new Symbol.DynamicVarSymbol(nullBootstrap.name,
495                                            syms.noSymbol,
496                                            new MethodHandleSymbol(nullBootstrap),
497                                            syms.objectType,
498                                            new LoadableConstant[0]);
499     }
500 
501     private JCExpression makeApply(JCExpression site, Symbol method, List&lt;JCExpression&gt; params) {
502         JCFieldAccess acc = make.Select(site, method.name);
503         acc.sym = method;
504         acc.type = method.type;
505         return make.Apply(List.nil(), acc, params).setType(acc.type.getReturnType());
506     }
507 
508     //from Lower:
509     /** Make an attributed tree representing a literal. This will be an
510      *  Ident node in the case of boolean literals, a Literal node in all
511      *  other cases.
512      *  @param type       The literal&#39;s type.
513      *  @param value      The literal&#39;s value.
514      */
515     JCExpression makeLit(Type type, Object value) {
516         return make.Literal(type.getTag(), value).setType(type.constType(value));
517     }
518 
519     /** Make an attributed tree representing null.
520      */
521     JCExpression makeNull() {
522         return makeLit(syms.botType, null);
523     }
<a name="21" id="anc21"></a><span class="line-modified">524 </span>
525     /** Make an attributed assignop expression.
526      *  @param optag    The operators tree tag.
527      *  @param lhs      The operator&#39;s left argument.
528      *  @param rhs      The operator&#39;s right argument.
529      */
530     JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
531         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
532         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
533         tree.type = lhs.type;
534         return tree;
535     }
<a name="22" id="anc22"></a><span class="line-modified">536 </span>
537 //    JCNewArray makeArray(Type type, JCExpression... elements) {
538 //        JCNewArray newArray = make.NewArray(make.Type(types.erasure(type)),
539 //                                          List.nil(),
540 //                                          List.from(elements));
541 //        newArray.type = types.makeArrayType(newArray.elemtype.type);
542 //        return newArray;
543 //    }
544 
545     @Override
546     public void visitBinary(JCBinary tree) {
547         bindingContext = new BasicBindingContext();
548         try {
549             super.visitBinary(tree);
550             result = bindingContext.decorateExpression(tree);
551         } finally {
552             bindingContext.pop();
553         }
554     }
555 
556     @Override
557     public void visitBreak(JCBreak tree) {
558         if (tree.target.hasTag(SWITCH) &amp;&amp; ((JCSwitch) tree.target).kind == SwitchKind.MATCHING) {
559             Assert.checkNonNull(pendingMatchLabel);
560             tree.target = pendingMatchLabel;
561             result = tree;
562         } else {
563             super.visitBreak(tree);
564         }
565     }
566 
567     @Override
568     public void visitConditional(JCConditional tree) {
569         bindingContext = new BasicBindingContext();
570         try {
571             super.visitConditional(tree);
572             result = bindingContext.decorateExpression(tree);
573         } finally {
574             bindingContext.pop();
575         }
576     }
577 
578     @Override
579     public void visitIf(JCIf tree) {
580         bindingContext = new BasicBindingContext();
581         try {
582             super.visitIf(tree);
583             result = bindingContext.decorateStatement(tree);
584         } finally {
585             bindingContext.pop();
586         }
587     }
588 
589     @Override
590     public void visitForLoop(JCForLoop tree) {
591         bindingContext = new BasicBindingContext();
592         try {
593             super.visitForLoop(tree);
594             result = bindingContext.decorateStatement(tree);
595         } finally {
596             bindingContext.pop();
597         }
598     }
599 
600     @Override
601     public void visitWhileLoop(JCWhileLoop tree) {
602         bindingContext = new BasicBindingContext();
603         try {
604             super.visitWhileLoop(tree);
605             result = bindingContext.decorateStatement(tree);
606         } finally {
607             bindingContext.pop();
608         }
609     }
610 
611     @Override
612     public void visitDoLoop(JCDoWhileLoop tree) {
613         bindingContext = new BasicBindingContext();
614         try {
615             super.visitDoLoop(tree);
616             result = bindingContext.decorateStatement(tree);
617         } finally {
618             bindingContext.pop();
619         }
620     }
621 
622     @Override
623     public void visitSwitch(JCSwitch tree) {
624         if (tree.kind == SwitchKind.MATCHING) {
625             JCLabeledStatement prevMatchLabel = pendingMatchLabel;
626             try {
627                 pendingMatchLabel = make.Labelled(names.fromString(&quot;match$&quot; + tree.pos), null);
628                 VarSymbol fallthroughSym = new VarSymbol(0, names.fromString(&quot;fallthrough$&quot; + tree.pos), syms.booleanType, currentMethodSym);
629 
630                 boolean hasFallThrough = false;
631                 boolean wasFallThrough = false;
632 
633                 List&lt;JCStatement&gt; resultStatements = List.nil();
634 
635                 for (JCCase clause : tree.cases) {
636                     Assert.check(clause.pats.size() &lt;= 1);
637                     final JCExpression jcMatches = clause.pats.nonEmpty() ? make.TypeTest(tree.selector, clause.pats.head) : make.Literal(BOOLEAN, 1);
638                     jcMatches.setType(syms.booleanType);
639                     JCStatement body;
640                     List&lt;JCStatement&gt; stats = clause.stats;
641                     if (clause.completesNormally) {
642                         stats = stats.append(make.at(tree.pos).Exec(make.Assign(make.Ident(fallthroughSym), make.Literal(BOOLEAN, 1).setType(syms.booleanType)).setType(syms.booleanType)));
643                     }
644                     body = make.Block(0, stats);
645                     JCStatement translatedIf = translate(make.If(jcMatches, body, null));
646                     JCIf testStatement = translatedIf.hasTag(Tag.IF) ? (JCIf)translatedIf : (JCIf) ((JCBlock)translatedIf).stats.tail.head;
647 
648                     if (wasFallThrough) {
649                         testStatement.cond = makeBinary(Tag.OR,
650                                 make.Ident(fallthroughSym),
651                                 testStatement.cond);
652                     }
653 
654                     hasFallThrough |= wasFallThrough = clause.completesNormally;
655                     resultStatements = resultStatements.append(translatedIf);
656                 }
657                 if (hasFallThrough) {
658                     resultStatements = resultStatements.prepend(make.at(tree.pos)
659                                                                     .VarDef(fallthroughSym,
660                                                                             make.Literal(BOOLEAN, 0).setType(syms.booleanType)));
661                 }
662                 pendingMatchLabel.body = make.Block(0, resultStatements);
663                 result = pendingMatchLabel;
664             } finally {
665                 pendingMatchLabel = prevMatchLabel;
666             }
667         } else {
668             super.visitSwitch(tree);
669         }
670     }
671 
672     @Override
673     public void visitClassDef(JCTree.JCClassDecl tree) {
674         JCClassDecl prevCurrentClass = currentClass;
675         List&lt;JCTree&gt; prevCondyableMethods = condyableMethods;
676         MethodSymbol prevNullBootstrap = nullBootstrap;
677         JCMethodDecl prevNullBootstrapTree = nullBootstrapTree;
678         try {
679             currentClass = tree;
680             condyableMethods = List.nil();
681             nullBootstrap = null;
682             nullBootstrapTree = null;
683             super.visitClassDef(tree);
684         } finally {
685             currentClass.defs = currentClass.defs.prependList(condyableMethods);
686             if (nullBootstrapTree != null) {
687                 currentClass.defs = currentClass.defs.prepend(nullBootstrapTree);
688             }
689             currentClass = prevCurrentClass;
690             condyableMethods = prevCondyableMethods;
691             nullBootstrap = prevNullBootstrap;
692             nullBootstrapTree = prevNullBootstrapTree;
693         }
694     }
695 
696     @Override
697     public void visitMethodDef(JCMethodDecl tree) {
698         MethodSymbol prevMethodSym = currentMethodSym;
699         try {
700             currentMethodSym = tree.sym;
701             super.visitMethodDef(tree);
702         } finally {
703             currentMethodSym = prevMethodSym;
704         }
705     }
706 
707     @Override
708     public void visitIdent(JCIdent tree) {
709         VarSymbol bindingVar = null;
710         if ((tree.sym.flags() &amp; Flags.MATCH_BINDING) != 0) {
711             bindingVar = bindingContext.getBindingFor((BindingSymbol)tree.sym);
712         }
713         if (bindingVar == null) {
714             super.visitIdent(tree);
715         } else {
716             result = make.at(tree.pos).Ident(bindingVar);
717         }
718     }
719 
720     @Override
721     public void visitBlock(JCBlock tree) {
722         ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
723         bindingContext = new BindingDeclarationFenceBindingContext() {
724             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
725                 //{
726                 //    if (E instanceof T N) {
727                 //        return ;
728                 //    }
729                 //    //use of N:
730                 //}
731                 //=&gt;
732                 //{
733                 //    T N;
734                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
735                 //        return ;
736                 //    }
737                 //    //use of N:
738                 //}
739                 hoistedVarMap.put(binding, var.sym);
740                 statements.append(var);
741                 return true;
742             }
743         };
<a name="23" id="anc23"></a><span class="line-added">744         Symbol prevOwnerSym = currentOwnerSym;</span>
745         try {
<a name="24" id="anc24"></a><span class="line-added">746             if (currentOwnerSym == null) {</span>
<span class="line-added">747                 currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,</span>
<span class="line-added">748                                  names.empty, null,</span>
<span class="line-added">749                                  currentClass.sym);</span>
<span class="line-added">750             }</span>
751             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
752                 statements.append(translate(l.head));
753             }
754 
755             tree.stats = statements.toList();
756             result = tree;
757         } finally {
758             bindingContext.pop();
<a name="25" id="anc25"></a><span class="line-added">759             currentOwnerSym = prevOwnerSym;</span>
760         }
761     }
762 
763     @Override
764     public void visitLambda(JCLambda tree) {
765         BindingContext prevContent = bindingContext;
766         try {
767             bindingContext = new BindingDeclarationFenceBindingContext();
768             super.visitLambda(tree);
769         } finally {
770             bindingContext = prevContent;
771         }
772     }
773 
774     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
775         try {
776             this.make = make;
777             this.env = env;
778             translate(cdef);
779         } finally {
780             // note that recursive invocations of this method fail hard
781             this.make = null;
782             this.env = null;
783         }
784 
785         return cdef;
786     }
787 
788     /** Make an instanceof expression.
789      *  @param lhs      The expression.
790      *  @param type     The type to be tested.
791      */
792 
793     JCInstanceOf makeTypeTest(JCExpression lhs, JCExpression type) {
794         JCInstanceOf tree = make.TypeTest(lhs, type);
795         tree.type = syms.booleanType;
796         return tree;
797     }
798 
799     /** Make an attributed binary expression (copied from Lower).
800      *  @param optag    The operators tree tag.
801      *  @param lhs      The operator&#39;s left argument.
802      *  @param rhs      The operator&#39;s right argument.
803      */
804     JCBinary makeBinary(JCTree.Tag optag, JCExpression lhs, JCExpression rhs) {
805         JCBinary tree = make.Binary(optag, lhs, rhs);
806         tree.operator = operators.resolveBinary(tree, optag, lhs.type, rhs.type);
807         tree.type = tree.operator.type.getReturnType();
808         return tree;
809     }
810 
811     JCExpression convert(JCExpression expr, Type target) {
812         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
813         result.type = target;
814         return result;
815     }
816 
817     abstract class BindingContext {
818         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
819         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
820         abstract JCStatement decorateStatement(JCStatement stat);
821         abstract JCExpression decorateExpression(JCExpression expr);
822         abstract BindingContext pop();
823         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
824     }
825 
826     class BasicBindingContext extends BindingContext {
827         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
828         BindingContext parent;
829 
830         public BasicBindingContext() {
831             this.parent = bindingContext;
<a name="26" id="anc26"></a><span class="line-modified">832             this.hoistedVarMap = new LinkedHashMap&lt;&gt;();</span>
833         }
834 
835         @Override
836         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
837             VarSymbol res = parent.bindingDeclared(varSymbol);
838             if (res == null) {
<a name="27" id="anc27"></a><span class="line-modified">839                 res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, varSymbol.owner);</span>
840                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
841                 hoistedVarMap.put(varSymbol, res);
842             }
843             return res;
844         }
845 
846         @Override
847         VarSymbol getBindingFor(BindingSymbol varSymbol) {
848             VarSymbol res = parent.getBindingFor(varSymbol);
849             if (res != null) {
850                 return res;
851             }
852             return hoistedVarMap.entrySet().stream()
853                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
854                     .findFirst()
855                     .map(e -&gt; e.getValue()).orElse(null);
856         }
857 
858         @Override
859         JCStatement decorateStatement(JCStatement stat) {
860             if (hoistedVarMap.isEmpty()) return stat;
861             //if (E instanceof T N) {
862             //     //use N
863             //}
864             //=&gt;
865             //{
866             //    T N;
867             //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
868             //        //use N
869             //    }
870             //}
871             ListBuffer&lt;JCStatement&gt; stats = new ListBuffer&lt;&gt;();
872             for (Entry&lt;BindingSymbol, VarSymbol&gt; e : hoistedVarMap.entrySet()) {
873                 JCVariableDecl decl = makeHoistedVarDecl(stat.pos, e.getValue());
874                 if (!e.getKey().isPreserved() ||
875                     !parent.tryPrepend(e.getKey(), decl)) {
876                     stats.add(decl);
877                 }
878             }
879             if (stats.nonEmpty()) {
880                 stats.add(stat);
881                 stat = make.at(stat.pos).Block(0, stats.toList());
882             }
883             return stat;
884         }
885 
886         @Override
887         JCExpression decorateExpression(JCExpression expr) {
888             //E instanceof T N &amp;&amp; /*use of N*/
889             //=&gt;
890             //(let T N; (let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp)) &amp;&amp; /*use of N*/)
891             for (VarSymbol vsym : hoistedVarMap.values()) {
892                 expr = make.at(expr.pos).LetExpr(makeHoistedVarDecl(expr.pos, vsym), expr).setType(expr.type);
893             }
894             return expr;
895         }
896 
897         @Override
898         BindingContext pop() {
899             return bindingContext = parent;
900         }
901 
902         @Override
903         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
904             return false;
905         }
906 
907         private JCVariableDecl makeHoistedVarDecl(int pos, VarSymbol varSymbol) {
908             return make.at(pos).VarDef(varSymbol, null);
909         }
910     }
911 
912     private class BindingDeclarationFenceBindingContext extends BasicBindingContext {
913 
914         @Override
915         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
916             return null;
917         }
918 
919     }
920 }
<a name="28" id="anc28"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="28" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.compiler/share/classes/com/sun/tools/javac/tree/TreeMaker.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1999, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.tools.javac.tree;
  27 
  28 import java.util.Iterator;
  29 
  30 import com.sun.source.tree.CaseTree;
  31 import com.sun.source.tree.CaseTree.CaseKind;
  32 import com.sun.source.tree.ModuleTree.ModuleKind;
  33 import com.sun.tools.javac.code.*;
  34 import com.sun.tools.javac.code.Attribute.UnresolvedClass;
  35 import com.sun.tools.javac.code.Symbol.*;
  36 import com.sun.tools.javac.code.Type.*;
  37 import com.sun.tools.javac.util.*;
  38 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
  39 
  40 import com.sun.tools.javac.tree.JCTree.*;
  41 
  42 import static com.sun.tools.javac.code.Flags.*;
  43 import static com.sun.tools.javac.code.Kinds.Kind.*;
  44 import static com.sun.tools.javac.code.TypeTag.*;
<a name="1" id="anc1"></a><span class="line-removed">  45 import com.sun.tools.javac.tree.JCTree;</span>
<span class="line-removed">  46 import com.sun.tools.javac.tree.JCTree.JCExpression;</span>
<span class="line-removed">  47 import com.sun.tools.javac.tree.JCTree.JCPattern;</span>
<span class="line-removed">  48 import com.sun.tools.javac.util.List;</span>
<span class="line-removed">  49 import com.sun.tools.javac.util.Name;</span>
  50 
  51 /** Factory class for trees.
  52  *
  53  *  &lt;p&gt;&lt;b&gt;This is NOT part of any supported API.
  54  *  If you write code that depends on this, you do so at your own risk.
  55  *  This code and its internal interfaces are subject to change or
  56  *  deletion without notice.&lt;/b&gt;
  57  */
  58 public class TreeMaker implements JCTree.Factory {
  59 
  60     /** The context key for the tree factory. */
  61     protected static final Context.Key&lt;TreeMaker&gt; treeMakerKey = new Context.Key&lt;&gt;();
  62 
  63     /** Get the TreeMaker instance. */
  64     public static TreeMaker instance(Context context) {
  65         TreeMaker instance = context.get(treeMakerKey);
  66         if (instance == null)
  67             instance = new TreeMaker(context);
  68         return instance;
  69     }
  70 
  71     /** The position at which subsequent trees will be created.
  72      */
  73     public int pos = Position.NOPOS;
  74 
  75     /** The toplevel tree to which created trees belong.
  76      */
  77     public JCCompilationUnit toplevel;
  78 
  79     /** The current name table. */
  80     Names names;
  81 
  82     Types types;
  83 
  84     /** The current symbol table. */
  85     Symtab syms;
  86 
  87     /** Create a tree maker with null toplevel and NOPOS as initial position.
  88      */
  89     protected TreeMaker(Context context) {
  90         context.put(treeMakerKey, this);
  91         this.pos = Position.NOPOS;
  92         this.toplevel = null;
  93         this.names = Names.instance(context);
  94         this.syms = Symtab.instance(context);
  95         this.types = Types.instance(context);
  96     }
  97 
  98     /** Create a tree maker with a given toplevel and FIRSTPOS as initial position.
  99      */
 100     protected TreeMaker(JCCompilationUnit toplevel, Names names, Types types, Symtab syms) {
 101         this.pos = Position.FIRSTPOS;
 102         this.toplevel = toplevel;
 103         this.names = names;
 104         this.types = types;
 105         this.syms = syms;
 106     }
 107 
 108     /** Create a new tree maker for a given toplevel.
 109      */
 110     public TreeMaker forToplevel(JCCompilationUnit toplevel) {
 111         return new TreeMaker(toplevel, names, types, syms);
 112     }
 113 
 114     /** Reassign current position.
 115      */
 116     public TreeMaker at(int pos) {
 117         this.pos = pos;
 118         return this;
 119     }
 120 
 121     /** Reassign current position.
 122      */
 123     public TreeMaker at(DiagnosticPosition pos) {
 124         this.pos = (pos == null ? Position.NOPOS : pos.getStartPosition());
 125         return this;
 126     }
 127 
 128     /**
 129      * Create given tree node at current position.
 130      * @param defs a list of PackageDef, ClassDef, Import, and Skip
 131      */
 132     public JCCompilationUnit TopLevel(List&lt;JCTree&gt; defs) {
 133         for (JCTree node : defs)
 134             Assert.check(node instanceof JCClassDecl
 135                 || node instanceof JCPackageDecl
 136                 || node instanceof JCImport
 137                 || node instanceof JCModuleDecl
 138                 || node instanceof JCSkip
 139                 || node instanceof JCErroneous
 140                 || (node instanceof JCExpressionStatement
 141                     &amp;&amp; ((JCExpressionStatement)node).expr instanceof JCErroneous),
 142                     () -&gt; node.getClass().getSimpleName());
 143         JCCompilationUnit tree = new JCCompilationUnit(defs);
 144         tree.pos = pos;
 145         return tree;
 146     }
 147 
 148     public JCPackageDecl PackageDecl(List&lt;JCAnnotation&gt; annotations,
 149                                      JCExpression pid) {
 150         Assert.checkNonNull(annotations);
 151         Assert.checkNonNull(pid);
 152         JCPackageDecl tree = new JCPackageDecl(annotations, pid);
 153         tree.pos = pos;
 154         return tree;
 155     }
 156 
 157     public JCImport Import(JCTree qualid, boolean importStatic) {
 158         JCImport tree = new JCImport(qualid, importStatic);
 159         tree.pos = pos;
 160         return tree;
 161     }
 162 
 163     public JCClassDecl ClassDef(JCModifiers mods,
 164                                 Name name,
 165                                 List&lt;JCTypeParameter&gt; typarams,
 166                                 JCExpression extending,
 167                                 List&lt;JCExpression&gt; implementing,
 168                                 List&lt;JCTree&gt; defs)
 169     {
 170         JCClassDecl tree = new JCClassDecl(mods,
 171                                      name,
 172                                      typarams,
 173                                      extending,
 174                                      implementing,
 175                                      defs,
 176                                      null);
 177         tree.pos = pos;
 178         return tree;
 179     }
 180 
 181     public JCMethodDecl MethodDef(JCModifiers mods,
 182                                Name name,
 183                                JCExpression restype,
 184                                List&lt;JCTypeParameter&gt; typarams,
 185                                List&lt;JCVariableDecl&gt; params,
 186                                List&lt;JCExpression&gt; thrown,
 187                                JCBlock body,
 188                                JCExpression defaultValue) {
 189         return MethodDef(
 190                 mods, name, restype, typarams, null, params,
 191                 thrown, body, defaultValue);
 192     }
 193 
 194     public JCMethodDecl MethodDef(JCModifiers mods,
 195                                Name name,
 196                                JCExpression restype,
 197                                List&lt;JCTypeParameter&gt; typarams,
 198                                JCVariableDecl recvparam,
 199                                List&lt;JCVariableDecl&gt; params,
 200                                List&lt;JCExpression&gt; thrown,
 201                                JCBlock body,
 202                                JCExpression defaultValue)
 203     {
 204         JCMethodDecl tree = new JCMethodDecl(mods,
 205                                        name,
 206                                        restype,
 207                                        typarams,
 208                                        recvparam,
 209                                        params,
 210                                        thrown,
 211                                        body,
 212                                        defaultValue,
 213                                        null);
 214         tree.pos = pos;
 215         return tree;
 216     }
 217 
 218     public JCVariableDecl VarDef(JCModifiers mods, Name name, JCExpression vartype, JCExpression init) {
 219         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype, init, null);
 220         tree.pos = pos;
 221         return tree;
 222     }
 223 
 224     public JCVariableDecl ReceiverVarDef(JCModifiers mods, JCExpression name, JCExpression vartype) {
 225         JCVariableDecl tree = new JCVariableDecl(mods, name, vartype);
 226         tree.pos = pos;
 227         return tree;
 228     }
 229 
 230     public JCSkip Skip() {
 231         JCSkip tree = new JCSkip();
 232         tree.pos = pos;
 233         return tree;
 234     }
 235 
 236     public JCBlock Block(long flags, List&lt;JCStatement&gt; stats) {
 237         JCBlock tree = new JCBlock(flags, stats);
 238         tree.pos = pos;
 239         return tree;
 240     }
 241 
 242     public JCDoWhileLoop DoLoop(JCStatement body, JCExpression cond) {
 243         JCDoWhileLoop tree = new JCDoWhileLoop(body, cond);
 244         tree.pos = pos;
 245         return tree;
 246     }
 247 
 248     public JCWhileLoop WhileLoop(JCExpression cond, JCStatement body) {
 249         JCWhileLoop tree = new JCWhileLoop(cond, body);
 250         tree.pos = pos;
 251         return tree;
 252     }
 253 
 254     public JCForLoop ForLoop(List&lt;JCStatement&gt; init,
 255                            JCExpression cond,
 256                            List&lt;JCExpressionStatement&gt; step,
 257                            JCStatement body)
 258     {
 259         JCForLoop tree = new JCForLoop(init, cond, step, body);
 260         tree.pos = pos;
 261         return tree;
 262     }
 263 
 264     public JCEnhancedForLoop ForeachLoop(JCVariableDecl var, JCExpression expr, JCStatement body) {
 265         JCEnhancedForLoop tree = new JCEnhancedForLoop(var, expr, body);
 266         tree.pos = pos;
 267         return tree;
 268     }
 269 
 270     public JCLabeledStatement Labelled(Name label, JCStatement body) {
 271         JCLabeledStatement tree = new JCLabeledStatement(label, body);
 272         tree.pos = pos;
 273         return tree;
 274     }
 275 
 276     public JCSwitch Switch(JCExpression selector, List&lt;JCCase&gt; cases) {
 277         JCSwitch tree = new JCSwitch(selector, cases);
 278         tree.pos = pos;
 279         return tree;
 280     }
 281 
 282     public JCCase Case(CaseKind caseKind, List&lt;JCPattern&gt; pats,
 283                        List&lt;JCStatement&gt; stats, JCTree body) {
 284         JCCase tree = new JCCase(caseKind, pats, stats, body);
 285         tree.pos = pos;
 286         return tree;
 287     }
 288 
 289     public JCSwitchExpression SwitchExpression(JCExpression selector, List&lt;JCCase&gt; cases) {
 290         JCSwitchExpression tree = new JCSwitchExpression(selector, cases);
 291         tree.pos = pos;
 292         return tree;
 293     }
 294 
 295     public JCSynchronized Synchronized(JCExpression lock, JCBlock body) {
 296         JCSynchronized tree = new JCSynchronized(lock, body);
 297         tree.pos = pos;
 298         return tree;
 299     }
 300 
 301     public JCTry Try(JCBlock body, List&lt;JCCatch&gt; catchers, JCBlock finalizer) {
 302         return Try(List.nil(), body, catchers, finalizer);
 303     }
 304 
 305     public JCTry Try(List&lt;JCTree&gt; resources,
 306                      JCBlock body,
 307                      List&lt;JCCatch&gt; catchers,
 308                      JCBlock finalizer) {
 309         JCTry tree = new JCTry(resources, body, catchers, finalizer);
 310         tree.pos = pos;
 311         return tree;
 312     }
 313 
 314     public JCCatch Catch(JCVariableDecl param, JCBlock body) {
 315         JCCatch tree = new JCCatch(param, body);
 316         tree.pos = pos;
 317         return tree;
 318     }
 319 
 320     public JCConditional Conditional(JCExpression cond,
 321                                    JCExpression thenpart,
 322                                    JCExpression elsepart)
 323     {
 324         JCConditional tree = new JCConditional(cond, thenpart, elsepart);
 325         tree.pos = pos;
 326         return tree;
 327     }
 328 
 329     public JCIf If(JCExpression cond, JCStatement thenpart, JCStatement elsepart) {
 330         JCIf tree = new JCIf(cond, thenpart, elsepart);
 331         tree.pos = pos;
 332         return tree;
 333     }
 334 
 335     public JCExpressionStatement Exec(JCExpression expr) {
 336         JCExpressionStatement tree = new JCExpressionStatement(expr);
 337         tree.pos = pos;
 338         return tree;
 339     }
 340 
 341     public JCBreak Break(Name label) {
 342         JCBreak tree = new JCBreak(label, null);
 343         tree.pos = pos;
 344         return tree;
 345     }
 346 
 347     public JCYield Yield(JCExpression value) {
 348         JCYield tree = new JCYield(value, null);
 349         tree.pos = pos;
 350         return tree;
 351     }
 352 
 353     public JCContinue Continue(Name label) {
 354         JCContinue tree = new JCContinue(label, null);
 355         tree.pos = pos;
 356         return tree;
 357     }
 358 
 359     public JCReturn Return(JCExpression expr) {
 360         JCReturn tree = new JCReturn(expr);
 361         tree.pos = pos;
 362         return tree;
 363     }
 364 
 365     public JCThrow Throw(JCExpression expr) {
 366         JCThrow tree = new JCThrow(expr);
 367         tree.pos = pos;
 368         return tree;
 369     }
 370 
 371     public JCAssert Assert(JCExpression cond, JCExpression detail) {
 372         JCAssert tree = new JCAssert(cond, detail);
 373         tree.pos = pos;
 374         return tree;
 375     }
 376 
 377     public JCMethodInvocation Apply(List&lt;JCExpression&gt; typeargs,
 378                        JCExpression fn,
 379                        List&lt;JCExpression&gt; args)
 380     {
 381         JCMethodInvocation tree = new JCMethodInvocation(typeargs, fn, args);
 382         tree.pos = pos;
 383         return tree;
 384     }
 385 
 386     public JCNewClass NewClass(JCExpression encl,
 387                              List&lt;JCExpression&gt; typeargs,
 388                              JCExpression clazz,
 389                              List&lt;JCExpression&gt; args,
 390                              JCClassDecl def)
 391     {
 392         return SpeculativeNewClass(encl, typeargs, clazz, args, def, false);
 393     }
 394 
 395     public JCNewClass SpeculativeNewClass(JCExpression encl,
 396                              List&lt;JCExpression&gt; typeargs,
 397                              JCExpression clazz,
 398                              List&lt;JCExpression&gt; args,
 399                              JCClassDecl def,
 400                              boolean classDefRemoved)
 401     {
 402         JCNewClass tree = classDefRemoved ?
 403                 new JCNewClass(encl, typeargs, clazz, args, def) {
 404                     @Override
 405                     public boolean classDeclRemoved() {
 406                         return true;
 407                     }
 408                 } :
 409                 new JCNewClass(encl, typeargs, clazz, args, def);
 410         tree.pos = pos;
 411         return tree;
 412     }
 413 
 414     public JCNewArray NewArray(JCExpression elemtype,
 415                              List&lt;JCExpression&gt; dims,
 416                              List&lt;JCExpression&gt; elems)
 417     {
 418         JCNewArray tree = new JCNewArray(elemtype, dims, elems);
 419         tree.pos = pos;
 420         return tree;
 421     }
 422 
 423     public JCLambda Lambda(List&lt;JCVariableDecl&gt; params,
 424                            JCTree body)
 425     {
 426         JCLambda tree = new JCLambda(params, body);
 427         tree.pos = pos;
 428         return tree;
 429     }
 430 
 431     public JCParens Parens(JCExpression expr) {
 432         JCParens tree = new JCParens(expr);
 433         tree.pos = pos;
 434         return tree;
 435     }
 436 
 437     public JCAssign Assign(JCExpression lhs, JCExpression rhs) {
 438         JCAssign tree = new JCAssign(lhs, rhs);
 439         tree.pos = pos;
 440         return tree;
 441     }
 442 
 443     public JCAssignOp Assignop(JCTree.Tag opcode, JCTree lhs, JCTree rhs) {
 444         JCAssignOp tree = new JCAssignOp(opcode, lhs, rhs, null);
 445         tree.pos = pos;
 446         return tree;
 447     }
 448 
 449     public JCUnary Unary(JCTree.Tag opcode, JCExpression arg) {
 450         JCUnary tree = new JCUnary(opcode, arg);
 451         tree.pos = pos;
 452         return tree;
 453     }
 454 
 455     public JCBinary Binary(JCTree.Tag opcode, JCExpression lhs, JCExpression rhs) {
 456         JCBinary tree = new JCBinary(opcode, lhs, rhs, null);
 457         tree.pos = pos;
 458         return tree;
 459     }
 460 
 461     public JCTypeCast TypeCast(JCTree clazz, JCExpression expr) {
 462         JCTypeCast tree = new JCTypeCast(clazz, expr);
 463         tree.pos = pos;
 464         return tree;
 465     }
 466 
 467     public JCInstanceOf TypeTest(JCExpression expr, JCTree clazz) {
 468         JCInstanceOf tree = new JCInstanceOf(expr, clazz);
 469         tree.pos = pos;
 470         return tree;
 471     }
 472 
 473     public JCAnyPattern AnyPattern() {
 474         JCAnyPattern tree = new JCAnyPattern();
 475         tree.pos = pos;
 476         return tree;
 477     }
 478 
 479     public JCBindingPattern BindingPattern(Name name, JCTree vartype) {
 480         JCBindingPattern tree = new JCBindingPattern(name, null, vartype);
 481         tree.pos = pos;
 482         return tree;
 483     }
 484 
<a name="2" id="anc2"></a><span class="line-modified"> 485     public JCDeconstructionPattern DeconstructionPattern(Name name, JCExpression deconstructor, List&lt;JCPattern&gt; nested) {</span>
<span class="line-modified"> 486         JCDeconstructionPattern tree = new JCDeconstructionPattern(name, deconstructor, nested);</span>
 487         tree.pos = pos;
 488         return tree;
 489     }
 490 
 491     public JCLiteralPattern LiteralPattern(JCExpression cexp) {
 492         JCLiteralPattern tree = new JCLiteralPattern(cexp);
 493         tree.pos = pos;
 494         return tree;
 495     }
 496 
 497     public JCArrayAccess Indexed(JCExpression indexed, JCExpression index) {
 498         JCArrayAccess tree = new JCArrayAccess(indexed, index);
 499         tree.pos = pos;
 500         return tree;
 501     }
 502 
 503     public JCFieldAccess Select(JCExpression selected, Name selector) {
 504         JCFieldAccess tree = new JCFieldAccess(selected, selector, null);
 505         tree.pos = pos;
 506         return tree;
 507     }
 508 
 509     public JCMemberReference Reference(JCMemberReference.ReferenceMode mode, Name name,
 510             JCExpression expr, List&lt;JCExpression&gt; typeargs) {
 511         JCMemberReference tree = new JCMemberReference(mode, name, expr, typeargs);
 512         tree.pos = pos;
 513         return tree;
 514     }
 515 
 516     public JCIdent Ident(Name name) {
 517         JCIdent tree = new JCIdent(name, null);
 518         tree.pos = pos;
 519         return tree;
 520     }
 521 
 522     public JCLiteral Literal(TypeTag tag, Object value) {
 523         JCLiteral tree = new JCLiteral(tag, value);
 524         tree.pos = pos;
 525         return tree;
 526     }
 527 
 528     public JCPrimitiveTypeTree TypeIdent(TypeTag typetag) {
 529         JCPrimitiveTypeTree tree = new JCPrimitiveTypeTree(typetag);
 530         tree.pos = pos;
 531         return tree;
 532     }
 533 
 534     public JCArrayTypeTree TypeArray(JCExpression elemtype) {
 535         JCArrayTypeTree tree = new JCArrayTypeTree(elemtype);
 536         tree.pos = pos;
 537         return tree;
 538     }
 539 
 540     public JCTypeApply TypeApply(JCExpression clazz, List&lt;JCExpression&gt; arguments) {
 541         JCTypeApply tree = new JCTypeApply(clazz, arguments);
 542         tree.pos = pos;
 543         return tree;
 544     }
 545 
 546     public JCTypeUnion TypeUnion(List&lt;JCExpression&gt; components) {
 547         JCTypeUnion tree = new JCTypeUnion(components);
 548         tree.pos = pos;
 549         return tree;
 550     }
 551 
 552     public JCTypeIntersection TypeIntersection(List&lt;JCExpression&gt; components) {
 553         JCTypeIntersection tree = new JCTypeIntersection(components);
 554         tree.pos = pos;
 555         return tree;
 556     }
 557 
 558     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds) {
 559         return TypeParameter(name, bounds, List.nil());
 560     }
 561 
 562     public JCTypeParameter TypeParameter(Name name, List&lt;JCExpression&gt; bounds, List&lt;JCAnnotation&gt; annos) {
 563         JCTypeParameter tree = new JCTypeParameter(name, bounds, annos);
 564         tree.pos = pos;
 565         return tree;
 566     }
 567 
 568     public JCWildcard Wildcard(TypeBoundKind kind, JCTree type) {
 569         JCWildcard tree = new JCWildcard(kind, type);
 570         tree.pos = pos;
 571         return tree;
 572     }
 573 
 574     public TypeBoundKind TypeBoundKind(BoundKind kind) {
 575         TypeBoundKind tree = new TypeBoundKind(kind);
 576         tree.pos = pos;
 577         return tree;
 578     }
 579 
 580     public JCAnnotation Annotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 581         JCAnnotation tree = new JCAnnotation(Tag.ANNOTATION, annotationType, args);
 582         tree.pos = pos;
 583         return tree;
 584     }
 585 
 586     public JCAnnotation TypeAnnotation(JCTree annotationType, List&lt;JCExpression&gt; args) {
 587         JCAnnotation tree = new JCAnnotation(Tag.TYPE_ANNOTATION, annotationType, args);
 588         tree.pos = pos;
 589         return tree;
 590     }
 591 
 592     public JCModifiers Modifiers(long flags, List&lt;JCAnnotation&gt; annotations) {
 593         JCModifiers tree = new JCModifiers(flags, annotations);
 594         boolean noFlags = (flags &amp; (Flags.ModifierFlags | Flags.ANNOTATION)) == 0;
 595         tree.pos = (noFlags &amp;&amp; annotations.isEmpty()) ? Position.NOPOS : pos;
 596         return tree;
 597     }
 598 
 599     public JCModifiers Modifiers(long flags) {
 600         return Modifiers(flags, List.nil());
 601     }
 602 
 603     @Override
 604     public JCModuleDecl ModuleDef(JCModifiers mods, ModuleKind kind,
 605             JCExpression qualid, List&lt;JCDirective&gt; directives) {
 606         JCModuleDecl tree = new JCModuleDecl(mods, kind, qualid, directives);
 607         tree.pos = pos;
 608         return tree;
 609     }
 610 
 611     @Override
 612     public JCExports Exports(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 613         JCExports tree = new JCExports(qualId, moduleNames);
 614         tree.pos = pos;
 615         return tree;
 616     }
 617 
 618     @Override
 619     public JCOpens Opens(JCExpression qualId, List&lt;JCExpression&gt; moduleNames) {
 620         JCOpens tree = new JCOpens(qualId, moduleNames);
 621         tree.pos = pos;
 622         return tree;
 623     }
 624 
 625     @Override
 626     public JCProvides Provides(JCExpression serviceName, List&lt;JCExpression&gt; implNames) {
 627         JCProvides tree = new JCProvides(serviceName, implNames);
 628         tree.pos = pos;
 629         return tree;
 630     }
 631 
 632     @Override
 633     public JCRequires Requires(boolean isTransitive, boolean isStaticPhase, JCExpression qualId) {
 634         JCRequires tree = new JCRequires(isTransitive, isStaticPhase, qualId);
 635         tree.pos = pos;
 636         return tree;
 637     }
 638 
 639     @Override
 640     public JCUses Uses(JCExpression qualId) {
 641         JCUses tree = new JCUses(qualId);
 642         tree.pos = pos;
 643         return tree;
 644     }
 645 
 646     public JCAnnotatedType AnnotatedType(List&lt;JCAnnotation&gt; annotations, JCExpression underlyingType) {
 647         JCAnnotatedType tree = new JCAnnotatedType(annotations, underlyingType);
 648         tree.pos = pos;
 649         return tree;
 650     }
 651 
 652     public JCErroneous Erroneous() {
 653         return Erroneous(List.nil());
 654     }
 655 
 656     public JCErroneous Erroneous(List&lt;? extends JCTree&gt; errs) {
 657         JCErroneous tree = new JCErroneous(errs);
 658         tree.pos = pos;
 659         return tree;
 660     }
 661 
<a name="3" id="anc3"></a><span class="line-modified"> 662     public LetExpr LetExpr(List&lt;? extends JCStatement&gt; defs, JCExpression expr) {</span>
 663         LetExpr tree = new LetExpr(defs, expr);
 664         tree.pos = pos;
 665         return tree;
 666     }
 667 
 668 /* ***************************************************************************
 669  * Derived building blocks.
 670  ****************************************************************************/
 671 
 672     public JCClassDecl AnonymousClassDef(JCModifiers mods,
 673                                          List&lt;JCTree&gt; defs)
 674     {
 675         return ClassDef(mods,
 676                         names.empty,
 677                         List.nil(),
 678                         null,
 679                         List.nil(),
 680                         defs);
 681     }
 682 
 683     public LetExpr LetExpr(JCVariableDecl def, JCExpression expr) {
 684         LetExpr tree = new LetExpr(List.of(def), expr);
 685         tree.pos = pos;
 686         return tree;
 687     }
 688 
 689     /** Create an identifier from a symbol.
 690      */
 691     public JCIdent Ident(Symbol sym) {
 692         return (JCIdent)new JCIdent((sym.name != names.empty)
 693                                 ? sym.name
 694                                 : sym.flatName(), sym)
 695             .setPos(pos)
 696             .setType(sym.type);
 697     }
 698 
 699     /** Create a selection node from a qualifier tree and a symbol.
 700      *  @param base   The qualifier tree.
 701      */
 702     public JCExpression Select(JCExpression base, Symbol sym) {
 703         return new JCFieldAccess(base, sym.name, sym).setPos(pos).setType(sym.type);
 704     }
 705 
 706     /** Create a qualified identifier from a symbol, adding enough qualifications
 707      *  to make the reference unique.
 708      */
 709     public JCExpression QualIdent(Symbol sym) {
 710         return isUnqualifiable(sym)
 711             ? Ident(sym)
 712             : Select(QualIdent(sym.owner), sym);
 713     }
 714 
 715     /** Create an identifier that refers to the variable declared in given variable
 716      *  declaration.
 717      */
 718     public JCExpression Ident(JCVariableDecl param) {
 719         return Ident(param.sym);
 720     }
 721 
 722     /** Create a list of identifiers referring to the variables declared
 723      *  in given list of variable declarations.
 724      */
 725     public List&lt;JCExpression&gt; Idents(List&lt;JCVariableDecl&gt; params) {
 726         ListBuffer&lt;JCExpression&gt; ids = new ListBuffer&lt;&gt;();
 727         for (List&lt;JCVariableDecl&gt; l = params; l.nonEmpty(); l = l.tail)
 728             ids.append(Ident(l.head));
 729         return ids.toList();
 730     }
 731 
 732     /** Create a tree representing `this&#39;, given its type.
 733      */
 734     public JCExpression This(Type t) {
 735         return Ident(new VarSymbol(FINAL, names._this, t, t.tsym));
 736     }
 737 
 738     /** Create a tree representing qualified `this&#39; given its type
 739      */
 740     public JCExpression QualThis(Type t) {
 741         return Select(Type(t), new VarSymbol(FINAL, names._this, t, t.tsym));
 742     }
 743 
 744     /** Create a tree representing a class literal.
 745      */
 746     public JCExpression ClassLiteral(ClassSymbol clazz) {
 747         return ClassLiteral(clazz.type);
 748     }
 749 
 750     /** Create a tree representing a class literal.
 751      */
 752     public JCExpression ClassLiteral(Type t) {
 753         VarSymbol lit = new VarSymbol(STATIC | PUBLIC | FINAL,
 754                                       names._class,
 755                                       t,
 756                                       t.tsym);
 757         return Select(Type(t), lit);
 758     }
 759 
 760     /** Create a tree representing `super&#39;, given its type and owner.
 761      */
 762     public JCIdent Super(Type t, TypeSymbol owner) {
 763         return Ident(new VarSymbol(FINAL, names._super, t, owner));
 764     }
 765 
 766     /**
 767      * Create a method invocation from a method tree and a list of
 768      * argument trees.
 769      */
 770     public JCMethodInvocation App(JCExpression meth, List&lt;JCExpression&gt; args) {
 771         return Apply(null, meth, args).setType(meth.type.getReturnType());
 772     }
 773 
 774     /**
 775      * Create a no-arg method invocation from a method tree
 776      */
 777     public JCMethodInvocation App(JCExpression meth) {
 778         return Apply(null, meth, List.nil()).setType(meth.type.getReturnType());
 779     }
 780 
 781     /** Create a method invocation from a method tree and a list of argument trees.
 782      */
 783     public JCExpression Create(Symbol ctor, List&lt;JCExpression&gt; args) {
 784         Type t = ctor.owner.erasure(types);
 785         JCNewClass newclass = NewClass(null, null, Type(t), args, null);
 786         newclass.constructor = ctor;
 787         newclass.setType(t);
 788         return newclass;
 789     }
 790 
 791     /** Create a tree representing given type.
 792      */
 793     public JCExpression Type(Type t) {
 794         if (t == null) return null;
 795         JCExpression tp;
 796         switch (t.getTag()) {
 797         case BYTE: case CHAR: case SHORT: case INT: case LONG: case FLOAT:
 798         case DOUBLE: case BOOLEAN: case VOID:
 799             tp = TypeIdent(t.getTag());
 800             break;
 801         case TYPEVAR:
 802             tp = Ident(t.tsym);
 803             break;
 804         case WILDCARD: {
 805             WildcardType a = ((WildcardType) t);
 806             tp = Wildcard(TypeBoundKind(a.kind), a.kind == BoundKind.UNBOUND ? null : Type(a.type));
 807             break;
 808         }
 809         case CLASS:
 810             switch (t.getKind()) {
 811             case UNION: {
 812                 UnionClassType tu = (UnionClassType)t;
 813                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 814                 for (Type ta : tu.getAlternativeTypes()) {
 815                     la.add(Type(ta));
 816                 }
 817                 tp = TypeUnion(la.toList());
 818                 break;
 819             }
 820             case INTERSECTION: {
 821                 IntersectionClassType it = (IntersectionClassType)t;
 822                 ListBuffer&lt;JCExpression&gt; la = new ListBuffer&lt;&gt;();
 823                 for (Type ta : it.getExplicitComponents()) {
 824                     la.add(Type(ta));
 825                 }
 826                 tp = TypeIntersection(la.toList());
 827                 break;
 828             }
 829             default: {
 830                 Type outer = t.getEnclosingType();
 831                 JCExpression clazz = outer.hasTag(CLASS) &amp;&amp; t.tsym.owner.kind == TYP
 832                         ? Select(Type(outer), t.tsym)
 833                         : QualIdent(t.tsym);
 834                 tp = t.getTypeArguments().isEmpty()
 835                         ? clazz
 836                         : TypeApply(clazz, Types(t.getTypeArguments()));
 837                 break;
 838             }
 839             }
 840             break;
 841         case ARRAY:
 842             tp = TypeArray(Type(types.elemtype(t)));
 843             break;
 844         case ERROR:
 845             tp = TypeIdent(ERROR);
 846             break;
 847         default:
 848             throw new AssertionError(&quot;unexpected type: &quot; + t);
 849         }
 850         return tp.setType(t);
 851     }
 852 
 853     /** Create a list of trees representing given list of types.
 854      */
 855     public List&lt;JCExpression&gt; Types(List&lt;Type&gt; ts) {
 856         ListBuffer&lt;JCExpression&gt; lb = new ListBuffer&lt;&gt;();
 857         for (List&lt;Type&gt; l = ts; l.nonEmpty(); l = l.tail)
 858             lb.append(Type(l.head));
 859         return lb.toList();
 860     }
 861 
 862     /** Create a variable definition from a variable symbol and an initializer
 863      *  expression.
 864      */
 865     public JCVariableDecl VarDef(VarSymbol v, JCExpression init) {
 866         return (JCVariableDecl)
 867             new JCVariableDecl(
 868                 Modifiers(v.flags(), Annotations(v.getRawAttributes())),
 869                 v.name,
 870                 Type(v.type),
 871                 init,
 872                 v).setPos(pos).setType(v.type);
 873     }
 874 
 875     /** Create annotation trees from annotations.
 876      */
 877     public List&lt;JCAnnotation&gt; Annotations(List&lt;Attribute.Compound&gt; attributes) {
 878         if (attributes == null) return List.nil();
 879         ListBuffer&lt;JCAnnotation&gt; result = new ListBuffer&lt;&gt;();
 880         for (List&lt;Attribute.Compound&gt; i = attributes; i.nonEmpty(); i=i.tail) {
 881             Attribute a = i.head;
 882             result.append(Annotation(a));
 883         }
 884         return result.toList();
 885     }
 886 
 887     public JCLiteral Literal(Object value) {
 888         JCLiteral result = null;
 889         if (value instanceof String) {
 890             result = Literal(CLASS, value).
 891                 setType(syms.stringType.constType(value));
 892         } else if (value instanceof Integer) {
 893             result = Literal(INT, value).
 894                 setType(syms.intType.constType(value));
 895         } else if (value instanceof Long) {
 896             result = Literal(LONG, value).
 897                 setType(syms.longType.constType(value));
 898         } else if (value instanceof Byte) {
 899             result = Literal(BYTE, value).
 900                 setType(syms.byteType.constType(value));
 901         } else if (value instanceof Character) {
 902             int v = (int) (((Character) value).toString().charAt(0));
 903             result = Literal(CHAR, v).
 904                 setType(syms.charType.constType(v));
 905         } else if (value instanceof Double) {
 906             result = Literal(DOUBLE, value).
 907                 setType(syms.doubleType.constType(value));
 908         } else if (value instanceof Float) {
 909             result = Literal(FLOAT, value).
 910                 setType(syms.floatType.constType(value));
 911         } else if (value instanceof Short) {
 912             result = Literal(SHORT, value).
 913                 setType(syms.shortType.constType(value));
 914         } else if (value instanceof Boolean) {
 915             int v = ((Boolean) value) ? 1 : 0;
 916             result = Literal(BOOLEAN, v).
 917                 setType(syms.booleanType.constType(v));
 918         } else {
 919             throw new AssertionError(value);
 920         }
 921         return result;
 922     }
 923 
 924     class AnnotationBuilder implements Attribute.Visitor {
 925         JCExpression result = null;
 926         public void visitConstant(Attribute.Constant v) {
 927             result = Literal(v.type.getTag(), v.value);
 928         }
 929         public void visitClass(Attribute.Class clazz) {
 930             result = ClassLiteral(clazz.classType).setType(syms.classType);
 931         }
 932         public void visitEnum(Attribute.Enum e) {
 933             result = QualIdent(e.value);
 934         }
 935         public void visitError(Attribute.Error e) {
 936             if (e instanceof UnresolvedClass) {
 937                 result = ClassLiteral(((UnresolvedClass) e).classType).setType(syms.classType);
 938             } else {
 939                 result = Erroneous();
 940             }
 941         }
 942         public void visitCompound(Attribute.Compound compound) {
 943             if (compound instanceof Attribute.TypeCompound) {
 944                 result = visitTypeCompoundInternal((Attribute.TypeCompound) compound);
 945             } else {
 946                 result = visitCompoundInternal(compound);
 947             }
 948         }
 949         public JCAnnotation visitCompoundInternal(Attribute.Compound compound) {
 950             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 951             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 952                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 953                 JCExpression valueTree = translate(pair.snd);
 954                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 955             }
 956             return Annotation(Type(compound.type), args.toList());
 957         }
 958         public JCAnnotation visitTypeCompoundInternal(Attribute.TypeCompound compound) {
 959             ListBuffer&lt;JCExpression&gt; args = new ListBuffer&lt;&gt;();
 960             for (List&lt;Pair&lt;Symbol.MethodSymbol,Attribute&gt;&gt; values = compound.values; values.nonEmpty(); values=values.tail) {
 961                 Pair&lt;MethodSymbol,Attribute&gt; pair = values.head;
 962                 JCExpression valueTree = translate(pair.snd);
 963                 args.append(Assign(Ident(pair.fst), valueTree).setType(valueTree.type));
 964             }
 965             return TypeAnnotation(Type(compound.type), args.toList());
 966         }
 967         public void visitArray(Attribute.Array array) {
 968             ListBuffer&lt;JCExpression&gt; elems = new ListBuffer&lt;&gt;();
 969             for (int i = 0; i &lt; array.values.length; i++)
 970                 elems.append(translate(array.values[i]));
 971             result = NewArray(null, List.nil(), elems.toList()).setType(array.type);
 972         }
 973         JCExpression translate(Attribute a) {
 974             a.accept(this);
 975             return result;
 976         }
 977         JCAnnotation translate(Attribute.Compound a) {
 978             return visitCompoundInternal(a);
 979         }
 980         JCAnnotation translate(Attribute.TypeCompound a) {
 981             return visitTypeCompoundInternal(a);
 982         }
 983     }
 984 
 985     AnnotationBuilder annotationBuilder = new AnnotationBuilder();
 986 
 987     /** Create an annotation tree from an attribute.
 988      */
 989     public JCAnnotation Annotation(Attribute a) {
 990         return annotationBuilder.translate((Attribute.Compound)a);
 991     }
 992 
 993     public JCAnnotation TypeAnnotation(Attribute a) {
 994         return annotationBuilder.translate((Attribute.TypeCompound) a);
 995     }
 996 
 997     /** Create a method definition from a method symbol and a method body.
 998      */
 999     public JCMethodDecl MethodDef(MethodSymbol m, JCBlock body) {
1000         return MethodDef(m, m.type, body);
1001     }
1002 
1003     /** Create a method definition from a method symbol, method type
1004      *  and a method body.
1005      */
1006     public JCMethodDecl MethodDef(MethodSymbol m, Type mtype, JCBlock body) {
1007         return (JCMethodDecl)
1008             new JCMethodDecl(
1009                 Modifiers(m.flags(), Annotations(m.getRawAttributes())),
1010                 m.name,
1011                 Type(mtype.getReturnType()),
1012                 TypeParams(mtype.getTypeArguments()),
1013                 null, // receiver type
1014                 Params(mtype.getParameterTypes(), m),
1015                 Types(mtype.getThrownTypes()),
1016                 body,
1017                 null,
1018                 m).setPos(pos).setType(mtype);
1019     }
1020 
1021     /** Create a type parameter tree from its name and type.
1022      */
1023     public JCTypeParameter TypeParam(Name name, TypeVar tvar) {
1024         return (JCTypeParameter)
1025             TypeParameter(name, Types(types.getBounds(tvar))).setPos(pos).setType(tvar);
1026     }
1027 
1028     /** Create a list of type parameter trees from a list of type variables.
1029      */
1030     public List&lt;JCTypeParameter&gt; TypeParams(List&lt;Type&gt; typarams) {
1031         ListBuffer&lt;JCTypeParameter&gt; tparams = new ListBuffer&lt;&gt;();
1032         for (List&lt;Type&gt; l = typarams; l.nonEmpty(); l = l.tail)
1033             tparams.append(TypeParam(l.head.tsym.name, (TypeVar)l.head));
1034         return tparams.toList();
1035     }
1036 
1037     /** Create a value parameter tree from its name, type, and owner.
1038      */
1039     public JCVariableDecl Param(Name name, Type argtype, Symbol owner) {
1040         return VarDef(new VarSymbol(PARAMETER, name, argtype, owner), null);
1041     }
1042 
1043     /** Create a a list of value parameter trees x0, ..., xn from a list of
1044      *  their types and an their owner.
1045      */
1046     public List&lt;JCVariableDecl&gt; Params(List&lt;Type&gt; argtypes, Symbol owner) {
1047         ListBuffer&lt;JCVariableDecl&gt; params = new ListBuffer&lt;&gt;();
1048         MethodSymbol mth = (owner.kind == MTH) ? ((MethodSymbol)owner) : null;
1049         if (mth != null &amp;&amp; mth.params != null &amp;&amp; argtypes.length() == mth.params.length()) {
1050             for (VarSymbol param : ((MethodSymbol)owner).params)
1051                 params.append(VarDef(param, null));
1052         } else {
1053             int i = 0;
1054             for (List&lt;Type&gt; l = argtypes; l.nonEmpty(); l = l.tail)
1055                 params.append(Param(paramName(i++), l.head, owner));
1056         }
1057         return params.toList();
1058     }
1059 
1060     /** Wrap a method invocation in an expression statement or return statement,
1061      *  depending on whether the method invocation expression&#39;s type is void.
1062      */
1063     public JCStatement Call(JCExpression apply) {
1064         return apply.type.hasTag(VOID) ? Exec(apply) : Return(apply);
1065     }
1066 
1067     /** Construct an assignment from a variable symbol and a right hand side.
1068      */
1069     public JCStatement Assignment(Symbol v, JCExpression rhs) {
1070         return Exec(Assign(Ident(v), rhs).setType(v.type));
1071     }
1072 
1073     /** Construct an index expression from a variable and an expression.
1074      */
1075     public JCArrayAccess Indexed(Symbol v, JCExpression index) {
1076         JCArrayAccess tree = new JCArrayAccess(QualIdent(v), index);
1077         tree.type = ((ArrayType)v.type).elemtype;
1078         return tree;
1079     }
1080 
1081     /** Make an attributed type cast expression.
1082      */
1083     public JCTypeCast TypeCast(Type type, JCExpression expr) {
1084         return (JCTypeCast)TypeCast(Type(type), expr).setType(type);
1085     }
1086 
1087 /* ***************************************************************************
1088  * Helper methods.
1089  ****************************************************************************/
1090 
1091     /** Can given symbol be referred to in unqualified form?
1092      */
1093     boolean isUnqualifiable(Symbol sym) {
1094         if (sym.name == names.empty ||
1095             sym.owner == null ||
1096             sym.owner == syms.rootPackage ||
1097             sym.owner.kind == MTH || sym.owner.kind == VAR) {
1098             return true;
1099         } else if (sym.kind == TYP &amp;&amp; toplevel != null) {
1100             Iterator&lt;Symbol&gt; it = toplevel.namedImportScope.getSymbolsByName(sym.name).iterator();
1101             if (it.hasNext()) {
1102                 Symbol s = it.next();
1103                 return
1104                   s == sym &amp;&amp;
1105                   !it.hasNext();
1106             }
1107             it = toplevel.packge.members().getSymbolsByName(sym.name).iterator();
1108             if (it.hasNext()) {
1109                 Symbol s = it.next();
1110                 return
1111                   s == sym &amp;&amp;
1112                   !it.hasNext();
1113             }
1114             it = toplevel.starImportScope.getSymbolsByName(sym.name).iterator();
1115             if (it.hasNext()) {
1116                 Symbol s = it.next();
1117                 return
1118                   s == sym &amp;&amp;
1119                   !it.hasNext();
1120             }
1121         }
1122         return false;
1123     }
1124 
1125     /** The name of synthetic parameter number `i&#39;.
1126      */
1127     public Name paramName(int i)   { return names.fromString(&quot;x&quot; + i); }
1128 
1129     /** The name of synthetic type parameter number `i&#39;.
1130      */
1131     public Name typaramName(int i) { return names.fromString(&quot;A&quot; + i); }
1132 }
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
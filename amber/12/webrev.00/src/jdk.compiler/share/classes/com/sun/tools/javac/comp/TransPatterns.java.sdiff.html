<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeDiffer.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;
 30 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;
 31 import com.sun.tools.javac.code.Symbol;
 32 import com.sun.tools.javac.code.Symbol.BindingSymbol;

 33 import com.sun.tools.javac.code.Symbol.VarSymbol;
 34 import com.sun.tools.javac.code.Symtab;
 35 import com.sun.tools.javac.code.Types;
 36 import com.sun.tools.javac.tree.JCTree.JCAssign;
 37 import com.sun.tools.javac.tree.JCTree.JCBinary;
 38 import com.sun.tools.javac.tree.JCTree.JCConditional;
 39 import com.sun.tools.javac.tree.JCTree.JCExpression;
 40 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 41 import com.sun.tools.javac.tree.JCTree.JCIdent;
 42 import com.sun.tools.javac.tree.JCTree.JCIf;
 43 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 44 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 45 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 46 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 47 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 48 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 49 import com.sun.tools.javac.tree.JCTree.Tag;
 50 import com.sun.tools.javac.tree.TreeMaker;
 51 import com.sun.tools.javac.tree.TreeTranslator;
 52 import com.sun.tools.javac.util.Assert;
 53 import com.sun.tools.javac.util.Context;
 54 import com.sun.tools.javac.util.ListBuffer;
 55 import com.sun.tools.javac.util.Log;
 56 import com.sun.tools.javac.util.Names;
 57 import com.sun.tools.javac.util.Options;
 58 
 59 import java.util.Map;
 60 import java.util.Map.Entry;

 61 
 62 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 63 import com.sun.tools.javac.code.Type;
 64 import com.sun.tools.javac.code.Type.ClassType;
 65 import com.sun.tools.javac.code.Type.MethodType;
 66 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
 67 import static com.sun.tools.javac.code.TypeTag.BOT;
 68 import com.sun.tools.javac.jvm.ClassFile;
 69 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 70 import com.sun.tools.javac.jvm.Target;
 71 import com.sun.tools.javac.tree.JCTree.GenericSwitch.SwitchKind;
 72 import com.sun.tools.javac.tree.JCTree.JCAssignOp;
 73 import com.sun.tools.javac.tree.JCTree;
 74 import com.sun.tools.javac.tree.JCTree.JCBlock;
 75 import com.sun.tools.javac.tree.JCTree.JCBreak;
 76 import com.sun.tools.javac.tree.JCTree.JCCase;
 77 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 78 import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;
 79 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 80 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 81 import com.sun.tools.javac.tree.JCTree.JCLiteralPattern;
 82 import com.sun.tools.javac.tree.JCTree.JCPattern;
 83 import com.sun.tools.javac.tree.JCTree.JCLambda;
 84 import com.sun.tools.javac.tree.JCTree.JCStatement;
 85 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 86 import com.sun.tools.javac.tree.JCTree.LetExpr;
 87 import static com.sun.tools.javac.tree.JCTree.Tag.SWITCH;
 88 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 89 import com.sun.tools.javac.util.List;
<span class="line-removed"> 90 import java.util.HashMap;</span>
 91 
 92 /**
 93  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 94  */
 95 public class TransPatterns extends TreeTranslator {
 96 
 97     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 98 
 99     public static TransPatterns instance(Context context) {
100         TransPatterns instance = context.get(transPatternsKey);
101         if (instance == null)
102             instance = new TransPatterns(context);
103         return instance;
104     }
105 
106     private final Symtab syms;
107     private final Types types;
108     private final Operators operators;
109     private final Log log;
110     private final ConstFold constFold;
</pre>
<hr />
<pre>
135             return expr;
136         }
137 
138         @Override
139         BindingContext pop() {
140             //do nothing
141             return this;
142         }
143 
144         @Override
145         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
146             return false;
147         }
148     };
149 
150     JCLabeledStatement pendingMatchLabel = null;
151 
152     boolean debugTransPatterns;
153 
154     private JCClassDecl currentClass;

155     private List&lt;JCTree&gt; condyableMethods = List.nil();
156     private MethodSymbol nullBootstrap; //hack: for ofConstant(null).
157     private JCMethodDecl nullBootstrapTree;
158     private MethodSymbol currentMethodSym = null;
159 
160     protected TransPatterns(Context context) {
161         context.put(transPatternsKey, this);
162         syms = Symtab.instance(context);
163         make = TreeMaker.instance(context);
164         types = Types.instance(context);
165         operators = Operators.instance(context);
166         log = Log.instance(context);
167         constFold = ConstFold.instance(context);
168         names = Names.instance(context);
169         rs = Resolve.instance(context);
170         target = Target.instance(context);
171         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
172     }
173 
174     @Override
175     public void visitTypeTest(JCInstanceOf tree) {
176         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN) || tree.pattern.hasTag(Tag.LITERALPATTERN)) {
177             //E instanceof T N

178             //=&gt;
179             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))
180             JCPattern patt = (JCPattern) tree.pattern;
181             ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
182             Type tempType = tree.expr.type.hasTag(BOT) ?
183                     syms.objectType
184                     : tree.expr.type;
185             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
<span class="line-modified">186                     names.fromString(&quot;&quot; + tree.pos + target.syntheticNameChar() + &quot;temp&quot;), //XXX: use a better name if possible: pattSym.name</span>
187                     tempType,
<span class="line-modified">188                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!</span>
189             JCExpression translatedExpr = translate(tree.expr);
190             statements.append(make.at(tree.pos).VarDef(temp, translatedExpr));
191             ListBuffer&lt;VarSymbol&gt; bindingVars = new ListBuffer&lt;&gt;();
192             Symbol.DynamicVarSymbol extractor = preparePatternExtractor(patt, tree.expr.type, bindingVars);
193             JCIdent qualifier = make.Ident(patt.type.tsym);
194             qualifier.sym = extractor;
195             qualifier.type = extractor.type;
196             VarSymbol e = new VarSymbol(0,
197                     names.fromString(&quot;$e$&quot; + tree.pos),
198                     syms.patternHandleType,
<span class="line-modified">199                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!</span>
200             statements.add(make.VarDef(e, qualifier));
<span class="line-modified">201             </span>
202             VarSymbol tryMatch = new VarSymbol(0,
203                     names.fromString(&quot;$tryMatch$&quot; + tree.pos),
204                     syms.methodHandleType,
<span class="line-modified">205                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!</span>
206             MethodSymbol tryMatchMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;tryMatch&quot;), List.nil(), List.nil());
207             statements.append(make.VarDef(tryMatch, makeApply(make.Ident(e), tryMatchMethod, List.nil())));
208             VarSymbol carrierMatch = new VarSymbol(0,
209                     names.fromString(&quot;$carrier$&quot; + tree.pos),
210                     syms.objectType,
<span class="line-modified">211                     currentMethodSym); //XXX: currentMethodSym may not exist!!!!</span>
212             MethodSymbol invokeMethodObject = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
213             statements.append(make.VarDef(carrierMatch, makeApply(make.Ident(tryMatch), invokeMethodObject, List.of(translate(tree.expr)))));
214             result = makeBinary(Tag.NE, make.Ident(carrierMatch), makeNull());
215 
216             int idx = 0;
217             for (VarSymbol bindingVar : bindingVars) {
218                 if (bindingVar != syms.lengthVar) {
219                     VarSymbol component = new VarSymbol(0,
220                             names.fromString(&quot;$component$&quot; + tree.pos + &quot;$&quot; + idx),
221                             syms.methodHandleType,
<span class="line-modified">222                             currentMethodSym); //XXX: currentMethodSym may not exist!!!!</span>
223                     MethodSymbol componentMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;component&quot;), List.of(syms.intType), List.nil());
224                     statements.append(make.VarDef(component, makeApply(make.Ident(e), componentMethod, List.of(make.Literal(idx)))));
225                     Type componentType = types.erasure(bindingVar.type.baseType());
226                     JCTree oldNextTree = env.next.tree;
227                     JCTree oldTree = env.tree;
228                     MethodSymbol invokeMethodForComponent;
229                     try {
230                         env.next.tree = make.TypeCast(componentType, (JCExpression) (env.tree = make.Erroneous()));
231                         invokeMethodForComponent = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
232                     } finally {
233                         env.next.tree = oldNextTree;
234                         env.tree = oldTree;
235                     }
236                     Type castTargetType = bindingVar.erasure(types);
237                     JCAssign bindingInit = (JCAssign)make.at(tree.pos).Assign(
238                             make.Ident(bindingVar), convert(makeApply(make.Ident(component), invokeMethodForComponent, List.of(make.Ident(carrierMatch))), castTargetType)).setType(bindingVar.erasure(types));
239                     JCExpression assignBoolExpr = make.at(tree.pos).LetExpr(List.of(make.Exec(bindingInit)), make.Literal(true)).setType(syms.booleanType);
240                     result = makeBinary(Tag.AND, (JCExpression)result, assignBoolExpr);
241                 }
242                 idx++;
243             }
244             result = make.at(tree.pos).LetExpr(statements.toList(), (JCExpression)result).setType(syms.booleanType);
245             ((LetExpr) result).needsCond = true;
246         } else {
247             super.visitTypeTest(tree);
248         }
249     }
<span class="line-modified">250     </span>
251     private Symbol.DynamicVarSymbol preparePatternExtractor(JCPattern patt, Type target, ListBuffer&lt;VarSymbol&gt; bindingVars) {
252         if (target == syms.botType) {
253             target = syms.objectType;
254         }
255         if (patt.hasTag(Tag.BINDINGPATTERN)) {
256             Type tempType = patt.type.hasTag(BOT) ?
257                     syms.objectType
258                     : patt.type;
259             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
260                                                               List.of(tempType),
261                                                               syms.classType.tsym));
262 
263             if (!tempType.isPrimitive()) {
264                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
265                                                                      List.of(target),
266                                                                      syms.classType.tsym));
267             }
268 
269             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
270                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
271 
272             VarSymbol binding = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
<span class="line-modified">273             </span>
274             if (binding != null) {
275                 bindingVars.append(binding);
276             }
277 
278             if (tempType.isPrimitive()) {
279                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
280             } else {
281                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
282             }
283         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {



284             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
285             Type tempType = patt.type.hasTag(BOT) ?
286                     syms.objectType
287                     : patt.type;
288             Type indyType = syms.objectType;
289             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
290                                                 syms.stringType,
291                                                 new ClassType(syms.classType.getEnclosingType(),
292                                                               List.of(syms.patternHandleType),
293                                                               syms.classType.tsym),
294                                                 new ClassType(syms.classType.getEnclosingType(),
295                                                               List.of(tempType),
296                                                               syms.classType.tsym),
297                                                 syms.methodTypeType,
298                                                 syms.stringType,
299                                                 syms.intType);
<span class="line-modified">300             </span>
301             Symbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
302                     names.fromString(&quot;ofNamed&quot;), bsm_staticArgs, List.nil());
303 
304             Symbol.DynamicVarSymbol outter = new Symbol.DynamicVarSymbol(names.fromString(&quot;ofNamed&quot;),
305                     syms.noSymbol,
306                     new Symbol.MethodHandleSymbol(ofType),
307                     indyType,
308                     new LoadableConstant[] {(ClassType) tempType,
309                                             new MethodType(dpatt.innerTypes, syms.voidType, List.nil(), syms.methodClass),
310                                             LoadableConstant.String(dpatt.extractorResolver.name.toString()),
311                                             LoadableConstant.Int(ClassFile.REF_newInvokeSpecial)});
312 
313             DynamicVarSymbol[] params = new DynamicVarSymbol[((JCDeconstructionPattern) patt).getNestedPatterns().size() + 1];
314             params[0] = outter;
315             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
316             ListBuffer&lt;VarSymbol&gt;[] nestedBindings = new ListBuffer[((JCDeconstructionPattern) patt).getNestedPatterns().size()];
317 
318             for (int i = 0; i &lt; ((JCDeconstructionPattern) patt).getNestedPatterns().size(); i++) {
319                 JCPattern nested = ((JCDeconstructionPattern) patt).getNestedPatterns().get(i);
320                 params[i + 1] = preparePatternExtractor(nested, nested.type, nestedBindings[i] = new ListBuffer&lt;&gt;());
321                 if (nested.hasTag(Tag.BINDINGPATTERN)) {
322                     bindingVars.appendList(nestedBindings[i].toList());
323                     nestedBindings[i].clear();
324                 } else {
325                     bindingVars.append(syms.lengthVar);
326                 }
327             }
<span class="line-modified">328             </span>
329             for (ListBuffer&lt;VarSymbol&gt; nested : nestedBindings) {
330                 if (nested.isEmpty())
331                     continue;
332                 bindingVars.appendList(nested.toList());
333             }
334 
335             List&lt;Type&gt; bsm_staticArgsNested = List.of(syms.patternHandleType,
336                                                       types.makeArrayType(syms.patternHandleType));
337 
338             MethodSymbol ofNested = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
339                     names.fromString(&quot;nested&quot;), bsm_staticArgsNested, List.nil());
<span class="line-modified">340             </span>
341             return makeCondyable(patt.pos(), ofNested, params);
342         } else if (patt.hasTag(Tag.ANYPATTERN)) {
343             Type tempType = patt.type.hasTag(BOT) ?
344                     syms.objectType
345                     : patt.type;
346             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
347                                                               List.of(tempType),
348                                                               syms.classType.tsym));
<span class="line-modified">349             </span>
350             if (!tempType.isPrimitive()) {
351                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
352                                                                      List.of(target),
353                                                                      syms.classType.tsym));
354             }
355 
356             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
357                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
358 
359             if (tempType.isPrimitive()) {
360                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
361             } else {
362                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
363             }
364         } else if (patt.hasTag(Tag.LITERALPATTERN)) {
365             JCLiteralPattern lpatt = (JCLiteralPattern) patt;
366             boolean adapt = types.boxedTypeOrType(target) == target;
367             List&lt;Type&gt; bsm_staticArgs = List.of(syms.objectType);
<span class="line-modified">368             </span>
369             if (adapt) {
370                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
371                                                                      List.of(target),
372                                                                      syms.classType.tsym));
373             }
374 
375             MethodSymbol ofConstant = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
376                     names.fromString(&quot;ofConstant&quot;), bsm_staticArgs, List.nil());
377 
378             LoadableConstant lc;
379             Object constValue = lpatt.value.type.constValue();
380             if (constValue instanceof Double) {
381                 lc = LoadableConstant.Double((Double) constValue);
382             } else if (constValue instanceof Float) {
383                 lc = LoadableConstant.Float((Float) constValue);
384             } else  if (constValue instanceof Integer) {
385                 lc = LoadableConstant.Int((Integer) constValue);
386             } else if (constValue instanceof Long) {
387                 lc = LoadableConstant.Long((Long) constValue);
388             } else if (constValue instanceof String) {
</pre>
<hr />
<pre>
498         acc.type = method.type;
499         return make.Apply(List.nil(), acc, params).setType(acc.type.getReturnType());
500     }
501 
502     //from Lower:
503     /** Make an attributed tree representing a literal. This will be an
504      *  Ident node in the case of boolean literals, a Literal node in all
505      *  other cases.
506      *  @param type       The literal&#39;s type.
507      *  @param value      The literal&#39;s value.
508      */
509     JCExpression makeLit(Type type, Object value) {
510         return make.Literal(type.getTag(), value).setType(type.constType(value));
511     }
512 
513     /** Make an attributed tree representing null.
514      */
515     JCExpression makeNull() {
516         return makeLit(syms.botType, null);
517     }
<span class="line-modified">518     </span>
519     /** Make an attributed assignop expression.
520      *  @param optag    The operators tree tag.
521      *  @param lhs      The operator&#39;s left argument.
522      *  @param rhs      The operator&#39;s right argument.
523      */
524     JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
525         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
526         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
527         tree.type = lhs.type;
528         return tree;
529     }
<span class="line-modified">530     </span>
531 //    JCNewArray makeArray(Type type, JCExpression... elements) {
532 //        JCNewArray newArray = make.NewArray(make.Type(types.erasure(type)),
533 //                                          List.nil(),
534 //                                          List.from(elements));
535 //        newArray.type = types.makeArrayType(newArray.elemtype.type);
536 //        return newArray;
537 //    }
538 
539     @Override
540     public void visitBinary(JCBinary tree) {
541         bindingContext = new BasicBindingContext();
542         try {
543             super.visitBinary(tree);
544             result = bindingContext.decorateExpression(tree);
545         } finally {
546             bindingContext.pop();
547         }
548     }
549 
550     @Override
</pre>
<hr />
<pre>
718             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
719                 //{
720                 //    if (E instanceof T N) {
721                 //        return ;
722                 //    }
723                 //    //use of N:
724                 //}
725                 //=&gt;
726                 //{
727                 //    T N;
728                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
729                 //        return ;
730                 //    }
731                 //    //use of N:
732                 //}
733                 hoistedVarMap.put(binding, var.sym);
734                 statements.append(var);
735                 return true;
736             }
737         };

738         try {





739             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
740                 statements.append(translate(l.head));
741             }
742 
743             tree.stats = statements.toList();
744             result = tree;
745         } finally {
746             bindingContext.pop();

747         }
748     }
749 
750     @Override
751     public void visitLambda(JCLambda tree) {
752         BindingContext prevContent = bindingContext;
753         try {
754             bindingContext = new BindingDeclarationFenceBindingContext();
755             super.visitLambda(tree);
756         } finally {
757             bindingContext = prevContent;
758         }
759     }
760 
761     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
762         try {
763             this.make = make;
764             this.env = env;
765             translate(cdef);
766         } finally {
</pre>
<hr />
<pre>
799         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
800         result.type = target;
801         return result;
802     }
803 
804     abstract class BindingContext {
805         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
806         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
807         abstract JCStatement decorateStatement(JCStatement stat);
808         abstract JCExpression decorateExpression(JCExpression expr);
809         abstract BindingContext pop();
810         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
811     }
812 
813     class BasicBindingContext extends BindingContext {
814         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
815         BindingContext parent;
816 
817         public BasicBindingContext() {
818             this.parent = bindingContext;
<span class="line-modified">819             this.hoistedVarMap = new HashMap&lt;&gt;();</span>
820         }
821 
822         @Override
823         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
824             VarSymbol res = parent.bindingDeclared(varSymbol);
825             if (res == null) {
<span class="line-modified">826                 res = new VarSymbol(varSymbol.flags() &amp; ~Flags.MATCH_BINDING, varSymbol.name, varSymbol.type, varSymbol.owner);</span>
827                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
828                 hoistedVarMap.put(varSymbol, res);
829             }
830             return res;
831         }
832 
833         @Override
834         VarSymbol getBindingFor(BindingSymbol varSymbol) {
835             VarSymbol res = parent.getBindingFor(varSymbol);
836             if (res != null) {
837                 return res;
838             }
839             return hoistedVarMap.entrySet().stream()
840                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
841                     .findFirst()
842                     .map(e -&gt; e.getValue()).orElse(null);
843         }
844 
845         @Override
846         JCStatement decorateStatement(JCStatement stat) {
</pre>
</td>
<td>
<hr />
<pre>
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package com.sun.tools.javac.comp;
 27 
 28 import com.sun.tools.javac.code.Flags;
 29 import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;
 30 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;
 31 import com.sun.tools.javac.code.Symbol;
 32 import com.sun.tools.javac.code.Symbol.BindingSymbol;
<span class="line-added"> 33 import com.sun.tools.javac.code.Symbol.ClassSymbol;</span>
 34 import com.sun.tools.javac.code.Symbol.VarSymbol;
 35 import com.sun.tools.javac.code.Symtab;
 36 import com.sun.tools.javac.code.Types;
 37 import com.sun.tools.javac.tree.JCTree.JCAssign;
 38 import com.sun.tools.javac.tree.JCTree.JCBinary;
 39 import com.sun.tools.javac.tree.JCTree.JCConditional;
 40 import com.sun.tools.javac.tree.JCTree.JCExpression;
 41 import com.sun.tools.javac.tree.JCTree.JCForLoop;
 42 import com.sun.tools.javac.tree.JCTree.JCIdent;
 43 import com.sun.tools.javac.tree.JCTree.JCIf;
 44 import com.sun.tools.javac.tree.JCTree.JCInstanceOf;
 45 import com.sun.tools.javac.tree.JCTree.JCLabeledStatement;
 46 import com.sun.tools.javac.tree.JCTree.JCMethodDecl;
 47 import com.sun.tools.javac.tree.JCTree.JCVariableDecl;
 48 import com.sun.tools.javac.tree.JCTree.JCBindingPattern;
 49 import com.sun.tools.javac.tree.JCTree.JCWhileLoop;
 50 import com.sun.tools.javac.tree.JCTree.Tag;
 51 import com.sun.tools.javac.tree.TreeMaker;
 52 import com.sun.tools.javac.tree.TreeTranslator;
 53 import com.sun.tools.javac.util.Assert;
 54 import com.sun.tools.javac.util.Context;
 55 import com.sun.tools.javac.util.ListBuffer;
 56 import com.sun.tools.javac.util.Log;
 57 import com.sun.tools.javac.util.Names;
 58 import com.sun.tools.javac.util.Options;
 59 
 60 import java.util.Map;
 61 import java.util.Map.Entry;
<span class="line-added"> 62 import java.util.LinkedHashMap;</span>
 63 
 64 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 65 import com.sun.tools.javac.code.Type;
 66 import com.sun.tools.javac.code.Type.ClassType;
 67 import com.sun.tools.javac.code.Type.MethodType;
 68 import static com.sun.tools.javac.code.TypeTag.BOOLEAN;
 69 import static com.sun.tools.javac.code.TypeTag.BOT;
 70 import com.sun.tools.javac.jvm.ClassFile;
 71 import com.sun.tools.javac.jvm.PoolConstant.LoadableConstant;
 72 import com.sun.tools.javac.jvm.Target;
 73 import com.sun.tools.javac.tree.JCTree.GenericSwitch.SwitchKind;
 74 import com.sun.tools.javac.tree.JCTree.JCAssignOp;
 75 import com.sun.tools.javac.tree.JCTree;
 76 import com.sun.tools.javac.tree.JCTree.JCBlock;
 77 import com.sun.tools.javac.tree.JCTree.JCBreak;
 78 import com.sun.tools.javac.tree.JCTree.JCCase;
 79 import com.sun.tools.javac.tree.JCTree.JCClassDecl;
 80 import com.sun.tools.javac.tree.JCTree.JCDeconstructionPattern;
 81 import com.sun.tools.javac.tree.JCTree.JCDoWhileLoop;
 82 import com.sun.tools.javac.tree.JCTree.JCFieldAccess;
 83 import com.sun.tools.javac.tree.JCTree.JCLiteralPattern;
 84 import com.sun.tools.javac.tree.JCTree.JCPattern;
 85 import com.sun.tools.javac.tree.JCTree.JCLambda;
 86 import com.sun.tools.javac.tree.JCTree.JCStatement;
 87 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 88 import com.sun.tools.javac.tree.JCTree.LetExpr;
 89 import static com.sun.tools.javac.tree.JCTree.Tag.SWITCH;
 90 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 91 import com.sun.tools.javac.util.List;

 92 
 93 /**
 94  * This pass translates pattern-matching constructs, such as instanceof &lt;pattern&gt;.
 95  */
 96 public class TransPatterns extends TreeTranslator {
 97 
 98     protected static final Context.Key&lt;TransPatterns&gt; transPatternsKey = new Context.Key&lt;&gt;();
 99 
100     public static TransPatterns instance(Context context) {
101         TransPatterns instance = context.get(transPatternsKey);
102         if (instance == null)
103             instance = new TransPatterns(context);
104         return instance;
105     }
106 
107     private final Symtab syms;
108     private final Types types;
109     private final Operators operators;
110     private final Log log;
111     private final ConstFold constFold;
</pre>
<hr />
<pre>
136             return expr;
137         }
138 
139         @Override
140         BindingContext pop() {
141             //do nothing
142             return this;
143         }
144 
145         @Override
146         boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
147             return false;
148         }
149     };
150 
151     JCLabeledStatement pendingMatchLabel = null;
152 
153     boolean debugTransPatterns;
154 
155     private JCClassDecl currentClass;
<span class="line-added">156     private Symbol currentOwnerSym = null;</span>
157     private List&lt;JCTree&gt; condyableMethods = List.nil();
158     private MethodSymbol nullBootstrap; //hack: for ofConstant(null).
159     private JCMethodDecl nullBootstrapTree;
160     private MethodSymbol currentMethodSym = null;
161 
162     protected TransPatterns(Context context) {
163         context.put(transPatternsKey, this);
164         syms = Symtab.instance(context);
165         make = TreeMaker.instance(context);
166         types = Types.instance(context);
167         operators = Operators.instance(context);
168         log = Log.instance(context);
169         constFold = ConstFold.instance(context);
170         names = Names.instance(context);
171         rs = Resolve.instance(context);
172         target = Target.instance(context);
173         debugTransPatterns = Options.instance(context).isSet(&quot;debug.patterns&quot;);
174     }
175 
176     @Override
177     public void visitTypeTest(JCInstanceOf tree) {
178         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN) || tree.pattern.hasTag(Tag.LITERALPATTERN)) {
179             //E instanceof T N
<span class="line-added">180             //E instanceof T(PATT1, PATT2, ...)</span>
181             //=&gt;
182             //(let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))
183             JCPattern patt = (JCPattern) tree.pattern;
184             ListBuffer&lt;JCStatement&gt; statements = new ListBuffer&lt;&gt;();
185             Type tempType = tree.expr.type.hasTag(BOT) ?
186                     syms.objectType
187                     : tree.expr.type;
188             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
<span class="line-modified">189                     names.fromString(target.syntheticNameChar() + &quot;e&quot; + target.syntheticNameChar()),</span>
190                     tempType,
<span class="line-modified">191                     currentOwnerSym);</span>
192             JCExpression translatedExpr = translate(tree.expr);
193             statements.append(make.at(tree.pos).VarDef(temp, translatedExpr));
194             ListBuffer&lt;VarSymbol&gt; bindingVars = new ListBuffer&lt;&gt;();
195             Symbol.DynamicVarSymbol extractor = preparePatternExtractor(patt, tree.expr.type, bindingVars);
196             JCIdent qualifier = make.Ident(patt.type.tsym);
197             qualifier.sym = extractor;
198             qualifier.type = extractor.type;
199             VarSymbol e = new VarSymbol(0,
200                     names.fromString(&quot;$e$&quot; + tree.pos),
201                     syms.patternHandleType,
<span class="line-modified">202                     currentOwnerSym);</span>
203             statements.add(make.VarDef(e, qualifier));
<span class="line-modified">204 </span>
205             VarSymbol tryMatch = new VarSymbol(0,
206                     names.fromString(&quot;$tryMatch$&quot; + tree.pos),
207                     syms.methodHandleType,
<span class="line-modified">208                     currentOwnerSym);</span>
209             MethodSymbol tryMatchMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;tryMatch&quot;), List.nil(), List.nil());
210             statements.append(make.VarDef(tryMatch, makeApply(make.Ident(e), tryMatchMethod, List.nil())));
211             VarSymbol carrierMatch = new VarSymbol(0,
212                     names.fromString(&quot;$carrier$&quot; + tree.pos),
213                     syms.objectType,
<span class="line-modified">214                     currentOwnerSym);</span>
215             MethodSymbol invokeMethodObject = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
216             statements.append(make.VarDef(carrierMatch, makeApply(make.Ident(tryMatch), invokeMethodObject, List.of(translate(tree.expr)))));
217             result = makeBinary(Tag.NE, make.Ident(carrierMatch), makeNull());
218 
219             int idx = 0;
220             for (VarSymbol bindingVar : bindingVars) {
221                 if (bindingVar != syms.lengthVar) {
222                     VarSymbol component = new VarSymbol(0,
223                             names.fromString(&quot;$component$&quot; + tree.pos + &quot;$&quot; + idx),
224                             syms.methodHandleType,
<span class="line-modified">225                             currentOwnerSym);</span>
226                     MethodSymbol componentMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString(&quot;component&quot;), List.of(syms.intType), List.nil());
227                     statements.append(make.VarDef(component, makeApply(make.Ident(e), componentMethod, List.of(make.Literal(idx)))));
228                     Type componentType = types.erasure(bindingVar.type.baseType());
229                     JCTree oldNextTree = env.next.tree;
230                     JCTree oldTree = env.tree;
231                     MethodSymbol invokeMethodForComponent;
232                     try {
233                         env.next.tree = make.TypeCast(componentType, (JCExpression) (env.tree = make.Erroneous()));
234                         invokeMethodForComponent = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString(&quot;invoke&quot;), List.of(syms.objectType), List.nil());
235                     } finally {
236                         env.next.tree = oldNextTree;
237                         env.tree = oldTree;
238                     }
239                     Type castTargetType = bindingVar.erasure(types);
240                     JCAssign bindingInit = (JCAssign)make.at(tree.pos).Assign(
241                             make.Ident(bindingVar), convert(makeApply(make.Ident(component), invokeMethodForComponent, List.of(make.Ident(carrierMatch))), castTargetType)).setType(bindingVar.erasure(types));
242                     JCExpression assignBoolExpr = make.at(tree.pos).LetExpr(List.of(make.Exec(bindingInit)), make.Literal(true)).setType(syms.booleanType);
243                     result = makeBinary(Tag.AND, (JCExpression)result, assignBoolExpr);
244                 }
245                 idx++;
246             }
247             result = make.at(tree.pos).LetExpr(statements.toList(), (JCExpression)result).setType(syms.booleanType);
248             ((LetExpr) result).needsCond = true;
249         } else {
250             super.visitTypeTest(tree);
251         }
252     }
<span class="line-modified">253 </span>
254     private Symbol.DynamicVarSymbol preparePatternExtractor(JCPattern patt, Type target, ListBuffer&lt;VarSymbol&gt; bindingVars) {
255         if (target == syms.botType) {
256             target = syms.objectType;
257         }
258         if (patt.hasTag(Tag.BINDINGPATTERN)) {
259             Type tempType = patt.type.hasTag(BOT) ?
260                     syms.objectType
261                     : patt.type;
262             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
263                                                               List.of(tempType),
264                                                               syms.classType.tsym));
265 
266             if (!tempType.isPrimitive()) {
267                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
268                                                                      List.of(target),
269                                                                      syms.classType.tsym));
270             }
271 
272             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
273                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
274 
275             VarSymbol binding = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
<span class="line-modified">276 </span>
277             if (binding != null) {
278                 bindingVars.append(binding);
279             }
280 
281             if (tempType.isPrimitive()) {
282                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
283             } else {
284                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
285             }
286         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
<span class="line-added">287             //type test already done, finish handling of deconstruction patterns (&quot;T(PATT1, PATT2, ...)&quot;)</span>
<span class="line-added">288             //=&gt;</span>
<span class="line-added">289             //&lt;PATT1-handling&gt; &amp;&amp; &lt;PATT2-handling&gt; &amp;&amp; ...</span>
290             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
291             Type tempType = patt.type.hasTag(BOT) ?
292                     syms.objectType
293                     : patt.type;
294             Type indyType = syms.objectType;
295             List&lt;Type&gt; bsm_staticArgs = List.of(syms.methodHandleLookupType,
296                                                 syms.stringType,
297                                                 new ClassType(syms.classType.getEnclosingType(),
298                                                               List.of(syms.patternHandleType),
299                                                               syms.classType.tsym),
300                                                 new ClassType(syms.classType.getEnclosingType(),
301                                                               List.of(tempType),
302                                                               syms.classType.tsym),
303                                                 syms.methodTypeType,
304                                                 syms.stringType,
305                                                 syms.intType);
<span class="line-modified">306 </span>
307             Symbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
308                     names.fromString(&quot;ofNamed&quot;), bsm_staticArgs, List.nil());
309 
310             Symbol.DynamicVarSymbol outter = new Symbol.DynamicVarSymbol(names.fromString(&quot;ofNamed&quot;),
311                     syms.noSymbol,
312                     new Symbol.MethodHandleSymbol(ofType),
313                     indyType,
314                     new LoadableConstant[] {(ClassType) tempType,
315                                             new MethodType(dpatt.innerTypes, syms.voidType, List.nil(), syms.methodClass),
316                                             LoadableConstant.String(dpatt.extractorResolver.name.toString()),
317                                             LoadableConstant.Int(ClassFile.REF_newInvokeSpecial)});
318 
319             DynamicVarSymbol[] params = new DynamicVarSymbol[((JCDeconstructionPattern) patt).getNestedPatterns().size() + 1];
320             params[0] = outter;
321             @SuppressWarnings({&quot;rawtypes&quot;, &quot;unchecked&quot;})
322             ListBuffer&lt;VarSymbol&gt;[] nestedBindings = new ListBuffer[((JCDeconstructionPattern) patt).getNestedPatterns().size()];
323 
324             for (int i = 0; i &lt; ((JCDeconstructionPattern) patt).getNestedPatterns().size(); i++) {
325                 JCPattern nested = ((JCDeconstructionPattern) patt).getNestedPatterns().get(i);
326                 params[i + 1] = preparePatternExtractor(nested, nested.type, nestedBindings[i] = new ListBuffer&lt;&gt;());
327                 if (nested.hasTag(Tag.BINDINGPATTERN)) {
328                     bindingVars.appendList(nestedBindings[i].toList());
329                     nestedBindings[i].clear();
330                 } else {
331                     bindingVars.append(syms.lengthVar);
332                 }
333             }
<span class="line-modified">334 </span>
335             for (ListBuffer&lt;VarSymbol&gt; nested : nestedBindings) {
336                 if (nested.isEmpty())
337                     continue;
338                 bindingVars.appendList(nested.toList());
339             }
340 
341             List&lt;Type&gt; bsm_staticArgsNested = List.of(syms.patternHandleType,
342                                                       types.makeArrayType(syms.patternHandleType));
343 
344             MethodSymbol ofNested = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
345                     names.fromString(&quot;nested&quot;), bsm_staticArgsNested, List.nil());
<span class="line-modified">346 </span>
347             return makeCondyable(patt.pos(), ofNested, params);
348         } else if (patt.hasTag(Tag.ANYPATTERN)) {
349             Type tempType = patt.type.hasTag(BOT) ?
350                     syms.objectType
351                     : patt.type;
352             List&lt;Type&gt; bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
353                                                               List.of(tempType),
354                                                               syms.classType.tsym));
<span class="line-modified">355 </span>
356             if (!tempType.isPrimitive()) {
357                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
358                                                                      List.of(target),
359                                                                      syms.classType.tsym));
360             }
361 
362             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
363                     names.fromString(&quot;ofType&quot;), bsm_staticArgs, List.nil());
364 
365             if (tempType.isPrimitive()) {
366                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
367             } else {
368                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
369             }
370         } else if (patt.hasTag(Tag.LITERALPATTERN)) {
371             JCLiteralPattern lpatt = (JCLiteralPattern) patt;
372             boolean adapt = types.boxedTypeOrType(target) == target;
373             List&lt;Type&gt; bsm_staticArgs = List.of(syms.objectType);
<span class="line-modified">374 </span>
375             if (adapt) {
376                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
377                                                                      List.of(target),
378                                                                      syms.classType.tsym));
379             }
380 
381             MethodSymbol ofConstant = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
382                     names.fromString(&quot;ofConstant&quot;), bsm_staticArgs, List.nil());
383 
384             LoadableConstant lc;
385             Object constValue = lpatt.value.type.constValue();
386             if (constValue instanceof Double) {
387                 lc = LoadableConstant.Double((Double) constValue);
388             } else if (constValue instanceof Float) {
389                 lc = LoadableConstant.Float((Float) constValue);
390             } else  if (constValue instanceof Integer) {
391                 lc = LoadableConstant.Int((Integer) constValue);
392             } else if (constValue instanceof Long) {
393                 lc = LoadableConstant.Long((Long) constValue);
394             } else if (constValue instanceof String) {
</pre>
<hr />
<pre>
504         acc.type = method.type;
505         return make.Apply(List.nil(), acc, params).setType(acc.type.getReturnType());
506     }
507 
508     //from Lower:
509     /** Make an attributed tree representing a literal. This will be an
510      *  Ident node in the case of boolean literals, a Literal node in all
511      *  other cases.
512      *  @param type       The literal&#39;s type.
513      *  @param value      The literal&#39;s value.
514      */
515     JCExpression makeLit(Type type, Object value) {
516         return make.Literal(type.getTag(), value).setType(type.constType(value));
517     }
518 
519     /** Make an attributed tree representing null.
520      */
521     JCExpression makeNull() {
522         return makeLit(syms.botType, null);
523     }
<span class="line-modified">524 </span>
525     /** Make an attributed assignop expression.
526      *  @param optag    The operators tree tag.
527      *  @param lhs      The operator&#39;s left argument.
528      *  @param rhs      The operator&#39;s right argument.
529      */
530     JCAssignOp makeAssignop(JCTree.Tag optag, JCTree lhs, JCTree rhs) {
531         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
532         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
533         tree.type = lhs.type;
534         return tree;
535     }
<span class="line-modified">536 </span>
537 //    JCNewArray makeArray(Type type, JCExpression... elements) {
538 //        JCNewArray newArray = make.NewArray(make.Type(types.erasure(type)),
539 //                                          List.nil(),
540 //                                          List.from(elements));
541 //        newArray.type = types.makeArrayType(newArray.elemtype.type);
542 //        return newArray;
543 //    }
544 
545     @Override
546     public void visitBinary(JCBinary tree) {
547         bindingContext = new BasicBindingContext();
548         try {
549             super.visitBinary(tree);
550             result = bindingContext.decorateExpression(tree);
551         } finally {
552             bindingContext.pop();
553         }
554     }
555 
556     @Override
</pre>
<hr />
<pre>
724             boolean tryPrepend(BindingSymbol binding, JCVariableDecl var) {
725                 //{
726                 //    if (E instanceof T N) {
727                 //        return ;
728                 //    }
729                 //    //use of N:
730                 //}
731                 //=&gt;
732                 //{
733                 //    T N;
734                 //    if ((let T&#39; N$temp = E; N$temp instanceof T &amp;&amp; (N = (T) N$temp == (T) N$temp))) {
735                 //        return ;
736                 //    }
737                 //    //use of N:
738                 //}
739                 hoistedVarMap.put(binding, var.sym);
740                 statements.append(var);
741                 return true;
742             }
743         };
<span class="line-added">744         Symbol prevOwnerSym = currentOwnerSym;</span>
745         try {
<span class="line-added">746             if (currentOwnerSym == null) {</span>
<span class="line-added">747                 currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,</span>
<span class="line-added">748                                  names.empty, null,</span>
<span class="line-added">749                                  currentClass.sym);</span>
<span class="line-added">750             }</span>
751             for (List&lt;JCStatement&gt; l = tree.stats; l.nonEmpty(); l = l.tail) {
752                 statements.append(translate(l.head));
753             }
754 
755             tree.stats = statements.toList();
756             result = tree;
757         } finally {
758             bindingContext.pop();
<span class="line-added">759             currentOwnerSym = prevOwnerSym;</span>
760         }
761     }
762 
763     @Override
764     public void visitLambda(JCLambda tree) {
765         BindingContext prevContent = bindingContext;
766         try {
767             bindingContext = new BindingDeclarationFenceBindingContext();
768             super.visitLambda(tree);
769         } finally {
770             bindingContext = prevContent;
771         }
772     }
773 
774     public JCTree translateTopLevelClass(Env&lt;AttrContext&gt; env, JCTree cdef, TreeMaker make) {
775         try {
776             this.make = make;
777             this.env = env;
778             translate(cdef);
779         } finally {
</pre>
<hr />
<pre>
812         JCExpression result = make.at(expr.pos()).TypeCast(make.Type(target), expr);
813         result.type = target;
814         return result;
815     }
816 
817     abstract class BindingContext {
818         abstract VarSymbol bindingDeclared(BindingSymbol varSymbol);
819         abstract VarSymbol getBindingFor(BindingSymbol varSymbol);
820         abstract JCStatement decorateStatement(JCStatement stat);
821         abstract JCExpression decorateExpression(JCExpression expr);
822         abstract BindingContext pop();
823         abstract boolean tryPrepend(BindingSymbol binding, JCVariableDecl var);
824     }
825 
826     class BasicBindingContext extends BindingContext {
827         Map&lt;BindingSymbol, VarSymbol&gt; hoistedVarMap;
828         BindingContext parent;
829 
830         public BasicBindingContext() {
831             this.parent = bindingContext;
<span class="line-modified">832             this.hoistedVarMap = new LinkedHashMap&lt;&gt;();</span>
833         }
834 
835         @Override
836         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
837             VarSymbol res = parent.bindingDeclared(varSymbol);
838             if (res == null) {
<span class="line-modified">839                 res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, varSymbol.owner);</span>
840                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
841                 hoistedVarMap.put(varSymbol, res);
842             }
843             return res;
844         }
845 
846         @Override
847         VarSymbol getBindingFor(BindingSymbol varSymbol) {
848             VarSymbol res = parent.getBindingFor(varSymbol);
849             if (res != null) {
850                 return res;
851             }
852             return hoistedVarMap.entrySet().stream()
853                     .filter(e -&gt; e.getKey().isAliasFor(varSymbol))
854                     .findFirst()
855                     .map(e -&gt; e.getValue()).orElse(null);
856         }
857 
858         @Override
859         JCStatement decorateStatement(JCStatement stat) {
</pre>
</td>
</tr>
</table>
<center><a href="Check.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="TreeDiffer.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
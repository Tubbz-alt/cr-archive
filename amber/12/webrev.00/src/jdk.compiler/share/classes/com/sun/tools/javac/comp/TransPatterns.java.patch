diff a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java
--- a/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java
+++ b/src/jdk.compiler/share/classes/com/sun/tools/javac/comp/TransPatterns.java
@@ -28,10 +28,11 @@
 import com.sun.tools.javac.code.Flags;
 import com.sun.tools.javac.code.Symbol.DynamicVarSymbol;
 import com.sun.tools.javac.code.Symbol.MethodHandleSymbol;
 import com.sun.tools.javac.code.Symbol;
 import com.sun.tools.javac.code.Symbol.BindingSymbol;
+import com.sun.tools.javac.code.Symbol.ClassSymbol;
 import com.sun.tools.javac.code.Symbol.VarSymbol;
 import com.sun.tools.javac.code.Symtab;
 import com.sun.tools.javac.code.Types;
 import com.sun.tools.javac.tree.JCTree.JCAssign;
 import com.sun.tools.javac.tree.JCTree.JCBinary;
@@ -56,10 +57,11 @@
 import com.sun.tools.javac.util.Names;
 import com.sun.tools.javac.util.Options;
 
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.LinkedHashMap;
 
 import com.sun.tools.javac.code.Symbol.MethodSymbol;
 import com.sun.tools.javac.code.Type;
 import com.sun.tools.javac.code.Type.ClassType;
 import com.sun.tools.javac.code.Type.MethodType;
@@ -85,11 +87,10 @@
 import com.sun.tools.javac.tree.JCTree.JCSwitch;
 import com.sun.tools.javac.tree.JCTree.LetExpr;
 import static com.sun.tools.javac.tree.JCTree.Tag.SWITCH;
 import com.sun.tools.javac.util.JCDiagnostic.DiagnosticPosition;
 import com.sun.tools.javac.util.List;
-import java.util.HashMap;
 
 /**
  * This pass translates pattern-matching constructs, such as instanceof <pattern>.
  */
 public class TransPatterns extends TreeTranslator {
@@ -150,10 +151,11 @@
     JCLabeledStatement pendingMatchLabel = null;
 
     boolean debugTransPatterns;
 
     private JCClassDecl currentClass;
+    private Symbol currentOwnerSym = null;
     private List<JCTree> condyableMethods = List.nil();
     private MethodSymbol nullBootstrap; //hack: for ofConstant(null).
     private JCMethodDecl nullBootstrapTree;
     private MethodSymbol currentMethodSym = null;
 
@@ -173,55 +175,56 @@
 
     @Override
     public void visitTypeTest(JCInstanceOf tree) {
         if (tree.pattern.hasTag(Tag.BINDINGPATTERN) || tree.pattern.hasTag(Tag.DECONSTRUCTIONPATTERN) || tree.pattern.hasTag(Tag.LITERALPATTERN)) {
             //E instanceof T N
+            //E instanceof T(PATT1, PATT2, ...)
             //=>
             //(let T' N$temp = E; N$temp instanceof T && (N = (T) N$temp == (T) N$temp))
             JCPattern patt = (JCPattern) tree.pattern;
             ListBuffer<JCStatement> statements = new ListBuffer<>();
             Type tempType = tree.expr.type.hasTag(BOT) ?
                     syms.objectType
                     : tree.expr.type;
             VarSymbol temp = new VarSymbol(Flags.SYNTHETIC,
-                    names.fromString("" + tree.pos + target.syntheticNameChar() + "temp"), //XXX: use a better name if possible: pattSym.name
+                    names.fromString(target.syntheticNameChar() + "e" + target.syntheticNameChar()),
                     tempType,
-                    currentMethodSym); //XXX: currentMethodSym may not exist!!!!
+                    currentOwnerSym);
             JCExpression translatedExpr = translate(tree.expr);
             statements.append(make.at(tree.pos).VarDef(temp, translatedExpr));
             ListBuffer<VarSymbol> bindingVars = new ListBuffer<>();
             Symbol.DynamicVarSymbol extractor = preparePatternExtractor(patt, tree.expr.type, bindingVars);
             JCIdent qualifier = make.Ident(patt.type.tsym);
             qualifier.sym = extractor;
             qualifier.type = extractor.type;
             VarSymbol e = new VarSymbol(0,
                     names.fromString("$e$" + tree.pos),
                     syms.patternHandleType,
-                    currentMethodSym); //XXX: currentMethodSym may not exist!!!!
+                    currentOwnerSym);
             statements.add(make.VarDef(e, qualifier));
-            
+
             VarSymbol tryMatch = new VarSymbol(0,
                     names.fromString("$tryMatch$" + tree.pos),
                     syms.methodHandleType,
-                    currentMethodSym); //XXX: currentMethodSym may not exist!!!!
+                    currentOwnerSym);
             MethodSymbol tryMatchMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString("tryMatch"), List.nil(), List.nil());
             statements.append(make.VarDef(tryMatch, makeApply(make.Ident(e), tryMatchMethod, List.nil())));
             VarSymbol carrierMatch = new VarSymbol(0,
                     names.fromString("$carrier$" + tree.pos),
                     syms.objectType,
-                    currentMethodSym); //XXX: currentMethodSym may not exist!!!!
+                    currentOwnerSym);
             MethodSymbol invokeMethodObject = rs.resolveInternalMethod(patt.pos(), env, syms.methodHandleType, names.fromString("invoke"), List.of(syms.objectType), List.nil());
             statements.append(make.VarDef(carrierMatch, makeApply(make.Ident(tryMatch), invokeMethodObject, List.of(translate(tree.expr)))));
             result = makeBinary(Tag.NE, make.Ident(carrierMatch), makeNull());
 
             int idx = 0;
             for (VarSymbol bindingVar : bindingVars) {
                 if (bindingVar != syms.lengthVar) {
                     VarSymbol component = new VarSymbol(0,
                             names.fromString("$component$" + tree.pos + "$" + idx),
                             syms.methodHandleType,
-                            currentMethodSym); //XXX: currentMethodSym may not exist!!!!
+                            currentOwnerSym);
                     MethodSymbol componentMethod = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandleType, names.fromString("component"), List.of(syms.intType), List.nil());
                     statements.append(make.VarDef(component, makeApply(make.Ident(e), componentMethod, List.of(make.Literal(idx)))));
                     Type componentType = types.erasure(bindingVar.type.baseType());
                     JCTree oldNextTree = env.next.tree;
                     JCTree oldTree = env.tree;
@@ -245,11 +248,11 @@
             ((LetExpr) result).needsCond = true;
         } else {
             super.visitTypeTest(tree);
         }
     }
-    
+
     private Symbol.DynamicVarSymbol preparePatternExtractor(JCPattern patt, Type target, ListBuffer<VarSymbol> bindingVars) {
         if (target == syms.botType) {
             target = syms.objectType;
         }
         if (patt.hasTag(Tag.BINDINGPATTERN)) {
@@ -268,21 +271,24 @@
 
             MethodSymbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
                     names.fromString("ofType"), bsm_staticArgs, List.nil());
 
             VarSymbol binding = bindingContext.bindingDeclared(((JCBindingPattern) patt).symbol);
-            
+
             if (binding != null) {
                 bindingVars.append(binding);
             }
 
             if (tempType.isPrimitive()) {
                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {loadPrimitiveClass(patt.pos(), tempType)});
             } else {
                 return makeCondyable(patt.pos(), ofType, new LoadableConstant[] {(ClassType) tempType, (ClassType) target});
             }
         } else if (patt.hasTag(Tag.DECONSTRUCTIONPATTERN)) {
+            //type test already done, finish handling of deconstruction patterns ("T(PATT1, PATT2, ...)")
+            //=>
+            //<PATT1-handling> && <PATT2-handling> && ...
             JCDeconstructionPattern dpatt = (JCDeconstructionPattern) patt;
             Type tempType = patt.type.hasTag(BOT) ?
                     syms.objectType
                     : patt.type;
             Type indyType = syms.objectType;
@@ -295,11 +301,11 @@
                                                               List.of(tempType),
                                                               syms.classType.tsym),
                                                 syms.methodTypeType,
                                                 syms.stringType,
                                                 syms.intType);
-            
+
             Symbol ofType = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
                     names.fromString("ofNamed"), bsm_staticArgs, List.nil());
 
             Symbol.DynamicVarSymbol outter = new Symbol.DynamicVarSymbol(names.fromString("ofNamed"),
                     syms.noSymbol,
@@ -323,11 +329,11 @@
                     nestedBindings[i].clear();
                 } else {
                     bindingVars.append(syms.lengthVar);
                 }
             }
-            
+
             for (ListBuffer<VarSymbol> nested : nestedBindings) {
                 if (nested.isEmpty())
                     continue;
                 bindingVars.appendList(nested.toList());
             }
@@ -335,20 +341,20 @@
             List<Type> bsm_staticArgsNested = List.of(syms.patternHandleType,
                                                       types.makeArrayType(syms.patternHandleType));
 
             MethodSymbol ofNested = rs.resolveInternalMethod(patt.pos(), env, syms.patternHandlesType,
                     names.fromString("nested"), bsm_staticArgsNested, List.nil());
-            
+
             return makeCondyable(patt.pos(), ofNested, params);
         } else if (patt.hasTag(Tag.ANYPATTERN)) {
             Type tempType = patt.type.hasTag(BOT) ?
                     syms.objectType
                     : patt.type;
             List<Type> bsm_staticArgs = List.of(new ClassType(syms.classType.getEnclosingType(),
                                                               List.of(tempType),
                                                               syms.classType.tsym));
-            
+
             if (!tempType.isPrimitive()) {
                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
                                                                      List.of(target),
                                                                      syms.classType.tsym));
             }
@@ -363,11 +369,11 @@
             }
         } else if (patt.hasTag(Tag.LITERALPATTERN)) {
             JCLiteralPattern lpatt = (JCLiteralPattern) patt;
             boolean adapt = types.boxedTypeOrType(target) == target;
             List<Type> bsm_staticArgs = List.of(syms.objectType);
-            
+
             if (adapt) {
                 bsm_staticArgs = bsm_staticArgs.append(new ClassType(syms.classType.getEnclosingType(),
                                                                      List.of(target),
                                                                      syms.classType.tsym));
             }
@@ -513,11 +519,11 @@
     /** Make an attributed tree representing null.
      */
     JCExpression makeNull() {
         return makeLit(syms.botType, null);
     }
-    
+
     /** Make an attributed assignop expression.
      *  @param optag    The operators tree tag.
      *  @param lhs      The operator's left argument.
      *  @param rhs      The operator's right argument.
      */
@@ -525,11 +531,11 @@
         JCAssignOp tree = make.Assignop(optag, lhs, rhs);
         tree.operator = operators.resolveBinary(tree, tree.getTag().noAssignOp(), lhs.type, rhs.type);
         tree.type = lhs.type;
         return tree;
     }
-    
+
 //    JCNewArray makeArray(Type type, JCExpression... elements) {
 //        JCNewArray newArray = make.NewArray(make.Type(types.erasure(type)),
 //                                          List.nil(),
 //                                          List.from(elements));
 //        newArray.type = types.makeArrayType(newArray.elemtype.type);
@@ -733,19 +739,26 @@
                 hoistedVarMap.put(binding, var.sym);
                 statements.append(var);
                 return true;
             }
         };
+        Symbol prevOwnerSym = currentOwnerSym;
         try {
+            if (currentOwnerSym == null) {
+                currentOwnerSym = new MethodSymbol(tree.flags | Flags.BLOCK,
+                                 names.empty, null,
+                                 currentClass.sym);
+            }
             for (List<JCStatement> l = tree.stats; l.nonEmpty(); l = l.tail) {
                 statements.append(translate(l.head));
             }
 
             tree.stats = statements.toList();
             result = tree;
         } finally {
             bindingContext.pop();
+            currentOwnerSym = prevOwnerSym;
         }
     }
 
     @Override
     public void visitLambda(JCLambda tree) {
@@ -814,18 +827,18 @@
         Map<BindingSymbol, VarSymbol> hoistedVarMap;
         BindingContext parent;
 
         public BasicBindingContext() {
             this.parent = bindingContext;
-            this.hoistedVarMap = new HashMap<>();
+            this.hoistedVarMap = new LinkedHashMap<>();
         }
 
         @Override
         VarSymbol bindingDeclared(BindingSymbol varSymbol) {
             VarSymbol res = parent.bindingDeclared(varSymbol);
             if (res == null) {
-                res = new VarSymbol(varSymbol.flags() & ~Flags.MATCH_BINDING, varSymbol.name, varSymbol.type, varSymbol.owner);
+                res = new VarSymbol(varSymbol.flags(), varSymbol.name, varSymbol.type, varSymbol.owner);
                 res.setTypeAttributes(varSymbol.getRawTypeAttributes());
                 hoistedVarMap.put(varSymbol, res);
             }
             return res;
         }

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/jdk.incubator.jpackage/macosx/classes/jdk/incubator/jpackage/internal/MacAppImageBuilder.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 package jdk.incubator.jpackage.internal;
 27 
 28 import java.io.File;
 29 import java.io.FileInputStream;
 30 import java.io.IOException;
 31 import java.io.InputStream;
 32 import java.io.Writer;
 33 import java.math.BigInteger;
 34 import java.nio.file.Files;
 35 import java.nio.file.Path;
 36 import java.nio.file.StandardCopyOption;
 37 import java.nio.file.attribute.PosixFilePermission;
 38 import java.text.MessageFormat;
 39 import java.util.ArrayList;
 40 import java.util.Arrays;
 41 import java.util.EnumSet;
 42 import java.util.HashMap;
 43 import java.util.List;
 44 import java.util.Map;
 45 import java.util.Objects;
 46 import java.util.Optional;
 47 import java.util.ResourceBundle;
 48 import java.util.Set;
 49 import java.util.concurrent.atomic.AtomicReference;
 50 import java.util.function.Consumer;
 51 import java.util.stream.Stream;
 52 import javax.xml.parsers.DocumentBuilder;
 53 import javax.xml.parsers.DocumentBuilderFactory;
 54 import javax.xml.xpath.XPath;
 55 import javax.xml.xpath.XPathConstants;
 56 import javax.xml.xpath.XPathFactory;
 57 
 58 import static jdk.incubator.jpackage.internal.StandardBundlerParam.*;
 59 import static jdk.incubator.jpackage.internal.MacBaseInstallerBundler.*;
 60 import static jdk.incubator.jpackage.internal.MacAppBundler.*;
 61 import static jdk.incubator.jpackage.internal.OverridableResource.createResource;
 62 
 63 public class MacAppImageBuilder extends AbstractAppImageBuilder {
 64 
 65     private static final ResourceBundle I18N = ResourceBundle.getBundle(
 66             &quot;jdk.incubator.jpackage.internal.resources.MacResources&quot;);
 67 
 68     private static final String LIBRARY_NAME = &quot;libapplauncher.dylib&quot;;
 69     private static final String TEMPLATE_BUNDLE_ICON = &quot;java.icns&quot;;
 70     private static final String OS_TYPE_CODE = &quot;APPL&quot;;
 71     private static final String TEMPLATE_INFO_PLIST_LITE =
 72             &quot;Info-lite.plist.template&quot;;
 73     private static final String TEMPLATE_RUNTIME_INFO_PLIST =
 74             &quot;Runtime-Info.plist.template&quot;;
 75 
 76     private final Path root;
 77     private final Path contentsDir;
 78     private final Path appDir;
 79     private final Path javaModsDir;
 80     private final Path resourcesDir;
 81     private final Path macOSDir;
 82     private final Path runtimeDir;
 83     private final Path runtimeRoot;
 84     private final Path mdir;
 85 
 86     private static List&lt;String&gt; keyChains;
 87 
 88     public static final BundlerParamInfo&lt;Boolean&gt;
 89             MAC_CONFIGURE_LAUNCHER_IN_PLIST = new StandardBundlerParam&lt;&gt;(
 90                     &quot;mac.configure-launcher-in-plist&quot;,
 91                     Boolean.class,
 92                     params -&gt; Boolean.FALSE,
 93                     (s, p) -&gt; Boolean.valueOf(s));
 94 
 95     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_NAME =
 96             new StandardBundlerParam&lt;&gt;(
 97                     Arguments.CLIOptions.MAC_BUNDLE_NAME.getId(),
 98                     String.class,
 99                     params -&gt; null,
100                     (s, p) -&gt; s);
101 
102     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_IDENTIFIER =
103             new StandardBundlerParam&lt;&gt;(
104                     Arguments.CLIOptions.MAC_BUNDLE_IDENTIFIER.getId(),
105                     String.class,
106                     params -&gt; {
107                         // Get identifier from app image if user provided
108                         // app image and did not provide the identifier via CLI.
109                         String identifier = extractBundleIdentifier(params);
110                         if (identifier != null) {
111                             return identifier;
112                         }
113 
114                         identifier = IDENTIFIER.fetchFrom(params);
115                         if (identifier != null) {
116                             return identifier;
117                         }
118                         // the IDENTIFIER (above) will default to derive from
119                         // the main-class, in case there is no main-class
120                         // (such as runtime installer) revert to the name.
121                         // any of these could be invalid, so check later.
122                         return APP_NAME.fetchFrom(params);
123                     },
124                     (s, p) -&gt; s);
125 
126     public static final BundlerParamInfo&lt;String&gt; MAC_CF_BUNDLE_VERSION =
127             new StandardBundlerParam&lt;&gt;(
128                     &quot;mac.CFBundleVersion&quot;,
129                     String.class,
130                     p -&gt; {
131                         String s = VERSION.fetchFrom(p);
132                         if (validCFBundleVersion(s)) {
133                             return s;
134                         } else {
135                             return &quot;100&quot;;
136                         }
137                     },
138                     (s, p) -&gt; s);
139 
140     public static final BundlerParamInfo&lt;File&gt; ICON_ICNS =
141             new StandardBundlerParam&lt;&gt;(
142             &quot;icon.icns&quot;,
143             File.class,
144             params -&gt; {
145                 File f = ICON.fetchFrom(params);
146                 if (f != null &amp;&amp; !f.getName().toLowerCase().endsWith(&quot;.icns&quot;)) {
147                     Log.error(MessageFormat.format(
148                             I18N.getString(&quot;message.icon-not-icns&quot;), f));
149                     return null;
150                 }
151                 return f;
152             },
153             (s, p) -&gt; new File(s));
154 
155     public static final StandardBundlerParam&lt;Boolean&gt; SIGN_BUNDLE  =
156             new StandardBundlerParam&lt;&gt;(
157             Arguments.CLIOptions.MAC_SIGN.getId(),
158             Boolean.class,
159             params -&gt; false,
160             // valueOf(null) is false, we actually do want null in some cases
161             (s, p) -&gt; (s == null || &quot;null&quot;.equalsIgnoreCase(s)) ?
162                     null : Boolean.valueOf(s)
163         );
164 
165     public MacAppImageBuilder(Map&lt;String, Object&gt; params, Path imageOutDir)
166             throws IOException {
167         super(params, imageOutDir.resolve(APP_NAME.fetchFrom(params)
168                 + &quot;.app/Contents/runtime/Contents/Home&quot;));
169 
170         Objects.requireNonNull(imageOutDir);
171 
172         this.root = imageOutDir.resolve(APP_NAME.fetchFrom(params) + &quot;.app&quot;);
173         this.contentsDir = root.resolve(&quot;Contents&quot;);
174         this.appDir = contentsDir.resolve(&quot;app&quot;);
175         this.javaModsDir = appDir.resolve(&quot;mods&quot;);
176         this.resourcesDir = contentsDir.resolve(&quot;Resources&quot;);
177         this.macOSDir = contentsDir.resolve(&quot;MacOS&quot;);
178         this.runtimeDir = contentsDir.resolve(&quot;runtime&quot;);
179         this.runtimeRoot = runtimeDir.resolve(&quot;Contents/Home&quot;);
180         this.mdir = runtimeRoot.resolve(&quot;lib&quot;);
181         Files.createDirectories(appDir);
182         Files.createDirectories(resourcesDir);
183         Files.createDirectories(macOSDir);
184         Files.createDirectories(runtimeDir);
185     }
186 
187     private void writeEntry(InputStream in, Path dstFile) throws IOException {
188         Files.createDirectories(dstFile.getParent());
189         Files.copy(in, dstFile);
190     }
191 
192     public static boolean validCFBundleVersion(String v) {
193         // CFBundleVersion (String - iOS, OS X) specifies the build version
194         // number of the bundle, which identifies an iteration (released or
195         // unreleased) of the bundle. The build version number should be a
196         // string comprised of three non-negative, period-separated integers
197         // with the first integer being greater than zero. The string should
198         // only contain numeric (0-9) and period (.) characters. Leading zeros
199         // are truncated from each integer and will be ignored (that is,
200         // 1.02.3 is equivalent to 1.2.3). This key is not localizable.
201 
202         if (v == null) {
203             return false;
204         }
205 
206         String p[] = v.split(&quot;\\.&quot;);
207         if (p.length &gt; 3 || p.length &lt; 1) {
208             Log.verbose(I18N.getString(
209                     &quot;message.version-string-too-many-components&quot;));
210             return false;
211         }
212 
213         try {
214             BigInteger n = new BigInteger(p[0]);
215             if (BigInteger.ONE.compareTo(n) &gt; 0) {
216                 Log.verbose(I18N.getString(
217                         &quot;message.version-string-first-number-not-zero&quot;));
218                 return false;
219             }
220             if (p.length &gt; 1) {
221                 n = new BigInteger(p[1]);
222                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
223                     Log.verbose(I18N.getString(
224                             &quot;message.version-string-no-negative-numbers&quot;));
225                     return false;
226                 }
227             }
228             if (p.length &gt; 2) {
229                 n = new BigInteger(p[2]);
230                 if (BigInteger.ZERO.compareTo(n) &gt; 0) {
231                     Log.verbose(I18N.getString(
232                             &quot;message.version-string-no-negative-numbers&quot;));
233                     return false;
234                 }
235             }
236         } catch (NumberFormatException ne) {
237             Log.verbose(I18N.getString(&quot;message.version-string-numbers-only&quot;));
238             Log.verbose(ne);
239             return false;
240         }
241 
242         return true;
243     }
244 
245     @Override
246     public Path getAppDir() {
247         return appDir;
248     }
249 
250     @Override
251     public Path getAppModsDir() {
252         return javaModsDir;
253     }
254 
255     @Override
256     public void prepareApplicationFiles(Map&lt;String, ? super Object&gt; params)
257             throws IOException {
258         Map&lt;String, ? super Object&gt; originalParams = new HashMap&lt;&gt;(params);
259         // Generate PkgInfo
260         File pkgInfoFile = new File(contentsDir.toFile(), &quot;PkgInfo&quot;);
261         pkgInfoFile.createNewFile();
262         writePkgInfo(pkgInfoFile);
263 
264         Path executable = macOSDir.resolve(getLauncherName(params));
265 
266         // create the main app launcher
267         try (InputStream is_launcher =
268                 getResourceAsStream(&quot;jpackageapplauncher&quot;);
269             InputStream is_lib = getResourceAsStream(LIBRARY_NAME)) {
270             // Copy executable and library to MacOS folder
271             writeEntry(is_launcher, executable);
272             writeEntry(is_lib, macOSDir.resolve(LIBRARY_NAME));
273         }
274         executable.toFile().setExecutable(true, false);
275         // generate main app launcher config file
276         File cfg = new File(root.toFile(), getLauncherCfgName(params));
277         writeCfgFile(params, cfg);
278 
279         // create additional app launcher(s) and config file(s)
280         List&lt;Map&lt;String, ? super Object&gt;&gt; entryPoints =
281                 StandardBundlerParam.ADD_LAUNCHERS.fetchFrom(params);
282         for (Map&lt;String, ? super Object&gt; entryPoint : entryPoints) {
283             Map&lt;String, ? super Object&gt; tmp =
284                     AddLauncherArguments.merge(originalParams, entryPoint);
285 
286             // add executable for add launcher
287             Path addExecutable = macOSDir.resolve(getLauncherName(tmp));
288             try (InputStream is = getResourceAsStream(&quot;jpackageapplauncher&quot;);) {
289                 writeEntry(is, addExecutable);
290             }
291             addExecutable.toFile().setExecutable(true, false);
292 
293             // add config file for add launcher
294             cfg = new File(root.toFile(), getLauncherCfgName(tmp));
295             writeCfgFile(tmp, cfg);
296         }
297 
298         // Copy class path entries to Java folder
299         copyClassPathEntries(appDir, params);
300 
301         /*********** Take care of &quot;config&quot; files *******/
302 
303         createResource(TEMPLATE_BUNDLE_ICON, params)
304                 .setCategory(&quot;icon&quot;)
305                 .setExternal(ICON_ICNS.fetchFrom(params))
306                 .saveToFile(resourcesDir.resolve(APP_NAME.fetchFrom(params)
307                         + &quot;.icns&quot;));
308 
309         // copy file association icons
310         for (Map&lt;String, ?
311                 super Object&gt; fa : FILE_ASSOCIATIONS.fetchFrom(params)) {
312             File f = FA_ICON.fetchFrom(fa);
313             if (f != null &amp;&amp; f.exists()) {
314                 try (InputStream in2 = new FileInputStream(f)) {
315                     Files.copy(in2, resourcesDir.resolve(f.getName()));
316                 }
317 
318             }
319         }
320 
321         copyRuntimeFiles(params);
322         sign(params);
323     }
324 
325     @Override
326     public void prepareJreFiles(Map&lt;String, ? super Object&gt; params)
327             throws IOException {
328         copyRuntimeFiles(params);
329         sign(params);
330     }
331 
332     @Override
333     File getRuntimeImageDir(File runtimeImageTop) {
334         File home = new File(runtimeImageTop, &quot;Contents/Home&quot;);
335         return (home.exists() ? home : runtimeImageTop);
336     }
337 
338     private void copyRuntimeFiles(Map&lt;String, ? super Object&gt; params)
339             throws IOException {
340         // Generate Info.plist
341         writeInfoPlist(contentsDir.resolve(&quot;Info.plist&quot;).toFile(), params);
342 
343         // generate java runtime info.plist
344         writeRuntimeInfoPlist(
345                 runtimeDir.resolve(&quot;Contents/Info.plist&quot;).toFile(), params);
346 
347         // copy library
348         Path runtimeMacOSDir = Files.createDirectories(
349                 runtimeDir.resolve(&quot;Contents/MacOS&quot;));
350 
351         // JDK 9, 10, and 11 have extra &#39;/jli/&#39; subdir
352         Path jli = runtimeRoot.resolve(&quot;lib/libjli.dylib&quot;);
353         if (!Files.exists(jli)) {
354             jli = runtimeRoot.resolve(&quot;lib/jli/libjli.dylib&quot;);
355         }
356 
357         Files.copy(jli, runtimeMacOSDir.resolve(&quot;libjli.dylib&quot;));
358     }
359 
360     private void sign(Map&lt;String, ? super Object&gt; params) throws IOException {
361         if (Optional.ofNullable(
362                 SIGN_BUNDLE.fetchFrom(params)).orElse(Boolean.TRUE)) {
363             try {
364                 addNewKeychain(params);
365             } catch (InterruptedException e) {
366                 Log.error(e.getMessage());
367             }
368             String signingIdentity =
369                     DEVELOPER_ID_APP_SIGNING_KEY.fetchFrom(params);
370             if (signingIdentity != null) {
371                 prepareEntitlements(params);
372                 signAppBundle(params, root, signingIdentity,
373                         BUNDLE_ID_SIGNING_PREFIX.fetchFrom(params),
374                         getConfig_Entitlements(params));
375             }
376             restoreKeychainList(params);
377         }
378     }
379 
380     static File getConfig_Entitlements(Map&lt;String, ? super Object&gt; params) {
381         return new File(CONFIG_ROOT.fetchFrom(params),
382                 getLauncherName(params) + &quot;.entitlements&quot;);
383     }
384 
385     static void prepareEntitlements(Map&lt;String, ? super Object&gt; params)
386             throws IOException {
387         createResource(&quot;entitlements.plist&quot;, params)
388                 .setCategory(I18N.getString(&quot;resource.entitlements&quot;))
389                 .saveToFile(getConfig_Entitlements(params));
390     }
391 
392     private static String getLauncherName(Map&lt;String, ? super Object&gt; params) {
393         if (APP_NAME.fetchFrom(params) != null) {
394             return APP_NAME.fetchFrom(params);
395         } else {
396             return MAIN_CLASS.fetchFrom(params);
397         }
398     }
399 
400     public static String getLauncherCfgName(
401             Map&lt;String, ? super Object&gt; params) {
402         return &quot;Contents/app/&quot; + APP_NAME.fetchFrom(params) + &quot;.cfg&quot;;
403     }
404 
405     private void copyClassPathEntries(Path javaDirectory,
406             Map&lt;String, ? super Object&gt; params) throws IOException {
407         List&lt;RelativeFileSet&gt; resourcesList =
408                 APP_RESOURCES_LIST.fetchFrom(params);
409         if (resourcesList == null) {
410             throw new RuntimeException(
411                     I18N.getString(&quot;message.null-classpath&quot;));
412         }
413 
414         for (RelativeFileSet classPath : resourcesList) {
415             File srcdir = classPath.getBaseDirectory();
416             for (String fname : classPath.getIncludedFiles()) {
417                 copyEntry(javaDirectory, srcdir, fname);
418             }
419         }
420     }
421 
422     private String getBundleName(Map&lt;String, ? super Object&gt; params) {
423         if (MAC_CF_BUNDLE_NAME.fetchFrom(params) != null) {
424             String bn = MAC_CF_BUNDLE_NAME.fetchFrom(params);
425             if (bn.length() &gt; 16) {
426                 Log.error(MessageFormat.format(I18N.getString(
427                         &quot;message.bundle-name-too-long-warning&quot;),
428                         MAC_CF_BUNDLE_NAME.getID(), bn));
429             }
430             return MAC_CF_BUNDLE_NAME.fetchFrom(params);
431         } else if (APP_NAME.fetchFrom(params) != null) {
432             return APP_NAME.fetchFrom(params);
433         } else {
434             String nm = MAIN_CLASS.fetchFrom(params);
435             if (nm.length() &gt; 16) {
436                 nm = nm.substring(0, 16);
437             }
438             return nm;
439         }
440     }
441 
442     private void writeRuntimeInfoPlist(File file,
443             Map&lt;String, ? super Object&gt; params) throws IOException {
444         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
445         String identifier = StandardBundlerParam.isRuntimeInstaller(params) ?
446                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params) :
447                 &quot;com.oracle.java.&quot; + MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params);
448         data.put(&quot;CF_BUNDLE_IDENTIFIER&quot;, identifier);
449         String name = StandardBundlerParam.isRuntimeInstaller(params) ?
450                 getBundleName(params): &quot;Java Runtime Image&quot;;
451         data.put(&quot;CF_BUNDLE_NAME&quot;, name);
452         data.put(&quot;CF_BUNDLE_VERSION&quot;, VERSION.fetchFrom(params));
453         data.put(&quot;CF_BUNDLE_SHORT_VERSION_STRING&quot;, VERSION.fetchFrom(params));
454 
455         createResource(TEMPLATE_RUNTIME_INFO_PLIST, params)
456                 .setPublicName(&quot;Runtime-Info.plist&quot;)
457                 .setCategory(I18N.getString(&quot;resource.runtime-info-plist&quot;))
458                 .setSubstitutionData(data)
459                 .saveToFile(file);
460     }
461 
462     private void writeInfoPlist(File file, Map&lt;String, ? super Object&gt; params)
463             throws IOException {
464         Log.verbose(MessageFormat.format(I18N.getString(
465                 &quot;message.preparing-info-plist&quot;), file.getAbsolutePath()));
466 
467         //prepare config for exe
468         //Note: do not need CFBundleDisplayName if we don&#39;t support localization
469         Map&lt;String, String&gt; data = new HashMap&lt;&gt;();
470         data.put(&quot;DEPLOY_ICON_FILE&quot;, APP_NAME.fetchFrom(params) + &quot;.icns&quot;);
471         data.put(&quot;DEPLOY_BUNDLE_IDENTIFIER&quot;,
472                 MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params));
473         data.put(&quot;DEPLOY_BUNDLE_NAME&quot;,
474                 getBundleName(params));
475         data.put(&quot;DEPLOY_BUNDLE_COPYRIGHT&quot;,
476                 COPYRIGHT.fetchFrom(params) != null ?
477                 COPYRIGHT.fetchFrom(params) : &quot;Unknown&quot;);
478         data.put(&quot;DEPLOY_LAUNCHER_NAME&quot;, getLauncherName(params));
479         data.put(&quot;DEPLOY_BUNDLE_SHORT_VERSION&quot;,
480                 VERSION.fetchFrom(params) != null ?
481                 VERSION.fetchFrom(params) : &quot;1.0.0&quot;);
482         data.put(&quot;DEPLOY_BUNDLE_CFBUNDLE_VERSION&quot;,
483                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) != null ?
484                 MAC_CF_BUNDLE_VERSION.fetchFrom(params) : &quot;100&quot;);
485 
486         boolean hasMainJar = MAIN_JAR.fetchFrom(params) != null;
487         boolean hasMainModule =
488                 StandardBundlerParam.MODULE.fetchFrom(params) != null;
489 
490         if (hasMainJar) {
491             data.put(&quot;DEPLOY_MAIN_JAR_NAME&quot;, MAIN_JAR.fetchFrom(params).
492                     getIncludedFiles().iterator().next());
493         }
494         else if (hasMainModule) {
495             data.put(&quot;DEPLOY_MODULE_NAME&quot;,
496                     StandardBundlerParam.MODULE.fetchFrom(params));
497         }
498 
499         StringBuilder sb = new StringBuilder();
500         List&lt;String&gt; jvmOptions = JAVA_OPTIONS.fetchFrom(params);
501 
502         String newline = &quot;&quot;; //So we don&#39;t add extra line after last append
503         for (String o : jvmOptions) {
504             sb.append(newline).append(
505                     &quot;    &lt;string&gt;&quot;).append(o).append(&quot;&lt;/string&gt;&quot;);
506             newline = &quot;\n&quot;;
507         }
508 
509         data.put(&quot;DEPLOY_JAVA_OPTIONS&quot;, sb.toString());
510 
511         sb = new StringBuilder();
512         List&lt;String&gt; args = ARGUMENTS.fetchFrom(params);
513         newline = &quot;&quot;;
514         // So we don&#39;t add unneccessary extra line after last append
515 
516         for (String o : args) {
517             sb.append(newline).append(&quot;    &lt;string&gt;&quot;).append(o).append(
518                     &quot;&lt;/string&gt;&quot;);
519             newline = &quot;\n&quot;;
520         }
521         data.put(&quot;DEPLOY_ARGUMENTS&quot;, sb.toString());
522 
523         newline = &quot;&quot;;
524 
525         data.put(&quot;DEPLOY_LAUNCHER_CLASS&quot;, MAIN_CLASS.fetchFrom(params));
526 
527         data.put(&quot;DEPLOY_APP_CLASSPATH&quot;,
528                   getCfgClassPath(CLASSPATH.fetchFrom(params)));
529 
530         StringBuilder bundleDocumentTypes = new StringBuilder();
531         StringBuilder exportedTypes = new StringBuilder();
532         for (Map&lt;String, ? super Object&gt;
533                 fileAssociation : FILE_ASSOCIATIONS.fetchFrom(params)) {
534 
535             List&lt;String&gt; extensions = FA_EXTENSIONS.fetchFrom(fileAssociation);
536 
537             if (extensions == null) {
538                 Log.verbose(I18N.getString(
539                         &quot;message.creating-association-with-null-extension&quot;));
540             }
541 
542             List&lt;String&gt; mimeTypes = FA_CONTENT_TYPE.fetchFrom(fileAssociation);
543             String itemContentType = MAC_CF_BUNDLE_IDENTIFIER.fetchFrom(params)
544                     + &quot;.&quot; + ((extensions == null || extensions.isEmpty())
545                     ? &quot;mime&quot; : extensions.get(0));
546             String description = FA_DESCRIPTION.fetchFrom(fileAssociation);
547             File icon = FA_ICON.fetchFrom(fileAssociation);
548 
549             bundleDocumentTypes.append(&quot;    &lt;dict&gt;\n&quot;)
550                     .append(&quot;      &lt;key&gt;LSItemContentTypes&lt;/key&gt;\n&quot;)
551                     .append(&quot;      &lt;array&gt;\n&quot;)
552                     .append(&quot;        &lt;string&gt;&quot;)
553                     .append(itemContentType)
554                     .append(&quot;&lt;/string&gt;\n&quot;)
555                     .append(&quot;      &lt;/array&gt;\n&quot;)
556                     .append(&quot;\n&quot;)
557                     .append(&quot;      &lt;key&gt;CFBundleTypeName&lt;/key&gt;\n&quot;)
558                     .append(&quot;      &lt;string&gt;&quot;)
559                     .append(description)
560                     .append(&quot;&lt;/string&gt;\n&quot;)
561                     .append(&quot;\n&quot;)
562                     .append(&quot;      &lt;key&gt;LSHandlerRank&lt;/key&gt;\n&quot;)
563                     .append(&quot;      &lt;string&gt;Owner&lt;/string&gt;\n&quot;)
564                             // TODO make a bundler arg
565                     .append(&quot;\n&quot;)
566                     .append(&quot;      &lt;key&gt;CFBundleTypeRole&lt;/key&gt;\n&quot;)
567                     .append(&quot;      &lt;string&gt;Editor&lt;/string&gt;\n&quot;)
568                             // TODO make a bundler arg
569                     .append(&quot;\n&quot;)
570                     .append(&quot;      &lt;key&gt;LSIsAppleDefaultForType&lt;/key&gt;\n&quot;)
571                     .append(&quot;      &lt;true/&gt;\n&quot;)
572                             // TODO make a bundler arg
573                     .append(&quot;\n&quot;);
574 
575             if (icon != null &amp;&amp; icon.exists()) {
576                 bundleDocumentTypes
577                         .append(&quot;      &lt;key&gt;CFBundleTypeIconFile&lt;/key&gt;\n&quot;)
578                         .append(&quot;      &lt;string&gt;&quot;)
579                         .append(icon.getName())
580                         .append(&quot;&lt;/string&gt;\n&quot;);
581             }
582             bundleDocumentTypes.append(&quot;    &lt;/dict&gt;\n&quot;);
583 
584             exportedTypes.append(&quot;    &lt;dict&gt;\n&quot;)
585                     .append(&quot;      &lt;key&gt;UTTypeIdentifier&lt;/key&gt;\n&quot;)
586                     .append(&quot;      &lt;string&gt;&quot;)
587                     .append(itemContentType)
588                     .append(&quot;&lt;/string&gt;\n&quot;)
589                     .append(&quot;\n&quot;)
590                     .append(&quot;      &lt;key&gt;UTTypeDescription&lt;/key&gt;\n&quot;)
591                     .append(&quot;      &lt;string&gt;&quot;)
592                     .append(description)
593                     .append(&quot;&lt;/string&gt;\n&quot;)
594                     .append(&quot;      &lt;key&gt;UTTypeConformsTo&lt;/key&gt;\n&quot;)
595                     .append(&quot;      &lt;array&gt;\n&quot;)
596                     .append(&quot;          &lt;string&gt;public.data&lt;/string&gt;\n&quot;)
597                             //TODO expose this?
598                     .append(&quot;      &lt;/array&gt;\n&quot;)
599                     .append(&quot;\n&quot;);
600 
601             if (icon != null &amp;&amp; icon.exists()) {
602                 exportedTypes.append(&quot;      &lt;key&gt;UTTypeIconFile&lt;/key&gt;\n&quot;)
603                         .append(&quot;      &lt;string&gt;&quot;)
604                         .append(icon.getName())
605                         .append(&quot;&lt;/string&gt;\n&quot;)
606                         .append(&quot;\n&quot;);
607             }
608 
609             exportedTypes.append(&quot;\n&quot;)
610                     .append(&quot;      &lt;key&gt;UTTypeTagSpecification&lt;/key&gt;\n&quot;)
611                     .append(&quot;      &lt;dict&gt;\n&quot;)
612                             // TODO expose via param? .append(
613                             // &quot;        &lt;key&gt;com.apple.ostype&lt;/key&gt;\n&quot;);
614                             // TODO expose via param? .append(
615                             // &quot;        &lt;string&gt;ABCD&lt;/string&gt;\n&quot;)
616                     .append(&quot;\n&quot;);
617 
618             if (extensions != null &amp;&amp; !extensions.isEmpty()) {
619                 exportedTypes.append(
620                         &quot;        &lt;key&gt;public.filename-extension&lt;/key&gt;\n&quot;)
621                         .append(&quot;        &lt;array&gt;\n&quot;);
622 
623                 for (String ext : extensions) {
624                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
625                             .append(ext)
626                             .append(&quot;&lt;/string&gt;\n&quot;);
627                 }
628                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
629             }
630             if (mimeTypes != null &amp;&amp; !mimeTypes.isEmpty()) {
631                 exportedTypes.append(&quot;        &lt;key&gt;public.mime-type&lt;/key&gt;\n&quot;)
632                         .append(&quot;        &lt;array&gt;\n&quot;);
633 
634                 for (String mime : mimeTypes) {
635                     exportedTypes.append(&quot;          &lt;string&gt;&quot;)
636                             .append(mime)
637                             .append(&quot;&lt;/string&gt;\n&quot;);
638                 }
639                 exportedTypes.append(&quot;        &lt;/array&gt;\n&quot;);
640             }
641             exportedTypes.append(&quot;      &lt;/dict&gt;\n&quot;)
642                     .append(&quot;    &lt;/dict&gt;\n&quot;);
643         }
644         String associationData;
645         if (bundleDocumentTypes.length() &gt; 0) {
646             associationData =
647                     &quot;\n  &lt;key&gt;CFBundleDocumentTypes&lt;/key&gt;\n  &lt;array&gt;\n&quot;
648                     + bundleDocumentTypes.toString()
649                     + &quot;  &lt;/array&gt;\n\n&quot;
650                     + &quot;  &lt;key&gt;UTExportedTypeDeclarations&lt;/key&gt;\n  &lt;array&gt;\n&quot;
651                     + exportedTypes.toString()
652                     + &quot;  &lt;/array&gt;\n&quot;;
653         } else {
654             associationData = &quot;&quot;;
655         }
656         data.put(&quot;DEPLOY_FILE_ASSOCIATIONS&quot;, associationData);
657 
658         createResource(TEMPLATE_INFO_PLIST_LITE, params)
659                 .setCategory(I18N.getString(&quot;resource.app-info-plist&quot;))
660                 .setSubstitutionData(data)
661                 .setPublicName(&quot;Info.plist&quot;)
662                 .saveToFile(file);
663     }
664 
665     private void writePkgInfo(File file) throws IOException {
666         //hardcoded as it does not seem we need to change it ever
667         String signature = &quot;????&quot;;
668 
669         try (Writer out = Files.newBufferedWriter(file.toPath())) {
670             out.write(OS_TYPE_CODE + signature);
671             out.flush();
672         }
673     }
674 
675     public static void addNewKeychain(Map&lt;String, ? super Object&gt; params)
676                                     throws IOException, InterruptedException {
677         if (Platform.getMajorVersion() &lt; 10 ||
678                 (Platform.getMajorVersion() == 10 &amp;&amp;
679                 Platform.getMinorVersion() &lt; 12)) {
680             // we need this for OS X 10.12+
681             return;
682         }
683 
684         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
685         if (keyChain == null || keyChain.isEmpty()) {
686             return;
687         }
688 
689         // get current keychain list
690         String keyChainPath = new File (keyChain).getAbsolutePath().toString();
691         List&lt;String&gt; keychainList = new ArrayList&lt;&gt;();
692         int ret = IOUtils.getProcessOutput(
693                 keychainList, &quot;security&quot;, &quot;list-keychains&quot;);
694         if (ret != 0) {
695             Log.error(I18N.getString(&quot;message.keychain.error&quot;));
696             return;
697         }
698 
699         boolean contains = keychainList.stream().anyMatch(
700                     str -&gt; str.trim().equals(&quot;\&quot;&quot;+keyChainPath.trim()+&quot;\&quot;&quot;));
701         if (contains) {
702             // keychain is already added in the search list
703             return;
704         }
705 
706         keyChains = new ArrayList&lt;&gt;();
707         // remove &quot;
708         keychainList.forEach((String s) -&gt; {
709             String path = s.trim();
710             if (path.startsWith(&quot;\&quot;&quot;) &amp;&amp; path.endsWith(&quot;\&quot;&quot;)) {
711                 path = path.substring(1, path.length()-1);
712             }
713             keyChains.add(path);
714         });
715 
716         List&lt;String&gt; args = new ArrayList&lt;&gt;();
717         args.add(&quot;security&quot;);
718         args.add(&quot;list-keychains&quot;);
719         args.add(&quot;-s&quot;);
720 
721         args.addAll(keyChains);
722         args.add(keyChain);
723 
724         ProcessBuilder  pb = new ProcessBuilder(args);
725         IOUtils.exec(pb);
726     }
727 
728     public static void restoreKeychainList(Map&lt;String, ? super Object&gt; params)
729             throws IOException{
730         if (Platform.getMajorVersion() &lt; 10 ||
731                 (Platform.getMajorVersion() == 10 &amp;&amp;
732                 Platform.getMinorVersion() &lt; 12)) {
733             // we need this for OS X 10.12+
734             return;
735         }
736 
737         if (keyChains == null || keyChains.isEmpty()) {
738             return;
739         }
740 
741         List&lt;String&gt; args = new ArrayList&lt;&gt;();
742         args.add(&quot;security&quot;);
743         args.add(&quot;list-keychains&quot;);
744         args.add(&quot;-s&quot;);
745 
746         args.addAll(keyChains);
747 
748         ProcessBuilder  pb = new ProcessBuilder(args);
749         IOUtils.exec(pb);
750     }
751 
752     static void signAppBundle(
753             Map&lt;String, ? super Object&gt; params, Path appLocation,
754             String signingIdentity, String identifierPrefix, File entitlements)
755             throws IOException {
756         AtomicReference&lt;IOException&gt; toThrow = new AtomicReference&lt;&gt;();
757         String appExecutable = &quot;/Contents/MacOS/&quot; + APP_NAME.fetchFrom(params);
758         String keyChain = SIGNING_KEYCHAIN.fetchFrom(params);
759 
760         // sign all dylibs and executables
761         try (Stream&lt;Path&gt; stream = Files.walk(appLocation)) {
762             stream.peek(path -&gt; { // fix permissions
763                 try {
764                     Set&lt;PosixFilePermission&gt; pfp =
765                             Files.getPosixFilePermissions(path);
766                     if (!pfp.contains(PosixFilePermission.OWNER_WRITE)) {
767                         pfp = EnumSet.copyOf(pfp);
768                         pfp.add(PosixFilePermission.OWNER_WRITE);
769                         Files.setPosixFilePermissions(path, pfp);
770                     }
771                 } catch (IOException e) {
772                     Log.verbose(e);
773                 }
774             }).filter(p -&gt; Files.isRegularFile(p) &amp;&amp;
775                       (Files.isExecutable(p) || p.toString().endsWith(&quot;.dylib&quot;))
776                       &amp;&amp; !(p.toString().endsWith(appExecutable)
777                       || p.toString().contains(&quot;/Contents/runtime&quot;)
778                       || p.toString().contains(&quot;/Contents/Frameworks&quot;))
779                      ).forEach(p -&gt; {
780                 // noinspection ThrowableResultOfMethodCallIgnored
781                 if (toThrow.get() != null) return;
782 
783                 // If p is a symlink then skip the signing process.
784                 if (Files.isSymbolicLink(p)) {
785                     Log.verbose(MessageFormat.format(I18N.getString(
786                             &quot;message.ignoring.symlink&quot;), p.toString()));
787                 } else if (isFileSigned(p)) {
788                     // executable or lib already signed
789                     Log.verbose(MessageFormat.format(I18N.getString(
790                             &quot;message.already.signed&quot;), p.toString()));
791                 } else {
792                     List&lt;String&gt; args = new ArrayList&lt;&gt;();
793                     args.addAll(Arrays.asList(&quot;codesign&quot;,
794                             &quot;--timestamp&quot;,
795                             &quot;--options&quot;, &quot;runtime&quot;,
796                             &quot;-s&quot;, signingIdentity,
797                             &quot;--prefix&quot;, identifierPrefix,
798                             &quot;-vvvv&quot;));
799                     if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
800                         args.add(&quot;--keychain&quot;);
801                         args.add(keyChain);
802                     }
803 
804                     if (Files.isExecutable(p)) {
805                         if (entitlements != null) {
806                             args.add(&quot;--entitlements&quot;);
807                             args.add(entitlements.toString());
808                         }
809                     }
810 
811                     args.add(p.toString());
812 
813                     try {
814                         Set&lt;PosixFilePermission&gt; oldPermissions =
815                                 Files.getPosixFilePermissions(p);
816                         File f = p.toFile();
817                         f.setWritable(true, true);
818 
819                         ProcessBuilder pb = new ProcessBuilder(args);
820 
821                         IOUtils.exec(pb);
822 
823                         Files.setPosixFilePermissions(p, oldPermissions);
824                     } catch (IOException ioe) {
825                         toThrow.set(ioe);
826                     }
827                 }
828             });
829         }
830         IOException ioe = toThrow.get();
831         if (ioe != null) {
832             throw ioe;
833         }
834 
835         // sign all runtime and frameworks
836         Consumer&lt;? super Path&gt; signIdentifiedByPList = path -&gt; {
837             //noinspection ThrowableResultOfMethodCallIgnored
838             if (toThrow.get() != null) return;
839 
840             try {
841                 List&lt;String&gt; args = new ArrayList&lt;&gt;();
842                 args.addAll(Arrays.asList(&quot;codesign&quot;,
843                         &quot;--timestamp&quot;,
844                         &quot;--options&quot;, &quot;runtime&quot;,
845                         &quot;--deep&quot;,
846                         &quot;--force&quot;,
847                         &quot;-s&quot;, signingIdentity, // sign with this key
848                         &quot;--prefix&quot;, identifierPrefix,
849                         // use the identifier as a prefix
850                         &quot;-vvvv&quot;));
851 
852                 if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
853                     args.add(&quot;--keychain&quot;);
854                     args.add(keyChain);
855                 }
856                 args.add(path.toString());
857                 ProcessBuilder pb = new ProcessBuilder(args);
858 
859                 IOUtils.exec(pb);
860             } catch (IOException e) {
861                 toThrow.set(e);
862             }
863         };
864 
865         Path javaPath = appLocation.resolve(&quot;Contents/runtime&quot;);
866         if (Files.isDirectory(javaPath)) {
867             signIdentifiedByPList.accept(javaPath);
868 
869             ioe = toThrow.get();
870             if (ioe != null) {
871                 throw ioe;
872             }
873         }
874         Path frameworkPath = appLocation.resolve(&quot;Contents/Frameworks&quot;);
875         if (Files.isDirectory(frameworkPath)) {
876             Files.list(frameworkPath)
877                     .forEach(signIdentifiedByPList);
878 
879             ioe = toThrow.get();
880             if (ioe != null) {
881                 throw ioe;
882             }
883         }
884 
885         // sign the app itself
886         List&lt;String&gt; args = new ArrayList&lt;&gt;();
887         args.addAll(Arrays.asList(&quot;codesign&quot;,
888                 &quot;--timestamp&quot;,
889                 &quot;--options&quot;, &quot;runtime&quot;,
890                 &quot;--deep&quot;,
891                 &quot;--force&quot;,
892                 &quot;-s&quot;, signingIdentity,
893                 &quot;-vvvv&quot;));
894 
895         if (keyChain != null &amp;&amp; !keyChain.isEmpty()) {
896             args.add(&quot;--keychain&quot;);
897             args.add(keyChain);
898         }
899 
900         if (entitlements != null) {
901             args.add(&quot;--entitlements&quot;);
902             args.add(entitlements.toString());
903         }
904 
905         args.add(appLocation.toString());
906 
907         ProcessBuilder pb =
908                 new ProcessBuilder(args.toArray(new String[args.size()]));
909 
910         IOUtils.exec(pb);
911     }
912 
913     private static boolean isFileSigned(Path file) {
914         ProcessBuilder pb =
915                 new ProcessBuilder(&quot;codesign&quot;, &quot;--verify&quot;, file.toString());
916 
917         try {
918             IOUtils.exec(pb);
919         } catch (IOException ex) {
920             return false;
921         }
922 
923         return true;
924     }
925 
926     private static String extractBundleIdentifier(Map&lt;String, Object&gt; params) {
927         if (PREDEFINED_APP_IMAGE.fetchFrom(params) == null) {
928             return null;
929         }
930 
931         try {
932             File infoPList = new File(PREDEFINED_APP_IMAGE.fetchFrom(params) +
933                                       File.separator + &quot;Contents&quot; +
934                                       File.separator + &quot;Info.plist&quot;);
935 
936             DocumentBuilderFactory dbf
937                     = DocumentBuilderFactory.newDefaultInstance();
938             dbf.setFeature(&quot;http://apache.org/xml/features/&quot; +
939                            &quot;nonvalidating/load-external-dtd&quot;, false);
940             DocumentBuilder b = dbf.newDocumentBuilder();
941             org.w3c.dom.Document doc = b.parse(new FileInputStream(
942                     infoPList.getAbsolutePath()));
943 
944             XPath xPath = XPathFactory.newInstance().newXPath();
945             // Query for the value of &lt;string&gt; element preceding &lt;key&gt;
946             // element with value equal to CFBundleIdentifier
947             String v = (String) xPath.evaluate(
948                     &quot;//string[preceding-sibling::key = \&quot;CFBundleIdentifier\&quot;][1]&quot;,
949                     doc, XPathConstants.STRING);
950 
951             if (v != null &amp;&amp; !v.isEmpty()) {
952                 return v;
953             }
954         } catch (Exception ex) {
955             Log.verbose(ex);
956         }
957 
958         return null;
959     }
960 
961 }
    </pre>
  </body>
</html>
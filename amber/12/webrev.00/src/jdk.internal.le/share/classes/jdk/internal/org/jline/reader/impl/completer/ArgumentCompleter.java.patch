diff a/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/completer/ArgumentCompleter.java b/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/completer/ArgumentCompleter.java
--- a/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/completer/ArgumentCompleter.java
+++ b/src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/completer/ArgumentCompleter.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2002-2018, the original author or authors.
+ * Copyright (c) 2002-2019, the original author or authors.
  *
  * This software is distributable under the BSD license. See the terms of the
  * BSD license in the documentation provided with this software.
  *
  * https://opensource.org/licenses/BSD-3-Clause
@@ -32,10 +32,11 @@
 public class ArgumentCompleter implements Completer
 {
     private final List<Completer> completers = new ArrayList<>();
 
     private boolean strict = true;
+    private boolean strictCommand = true;
 
     /**
      * Create a new completer.
      *
      * @param completers    The embedded completers
@@ -62,10 +63,19 @@
      */
     public void setStrict(final boolean strict) {
         this.strict = strict;
     }
 
+    /**
+     * If true, a completion at argument index N will only succeed
+     * if all the completions from 1-(N-1) also succeed.
+     *
+     * @param strictCommand the strictCommand flag
+     */
+    public void setStrictCommand(final boolean strictCommand) {
+        this.strictCommand = strictCommand;
+    }
     /**
      * Returns whether a completion at argument index N will success
      * if all the completions from arguments 0-(N-1) also succeed.
      *
      * @return  True if strict.
@@ -102,12 +112,16 @@
         else {
             completer = completers.get(line.wordIndex());
         }
 
         // ensure that all the previous completers are successful before allowing this completer to pass (only if strict).
-        for (int i = 0; isStrict() && (i < line.wordIndex()); i++) {
-            Completer sub = completers.get(i >= completers.size() ? (completers.size() - 1) : i);
+        for (int i = strictCommand ? 0 : 1; isStrict() && (i < line.wordIndex()); i++) {
+            int idx = i >= completers.size() ? (completers.size() - 1) : i;
+            if (idx == 0 && !strictCommand) {
+                continue;
+            }
+            Completer sub = completers.get(idx);
             List<? extends CharSequence> args = line.words();
             String arg = (args == null || i >= args.size()) ? "" : args.get(i).toString();
 
             List<Candidate> subCandidates = new LinkedList<>();
             sub.complete(reader, new ArgumentLine(arg, arg.length()), subCandidates);

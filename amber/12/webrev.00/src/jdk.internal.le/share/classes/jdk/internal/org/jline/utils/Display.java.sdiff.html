<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/Display.java</title>
    <link rel="stylesheet" href="../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../terminal/impl/PosixSysTerminal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InfoCmp.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/utils/Display.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002-2018, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.Collections;
 12 import java.util.HashMap;
 13 import java.util.List;
 14 import java.util.Map;
 15 import java.util.Objects;
 16 import java.util.stream.Collectors;
 17 
 18 import jdk.internal.org.jline.terminal.Terminal;
 19 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 20 
 21 /**
 22  * Handle display and visual cursor.
</pre>
<hr />
<pre>
198             int newLength = newLine.length();
199             boolean oldNL = oldLength &gt; 0 &amp;&amp; oldLine.charAt(oldLength-1)==&#39;\n&#39;;
200             boolean newNL = newLength &gt; 0 &amp;&amp; newLine.charAt(newLength-1)==&#39;\n&#39;;
201             if (oldNL) {
202                 oldLength--;
203                 oldLine = oldLine.substring(0, oldLength);
204             }
205             if (newNL) {
206                 newLength--;
207                 newLine = newLine.substring(0, newLength);
208             }
209             if (wrapNeeded
210                 &amp;&amp; lineIndex == (cursorPos + 1) / columns1
211                 &amp;&amp; lineIndex &lt; newLines.size()) {
212                 // move from right margin to next line&#39;s left margin
213                 cursorPos++;
214                 if (newLength == 0 || newLine.isHidden(0)) {
215                     // go to next line column zero
216                     rawPrint(new AttributedString(&quot; \b&quot;));
217                 } else {
<span class="line-modified">218                     AttributedString firstChar =</span>
<span class="line-removed">219                         newLine.columnSubSequence(0, 1);</span>
220                     // go to next line column one
221                     rawPrint(firstChar);
<span class="line-modified">222                     cursorPos++;</span>
<span class="line-modified">223                     int firstLength = firstChar.length(); // normally 1</span>
<span class="line-modified">224                     newLine = newLine.substring(firstLength, newLength);</span>
<span class="line-modified">225                     newLength -= firstLength;</span>
<span class="line-modified">226                     if (oldLength &gt;= firstLength) {</span>
<span class="line-modified">227                         oldLine = oldLine.substring(firstLength, oldLength);</span>
<span class="line-removed">228                         oldLength -= firstLength;</span>
229                     }
230                     currentPos = cursorPos;
231                 }
232             }
233             List&lt;DiffHelper.Diff&gt; diffs = DiffHelper.diff(oldLine, newLine);
234             boolean ident = true;
235             boolean cleared = false;
236             for (int i = 0; i &lt; diffs.size(); i++) {
237                 DiffHelper.Diff diff = diffs.get(i);
238                 int width = diff.text.columnLength();
239                 switch (diff.operation) {
240                     case EQUAL:
241                         if (!ident) {
242                             cursorPos = moveVisualCursorTo(currentPos);
243                             rawPrint(diff.text);
244                             cursorPos += width;
245                             currentPos = cursorPos;
246                         } else {
247                             currentPos += width;
248                         }
</pre>
<hr />
<pre>
312             if (this.delayedWrapAtEol) {
313                 boolean oldWrap = ! oldNL &amp;&amp; lineIndex &lt; oldLines.size();
314                 if (newWrap != oldWrap &amp;&amp; ! (oldWrap &amp;&amp; cleared)) {
315                     moveVisualCursorTo(lineIndex*columns1-1, newLines);
316                     if (newWrap)
317                         wrapNeeded = true;
318                     else
319                         terminal.puts(Capability.clr_eol);
320                 }
321             } else if (atRight) {
322                 if (this.wrapAtEol) {
323                     terminal.writer().write(&quot; \b&quot;);
324                     cursorPos++;
325                 } else {
326                     terminal.puts(Capability.carriage_return); // CR / not newline.
327                     cursorPos = curCol;
328                 }
329                 currentPos = cursorPos;
330             }
331         }
<span class="line-removed">332         int was = cursorPos;</span>
333         if (cursorPos != targetCursorPos) {
334             moveVisualCursorTo(targetCursorPos &lt; 0 ? currentPos : targetCursorPos, newLines);
335         }
336         oldLines = newLines;
337 
338         if (flush) {
339             terminal.flush();
340         }
341     }
342 
343     protected boolean deleteLines(int nb) {
344         return perform(Capability.delete_line, Capability.parm_delete_line, nb);
345     }
346 
347     protected boolean insertLines(int nb) {
348         return perform(Capability.insert_line, Capability.parm_insert_line, nb);
349     }
350 
351     protected boolean insertChars(int nb) {
352         return perform(Capability.insert_character, Capability.parm_ich, nb);
</pre>
<hr />
<pre>
479         }
480         cursorPos = i1;
481         return i1;
482     }
483 
484     void rawPrint(char c, int num) {
485         for (int i = 0; i &lt; num; i++) {
486             rawPrint(c);
487         }
488     }
489 
490     void rawPrint(int c) {
491         terminal.writer().write(c);
492     }
493 
494     void rawPrint(AttributedString str) {
495         str.print(terminal);
496     }
497 
498     public int wcwidth(String str) {
<span class="line-modified">499         return AttributedString.fromAnsi(str).columnLength();</span>
500     }
501 
502 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2002-2020, the original author or authors.</span>
  3  *
  4  * This software is distributable under the BSD license. See the terms of the
  5  * BSD license in the documentation provided with this software.
  6  *
  7  * https://opensource.org/licenses/BSD-3-Clause
  8  */
  9 package jdk.internal.org.jline.utils;
 10 
 11 import java.util.Collections;
 12 import java.util.HashMap;
 13 import java.util.List;
 14 import java.util.Map;
 15 import java.util.Objects;
 16 import java.util.stream.Collectors;
 17 
 18 import jdk.internal.org.jline.terminal.Terminal;
 19 import jdk.internal.org.jline.utils.InfoCmp.Capability;
 20 
 21 /**
 22  * Handle display and visual cursor.
</pre>
<hr />
<pre>
198             int newLength = newLine.length();
199             boolean oldNL = oldLength &gt; 0 &amp;&amp; oldLine.charAt(oldLength-1)==&#39;\n&#39;;
200             boolean newNL = newLength &gt; 0 &amp;&amp; newLine.charAt(newLength-1)==&#39;\n&#39;;
201             if (oldNL) {
202                 oldLength--;
203                 oldLine = oldLine.substring(0, oldLength);
204             }
205             if (newNL) {
206                 newLength--;
207                 newLine = newLine.substring(0, newLength);
208             }
209             if (wrapNeeded
210                 &amp;&amp; lineIndex == (cursorPos + 1) / columns1
211                 &amp;&amp; lineIndex &lt; newLines.size()) {
212                 // move from right margin to next line&#39;s left margin
213                 cursorPos++;
214                 if (newLength == 0 || newLine.isHidden(0)) {
215                     // go to next line column zero
216                     rawPrint(new AttributedString(&quot; \b&quot;));
217                 } else {
<span class="line-modified">218                     AttributedString firstChar = newLine.substring(0, 1);</span>

219                     // go to next line column one
220                     rawPrint(firstChar);
<span class="line-modified">221                     cursorPos += firstChar.columnLength(); // normally 1</span>
<span class="line-modified">222                     newLine = newLine.substring(1, newLength);</span>
<span class="line-modified">223                     newLength--;</span>
<span class="line-modified">224                     if (oldLength &gt; 0) {</span>
<span class="line-modified">225                         oldLine = oldLine.substring(1, oldLength);</span>
<span class="line-modified">226                         oldLength--;</span>

227                     }
228                     currentPos = cursorPos;
229                 }
230             }
231             List&lt;DiffHelper.Diff&gt; diffs = DiffHelper.diff(oldLine, newLine);
232             boolean ident = true;
233             boolean cleared = false;
234             for (int i = 0; i &lt; diffs.size(); i++) {
235                 DiffHelper.Diff diff = diffs.get(i);
236                 int width = diff.text.columnLength();
237                 switch (diff.operation) {
238                     case EQUAL:
239                         if (!ident) {
240                             cursorPos = moveVisualCursorTo(currentPos);
241                             rawPrint(diff.text);
242                             cursorPos += width;
243                             currentPos = cursorPos;
244                         } else {
245                             currentPos += width;
246                         }
</pre>
<hr />
<pre>
310             if (this.delayedWrapAtEol) {
311                 boolean oldWrap = ! oldNL &amp;&amp; lineIndex &lt; oldLines.size();
312                 if (newWrap != oldWrap &amp;&amp; ! (oldWrap &amp;&amp; cleared)) {
313                     moveVisualCursorTo(lineIndex*columns1-1, newLines);
314                     if (newWrap)
315                         wrapNeeded = true;
316                     else
317                         terminal.puts(Capability.clr_eol);
318                 }
319             } else if (atRight) {
320                 if (this.wrapAtEol) {
321                     terminal.writer().write(&quot; \b&quot;);
322                     cursorPos++;
323                 } else {
324                     terminal.puts(Capability.carriage_return); // CR / not newline.
325                     cursorPos = curCol;
326                 }
327                 currentPos = cursorPos;
328             }
329         }

330         if (cursorPos != targetCursorPos) {
331             moveVisualCursorTo(targetCursorPos &lt; 0 ? currentPos : targetCursorPos, newLines);
332         }
333         oldLines = newLines;
334 
335         if (flush) {
336             terminal.flush();
337         }
338     }
339 
340     protected boolean deleteLines(int nb) {
341         return perform(Capability.delete_line, Capability.parm_delete_line, nb);
342     }
343 
344     protected boolean insertLines(int nb) {
345         return perform(Capability.insert_line, Capability.parm_insert_line, nb);
346     }
347 
348     protected boolean insertChars(int nb) {
349         return perform(Capability.insert_character, Capability.parm_ich, nb);
</pre>
<hr />
<pre>
476         }
477         cursorPos = i1;
478         return i1;
479     }
480 
481     void rawPrint(char c, int num) {
482         for (int i = 0; i &lt; num; i++) {
483             rawPrint(c);
484         }
485     }
486 
487     void rawPrint(int c) {
488         terminal.writer().write(c);
489     }
490 
491     void rawPrint(AttributedString str) {
492         str.print(terminal);
493     }
494 
495     public int wcwidth(String str) {
<span class="line-modified">496         return str != null ? AttributedString.fromAnsi(str).columnLength() : 0;</span>
497     }
498 
499 }
</pre>
</td>
</tr>
</table>
<center><a href="../terminal/impl/PosixSysTerminal.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../index.html" target="_top">index</a> <a href="InfoCmp.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
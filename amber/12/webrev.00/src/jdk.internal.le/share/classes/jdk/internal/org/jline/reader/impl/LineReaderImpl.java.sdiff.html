<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="completer/ArgumentCompleter.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.le/share/classes/jdk/internal/org/jline/reader/impl/LineReaderImpl.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002-2019, the original author or authors.</span>
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
   7  * https://opensource.org/licenses/BSD-3-Clause
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 




  11 import java.io.Flushable;
  12 import java.io.IOError;
  13 import java.io.IOException;
  14 import java.io.InputStream;
  15 import java.io.InterruptedIOException;

  16 import java.time.Instant;
  17 import java.util.*;
  18 import java.util.Map.Entry;
  19 import java.util.concurrent.atomic.AtomicBoolean;
<span class="line-removed">  20 import java.util.concurrent.locks.Lock;</span>
  21 import java.util.concurrent.locks.ReentrantLock;
  22 import java.util.function.*;
  23 import java.util.regex.Matcher;
  24 import java.util.regex.Pattern;
  25 import java.util.stream.Collectors;
  26 import java.util.stream.Stream;
  27 import java.util.stream.StreamSupport;
  28 
  29 import jdk.internal.org.jline.keymap.BindingReader;
  30 import jdk.internal.org.jline.keymap.KeyMap;
  31 import jdk.internal.org.jline.reader.*;
  32 import jdk.internal.org.jline.reader.Parser.ParseContext;
  33 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  34 import jdk.internal.org.jline.terminal.*;
  35 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  36 import jdk.internal.org.jline.terminal.Terminal.Signal;
  37 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
  38 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
  39 import jdk.internal.org.jline.utils.AttributedString;
  40 import jdk.internal.org.jline.utils.AttributedStringBuilder;
</pre>
<hr />
<pre>
  69 
  70     public static final int TAB_WIDTH = 4;
  71 
  72 
  73     public static final String DEFAULT_WORDCHARS = &quot;*?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;&quot;;
  74     public static final String DEFAULT_REMOVE_SUFFIX_CHARS = &quot; \t\n;&amp;|&quot;;
  75     public static final String DEFAULT_COMMENT_BEGIN = &quot;#&quot;;
  76     public static final String DEFAULT_SEARCH_TERMINATORS = &quot;\033\012&quot;;
  77     public static final String DEFAULT_BELL_STYLE = &quot;&quot;;
  78     public static final int    DEFAULT_LIST_MAX = 100;
  79     public static final int    DEFAULT_ERRORS = 2;
  80     public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;
  81     public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;
  82     public static final String DEFAULT_SECONDARY_PROMPT_PATTERN = &quot;%M&gt; &quot;;
  83     public static final String DEFAULT_OTHERS_GROUP_NAME = &quot;others&quot;;
  84     public static final String DEFAULT_ORIGINAL_GROUP_NAME = &quot;original&quot;;
  85     public static final String DEFAULT_COMPLETION_STYLE_STARTING = &quot;36&quot;;    // cyan
  86     public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = &quot;90&quot;; // dark gray
  87     public static final String DEFAULT_COMPLETION_STYLE_GROUP = &quot;35;1&quot;;     // magenta
  88     public static final String DEFAULT_COMPLETION_STYLE_SELECTION = &quot;7&quot;;    // inverted


  89 
  90     private static final int MIN_ROWS = 3;
  91 
  92     public static final String BRACKETED_PASTE_ON = &quot;\033[?2004h&quot;;
  93     public static final String BRACKETED_PASTE_OFF = &quot;\033[?2004l&quot;;
  94     public static final String BRACKETED_PASTE_BEGIN = &quot;\033[200~&quot;;
  95     public static final String BRACKETED_PASTE_END = &quot;\033[201~&quot;;
  96 
  97     public static final String FOCUS_IN_SEQ = &quot;\033[I&quot;;
  98     public static final String FOCUS_OUT_SEQ = &quot;\033[O&quot;;
  99 
 100     /**
 101      * Possible states in which the current readline operation may be in.
 102      */
 103     protected enum State {
 104         /**
 105          * The user is just typing away
 106          */
 107         NORMAL,
 108         /**
 109          * readLine should exit and return the buffer content
 110          */
 111         DONE,




 112         /**
 113          * readLine should exit and throw an EOFException
 114          */
 115         EOF,
 116         /**
 117          * readLine should exit and throw an UserInterruptException
 118          */
 119         INTERRUPT
 120     }
 121 
 122     protected enum ViMoveMode {
 123         NORMAL,
 124         YANK,
 125         DELETE,
 126         CHANGE
 127     }
 128 
 129     protected enum BellType {
 130         NONE,
 131         AUDIBLE,
</pre>
<hr />
<pre>
 143     /** The terminal keys mapping */
 144     protected final Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps;
 145 
 146     //
 147     // Configuration
 148     //
 149     protected final Map&lt;String, Object&gt; variables;
 150     protected History history = new DefaultHistory();
 151     protected Completer completer = null;
 152     protected Highlighter highlighter = new DefaultHighlighter();
 153     protected Parser parser = new DefaultParser();
 154     protected Expander expander = new DefaultExpander();
 155 
 156     //
 157     // State variables
 158     //
 159 
 160     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 161 
 162     protected final Buffer buf = new BufferImpl();


 163 
 164     protected final Size size = new Size();
 165 
 166     protected AttributedString prompt = AttributedString.EMPTY;
 167     protected AttributedString rightPrompt = AttributedString.EMPTY;
 168 
 169     protected MaskingCallback maskingCallback;
 170 
 171     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 172     protected Buffer historyBuffer = null;
 173     protected CharSequence searchBuffer;
 174     protected StringBuffer searchTerm = null;
 175     protected boolean searchFailing;
 176     protected boolean searchBackward;
 177     protected int searchIndex = -1;

 178 
 179 
 180     // Reading buffers
 181     protected final BindingReader bindingReader;
 182 
 183 
 184     /**
 185      * VI character find
 186      */
 187     protected int findChar;
 188     protected int findDir;
 189     protected int findTailAdd;
 190     /**
 191      * VI history string search
 192      */
 193     private int searchDir;
 194     private String searchString;
 195 
 196     /**
 197      * Region state
</pre>
<hr />
<pre>
 229 
 230     protected Map&lt;String, Widget&gt; builtinWidgets;
 231     protected Map&lt;String, Widget&gt; widgets;
 232 
 233     protected int count;
 234     protected int mult;
 235     protected int universal = 4;
 236     protected int repeatCount;
 237     protected boolean isArgDigit;
 238 
 239     protected ParsedLine parsedLine;
 240 
 241     protected boolean skipRedisplay;
 242     protected Display display;
 243 
 244     protected boolean overTyping = false;
 245 
 246     protected String keyMap;
 247 
 248     protected int smallTerminalOffset = 0;
<span class="line-removed"> 249 </span>
 250     /*
 251      * accept-and-infer-next-history, accept-and-hold &amp; accept-line-and-down-history
 252      */
 253     protected boolean nextCommandFromHistory = false;
 254     protected int nextHistoryId = -1;
 255 




 256 
 257     public LineReaderImpl(Terminal terminal) throws IOException {
 258         this(terminal, null, null);
 259     }
 260 
 261     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 262         this(terminal, appName, null);
 263     }
 264 
 265     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 266         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 267         this.terminal = terminal;
 268         if (appName == null) {
 269             appName = &quot;JLine&quot;;
 270         }
 271         this.appName = appName;
 272         if (variables != null) {
 273             this.variables = variables;
 274         } else {
 275             this.variables = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
 296 
 297     public KeyMap&lt;Binding&gt; getKeys() {
 298         return keyMaps.get(keyMap);
 299     }
 300 
 301     @Override
 302     public Map&lt;String, Widget&gt; getWidgets() {
 303         return widgets;
 304     }
 305 
 306     @Override
 307     public Map&lt;String, Widget&gt; getBuiltinWidgets() {
 308         return Collections.unmodifiableMap(builtinWidgets);
 309     }
 310 
 311     @Override
 312     public Buffer getBuffer() {
 313         return buf;
 314     }
 315 




















 316     @Override
 317     public void runMacro(String macro) {
 318         bindingReader.runMacro(macro);
 319     }
 320 
 321     @Override
 322     public MouseEvent readMouseEvent() {
 323         return terminal.readMouseEvent(bindingReader::readCharacter);
 324     }
 325 
 326     /**
 327      * Set the completer.
 328      *
 329      * @param completer the completer to use
 330      */
 331     public void setCompleter(Completer completer) {
 332         this.completer = completer;
 333     }
 334 
 335     /**
</pre>
<hr />
<pre>
 454      * @return            A line that is read from the terminal, can never be null.
 455      */
 456     public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 457         return readLine(prompt, rightPrompt, mask != null ? new SimpleMaskingCallback(mask) : null, buffer);
 458     }
 459 
 460     /**
 461      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 462      * (without any trailing newlines).
 463      *
 464      * @param prompt          The prompt to issue to the terminal, may be null.
 465      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 466      * @param maskingCallback The callback used to mask parts of the edited line.
 467      * @param buffer          A string that will be set for editing.
 468      * @return                A line that is read from the terminal, can never be null.
 469      */
 470     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 471         // prompt may be null
 472         // maskingCallback may be null
 473         // buffer may be null


























 474 
 475         if (!startedReading.compareAndSet(false, true)) {
 476             throw new IllegalStateException();
 477         }
 478 
 479         Thread readLineThread = Thread.currentThread();
 480         SignalHandler previousIntrHandler = null;
 481         SignalHandler previousWinchHandler = null;
 482         SignalHandler previousContHandler = null;
 483         Attributes originalAttributes = null;
 484         boolean dumb = isTerminalDumb();
 485         try {
 486 
 487             this.maskingCallback = maskingCallback;
 488 
 489             /*
 490              * This is the accumulator for VI-mode repeat count. That is, while in
 491              * move mode, if you type 30x it will delete 30 characters. This is
 492              * where the &quot;30&quot; is accumulated until the command is struck.
 493              */
</pre>
<hr />
<pre>
 581                     throw new EndOfFileException();
 582                 }
 583 
 584                 // If this is still false after handling the binding, then
 585                 // we reset our repeatCount to 0.
 586                 isArgDigit = false;
 587                 // Every command that can be repeated a specified number
 588                 // of times, needs to know how many times to repeat, so
 589                 // we figure that out here.
 590                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 591                 // Reset undo/redo flag
 592                 isUndo = false;
 593                 // Reset region after a paste
 594                 if (regionActive == RegionType.PASTE) {
 595                     regionActive = RegionType.NONE;
 596                 }
 597 
 598                 try {
 599                     lock.lock();
 600                     // Get executable widget
<span class="line-modified"> 601                     Buffer copy = buf.copy();</span>
 602                     Widget w = getWidget(o);
 603                     if (!w.apply()) {
 604                         beep();
 605                     }
<span class="line-modified"> 606                     if (!isUndo &amp;&amp; !copy.toString().equals(buf.toString())) {</span>

 607                         undo.newState(buf.copy());
 608                     }
 609 
 610                     switch (state) {
 611                         case DONE:
 612                             return finishBuffer();


 613                         case EOF:
 614                             throw new EndOfFileException();
 615                         case INTERRUPT:
 616                             throw new UserInterruptException(buf.toString());
 617                     }
 618 
 619                     if (!isArgDigit) {
 620                         /*
 621                          * If the operation performed wasn&#39;t a vi argument
 622                          * digit, then clear out the current repeatCount;
 623                          */
 624                         repeatCount = 0;
 625                         mult = 1;
 626                     }
 627 
 628                     if (!dumb) {
 629                         redisplay();
 630                     }
 631                 } finally {
 632                     lock.unlock();
</pre>
<hr />
<pre>
 648                 cleanup();
 649                 if (originalAttributes != null) {
 650                     terminal.setAttributes(originalAttributes);
 651                 }
 652                 if (previousIntrHandler != null) {
 653                     terminal.handle(Signal.INT, previousIntrHandler);
 654                 }
 655                 if (previousWinchHandler != null) {
 656                     terminal.handle(Signal.WINCH, previousWinchHandler);
 657                 }
 658                 if (previousContHandler != null) {
 659                     terminal.handle(Signal.CONT, previousContHandler);
 660                 }
 661             } finally {
 662                 lock.unlock();
 663             }
 664             startedReading.set(false);
 665         }
 666     }
 667 
<span class="line-modified"> 668     private boolean isTerminalDumb(){</span>
 669         return Terminal.TYPE_DUMB.equals(terminal.getType())
 670                 || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());
 671     }
 672 
<span class="line-modified"> 673     private void doDisplay(){</span>
 674         // Cache terminal size for the duration of the call to readLine()
 675         // It will eventually be updated with WINCH signals
 676         size.copy(terminal.getBufferSize());
 677 
 678         display = new Display(terminal, false);
 679         if (size.getRows() == 0 || size.getColumns() == 0) {
 680             display.resize(1, Integer.MAX_VALUE);
 681         } else {
 682             display.resize(size.getRows(), size.getColumns());
 683         }
 684         if (isSet(Option.DELAY_LINE_WRAP))
 685             display.setDelayLineWrap(true);
 686     }
 687 
 688     @Override
 689     public void printAbove(String str) {
 690         try {
 691             lock.lock();
 692 
 693             boolean reading = this.reading;
</pre>
<hr />
<pre>
 832         }
 833     }
 834 
 835     public int peekCharacter(long timeout) {
 836         return bindingReader.peekCharacter(timeout);
 837     }
 838 
 839     protected &lt;T&gt; T doReadBinding(KeyMap&lt;T&gt; keys, KeyMap&lt;T&gt; local) {
 840         if (lock.isHeldByCurrentThread()) {
 841             try {
 842                 lock.unlock();
 843                 return bindingReader.readBinding(keys, local);
 844             } finally {
 845                 lock.lock();
 846             }
 847         } else {
 848             return bindingReader.readBinding(keys, local);
 849         }
 850     }
 851 













 852     /**
 853      * Read from the input stream and decode an operation from the key map.
 854      *
 855      * The input stream will be read character by character until a matching
 856      * binding can be found.  Characters that can&#39;t possibly be matched to
 857      * any binding will be discarded.
 858      *
 859      * @param keys the KeyMap to use for decoding the input stream
 860      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 861      *         stream has been reached
 862      */
 863     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 864         return readBinding(keys, null);
 865     }
 866 
 867     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
 868         Binding o = doReadBinding(keys, local);
 869         /*
 870          * The kill ring keeps record of whether or not the
 871          * previous command was a yank or a kill. We reset
 872          * that state here if needed.
 873          */
 874         if (o instanceof Reference) {
 875             String ref = ((Reference) o).name();
 876             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 877                 killRing.resetLastYank();
 878             }
 879             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 880                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 881                 killRing.resetLastKill();
 882             }
 883         }
 884         return o;
 885     }
 886 
 887     @Override
 888     public ParsedLine getParsedLine() {
 889         return parsedLine;
 890     }
 891 

 892     public String getLastBinding() {
 893         return bindingReader.getLastBinding();
 894     }
 895 

 896     public String getSearchTerm() {
 897         return searchTerm != null ? searchTerm.toString() : null;
 898     }
 899 
 900     @Override
 901     public RegionType getRegionActive() {
 902         return regionActive;
 903     }
 904 
 905     @Override
 906     public int getRegionMark() {
 907         return regionMark;
 908     }
 909 
 910     //
 911     // Key Bindings
 912     //
 913 
 914     /**
 915      * Sets the current keymap by name. Supported keymaps are &quot;emacs&quot;,
</pre>
<hr />
<pre>
 966         options.put(option, value);
 967         return this;
 968     }
 969 
 970     @Override
 971     public boolean isSet(Option option) {
 972         Boolean b = options.get(option);
 973         return b != null ? b : option.isDef();
 974     }
 975 
 976     @Override
 977     public void setOpt(Option option) {
 978         options.put(option, Boolean.TRUE);
 979     }
 980 
 981     @Override
 982     public void unsetOpt(Option option) {
 983         options.put(option, Boolean.FALSE);
 984     }
 985 




 986 















 987 
 988     //
 989     // Widget implementation
 990     //
 991 
 992     /**
 993      * Clear the buffer and add its contents to the history.
 994      *
 995      * @return the former contents of the buffer.
 996      */
 997     protected String finishBuffer() {
<span class="line-modified"> 998         String str = buf.toString();</span>



 999         String historyLine = str;
1000 
1001         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
1002             StringBuilder sb = new StringBuilder();
1003             boolean escaped = false;
1004             for (int i = 0; i &lt; str.length(); i++) {
1005                 char ch = str.charAt(i);
1006                 if (escaped) {
1007                     escaped = false;
1008                     if (ch != &#39;\n&#39;) {
1009                         sb.append(ch);
1010                     }
1011                 } else if (parser.isEscapeChar(ch)) {
1012                     escaped = true;
1013                 } else {
1014                     sb.append(ch);
1015                 }
1016             }
1017             str = sb.toString();
1018         }
1019 
1020         if (maskingCallback != null) {
1021             historyLine = maskingCallback.history(historyLine);
1022         }
1023 
1024         // we only add it to the history if the buffer is not empty
1025         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
1026             history.add(Instant.now(), historyLine);
1027         }
1028         return str;
1029     }
1030 
1031     protected void handleSignal(Signal signal) {

1032         if (signal == Signal.WINCH) {
1033             Status status = Status.getStatus(terminal, false);
1034             if (status != null) {
1035                 status.hardReset();
1036             }
1037             size.copy(terminal.getBufferSize());
1038             display.resize(size.getRows(), size.getColumns());
<span class="line-modified">1039             redrawLine();</span>

1040             redisplay();
1041         }
1042         else if (signal == Signal.CONT) {
1043             terminal.enterRawMode();
1044             size.copy(terminal.getBufferSize());
1045             display.resize(size.getRows(), size.getColumns());
1046             terminal.puts(Capability.keypad_xmit);
1047             redrawLine();
1048             redisplay();
1049         }
1050     }
1051 
1052     @SuppressWarnings(&quot;unchecked&quot;)
1053     protected Widget getWidget(Object binding) {
1054         Widget w;
1055         if (binding instanceof Widget) {
1056             w = (Widget) binding;
1057         } else if (binding instanceof Macro) {
1058             String macro = ((Macro) binding).getSequence();
1059             w = () -&gt; {
</pre>
<hr />
<pre>
2055         }
2056     }
2057 
2058     protected boolean insertCloseCurly() {
2059         return insertClose(&quot;}&quot;);
2060     }
2061 
2062     protected boolean insertCloseParen() {
2063         return insertClose(&quot;)&quot;);
2064     }
2065 
2066     protected boolean insertCloseSquare() {
2067         return insertClose(&quot;]&quot;);
2068     }
2069 
2070     protected boolean insertClose(String s) {
2071         putString(s);
2072 
2073         long blink = getLong(BLINK_MATCHING_PAREN, DEFAULT_BLINK_MATCHING_PAREN);
2074         if (blink &lt;= 0) {

2075             return true;
2076         }
2077 
2078         int closePosition = buf.cursor();
2079 
2080         buf.move(-1);
2081         doViMatchBracket();
2082         redisplay();
2083 
2084         peekCharacter(blink);
<span class="line-modified">2085 </span>
2086         buf.cursor(closePosition);




2087         return true;
2088     }
2089 

















2090     protected boolean viMatchBracket() {
2091         return doViMatchBracket();
2092     }
2093 
2094     protected boolean undefinedKey() {
2095         return false;
2096     }
2097 
2098     /**
2099      * Implements vi style bracket matching (&quot;%&quot; command). The matching
2100      * bracket for the current bracket type that you are sitting on is matched.
2101      *
2102      * @return true if it worked, false if the cursor was not on a bracket
2103      *   character or if there was no matching bracket.
2104      */
2105     protected boolean doViMatchBracket() {
2106         int pos        = buf.cursor();
2107 
2108         if (pos == buf.length()) {
2109             return false;
</pre>
<hr />
<pre>
2407     */
2408 
2409     protected void cleanup() {
2410         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
2411             Buffer oldBuffer = buf.copy();
2412             AttributedString oldPrompt = prompt;
2413             buf.clear();
2414             prompt = new AttributedString(&quot;&quot;);
2415             doCleanup(false);
2416             prompt = oldPrompt;
2417             buf.copyFrom(oldBuffer);
2418         } else {
2419             doCleanup(true);
2420         }
2421     }
2422 
2423     protected void doCleanup(boolean nl) {
2424         buf.cursor(buf.length());
2425         post = null;
2426         if (size.getColumns() &gt; 0 || size.getRows() &gt; 0) {

2427             redisplay(false);
2428             if (nl) {
2429                 println();
2430             }
2431             terminal.puts(Capability.keypad_local);
2432             terminal.trackMouse(Terminal.MouseTracking.Off);
2433             if (isSet(Option.BRACKETED_PASTE))
2434                 terminal.writer().write(BRACKETED_PASTE_OFF);
2435             flush();
2436         }
2437         history.moveToEnd();
2438     }
2439 
2440     protected boolean historyIncrementalSearchForward() {
2441         return doSearchHistory(false);
2442     }
2443 
2444     protected boolean historyIncrementalSearchBackward() {
2445         return doSearchHistory(true);
2446     }
</pre>
<hr />
<pre>
2818             nextCommandFromHistory = true;
2819         }
2820         return nextCommandFromHistory;
2821     }
2822 
2823     protected boolean acceptAndInferNextHistory() {
2824         nextCommandFromHistory = false;
2825         acceptLine();
2826         if (!buf.toString().isEmpty()) {
2827             nextHistoryId = searchBackwards(buf.toString(), history.last());
2828             if (nextHistoryId &gt;= 0 &amp;&amp; history.size() &gt; nextHistoryId + 1) {
2829                 nextHistoryId++;
2830                 nextCommandFromHistory = true;
2831             }
2832         }
2833         return nextCommandFromHistory;
2834     }
2835 
2836     protected boolean acceptLine() {
2837         parsedLine = null;

2838         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2839             try {
2840                 String str = buf.toString();
2841                 String exp = expander.expandHistory(history, str);
2842                 if (!exp.equals(str)) {
2843                     buf.clear();
2844                     buf.write(exp);
2845                     if (isSet(Option.HISTORY_VERIFY)) {
2846                         return true;
2847                     }
2848                 }
2849             } catch (IllegalArgumentException e) {
2850                 // Ignore
2851             }
2852         }
2853         try {

2854             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2855         } catch (EOFError e) {
<span class="line-modified">2856             buf.write(&quot;\n&quot;);</span>









2857             return true;
2858         } catch (SyntaxError e) {
2859             // do nothing
2860         }
2861         callWidget(CALLBACK_FINISH);
2862         state = State.DONE;
2863         return true;
2864     }
2865 







2866     protected boolean selfInsert() {
2867         for (int count = this.count; count &gt; 0; count--) {
2868             putString(getLastBinding());
2869         }
2870         return true;
2871     }
2872 
2873     protected boolean selfInsertUnmeta() {
2874         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
2875             String s = getLastBinding().substring(1);
2876             if (&quot;\r&quot;.equals(s)) {
2877                 s = &quot;\n&quot;;
2878             }
2879             for (int count = this.count; count &gt; 0; count--) {
2880                 putString(s);
2881             }
2882             return true;
2883         } else {
2884             return false;
2885         }
</pre>
<hr />
<pre>
3447                 sb.append(&quot;)&quot;);
3448             } else {
3449                 sb.append(&quot;EOF&quot;);
3450             }
3451             sb.append(&quot;   &quot;);
3452             sb.append(&quot;point &quot;);
3453             sb.append(Integer.toString(buf.cursor() + 1));
3454             sb.append(&quot; of &quot;);
3455             sb.append(Integer.toString(buf.length() + 1));
3456             sb.append(&quot; (&quot;);
3457             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3458             sb.append(&quot;%)&quot;);
3459             sb.append(&quot;   &quot;);
3460             sb.append(&quot;column &quot;);
3461             sb.append(Integer.toString(buf.cursor() - findbol()));
3462             return sb.toAttributedString();
3463         };
3464         return true;
3465     }
3466 





















3467     protected Map&lt;String, Widget&gt; builtinWidgets() {
3468         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
3469         addBuiltinWidget(widgets, ACCEPT_AND_INFER_NEXT_HISTORY, this::acceptAndInferNextHistory);
3470         addBuiltinWidget(widgets, ACCEPT_AND_HOLD, this::acceptAndHold);
3471         addBuiltinWidget(widgets, ACCEPT_LINE, this::acceptLine);
3472         addBuiltinWidget(widgets, ACCEPT_LINE_AND_DOWN_HISTORY, this::acceptLineAndDownHistory);
3473         addBuiltinWidget(widgets, ARGUMENT_BASE, this::argumentBase);
3474         addBuiltinWidget(widgets, BACKWARD_CHAR, this::backwardChar);
3475         addBuiltinWidget(widgets, BACKWARD_DELETE_CHAR, this::backwardDeleteChar);
3476         addBuiltinWidget(widgets, BACKWARD_DELETE_WORD, this::backwardDeleteWord);
3477         addBuiltinWidget(widgets, BACKWARD_KILL_LINE, this::backwardKillLine);
3478         addBuiltinWidget(widgets, BACKWARD_KILL_WORD, this::backwardKillWord);
3479         addBuiltinWidget(widgets, BACKWARD_WORD, this::backwardWord);
3480         addBuiltinWidget(widgets, BEEP, this::beep);
3481         addBuiltinWidget(widgets, BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);
3482         addBuiltinWidget(widgets, BEGINNING_OF_HISTORY, this::beginningOfHistory);
3483         addBuiltinWidget(widgets, BEGINNING_OF_LINE, this::beginningOfLine);
3484         addBuiltinWidget(widgets, BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);
3485         addBuiltinWidget(widgets, CAPITALIZE_WORD, this::capitalizeWord);
3486         addBuiltinWidget(widgets, CLEAR, this::clear);
3487         addBuiltinWidget(widgets, CLEAR_SCREEN, this::clearScreen);
3488         addBuiltinWidget(widgets, COMPLETE_PREFIX, this::completePrefix);
3489         addBuiltinWidget(widgets, COMPLETE_WORD, this::completeWord);
3490         addBuiltinWidget(widgets, COPY_PREV_WORD, this::copyPrevWord);
3491         addBuiltinWidget(widgets, COPY_REGION_AS_KILL, this::copyRegionAsKill);
3492         addBuiltinWidget(widgets, DELETE_CHAR, this::deleteChar);
3493         addBuiltinWidget(widgets, DELETE_CHAR_OR_LIST, this::deleteCharOrList);
3494         addBuiltinWidget(widgets, DELETE_WORD, this::deleteWord);
3495         addBuiltinWidget(widgets, DIGIT_ARGUMENT, this::digitArgument);
3496         addBuiltinWidget(widgets, DO_LOWERCASE_VERSION, this::doLowercaseVersion);
3497         addBuiltinWidget(widgets, DOWN_CASE_WORD, this::downCaseWord);
3498         addBuiltinWidget(widgets, DOWN_LINE, this::downLine);
3499         addBuiltinWidget(widgets, DOWN_LINE_OR_HISTORY, this::downLineOrHistory);
3500         addBuiltinWidget(widgets, DOWN_LINE_OR_SEARCH, this::downLineOrSearch);
3501         addBuiltinWidget(widgets, DOWN_HISTORY, this::downHistory);

3502         addBuiltinWidget(widgets, EMACS_EDITING_MODE, this::emacsEditingMode);
3503         addBuiltinWidget(widgets, EMACS_BACKWARD_WORD, this::emacsBackwardWord);
3504         addBuiltinWidget(widgets, EMACS_FORWARD_WORD, this::emacsForwardWord);
3505         addBuiltinWidget(widgets, END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);
3506         addBuiltinWidget(widgets, END_OF_HISTORY, this::endOfHistory);
3507         addBuiltinWidget(widgets, END_OF_LINE, this::endOfLine);
3508         addBuiltinWidget(widgets, END_OF_LINE_HIST, this::endOfLineHist);
3509         addBuiltinWidget(widgets, EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);
3510         addBuiltinWidget(widgets, EXPAND_HISTORY, this::expandHistory);
3511         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE, this::expandOrComplete);
3512         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);
3513         addBuiltinWidget(widgets, EXPAND_WORD, this::expandWord);
3514         addBuiltinWidget(widgets, FRESH_LINE, this::freshLine);
3515         addBuiltinWidget(widgets, FORWARD_CHAR, this::forwardChar);
3516         addBuiltinWidget(widgets, FORWARD_WORD, this::forwardWord);
3517         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);
3518         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);
3519         addBuiltinWidget(widgets, HISTORY_SEARCH_BACKWARD, this::historySearchBackward);
3520         addBuiltinWidget(widgets, HISTORY_SEARCH_FORWARD, this::historySearchForward);
3521         addBuiltinWidget(widgets, INSERT_CLOSE_CURLY, this::insertCloseCurly);
</pre>
<hr />
<pre>
3599         addBuiltinWidget(widgets, VI_REPLACE_CHARS, this::viReplaceChars);
3600         addBuiltinWidget(widgets, VI_REV_REPEAT_FIND, this::viRevRepeatFind);
3601         addBuiltinWidget(widgets, VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);
3602         addBuiltinWidget(widgets, VI_SWAP_CASE, this::viSwapCase);
3603         addBuiltinWidget(widgets, VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);
3604         addBuiltinWidget(widgets, VI_YANK, this::viYankTo);
3605         addBuiltinWidget(widgets, VI_YANK_WHOLE_LINE, this::viYankWholeLine);
3606         addBuiltinWidget(widgets, VISUAL_LINE_MODE, this::visualLineMode);
3607         addBuiltinWidget(widgets, VISUAL_MODE, this::visualMode);
3608         addBuiltinWidget(widgets, WHAT_CURSOR_POSITION, this::whatCursorPosition);
3609         addBuiltinWidget(widgets, YANK, this::yank);
3610         addBuiltinWidget(widgets, YANK_POP, this::yankPop);
3611         addBuiltinWidget(widgets, MOUSE, this::mouse);
3612         addBuiltinWidget(widgets, BEGIN_PASTE, this::beginPaste);
3613         addBuiltinWidget(widgets, FOCUS_IN, this::focusIn);
3614         addBuiltinWidget(widgets, FOCUS_OUT, this::focusOut);
3615         return widgets;
3616     }
3617 
3618     private void addBuiltinWidget(Map&lt;String, Widget&gt; widgets, String name, Widget widget) {
<span class="line-modified">3619         widgets.put(name, namedWidget(name, widget));</span>
3620     }
3621 
3622     private Widget namedWidget(String name, Widget widget) {
3623         return new Widget() {
3624             @Override
3625             public String toString() {
3626                 return name;
3627             }
3628             @Override
3629             public boolean apply() {
3630                 return widget.apply();
3631             }
3632         };
3633     }
3634 
3635     public boolean redisplay() {
3636         redisplay(true);
3637         return true;
3638     }
3639 
</pre>
<hr />
<pre>
3774                 newLinesToDisplay = newLines;
3775             }
3776             display.update(newLinesToDisplay, cursorPos, flush);
3777         } finally {
3778             lock.unlock();
3779         }
3780     }
3781 
3782     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3783         if (lines.size() &gt; 1) {
3784             for (int i = 0; i &lt; lines.size() - 1; i++) {
3785                 sb.append(lines.get(i));
3786                 sb.style(sb.style().inverse());
3787                 sb.append(&quot;\\n&quot;);
3788                 sb.style(sb.style().inverseOff());
3789             }
3790         }
3791         sb.append(lines.get(lines.size() - 1));
3792     }
3793 
































3794     /**
3795      * Compute the full string to be displayed with the left, right and secondary prompts
3796      * @param secondaryPrompts a list to store the secondary prompts
3797      * @return the displayed string including the buffer, left prompts and the help below
3798      */
3799     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
3800         AttributedString attBuf = getHighlightedBuffer(buf.toString());
3801 
3802         AttributedString tNewBuf = insertSecondaryPrompts(attBuf, secondaryPrompts);
3803         AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);
3804         full.append(prompt);
3805         full.append(tNewBuf);








































3806         if (post != null) {
3807             full.append(&quot;\n&quot;);
3808             full.append(post.get());
3809         }

3810         return full.toAttributedString();
3811     }
3812 
3813     private AttributedString getHighlightedBuffer(String buffer) {
3814         if (maskingCallback != null) {
3815             buffer = maskingCallback.display(buffer);
3816         }
<span class="line-modified">3817         if (highlighter != null &amp;&amp; !isSet(Option.DISABLE_HIGHLIGHTER)) {</span>

3818             return highlighter.highlight(this, buffer);
3819         }
3820         return new AttributedString(buffer);
3821     }
3822 
3823     private AttributedString expandPromptPattern(String pattern, int padToWidth,
3824                                                  String message, int line) {
3825         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
3826         boolean isHidden = false;
3827         int padPartIndex = -1;
3828         StringBuilder padPartString = null;
3829         StringBuilder sb = new StringBuilder();
3830         // Add &quot;%{&quot; to avoid special case for end of string.
3831         pattern = pattern + &quot;%{&quot;;
3832         int plen = pattern.length();
3833         int padChar = -1;
3834         int padPos = -1;
3835         int cols = 0;
3836         for (int i = 0; i &lt; plen; ) {
3837             char ch = pattern.charAt(i++);
</pre>
<hr />
<pre>
3919         if (padToWidth &gt; cols) {
3920             int padCharCols = WCWidth.wcwidth(padChar);
3921             int padCount = (padToWidth - cols) / padCharCols;
3922             sb = padPartString;
3923             while (--padCount &gt;= 0)
3924                 sb.insert(padPos, (char) padChar); // FIXME if wide
3925             parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));
3926         }
3927         return AttributedString.join(null, parts);
3928     }
3929 
3930     private AttributedString insertSecondaryPrompts(AttributedString str, List&lt;AttributedString&gt; prompts) {
3931         return insertSecondaryPrompts(str, prompts, true);
3932     }
3933 
3934     private AttributedString insertSecondaryPrompts(AttributedString strAtt, List&lt;AttributedString&gt; prompts, boolean computePrompts) {
3935         Objects.requireNonNull(prompts);
3936         List&lt;AttributedString&gt; lines = strAtt.columnSplitLength(Integer.MAX_VALUE);
3937         AttributedStringBuilder sb = new AttributedStringBuilder();
3938         String secondaryPromptPattern = getString(SECONDARY_PROMPT_PATTERN, DEFAULT_SECONDARY_PROMPT_PATTERN);
<span class="line-modified">3939         boolean needsMessage = secondaryPromptPattern.contains(&quot;%M&quot;);</span>

3940         AttributedStringBuilder buf = new AttributedStringBuilder();
3941         int width = 0;
3942         List&lt;String&gt; missings = new ArrayList&lt;&gt;();
3943         if (computePrompts &amp;&amp; secondaryPromptPattern.contains(&quot;%P&quot;)) {
3944             width = prompt.columnLength();
3945             for (int line = 0; line &lt; lines.size() - 1; line++) {
3946                 AttributedString prompt;
3947                 buf.append(lines.get(line)).append(&quot;\n&quot;);
3948                 String missing = &quot;&quot;;
3949                 if (needsMessage) {
3950                     try {
3951                         parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
3952                     } catch (EOFError e) {
3953                         missing = e.getMissing();
3954                     } catch (SyntaxError e) {
3955                         // Ignore
3956                     }
3957                 }
3958                 missings.add(missing);
3959                 prompt = expandPromptPattern(secondaryPromptPattern, 0, missing, line + 1);
</pre>
<hr />
<pre>
4085         }
4086     }
4087 
4088     protected boolean menuExpandOrComplete() {
4089         if (insertTab()) {
4090             return selfInsert();
4091         } else {
4092             return doComplete(CompletionType.ExpandComplete, true, false);
4093         }
4094     }
4095 
4096     protected boolean completePrefix() {
4097         if (insertTab()) {
4098             return selfInsert();
4099         } else {
4100             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), true);
4101         }
4102     }
4103 
4104     protected boolean listChoices() {
<span class="line-modified">4105         return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);</span>




4106     }
4107 
4108     protected boolean deleteCharOrList() {
4109         if (buf.cursor() != buf.length() || buf.length() == 0) {
4110             return deleteChar();
4111         } else {
4112             return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
4113         }
4114     }
4115 
4116     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {




4117         // If completion is disabled, just bail out
4118         if (getBoolean(DISABLE_COMPLETION, false)) {
4119             return true;
4120         }
4121         // Try to expand history first
4122         // If there is actually an expansion, bail out now
4123         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
4124             try {
4125                 if (expandHistory()) {
4126                     return true;
4127                 }
4128             } catch (Exception e) {
4129                 Log.info(&quot;Error while expanding history&quot;, e);
4130                 return false;
4131             }
4132         }
4133 
4134         // Parse the command line
4135         CompletingParsedLine line;
4136         try {
</pre>
<hr />
<pre>
4195                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wp)),
4196                     typoMatcher(wp, errors, caseInsensitive)
4197             );
4198             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);
4199         } else if (isSet(Option.COMPLETE_IN_WORD)) {
4200             String wd = line.word();
4201             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4202             String wp = wdi.substring(0, line.wordCursor());
4203             String ws = wdi.substring(line.wordCursor());
4204             Pattern p1 = Pattern.compile(Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4205             Pattern p2 = Pattern.compile(&quot;.*&quot; + Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4206             matchers = Arrays.asList(
4207                     simpleMatcher(s -&gt; p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4208                     simpleMatcher(s -&gt; p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4209                     typoMatcher(wdi, errors, caseInsensitive)
4210             );
4211             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4212         } else {
4213             String wd = line.word();
4214             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
<span class="line-modified">4215             matchers = Arrays.asList(</span>
<span class="line-modified">4216                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),</span>
<span class="line-modified">4217                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),</span>
<span class="line-modified">4218                     typoMatcher(wdi, errors, caseInsensitive)</span>
<span class="line-modified">4219             );</span>






4220             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4221         }
4222         // Find matching candidates
4223         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4224         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4225                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4226             matching = matcher.apply(sortedCandidates);
4227             if (!matching.isEmpty()) {
4228                 break;
4229             }
4230         }
4231 
4232         // If we have no matches, bail out
4233         if (matching.isEmpty()) {
4234             return false;
4235         }
4236         size.copy(terminal.getSize());
4237         try {
4238             // If we only need to display the list, do it now
4239             if (lst == CompletionType.List) {
4240                 List&lt;Candidate&gt; possible = matching.entrySet().stream()
4241                         .flatMap(e -&gt; e.getValue().stream())
4242                         .collect(Collectors.toList());
<span class="line-modified">4243                 doList(possible, line.word(), false, line::escape);</span>
4244                 return !possible.isEmpty();
4245             }
4246 
4247             // Check if there&#39;s a single possible match
4248             Candidate completion = null;
4249             // If there&#39;s a single possible completion
4250             if (matching.size() == 1) {
4251                 completion = matching.values().stream().flatMap(Collection::stream)
4252                         .findFirst().orElse(null);
4253             }
4254             // Or if RECOGNIZE_EXACT is set, try to find an exact match
4255             else if (isSet(Option.RECOGNIZE_EXACT)) {
4256                 completion = matching.values().stream().flatMap(Collection::stream)
4257                         .filter(Candidate::complete)
4258                         .filter(c -&gt; exact.test(c.value()))
4259                         .findFirst().orElse(null);
4260             }
4261             // Complete and exit
4262             if (completion != null &amp;&amp; !completion.value().isEmpty()) {
4263                 if (prefix) {
</pre>
<hr />
<pre>
4306 
4307             // Find current word and move to end
4308             String current;
4309             if (prefix) {
4310                 current = line.word().substring(0, line.wordCursor());
4311             } else {
4312                 current = line.word();
4313                 buf.move(line.rawWordLength() - line.rawWordCursor());
4314             }
4315             // Now, we need to find the unambiguous completion
4316             // TODO: need to find common suffix
4317             String commonPrefix = null;
4318             for (String key : matching.keySet()) {
4319                 commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);
4320             }
4321             boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);
4322 
4323             if (hasUnambiguous) {
4324                 buf.backspace(line.rawWordLength());
4325                 buf.write(line.escape(commonPrefix, false));

4326                 current = commonPrefix;
4327                 if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))
4328                         || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {
4329                     if (!nextBindingIsComplete()) {
4330                         return true;
4331                     }
4332                 }
4333             }
4334             if (isSet(Option.AUTO_LIST)) {
4335                 if (!doList(possible, current, true, line::escape)) {
4336                     return true;
4337                 }
4338             }
4339             if (isSet(Option.AUTO_MENU)) {
4340                 buf.backspace(current.length());
4341                 doMenu(possible, line.word(), line::escape);
4342             }
4343             return true;
4344         } finally {
4345             size.copy(terminal.getBufferSize());
</pre>
<hr />
<pre>
4370                     return line.cursor();
4371                 }
4372                 public CharSequence escape(CharSequence candidate, boolean complete) {
4373                     return candidate;
4374                 }
4375                 public int rawWordCursor() {
4376                     return wordCursor();
4377                 }
4378                 public int rawWordLength() {
4379                     return word().length();
4380                 }
4381             };
4382         }
4383     }
4384 
4385     protected Comparator&lt;Candidate&gt; getCandidateComparator(boolean caseInsensitive, String word) {
4386         String wdi = caseInsensitive ? word.toLowerCase() : word;
4387         ToIntFunction&lt;String&gt; wordDistance = w -&gt; distance(wdi, caseInsensitive ? w.toLowerCase() : w);
4388         return Comparator
4389                 .comparing(Candidate::value, Comparator.comparingInt(wordDistance))
<span class="line-removed">4390                 .thenComparing(Candidate::value, Comparator.comparingInt(String::length))</span>
4391                 .thenComparing(Comparator.naturalOrder());
4392     }
4393 
4394     protected String getOthersGroupName() {
4395         return getString(OTHERS_GROUP_NAME, DEFAULT_OTHERS_GROUP_NAME);
4396     }
4397 
4398     protected String getOriginalGroupName() {
4399         return getString(ORIGINAL_GROUP_NAME, DEFAULT_ORIGINAL_GROUP_NAME);
4400     }
4401 
4402 
4403     protected Comparator&lt;String&gt; getGroupComparator() {
4404         return Comparator.&lt;String&gt;comparingInt(s -&gt; getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)
4405                 .thenComparing(String::toLowerCase, Comparator.naturalOrder());
4406     }
4407 
4408     private void mergeCandidates(List&lt;Candidate&gt; possible) {
4409         // Merge candidates if the have the same key
4410         Map&lt;String, List&lt;Candidate&gt;&gt; keyedCandidates = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
4579             }
4580         }
4581 
4582         public void right() {
4583             if (isSet(Option.LIST_ROWS_FIRST)) {
4584                 minor(1);
4585             } else {
4586                 major(1);
4587             }
4588         }
4589 
4590         private void update() {
4591             buf.backspace(word.length());
4592             word = escaper.apply(completion().value(), true).toString();
4593             buf.write(word);
4594 
4595             // Compute displayed prompt
4596             PostResult pr = computePost(possible, completion(), null, completed);
4597             AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4598             int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
<span class="line-modified">4599             if (pr.lines &gt; size.getRows() - promptLines) {</span>
<span class="line-modified">4600                 int displayed = size.getRows() - promptLines - 1;</span>


4601                 if (pr.selectedLine &gt;= 0) {
4602                     if (pr.selectedLine &lt; topLine) {
4603                         topLine = pr.selectedLine;
4604                     } else if (pr.selectedLine &gt;= topLine + displayed) {
4605                         topLine = pr.selectedLine - displayed + 1;
4606                     }
4607                 }
4608                 AttributedString post = pr.post;
4609                 if (post.length() &gt; 0 &amp;&amp; post.charAt(post.length() - 1) != &#39;\n&#39;) {
4610                     post = new AttributedStringBuilder(post.length() + 1)
4611                             .append(post).append(&quot;\n&quot;).toAttributedString();
4612                 }
4613                 List&lt;AttributedString&gt; lines = post.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
4614                 List&lt;AttributedString&gt; sub = new ArrayList&lt;&gt;(lines.subList(topLine, topLine + displayed));
4615                 sub.add(new AttributedStringBuilder()
4616                         .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))
4617                         .append(&quot;rows &quot;)
4618                         .append(Integer.toString(topLine + 1))
4619                         .append(&quot; to &quot;)
4620                         .append(Integer.toString(topLine + displayed))
</pre>
<hr />
<pre>
4631         }
4632 
4633         @Override
4634         public AttributedString get() {
4635             return computed;
4636         }
4637 
4638     }
4639 
4640     protected boolean doMenu(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4641         // Reorder candidates according to display order
4642         final List&lt;Candidate&gt; possible = new ArrayList&lt;&gt;();
4643         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4644         original.sort(getCandidateComparator(caseInsensitive, completed));
4645         mergeCandidates(original);
4646         computePost(original, null, possible, completed);
4647 
4648         // Build menu support
4649         MenuSupport menuSupport = new MenuSupport(original, completed, escaper);
4650         post = menuSupport;
<span class="line-modified">4651         redisplay();</span>
4652 
4653         // Loop
4654         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4655         Binding operation;
4656         while ((operation = readBinding(getKeys(), keyMap)) != null) {
4657             String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
4658             switch (ref) {
4659                 case MENU_COMPLETE:
4660                     menuSupport.next();
4661                     break;
4662                 case REVERSE_MENU_COMPLETE:
4663                     menuSupport.previous();
4664                     break;
4665                 case UP_LINE_OR_HISTORY:
4666                 case UP_LINE_OR_SEARCH:
4667                     menuSupport.up();
4668                     break;
4669                 case DOWN_LINE_OR_HISTORY:
4670                 case DOWN_LINE_OR_SEARCH:
4671                     menuSupport.down();
</pre>
<hr />
<pre>
4687                                 &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4688                                 || BACKWARD_DELETE_CHAR.equals(ref)) {
4689                             buf.backspace(completion.suffix().length());
4690                         }
4691                     }
4692                     if (completion.complete()
4693                             &amp;&amp; getLastBinding().charAt(0) != &#39; &#39;
4694                             &amp;&amp; (SELF_INSERT.equals(ref) || getLastBinding().charAt(0) != &#39; &#39;)) {
4695                         buf.write(&#39; &#39;);
4696                     }
4697                     if (!ACCEPT_LINE.equals(ref)
4698                             &amp;&amp; !(SELF_INSERT.equals(ref)
4699                                 &amp;&amp; completion.suffix() != null
4700                                 &amp;&amp; completion.suffix().startsWith(getLastBinding()))) {
4701                         pushBackBinding(true);
4702                     }
4703                     post = null;
4704                     return true;
4705                 }
4706             }
<span class="line-modified">4707             redisplay();</span>

4708         }
4709         return false;
4710     }
4711 
<span class="line-modified">4712     protected boolean doList(List&lt;Candidate&gt; possible, String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {</span>











4713         // If we list only and if there&#39;s a big
4714         // number of items, we should ask the user
4715         // for confirmation, display the list
4716         // and redraw the line at the bottom
4717         mergeCandidates(possible);
4718         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4719         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4720         PostResult postResult = computePost(possible, null, null, completed);
4721         int lines = postResult.lines;
4722         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4723         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4724                 || lines &gt;= size.getRows() - promptLines) {
<span class="line-modified">4725             // prompt</span>
<span class="line-modified">4726             post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see all &quot; + possible.size()</span>
<span class="line-modified">4727                     + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);</span>
<span class="line-modified">4728             redisplay(true);</span>
<span class="line-modified">4729             int c = readCharacter();</span>
<span class="line-modified">4730             if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {</span>
<span class="line-modified">4731                 post = null;</span>




4732                 return false;
4733             }
4734         }
4735 
4736         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4737         StringBuilder sb = new StringBuilder();
4738         while (true) {
4739             String current = completed + sb.toString();
4740             List&lt;Candidate&gt; cands;
4741             if (sb.length() &gt; 0) {
4742                 cands = possible.stream()
4743                         .filter(c -&gt; caseInsensitive
4744                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
4745                                     : c.value().startsWith(current))
4746                         .sorted(getCandidateComparator(caseInsensitive, current))
4747                         .collect(Collectors.toList());
4748             } else {
4749                 cands = possible.stream()
4750                         .sorted(getCandidateComparator(caseInsensitive, current))
4751                         .collect(Collectors.toList());
</pre>
<hr />
<pre>
4772             };
4773             if (!runLoop) {
4774                 return false;
4775             }
4776             redisplay();
4777             // TODO: use a different keyMap ?
4778             Binding b = doReadBinding(getKeys(), null);
4779             if (b instanceof Reference) {
4780                 String name = ((Reference) b).name();
4781                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
4782                     if (sb.length() == 0) {
4783                         pushBackBinding();
4784                         post = null;
4785                         return false;
4786                     } else {
4787                         sb.setLength(sb.length() - 1);
4788                         buf.backspace();
4789                     }
4790                 } else if (SELF_INSERT.equals(name)) {
4791                     sb.append(getLastBinding());
<span class="line-modified">4792                     buf.write(getLastBinding());</span>
4793                     if (cands.isEmpty()) {
4794                         post = null;
4795                         return false;
4796                     }
4797                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
4798                     if (cands.size() == 1 || sb.length() &gt; 0) {
4799                         post = null;
4800                         pushBackBinding();
4801                     } else if (isSet(Option.AUTO_MENU)) {
4802                         buf.backspace(escaper.apply(current, false).length());
4803                         doMenu(cands, current, escaper);
4804                     }
4805                     return false;
4806                 } else {
4807                     pushBackBinding();
4808                     post = null;
4809                     return false;
4810                 }
4811             } else if (b == null) {
4812                 post = null;
</pre>
<hr />
<pre>
5353 
5354             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
5355             getDisplayedBufferWithPrompts(secondaryPrompts);
5356 
5357             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
5358             sb.append(prompt);
5359             sb.append(insertSecondaryPrompts(new AttributedString(buf.upToCursor()), secondaryPrompts, false));
5360             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
5361 
5362             int currentLine = promptLines.size() - 1;
5363             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5364             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5365             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5366             int adjust = pl1 - pl0;
5367             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5368         }
5369         return true;
5370     }
5371 
5372     public boolean beginPaste() {
<span class="line-modified">5373         final Object SELF_INSERT = new Object();</span>
<span class="line-removed">5374         final Object END_PASTE = new Object();</span>
<span class="line-removed">5375         KeyMap&lt;Object&gt; keyMap = new KeyMap&lt;&gt;();</span>
<span class="line-removed">5376         keyMap.setUnicode(SELF_INSERT);</span>
<span class="line-removed">5377         keyMap.setNomatch(SELF_INSERT);</span>
<span class="line-removed">5378         keyMap.setAmbiguousTimeout(0);</span>
<span class="line-removed">5379         keyMap.bind(END_PASTE, BRACKETED_PASTE_END);</span>
<span class="line-removed">5380         StringBuilder sb = new StringBuilder();</span>
<span class="line-removed">5381         while (true) {</span>
<span class="line-removed">5382             Object b = doReadBinding(keyMap, null);</span>
<span class="line-removed">5383             if (b == END_PASTE) {</span>
<span class="line-removed">5384                 break;</span>
<span class="line-removed">5385             }</span>
<span class="line-removed">5386             String s = getLastBinding();</span>
<span class="line-removed">5387             if (&quot;\r&quot;.equals(s)) {</span>
<span class="line-removed">5388                 s = &quot;\n&quot;;</span>
<span class="line-removed">5389             }</span>
<span class="line-removed">5390             sb.append(s);</span>
<span class="line-removed">5391         }</span>
5392         regionActive = RegionType.PASTE;
5393         regionMark = getBuffer().cursor();
<span class="line-modified">5394         getBuffer().write(sb);</span>
5395         return true;
5396     }
5397 
5398     public boolean focusIn() {
5399         return false;
5400     }
5401 
5402     public boolean focusOut() {
5403         return false;
5404     }
5405 
5406     /**
5407      * Clean the used display
5408      * @return &lt;code&gt;true&lt;/code&gt;
5409      */
5410     public boolean clear() {
5411         display.update(Collections.emptyList(), 0);
5412         return true;
5413     }
5414 
</pre>
<hr />
<pre>
5570         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5571         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
5572         bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl(&#39;O&#39;));
5573         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5574         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5575         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5576         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5577         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5578         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5579         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5580         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5581         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5582         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5583         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5584         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5585         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5586         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5587         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5588         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5589         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));

5590         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5591         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5592         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
5593         bind(emacs, INFER_NEXT_HISTORY,                     translate(&quot;^X^N&quot;));
5594         bind(emacs, OVERWRITE_MODE,                         translate(&quot;^X^O&quot;));
5595         bind(emacs, REDO,                                   translate(&quot;^X^R&quot;));
5596         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5597         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5598         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5599         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5600         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5601         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5602         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5603         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5604         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5605         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5606         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5607         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5608         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5609         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
</pre>
<hr />
<pre>
5870         if (attr != null) {
5871             rebind(keyMap, BACKWARD_DELETE_CHAR,
5872                     del(), (char) attr.getControlChar(ControlChar.VERASE));
5873             rebind(keyMap, BACKWARD_KILL_WORD,
5874                     ctrl(&#39;W&#39;),  (char) attr.getControlChar(ControlChar.VWERASE));
5875             rebind(keyMap, KILL_WHOLE_LINE,
5876                     ctrl(&#39;U&#39;), (char) attr.getControlChar(ControlChar.VKILL));
5877             rebind(keyMap, QUOTED_INSERT,
5878                     ctrl(&#39;V&#39;), (char) attr.getControlChar(ControlChar.VLNEXT));
5879         }
5880     }
5881 
5882     private void rebind(KeyMap&lt;Binding&gt; keyMap, String operation, String prevBinding, char newBinding) {
5883         if (newBinding &gt; 0 &amp;&amp; newBinding &lt; 128) {
5884             Reference ref = new Reference(operation);
5885             bind(keyMap, SELF_INSERT, prevBinding);
5886             keyMap.bind(ref, Character.toString(newBinding));
5887         }
5888     }
5889 
<span class="line-removed">5890 </span>
5891 }
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2002-2020, the original author or authors.</span>
   3  *
   4  * This software is distributable under the BSD license. See the terms of the
   5  * BSD license in the documentation provided with this software.
   6  *
   7  * https://opensource.org/licenses/BSD-3-Clause
   8  */
   9 package jdk.internal.org.jline.reader.impl;
  10 
<span class="line-added">  11 import java.io.BufferedReader;</span>
<span class="line-added">  12 import java.io.File;</span>
<span class="line-added">  13 import java.io.FileReader;</span>
<span class="line-added">  14 import java.io.FileWriter;</span>
  15 import java.io.Flushable;
  16 import java.io.IOError;
  17 import java.io.IOException;
  18 import java.io.InputStream;
  19 import java.io.InterruptedIOException;
<span class="line-added">  20 import java.lang.reflect.Constructor;</span>
  21 import java.time.Instant;
  22 import java.util.*;
  23 import java.util.Map.Entry;
  24 import java.util.concurrent.atomic.AtomicBoolean;

  25 import java.util.concurrent.locks.ReentrantLock;
  26 import java.util.function.*;
  27 import java.util.regex.Matcher;
  28 import java.util.regex.Pattern;
  29 import java.util.stream.Collectors;
  30 import java.util.stream.Stream;
  31 import java.util.stream.StreamSupport;
  32 
  33 import jdk.internal.org.jline.keymap.BindingReader;
  34 import jdk.internal.org.jline.keymap.KeyMap;
  35 import jdk.internal.org.jline.reader.*;
  36 import jdk.internal.org.jline.reader.Parser.ParseContext;
  37 import jdk.internal.org.jline.reader.impl.history.DefaultHistory;
  38 import jdk.internal.org.jline.terminal.*;
  39 import jdk.internal.org.jline.terminal.Attributes.ControlChar;
  40 import jdk.internal.org.jline.terminal.Terminal.Signal;
  41 import jdk.internal.org.jline.terminal.Terminal.SignalHandler;
  42 import jdk.internal.org.jline.terminal.impl.AbstractWindowsTerminal;
  43 import jdk.internal.org.jline.utils.AttributedString;
  44 import jdk.internal.org.jline.utils.AttributedStringBuilder;
</pre>
<hr />
<pre>
  73 
  74     public static final int TAB_WIDTH = 4;
  75 
  76 
  77     public static final String DEFAULT_WORDCHARS = &quot;*?_-.[]~=/&amp;;!#$%^(){}&lt;&gt;&quot;;
  78     public static final String DEFAULT_REMOVE_SUFFIX_CHARS = &quot; \t\n;&amp;|&quot;;
  79     public static final String DEFAULT_COMMENT_BEGIN = &quot;#&quot;;
  80     public static final String DEFAULT_SEARCH_TERMINATORS = &quot;\033\012&quot;;
  81     public static final String DEFAULT_BELL_STYLE = &quot;&quot;;
  82     public static final int    DEFAULT_LIST_MAX = 100;
  83     public static final int    DEFAULT_ERRORS = 2;
  84     public static final long   DEFAULT_BLINK_MATCHING_PAREN = 500L;
  85     public static final long   DEFAULT_AMBIGUOUS_BINDING = 1000L;
  86     public static final String DEFAULT_SECONDARY_PROMPT_PATTERN = &quot;%M&gt; &quot;;
  87     public static final String DEFAULT_OTHERS_GROUP_NAME = &quot;others&quot;;
  88     public static final String DEFAULT_ORIGINAL_GROUP_NAME = &quot;original&quot;;
  89     public static final String DEFAULT_COMPLETION_STYLE_STARTING = &quot;36&quot;;    // cyan
  90     public static final String DEFAULT_COMPLETION_STYLE_DESCRIPTION = &quot;90&quot;; // dark gray
  91     public static final String DEFAULT_COMPLETION_STYLE_GROUP = &quot;35;1&quot;;     // magenta
  92     public static final String DEFAULT_COMPLETION_STYLE_SELECTION = &quot;7&quot;;    // inverted
<span class="line-added">  93     public static final int    DEFAULT_INDENTATION = 0;</span>
<span class="line-added">  94     public static final int    DEFAULT_FEATURES_MAX_BUFFER_SIZE = 1000;</span>
  95 
  96     private static final int MIN_ROWS = 3;
  97 
  98     public static final String BRACKETED_PASTE_ON = &quot;\033[?2004h&quot;;
  99     public static final String BRACKETED_PASTE_OFF = &quot;\033[?2004l&quot;;
 100     public static final String BRACKETED_PASTE_BEGIN = &quot;\033[200~&quot;;
 101     public static final String BRACKETED_PASTE_END = &quot;\033[201~&quot;;
 102 
 103     public static final String FOCUS_IN_SEQ = &quot;\033[I&quot;;
 104     public static final String FOCUS_OUT_SEQ = &quot;\033[O&quot;;
 105 
 106     /**
 107      * Possible states in which the current readline operation may be in.
 108      */
 109     protected enum State {
 110         /**
 111          * The user is just typing away
 112          */
 113         NORMAL,
 114         /**
 115          * readLine should exit and return the buffer content
 116          */
 117         DONE,
<span class="line-added"> 118         /**</span>
<span class="line-added"> 119          * readLine should exit and return empty String</span>
<span class="line-added"> 120          */</span>
<span class="line-added"> 121         IGNORE,</span>
 122         /**
 123          * readLine should exit and throw an EOFException
 124          */
 125         EOF,
 126         /**
 127          * readLine should exit and throw an UserInterruptException
 128          */
 129         INTERRUPT
 130     }
 131 
 132     protected enum ViMoveMode {
 133         NORMAL,
 134         YANK,
 135         DELETE,
 136         CHANGE
 137     }
 138 
 139     protected enum BellType {
 140         NONE,
 141         AUDIBLE,
</pre>
<hr />
<pre>
 153     /** The terminal keys mapping */
 154     protected final Map&lt;String, KeyMap&lt;Binding&gt;&gt; keyMaps;
 155 
 156     //
 157     // Configuration
 158     //
 159     protected final Map&lt;String, Object&gt; variables;
 160     protected History history = new DefaultHistory();
 161     protected Completer completer = null;
 162     protected Highlighter highlighter = new DefaultHighlighter();
 163     protected Parser parser = new DefaultParser();
 164     protected Expander expander = new DefaultExpander();
 165 
 166     //
 167     // State variables
 168     //
 169 
 170     protected final Map&lt;Option, Boolean&gt; options = new HashMap&lt;&gt;();
 171 
 172     protected final Buffer buf = new BufferImpl();
<span class="line-added"> 173     protected String tailTip = &quot;&quot;;</span>
<span class="line-added"> 174     protected SuggestionType autosuggestion = SuggestionType.NONE;</span>
 175 
 176     protected final Size size = new Size();
 177 
 178     protected AttributedString prompt = AttributedString.EMPTY;
 179     protected AttributedString rightPrompt = AttributedString.EMPTY;
 180 
 181     protected MaskingCallback maskingCallback;
 182 
 183     protected Map&lt;Integer, String&gt; modifiedHistory = new HashMap&lt;&gt;();
 184     protected Buffer historyBuffer = null;
 185     protected CharSequence searchBuffer;
 186     protected StringBuffer searchTerm = null;
 187     protected boolean searchFailing;
 188     protected boolean searchBackward;
 189     protected int searchIndex = -1;
<span class="line-added"> 190     protected boolean doAutosuggestion;</span>
 191 
 192 
 193     // Reading buffers
 194     protected final BindingReader bindingReader;
 195 
 196 
 197     /**
 198      * VI character find
 199      */
 200     protected int findChar;
 201     protected int findDir;
 202     protected int findTailAdd;
 203     /**
 204      * VI history string search
 205      */
 206     private int searchDir;
 207     private String searchString;
 208 
 209     /**
 210      * Region state
</pre>
<hr />
<pre>
 242 
 243     protected Map&lt;String, Widget&gt; builtinWidgets;
 244     protected Map&lt;String, Widget&gt; widgets;
 245 
 246     protected int count;
 247     protected int mult;
 248     protected int universal = 4;
 249     protected int repeatCount;
 250     protected boolean isArgDigit;
 251 
 252     protected ParsedLine parsedLine;
 253 
 254     protected boolean skipRedisplay;
 255     protected Display display;
 256 
 257     protected boolean overTyping = false;
 258 
 259     protected String keyMap;
 260 
 261     protected int smallTerminalOffset = 0;

 262     /*
 263      * accept-and-infer-next-history, accept-and-hold &amp; accept-line-and-down-history
 264      */
 265     protected boolean nextCommandFromHistory = false;
 266     protected int nextHistoryId = -1;
 267 
<span class="line-added"> 268     /*</span>
<span class="line-added"> 269      * execute commands from commandsBuffer</span>
<span class="line-added"> 270      */</span>
<span class="line-added"> 271     protected List&lt;String&gt; commandsBuffer = new ArrayList&lt;&gt;();</span>
 272 
 273     public LineReaderImpl(Terminal terminal) throws IOException {
 274         this(terminal, null, null);
 275     }
 276 
 277     public LineReaderImpl(Terminal terminal, String appName) throws IOException {
 278         this(terminal, appName, null);
 279     }
 280 
 281     public LineReaderImpl(Terminal terminal, String appName, Map&lt;String, Object&gt; variables) {
 282         Objects.requireNonNull(terminal, &quot;terminal can not be null&quot;);
 283         this.terminal = terminal;
 284         if (appName == null) {
 285             appName = &quot;JLine&quot;;
 286         }
 287         this.appName = appName;
 288         if (variables != null) {
 289             this.variables = variables;
 290         } else {
 291             this.variables = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
 312 
 313     public KeyMap&lt;Binding&gt; getKeys() {
 314         return keyMaps.get(keyMap);
 315     }
 316 
 317     @Override
 318     public Map&lt;String, Widget&gt; getWidgets() {
 319         return widgets;
 320     }
 321 
 322     @Override
 323     public Map&lt;String, Widget&gt; getBuiltinWidgets() {
 324         return Collections.unmodifiableMap(builtinWidgets);
 325     }
 326 
 327     @Override
 328     public Buffer getBuffer() {
 329         return buf;
 330     }
 331 
<span class="line-added"> 332     @Override</span>
<span class="line-added"> 333     public void setAutosuggestion(SuggestionType type) {</span>
<span class="line-added"> 334         this.autosuggestion = type;</span>
<span class="line-added"> 335     }</span>
<span class="line-added"> 336 </span>
<span class="line-added"> 337     @Override</span>
<span class="line-added"> 338     public SuggestionType getAutosuggestion() {</span>
<span class="line-added"> 339         return autosuggestion;</span>
<span class="line-added"> 340     }</span>
<span class="line-added"> 341 </span>
<span class="line-added"> 342     @Override</span>
<span class="line-added"> 343     public String getTailTip() {</span>
<span class="line-added"> 344         return tailTip;</span>
<span class="line-added"> 345     }</span>
<span class="line-added"> 346 </span>
<span class="line-added"> 347     @Override</span>
<span class="line-added"> 348     public void setTailTip(String tailTip) {</span>
<span class="line-added"> 349         this.tailTip = tailTip;</span>
<span class="line-added"> 350     }</span>
<span class="line-added"> 351 </span>
 352     @Override
 353     public void runMacro(String macro) {
 354         bindingReader.runMacro(macro);
 355     }
 356 
 357     @Override
 358     public MouseEvent readMouseEvent() {
 359         return terminal.readMouseEvent(bindingReader::readCharacter);
 360     }
 361 
 362     /**
 363      * Set the completer.
 364      *
 365      * @param completer the completer to use
 366      */
 367     public void setCompleter(Completer completer) {
 368         this.completer = completer;
 369     }
 370 
 371     /**
</pre>
<hr />
<pre>
 490      * @return            A line that is read from the terminal, can never be null.
 491      */
 492     public String readLine(String prompt, String rightPrompt, Character mask, String buffer) throws UserInterruptException, EndOfFileException {
 493         return readLine(prompt, rightPrompt, mask != null ? new SimpleMaskingCallback(mask) : null, buffer);
 494     }
 495 
 496     /**
 497      * Read a line from the &lt;i&gt;in&lt;/i&gt; {@link InputStream}, and return the line
 498      * (without any trailing newlines).
 499      *
 500      * @param prompt          The prompt to issue to the terminal, may be null.
 501      * @param rightPrompt     The prompt to issue to the right of the terminal, may be null.
 502      * @param maskingCallback The callback used to mask parts of the edited line.
 503      * @param buffer          A string that will be set for editing.
 504      * @return                A line that is read from the terminal, can never be null.
 505      */
 506     public String readLine(String prompt, String rightPrompt, MaskingCallback maskingCallback, String buffer) throws UserInterruptException, EndOfFileException {
 507         // prompt may be null
 508         // maskingCallback may be null
 509         // buffer may be null
<span class="line-added"> 510         if (!commandsBuffer.isEmpty()) {</span>
<span class="line-added"> 511             String cmd = commandsBuffer.remove(0);</span>
<span class="line-added"> 512             boolean done = false;</span>
<span class="line-added"> 513             do {</span>
<span class="line-added"> 514                 try {</span>
<span class="line-added"> 515                     parser.parse(cmd, cmd.length() + 1, ParseContext.ACCEPT_LINE);</span>
<span class="line-added"> 516                     done = true;</span>
<span class="line-added"> 517                 } catch (EOFError e) {</span>
<span class="line-added"> 518                     if (commandsBuffer.isEmpty()) {</span>
<span class="line-added"> 519                         throw new IllegalArgumentException(&quot;Incompleted command: \n&quot; + cmd);</span>
<span class="line-added"> 520                     }</span>
<span class="line-added"> 521                     cmd += &quot;\n&quot;;</span>
<span class="line-added"> 522                     cmd += commandsBuffer.remove(0);</span>
<span class="line-added"> 523                 } catch (SyntaxError e) {</span>
<span class="line-added"> 524                     done = true;</span>
<span class="line-added"> 525                 } catch (Exception e) {</span>
<span class="line-added"> 526                     commandsBuffer.clear();</span>
<span class="line-added"> 527                     throw new IllegalArgumentException(e.getMessage());</span>
<span class="line-added"> 528                 }</span>
<span class="line-added"> 529             } while (!done);</span>
<span class="line-added"> 530             AttributedStringBuilder sb = new AttributedStringBuilder();</span>
<span class="line-added"> 531             sb.styled(AttributedStyle::bold, cmd);</span>
<span class="line-added"> 532             sb.toAttributedString().println(terminal);</span>
<span class="line-added"> 533             terminal.flush();</span>
<span class="line-added"> 534             return finish(cmd);</span>
<span class="line-added"> 535         }</span>
 536 
 537         if (!startedReading.compareAndSet(false, true)) {
 538             throw new IllegalStateException();
 539         }
 540 
 541         Thread readLineThread = Thread.currentThread();
 542         SignalHandler previousIntrHandler = null;
 543         SignalHandler previousWinchHandler = null;
 544         SignalHandler previousContHandler = null;
 545         Attributes originalAttributes = null;
 546         boolean dumb = isTerminalDumb();
 547         try {
 548 
 549             this.maskingCallback = maskingCallback;
 550 
 551             /*
 552              * This is the accumulator for VI-mode repeat count. That is, while in
 553              * move mode, if you type 30x it will delete 30 characters. This is
 554              * where the &quot;30&quot; is accumulated until the command is struck.
 555              */
</pre>
<hr />
<pre>
 643                     throw new EndOfFileException();
 644                 }
 645 
 646                 // If this is still false after handling the binding, then
 647                 // we reset our repeatCount to 0.
 648                 isArgDigit = false;
 649                 // Every command that can be repeated a specified number
 650                 // of times, needs to know how many times to repeat, so
 651                 // we figure that out here.
 652                 count = ((repeatCount == 0) ? 1 : repeatCount) * mult;
 653                 // Reset undo/redo flag
 654                 isUndo = false;
 655                 // Reset region after a paste
 656                 if (regionActive == RegionType.PASTE) {
 657                     regionActive = RegionType.NONE;
 658                 }
 659 
 660                 try {
 661                     lock.lock();
 662                     // Get executable widget
<span class="line-modified"> 663                     Buffer copy = buf.length() &lt;= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE) ? buf.copy() : null;</span>
 664                     Widget w = getWidget(o);
 665                     if (!w.apply()) {
 666                         beep();
 667                     }
<span class="line-modified"> 668                     if (!isUndo &amp;&amp; copy != null &amp;&amp; buf.length() &lt;= getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)</span>
<span class="line-added"> 669                             &amp;&amp; !copy.toString().equals(buf.toString())) {</span>
 670                         undo.newState(buf.copy());
 671                     }
 672 
 673                     switch (state) {
 674                         case DONE:
 675                             return finishBuffer();
<span class="line-added"> 676                         case IGNORE:</span>
<span class="line-added"> 677                             return &quot;&quot;;</span>
 678                         case EOF:
 679                             throw new EndOfFileException();
 680                         case INTERRUPT:
 681                             throw new UserInterruptException(buf.toString());
 682                     }
 683 
 684                     if (!isArgDigit) {
 685                         /*
 686                          * If the operation performed wasn&#39;t a vi argument
 687                          * digit, then clear out the current repeatCount;
 688                          */
 689                         repeatCount = 0;
 690                         mult = 1;
 691                     }
 692 
 693                     if (!dumb) {
 694                         redisplay();
 695                     }
 696                 } finally {
 697                     lock.unlock();
</pre>
<hr />
<pre>
 713                 cleanup();
 714                 if (originalAttributes != null) {
 715                     terminal.setAttributes(originalAttributes);
 716                 }
 717                 if (previousIntrHandler != null) {
 718                     terminal.handle(Signal.INT, previousIntrHandler);
 719                 }
 720                 if (previousWinchHandler != null) {
 721                     terminal.handle(Signal.WINCH, previousWinchHandler);
 722                 }
 723                 if (previousContHandler != null) {
 724                     terminal.handle(Signal.CONT, previousContHandler);
 725                 }
 726             } finally {
 727                 lock.unlock();
 728             }
 729             startedReading.set(false);
 730         }
 731     }
 732 
<span class="line-modified"> 733     private boolean isTerminalDumb() {</span>
 734         return Terminal.TYPE_DUMB.equals(terminal.getType())
 735                 || Terminal.TYPE_DUMB_COLOR.equals(terminal.getType());
 736     }
 737 
<span class="line-modified"> 738     private void doDisplay() {</span>
 739         // Cache terminal size for the duration of the call to readLine()
 740         // It will eventually be updated with WINCH signals
 741         size.copy(terminal.getBufferSize());
 742 
 743         display = new Display(terminal, false);
 744         if (size.getRows() == 0 || size.getColumns() == 0) {
 745             display.resize(1, Integer.MAX_VALUE);
 746         } else {
 747             display.resize(size.getRows(), size.getColumns());
 748         }
 749         if (isSet(Option.DELAY_LINE_WRAP))
 750             display.setDelayLineWrap(true);
 751     }
 752 
 753     @Override
 754     public void printAbove(String str) {
 755         try {
 756             lock.lock();
 757 
 758             boolean reading = this.reading;
</pre>
<hr />
<pre>
 897         }
 898     }
 899 
 900     public int peekCharacter(long timeout) {
 901         return bindingReader.peekCharacter(timeout);
 902     }
 903 
 904     protected &lt;T&gt; T doReadBinding(KeyMap&lt;T&gt; keys, KeyMap&lt;T&gt; local) {
 905         if (lock.isHeldByCurrentThread()) {
 906             try {
 907                 lock.unlock();
 908                 return bindingReader.readBinding(keys, local);
 909             } finally {
 910                 lock.lock();
 911             }
 912         } else {
 913             return bindingReader.readBinding(keys, local);
 914         }
 915     }
 916 
<span class="line-added"> 917     protected String doReadStringUntil(String sequence) {</span>
<span class="line-added"> 918         if (lock.isHeldByCurrentThread()) {</span>
<span class="line-added"> 919             try {</span>
<span class="line-added"> 920                 lock.unlock();</span>
<span class="line-added"> 921                 return bindingReader.readStringUntil(sequence);</span>
<span class="line-added"> 922             } finally {</span>
<span class="line-added"> 923                 lock.lock();</span>
<span class="line-added"> 924             }</span>
<span class="line-added"> 925         } else {</span>
<span class="line-added"> 926             return bindingReader.readStringUntil(sequence);</span>
<span class="line-added"> 927         }</span>
<span class="line-added"> 928     }</span>
<span class="line-added"> 929 </span>
 930     /**
 931      * Read from the input stream and decode an operation from the key map.
 932      *
 933      * The input stream will be read character by character until a matching
 934      * binding can be found.  Characters that can&#39;t possibly be matched to
 935      * any binding will be discarded.
 936      *
 937      * @param keys the KeyMap to use for decoding the input stream
 938      * @return the decoded binding or &lt;code&gt;null&lt;/code&gt; if the end of
 939      *         stream has been reached
 940      */
 941     public Binding readBinding(KeyMap&lt;Binding&gt; keys) {
 942         return readBinding(keys, null);
 943     }
 944 
 945     public Binding readBinding(KeyMap&lt;Binding&gt; keys, KeyMap&lt;Binding&gt; local) {
 946         Binding o = doReadBinding(keys, local);
 947         /*
 948          * The kill ring keeps record of whether or not the
 949          * previous command was a yank or a kill. We reset
 950          * that state here if needed.
 951          */
 952         if (o instanceof Reference) {
 953             String ref = ((Reference) o).name();
 954             if (!YANK_POP.equals(ref) &amp;&amp; !YANK.equals(ref)) {
 955                 killRing.resetLastYank();
 956             }
 957             if (!KILL_LINE.equals(ref) &amp;&amp; !KILL_WHOLE_LINE.equals(ref)
 958                     &amp;&amp; !BACKWARD_KILL_WORD.equals(ref) &amp;&amp; !KILL_WORD.equals(ref)) {
 959                 killRing.resetLastKill();
 960             }
 961         }
 962         return o;
 963     }
 964 
 965     @Override
 966     public ParsedLine getParsedLine() {
 967         return parsedLine;
 968     }
 969 
<span class="line-added"> 970     @Override</span>
 971     public String getLastBinding() {
 972         return bindingReader.getLastBinding();
 973     }
 974 
<span class="line-added"> 975     @Override</span>
 976     public String getSearchTerm() {
 977         return searchTerm != null ? searchTerm.toString() : null;
 978     }
 979 
 980     @Override
 981     public RegionType getRegionActive() {
 982         return regionActive;
 983     }
 984 
 985     @Override
 986     public int getRegionMark() {
 987         return regionMark;
 988     }
 989 
 990     //
 991     // Key Bindings
 992     //
 993 
 994     /**
 995      * Sets the current keymap by name. Supported keymaps are &quot;emacs&quot;,
</pre>
<hr />
<pre>
1046         options.put(option, value);
1047         return this;
1048     }
1049 
1050     @Override
1051     public boolean isSet(Option option) {
1052         Boolean b = options.get(option);
1053         return b != null ? b : option.isDef();
1054     }
1055 
1056     @Override
1057     public void setOpt(Option option) {
1058         options.put(option, Boolean.TRUE);
1059     }
1060 
1061     @Override
1062     public void unsetOpt(Option option) {
1063         options.put(option, Boolean.FALSE);
1064     }
1065 
<span class="line-added">1066     @Override</span>
<span class="line-added">1067     public void addCommandsInBuffer(Collection&lt;String&gt; commands) {</span>
<span class="line-added">1068         commandsBuffer.addAll(commands);</span>
<span class="line-added">1069     }</span>
1070 
<span class="line-added">1071     @Override</span>
<span class="line-added">1072     public void editAndAddInBuffer(File file) throws Exception {</span>
<span class="line-added">1073         Constructor&lt;?&gt; ctor = Class.forName(&quot;org.jline.builtins.Nano&quot;).getConstructor(Terminal.class, File.class);</span>
<span class="line-added">1074         Editor editor = (Editor) ctor.newInstance(terminal, new File(file.getParent()));</span>
<span class="line-added">1075         editor.setRestricted(true);</span>
<span class="line-added">1076         editor.open(Arrays.asList(file.getName()));</span>
<span class="line-added">1077         editor.run();</span>
<span class="line-added">1078         BufferedReader br = new BufferedReader(new FileReader(file));</span>
<span class="line-added">1079         String line;</span>
<span class="line-added">1080         commandsBuffer.clear();</span>
<span class="line-added">1081         while ((line = br.readLine()) != null) {</span>
<span class="line-added">1082             commandsBuffer.add(line);</span>
<span class="line-added">1083         }</span>
<span class="line-added">1084         br.close();</span>
<span class="line-added">1085     }</span>
1086 
1087     //
1088     // Widget implementation
1089     //
1090 
1091     /**
1092      * Clear the buffer and add its contents to the history.
1093      *
1094      * @return the former contents of the buffer.
1095      */
1096     protected String finishBuffer() {
<span class="line-modified">1097         return finish(buf.toString());</span>
<span class="line-added">1098     }</span>
<span class="line-added">1099 </span>
<span class="line-added">1100     protected String finish(String str) {</span>
1101         String historyLine = str;
1102 
1103         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
1104             StringBuilder sb = new StringBuilder();
1105             boolean escaped = false;
1106             for (int i = 0; i &lt; str.length(); i++) {
1107                 char ch = str.charAt(i);
1108                 if (escaped) {
1109                     escaped = false;
1110                     if (ch != &#39;\n&#39;) {
1111                         sb.append(ch);
1112                     }
1113                 } else if (parser.isEscapeChar(ch)) {
1114                     escaped = true;
1115                 } else {
1116                     sb.append(ch);
1117                 }
1118             }
1119             str = sb.toString();
1120         }
1121 
1122         if (maskingCallback != null) {
1123             historyLine = maskingCallback.history(historyLine);
1124         }
1125 
1126         // we only add it to the history if the buffer is not empty
1127         if (historyLine != null &amp;&amp; historyLine.length() &gt; 0 ) {
1128             history.add(Instant.now(), historyLine);
1129         }
1130         return str;
1131     }
1132 
1133     protected void handleSignal(Signal signal) {
<span class="line-added">1134         doAutosuggestion = false;</span>
1135         if (signal == Signal.WINCH) {
1136             Status status = Status.getStatus(terminal, false);
1137             if (status != null) {
1138                 status.hardReset();
1139             }
1140             size.copy(terminal.getBufferSize());
1141             display.resize(size.getRows(), size.getColumns());
<span class="line-modified">1142             // restores prompt but also prevents scrolling in consoleZ, see #492</span>
<span class="line-added">1143             // redrawLine();</span>
1144             redisplay();
1145         }
1146         else if (signal == Signal.CONT) {
1147             terminal.enterRawMode();
1148             size.copy(terminal.getBufferSize());
1149             display.resize(size.getRows(), size.getColumns());
1150             terminal.puts(Capability.keypad_xmit);
1151             redrawLine();
1152             redisplay();
1153         }
1154     }
1155 
1156     @SuppressWarnings(&quot;unchecked&quot;)
1157     protected Widget getWidget(Object binding) {
1158         Widget w;
1159         if (binding instanceof Widget) {
1160             w = (Widget) binding;
1161         } else if (binding instanceof Macro) {
1162             String macro = ((Macro) binding).getSequence();
1163             w = () -&gt; {
</pre>
<hr />
<pre>
2159         }
2160     }
2161 
2162     protected boolean insertCloseCurly() {
2163         return insertClose(&quot;}&quot;);
2164     }
2165 
2166     protected boolean insertCloseParen() {
2167         return insertClose(&quot;)&quot;);
2168     }
2169 
2170     protected boolean insertCloseSquare() {
2171         return insertClose(&quot;]&quot;);
2172     }
2173 
2174     protected boolean insertClose(String s) {
2175         putString(s);
2176 
2177         long blink = getLong(BLINK_MATCHING_PAREN, DEFAULT_BLINK_MATCHING_PAREN);
2178         if (blink &lt;= 0) {
<span class="line-added">2179             removeIndentation();</span>
2180             return true;
2181         }
2182 
2183         int closePosition = buf.cursor();
2184 
2185         buf.move(-1);
2186         doViMatchBracket();
2187         redisplay();
2188 
2189         peekCharacter(blink);
<span class="line-modified">2190         int blinkPosition = buf.cursor();</span>
2191         buf.cursor(closePosition);
<span class="line-added">2192 </span>
<span class="line-added">2193         if (blinkPosition != closePosition - 1) {</span>
<span class="line-added">2194             removeIndentation();</span>
<span class="line-added">2195         }</span>
2196         return true;
2197     }
2198 
<span class="line-added">2199     private void removeIndentation() {</span>
<span class="line-added">2200         int indent = getInt(INDENTATION, DEFAULT_INDENTATION);</span>
<span class="line-added">2201         if (indent &gt; 0) {</span>
<span class="line-added">2202             buf.move(-1);</span>
<span class="line-added">2203             for (int i = 0; i &lt; indent; i++) {</span>
<span class="line-added">2204                 buf.move(-1);</span>
<span class="line-added">2205                 if (buf.currChar() == &#39; &#39;) {</span>
<span class="line-added">2206                     buf.delete();</span>
<span class="line-added">2207                 } else {</span>
<span class="line-added">2208                     buf.move(1);</span>
<span class="line-added">2209                     break;</span>
<span class="line-added">2210                 }</span>
<span class="line-added">2211             }</span>
<span class="line-added">2212             buf.move(1);</span>
<span class="line-added">2213         }</span>
<span class="line-added">2214     }</span>
<span class="line-added">2215 </span>
2216     protected boolean viMatchBracket() {
2217         return doViMatchBracket();
2218     }
2219 
2220     protected boolean undefinedKey() {
2221         return false;
2222     }
2223 
2224     /**
2225      * Implements vi style bracket matching (&quot;%&quot; command). The matching
2226      * bracket for the current bracket type that you are sitting on is matched.
2227      *
2228      * @return true if it worked, false if the cursor was not on a bracket
2229      *   character or if there was no matching bracket.
2230      */
2231     protected boolean doViMatchBracket() {
2232         int pos        = buf.cursor();
2233 
2234         if (pos == buf.length()) {
2235             return false;
</pre>
<hr />
<pre>
2533     */
2534 
2535     protected void cleanup() {
2536         if (isSet(Option.ERASE_LINE_ON_FINISH)) {
2537             Buffer oldBuffer = buf.copy();
2538             AttributedString oldPrompt = prompt;
2539             buf.clear();
2540             prompt = new AttributedString(&quot;&quot;);
2541             doCleanup(false);
2542             prompt = oldPrompt;
2543             buf.copyFrom(oldBuffer);
2544         } else {
2545             doCleanup(true);
2546         }
2547     }
2548 
2549     protected void doCleanup(boolean nl) {
2550         buf.cursor(buf.length());
2551         post = null;
2552         if (size.getColumns() &gt; 0 || size.getRows() &gt; 0) {
<span class="line-added">2553             doAutosuggestion = false;</span>
2554             redisplay(false);
2555             if (nl) {
2556                 println();
2557             }
2558             terminal.puts(Capability.keypad_local);
2559             terminal.trackMouse(Terminal.MouseTracking.Off);
2560             if (isSet(Option.BRACKETED_PASTE))
2561                 terminal.writer().write(BRACKETED_PASTE_OFF);
2562             flush();
2563         }
2564         history.moveToEnd();
2565     }
2566 
2567     protected boolean historyIncrementalSearchForward() {
2568         return doSearchHistory(false);
2569     }
2570 
2571     protected boolean historyIncrementalSearchBackward() {
2572         return doSearchHistory(true);
2573     }
</pre>
<hr />
<pre>
2945             nextCommandFromHistory = true;
2946         }
2947         return nextCommandFromHistory;
2948     }
2949 
2950     protected boolean acceptAndInferNextHistory() {
2951         nextCommandFromHistory = false;
2952         acceptLine();
2953         if (!buf.toString().isEmpty()) {
2954             nextHistoryId = searchBackwards(buf.toString(), history.last());
2955             if (nextHistoryId &gt;= 0 &amp;&amp; history.size() &gt; nextHistoryId + 1) {
2956                 nextHistoryId++;
2957                 nextCommandFromHistory = true;
2958             }
2959         }
2960         return nextCommandFromHistory;
2961     }
2962 
2963     protected boolean acceptLine() {
2964         parsedLine = null;
<span class="line-added">2965         int curPos = 0;</span>
2966         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
2967             try {
2968                 String str = buf.toString();
2969                 String exp = expander.expandHistory(history, str);
2970                 if (!exp.equals(str)) {
2971                     buf.clear();
2972                     buf.write(exp);
2973                     if (isSet(Option.HISTORY_VERIFY)) {
2974                         return true;
2975                     }
2976                 }
2977             } catch (IllegalArgumentException e) {
2978                 // Ignore
2979             }
2980         }
2981         try {
<span class="line-added">2982             curPos = buf.cursor();</span>
2983             parsedLine = parser.parse(buf.toString(), buf.cursor(), ParseContext.ACCEPT_LINE);
2984         } catch (EOFError e) {
<span class="line-modified">2985             StringBuilder sb = new StringBuilder(&quot;\n&quot;);</span>
<span class="line-added">2986             indention(e.getOpenBrackets(), sb);</span>
<span class="line-added">2987             int curMove = sb.length();</span>
<span class="line-added">2988             if (isSet(Option.INSERT_BRACKET) &amp;&amp; e.getOpenBrackets() &gt; 1 &amp;&amp; e.getNextClosingBracket() != null) {</span>
<span class="line-added">2989                 sb.append(&#39;\n&#39;);</span>
<span class="line-added">2990                 indention(e.getOpenBrackets() - 1, sb);</span>
<span class="line-added">2991                 sb.append(e.getNextClosingBracket());</span>
<span class="line-added">2992             }</span>
<span class="line-added">2993             buf.write(sb.toString());</span>
<span class="line-added">2994             buf.cursor(curPos + curMove);</span>
2995             return true;
2996         } catch (SyntaxError e) {
2997             // do nothing
2998         }
2999         callWidget(CALLBACK_FINISH);
3000         state = State.DONE;
3001         return true;
3002     }
3003 
<span class="line-added">3004     void indention(int nb, StringBuilder sb) {</span>
<span class="line-added">3005         int indent = getInt(INDENTATION, DEFAULT_INDENTATION)*nb;</span>
<span class="line-added">3006         for (int i = 0; i &lt; indent; i++) {</span>
<span class="line-added">3007             sb.append(&#39; &#39;);</span>
<span class="line-added">3008         }</span>
<span class="line-added">3009     }</span>
<span class="line-added">3010 </span>
3011     protected boolean selfInsert() {
3012         for (int count = this.count; count &gt; 0; count--) {
3013             putString(getLastBinding());
3014         }
3015         return true;
3016     }
3017 
3018     protected boolean selfInsertUnmeta() {
3019         if (getLastBinding().charAt(0) == &#39;\u001b&#39;) {
3020             String s = getLastBinding().substring(1);
3021             if (&quot;\r&quot;.equals(s)) {
3022                 s = &quot;\n&quot;;
3023             }
3024             for (int count = this.count; count &gt; 0; count--) {
3025                 putString(s);
3026             }
3027             return true;
3028         } else {
3029             return false;
3030         }
</pre>
<hr />
<pre>
3592                 sb.append(&quot;)&quot;);
3593             } else {
3594                 sb.append(&quot;EOF&quot;);
3595             }
3596             sb.append(&quot;   &quot;);
3597             sb.append(&quot;point &quot;);
3598             sb.append(Integer.toString(buf.cursor() + 1));
3599             sb.append(&quot; of &quot;);
3600             sb.append(Integer.toString(buf.length() + 1));
3601             sb.append(&quot; (&quot;);
3602             sb.append(Integer.toString(buf.length() == 0 ? 100 : ((100 * buf.cursor()) / buf.length())));
3603             sb.append(&quot;%)&quot;);
3604             sb.append(&quot;   &quot;);
3605             sb.append(&quot;column &quot;);
3606             sb.append(Integer.toString(buf.cursor() - findbol()));
3607             return sb.toAttributedString();
3608         };
3609         return true;
3610     }
3611 
<span class="line-added">3612     protected boolean editAndExecute() {</span>
<span class="line-added">3613         boolean out = true;</span>
<span class="line-added">3614         File file = null;</span>
<span class="line-added">3615         try {</span>
<span class="line-added">3616             file = File.createTempFile(&quot;jline-execute-&quot;, null);</span>
<span class="line-added">3617             FileWriter writer = new FileWriter(file);</span>
<span class="line-added">3618             writer.write(buf.toString());</span>
<span class="line-added">3619             writer.close();</span>
<span class="line-added">3620             editAndAddInBuffer(file);</span>
<span class="line-added">3621         } catch (Exception e) {</span>
<span class="line-added">3622             e.printStackTrace(terminal.writer());</span>
<span class="line-added">3623             out = false;</span>
<span class="line-added">3624         } finally {</span>
<span class="line-added">3625             state = State.IGNORE;</span>
<span class="line-added">3626             if (file != null &amp;&amp; file.exists()) {</span>
<span class="line-added">3627                 file.delete();</span>
<span class="line-added">3628             }</span>
<span class="line-added">3629         }</span>
<span class="line-added">3630         return out;</span>
<span class="line-added">3631     }</span>
<span class="line-added">3632 </span>
3633     protected Map&lt;String, Widget&gt; builtinWidgets() {
3634         Map&lt;String, Widget&gt; widgets = new HashMap&lt;&gt;();
3635         addBuiltinWidget(widgets, ACCEPT_AND_INFER_NEXT_HISTORY, this::acceptAndInferNextHistory);
3636         addBuiltinWidget(widgets, ACCEPT_AND_HOLD, this::acceptAndHold);
3637         addBuiltinWidget(widgets, ACCEPT_LINE, this::acceptLine);
3638         addBuiltinWidget(widgets, ACCEPT_LINE_AND_DOWN_HISTORY, this::acceptLineAndDownHistory);
3639         addBuiltinWidget(widgets, ARGUMENT_BASE, this::argumentBase);
3640         addBuiltinWidget(widgets, BACKWARD_CHAR, this::backwardChar);
3641         addBuiltinWidget(widgets, BACKWARD_DELETE_CHAR, this::backwardDeleteChar);
3642         addBuiltinWidget(widgets, BACKWARD_DELETE_WORD, this::backwardDeleteWord);
3643         addBuiltinWidget(widgets, BACKWARD_KILL_LINE, this::backwardKillLine);
3644         addBuiltinWidget(widgets, BACKWARD_KILL_WORD, this::backwardKillWord);
3645         addBuiltinWidget(widgets, BACKWARD_WORD, this::backwardWord);
3646         addBuiltinWidget(widgets, BEEP, this::beep);
3647         addBuiltinWidget(widgets, BEGINNING_OF_BUFFER_OR_HISTORY, this::beginningOfBufferOrHistory);
3648         addBuiltinWidget(widgets, BEGINNING_OF_HISTORY, this::beginningOfHistory);
3649         addBuiltinWidget(widgets, BEGINNING_OF_LINE, this::beginningOfLine);
3650         addBuiltinWidget(widgets, BEGINNING_OF_LINE_HIST, this::beginningOfLineHist);
3651         addBuiltinWidget(widgets, CAPITALIZE_WORD, this::capitalizeWord);
3652         addBuiltinWidget(widgets, CLEAR, this::clear);
3653         addBuiltinWidget(widgets, CLEAR_SCREEN, this::clearScreen);
3654         addBuiltinWidget(widgets, COMPLETE_PREFIX, this::completePrefix);
3655         addBuiltinWidget(widgets, COMPLETE_WORD, this::completeWord);
3656         addBuiltinWidget(widgets, COPY_PREV_WORD, this::copyPrevWord);
3657         addBuiltinWidget(widgets, COPY_REGION_AS_KILL, this::copyRegionAsKill);
3658         addBuiltinWidget(widgets, DELETE_CHAR, this::deleteChar);
3659         addBuiltinWidget(widgets, DELETE_CHAR_OR_LIST, this::deleteCharOrList);
3660         addBuiltinWidget(widgets, DELETE_WORD, this::deleteWord);
3661         addBuiltinWidget(widgets, DIGIT_ARGUMENT, this::digitArgument);
3662         addBuiltinWidget(widgets, DO_LOWERCASE_VERSION, this::doLowercaseVersion);
3663         addBuiltinWidget(widgets, DOWN_CASE_WORD, this::downCaseWord);
3664         addBuiltinWidget(widgets, DOWN_LINE, this::downLine);
3665         addBuiltinWidget(widgets, DOWN_LINE_OR_HISTORY, this::downLineOrHistory);
3666         addBuiltinWidget(widgets, DOWN_LINE_OR_SEARCH, this::downLineOrSearch);
3667         addBuiltinWidget(widgets, DOWN_HISTORY, this::downHistory);
<span class="line-added">3668         addBuiltinWidget(widgets, EDIT_AND_EXECUTE_COMMAND, this::editAndExecute);</span>
3669         addBuiltinWidget(widgets, EMACS_EDITING_MODE, this::emacsEditingMode);
3670         addBuiltinWidget(widgets, EMACS_BACKWARD_WORD, this::emacsBackwardWord);
3671         addBuiltinWidget(widgets, EMACS_FORWARD_WORD, this::emacsForwardWord);
3672         addBuiltinWidget(widgets, END_OF_BUFFER_OR_HISTORY, this::endOfBufferOrHistory);
3673         addBuiltinWidget(widgets, END_OF_HISTORY, this::endOfHistory);
3674         addBuiltinWidget(widgets, END_OF_LINE, this::endOfLine);
3675         addBuiltinWidget(widgets, END_OF_LINE_HIST, this::endOfLineHist);
3676         addBuiltinWidget(widgets, EXCHANGE_POINT_AND_MARK, this::exchangePointAndMark);
3677         addBuiltinWidget(widgets, EXPAND_HISTORY, this::expandHistory);
3678         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE, this::expandOrComplete);
3679         addBuiltinWidget(widgets, EXPAND_OR_COMPLETE_PREFIX, this::expandOrCompletePrefix);
3680         addBuiltinWidget(widgets, EXPAND_WORD, this::expandWord);
3681         addBuiltinWidget(widgets, FRESH_LINE, this::freshLine);
3682         addBuiltinWidget(widgets, FORWARD_CHAR, this::forwardChar);
3683         addBuiltinWidget(widgets, FORWARD_WORD, this::forwardWord);
3684         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_BACKWARD, this::historyIncrementalSearchBackward);
3685         addBuiltinWidget(widgets, HISTORY_INCREMENTAL_SEARCH_FORWARD, this::historyIncrementalSearchForward);
3686         addBuiltinWidget(widgets, HISTORY_SEARCH_BACKWARD, this::historySearchBackward);
3687         addBuiltinWidget(widgets, HISTORY_SEARCH_FORWARD, this::historySearchForward);
3688         addBuiltinWidget(widgets, INSERT_CLOSE_CURLY, this::insertCloseCurly);
</pre>
<hr />
<pre>
3766         addBuiltinWidget(widgets, VI_REPLACE_CHARS, this::viReplaceChars);
3767         addBuiltinWidget(widgets, VI_REV_REPEAT_FIND, this::viRevRepeatFind);
3768         addBuiltinWidget(widgets, VI_REV_REPEAT_SEARCH, this::viRevRepeatSearch);
3769         addBuiltinWidget(widgets, VI_SWAP_CASE, this::viSwapCase);
3770         addBuiltinWidget(widgets, VI_UP_LINE_OR_HISTORY, this::viUpLineOrHistory);
3771         addBuiltinWidget(widgets, VI_YANK, this::viYankTo);
3772         addBuiltinWidget(widgets, VI_YANK_WHOLE_LINE, this::viYankWholeLine);
3773         addBuiltinWidget(widgets, VISUAL_LINE_MODE, this::visualLineMode);
3774         addBuiltinWidget(widgets, VISUAL_MODE, this::visualMode);
3775         addBuiltinWidget(widgets, WHAT_CURSOR_POSITION, this::whatCursorPosition);
3776         addBuiltinWidget(widgets, YANK, this::yank);
3777         addBuiltinWidget(widgets, YANK_POP, this::yankPop);
3778         addBuiltinWidget(widgets, MOUSE, this::mouse);
3779         addBuiltinWidget(widgets, BEGIN_PASTE, this::beginPaste);
3780         addBuiltinWidget(widgets, FOCUS_IN, this::focusIn);
3781         addBuiltinWidget(widgets, FOCUS_OUT, this::focusOut);
3782         return widgets;
3783     }
3784 
3785     private void addBuiltinWidget(Map&lt;String, Widget&gt; widgets, String name, Widget widget) {
<span class="line-modified">3786         widgets.put(name, namedWidget(&quot;.&quot; + name, widget));</span>
3787     }
3788 
3789     private Widget namedWidget(String name, Widget widget) {
3790         return new Widget() {
3791             @Override
3792             public String toString() {
3793                 return name;
3794             }
3795             @Override
3796             public boolean apply() {
3797                 return widget.apply();
3798             }
3799         };
3800     }
3801 
3802     public boolean redisplay() {
3803         redisplay(true);
3804         return true;
3805     }
3806 
</pre>
<hr />
<pre>
3941                 newLinesToDisplay = newLines;
3942             }
3943             display.update(newLinesToDisplay, cursorPos, flush);
3944         } finally {
3945             lock.unlock();
3946         }
3947     }
3948 
3949     private void concat(List&lt;AttributedString&gt; lines, AttributedStringBuilder sb) {
3950         if (lines.size() &gt; 1) {
3951             for (int i = 0; i &lt; lines.size() - 1; i++) {
3952                 sb.append(lines.get(i));
3953                 sb.style(sb.style().inverse());
3954                 sb.append(&quot;\\n&quot;);
3955                 sb.style(sb.style().inverseOff());
3956             }
3957         }
3958         sb.append(lines.get(lines.size() - 1));
3959     }
3960 
<span class="line-added">3961     private String matchPreviousCommand(String buffer) {</span>
<span class="line-added">3962         if (buffer.length() == 0) {</span>
<span class="line-added">3963             return &quot;&quot;;</span>
<span class="line-added">3964         }</span>
<span class="line-added">3965         History history = getHistory();</span>
<span class="line-added">3966         StringBuilder sb = new StringBuilder();</span>
<span class="line-added">3967         char prev = &#39;0&#39;;</span>
<span class="line-added">3968         for (char c: buffer.toCharArray()) {</span>
<span class="line-added">3969             if ((c == &#39;(&#39; || c == &#39;)&#39; || c == &#39;[&#39; || c == &#39;]&#39; || c == &#39;{&#39; || c == &#39;}&#39; || c == &#39;^&#39;) &amp;&amp; prev != &#39;\\&#39; ) {</span>
<span class="line-added">3970                 sb.append(&#39;\\&#39;);</span>
<span class="line-added">3971             }</span>
<span class="line-added">3972             sb.append(c);</span>
<span class="line-added">3973             prev = c;</span>
<span class="line-added">3974         }</span>
<span class="line-added">3975         Pattern pattern = Pattern.compile(sb.toString() + &quot;.*&quot;, Pattern.DOTALL);</span>
<span class="line-added">3976         Iterator&lt;History.Entry&gt; iter = history.reverseIterator(history.last());</span>
<span class="line-added">3977         String suggestion = &quot;&quot;;</span>
<span class="line-added">3978         int tot = 0;</span>
<span class="line-added">3979         while (iter.hasNext()) {</span>
<span class="line-added">3980             History.Entry entry = iter.next();</span>
<span class="line-added">3981             Matcher matcher = pattern.matcher(entry.line());</span>
<span class="line-added">3982             if (matcher.matches()) {</span>
<span class="line-added">3983                 suggestion = entry.line().substring(buffer.length());</span>
<span class="line-added">3984                 break;</span>
<span class="line-added">3985             } else if (tot &gt; 200) {</span>
<span class="line-added">3986                 break;</span>
<span class="line-added">3987             }</span>
<span class="line-added">3988             tot++;</span>
<span class="line-added">3989         }</span>
<span class="line-added">3990         return suggestion;</span>
<span class="line-added">3991     }</span>
<span class="line-added">3992 </span>
3993     /**
3994      * Compute the full string to be displayed with the left, right and secondary prompts
3995      * @param secondaryPrompts a list to store the secondary prompts
3996      * @return the displayed string including the buffer, left prompts and the help below
3997      */
3998     public AttributedString getDisplayedBufferWithPrompts(List&lt;AttributedString&gt; secondaryPrompts) {
3999         AttributedString attBuf = getHighlightedBuffer(buf.toString());
4000 
4001         AttributedString tNewBuf = insertSecondaryPrompts(attBuf, secondaryPrompts);
4002         AttributedStringBuilder full = new AttributedStringBuilder().tabs(TAB_WIDTH);
4003         full.append(prompt);
4004         full.append(tNewBuf);
<span class="line-added">4005         if (doAutosuggestion) {</span>
<span class="line-added">4006             String lastBinding = getLastBinding() != null ? getLastBinding() : &quot;&quot;;</span>
<span class="line-added">4007             if (autosuggestion == SuggestionType.HISTORY) {</span>
<span class="line-added">4008                 AttributedStringBuilder sb = new AttributedStringBuilder();</span>
<span class="line-added">4009                 tailTip = matchPreviousCommand(buf.toString());</span>
<span class="line-added">4010                 sb.styled(AttributedStyle::faint, tailTip);</span>
<span class="line-added">4011                 full.append(sb.toAttributedString());</span>
<span class="line-added">4012             } else if (autosuggestion == SuggestionType.COMPLETER) {</span>
<span class="line-added">4013                 if (buf.length() &gt; 0 &amp;&amp; buf.length() == buf.cursor()</span>
<span class="line-added">4014                     &amp;&amp; (!lastBinding.equals(&quot;\t&quot;) || buf.prevChar() == &#39; &#39; || buf.prevChar() == &#39;=&#39;)) {</span>
<span class="line-added">4015                     clearChoices();</span>
<span class="line-added">4016                     listChoices(true);</span>
<span class="line-added">4017                 } else if (!lastBinding.equals(&quot;\t&quot;)) {</span>
<span class="line-added">4018                     clearChoices();</span>
<span class="line-added">4019                 }</span>
<span class="line-added">4020             } else if (autosuggestion == SuggestionType.TAIL_TIP) {</span>
<span class="line-added">4021                 if (buf.length() == buf.cursor()) {</span>
<span class="line-added">4022                     if (!lastBinding.equals(&quot;\t&quot;) || buf.prevChar() == &#39; &#39;) {</span>
<span class="line-added">4023                         clearChoices();</span>
<span class="line-added">4024                     }</span>
<span class="line-added">4025                     AttributedStringBuilder sb = new AttributedStringBuilder();</span>
<span class="line-added">4026                     if (buf.prevChar() != &#39; &#39;) {</span>
<span class="line-added">4027                         if (!tailTip.startsWith(&quot;[&quot;)) {</span>
<span class="line-added">4028                             int idx = tailTip.indexOf(&#39; &#39;);</span>
<span class="line-added">4029                             int idb = buf.toString().lastIndexOf(&#39; &#39;);</span>
<span class="line-added">4030                             int idd = buf.toString().lastIndexOf(&#39;-&#39;);</span>
<span class="line-added">4031                             if (idx &gt; 0 &amp;&amp; ((idb == -1 &amp;&amp; idb == idd) || (idb &gt;= 0 &amp;&amp; idb &gt; idd))) {</span>
<span class="line-added">4032                                 tailTip = tailTip.substring(idx);</span>
<span class="line-added">4033                             } else if (idb &gt;= 0 &amp;&amp; idb &lt; idd) {</span>
<span class="line-added">4034                                 sb.append(&quot; &quot;);</span>
<span class="line-added">4035                             }</span>
<span class="line-added">4036                         } else {</span>
<span class="line-added">4037                             sb.append(&quot; &quot;);</span>
<span class="line-added">4038                         }</span>
<span class="line-added">4039                     }</span>
<span class="line-added">4040                     sb.styled(AttributedStyle::faint, tailTip);</span>
<span class="line-added">4041                     full.append(sb.toAttributedString());</span>
<span class="line-added">4042                 }</span>
<span class="line-added">4043             }</span>
<span class="line-added">4044         }</span>
4045         if (post != null) {
4046             full.append(&quot;\n&quot;);
4047             full.append(post.get());
4048         }
<span class="line-added">4049         doAutosuggestion = true;</span>
4050         return full.toAttributedString();
4051     }
4052 
4053     private AttributedString getHighlightedBuffer(String buffer) {
4054         if (maskingCallback != null) {
4055             buffer = maskingCallback.display(buffer);
4056         }
<span class="line-modified">4057         if (highlighter != null &amp;&amp; !isSet(Option.DISABLE_HIGHLIGHTER)</span>
<span class="line-added">4058                 &amp;&amp; buffer.length() &lt; getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE)) {</span>
4059             return highlighter.highlight(this, buffer);
4060         }
4061         return new AttributedString(buffer);
4062     }
4063 
4064     private AttributedString expandPromptPattern(String pattern, int padToWidth,
4065                                                  String message, int line) {
4066         ArrayList&lt;AttributedString&gt; parts = new ArrayList&lt;&gt;();
4067         boolean isHidden = false;
4068         int padPartIndex = -1;
4069         StringBuilder padPartString = null;
4070         StringBuilder sb = new StringBuilder();
4071         // Add &quot;%{&quot; to avoid special case for end of string.
4072         pattern = pattern + &quot;%{&quot;;
4073         int plen = pattern.length();
4074         int padChar = -1;
4075         int padPos = -1;
4076         int cols = 0;
4077         for (int i = 0; i &lt; plen; ) {
4078             char ch = pattern.charAt(i++);
</pre>
<hr />
<pre>
4160         if (padToWidth &gt; cols) {
4161             int padCharCols = WCWidth.wcwidth(padChar);
4162             int padCount = (padToWidth - cols) / padCharCols;
4163             sb = padPartString;
4164             while (--padCount &gt;= 0)
4165                 sb.insert(padPos, (char) padChar); // FIXME if wide
4166             parts.set(padPartIndex, AttributedString.fromAnsi(sb.toString()));
4167         }
4168         return AttributedString.join(null, parts);
4169     }
4170 
4171     private AttributedString insertSecondaryPrompts(AttributedString str, List&lt;AttributedString&gt; prompts) {
4172         return insertSecondaryPrompts(str, prompts, true);
4173     }
4174 
4175     private AttributedString insertSecondaryPrompts(AttributedString strAtt, List&lt;AttributedString&gt; prompts, boolean computePrompts) {
4176         Objects.requireNonNull(prompts);
4177         List&lt;AttributedString&gt; lines = strAtt.columnSplitLength(Integer.MAX_VALUE);
4178         AttributedStringBuilder sb = new AttributedStringBuilder();
4179         String secondaryPromptPattern = getString(SECONDARY_PROMPT_PATTERN, DEFAULT_SECONDARY_PROMPT_PATTERN);
<span class="line-modified">4180         boolean needsMessage = secondaryPromptPattern.contains(&quot;%M&quot;)</span>
<span class="line-added">4181                 &amp;&amp; strAtt.length() &lt; getInt(FEATURES_MAX_BUFFER_SIZE, DEFAULT_FEATURES_MAX_BUFFER_SIZE);</span>
4182         AttributedStringBuilder buf = new AttributedStringBuilder();
4183         int width = 0;
4184         List&lt;String&gt; missings = new ArrayList&lt;&gt;();
4185         if (computePrompts &amp;&amp; secondaryPromptPattern.contains(&quot;%P&quot;)) {
4186             width = prompt.columnLength();
4187             for (int line = 0; line &lt; lines.size() - 1; line++) {
4188                 AttributedString prompt;
4189                 buf.append(lines.get(line)).append(&quot;\n&quot;);
4190                 String missing = &quot;&quot;;
4191                 if (needsMessage) {
4192                     try {
4193                         parser.parse(buf.toString(), buf.length(), ParseContext.SECONDARY_PROMPT);
4194                     } catch (EOFError e) {
4195                         missing = e.getMissing();
4196                     } catch (SyntaxError e) {
4197                         // Ignore
4198                     }
4199                 }
4200                 missings.add(missing);
4201                 prompt = expandPromptPattern(secondaryPromptPattern, 0, missing, line + 1);
</pre>
<hr />
<pre>
4327         }
4328     }
4329 
4330     protected boolean menuExpandOrComplete() {
4331         if (insertTab()) {
4332             return selfInsert();
4333         } else {
4334             return doComplete(CompletionType.ExpandComplete, true, false);
4335         }
4336     }
4337 
4338     protected boolean completePrefix() {
4339         if (insertTab()) {
4340             return selfInsert();
4341         } else {
4342             return doComplete(CompletionType.Complete, isSet(Option.MENU_COMPLETE), true);
4343         }
4344     }
4345 
4346     protected boolean listChoices() {
<span class="line-modified">4347         return listChoices(false);</span>
<span class="line-added">4348     }</span>
<span class="line-added">4349 </span>
<span class="line-added">4350     private boolean listChoices(boolean forSuggestion) {</span>
<span class="line-added">4351         return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false, forSuggestion);</span>
4352     }
4353 
4354     protected boolean deleteCharOrList() {
4355         if (buf.cursor() != buf.length() || buf.length() == 0) {
4356             return deleteChar();
4357         } else {
4358             return doComplete(CompletionType.List, isSet(Option.MENU_COMPLETE), false);
4359         }
4360     }
4361 
4362     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix) {
<span class="line-added">4363         return doComplete(lst, useMenu, prefix, false);</span>
<span class="line-added">4364     }</span>
<span class="line-added">4365 </span>
<span class="line-added">4366     protected boolean doComplete(CompletionType lst, boolean useMenu, boolean prefix, boolean forSuggestion) {</span>
4367         // If completion is disabled, just bail out
4368         if (getBoolean(DISABLE_COMPLETION, false)) {
4369             return true;
4370         }
4371         // Try to expand history first
4372         // If there is actually an expansion, bail out now
4373         if (!isSet(Option.DISABLE_EVENT_EXPANSION)) {
4374             try {
4375                 if (expandHistory()) {
4376                     return true;
4377                 }
4378             } catch (Exception e) {
4379                 Log.info(&quot;Error while expanding history&quot;, e);
4380                 return false;
4381             }
4382         }
4383 
4384         // Parse the command line
4385         CompletingParsedLine line;
4386         try {
</pre>
<hr />
<pre>
4445                     simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wp)),
4446                     typoMatcher(wp, errors, caseInsensitive)
4447             );
4448             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wp) : s.equals(wp);
4449         } else if (isSet(Option.COMPLETE_IN_WORD)) {
4450             String wd = line.word();
4451             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
4452             String wp = wdi.substring(0, line.wordCursor());
4453             String ws = wdi.substring(line.wordCursor());
4454             Pattern p1 = Pattern.compile(Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4455             Pattern p2 = Pattern.compile(&quot;.*&quot; + Pattern.quote(wp) + &quot;.*&quot; + Pattern.quote(ws) + &quot;.*&quot;);
4456             matchers = Arrays.asList(
4457                     simpleMatcher(s -&gt; p1.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4458                     simpleMatcher(s -&gt; p2.matcher(caseInsensitive ? s.toLowerCase() : s).matches()),
4459                     typoMatcher(wdi, errors, caseInsensitive)
4460             );
4461             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4462         } else {
4463             String wd = line.word();
4464             String wdi = caseInsensitive ? wd.toLowerCase() : wd;
<span class="line-modified">4465             if (isSet(Option.EMPTY_WORD_OPTIONS) || wd.length() &gt; 0) {</span>
<span class="line-modified">4466                 matchers = Arrays.asList(</span>
<span class="line-modified">4467                         simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).startsWith(wdi)),</span>
<span class="line-modified">4468                         simpleMatcher(s -&gt; (caseInsensitive ? s.toLowerCase() : s).contains(wdi)),</span>
<span class="line-modified">4469                         typoMatcher(wdi, errors, caseInsensitive)</span>
<span class="line-added">4470                 );</span>
<span class="line-added">4471             } else {</span>
<span class="line-added">4472                 matchers = Arrays.asList(</span>
<span class="line-added">4473                         simpleMatcher(s -&gt; !s.startsWith(&quot;-&quot;))</span>
<span class="line-added">4474                 );</span>
<span class="line-added">4475             }</span>
4476             exact = s -&gt; caseInsensitive ? s.equalsIgnoreCase(wd) : s.equals(wd);
4477         }
4478         // Find matching candidates
4479         Map&lt;String, List&lt;Candidate&gt;&gt; matching = Collections.emptyMap();
4480         for (Function&lt;Map&lt;String, List&lt;Candidate&gt;&gt;,
4481                       Map&lt;String, List&lt;Candidate&gt;&gt;&gt; matcher : matchers) {
4482             matching = matcher.apply(sortedCandidates);
4483             if (!matching.isEmpty()) {
4484                 break;
4485             }
4486         }
4487 
4488         // If we have no matches, bail out
4489         if (matching.isEmpty()) {
4490             return false;
4491         }
4492         size.copy(terminal.getSize());
4493         try {
4494             // If we only need to display the list, do it now
4495             if (lst == CompletionType.List) {
4496                 List&lt;Candidate&gt; possible = matching.entrySet().stream()
4497                         .flatMap(e -&gt; e.getValue().stream())
4498                         .collect(Collectors.toList());
<span class="line-modified">4499                 doList(possible, line.word(), false, line::escape, forSuggestion);</span>
4500                 return !possible.isEmpty();
4501             }
4502 
4503             // Check if there&#39;s a single possible match
4504             Candidate completion = null;
4505             // If there&#39;s a single possible completion
4506             if (matching.size() == 1) {
4507                 completion = matching.values().stream().flatMap(Collection::stream)
4508                         .findFirst().orElse(null);
4509             }
4510             // Or if RECOGNIZE_EXACT is set, try to find an exact match
4511             else if (isSet(Option.RECOGNIZE_EXACT)) {
4512                 completion = matching.values().stream().flatMap(Collection::stream)
4513                         .filter(Candidate::complete)
4514                         .filter(c -&gt; exact.test(c.value()))
4515                         .findFirst().orElse(null);
4516             }
4517             // Complete and exit
4518             if (completion != null &amp;&amp; !completion.value().isEmpty()) {
4519                 if (prefix) {
</pre>
<hr />
<pre>
4562 
4563             // Find current word and move to end
4564             String current;
4565             if (prefix) {
4566                 current = line.word().substring(0, line.wordCursor());
4567             } else {
4568                 current = line.word();
4569                 buf.move(line.rawWordLength() - line.rawWordCursor());
4570             }
4571             // Now, we need to find the unambiguous completion
4572             // TODO: need to find common suffix
4573             String commonPrefix = null;
4574             for (String key : matching.keySet()) {
4575                 commonPrefix = commonPrefix == null ? key : getCommonStart(commonPrefix, key, caseInsensitive);
4576             }
4577             boolean hasUnambiguous = commonPrefix.startsWith(current) &amp;&amp; !commonPrefix.equals(current);
4578 
4579             if (hasUnambiguous) {
4580                 buf.backspace(line.rawWordLength());
4581                 buf.write(line.escape(commonPrefix, false));
<span class="line-added">4582                 callWidget(REDISPLAY);</span>
4583                 current = commonPrefix;
4584                 if ((!isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.AUTO_MENU))
4585                         || (isSet(Option.AUTO_LIST) &amp;&amp; isSet(Option.LIST_AMBIGUOUS))) {
4586                     if (!nextBindingIsComplete()) {
4587                         return true;
4588                     }
4589                 }
4590             }
4591             if (isSet(Option.AUTO_LIST)) {
4592                 if (!doList(possible, current, true, line::escape)) {
4593                     return true;
4594                 }
4595             }
4596             if (isSet(Option.AUTO_MENU)) {
4597                 buf.backspace(current.length());
4598                 doMenu(possible, line.word(), line::escape);
4599             }
4600             return true;
4601         } finally {
4602             size.copy(terminal.getBufferSize());
</pre>
<hr />
<pre>
4627                     return line.cursor();
4628                 }
4629                 public CharSequence escape(CharSequence candidate, boolean complete) {
4630                     return candidate;
4631                 }
4632                 public int rawWordCursor() {
4633                     return wordCursor();
4634                 }
4635                 public int rawWordLength() {
4636                     return word().length();
4637                 }
4638             };
4639         }
4640     }
4641 
4642     protected Comparator&lt;Candidate&gt; getCandidateComparator(boolean caseInsensitive, String word) {
4643         String wdi = caseInsensitive ? word.toLowerCase() : word;
4644         ToIntFunction&lt;String&gt; wordDistance = w -&gt; distance(wdi, caseInsensitive ? w.toLowerCase() : w);
4645         return Comparator
4646                 .comparing(Candidate::value, Comparator.comparingInt(wordDistance))

4647                 .thenComparing(Comparator.naturalOrder());
4648     }
4649 
4650     protected String getOthersGroupName() {
4651         return getString(OTHERS_GROUP_NAME, DEFAULT_OTHERS_GROUP_NAME);
4652     }
4653 
4654     protected String getOriginalGroupName() {
4655         return getString(ORIGINAL_GROUP_NAME, DEFAULT_ORIGINAL_GROUP_NAME);
4656     }
4657 
4658 
4659     protected Comparator&lt;String&gt; getGroupComparator() {
4660         return Comparator.&lt;String&gt;comparingInt(s -&gt; getOthersGroupName().equals(s) ? 1 : getOriginalGroupName().equals(s) ? -1 : 0)
4661                 .thenComparing(String::toLowerCase, Comparator.naturalOrder());
4662     }
4663 
4664     private void mergeCandidates(List&lt;Candidate&gt; possible) {
4665         // Merge candidates if the have the same key
4666         Map&lt;String, List&lt;Candidate&gt;&gt; keyedCandidates = new HashMap&lt;&gt;();
</pre>
<hr />
<pre>
4835             }
4836         }
4837 
4838         public void right() {
4839             if (isSet(Option.LIST_ROWS_FIRST)) {
4840                 minor(1);
4841             } else {
4842                 major(1);
4843             }
4844         }
4845 
4846         private void update() {
4847             buf.backspace(word.length());
4848             word = escaper.apply(completion().value(), true).toString();
4849             buf.write(word);
4850 
4851             // Compute displayed prompt
4852             PostResult pr = computePost(possible, completion(), null, completed);
4853             AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4854             int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
<span class="line-modified">4855             Status status = Status.getStatus(terminal, false);</span>
<span class="line-modified">4856             int displaySize = size.getRows() - (status != null ? status.size() : 0) - promptLines;</span>
<span class="line-added">4857             if (pr.lines &gt; displaySize) {</span>
<span class="line-added">4858                 int displayed = displaySize - 1;</span>
4859                 if (pr.selectedLine &gt;= 0) {
4860                     if (pr.selectedLine &lt; topLine) {
4861                         topLine = pr.selectedLine;
4862                     } else if (pr.selectedLine &gt;= topLine + displayed) {
4863                         topLine = pr.selectedLine - displayed + 1;
4864                     }
4865                 }
4866                 AttributedString post = pr.post;
4867                 if (post.length() &gt; 0 &amp;&amp; post.charAt(post.length() - 1) != &#39;\n&#39;) {
4868                     post = new AttributedStringBuilder(post.length() + 1)
4869                             .append(post).append(&quot;\n&quot;).toAttributedString();
4870                 }
4871                 List&lt;AttributedString&gt; lines = post.columnSplitLength(size.getColumns(), true, display.delayLineWrap());
4872                 List&lt;AttributedString&gt; sub = new ArrayList&lt;&gt;(lines.subList(topLine, topLine + displayed));
4873                 sub.add(new AttributedStringBuilder()
4874                         .style(AttributedStyle.DEFAULT.foreground(AttributedStyle.CYAN))
4875                         .append(&quot;rows &quot;)
4876                         .append(Integer.toString(topLine + 1))
4877                         .append(&quot; to &quot;)
4878                         .append(Integer.toString(topLine + displayed))
</pre>
<hr />
<pre>
4889         }
4890 
4891         @Override
4892         public AttributedString get() {
4893             return computed;
4894         }
4895 
4896     }
4897 
4898     protected boolean doMenu(List&lt;Candidate&gt; original, String completed, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {
4899         // Reorder candidates according to display order
4900         final List&lt;Candidate&gt; possible = new ArrayList&lt;&gt;();
4901         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
4902         original.sort(getCandidateComparator(caseInsensitive, completed));
4903         mergeCandidates(original);
4904         computePost(original, null, possible, completed);
4905 
4906         // Build menu support
4907         MenuSupport menuSupport = new MenuSupport(original, completed, escaper);
4908         post = menuSupport;
<span class="line-modified">4909         callWidget(REDISPLAY);</span>
4910 
4911         // Loop
4912         KeyMap&lt;Binding&gt; keyMap = keyMaps.get(MENU);
4913         Binding operation;
4914         while ((operation = readBinding(getKeys(), keyMap)) != null) {
4915             String ref = (operation instanceof Reference) ? ((Reference) operation).name() : &quot;&quot;;
4916             switch (ref) {
4917                 case MENU_COMPLETE:
4918                     menuSupport.next();
4919                     break;
4920                 case REVERSE_MENU_COMPLETE:
4921                     menuSupport.previous();
4922                     break;
4923                 case UP_LINE_OR_HISTORY:
4924                 case UP_LINE_OR_SEARCH:
4925                     menuSupport.up();
4926                     break;
4927                 case DOWN_LINE_OR_HISTORY:
4928                 case DOWN_LINE_OR_SEARCH:
4929                     menuSupport.down();
</pre>
<hr />
<pre>
4945                                 &amp;&amp; chars.indexOf(getLastBinding().charAt(0)) &gt;= 0
4946                                 || BACKWARD_DELETE_CHAR.equals(ref)) {
4947                             buf.backspace(completion.suffix().length());
4948                         }
4949                     }
4950                     if (completion.complete()
4951                             &amp;&amp; getLastBinding().charAt(0) != &#39; &#39;
4952                             &amp;&amp; (SELF_INSERT.equals(ref) || getLastBinding().charAt(0) != &#39; &#39;)) {
4953                         buf.write(&#39; &#39;);
4954                     }
4955                     if (!ACCEPT_LINE.equals(ref)
4956                             &amp;&amp; !(SELF_INSERT.equals(ref)
4957                                 &amp;&amp; completion.suffix() != null
4958                                 &amp;&amp; completion.suffix().startsWith(getLastBinding()))) {
4959                         pushBackBinding(true);
4960                     }
4961                     post = null;
4962                     return true;
4963                 }
4964             }
<span class="line-modified">4965             doAutosuggestion = false;</span>
<span class="line-added">4966             callWidget(REDISPLAY);</span>
4967         }
4968         return false;
4969     }
4970 
<span class="line-modified">4971     protected boolean clearChoices() {</span>
<span class="line-added">4972         return doList(new ArrayList&lt;Candidate&gt;(), &quot;&quot;, false, null, false);</span>
<span class="line-added">4973     }</span>
<span class="line-added">4974 </span>
<span class="line-added">4975     protected boolean doList(List&lt;Candidate&gt; possible</span>
<span class="line-added">4976                            , String completed, boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper) {</span>
<span class="line-added">4977         return doList(possible, completed, runLoop, escaper, false);</span>
<span class="line-added">4978     }</span>
<span class="line-added">4979 </span>
<span class="line-added">4980     protected boolean doList(List&lt;Candidate&gt; possible</span>
<span class="line-added">4981                            , String completed</span>
<span class="line-added">4982                            , boolean runLoop, BiFunction&lt;CharSequence, Boolean, CharSequence&gt; escaper, boolean forSuggestion) {</span>
4983         // If we list only and if there&#39;s a big
4984         // number of items, we should ask the user
4985         // for confirmation, display the list
4986         // and redraw the line at the bottom
4987         mergeCandidates(possible);
4988         AttributedString text = insertSecondaryPrompts(AttributedStringBuilder.append(prompt, buf.toString()), new ArrayList&lt;&gt;());
4989         int promptLines = text.columnSplitLength(size.getColumns(), false, display.delayLineWrap()).size();
4990         PostResult postResult = computePost(possible, null, null, completed);
4991         int lines = postResult.lines;
4992         int listMax = getInt(LIST_MAX, DEFAULT_LIST_MAX);
4993         if (listMax &gt; 0 &amp;&amp; possible.size() &gt;= listMax
4994                 || lines &gt;= size.getRows() - promptLines) {
<span class="line-modified">4995             if (!forSuggestion) {</span>
<span class="line-modified">4996                 // prompt</span>
<span class="line-modified">4997                 post = () -&gt; new AttributedString(getAppName() + &quot;: do you wish to see all &quot; + possible.size()</span>
<span class="line-modified">4998                         + &quot; possibilities (&quot; + lines + &quot; lines)?&quot;);</span>
<span class="line-modified">4999                 redisplay(true);</span>
<span class="line-modified">5000                 int c = readCharacter();</span>
<span class="line-modified">5001                 if (c != &#39;y&#39; &amp;&amp; c != &#39;Y&#39; &amp;&amp; c != &#39;\t&#39;) {</span>
<span class="line-added">5002                     post = null;</span>
<span class="line-added">5003                     return false;</span>
<span class="line-added">5004                 }</span>
<span class="line-added">5005             } else {</span>
5006                 return false;
5007             }
5008         }
5009 
5010         boolean caseInsensitive = isSet(Option.CASE_INSENSITIVE);
5011         StringBuilder sb = new StringBuilder();
5012         while (true) {
5013             String current = completed + sb.toString();
5014             List&lt;Candidate&gt; cands;
5015             if (sb.length() &gt; 0) {
5016                 cands = possible.stream()
5017                         .filter(c -&gt; caseInsensitive
5018                                     ? c.value().toLowerCase().startsWith(current.toLowerCase())
5019                                     : c.value().startsWith(current))
5020                         .sorted(getCandidateComparator(caseInsensitive, current))
5021                         .collect(Collectors.toList());
5022             } else {
5023                 cands = possible.stream()
5024                         .sorted(getCandidateComparator(caseInsensitive, current))
5025                         .collect(Collectors.toList());
</pre>
<hr />
<pre>
5046             };
5047             if (!runLoop) {
5048                 return false;
5049             }
5050             redisplay();
5051             // TODO: use a different keyMap ?
5052             Binding b = doReadBinding(getKeys(), null);
5053             if (b instanceof Reference) {
5054                 String name = ((Reference) b).name();
5055                 if (BACKWARD_DELETE_CHAR.equals(name) || VI_BACKWARD_DELETE_CHAR.equals(name)) {
5056                     if (sb.length() == 0) {
5057                         pushBackBinding();
5058                         post = null;
5059                         return false;
5060                     } else {
5061                         sb.setLength(sb.length() - 1);
5062                         buf.backspace();
5063                     }
5064                 } else if (SELF_INSERT.equals(name)) {
5065                     sb.append(getLastBinding());
<span class="line-modified">5066                     callWidget(name);</span>
5067                     if (cands.isEmpty()) {
5068                         post = null;
5069                         return false;
5070                     }
5071                 } else if (&quot;\t&quot;.equals(getLastBinding())) {
5072                     if (cands.size() == 1 || sb.length() &gt; 0) {
5073                         post = null;
5074                         pushBackBinding();
5075                     } else if (isSet(Option.AUTO_MENU)) {
5076                         buf.backspace(escaper.apply(current, false).length());
5077                         doMenu(cands, current, escaper);
5078                     }
5079                     return false;
5080                 } else {
5081                     pushBackBinding();
5082                     post = null;
5083                     return false;
5084                 }
5085             } else if (b == null) {
5086                 post = null;
</pre>
<hr />
<pre>
5627 
5628             List&lt;AttributedString&gt; secondaryPrompts = new ArrayList&lt;&gt;();
5629             getDisplayedBufferWithPrompts(secondaryPrompts);
5630 
5631             AttributedStringBuilder sb = new AttributedStringBuilder().tabs(TAB_WIDTH);
5632             sb.append(prompt);
5633             sb.append(insertSecondaryPrompts(new AttributedString(buf.upToCursor()), secondaryPrompts, false));
5634             List&lt;AttributedString&gt; promptLines = sb.columnSplitLength(size.getColumns(), false, display.delayLineWrap());
5635 
5636             int currentLine = promptLines.size() - 1;
5637             int wantedLine = Math.max(0, Math.min(currentLine + event.getY() - cursor.getY(), secondaryPrompts.size()));
5638             int pl0 = currentLine == 0 ? prompt.columnLength() : secondaryPrompts.get(currentLine - 1).columnLength();
5639             int pl1 = wantedLine == 0 ? prompt.columnLength() : secondaryPrompts.get(wantedLine - 1).columnLength();
5640             int adjust = pl1 - pl0;
5641             buf.moveXY(event.getX() - cursor.getX() - adjust, event.getY() - cursor.getY());
5642         }
5643         return true;
5644     }
5645 
5646     public boolean beginPaste() {
<span class="line-modified">5647         String str = doReadStringUntil(BRACKETED_PASTE_END);</span>


















5648         regionActive = RegionType.PASTE;
5649         regionMark = getBuffer().cursor();
<span class="line-modified">5650         getBuffer().write(str.replace(&#39;\r&#39;, &#39;\n&#39;));</span>
5651         return true;
5652     }
5653 
5654     public boolean focusIn() {
5655         return false;
5656     }
5657 
5658     public boolean focusOut() {
5659         return false;
5660     }
5661 
5662     /**
5663      * Clean the used display
5664      * @return &lt;code&gt;true&lt;/code&gt;
5665      */
5666     public boolean clear() {
5667         display.update(Collections.emptyList(), 0);
5668         return true;
5669     }
5670 
</pre>
<hr />
<pre>
5826         bind(emacs, ACCEPT_LINE,                            ctrl(&#39;M&#39;));
5827         bind(emacs, DOWN_LINE_OR_HISTORY,                   ctrl(&#39;N&#39;));
5828         bind(emacs, ACCEPT_LINE_AND_DOWN_HISTORY,           ctrl(&#39;O&#39;));
5829         bind(emacs, UP_LINE_OR_HISTORY,                     ctrl(&#39;P&#39;));
5830         bind(emacs, HISTORY_INCREMENTAL_SEARCH_BACKWARD,    ctrl(&#39;R&#39;));
5831         bind(emacs, HISTORY_INCREMENTAL_SEARCH_FORWARD,     ctrl(&#39;S&#39;));
5832         bind(emacs, TRANSPOSE_CHARS,                        ctrl(&#39;T&#39;));
5833         bind(emacs, KILL_WHOLE_LINE,                        ctrl(&#39;U&#39;));
5834         bind(emacs, QUOTED_INSERT,                          ctrl(&#39;V&#39;));
5835         bind(emacs, BACKWARD_KILL_WORD,                     ctrl(&#39;W&#39;));
5836         bind(emacs, YANK,                                   ctrl(&#39;Y&#39;));
5837         bind(emacs, CHARACTER_SEARCH,                       ctrl(&#39;]&#39;));
5838         bind(emacs, UNDO,                                   ctrl(&#39;_&#39;));
5839         bind(emacs, SELF_INSERT,                            range(&quot; -~&quot;));
5840         bind(emacs, INSERT_CLOSE_PAREN,                     &quot;)&quot;);
5841         bind(emacs, INSERT_CLOSE_SQUARE,                    &quot;]&quot;);
5842         bind(emacs, INSERT_CLOSE_CURLY,                     &quot;}&quot;);
5843         bind(emacs, BACKWARD_DELETE_CHAR,                   del());
5844         bind(emacs, VI_MATCH_BRACKET,                       translate(&quot;^X^B&quot;));
5845         bind(emacs, SEND_BREAK,                             translate(&quot;^X^G&quot;));
<span class="line-added">5846         bind(emacs, EDIT_AND_EXECUTE_COMMAND,               translate(&quot;^X^E&quot;));</span>
5847         bind(emacs, VI_FIND_NEXT_CHAR,                      translate(&quot;^X^F&quot;));
5848         bind(emacs, VI_JOIN,                                translate(&quot;^X^J&quot;));
5849         bind(emacs, KILL_BUFFER,                            translate(&quot;^X^K&quot;));
5850         bind(emacs, INFER_NEXT_HISTORY,                     translate(&quot;^X^N&quot;));
5851         bind(emacs, OVERWRITE_MODE,                         translate(&quot;^X^O&quot;));
5852         bind(emacs, REDO,                                   translate(&quot;^X^R&quot;));
5853         bind(emacs, UNDO,                                   translate(&quot;^X^U&quot;));
5854         bind(emacs, VI_CMD_MODE,                            translate(&quot;^X^V&quot;));
5855         bind(emacs, EXCHANGE_POINT_AND_MARK,                translate(&quot;^X^X&quot;));
5856         bind(emacs, DO_LOWERCASE_VERSION,                   translate(&quot;^XA-^XZ&quot;));
5857         bind(emacs, WHAT_CURSOR_POSITION,                   translate(&quot;^X=&quot;));
5858         bind(emacs, KILL_LINE,                              translate(&quot;^X^?&quot;));
5859         bind(emacs, SEND_BREAK,                             alt(ctrl(&#39;G&#39;)));
5860         bind(emacs, BACKWARD_KILL_WORD,                     alt(ctrl(&#39;H&#39;)));
5861         bind(emacs, SELF_INSERT_UNMETA,                     alt(ctrl(&#39;M&#39;)));
5862         bind(emacs, COMPLETE_WORD,                          alt(esc()));
5863         bind(emacs, CHARACTER_SEARCH_BACKWARD,              alt(ctrl(&#39;]&#39;)));
5864         bind(emacs, COPY_PREV_WORD,                         alt(ctrl(&#39;_&#39;)));
5865         bind(emacs, SET_MARK_COMMAND,                       alt(&#39; &#39;));
5866         bind(emacs, NEG_ARGUMENT,                           alt(&#39;-&#39;));
</pre>
<hr />
<pre>
6127         if (attr != null) {
6128             rebind(keyMap, BACKWARD_DELETE_CHAR,
6129                     del(), (char) attr.getControlChar(ControlChar.VERASE));
6130             rebind(keyMap, BACKWARD_KILL_WORD,
6131                     ctrl(&#39;W&#39;),  (char) attr.getControlChar(ControlChar.VWERASE));
6132             rebind(keyMap, KILL_WHOLE_LINE,
6133                     ctrl(&#39;U&#39;), (char) attr.getControlChar(ControlChar.VKILL));
6134             rebind(keyMap, QUOTED_INSERT,
6135                     ctrl(&#39;V&#39;), (char) attr.getControlChar(ControlChar.VLNEXT));
6136         }
6137     }
6138 
6139     private void rebind(KeyMap&lt;Binding&gt; keyMap, String operation, String prevBinding, char newBinding) {
6140         if (newBinding &gt; 0 &amp;&amp; newBinding &lt; 128) {
6141             Reference ref = new Reference(operation);
6142             bind(keyMap, SELF_INSERT, prevBinding);
6143             keyMap.bind(ref, Character.toString(newBinding));
6144         }
6145     }
6146 

6147 }
</pre>
</td>
</tr>
</table>
<center><a href="DefaultParser.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../index.html" target="_top">index</a> <a href="completer/ArgumentCompleter.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
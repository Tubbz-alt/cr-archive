<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotPlatformConfigurationProvider.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="DefaultHotSpotLoweringProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../nodes/EndLockScopeNode.java.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/meta/HotSpotPlatformConfigurationProvider.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1,7 ***</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
<span class="line-new-header">--- 1,7 ---</span>
  /*
<span class="line-modified">!  * Copyright (c) 2019, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   *
   * This code is free software; you can redistribute it and/or modify it
   * under the terms of the GNU General Public License version 2 only, as
   * published by the Free Software Foundation.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 35,10 ***</span>
<span class="line-new-header">--- 35,11 ---</span>
  import org.graalvm.compiler.nodes.java.AbstractNewObjectNode;
  import org.graalvm.compiler.nodes.memory.FixedAccessNode;
  import org.graalvm.compiler.nodes.spi.PlatformConfigurationProvider;
  
  import jdk.vm.ci.meta.MetaAccessProvider;
<span class="line-added">+ import jdk.vm.ci.meta.ResolvedJavaField;</span>
  import jdk.vm.ci.meta.ResolvedJavaType;
  
  public class HotSpotPlatformConfigurationProvider implements PlatformConfigurationProvider {
      private final BarrierSet barrierSet;
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 59,58 ***</span>
          return barrierSet;
      }
  
      private BarrierSet createBarrierSet(GraalHotSpotVMConfig config, MetaAccessProvider metaAccess) {
          boolean useDeferredInitBarriers = config.useDeferredInitBarriers;
          if (config.useG1GC) {
<span class="line-modified">!             ResolvedJavaType referenceType = HotSpotReplacementsUtil.referenceType(metaAccess);</span>
<span class="line-modified">!             long referentOffset = HotSpotReplacementsUtil.referentOffset(metaAccess);</span>
<span class="line-removed">-             return new G1BarrierSet(referenceType, referentOffset) {</span>
                  @Override
<span class="line-modified">!                 protected boolean writeRequiresPostBarrier(FixedAccessNode initializingWrite, ValueNode writtenValue) {</span>
<span class="line-modified">!                     if (!super.writeRequiresPostBarrier(initializingWrite, writtenValue)) {</span>
                          return false;
                      }
<span class="line-modified">!                     return !useDeferredInitBarriers || !isWriteToNewObject(initializingWrite);</span>
                  }
              };
          } else {
<span class="line-modified">!             return new CardTableBarrierSet() {</span>
                  @Override
<span class="line-modified">!                 protected boolean writeRequiresBarrier(FixedAccessNode initializingWrite, ValueNode writtenValue) {</span>
<span class="line-modified">!                     if (!super.writeRequiresBarrier(initializingWrite, writtenValue)) {</span>
                          return false;
                      }
<span class="line-modified">!                     return !useDeferredInitBarriers || !isWriteToNewObject(initializingWrite);</span>
                  }
  
              };
          }
      }
  
      /**
       * For initializing writes, the last allocation executed by the JVM is guaranteed to be
       * automatically card marked so it&#39;s safe to skip the card mark in the emitted code.
       */
<span class="line-modified">!     protected boolean isWriteToNewObject(FixedAccessNode initializingWrite) {</span>
<span class="line-modified">!         if (!initializingWrite.getLocationIdentity().isInit()) {</span>
              return false;
          }
          // This is only allowed for the last allocation in sequence
<span class="line-modified">!         ValueNode base = initializingWrite.getAddress().getBase();</span>
          if (base instanceof AbstractNewObjectNode) {
<span class="line-modified">!             Node pred = initializingWrite.predecessor();</span>
              while (pred != null) {
                  if (pred == base) {
                      return true;
                  }
                  if (pred instanceof AbstractNewObjectNode) {
<span class="line-modified">!                     initializingWrite.getDebug().log(DebugContext.INFO_LEVEL, &quot;Disallowed deferred init because %s was last allocation instead of %s&quot;, pred, base);</span>
                      return false;
                  }
                  pred = pred.predecessor();
              }
          }
<span class="line-modified">!         initializingWrite.getDebug().log(DebugContext.INFO_LEVEL, &quot;Unable to find allocation for deferred init for %s with base %s&quot;, initializingWrite, base);</span>
          return false;
      }
  }
<span class="line-new-header">--- 60,58 ---</span>
          return barrierSet;
      }
  
      private BarrierSet createBarrierSet(GraalHotSpotVMConfig config, MetaAccessProvider metaAccess) {
          boolean useDeferredInitBarriers = config.useDeferredInitBarriers;
<span class="line-added">+         ResolvedJavaType objectArrayType = metaAccess.lookupJavaType(Object[].class);</span>
          if (config.useG1GC) {
<span class="line-modified">!             ResolvedJavaField referentField = HotSpotReplacementsUtil.referentField(metaAccess);</span>
<span class="line-modified">!             return new G1BarrierSet(objectArrayType, referentField) {</span>
                  @Override
<span class="line-modified">!                 protected boolean writeRequiresPostBarrier(FixedAccessNode node, ValueNode writtenValue) {</span>
<span class="line-modified">!                     if (!super.writeRequiresPostBarrier(node, writtenValue)) {</span>
                          return false;
                      }
<span class="line-modified">!                     return !useDeferredInitBarriers || !isWriteToNewObject(node);</span>
                  }
              };
          } else {
<span class="line-modified">!             return new CardTableBarrierSet(objectArrayType) {</span>
                  @Override
<span class="line-modified">!                 protected boolean writeRequiresBarrier(FixedAccessNode node, ValueNode writtenValue) {</span>
<span class="line-modified">!                     if (!super.writeRequiresBarrier(node, writtenValue)) {</span>
                          return false;
                      }
<span class="line-modified">!                     return !useDeferredInitBarriers || !isWriteToNewObject(node);</span>
                  }
  
              };
          }
      }
  
      /**
       * For initializing writes, the last allocation executed by the JVM is guaranteed to be
       * automatically card marked so it&#39;s safe to skip the card mark in the emitted code.
       */
<span class="line-modified">!     protected boolean isWriteToNewObject(FixedAccessNode node) {</span>
<span class="line-modified">!         if (!node.getLocationIdentity().isInit()) {</span>
              return false;
          }
          // This is only allowed for the last allocation in sequence
<span class="line-modified">!         ValueNode base = node.getAddress().getBase();</span>
          if (base instanceof AbstractNewObjectNode) {
<span class="line-modified">!             Node pred = node.predecessor();</span>
              while (pred != null) {
                  if (pred == base) {
                      return true;
                  }
                  if (pred instanceof AbstractNewObjectNode) {
<span class="line-modified">!                     node.getDebug().log(DebugContext.INFO_LEVEL, &quot;Disallowed deferred init because %s was last allocation instead of %s&quot;, pred, base);</span>
                      return false;
                  }
                  pred = pred.predecessor();
              }
          }
<span class="line-modified">!         node.getDebug().log(DebugContext.INFO_LEVEL, &quot;Unable to find allocation for deferred init for %s with base %s&quot;, node, base);</span>
          return false;
      }
  }
</pre>
<center><a href="DefaultHotSpotLoweringProvider.java.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="../nodes/EndLockScopeNode.java.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
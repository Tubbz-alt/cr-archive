<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../../style.css" />
  </head>
<body>
<center><a href="../nodes/EndLockScopeNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsafeCopyMemoryNode.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.hotspot/src/org/graalvm/compiler/hotspot/replacements/HotSpotReplacementsUtil.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
139         }
140     }
141 
142     @Fold
143     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
144         return context.getOriginalMethod().getDeclaringClass();
145     }
146 
147     @Fold
148     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
149         try {
150             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
151             return unresolved.resolve(methodHolderClass(context));
152         } catch (LinkageError e) {
153             throw new GraalError(e);
154         }
155     }
156 
157     @Fold
158     public static int getFieldOffset(ResolvedJavaType type, String fieldName) {




159         for (ResolvedJavaField field : type.getInstanceFields(true)) {
160             if (field.getName().equals(fieldName)) {
<span class="line-modified">161                 return field.getOffset();</span>
162             }
163         }
164         throw new GraalError(&quot;missing field &quot; + fieldName + &quot; in type &quot; + type);
165     }
166 
167     public static HotSpotJVMCIRuntime runtime() {
168         return HotSpotJVMCIRuntime.runtime();
169     }
170 
171     @Fold
172     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
173         return injectedVMConfig.heapWordSize;
174     }
175 
176     @Fold
177     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
178         return config.klassLayoutHelperNeutralValue;
179     }
180 
181     @Fold
</pre>
<hr />
<pre>
848     @Fold
849     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
850         return config.layoutHelperLog2ElementSizeShift;
851     }
852 
853     @Fold
854     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
855         return config.layoutHelperLog2ElementSizeMask;
856     }
857 
858     @NodeIntrinsic(ForeignCallNode.class)
859     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
860 
861     @Fold
862     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
863         return config.gcTotalCollectionsAddress();
864     }
865 
866     @Fold
867     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
<span class="line-modified">868         return getFieldOffset(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);</span>





869     }
870 
871     @Fold
872     public static ResolvedJavaType referenceType(@InjectedParameter MetaAccessProvider metaAccessProvider) {
873         return metaAccessProvider.lookupJavaType(Reference.class);
874     }
875 
876     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
877         @Override
878         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
879             ValueNode javaObject = findReadHub(object);
880             if (javaObject != null) {
881                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
882                 if (type != null &amp;&amp; type.isArray()) {
883                     ResolvedJavaType element = type.getComponentType();
884                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
885                         Assumptions assumptions = object.graph().getAssumptions();
886                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
887                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
888                             leafType.recordTo(assumptions);
</pre>
</td>
<td>
<hr />
<pre>
139         }
140     }
141 
142     @Fold
143     public static ResolvedJavaType methodHolderClass(@InjectedParameter IntrinsicContext context) {
144         return context.getOriginalMethod().getDeclaringClass();
145     }
146 
147     @Fold
148     static ResolvedJavaType getType(@Fold.InjectedParameter IntrinsicContext context, String typeName) {
149         try {
150             UnresolvedJavaType unresolved = UnresolvedJavaType.create(typeName);
151             return unresolved.resolve(methodHolderClass(context));
152         } catch (LinkageError e) {
153             throw new GraalError(e);
154         }
155     }
156 
157     @Fold
158     public static int getFieldOffset(ResolvedJavaType type, String fieldName) {
<span class="line-added">159         return getField(type, fieldName).getOffset();</span>
<span class="line-added">160     }</span>
<span class="line-added">161 </span>
<span class="line-added">162     private static ResolvedJavaField getField(ResolvedJavaType type, String fieldName) {</span>
163         for (ResolvedJavaField field : type.getInstanceFields(true)) {
164             if (field.getName().equals(fieldName)) {
<span class="line-modified">165                 return field;</span>
166             }
167         }
168         throw new GraalError(&quot;missing field &quot; + fieldName + &quot; in type &quot; + type);
169     }
170 
171     public static HotSpotJVMCIRuntime runtime() {
172         return HotSpotJVMCIRuntime.runtime();
173     }
174 
175     @Fold
176     public static int getHeapWordSize(@InjectedParameter GraalHotSpotVMConfig injectedVMConfig) {
177         return injectedVMConfig.heapWordSize;
178     }
179 
180     @Fold
181     public static int klassLayoutHelperNeutralValue(@InjectedParameter GraalHotSpotVMConfig config) {
182         return config.klassLayoutHelperNeutralValue;
183     }
184 
185     @Fold
</pre>
<hr />
<pre>
852     @Fold
853     public static int layoutHelperLog2ElementSizeShift(@InjectedParameter GraalHotSpotVMConfig config) {
854         return config.layoutHelperLog2ElementSizeShift;
855     }
856 
857     @Fold
858     public static int layoutHelperLog2ElementSizeMask(@InjectedParameter GraalHotSpotVMConfig config) {
859         return config.layoutHelperLog2ElementSizeMask;
860     }
861 
862     @NodeIntrinsic(ForeignCallNode.class)
863     public static native int identityHashCode(@ConstantNodeParameter ForeignCallDescriptor descriptor, Object object);
864 
865     @Fold
866     public static long gcTotalCollectionsAddress(@InjectedParameter GraalHotSpotVMConfig config) {
867         return config.gcTotalCollectionsAddress();
868     }
869 
870     @Fold
871     public static long referentOffset(@InjectedParameter MetaAccessProvider metaAccessProvider) {
<span class="line-modified">872         return referentField(metaAccessProvider).getOffset();</span>
<span class="line-added">873     }</span>
<span class="line-added">874 </span>
<span class="line-added">875     @Fold</span>
<span class="line-added">876     public static ResolvedJavaField referentField(@InjectedParameter MetaAccessProvider metaAccessProvider) {</span>
<span class="line-added">877         return getField(metaAccessProvider.lookupJavaType(Reference.class), &quot;referent&quot;);</span>
878     }
879 
880     @Fold
881     public static ResolvedJavaType referenceType(@InjectedParameter MetaAccessProvider metaAccessProvider) {
882         return metaAccessProvider.lookupJavaType(Reference.class);
883     }
884 
885     public static final LocationIdentity OBJ_ARRAY_KLASS_ELEMENT_KLASS_LOCATION = new HotSpotOptimizingLocationIdentity(&quot;ObjArrayKlass::_element_klass&quot;) {
886         @Override
887         public ValueNode canonicalizeRead(ValueNode read, AddressNode location, ValueNode object, CanonicalizerTool tool) {
888             ValueNode javaObject = findReadHub(object);
889             if (javaObject != null) {
890                 ResolvedJavaType type = StampTool.typeOrNull(javaObject);
891                 if (type != null &amp;&amp; type.isArray()) {
892                     ResolvedJavaType element = type.getComponentType();
893                     if (element != null &amp;&amp; !element.isPrimitive() &amp;&amp; !element.getElementalType().isInterface()) {
894                         Assumptions assumptions = object.graph().getAssumptions();
895                         AssumptionResult&lt;ResolvedJavaType&gt; leafType = element.findLeafConcreteSubtype();
896                         if (leafType != null &amp;&amp; leafType.canRecordTo(assumptions)) {
897                             leafType.recordTo(assumptions);
</pre>
</td>
</tr>
</table>
<center><a href="../nodes/EndLockScopeNode.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../../../../../index.html" target="_top">index</a> <a href="UnsafeCopyMemoryNode.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
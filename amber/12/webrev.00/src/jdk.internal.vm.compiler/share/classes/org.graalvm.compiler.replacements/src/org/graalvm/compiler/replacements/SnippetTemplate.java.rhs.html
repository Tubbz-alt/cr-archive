<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.replacements/src/org/graalvm/compiler/replacements/SnippetTemplate.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.replacements;
  26 
  27 import static java.util.FormattableFlags.ALTERNATE;
  28 import static jdk.vm.ci.services.Services.IS_IN_NATIVE_IMAGE;
  29 import static org.graalvm.compiler.debug.DebugContext.DEFAULT_LOG_STREAM;
  30 import static org.graalvm.compiler.debug.DebugContext.applyFormattingFlagsAndWidth;
  31 import static org.graalvm.compiler.debug.DebugOptions.DebugStubsAndSnippets;
  32 import static org.graalvm.compiler.graph.iterators.NodePredicates.isNotA;
  33 import static org.graalvm.compiler.nodeinfo.NodeCycles.CYCLES_IGNORED;
  34 import static org.graalvm.compiler.nodeinfo.NodeSize.SIZE_IGNORED;
  35 import static org.graalvm.compiler.phases.common.DeadCodeEliminationPhase.Optionality.Required;
  36 import static jdk.internal.vm.compiler.word.LocationIdentity.any;
  37 
  38 import java.lang.reflect.Array;
  39 import java.lang.reflect.Method;
  40 import java.util.ArrayList;
  41 import java.util.Arrays;
  42 import java.util.Collection;
  43 import java.util.Collections;
  44 import java.util.Formattable;
  45 import java.util.Formatter;
  46 import java.util.LinkedHashMap;
  47 import java.util.List;
  48 import java.util.Map;
  49 import java.util.concurrent.atomic.AtomicInteger;
  50 import java.util.concurrent.atomic.AtomicReference;
  51 import java.util.function.Predicate;
  52 
  53 import jdk.internal.vm.compiler.collections.EconomicMap;
  54 import jdk.internal.vm.compiler.collections.EconomicSet;
  55 import jdk.internal.vm.compiler.collections.Equivalence;
  56 import jdk.internal.vm.compiler.collections.UnmodifiableEconomicMap;
  57 import org.graalvm.compiler.api.replacements.Fold;
  58 import org.graalvm.compiler.api.replacements.Snippet;
  59 import org.graalvm.compiler.api.replacements.Snippet.ConstantParameter;
  60 import org.graalvm.compiler.api.replacements.Snippet.NonNullParameter;
  61 import org.graalvm.compiler.api.replacements.Snippet.VarargsParameter;
  62 import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;
  63 import org.graalvm.compiler.core.common.GraalOptions;
  64 import org.graalvm.compiler.core.common.type.Stamp;
  65 import org.graalvm.compiler.core.common.type.StampFactory;
  66 import org.graalvm.compiler.core.common.type.StampPair;
  67 import org.graalvm.compiler.core.common.type.TypeReference;
  68 import org.graalvm.compiler.debug.Assertions;
  69 import org.graalvm.compiler.debug.CounterKey;
  70 import org.graalvm.compiler.debug.DebugCloseable;
  71 import org.graalvm.compiler.debug.DebugContext;
  72 import org.graalvm.compiler.debug.DebugContext.Description;
  73 import org.graalvm.compiler.debug.DebugHandlersFactory;
  74 import org.graalvm.compiler.debug.GraalError;
  75 import org.graalvm.compiler.debug.TimerKey;
  76 import org.graalvm.compiler.graph.Graph.Mark;
  77 import org.graalvm.compiler.graph.Node;
  78 import org.graalvm.compiler.graph.Node.NodeIntrinsic;
  79 import org.graalvm.compiler.graph.NodeClass;
  80 import org.graalvm.compiler.graph.NodeSourcePosition;
  81 import org.graalvm.compiler.graph.Position;
  82 import org.graalvm.compiler.loop.LoopEx;
  83 import org.graalvm.compiler.loop.LoopsData;
  84 import org.graalvm.compiler.loop.phases.LoopTransformations;
  85 import org.graalvm.compiler.nodeinfo.InputType;
  86 import org.graalvm.compiler.nodeinfo.NodeInfo;
  87 import org.graalvm.compiler.nodes.AbstractBeginNode;
  88 import org.graalvm.compiler.nodes.AbstractMergeNode;
  89 import org.graalvm.compiler.nodes.ConstantNode;
  90 import org.graalvm.compiler.nodes.ControlSinkNode;
  91 import org.graalvm.compiler.nodes.DeoptimizingNode;
  92 import org.graalvm.compiler.nodes.FixedNode;
  93 import org.graalvm.compiler.nodes.FixedWithNextNode;
  94 import org.graalvm.compiler.nodes.FrameState;
  95 import org.graalvm.compiler.nodes.InliningLog;
  96 import org.graalvm.compiler.nodes.LoopBeginNode;
  97 import org.graalvm.compiler.nodes.MergeNode;
  98 import org.graalvm.compiler.nodes.NodeView;
  99 import org.graalvm.compiler.nodes.ParameterNode;
 100 import org.graalvm.compiler.nodes.PhiNode;
 101 import org.graalvm.compiler.nodes.PiNode.Placeholder;
 102 import org.graalvm.compiler.nodes.PiNode.PlaceholderStamp;
 103 import org.graalvm.compiler.nodes.ReturnNode;
 104 import org.graalvm.compiler.nodes.StartNode;
 105 import org.graalvm.compiler.nodes.StateSplit;
 106 import org.graalvm.compiler.nodes.StructuredGraph;
 107 import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;
 108 import org.graalvm.compiler.nodes.ValueNode;
 109 import org.graalvm.compiler.nodes.ValueNodeUtil;
 110 import org.graalvm.compiler.nodes.calc.FloatingNode;
 111 import org.graalvm.compiler.nodes.java.LoadIndexedNode;
 112 import org.graalvm.compiler.nodes.java.MethodCallTargetNode;
 113 import org.graalvm.compiler.nodes.java.StoreIndexedNode;
 114 import org.graalvm.compiler.nodes.memory.MemoryAccess;
 115 import org.graalvm.compiler.nodes.memory.MemoryAnchorNode;
 116 import org.graalvm.compiler.nodes.memory.MemoryKill;
 117 import org.graalvm.compiler.nodes.memory.MemoryMap;
 118 import org.graalvm.compiler.nodes.memory.MemoryMapNode;
<a name="1" id="anc1"></a>
 119 import org.graalvm.compiler.nodes.memory.MemoryPhiNode;
 120 import org.graalvm.compiler.nodes.memory.MultiMemoryKill;
 121 import org.graalvm.compiler.nodes.memory.SingleMemoryKill;
 122 import org.graalvm.compiler.nodes.spi.ArrayLengthProvider;
 123 import org.graalvm.compiler.nodes.spi.CoreProviders;
 124 import org.graalvm.compiler.nodes.spi.LoweringTool;
<a name="2" id="anc2"></a><span class="line-modified"> 125 import org.graalvm.compiler.nodes.spi.MemoryEdgeProxy;</span>
 126 import org.graalvm.compiler.nodes.util.GraphUtil;
 127 import org.graalvm.compiler.options.Option;
 128 import org.graalvm.compiler.options.OptionKey;
 129 import org.graalvm.compiler.options.OptionValues;
 130 import org.graalvm.compiler.phases.common.CanonicalizerPhase;
 131 import org.graalvm.compiler.phases.common.DeadCodeEliminationPhase;
 132 import org.graalvm.compiler.phases.common.FloatingReadPhase;
 133 import org.graalvm.compiler.phases.common.FloatingReadPhase.MemoryMapImpl;
 134 import org.graalvm.compiler.phases.common.GuardLoweringPhase;
 135 import org.graalvm.compiler.phases.common.LoweringPhase;
 136 import org.graalvm.compiler.phases.common.RemoveValueProxyPhase;
 137 import org.graalvm.compiler.phases.common.inlining.InliningUtil;
 138 import org.graalvm.compiler.phases.util.Providers;
 139 import org.graalvm.compiler.replacements.nodes.ExplodeLoopNode;
 140 import org.graalvm.compiler.replacements.nodes.LoadSnippetVarargParameterNode;
 141 import org.graalvm.util.CollectionsUtil;
 142 import jdk.internal.vm.compiler.word.LocationIdentity;
 143 import jdk.internal.vm.compiler.word.WordBase;
 144 
 145 import jdk.vm.ci.code.TargetDescription;
 146 import jdk.vm.ci.meta.Constant;
 147 import jdk.vm.ci.meta.ConstantReflectionProvider;
 148 import jdk.vm.ci.meta.JavaConstant;
 149 import jdk.vm.ci.meta.JavaKind;
 150 import jdk.vm.ci.meta.Local;
 151 import jdk.vm.ci.meta.LocalVariableTable;
 152 import jdk.vm.ci.meta.MetaAccessProvider;
 153 import jdk.vm.ci.meta.ResolvedJavaMethod;
 154 import jdk.vm.ci.meta.ResolvedJavaMethod.Parameter;
 155 import jdk.vm.ci.meta.ResolvedJavaType;
 156 import jdk.vm.ci.meta.Signature;
 157 
 158 /**
 159  * A snippet template is a graph created by parsing a snippet method and then specialized by binding
 160  * constants to the snippet&#39;s {@link ConstantParameter} parameters.
 161  *
 162  * Snippet templates can be managed in a cache maintained by {@link AbstractTemplates}.
 163  */
 164 public class SnippetTemplate {
 165 
 166     private boolean mayRemoveLocation = false;
 167 
 168     /**
 169      * Holds the {@link ResolvedJavaMethod} of the snippet, together with some information about the
 170      * method that needs to be computed only once. The {@link SnippetInfo} should be created once
 171      * per snippet and then cached.
 172      */
 173     public abstract static class SnippetInfo {
 174 
 175         protected final ResolvedJavaMethod method;
 176         protected final ResolvedJavaMethod original;
 177         protected final LocationIdentity[] privateLocations;
 178         protected final Object receiver;
 179 
 180         public Object getReceiver() {
 181             return receiver;
 182         }
 183 
 184         boolean hasReceiver() {
 185             assert hasReceiver(method) == (receiver != null) : &quot;Snippet with the receiver must have it set as constant. Snippet: &quot; + this;
 186             return hasReceiver(method);
 187         }
 188 
 189         static boolean hasReceiver(ResolvedJavaMethod method) {
 190             return method.hasReceiver();
 191         }
 192 
 193         /**
 194          * Lazily constructed parts of {@link SnippetInfo}.
 195          */
 196         static class Lazy {
 197             Lazy(ResolvedJavaMethod method) {
 198                 int count = method.getSignature().getParameterCount(hasReceiver(method));
 199                 constantParameters = new boolean[count];
 200                 varargsParameters = new boolean[count];
 201                 nonNullParameters = new boolean[count];
 202                 int offset = hasReceiver(method) ? 1 : 0;
 203                 for (int i = offset; i &lt; count; i++) {
 204                     constantParameters[i] = method.getParameterAnnotation(ConstantParameter.class, i - offset) != null;
 205                     varargsParameters[i] = method.getParameterAnnotation(VarargsParameter.class, i - offset) != null;
 206                     nonNullParameters[i] = method.getParameterAnnotation(NonNullParameter.class, i - offset) != null;
 207 
 208                     assert !constantParameters[i - offset] || !varargsParameters[i - offset] : &quot;Parameter cannot be annotated with both @&quot; + ConstantParameter.class.getSimpleName() + &quot; and @&quot; +
 209                                     VarargsParameter.class.getSimpleName();
 210                 }
 211                 if (method.hasReceiver()) {
 212                     // Receiver must be constant.
 213                     assert !constantParameters[0];
 214                     constantParameters[0] = true;
 215                 }
 216 
 217                 // Retrieve the names only when assertions are turned on. Parameter annotations are
 218                 // unsupported in the native image.
 219                 assert IS_IN_NATIVE_IMAGE || initNames(method, count);
 220             }
 221 
 222             final boolean[] constantParameters;
 223             final boolean[] varargsParameters;
 224             final boolean[] nonNullParameters;
 225 
 226             /**
 227              * The parameter names, taken from the local variables table. Only used for assertion
 228              * checking, so use only within an assert statement.
 229              */
 230             String[] names;
 231 
 232             private boolean initNames(ResolvedJavaMethod method, int parameterCount) {
 233                 names = new String[parameterCount];
 234                 int offset = 0;
 235                 if (method.hasReceiver()) {
 236                     names[0] = &quot;this&quot;;
 237                     offset = 1;
 238                 }
 239                 Parameter[] params = method.getParameters();
 240                 if (params != null) {
 241                     for (int i = offset; i &lt; names.length; i++) {
 242                         if (params[i - offset].isNamePresent()) {
 243                             names[i] = params[i - offset].getName();
 244                         }
 245                     }
 246                 } else {
 247                     int slotIdx = 0;
 248                     LocalVariableTable localVariableTable = method.getLocalVariableTable();
 249                     if (localVariableTable != null) {
 250                         for (int i = 0; i &lt; names.length; i++) {
 251                             Local local = localVariableTable.getLocal(slotIdx, 0);
 252                             if (local != null) {
 253                                 names[i] = local.getName();
 254                             }
 255                             JavaKind kind = method.getSignature().getParameterKind(i);
 256                             slotIdx += kind.getSlotCount();
 257                         }
 258                     }
 259                 }
 260                 return true;
 261             }
 262         }
 263 
 264         /**
 265          * Times instantiations of all templates derived from this snippet.
 266          */
 267         private final TimerKey instantiationTimer;
 268 
 269         /**
 270          * Counts instantiations of all templates derived from this snippet.
 271          */
 272         private final CounterKey instantiationCounter;
 273 
 274         protected abstract Lazy lazy();
 275 
 276         protected SnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 277             this.method = method;
 278             this.original = original;
 279             this.privateLocations = privateLocations;
 280             instantiationCounter = DebugContext.counter(&quot;SnippetInstantiationCount[%s]&quot;, method.getName());
 281             instantiationTimer = DebugContext.timer(&quot;SnippetInstantiationTime[%s]&quot;, method.getName());
 282             this.receiver = receiver;
 283         }
 284 
 285         public ResolvedJavaMethod getMethod() {
 286             return method;
 287         }
 288 
 289         public int getParameterCount() {
 290             return lazy().constantParameters.length;
 291         }
 292 
 293         public boolean isConstantParameter(int paramIdx) {
 294             return lazy().constantParameters[paramIdx];
 295         }
 296 
 297         public boolean isVarargsParameter(int paramIdx) {
 298             return lazy().varargsParameters[paramIdx];
 299         }
 300 
 301         public boolean isNonNullParameter(int paramIdx) {
 302             return lazy().nonNullParameters[paramIdx];
 303         }
 304 
 305         public String getParameterName(int paramIdx) {
 306             String[] names = lazy().names;
 307             if (names != null) {
 308                 return names[paramIdx];
 309             }
 310             return null;
 311         }
 312 
 313         @Override
 314         public String toString() {
 315             return getClass().getSimpleName() + &quot;:&quot; + method.format(&quot;%h.%n&quot;);
 316         }
 317     }
 318 
 319     protected static class LazySnippetInfo extends SnippetInfo {
 320         protected final AtomicReference&lt;Lazy&gt; lazy = new AtomicReference&lt;&gt;(null);
 321 
 322         protected LazySnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 323             super(method, original, privateLocations, receiver);
 324         }
 325 
 326         @Override
 327         protected Lazy lazy() {
 328             if (lazy.get() == null) {
 329                 lazy.compareAndSet(null, new Lazy(method));
 330             }
 331             return lazy.get();
 332         }
 333     }
 334 
 335     protected static class EagerSnippetInfo extends SnippetInfo {
 336         protected final Lazy lazy;
 337 
 338         protected EagerSnippetInfo(ResolvedJavaMethod method, ResolvedJavaMethod original, LocationIdentity[] privateLocations, Object receiver) {
 339             super(method, original, privateLocations, receiver);
 340             lazy = new Lazy(method);
 341         }
 342 
 343         @Override
 344         protected Lazy lazy() {
 345             return lazy;
 346         }
 347     }
 348 
 349     /**
 350      * Values that are bound to the snippet method parameters. The methods {@link #add},
 351      * {@link #addConst}, and {@link #addVarargs} must be called in the same order as in the
 352      * signature of the snippet method. The parameter name is passed to the add methods for
 353      * assertion checking, i.e., to enforce that the order matches. Which method needs to be called
 354      * depends on the annotation of the snippet method parameter:
 355      * &lt;ul&gt;
 356      * &lt;li&gt;Use {@link #add} for a parameter without an annotation. The value is bound when the
 357      * {@link SnippetTemplate} is {@link SnippetTemplate#instantiate instantiated}.
 358      * &lt;li&gt;Use {@link #addConst} for a parameter annotated with {@link ConstantParameter}. The value
 359      * is bound when the {@link SnippetTemplate} is {@link SnippetTemplate#SnippetTemplate created}.
 360      * &lt;li&gt;Use {@link #addVarargs} for an array parameter annotated with {@link VarargsParameter}. A
 361      * separate {@link SnippetTemplate} is {@link SnippetTemplate#SnippetTemplate created} for every
 362      * distinct array length. The actual values are bound when the {@link SnippetTemplate} is
 363      * {@link SnippetTemplate#instantiate instantiated}
 364      * &lt;/ul&gt;
 365      */
 366     public static class Arguments implements Formattable {
 367 
 368         protected final SnippetInfo info;
 369         protected final CacheKey cacheKey;
 370         protected final Object[] values;
 371         protected final Stamp[] constStamps;
 372         protected boolean cacheable;
 373 
 374         protected int nextParamIdx;
 375 
 376         public Arguments(SnippetInfo info, GuardsStage guardsStage, LoweringTool.LoweringStage loweringStage) {
 377             this.info = info;
 378             this.cacheKey = new CacheKey(info, guardsStage, loweringStage);
 379             this.values = new Object[info.getParameterCount()];
 380             this.constStamps = new Stamp[info.getParameterCount()];
 381             this.cacheable = true;
 382             if (info.hasReceiver()) {
 383                 addConst(&quot;this&quot;, info.getReceiver());
 384             }
 385         }
 386 
 387         public Arguments add(String name, Object value) {
 388             assert check(name, false, false);
 389             values[nextParamIdx] = value;
 390             nextParamIdx++;
 391             return this;
 392         }
 393 
 394         public Arguments addConst(String name, Object value) {
 395             assert value != null;
 396             return addConst(name, value, null);
 397         }
 398 
 399         public Arguments addConst(String name, Object value, Stamp stamp) {
 400             assert check(name, true, false);
 401             values[nextParamIdx] = value;
 402             constStamps[nextParamIdx] = stamp;
 403             cacheKey.setParam(nextParamIdx, value);
 404             nextParamIdx++;
 405             return this;
 406         }
 407 
 408         public Arguments addVarargs(String name, Class&lt;?&gt; componentType, Stamp argStamp, Object value) {
 409             assert check(name, false, true);
 410             Varargs varargs = new Varargs(componentType, argStamp, value);
 411             values[nextParamIdx] = varargs;
 412             // A separate template is necessary for every distinct array length
 413             cacheKey.setParam(nextParamIdx, varargs.length);
 414             nextParamIdx++;
 415             return this;
 416         }
 417 
 418         public void setCacheable(boolean cacheable) {
 419             this.cacheable = cacheable;
 420         }
 421 
 422         private boolean check(String name, boolean constParam, boolean varargsParam) {
 423             assert nextParamIdx &lt; info.getParameterCount() : &quot;too many parameters: &quot; + name + &quot;  &quot; + this;
 424             assert info.getParameterName(nextParamIdx) == null || info.getParameterName(nextParamIdx).equals(name) : &quot;wrong parameter name at &quot; + nextParamIdx + &quot; : &quot; + name + &quot;  &quot; + this;
 425             assert constParam == info.isConstantParameter(nextParamIdx) : &quot;Parameter &quot; + (constParam ? &quot;not &quot; : &quot;&quot;) + &quot;annotated with @&quot; + ConstantParameter.class.getSimpleName() + &quot;: &quot; + name +
 426                             &quot;  &quot; + this;
 427             assert varargsParam == info.isVarargsParameter(nextParamIdx) : &quot;Parameter &quot; + (varargsParam ? &quot;not &quot; : &quot;&quot;) + &quot;annotated with @&quot; + VarargsParameter.class.getSimpleName() + &quot;: &quot; + name +
 428                             &quot;  &quot; + this;
 429             return true;
 430         }
 431 
 432         @Override
 433         public String toString() {
 434             StringBuilder result = new StringBuilder();
 435             result.append(&quot;Parameters&lt;&quot;).append(info.method.format(&quot;%h.%n&quot;)).append(&quot; [&quot;);
 436             String sep = &quot;&quot;;
 437             for (int i = 0; i &lt; info.getParameterCount(); i++) {
 438                 result.append(sep);
 439                 if (info.isConstantParameter(i)) {
 440                     result.append(&quot;const &quot;);
 441                 } else if (info.isVarargsParameter(i)) {
 442                     result.append(&quot;varargs &quot;);
 443                 }
 444                 result.append(info.getParameterName(i)).append(&quot; = &quot;).append(values[i]);
 445                 sep = &quot;, &quot;;
 446             }
 447             result.append(&quot;&gt;&quot;);
 448             return result.toString();
 449         }
 450 
 451         @Override
 452         public void formatTo(Formatter formatter, int flags, int width, int precision) {
 453             if ((flags &amp; ALTERNATE) == 0) {
 454                 formatter.format(applyFormattingFlagsAndWidth(toString(), flags, width));
 455             } else {
 456                 StringBuilder sb = new StringBuilder();
 457                 sb.append(info.method.getName()).append(&#39;(&#39;);
 458                 String sep = &quot;&quot;;
 459                 for (int i = 0; i &lt; info.getParameterCount(); i++) {
 460                     if (info.isConstantParameter(i)) {
 461                         sb.append(sep);
 462                         if (info.getParameterName(i) != null) {
 463                             sb.append(info.getParameterName(i));
 464                         } else {
 465                             sb.append(i);
 466                         }
 467                         sb.append(&#39;=&#39;).append(values[i]);
 468                         sep = &quot;, &quot;;
 469                     }
 470                 }
 471                 sb.append(&quot;)&quot;);
 472                 String string = sb.toString();
 473                 if (string.indexOf(&#39;%&#39;) != -1) {
 474                     // Quote any % signs
 475                     string = string.replace(&quot;%&quot;, &quot;%%&quot;);
 476                 }
 477                 formatter.format(applyFormattingFlagsAndWidth(string, flags &amp; ~ALTERNATE, width));
 478             }
 479         }
 480     }
 481 
 482     /**
 483      * Wrapper for the prototype value of a {@linkplain VarargsParameter varargs} parameter.
 484      */
 485     static class Varargs {
 486 
 487         protected final Class&lt;?&gt; componentType;
 488         protected final Stamp stamp;
 489         protected final Object value;
 490         protected final int length;
 491 
 492         protected Varargs(Class&lt;?&gt; componentType, Stamp stamp, Object value) {
 493             this.componentType = componentType;
 494             this.stamp = stamp;
 495             this.value = value;
 496             if (value instanceof List) {
 497                 this.length = ((List&lt;?&gt;) value).size();
 498             } else {
 499                 this.length = Array.getLength(value);
 500             }
 501         }
 502 
 503         @Override
 504         public String toString() {
 505             if (value instanceof boolean[]) {
 506                 return Arrays.toString((boolean[]) value);
 507             }
 508             if (value instanceof byte[]) {
 509                 return Arrays.toString((byte[]) value);
 510             }
 511             if (value instanceof char[]) {
 512                 return Arrays.toString((char[]) value);
 513             }
 514             if (value instanceof short[]) {
 515                 return Arrays.toString((short[]) value);
 516             }
 517             if (value instanceof int[]) {
 518                 return Arrays.toString((int[]) value);
 519             }
 520             if (value instanceof long[]) {
 521                 return Arrays.toString((long[]) value);
 522             }
 523             if (value instanceof float[]) {
 524                 return Arrays.toString((float[]) value);
 525             }
 526             if (value instanceof double[]) {
 527                 return Arrays.toString((double[]) value);
 528             }
 529             if (value instanceof Object[]) {
 530                 return Arrays.toString((Object[]) value);
 531             }
 532             return String.valueOf(value);
 533         }
 534     }
 535 
 536     @NodeInfo(cycles = CYCLES_IGNORED, size = SIZE_IGNORED)
 537     static final class VarargsPlaceholderNode extends FloatingNode implements ArrayLengthProvider {
 538 
 539         public static final NodeClass&lt;VarargsPlaceholderNode&gt; TYPE = NodeClass.create(VarargsPlaceholderNode.class);
 540         protected final Varargs varargs;
 541 
 542         protected VarargsPlaceholderNode(Varargs varargs, MetaAccessProvider metaAccess) {
 543             super(TYPE, StampFactory.objectNonNull(TypeReference.createExactTrusted(metaAccess.lookupJavaType(varargs.componentType).getArrayClass())));
 544             this.varargs = varargs;
 545         }
 546 
 547         @Override
 548         public ValueNode findLength(FindLengthMode mode, ConstantReflectionProvider constantReflection) {
 549             return ConstantNode.forInt(varargs.length);
 550         }
 551     }
 552 
 553     static class CacheKey {
 554 
 555         private final ResolvedJavaMethod method;
 556         private final Object[] values;
 557         private final GuardsStage guardsStage;
 558         private final LoweringTool.LoweringStage loweringStage;
 559         private int hash;
 560 
 561         protected CacheKey(SnippetInfo info, GuardsStage guardsStage, LoweringTool.LoweringStage loweringStage) {
 562             this.method = info.method;
 563             this.guardsStage = guardsStage;
 564             this.loweringStage = loweringStage;
 565             this.values = new Object[info.getParameterCount()];
 566             this.hash = info.method.hashCode() + 31 * guardsStage.ordinal();
 567         }
 568 
 569         protected void setParam(int paramIdx, Object value) {
 570             values[paramIdx] = value;
 571             hash = (hash * 31) ^ (value == null ? 0 : value.hashCode());
 572         }
 573 
 574         @Override
 575         public boolean equals(Object obj) {
 576             if (!(obj instanceof CacheKey)) {
 577                 return false;
 578             }
 579             CacheKey other = (CacheKey) obj;
 580             if (!method.equals(other.method)) {
 581                 return false;
 582             }
 583             if (guardsStage != other.guardsStage || loweringStage != other.loweringStage) {
 584                 return false;
 585             }
 586             for (int i = 0; i &lt; values.length; i++) {
 587                 if (values[i] != null &amp;&amp; !values[i].equals(other.values[i])) {
 588                     return false;
 589                 }
 590             }
 591             return true;
 592         }
 593 
 594         @Override
 595         public int hashCode() {
 596             return hash;
 597         }
 598     }
 599 
 600     private static final TimerKey SnippetTemplateCreationTime = DebugContext.timer(&quot;SnippetTemplateCreationTime&quot;);
 601     private static final CounterKey SnippetTemplates = DebugContext.counter(&quot;SnippetTemplateCount&quot;);
 602 
 603     static class Options {
 604         @Option(help = &quot;Use a LRU cache for snippet templates.&quot;)//
 605         public static final OptionKey&lt;Boolean&gt; UseSnippetTemplateCache = new OptionKey&lt;&gt;(true);
 606 
 607         @Option(help = &quot;&quot;)//
 608         static final OptionKey&lt;Integer&gt; MaxTemplatesPerSnippet = new OptionKey&lt;&gt;(50);
 609     }
 610 
 611     /**
 612      * Base class for snippet classes. It provides a cache for {@link SnippetTemplate}s.
 613      */
 614     public abstract static class AbstractTemplates implements org.graalvm.compiler.api.replacements.SnippetTemplateCache {
 615 
 616         protected final OptionValues options;
 617         protected final Providers providers;
 618         protected final SnippetReflectionProvider snippetReflection;
 619         protected final Iterable&lt;DebugHandlersFactory&gt; factories;
 620         protected final TargetDescription target;
 621         private final Map&lt;CacheKey, SnippetTemplate&gt; templates;
 622 
 623         protected AbstractTemplates(OptionValues options, Iterable&lt;DebugHandlersFactory&gt; factories, Providers providers, SnippetReflectionProvider snippetReflection, TargetDescription target) {
 624             this.options = options;
 625             this.providers = providers;
 626             this.snippetReflection = snippetReflection;
 627             this.target = target;
 628             this.factories = factories;
 629             if (Options.UseSnippetTemplateCache.getValue(options)) {
 630                 int size = Options.MaxTemplatesPerSnippet.getValue(options);
 631                 this.templates = Collections.synchronizedMap(new LRUCache&lt;&gt;(size, size));
 632             } else {
 633                 this.templates = null;
 634             }
 635         }
 636 
 637         public Providers getProviders() {
 638             return providers;
 639         }
 640 
 641         public static Method findMethod(Class&lt;? extends Snippets&gt; declaringClass, String methodName, Method except) {
 642             for (Method m : declaringClass.getDeclaredMethods()) {
 643                 if (m.getName().equals(methodName) &amp;&amp; !m.equals(except)) {
 644                     return m;
 645                 }
 646             }
 647             return null;
 648         }
 649 
 650         public static ResolvedJavaMethod findMethod(MetaAccessProvider metaAccess, Class&lt;?&gt; declaringClass, String methodName) {
 651             ResolvedJavaType type = metaAccess.lookupJavaType(declaringClass);
 652             ResolvedJavaMethod result = null;
 653             for (ResolvedJavaMethod m : type.getDeclaredMethods()) {
 654                 if (m.getName().equals(methodName)) {
 655                     if (!Assertions.assertionsEnabled()) {
 656                         return m;
 657                     } else {
 658                         assert result == null : &quot;multiple definitions found&quot;;
 659                         result = m;
 660                     }
 661                 }
 662             }
 663             if (result == null) {
 664                 throw new GraalError(&quot;Could not find method in &quot; + declaringClass + &quot; named &quot; + methodName);
 665             }
 666             return result;
 667         }
 668 
 669         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, LocationIdentity... initialPrivateLocations) {
 670             return snippet(declaringClass, methodName, null, null, initialPrivateLocations);
 671         }
 672 
 673         /**
 674          * Finds the unique method in {@code declaringClass} named {@code methodName} annotated by
 675          * {@link Snippet} and returns a {@link SnippetInfo} value describing it. There must be
 676          * exactly one snippet method in {@code declaringClass} with a given name.
 677          */
 678         protected SnippetInfo snippet(Class&lt;? extends Snippets&gt; declaringClass, String methodName, ResolvedJavaMethod original, Object receiver, LocationIdentity... initialPrivateLocations) {
 679             assert methodName != null;
 680             ResolvedJavaMethod javaMethod = findMethod(providers.getMetaAccess(), declaringClass, methodName);
 681             assert javaMethod != null : &quot;did not find @&quot; + Snippet.class.getSimpleName() + &quot; method in &quot; + declaringClass + &quot; named &quot; + methodName;
 682             assert javaMethod.getAnnotation(Snippet.class) != null : javaMethod + &quot; must be annotated with @&quot; + Snippet.class.getSimpleName();
 683             providers.getReplacements().registerSnippet(javaMethod, original, receiver, GraalOptions.TrackNodeSourcePosition.getValue(options), options);
 684             LocationIdentity[] privateLocations = GraalOptions.SnippetCounters.getValue(options) ? SnippetCounterNode.addSnippetCounters(initialPrivateLocations) : initialPrivateLocations;
 685             if (GraalOptions.EagerSnippets.getValue(options)) {
 686                 return new EagerSnippetInfo(javaMethod, original, privateLocations, receiver);
 687             } else {
 688                 return new LazySnippetInfo(javaMethod, original, privateLocations, receiver);
 689             }
 690         }
 691 
 692         static final AtomicInteger nextSnippetTemplateId = new AtomicInteger();
 693 
 694         private DebugContext openDebugContext(DebugContext outer, Arguments args) {
 695             if (DebugStubsAndSnippets.getValue(options)) {
 696                 Description description = new Description(args.cacheKey.method, &quot;SnippetTemplate_&quot; + nextSnippetTemplateId.incrementAndGet());
 697                 return DebugContext.create(options, description, outer.getGlobalMetrics(), DEFAULT_LOG_STREAM, factories);
 698             }
 699             return DebugContext.disabled(options);
 700         }
 701 
 702         /**
 703          * Gets a template for a given key, creating it first if necessary.
 704          */
 705         @SuppressWarnings(&quot;try&quot;)
 706         public SnippetTemplate template(ValueNode replacee, final Arguments args) {
 707             StructuredGraph graph = replacee.graph();
 708             DebugContext outer = graph.getDebug();
 709             SnippetTemplate template = Options.UseSnippetTemplateCache.getValue(options) &amp;&amp; args.cacheable ? templates.get(args.cacheKey) : null;
 710             if (template == null || (graph.trackNodeSourcePosition() &amp;&amp; !template.snippet.trackNodeSourcePosition())) {
 711                 try (DebugContext debug = openDebugContext(outer, args)) {
 712                     try (DebugCloseable a = SnippetTemplateCreationTime.start(debug); DebugContext.Scope s = debug.scope(&quot;SnippetSpecialization&quot;, args.info.method)) {
 713                         SnippetTemplates.increment(debug);
 714                         OptionValues snippetOptions = new OptionValues(options, GraalOptions.TraceInlining, GraalOptions.TraceInliningForStubsAndSnippets.getValue(options));
 715                         template = new SnippetTemplate(snippetOptions, debug, providers, snippetReflection, args, graph.trackNodeSourcePosition(), replacee);
 716                         if (Options.UseSnippetTemplateCache.getValue(snippetOptions) &amp;&amp; args.cacheable) {
 717                             templates.put(args.cacheKey, template);
 718                         }
 719                     } catch (Throwable e) {
 720                         throw debug.handle(e);
 721                     }
 722                 }
 723             }
 724             return template;
 725         }
 726     }
 727 
 728     private static final class LRUCache&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; {
 729         private static final long serialVersionUID = 1L;
 730         private final int maxCacheSize;
 731 
 732         LRUCache(int initialCapacity, int maxCacheSize) {
 733             super(initialCapacity, 0.75F, true);
 734             this.maxCacheSize = maxCacheSize;
 735         }
 736 
 737         @Override
 738         protected boolean removeEldestEntry(java.util.Map.Entry&lt;K, V&gt; eldest) {
 739             return size() &gt; maxCacheSize;
 740         }
 741     }
 742 
 743     // These values must be compared with equals() not &#39;==&#39; to support replay compilation.
 744     private static final Object UNUSED_PARAMETER = &quot;UNUSED_PARAMETER&quot;;
 745     private static final Object CONSTANT_PARAMETER = &quot;CONSTANT_PARAMETER&quot;;
 746 
 747     /**
 748      * Determines if any parameter of a given method is annotated with {@link ConstantParameter}.
 749      */
 750     public static boolean hasConstantParameter(ResolvedJavaMethod method) {
 751         for (ConstantParameter p : method.getParameterAnnotations(ConstantParameter.class)) {
 752             if (p != null) {
 753                 return true;
 754             }
 755         }
 756         return false;
 757     }
 758 
 759     private final SnippetReflectionProvider snippetReflection;
 760 
 761     /**
 762      * Creates a snippet template.
 763      */
 764     @SuppressWarnings(&quot;try&quot;)
 765     protected SnippetTemplate(OptionValues options, DebugContext debug, final Providers providers, SnippetReflectionProvider snippetReflection, Arguments args, boolean trackNodeSourcePosition,
 766                     Node replacee) {
 767         this.snippetReflection = snippetReflection;
 768         this.info = args.info;
 769 
 770         Object[] constantArgs = getConstantArgs(args);
 771         boolean shouldTrackNodeSourcePosition1 = trackNodeSourcePosition || (providers.getCodeCache() != null &amp;&amp; providers.getCodeCache().shouldDebugNonSafepoints());
 772         StructuredGraph snippetGraph = providers.getReplacements().getSnippet(args.info.method, args.info.original, constantArgs, shouldTrackNodeSourcePosition1, replacee.getNodeSourcePosition(),
 773                         options);
 774 
 775         ResolvedJavaMethod method = snippetGraph.method();
 776         Signature signature = method.getSignature();
 777 
 778         // Copy snippet graph, replacing constant parameters with given arguments
 779         final StructuredGraph snippetCopy = new StructuredGraph.Builder(options, debug).name(snippetGraph.name).method(snippetGraph.method()).trackNodeSourcePosition(
 780                         snippetGraph.trackNodeSourcePosition()).setIsSubstitution(true).build();
 781         assert !GraalOptions.TrackNodeSourcePosition.getValue(options) || snippetCopy.trackNodeSourcePosition();
 782         try (DebugContext.Scope scope = debug.scope(&quot;SpecializeSnippet&quot;, snippetCopy)) {
 783             if (!snippetGraph.isUnsafeAccessTrackingEnabled()) {
 784                 snippetCopy.disableUnsafeAccessTracking();
 785             }
 786 
 787             EconomicMap&lt;Node, Node&gt; nodeReplacements = EconomicMap.create(Equivalence.IDENTITY);
 788             nodeReplacements.put(snippetGraph.start(), snippetCopy.start());
 789 
 790             MetaAccessProvider metaAccess = providers.getMetaAccess();
 791             assert checkTemplate(metaAccess, args, method, signature);
 792 
 793             int parameterCount = args.info.getParameterCount();
 794             VarargsPlaceholderNode[] placeholders = new VarargsPlaceholderNode[parameterCount];
 795 
 796             for (int i = 0; i &lt; parameterCount; i++) {
 797                 ParameterNode parameter = snippetGraph.getParameter(i);
 798                 if (parameter != null) {
 799                     if (args.info.isConstantParameter(i)) {
 800                         Object arg = args.values[i];
 801                         JavaKind kind = signature.getParameterKind(i);
 802                         ConstantNode constantNode;
 803                         if (arg instanceof Constant) {
 804                             Stamp stamp = args.constStamps[i];
 805                             if (stamp == null) {
 806                                 assert arg instanceof JavaConstant : &quot;could not determine type of constant &quot; + arg;
 807                                 constantNode = ConstantNode.forConstant((JavaConstant) arg, metaAccess, snippetCopy);
 808                             } else {
 809                                 constantNode = ConstantNode.forConstant(stamp, (Constant) arg, metaAccess, snippetCopy);
 810                             }
 811                         } else {
 812                             constantNode = ConstantNode.forConstant(snippetReflection.forBoxed(kind, arg), metaAccess, snippetCopy);
 813                         }
 814                         nodeReplacements.put(parameter, constantNode);
 815                     } else if (args.info.isVarargsParameter(i)) {
 816                         Varargs varargs = (Varargs) args.values[i];
 817                         VarargsPlaceholderNode placeholder = snippetCopy.unique(new VarargsPlaceholderNode(varargs, providers.getMetaAccess()));
 818                         nodeReplacements.put(parameter, placeholder);
 819                         placeholders[i] = placeholder;
 820                     } else if (args.info.isNonNullParameter(i)) {
 821                         parameter.setStamp(parameter.stamp(NodeView.DEFAULT).join(StampFactory.objectNonNull()));
 822                     }
 823                 }
 824             }
 825             try (InliningLog.UpdateScope updateScope = snippetCopy.getInliningLog().openDefaultUpdateScope()) {
 826                 UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = snippetCopy.addDuplicates(snippetGraph.getNodes(), snippetGraph, snippetGraph.getNodeCount(), nodeReplacements);
 827                 if (updateScope != null) {
 828                     snippetCopy.getInliningLog().replaceLog(duplicates, snippetGraph.getInliningLog());
 829                 }
 830             }
 831 
 832             debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;Before specialization&quot;);
 833 
 834             // Gather the template parameters
 835             parameters = new Object[parameterCount];
 836             for (int i = 0; i &lt; parameterCount; i++) {
 837                 if (args.info.isConstantParameter(i)) {
 838                     parameters[i] = CONSTANT_PARAMETER;
 839                 } else if (args.info.isVarargsParameter(i)) {
 840                     assert snippetCopy.getParameter(i) == null;
 841                     Varargs varargs = (Varargs) args.values[i];
 842                     int length = varargs.length;
 843                     ParameterNode[] params = new ParameterNode[length];
 844                     Stamp stamp = varargs.stamp;
 845                     for (int j = 0; j &lt; length; j++) {
 846                         // Use a decimal friendly numbering make it more obvious how values map
 847                         assert parameterCount &lt; 10000;
 848                         int idx = (i + 1) * 10000 + j;
 849                         assert idx &gt;= parameterCount : &quot;collision in parameter numbering&quot;;
 850                         ParameterNode local = snippetCopy.addOrUnique(new ParameterNode(idx, StampPair.createSingle(stamp)));
 851                         params[j] = local;
 852                     }
 853                     parameters[i] = params;
 854 
 855                     VarargsPlaceholderNode placeholder = placeholders[i];
 856                     if (placeholder != null) {
 857                         for (Node usage : placeholder.usages().snapshot()) {
 858                             if (usage instanceof LoadIndexedNode) {
 859                                 LoadIndexedNode loadIndexed = (LoadIndexedNode) usage;
 860                                 debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;Before replacing %s&quot;, loadIndexed);
 861                                 LoadSnippetVarargParameterNode loadSnippetParameter = snippetCopy.add(
 862                                                 new LoadSnippetVarargParameterNode(params, loadIndexed.index(), loadIndexed.stamp(NodeView.DEFAULT)));
 863                                 snippetCopy.replaceFixedWithFixed(loadIndexed, loadSnippetParameter);
 864                                 debug.dump(DebugContext.INFO_LEVEL, snippetCopy, &quot;After replacing %s&quot;, loadIndexed);
 865                             } else if (usage instanceof StoreIndexedNode) {
 866                                 /*
 867                                  * The template lowering doesn&#39;t really treat this as an array so
 868                                  * you can&#39;t store back into the varargs. Allocate your own array if
 869                                  * you really need this and EA should eliminate it.
 870                                  */
 871                                 throw new GraalError(&quot;Can&#39;t store into VarargsParameter array&quot;);
 872                             }
 873                         }
 874                     }
 875                 } else {
 876                     ParameterNode local = snippetCopy.getParameter(i);
 877                     if (local == null) {
 878                         // Parameter value was eliminated
 879                         parameters[i] = UNUSED_PARAMETER;
 880                     } else {
 881                         parameters[i] = local;
 882                     }
 883                 }
 884             }
 885 
 886             explodeLoops(snippetCopy, providers);
 887 
 888             GuardsStage guardsStage = args.cacheKey.guardsStage;
 889             // Perform lowering on the snippet
 890             if (!guardsStage.allowsFloatingGuards()) {
 891                 new GuardLoweringPhase().apply(snippetCopy, null);
 892             }
 893             snippetCopy.setGuardsStage(guardsStage);
 894             try (DebugContext.Scope s = debug.scope(&quot;LoweringSnippetTemplate&quot;, snippetCopy)) {
 895                 new LoweringPhase(CanonicalizerPhase.create(), args.cacheKey.loweringStage).apply(snippetCopy, providers);
 896             } catch (Throwable e) {
 897                 throw debug.handle(e);
 898             }
 899 
 900             ArrayList&lt;StateSplit&gt; curSideEffectNodes = new ArrayList&lt;&gt;();
 901             ArrayList&lt;DeoptimizingNode&gt; curDeoptNodes = new ArrayList&lt;&gt;();
 902             ArrayList&lt;ValueNode&gt; curPlaceholderStampedNodes = new ArrayList&lt;&gt;();
 903             for (Node node : snippetCopy.getNodes()) {
 904                 if (node instanceof ValueNode) {
 905                     ValueNode valueNode = (ValueNode) node;
 906                     if (valueNode.stamp(NodeView.DEFAULT) == PlaceholderStamp.singleton()) {
 907                         curPlaceholderStampedNodes.add(valueNode);
 908                     }
 909                 }
 910 
 911                 if (node instanceof StateSplit) {
 912                     StateSplit stateSplit = (StateSplit) node;
 913                     FrameState frameState = stateSplit.stateAfter();
 914                     if (stateSplit.hasSideEffect()) {
 915                         curSideEffectNodes.add((StateSplit) node);
 916                     }
 917                     if (frameState != null) {
 918                         stateSplit.setStateAfter(null);
 919                     }
 920                 }
 921                 if (node instanceof DeoptimizingNode) {
 922                     DeoptimizingNode deoptNode = (DeoptimizingNode) node;
 923                     if (deoptNode.canDeoptimize()) {
 924                         curDeoptNodes.add(deoptNode);
 925                     }
 926                 }
 927             }
 928 
 929             new DeadCodeEliminationPhase(Required).apply(snippetCopy);
 930 
 931             assert checkAllVarargPlaceholdersAreDeleted(parameterCount, placeholders);
 932 
 933             if (((StructuredGraph) replacee.graph()).isAfterFloatingReadPhase()) {
 934                 new FloatingReadPhase(true, true).apply(snippetCopy);
 935             }
 936 
 937             if (!guardsStage.requiresValueProxies()) {
 938                 new RemoveValueProxyPhase().apply(snippetCopy);
 939             }
 940 
<a name="3" id="anc3"></a><span class="line-modified"> 941             MemoryAnchorNode anchor = snippetCopy.add(new MemoryAnchorNode(info.privateLocations));</span>
 942             snippetCopy.start().replaceAtUsages(InputType.Memory, anchor);
 943 
 944             this.snippet = snippetCopy;
 945 
 946             StartNode entryPointNode = snippet.start();
 947             if (anchor.hasNoUsages()) {
 948                 anchor.safeDelete();
 949                 this.memoryAnchor = null;
 950             } else {
 951                 // Find out if all the return memory maps point to the anchor (i.e., there&#39;s no kill
 952                 // anywhere)
 953                 boolean needsMemoryMaps = false;
 954                 for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 955                     MemoryMapNode memoryMap = retNode.getMemoryMap();
 956                     if (memoryMap.getLocations().size() &gt; 1 || memoryMap.getLastLocationAccess(LocationIdentity.any()) != anchor) {
 957                         needsMemoryMaps = true;
 958                         break;
 959                     }
 960                 }
 961                 boolean needsAnchor;
 962                 if (needsMemoryMaps) {
 963                     needsAnchor = true;
 964                 } else {
 965                     // Check that all those memory maps where the only usages of the anchor
 966                     needsAnchor = anchor.usages().filter(isNotA(MemoryMapNode.class)).isNotEmpty();
 967                     // Remove the useless memory map
 968                     MemoryMapNode memoryMap = null;
 969                     for (ReturnNode retNode : snippet.getNodes(ReturnNode.TYPE)) {
 970                         if (memoryMap == null) {
 971                             memoryMap = retNode.getMemoryMap();
 972                         } else {
 973                             assert memoryMap == retNode.getMemoryMap();
 974                         }
 975                         retNode.setMemoryMap(null);
 976                     }
 977                     if (memoryMap != null) {
 978                         memoryMap.safeDelete();
 979                     }
 980                 }
 981                 if (needsAnchor) {
 982                     snippetCopy.addAfterFixed(snippetCopy.start(), anchor);
 983                     this.memoryAnchor = anchor;
 984                 } else {
 985                     anchor.safeDelete();
 986                     this.memoryAnchor = null;
 987                 }
 988             }
 989             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate after fixing memory anchoring&quot;);
 990 
 991             List&lt;ReturnNode&gt; returnNodes = snippet.getNodes(ReturnNode.TYPE).snapshot();
 992             if (returnNodes.isEmpty()) {
 993                 this.returnNode = null;
 994             } else if (returnNodes.size() == 1) {
 995                 this.returnNode = returnNodes.get(0);
 996             } else {
 997                 AbstractMergeNode merge = snippet.add(new MergeNode());
 998                 List&lt;MemoryMapNode&gt; memMaps = new ArrayList&lt;&gt;();
 999                 for (ReturnNode retNode : returnNodes) {
1000                     MemoryMapNode memoryMapNode = retNode.getMemoryMap();
1001                     if (memoryMapNode != null) {
1002                         memMaps.add(memoryMapNode);
1003                     }
1004                 }
1005 
1006                 ValueNode returnValue = InliningUtil.mergeReturns(merge, returnNodes);
1007                 this.returnNode = snippet.add(new ReturnNode(returnValue));
1008                 if (!memMaps.isEmpty()) {
1009                     MemoryMapImpl mmap = FloatingReadPhase.mergeMemoryMaps(merge, memMaps);
1010                     MemoryMapNode memoryMap = snippet.unique(new MemoryMapNode(mmap.getMap()));
1011                     this.returnNode.setMemoryMap(memoryMap);
1012                     for (MemoryMapNode mm : memMaps) {
1013                         if (mm != memoryMap &amp;&amp; mm.isAlive()) {
1014                             assert mm.hasNoUsages();
1015                             GraphUtil.killWithUnusedFloatingInputs(mm);
1016                         }
1017                     }
1018                 }
1019                 merge.setNext(this.returnNode);
1020             }
1021 
1022             assert verifyIntrinsicsProcessed(snippetCopy);
1023 
1024             this.sideEffectNodes = curSideEffectNodes;
1025             this.deoptNodes = curDeoptNodes;
1026             this.placeholderStampedNodes = curPlaceholderStampedNodes;
1027 
1028             nodes = new ArrayList&lt;&gt;(snippet.getNodeCount());
1029             for (Node node : snippet.getNodes()) {
1030                 if (node != entryPointNode &amp;&amp; node != entryPointNode.stateAfter()) {
1031                     nodes.add(node);
1032                 }
1033             }
1034 
1035             if (debug.areMetricsEnabled()) {
1036                 DebugContext.counter(&quot;SnippetTemplateNodeCount[%#s]&quot;, args).add(debug, nodes.size());
1037             }
1038             debug.dump(DebugContext.INFO_LEVEL, snippet, &quot;SnippetTemplate final state&quot;);
1039             this.snippet.freeze();
1040 
1041         } catch (Throwable ex) {
1042             throw debug.handle(ex);
1043         }
1044     }
1045 
1046     private static boolean verifyIntrinsicsProcessed(StructuredGraph snippetCopy) {
1047         for (MethodCallTargetNode target : snippetCopy.getNodes(MethodCallTargetNode.TYPE)) {
1048             ResolvedJavaMethod targetMethod = target.targetMethod();
1049             if (targetMethod != null) {
1050                 assert targetMethod.getAnnotation(Fold.class) == null &amp;&amp; targetMethod.getAnnotation(NodeIntrinsic.class) == null : &quot;plugin should have been processed&quot;;
1051             }
1052         }
1053         return true;
1054     }
1055 
1056     public static void explodeLoops(final StructuredGraph snippetCopy, CoreProviders providers) {
1057         // Do any required loop explosion
1058         boolean exploded = false;
1059         do {
1060             exploded = false;
1061             ExplodeLoopNode explodeLoop = snippetCopy.getNodes().filter(ExplodeLoopNode.class).first();
1062             if (explodeLoop != null) { // Earlier canonicalization may have removed the loop
1063                 // altogether
1064                 LoopBeginNode loopBegin = explodeLoop.findLoopBegin();
1065                 if (loopBegin != null) {
1066                     LoopEx loop = new LoopsData(snippetCopy).loop(loopBegin);
1067                     Mark mark = snippetCopy.getMark();
1068                     CanonicalizerPhase canonicalizer = null;
1069                     if (GraalOptions.ImmutableCode.getValue(snippetCopy.getOptions())) {
1070                         canonicalizer = CanonicalizerPhase.createWithoutReadCanonicalization();
1071                     } else {
1072                         canonicalizer = CanonicalizerPhase.create();
1073                     }
1074                     LoopTransformations.fullUnroll(loop, providers, canonicalizer);
1075                     CanonicalizerPhase.create().applyIncremental(snippetCopy, providers, mark, false);
1076                     loop.deleteUnusedNodes();
1077                 }
1078                 GraphUtil.removeFixedWithUnusedInputs(explodeLoop);
1079                 exploded = true;
1080             }
1081         } while (exploded);
1082     }
1083 
1084     protected Object[] getConstantArgs(Arguments args) {
1085         Object[] constantArgs = args.values.clone();
1086         for (int i = 0; i &lt; args.info.getParameterCount(); i++) {
1087             if (!args.info.isConstantParameter(i)) {
1088                 constantArgs[i] = null;
1089             } else {
1090                 assert constantArgs[i] != null : &quot;Can&#39;t pass raw null through as argument&quot;;
1091             }
1092         }
1093         return constantArgs;
1094     }
1095 
1096     private static boolean checkAllVarargPlaceholdersAreDeleted(int parameterCount, VarargsPlaceholderNode[] placeholders) {
1097         for (int i = 0; i &lt; parameterCount; i++) {
1098             if (placeholders[i] != null) {
1099                 assert placeholders[i].isDeleted() : placeholders[i];
1100             }
1101         }
1102         return true;
1103     }
1104 
1105     private static boolean checkConstantArgument(MetaAccessProvider metaAccess, final ResolvedJavaMethod method, Signature signature, int paramIndex, String name, Object arg, JavaKind kind) {
1106         ResolvedJavaType type = signature.getParameterType(paramIndex, method.getDeclaringClass()).resolve(method.getDeclaringClass());
1107         if (metaAccess.lookupJavaType(WordBase.class).isAssignableFrom(type)) {
1108             assert arg instanceof JavaConstant : method + &quot;: word constant parameters must be passed boxed in a Constant value: &quot; + arg;
1109             return true;
1110         }
1111         if (kind != JavaKind.Object) {
1112             assert arg != null &amp;&amp; kind.toBoxedJavaClass() == arg.getClass() : method + &quot;: wrong value kind for &quot; + name + &quot;: expected &quot; + kind + &quot;, got &quot; +
1113                             (arg == null ? &quot;null&quot; : arg.getClass().getSimpleName());
1114         }
1115         return true;
1116     }
1117 
1118     private static boolean checkVarargs(MetaAccessProvider metaAccess, final ResolvedJavaMethod method, Signature signature, int i, String name, Varargs varargs) {
1119         ResolvedJavaType type = (ResolvedJavaType) signature.getParameterType(i, method.getDeclaringClass());
1120         assert type.isArray() : &quot;varargs parameter must be an array type&quot;;
1121         assert type.getComponentType().isAssignableFrom(metaAccess.lookupJavaType(varargs.componentType)) : &quot;componentType for &quot; + name + &quot; not matching &quot; + type.toJavaName() + &quot; instance: &quot; +
1122                         varargs.componentType;
1123         return true;
1124     }
1125 
1126     /**
1127      * The graph built from the snippet method.
1128      */
1129     private final StructuredGraph snippet;
1130 
1131     private final SnippetInfo info;
1132 
1133     /**
1134      * The named parameters of this template that must be bound to values during instantiation. For
1135      * a parameter that is still live after specialization, the value in this map is either a
1136      * {@link ParameterNode} instance or a {@link ParameterNode} array. For an eliminated parameter,
1137      * the value is identical to the key.
1138      */
1139     private final Object[] parameters;
1140 
1141     /**
1142      * The return node (if any) of the snippet.
1143      */
1144     private final ReturnNode returnNode;
1145 
1146     /**
1147      * The memory anchor (if any) of the snippet.
1148      */
1149     private final MemoryAnchorNode memoryAnchor;
1150 
1151     /**
1152      * Nodes that inherit the {@link StateSplit#stateAfter()} from the replacee during
1153      * instantiation.
1154      */
1155     private final ArrayList&lt;StateSplit&gt; sideEffectNodes;
1156 
1157     /**
1158      * Nodes that inherit a deoptimization {@link FrameState} from the replacee during
1159      * instantiation.
1160      */
1161     private final ArrayList&lt;DeoptimizingNode&gt; deoptNodes;
1162 
1163     /**
1164      * Nodes that have a stamp originating from a {@link Placeholder}.
1165      */
1166     private final ArrayList&lt;ValueNode&gt; placeholderStampedNodes;
1167 
1168     /**
1169      * The nodes to be inlined when this specialization is instantiated.
1170      */
1171     private final ArrayList&lt;Node&gt; nodes;
1172 
1173     /**
1174      * Gets the instantiation-time bindings to this template&#39;s parameters.
1175      *
1176      * @return the map that will be used to bind arguments to parameters when inlining this template
1177      */
1178     private EconomicMap&lt;Node, Node&gt; bind(StructuredGraph replaceeGraph, MetaAccessProvider metaAccess, Arguments args) {
1179         EconomicMap&lt;Node, Node&gt; replacements = EconomicMap.create(Equivalence.IDENTITY);
1180         assert args.info.getParameterCount() == parameters.length : &quot;number of args (&quot; + args.info.getParameterCount() + &quot;) != number of parameters (&quot; + parameters.length + &quot;)&quot;;
1181         for (int i = 0; i &lt; parameters.length; i++) {
1182             Object parameter = parameters[i];
1183             assert parameter != null : this + &quot; has no parameter named &quot; + args.info.getParameterName(i);
1184             Object argument = args.values[i];
1185             if (parameter instanceof ParameterNode) {
1186                 if (argument instanceof ValueNode) {
1187                     replacements.put((ParameterNode) parameter, (ValueNode) argument);
1188                 } else {
1189                     JavaKind kind = ((ParameterNode) parameter).getStackKind();
1190                     assert argument != null || kind == JavaKind.Object : this + &quot; cannot accept null for non-object parameter named &quot; + args.info.getParameterName(i);
1191                     JavaConstant constant = forBoxed(argument, kind);
1192                     replacements.put((ParameterNode) parameter, ConstantNode.forConstant(constant, metaAccess, replaceeGraph));
1193                 }
1194             } else if (parameter instanceof ParameterNode[]) {
1195                 ParameterNode[] params = (ParameterNode[]) parameter;
1196                 Varargs varargs = (Varargs) argument;
1197                 int length = params.length;
1198                 List&lt;?&gt; list = null;
1199                 Object array = null;
1200                 if (varargs.value instanceof List) {
1201                     list = (List&lt;?&gt;) varargs.value;
1202                     assert list.size() == length : length + &quot; != &quot; + list.size();
1203                 } else {
1204                     array = varargs.value;
1205                     assert array != null &amp;&amp; array.getClass().isArray();
1206                     assert Array.getLength(array) == length : length + &quot; != &quot; + Array.getLength(array);
1207                 }
1208 
1209                 for (int j = 0; j &lt; length; j++) {
1210                     ParameterNode param = params[j];
1211                     assert param != null;
1212                     Object value = list != null ? list.get(j) : Array.get(array, j);
1213                     if (value instanceof ValueNode) {
1214                         replacements.put(param, (ValueNode) value);
1215                     } else {
1216                         JavaConstant constant = forBoxed(value, param.getStackKind());
1217                         ConstantNode element = ConstantNode.forConstant(constant, metaAccess, replaceeGraph);
1218                         replacements.put(param, element);
1219                     }
1220                 }
1221             } else {
1222                 assert parameter.equals(CONSTANT_PARAMETER) || parameter.equals(UNUSED_PARAMETER) : &quot;unexpected entry for parameter: &quot; + args.info.getParameterName(i) + &quot; -&gt; &quot; + parameter;
1223             }
1224         }
1225         return replacements;
1226     }
1227 
1228     /**
1229      * Converts a Java boxed value to a {@link JavaConstant} of the right kind. This adjusts for the
1230      * limitation that a {@link Local}&#39;s kind is a {@linkplain JavaKind#getStackKind() stack kind}
1231      * and so cannot be used for re-boxing primitives smaller than an int.
1232      *
1233      * @param argument a Java boxed value
1234      * @param localKind the kind of the {@link Local} to which {@code argument} will be bound
1235      */
1236     protected JavaConstant forBoxed(Object argument, JavaKind localKind) {
1237         assert localKind == localKind.getStackKind();
1238         if (localKind == JavaKind.Int) {
1239             return JavaConstant.forBoxedPrimitive(argument);
1240         }
1241         return snippetReflection.forBoxed(localKind, argument);
1242     }
1243 
1244     /**
1245      * Logic for replacing a snippet-lowered node at its usages with the return value of the
1246      * snippet. An alternative to the {@linkplain SnippetTemplate#DEFAULT_REPLACER default}
1247      * replacement logic can be used to handle mismatches between the stamp of the node being
1248      * lowered and the stamp of the snippet&#39;s return value.
1249      */
1250     public interface UsageReplacer {
1251         /**
1252          * Replaces all usages of {@code oldNode} with direct or indirect usages of {@code newNode}.
1253          */
1254         void replace(ValueNode oldNode, ValueNode newNode);
1255     }
1256 
1257     /**
1258      * Represents the default {@link UsageReplacer usage replacer} logic which simply delegates to
1259      * {@link Node#replaceAtUsages(Node)}.
1260      */
1261     public static final UsageReplacer DEFAULT_REPLACER = new UsageReplacer() {
1262 
1263         @Override
1264         public void replace(ValueNode oldNode, ValueNode newNode) {
1265             if (newNode == null) {
1266                 assert oldNode.hasNoUsages();
1267             } else {
1268                 oldNode.replaceAtUsages(newNode);
1269             }
1270         }
1271     };
1272 
1273     private boolean assertSnippetKills(ValueNode replacee) {
1274         if (!replacee.graph().isAfterFloatingReadPhase()) {
1275             // no floating reads yet, ignore locations created while lowering
1276             return true;
1277         }
1278         if (returnNode == null) {
1279             // The snippet terminates control flow
1280             return true;
1281         }
1282         MemoryMapNode memoryMap = returnNode.getMemoryMap();
1283         if (memoryMap == null || memoryMap.isEmpty()) {
1284             // there are no kills in the snippet graph
1285             return true;
1286         }
1287 
1288         EconomicSet&lt;LocationIdentity&gt; kills = EconomicSet.create(Equivalence.DEFAULT);
1289         kills.addAll(memoryMap.getLocations());
1290 
1291         if (replacee instanceof SingleMemoryKill) {
1292             // check if some node in snippet graph also kills the same location
1293             LocationIdentity locationIdentity = ((SingleMemoryKill) replacee).getKilledLocationIdentity();
1294             if (locationIdentity.isAny()) {
1295                 assert !(memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) : replacee + &quot; kills ANY_LOCATION, but snippet does not&quot;;
1296                 // if the replacee kills ANY_LOCATION, the snippet can kill arbitrary locations
1297                 return true;
1298             }
1299             assert kills.contains(locationIdentity) : replacee + &quot; kills &quot; + locationIdentity + &quot;, but snippet doesn&#39;t contain a kill to this location&quot;;
1300             kills.remove(locationIdentity);
1301         }
1302         assert !(replacee instanceof MultiMemoryKill) : replacee + &quot; multi not supported (yet)&quot;;
1303 
1304         // remove ANY_LOCATION if it&#39;s just a kill by the start node
1305         if (memoryMap.getLastLocationAccess(any()) instanceof MemoryAnchorNode) {
1306             kills.remove(any());
1307         }
1308 
1309         // node can only lower to a ANY_LOCATION kill if the replacee also kills ANY_LOCATION
1310         assert !kills.contains(any()) : &quot;snippet graph contains a kill to ANY_LOCATION, but replacee (&quot; + replacee + &quot;) doesn&#39;t kill ANY_LOCATION.  kills: &quot; + kills;
1311 
1312         /*
1313          * Kills to private locations are safe, since there can be no floating read to these
1314          * locations except reads that are introduced by the snippet itself or related snippets in
1315          * the same lowering round. These reads are anchored to a MemoryAnchor at the beginning of
1316          * their snippet, so they can not float above a kill in another instance of the same
1317          * snippet.
1318          */
1319         for (LocationIdentity p : this.info.privateLocations) {
1320             kills.remove(p);
1321         }
1322 
1323         assert kills.isEmpty() : &quot;snippet graph kills non-private locations &quot; + kills + &quot; that replacee (&quot; + replacee + &quot;) doesn&#39;t kill&quot;;
1324         return true;
1325     }
1326 
1327     private static class MemoryInputMap implements MemoryMap {
1328 
1329         private final LocationIdentity locationIdentity;
<a name="4" id="anc4"></a><span class="line-modified">1330         private final MemoryKill lastLocationAccess;</span>
1331 
1332         MemoryInputMap(ValueNode replacee) {
1333             if (replacee instanceof MemoryAccess) {
1334                 MemoryAccess access = (MemoryAccess) replacee;
1335                 locationIdentity = access.getLocationIdentity();
1336                 lastLocationAccess = access.getLastLocationAccess();
1337             } else {
1338                 locationIdentity = null;
1339                 lastLocationAccess = null;
1340             }
1341         }
1342 
1343         @Override
<a name="5" id="anc5"></a><span class="line-modified">1344         public MemoryKill getLastLocationAccess(LocationIdentity location) {</span>
1345             if (locationIdentity != null &amp;&amp; locationIdentity.equals(location)) {
1346                 return lastLocationAccess;
1347             } else {
1348                 return null;
1349             }
1350         }
1351 
1352         @Override
1353         public Collection&lt;LocationIdentity&gt; getLocations() {
1354             if (locationIdentity == null) {
1355                 return Collections.emptySet();
1356             } else {
1357                 return Collections.singleton(locationIdentity);
1358             }
1359         }
1360     }
1361 
1362     private class MemoryOutputMap extends MemoryInputMap {
1363 
1364         private final UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates;
1365 
1366         MemoryOutputMap(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1367             super(replacee);
1368             this.duplicates = duplicates;
1369         }
1370 
1371         @Override
<a name="6" id="anc6"></a><span class="line-modified">1372         public MemoryKill getLastLocationAccess(LocationIdentity locationIdentity) {</span>
1373             MemoryMapNode memoryMap = returnNode.getMemoryMap();
1374             assert memoryMap != null : &quot;no memory map stored for this snippet graph (snippet doesn&#39;t have a ReturnNode?)&quot;;
<a name="7" id="anc7"></a><span class="line-modified">1375             MemoryKill lastLocationAccess = memoryMap.getLastLocationAccess(locationIdentity);</span>
1376             assert lastLocationAccess != null : locationIdentity;
1377             if (lastLocationAccess == memoryAnchor) {
1378                 return super.getLastLocationAccess(locationIdentity);
1379             } else {
<a name="8" id="anc8"></a><span class="line-modified">1380                 return (MemoryKill) duplicates.get(ValueNodeUtil.asNode(lastLocationAccess));</span>
1381             }
1382         }
1383 
1384         @Override
1385         public Collection&lt;LocationIdentity&gt; getLocations() {
1386             return returnNode.getMemoryMap().getLocations();
1387         }
1388     }
1389 
1390     private void rewireMemoryGraph(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1391         if (replacee.graph().isAfterFloatingReadPhase()) {
1392             // rewire outgoing memory edges
1393             replaceMemoryUsages(replacee, new MemoryOutputMap(replacee, duplicates));
1394 
1395             if (returnNode != null) {
1396                 ReturnNode ret = (ReturnNode) duplicates.get(returnNode);
1397                 if (ret != null) {
1398                     MemoryMapNode memoryMap = ret.getMemoryMap();
1399                     if (memoryMap != null) {
1400                         ret.setMemoryMap(null);
1401                         memoryMap.safeDelete();
1402                     }
1403                 }
1404             }
1405             if (memoryAnchor != null) {
1406                 // rewire incoming memory edges
1407                 MemoryAnchorNode memoryDuplicate = (MemoryAnchorNode) duplicates.get(memoryAnchor);
1408                 replaceMemoryUsages(memoryDuplicate, new MemoryInputMap(replacee));
1409 
1410                 if (memoryDuplicate.hasNoUsages()) {
1411                     if (memoryDuplicate.next() != null) {
1412                         memoryDuplicate.graph().removeFixed(memoryDuplicate);
1413                     } else {
1414                         // this was a dummy memory node used when instantiating pure data-flow
1415                         // snippets: it was not attached to the control flow.
1416                         memoryDuplicate.safeDelete();
1417                     }
1418                 }
1419             }
1420         }
1421     }
1422 
1423     private static LocationIdentity getLocationIdentity(Node node) {
1424         if (node instanceof MemoryAccess) {
1425             return ((MemoryAccess) node).getLocationIdentity();
<a name="9" id="anc9"></a><span class="line-modified">1426         } else if (node instanceof MemoryEdgeProxy) {</span>
<span class="line-modified">1427             return ((MemoryEdgeProxy) node).getLocationIdentity();</span>
1428         } else if (node instanceof MemoryPhiNode) {
1429             return ((MemoryPhiNode) node).getLocationIdentity();
1430         } else {
1431             return null;
1432         }
1433     }
1434 
1435     private void replaceMemoryUsages(ValueNode node, MemoryMap map) {
1436         for (Node usage : node.usages().snapshot()) {
1437             if (usage instanceof MemoryMapNode) {
1438                 continue;
1439             }
1440 
1441             LocationIdentity location = getLocationIdentity(usage);
1442             if (location != null) {
1443                 for (Position pos : usage.inputPositions()) {
1444                     if (pos.getInputType() == InputType.Memory &amp;&amp; pos.get(usage) == node) {
<a name="10" id="anc10"></a><span class="line-modified">1445                         MemoryKill replacement = map.getLastLocationAccess(location);</span>
1446                         if (replacement == null) {
1447                             assert mayRemoveLocation || LocationIdentity.any().equals(location) ||
1448                                             CollectionsUtil.anyMatch(info.privateLocations, Predicate.isEqual(location)) : &quot;Snippet &quot; +
1449                                                             info.method.format(&quot;%h.%n&quot;) + &quot; contains access to the non-private location &quot; +
1450                                                             location + &quot;, but replacee doesn&#39;t access this location.&quot; + map.getLocations();
1451                         } else {
1452                             pos.set(usage, replacement.asNode());
1453                         }
1454                     }
1455                 }
1456             }
1457         }
1458     }
1459 
1460     /**
1461      * Replaces a given fixed node with this specialized snippet.
1462      *
1463      * @param metaAccess
1464      * @param replacee the node that will be replaced
1465      * @param replacer object that replaces the usages of {@code replacee}
1466      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1467      * @return the map of duplicated nodes (original -&amp;gt; duplicate)
1468      */
1469     @SuppressWarnings(&quot;try&quot;)
1470     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args) {
1471         return instantiate(metaAccess, replacee, replacer, args, true);
1472     }
1473 
1474     /**
1475      * Replaces a given fixed node with this specialized snippet.
1476      *
1477      * @param metaAccess
1478      * @param replacee the node that will be replaced
1479      * @param replacer object that replaces the usages of {@code replacee}
1480      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1481      * @param killReplacee is true, the replacee node is deleted
1482      * @return the map of duplicated nodes (original -&amp;gt; duplicate)
1483      */
1484     @SuppressWarnings(&quot;try&quot;)
1485     public UnmodifiableEconomicMap&lt;Node, Node&gt; instantiate(MetaAccessProvider metaAccess, FixedNode replacee, UsageReplacer replacer, Arguments args, boolean killReplacee) {
1486         DebugContext debug = replacee.getDebug();
1487         assert assertSnippetKills(replacee);
1488         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1489             args.info.instantiationCounter.increment(debug);
1490             // Inline the snippet nodes, replacing parameters with the given args in the process
1491             StartNode entryPointNode = snippet.start();
1492             FixedNode firstCFGNode = entryPointNode.next();
1493             StructuredGraph replaceeGraph = replacee.graph();
1494             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1495             replacements.put(entryPointNode, AbstractBeginNode.prevBegin(replacee));
1496             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1497 
1498             // Re-wire the control flow graph around the replacee
1499             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1500             replacee.replaceAtPredecessor(firstCFGNodeDuplicate);
1501 
1502             rewireFrameStates(replacee, duplicates);
1503 
1504             updateStamps(replacee, duplicates);
1505 
1506             rewireMemoryGraph(replacee, duplicates);
1507 
1508             // Replace all usages of the replacee with the value returned by the snippet
1509             ValueNode returnValue = null;
1510             if (returnNode != null &amp;&amp; !(replacee instanceof ControlSinkNode)) {
1511                 ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1512                 returnValue = returnDuplicate.result();
1513                 if (returnValue == null &amp;&amp; replacee.usages().isNotEmpty() &amp;&amp; replacee instanceof MemoryKill) {
1514                     replacer.replace(replacee, null);
1515                 } else {
1516                     assert returnValue != null || replacee.hasNoUsages();
1517                     replacer.replace(replacee, returnValue);
1518                 }
1519                 if (returnDuplicate.isAlive()) {
1520                     FixedNode next = null;
1521                     if (replacee instanceof FixedWithNextNode) {
1522                         FixedWithNextNode fwn = (FixedWithNextNode) replacee;
1523                         next = fwn.next();
1524                         fwn.setNext(null);
1525                     }
1526                     returnDuplicate.replaceAndDelete(next);
1527                 }
1528             }
1529 
1530             if (killReplacee) {
1531                 // Remove the replacee from its graph
1532                 GraphUtil.killCFG(replacee);
1533             }
1534 
1535             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1536             return duplicates;
1537         }
1538     }
1539 
1540     private UnmodifiableEconomicMap&lt;Node, Node&gt; inlineSnippet(Node replacee, DebugContext debug, StructuredGraph replaceeGraph, EconomicMap&lt;Node, Node&gt; replacements) {
1541         Mark mark = replaceeGraph.getMark();
1542         try (InliningLog.UpdateScope scope = replaceeGraph.getInliningLog().openUpdateScope((oldNode, newNode) -&gt; {
1543             InliningLog log = replaceeGraph.getInliningLog();
1544             if (oldNode == null) {
1545                 log.trackNewCallsite(newNode);
1546             }
1547         })) {
1548             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = replaceeGraph.addDuplicates(nodes, snippet, snippet.getNodeCount(), replacements);
1549             if (scope != null) {
1550                 replaceeGraph.getInliningLog().addLog(duplicates, snippet.getInliningLog());
1551             }
1552             NodeSourcePosition position = replacee.getNodeSourcePosition();
1553             InliningUtil.updateSourcePosition(replaceeGraph, duplicates, mark, position, true);
1554             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After inlining snippet %s&quot;, snippet.method());
1555             return duplicates;
1556         }
1557     }
1558 
1559     private void propagateStamp(Node node) {
1560         if (node instanceof PhiNode) {
1561             PhiNode phi = (PhiNode) node;
1562             if (phi.inferStamp()) {
1563                 for (Node usage : node.usages()) {
1564                     propagateStamp(usage);
1565                 }
1566             }
1567         }
1568     }
1569 
1570     private void updateStamps(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1571         for (ValueNode node : placeholderStampedNodes) {
1572             ValueNode dup = (ValueNode) duplicates.get(node);
1573             Stamp replaceeStamp = replacee.stamp(NodeView.DEFAULT);
1574             if (node instanceof Placeholder) {
1575                 Placeholder placeholderDup = (Placeholder) dup;
1576                 placeholderDup.makeReplacement(replaceeStamp);
1577             } else {
1578                 dup.setStamp(replaceeStamp);
1579             }
1580         }
1581         for (ParameterNode paramNode : snippet.getNodes(ParameterNode.TYPE)) {
1582             for (Node usage : paramNode.usages()) {
1583                 Node usageDup = duplicates.get(usage);
1584                 propagateStamp(usageDup);
1585             }
1586         }
1587     }
1588 
1589     /**
1590      * Gets a copy of the specialized graph.
1591      */
1592     public StructuredGraph copySpecializedGraph(DebugContext debugForCopy) {
1593         return (StructuredGraph) snippet.copy(debugForCopy);
1594     }
1595 
1596     /**
1597      * Replaces a given floating node with this specialized snippet.
1598      *
1599      * @param metaAccess
1600      * @param replacee the node that will be replaced
1601      * @param replacer object that replaces the usages of {@code replacee}
1602      * @param tool lowering tool used to insert the snippet into the control-flow
1603      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1604      */
1605     @SuppressWarnings(&quot;try&quot;)
1606     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, LoweringTool tool, Arguments args) {
1607         DebugContext debug = replacee.getDebug();
1608         assert assertSnippetKills(replacee);
1609         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1610             args.info.instantiationCounter.increment(debug);
1611 
1612             // Inline the snippet nodes, replacing parameters with the given args in the process
1613             StartNode entryPointNode = snippet.start();
1614             FixedNode firstCFGNode = entryPointNode.next();
1615             StructuredGraph replaceeGraph = replacee.graph();
1616             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1617             replacements.put(entryPointNode, tool.getCurrentGuardAnchor().asNode());
1618             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1619 
1620             FixedWithNextNode lastFixedNode = tool.lastFixedNode();
1621             assert lastFixedNode != null &amp;&amp; lastFixedNode.isAlive() : replaceeGraph + &quot; lastFixed=&quot; + lastFixedNode;
1622             FixedNode next = lastFixedNode.next();
1623             lastFixedNode.setNext(null);
1624             FixedNode firstCFGNodeDuplicate = (FixedNode) duplicates.get(firstCFGNode);
1625             replaceeGraph.addAfterFixed(lastFixedNode, firstCFGNodeDuplicate);
1626 
1627             // floating nodes are not state-splits not need to re-wire frame states
1628             assert !(replacee instanceof StateSplit);
1629             updateStamps(replacee, duplicates);
1630 
1631             rewireMemoryGraph(replacee, duplicates);
1632 
1633             // Replace all usages of the replacee with the value returned by the snippet
1634             ReturnNode returnDuplicate = (ReturnNode) duplicates.get(returnNode);
1635             ValueNode returnValue = returnDuplicate.result();
1636             assert returnValue != null || replacee.hasNoUsages();
1637             replacer.replace(replacee, returnValue);
1638 
1639             if (returnDuplicate.isAlive()) {
1640                 returnDuplicate.replaceAndDelete(next);
1641             }
1642 
1643             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1644         }
1645     }
1646 
1647     /**
1648      * Replaces a given floating node with this specialized snippet.
1649      *
1650      * This snippet must be pure data-flow
1651      *
1652      * @param metaAccess
1653      * @param replacee the node that will be replaced
1654      * @param replacer object that replaces the usages of {@code replacee}
1655      * @param args the arguments to be bound to the flattened positional parameters of the snippet
1656      */
1657     @SuppressWarnings(&quot;try&quot;)
1658     public void instantiate(MetaAccessProvider metaAccess, FloatingNode replacee, UsageReplacer replacer, Arguments args) {
1659         DebugContext debug = replacee.getDebug();
1660         assert assertSnippetKills(replacee);
1661         try (DebugCloseable a = args.info.instantiationTimer.start(debug)) {
1662             args.info.instantiationCounter.increment(debug);
1663 
1664             // Inline the snippet nodes, replacing parameters with the given args in the process
1665             StartNode entryPointNode = snippet.start();
1666             assert entryPointNode.next() == (memoryAnchor == null ? returnNode : memoryAnchor) : entryPointNode.next();
1667             StructuredGraph replaceeGraph = replacee.graph();
1668             EconomicMap&lt;Node, Node&gt; replacements = bind(replaceeGraph, metaAccess, args);
1669             MemoryAnchorNode anchorDuplicate = null;
1670             if (memoryAnchor != null) {
<a name="11" id="anc11"></a><span class="line-modified">1671                 anchorDuplicate = replaceeGraph.add(new MemoryAnchorNode(info.privateLocations));</span>
1672                 replacements.put(memoryAnchor, anchorDuplicate);
1673             }
1674             List&lt;Node&gt; floatingNodes = new ArrayList&lt;&gt;(nodes.size() - 2);
1675             for (Node n : nodes) {
1676                 if (n != entryPointNode &amp;&amp; n != returnNode) {
1677                     floatingNodes.add(n);
1678                 }
1679             }
1680             UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates = inlineSnippet(replacee, debug, replaceeGraph, replacements);
1681 
1682             // floating nodes are not state-splits not need to re-wire frame states
1683             assert !(replacee instanceof StateSplit);
1684             updateStamps(replacee, duplicates);
1685 
1686             rewireMemoryGraph(replacee, duplicates);
1687             assert anchorDuplicate == null || anchorDuplicate.isDeleted();
1688 
1689             // Replace all usages of the replacee with the value returned by the snippet
1690             ValueNode returnValue = (ValueNode) duplicates.get(returnNode.result());
1691             replacer.replace(replacee, returnValue);
1692 
1693             debug.dump(DebugContext.DETAILED_LEVEL, replaceeGraph, &quot;After lowering %s with %s&quot;, replacee, this);
1694         }
1695     }
1696 
1697     protected void rewireFrameStates(ValueNode replacee, UnmodifiableEconomicMap&lt;Node, Node&gt; duplicates) {
1698         if (replacee.graph().getGuardsStage().areFrameStatesAtSideEffects() &amp;&amp; replacee instanceof StateSplit) {
1699             for (StateSplit sideEffectNode : sideEffectNodes) {
1700                 assert ((StateSplit) replacee).hasSideEffect();
1701                 Node sideEffectDup = duplicates.get(sideEffectNode.asNode());
1702                 ((StateSplit) sideEffectDup).setStateAfter(((StateSplit) replacee).stateAfter());
1703             }
1704         } else if (replacee.graph().getGuardsStage().areFrameStatesAtDeopts() &amp;&amp; replacee instanceof DeoptimizingNode) {
1705             DeoptimizingNode replaceeDeopt = (DeoptimizingNode) replacee;
1706 
1707             FrameState stateBefore = null;
1708             FrameState stateDuring = null;
1709             FrameState stateAfter = null;
1710             if (replaceeDeopt.canDeoptimize()) {
1711                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptBefore) {
1712                     stateBefore = ((DeoptimizingNode.DeoptBefore) replaceeDeopt).stateBefore();
1713                 }
1714                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptDuring) {
1715                     stateDuring = ((DeoptimizingNode.DeoptDuring) replaceeDeopt).stateDuring();
1716                 }
1717                 if (replaceeDeopt instanceof DeoptimizingNode.DeoptAfter) {
1718                     stateAfter = ((DeoptimizingNode.DeoptAfter) replaceeDeopt).stateAfter();
1719                 }
1720             }
1721 
1722             for (DeoptimizingNode deoptNode : deoptNodes) {
1723                 DeoptimizingNode deoptDup = (DeoptimizingNode) duplicates.get(deoptNode.asNode());
1724                 if (deoptDup.canDeoptimize()) {
1725                     if (deoptDup instanceof DeoptimizingNode.DeoptBefore) {
1726                         ((DeoptimizingNode.DeoptBefore) deoptDup).setStateBefore(stateBefore);
1727                     }
1728                     if (deoptDup instanceof DeoptimizingNode.DeoptDuring) {
1729                         // compute a state &quot;during&quot; for a DeoptDuring inside the snippet depending
1730                         // on what kind of states we had on the node we are replacing.
1731                         // If the original node had a state &quot;during&quot; already, we just use that,
1732                         // otherwise we need to find a strategy to compute a state during based on
1733                         // some other state (before or after).
1734                         DeoptimizingNode.DeoptDuring deoptDupDuring = (DeoptimizingNode.DeoptDuring) deoptDup;
1735                         if (stateDuring != null) {
1736                             deoptDupDuring.setStateDuring(stateDuring);
1737                         } else if (stateAfter != null) {
1738                             deoptDupDuring.computeStateDuring(stateAfter);
1739                         } else if (stateBefore != null) {
1740                             assert !deoptDupDuring.hasSideEffect() : &quot;can&#39;t use stateBefore as stateDuring for state split &quot; + deoptDupDuring;
1741                             deoptDupDuring.setStateDuring(stateBefore);
1742                         }
1743                     }
1744                     if (deoptDup instanceof DeoptimizingNode.DeoptAfter) {
1745                         DeoptimizingNode.DeoptAfter deoptDupAfter = (DeoptimizingNode.DeoptAfter) deoptDup;
1746                         if (stateAfter != null) {
1747                             deoptDupAfter.setStateAfter(stateAfter);
1748                         } else {
1749                             assert !deoptDupAfter.hasSideEffect() : &quot;can&#39;t use stateBefore as stateAfter for state split &quot; + deoptDupAfter;
1750                             deoptDupAfter.setStateAfter(stateBefore);
1751                         }
1752 
1753                     }
1754                 }
1755             }
1756         }
1757     }
1758 
1759     @Override
1760     public String toString() {
1761         StringBuilder buf = new StringBuilder(snippet.toString()).append(&#39;(&#39;);
1762         String sep = &quot;&quot;;
1763         for (int i = 0; i &lt; parameters.length; i++) {
1764             String name = &quot;[&quot; + i + &quot;]&quot;;
1765             Object value = parameters[i];
1766             buf.append(sep);
1767             sep = &quot;, &quot;;
1768             if (value == null) {
1769                 buf.append(&quot;&lt;null&gt; &quot;).append(name);
1770             } else if (value.equals(UNUSED_PARAMETER)) {
1771                 buf.append(&quot;&lt;unused&gt; &quot;).append(name);
1772             } else if (value.equals(CONSTANT_PARAMETER)) {
1773                 buf.append(&quot;&lt;constant&gt; &quot;).append(name);
1774             } else if (value instanceof ParameterNode) {
1775                 ParameterNode param = (ParameterNode) value;
1776                 buf.append(param.getStackKind().getJavaName()).append(&#39; &#39;).append(name);
1777             } else {
1778                 ParameterNode[] params = (ParameterNode[]) value;
1779                 String kind = params.length == 0 ? &quot;?&quot; : params[0].getStackKind().getJavaName();
1780                 buf.append(kind).append(&#39;[&#39;).append(params.length).append(&quot;] &quot;).append(name);
1781             }
1782         }
1783         return buf.append(&#39;)&#39;).toString();
1784     }
1785 
1786     private static boolean checkTemplate(MetaAccessProvider metaAccess, Arguments args, ResolvedJavaMethod method, Signature signature) {
1787         int offset = args.info.hasReceiver() ? 1 : 0;
1788         for (int i = offset; i &lt; args.info.getParameterCount(); i++) {
1789             if (args.info.isConstantParameter(i)) {
1790                 JavaKind kind = signature.getParameterKind(i - offset);
1791                 assert checkConstantArgument(metaAccess, method, signature, i - offset, args.info.getParameterName(i), args.values[i], kind);
1792 
1793             } else if (args.info.isVarargsParameter(i)) {
1794                 assert args.values[i] instanceof Varargs;
1795                 Varargs varargs = (Varargs) args.values[i];
1796                 assert checkVarargs(metaAccess, method, signature, i - offset, args.info.getParameterName(i), varargs);
1797             }
1798         }
1799         return true;
1800     }
1801 
1802     public void setMayRemoveLocation(boolean mayRemoveLocation) {
1803         this.mayRemoveLocation = mayRemoveLocation;
1804     }
1805 }
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
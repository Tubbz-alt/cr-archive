<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/jdk.internal.vm.compiler/share/classes/org.graalvm.compiler.graph/src/org/graalvm/compiler/graph/NodeClass.java</title>
    <link rel="stylesheet" href="../../../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  */
  23 
  24 
  25 package org.graalvm.compiler.graph;
  26 
  27 import static org.graalvm.compiler.core.common.Fields.translateInto;
  28 import static org.graalvm.compiler.debug.GraalError.shouldNotReachHere;
  29 import static org.graalvm.compiler.graph.Edges.translateInto;
  30 import static org.graalvm.compiler.graph.Graph.isModificationCountsEnabled;
  31 import static org.graalvm.compiler.graph.InputEdges.translateInto;
  32 import static org.graalvm.compiler.graph.Node.WithAllEdges;
  33 import static org.graalvm.compiler.serviceprovider.GraalUnsafeAccess.getUnsafe;
  34 
  35 import java.lang.annotation.Annotation;
  36 import java.lang.reflect.AnnotatedElement;
  37 import java.lang.reflect.Field;
  38 import java.lang.reflect.Modifier;
  39 import java.util.ArrayList;
  40 import java.util.Arrays;
  41 import java.util.EnumSet;
  42 import java.util.Iterator;
  43 import java.util.NoSuchElementException;
  44 import java.util.Objects;
  45 import java.util.concurrent.atomic.AtomicInteger;
  46 
  47 import jdk.internal.vm.compiler.collections.EconomicMap;
  48 import jdk.internal.vm.compiler.collections.Equivalence;
  49 import org.graalvm.compiler.core.common.FieldIntrospection;
  50 import org.graalvm.compiler.core.common.Fields;
  51 import org.graalvm.compiler.core.common.FieldsScanner;
  52 import org.graalvm.compiler.debug.CounterKey;
  53 import org.graalvm.compiler.debug.DebugCloseable;
  54 import org.graalvm.compiler.debug.DebugContext;
  55 import org.graalvm.compiler.debug.GraalError;
  56 import org.graalvm.compiler.debug.TTY;
  57 import org.graalvm.compiler.debug.TimerKey;
  58 import org.graalvm.compiler.graph.Edges.Type;
  59 import org.graalvm.compiler.graph.Graph.DuplicationReplacement;
  60 import org.graalvm.compiler.graph.Node.EdgeVisitor;
  61 import org.graalvm.compiler.graph.Node.Input;
  62 import org.graalvm.compiler.graph.Node.OptionalInput;
  63 import org.graalvm.compiler.graph.Node.Successor;
  64 import org.graalvm.compiler.graph.iterators.NodeIterable;
  65 import org.graalvm.compiler.graph.spi.Canonicalizable;
  66 import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;
  67 import org.graalvm.compiler.graph.spi.Simplifiable;
  68 import org.graalvm.compiler.nodeinfo.InputType;
  69 import org.graalvm.compiler.nodeinfo.NodeCycles;
  70 import org.graalvm.compiler.nodeinfo.NodeInfo;
  71 import org.graalvm.compiler.nodeinfo.NodeSize;
  72 import org.graalvm.compiler.nodeinfo.Verbosity;
  73 
  74 import sun.misc.Unsafe;
  75 
  76 /**
  77  * Metadata for every {@link Node} type. The metadata includes:
  78  * &lt;ul&gt;
  79  * &lt;li&gt;The offsets of fields annotated with {@link Input} and {@link Successor} as well as methods
  80  * for iterating over such fields.&lt;/li&gt;
  81  * &lt;li&gt;The identifier for an {@link IterableNodeType} class.&lt;/li&gt;
  82  * &lt;/ul&gt;
  83  */
  84 public final class NodeClass&lt;T&gt; extends FieldIntrospection&lt;T&gt; {
  85 
  86     private static final Unsafe UNSAFE = getUnsafe();
  87     // Timers for creation of a NodeClass instance
  88     private static final TimerKey Init_FieldScanning = DebugContext.timer(&quot;NodeClass.Init.FieldScanning&quot;);
  89     private static final TimerKey Init_FieldScanningInner = DebugContext.timer(&quot;NodeClass.Init.FieldScanning.Inner&quot;);
  90     private static final TimerKey Init_AnnotationParsing = DebugContext.timer(&quot;NodeClass.Init.AnnotationParsing&quot;);
  91     private static final TimerKey Init_Edges = DebugContext.timer(&quot;NodeClass.Init.Edges&quot;);
  92     private static final TimerKey Init_Data = DebugContext.timer(&quot;NodeClass.Init.Data&quot;);
  93     private static final TimerKey Init_AllowedUsages = DebugContext.timer(&quot;NodeClass.Init.AllowedUsages&quot;);
  94     private static final TimerKey Init_IterableIds = DebugContext.timer(&quot;NodeClass.Init.IterableIds&quot;);
  95 
  96     public static final long MAX_EDGES = 8;
  97     public static final long MAX_LIST_EDGES = 6;
  98     public static final long OFFSET_MASK = 0xFC;
  99     public static final long LIST_MASK = 0x01;
 100     public static final long NEXT_EDGE = 0x08;
 101 
 102     @SuppressWarnings(&quot;try&quot;)
 103     private static &lt;T extends Annotation&gt; T getAnnotationTimed(AnnotatedElement e, Class&lt;T&gt; annotationClass, DebugContext debug) {
 104         try (DebugCloseable s = Init_AnnotationParsing.start(debug)) {
 105             return e.getAnnotation(annotationClass);
 106         }
 107     }
 108 
 109     /**
 110      * Gets the {@link NodeClass} associated with a given {@link Class}.
 111      */
 112     public static &lt;T&gt; NodeClass&lt;T&gt; create(Class&lt;T&gt; c) {
 113         assert getUnchecked(c) == null;
 114         Class&lt;? super T&gt; superclass = c.getSuperclass();
 115         NodeClass&lt;? super T&gt; nodeSuperclass = null;
 116         if (superclass != NODE_CLASS) {
 117             nodeSuperclass = get(superclass);
 118         }
 119         return new NodeClass&lt;&gt;(c, nodeSuperclass);
 120     }
 121 
 122     @SuppressWarnings(&quot;unchecked&quot;)
 123     private static &lt;T&gt; NodeClass&lt;T&gt; getUnchecked(Class&lt;T&gt; clazz) {
 124         try {
 125             Field field = clazz.getDeclaredField(&quot;TYPE&quot;);
 126             field.setAccessible(true);
 127             return (NodeClass&lt;T&gt;) field.get(null);
 128         } catch (IllegalArgumentException | IllegalAccessException | NoSuchFieldException | SecurityException e) {
 129             throw new RuntimeException(&quot;Could not load Graal NodeClass TYPE field for &quot; + clazz, e);
 130         }
 131     }
 132 
 133     public static &lt;T&gt; NodeClass&lt;T&gt; get(Class&lt;T&gt; clazz) {
 134         int numTries = 0;
 135         while (true) {
 136             boolean shouldBeInitializedBefore = UNSAFE.shouldBeInitialized(clazz);
 137 
 138             NodeClass&lt;T&gt; result = getUnchecked(clazz);
 139             if (result != null || clazz == NODE_CLASS) {
 140                 return result;
 141             }
 142 
 143             /*
 144              * GR-9537: We observed a transient problem with TYPE fields being null. Retry a couple
 145              * of times and print something to the log so that we can gather more diagnostic
 146              * information without failing gates.
 147              */
 148             numTries++;
 149             boolean shouldBeInitializedAfter = UNSAFE.shouldBeInitialized(clazz);
 150             String msg = &quot;GR-9537 Reflective field access of TYPE field returned null. This is probably a bug in HotSpot class initialization. &quot; +
 151                             &quot; clazz: &quot; + clazz.getTypeName() + &quot;, numTries: &quot; + numTries +
 152                             &quot;, shouldBeInitializedBefore: &quot; + shouldBeInitializedBefore + &quot;, shouldBeInitializedAfter: &quot; + shouldBeInitializedAfter;
 153             if (numTries &lt;= 100) {
 154                 TTY.println(msg);
 155                 UNSAFE.ensureClassInitialized(clazz);
 156             } else {
 157                 throw GraalError.shouldNotReachHere(msg);
 158             }
 159             return result;
 160         }
 161     }
 162 
 163     private static final Class&lt;?&gt; NODE_CLASS = Node.class;
 164     private static final Class&lt;?&gt; INPUT_LIST_CLASS = NodeInputList.class;
 165     private static final Class&lt;?&gt; SUCCESSOR_LIST_CLASS = NodeSuccessorList.class;
 166 
 167     private static AtomicInteger nextIterableId = new AtomicInteger();
 168     private static AtomicInteger nextLeafId = new AtomicInteger();
 169 
 170     private final InputEdges inputs;
 171     private final SuccessorEdges successors;
 172     private final NodeClass&lt;? super T&gt; superNodeClass;
 173 
 174     private final boolean canGVN;
 175     private final int startGVNNumber;
 176     private final String nameTemplate;
 177     private final int iterableId;
 178     private final EnumSet&lt;InputType&gt; allowedUsageTypes;
 179     private int[] iterableIds;
 180     private final long inputsIteration;
 181     private final long successorIteration;
 182 
 183     private static final CounterKey ITERABLE_NODE_TYPES = DebugContext.counter(&quot;IterableNodeTypes&quot;);
 184 
 185     /**
 186      * Determines if this node type implements {@link Canonicalizable}.
 187      */
 188     private final boolean isCanonicalizable;
 189 
 190     /**
 191      * Determines if this node type implements {@link BinaryCommutative}.
 192      */
 193     private final boolean isCommutative;
 194 
 195     /**
 196      * Determines if this node type implements {@link Simplifiable}.
 197      */
 198     private final boolean isSimplifiable;
 199     private final boolean isLeafNode;
 200 
 201     private final int leafId;
 202 
 203     public NodeClass(Class&lt;T&gt; clazz, NodeClass&lt;? super T&gt; superNodeClass) {
 204         this(clazz, superNodeClass, new FieldsScanner.DefaultCalcOffset(), null, 0);
 205     }
 206 
 207     @SuppressWarnings(&quot;try&quot;)
 208     public NodeClass(Class&lt;T&gt; clazz, NodeClass&lt;? super T&gt; superNodeClass, FieldsScanner.CalcOffset calcOffset, int[] presetIterableIds, int presetIterableId) {
 209         super(clazz);
 210         DebugContext debug = DebugContext.forCurrentThread();
 211         this.superNodeClass = superNodeClass;
 212         assert NODE_CLASS.isAssignableFrom(clazz);
 213 
 214         this.isCanonicalizable = Canonicalizable.class.isAssignableFrom(clazz);
 215         this.isCommutative = BinaryCommutative.class.isAssignableFrom(clazz);
 216         if (Canonicalizable.Unary.class.isAssignableFrom(clazz) || Canonicalizable.Binary.class.isAssignableFrom(clazz)) {
 217             assert Canonicalizable.Unary.class.isAssignableFrom(clazz) ^ Canonicalizable.Binary.class.isAssignableFrom(clazz) : clazz + &quot; should implement either Unary or Binary, not both&quot;;
 218         }
 219 
 220         this.isSimplifiable = Simplifiable.class.isAssignableFrom(clazz);
 221 
 222         NodeFieldsScanner fs = new NodeFieldsScanner(calcOffset, superNodeClass, debug);
 223         try (DebugCloseable t = Init_FieldScanning.start(debug)) {
 224             fs.scan(clazz, clazz.getSuperclass(), false);
 225         }
 226 
 227         try (DebugCloseable t1 = Init_Edges.start(debug)) {
 228             successors = new SuccessorEdges(fs.directSuccessors, fs.successors);
 229             successorIteration = computeIterationMask(successors.type(), successors.getDirectCount(), successors.getOffsets());
 230             inputs = new InputEdges(fs.directInputs, fs.inputs);
 231             inputsIteration = computeIterationMask(inputs.type(), inputs.getDirectCount(), inputs.getOffsets());
 232         }
 233         try (DebugCloseable t1 = Init_Data.start(debug)) {
<a name="1" id="anc1"></a><span class="line-modified"> 234             data = Fields.create(fs.data);</span>
 235         }
 236 
 237         isLeafNode = inputs.getCount() + successors.getCount() == 0;
 238         if (isLeafNode) {
 239             this.leafId = nextLeafId.getAndIncrement();
 240         } else {
 241             this.leafId = -1;
 242         }
 243 
 244         canGVN = Node.ValueNumberable.class.isAssignableFrom(clazz);
 245         startGVNNumber = clazz.getName().hashCode();
 246 
 247         NodeInfo info = getAnnotationTimed(clazz, NodeInfo.class, debug);
 248         assert info != null : &quot;Missing NodeInfo annotation on &quot; + clazz;
 249         if (!info.nameTemplate().isEmpty()) {
 250             this.nameTemplate = info.nameTemplate();
 251         } else if (!info.shortName().isEmpty()) {
 252             this.nameTemplate = info.shortName();
 253         } else {
 254             this.nameTemplate = &quot;&quot;;
 255         }
 256 
 257         try (DebugCloseable t1 = Init_AllowedUsages.start(debug)) {
 258             allowedUsageTypes = superNodeClass == null ? EnumSet.noneOf(InputType.class) : superNodeClass.allowedUsageTypes.clone();
 259             allowedUsageTypes.addAll(Arrays.asList(info.allowedUsageTypes()));
 260         }
 261 
 262         if (presetIterableIds != null) {
 263             this.iterableIds = presetIterableIds;
 264             this.iterableId = presetIterableId;
 265         } else if (IterableNodeType.class.isAssignableFrom(clazz)) {
 266             ITERABLE_NODE_TYPES.increment(debug);
 267             try (DebugCloseable t1 = Init_IterableIds.start(debug)) {
 268                 this.iterableId = nextIterableId.getAndIncrement();
 269 
 270                 NodeClass&lt;?&gt; snc = superNodeClass;
 271                 while (snc != null &amp;&amp; IterableNodeType.class.isAssignableFrom(snc.getClazz())) {
 272                     snc.addIterableId(iterableId);
 273                     snc = snc.superNodeClass;
 274                 }
 275 
 276                 this.iterableIds = new int[]{iterableId};
 277             }
 278         } else {
 279             this.iterableId = Node.NOT_ITERABLE;
 280             this.iterableIds = null;
 281         }
 282         assert verifyIterableIds();
 283 
 284         try (DebugContext.Scope scope = debug.scope(&quot;NodeCosts&quot;)) {
 285             /*
 286              * Note: We do not check for the existence of the node cost annotations during
 287              * construction as not every node needs to have them set. However if costs are queried,
 288              * after the construction of the node class, they must be properly set. This is
 289              * important as we can not trust our cost model if there are unspecified nodes. Nodes
 290              * that do not need cost annotations are e.g. abstractions like FixedNode or
 291              * FloatingNode or ValueNode. Sub classes where costs are not specified will ask the
 292              * superclass for their costs during node class initialization. Therefore getters for
 293              * cycles and size can omit verification during creation.
 294              */
 295             NodeCycles c = info.cycles();
 296             if (c == NodeCycles.CYCLES_UNSET) {
 297                 cycles = superNodeClass != null ? superNodeClass.cycles : NodeCycles.CYCLES_UNSET;
 298             } else {
 299                 cycles = c;
 300             }
 301             assert cycles != null;
 302             NodeSize s = info.size();
 303             if (s == NodeSize.SIZE_UNSET) {
 304                 size = superNodeClass != null ? superNodeClass.size : NodeSize.SIZE_UNSET;
 305             } else {
 306                 size = s;
 307             }
 308             assert size != null;
 309             debug.log(&quot;Node cost for node of type __| %s |_, cycles:%s,size:%s&quot;, clazz, cycles, size);
 310         }
 311         assert verifyMemoryEdgeInvariant(fs) : &quot;Nodes participating in the memory graph should have at most 1 optional memory input.&quot;;
 312     }
 313 
 314     private static boolean verifyMemoryEdgeInvariant(NodeFieldsScanner fs) {
 315         int optionalMemoryInputs = 0;
 316         for (InputInfo info : fs.inputs) {
 317             if (info.optional &amp;&amp; info.inputType == InputType.Memory) {
 318                 optionalMemoryInputs++;
 319             }
 320         }
 321         return optionalMemoryInputs &lt;= 1;
 322     }
 323 
 324     private final NodeCycles cycles;
 325     private final NodeSize size;
 326 
 327     public NodeCycles cycles() {
 328         return cycles;
 329     }
 330 
 331     public NodeSize size() {
 332         return size;
 333     }
 334 
 335     public static long computeIterationMask(Type type, int directCount, long[] offsets) {
 336         long mask = 0;
 337         if (offsets.length &gt; NodeClass.MAX_EDGES) {
 338             throw new GraalError(&quot;Exceeded maximum of %d edges (%s)&quot;, NodeClass.MAX_EDGES, type);
 339         }
 340         if (offsets.length - directCount &gt; NodeClass.MAX_LIST_EDGES) {
 341             throw new GraalError(&quot;Exceeded maximum of %d list edges (%s)&quot;, NodeClass.MAX_LIST_EDGES, type);
 342         }
 343 
 344         for (int i = offsets.length - 1; i &gt;= 0; i--) {
 345             long offset = offsets[i];
 346             assert ((offset &amp; 0xFF) == offset) : &quot;field offset too large!&quot;;
 347             mask &lt;&lt;= NodeClass.NEXT_EDGE;
 348             mask |= offset;
 349             if (i &gt;= directCount) {
 350                 mask |= 0x3;
 351             }
 352         }
 353         return mask;
 354     }
 355 
 356     private synchronized void addIterableId(int newIterableId) {
 357         assert !containsId(newIterableId, iterableIds);
 358         int[] copy = Arrays.copyOf(iterableIds, iterableIds.length + 1);
 359         copy[iterableIds.length] = newIterableId;
 360         iterableIds = copy;
 361     }
 362 
 363     private boolean verifyIterableIds() {
 364         NodeClass&lt;?&gt; snc = superNodeClass;
 365         while (snc != null &amp;&amp; IterableNodeType.class.isAssignableFrom(snc.getClazz())) {
 366             assert containsId(iterableId, snc.iterableIds);
 367             snc = snc.superNodeClass;
 368         }
 369         return true;
 370     }
 371 
 372     private static boolean containsId(int iterableId, int[] iterableIds) {
 373         for (int i : iterableIds) {
 374             if (i == iterableId) {
 375                 return true;
 376             }
 377         }
 378         return false;
 379     }
 380 
 381     private String shortName;
 382 
 383     public String shortName() {
 384         if (shortName == null) {
 385             NodeInfo info = getClazz().getAnnotation(NodeInfo.class);
 386             if (!info.shortName().isEmpty()) {
 387                 shortName = info.shortName();
 388             } else {
 389                 String localShortName = getClazz().getSimpleName();
 390                 if (localShortName.endsWith(&quot;Node&quot;) &amp;&amp; !localShortName.equals(&quot;StartNode&quot;) &amp;&amp; !localShortName.equals(&quot;EndNode&quot;)) {
 391                     shortName = localShortName.substring(0, localShortName.length() - 4);
 392                 } else {
 393                     shortName = localShortName;
 394                 }
 395             }
 396         }
 397         return shortName;
 398     }
 399 
 400     @Override
 401     public Fields[] getAllFields() {
 402         return new Fields[]{data, inputs, successors};
 403     }
 404 
 405     int[] iterableIds() {
 406         return iterableIds;
 407     }
 408 
 409     public int iterableId() {
 410         return iterableId;
 411     }
 412 
 413     public boolean valueNumberable() {
 414         return canGVN;
 415     }
 416 
 417     /**
 418      * Determines if this node type implements {@link Canonicalizable}.
 419      */
 420     public boolean isCanonicalizable() {
 421         return isCanonicalizable;
 422     }
 423 
 424     /**
 425      * Determines if this node type implements {@link BinaryCommutative}.
 426      */
 427     public boolean isCommutative() {
 428         return isCommutative;
 429     }
 430 
 431     /**
 432      * Determines if this node type implements {@link Simplifiable}.
 433      */
 434     public boolean isSimplifiable() {
 435         return isSimplifiable;
 436     }
 437 
 438     static int allocatedNodeIterabledIds() {
 439         return nextIterableId.get();
 440     }
 441 
 442     public EnumSet&lt;InputType&gt; getAllowedUsageTypes() {
 443         return allowedUsageTypes;
 444     }
 445 
 446     /**
 447      * Describes a field representing an input or successor edge in a node.
 448      */
 449     protected static class EdgeInfo extends FieldsScanner.FieldInfo {
 450 
 451         public EdgeInfo(long offset, String name, Class&lt;?&gt; type, Class&lt;?&gt; declaringClass) {
 452             super(offset, name, type, declaringClass);
 453         }
 454 
 455         /**
 456          * Sorts non-list edges before list edges.
 457          */
 458         @Override
 459         public int compareTo(FieldsScanner.FieldInfo o) {
 460             if (NodeList.class.isAssignableFrom(o.type)) {
 461                 if (!NodeList.class.isAssignableFrom(type)) {
 462                     return -1;
 463                 }
 464             } else {
 465                 if (NodeList.class.isAssignableFrom(type)) {
 466                     return 1;
 467                 }
 468             }
 469             return super.compareTo(o);
 470         }
 471     }
 472 
 473     /**
 474      * Describes a field representing an {@linkplain Type#Inputs input} edge in a node.
 475      */
 476     protected static class InputInfo extends EdgeInfo {
 477         final InputType inputType;
 478         final boolean optional;
 479 
 480         public InputInfo(long offset, String name, Class&lt;?&gt; type, Class&lt;?&gt; declaringClass, InputType inputType, boolean optional) {
 481             super(offset, name, type, declaringClass);
 482             this.inputType = inputType;
 483             this.optional = optional;
 484         }
 485 
 486         @Override
 487         public String toString() {
 488             return super.toString() + &quot;{inputType=&quot; + inputType + &quot;, optional=&quot; + optional + &quot;}&quot;;
 489         }
 490     }
 491 
 492     protected static class NodeFieldsScanner extends FieldsScanner {
 493 
 494         public final ArrayList&lt;InputInfo&gt; inputs = new ArrayList&lt;&gt;();
 495         public final ArrayList&lt;EdgeInfo&gt; successors = new ArrayList&lt;&gt;();
 496         int directInputs;
 497         int directSuccessors;
 498         final DebugContext debug;
 499 
 500         protected NodeFieldsScanner(FieldsScanner.CalcOffset calc, NodeClass&lt;?&gt; superNodeClass, DebugContext debug) {
 501             super(calc);
 502             this.debug = debug;
 503             if (superNodeClass != null) {
 504                 translateInto(superNodeClass.inputs, inputs);
 505                 translateInto(superNodeClass.successors, successors);
 506                 translateInto(superNodeClass.data, data);
 507                 directInputs = superNodeClass.inputs.getDirectCount();
 508                 directSuccessors = superNodeClass.successors.getDirectCount();
 509             }
 510         }
 511 
 512         @SuppressWarnings(&quot;try&quot;)
 513         @Override
 514         protected void scanField(Field field, long offset) {
 515             Input inputAnnotation = getAnnotationTimed(field, Node.Input.class, debug);
 516             OptionalInput optionalInputAnnotation = getAnnotationTimed(field, Node.OptionalInput.class, debug);
 517             Successor successorAnnotation = getAnnotationTimed(field, Successor.class, debug);
 518             try (DebugCloseable s = Init_FieldScanningInner.start(debug)) {
 519                 Class&lt;?&gt; type = field.getType();
 520                 int modifiers = field.getModifiers();
 521 
 522                 if (inputAnnotation != null || optionalInputAnnotation != null) {
 523                     assert successorAnnotation == null : &quot;field cannot be both input and successor&quot;;
 524                     if (INPUT_LIST_CLASS.isAssignableFrom(type)) {
 525                         // NodeInputList fields should not be final since they are
 526                         // written (via Unsafe) in clearInputs()
 527                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;NodeInputList input field %s should not be final&quot;, field);
 528                         GraalError.guarantee(!Modifier.isPublic(modifiers), &quot;NodeInputList input field %s should not be public&quot;, field);
 529                     } else {
 530                         GraalError.guarantee(NODE_CLASS.isAssignableFrom(type) || type.isInterface(), &quot;invalid input type: %s&quot;, type);
 531                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;Node input field %s should not be final&quot;, field);
 532                         directInputs++;
 533                     }
 534                     InputType inputType;
 535                     if (inputAnnotation != null) {
 536                         assert optionalInputAnnotation == null : &quot;inputs can either be optional or non-optional&quot;;
 537                         inputType = inputAnnotation.value();
 538                     } else {
 539                         inputType = optionalInputAnnotation.value();
 540                     }
 541                     inputs.add(new InputInfo(offset, field.getName(), type, field.getDeclaringClass(), inputType, field.isAnnotationPresent(Node.OptionalInput.class)));
 542                 } else if (successorAnnotation != null) {
 543                     if (SUCCESSOR_LIST_CLASS.isAssignableFrom(type)) {
 544                         // NodeSuccessorList fields should not be final since they are
 545                         // written (via Unsafe) in clearSuccessors()
 546                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;NodeSuccessorList successor field % should not be final&quot;, field);
 547                         GraalError.guarantee(!Modifier.isPublic(modifiers), &quot;NodeSuccessorList successor field %s should not be public&quot;, field);
 548                     } else {
 549                         GraalError.guarantee(NODE_CLASS.isAssignableFrom(type), &quot;invalid successor type: %s&quot;, type);
 550                         GraalError.guarantee(!Modifier.isFinal(modifiers), &quot;Node successor field %s should not be final&quot;, field);
 551                         directSuccessors++;
 552                     }
 553                     successors.add(new EdgeInfo(offset, field.getName(), type, field.getDeclaringClass()));
 554                 } else {
 555                     GraalError.guarantee(!NODE_CLASS.isAssignableFrom(type) || field.getName().equals(&quot;Null&quot;), &quot;suspicious node field: %s&quot;, field);
 556                     GraalError.guarantee(!INPUT_LIST_CLASS.isAssignableFrom(type), &quot;suspicious node input list field: %s&quot;, field);
 557                     GraalError.guarantee(!SUCCESSOR_LIST_CLASS.isAssignableFrom(type), &quot;suspicious node successor list field: %s&quot;, field);
 558                     super.scanField(field, offset);
 559                 }
 560             }
 561         }
 562     }
 563 
 564     @Override
 565     public String toString() {
 566         StringBuilder str = new StringBuilder();
 567         str.append(&quot;NodeClass &quot;).append(getClazz().getSimpleName()).append(&quot; [&quot;);
 568         inputs.appendFields(str);
 569         str.append(&quot;] [&quot;);
 570         successors.appendFields(str);
 571         str.append(&quot;] [&quot;);
 572         data.appendFields(str);
 573         str.append(&quot;]&quot;);
 574         return str.toString();
 575     }
 576 
 577     private static int deepHashCode0(Object o) {
 578         if (o == null) {
 579             return 0;
 580         } else if (!o.getClass().isArray()) {
 581             return o.hashCode();
 582         } else if (o instanceof Object[]) {
 583             return Arrays.deepHashCode((Object[]) o);
 584         } else if (o instanceof byte[]) {
 585             return Arrays.hashCode((byte[]) o);
 586         } else if (o instanceof short[]) {
 587             return Arrays.hashCode((short[]) o);
 588         } else if (o instanceof int[]) {
 589             return Arrays.hashCode((int[]) o);
 590         } else if (o instanceof long[]) {
 591             return Arrays.hashCode((long[]) o);
 592         } else if (o instanceof char[]) {
 593             return Arrays.hashCode((char[]) o);
 594         } else if (o instanceof float[]) {
 595             return Arrays.hashCode((float[]) o);
 596         } else if (o instanceof double[]) {
 597             return Arrays.hashCode((double[]) o);
 598         } else if (o instanceof boolean[]) {
 599             return Arrays.hashCode((boolean[]) o);
 600         } else {
 601             throw shouldNotReachHere();
 602         }
 603     }
 604 
 605     public int valueNumber(Node n) {
 606         int number = 0;
 607         if (canGVN) {
 608             number = startGVNNumber;
 609             for (int i = 0; i &lt; data.getCount(); ++i) {
 610                 Class&lt;?&gt; type = data.getType(i);
 611                 if (type.isPrimitive()) {
 612                     if (type == Integer.TYPE) {
 613                         int intValue = data.getInt(n, i);
 614                         number += intValue;
 615                     } else if (type == Long.TYPE) {
 616                         long longValue = data.getLong(n, i);
 617                         number += longValue ^ (longValue &gt;&gt;&gt; 32);
 618                     } else if (type == Boolean.TYPE) {
 619                         boolean booleanValue = data.getBoolean(n, i);
 620                         if (booleanValue) {
 621                             number += 7;
 622                         }
 623                     } else if (type == Float.TYPE) {
 624                         float floatValue = data.getFloat(n, i);
 625                         number += Float.floatToRawIntBits(floatValue);
 626                     } else if (type == Double.TYPE) {
 627                         double doubleValue = data.getDouble(n, i);
 628                         long longValue = Double.doubleToRawLongBits(doubleValue);
 629                         number += longValue ^ (longValue &gt;&gt;&gt; 32);
 630                     } else if (type == Short.TYPE) {
 631                         short shortValue = data.getShort(n, i);
 632                         number += shortValue;
 633                     } else if (type == Character.TYPE) {
 634                         char charValue = data.getChar(n, i);
 635                         number += charValue;
 636                     } else if (type == Byte.TYPE) {
 637                         byte byteValue = data.getByte(n, i);
 638                         number += byteValue;
 639                     } else {
 640                         assert false : &quot;unhandled property type: &quot; + type;
 641                     }
 642                 } else {
 643                     Object o = data.getObject(n, i);
 644                     number += deepHashCode0(o);
 645                 }
 646                 number *= 13;
 647             }
 648         }
 649         return number;
 650     }
 651 
 652     private static boolean deepEquals0(Object e1, Object e2) {
 653         if (e1 == e2) {
 654             return true;
 655         } else if (e1 == null || e2 == null) {
 656             return false;
 657         } else if (!e1.getClass().isArray() || e1.getClass() != e2.getClass()) {
 658             return e1.equals(e2);
 659         } else if (e1 instanceof Object[] &amp;&amp; e2 instanceof Object[]) {
 660             return deepEquals((Object[]) e1, (Object[]) e2);
 661         } else if (e1 instanceof int[]) {
 662             return Arrays.equals((int[]) e1, (int[]) e2);
 663         } else if (e1 instanceof long[]) {
 664             return Arrays.equals((long[]) e1, (long[]) e2);
 665         } else if (e1 instanceof byte[]) {
 666             return Arrays.equals((byte[]) e1, (byte[]) e2);
 667         } else if (e1 instanceof char[]) {
 668             return Arrays.equals((char[]) e1, (char[]) e2);
 669         } else if (e1 instanceof short[]) {
 670             return Arrays.equals((short[]) e1, (short[]) e2);
 671         } else if (e1 instanceof float[]) {
 672             return Arrays.equals((float[]) e1, (float[]) e2);
 673         } else if (e1 instanceof double[]) {
 674             return Arrays.equals((double[]) e1, (double[]) e2);
 675         } else if (e1 instanceof boolean[]) {
 676             return Arrays.equals((boolean[]) e1, (boolean[]) e2);
 677         } else {
 678             throw shouldNotReachHere();
 679         }
 680     }
 681 
 682     private static boolean deepEquals(Object[] a1, Object[] a2) {
 683         int length = a1.length;
 684         if (a2.length != length) {
 685             return false;
 686         }
 687 
 688         for (int i = 0; i &lt; length; i++) {
 689             if (!deepEquals0(a1[i], a2[i])) {
 690                 return false;
 691             }
 692         }
 693         return true;
 694     }
 695 
 696     public boolean dataEquals(Node a, Node b) {
 697         assert a.getClass() == b.getClass();
 698         for (int i = 0; i &lt; data.getCount(); ++i) {
 699             Class&lt;?&gt; type = data.getType(i);
 700             if (type.isPrimitive()) {
 701                 if (type == Integer.TYPE) {
 702                     int aInt = data.getInt(a, i);
 703                     int bInt = data.getInt(b, i);
 704                     if (aInt != bInt) {
 705                         return false;
 706                     }
 707                 } else if (type == Boolean.TYPE) {
 708                     boolean aBoolean = data.getBoolean(a, i);
 709                     boolean bBoolean = data.getBoolean(b, i);
 710                     if (aBoolean != bBoolean) {
 711                         return false;
 712                     }
 713                 } else if (type == Long.TYPE) {
 714                     long aLong = data.getLong(a, i);
 715                     long bLong = data.getLong(b, i);
 716                     if (aLong != bLong) {
 717                         return false;
 718                     }
 719                 } else if (type == Float.TYPE) {
 720                     float aFloat = data.getFloat(a, i);
 721                     float bFloat = data.getFloat(b, i);
 722                     if (aFloat != bFloat) {
 723                         return false;
 724                     }
 725                 } else if (type == Double.TYPE) {
 726                     double aDouble = data.getDouble(a, i);
 727                     double bDouble = data.getDouble(b, i);
 728                     if (aDouble != bDouble) {
 729                         return false;
 730                     }
 731                 } else if (type == Short.TYPE) {
 732                     short aShort = data.getShort(a, i);
 733                     short bShort = data.getShort(b, i);
 734                     if (aShort != bShort) {
 735                         return false;
 736                     }
 737                 } else if (type == Character.TYPE) {
 738                     char aChar = data.getChar(a, i);
 739                     char bChar = data.getChar(b, i);
 740                     if (aChar != bChar) {
 741                         return false;
 742                     }
 743                 } else if (type == Byte.TYPE) {
 744                     byte aByte = data.getByte(a, i);
 745                     byte bByte = data.getByte(b, i);
 746                     if (aByte != bByte) {
 747                         return false;
 748                     }
 749                 } else {
 750                     assert false : &quot;unhandled type: &quot; + type;
 751                 }
 752             } else {
 753                 Object objectA = data.getObject(a, i);
 754                 Object objectB = data.getObject(b, i);
 755                 assert !isLambda(objectA) || !isLambda(objectB) : &quot;lambdas are not permitted in fields of &quot; + this.toString();
 756                 if (objectA != objectB) {
 757                     if (objectA != null &amp;&amp; objectB != null) {
 758                         if (!deepEquals0(objectA, objectB)) {
 759                             return false;
 760                         }
 761                     } else {
 762                         return false;
 763                     }
 764                 }
 765             }
 766         }
 767         return true;
 768     }
 769 
 770     private static boolean isLambda(Object obj) {
 771         // This needs to be consistent with InnerClassLambdaMetafactory constructor.
 772         return obj != null &amp;&amp; obj.getClass().getSimpleName().contains(&quot;$$Lambda$&quot;);
 773     }
 774 
 775     public boolean isValid(Position pos, NodeClass&lt;?&gt; from, Edges fromEdges) {
 776         if (this == from) {
 777             return true;
 778         }
 779         Edges toEdges = getEdges(fromEdges.type());
 780         if (pos.getIndex() &gt;= toEdges.getCount()) {
 781             return false;
 782         }
 783         if (pos.getIndex() &gt;= fromEdges.getCount()) {
 784             return false;
 785         }
 786         return toEdges.isSame(fromEdges, pos.getIndex());
 787     }
 788 
 789     static void updateEdgesInPlace(Node node, InplaceUpdateClosure duplicationReplacement, Edges edges) {
 790         int index = 0;
 791         Type curType = edges.type();
 792         int directCount = edges.getDirectCount();
 793         final long[] curOffsets = edges.getOffsets();
 794         while (index &lt; directCount) {
 795             Node edge = Edges.getNode(node, curOffsets, index);
 796             if (edge != null) {
 797                 Node newEdge = duplicationReplacement.replacement(edge, curType);
 798                 if (curType == Edges.Type.Inputs) {
 799                     node.updateUsages(null, newEdge);
 800                 } else {
 801                     node.updatePredecessor(null, newEdge);
 802                 }
 803                 edges.initializeNode(node, index, newEdge);
 804             }
 805             index++;
 806         }
 807 
 808         while (index &lt; edges.getCount()) {
 809             NodeList&lt;Node&gt; list = Edges.getNodeList(node, curOffsets, index);
 810             if (list != null) {
 811                 edges.initializeList(node, index, updateEdgeListCopy(node, list, duplicationReplacement, curType));
 812             }
 813             index++;
 814         }
 815     }
 816 
 817     void updateInputSuccInPlace(Node node, InplaceUpdateClosure duplicationReplacement) {
 818         updateEdgesInPlace(node, duplicationReplacement, inputs);
 819         updateEdgesInPlace(node, duplicationReplacement, successors);
 820     }
 821 
 822     private static NodeList&lt;Node&gt; updateEdgeListCopy(Node node, NodeList&lt;Node&gt; list, InplaceUpdateClosure duplicationReplacement, Edges.Type type) {
 823         NodeList&lt;Node&gt; result = type == Edges.Type.Inputs ? new NodeInputList&lt;&gt;(node, list.size()) : new NodeSuccessorList&lt;&gt;(node, list.size());
 824 
 825         for (int i = 0; i &lt; list.count(); ++i) {
 826             Node oldNode = list.get(i);
 827             if (oldNode != null) {
 828                 Node newNode = duplicationReplacement.replacement(oldNode, type);
 829                 result.set(i, newNode);
 830             }
 831         }
 832         return result;
 833     }
 834 
 835     /**
 836      * Gets the input or successor edges defined by this node class.
 837      */
 838     public Edges getEdges(Edges.Type type) {
 839         return type == Edges.Type.Inputs ? inputs : successors;
 840     }
 841 
 842     public Edges getInputEdges() {
 843         return inputs;
 844     }
 845 
 846     public Edges getSuccessorEdges() {
 847         return successors;
 848     }
 849 
 850     /**
 851      * Returns a newly allocated node for which no subclass-specific constructor has been called.
 852      */
 853     @SuppressWarnings(&quot;unchecked&quot;)
 854     public Node allocateInstance() {
 855         try {
 856             Node node = (Node) UNSAFE.allocateInstance(getJavaClass());
 857             node.init((NodeClass&lt;? extends Node&gt;) this);
 858             return node;
 859         } catch (InstantiationException ex) {
 860             throw shouldNotReachHere(ex);
 861         }
 862     }
 863 
 864     public Class&lt;T&gt; getJavaClass() {
 865         return getClazz();
 866     }
 867 
 868     /**
 869      * The template used to build the {@link Verbosity#Name} version. Variable parts are specified
 870      * using &amp;#123;i#inputName&amp;#125; or &amp;#123;p#propertyName&amp;#125;. If no
 871      * {@link NodeInfo#nameTemplate() template} is specified, it uses {@link NodeInfo#shortName()}.
 872      * If none of the two is specified, it returns an empty string.
 873      */
 874     public String getNameTemplate() {
 875         return nameTemplate;
 876     }
 877 
 878     interface InplaceUpdateClosure {
 879 
 880         Node replacement(Node node, Edges.Type type);
 881     }
 882 
 883     static EconomicMap&lt;Node, Node&gt; addGraphDuplicate(final Graph graph, final Graph oldGraph, int estimatedNodeCount, Iterable&lt;? extends Node&gt; nodes, final DuplicationReplacement replacements) {
 884         final EconomicMap&lt;Node, Node&gt; newNodes;
 885         int denseThreshold = oldGraph.getNodeCount() + oldGraph.getNodesDeletedSinceLastCompression() &gt;&gt; 4;
 886         if (estimatedNodeCount &gt; denseThreshold) {
 887             // Use dense map
 888             newNodes = new NodeMap&lt;&gt;(oldGraph);
 889         } else {
 890             // Use sparse map
 891             newNodes = EconomicMap.create(Equivalence.IDENTITY);
 892         }
 893         createNodeDuplicates(graph, nodes, replacements, newNodes);
 894 
 895         InplaceUpdateClosure replacementClosure = new InplaceUpdateClosure() {
 896 
 897             @Override
 898             public Node replacement(Node node, Edges.Type type) {
 899                 Node target = newNodes.get(node);
 900                 if (target == null) {
 901                     Node replacement = node;
 902                     if (replacements != null) {
 903                         replacement = replacements.replacement(node);
 904                     }
 905                     if (replacement != node) {
 906                         target = replacement;
 907                     } else if (node.graph() == graph &amp;&amp; type == Edges.Type.Inputs) {
 908                         // patch to the outer world
 909                         target = node;
 910                     }
 911 
 912                 }
 913                 return target;
 914             }
 915 
 916         };
 917 
 918         // re-wire inputs
 919         for (Node oldNode : nodes) {
 920             Node node = newNodes.get(oldNode);
 921             NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
 922             if (replacements == null || replacements.replacement(oldNode) == oldNode) {
 923                 nodeClass.updateInputSuccInPlace(node, replacementClosure);
 924             } else {
 925                 transferEdgesDifferentNodeClass(graph, replacements, newNodes, oldNode, node);
 926             }
 927         }
 928 
 929         return newNodes;
 930     }
 931 
 932     private static void createNodeDuplicates(final Graph graph, Iterable&lt;? extends Node&gt; nodes, final DuplicationReplacement replacements, final EconomicMap&lt;Node, Node&gt; newNodes) {
 933         for (Node node : nodes) {
 934             if (node != null) {
 935                 assert !node.isDeleted() : &quot;trying to duplicate deleted node: &quot; + node;
 936                 Node replacement = node;
 937                 if (replacements != null) {
 938                     replacement = replacements.replacement(node);
 939                 }
 940                 if (replacement != node) {
 941                     assert replacement != null;
 942                     newNodes.put(node, replacement);
 943                 } else {
 944                     Node newNode = node.clone(graph, WithAllEdges);
 945                     assert newNode.getNodeClass().isLeafNode() || newNode.hasNoUsages();
 946                     assert newNode.getClass() == node.getClass();
 947                     newNodes.put(node, newNode);
 948                 }
 949             }
 950         }
 951     }
 952 
 953     private static void transferEdgesDifferentNodeClass(final Graph graph, final DuplicationReplacement replacements, final EconomicMap&lt;Node, Node&gt; newNodes, Node oldNode, Node node) {
 954         transferEdges(graph, replacements, newNodes, oldNode, node, Edges.Type.Inputs);
 955         transferEdges(graph, replacements, newNodes, oldNode, node, Edges.Type.Successors);
 956     }
 957 
 958     private static void transferEdges(final Graph graph, final DuplicationReplacement replacements, final EconomicMap&lt;Node, Node&gt; newNodes, Node oldNode, Node node, Edges.Type type) {
 959         NodeClass&lt;?&gt; nodeClass = node.getNodeClass();
 960         NodeClass&lt;?&gt; oldNodeClass = oldNode.getNodeClass();
 961         Edges oldEdges = oldNodeClass.getEdges(type);
 962         for (Position pos : oldEdges.getPositionsIterable(oldNode)) {
 963             if (!nodeClass.isValid(pos, oldNodeClass, oldEdges)) {
 964                 continue;
 965             }
 966             Node oldEdge = pos.get(oldNode);
 967             if (oldEdge != null) {
 968                 Node target = newNodes.get(oldEdge);
 969                 if (target == null) {
 970                     Node replacement = oldEdge;
 971                     if (replacements != null) {
 972                         replacement = replacements.replacement(oldEdge);
 973                     }
 974                     if (replacement != oldEdge) {
 975                         target = replacement;
 976                     } else if (type == Edges.Type.Inputs &amp;&amp; oldEdge.graph() == graph) {
 977                         // patch to the outer world
 978                         target = oldEdge;
 979                     }
 980                 }
 981                 pos.set(node, target);
 982             }
 983         }
 984     }
 985 
 986     /**
 987      * @return true if the node has no inputs and no successors
 988      */
 989     public boolean isLeafNode() {
 990         return isLeafNode;
 991     }
 992 
 993     public int getLeafId() {
 994         return this.leafId;
 995     }
 996 
 997     public NodeClass&lt;? super T&gt; getSuperNodeClass() {
 998         return superNodeClass;
 999     }
1000 
1001     public long inputsIteration() {
1002         return inputsIteration;
1003     }
1004 
1005     /**
1006      * An iterator that will iterate over edges.
1007      *
1008      * An iterator of this type will not return null values, unless edges are modified concurrently.
1009      * Concurrent modifications are detected by an assertion on a best-effort basis.
1010      */
1011     private static class RawEdgesIterator implements Iterator&lt;Node&gt; {
1012         protected final Node node;
1013         protected long mask;
1014         protected Node nextValue;
1015 
1016         RawEdgesIterator(Node node, long mask) {
1017             this.node = node;
1018             this.mask = mask;
1019         }
1020 
1021         @Override
1022         public boolean hasNext() {
1023             Node next = nextValue;
1024             if (next != null) {
1025                 return true;
1026             } else {
1027                 nextValue = forward();
1028                 return nextValue != null;
1029             }
1030         }
1031 
1032         private Node forward() {
1033             while (mask != 0) {
1034                 Node next = getInput();
1035                 mask = advanceInput();
1036                 if (next != null) {
1037                     return next;
1038                 }
1039             }
1040             return null;
1041         }
1042 
1043         @Override
1044         public Node next() {
1045             Node next = nextValue;
1046             if (next == null) {
1047                 next = forward();
1048                 if (next == null) {
1049                     throw new NoSuchElementException();
1050                 } else {
1051                     return next;
1052                 }
1053             } else {
1054                 nextValue = null;
1055                 return next;
1056             }
1057         }
1058 
1059         public final long advanceInput() {
1060             int state = (int) mask &amp; 0x03;
1061             if (state == 0) {
1062                 // Skip normal field.
1063                 return mask &gt;&gt;&gt; NEXT_EDGE;
1064             } else if (state == 1) {
1065                 // We are iterating a node list.
1066                 if ((mask &amp; 0xFFFF00) != 0) {
1067                     // Node list count is non-zero, decrease by 1.
1068                     return mask - 0x100;
1069                 } else {
1070                     // Node list is finished =&gt; go to next input.
1071                     return mask &gt;&gt;&gt; 24;
1072                 }
1073             } else {
1074                 // Need to expand node list.
1075                 NodeList&lt;?&gt; nodeList = Edges.getNodeListUnsafe(node, mask &amp; 0xFC);
1076                 if (nodeList != null) {
1077                     int size = nodeList.size();
1078                     if (size != 0) {
1079                         // Set pointer to upper most index of node list.
1080                         return ((mask &gt;&gt;&gt; NEXT_EDGE) &lt;&lt; 24) | (mask &amp; 0xFD) | ((size - 1) &lt;&lt; NEXT_EDGE);
1081                     }
1082                 }
1083                 // Node list is empty or null =&gt; skip.
1084                 return mask &gt;&gt;&gt; NEXT_EDGE;
1085             }
1086         }
1087 
1088         public Node getInput() {
1089             int state = (int) mask &amp; 0x03;
1090             if (state == 0) {
1091                 return Edges.getNodeUnsafe(node, mask &amp; 0xFC);
1092             } else if (state == 1) {
1093                 // We are iterating a node list.
1094                 NodeList&lt;?&gt; nodeList = Edges.getNodeListUnsafe(node, mask &amp; 0xFC);
1095                 return nodeList.nodes[nodeList.size() - 1 - (int) ((mask &gt;&gt;&gt; NEXT_EDGE) &amp; 0xFFFF)];
1096             } else {
1097                 // Node list needs to expand first.
1098                 return null;
1099             }
1100         }
1101 
1102         @Override
1103         public void remove() {
1104             throw new UnsupportedOperationException();
1105         }
1106 
1107         public Position nextPosition() {
1108             return null;
1109         }
1110     }
1111 
1112     private static final class RawEdgesWithModCountIterator extends RawEdgesIterator {
1113         private final int modCount;
1114 
1115         private RawEdgesWithModCountIterator(Node node, long mask) {
1116             super(node, mask);
1117             assert isModificationCountsEnabled();
1118             this.modCount = node.modCount();
1119         }
1120 
1121         @Override
1122         public boolean hasNext() {
1123             try {
1124                 return super.hasNext();
1125             } finally {
1126                 assert modCount == node.modCount() : &quot;must not be modified&quot;;
1127             }
1128         }
1129 
1130         @Override
1131         public Node next() {
1132             try {
1133                 return super.next();
1134             } finally {
1135                 assert modCount == node.modCount() : &quot;must not be modified&quot;;
1136             }
1137         }
1138 
1139         @Override
1140         public Position nextPosition() {
1141             try {
1142                 return super.nextPosition();
1143             } finally {
1144                 assert modCount == node.modCount();
1145             }
1146         }
1147     }
1148 
1149     public NodeIterable&lt;Node&gt; getSuccessorIterable(final Node node) {
1150         long mask = this.successorIteration;
1151         return new NodeIterable&lt;Node&gt;() {
1152 
1153             @Override
1154             public Iterator&lt;Node&gt; iterator() {
1155                 if (isModificationCountsEnabled()) {
1156                     return new RawEdgesWithModCountIterator(node, mask);
1157                 } else {
1158                     return new RawEdgesIterator(node, mask);
1159                 }
1160             }
1161 
1162             @Override
1163             public String toString() {
1164                 StringBuilder sb = new StringBuilder();
1165                 Iterator&lt;Node&gt; iterator = iterator();
1166                 boolean first = true;
1167                 sb.append(&quot;succs=&quot;);
1168                 sb.append(&#39;[&#39;);
1169                 while (iterator.hasNext()) {
1170                     Node input = iterator.next();
1171                     if (!first) {
1172                         sb.append(&quot;, &quot;);
1173                     }
1174                     sb.append(input);
1175                     first = false;
1176                 }
1177                 sb.append(&#39;]&#39;);
1178                 return sb.toString();
1179             }
1180         };
1181     }
1182 
1183     public NodeIterable&lt;Node&gt; getInputIterable(final Node node) {
1184         long mask = this.inputsIteration;
1185         return new NodeIterable&lt;Node&gt;() {
1186 
1187             @Override
1188             public Iterator&lt;Node&gt; iterator() {
1189                 if (isModificationCountsEnabled()) {
1190                     return new RawEdgesWithModCountIterator(node, mask);
1191                 } else {
1192                     return new RawEdgesIterator(node, mask);
1193                 }
1194             }
1195 
1196             @Override
1197             public String toString() {
1198                 StringBuilder sb = new StringBuilder();
1199                 Iterator&lt;Node&gt; iterator = iterator();
1200                 boolean first = true;
1201                 sb.append(&quot;inputs=&quot;);
1202                 sb.append(&#39;[&#39;);
1203                 while (iterator.hasNext()) {
1204                     Node input = iterator.next();
1205                     if (!first) {
1206                         sb.append(&quot;, &quot;);
1207                     }
1208                     sb.append(input);
1209                     first = false;
1210                 }
1211                 sb.append(&#39;]&#39;);
1212                 return sb.toString();
1213             }
1214         };
1215     }
1216 
1217     public boolean equalSuccessors(Node node, Node other) {
1218         return equalEdges(node, other, successorIteration);
1219     }
1220 
1221     public boolean equalInputs(Node node, Node other) {
1222         return equalEdges(node, other, inputsIteration);
1223     }
1224 
1225     private boolean equalEdges(Node node, Node other, long mask) {
1226         long myMask = mask;
1227         assert other.getNodeClass() == this;
1228         while (myMask != 0) {
1229             long offset = (myMask &amp; OFFSET_MASK);
1230             if ((myMask &amp; LIST_MASK) == 0) {
1231                 Object v1 = Edges.getNodeUnsafe(node, offset);
1232                 Object v2 = Edges.getNodeUnsafe(other, offset);
1233                 if (v1 != v2) {
1234                     return false;
1235                 }
1236             } else {
1237                 NodeList&lt;Node&gt; v1 = Edges.getNodeListUnsafe(node, offset);
1238                 NodeList&lt;Node&gt; v2 = Edges.getNodeListUnsafe(other, offset);
1239                 if (!Objects.equals(v1, v2)) {
1240                     return false;
1241                 }
1242             }
1243             myMask &gt;&gt;&gt;= NEXT_EDGE;
1244         }
1245         return true;
1246     }
1247 
1248     public void pushInputs(Node node, NodeStack stack) {
1249         long myMask = this.inputsIteration;
1250         while (myMask != 0) {
1251             long offset = (myMask &amp; OFFSET_MASK);
1252             if ((myMask &amp; LIST_MASK) == 0) {
1253                 Node curNode = Edges.getNodeUnsafe(node, offset);
1254                 if (curNode != null) {
1255                     stack.push(curNode);
1256                 }
1257             } else {
1258                 pushAllHelper(stack, node, offset);
1259             }
1260             myMask &gt;&gt;&gt;= NEXT_EDGE;
1261         }
1262     }
1263 
1264     private static void pushAllHelper(NodeStack stack, Node node, long offset) {
1265         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1266         if (list != null) {
1267             for (int i = 0; i &lt; list.size(); ++i) {
1268                 Node curNode = list.get(i);
1269                 if (curNode != null) {
1270                     stack.push(curNode);
1271                 }
1272             }
1273         }
1274     }
1275 
1276     public void applySuccessors(Node node, EdgeVisitor consumer) {
1277         applyEdges(node, consumer, this.successorIteration);
1278     }
1279 
1280     public void applyInputs(Node node, EdgeVisitor consumer) {
1281         applyEdges(node, consumer, this.inputsIteration);
1282     }
1283 
1284     private static void applyEdges(Node node, EdgeVisitor consumer, long mask) {
1285         long myMask = mask;
1286         while (myMask != 0) {
1287             long offset = (myMask &amp; OFFSET_MASK);
1288             if ((myMask &amp; LIST_MASK) == 0) {
1289                 Node curNode = Edges.getNodeUnsafe(node, offset);
1290                 if (curNode != null) {
1291                     Node newNode = consumer.apply(node, curNode);
1292                     if (newNode != curNode) {
1293                         Edges.putNodeUnsafe(node, offset, newNode);
1294                     }
1295                 }
1296             } else {
1297                 applyHelper(node, consumer, offset);
1298             }
1299             myMask &gt;&gt;&gt;= NEXT_EDGE;
1300         }
1301     }
1302 
1303     private static void applyHelper(Node node, EdgeVisitor consumer, long offset) {
1304         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1305         if (list != null) {
1306             for (int i = 0; i &lt; list.size(); ++i) {
1307                 Node curNode = list.get(i);
1308                 if (curNode != null) {
1309                     Node newNode = consumer.apply(node, curNode);
1310                     if (newNode != curNode) {
1311                         list.initialize(i, newNode);
1312                     }
1313                 }
1314             }
1315         }
1316     }
1317 
1318     public void unregisterAtSuccessorsAsPredecessor(Node node) {
1319         long myMask = this.successorIteration;
1320         while (myMask != 0) {
1321             long offset = (myMask &amp; OFFSET_MASK);
1322             if ((myMask &amp; LIST_MASK) == 0) {
1323                 Node curNode = Edges.getNodeUnsafe(node, offset);
1324                 if (curNode != null) {
1325                     node.updatePredecessor(curNode, null);
1326                     Edges.putNodeUnsafe(node, offset, null);
1327                 }
1328             } else {
1329                 unregisterAtSuccessorsAsPredecessorHelper(node, offset);
1330             }
1331             myMask &gt;&gt;&gt;= NEXT_EDGE;
1332         }
1333     }
1334 
1335     private static void unregisterAtSuccessorsAsPredecessorHelper(Node node, long offset) {
1336         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1337         if (list != null) {
1338             for (int i = 0; i &lt; list.size(); ++i) {
1339                 Node curNode = list.get(i);
1340                 if (curNode != null) {
1341                     node.updatePredecessor(curNode, null);
1342                 }
1343             }
1344             list.clearWithoutUpdate();
1345         }
1346     }
1347 
1348     public void registerAtSuccessorsAsPredecessor(Node node) {
1349         long myMask = this.successorIteration;
1350         while (myMask != 0) {
1351             long offset = (myMask &amp; OFFSET_MASK);
1352             if ((myMask &amp; LIST_MASK) == 0) {
1353                 Node curNode = Edges.getNodeUnsafe(node, offset);
1354                 if (curNode != null) {
1355                     assert curNode.isAlive() : &quot;Successor not alive&quot;;
1356                     node.updatePredecessor(null, curNode);
1357                 }
1358             } else {
1359                 registerAtSuccessorsAsPredecessorHelper(node, offset);
1360             }
1361             myMask &gt;&gt;&gt;= NEXT_EDGE;
1362         }
1363     }
1364 
1365     private static void registerAtSuccessorsAsPredecessorHelper(Node node, long offset) {
1366         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1367         if (list != null) {
1368             for (int i = 0; i &lt; list.size(); ++i) {
1369                 Node curNode = list.get(i);
1370                 if (curNode != null) {
1371                     assert curNode.isAlive() : &quot;Successor not alive&quot;;
1372                     node.updatePredecessor(null, curNode);
1373                 }
1374             }
1375         }
1376     }
1377 
1378     public boolean replaceFirstInput(Node node, Node key, Node replacement) {
1379         return replaceFirstEdge(node, key, replacement, this.inputsIteration);
1380     }
1381 
1382     public boolean replaceFirstSuccessor(Node node, Node key, Node replacement) {
1383         return replaceFirstEdge(node, key, replacement, this.successorIteration);
1384     }
1385 
1386     public static boolean replaceFirstEdge(Node node, Node key, Node replacement, long mask) {
1387         long myMask = mask;
1388         while (myMask != 0) {
1389             long offset = (myMask &amp; OFFSET_MASK);
1390             if ((myMask &amp; LIST_MASK) == 0) {
1391                 Object curNode = Edges.getNodeUnsafe(node, offset);
1392                 if (curNode == key) {
1393                     Edges.putNodeUnsafe(node, offset, replacement);
1394                     return true;
1395                 }
1396             } else {
1397                 NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1398                 if (list != null &amp;&amp; list.replaceFirst(key, replacement)) {
1399                     return true;
1400                 }
1401             }
1402             myMask &gt;&gt;&gt;= NEXT_EDGE;
1403         }
1404         return false;
1405     }
1406 
1407     public void registerAtInputsAsUsage(Node node) {
1408         long myMask = this.inputsIteration;
1409         while (myMask != 0) {
1410             long offset = (myMask &amp; OFFSET_MASK);
1411             if ((myMask &amp; LIST_MASK) == 0) {
1412                 Node curNode = Edges.getNodeUnsafe(node, offset);
1413                 if (curNode != null) {
1414                     assert curNode.isAlive() : &quot;Input not alive &quot; + curNode;
1415                     curNode.addUsage(node);
1416                 }
1417             } else {
1418                 registerAtInputsAsUsageHelper(node, offset);
1419             }
1420             myMask &gt;&gt;&gt;= NEXT_EDGE;
1421         }
1422     }
1423 
1424     private static void registerAtInputsAsUsageHelper(Node node, long offset) {
1425         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1426         if (list != null) {
1427             for (int i = 0; i &lt; list.size(); ++i) {
1428                 Node curNode = list.get(i);
1429                 if (curNode != null) {
1430                     assert curNode.isAlive() : &quot;Input not alive&quot;;
1431                     curNode.addUsage(node);
1432                 }
1433             }
1434         }
1435     }
1436 
1437     public void unregisterAtInputsAsUsage(Node node) {
1438         long myMask = this.inputsIteration;
1439         while (myMask != 0) {
1440             long offset = (myMask &amp; OFFSET_MASK);
1441             if ((myMask &amp; LIST_MASK) == 0) {
1442                 Node curNode = Edges.getNodeUnsafe(node, offset);
1443                 if (curNode != null) {
1444                     node.removeThisFromUsages(curNode);
1445                     if (curNode.hasNoUsages()) {
1446                         node.maybeNotifyZeroUsages(curNode);
1447                     }
1448                     Edges.putNodeUnsafe(node, offset, null);
1449                 }
1450             } else {
1451                 unregisterAtInputsAsUsageHelper(node, offset);
1452             }
1453             myMask &gt;&gt;&gt;= NEXT_EDGE;
1454         }
1455     }
1456 
1457     private static void unregisterAtInputsAsUsageHelper(Node node, long offset) {
1458         NodeList&lt;Node&gt; list = Edges.getNodeListUnsafe(node, offset);
1459         if (list != null) {
1460             for (int i = 0; i &lt; list.size(); ++i) {
1461                 Node curNode = list.get(i);
1462                 if (curNode != null) {
1463                     node.removeThisFromUsages(curNode);
1464                     if (curNode.hasNoUsages()) {
1465                         node.maybeNotifyZeroUsages(curNode);
1466                     }
1467                 }
1468             }
1469             list.clearWithoutUpdate();
1470         }
1471     }
1472 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/macosx/classes/apple/security/KeychainStore.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../../../linux/native/libnio/ch/EPoll.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../java/net/DefaultInterface.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/macosx/classes/apple/security/KeychainStore.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 110     }
 111 
 112     private static void permissionCheck() {
 113         SecurityManager sec = System.getSecurityManager();
 114 
 115         if (sec != null) {
 116             sec.checkPermission(new RuntimePermission(&quot;useKeychainStore&quot;));
 117         }
 118     }
 119 
 120 
 121     /**
 122      * Verify the Apple provider in the constructor.
 123      *
 124      * @exception SecurityException if fails to verify
 125      * its own integrity
 126      */
 127     public KeychainStore() { }
 128 
 129     /**
<span class="line-modified"> 130         * Returns the key associated with the given alias, using the given</span>
 131      * password to recover it.
 132      *
 133      * @param alias the alias name
 134      * @param password the password for recovering the key. This password is
 135      *        used internally as the key is exported in a PKCS12 format.
 136      *
 137      * @return the requested key, or null if the given alias does not exist
 138      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
 139      *
 140      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 141      * key cannot be found
 142      * @exception UnrecoverableKeyException if the key cannot be recovered
 143      * (e.g., the given password is wrong).
 144      */
 145     public Key engineGetKey(String alias, char[] password)
 146         throws NoSuchAlgorithmException, UnrecoverableKeyException
 147     {
 148         permissionCheck();
 149 
 150         // An empty password is rejected by MacOS API, no private key data
</pre>
<hr />
<pre>
 223             returnValue = kfac.generatePrivate(kspec);
 224         } catch (Exception e) {
 225             UnrecoverableKeyException uke =
 226             new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
 227                                           e.getMessage());
 228             uke.initCause(e);
 229             throw uke;
 230         }
 231 
 232         return returnValue;
 233     }
 234 
 235     private native byte[] _getEncodedKeyData(long secKeyRef, char[] password);
 236 
 237     /**
 238      * Returns the certificate chain associated with the given alias.
 239      *
 240      * @param alias the alias name
 241      *
 242      * @return the certificate chain (ordered with the user&#39;s certificate first
<span class="line-modified"> 243                                       * and the root certificate authority last), or null if the given alias</span>
 244      * does not exist or does not contain a certificate chain (i.e., the given
<span class="line-modified"> 245                                                                * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a</span>
<span class="line-modified"> 246                                                                * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).</span>
 247      */
 248     public Certificate[] engineGetCertificateChain(String alias) {
 249         permissionCheck();
 250 
 251         Object entry = entries.get(alias.toLowerCase());
 252 
 253         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
 254             if (((KeyEntry)entry).chain == null) {
 255                 return null;
 256             } else {
 257                 return ((KeyEntry)entry).chain.clone();
 258             }
 259         } else {
 260             return null;
 261         }
 262     }
 263 
 264     /**
 265      * Returns the certificate associated with the given alias.
 266      *
</pre>
<hr />
<pre>
 280         permissionCheck();
 281 
 282         Object entry = entries.get(alias.toLowerCase());
 283 
 284         if (entry != null) {
 285             if (entry instanceof TrustedCertEntry) {
 286                 return ((TrustedCertEntry)entry).cert;
 287             } else {
 288                 KeyEntry ke = (KeyEntry)entry;
 289                 if (ke.chain == null || ke.chain.length == 0) {
 290                     return null;
 291                 }
 292                 return ke.chain[0];
 293             }
 294         } else {
 295             return null;
 296         }
 297     }
 298 
 299     /**
<span class="line-modified"> 300         * Returns the creation date of the entry identified by the given alias.</span>
 301      *
 302      * @param alias the alias name
 303      *
 304      * @return the creation date of this entry, or null if the given alias does
 305      * not exist
 306      */
 307     public Date engineGetCreationDate(String alias) {
 308         permissionCheck();
 309 
 310         Object entry = entries.get(alias.toLowerCase());
 311 
 312         if (entry != null) {
 313             if (entry instanceof TrustedCertEntry) {
 314                 return new Date(((TrustedCertEntry)entry).date.getTime());
 315             } else {
 316                 return new Date(((KeyEntry)entry).date.getTime());
 317             }
 318         } else {
 319             return null;
 320         }
 321     }
 322 
 323     /**
<span class="line-modified"> 324         * Assigns the given key to the given alias, protecting it with the given</span>
 325      * password.
 326      *
 327      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 328      * it must be accompanied by a certificate chain certifying the
 329      * corresponding public key.
 330      *
 331      * &lt;p&gt;If the given alias already exists, the keystore information
 332      * associated with it is overridden by the given key (and possibly
<span class="line-modified"> 333                                                           * certificate chain).</span>
 334      *
 335      * @param alias the alias name
 336      * @param key the key to be associated with the alias
 337      * @param password the password to protect the key
 338      * @param chain the certificate chain for the corresponding public
 339      * key (only required if the given key is of type
<span class="line-modified"> 340             * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).</span>
 341      *
 342      * @exception KeyStoreException if the given key cannot be protected, or
 343      * this operation fails for some other reason
 344      */
 345     public void engineSetKeyEntry(String alias, Key key, char[] password,
 346                                   Certificate[] chain)
 347         throws KeyStoreException
 348     {
 349         permissionCheck();
 350 
 351         synchronized(entries) {
 352             try {
 353                 KeyEntry entry = new KeyEntry();
 354                 entry.date = new Date();
 355 
 356                 if (key instanceof PrivateKey) {
 357                     if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||
 358                         (key.getFormat().equals(&quot;PKCS8&quot;))) {
 359                         entry.protectedPrivKey = encryptPrivateKey(key.getEncoded(), password);
 360                         entry.password = password.clone();
</pre>
<hr />
<pre>
 374                     entry.chain = chain.clone();
 375                     entry.chainRefs = new long[entry.chain.length];
 376                 }
 377 
 378                 String lowerAlias = alias.toLowerCase();
 379                 if (entries.get(lowerAlias) != null) {
 380                     deletedEntries.put(lowerAlias, entries.get(lowerAlias));
 381                 }
 382 
 383                 entries.put(lowerAlias, entry);
 384                 addedEntries.put(lowerAlias, entry);
 385             } catch (Exception nsae) {
 386                 KeyStoreException ke = new KeyStoreException(&quot;Key protection algorithm not found: &quot; + nsae);
 387                 ke.initCause(nsae);
 388                 throw ke;
 389             }
 390         }
 391     }
 392 
 393     /**
<span class="line-modified"> 394         * Assigns the given key (that has already been protected) to the given</span>
 395      * alias.
 396      *
 397      * &lt;p&gt;If the protected key is of type
 398      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 399      * certificate chain certifying the corresponding public key. If the
 400      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 401      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 402      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 403      *
 404      * &lt;p&gt;If the given alias already exists, the keystore information
 405      * associated with it is overridden by the given key (and possibly
<span class="line-modified"> 406                                                           * certificate chain).</span>
 407      *
 408      * @param alias the alias name
 409      * @param key the key (in protected format) to be associated with the alias
 410      * @param chain the certificate chain for the corresponding public
 411      * key (only useful if the protected key is of type
<span class="line-modified"> 412             * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).</span>
 413      *
 414      * @exception KeyStoreException if this operation fails.
 415      */
 416     public void engineSetKeyEntry(String alias, byte[] key,
 417                                   Certificate[] chain)
 418         throws KeyStoreException
 419     {
 420         permissionCheck();
 421 
 422         synchronized(entries) {
 423             // key must be encoded as EncryptedPrivateKeyInfo as defined in
 424             // PKCS#8
 425             KeyEntry entry = new KeyEntry();
 426             try {
 427                 EncryptedPrivateKeyInfo privateKey = new EncryptedPrivateKeyInfo(key);
 428                 entry.protectedPrivKey = privateKey.getEncoded();
 429             } catch (IOException ioe) {
 430                 throw new KeyStoreException(&quot;key is not encoded as &quot;
 431                                             + &quot;EncryptedPrivateKeyInfo&quot;);
 432             }
 433 
 434             entry.date = new Date();
 435 
 436             if ((chain != null) &amp;&amp;
 437                 (chain.length != 0)) {
 438                 entry.chain = chain.clone();
 439                 entry.chainRefs = new long[entry.chain.length];
 440             }
 441 
 442             String lowerAlias = alias.toLowerCase();
 443             if (entries.get(lowerAlias) != null) {
 444                 deletedEntries.put(lowerAlias, entries.get(alias));
 445             }
 446             entries.put(lowerAlias, entry);
 447             addedEntries.put(lowerAlias, entry);
 448         }
 449     }
 450 
 451     /**
<span class="line-modified"> 452         * Assigns the given certificate to the given alias.</span>
 453      *
 454      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
 455      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
 456      * overridden by the given certificate.
 457      *
 458      * @param alias the alias name
 459      * @param cert the certificate
 460      *
 461      * @exception KeyStoreException if the given alias already exists and does
 462      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
 463      * fails for some other reason.
 464      */
 465     public void engineSetCertificateEntry(String alias, Certificate cert)
 466         throws KeyStoreException
 467     {
 468         permissionCheck();
 469 
 470         synchronized(entries) {
 471 
 472             Object entry = entries.get(alias.toLowerCase());
</pre>
<hr />
<pre>
 484                     TrustedCertEntry tce = (TrustedCertEntry)value;
 485                     if (tce.cert.equals(cert)) {
 486                         throw new KeyStoreException(&quot;Keychain does not support mulitple copies of same certificate.&quot;);
 487                     }
 488                 }
 489             }
 490 
 491             TrustedCertEntry trustedCertEntry = new TrustedCertEntry();
 492             trustedCertEntry.cert = cert;
 493             trustedCertEntry.date = new Date();
 494             String lowerAlias = alias.toLowerCase();
 495             if (entries.get(lowerAlias) != null) {
 496                 deletedEntries.put(lowerAlias, entries.get(lowerAlias));
 497             }
 498             entries.put(lowerAlias, trustedCertEntry);
 499             addedEntries.put(lowerAlias, trustedCertEntry);
 500         }
 501     }
 502 
 503     /**
<span class="line-modified"> 504         * Deletes the entry identified by the given alias from this keystore.</span>
 505      *
 506      * @param alias the alias name
 507      *
 508      * @exception KeyStoreException if the entry cannot be removed.
 509      */
 510     public void engineDeleteEntry(String alias)
 511         throws KeyStoreException
 512     {
 513         permissionCheck();
 514 
 515         synchronized(entries) {
 516             Object entry = entries.remove(alias.toLowerCase());
 517             deletedEntries.put(alias.toLowerCase(), entry);
 518         }
 519     }
 520 
 521     /**
<span class="line-modified"> 522         * Lists all the alias names of this keystore.</span>
 523      *
 524      * @return enumeration of the alias names
 525      */
 526     public Enumeration&lt;String&gt; engineAliases() {
 527         permissionCheck();
 528         return entries.keys();
 529     }
 530 
 531     /**
<span class="line-modified"> 532         * Checks if the given alias exists in this keystore.</span>
 533      *
 534      * @param alias the alias name
 535      *
 536      * @return true if the alias exists, false otherwise
 537      */
 538     public boolean engineContainsAlias(String alias) {
 539         permissionCheck();
 540         return entries.containsKey(alias.toLowerCase());
 541     }
 542 
 543     /**
<span class="line-modified"> 544         * Retrieves the number of entries in this keystore.</span>
 545      *
 546      * @return the number of entries in this keystore
 547      */
 548     public int engineSize() {
 549         permissionCheck();
 550         return entries.size();
 551     }
 552 
 553     /**
<span class="line-modified"> 554         * Returns true if the entry identified by the given alias is a</span>
 555      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
 556      *
 557      * @return true if the entry identified by the given alias is a
 558      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
 559      */
 560     public boolean engineIsKeyEntry(String alias) {
 561         permissionCheck();
 562         Object entry = entries.get(alias.toLowerCase());
 563         if ((entry != null) &amp;&amp; (entry instanceof KeyEntry)) {
 564             return true;
 565         } else {
 566             return false;
 567         }
 568     }
 569 
 570     /**
<span class="line-modified"> 571         * Returns true if the entry identified by the given alias is a</span>
 572      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
 573      *
 574      * @return true if the entry identified by the given alias is a
 575      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
 576      */
 577     public boolean engineIsCertificateEntry(String alias) {
 578         permissionCheck();
 579         Object entry = entries.get(alias.toLowerCase());
 580         if ((entry != null) &amp;&amp; (entry instanceof TrustedCertEntry)) {
 581             return true;
 582         } else {
 583             return false;
 584         }
 585     }
 586 
 587     /**
<span class="line-modified"> 588         * Returns the (alias) name of the first keystore entry whose certificate</span>
 589      * matches the given certificate.
 590      *
 591      * &lt;p&gt;This method attempts to match the given certificate with each
 592      * keystore entry. If the entry being considered
 593      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
 594      * compared to that entry&#39;s certificate. If the entry being considered is
 595      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
 596      * element of that entry&#39;s certificate chain (if a chain exists).
 597      *
 598      * @param cert the certificate to match with.
 599      *
 600      * @return the (alias) name of the first entry with matching certificate,
 601      * or null if no such entry exists in this keystore.
 602      */
 603     public String engineGetCertificateAlias(Certificate cert) {
 604         permissionCheck();
 605         Certificate certElem;
 606 
 607         for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {
 608             String alias = e.nextElement();
 609             Object entry = entries.get(alias);
 610             if (entry instanceof TrustedCertEntry) {
 611                 certElem = ((TrustedCertEntry)entry).cert;
 612             } else {
 613                 KeyEntry ke = (KeyEntry)entry;
 614                 if (ke.chain == null || ke.chain.length == 0) {
 615                     continue;
 616                 }
 617                 certElem = ke.chain[0];
 618             }
 619             if (certElem.equals(cert)) {
 620                 return alias;
 621             }
 622         }
 623         return null;
 624     }
 625 
 626     /**
<span class="line-modified"> 627         * Stores this keystore to the given output stream, and protects its</span>
 628      * integrity with the given password.
 629      *
 630      * @param stream Ignored. the output stream to which this keystore is written.
 631      * @param password the password to generate the keystore integrity check
 632      *
 633      * @exception IOException if there was an I/O problem with data
 634      * @exception NoSuchAlgorithmException if the appropriate data integrity
 635      * algorithm could not be found
 636      * @exception CertificateException if any of the certificates included in
 637      * the keystore data could not be stored
 638      */
 639     public void engineStore(OutputStream stream, char[] password)
 640         throws IOException, NoSuchAlgorithmException, CertificateException
 641     {
 642         permissionCheck();
 643 
 644         // Delete items that do have a keychain item ref.
 645         for (Enumeration&lt;String&gt; e = deletedEntries.keys(); e.hasMoreElements(); ) {
 646             String alias = e.nextElement();
 647             Object entry = deletedEntries.get(alias);
</pre>
<hr />
<pre>
 701 
 702     private long addCertificateToKeychain(String alias, Certificate cert) {
 703         byte[] certblob = null;
 704         long returnValue = 0;
 705 
 706         try {
 707             certblob = cert.getEncoded();
 708             returnValue = _addItemToKeychain(alias, true, certblob, null);
 709         } catch (Exception e) {
 710             e.printStackTrace();
 711         }
 712 
 713         return returnValue;
 714     }
 715 
 716     private native long _addItemToKeychain(String alias, boolean isCertificate, byte[] datablob, char[] password);
 717     private native int _removeItemFromKeychain(long certRef);
 718     private native void _releaseKeychainItemRef(long keychainItemRef);
 719 
 720     /**
<span class="line-modified"> 721       * Loads the keystore from the Keychain.</span>
 722      *
 723      * @param stream Ignored - here for API compatibility.
 724      * @param password Ignored - if user needs to unlock keychain Security
 725      * framework will post any dialogs.
 726      *
 727      * @exception IOException if there is an I/O or format problem with the
 728      * keystore data
 729      * @exception NoSuchAlgorithmException if the algorithm used to check
 730      * the integrity of the keystore cannot be found
 731      * @exception CertificateException if any of the certificates in the
 732      * keystore could not be loaded
 733      */
 734     public void engineLoad(InputStream stream, char[] password)
 735         throws IOException, NoSuchAlgorithmException, CertificateException
 736     {
 737         permissionCheck();
 738 
 739         // Release any stray keychain references before clearing out the entries.
 740         synchronized(entries) {
 741             for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {
</pre>
<hr />
<pre>
 901             X500Principal subjectDN =
 902                 ((X509Certificate)certChain[i+1]).getSubjectX500Principal();
 903             if (!(issuerDN.equals(subjectDN)))
 904                 return false;
 905         }
 906         return true;
 907     }
 908 
 909     private byte[] fetchPrivateKeyFromBag(byte[] privateKeyInfo) throws IOException, NoSuchAlgorithmException, CertificateException
 910     {
 911         byte[] returnValue = null;
 912         DerValue val = new DerValue(new ByteArrayInputStream(privateKeyInfo));
 913         DerInputStream s = val.toDerInputStream();
 914         int version = s.getInteger();
 915 
 916         if (version != 3) {
 917             throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);
 918         }
 919 
 920         /*
<span class="line-modified"> 921             * Read the authSafe.</span>
 922          */
 923         byte[] authSafeData;
 924         ContentInfo authSafe = new ContentInfo(s);
 925         ObjectIdentifier contentType = authSafe.getContentType();
 926 
 927         if (contentType.equals(ContentInfo.DATA_OID)) {
 928             authSafeData = authSafe.getData();
 929         } else /* signed data */ {
 930             throw new IOException(&quot;public key protected PKCS12 not supported&quot;);
 931         }
 932 
 933         DerInputStream as = new DerInputStream(authSafeData);
 934         DerValue[] safeContentsArray = as.getSequence(2);
 935         int count = safeContentsArray.length;
 936 
 937         /*
 938          * Spin over the ContentInfos.
 939          */
 940         for (int i = 0; i &lt; count; i++) {
 941             byte[] safeContentsData;
</pre>
<hr />
<pre>
 986             bagId = sbi.getOID();
 987             bagValue = sbi.getDerValue();
 988             if (!bagValue.isContextSpecific((byte)0)) {
 989                 throw new IOException(&quot;unsupported PKCS12 bag value type &quot;
 990                                       + bagValue.tag);
 991             }
 992             bagValue = bagValue.data.getDerValue();
 993             if (bagId.equals(PKCS8ShroudedKeyBag_OID)) {
 994                 // got what we were looking for.  Return it.
 995                 returnValue = bagValue.toByteArray();
 996             } else {
 997                 // log error message for &quot;unsupported PKCS12 bag type&quot;
 998                 System.out.println(&quot;Unsupported bag type &#39;&quot; + bagId + &quot;&#39;&quot;);
 999             }
1000         }
1001 
1002         return returnValue;
1003     }
1004 
1005     /*
<span class="line-modified">1006         * Generate PBE Algorithm Parameters</span>
1007      */
1008     private AlgorithmParameters getAlgorithmParameters(String algorithm)
1009         throws IOException
1010     {
1011         AlgorithmParameters algParams = null;
1012 
1013         // create PBE parameters from salt and iteration count
1014         PBEParameterSpec paramSpec =
1015             new PBEParameterSpec(getSalt(), iterationCount);
1016         try {
1017             algParams = AlgorithmParameters.getInstance(algorithm);
1018             algParams.init(paramSpec);
1019         } catch (Exception e) {
1020             IOException ioe =
1021             new IOException(&quot;getAlgorithmParameters failed: &quot; +
1022                             e.getMessage());
1023             ioe.initCause(e);
1024             throw ioe;
1025         }
1026         return algParams;
</pre>
</td>
<td>
<hr />
<pre>
 110     }
 111 
 112     private static void permissionCheck() {
 113         SecurityManager sec = System.getSecurityManager();
 114 
 115         if (sec != null) {
 116             sec.checkPermission(new RuntimePermission(&quot;useKeychainStore&quot;));
 117         }
 118     }
 119 
 120 
 121     /**
 122      * Verify the Apple provider in the constructor.
 123      *
 124      * @exception SecurityException if fails to verify
 125      * its own integrity
 126      */
 127     public KeychainStore() { }
 128 
 129     /**
<span class="line-modified"> 130      * Returns the key associated with the given alias, using the given</span>
 131      * password to recover it.
 132      *
 133      * @param alias the alias name
 134      * @param password the password for recovering the key. This password is
 135      *        used internally as the key is exported in a PKCS12 format.
 136      *
 137      * @return the requested key, or null if the given alias does not exist
 138      * or does not identify a &lt;i&gt;key entry&lt;/i&gt;.
 139      *
 140      * @exception NoSuchAlgorithmException if the algorithm for recovering the
 141      * key cannot be found
 142      * @exception UnrecoverableKeyException if the key cannot be recovered
 143      * (e.g., the given password is wrong).
 144      */
 145     public Key engineGetKey(String alias, char[] password)
 146         throws NoSuchAlgorithmException, UnrecoverableKeyException
 147     {
 148         permissionCheck();
 149 
 150         // An empty password is rejected by MacOS API, no private key data
</pre>
<hr />
<pre>
 223             returnValue = kfac.generatePrivate(kspec);
 224         } catch (Exception e) {
 225             UnrecoverableKeyException uke =
 226             new UnrecoverableKeyException(&quot;Get Key failed: &quot; +
 227                                           e.getMessage());
 228             uke.initCause(e);
 229             throw uke;
 230         }
 231 
 232         return returnValue;
 233     }
 234 
 235     private native byte[] _getEncodedKeyData(long secKeyRef, char[] password);
 236 
 237     /**
 238      * Returns the certificate chain associated with the given alias.
 239      *
 240      * @param alias the alias name
 241      *
 242      * @return the certificate chain (ordered with the user&#39;s certificate first
<span class="line-modified"> 243      * and the root certificate authority last), or null if the given alias</span>
 244      * does not exist or does not contain a certificate chain (i.e., the given
<span class="line-modified"> 245      * alias identifies either a &lt;i&gt;trusted certificate entry&lt;/i&gt; or a</span>
<span class="line-modified"> 246      * &lt;i&gt;key entry&lt;/i&gt; without a certificate chain).</span>
 247      */
 248     public Certificate[] engineGetCertificateChain(String alias) {
 249         permissionCheck();
 250 
 251         Object entry = entries.get(alias.toLowerCase());
 252 
 253         if (entry != null &amp;&amp; entry instanceof KeyEntry) {
 254             if (((KeyEntry)entry).chain == null) {
 255                 return null;
 256             } else {
 257                 return ((KeyEntry)entry).chain.clone();
 258             }
 259         } else {
 260             return null;
 261         }
 262     }
 263 
 264     /**
 265      * Returns the certificate associated with the given alias.
 266      *
</pre>
<hr />
<pre>
 280         permissionCheck();
 281 
 282         Object entry = entries.get(alias.toLowerCase());
 283 
 284         if (entry != null) {
 285             if (entry instanceof TrustedCertEntry) {
 286                 return ((TrustedCertEntry)entry).cert;
 287             } else {
 288                 KeyEntry ke = (KeyEntry)entry;
 289                 if (ke.chain == null || ke.chain.length == 0) {
 290                     return null;
 291                 }
 292                 return ke.chain[0];
 293             }
 294         } else {
 295             return null;
 296         }
 297     }
 298 
 299     /**
<span class="line-modified"> 300      * Returns the creation date of the entry identified by the given alias.</span>
 301      *
 302      * @param alias the alias name
 303      *
 304      * @return the creation date of this entry, or null if the given alias does
 305      * not exist
 306      */
 307     public Date engineGetCreationDate(String alias) {
 308         permissionCheck();
 309 
 310         Object entry = entries.get(alias.toLowerCase());
 311 
 312         if (entry != null) {
 313             if (entry instanceof TrustedCertEntry) {
 314                 return new Date(((TrustedCertEntry)entry).date.getTime());
 315             } else {
 316                 return new Date(((KeyEntry)entry).date.getTime());
 317             }
 318         } else {
 319             return null;
 320         }
 321     }
 322 
 323     /**
<span class="line-modified"> 324      * Assigns the given key to the given alias, protecting it with the given</span>
 325      * password.
 326      *
 327      * &lt;p&gt;If the given key is of type &lt;code&gt;java.security.PrivateKey&lt;/code&gt;,
 328      * it must be accompanied by a certificate chain certifying the
 329      * corresponding public key.
 330      *
 331      * &lt;p&gt;If the given alias already exists, the keystore information
 332      * associated with it is overridden by the given key (and possibly
<span class="line-modified"> 333      * certificate chain).</span>
 334      *
 335      * @param alias the alias name
 336      * @param key the key to be associated with the alias
 337      * @param password the password to protect the key
 338      * @param chain the certificate chain for the corresponding public
 339      * key (only required if the given key is of type
<span class="line-modified"> 340      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).</span>
 341      *
 342      * @exception KeyStoreException if the given key cannot be protected, or
 343      * this operation fails for some other reason
 344      */
 345     public void engineSetKeyEntry(String alias, Key key, char[] password,
 346                                   Certificate[] chain)
 347         throws KeyStoreException
 348     {
 349         permissionCheck();
 350 
 351         synchronized(entries) {
 352             try {
 353                 KeyEntry entry = new KeyEntry();
 354                 entry.date = new Date();
 355 
 356                 if (key instanceof PrivateKey) {
 357                     if ((key.getFormat().equals(&quot;PKCS#8&quot;)) ||
 358                         (key.getFormat().equals(&quot;PKCS8&quot;))) {
 359                         entry.protectedPrivKey = encryptPrivateKey(key.getEncoded(), password);
 360                         entry.password = password.clone();
</pre>
<hr />
<pre>
 374                     entry.chain = chain.clone();
 375                     entry.chainRefs = new long[entry.chain.length];
 376                 }
 377 
 378                 String lowerAlias = alias.toLowerCase();
 379                 if (entries.get(lowerAlias) != null) {
 380                     deletedEntries.put(lowerAlias, entries.get(lowerAlias));
 381                 }
 382 
 383                 entries.put(lowerAlias, entry);
 384                 addedEntries.put(lowerAlias, entry);
 385             } catch (Exception nsae) {
 386                 KeyStoreException ke = new KeyStoreException(&quot;Key protection algorithm not found: &quot; + nsae);
 387                 ke.initCause(nsae);
 388                 throw ke;
 389             }
 390         }
 391     }
 392 
 393     /**
<span class="line-modified"> 394      * Assigns the given key (that has already been protected) to the given</span>
 395      * alias.
 396      *
 397      * &lt;p&gt;If the protected key is of type
 398      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;, it must be accompanied by a
 399      * certificate chain certifying the corresponding public key. If the
 400      * underlying keystore implementation is of type &lt;code&gt;jks&lt;/code&gt;,
 401      * &lt;code&gt;key&lt;/code&gt; must be encoded as an
 402      * &lt;code&gt;EncryptedPrivateKeyInfo&lt;/code&gt; as defined in the PKCS #8 standard.
 403      *
 404      * &lt;p&gt;If the given alias already exists, the keystore information
 405      * associated with it is overridden by the given key (and possibly
<span class="line-modified"> 406      * certificate chain).</span>
 407      *
 408      * @param alias the alias name
 409      * @param key the key (in protected format) to be associated with the alias
 410      * @param chain the certificate chain for the corresponding public
 411      * key (only useful if the protected key is of type
<span class="line-modified"> 412      * &lt;code&gt;java.security.PrivateKey&lt;/code&gt;).</span>
 413      *
 414      * @exception KeyStoreException if this operation fails.
 415      */
 416     public void engineSetKeyEntry(String alias, byte[] key,
 417                                   Certificate[] chain)
 418         throws KeyStoreException
 419     {
 420         permissionCheck();
 421 
 422         synchronized(entries) {
 423             // key must be encoded as EncryptedPrivateKeyInfo as defined in
 424             // PKCS#8
 425             KeyEntry entry = new KeyEntry();
 426             try {
 427                 EncryptedPrivateKeyInfo privateKey = new EncryptedPrivateKeyInfo(key);
 428                 entry.protectedPrivKey = privateKey.getEncoded();
 429             } catch (IOException ioe) {
 430                 throw new KeyStoreException(&quot;key is not encoded as &quot;
 431                                             + &quot;EncryptedPrivateKeyInfo&quot;);
 432             }
 433 
 434             entry.date = new Date();
 435 
 436             if ((chain != null) &amp;&amp;
 437                 (chain.length != 0)) {
 438                 entry.chain = chain.clone();
 439                 entry.chainRefs = new long[entry.chain.length];
 440             }
 441 
 442             String lowerAlias = alias.toLowerCase();
 443             if (entries.get(lowerAlias) != null) {
 444                 deletedEntries.put(lowerAlias, entries.get(alias));
 445             }
 446             entries.put(lowerAlias, entry);
 447             addedEntries.put(lowerAlias, entry);
 448         }
 449     }
 450 
 451     /**
<span class="line-modified"> 452      * Assigns the given certificate to the given alias.</span>
 453      *
 454      * &lt;p&gt;If the given alias already exists in this keystore and identifies a
 455      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, the certificate associated with it is
 456      * overridden by the given certificate.
 457      *
 458      * @param alias the alias name
 459      * @param cert the certificate
 460      *
 461      * @exception KeyStoreException if the given alias already exists and does
 462      * not identify a &lt;i&gt;trusted certificate entry&lt;/i&gt;, or this operation
 463      * fails for some other reason.
 464      */
 465     public void engineSetCertificateEntry(String alias, Certificate cert)
 466         throws KeyStoreException
 467     {
 468         permissionCheck();
 469 
 470         synchronized(entries) {
 471 
 472             Object entry = entries.get(alias.toLowerCase());
</pre>
<hr />
<pre>
 484                     TrustedCertEntry tce = (TrustedCertEntry)value;
 485                     if (tce.cert.equals(cert)) {
 486                         throw new KeyStoreException(&quot;Keychain does not support mulitple copies of same certificate.&quot;);
 487                     }
 488                 }
 489             }
 490 
 491             TrustedCertEntry trustedCertEntry = new TrustedCertEntry();
 492             trustedCertEntry.cert = cert;
 493             trustedCertEntry.date = new Date();
 494             String lowerAlias = alias.toLowerCase();
 495             if (entries.get(lowerAlias) != null) {
 496                 deletedEntries.put(lowerAlias, entries.get(lowerAlias));
 497             }
 498             entries.put(lowerAlias, trustedCertEntry);
 499             addedEntries.put(lowerAlias, trustedCertEntry);
 500         }
 501     }
 502 
 503     /**
<span class="line-modified"> 504      * Deletes the entry identified by the given alias from this keystore.</span>
 505      *
 506      * @param alias the alias name
 507      *
 508      * @exception KeyStoreException if the entry cannot be removed.
 509      */
 510     public void engineDeleteEntry(String alias)
 511         throws KeyStoreException
 512     {
 513         permissionCheck();
 514 
 515         synchronized(entries) {
 516             Object entry = entries.remove(alias.toLowerCase());
 517             deletedEntries.put(alias.toLowerCase(), entry);
 518         }
 519     }
 520 
 521     /**
<span class="line-modified"> 522      * Lists all the alias names of this keystore.</span>
 523      *
 524      * @return enumeration of the alias names
 525      */
 526     public Enumeration&lt;String&gt; engineAliases() {
 527         permissionCheck();
 528         return entries.keys();
 529     }
 530 
 531     /**
<span class="line-modified"> 532      * Checks if the given alias exists in this keystore.</span>
 533      *
 534      * @param alias the alias name
 535      *
 536      * @return true if the alias exists, false otherwise
 537      */
 538     public boolean engineContainsAlias(String alias) {
 539         permissionCheck();
 540         return entries.containsKey(alias.toLowerCase());
 541     }
 542 
 543     /**
<span class="line-modified"> 544      * Retrieves the number of entries in this keystore.</span>
 545      *
 546      * @return the number of entries in this keystore
 547      */
 548     public int engineSize() {
 549         permissionCheck();
 550         return entries.size();
 551     }
 552 
 553     /**
<span class="line-modified"> 554      * Returns true if the entry identified by the given alias is a</span>
 555      * &lt;i&gt;key entry&lt;/i&gt;, and false otherwise.
 556      *
 557      * @return true if the entry identified by the given alias is a
 558      * &lt;i&gt;key entry&lt;/i&gt;, false otherwise.
 559      */
 560     public boolean engineIsKeyEntry(String alias) {
 561         permissionCheck();
 562         Object entry = entries.get(alias.toLowerCase());
 563         if ((entry != null) &amp;&amp; (entry instanceof KeyEntry)) {
 564             return true;
 565         } else {
 566             return false;
 567         }
 568     }
 569 
 570     /**
<span class="line-modified"> 571      * Returns true if the entry identified by the given alias is a</span>
 572      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, and false otherwise.
 573      *
 574      * @return true if the entry identified by the given alias is a
 575      * &lt;i&gt;trusted certificate entry&lt;/i&gt;, false otherwise.
 576      */
 577     public boolean engineIsCertificateEntry(String alias) {
 578         permissionCheck();
 579         Object entry = entries.get(alias.toLowerCase());
 580         if ((entry != null) &amp;&amp; (entry instanceof TrustedCertEntry)) {
 581             return true;
 582         } else {
 583             return false;
 584         }
 585     }
 586 
 587     /**
<span class="line-modified"> 588      * Returns the (alias) name of the first keystore entry whose certificate</span>
 589      * matches the given certificate.
 590      *
 591      * &lt;p&gt;This method attempts to match the given certificate with each
 592      * keystore entry. If the entry being considered
 593      * is a &lt;i&gt;trusted certificate entry&lt;/i&gt;, the given certificate is
 594      * compared to that entry&#39;s certificate. If the entry being considered is
 595      * a &lt;i&gt;key entry&lt;/i&gt;, the given certificate is compared to the first
 596      * element of that entry&#39;s certificate chain (if a chain exists).
 597      *
 598      * @param cert the certificate to match with.
 599      *
 600      * @return the (alias) name of the first entry with matching certificate,
 601      * or null if no such entry exists in this keystore.
 602      */
 603     public String engineGetCertificateAlias(Certificate cert) {
 604         permissionCheck();
 605         Certificate certElem;
 606 
 607         for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {
 608             String alias = e.nextElement();
 609             Object entry = entries.get(alias);
 610             if (entry instanceof TrustedCertEntry) {
 611                 certElem = ((TrustedCertEntry)entry).cert;
 612             } else {
 613                 KeyEntry ke = (KeyEntry)entry;
 614                 if (ke.chain == null || ke.chain.length == 0) {
 615                     continue;
 616                 }
 617                 certElem = ke.chain[0];
 618             }
 619             if (certElem.equals(cert)) {
 620                 return alias;
 621             }
 622         }
 623         return null;
 624     }
 625 
 626     /**
<span class="line-modified"> 627      * Stores this keystore to the given output stream, and protects its</span>
 628      * integrity with the given password.
 629      *
 630      * @param stream Ignored. the output stream to which this keystore is written.
 631      * @param password the password to generate the keystore integrity check
 632      *
 633      * @exception IOException if there was an I/O problem with data
 634      * @exception NoSuchAlgorithmException if the appropriate data integrity
 635      * algorithm could not be found
 636      * @exception CertificateException if any of the certificates included in
 637      * the keystore data could not be stored
 638      */
 639     public void engineStore(OutputStream stream, char[] password)
 640         throws IOException, NoSuchAlgorithmException, CertificateException
 641     {
 642         permissionCheck();
 643 
 644         // Delete items that do have a keychain item ref.
 645         for (Enumeration&lt;String&gt; e = deletedEntries.keys(); e.hasMoreElements(); ) {
 646             String alias = e.nextElement();
 647             Object entry = deletedEntries.get(alias);
</pre>
<hr />
<pre>
 701 
 702     private long addCertificateToKeychain(String alias, Certificate cert) {
 703         byte[] certblob = null;
 704         long returnValue = 0;
 705 
 706         try {
 707             certblob = cert.getEncoded();
 708             returnValue = _addItemToKeychain(alias, true, certblob, null);
 709         } catch (Exception e) {
 710             e.printStackTrace();
 711         }
 712 
 713         return returnValue;
 714     }
 715 
 716     private native long _addItemToKeychain(String alias, boolean isCertificate, byte[] datablob, char[] password);
 717     private native int _removeItemFromKeychain(long certRef);
 718     private native void _releaseKeychainItemRef(long keychainItemRef);
 719 
 720     /**
<span class="line-modified"> 721      * Loads the keystore from the Keychain.</span>
 722      *
 723      * @param stream Ignored - here for API compatibility.
 724      * @param password Ignored - if user needs to unlock keychain Security
 725      * framework will post any dialogs.
 726      *
 727      * @exception IOException if there is an I/O or format problem with the
 728      * keystore data
 729      * @exception NoSuchAlgorithmException if the algorithm used to check
 730      * the integrity of the keystore cannot be found
 731      * @exception CertificateException if any of the certificates in the
 732      * keystore could not be loaded
 733      */
 734     public void engineLoad(InputStream stream, char[] password)
 735         throws IOException, NoSuchAlgorithmException, CertificateException
 736     {
 737         permissionCheck();
 738 
 739         // Release any stray keychain references before clearing out the entries.
 740         synchronized(entries) {
 741             for (Enumeration&lt;String&gt; e = entries.keys(); e.hasMoreElements(); ) {
</pre>
<hr />
<pre>
 901             X500Principal subjectDN =
 902                 ((X509Certificate)certChain[i+1]).getSubjectX500Principal();
 903             if (!(issuerDN.equals(subjectDN)))
 904                 return false;
 905         }
 906         return true;
 907     }
 908 
 909     private byte[] fetchPrivateKeyFromBag(byte[] privateKeyInfo) throws IOException, NoSuchAlgorithmException, CertificateException
 910     {
 911         byte[] returnValue = null;
 912         DerValue val = new DerValue(new ByteArrayInputStream(privateKeyInfo));
 913         DerInputStream s = val.toDerInputStream();
 914         int version = s.getInteger();
 915 
 916         if (version != 3) {
 917             throw new IOException(&quot;PKCS12 keystore not in version 3 format&quot;);
 918         }
 919 
 920         /*
<span class="line-modified"> 921          * Read the authSafe.</span>
 922          */
 923         byte[] authSafeData;
 924         ContentInfo authSafe = new ContentInfo(s);
 925         ObjectIdentifier contentType = authSafe.getContentType();
 926 
 927         if (contentType.equals(ContentInfo.DATA_OID)) {
 928             authSafeData = authSafe.getData();
 929         } else /* signed data */ {
 930             throw new IOException(&quot;public key protected PKCS12 not supported&quot;);
 931         }
 932 
 933         DerInputStream as = new DerInputStream(authSafeData);
 934         DerValue[] safeContentsArray = as.getSequence(2);
 935         int count = safeContentsArray.length;
 936 
 937         /*
 938          * Spin over the ContentInfos.
 939          */
 940         for (int i = 0; i &lt; count; i++) {
 941             byte[] safeContentsData;
</pre>
<hr />
<pre>
 986             bagId = sbi.getOID();
 987             bagValue = sbi.getDerValue();
 988             if (!bagValue.isContextSpecific((byte)0)) {
 989                 throw new IOException(&quot;unsupported PKCS12 bag value type &quot;
 990                                       + bagValue.tag);
 991             }
 992             bagValue = bagValue.data.getDerValue();
 993             if (bagId.equals(PKCS8ShroudedKeyBag_OID)) {
 994                 // got what we were looking for.  Return it.
 995                 returnValue = bagValue.toByteArray();
 996             } else {
 997                 // log error message for &quot;unsupported PKCS12 bag type&quot;
 998                 System.out.println(&quot;Unsupported bag type &#39;&quot; + bagId + &quot;&#39;&quot;);
 999             }
1000         }
1001 
1002         return returnValue;
1003     }
1004 
1005     /*
<span class="line-modified">1006      * Generate PBE Algorithm Parameters</span>
1007      */
1008     private AlgorithmParameters getAlgorithmParameters(String algorithm)
1009         throws IOException
1010     {
1011         AlgorithmParameters algParams = null;
1012 
1013         // create PBE parameters from salt and iteration count
1014         PBEParameterSpec paramSpec =
1015             new PBEParameterSpec(getSalt(), iterationCount);
1016         try {
1017             algParams = AlgorithmParameters.getInstance(algorithm);
1018             algParams.init(paramSpec);
1019         } catch (Exception e) {
1020             IOException ioe =
1021             new IOException(&quot;getAlgorithmParameters failed: &quot; +
1022                             e.getMessage());
1023             ioe.initCause(e);
1024             throw ioe;
1025         }
1026         return algParams;
</pre>
</td>
</tr>
</table>
<center><a href="../../../../linux/native/libnio/ch/EPoll.c.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../java/net/DefaultInterface.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
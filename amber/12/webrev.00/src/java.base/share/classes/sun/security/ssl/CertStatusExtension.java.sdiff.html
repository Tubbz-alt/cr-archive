<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="CertSignAlgsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateVerify.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 104      *      enum { ocsp(1), (255) } CertificateStatusType;
 105      *
 106      *      struct {
 107      *          ResponderID responder_id_list&lt;0..2^16-1&gt;;
 108      *          Extensions  request_extensions;
 109      *      } OCSPStatusRequest;
 110      *
 111      *      opaque ResponderID&lt;1..2^16-1&gt;;
 112      *      opaque Extensions&lt;0..2^16-1&gt;;
 113      */
 114     static final class CertStatusRequestSpec implements SSLExtensionSpec {
 115         static final CertStatusRequestSpec DEFAULT =
 116                 new CertStatusRequestSpec(OCSPStatusRequest.EMPTY_OCSP);
 117 
 118         final CertStatusRequest statusRequest;
 119 
 120         private CertStatusRequestSpec(CertStatusRequest statusRequest) {
 121             this.statusRequest = statusRequest;
 122         }
 123 
<span class="line-modified"> 124         private CertStatusRequestSpec(ByteBuffer buffer) throws IOException {</span>

 125             // Is it a empty extension_data?
 126             if (buffer.remaining() == 0) {
 127                 // server response
 128                 this.statusRequest = null;
 129                 return;
 130             }
 131 
 132             if (buffer.remaining() &lt; 1) {
<span class="line-modified"> 133                 throw new SSLProtocolException(</span>
<span class="line-modified"> 134                     &quot;Invalid status_request extension: insufficient data&quot;);</span>

 135             }
 136 
 137             byte statusType = (byte)Record.getInt8(buffer);
 138             byte[] encoded = new byte[buffer.remaining()];
 139             if (encoded.length != 0) {
 140                 buffer.get(encoded);
 141             }
 142             if (statusType == CertStatusRequestType.OCSP.id) {
 143                 this.statusRequest = new OCSPStatusRequest(statusType, encoded);
 144             } else {
 145                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 146                     SSLLogger.info(
 147                         &quot;Unknown certificate status request &quot; +
 148                         &quot;(status type: &quot; + statusType + &quot;)&quot;);
 149                 }
 150 
 151                 this.statusRequest = new CertStatusRequest(statusType, encoded);
 152             }
 153         }
 154 
</pre>
<hr />
<pre>
 161 
 162     /**
 163      * Defines the CertificateStatus response structure as outlined in
 164      * RFC 6066.  This will contain a status response type, plus a single,
 165      * non-empty OCSP response in DER-encoded form.
 166      *
 167      * struct {
 168      *     CertificateStatusType status_type;
 169      *     select (status_type) {
 170      *         case ocsp: OCSPResponse;
 171      *     } response;
 172      * } CertificateStatus;
 173      */
 174     static final class CertStatusResponseSpec implements SSLExtensionSpec {
 175         final CertStatusResponse statusResponse;
 176 
 177         private CertStatusResponseSpec(CertStatusResponse resp) {
 178             this.statusResponse = resp;
 179         }
 180 
<span class="line-modified"> 181         private CertStatusResponseSpec(ByteBuffer buffer) throws IOException {</span>

 182             if (buffer.remaining() &lt; 2) {
<span class="line-modified"> 183                 throw new SSLProtocolException(</span>
<span class="line-modified"> 184                     &quot;Invalid status_request extension: insufficient data&quot;);</span>

 185             }
 186 
 187             // Get the status type (1 byte) and response data (vector)
 188             byte type = (byte)Record.getInt8(buffer);
 189             byte[] respData = Record.getBytes24(buffer);
 190 
 191             // Create the CertStatusResponse based on the type
 192             if (type == CertStatusRequestType.OCSP.id) {
 193                 this.statusResponse = new OCSPStatusResponse(type, respData);
 194             } else {
 195                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 196                     SSLLogger.info(
 197                         &quot;Unknown certificate status response &quot; +
 198                         &quot;(status type: &quot; + type + &quot;)&quot;);
 199                 }
 200 
 201                 this.statusResponse = new CertStatusResponse(type, respData);
 202             }
 203         }
 204 
 205         @Override
 206         public String toString() {
 207             return statusResponse == null ?
 208                         &quot;&lt;empty&gt;&quot; : statusResponse.toString();
 209         }
 210     }
 211 
 212     private static final
 213             class CertStatusRequestStringizer implements SSLStringizer {
 214         @Override
<span class="line-modified"> 215         public String toString(ByteBuffer buffer) {</span>
 216             try {
<span class="line-modified"> 217                 return (new CertStatusRequestSpec(buffer)).toString();</span>
 218             } catch (IOException ioe) {
 219                 // For debug logging only, so please swallow exceptions.
 220                 return ioe.getMessage();
 221             }
 222         }
 223     }
 224 
 225     private static final
 226             class CertStatusRespStringizer implements SSLStringizer {
 227         @Override
<span class="line-modified"> 228         public String toString(ByteBuffer buffer) {</span>
 229             try {
<span class="line-modified"> 230                 return (new CertStatusResponseSpec(buffer)).toString();</span>
 231             } catch (IOException ioe) {
 232                  // For debug logging only, so please swallow exceptions.
 233                 return ioe.getMessage();
 234             }
 235         }
 236     }
 237 
 238     static enum CertStatusRequestType {
 239         OCSP        ((byte)0x01,    &quot;ocsp&quot;),        // RFC 6066/6961
 240         OCSP_MULTI  ((byte)0x02,    &quot;ocsp_multi&quot;);  // RFC 6961
 241 
 242         final byte id;
 243         final String name;
 244 
 245         private CertStatusRequestType(byte id, String name) {
 246             this.id = id;
 247             this.name = name;
 248         }
 249 
 250         /**
</pre>
<hr />
<pre>
 582         private CHCertStatusReqConsumer() {
 583             // blank
 584         }
 585 
 586         @Override
 587         public void consume(ConnectionContext context,
 588             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 589 
 590             // The consuming happens in server side only.
 591             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 592 
 593             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {
 594                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 595                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
 596                         SSLExtension.CH_STATUS_REQUEST.name);
 597                 }
 598                 return;     // ignore the extension
 599             }
 600 
 601             // Parse the extension.
<span class="line-modified"> 602             CertStatusRequestSpec spec;</span>
<span class="line-removed"> 603             try {</span>
<span class="line-removed"> 604                 spec = new CertStatusRequestSpec(buffer);</span>
<span class="line-removed"> 605             } catch (IOException ioe) {</span>
<span class="line-removed"> 606                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed"> 607             }</span>
 608 
 609             // Update the context.
 610             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST, spec);
 611             if (!shc.isResumption &amp;&amp;
 612                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
 613                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 614                     SSLHandshake.CERTIFICATE_STATUS);
 615             }   // Otherwise, the certificate status presents in server cert.
 616 
 617             // No impact on session resumption.
 618         }
 619     }
 620 
 621     /**
 622      * Network data producer of a &quot;status_request&quot; extension in the
 623      * ServerHello handshake message.
 624      */
 625     private static final
 626             class SHCertStatusReqProducer implements HandshakeProducer {
 627         // Prevent instantiation of this class.
</pre>
<hr />
<pre>
 759      *
 760      *      opaque ResponderID&lt;1..2^16-1&gt;;
 761      *      opaque Extensions&lt;0..2^16-1&gt;;
 762      *
 763      *      struct {
 764      *        CertificateStatusRequestItemV2
 765      *                         certificate_status_req_list&lt;1..2^16-1&gt;;
 766      *      } CertificateStatusRequestListV2;
 767      */
 768     static final class CertStatusRequestV2Spec implements SSLExtensionSpec {
 769         static final CertStatusRequestV2Spec DEFAULT =
 770                 new CertStatusRequestV2Spec(new CertStatusRequest[] {
 771                         OCSPStatusRequest.EMPTY_OCSP_MULTI});
 772 
 773         final CertStatusRequest[] certStatusRequests;
 774 
 775         private CertStatusRequestV2Spec(CertStatusRequest[] certStatusRequests) {
 776             this.certStatusRequests = certStatusRequests;
 777         }
 778 
<span class="line-modified"> 779         private CertStatusRequestV2Spec(ByteBuffer message) throws IOException {</span>

 780             // Is it a empty extension_data?
 781             if (message.remaining() == 0) {
 782                 // server response
 783                 this.certStatusRequests = new CertStatusRequest[0];
 784                 return;
 785             }
 786 
 787             if (message.remaining() &lt; 5) {  //  2: certificate_status_req_list
 788                                             // +1: status_type
 789                                             // +2: request_length
<span class="line-modified"> 790                 throw new SSLProtocolException(</span>
<span class="line-modified"> 791                     &quot;Invalid status_request_v2 extension: insufficient data&quot;);</span>

 792             }
 793 
 794             int listLen = Record.getInt16(message);
 795             if (listLen &lt;= 0) {
<span class="line-modified"> 796                 throw new SSLProtocolException(</span>

 797                     &quot;certificate_status_req_list length must be positive &quot; +
<span class="line-modified"> 798                     &quot;(received length: &quot; + listLen + &quot;)&quot;);</span>
 799             }
 800 
 801             int remaining = listLen;
 802             List&lt;CertStatusRequest&gt; statusRequests = new ArrayList&lt;&gt;();
 803             while (remaining &gt; 0) {
 804                 byte statusType = (byte)Record.getInt8(message);
 805                 int requestLen = Record.getInt16(message);
 806 
 807                 if (message.remaining() &lt; requestLen) {
<span class="line-modified"> 808                     throw new SSLProtocolException(</span>


 809                             &quot;Invalid status_request_v2 extension: &quot; +
 810                             &quot;insufficient data (request_length=&quot; + requestLen +
<span class="line-modified"> 811                             &quot;, remining=&quot; + message.remaining() + &quot;)&quot;);</span>
 812                 }
 813 
 814                 byte[] encoded = new byte[requestLen];
 815                 if (encoded.length != 0) {
 816                     message.get(encoded);
 817                 }
 818                 remaining -= 3;     // 1(status type) + 2(request_length) bytes
 819                 remaining -= requestLen;
 820 
 821                 if (statusType == CertStatusRequestType.OCSP.id ||
 822                         statusType == CertStatusRequestType.OCSP_MULTI.id) {
 823                     if (encoded.length &lt; 4) {
 824                                         //  2: length of responder_id_list
 825                                         // +2: length of request_extensions
<span class="line-modified"> 826                         throw new SSLProtocolException(</span>


 827                             &quot;Invalid status_request_v2 extension: &quot; +
<span class="line-modified"> 828                             &quot;insufficient data&quot;);</span>
 829                     }
 830                     statusRequests.add(
 831                             new OCSPStatusRequest(statusType, encoded));
 832                 } else {
 833                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 834                         SSLLogger.info(
 835                                 &quot;Unknown certificate status request &quot; +
 836                                 &quot;(status type: &quot; + statusType + &quot;)&quot;);
 837                     }
 838                     statusRequests.add(
 839                             new CertStatusRequest(statusType, encoded));
 840                 }
 841             }
 842 
 843             certStatusRequests =
 844                     statusRequests.toArray(new CertStatusRequest[0]);
 845         }
 846 
 847         @Override
 848         public String toString() {
</pre>
<hr />
<pre>
 857                 for (CertStatusRequest csr : certStatusRequests) {
 858                     if (isFirst) {
 859                         isFirst = false;
 860                     } else {
 861                         builder.append(&quot;, &quot;);
 862                     }
 863                     Object[] messageFields = {
 864                             Utilities.indent(csr.toString())
 865                         };
 866                     builder.append(messageFormat.format(messageFields));
 867                 }
 868 
 869                 return builder.toString();
 870             }
 871         }
 872     }
 873 
 874     private static final
 875             class CertStatusRequestsStringizer implements SSLStringizer {
 876         @Override
<span class="line-modified"> 877         public String toString(ByteBuffer buffer) {</span>
 878             try {
<span class="line-modified"> 879                 return (new CertStatusRequestV2Spec(buffer)).toString();</span>
 880             } catch (IOException ioe) {
 881                 // For debug logging only, so please swallow exceptions.
 882                 return ioe.getMessage();
 883             }
 884         }
 885     }
 886 
 887     /**
 888      * Network data producer of a &quot;status_request_v2&quot; extension in the
 889      * ClientHello handshake message.
 890      */
 891     private static final
 892             class CHCertStatusReqV2Producer implements HandshakeProducer {
 893         // Prevent instantiation of this class.
 894         private CHCertStatusReqV2Producer() {
 895             // blank
 896         }
 897 
 898         @Override
 899         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
 940             // blank
 941         }
 942 
 943         @Override
 944         public void consume(ConnectionContext context,
 945             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 946 
 947             // The consuming happens in server side only.
 948             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 949 
 950             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {
 951                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 952                     SSLLogger.finest(
 953                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 954                 }
 955 
 956                 return;     // ignore the extension
 957             }
 958 
 959             // Parse the extension.
<span class="line-modified"> 960             CertStatusRequestV2Spec spec;</span>
<span class="line-removed"> 961             try {</span>
<span class="line-removed"> 962                 spec = new CertStatusRequestV2Spec(buffer);</span>
<span class="line-removed"> 963             } catch (IOException ioe) {</span>
<span class="line-removed"> 964                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed"> 965             }</span>
 966 
 967             // Update the context.
 968             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
 969                     spec);
 970             if (!shc.isResumption) {
 971                 shc.handshakeProducers.putIfAbsent(
 972                         SSLHandshake.CERTIFICATE_STATUS.id,
 973                         SSLHandshake.CERTIFICATE_STATUS);
 974             }
 975 
 976             // No impact on session resumption.
 977         }
 978     }
 979 
 980     /**
 981      * Network data producer of a &quot;status_request_v2&quot; extension in the
 982      * ServerHello handshake message.
 983      */
 984     private static final
 985             class SHCertStatusReqV2Producer implements HandshakeProducer {
</pre>
<hr />
<pre>
1168             // Clear the pinned CertificateEntry from the context
1169             shc.currentCertEntry = null;
1170             return producedData;
1171         }
1172     }
1173 
1174     private static final
1175         class CTCertStatusResponseConsumer implements ExtensionConsumer {
1176         // Prevent instantiation of this class.
1177         private CTCertStatusResponseConsumer() {
1178             // blank
1179         }
1180 
1181         @Override
1182         public void consume(ConnectionContext context,
1183                 HandshakeMessage message, ByteBuffer buffer) throws IOException {
1184             // The consumption happens in client side only.
1185             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1186 
1187             // Parse the extension.
<span class="line-modified">1188             CertStatusResponseSpec spec;</span>
<span class="line-removed">1189             try {</span>
<span class="line-removed">1190                 spec = new CertStatusResponseSpec(buffer);</span>
<span class="line-removed">1191             } catch (IOException ioe) {</span>
<span class="line-removed">1192                 throw chc.conContext.fatal(Alert.DECODE_ERROR, ioe);</span>
<span class="line-removed">1193             }</span>
1194 
1195             if (chc.sslContext.isStaplingEnabled(true)) {
1196                 // Activate stapling
1197                 chc.staplingActive = true;
1198             } else {
1199                 // Do no further processing of stapled responses
1200                 return;
1201             }
1202 
1203             // Get response list from the session.  This is unmodifiable
1204             // so we need to create a new list.  Then add this new response
1205             // to the end and submit it back to the session object.
1206             if ((chc.handshakeSession != null) &amp;&amp; (!chc.isResumption)) {
1207                 List&lt;byte[]&gt; respList = new ArrayList&lt;&gt;(
1208                         chc.handshakeSession.getStatusResponses());
1209                 respList.add(spec.statusResponse.encodedResponse);
1210                 chc.handshakeSession.setStatusResponses(respList);
1211             } else {
1212                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1213                     SSLLogger.finest(
</pre>
</td>
<td>
<hr />
<pre>
 104      *      enum { ocsp(1), (255) } CertificateStatusType;
 105      *
 106      *      struct {
 107      *          ResponderID responder_id_list&lt;0..2^16-1&gt;;
 108      *          Extensions  request_extensions;
 109      *      } OCSPStatusRequest;
 110      *
 111      *      opaque ResponderID&lt;1..2^16-1&gt;;
 112      *      opaque Extensions&lt;0..2^16-1&gt;;
 113      */
 114     static final class CertStatusRequestSpec implements SSLExtensionSpec {
 115         static final CertStatusRequestSpec DEFAULT =
 116                 new CertStatusRequestSpec(OCSPStatusRequest.EMPTY_OCSP);
 117 
 118         final CertStatusRequest statusRequest;
 119 
 120         private CertStatusRequestSpec(CertStatusRequest statusRequest) {
 121             this.statusRequest = statusRequest;
 122         }
 123 
<span class="line-modified"> 124         private CertStatusRequestSpec(HandshakeContext hc,</span>
<span class="line-added"> 125                 ByteBuffer buffer) throws IOException {</span>
 126             // Is it a empty extension_data?
 127             if (buffer.remaining() == 0) {
 128                 // server response
 129                 this.statusRequest = null;
 130                 return;
 131             }
 132 
 133             if (buffer.remaining() &lt; 1) {
<span class="line-modified"> 134                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 135                         new SSLProtocolException(</span>
<span class="line-added"> 136                     &quot;Invalid status_request extension: insufficient data&quot;));</span>
 137             }
 138 
 139             byte statusType = (byte)Record.getInt8(buffer);
 140             byte[] encoded = new byte[buffer.remaining()];
 141             if (encoded.length != 0) {
 142                 buffer.get(encoded);
 143             }
 144             if (statusType == CertStatusRequestType.OCSP.id) {
 145                 this.statusRequest = new OCSPStatusRequest(statusType, encoded);
 146             } else {
 147                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 148                     SSLLogger.info(
 149                         &quot;Unknown certificate status request &quot; +
 150                         &quot;(status type: &quot; + statusType + &quot;)&quot;);
 151                 }
 152 
 153                 this.statusRequest = new CertStatusRequest(statusType, encoded);
 154             }
 155         }
 156 
</pre>
<hr />
<pre>
 163 
 164     /**
 165      * Defines the CertificateStatus response structure as outlined in
 166      * RFC 6066.  This will contain a status response type, plus a single,
 167      * non-empty OCSP response in DER-encoded form.
 168      *
 169      * struct {
 170      *     CertificateStatusType status_type;
 171      *     select (status_type) {
 172      *         case ocsp: OCSPResponse;
 173      *     } response;
 174      * } CertificateStatus;
 175      */
 176     static final class CertStatusResponseSpec implements SSLExtensionSpec {
 177         final CertStatusResponse statusResponse;
 178 
 179         private CertStatusResponseSpec(CertStatusResponse resp) {
 180             this.statusResponse = resp;
 181         }
 182 
<span class="line-modified"> 183         private CertStatusResponseSpec(HandshakeContext hc,</span>
<span class="line-added"> 184                 ByteBuffer buffer) throws IOException {</span>
 185             if (buffer.remaining() &lt; 2) {
<span class="line-modified"> 186                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 187                         new SSLProtocolException(</span>
<span class="line-added"> 188                     &quot;Invalid status_request extension: insufficient data&quot;));</span>
 189             }
 190 
 191             // Get the status type (1 byte) and response data (vector)
 192             byte type = (byte)Record.getInt8(buffer);
 193             byte[] respData = Record.getBytes24(buffer);
 194 
 195             // Create the CertStatusResponse based on the type
 196             if (type == CertStatusRequestType.OCSP.id) {
 197                 this.statusResponse = new OCSPStatusResponse(type, respData);
 198             } else {
 199                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 200                     SSLLogger.info(
 201                         &quot;Unknown certificate status response &quot; +
 202                         &quot;(status type: &quot; + type + &quot;)&quot;);
 203                 }
 204 
 205                 this.statusResponse = new CertStatusResponse(type, respData);
 206             }
 207         }
 208 
 209         @Override
 210         public String toString() {
 211             return statusResponse == null ?
 212                         &quot;&lt;empty&gt;&quot; : statusResponse.toString();
 213         }
 214     }
 215 
 216     private static final
 217             class CertStatusRequestStringizer implements SSLStringizer {
 218         @Override
<span class="line-modified"> 219         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
 220             try {
<span class="line-modified"> 221                 return (new CertStatusRequestSpec(hc, buffer)).toString();</span>
 222             } catch (IOException ioe) {
 223                 // For debug logging only, so please swallow exceptions.
 224                 return ioe.getMessage();
 225             }
 226         }
 227     }
 228 
 229     private static final
 230             class CertStatusRespStringizer implements SSLStringizer {
 231         @Override
<span class="line-modified"> 232         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
 233             try {
<span class="line-modified"> 234                 return (new CertStatusResponseSpec(hc, buffer)).toString();</span>
 235             } catch (IOException ioe) {
 236                  // For debug logging only, so please swallow exceptions.
 237                 return ioe.getMessage();
 238             }
 239         }
 240     }
 241 
 242     static enum CertStatusRequestType {
 243         OCSP        ((byte)0x01,    &quot;ocsp&quot;),        // RFC 6066/6961
 244         OCSP_MULTI  ((byte)0x02,    &quot;ocsp_multi&quot;);  // RFC 6961
 245 
 246         final byte id;
 247         final String name;
 248 
 249         private CertStatusRequestType(byte id, String name) {
 250             this.id = id;
 251             this.name = name;
 252         }
 253 
 254         /**
</pre>
<hr />
<pre>
 586         private CHCertStatusReqConsumer() {
 587             // blank
 588         }
 589 
 590         @Override
 591         public void consume(ConnectionContext context,
 592             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 593 
 594             // The consuming happens in server side only.
 595             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 596 
 597             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST)) {
 598                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 599                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
 600                         SSLExtension.CH_STATUS_REQUEST.name);
 601                 }
 602                 return;     // ignore the extension
 603             }
 604 
 605             // Parse the extension.
<span class="line-modified"> 606             CertStatusRequestSpec spec = new CertStatusRequestSpec(shc, buffer);</span>





 607 
 608             // Update the context.
 609             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST, spec);
 610             if (!shc.isResumption &amp;&amp;
 611                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
 612                 shc.handshakeProducers.put(SSLHandshake.CERTIFICATE_STATUS.id,
 613                     SSLHandshake.CERTIFICATE_STATUS);
 614             }   // Otherwise, the certificate status presents in server cert.
 615 
 616             // No impact on session resumption.
 617         }
 618     }
 619 
 620     /**
 621      * Network data producer of a &quot;status_request&quot; extension in the
 622      * ServerHello handshake message.
 623      */
 624     private static final
 625             class SHCertStatusReqProducer implements HandshakeProducer {
 626         // Prevent instantiation of this class.
</pre>
<hr />
<pre>
 758      *
 759      *      opaque ResponderID&lt;1..2^16-1&gt;;
 760      *      opaque Extensions&lt;0..2^16-1&gt;;
 761      *
 762      *      struct {
 763      *        CertificateStatusRequestItemV2
 764      *                         certificate_status_req_list&lt;1..2^16-1&gt;;
 765      *      } CertificateStatusRequestListV2;
 766      */
 767     static final class CertStatusRequestV2Spec implements SSLExtensionSpec {
 768         static final CertStatusRequestV2Spec DEFAULT =
 769                 new CertStatusRequestV2Spec(new CertStatusRequest[] {
 770                         OCSPStatusRequest.EMPTY_OCSP_MULTI});
 771 
 772         final CertStatusRequest[] certStatusRequests;
 773 
 774         private CertStatusRequestV2Spec(CertStatusRequest[] certStatusRequests) {
 775             this.certStatusRequests = certStatusRequests;
 776         }
 777 
<span class="line-modified"> 778         private CertStatusRequestV2Spec(HandshakeContext hc,</span>
<span class="line-added"> 779                 ByteBuffer message) throws IOException {</span>
 780             // Is it a empty extension_data?
 781             if (message.remaining() == 0) {
 782                 // server response
 783                 this.certStatusRequests = new CertStatusRequest[0];
 784                 return;
 785             }
 786 
 787             if (message.remaining() &lt; 5) {  //  2: certificate_status_req_list
 788                                             // +1: status_type
 789                                             // +2: request_length
<span class="line-modified"> 790                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 791                         new SSLProtocolException(</span>
<span class="line-added"> 792                     &quot;Invalid status_request_v2 extension: insufficient data&quot;));</span>
 793             }
 794 
 795             int listLen = Record.getInt16(message);
 796             if (listLen &lt;= 0) {
<span class="line-modified"> 797                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added"> 798                         new SSLProtocolException(</span>
 799                     &quot;certificate_status_req_list length must be positive &quot; +
<span class="line-modified"> 800                     &quot;(received length: &quot; + listLen + &quot;)&quot;));</span>
 801             }
 802 
 803             int remaining = listLen;
 804             List&lt;CertStatusRequest&gt; statusRequests = new ArrayList&lt;&gt;();
 805             while (remaining &gt; 0) {
 806                 byte statusType = (byte)Record.getInt8(message);
 807                 int requestLen = Record.getInt16(message);
 808 
 809                 if (message.remaining() &lt; requestLen) {
<span class="line-modified"> 810                         throw hc.conContext.fatal(</span>
<span class="line-added"> 811                                 Alert.DECODE_ERROR,</span>
<span class="line-added"> 812                                 new SSLProtocolException(</span>
 813                             &quot;Invalid status_request_v2 extension: &quot; +
 814                             &quot;insufficient data (request_length=&quot; + requestLen +
<span class="line-modified"> 815                             &quot;, remining=&quot; + message.remaining() + &quot;)&quot;));</span>
 816                 }
 817 
 818                 byte[] encoded = new byte[requestLen];
 819                 if (encoded.length != 0) {
 820                     message.get(encoded);
 821                 }
 822                 remaining -= 3;     // 1(status type) + 2(request_length) bytes
 823                 remaining -= requestLen;
 824 
 825                 if (statusType == CertStatusRequestType.OCSP.id ||
 826                         statusType == CertStatusRequestType.OCSP_MULTI.id) {
 827                     if (encoded.length &lt; 4) {
 828                                         //  2: length of responder_id_list
 829                                         // +2: length of request_extensions
<span class="line-modified"> 830                         throw hc.conContext.fatal(</span>
<span class="line-added"> 831                                 Alert.DECODE_ERROR,</span>
<span class="line-added"> 832                                 new SSLProtocolException(</span>
 833                             &quot;Invalid status_request_v2 extension: &quot; +
<span class="line-modified"> 834                             &quot;insufficient data&quot;));</span>
 835                     }
 836                     statusRequests.add(
 837                             new OCSPStatusRequest(statusType, encoded));
 838                 } else {
 839                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 840                         SSLLogger.info(
 841                                 &quot;Unknown certificate status request &quot; +
 842                                 &quot;(status type: &quot; + statusType + &quot;)&quot;);
 843                     }
 844                     statusRequests.add(
 845                             new CertStatusRequest(statusType, encoded));
 846                 }
 847             }
 848 
 849             certStatusRequests =
 850                     statusRequests.toArray(new CertStatusRequest[0]);
 851         }
 852 
 853         @Override
 854         public String toString() {
</pre>
<hr />
<pre>
 863                 for (CertStatusRequest csr : certStatusRequests) {
 864                     if (isFirst) {
 865                         isFirst = false;
 866                     } else {
 867                         builder.append(&quot;, &quot;);
 868                     }
 869                     Object[] messageFields = {
 870                             Utilities.indent(csr.toString())
 871                         };
 872                     builder.append(messageFormat.format(messageFields));
 873                 }
 874 
 875                 return builder.toString();
 876             }
 877         }
 878     }
 879 
 880     private static final
 881             class CertStatusRequestsStringizer implements SSLStringizer {
 882         @Override
<span class="line-modified"> 883         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
 884             try {
<span class="line-modified"> 885                 return (new CertStatusRequestV2Spec(hc, buffer)).toString();</span>
 886             } catch (IOException ioe) {
 887                 // For debug logging only, so please swallow exceptions.
 888                 return ioe.getMessage();
 889             }
 890         }
 891     }
 892 
 893     /**
 894      * Network data producer of a &quot;status_request_v2&quot; extension in the
 895      * ClientHello handshake message.
 896      */
 897     private static final
 898             class CHCertStatusReqV2Producer implements HandshakeProducer {
 899         // Prevent instantiation of this class.
 900         private CHCertStatusReqV2Producer() {
 901             // blank
 902         }
 903 
 904         @Override
 905         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
 946             // blank
 947         }
 948 
 949         @Override
 950         public void consume(ConnectionContext context,
 951             HandshakeMessage message, ByteBuffer buffer) throws IOException {
 952 
 953             // The consuming happens in server side only.
 954             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 955 
 956             if (!shc.sslConfig.isAvailable(SSLExtension.CH_STATUS_REQUEST_V2)) {
 957                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 958                     SSLLogger.finest(
 959                         &quot;Ignore unavailable status_request_v2 extension&quot;);
 960                 }
 961 
 962                 return;     // ignore the extension
 963             }
 964 
 965             // Parse the extension.
<span class="line-modified"> 966             CertStatusRequestV2Spec spec = new CertStatusRequestV2Spec(shc, buffer);</span>





 967 
 968             // Update the context.
 969             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
 970                     spec);
 971             if (!shc.isResumption) {
 972                 shc.handshakeProducers.putIfAbsent(
 973                         SSLHandshake.CERTIFICATE_STATUS.id,
 974                         SSLHandshake.CERTIFICATE_STATUS);
 975             }
 976 
 977             // No impact on session resumption.
 978         }
 979     }
 980 
 981     /**
 982      * Network data producer of a &quot;status_request_v2&quot; extension in the
 983      * ServerHello handshake message.
 984      */
 985     private static final
 986             class SHCertStatusReqV2Producer implements HandshakeProducer {
</pre>
<hr />
<pre>
1169             // Clear the pinned CertificateEntry from the context
1170             shc.currentCertEntry = null;
1171             return producedData;
1172         }
1173     }
1174 
1175     private static final
1176         class CTCertStatusResponseConsumer implements ExtensionConsumer {
1177         // Prevent instantiation of this class.
1178         private CTCertStatusResponseConsumer() {
1179             // blank
1180         }
1181 
1182         @Override
1183         public void consume(ConnectionContext context,
1184                 HandshakeMessage message, ByteBuffer buffer) throws IOException {
1185             // The consumption happens in client side only.
1186             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1187 
1188             // Parse the extension.
<span class="line-modified">1189             CertStatusResponseSpec spec = new CertStatusResponseSpec(chc, buffer);</span>





1190 
1191             if (chc.sslContext.isStaplingEnabled(true)) {
1192                 // Activate stapling
1193                 chc.staplingActive = true;
1194             } else {
1195                 // Do no further processing of stapled responses
1196                 return;
1197             }
1198 
1199             // Get response list from the session.  This is unmodifiable
1200             // so we need to create a new list.  Then add this new response
1201             // to the end and submit it back to the session object.
1202             if ((chc.handshakeSession != null) &amp;&amp; (!chc.isResumption)) {
1203                 List&lt;byte[]&gt; respList = new ArrayList&lt;&gt;(
1204                         chc.handshakeSession.getStatusResponses());
1205                 respList.add(spec.statusResponse.encodedResponse);
1206                 chc.handshakeSession.setStatusResponses(respList);
1207             } else {
1208                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake,verbose&quot;)) {
1209                     SSLLogger.finest(
</pre>
</td>
</tr>
</table>
<center><a href="CertSignAlgsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="CertificateVerify.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
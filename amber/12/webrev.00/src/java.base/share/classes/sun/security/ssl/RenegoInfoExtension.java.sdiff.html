<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/RenegoInfoExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="PskKeyExchangeModesExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/RenegoInfoExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 57             new SHRenegotiationInfoAbsence();
 58 
 59     static final SSLStringizer rniStringizer =
 60             new RenegotiationInfoStringizer();
 61 
 62     /**
 63      * The &quot;renegotiation_info&quot; extension.
 64      */
 65     static final class RenegotiationInfoSpec implements SSLExtensionSpec {
 66         // A nominal object that does not holding any real renegotiation info.
 67         static final RenegotiationInfoSpec NOMINAL =
 68                 new RenegotiationInfoSpec(new byte[0]);
 69 
 70         private final byte[] renegotiatedConnection;
 71 
 72         private RenegotiationInfoSpec(byte[] renegotiatedConnection) {
 73             this.renegotiatedConnection = Arrays.copyOf(
 74                     renegotiatedConnection, renegotiatedConnection.length);
 75         }
 76 
<span class="line-modified"> 77         private RenegotiationInfoSpec(ByteBuffer m) throws IOException {</span>

 78             // Parse the extension.
 79             if (!m.hasRemaining() || m.remaining() &lt; 1) {
<span class="line-modified"> 80                 throw new SSLProtocolException(</span>

 81                     &quot;Invalid renegotiation_info extension data: &quot; +
<span class="line-modified"> 82                     &quot;insufficient data&quot;);</span>
 83             }
 84             this.renegotiatedConnection = Record.getBytes8(m);
 85         }
 86 
 87         @Override
 88         public String toString() {
 89             MessageFormat messageFormat = new MessageFormat(
 90                 &quot;\&quot;renegotiated connection\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
 91             if (renegotiatedConnection.length == 0) {
 92                 Object[] messageFields = {
 93                         &quot;&lt;no renegotiated connection&gt;&quot;
 94                     };
 95                 return messageFormat.format(messageFields);
 96             } else {
 97                 Object[] messageFields = {
 98                         Utilities.toHexString(renegotiatedConnection)
 99                     };
100                 return messageFormat.format(messageFields);
101             }
102         }
103     }
104 
105     private static final
106             class RenegotiationInfoStringizer implements SSLStringizer {
107         @Override
<span class="line-modified">108         public String toString(ByteBuffer buffer) {</span>
109             try {
<span class="line-modified">110                 return (new RenegotiationInfoSpec(buffer)).toString();</span>
111             } catch (IOException ioe) {
112                 // For debug logging only, so please swallow exceptions.
113                 return ioe.getMessage();
114             }
115         }
116     }
117 
118     /**
119      * Network data producer of a &quot;renegotiation_info&quot; extension in
120      * the ClientHello handshake message.
121      */
122     private static final
123             class CHRenegotiationInfoProducer implements HandshakeProducer {
124         // Prevent instantiation of this class.
125         private CHRenegotiationInfoProducer() {
126             // blank
127         }
128 
129         @Override
130         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
203             // blank
204         }
205 
206         @Override
207         public void consume(ConnectionContext context,
208             HandshakeMessage message, ByteBuffer buffer) throws IOException {
209 
210             // The consuming happens in server side only.
211             ServerHandshakeContext shc = (ServerHandshakeContext)context;
212 
213             // Is it a supported and enabled extension?
214             if (!shc.sslConfig.isAvailable(CH_RENEGOTIATION_INFO)) {
215                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
216                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
217                             CH_RENEGOTIATION_INFO.name);
218                 }
219                 return;     // ignore the extension
220             }
221 
222             // Parse the extension.
<span class="line-modified">223             RenegotiationInfoSpec spec;</span>
<span class="line-removed">224             try {</span>
<span class="line-removed">225                 spec = new RenegotiationInfoSpec(buffer);</span>
<span class="line-removed">226             } catch (IOException ioe) {</span>
<span class="line-removed">227                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">228             }</span>
<span class="line-removed">229 </span>
230             if (!shc.conContext.isNegotiated) {
231                 // initial handshaking.
232                 if (spec.renegotiatedConnection.length != 0) {
233                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
234                         &quot;Invalid renegotiation_info extension data: not empty&quot;);
235                 }
236                 shc.conContext.secureRenegotiation = true;
237             } else {
238                 if (!shc.conContext.secureRenegotiation) {
239                     // Unexpected RI extension for insecure renegotiation,
240                     // abort the handshake with a fatal handshake_failure alert.
241                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
242                             &quot;The renegotiation_info is present in a insecure &quot; +
243                             &quot;renegotiation&quot;);
244                 } else {
245                     // verify the client_verify_data value
246                     if (!Arrays.equals(shc.conContext.clientVerifyData,
247                             spec.renegotiatedConnection)) {
248                         throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
249                             &quot;Invalid renegotiation_info extension data: &quot; +
</pre>
<hr />
<pre>
416 
417         @Override
418         public void consume(ConnectionContext context,
419             HandshakeMessage message, ByteBuffer buffer) throws IOException {
420             // The producing happens in client side only.
421             ClientHandshakeContext chc = (ClientHandshakeContext)context;
422 
423             // In response to the client renegotiation_info extension request
424             // or SCSV signling, which is mandatory for ClientHello message.
425             RenegotiationInfoSpec requestedSpec = (RenegotiationInfoSpec)
426                     chc.handshakeExtensions.get(CH_RENEGOTIATION_INFO);
427             if (requestedSpec == null &amp;&amp;
428                     !chc.activeCipherSuites.contains(
429                             CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV)) {
430                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
431                     &quot;Missing renegotiation_info and SCSV detected in &quot; +
432                     &quot;ClientHello&quot;);
433             }
434 
435             // Parse the extension.
<span class="line-modified">436             RenegotiationInfoSpec spec;</span>
<span class="line-removed">437             try {</span>
<span class="line-removed">438                 spec = new RenegotiationInfoSpec(buffer);</span>
<span class="line-removed">439             } catch (IOException ioe) {</span>
<span class="line-removed">440                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">441             }</span>
<span class="line-removed">442 </span>
<span class="line-removed">443 </span>
444             if (!chc.conContext.isNegotiated) {     // initial handshake
445                 // If the extension is present, set the secure_renegotiation
446                 // flag to TRUE.  The client MUST then verify that the
447                 // length of the &quot;renegotiated_connection&quot; field is zero,
448                 // and if it is not, MUST abort the handshake (by sending
449                 // a fatal handshake_failure alert). [RFC 5746]
450                 if (spec.renegotiatedConnection.length != 0) {
451                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
452                         &quot;Invalid renegotiation_info in ServerHello: &quot; +
453                         &quot;not empty renegotiated_connection&quot;);
454                 }
455 
456                 chc.conContext.secureRenegotiation = true;
457             } else {        // renegotiation
458                 // The client MUST then verify that the first half of the
459                 // &quot;renegotiated_connection&quot; field is equal to the saved
460                 // client_verify_data value, and the second half is equal to the
461                 // saved server_verify_data value.  If they are not, the client
462                 // MUST abort the handshake. [RFC 5746]
463                 int infoLen = chc.conContext.clientVerifyData.length +
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 57             new SHRenegotiationInfoAbsence();
 58 
 59     static final SSLStringizer rniStringizer =
 60             new RenegotiationInfoStringizer();
 61 
 62     /**
 63      * The &quot;renegotiation_info&quot; extension.
 64      */
 65     static final class RenegotiationInfoSpec implements SSLExtensionSpec {
 66         // A nominal object that does not holding any real renegotiation info.
 67         static final RenegotiationInfoSpec NOMINAL =
 68                 new RenegotiationInfoSpec(new byte[0]);
 69 
 70         private final byte[] renegotiatedConnection;
 71 
 72         private RenegotiationInfoSpec(byte[] renegotiatedConnection) {
 73             this.renegotiatedConnection = Arrays.copyOf(
 74                     renegotiatedConnection, renegotiatedConnection.length);
 75         }
 76 
<span class="line-modified"> 77         private RenegotiationInfoSpec(HandshakeContext hc,</span>
<span class="line-added"> 78                 ByteBuffer m) throws IOException {</span>
 79             // Parse the extension.
 80             if (!m.hasRemaining() || m.remaining() &lt; 1) {
<span class="line-modified"> 81                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added"> 82                         new SSLProtocolException(</span>
 83                     &quot;Invalid renegotiation_info extension data: &quot; +
<span class="line-modified"> 84                     &quot;insufficient data&quot;));</span>
 85             }
 86             this.renegotiatedConnection = Record.getBytes8(m);
 87         }
 88 
 89         @Override
 90         public String toString() {
 91             MessageFormat messageFormat = new MessageFormat(
 92                 &quot;\&quot;renegotiated connection\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
 93             if (renegotiatedConnection.length == 0) {
 94                 Object[] messageFields = {
 95                         &quot;&lt;no renegotiated connection&gt;&quot;
 96                     };
 97                 return messageFormat.format(messageFields);
 98             } else {
 99                 Object[] messageFields = {
100                         Utilities.toHexString(renegotiatedConnection)
101                     };
102                 return messageFormat.format(messageFields);
103             }
104         }
105     }
106 
107     private static final
108             class RenegotiationInfoStringizer implements SSLStringizer {
109         @Override
<span class="line-modified">110         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
111             try {
<span class="line-modified">112                 return (new RenegotiationInfoSpec(hc, buffer)).toString();</span>
113             } catch (IOException ioe) {
114                 // For debug logging only, so please swallow exceptions.
115                 return ioe.getMessage();
116             }
117         }
118     }
119 
120     /**
121      * Network data producer of a &quot;renegotiation_info&quot; extension in
122      * the ClientHello handshake message.
123      */
124     private static final
125             class CHRenegotiationInfoProducer implements HandshakeProducer {
126         // Prevent instantiation of this class.
127         private CHRenegotiationInfoProducer() {
128             // blank
129         }
130 
131         @Override
132         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
205             // blank
206         }
207 
208         @Override
209         public void consume(ConnectionContext context,
210             HandshakeMessage message, ByteBuffer buffer) throws IOException {
211 
212             // The consuming happens in server side only.
213             ServerHandshakeContext shc = (ServerHandshakeContext)context;
214 
215             // Is it a supported and enabled extension?
216             if (!shc.sslConfig.isAvailable(CH_RENEGOTIATION_INFO)) {
217                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
218                     SSLLogger.fine(&quot;Ignore unavailable extension: &quot; +
219                             CH_RENEGOTIATION_INFO.name);
220                 }
221                 return;     // ignore the extension
222             }
223 
224             // Parse the extension.
<span class="line-modified">225             RenegotiationInfoSpec spec = new RenegotiationInfoSpec(shc, buffer);</span>






226             if (!shc.conContext.isNegotiated) {
227                 // initial handshaking.
228                 if (spec.renegotiatedConnection.length != 0) {
229                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
230                         &quot;Invalid renegotiation_info extension data: not empty&quot;);
231                 }
232                 shc.conContext.secureRenegotiation = true;
233             } else {
234                 if (!shc.conContext.secureRenegotiation) {
235                     // Unexpected RI extension for insecure renegotiation,
236                     // abort the handshake with a fatal handshake_failure alert.
237                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
238                             &quot;The renegotiation_info is present in a insecure &quot; +
239                             &quot;renegotiation&quot;);
240                 } else {
241                     // verify the client_verify_data value
242                     if (!Arrays.equals(shc.conContext.clientVerifyData,
243                             spec.renegotiatedConnection)) {
244                         throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
245                             &quot;Invalid renegotiation_info extension data: &quot; +
</pre>
<hr />
<pre>
412 
413         @Override
414         public void consume(ConnectionContext context,
415             HandshakeMessage message, ByteBuffer buffer) throws IOException {
416             // The producing happens in client side only.
417             ClientHandshakeContext chc = (ClientHandshakeContext)context;
418 
419             // In response to the client renegotiation_info extension request
420             // or SCSV signling, which is mandatory for ClientHello message.
421             RenegotiationInfoSpec requestedSpec = (RenegotiationInfoSpec)
422                     chc.handshakeExtensions.get(CH_RENEGOTIATION_INFO);
423             if (requestedSpec == null &amp;&amp;
424                     !chc.activeCipherSuites.contains(
425                             CipherSuite.TLS_EMPTY_RENEGOTIATION_INFO_SCSV)) {
426                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
427                     &quot;Missing renegotiation_info and SCSV detected in &quot; +
428                     &quot;ClientHello&quot;);
429             }
430 
431             // Parse the extension.
<span class="line-modified">432             RenegotiationInfoSpec spec = new RenegotiationInfoSpec(chc, buffer);</span>







433             if (!chc.conContext.isNegotiated) {     // initial handshake
434                 // If the extension is present, set the secure_renegotiation
435                 // flag to TRUE.  The client MUST then verify that the
436                 // length of the &quot;renegotiated_connection&quot; field is zero,
437                 // and if it is not, MUST abort the handshake (by sending
438                 // a fatal handshake_failure alert). [RFC 5746]
439                 if (spec.renegotiatedConnection.length != 0) {
440                     throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
441                         &quot;Invalid renegotiation_info in ServerHello: &quot; +
442                         &quot;not empty renegotiated_connection&quot;);
443                 }
444 
445                 chc.conContext.secureRenegotiation = true;
446             } else {        // renegotiation
447                 // The client MUST then verify that the first half of the
448                 // &quot;renegotiated_connection&quot; field is equal to the saved
449                 // client_verify_data value, and the second half is equal to the
450                 // saved server_verify_data value.  If they are not, the client
451                 // MUST abort the handshake. [RFC 5746]
452                 int infoLen = chc.conContext.clientVerifyData.length +
</pre>
</td>
</tr>
</table>
<center><a href="PskKeyExchangeModesExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SSLExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
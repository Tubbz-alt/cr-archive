<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/sun/security/ssl/ServerHello.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package sun.security.ssl;
  27 
  28 import java.io.IOException;
  29 import java.nio.ByteBuffer;
  30 import java.security.AlgorithmConstraints;
  31 import java.security.CryptoPrimitive;
  32 import java.security.GeneralSecurityException;
  33 import java.text.MessageFormat;
  34 import java.util.Arrays;
  35 import java.util.EnumSet;
  36 import java.util.LinkedList;
  37 import java.util.List;
  38 import java.util.Locale;
  39 import java.util.Map;
  40 import javax.crypto.SecretKey;
  41 import javax.crypto.spec.IvParameterSpec;
  42 import javax.net.ssl.SSLException;
  43 import javax.net.ssl.SSLHandshakeException;
  44 import javax.net.ssl.SSLProtocolException;
  45 import sun.security.ssl.CipherSuite.KeyExchange;
  46 import sun.security.ssl.ClientHello.ClientHelloMessage;
  47 import sun.security.ssl.SSLCipher.SSLReadCipher;
  48 import sun.security.ssl.SSLCipher.SSLWriteCipher;
  49 import sun.security.ssl.SSLHandshake.HandshakeMessage;
  50 import sun.security.ssl.SupportedVersionsExtension.SHSupportedVersionsSpec;
  51 
<a name="1" id="anc1"></a>

  52 /**
  53  * Pack of the ServerHello/HelloRetryRequest handshake message.
  54  */
  55 final class ServerHello {
  56     static final SSLConsumer handshakeConsumer =
  57         new ServerHelloConsumer();
  58     static final HandshakeProducer t12HandshakeProducer =
  59         new T12ServerHelloProducer();
  60     static final HandshakeProducer t13HandshakeProducer =
  61         new T13ServerHelloProducer();
  62     static final HandshakeProducer hrrHandshakeProducer =
  63         new T13HelloRetryRequestProducer();
  64 
  65     static final HandshakeProducer hrrReproducer =
  66         new T13HelloRetryRequestReproducer();
  67 
  68     private static final HandshakeConsumer t12HandshakeConsumer =
  69         new T12ServerHelloConsumer();
  70     private static final HandshakeConsumer t13HandshakeConsumer =
  71         new T13ServerHelloConsumer();
  72 
  73     private static final HandshakeConsumer d12HandshakeConsumer =
  74         new T12ServerHelloConsumer();
  75     private static final HandshakeConsumer d13HandshakeConsumer =
  76         new T13ServerHelloConsumer();
  77 
  78     private static final HandshakeConsumer t13HrrHandshakeConsumer =
  79         new T13HelloRetryRequestConsumer();
  80     private static final HandshakeConsumer d13HrrHandshakeConsumer =
  81         new T13HelloRetryRequestConsumer();
  82 
  83     /**
  84      * The ServerHello handshake message.
  85      */
  86     static final class ServerHelloMessage extends HandshakeMessage {
  87         final ProtocolVersion           serverVersion;      // TLS 1.3 legacy
  88         final RandomCookie              serverRandom;
  89         final SessionId                 sessionId;          // TLS 1.3 legacy
  90         final CipherSuite               cipherSuite;
  91         final byte                      compressionMethod;  // TLS 1.3 legacy
  92         final SSLExtensions             extensions;
  93 
  94         // The HelloRetryRequest producer needs to use the ClientHello message
  95         // for cookie generation.  Please don&#39;t use this field for other
  96         // purpose unless it is really necessary.
  97         final ClientHelloMessage        clientHello;
  98 
  99         // Reserved for HelloRetryRequest consumer.  Please don&#39;t use this
 100         // field for other purpose unless it is really necessary.
 101         final ByteBuffer                handshakeRecord;
 102 
 103         ServerHelloMessage(HandshakeContext context,
 104                 ProtocolVersion serverVersion, SessionId sessionId,
 105                 CipherSuite cipherSuite, RandomCookie serverRandom,
 106                 ClientHelloMessage clientHello) {
 107             super(context);
 108 
 109             this.serverVersion = serverVersion;
 110             this.serverRandom = serverRandom;
 111             this.sessionId = sessionId;
 112             this.cipherSuite = cipherSuite;
 113             this.compressionMethod = 0x00;      // Don&#39;t support compression.
 114             this.extensions = new SSLExtensions(this);
 115 
 116             // Reserve the ClientHello message for cookie generation.
 117             this.clientHello = clientHello;
 118 
 119             // The handshakeRecord field is used for HelloRetryRequest consumer
 120             // only.  It&#39;s fine to set it to null for generating side of the
 121             // ServerHello/HelloRetryRequest message.
 122             this.handshakeRecord = null;
 123         }
 124 
 125         ServerHelloMessage(HandshakeContext context,
 126                 ByteBuffer m) throws IOException {
 127             super(context);
 128 
 129             // Reserve for HelloRetryRequest consumer if needed.
 130             this.handshakeRecord = m.duplicate();
 131 
 132             byte major = m.get();
 133             byte minor = m.get();
 134             this.serverVersion = ProtocolVersion.valueOf(major, minor);
 135             if (this.serverVersion == null) {
 136                 // The client should only request for known protocol versions.
 137                 throw context.conContext.fatal(Alert.PROTOCOL_VERSION,
 138                     &quot;Unsupported protocol version: &quot; +
 139                     ProtocolVersion.nameOf(major, minor));
 140             }
 141 
 142             this.serverRandom = new RandomCookie(m);
 143             this.sessionId = new SessionId(Record.getBytes8(m));
 144             try {
 145                 sessionId.checkLength(serverVersion.id);
 146             } catch (SSLProtocolException ex) {
 147                 throw handshakeContext.conContext.fatal(
 148                         Alert.ILLEGAL_PARAMETER, ex);
 149             }
 150 
 151             int cipherSuiteId = Record.getInt16(m);
 152             this.cipherSuite = CipherSuite.valueOf(cipherSuiteId);
 153             if (cipherSuite == null || !context.isNegotiable(cipherSuite)) {
 154                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 155                     &quot;Server selected improper ciphersuite &quot; +
 156                     CipherSuite.nameOf(cipherSuiteId));
 157             }
 158 
 159             this.compressionMethod = m.get();
 160             if (compressionMethod != 0) {
 161                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 162                     &quot;compression type not supported, &quot; + compressionMethod);
 163             }
 164 
 165             SSLExtension[] supportedExtensions;
 166             if (serverRandom.isHelloRetryRequest()) {
 167                 supportedExtensions = context.sslConfig.getEnabledExtensions(
 168                             SSLHandshake.HELLO_RETRY_REQUEST);
 169             } else {
 170                 supportedExtensions = context.sslConfig.getEnabledExtensions(
 171                             SSLHandshake.SERVER_HELLO);
 172             }
 173 
 174             if (m.hasRemaining()) {
 175                 this.extensions =
 176                     new SSLExtensions(this, m, supportedExtensions);
 177             } else {
 178                 this.extensions = new SSLExtensions(this);
 179             }
 180 
 181             // The clientHello field is used for HelloRetryRequest producer
 182             // only.  It&#39;s fine to set it to null for receiving side of
 183             // ServerHello/HelloRetryRequest message.
 184             this.clientHello = null;        // not used, let it be null;
 185         }
 186 
 187         @Override
 188         public SSLHandshake handshakeType() {
 189             return serverRandom.isHelloRetryRequest() ?
 190                 SSLHandshake.HELLO_RETRY_REQUEST : SSLHandshake.SERVER_HELLO;
 191         }
 192 
 193         @Override
 194         public int messageLength() {
 195             // almost fixed header size, except session ID and extensions:
 196             //      major + minor = 2
 197             //      random = 32
 198             //      session ID len field = 1
 199             //      cipher suite = 2
 200             //      compression = 1
 201             //      extensions: if present, 2 + length of extensions
 202             // In TLS 1.3, use of certain extensions is mandatory.
 203             return 38 + sessionId.length() + extensions.length();
 204         }
 205 
 206         @Override
 207         public void send(HandshakeOutStream hos) throws IOException {
 208             hos.putInt8(serverVersion.major);
 209             hos.putInt8(serverVersion.minor);
 210             hos.write(serverRandom.randomBytes);
 211             hos.putBytes8(sessionId.getId());
 212             hos.putInt8((cipherSuite.id &gt;&gt; 8) &amp; 0xFF);
 213             hos.putInt8(cipherSuite.id &amp; 0xff);
 214             hos.putInt8(compressionMethod);
 215 
 216             extensions.send(hos);           // In TLS 1.3, use of certain
 217                                             // extensions is mandatory.
 218         }
 219 
 220         @Override
 221         public String toString() {
 222             MessageFormat messageFormat = new MessageFormat(
 223                 &quot;\&quot;{0}\&quot;: &#39;{&#39;\n&quot; +
 224                 &quot;  \&quot;server version\&quot;      : \&quot;{1}\&quot;,\n&quot; +
 225                 &quot;  \&quot;random\&quot;              : \&quot;{2}\&quot;,\n&quot; +
 226                 &quot;  \&quot;session id\&quot;          : \&quot;{3}\&quot;,\n&quot; +
 227                 &quot;  \&quot;cipher suite\&quot;        : \&quot;{4}\&quot;,\n&quot; +
 228                 &quot;  \&quot;compression methods\&quot; : \&quot;{5}\&quot;,\n&quot; +
 229                 &quot;  \&quot;extensions\&quot;          : [\n&quot; +
 230                 &quot;{6}\n&quot; +
 231                 &quot;  ]\n&quot; +
 232                 &quot;&#39;}&#39;&quot;,
 233                 Locale.ENGLISH);
 234             Object[] messageFields = {
 235                 serverRandom.isHelloRetryRequest() ?
 236                     &quot;HelloRetryRequest&quot; : &quot;ServerHello&quot;,
 237                 serverVersion.name,
 238                 Utilities.toHexString(serverRandom.randomBytes),
 239                 sessionId.toString(),
 240                 cipherSuite.name + &quot;(&quot; +
 241                         Utilities.byte16HexString(cipherSuite.id) + &quot;)&quot;,
 242                 Utilities.toHexString(compressionMethod),
 243                 Utilities.indent(extensions.toString(), &quot;    &quot;)
 244             };
 245 
 246             return messageFormat.format(messageFields);
 247         }
 248     }
 249 
 250     /**
 251      * The &quot;ServerHello&quot; handshake message producer.
 252      */
 253     private static final class T12ServerHelloProducer
 254             implements HandshakeProducer {
 255 
 256         // Prevent instantiation of this class.
 257         private T12ServerHelloProducer() {
 258             // blank
 259         }
 260 
 261         @Override
 262         public byte[] produce(ConnectionContext context,
 263                 HandshakeMessage message) throws IOException {
 264             // The producing happens in server side only.
 265             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 266             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 267 
 268             // If client hasn&#39;t specified a session we can resume, start a
 269             // new one and choose its cipher suite and compression options,
 270             // unless new session creation is disabled for this connection!
 271             if (!shc.isResumption || shc.resumingSession == null) {
 272                 if (!shc.sslConfig.enableSessionCreation) {
 273                     throw new SSLException(
 274                         &quot;Not resumption, and no new session is allowed&quot;);
 275                 }
 276 
 277                 if (shc.localSupportedSignAlgs == null) {
 278                     shc.localSupportedSignAlgs =
 279                         SignatureScheme.getSupportedAlgorithms(
 280                                 shc.algorithmConstraints, shc.activeProtocols);
 281                 }
 282 
 283                 SSLSessionImpl session =
 284                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 285                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 286                 shc.handshakeSession = session;
 287 
 288                 // consider the handshake extension impact
 289                 SSLExtension[] enabledExtensions =
 290                         shc.sslConfig.getEnabledExtensions(
 291                             SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 292                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 293 
 294                 // negotiate the cipher suite.
 295                 KeyExchangeProperties credentials =
 296                         chooseCipherSuite(shc, clientHello);
 297                 if (credentials == null) {
 298                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 299                             &quot;no cipher suites in common&quot;);
 300                 }
 301                 shc.negotiatedCipherSuite = credentials.cipherSuite;
 302                 shc.handshakeKeyExchange = credentials.keyExchange;
 303                 shc.handshakeSession.setSuite(credentials.cipherSuite);
 304                 shc.handshakePossessions.addAll(
 305                         Arrays.asList(credentials.possessions));
 306                 shc.handshakeHash.determine(
 307                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 308 
 309                 // Check the incoming OCSP stapling extensions and attempt
 310                 // to get responses.  If the resulting stapleParams is non
 311                 // null, it implies that stapling is enabled on the server side.
 312                 shc.stapleParams = StatusResponseManager.processStapling(shc);
 313                 shc.staplingActive = (shc.stapleParams != null);
 314 
 315                 // update the responders
 316                 SSLKeyExchange ke = credentials.keyExchange;
 317                 if (ke != null) {
 318                     for (Map.Entry&lt;Byte, HandshakeProducer&gt; me :
 319                             ke.getHandshakeProducers(shc)) {
 320                         shc.handshakeProducers.put(
 321                                 me.getKey(), me.getValue());
 322                     }
 323                 }
 324 
 325                 if ((ke != null) &amp;&amp;
 326                         (shc.sslConfig.clientAuthType !=
 327                                 ClientAuthType.CLIENT_AUTH_NONE) &amp;&amp;
 328                         !shc.negotiatedCipherSuite.isAnonymous()) {
 329                     for (SSLHandshake hs :
 330                             ke.getRelatedHandshakers(shc)) {
 331                         if (hs == SSLHandshake.CERTIFICATE) {
 332                             shc.handshakeProducers.put(
 333                                     SSLHandshake.CERTIFICATE_REQUEST.id,
 334                                     SSLHandshake.CERTIFICATE_REQUEST);
 335                             break;
 336                         }
 337                     }
 338                 }
 339                 shc.handshakeProducers.put(SSLHandshake.SERVER_HELLO_DONE.id,
 340                         SSLHandshake.SERVER_HELLO_DONE);
 341             } else {
 342                 // stateless and use the client session id (RFC 5077 3.4)
 343                 if (shc.statelessResumption) {
 344                     shc.resumingSession = new SSLSessionImpl(shc.resumingSession,
 345                             (clientHello.sessionId.length() == 0) ?
 346                                     new SessionId(true,
 347                                             shc.sslContext.getSecureRandom()) :
 348                                     new SessionId(clientHello.sessionId.getId())
 349                     );
 350                 }
 351                 shc.handshakeSession = shc.resumingSession;
 352                 shc.negotiatedProtocol =
 353                         shc.resumingSession.getProtocolVersion();
 354                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 355                 shc.handshakeHash.determine(
 356                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 357             }
 358 
 359             // Generate the ServerHello handshake message.
 360             ServerHelloMessage shm = new ServerHelloMessage(shc,
 361                     shc.negotiatedProtocol,
 362                     shc.handshakeSession.getSessionId(),
 363                     shc.negotiatedCipherSuite,
 364                     new RandomCookie(shc),
 365                     clientHello);
 366             shc.serverHelloRandom = shm.serverRandom;
 367 
 368             // Produce extensions for ServerHello handshake message.
 369             SSLExtension[] serverHelloExtensions =
 370                 shc.sslConfig.getEnabledExtensions(
 371                         SSLHandshake.SERVER_HELLO, shc.negotiatedProtocol);
 372             shm.extensions.produce(shc, serverHelloExtensions);
 373             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 374                 SSLLogger.fine(&quot;Produced ServerHello handshake message&quot;, shm);
 375             }
 376 
 377             // Output the handshake message.
 378             shm.write(shc.handshakeOutput);
 379             shc.handshakeOutput.flush();
 380 
 381             if (shc.isResumption &amp;&amp; shc.resumingSession != null) {
 382                 SSLTrafficKeyDerivation kdg =
 383                     SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 384                 if (kdg == null) {
 385                     // unlikely
 386                     throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 387                             &quot;Not supported key derivation: &quot; +
 388                             shc.negotiatedProtocol);
 389                 } else {
 390                     shc.handshakeKeyDerivation = kdg.createKeyDerivation(
 391                             shc, shc.resumingSession.getMasterSecret());
 392                 }
 393 
 394                 // update the responders
 395                 shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 396                         SSLHandshake.FINISHED);
 397             }
 398 
 399             // The handshake message has been delivered.
 400             return null;
 401         }
 402 
 403         private static KeyExchangeProperties chooseCipherSuite(
 404                 ServerHandshakeContext shc,
 405                 ClientHelloMessage clientHello) throws IOException {
 406             List&lt;CipherSuite&gt; preferred;
 407             List&lt;CipherSuite&gt; proposed;
 408             if (shc.sslConfig.preferLocalCipherSuites) {
 409                 preferred = shc.activeCipherSuites;
 410                 proposed = clientHello.cipherSuites;
 411             } else {
 412                 preferred = clientHello.cipherSuites;
 413                 proposed = shc.activeCipherSuites;
 414             }
 415 
 416             List&lt;CipherSuite&gt; legacySuites = new LinkedList&lt;&gt;();
 417             for (CipherSuite cs : preferred) {
 418                 if (!HandshakeContext.isNegotiable(
 419                         proposed, shc.negotiatedProtocol, cs)) {
 420                     continue;
 421                 }
 422 
 423                 if (shc.sslConfig.clientAuthType ==
 424                         ClientAuthType.CLIENT_AUTH_REQUIRED) {
 425                     if ((cs.keyExchange == KeyExchange.K_DH_ANON) ||
 426                         (cs.keyExchange == KeyExchange.K_ECDH_ANON)) {
 427                         continue;
 428                     }
 429                 }
 430 
 431                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 432                         cs.keyExchange, shc.negotiatedProtocol);
 433                 if (ke == null) {
 434                     continue;
 435                 }
 436                 if (!ServerHandshakeContext.legacyAlgorithmConstraints.permits(
 437                         EnumSet.of(CryptoPrimitive.KEY_AGREEMENT), cs.name, null)) {
 438                     legacySuites.add(cs);
 439                     continue;
 440                 }
 441 
 442                 SSLPossession[] hcds = ke.createPossessions(shc);
 443                 if ((hcds == null) || (hcds.length == 0)) {
 444                     continue;
 445                 }
 446 
 447                 // The cipher suite has been negotiated.
 448                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 449                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 450                 }
 451 
 452                 return new KeyExchangeProperties(cs, ke, hcds);
 453             }
 454 
 455             for (CipherSuite cs : legacySuites) {
 456                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
 457                         cs.keyExchange,  shc.negotiatedProtocol);
 458                 if (ke != null) {
 459                     SSLPossession[] hcds = ke.createPossessions(shc);
 460                     if ((hcds != null) &amp;&amp; (hcds.length != 0)) {
 461                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 462                             SSLLogger.warning(
 463                                 &quot;use legacy cipher suite &quot; + cs.name);
 464                         }
 465                         return new KeyExchangeProperties(cs, ke, hcds);
 466                     }
 467                 }
 468             }
 469 
 470             throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 471                     &quot;no cipher suites in common&quot;);
 472         }
 473 
 474         private static final class KeyExchangeProperties {
 475             final CipherSuite cipherSuite;
 476             final SSLKeyExchange keyExchange;
 477             final SSLPossession[] possessions;
 478 
 479             private KeyExchangeProperties(CipherSuite cipherSuite,
 480                     SSLKeyExchange keyExchange, SSLPossession[] possessions) {
 481                 this.cipherSuite = cipherSuite;
 482                 this.keyExchange = keyExchange;
 483                 this.possessions = possessions;
 484             }
 485         }
 486     }
 487 
 488     /**
 489      * The &quot;ServerHello&quot; handshake message producer.
 490      */
 491     private static final
 492             class T13ServerHelloProducer implements HandshakeProducer {
 493         // Prevent instantiation of this class.
 494         private T13ServerHelloProducer() {
 495             // blank
 496         }
 497 
 498         @Override
 499         public byte[] produce(ConnectionContext context,
 500                 HandshakeMessage message) throws IOException {
 501             // The producing happens in server side only.
 502             ServerHandshakeContext shc = (ServerHandshakeContext)context;
 503             ClientHelloMessage clientHello = (ClientHelloMessage)message;
 504 
 505             SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
 506                     shc.sslContext.engineGetServerSessionContext();
 507 
 508             // If client hasn&#39;t specified a session we can resume, start a
 509             // new one and choose its cipher suite and compression options,
 510             // unless new session creation is disabled for this connection!
 511             if (!shc.isResumption || shc.resumingSession == null) {
 512                 if (!shc.sslConfig.enableSessionCreation) {
 513                     throw new SSLException(
 514                         &quot;Not resumption, and no new session is allowed&quot;);
 515                 }
 516 
 517                 if (shc.localSupportedSignAlgs == null) {
 518                     shc.localSupportedSignAlgs =
 519                         SignatureScheme.getSupportedAlgorithms(
 520                                 shc.algorithmConstraints, shc.activeProtocols);
 521                 }
 522 
 523                 SSLSessionImpl session =
 524                         new SSLSessionImpl(shc, CipherSuite.C_NULL);
 525                 session.setMaximumPacketSize(shc.sslConfig.maximumPacketSize);
 526                 shc.handshakeSession = session;
 527 
 528                 // consider the handshake extension impact
 529                 SSLExtension[] enabledExtensions =
 530                         shc.sslConfig.getEnabledExtensions(
 531                             SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 532                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 533 
 534                 // negotiate the cipher suite.
 535                 CipherSuite cipherSuite = chooseCipherSuite(shc, clientHello);
 536                 if (cipherSuite == null) {
 537                     throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 538                             &quot;no cipher suites in common&quot;);
 539                 }
 540                 shc.negotiatedCipherSuite = cipherSuite;
 541                 shc.handshakeSession.setSuite(cipherSuite);
 542                 shc.handshakeHash.determine(
 543                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 544             } else {
 545                 shc.handshakeSession = shc.resumingSession;
 546 
 547                 // consider the handshake extension impact
 548                 SSLExtension[] enabledExtensions =
 549                 shc.sslConfig.getEnabledExtensions(
 550                 SSLHandshake.CLIENT_HELLO, shc.negotiatedProtocol);
 551                 clientHello.extensions.consumeOnTrade(shc, enabledExtensions);
 552 
 553                 shc.negotiatedProtocol =
 554                         shc.resumingSession.getProtocolVersion();
 555                 shc.negotiatedCipherSuite = shc.resumingSession.getSuite();
 556                 shc.handshakeHash.determine(
 557                         shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 558 
 559                 setUpPskKD(shc,
 560                         shc.resumingSession.consumePreSharedKey());
 561 
 562                 // The session can&#39;t be resumed again---remove it from cache
 563                 sessionCache.remove(shc.resumingSession.getSessionId());
 564             }
 565 
 566             // update the responders
 567             shc.handshakeProducers.put(SSLHandshake.ENCRYPTED_EXTENSIONS.id,
 568                     SSLHandshake.ENCRYPTED_EXTENSIONS);
 569             shc.handshakeProducers.put(SSLHandshake.FINISHED.id,
 570                     SSLHandshake.FINISHED);
 571 
 572             // Generate the ServerHello handshake message.
 573             ServerHelloMessage shm = new ServerHelloMessage(shc,
 574                     ProtocolVersion.TLS12,      // use legacy version
 575                     clientHello.sessionId,      // echo back
 576                     shc.negotiatedCipherSuite,
 577                     new RandomCookie(shc),
 578                     clientHello);
 579             shc.serverHelloRandom = shm.serverRandom;
 580 
 581             // Produce extensions for ServerHello handshake message.
 582             SSLExtension[] serverHelloExtensions =
 583                     shc.sslConfig.getEnabledExtensions(
 584                         SSLHandshake.SERVER_HELLO, shc.negotiatedProtocol);
 585             shm.extensions.produce(shc, serverHelloExtensions);
 586             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 587                 SSLLogger.fine(&quot;Produced ServerHello handshake message&quot;, shm);
 588             }
 589 
 590             // Output the handshake message.
 591             shm.write(shc.handshakeOutput);
 592             shc.handshakeOutput.flush();
 593 
 594             // Change client/server handshake traffic secrets.
 595             // Refresh handshake hash
 596             shc.handshakeHash.update();
 597 
 598             // Change client/server handshake traffic secrets.
 599             SSLKeyExchange ke = shc.handshakeKeyExchange;
 600             if (ke == null) {
 601                 // unlikely
 602                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 603                         &quot;Not negotiated key shares&quot;);
 604             }
 605 
 606             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(shc);
 607             SecretKey handshakeSecret = handshakeKD.deriveKey(
 608                     &quot;TlsHandshakeSecret&quot;, null);
 609 
 610             SSLTrafficKeyDerivation kdg =
 611                 SSLTrafficKeyDerivation.valueOf(shc.negotiatedProtocol);
 612             if (kdg == null) {
 613                 // unlikely
 614                 throw shc.conContext.fatal(Alert.INTERNAL_ERROR,
 615                         &quot;Not supported key derivation: &quot; +
 616                         shc.negotiatedProtocol);
 617             }
 618 
 619             SSLKeyDerivation kd =
 620                     new SSLSecretDerivation(shc, handshakeSecret);
 621 
 622             // update the handshake traffic read keys.
 623             SecretKey readSecret = kd.deriveKey(
 624                     &quot;TlsClientHandshakeTrafficSecret&quot;, null);
 625             SSLKeyDerivation readKD =
 626                     kdg.createKeyDerivation(shc, readSecret);
 627             SecretKey readKey = readKD.deriveKey(
 628                     &quot;TlsKey&quot;, null);
 629             SecretKey readIvSecret = readKD.deriveKey(
 630                     &quot;TlsIv&quot;, null);
 631             IvParameterSpec readIv =
 632                     new IvParameterSpec(readIvSecret.getEncoded());
 633             SSLReadCipher readCipher;
 634             try {
 635                 readCipher =
 636                     shc.negotiatedCipherSuite.bulkCipher.createReadCipher(
 637                         Authenticator.valueOf(shc.negotiatedProtocol),
 638                         shc.negotiatedProtocol, readKey, readIv,
 639                         shc.sslContext.getSecureRandom());
 640             } catch (GeneralSecurityException gse) {
 641                 // unlikely
 642                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 643                         &quot;Missing cipher algorithm&quot;, gse);
 644             }
 645 
 646             if (readCipher == null) {
 647                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 648                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 649                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 650                     &quot;)&quot;);
 651             }
 652 
 653             shc.baseReadSecret = readSecret;
 654             shc.conContext.inputRecord.changeReadCiphers(readCipher);
 655 
 656             // update the handshake traffic write secret.
 657             SecretKey writeSecret = kd.deriveKey(
 658                     &quot;TlsServerHandshakeTrafficSecret&quot;, null);
 659             SSLKeyDerivation writeKD =
 660                     kdg.createKeyDerivation(shc, writeSecret);
 661             SecretKey writeKey = writeKD.deriveKey(
 662                     &quot;TlsKey&quot;, null);
 663             SecretKey writeIvSecret = writeKD.deriveKey(
 664                     &quot;TlsIv&quot;, null);
 665             IvParameterSpec writeIv =
 666                     new IvParameterSpec(writeIvSecret.getEncoded());
 667             SSLWriteCipher writeCipher;
 668             try {
 669                 writeCipher =
 670                     shc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
 671                         Authenticator.valueOf(shc.negotiatedProtocol),
 672                         shc.negotiatedProtocol, writeKey, writeIv,
 673                         shc.sslContext.getSecureRandom());
 674             } catch (GeneralSecurityException gse) {
 675                 // unlikely
 676                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 677                         &quot;Missing cipher algorithm&quot;, gse);
 678             }
 679 
 680             if (writeCipher == null) {
 681                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 682                     &quot;Illegal cipher suite (&quot; + shc.negotiatedCipherSuite +
 683                     &quot;) and protocol version (&quot; + shc.negotiatedProtocol +
 684                     &quot;)&quot;);
 685             }
 686 
 687             shc.baseWriteSecret = writeSecret;
 688             shc.conContext.outputRecord.changeWriteCiphers(
 689                     writeCipher, (clientHello.sessionId.length() != 0));
 690 
 691             // Update the context for master key derivation.
 692             shc.handshakeKeyDerivation = kd;
 693 
 694             // Check if the server supports stateless resumption
 695             if (sessionCache.statelessEnabled()) {
 696                 shc.statelessResumption = true;
 697             }
 698 
 699             // The handshake message has been delivered.
 700             return null;
 701         }
 702 
 703         private static CipherSuite chooseCipherSuite(
 704                 ServerHandshakeContext shc,
 705                 ClientHelloMessage clientHello) throws IOException {
 706             List&lt;CipherSuite&gt; preferred;
 707             List&lt;CipherSuite&gt; proposed;
 708             if (shc.sslConfig.preferLocalCipherSuites) {
 709                 preferred = shc.activeCipherSuites;
 710                 proposed = clientHello.cipherSuites;
 711             } else {
 712                 preferred = clientHello.cipherSuites;
 713                 proposed = shc.activeCipherSuites;
 714             }
 715 
 716             CipherSuite legacySuite = null;
 717             AlgorithmConstraints legacyConstraints =
 718                     ServerHandshakeContext.legacyAlgorithmConstraints;
 719             for (CipherSuite cs : preferred) {
 720                 if (!HandshakeContext.isNegotiable(
 721                         proposed, shc.negotiatedProtocol, cs)) {
 722                     continue;
 723                 }
 724 
 725                 if ((legacySuite == null) &amp;&amp;
 726                         !legacyConstraints.permits(
 727                                 EnumSet.of(CryptoPrimitive.KEY_AGREEMENT),
 728                                 cs.name, null)) {
 729                     legacySuite = cs;
 730                     continue;
 731                 }
 732 
 733                 // The cipher suite has been negotiated.
 734                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 735                     SSLLogger.fine(&quot;use cipher suite &quot; + cs.name);
 736                 }
 737                 return cs;
 738             }
 739 
 740             if (legacySuite != null) {
 741                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 742                     SSLLogger.warning(
 743                             &quot;use legacy cipher suite &quot; + legacySuite.name);
 744                 }
 745                 return legacySuite;
 746             }
 747 
 748             // no cipher suites in common
 749             return null;
 750         }
 751     }
 752 
 753     /**
 754      * The &quot;HelloRetryRequest&quot; handshake message producer.
 755      */
 756     private static final
 757             class T13HelloRetryRequestProducer implements HandshakeProducer {
 758         // Prevent instantiation of this class.
 759         private T13HelloRetryRequestProducer() {
 760             // blank
 761         }
 762 
 763         @Override
 764         public byte[] produce(ConnectionContext context,
 765                 HandshakeMessage message) throws IOException {
 766             ServerHandshakeContext shc = (ServerHandshakeContext) context;
 767             ClientHelloMessage clientHello = (ClientHelloMessage) message;
 768 
 769             // negotiate the cipher suite.
 770             CipherSuite cipherSuite =
 771                     T13ServerHelloProducer.chooseCipherSuite(shc, clientHello);
 772             if (cipherSuite == null) {
 773                 throw shc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
 774                         &quot;no cipher suites in common for hello retry request&quot;);
 775             }
 776 
 777             ServerHelloMessage hhrm = new ServerHelloMessage(shc,
 778                     ProtocolVersion.TLS12,      // use legacy version
 779                     clientHello.sessionId,      //  echo back
 780                     cipherSuite,
 781                     RandomCookie.hrrRandom,
 782                     clientHello
 783             );
 784 
 785             shc.negotiatedCipherSuite = cipherSuite;
 786             shc.handshakeHash.determine(
 787                     shc.negotiatedProtocol, shc.negotiatedCipherSuite);
 788 
 789             // Produce extensions for HelloRetryRequest handshake message.
 790             SSLExtension[] serverHelloExtensions =
 791                 shc.sslConfig.getEnabledExtensions(
 792                     SSLHandshake.HELLO_RETRY_REQUEST, shc.negotiatedProtocol);
 793             hhrm.extensions.produce(shc, serverHelloExtensions);
 794             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 795                 SSLLogger.fine(
 796                         &quot;Produced HelloRetryRequest handshake message&quot;, hhrm);
 797             }
 798 
 799             // Output the handshake message.
 800             hhrm.write(shc.handshakeOutput);
 801             shc.handshakeOutput.flush();
 802 
 803             // Stateless, shall we clean up the handshake context as well?
 804             shc.handshakeHash.finish();     // forgot about the handshake hash
 805             shc.handshakeExtensions.clear();
 806 
 807             // What&#39;s the expected response?
 808             shc.handshakeConsumers.put(
 809                     SSLHandshake.CLIENT_HELLO.id, SSLHandshake.CLIENT_HELLO);
 810 
 811             // The handshake message has been delivered.
 812             return null;
 813         }
 814     }
 815 
 816     /**
 817      * The &quot;HelloRetryRequest&quot; handshake message reproducer.
 818      */
 819     private static final
 820             class T13HelloRetryRequestReproducer implements HandshakeProducer {
 821         // Prevent instantiation of this class.
 822         private T13HelloRetryRequestReproducer() {
 823             // blank
 824         }
 825 
 826         @Override
 827         public byte[] produce(ConnectionContext context,
 828                 HandshakeMessage message) throws IOException {
 829             ServerHandshakeContext shc = (ServerHandshakeContext) context;
 830             ClientHelloMessage clientHello = (ClientHelloMessage) message;
 831 
 832             // negotiate the cipher suite.
 833             CipherSuite cipherSuite = shc.negotiatedCipherSuite;
 834             ServerHelloMessage hhrm = new ServerHelloMessage(shc,
 835                     ProtocolVersion.TLS12,      // use legacy version
 836                     clientHello.sessionId,      //  echo back
 837                     cipherSuite,
 838                     RandomCookie.hrrRandom,
 839                     clientHello
 840             );
 841 
 842             // Produce extensions for HelloRetryRequest handshake message.
 843             SSLExtension[] serverHelloExtensions =
 844                 shc.sslConfig.getEnabledExtensions(
 845                     SSLHandshake.MESSAGE_HASH, shc.negotiatedProtocol);
 846             hhrm.extensions.produce(shc, serverHelloExtensions);
 847             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 848                 SSLLogger.fine(
 849                         &quot;Reproduced HelloRetryRequest handshake message&quot;, hhrm);
 850             }
 851 
 852             HandshakeOutStream hos = new HandshakeOutStream(null);
 853             hhrm.write(hos);
 854 
 855             return hos.toByteArray();
 856         }
 857     }
 858 
 859     /**
 860      * The &quot;ServerHello&quot; handshake message consumer.
 861      */
 862     private static final
 863             class ServerHelloConsumer implements SSLConsumer {
 864         // Prevent instantiation of this class.
 865         private ServerHelloConsumer() {
 866             // blank
 867         }
 868 
 869         @Override
 870         public void consume(ConnectionContext context,
 871                 ByteBuffer message) throws IOException {
 872             // The consuming happens in client side only.
 873             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 874 
 875             // clean up this consumer
 876             chc.handshakeConsumers.remove(SSLHandshake.SERVER_HELLO.id);
 877             if (!chc.handshakeConsumers.isEmpty()) {
 878                 // DTLS 1.0/1.2
 879                 chc.handshakeConsumers.remove(
 880                         SSLHandshake.HELLO_VERIFY_REQUEST.id);
 881             }
 882             if (!chc.handshakeConsumers.isEmpty()) {
 883                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
 884                     &quot;No more message expected before ServerHello is processed&quot;);
 885             }
 886 
 887             ServerHelloMessage shm = new ServerHelloMessage(chc, message);
 888             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 889                 SSLLogger.fine(&quot;Consuming ServerHello handshake message&quot;, shm);
 890             }
 891 
 892             if (shm.serverRandom.isHelloRetryRequest()) {
 893                 onHelloRetryRequest(chc, shm);
 894             } else {
 895                 onServerHello(chc, shm);
 896             }
 897         }
 898 
 899         private void onHelloRetryRequest(ClientHandshakeContext chc,
 900                 ServerHelloMessage helloRetryRequest) throws IOException {
 901             // Negotiate protocol version.
 902             //
 903             // Check and launch SupportedVersions.
 904             SSLExtension[] extTypes = new SSLExtension[] {
 905                     SSLExtension.HRR_SUPPORTED_VERSIONS
 906                 };
 907             helloRetryRequest.extensions.consumeOnLoad(chc, extTypes);
 908 
 909             ProtocolVersion serverVersion;
 910             SHSupportedVersionsSpec svs =
 911                     (SHSupportedVersionsSpec)chc.handshakeExtensions.get(
 912                             SSLExtension.HRR_SUPPORTED_VERSIONS);
 913             if (svs != null) {
 914                 serverVersion =            // could be null
 915                         ProtocolVersion.valueOf(svs.selectedVersion);
 916             } else {
 917                 serverVersion = helloRetryRequest.serverVersion;
 918             }
 919 
 920             if (!chc.activeProtocols.contains(serverVersion)) {
 921                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 922                     &quot;The server selected protocol version &quot; + serverVersion +
 923                     &quot; is not accepted by client preferences &quot; +
 924                     chc.activeProtocols);
 925             }
 926 
 927             if (!serverVersion.useTLS13PlusSpec()) {
 928                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 929                     &quot;Unexpected HelloRetryRequest for &quot; + serverVersion.name);
 930             }
 931 
 932             chc.negotiatedProtocol = serverVersion;
 933             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 934                 SSLLogger.fine(
 935                     &quot;Negotiated protocol version: &quot; + serverVersion.name);
 936             }
 937 
 938             // TLS 1.3 key share extension may have produced client
 939             // possessions for TLS 1.3 key exchanges.
 940             //
 941             // Clean up before producing new client key share possessions.
 942             chc.handshakePossessions.clear();
 943 
 944             if (serverVersion.isDTLS) {
 945                 d13HrrHandshakeConsumer.consume(chc, helloRetryRequest);
 946             } else {
 947                 t13HrrHandshakeConsumer.consume(chc, helloRetryRequest);
 948             }
 949         }
 950 
 951         private void onServerHello(ClientHandshakeContext chc,
 952                 ServerHelloMessage serverHello) throws IOException {
 953             // Negotiate protocol version.
 954             //
 955             // Check and launch SupportedVersions.
 956             SSLExtension[] extTypes = new SSLExtension[] {
 957                     SSLExtension.SH_SUPPORTED_VERSIONS
 958                 };
 959             serverHello.extensions.consumeOnLoad(chc, extTypes);
 960 
 961             ProtocolVersion serverVersion;
 962             SHSupportedVersionsSpec svs =
 963                     (SHSupportedVersionsSpec)chc.handshakeExtensions.get(
 964                             SSLExtension.SH_SUPPORTED_VERSIONS);
 965             if (svs != null) {
 966                 serverVersion =            // could be null
 967                         ProtocolVersion.valueOf(svs.selectedVersion);
 968             } else {
 969                 serverVersion = serverHello.serverVersion;
 970             }
 971 
 972             if (!chc.activeProtocols.contains(serverVersion)) {
 973                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
 974                     &quot;The server selected protocol version &quot; + serverVersion +
 975                     &quot; is not accepted by client preferences &quot; +
 976                     chc.activeProtocols);
 977             }
 978 
 979             chc.negotiatedProtocol = serverVersion;
 980             if (!chc.conContext.isNegotiated) {
 981                 chc.conContext.protocolVersion = chc.negotiatedProtocol;
 982                 chc.conContext.outputRecord.setVersion(chc.negotiatedProtocol);
 983             }
 984             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 985                 SSLLogger.fine(
 986                     &quot;Negotiated protocol version: &quot; + serverVersion.name);
 987             }
 988 
 989             if (serverHello.serverRandom.isVersionDowngrade(chc)) {
 990                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
 991                     &quot;A potential protocol version downgrade attack&quot;);
 992             }
 993 
 994             // Consume the handshake message for the specific protocol version.
 995             if (serverVersion.isDTLS) {
 996                 if (serverVersion.useTLS13PlusSpec()) {
 997                     d13HandshakeConsumer.consume(chc, serverHello);
 998                 } else {
 999                     // TLS 1.3 key share extension may have produced client
1000                     // possessions for TLS 1.3 key exchanges.
1001                     chc.handshakePossessions.clear();
1002 
1003                     d12HandshakeConsumer.consume(chc, serverHello);
1004                 }
1005             } else {
1006                 if (serverVersion.useTLS13PlusSpec()) {
1007                     t13HandshakeConsumer.consume(chc, serverHello);
1008                 } else {
1009                     // TLS 1.3 key share extension may have produced client
1010                     // possessions for TLS 1.3 key exchanges.
1011                     chc.handshakePossessions.clear();
1012 
1013                     t12HandshakeConsumer.consume(chc, serverHello);
1014                 }
1015             }
1016         }
1017     }
1018 
1019     private static final
1020             class T12ServerHelloConsumer implements HandshakeConsumer {
1021         // Prevent instantiation of this class.
1022         private T12ServerHelloConsumer() {
1023             // blank
1024         }
1025 
1026         @Override
1027         public void consume(ConnectionContext context,
1028                 HandshakeMessage message) throws IOException {
1029             // The consuming happens in client side only.
1030             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1031             ServerHelloMessage serverHello = (ServerHelloMessage)message;
1032             if (!chc.isNegotiable(serverHello.serverVersion)) {
1033                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1034                     &quot;Server chose &quot; + serverHello.serverVersion +
1035                     &quot;, but that protocol version is not enabled or &quot; +
1036                     &quot;not supported by the client.&quot;);
1037             }
1038 
1039             // chc.negotiatedProtocol = serverHello.serverVersion;
1040             chc.negotiatedCipherSuite = serverHello.cipherSuite;
1041             chc.handshakeHash.determine(
1042                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1043             chc.serverHelloRandom = serverHello.serverRandom;
1044             if (chc.negotiatedCipherSuite.keyExchange == null) {
1045                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1046                     &quot;TLS 1.2 or prior version does not support the &quot; +
1047                     &quot;server cipher suite: &quot; + chc.negotiatedCipherSuite.name);
1048             }
1049 
1050             //
1051             // validate
1052             //
1053 
1054             // Check and launch the &quot;renegotiation_info&quot; extension.
1055             SSLExtension[] extTypes = new SSLExtension[] {
1056                     SSLExtension.SH_RENEGOTIATION_INFO
1057                 };
1058             serverHello.extensions.consumeOnLoad(chc, extTypes);
1059 
1060             // Is it session resuming?
1061             if (chc.resumingSession != null) {
1062                 // we tried to resume, let&#39;s see what the server decided
1063                 if (serverHello.sessionId.equals(
1064                         chc.resumingSession.getSessionId())) {
1065                     // server resumed the session, let&#39;s make sure everything
1066                     // checks out
1067 
1068                     // Verify that the session ciphers are unchanged.
1069                     CipherSuite sessionSuite = chc.resumingSession.getSuite();
1070                     if (chc.negotiatedCipherSuite != sessionSuite) {
1071                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1072                             &quot;Server returned wrong cipher suite for session&quot;);
1073                     }
1074 
1075                     // verify protocol version match
1076                     ProtocolVersion sessionVersion =
1077                             chc.resumingSession.getProtocolVersion();
1078                     if (chc.negotiatedProtocol != sessionVersion) {
1079                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1080                             &quot;Server resumed with wrong protocol version&quot;);
1081                     }
1082 
1083                     // looks fine;  resume it.
1084                     chc.isResumption = true;
1085                     chc.resumingSession.setAsSessionResumption(true);
1086                     chc.handshakeSession = chc.resumingSession;
1087                 } else {
1088                     // we wanted to resume, but the server refused
1089                     //
1090                     // Invalidate the session for initial handshake in case
1091                     // of reusing next time.
1092                     if (chc.resumingSession != null) {
1093                         chc.resumingSession.invalidate();
1094                         chc.resumingSession = null;
1095                     }
1096                     chc.isResumption = false;
1097                     if (!chc.sslConfig.enableSessionCreation) {
1098                         throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1099                             &quot;New session creation is disabled&quot;);
1100                     }
1101                 }
1102             }
1103 
1104             // Check and launch ClientHello extensions.
1105             extTypes = chc.sslConfig.getEnabledExtensions(
1106                     SSLHandshake.SERVER_HELLO);
1107             serverHello.extensions.consumeOnLoad(chc, extTypes);
1108 
1109             if (!chc.isResumption) {
1110                 if (chc.resumingSession != null) {
1111                     // in case the resumption happens next time.
1112                     chc.resumingSession.invalidate();
1113                     chc.resumingSession = null;
1114                 }
1115 
1116                 if (!chc.sslConfig.enableSessionCreation) {
1117                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1118                         &quot;New session creation is disabled&quot;);
1119                 }
1120 
1121                 if (serverHello.sessionId.length() == 0 &amp;&amp;
1122                         chc.statelessResumption) {
1123                     SessionId newId = new SessionId(true,
1124                             chc.sslContext.getSecureRandom());
1125                     chc.handshakeSession = new SSLSessionImpl(chc,
1126                             chc.negotiatedCipherSuite, newId);
1127 
1128                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1129                         SSLLogger.fine(&quot;Locally assigned Session Id: &quot; +
1130                                 newId.toString());
1131                     }
1132                 } else {
1133                     chc.handshakeSession = new SSLSessionImpl(chc,
1134                             chc.negotiatedCipherSuite,
1135                             serverHello.sessionId);
1136                 }
1137                 chc.handshakeSession.setMaximumPacketSize(
1138                         chc.sslConfig.maximumPacketSize);
1139             }
1140 
1141             //
1142             // update
1143             //
1144             serverHello.extensions.consumeOnTrade(chc, extTypes);
1145 
1146             // update the consumers and producers
1147             if (chc.isResumption) {
1148                 SSLTrafficKeyDerivation kdg =
1149                         SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1150                 if (kdg == null) {
1151                     // unlikely
1152                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1153                             &quot;Not supported key derivation: &quot; +
1154                             chc.negotiatedProtocol);
1155                 } else {
1156                     chc.handshakeKeyDerivation = kdg.createKeyDerivation(
1157                             chc, chc.resumingSession.getMasterSecret());
1158                 }
1159 
1160                 if (chc.statelessResumption) {
1161                     chc.handshakeConsumers.putIfAbsent(
1162                             SSLHandshake.NEW_SESSION_TICKET.id,
1163                             SSLHandshake.NEW_SESSION_TICKET);
1164                 }
1165                 chc.conContext.consumers.putIfAbsent(
1166                         ContentType.CHANGE_CIPHER_SPEC.id,
1167                         ChangeCipherSpec.t10Consumer);
1168                 chc.handshakeConsumers.put(
1169                         SSLHandshake.FINISHED.id,
1170                         SSLHandshake.FINISHED);
1171             } else {
1172                 SSLKeyExchange ke = SSLKeyExchange.valueOf(
1173                         chc.negotiatedCipherSuite.keyExchange,
1174                         chc.negotiatedProtocol);
1175                 chc.handshakeKeyExchange = ke;
1176                 if (ke != null) {
1177                     for (SSLHandshake handshake :
1178                             ke.getRelatedHandshakers(chc)) {
1179                         chc.handshakeConsumers.put(handshake.id, handshake);
1180                     }
1181                 }
1182 
1183                 chc.handshakeConsumers.put(SSLHandshake.SERVER_HELLO_DONE.id,
1184                         SSLHandshake.SERVER_HELLO_DONE);
1185             }
1186 
1187             //
1188             // produce
1189             //
1190             // Need no new handshake message producers here.
1191         }
1192     }
1193 
1194     private static void setUpPskKD(HandshakeContext hc,
1195             SecretKey psk) throws SSLHandshakeException {
1196 
1197         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
1198             SSLLogger.fine(&quot;Using PSK to derive early secret&quot;);
1199         }
1200 
1201         try {
1202             CipherSuite.HashAlg hashAlg = hc.negotiatedCipherSuite.hashAlg;
1203             HKDF hkdf = new HKDF(hashAlg.name);
1204             byte[] zeros = new byte[hashAlg.hashLength];
1205             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
1206             hc.handshakeKeyDerivation =
1207                     new SSLSecretDerivation(hc, earlySecret);
1208         } catch  (GeneralSecurityException gse) {
1209             throw (SSLHandshakeException) new SSLHandshakeException(
1210                 &quot;Could not generate secret&quot;).initCause(gse);
1211         }
1212     }
1213 
1214     private static final
1215             class T13ServerHelloConsumer implements HandshakeConsumer {
1216         // Prevent instantiation of this class.
1217         private T13ServerHelloConsumer() {
1218             // blank
1219         }
1220 
1221         @Override
1222         public void consume(ConnectionContext context,
1223                 HandshakeMessage message) throws IOException {
1224             // The consuming happens in client side only.
1225             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1226             ServerHelloMessage serverHello = (ServerHelloMessage)message;
1227             if (serverHello.serverVersion != ProtocolVersion.TLS12) {
1228                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1229                     &quot;The ServerHello.legacy_version field is not TLS 1.2&quot;);
1230             }
1231 
1232             chc.negotiatedCipherSuite = serverHello.cipherSuite;
1233             chc.handshakeHash.determine(
1234                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1235             chc.serverHelloRandom = serverHello.serverRandom;
1236 
1237             //
1238             // validate
1239             //
1240 
1241             // Check and launch ServerHello extensions.
1242             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
1243                     SSLHandshake.SERVER_HELLO);
1244             serverHello.extensions.consumeOnLoad(chc, extTypes);
1245             if (!chc.isResumption) {
1246                 if (chc.resumingSession != null) {
1247                     // in case the resumption happens next time.
1248                     chc.resumingSession.invalidate();
1249                     chc.resumingSession = null;
1250                 }
1251 
1252                 if (!chc.sslConfig.enableSessionCreation) {
1253                     throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1254                         &quot;New session creation is disabled&quot;);
1255                 }
1256                 chc.handshakeSession = new SSLSessionImpl(chc,
1257                         chc.negotiatedCipherSuite,
1258                         serverHello.sessionId);
1259                 chc.handshakeSession.setMaximumPacketSize(
1260                         chc.sslConfig.maximumPacketSize);
1261             } else {
1262                 // The PSK is consumed to allow it to be deleted
1263                 SecretKey psk =
1264                         chc.resumingSession.consumePreSharedKey();
1265                 if(psk == null) {
1266                     throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1267                     &quot;No PSK available. Unable to resume.&quot;);
1268                 }
1269 
1270                 chc.handshakeSession = chc.resumingSession;
1271 
1272                 setUpPskKD(chc, psk);
1273             }
1274 
1275             //
1276             // update
1277             //
1278             serverHello.extensions.consumeOnTrade(chc, extTypes);
1279 
1280             // Change client/server handshake traffic secrets.
1281             // Refresh handshake hash
1282             chc.handshakeHash.update();
1283 
1284             SSLKeyExchange ke = chc.handshakeKeyExchange;
1285             if (ke == null) {
1286                 // unlikely
1287                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1288                         &quot;Not negotiated key shares&quot;);
1289             }
1290 
1291             SSLKeyDerivation handshakeKD = ke.createKeyDerivation(chc);
1292             SecretKey handshakeSecret = handshakeKD.deriveKey(
1293                     &quot;TlsHandshakeSecret&quot;, null);
1294             SSLTrafficKeyDerivation kdg =
1295                 SSLTrafficKeyDerivation.valueOf(chc.negotiatedProtocol);
1296             if (kdg == null) {
1297                 // unlikely
1298                 throw chc.conContext.fatal(Alert.INTERNAL_ERROR,
1299                         &quot;Not supported key derivation: &quot; +
1300                         chc.negotiatedProtocol);
1301             }
1302 
1303             SSLKeyDerivation secretKD =
1304                     new SSLSecretDerivation(chc, handshakeSecret);
1305 
1306             // update the handshake traffic read keys.
1307             SecretKey readSecret = secretKD.deriveKey(
1308                     &quot;TlsServerHandshakeTrafficSecret&quot;, null);
1309 
1310             SSLKeyDerivation readKD =
1311                     kdg.createKeyDerivation(chc, readSecret);
1312             SecretKey readKey = readKD.deriveKey(
1313                     &quot;TlsKey&quot;, null);
1314             SecretKey readIvSecret = readKD.deriveKey(
1315                     &quot;TlsIv&quot;, null);
1316             IvParameterSpec readIv =
1317                     new IvParameterSpec(readIvSecret.getEncoded());
1318             SSLReadCipher readCipher;
1319             try {
1320                 readCipher =
1321                     chc.negotiatedCipherSuite.bulkCipher.createReadCipher(
1322                         Authenticator.valueOf(chc.negotiatedProtocol),
1323                         chc.negotiatedProtocol, readKey, readIv,
1324                         chc.sslContext.getSecureRandom());
1325             } catch (GeneralSecurityException gse) {
1326                 // unlikely
1327                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1328                         &quot;Missing cipher algorithm&quot;, gse);
1329             }
1330 
1331             if (readCipher == null) {
1332                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1333                     &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1334                     &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1335                     &quot;)&quot;);
1336             }
1337 
1338             chc.baseReadSecret = readSecret;
1339             chc.conContext.inputRecord.changeReadCiphers(readCipher);
1340 
1341             // update the handshake traffic write keys.
1342             SecretKey writeSecret = secretKD.deriveKey(
1343                     &quot;TlsClientHandshakeTrafficSecret&quot;, null);
1344             SSLKeyDerivation writeKD =
1345                     kdg.createKeyDerivation(chc, writeSecret);
1346             SecretKey writeKey = writeKD.deriveKey(
1347                     &quot;TlsKey&quot;, null);
1348             SecretKey writeIvSecret = writeKD.deriveKey(
1349                     &quot;TlsIv&quot;, null);
1350             IvParameterSpec writeIv =
1351                     new IvParameterSpec(writeIvSecret.getEncoded());
1352             SSLWriteCipher writeCipher;
1353             try {
1354                 writeCipher =
1355                     chc.negotiatedCipherSuite.bulkCipher.createWriteCipher(
1356                         Authenticator.valueOf(chc.negotiatedProtocol),
1357                         chc.negotiatedProtocol, writeKey, writeIv,
1358                         chc.sslContext.getSecureRandom());
1359             } catch (GeneralSecurityException gse) {
1360                 // unlikely
1361                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1362                         &quot;Missing cipher algorithm&quot;, gse);
1363             }
1364 
1365             if (writeCipher == null) {
1366                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
1367                     &quot;Illegal cipher suite (&quot; + chc.negotiatedCipherSuite +
1368                     &quot;) and protocol version (&quot; + chc.negotiatedProtocol +
1369                     &quot;)&quot;);
1370             }
1371 
1372             chc.baseWriteSecret = writeSecret;
1373             chc.conContext.outputRecord.changeWriteCiphers(
1374                     writeCipher, (serverHello.sessionId.length() != 0));
1375 
1376             // Should use resumption_master_secret for TLS 1.3.
1377             // chc.handshakeSession.setMasterSecret(masterSecret);
1378 
1379             // Update the context for master key derivation.
1380             chc.handshakeKeyDerivation = secretKD;
1381 
1382             // update the consumers and producers
1383             //
1384             // The server sends a dummy change_cipher_spec record immediately
1385             // after its first handshake message.  This may either be after a
1386             // ServerHello or a HelloRetryRequest.
1387             chc.conContext.consumers.putIfAbsent(
1388                     ContentType.CHANGE_CIPHER_SPEC.id,
1389                     ChangeCipherSpec.t13Consumer);
1390 
1391             chc.handshakeConsumers.put(
1392                     SSLHandshake.ENCRYPTED_EXTENSIONS.id,
1393                     SSLHandshake.ENCRYPTED_EXTENSIONS);
1394 
1395             // Support cert authentication only, when not PSK.
1396             chc.handshakeConsumers.put(
1397                     SSLHandshake.CERTIFICATE_REQUEST.id,
1398                     SSLHandshake.CERTIFICATE_REQUEST);
1399             chc.handshakeConsumers.put(
1400                     SSLHandshake.CERTIFICATE.id,
1401                     SSLHandshake.CERTIFICATE);
1402             chc.handshakeConsumers.put(
1403                     SSLHandshake.CERTIFICATE_VERIFY.id,
1404                     SSLHandshake.CERTIFICATE_VERIFY);
1405 
1406             chc.handshakeConsumers.put(
1407                     SSLHandshake.FINISHED.id,
1408                     SSLHandshake.FINISHED);
1409 
1410             //
1411             // produce
1412             //
1413             // Need no new handshake message producers here.
1414         }
1415     }
1416 
1417     private static final
1418             class T13HelloRetryRequestConsumer implements HandshakeConsumer {
1419         // Prevent instantiation of this class.
1420         private T13HelloRetryRequestConsumer() {
1421             // blank
1422         }
1423 
1424         @Override
1425         public void consume(ConnectionContext context,
1426                 HandshakeMessage message) throws IOException {
1427             // The consuming happens in client side only.
1428             ClientHandshakeContext chc = (ClientHandshakeContext)context;
1429             ServerHelloMessage helloRetryRequest = (ServerHelloMessage)message;
1430             if (helloRetryRequest.serverVersion != ProtocolVersion.TLS12) {
1431                 throw chc.conContext.fatal(Alert.PROTOCOL_VERSION,
1432                     &quot;The HelloRetryRequest.legacy_version is not TLS 1.2&quot;);
1433             }
1434 
1435             chc.negotiatedCipherSuite = helloRetryRequest.cipherSuite;
1436 
1437             //
1438             // validate
1439             //
1440 
1441             // Check and launch ClientHello extensions.
1442             SSLExtension[] extTypes = chc.sslConfig.getEnabledExtensions(
1443                     SSLHandshake.HELLO_RETRY_REQUEST);
1444             helloRetryRequest.extensions.consumeOnLoad(chc, extTypes);
1445 
1446             //
1447             // update
1448             //
1449             helloRetryRequest.extensions.consumeOnTrade(chc, extTypes);
1450 
1451             // Change client/server handshake traffic secrets.
1452             // Refresh handshake hash
1453             chc.handshakeHash.finish();     // reset the handshake hash
1454 
1455             // calculate the transcript hash of the 1st ClientHello message
1456             HandshakeOutStream hos = new HandshakeOutStream(null);
1457             try {
1458                 chc.initialClientHelloMsg.write(hos);
1459             } catch (IOException ioe) {
1460                 // unlikely
1461                 throw chc.conContext.fatal(Alert.HANDSHAKE_FAILURE,
1462                     &quot;Failed to construct message hash&quot;, ioe);
1463             }
1464             chc.handshakeHash.deliver(hos.toByteArray());
1465             chc.handshakeHash.determine(
1466                     chc.negotiatedProtocol, chc.negotiatedCipherSuite);
1467             byte[] clientHelloHash = chc.handshakeHash.digest();
1468 
1469             // calculate the message_hash
1470             //
1471             // Transcript-Hash(ClientHello1, HelloRetryRequest, ... Mn) =
1472             //   Hash(message_hash ||    /* Handshake type */
1473             //     00 00 Hash.length ||  /* Handshake message length (bytes) */
1474             //     Hash(ClientHello1) || /* Hash of ClientHello1 */
1475             //     HelloRetryRequest || ... || Mn)
1476             int hashLen = chc.negotiatedCipherSuite.hashAlg.hashLength;
1477             byte[] hashedClientHello = new byte[4 + hashLen];
1478             hashedClientHello[0] = SSLHandshake.MESSAGE_HASH.id;
1479             hashedClientHello[1] = (byte)0x00;
1480             hashedClientHello[2] = (byte)0x00;
1481             hashedClientHello[3] = (byte)(hashLen &amp; 0xFF);
1482             System.arraycopy(clientHelloHash, 0,
1483                     hashedClientHello, 4, hashLen);
1484 
1485             chc.handshakeHash.finish();     // reset the handshake hash
1486             chc.handshakeHash.deliver(hashedClientHello);
1487 
1488             int hrrBodyLen = helloRetryRequest.handshakeRecord.remaining();
1489             byte[] hrrMessage = new byte[4 + hrrBodyLen];
1490             hrrMessage[0] = SSLHandshake.HELLO_RETRY_REQUEST.id;
1491             hrrMessage[1] = (byte)((hrrBodyLen &gt;&gt; 16) &amp; 0xFF);
1492             hrrMessage[2] = (byte)((hrrBodyLen &gt;&gt; 8) &amp; 0xFF);
1493             hrrMessage[3] = (byte)(hrrBodyLen &amp; 0xFF);
1494 
1495             ByteBuffer hrrBody = helloRetryRequest.handshakeRecord.duplicate();
1496             hrrBody.get(hrrMessage, 4, hrrBodyLen);
1497 
1498             chc.handshakeHash.receive(hrrMessage);
1499 
1500             // Update the initial ClientHello handshake message.
1501             chc.initialClientHelloMsg.extensions.reproduce(chc,
1502                     new SSLExtension[] {
1503                         SSLExtension.CH_COOKIE,
1504                         SSLExtension.CH_KEY_SHARE,
1505                         SSLExtension.CH_PRE_SHARED_KEY
1506                     });
1507 
1508             //
1509             // produce response handshake message
1510             //
1511             SSLHandshake.CLIENT_HELLO.produce(context, helloRetryRequest);
1512         }
1513     }
1514 }
<a name="2" id="anc2"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="2" type="hidden" />
</body>
</html>
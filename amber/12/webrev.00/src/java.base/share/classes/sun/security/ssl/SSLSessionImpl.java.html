<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/sun/security/ssl/SSLSessionImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package sun.security.ssl;
  26 
  27 import sun.security.x509.X509CertImpl;
  28 
  29 import java.io.IOException;
  30 import java.lang.reflect.Array;
  31 import java.math.BigInteger;
  32 import java.net.InetAddress;
  33 import java.nio.ByteBuffer;
  34 import java.security.Principal;
  35 import java.security.PrivateKey;
  36 import java.security.cert.CertificateEncodingException;
  37 import java.security.cert.X509Certificate;
  38 import java.util.ArrayList;
  39 import java.util.Arrays;
  40 import java.util.Queue;
  41 import java.util.Collection;
  42 import java.util.Collections;
  43 import java.util.Enumeration;
  44 import java.util.List;
  45 import java.util.concurrent.ConcurrentHashMap;
  46 import java.util.concurrent.ConcurrentLinkedQueue;
  47 import java.util.concurrent.locks.ReentrantLock;
  48 import javax.crypto.SecretKey;
  49 import javax.crypto.spec.SecretKeySpec;
  50 import javax.net.ssl.ExtendedSSLSession;
  51 import javax.net.ssl.SNIHostName;
  52 import javax.net.ssl.SNIServerName;
  53 import javax.net.ssl.SSLException;
  54 import javax.net.ssl.SSLPeerUnverifiedException;
  55 import javax.net.ssl.SSLPermission;
  56 import javax.net.ssl.SSLSessionBindingEvent;
  57 import javax.net.ssl.SSLSessionBindingListener;
  58 import javax.net.ssl.SSLSessionContext;
  59 
  60 /**
  61  * Implements the SSL session interface, and exposes the session context
  62  * which is maintained by SSL servers.
  63  *
  64  * &lt;P&gt; Servers have the ability to manage the sessions associated with
  65  * their authentication context(s).  They can do this by enumerating the
  66  * IDs of the sessions which are cached, examining those sessions, and then
  67  * perhaps invalidating a given session so that it can&#39;t be used again.
  68  * If servers do not explicitly manage the cache, sessions will linger
  69  * until memory is low enough that the runtime environment purges cache
  70  * entries automatically to reclaim space.
  71  *
  72  * &lt;P&gt;&lt;em&gt; The only reason this class is not package-private is that
  73  * there&#39;s no other public way to get at the server session context which
  74  * is associated with any given authentication context. &lt;/em&gt;
  75  *
  76  * @author David Brownell
  77  */
  78 final class SSLSessionImpl extends ExtendedSSLSession {
  79 
  80     /*
  81      * we only really need a single null session
  82      */
  83     static final SSLSessionImpl         nullSession = new SSLSessionImpl();
  84 
  85     /*
  86      * The state of a single session, as described in section 7.1
  87      * of the SSLv3 spec.
  88      */
  89     private final ProtocolVersion       protocolVersion;
  90     private final SessionId             sessionId;
  91     private X509Certificate[]   peerCerts;
  92     private CipherSuite         cipherSuite;
  93     private SecretKey           masterSecret;
  94     final boolean               useExtendedMasterSecret;
  95 
  96     /*
  97      * Information not part of the SSLv3 protocol spec, but used
  98      * to support session management policies.
  99      */
 100     private final long          creationTime;
 101     private long                lastUsedTime = 0;
 102     private final String        host;
 103     private final int           port;
 104     private SSLSessionContextImpl       context;
 105     private boolean             invalidated;
 106     private X509Certificate[]   localCerts;
 107     private PrivateKey          localPrivateKey;
 108     private final Collection&lt;SignatureScheme&gt;     localSupportedSignAlgs;
 109     private Collection&lt;SignatureScheme&gt; peerSupportedSignAlgs; //for certificate
 110     private boolean             useDefaultPeerSignAlgs = false;
 111     private List&lt;byte[]&gt;        statusResponses;
 112     private SecretKey           resumptionMasterSecret;
 113     private SecretKey           preSharedKey;
 114     private byte[]              pskIdentity;
 115     private final long          ticketCreationTime = System.currentTimeMillis();
 116     private int                 ticketAgeAdd;
 117 
 118     private int                 negotiatedMaxFragLen = -1;
 119     private int                 maximumPacketSize;
 120 
 121     private final Queue&lt;SSLSessionImpl&gt; childSessions =
 122                                         new ConcurrentLinkedQueue&lt;&gt;();
 123 
 124     /*
 125      * Is the session currently re-established with a session-resumption
 126      * abbreviated initial handshake?
 127      *
 128      * Note that currently we only set this variable in client side.
 129      */
 130     private boolean isSessionResumption = false;
 131 
 132     /*
 133      * Use of session caches is globally enabled/disabled.
 134      */
 135     private static boolean      defaultRejoinable = true;
 136 
 137     // server name indication
 138     final SNIServerName         serverNameIndication;
 139     private final List&lt;SNIServerName&gt;    requestedServerNames;
 140 
 141     // Counter used to create unique nonces in NewSessionTicket
 142     private BigInteger ticketNonceCounter = BigInteger.ONE;
 143 
 144     // The endpoint identification algorithm used to check certificates
 145     // in this session.
 146     private final String        identificationProtocol;
 147 
 148     private final ReentrantLock sessionLock = new ReentrantLock();
 149 
 150     /*
 151      * Create a new non-rejoinable session, using the default (null)
 152      * cipher spec.  This constructor returns a session which could
 153      * be used either by a client or by a server, as a connection is
 154      * first opened and before handshaking begins.
 155      */
 156     private SSLSessionImpl() {
 157         this.protocolVersion = ProtocolVersion.NONE;
 158         this.cipherSuite = CipherSuite.C_NULL;
 159         this.sessionId = new SessionId(false, null);
 160         this.host = null;
 161         this.port = -1;
 162         this.localSupportedSignAlgs = Collections.emptySet();
 163         this.serverNameIndication = null;
 164         this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 165         this.useExtendedMasterSecret = false;
 166         this.creationTime = System.currentTimeMillis();
 167         this.identificationProtocol = null;
 168         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 169     }
 170 
 171     /*
 172      * Create a new session, using a given cipher spec.  This will
 173      * be rejoinable if session caching is enabled; the constructor
 174      * is intended mostly for use by serves.
 175      */
 176     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite) {
 177         this(hc, cipherSuite,
 178             new SessionId(defaultRejoinable, hc.sslContext.getSecureRandom()));
 179     }
 180 
 181     /*
 182      * Record a new session, using a given cipher spec and session ID.
 183      */
 184     SSLSessionImpl(HandshakeContext hc, CipherSuite cipherSuite, SessionId id) {
 185         this(hc, cipherSuite, id, System.currentTimeMillis());
 186     }
 187 
 188     /*
 189      * Record a new session, using a given cipher spec, session ID,
 190      * and creation time.
 191      * Note: For the unmodifiable collections and lists we are creating new
 192      * collections as inputs to avoid potential deep nesting of
 193      * unmodifiable collections that can cause StackOverflowErrors
 194      * (see JDK-6323374).
 195      */
 196     SSLSessionImpl(HandshakeContext hc,
 197             CipherSuite cipherSuite, SessionId id, long creationTime) {
 198         this.protocolVersion = hc.negotiatedProtocol;
 199         this.cipherSuite = cipherSuite;
 200         this.sessionId = id;
 201         this.host = hc.conContext.transport.getPeerHost();
 202         this.port = hc.conContext.transport.getPeerPort();
 203         this.localSupportedSignAlgs = hc.localSupportedSignAlgs == null ?
 204                 Collections.emptySet() :
 205                 Collections.unmodifiableCollection(
 206                         new ArrayList&lt;&gt;(hc.localSupportedSignAlgs));
 207         this.serverNameIndication = hc.negotiatedServerName;
 208         this.requestedServerNames = Collections.unmodifiableList(
 209                 new ArrayList&lt;&gt;(hc.getRequestedServerNames()));
 210         if (hc.sslConfig.isClientMode) {
 211             this.useExtendedMasterSecret =
 212                 (hc.handshakeExtensions.get(
 213                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 214                 (hc.handshakeExtensions.get(
 215                         SSLExtension.SH_EXTENDED_MASTER_SECRET) != null);
 216         } else {
 217             this.useExtendedMasterSecret =
 218                 (hc.handshakeExtensions.get(
 219                         SSLExtension.CH_EXTENDED_MASTER_SECRET) != null) &amp;&amp;
 220                 (!hc.negotiatedProtocol.useTLS13PlusSpec());
 221         }
 222         this.creationTime = creationTime;
 223         this.identificationProtocol = hc.sslConfig.identificationProtocol;
 224         this.boundValues = new ConcurrentHashMap&lt;&gt;();
 225 
 226         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 227              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 228         }
 229     }
 230 
 231     SSLSessionImpl(SSLSessionImpl baseSession, SessionId newId) {
 232         this.protocolVersion = baseSession.getProtocolVersion();
 233         this.cipherSuite = baseSession.cipherSuite;
 234         this.sessionId = newId;
 235         this.host = baseSession.getPeerHost();
 236         this.port = baseSession.getPeerPort();
 237         this.localSupportedSignAlgs =
 238                 baseSession.localSupportedSignAlgs == null ?
 239                 Collections.emptySet() : baseSession.localSupportedSignAlgs;
 240         this.peerSupportedSignAlgs =
 241                 baseSession.peerSupportedSignAlgs == null ?
 242                 Collections.emptySet() : baseSession.peerSupportedSignAlgs;
 243         this.serverNameIndication = baseSession.serverNameIndication;
 244         this.requestedServerNames = baseSession.getRequestedServerNames();
 245         this.masterSecret = baseSession.getMasterSecret();
 246         this.useExtendedMasterSecret = baseSession.useExtendedMasterSecret;
 247         this.creationTime = baseSession.getCreationTime();
 248         this.lastUsedTime = System.currentTimeMillis();
 249         this.identificationProtocol = baseSession.getIdentificationProtocol();
 250         this.localCerts = baseSession.localCerts;
 251         this.peerCerts = baseSession.peerCerts;
 252         this.statusResponses = baseSession.statusResponses;
 253         this.resumptionMasterSecret = baseSession.resumptionMasterSecret;
 254         this.context = baseSession.context;
 255         this.negotiatedMaxFragLen = baseSession.negotiatedMaxFragLen;
 256         this.maximumPacketSize = baseSession.maximumPacketSize;
 257         this.boundValues = baseSession.boundValues;
 258 
 259         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 260              SSLLogger.finest(&quot;Session initialized:  &quot; + this);
 261         }
 262     }
 263 
 264     /**
 265      * &lt; 2 bytes &gt; protocolVersion
 266      * &lt; 2 bytes &gt; cipherSuite
 267      * &lt; 1 byte &gt; localSupportedSignAlgs entries
 268      *   &lt; 2 bytes per entries &gt; localSupportedSignAlgs
 269      * &lt; 1 bytes &gt; peerSupportedSignAlgs entries
 270      *   &lt; 2 bytes per entries &gt; peerSupportedSignAlgs
 271      * &lt; 2 bytes &gt; preSharedKey length
 272      * &lt; length in bytes &gt; preSharedKey
 273      * &lt; 1 byte &gt; pskIdentity length
 274      * &lt; length in bytes &gt; pskIdentity
 275      * &lt; 1 byte &gt; masterSecret length
 276      *   &lt; 1 byte &gt; masterSecret algorithm length
 277      *   &lt; length in bytes &gt; masterSecret algorithm
 278      *   &lt; 2 bytes &gt; masterSecretKey length
 279      *   &lt; length in bytes&gt; masterSecretKey
 280      * &lt; 1 byte &gt; useExtendedMasterSecret
 281      * &lt; 1 byte &gt; identificationProtocol length
 282      * &lt; length in bytes &gt; identificationProtocol
 283      * &lt; 1 byte &gt; serverNameIndication length
 284      * &lt; length in bytes &gt; serverNameIndication
 285      * &lt; 1 byte &gt; Number of requestedServerNames entries
 286      *   &lt; 1 byte &gt; ServerName length
 287      *   &lt; length in bytes &gt; ServerName
 288      * &lt; 4 bytes &gt; creationTime
 289      * &lt; 2 byte &gt; status response length
 290      *   &lt; 2 byte &gt; status response entry length
 291      *   &lt; length in byte &gt; status response entry
 292      * &lt; 1 byte &gt; Length of peer host
 293      *   &lt; length in bytes &gt; peer host
 294      * &lt; 2 bytes&gt; peer port
 295      * &lt; 1 byte &gt; Number of peerCerts entries
 296      *   &lt; 4 byte &gt; peerCert length
 297      *   &lt; length in bytes &gt; peerCert
 298      * &lt; 1 byte &gt; localCerts type (Cert, PSK, Anonymous)
 299      *   Certificate
 300      *     &lt; 1 byte &gt; Number of Certificate entries
 301      *       &lt; 4 byte&gt; Certificate length
 302      *       &lt; length in bytes&gt; Certificate
 303      *   PSK
 304      *     &lt; 1 byte &gt; Number of PSK entries
 305      *       &lt; 1 bytes &gt; PSK algorithm length
 306      *       &lt; length in bytes &gt; PSK algorithm string
 307      *       &lt; 4 bytes &gt; PSK key length
 308      *       &lt; length in bytes&gt; PSK key
 309      *       &lt; 4 bytes &gt; PSK identity length
 310      *       &lt; length in bytes&gt; PSK identity
 311      *   Anonymous
 312      *     &lt; 1 byte &gt;
 313      * &lt; 4 bytes &gt; maximumPacketSize
 314      * &lt; 4 bytes &gt; negotiatedMaxFragSize
 315      */
 316 
 317     SSLSessionImpl(HandshakeContext hc, ByteBuffer buf) throws IOException {
 318         int i = 0;
 319         byte[] b;
 320 
 321         boundValues = new ConcurrentHashMap&lt;&gt;();
 322         this.protocolVersion =
 323                 ProtocolVersion.valueOf(Short.toUnsignedInt(buf.getShort()));
 324 
 325         if (protocolVersion.useTLS13PlusSpec()) {
 326             this.sessionId = new SessionId(false, null);
 327         } else {
 328             // The CH session id may reset this if it&#39;s provided
 329             this.sessionId = new SessionId(true,
 330                     hc.sslContext.getSecureRandom());
 331         }
 332 
 333         this.cipherSuite =
 334                 CipherSuite.valueOf(Short.toUnsignedInt(buf.getShort()));
 335 
 336         // Local Supported signature algorithms
 337         ArrayList&lt;SignatureScheme&gt; list = new ArrayList&lt;&gt;();
 338         i = Byte.toUnsignedInt(buf.get());
 339         while (i-- &gt; 0) {
 340             list.add(SignatureScheme.valueOf(
 341                     Short.toUnsignedInt(buf.getShort())));
 342         }
 343         this.localSupportedSignAlgs = Collections.unmodifiableCollection(list);
 344 
 345         // Peer Supported signature algorithms
 346         i = Byte.toUnsignedInt(buf.get());
 347         list.clear();
 348         while (i-- &gt; 0) {
 349             list.add(SignatureScheme.valueOf(
 350                     Short.toUnsignedInt(buf.getShort())));
 351         }
 352         this.peerSupportedSignAlgs = Collections.unmodifiableCollection(list);
 353 
 354         // PSK
 355         i = Short.toUnsignedInt(buf.getShort());
 356         if (i &gt; 0) {
 357             b = new byte[i];
 358             // Get algorithm string
 359             buf.get(b, 0, i);
 360             // Encoded length
 361             i = Short.toUnsignedInt(buf.getShort());
 362             // Encoded SecretKey
 363             b = new byte[i];
 364             buf.get(b);
 365             this.preSharedKey = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 366         } else {
 367             this.preSharedKey = null;
 368         }
 369 
 370         // PSK identity
 371         i = buf.get();
 372         if (i &gt; 0) {
 373             b = new byte[i];
 374             buf.get(b);
 375             this.pskIdentity = b;
 376         } else {
 377             this.pskIdentity = null;
 378         }
 379 
 380         // Master secret length of secret key algorithm  (one byte)
 381         i = buf.get();
 382         if (i &gt; 0) {
 383             b = new byte[i];
 384             // Get algorithm string
 385             buf.get(b, 0, i);
 386             // Encoded length
 387             i = Short.toUnsignedInt(buf.getShort());
 388             // Encoded SecretKey
 389             b = new byte[i];
 390             buf.get(b);
 391             this.masterSecret = new SecretKeySpec(b, &quot;TlsMasterSecret&quot;);
 392         } else {
 393             this.masterSecret = null;
 394         }
 395         // Use extended master secret
 396         this.useExtendedMasterSecret = (buf.get() != 0);
 397 
 398         // Identification Protocol
 399         i = buf.get();
 400         if (i == 0) {
 401             identificationProtocol = null;
 402         } else {
 403             b = new byte[i];
 404             identificationProtocol =
 405                     buf.get(b, 0, i).asCharBuffer().toString();
 406         }
 407 
 408         // SNI
 409         i = buf.get();  // length
 410         if (i == 0) {
 411             serverNameIndication = null;
 412         } else {
 413             b = new byte[i];
 414             buf.get(b, 0, b.length);
 415             serverNameIndication = new SNIHostName(b);
 416         }
 417 
 418         // List of SNIServerName
 419         int len = Short.toUnsignedInt(buf.getShort());
 420         if (len == 0) {
 421             this.requestedServerNames = Collections.&lt;SNIServerName&gt;emptyList();
 422         } else {
 423             requestedServerNames = new ArrayList&lt;&gt;();
 424             while (len &gt; 0) {
 425                 int l = buf.get();
 426                 b = new byte[l];
 427                 buf.get(b, 0, l);
 428                 requestedServerNames.add(new SNIHostName(new String(b)));
 429                 len--;
 430             }
 431         }
 432 
 433         maximumPacketSize = buf.getInt();
 434         negotiatedMaxFragLen = buf.getInt();
 435 
 436         // Get creation time
 437         this.creationTime = buf.getLong();
 438 
 439         // Get Buffer sizes
 440 
 441         // Status Response
 442         len = Short.toUnsignedInt(buf.getShort());
 443         if (len == 0) {
 444             statusResponses = Collections.emptyList();
 445         } else {
 446             statusResponses = new ArrayList&lt;&gt;();
 447         }
 448         while (len-- &gt; 0) {
 449             b = new byte[Short.toUnsignedInt(buf.getShort())];
 450             buf.get(b);
 451             statusResponses.add(b);
 452         }
 453 
 454         // Get Peer host &amp; port
 455         i = Byte.toUnsignedInt(buf.get());
 456         if (i == 0) {
 457             this.host = new String();
 458         } else {
 459             b = new byte[i];
 460             this.host = buf.get(b).toString();
 461         }
 462         this.port = Short.toUnsignedInt(buf.getShort());
 463 
 464         // Peer certs
 465         i = buf.get();
 466         if (i == 0) {
 467             this.peerCerts = null;
 468         } else {
 469             this.peerCerts = new X509Certificate[i];
 470             int j = 0;
 471             while (i &gt; j) {
 472                 b = new byte[buf.getInt()];
 473                 buf.get(b);
 474                 try {
 475                     this.peerCerts[j] = new X509CertImpl(b);
 476                 } catch (Exception e) {
 477                     throw new IOException(e);
 478                 }
 479                 j++;
 480             }
 481         }
 482 
 483         // Get local certs of PSK
 484         switch (buf.get()) {
 485             case 0:
 486                 break;
 487             case 1:
 488                 // number of certs
 489                 len = buf.get();
 490                 this.localCerts = new X509Certificate[len];
 491                 i = 0;
 492                 while (len &gt; i) {
 493                     b = new byte[buf.getInt()];
 494                     buf.get(b);
 495                     try {
 496                         this.localCerts[i] = new X509CertImpl(b);
 497                     } catch (Exception e) {
 498                         throw new IOException(e);
 499                     }
 500                     i++;
 501                 }
 502                 break;
 503             case 2:
 504                 // pre-shared key
 505                 // Length of pre-shared key algorithm  (one byte)
 506                 i = buf.get();
 507                 b = new byte[i];
 508                 String alg = buf.get(b, 0, i).asCharBuffer().toString();
 509                 // Get length of encoding
 510                 i = Short.toUnsignedInt(buf.getShort());
 511                 // Get encoding
 512                 b = new byte[i];
 513                 buf.get(b);
 514                 this.preSharedKey = new SecretKeySpec(b, alg);
 515                 // Get identity len
 516                 this.pskIdentity = new byte[buf.get()];
 517                 buf.get(pskIdentity);
 518                 break;
 519             default:
 520                 throw new SSLException(&quot;Failed local certs of session.&quot;);
 521         }
 522 
 523         context = (SSLSessionContextImpl)
 524                 hc.sslContext.engineGetServerSessionContext();
 525         this.lastUsedTime = System.currentTimeMillis();
 526     }
 527 
 528     // Some situations we cannot provide a stateless ticket, but after it
 529     // has been negotiated
 530     boolean isStatelessable(HandshakeContext hc) {
 531         if (!hc.statelessResumption) {
 532             return false;
 533         }
 534 
 535         // If there is no getMasterSecret with TLS1.2 or under, do not resume.
 536         if (!protocolVersion.useTLS13PlusSpec() &amp;&amp;
 537                 getMasterSecret().getEncoded() == null) {
 538             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 539                 SSLLogger.finest(&quot;No MasterSecret, cannot make stateless&quot; +
 540                         &quot; ticket&quot;);
 541             }
 542             return false;
 543         }
 544         if (boundValues != null &amp;&amp; boundValues.size() &gt; 0) {
 545             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
 546                 SSLLogger.finest(&quot;There are boundValues, cannot make&quot; +
 547                         &quot; stateless ticket&quot;);
 548             }
 549             return false;
 550         }
 551         return true;
 552     }
 553 
 554     /**
 555      * Write out a SSLSessionImpl in a byte array for a stateless session ticket
 556      */
 557     byte[] write() throws Exception {
 558         byte[] b;
 559         HandshakeOutStream hos = new HandshakeOutStream(null);
 560 
 561         hos.putInt16(protocolVersion.id);
 562         hos.putInt16(cipherSuite.id);
 563 
 564         // Local Supported signature algorithms
 565         hos.putInt8(localSupportedSignAlgs.size());
 566         for (SignatureScheme s : localSupportedSignAlgs) {
 567             hos.putInt16(s.id);
 568         }
 569 
 570         // Peer Supported signature algorithms
 571         hos.putInt8(peerSupportedSignAlgs.size());
 572         for (SignatureScheme s : peerSupportedSignAlgs) {
 573             hos.putInt16(s.id);
 574         }
 575 
 576         // PSK
 577         if (preSharedKey == null ||
 578                 preSharedKey.getAlgorithm() == null) {
 579             hos.putInt16(0);
 580         } else {
 581             hos.putInt16(preSharedKey.getAlgorithm().length());
 582             if (preSharedKey.getAlgorithm().length() != 0) {
 583                 hos.write(preSharedKey.getAlgorithm().getBytes());
 584             }
 585             b = preSharedKey.getEncoded();
 586             hos.putInt16(b.length);
 587             hos.write(b, 0, b.length);
 588         }
 589 
 590         // PSK Identity
 591         if (pskIdentity == null) {
 592             hos.putInt8(0);
 593         } else {
 594             hos.putInt8(pskIdentity.length);
 595             hos.write(pskIdentity, 0, pskIdentity.length);
 596         }
 597 
 598         // Master Secret
 599         if (getMasterSecret() == null ||
 600                 getMasterSecret().getAlgorithm() == null) {
 601             hos.putInt8(0);
 602         } else {
 603             hos.putInt8(getMasterSecret().getAlgorithm().length());
 604             if (getMasterSecret().getAlgorithm().length() != 0) {
 605                 hos.write(getMasterSecret().getAlgorithm().getBytes());
 606             }
 607             b = getMasterSecret().getEncoded();
 608             hos.putInt16(b.length);
 609             hos.write(b, 0, b.length);
 610         }
 611 
 612         hos.putInt8(useExtendedMasterSecret ? 1 : 0);
 613 
 614         // Identification Protocol
 615         if (identificationProtocol == null) {
 616             hos.putInt8(0);
 617         } else {
 618             hos.putInt8(identificationProtocol.length());
 619             hos.write(identificationProtocol.getBytes(), 0,
 620                     identificationProtocol.length());
 621         }
 622 
 623         // SNI
 624         if (serverNameIndication == null) {
 625             hos.putInt8(0);
 626         } else {
 627             b = serverNameIndication.getEncoded();
 628             hos.putInt8(b.length);
 629             hos.write(b, 0, b.length);
 630         }
 631 
 632         // List of SNIServerName
 633         hos.putInt16(requestedServerNames.size());
 634         if (requestedServerNames.size() &gt; 0) {
 635             for (SNIServerName host : requestedServerNames) {
 636                 b = host.getEncoded();
 637                 hos.putInt8(b.length);
 638                 hos.write(b, 0, b.length);
 639             }
 640         }
 641 
 642         // Buffer sizes
 643         hos.putInt32(maximumPacketSize);
 644         hos.putInt32(negotiatedMaxFragLen);
 645 
 646         // creation time
 647         ByteBuffer buffer = ByteBuffer.allocate(Long.BYTES);
 648         hos.writeBytes(buffer.putLong(creationTime).array());
 649 
 650         // Status Responses
 651         List&lt;byte[]&gt; list = getStatusResponses();
 652         int l = list.size();
 653         hos.putInt16(l);
 654         for (byte[] e : list) {
 655             hos.putInt16(e.length);
 656             hos.write(e);
 657         }
 658 
 659         // peer Host &amp; Port
 660         if (host == null || host.length() == 0) {
 661             hos.putInt8(0);
 662         } else {
 663             hos.putInt8(host.length());
 664             hos.writeBytes(host.getBytes());
 665         }
 666         hos.putInt16(port);
 667 
 668         // Peer cert
 669         if (peerCerts == null || peerCerts.length == 0) {
 670             hos.putInt8(0);
 671         } else {
 672             hos.putInt8(peerCerts.length);
 673             for (X509Certificate c : peerCerts) {
 674                 b = c.getEncoded();
 675                 hos.putInt32(b.length);
 676                 hos.writeBytes(b);
 677             }
 678         }
 679 
 680         // Client identity
 681         if (localCerts != null &amp;&amp; localCerts.length &gt; 0) {
 682             // certificate based
 683             hos.putInt8(1);
 684             hos.putInt8(localCerts.length);
 685             for (X509Certificate c : localCerts) {
 686                 b = c.getEncoded();
 687                 hos.putInt32(b.length);
 688                 hos.writeBytes(b);
 689             }
 690         } else if (preSharedKey != null) {
 691             // pre-shared key
 692             hos.putInt8(2);
 693             hos.putInt8(preSharedKey.getAlgorithm().length());
 694             hos.write(preSharedKey.getAlgorithm().getBytes());
 695             b = preSharedKey.getEncoded();
 696             hos.putInt32(b.length);
 697             hos.writeBytes(b);
 698             hos.putInt32(pskIdentity.length);
 699             hos.writeBytes(pskIdentity);
 700         } else {
 701             // anonymous
 702             hos.putInt8(0);
 703         }
 704 
 705         return hos.toByteArray();
 706     }
 707 
 708     void setMasterSecret(SecretKey secret) {
 709         masterSecret = secret;
 710     }
 711 
 712     void setResumptionMasterSecret(SecretKey secret) {
 713         resumptionMasterSecret = secret;
 714     }
 715 
 716     void setPreSharedKey(SecretKey key) {
 717         preSharedKey = key;
 718     }
 719 
 720     void addChild(SSLSessionImpl session) {
 721         childSessions.add(session);
 722     }
 723 
 724     void setTicketAgeAdd(int ticketAgeAdd) {
 725         this.ticketAgeAdd = ticketAgeAdd;
 726     }
 727 
 728     void setPskIdentity(byte[] pskIdentity) {
 729         this.pskIdentity = pskIdentity;
 730     }
 731 
 732     BigInteger incrTicketNonceCounter() {
 733         BigInteger result = ticketNonceCounter;
 734         ticketNonceCounter = ticketNonceCounter.add(BigInteger.ONE);
 735         return result;
 736     }
 737 
 738     boolean isPSKable() {
 739         return (ticketNonceCounter.compareTo(BigInteger.ZERO) &gt; 0);
 740     }
 741 
 742     /**
 743      * Returns the master secret ... treat with extreme caution!
 744      */
 745     SecretKey getMasterSecret() {
 746         return masterSecret;
 747     }
 748 
 749     SecretKey getResumptionMasterSecret() {
 750         return resumptionMasterSecret;
 751     }
 752 
 753     SecretKey getPreSharedKey() {
 754         sessionLock.lock();
 755         try {
 756             return preSharedKey;
 757         } finally {
 758             sessionLock.unlock();
 759         }
 760     }
 761 
 762     SecretKey consumePreSharedKey() {
 763         sessionLock.lock();
 764         try {
 765             return preSharedKey;
 766         } finally {
 767             preSharedKey = null;
 768             sessionLock.unlock();
 769         }
 770     }
 771 
 772     int getTicketAgeAdd() {
 773         return ticketAgeAdd;
 774     }
 775 
 776     String getIdentificationProtocol() {
 777         return this.identificationProtocol;
 778     }
 779 
 780     /* PSK identities created from new_session_ticket messages should only
 781      * be used once. This method will return the identity and then clear it
 782      * so it cannot be used again.
 783      */
 784     byte[] consumePskIdentity() {
 785         sessionLock.lock();
 786         try {
 787             return pskIdentity;
 788         } finally {
 789             pskIdentity = null;
 790             sessionLock.unlock();
 791         }
 792     }
 793 
 794     byte[] getPskIdentity() {
 795         return pskIdentity;
 796     }
 797 
 798     void setPeerCertificates(X509Certificate[] peer) {
 799         if (peerCerts == null) {
 800             peerCerts = peer;
 801         }
 802     }
 803 
 804     void setLocalCertificates(X509Certificate[] local) {
 805         localCerts = local;
 806     }
 807 
 808     void setLocalPrivateKey(PrivateKey privateKey) {
 809         localPrivateKey = privateKey;
 810     }
 811 
 812     void setPeerSupportedSignatureAlgorithms(
 813             Collection&lt;SignatureScheme&gt; signatureSchemes) {
 814         peerSupportedSignAlgs = signatureSchemes;
 815     }
 816 
 817     // TLS 1.2 only
 818     //
 819     // Per RFC 5246, If the client supports only the default hash
 820     // and signature algorithms, it MAY omit the
 821     // signature_algorithms extension.  If the client does not
 822     // support the default algorithms, or supports other hash
 823     // and signature algorithms (and it is willing to use them
 824     // for verifying messages sent by the server, i.e., server
 825     // certificates and server key exchange), it MUST send the
 826     // signature_algorithms extension, listing the algorithms it
 827     // is willing to accept.
 828     private static final ArrayList&lt;SignatureScheme&gt; defaultPeerSupportedSignAlgs =
 829             new ArrayList&lt;&gt;(Arrays.asList(SignatureScheme.RSA_PKCS1_SHA1,
 830                     SignatureScheme.DSA_SHA1,
 831                     SignatureScheme.ECDSA_SHA1));
 832 
 833     void setUseDefaultPeerSignAlgs() {
 834         useDefaultPeerSignAlgs = true;
 835         peerSupportedSignAlgs = defaultPeerSupportedSignAlgs;
 836     }
 837 
 838     // Returns the connection session.
 839     SSLSessionImpl finish() {
 840         if (useDefaultPeerSignAlgs) {
 841             peerSupportedSignAlgs = Collections.emptySet();
 842         }
 843 
 844         return this;
 845     }
 846 
 847     /**
 848      * Provide status response data obtained during the SSL handshake.
 849      *
 850      * @param responses a {@link List} of responses in binary form.
 851      */
 852     void setStatusResponses(List&lt;byte[]&gt; responses) {
 853         if (responses != null &amp;&amp; !responses.isEmpty()) {
 854             statusResponses = responses;
 855         } else {
 856             statusResponses = Collections.emptyList();
 857         }
 858     }
 859 
 860     /**
 861      * Returns true iff this session may be resumed ... sessions are
 862      * usually resumable.  Security policies may suggest otherwise,
 863      * for example sessions that haven&#39;t been used for a while (say,
 864      * a working day) won&#39;t be resumable, and sessions might have a
 865      * maximum lifetime in any case.
 866      */
 867     boolean isRejoinable() {
 868         // TLS 1.3 can have no session id
 869         if (protocolVersion.useTLS13PlusSpec()) {
 870             return (!invalidated &amp;&amp; isLocalAuthenticationValid());
 871         }
 872         return sessionId != null &amp;&amp; sessionId.length() != 0 &amp;&amp;
 873                 !invalidated &amp;&amp; isLocalAuthenticationValid();
 874     }
 875 
 876     @Override
 877     public boolean isValid() {
 878         sessionLock.lock();
 879         try {
 880             return isRejoinable();
 881         } finally {
 882             sessionLock.unlock();
 883         }
 884     }
 885 
 886     /**
 887      * Check if the authentication used when establishing this session
 888      * is still valid. Returns true if no authentication was used
 889      */
 890     private boolean isLocalAuthenticationValid() {
 891         if (localPrivateKey != null) {
 892             try {
 893                 // if the private key is no longer valid, getAlgorithm()
 894                 // should throw an exception
 895                 // (e.g. Smartcard has been removed from the reader)
 896                 localPrivateKey.getAlgorithm();
 897             } catch (Exception e) {
 898                 invalidate();
 899                 return false;
 900             }
 901         }
 902 
 903         return true;
 904     }
 905 
 906     /**
 907      * Returns the ID for this session.  The ID is fixed for the
 908      * duration of the session; neither it, nor its value, changes.
 909      */
 910     @Override
 911     public byte[] getId() {
 912         return sessionId.getId();
 913     }
 914 
 915     /**
 916      * For server sessions, this returns the set of sessions which
 917      * are currently valid in this process.  For client sessions,
 918      * this returns null.
 919      */
 920     @Override
 921     public SSLSessionContext getSessionContext() {
 922         /*
 923          * An interim security policy until we can do something
 924          * more specific in 1.2. Only allow trusted code (code which
 925          * can set system properties) to get an
 926          * SSLSessionContext. This is to limit the ability of code to
 927          * look up specific sessions or enumerate over them. Otherwise,
 928          * code can only get session objects from successful SSL
 929          * connections which implies that they must have had permission
 930          * to make the network connection in the first place.
 931          */
 932         SecurityManager sm;
 933         if ((sm = System.getSecurityManager()) != null) {
 934             sm.checkPermission(new SSLPermission(&quot;getSSLSessionContext&quot;));
 935         }
 936 
 937         return context;
 938     }
 939 
 940 
 941     SessionId getSessionId() {
 942         return sessionId;
 943     }
 944 
 945 
 946     /**
 947      * Returns the cipher spec in use on this session
 948      */
 949     CipherSuite getSuite() {
 950         return cipherSuite;
 951     }
 952 
 953     /**
 954      * Resets the cipher spec in use on this session
 955      */
 956     void setSuite(CipherSuite suite) {
 957        cipherSuite = suite;
 958 
 959         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
 960              SSLLogger.finest(&quot;Negotiating session:  &quot; + this);
 961        }
 962     }
 963 
 964     /**
 965      * Return true if the session is currently re-established with a
 966      * session-resumption abbreviated initial handshake.
 967      */
 968     boolean isSessionResumption() {
 969         return isSessionResumption;
 970     }
 971 
 972     /**
 973      * Resets whether the session is re-established with a session-resumption
 974      * abbreviated initial handshake.
 975      */
 976     void setAsSessionResumption(boolean flag) {
 977         isSessionResumption = flag;
 978     }
 979 
 980     /**
 981      * Returns the name of the cipher suite in use on this session
 982      */
 983     @Override
 984     public String getCipherSuite() {
 985         return getSuite().name;
 986     }
 987 
 988     ProtocolVersion getProtocolVersion() {
 989         return protocolVersion;
 990     }
 991 
 992     /**
 993      * Returns the standard name of the protocol in use on this session
 994      */
 995     @Override
 996     public String getProtocol() {
 997         return getProtocolVersion().name;
 998     }
 999 
1000     /**
1001      * Returns the hashcode for this session
1002      */
1003     @Override
1004     public int hashCode() {
1005         return sessionId.hashCode();
1006     }
1007 
1008     /**
1009      * Returns true if sessions have same ids, false otherwise.
1010      */
1011     @Override
1012     public boolean equals(Object obj) {
1013 
1014         if (obj == this) {
1015             return true;
1016         }
1017 
1018         if (obj instanceof SSLSessionImpl) {
1019             SSLSessionImpl sess = (SSLSessionImpl) obj;
1020             return (sessionId != null) &amp;&amp; (sessionId.equals(
1021                         sess.getSessionId()));
1022         }
1023 
1024         return false;
1025     }
1026 
1027 
1028     /**
1029      * Return the cert chain presented by the peer in the
1030      * java.security.cert format.
1031      * Note: This method can be used only when using certificate-based
1032      * cipher suites; using it with non-certificate-based cipher suites
1033      * will throw an SSLPeerUnverifiedException.
1034      *
1035      * @return array of peer X.509 certs, with the peer&#39;s own cert
1036      *  first in the chain, and with the &quot;root&quot; CA last.
1037      */
1038     @Override
1039     public java.security.cert.Certificate[] getPeerCertificates()
1040             throws SSLPeerUnverifiedException {
1041         //
1042         // clone to preserve integrity of session ... caller can&#39;t
1043         // change record of peer identity even by accident, much
1044         // less do it intentionally.
1045         //
1046         if (peerCerts == null) {
1047             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1048         }
1049         // Certs are immutable objects, therefore we don&#39;t clone them.
1050         // But do need to clone the array, so that nothing is inserted
1051         // into peerCerts.
1052         return (java.security.cert.Certificate[])peerCerts.clone();
1053     }
1054 
1055     /**
1056      * Return the cert chain presented to the peer in the
1057      * java.security.cert format.
1058      * Note: This method is useful only when using certificate-based
1059      * cipher suites.
1060      *
1061      * @return array of peer X.509 certs, with the peer&#39;s own cert
1062      *  first in the chain, and with the &quot;root&quot; CA last.
1063      */
1064     @Override
1065     public java.security.cert.Certificate[] getLocalCertificates() {
1066         //
1067         // clone to preserve integrity of session ... caller can&#39;t
1068         // change record of peer identity even by accident, much
1069         // less do it intentionally.
1070         return (localCerts == null ? null :
1071             (java.security.cert.Certificate[])localCerts.clone());
1072     }
1073 
1074     /**
1075      * Return the cert chain presented by the peer.
1076      * Note: This method can be used only when using certificate-based
1077      * cipher suites; using it with non-certificate-based cipher suites
1078      * will throw an SSLPeerUnverifiedException.
1079      *
1080      * @return array of peer X.509 certs, with the peer&#39;s own cert
1081      *  first in the chain, and with the &quot;root&quot; CA last.
1082      */
1083     public X509Certificate[] getCertificateChain()
1084             throws SSLPeerUnverifiedException {
1085         /*
1086          * clone to preserve integrity of session ... caller can&#39;t
1087          * change record of peer identity even by accident, much
1088          * less do it intentionally.
1089          */
1090         if (peerCerts != null) {
1091             return peerCerts.clone();
1092         } else {
1093             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1094         }
1095     }
1096 
1097     /**
1098      * Return a List of status responses presented by the peer.
1099      * Note: This method can be used only when using certificate-based
1100      * server authentication; otherwise an empty {@code List} will be returned.
1101      *
1102      * @return an unmodifiable {@code List} of byte arrays, each consisting
1103      * of a DER-encoded OCSP response (see RFC 6960).  If no responses have
1104      * been presented by the server or non-certificate based server
1105      * authentication is used then an empty {@code List} is returned.
1106      */
1107     @Override
1108     public List&lt;byte[]&gt; getStatusResponses() {
1109         if (statusResponses == null || statusResponses.isEmpty()) {
1110             return Collections.emptyList();
1111         } else {
1112             // Clone both the list and the contents
1113             List&lt;byte[]&gt; responses = new ArrayList&lt;&gt;(statusResponses.size());
1114             for (byte[] respBytes : statusResponses) {
1115                 responses.add(respBytes.clone());
1116             }
1117             return Collections.unmodifiableList(responses);
1118         }
1119     }
1120 
1121     /**
1122      * Returns the identity of the peer which was established as part of
1123      * defining the session.
1124      *
1125      * @return the peer&#39;s principal. Returns an X500Principal of the
1126      * end-entity certificate for X509-based cipher suites.
1127      *
1128      * @throws SSLPeerUnverifiedException if the peer&#39;s identity has not
1129      *          been verified
1130      */
1131     @Override
1132     public Principal getPeerPrincipal()
1133                 throws SSLPeerUnverifiedException
1134     {
1135         if (peerCerts == null) {
1136             throw new SSLPeerUnverifiedException(&quot;peer not authenticated&quot;);
1137         }
1138         return peerCerts[0].getSubjectX500Principal();
1139     }
1140 
1141     /**
1142      * Returns the principal that was sent to the peer during handshaking.
1143      *
1144      * @return the principal sent to the peer. Returns an X500Principal
1145      * of the end-entity certificate for X509-based cipher suites.
1146      * If no principal was sent, then null is returned.
1147      */
1148     @Override
1149     public Principal getLocalPrincipal() {
1150         return ((localCerts == null || localCerts.length == 0) ? null :
1151                 localCerts[0].getSubjectX500Principal());
1152     }
1153 
1154     /*
1155      * Return the time the ticket for this session was created.
1156      */
1157     public long getTicketCreationTime() {
1158         return ticketCreationTime;
1159     }
1160 
1161     /**
1162      * Returns the time this session was created.
1163      */
1164     @Override
1165     public long getCreationTime() {
1166         return creationTime;
1167     }
1168 
1169     /**
1170      * Returns the last time this session was used to initialize
1171      * a connection.
1172      */
1173     @Override
1174     public long getLastAccessedTime() {
1175         return (lastUsedTime != 0) ? lastUsedTime : creationTime;
1176     }
1177 
1178     void setLastAccessedTime(long time) {
1179         lastUsedTime = time;
1180     }
1181 
1182 
1183     /**
1184      * Returns the network address of the session&#39;s peer.  This
1185      * implementation does not insist that connections between
1186      * different ports on the same host must necessarily belong
1187      * to different sessions, though that is of course allowed.
1188      */
1189     public InetAddress getPeerAddress() {
1190         try {
1191             return InetAddress.getByName(host);
1192         } catch (java.net.UnknownHostException e) {
1193             return null;
1194         }
1195     }
1196 
1197     @Override
1198     public String getPeerHost() {
1199         return host;
1200     }
1201 
1202     /**
1203      * Need to provide the port info for caching sessions based on
1204      * host and port. Accessed by SSLSessionContextImpl
1205      */
1206     @Override
1207     public int getPeerPort() {
1208         return port;
1209     }
1210 
1211     void setContext(SSLSessionContextImpl ctx) {
1212         if (context == null) {
1213             context = ctx;
1214         }
1215     }
1216 
1217     /**
1218      * Invalidate a session.  Active connections may still exist, but
1219      * no connections will be able to rejoin this session.
1220      */
1221     @Override
1222     public void invalidate() {
1223         sessionLock.lock();
1224         try {
1225             //
1226             // Can&#39;t invalidate the NULL session -- this would be
1227             // attempted when we get a handshaking error on a brand
1228             // new connection, with no &quot;real&quot; session yet.
1229             //
1230             if (this == nullSession) {
1231                 return;
1232             }
1233 
1234             if (context != null) {
1235                 context.remove(sessionId);
1236                 context = null;
1237             }
1238 
1239             if (invalidated) {
1240                 return;
1241             }
1242             invalidated = true;
1243             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;session&quot;)) {
1244                  SSLLogger.finest(&quot;Invalidated session:  &quot; + this);
1245             }
1246             for (SSLSessionImpl child : childSessions) {
1247                 child.invalidate();
1248             }
1249         } finally {
1250             sessionLock.unlock();
1251         }
1252     }
1253 
1254     /*
1255      * Table of application-specific session data indexed by an application
1256      * key and the calling security context. This is important since
1257      * sessions can be shared across different protection domains.
1258      */
1259     private final ConcurrentHashMap&lt;SecureKey, Object&gt; boundValues;
1260     boolean updateNST;
1261 
1262     /**
1263      * Assigns a session value.  Session change events are given if
1264      * appropriate, to any original value as well as the new value.
1265      */
1266     @Override
1267     public void putValue(String key, Object value) {
1268         if ((key == null) || (value == null)) {
1269             throw new IllegalArgumentException(&quot;arguments can not be null&quot;);
1270         }
1271 
1272         SecureKey secureKey = new SecureKey(key);
1273         Object oldValue = boundValues.put(secureKey, value);
1274 
1275         if (oldValue instanceof SSLSessionBindingListener) {
1276             SSLSessionBindingEvent e;
1277 
1278             e = new SSLSessionBindingEvent(this, key);
1279             ((SSLSessionBindingListener)oldValue).valueUnbound(e);
1280         }
1281         if (value instanceof SSLSessionBindingListener) {
1282             SSLSessionBindingEvent e;
1283 
1284             e = new SSLSessionBindingEvent(this, key);
1285             ((SSLSessionBindingListener)value).valueBound(e);
1286         }
1287         if (protocolVersion.useTLS13PlusSpec()) {
1288             updateNST = true;
1289         }
1290     }
1291 
1292     /**
1293      * Returns the specified session value.
1294      */
1295     @Override
1296     public Object getValue(String key) {
1297         if (key == null) {
1298             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1299         }
1300 
1301         SecureKey secureKey = new SecureKey(key);
1302         return boundValues.get(secureKey);
1303     }
1304 
1305 
1306     /**
1307      * Removes the specified session value, delivering a session changed
1308      * event as appropriate.
1309      */
1310     @Override
1311     public void removeValue(String key) {
1312         if (key == null) {
1313             throw new IllegalArgumentException(&quot;argument can not be null&quot;);
1314         }
1315 
1316         SecureKey secureKey = new SecureKey(key);
1317         Object value = boundValues.remove(secureKey);
1318 
1319         if (value instanceof SSLSessionBindingListener) {
1320             SSLSessionBindingEvent e;
1321 
1322             e = new SSLSessionBindingEvent(this, key);
1323             ((SSLSessionBindingListener)value).valueUnbound(e);
1324         }
1325         if (protocolVersion.useTLS13PlusSpec()) {
1326             updateNST = true;
1327         }
1328     }
1329 
1330 
1331     /**
1332      * Lists the names of the session values.
1333      */
1334     @Override
1335     public String[] getValueNames() {
1336         ArrayList&lt;Object&gt; v = new ArrayList&lt;&gt;();
1337         Object securityCtx = SecureKey.getCurrentSecurityContext();
1338         for (Enumeration&lt;SecureKey&gt; e = boundValues.keys();
1339                 e.hasMoreElements(); ) {
1340             SecureKey key = e.nextElement();
1341             if (securityCtx.equals(key.getSecurityContext())) {
1342                 v.add(key.getAppKey());
1343             }
1344         }
1345 
1346         return v.toArray(new String[0]);
1347     }
1348 
1349     /**
1350      * Use large packet sizes now or follow RFC 2246 packet sizes (2^14)
1351      * until changed.
1352      *
1353      * In the TLS specification (section 6.2.1, RFC2246), it is not
1354      * recommended that the plaintext has more than 2^14 bytes.
1355      * However, some TLS implementations violate the specification.
1356      * This is a workaround for interoperability with these stacks.
1357      *
1358      * Application could accept large fragments up to 2^15 bytes by
1359      * setting the system property jsse.SSLEngine.acceptLargeFragments
1360      * to &quot;true&quot;.
1361      */
1362     private boolean acceptLargeFragments =
1363             Utilities.getBooleanProperty(
1364                     &quot;jsse.SSLEngine.acceptLargeFragments&quot;, false);
1365 
1366     /**
1367      * Expand the buffer size of both SSL/TLS network packet and
1368      * application data.
1369      */
1370     protected void expandBufferSizes() {
1371         sessionLock.lock();
1372         try {
1373             acceptLargeFragments = true;
1374         } finally {
1375             sessionLock.unlock();
1376         }
1377     }
1378 
1379     /**
1380      * Gets the current size of the largest SSL/TLS packet that is expected
1381      * when using this session.
1382      */
1383     @Override
1384     public int getPacketBufferSize() {
1385         sessionLock.lock();
1386         try {
1387             // Use the bigger packet size calculated from maximumPacketSize
1388             // and negotiatedMaxFragLen.
1389             int packetSize = 0;
1390             if (negotiatedMaxFragLen &gt; 0) {
1391                 packetSize = cipherSuite.calculatePacketSize(
1392                         negotiatedMaxFragLen, protocolVersion,
1393                         protocolVersion.isDTLS);
1394             }
1395 
1396             if (maximumPacketSize &gt; 0) {
1397                 return (maximumPacketSize &gt; packetSize) ?
1398                         maximumPacketSize : packetSize;
1399             }
1400 
1401             if (packetSize != 0) {
1402                return packetSize;
1403             }
1404 
1405             if (protocolVersion.isDTLS) {
1406                 return DTLSRecord.maxRecordSize;
1407             } else {
1408                 return acceptLargeFragments ?
1409                         SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1410             }
1411         } finally {
1412             sessionLock.unlock();
1413         }
1414     }
1415 
1416     /**
1417      * Gets the current size of the largest application data that is
1418      * expected when using this session.
1419      */
1420     @Override
1421     public int getApplicationBufferSize() {
1422         sessionLock.lock();
1423         try {
1424             // Use the bigger fragment size calculated from maximumPacketSize
1425             // and negotiatedMaxFragLen.
1426             int fragmentSize = 0;
1427             if (maximumPacketSize &gt; 0) {
1428                 fragmentSize = cipherSuite.calculateFragSize(
1429                         maximumPacketSize, protocolVersion,
1430                         protocolVersion.isDTLS);
1431             }
1432 
1433             if (negotiatedMaxFragLen &gt; 0) {
1434                 return (negotiatedMaxFragLen &gt; fragmentSize) ?
1435                         negotiatedMaxFragLen : fragmentSize;
1436             }
1437 
1438             if (fragmentSize != 0) {
1439                 return fragmentSize;
1440             }
1441 
1442             if (protocolVersion.isDTLS) {
1443                 return Record.maxDataSize;
1444             } else {
1445                 int maxPacketSize = acceptLargeFragments ?
1446                             SSLRecord.maxLargeRecordSize : SSLRecord.maxRecordSize;
1447                 return (maxPacketSize - SSLRecord.headerSize);
1448             }
1449         } finally {
1450             sessionLock.unlock();
1451         }
1452     }
1453 
1454     /**
1455      * Sets the negotiated maximum fragment length, as specified by the
1456      * max_fragment_length ClientHello extension in RFC 6066.
1457      *
1458      * @param  negotiatedMaxFragLen
1459      *         the negotiated maximum fragment length, or {@code -1} if
1460      *         no such length has been negotiated.
1461      */
1462     void setNegotiatedMaxFragSize(
1463             int negotiatedMaxFragLen) {
1464         sessionLock.lock();
1465         try {
1466             this.negotiatedMaxFragLen = negotiatedMaxFragLen;
1467         } finally {
1468             sessionLock.unlock();
1469         }
1470     }
1471 
1472     /**
1473      * Get the negotiated maximum fragment length, as specified by the
1474      * max_fragment_length ClientHello extension in RFC 6066.
1475      *
1476      * @return the negotiated maximum fragment length, or {@code -1} if
1477      *         no such length has been negotiated.
1478      */
1479     int getNegotiatedMaxFragSize() {
1480         sessionLock.lock();
1481         try {
1482             return negotiatedMaxFragLen;
1483         } finally {
1484             sessionLock.unlock();
1485         }
1486     }
1487 
1488     void setMaximumPacketSize(int maximumPacketSize) {
1489         sessionLock.lock();
1490         try {
1491             this.maximumPacketSize = maximumPacketSize;
1492         } finally {
1493             sessionLock.unlock();
1494         }
1495     }
1496 
1497     int getMaximumPacketSize() {
1498         sessionLock.lock();
1499         try {
1500             return maximumPacketSize;
1501         } finally {
1502             sessionLock.unlock();
1503         }
1504     }
1505 
1506     /**
1507      * Gets an array of supported signature algorithm names that the local
1508      * side is willing to verify.
1509      */
1510     @Override
1511     public String[] getLocalSupportedSignatureAlgorithms() {
1512         return SignatureScheme.getAlgorithmNames(localSupportedSignAlgs);
1513     }
1514 
1515     /**
1516      * Gets an array of supported signature schemes that the local side is
1517      * willing to verify.
1518      */
1519     public Collection&lt;SignatureScheme&gt; getLocalSupportedSignatureSchemes() {
1520         return localSupportedSignAlgs;
1521     }
1522 
1523     /**
1524      * Gets an array of supported signature algorithms that the peer is
1525      * able to verify.
1526      */
1527     @Override
1528     public String[] getPeerSupportedSignatureAlgorithms() {
1529         return SignatureScheme.getAlgorithmNames(peerSupportedSignAlgs);
1530     }
1531 
1532     /**
1533      * Obtains a &lt;code&gt;List&lt;/code&gt; containing all {@link SNIServerName}s
1534      * of the requested Server Name Indication (SNI) extension.
1535      */
1536     @Override
1537     public List&lt;SNIServerName&gt; getRequestedServerNames() {
1538         return requestedServerNames;
1539     }
1540 
1541     /** Returns a string representation of this SSL session */
1542     @Override
1543     public String toString() {
1544         return &quot;Session(&quot; + creationTime + &quot;|&quot; + getCipherSuite() + &quot;)&quot;;
1545     }
1546 }
1547 
1548 /**
1549  * This &quot;struct&quot; class serves as a Hash Key that combines an
1550  * application-specific key and a security context.
1551  */
1552 class SecureKey {
1553     private static final Object     nullObject = new Object();
1554     private final Object            appKey;
1555     private final Object            securityCtx;
1556 
1557     static Object getCurrentSecurityContext() {
1558         SecurityManager sm = System.getSecurityManager();
1559         Object context = null;
1560 
1561         if (sm != null)
1562             context = sm.getSecurityContext();
1563         if (context == null)
1564             context = nullObject;
1565         return context;
1566     }
1567 
1568     SecureKey(Object key) {
1569         this.appKey = key;
1570         this.securityCtx = getCurrentSecurityContext();
1571     }
1572 
1573     Object getAppKey() {
1574         return appKey;
1575     }
1576 
1577     Object getSecurityContext() {
1578         return securityCtx;
1579     }
1580 
1581     @Override
1582     public int hashCode() {
1583         return appKey.hashCode() ^ securityCtx.hashCode();
1584     }
1585 
1586     @Override
1587     public boolean equals(Object o) {
1588         return o instanceof SecureKey &amp;&amp; ((SecureKey)o).appKey.equals(appKey)
1589                         &amp;&amp; ((SecureKey)o).securityCtx.equals(securityCtx);
1590     }
1591 }
    </pre>
  </body>
</html>
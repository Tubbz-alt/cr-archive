<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="ExtendedMasterSecretExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MaxFragExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/KeyShareExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 import java.util.LinkedList;
 35 import java.util.List;
 36 import java.util.Locale;
 37 import java.util.Map;
 38 import javax.net.ssl.SSLProtocolException;
 39 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
 40 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 41 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.util.HexDumpEncoder;
 45 
 46 /**
 47  * Pack of the &quot;key_share&quot; extensions.
 48  */
 49 final class KeyShareExtension {
 50     static final HandshakeProducer chNetworkProducer =
 51             new CHKeyShareProducer();
 52     static final ExtensionConsumer chOnLoadConsumer =
 53             new CHKeyShareConsumer();


 54     static final SSLStringizer chStringizer =
 55             new CHKeyShareStringizer();
 56 
 57     static final HandshakeProducer shNetworkProducer =
 58             new SHKeyShareProducer();
 59     static final ExtensionConsumer shOnLoadConsumer =
 60             new SHKeyShareConsumer();
 61     static final HandshakeAbsence shOnLoadAbsence =
 62             new SHKeyShareAbsence();
 63     static final SSLStringizer shStringizer =
 64             new SHKeyShareStringizer();
 65 
 66     static final HandshakeProducer hrrNetworkProducer =
 67             new HRRKeyShareProducer();
 68     static final ExtensionConsumer hrrOnLoadConsumer =
 69             new HRRKeyShareConsumer();
 70     static final HandshakeProducer hrrNetworkReproducer =
 71             new HRRKeyShareReproducer();
 72     static final SSLStringizer hrrStringizer =
 73             new HRRKeyShareStringizer();
</pre>
<hr />
<pre>
120             HexDumpEncoder hexEncoder = new HexDumpEncoder();
121             Object[] messageFields = {
122                 NamedGroup.nameOf(namedGroupId),
123                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
124             };
125 
126             return messageFormat.format(messageFields);
127         }
128     }
129 
130     /**
131      * The &quot;key_share&quot; extension in a ClientHello handshake message.
132      */
133     static final class CHKeyShareSpec implements SSLExtensionSpec {
134         final List&lt;KeyShareEntry&gt; clientShares;
135 
136         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
137             this.clientShares = clientShares;
138         }
139 
<span class="line-modified">140         private CHKeyShareSpec(ByteBuffer buffer) throws IOException {</span>

141             // struct {
142             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
143             // } KeyShareClientHello;
144             if (buffer.remaining() &lt; 2) {
<span class="line-modified">145                 throw new SSLProtocolException(</span>

146                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">147                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;);</span>
148             }
149 
150             int listLen = Record.getInt16(buffer);
151             if (listLen != buffer.remaining()) {
<span class="line-modified">152                 throw new SSLProtocolException(</span>

153                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">154                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;);</span>
155             }
156 
157             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
158             while (buffer.hasRemaining()) {
159                 int namedGroupId = Record.getInt16(buffer);
160                 byte[] keyExchange = Record.getBytes16(buffer);
161                 if (keyExchange.length == 0) {
<span class="line-modified">162                     throw new SSLProtocolException(</span>
<span class="line-modified">163                         &quot;Invalid key_share extension: empty key_exchange&quot;);</span>

164                 }
165 
166                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
167             }
168 
169             this.clientShares = Collections.unmodifiableList(keyShares);
170         }
171 
172         @Override
173         public String toString() {
174             MessageFormat messageFormat = new MessageFormat(
175                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
176 
177             StringBuilder builder = new StringBuilder(512);
178             for (KeyShareEntry entry : clientShares) {
179                 builder.append(entry.toString());
180             }
181 
182             Object[] messageFields = {
183                 Utilities.indent(builder.toString())
184             };
185 
186             return messageFormat.format(messageFields);
187         }
188     }
189 
190     private static final class CHKeyShareStringizer implements SSLStringizer {
191         @Override
<span class="line-modified">192         public String toString(ByteBuffer buffer) {</span>

193             try {
<span class="line-modified">194                 return (new CHKeyShareSpec(buffer)).toString();</span>
195             } catch (IOException ioe) {
196                 // For debug logging only, so please swallow exceptions.
197                 return ioe.getMessage();
198             }
199         }
200     }
201 
202     /**
203      * Network data producer of the extension in a ClientHello
204      * handshake message.
205      */
206     private static final
207             class CHKeyShareProducer implements HandshakeProducer {
208         // Prevent instantiation of this class.
209         private CHKeyShareProducer() {
210             // blank
211         }
212 
213         @Override
214         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
307             ServerHandshakeContext shc = (ServerHandshakeContext)context;
308 
309             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
310                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
311                     SSLLogger.fine(
312                             &quot;The key_share extension has been loaded&quot;);
313                 }
314                 return;
315             }
316 
317             // Is it a supported and enabled extension?
318             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
319                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
320                     SSLLogger.fine(
321                             &quot;Ignore unavailable key_share extension&quot;);
322                 }
323                 return;     // ignore the extension
324             }
325 
326             // Parse the extension
<span class="line-modified">327             CHKeyShareSpec spec;</span>
<span class="line-removed">328             try {</span>
<span class="line-removed">329                 spec = new CHKeyShareSpec(buffer);</span>
<span class="line-removed">330             } catch (IOException ioe) {</span>
<span class="line-removed">331                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">332             }</span>
<span class="line-removed">333 </span>
334             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
335             for (KeyShareEntry entry : spec.clientShares) {
336                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
337                 if (ng == null || !SupportedGroups.isActivatable(
338                         shc.sslConfig.algorithmConstraints, ng)) {
339                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
340                         SSLLogger.fine(
341                                 &quot;Ignore unsupported named group: &quot; +
342                                 NamedGroup.nameOf(entry.namedGroupId));
343                     }
344                     continue;
345                 }
346 
347                 try {
348                     SSLCredentials kaCred =
349                         ng.decodeCredentials(entry.keyExchange,
350                         shc.algorithmConstraints,
351                         s -&gt; SSLLogger.warning(s));
352                     if (kaCred != null) {
353                         credentials.add(kaCred);
</pre>
<hr />
<pre>
356                     SSLLogger.warning(
357                         &quot;Cannot decode named group: &quot; +
358                         NamedGroup.nameOf(entry.namedGroupId));
359                 }
360             }
361 
362             if (!credentials.isEmpty()) {
363                 shc.handshakeCredentials.addAll(credentials);
364             } else {
365                 // New handshake credentials are required from the client side.
366                 shc.handshakeProducers.put(
367                         SSLHandshake.HELLO_RETRY_REQUEST.id,
368                         SSLHandshake.HELLO_RETRY_REQUEST);
369             }
370 
371             // update the context
372             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
373         }
374     }
375 






























376     /**
377      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
378      */
379     static final class SHKeyShareSpec implements SSLExtensionSpec {
380         final KeyShareEntry serverShare;
381 
382         SHKeyShareSpec(KeyShareEntry serverShare) {
383             this.serverShare = serverShare;
384         }
385 
<span class="line-modified">386         private SHKeyShareSpec(ByteBuffer buffer) throws IOException {</span>

387             // struct {
388             //      KeyShareEntry server_share;
389             // } KeyShareServerHello;
390             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
<span class="line-modified">391                 throw new SSLProtocolException(</span>

392                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">393                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;);</span>
394             }
395 
396             int namedGroupId = Record.getInt16(buffer);
397             byte[] keyExchange = Record.getBytes16(buffer);
398 
399             if (buffer.hasRemaining()) {
<span class="line-modified">400                 throw new SSLProtocolException(</span>
<span class="line-modified">401                     &quot;Invalid key_share extension: unknown extra data&quot;);</span>

402             }
403 
404             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
405         }
406 
407         @Override
408         public String toString() {
409             MessageFormat messageFormat = new MessageFormat(
410                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
411                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
412                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
413                 &quot;{1}\n&quot; +
414                 &quot;  &#39;}&#39;\n&quot; +
415                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
416 
417             HexDumpEncoder hexEncoder = new HexDumpEncoder();
418             Object[] messageFields = {
419                 NamedGroup.nameOf(serverShare.namedGroupId),
420                 Utilities.indent(
421                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
422             };
423 
424             return messageFormat.format(messageFields);
425         }
426     }
427 
428     private static final class SHKeyShareStringizer implements SSLStringizer {
429         @Override
<span class="line-modified">430         public String toString(ByteBuffer buffer) {</span>

431             try {
<span class="line-modified">432                 return (new SHKeyShareSpec(buffer)).toString();</span>
433             } catch (IOException ioe) {
434                 // For debug logging only, so please swallow exceptions.
435                 return ioe.getMessage();
436             }
437         }
438     }
439 
440     /**
441      * Network data producer of the extension in a ServerHello
442      * handshake message.
443      */
444     private static final class SHKeyShareProducer implements HandshakeProducer {
445         // Prevent instantiation of this class.
446         private SHKeyShareProducer() {
447             // blank
448         }
449 
450         @Override
451         public byte[] produce(ConnectionContext context,
452                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
564 
565         @Override
566         public void consume(ConnectionContext context,
567             HandshakeMessage message, ByteBuffer buffer) throws IOException {
568             // Happens in client side only.
569             ClientHandshakeContext chc = (ClientHandshakeContext)context;
570             if (chc.clientRequestedNamedGroups == null ||
571                     chc.clientRequestedNamedGroups.isEmpty()) {
572                 // No supported groups.
573                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
574                         &quot;Unexpected key_share extension in ServerHello&quot;);
575             }
576 
577             // Is it a supported and enabled extension?
578             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
579                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
580                         &quot;Unsupported key_share extension in ServerHello&quot;);
581             }
582 
583             // Parse the extension
<span class="line-modified">584             SHKeyShareSpec spec;</span>
<span class="line-removed">585             try {</span>
<span class="line-removed">586                 spec = new SHKeyShareSpec(buffer);</span>
<span class="line-removed">587             } catch (IOException ioe) {</span>
<span class="line-removed">588                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">589             }</span>
<span class="line-removed">590 </span>
591             KeyShareEntry keyShare = spec.serverShare;
592             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
593             if (ng == null || !SupportedGroups.isActivatable(
594                     chc.sslConfig.algorithmConstraints, ng)) {
595                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
596                         &quot;Unsupported named group: &quot; +
597                         NamedGroup.nameOf(keyShare.namedGroupId));
598             }
599 
600             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
601             if (ke == null) {
602                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
603                         &quot;No key exchange for named group &quot; + ng.name);
604             }
605 
606             SSLCredentials credentials = null;
607             try {
608                 SSLCredentials kaCred = ng.decodeCredentials(
609                     keyShare.keyExchange, chc.algorithmConstraints,
610                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
</pre>
<hr />
<pre>
643             // Cannot use the previous requested key shares any more.
644             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
645                 SSLLogger.fine(
646                         &quot;No key_share extension in ServerHello, &quot; +
647                         &quot;cleanup the key shares if necessary&quot;);
648             }
649             chc.handshakePossessions.clear();
650         }
651     }
652 
653     /**
654      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
655      */
656     static final class HRRKeyShareSpec implements SSLExtensionSpec {
657         final int selectedGroup;
658 
659         HRRKeyShareSpec(NamedGroup serverGroup) {
660             this.selectedGroup = serverGroup.id;
661         }
662 
<span class="line-modified">663         private HRRKeyShareSpec(ByteBuffer buffer) throws IOException {</span>

664             // struct {
665             //     NamedGroup selected_group;
666             // } KeyShareHelloRetryRequest;
667             if (buffer.remaining() != 2) {
<span class="line-modified">668                 throw new SSLProtocolException(</span>

669                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">670                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;);</span>
671             }
672 
673             this.selectedGroup = Record.getInt16(buffer);
674         }
675 
676         @Override
677         public String toString() {
678             MessageFormat messageFormat = new MessageFormat(
679                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
680 
681             Object[] messageFields = {
682                     NamedGroup.nameOf(selectedGroup)
683                 };
684             return messageFormat.format(messageFields);
685         }
686     }
687 
688     private static final class HRRKeyShareStringizer implements SSLStringizer {
689         @Override
<span class="line-modified">690         public String toString(ByteBuffer buffer) {</span>

691             try {
<span class="line-modified">692                 return (new HRRKeyShareSpec(buffer)).toString();</span>
693             } catch (IOException ioe) {
694                 // For debug logging only, so please swallow exceptions.
695                 return ioe.getMessage();
696             }
697         }
698     }
699 
700     /**
701      * Network data producer of the extension in a HelloRetryRequest
702      * handshake message.
703      */
704     private static final
705             class HRRKeyShareProducer implements HandshakeProducer {
706         // Prevent instantiation of this class.
707         private HRRKeyShareProducer() {
708             // blank
709         }
710 
711         @Override
712         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
816         @Override
817         public void consume(ConnectionContext context,
818             HandshakeMessage message, ByteBuffer buffer) throws IOException {
819             // The producing happens in client side only.
820             ClientHandshakeContext chc = (ClientHandshakeContext)context;
821 
822             // Is it a supported and enabled extension?
823             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
824                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
825                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
826             }
827 
828             if (chc.clientRequestedNamedGroups == null ||
829                     chc.clientRequestedNamedGroups.isEmpty()) {
830                 // No supported groups.
831                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
832                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
833             }
834 
835             // Parse the extension
<span class="line-modified">836             HRRKeyShareSpec spec;</span>
<span class="line-removed">837             try {</span>
<span class="line-removed">838                 spec = new HRRKeyShareSpec(buffer);</span>
<span class="line-removed">839             } catch (IOException ioe) {</span>
<span class="line-removed">840                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">841             }</span>
<span class="line-removed">842 </span>
843             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
844             if (serverGroup == null) {
<span class="line-modified">845                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
846                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
847                                 NamedGroup.nameOf(spec.selectedGroup));
848             }
849 
850             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
<span class="line-modified">851                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,</span>
852                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
853                                 serverGroup.name);
854             }
855 
856             // update the context
857 
858             // When sending the new ClientHello, the client MUST replace the
859             // original &quot;key_share&quot; extension with one containing only a new
860             // KeyShareEntry for the group indicated in the selected_group
861             // field of the triggering HelloRetryRequest.
862             //
863             chc.serverSelectedNamedGroup = serverGroup;
864             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
865         }
866     }
867 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 34 import java.util.LinkedList;
 35 import java.util.List;
 36 import java.util.Locale;
 37 import java.util.Map;
 38 import javax.net.ssl.SSLProtocolException;
 39 import sun.security.ssl.KeyShareExtension.CHKeyShareSpec;
 40 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 41 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 42 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 43 import sun.security.ssl.SupportedGroupsExtension.SupportedGroups;
 44 import sun.security.util.HexDumpEncoder;
 45 
 46 /**
 47  * Pack of the &quot;key_share&quot; extensions.
 48  */
 49 final class KeyShareExtension {
 50     static final HandshakeProducer chNetworkProducer =
 51             new CHKeyShareProducer();
 52     static final ExtensionConsumer chOnLoadConsumer =
 53             new CHKeyShareConsumer();
<span class="line-added"> 54     static final HandshakeAbsence chOnTradAbsence =</span>
<span class="line-added"> 55             new CHKeyShareOnTradeAbsence();</span>
 56     static final SSLStringizer chStringizer =
 57             new CHKeyShareStringizer();
 58 
 59     static final HandshakeProducer shNetworkProducer =
 60             new SHKeyShareProducer();
 61     static final ExtensionConsumer shOnLoadConsumer =
 62             new SHKeyShareConsumer();
 63     static final HandshakeAbsence shOnLoadAbsence =
 64             new SHKeyShareAbsence();
 65     static final SSLStringizer shStringizer =
 66             new SHKeyShareStringizer();
 67 
 68     static final HandshakeProducer hrrNetworkProducer =
 69             new HRRKeyShareProducer();
 70     static final ExtensionConsumer hrrOnLoadConsumer =
 71             new HRRKeyShareConsumer();
 72     static final HandshakeProducer hrrNetworkReproducer =
 73             new HRRKeyShareReproducer();
 74     static final SSLStringizer hrrStringizer =
 75             new HRRKeyShareStringizer();
</pre>
<hr />
<pre>
122             HexDumpEncoder hexEncoder = new HexDumpEncoder();
123             Object[] messageFields = {
124                 NamedGroup.nameOf(namedGroupId),
125                 Utilities.indent(hexEncoder.encode(keyExchange), &quot;    &quot;)
126             };
127 
128             return messageFormat.format(messageFields);
129         }
130     }
131 
132     /**
133      * The &quot;key_share&quot; extension in a ClientHello handshake message.
134      */
135     static final class CHKeyShareSpec implements SSLExtensionSpec {
136         final List&lt;KeyShareEntry&gt; clientShares;
137 
138         private CHKeyShareSpec(List&lt;KeyShareEntry&gt; clientShares) {
139             this.clientShares = clientShares;
140         }
141 
<span class="line-modified">142         private CHKeyShareSpec(HandshakeContext handshakeContext,</span>
<span class="line-added">143                 ByteBuffer buffer) throws IOException {</span>
144             // struct {
145             //      KeyShareEntry client_shares&lt;0..2^16-1&gt;;
146             // } KeyShareClientHello;
147             if (buffer.remaining() &lt; 2) {
<span class="line-modified">148                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">149                         new SSLProtocolException(</span>
150                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">151                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));</span>
152             }
153 
154             int listLen = Record.getInt16(buffer);
155             if (listLen != buffer.remaining()) {
<span class="line-modified">156                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">157                         new SSLProtocolException(</span>
158                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">159                     &quot;incorrect list length (length=&quot; + listLen + &quot;)&quot;));</span>
160             }
161 
162             List&lt;KeyShareEntry&gt; keyShares = new LinkedList&lt;&gt;();
163             while (buffer.hasRemaining()) {
164                 int namedGroupId = Record.getInt16(buffer);
165                 byte[] keyExchange = Record.getBytes16(buffer);
166                 if (keyExchange.length == 0) {
<span class="line-modified">167                     throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">168                             new SSLProtocolException(</span>
<span class="line-added">169                         &quot;Invalid key_share extension: empty key_exchange&quot;));</span>
170                 }
171 
172                 keyShares.add(new KeyShareEntry(namedGroupId, keyExchange));
173             }
174 
175             this.clientShares = Collections.unmodifiableList(keyShares);
176         }
177 
178         @Override
179         public String toString() {
180             MessageFormat messageFormat = new MessageFormat(
181                 &quot;\&quot;client_shares\&quot;: &#39;[&#39;{0}\n&#39;]&#39;&quot;, Locale.ENGLISH);
182 
183             StringBuilder builder = new StringBuilder(512);
184             for (KeyShareEntry entry : clientShares) {
185                 builder.append(entry.toString());
186             }
187 
188             Object[] messageFields = {
189                 Utilities.indent(builder.toString())
190             };
191 
192             return messageFormat.format(messageFields);
193         }
194     }
195 
196     private static final class CHKeyShareStringizer implements SSLStringizer {
197         @Override
<span class="line-modified">198         public String toString(</span>
<span class="line-added">199                 HandshakeContext handshakeContext, ByteBuffer buffer) {</span>
200             try {
<span class="line-modified">201                 return (new CHKeyShareSpec(handshakeContext, buffer)).toString();</span>
202             } catch (IOException ioe) {
203                 // For debug logging only, so please swallow exceptions.
204                 return ioe.getMessage();
205             }
206         }
207     }
208 
209     /**
210      * Network data producer of the extension in a ClientHello
211      * handshake message.
212      */
213     private static final
214             class CHKeyShareProducer implements HandshakeProducer {
215         // Prevent instantiation of this class.
216         private CHKeyShareProducer() {
217             // blank
218         }
219 
220         @Override
221         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
314             ServerHandshakeContext shc = (ServerHandshakeContext)context;
315 
316             if (shc.handshakeExtensions.containsKey(SSLExtension.CH_KEY_SHARE)) {
317                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
318                     SSLLogger.fine(
319                             &quot;The key_share extension has been loaded&quot;);
320                 }
321                 return;
322             }
323 
324             // Is it a supported and enabled extension?
325             if (!shc.sslConfig.isAvailable(SSLExtension.CH_KEY_SHARE)) {
326                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
327                     SSLLogger.fine(
328                             &quot;Ignore unavailable key_share extension&quot;);
329                 }
330                 return;     // ignore the extension
331             }
332 
333             // Parse the extension
<span class="line-modified">334             CHKeyShareSpec spec = new CHKeyShareSpec(shc, buffer);</span>






335             List&lt;SSLCredentials&gt; credentials = new LinkedList&lt;&gt;();
336             for (KeyShareEntry entry : spec.clientShares) {
337                 NamedGroup ng = NamedGroup.valueOf(entry.namedGroupId);
338                 if (ng == null || !SupportedGroups.isActivatable(
339                         shc.sslConfig.algorithmConstraints, ng)) {
340                     if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
341                         SSLLogger.fine(
342                                 &quot;Ignore unsupported named group: &quot; +
343                                 NamedGroup.nameOf(entry.namedGroupId));
344                     }
345                     continue;
346                 }
347 
348                 try {
349                     SSLCredentials kaCred =
350                         ng.decodeCredentials(entry.keyExchange,
351                         shc.algorithmConstraints,
352                         s -&gt; SSLLogger.warning(s));
353                     if (kaCred != null) {
354                         credentials.add(kaCred);
</pre>
<hr />
<pre>
357                     SSLLogger.warning(
358                         &quot;Cannot decode named group: &quot; +
359                         NamedGroup.nameOf(entry.namedGroupId));
360                 }
361             }
362 
363             if (!credentials.isEmpty()) {
364                 shc.handshakeCredentials.addAll(credentials);
365             } else {
366                 // New handshake credentials are required from the client side.
367                 shc.handshakeProducers.put(
368                         SSLHandshake.HELLO_RETRY_REQUEST.id,
369                         SSLHandshake.HELLO_RETRY_REQUEST);
370             }
371 
372             // update the context
373             shc.handshakeExtensions.put(SSLExtension.CH_KEY_SHARE, spec);
374         }
375     }
376 
<span class="line-added">377     /**</span>
<span class="line-added">378      * The absence processing if the extension is not present in</span>
<span class="line-added">379      * a ClientHello handshake message.</span>
<span class="line-added">380      */</span>
<span class="line-added">381     private static final class CHKeyShareOnTradeAbsence</span>
<span class="line-added">382             implements HandshakeAbsence {</span>
<span class="line-added">383         @Override</span>
<span class="line-added">384         public void absent(ConnectionContext context,</span>
<span class="line-added">385                 HandshakeMessage message) throws IOException {</span>
<span class="line-added">386             // The producing happens in server side only.</span>
<span class="line-added">387             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>
<span class="line-added">388 </span>
<span class="line-added">389             // A client is considered to be attempting to negotiate using this</span>
<span class="line-added">390             // specification if the ClientHello contains a &quot;supported_versions&quot;</span>
<span class="line-added">391             // extension with 0x0304 contained in its body.  Such a ClientHello</span>
<span class="line-added">392             // message MUST meet the following requirements:</span>
<span class="line-added">393             //    -  If containing a &quot;supported_groups&quot; extension, it MUST also</span>
<span class="line-added">394             //       contain a &quot;key_share&quot; extension, and vice versa.  An empty</span>
<span class="line-added">395             //       KeyShare.client_shares vector is permitted.</span>
<span class="line-added">396             if (shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">397                     shc.handshakeExtensions.containsKey(</span>
<span class="line-added">398                             SSLExtension.CH_SUPPORTED_GROUPS)) {</span>
<span class="line-added">399                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,</span>
<span class="line-added">400                         &quot;No key_share extension to work with &quot; +</span>
<span class="line-added">401                         &quot;the supported_groups extension&quot;);</span>
<span class="line-added">402             }</span>
<span class="line-added">403         }</span>
<span class="line-added">404     }</span>
<span class="line-added">405 </span>
<span class="line-added">406 </span>
407     /**
408      * The key share entry used in ServerHello &quot;key_share&quot; extensions.
409      */
410     static final class SHKeyShareSpec implements SSLExtensionSpec {
411         final KeyShareEntry serverShare;
412 
413         SHKeyShareSpec(KeyShareEntry serverShare) {
414             this.serverShare = serverShare;
415         }
416 
<span class="line-modified">417         private SHKeyShareSpec(HandshakeContext handshakeContext,</span>
<span class="line-added">418                 ByteBuffer buffer) throws IOException {</span>
419             // struct {
420             //      KeyShareEntry server_share;
421             // } KeyShareServerHello;
422             if (buffer.remaining() &lt; 5) {       // 5: minimal server_share
<span class="line-modified">423                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">424                         new SSLProtocolException(</span>
425                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">426                     &quot;insufficient data (length=&quot; + buffer.remaining() + &quot;)&quot;));</span>
427             }
428 
429             int namedGroupId = Record.getInt16(buffer);
430             byte[] keyExchange = Record.getBytes16(buffer);
431 
432             if (buffer.hasRemaining()) {
<span class="line-modified">433                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">434                         new SSLProtocolException(</span>
<span class="line-added">435                     &quot;Invalid key_share extension: unknown extra data&quot;));</span>
436             }
437 
438             this.serverShare = new KeyShareEntry(namedGroupId, keyExchange);
439         }
440 
441         @Override
442         public String toString() {
443             MessageFormat messageFormat = new MessageFormat(
444                 &quot;\&quot;server_share\&quot;: &#39;{&#39;\n&quot; +
445                 &quot;  \&quot;named group\&quot;: {0}\n&quot; +
446                 &quot;  \&quot;key_exchange\&quot;: &#39;{&#39;\n&quot; +
447                 &quot;{1}\n&quot; +
448                 &quot;  &#39;}&#39;\n&quot; +
449                 &quot;&#39;}&#39;,&quot;, Locale.ENGLISH);
450 
451             HexDumpEncoder hexEncoder = new HexDumpEncoder();
452             Object[] messageFields = {
453                 NamedGroup.nameOf(serverShare.namedGroupId),
454                 Utilities.indent(
455                         hexEncoder.encode(serverShare.keyExchange), &quot;    &quot;)
456             };
457 
458             return messageFormat.format(messageFields);
459         }
460     }
461 
462     private static final class SHKeyShareStringizer implements SSLStringizer {
463         @Override
<span class="line-modified">464         public String toString(HandshakeContext handshakeContext,</span>
<span class="line-added">465                 ByteBuffer buffer) {</span>
466             try {
<span class="line-modified">467                 return (new SHKeyShareSpec(handshakeContext, buffer)).toString();</span>
468             } catch (IOException ioe) {
469                 // For debug logging only, so please swallow exceptions.
470                 return ioe.getMessage();
471             }
472         }
473     }
474 
475     /**
476      * Network data producer of the extension in a ServerHello
477      * handshake message.
478      */
479     private static final class SHKeyShareProducer implements HandshakeProducer {
480         // Prevent instantiation of this class.
481         private SHKeyShareProducer() {
482             // blank
483         }
484 
485         @Override
486         public byte[] produce(ConnectionContext context,
487                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
599 
600         @Override
601         public void consume(ConnectionContext context,
602             HandshakeMessage message, ByteBuffer buffer) throws IOException {
603             // Happens in client side only.
604             ClientHandshakeContext chc = (ClientHandshakeContext)context;
605             if (chc.clientRequestedNamedGroups == null ||
606                     chc.clientRequestedNamedGroups.isEmpty()) {
607                 // No supported groups.
608                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
609                         &quot;Unexpected key_share extension in ServerHello&quot;);
610             }
611 
612             // Is it a supported and enabled extension?
613             if (!chc.sslConfig.isAvailable(SSLExtension.SH_KEY_SHARE)) {
614                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
615                         &quot;Unsupported key_share extension in ServerHello&quot;);
616             }
617 
618             // Parse the extension
<span class="line-modified">619             SHKeyShareSpec spec = new SHKeyShareSpec(chc, buffer);</span>






620             KeyShareEntry keyShare = spec.serverShare;
621             NamedGroup ng = NamedGroup.valueOf(keyShare.namedGroupId);
622             if (ng == null || !SupportedGroups.isActivatable(
623                     chc.sslConfig.algorithmConstraints, ng)) {
624                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
625                         &quot;Unsupported named group: &quot; +
626                         NamedGroup.nameOf(keyShare.namedGroupId));
627             }
628 
629             SSLKeyExchange ke = SSLKeyExchange.valueOf(ng);
630             if (ke == null) {
631                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
632                         &quot;No key exchange for named group &quot; + ng.name);
633             }
634 
635             SSLCredentials credentials = null;
636             try {
637                 SSLCredentials kaCred = ng.decodeCredentials(
638                     keyShare.keyExchange, chc.algorithmConstraints,
639                     s -&gt; chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, s));
</pre>
<hr />
<pre>
672             // Cannot use the previous requested key shares any more.
673             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;handshake&quot;)) {
674                 SSLLogger.fine(
675                         &quot;No key_share extension in ServerHello, &quot; +
676                         &quot;cleanup the key shares if necessary&quot;);
677             }
678             chc.handshakePossessions.clear();
679         }
680     }
681 
682     /**
683      * The key share entry used in HelloRetryRequest &quot;key_share&quot; extensions.
684      */
685     static final class HRRKeyShareSpec implements SSLExtensionSpec {
686         final int selectedGroup;
687 
688         HRRKeyShareSpec(NamedGroup serverGroup) {
689             this.selectedGroup = serverGroup.id;
690         }
691 
<span class="line-modified">692         private HRRKeyShareSpec(HandshakeContext handshakeContext,</span>
<span class="line-added">693                 ByteBuffer buffer) throws IOException {</span>
694             // struct {
695             //     NamedGroup selected_group;
696             // } KeyShareHelloRetryRequest;
697             if (buffer.remaining() != 2) {
<span class="line-modified">698                 throw handshakeContext.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">699                         new SSLProtocolException(</span>
700                     &quot;Invalid key_share extension: &quot; +
<span class="line-modified">701                     &quot;improper data (length=&quot; + buffer.remaining() + &quot;)&quot;));</span>
702             }
703 
704             this.selectedGroup = Record.getInt16(buffer);
705         }
706 
707         @Override
708         public String toString() {
709             MessageFormat messageFormat = new MessageFormat(
710                 &quot;\&quot;selected group\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
711 
712             Object[] messageFields = {
713                     NamedGroup.nameOf(selectedGroup)
714                 };
715             return messageFormat.format(messageFields);
716         }
717     }
718 
719     private static final class HRRKeyShareStringizer implements SSLStringizer {
720         @Override
<span class="line-modified">721         public String toString(HandshakeContext handshakeContext,</span>
<span class="line-added">722                 ByteBuffer buffer) {</span>
723             try {
<span class="line-modified">724                 return (new HRRKeyShareSpec(handshakeContext, buffer)).toString();</span>
725             } catch (IOException ioe) {
726                 // For debug logging only, so please swallow exceptions.
727                 return ioe.getMessage();
728             }
729         }
730     }
731 
732     /**
733      * Network data producer of the extension in a HelloRetryRequest
734      * handshake message.
735      */
736     private static final
737             class HRRKeyShareProducer implements HandshakeProducer {
738         // Prevent instantiation of this class.
739         private HRRKeyShareProducer() {
740             // blank
741         }
742 
743         @Override
744         public byte[] produce(ConnectionContext context,
</pre>
<hr />
<pre>
848         @Override
849         public void consume(ConnectionContext context,
850             HandshakeMessage message, ByteBuffer buffer) throws IOException {
851             // The producing happens in client side only.
852             ClientHandshakeContext chc = (ClientHandshakeContext)context;
853 
854             // Is it a supported and enabled extension?
855             if (!chc.sslConfig.isAvailable(SSLExtension.HRR_KEY_SHARE)) {
856                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
857                         &quot;Unsupported key_share extension in HelloRetryRequest&quot;);
858             }
859 
860             if (chc.clientRequestedNamedGroups == null ||
861                     chc.clientRequestedNamedGroups.isEmpty()) {
862                 // No supported groups.
863                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
864                         &quot;Unexpected key_share extension in HelloRetryRequest&quot;);
865             }
866 
867             // Parse the extension
<span class="line-modified">868             HRRKeyShareSpec spec = new HRRKeyShareSpec(chc, buffer);</span>






869             NamedGroup serverGroup = NamedGroup.valueOf(spec.selectedGroup);
870             if (serverGroup == null) {
<span class="line-modified">871                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
872                         &quot;Unsupported HelloRetryRequest selected group: &quot; +
873                                 NamedGroup.nameOf(spec.selectedGroup));
874             }
875 
876             if (!chc.clientRequestedNamedGroups.contains(serverGroup)) {
<span class="line-modified">877                 throw chc.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
878                         &quot;Unexpected HelloRetryRequest selected group: &quot; +
879                                 serverGroup.name);
880             }
881 
882             // update the context
883 
884             // When sending the new ClientHello, the client MUST replace the
885             // original &quot;key_share&quot; extension with one containing only a new
886             // KeyShareEntry for the group indicated in the selected_group
887             // field of the triggering HelloRetryRequest.
888             //
889             chc.serverSelectedNamedGroup = serverGroup;
890             chc.handshakeExtensions.put(SSLExtension.HRR_KEY_SHARE, spec);
891         }
892     }
893 }
</pre>
</td>
</tr>
</table>
<center><a href="ExtendedMasterSecretExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="MaxFragExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
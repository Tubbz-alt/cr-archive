diff a/src/java.base/share/classes/sun/security/ssl/RenegoInfoExtension.java b/src/java.base/share/classes/sun/security/ssl/RenegoInfoExtension.java
--- a/src/java.base/share/classes/sun/security/ssl/RenegoInfoExtension.java
+++ b/src/java.base/share/classes/sun/security/ssl/RenegoInfoExtension.java
@@ -1,7 +1,7 @@
 /*
- * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.
+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.
  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  *
  * This code is free software; you can redistribute it and/or modify it
  * under the terms of the GNU General Public License version 2 only, as
  * published by the Free Software Foundation.  Oracle designates this
@@ -72,16 +72,18 @@
         private RenegotiationInfoSpec(byte[] renegotiatedConnection) {
             this.renegotiatedConnection = Arrays.copyOf(
                     renegotiatedConnection, renegotiatedConnection.length);
         }
 
-        private RenegotiationInfoSpec(ByteBuffer m) throws IOException {
+        private RenegotiationInfoSpec(HandshakeContext hc,
+                ByteBuffer m) throws IOException {
             // Parse the extension.
             if (!m.hasRemaining() || m.remaining() < 1) {
-                throw new SSLProtocolException(
+                throw hc.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
                     "Invalid renegotiation_info extension data: " +
-                    "insufficient data");
+                    "insufficient data"));
             }
             this.renegotiatedConnection = Record.getBytes8(m);
         }
 
         @Override
@@ -103,13 +105,13 @@
     }
 
     private static final
             class RenegotiationInfoStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(HandshakeContext hc, ByteBuffer buffer) {
             try {
-                return (new RenegotiationInfoSpec(buffer)).toString();
+                return (new RenegotiationInfoSpec(hc, buffer)).toString();
             } catch (IOException ioe) {
                 // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
@@ -218,17 +220,11 @@
                 }
                 return;     // ignore the extension
             }
 
             // Parse the extension.
-            RenegotiationInfoSpec spec;
-            try {
-                spec = new RenegotiationInfoSpec(buffer);
-            } catch (IOException ioe) {
-                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
-
+            RenegotiationInfoSpec spec = new RenegotiationInfoSpec(shc, buffer);
             if (!shc.conContext.isNegotiated) {
                 // initial handshaking.
                 if (spec.renegotiatedConnection.length != 0) {
                     throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
                         "Invalid renegotiation_info extension data: not empty");
@@ -431,18 +427,11 @@
                     "Missing renegotiation_info and SCSV detected in " +
                     "ClientHello");
             }
 
             // Parse the extension.
-            RenegotiationInfoSpec spec;
-            try {
-                spec = new RenegotiationInfoSpec(buffer);
-            } catch (IOException ioe) {
-                throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
-
-
+            RenegotiationInfoSpec spec = new RenegotiationInfoSpec(chc, buffer);
             if (!chc.conContext.isNegotiated) {     // initial handshake
                 // If the extension is present, set the secure_renegotiation
                 // flag to TRUE.  The client MUST then verify that the
                 // length of the "renegotiated_connection" field is zero,
                 // and if it is not, MUST abort the handshake (by sending

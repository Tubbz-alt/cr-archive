<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="MaxFragExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PskKeyExchangeModesExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/PreSharedKeyExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;

 39 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 40 import sun.security.ssl.ClientHello.ClientHelloMessage;
 41 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 42 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 43 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 44 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 45 import sun.security.util.HexDumpEncoder;
 46 
 47 import static sun.security.ssl.SSLExtension.*;
 48 
 49 /**
 50  * Pack of the &quot;pre_shared_key&quot; extension.
 51  */
 52 final class PreSharedKeyExtension {
 53     static final HandshakeProducer chNetworkProducer =
 54             new CHPreSharedKeyProducer();
 55     static final ExtensionConsumer chOnLoadConsumer =
 56             new CHPreSharedKeyConsumer();
 57     static final HandshakeAbsence chOnLoadAbsence =
<span class="line-modified"> 58             new CHPreSharedKeyAbsence();</span>
 59     static final HandshakeConsumer chOnTradeConsumer =
 60             new CHPreSharedKeyUpdate();


 61     static final SSLStringizer chStringizer =
 62             new CHPreSharedKeyStringizer();
 63 
 64     static final HandshakeProducer shNetworkProducer =
 65             new SHPreSharedKeyProducer();
 66     static final ExtensionConsumer shOnLoadConsumer =
 67             new SHPreSharedKeyConsumer();
 68     static final HandshakeAbsence shOnLoadAbsence =
 69             new SHPreSharedKeyAbsence();
 70     static final SSLStringizer shStringizer =
 71             new SHPreSharedKeyStringizer();
 72 
 73     private static final class PskIdentity {
 74         final byte[] identity;
 75         final int obfuscatedAge;
 76 
 77         PskIdentity(byte[] identity, int obfuscatedAge) {
 78             this.identity = identity;
 79             this.obfuscatedAge = obfuscatedAge;
 80         }
</pre>
<hr />
<pre>
 88             Record.putInt32(m, obfuscatedAge);
 89         }
 90 
 91         @Override
 92         public String toString() {
 93             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +
 94                 obfuscatedAge + &quot;}&quot;;
 95         }
 96     }
 97 
 98     private static final
 99             class CHPreSharedKeySpec implements SSLExtensionSpec {
100         final List&lt;PskIdentity&gt; identities;
101         final List&lt;byte[]&gt; binders;
102 
103         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
104             this.identities = identities;
105             this.binders = binders;
106         }
107 
<span class="line-modified">108         CHPreSharedKeySpec(HandshakeContext context,</span>
109                 ByteBuffer m) throws IOException {
110             // struct {
111             //     PskIdentity identities&lt;7..2^16-1&gt;;
112             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
113             // } OfferedPsks;
114             if (m.remaining() &lt; 44) {
<span class="line-modified">115                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

116                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">117                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;);</span>
118             }
119 
120             int idEncodedLength = Record.getInt16(m);
121             if (idEncodedLength &lt; 7) {
<span class="line-modified">122                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

123                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">124                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;);</span>
125             }
126 
127             identities = new ArrayList&lt;&gt;();
128             int idReadLength = 0;
129             while (idReadLength &lt; idEncodedLength) {
130                 byte[] id = Record.getBytes16(m);
131                 if (id.length &lt; 1) {
<span class="line-modified">132                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>

133                         &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">134                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;);</span>
135                 }
136                 int obfuscatedTicketAge = Record.getInt32(m);
137 
138                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
139                 identities.add(pskId);
140                 idReadLength += pskId.getEncodedLength();
141             }
142 
143             if (m.remaining() &lt; 35) {
<span class="line-modified">144                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">145                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">146                         &quot;insufficient binders data (length=&quot; +</span>
<span class="line-modified">147                         m.remaining() + &quot;)&quot;);</span>

148             }
149 
150             int bindersEncodedLen = Record.getInt16(m);
151             if (bindersEncodedLen &lt; 33) {
<span class="line-modified">152                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">153                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">154                         &quot;insufficient binders (length=&quot; +</span>
<span class="line-modified">155                         bindersEncodedLen + &quot;)&quot;);</span>

156             }
157 
158             binders = new ArrayList&lt;&gt;();
159             int bindersReadLength = 0;
160             while (bindersReadLength &lt; bindersEncodedLen) {
161                 byte[] binder = Record.getBytes8(m);
162                 if (binder.length &lt; 32) {
<span class="line-modified">163                     throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">164                             &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">165                             &quot;insufficient binder entry (length=&quot; +</span>
<span class="line-modified">166                             binder.length + &quot;)&quot;);</span>

167                 }
168                 binders.add(binder);
169                 bindersReadLength += 1 + binder.length;
170             }
171         }
172 
173         int getIdsEncodedLength() {
174             int idEncodedLength = 0;
175             for (PskIdentity curId : identities) {
176                 idEncodedLength += curId.getEncodedLength();
177             }
178 
179             return idEncodedLength;
180         }
181 
182         int getBindersEncodedLength() {
183             int binderEncodedLength = 0;
184             for (byte[] curBinder : binders) {
185                 binderEncodedLength += 1 + curBinder.length;
186             }
</pre>
<hr />
<pre>
234                         hexEncoder.encode(curId.identity), &quot;    &quot;) +
235                         &quot;\n  }\n&quot;);
236             }
237 
238             return result.toString();
239         }
240 
241         String bindersString() {
242             StringBuilder result = new StringBuilder();
243             for (byte[] curBinder : binders) {
244                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
245             }
246 
247             return result.toString();
248         }
249     }
250 
251     private static final
252             class CHPreSharedKeyStringizer implements SSLStringizer {
253         @Override
<span class="line-modified">254         public String toString(ByteBuffer buffer) {</span>
255             try {
<span class="line-modified">256                 // As the HandshakeContext parameter of CHPreSharedKeySpec</span>
<span class="line-removed">257                 // constructor is used for fatal alert only, we can use</span>
<span class="line-removed">258                 // null HandshakeContext here as we don&#39;t care about exception.</span>
<span class="line-removed">259                 //</span>
<span class="line-removed">260                 // Please take care of this code if the CHPreSharedKeySpec</span>
<span class="line-removed">261                 // constructor is updated in the future.</span>
<span class="line-removed">262                 return (new CHPreSharedKeySpec(null, buffer)).toString();</span>
263             } catch (Exception ex) {
264                 // For debug logging only, so please swallow exceptions.
265                 return ex.getMessage();
266             }
267         }
268     }
269 
270     private static final
271             class SHPreSharedKeySpec implements SSLExtensionSpec {
272         final int selectedIdentity;
273 
274         SHPreSharedKeySpec(int selectedIdentity) {
275             this.selectedIdentity = selectedIdentity;
276         }
277 
<span class="line-modified">278         SHPreSharedKeySpec(HandshakeContext context,</span>
279                 ByteBuffer m) throws IOException {
280             if (m.remaining() &lt; 2) {
<span class="line-modified">281                 throw context.conContext.fatal(Alert.ILLEGAL_PARAMETER,</span>
<span class="line-modified">282                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">283                         &quot;insufficient selected_identity (length=&quot; +</span>
<span class="line-modified">284                         m.remaining() + &quot;)&quot;);</span>

285             }
286             this.selectedIdentity = Record.getInt16(m);
287         }
288 
289         byte[] getEncoded() {
290             return new byte[] {
291                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
292                 (byte)(selectedIdentity &amp; 0xFF)
293             };
294         }
295 
296         @Override
297         public String toString() {
298             MessageFormat messageFormat = new MessageFormat(
299                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
300                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
301                 &quot;&#39;}&#39;&quot;,
302                 Locale.ENGLISH);
303 
304             Object[] messageFields = {
305                 Utilities.byte16HexString(selectedIdentity)
306             };
307 
308             return messageFormat.format(messageFields);
309         }
310     }
311 
312     private static final
313             class SHPreSharedKeyStringizer implements SSLStringizer {
314         @Override
<span class="line-modified">315         public String toString(ByteBuffer buffer) {</span>
316             try {
<span class="line-modified">317                 // As the HandshakeContext parameter of SHPreSharedKeySpec</span>
<span class="line-removed">318                 // constructor is used for fatal alert only, we can use</span>
<span class="line-removed">319                 // null HandshakeContext here as we don&#39;t care about exception.</span>
<span class="line-removed">320                 //</span>
<span class="line-removed">321                 // Please take care of this code if the SHPreSharedKeySpec</span>
<span class="line-removed">322                 // constructor is updated in the future.</span>
<span class="line-removed">323                 return (new SHPreSharedKeySpec(null, buffer)).toString();</span>
324             } catch (Exception ex) {
325                 // For debug logging only, so please swallow exceptions.
326                 return ex.getMessage();
327             }
328         }
329     }
330 
331     private static final
332             class CHPreSharedKeyConsumer implements ExtensionConsumer {
333         // Prevent instantiation of this class.
334         private CHPreSharedKeyConsumer() {
335             // blank
336         }
337 
338         @Override
339         public void consume(ConnectionContext context,
340                             HandshakeMessage message,
341                             ByteBuffer buffer) throws IOException {
342             ClientHelloMessage clientHello = (ClientHelloMessage) message;
343             ServerHandshakeContext shc = (ServerHandshakeContext)context;
344             // Is it a supported and enabled extension?
345             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
346                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
347                     SSLLogger.fine(
348                             &quot;Ignore unavailable pre_shared_key extension&quot;);
349                 }
350                 return;     // ignore the extension
351             }
352 
353             // Parse the extension.
<span class="line-modified">354             CHPreSharedKeySpec pskSpec = null;</span>
<span class="line-removed">355             try {</span>
<span class="line-removed">356                 pskSpec = new CHPreSharedKeySpec(shc, buffer);</span>
<span class="line-removed">357             } catch (IOException ioe) {</span>
<span class="line-removed">358                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">359             }</span>
360 
361             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
362             if (!shc.handshakeExtensions.containsKey(
363                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
366                         &quot;extension is not the last extension&quot;);
367             }
368 
369             // error if id and binder lists are not the same length
370             if (pskSpec.identities.size() != pskSpec.binders.size()) {
371                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
372                         &quot;PSK extension has incorrect number of binders&quot;);
373             }
374 
375             if (shc.isResumption) {     // resumingSession may not be set
376                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
377                         shc.sslContext.engineGetServerSessionContext();
378                 int idIndex = 0;
379                 SSLSessionImpl s = null;
380 
381                 for (PskIdentity requestedId : pskSpec.identities) {
382                     // If we are keeping state, see if the identity is in the cache
383                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {
384                         s = sessionCache.get(requestedId.identity);
385                     }
386                     // See if the identity is a stateless ticket
387                     if (s == null &amp;&amp;
388                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
389                             sessionCache.statelessEnabled()) {
390                         ByteBuffer b =
<span class="line-modified">391                                 new SessionTicketSpec(requestedId.identity).</span>
392                                         decrypt(shc);
393                         if (b != null) {
394                             try {
395                                 s = new SSLSessionImpl(shc, b);
396                             } catch (IOException | RuntimeException e) {
397                                 s = null;
398                             }
399                         }
400                         if (b == null || s == null) {
401                             if (SSLLogger.isOn &amp;&amp;
402                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
403                                 SSLLogger.fine(
404                                         &quot;Stateless session ticket invalid&quot;);
405                             }
406                         }
407                     }
408 
409                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
410                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
411                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
</pre>
<hr />
<pre>
814     private static SecretKey deriveBinderKey(HandshakeContext context,
815             SecretKey psk, SSLSessionImpl session) throws IOException {
816         try {
817             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
818             HKDF hkdf = new HKDF(hashAlg.name);
819             byte[] zeros = new byte[hashAlg.hashLength];
820             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
821 
822             byte[] label = (&quot;tls13 res binder&quot;).getBytes();
823             MessageDigest md = MessageDigest.getInstance(hashAlg.name);
824             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
825                     label, md.digest(new byte[0]), hashAlg.hashLength);
826             return hkdf.expand(earlySecret,
827                     hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
828         } catch (GeneralSecurityException ex) {
829             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
830         }
831     }
832 
833     private static final
<span class="line-modified">834             class CHPreSharedKeyAbsence implements HandshakeAbsence {</span>
835         @Override
836         public void absent(ConnectionContext context,
837                            HandshakeMessage message) throws IOException {
838 
839             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
840                 SSLLogger.fine(
841                 &quot;Handling pre_shared_key absence.&quot;);
842             }
843 
844             ServerHandshakeContext shc = (ServerHandshakeContext)context;
845 
846             // Resumption is only determined by PSK, when enabled
847             shc.resumingSession = null;
848             shc.isResumption = false;
849         }
850     }
851 































852     private static final
853             class SHPreSharedKeyConsumer implements ExtensionConsumer {
854         // Prevent instantiation of this class.
855         private SHPreSharedKeyConsumer() {
856             // blank
857         }
858 
859         @Override
860         public void consume(ConnectionContext context,
861             HandshakeMessage message, ByteBuffer buffer) throws IOException {
862             // The consuming happens in client side only.
863             ClientHandshakeContext chc = (ClientHandshakeContext)context;
864 
865             // Is it a response of the specific request?
866             if (!chc.handshakeExtensions.containsKey(
867                     SSLExtension.CH_PRE_SHARED_KEY)) {
868                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
869                     &quot;Server sent unexpected pre_shared_key extension&quot;);
870             }
871 
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 package sun.security.ssl;
 26 
 27 import java.io.IOException;
 28 import java.nio.ByteBuffer;
 29 import java.security.*;
 30 import java.text.MessageFormat;
 31 import java.util.List;
 32 import java.util.ArrayList;
 33 import java.util.Locale;
 34 import java.util.Arrays;
 35 import java.util.Collection;
 36 import javax.crypto.Mac;
 37 import javax.crypto.SecretKey;
 38 import javax.net.ssl.SSLPeerUnverifiedException;
<span class="line-added"> 39 import javax.net.ssl.SSLProtocolException;</span>
 40 import static sun.security.ssl.ClientAuthType.CLIENT_AUTH_REQUIRED;
 41 import sun.security.ssl.ClientHello.ClientHelloMessage;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 import sun.security.ssl.SessionTicketExtension.SessionTicketSpec;
 46 import sun.security.util.HexDumpEncoder;
 47 
 48 import static sun.security.ssl.SSLExtension.*;
 49 
 50 /**
 51  * Pack of the &quot;pre_shared_key&quot; extension.
 52  */
 53 final class PreSharedKeyExtension {
 54     static final HandshakeProducer chNetworkProducer =
 55             new CHPreSharedKeyProducer();
 56     static final ExtensionConsumer chOnLoadConsumer =
 57             new CHPreSharedKeyConsumer();
 58     static final HandshakeAbsence chOnLoadAbsence =
<span class="line-modified"> 59             new CHPreSharedKeyOnLoadAbsence();</span>
 60     static final HandshakeConsumer chOnTradeConsumer =
 61             new CHPreSharedKeyUpdate();
<span class="line-added"> 62     static final HandshakeAbsence chOnTradAbsence =</span>
<span class="line-added"> 63             new CHPreSharedKeyOnTradeAbsence();</span>
 64     static final SSLStringizer chStringizer =
 65             new CHPreSharedKeyStringizer();
 66 
 67     static final HandshakeProducer shNetworkProducer =
 68             new SHPreSharedKeyProducer();
 69     static final ExtensionConsumer shOnLoadConsumer =
 70             new SHPreSharedKeyConsumer();
 71     static final HandshakeAbsence shOnLoadAbsence =
 72             new SHPreSharedKeyAbsence();
 73     static final SSLStringizer shStringizer =
 74             new SHPreSharedKeyStringizer();
 75 
 76     private static final class PskIdentity {
 77         final byte[] identity;
 78         final int obfuscatedAge;
 79 
 80         PskIdentity(byte[] identity, int obfuscatedAge) {
 81             this.identity = identity;
 82             this.obfuscatedAge = obfuscatedAge;
 83         }
</pre>
<hr />
<pre>
 91             Record.putInt32(m, obfuscatedAge);
 92         }
 93 
 94         @Override
 95         public String toString() {
 96             return &quot;{&quot; + Utilities.toHexString(identity) + &quot;, &quot; +
 97                 obfuscatedAge + &quot;}&quot;;
 98         }
 99     }
100 
101     private static final
102             class CHPreSharedKeySpec implements SSLExtensionSpec {
103         final List&lt;PskIdentity&gt; identities;
104         final List&lt;byte[]&gt; binders;
105 
106         CHPreSharedKeySpec(List&lt;PskIdentity&gt; identities, List&lt;byte[]&gt; binders) {
107             this.identities = identities;
108             this.binders = binders;
109         }
110 
<span class="line-modified">111         CHPreSharedKeySpec(HandshakeContext hc,</span>
112                 ByteBuffer m) throws IOException {
113             // struct {
114             //     PskIdentity identities&lt;7..2^16-1&gt;;
115             //     PskBinderEntry binders&lt;33..2^16-1&gt;;
116             // } OfferedPsks;
117             if (m.remaining() &lt; 44) {
<span class="line-modified">118                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">119                         new SSLProtocolException(</span>
120                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">121                     &quot;insufficient data (length=&quot; + m.remaining() + &quot;)&quot;));</span>
122             }
123 
124             int idEncodedLength = Record.getInt16(m);
125             if (idEncodedLength &lt; 7) {
<span class="line-modified">126                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">127                         new SSLProtocolException(</span>
128                     &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">129                     &quot;insufficient identities (length=&quot; + idEncodedLength + &quot;)&quot;));</span>
130             }
131 
132             identities = new ArrayList&lt;&gt;();
133             int idReadLength = 0;
134             while (idReadLength &lt; idEncodedLength) {
135                 byte[] id = Record.getBytes16(m);
136                 if (id.length &lt; 1) {
<span class="line-modified">137                     throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-added">138                             new SSLProtocolException(</span>
139                         &quot;Invalid pre_shared_key extension: &quot; +
<span class="line-modified">140                         &quot;insufficient identity (length=&quot; + id.length + &quot;)&quot;));</span>
141                 }
142                 int obfuscatedTicketAge = Record.getInt32(m);
143 
144                 PskIdentity pskId = new PskIdentity(id, obfuscatedTicketAge);
145                 identities.add(pskId);
146                 idReadLength += pskId.getEncodedLength();
147             }
148 
149             if (m.remaining() &lt; 35) {
<span class="line-modified">150                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">151                         new SSLProtocolException(</span>
<span class="line-modified">152                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">153                     &quot;insufficient binders data (length=&quot; +</span>
<span class="line-added">154                     m.remaining() + &quot;)&quot;));</span>
155             }
156 
157             int bindersEncodedLen = Record.getInt16(m);
158             if (bindersEncodedLen &lt; 33) {
<span class="line-modified">159                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">160                         new SSLProtocolException(</span>
<span class="line-modified">161                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">162                     &quot;insufficient binders (length=&quot; +</span>
<span class="line-added">163                     bindersEncodedLen + &quot;)&quot;));</span>
164             }
165 
166             binders = new ArrayList&lt;&gt;();
167             int bindersReadLength = 0;
168             while (bindersReadLength &lt; bindersEncodedLen) {
169                 byte[] binder = Record.getBytes8(m);
170                 if (binder.length &lt; 32) {
<span class="line-modified">171                     throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">172                             new SSLProtocolException(</span>
<span class="line-modified">173                         &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">174                         &quot;insufficient binder entry (length=&quot; +</span>
<span class="line-added">175                         binder.length + &quot;)&quot;));</span>
176                 }
177                 binders.add(binder);
178                 bindersReadLength += 1 + binder.length;
179             }
180         }
181 
182         int getIdsEncodedLength() {
183             int idEncodedLength = 0;
184             for (PskIdentity curId : identities) {
185                 idEncodedLength += curId.getEncodedLength();
186             }
187 
188             return idEncodedLength;
189         }
190 
191         int getBindersEncodedLength() {
192             int binderEncodedLength = 0;
193             for (byte[] curBinder : binders) {
194                 binderEncodedLength += 1 + curBinder.length;
195             }
</pre>
<hr />
<pre>
243                         hexEncoder.encode(curId.identity), &quot;    &quot;) +
244                         &quot;\n  }\n&quot;);
245             }
246 
247             return result.toString();
248         }
249 
250         String bindersString() {
251             StringBuilder result = new StringBuilder();
252             for (byte[] curBinder : binders) {
253                 result.append(&quot;{&quot; + Utilities.toHexString(curBinder) + &quot;}\n&quot;);
254             }
255 
256             return result.toString();
257         }
258     }
259 
260     private static final
261             class CHPreSharedKeyStringizer implements SSLStringizer {
262         @Override
<span class="line-modified">263         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
264             try {
<span class="line-modified">265                 return (new CHPreSharedKeySpec(hc, buffer)).toString();</span>






266             } catch (Exception ex) {
267                 // For debug logging only, so please swallow exceptions.
268                 return ex.getMessage();
269             }
270         }
271     }
272 
273     private static final
274             class SHPreSharedKeySpec implements SSLExtensionSpec {
275         final int selectedIdentity;
276 
277         SHPreSharedKeySpec(int selectedIdentity) {
278             this.selectedIdentity = selectedIdentity;
279         }
280 
<span class="line-modified">281         SHPreSharedKeySpec(HandshakeContext hc,</span>
282                 ByteBuffer m) throws IOException {
283             if (m.remaining() &lt; 2) {
<span class="line-modified">284                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">285                         new SSLProtocolException(</span>
<span class="line-modified">286                     &quot;Invalid pre_shared_key extension: &quot; +</span>
<span class="line-modified">287                     &quot;insufficient selected_identity (length=&quot; +</span>
<span class="line-added">288                     m.remaining() + &quot;)&quot;));</span>
289             }
290             this.selectedIdentity = Record.getInt16(m);
291         }
292 
293         byte[] getEncoded() {
294             return new byte[] {
295                 (byte)((selectedIdentity &gt;&gt; 8) &amp; 0xFF),
296                 (byte)(selectedIdentity &amp; 0xFF)
297             };
298         }
299 
300         @Override
301         public String toString() {
302             MessageFormat messageFormat = new MessageFormat(
303                 &quot;\&quot;PreSharedKey\&quot;: &#39;{&#39;\n&quot; +
304                 &quot;  \&quot;selected_identity\&quot;      : \&quot;{0}\&quot;,\n&quot; +
305                 &quot;&#39;}&#39;&quot;,
306                 Locale.ENGLISH);
307 
308             Object[] messageFields = {
309                 Utilities.byte16HexString(selectedIdentity)
310             };
311 
312             return messageFormat.format(messageFields);
313         }
314     }
315 
316     private static final
317             class SHPreSharedKeyStringizer implements SSLStringizer {
318         @Override
<span class="line-modified">319         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
320             try {
<span class="line-modified">321                 return (new SHPreSharedKeySpec(hc, buffer)).toString();</span>






322             } catch (Exception ex) {
323                 // For debug logging only, so please swallow exceptions.
324                 return ex.getMessage();
325             }
326         }
327     }
328 
329     private static final
330             class CHPreSharedKeyConsumer implements ExtensionConsumer {
331         // Prevent instantiation of this class.
332         private CHPreSharedKeyConsumer() {
333             // blank
334         }
335 
336         @Override
337         public void consume(ConnectionContext context,
338                             HandshakeMessage message,
339                             ByteBuffer buffer) throws IOException {
340             ClientHelloMessage clientHello = (ClientHelloMessage) message;
341             ServerHandshakeContext shc = (ServerHandshakeContext)context;
342             // Is it a supported and enabled extension?
343             if (!shc.sslConfig.isAvailable(SSLExtension.CH_PRE_SHARED_KEY)) {
344                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
345                     SSLLogger.fine(
346                             &quot;Ignore unavailable pre_shared_key extension&quot;);
347                 }
348                 return;     // ignore the extension
349             }
350 
351             // Parse the extension.
<span class="line-modified">352             CHPreSharedKeySpec pskSpec = new CHPreSharedKeySpec(shc, buffer);</span>





353 
354             // The &quot;psk_key_exchange_modes&quot; extension should have been loaded.
355             if (!shc.handshakeExtensions.containsKey(
356                     SSLExtension.PSK_KEY_EXCHANGE_MODES)) {
357                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
358                         &quot;Client sent PSK but not PSK modes, or the PSK &quot; +
359                         &quot;extension is not the last extension&quot;);
360             }
361 
362             // error if id and binder lists are not the same length
363             if (pskSpec.identities.size() != pskSpec.binders.size()) {
364                 throw shc.conContext.fatal(Alert.ILLEGAL_PARAMETER,
365                         &quot;PSK extension has incorrect number of binders&quot;);
366             }
367 
368             if (shc.isResumption) {     // resumingSession may not be set
369                 SSLSessionContextImpl sessionCache = (SSLSessionContextImpl)
370                         shc.sslContext.engineGetServerSessionContext();
371                 int idIndex = 0;
372                 SSLSessionImpl s = null;
373 
374                 for (PskIdentity requestedId : pskSpec.identities) {
375                     // If we are keeping state, see if the identity is in the cache
376                     if (requestedId.identity.length == SessionId.MAX_LENGTH) {
377                         s = sessionCache.get(requestedId.identity);
378                     }
379                     // See if the identity is a stateless ticket
380                     if (s == null &amp;&amp;
381                             requestedId.identity.length &gt; SessionId.MAX_LENGTH &amp;&amp;
382                             sessionCache.statelessEnabled()) {
383                         ByteBuffer b =
<span class="line-modified">384                             new SessionTicketSpec(shc, requestedId.identity).</span>
385                                         decrypt(shc);
386                         if (b != null) {
387                             try {
388                                 s = new SSLSessionImpl(shc, b);
389                             } catch (IOException | RuntimeException e) {
390                                 s = null;
391                             }
392                         }
393                         if (b == null || s == null) {
394                             if (SSLLogger.isOn &amp;&amp;
395                                     SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
396                                 SSLLogger.fine(
397                                         &quot;Stateless session ticket invalid&quot;);
398                             }
399                         }
400                     }
401 
402                     if (s != null &amp;&amp; canRejoin(clientHello, shc, s)) {
403                         if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
404                             SSLLogger.fine(&quot;Resuming session: &quot;, s);
</pre>
<hr />
<pre>
807     private static SecretKey deriveBinderKey(HandshakeContext context,
808             SecretKey psk, SSLSessionImpl session) throws IOException {
809         try {
810             CipherSuite.HashAlg hashAlg = session.getSuite().hashAlg;
811             HKDF hkdf = new HKDF(hashAlg.name);
812             byte[] zeros = new byte[hashAlg.hashLength];
813             SecretKey earlySecret = hkdf.extract(zeros, psk, &quot;TlsEarlySecret&quot;);
814 
815             byte[] label = (&quot;tls13 res binder&quot;).getBytes();
816             MessageDigest md = MessageDigest.getInstance(hashAlg.name);
817             byte[] hkdfInfo = SSLSecretDerivation.createHkdfInfo(
818                     label, md.digest(new byte[0]), hashAlg.hashLength);
819             return hkdf.expand(earlySecret,
820                     hkdfInfo, hashAlg.hashLength, &quot;TlsBinderKey&quot;);
821         } catch (GeneralSecurityException ex) {
822             throw context.conContext.fatal(Alert.INTERNAL_ERROR, ex);
823         }
824     }
825 
826     private static final
<span class="line-modified">827             class CHPreSharedKeyOnLoadAbsence implements HandshakeAbsence {</span>
828         @Override
829         public void absent(ConnectionContext context,
830                            HandshakeMessage message) throws IOException {
831 
832             if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
833                 SSLLogger.fine(
834                 &quot;Handling pre_shared_key absence.&quot;);
835             }
836 
837             ServerHandshakeContext shc = (ServerHandshakeContext)context;
838 
839             // Resumption is only determined by PSK, when enabled
840             shc.resumingSession = null;
841             shc.isResumption = false;
842         }
843     }
844 
<span class="line-added">845     /**</span>
<span class="line-added">846      * The absence processing if the extension is not present in</span>
<span class="line-added">847      * a ClientHello handshake message.</span>
<span class="line-added">848      */</span>
<span class="line-added">849     private static final class CHPreSharedKeyOnTradeAbsence</span>
<span class="line-added">850             implements HandshakeAbsence {</span>
<span class="line-added">851         @Override</span>
<span class="line-added">852         public void absent(ConnectionContext context,</span>
<span class="line-added">853                 HandshakeMessage message) throws IOException {</span>
<span class="line-added">854             // The producing happens in server side only.</span>
<span class="line-added">855             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>
<span class="line-added">856 </span>
<span class="line-added">857             // A client is considered to be attempting to negotiate using this</span>
<span class="line-added">858             // specification if the ClientHello contains a &quot;supported_versions&quot;</span>
<span class="line-added">859             // extension with 0x0304 contained in its body.  Such a ClientHello</span>
<span class="line-added">860             // message MUST meet the following requirements:</span>
<span class="line-added">861             //   -  If not containing a &quot;pre_shared_key&quot; extension, it MUST</span>
<span class="line-added">862             //      contain both a &quot;signature_algorithms&quot; extension and a</span>
<span class="line-added">863             //      &quot;supported_groups&quot; extension.</span>
<span class="line-added">864             if (shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">865                     (!shc.handshakeExtensions.containsKey(</span>
<span class="line-added">866                             SSLExtension.CH_SIGNATURE_ALGORITHMS) ||</span>
<span class="line-added">867                      !shc.handshakeExtensions.containsKey(</span>
<span class="line-added">868                             SSLExtension.CH_SUPPORTED_GROUPS))) {</span>
<span class="line-added">869                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,</span>
<span class="line-added">870                     &quot;No supported_groups or signature_algorithms extension &quot; +</span>
<span class="line-added">871                     &quot;when pre_shared_key extension is not present&quot;);</span>
<span class="line-added">872             }</span>
<span class="line-added">873         }</span>
<span class="line-added">874     }</span>
<span class="line-added">875 </span>
876     private static final
877             class SHPreSharedKeyConsumer implements ExtensionConsumer {
878         // Prevent instantiation of this class.
879         private SHPreSharedKeyConsumer() {
880             // blank
881         }
882 
883         @Override
884         public void consume(ConnectionContext context,
885             HandshakeMessage message, ByteBuffer buffer) throws IOException {
886             // The consuming happens in client side only.
887             ClientHandshakeContext chc = (ClientHandshakeContext)context;
888 
889             // Is it a response of the specific request?
890             if (!chc.handshakeExtensions.containsKey(
891                     SSLExtension.CH_PRE_SHARED_KEY)) {
892                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE,
893                     &quot;Server sent unexpected pre_shared_key extension&quot;);
894             }
895 
</pre>
</td>
</tr>
</table>
<center><a href="MaxFragExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="PskKeyExchangeModesExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
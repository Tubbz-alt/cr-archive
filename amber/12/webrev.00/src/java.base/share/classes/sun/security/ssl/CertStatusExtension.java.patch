diff a/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java b/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java
--- a/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java
+++ b/src/java.base/share/classes/sun/security/ssl/CertStatusExtension.java
@@ -119,21 +119,23 @@
 
         private CertStatusRequestSpec(CertStatusRequest statusRequest) {
             this.statusRequest = statusRequest;
         }
 
-        private CertStatusRequestSpec(ByteBuffer buffer) throws IOException {
+        private CertStatusRequestSpec(HandshakeContext hc,
+                ByteBuffer buffer) throws IOException {
             // Is it a empty extension_data?
             if (buffer.remaining() == 0) {
                 // server response
                 this.statusRequest = null;
                 return;
             }
 
             if (buffer.remaining() < 1) {
-                throw new SSLProtocolException(
-                    "Invalid status_request extension: insufficient data");
+                throw hc.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
+                    "Invalid status_request extension: insufficient data"));
             }
 
             byte statusType = (byte)Record.getInt8(buffer);
             byte[] encoded = new byte[buffer.remaining()];
             if (encoded.length != 0) {
@@ -176,14 +178,16 @@
 
         private CertStatusResponseSpec(CertStatusResponse resp) {
             this.statusResponse = resp;
         }
 
-        private CertStatusResponseSpec(ByteBuffer buffer) throws IOException {
+        private CertStatusResponseSpec(HandshakeContext hc,
+                ByteBuffer buffer) throws IOException {
             if (buffer.remaining() < 2) {
-                throw new SSLProtocolException(
-                    "Invalid status_request extension: insufficient data");
+                throw hc.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
+                    "Invalid status_request extension: insufficient data"));
             }
 
             // Get the status type (1 byte) and response data (vector)
             byte type = (byte)Record.getInt8(buffer);
             byte[] respData = Record.getBytes24(buffer);
@@ -210,26 +214,26 @@
     }
 
     private static final
             class CertStatusRequestStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(HandshakeContext hc, ByteBuffer buffer) {
             try {
-                return (new CertStatusRequestSpec(buffer)).toString();
+                return (new CertStatusRequestSpec(hc, buffer)).toString();
             } catch (IOException ioe) {
                 // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
     }
 
     private static final
             class CertStatusRespStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(HandshakeContext hc, ByteBuffer buffer) {
             try {
-                return (new CertStatusResponseSpec(buffer)).toString();
+                return (new CertStatusResponseSpec(hc, buffer)).toString();
             } catch (IOException ioe) {
                  // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
@@ -597,16 +601,11 @@
                 }
                 return;     // ignore the extension
             }
 
             // Parse the extension.
-            CertStatusRequestSpec spec;
-            try {
-                spec = new CertStatusRequestSpec(buffer);
-            } catch (IOException ioe) {
-                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
+            CertStatusRequestSpec spec = new CertStatusRequestSpec(shc, buffer);
 
             // Update the context.
             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST, spec);
             if (!shc.isResumption &&
                     !shc.negotiatedProtocol.useTLS13PlusSpec()) {
@@ -774,43 +773,48 @@
 
         private CertStatusRequestV2Spec(CertStatusRequest[] certStatusRequests) {
             this.certStatusRequests = certStatusRequests;
         }
 
-        private CertStatusRequestV2Spec(ByteBuffer message) throws IOException {
+        private CertStatusRequestV2Spec(HandshakeContext hc,
+                ByteBuffer message) throws IOException {
             // Is it a empty extension_data?
             if (message.remaining() == 0) {
                 // server response
                 this.certStatusRequests = new CertStatusRequest[0];
                 return;
             }
 
             if (message.remaining() < 5) {  //  2: certificate_status_req_list
                                             // +1: status_type
                                             // +2: request_length
-                throw new SSLProtocolException(
-                    "Invalid status_request_v2 extension: insufficient data");
+                throw hc.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
+                    "Invalid status_request_v2 extension: insufficient data"));
             }
 
             int listLen = Record.getInt16(message);
             if (listLen <= 0) {
-                throw new SSLProtocolException(
+                throw hc.conContext.fatal(Alert.DECODE_ERROR,
+                        new SSLProtocolException(
                     "certificate_status_req_list length must be positive " +
-                    "(received length: " + listLen + ")");
+                    "(received length: " + listLen + ")"));
             }
 
             int remaining = listLen;
             List<CertStatusRequest> statusRequests = new ArrayList<>();
             while (remaining > 0) {
                 byte statusType = (byte)Record.getInt8(message);
                 int requestLen = Record.getInt16(message);
 
                 if (message.remaining() < requestLen) {
-                    throw new SSLProtocolException(
+                        throw hc.conContext.fatal(
+                                Alert.DECODE_ERROR,
+                                new SSLProtocolException(
                             "Invalid status_request_v2 extension: " +
                             "insufficient data (request_length=" + requestLen +
-                            ", remining=" + message.remaining() + ")");
+                            ", remining=" + message.remaining() + ")"));
                 }
 
                 byte[] encoded = new byte[requestLen];
                 if (encoded.length != 0) {
                     message.get(encoded);
@@ -821,13 +825,15 @@
                 if (statusType == CertStatusRequestType.OCSP.id ||
                         statusType == CertStatusRequestType.OCSP_MULTI.id) {
                     if (encoded.length < 4) {
                                         //  2: length of responder_id_list
                                         // +2: length of request_extensions
-                        throw new SSLProtocolException(
+                        throw hc.conContext.fatal(
+                                Alert.DECODE_ERROR,
+                                new SSLProtocolException(
                             "Invalid status_request_v2 extension: " +
-                            "insufficient data");
+                            "insufficient data"));
                     }
                     statusRequests.add(
                             new OCSPStatusRequest(statusType, encoded));
                 } else {
                     if (SSLLogger.isOn && SSLLogger.isOn("ssl,handshake")) {
@@ -872,13 +878,13 @@
     }
 
     private static final
             class CertStatusRequestsStringizer implements SSLStringizer {
         @Override
-        public String toString(ByteBuffer buffer) {
+        public String toString(HandshakeContext hc, ByteBuffer buffer) {
             try {
-                return (new CertStatusRequestV2Spec(buffer)).toString();
+                return (new CertStatusRequestV2Spec(hc, buffer)).toString();
             } catch (IOException ioe) {
                 // For debug logging only, so please swallow exceptions.
                 return ioe.getMessage();
             }
         }
@@ -955,16 +961,11 @@
 
                 return;     // ignore the extension
             }
 
             // Parse the extension.
-            CertStatusRequestV2Spec spec;
-            try {
-                spec = new CertStatusRequestV2Spec(buffer);
-            } catch (IOException ioe) {
-                throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);
-            }
+            CertStatusRequestV2Spec spec = new CertStatusRequestV2Spec(shc, buffer);
 
             // Update the context.
             shc.handshakeExtensions.put(SSLExtension.CH_STATUS_REQUEST_V2,
                     spec);
             if (!shc.isResumption) {
@@ -1183,16 +1184,11 @@
                 HandshakeMessage message, ByteBuffer buffer) throws IOException {
             // The consumption happens in client side only.
             ClientHandshakeContext chc = (ClientHandshakeContext)context;
 
             // Parse the extension.
-            CertStatusResponseSpec spec;
-            try {
-                spec = new CertStatusResponseSpec(buffer);
-            } catch (IOException ioe) {
-                throw chc.conContext.fatal(Alert.DECODE_ERROR, ioe);
-            }
+            CertStatusResponseSpec spec = new CertStatusResponseSpec(chc, buffer);
 
             if (chc.sslContext.isStaplingEnabled(true)) {
                 // Activate stapling
                 chc.staplingActive = true;
             } else {

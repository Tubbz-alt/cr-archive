<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SupportedVersionsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SupportedGroupsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransportContext.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SupportedVersionsExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2018, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 56             new SHSupportedVersionsStringizer();
 57 
 58     static final HandshakeProducer hrrNetworkProducer =
 59             new HRRSupportedVersionsProducer();
 60     static final ExtensionConsumer hrrOnLoadConsumer =
 61             new HRRSupportedVersionsConsumer();
 62     static final HandshakeProducer hrrReproducer =
 63             new HRRSupportedVersionsReproducer();
 64     static final SSLStringizer hrrStringizer =
 65             new SHSupportedVersionsStringizer();
 66     /**
 67      * The &quot;supported_versions&quot; extension in ClientHello.
 68      */
 69     static final class CHSupportedVersionsSpec implements SSLExtensionSpec {
 70         final int[] requestedProtocols;
 71 
 72         private CHSupportedVersionsSpec(int[] requestedProtocols) {
 73             this.requestedProtocols = requestedProtocols;
 74         }
 75 
<span class="line-modified"> 76         private CHSupportedVersionsSpec(ByteBuffer m) throws IOException  {</span>

 77             if (m.remaining() &lt; 3) {        //  1: the length of the list
 78                                             // +2: one version at least
<span class="line-modified"> 79                 throw new SSLProtocolException(</span>
<span class="line-modified"> 80                     &quot;Invalid supported_versions extension: insufficient data&quot;);</span>

 81             }
 82 
 83             byte[] vbs = Record.getBytes8(m);   // Get the version bytes.
 84             if (m.hasRemaining()) {
<span class="line-modified"> 85                 throw new SSLProtocolException(</span>
<span class="line-modified"> 86                     &quot;Invalid supported_versions extension: unknown extra data&quot;);</span>

 87             }
 88 
 89             if (vbs == null || vbs.length == 0 || (vbs.length &amp; 0x01) != 0) {
<span class="line-modified"> 90                 throw new SSLProtocolException(</span>
<span class="line-modified"> 91                     &quot;Invalid supported_versions extension: incomplete data&quot;);</span>

 92             }
 93 
 94             int[] protocols = new int[vbs.length &gt;&gt; 1];
 95             for (int i = 0, j = 0; i &lt; vbs.length;) {
 96                 byte major = vbs[i++];
 97                 byte minor = vbs[i++];
 98                 protocols[j++] = ((major &amp; 0xFF) &lt;&lt; 8) | (minor &amp; 0xFF);
 99             }
100 
101             this.requestedProtocols = protocols;
102         }
103 
104         @Override
105         public String toString() {
106             MessageFormat messageFormat = new MessageFormat(
107                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
108 
109             if (requestedProtocols == null || requestedProtocols.length == 0) {
110                 Object[] messageFields = {
111                         &quot;&lt;no supported version specified&gt;&quot;
</pre>
<hr />
<pre>
119                         isFirst = false;
120                     } else {
121                         builder.append(&quot;, &quot;);
122                     }
123 
124                     builder.append(ProtocolVersion.nameOf(pv));
125                 }
126 
127                 Object[] messageFields = {
128                         builder.toString()
129                     };
130 
131                 return messageFormat.format(messageFields);
132             }
133         }
134     }
135 
136     private static final
137             class CHSupportedVersionsStringizer implements SSLStringizer {
138         @Override
<span class="line-modified">139         public String toString(ByteBuffer buffer) {</span>
140             try {
<span class="line-modified">141                 return (new CHSupportedVersionsSpec(buffer)).toString();</span>
142             } catch (IOException ioe) {
143                 // For debug logging only, so please swallow exceptions.
144                 return ioe.getMessage();
145             }
146         }
147     }
148 
149     /**
150      * Network data producer of a &quot;supported_versions&quot; extension in ClientHello.
151      */
152     private static final
153             class CHSupportedVersionsProducer implements HandshakeProducer {
154         // Prevent instantiation of this class.
155         private CHSupportedVersionsProducer() {
156             // blank
157         }
158 
159         @Override
160         public byte[] produce(ConnectionContext context,
161                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
204             // blank
205         }
206 
207         @Override
208         public void consume(ConnectionContext context,
209             HandshakeMessage message, ByteBuffer buffer) throws IOException {
210             // The consuming happens in server side only.
211             ServerHandshakeContext shc = (ServerHandshakeContext)context;
212 
213             // Is it a supported and enabled extension?
214             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_VERSIONS)) {
215                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
216                     SSLLogger.fine(
217                         &quot;Ignore unavailable extension: &quot; +
218                         CH_SUPPORTED_VERSIONS.name);
219                 }
220                 return;     // ignore the extension
221             }
222 
223             // Parse the extension.
<span class="line-modified">224             CHSupportedVersionsSpec spec;</span>
<span class="line-modified">225             try {</span>
<span class="line-removed">226                 spec = new CHSupportedVersionsSpec(buffer);</span>
<span class="line-removed">227             } catch (IOException ioe) {</span>
<span class="line-removed">228                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">229             }</span>
230 
231             // Update the context.
232             shc.handshakeExtensions.put(CH_SUPPORTED_VERSIONS, spec);
233 
234             // No impact on session resumption.
235             //
236             // Note that the protocol version negotiation happens before the
237             // session resumption negotiation.  And the session resumption
238             // negotiation depends on the negotiated protocol version.
239         }
240     }
241 
242     /**
243      * The &quot;supported_versions&quot; extension in ServerHello and HelloRetryRequest.
244      */
245     static final class SHSupportedVersionsSpec implements SSLExtensionSpec {
246         final int selectedVersion;
247 
248         private SHSupportedVersionsSpec(ProtocolVersion selectedVersion) {
249             this.selectedVersion = selectedVersion.id;
250         }
251 
<span class="line-modified">252         private SHSupportedVersionsSpec(ByteBuffer m) throws IOException  {</span>

253             if (m.remaining() != 2) {       // 2: the selected version
<span class="line-modified">254                 throw new SSLProtocolException(</span>
<span class="line-modified">255                     &quot;Invalid supported_versions: insufficient data&quot;);</span>

256             }
257 
258             byte major = m.get();
259             byte minor = m.get();
260             this.selectedVersion = ((major &amp; 0xFF) &lt;&lt; 8) | (minor &amp; 0xFF);
261         }
262 
263         @Override
264         public String toString() {
265             MessageFormat messageFormat = new MessageFormat(
266                 &quot;\&quot;selected version\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
267 
268             Object[] messageFields = {
269                     ProtocolVersion.nameOf(selectedVersion)
270                 };
271             return messageFormat.format(messageFields);
272         }
273     }
274 
275     private static final
276             class SHSupportedVersionsStringizer implements SSLStringizer {
277         @Override
<span class="line-modified">278         public String toString(ByteBuffer buffer) {</span>
279             try {
<span class="line-modified">280                 return (new SHSupportedVersionsSpec(buffer)).toString();</span>
281             } catch (IOException ioe) {
282                 // For debug logging only, so please swallow exceptions.
283                 return ioe.getMessage();
284             }
285         }
286     }
287 
288     /**
289      * Network data producer of a &quot;supported_versions&quot; extension in ServerHello.
290      */
291     private static final
292             class SHSupportedVersionsProducer implements HandshakeProducer {
293         // Prevent instantiation of this class.
294         private SHSupportedVersionsProducer() {
295             // blank
296         }
297 
298         @Override
299         public byte[] produce(ConnectionContext context,
300                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
346             // blank
347         }
348 
349         @Override
350         public void consume(ConnectionContext context,
351             HandshakeMessage message, ByteBuffer buffer) throws IOException {
352             // The consuming happens in client side only.
353             ClientHandshakeContext chc = (ClientHandshakeContext)context;
354 
355             // Is it a supported and enabled extension?
356             if (!chc.sslConfig.isAvailable(SH_SUPPORTED_VERSIONS)) {
357                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
358                     SSLLogger.fine(
359                         &quot;Ignore unavailable extension: &quot; +
360                         SH_SUPPORTED_VERSIONS.name);
361                 }
362                 return;     // ignore the extension
363             }
364 
365             // Parse the extension.
<span class="line-modified">366             SHSupportedVersionsSpec spec;</span>
<span class="line-modified">367             try {</span>
<span class="line-removed">368                 spec = new SHSupportedVersionsSpec(buffer);</span>
<span class="line-removed">369             } catch (IOException ioe) {</span>
<span class="line-removed">370                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">371             }</span>
372 
373             // Update the context.
374             chc.handshakeExtensions.put(SH_SUPPORTED_VERSIONS, spec);
375 
376             // No impact on session resumption.
377             //
378             // Note that the protocol version negotiation happens before the
379             // session resumption negotiation.  And the session resumption
380             // negotiation depends on the negotiated protocol version.
381         }
382     }
383 
384     /**
385      * Network data producer of a &quot;supported_versions&quot; extension in
386      * HelloRetryRequest.
387      */
388     private static final
389             class HRRSupportedVersionsProducer implements HandshakeProducer {
390 
391         // Prevent instantiation of this class.
</pre>
<hr />
<pre>
435         }
436 
437         @Override
438         public void consume(ConnectionContext context,
439             HandshakeMessage message, ByteBuffer buffer) throws IOException {
440 
441             // The consuming happens in client side only.
442             ClientHandshakeContext chc = (ClientHandshakeContext)context;
443 
444             // Is it a supported and enabled extension?
445             if (!chc.sslConfig.isAvailable(HRR_SUPPORTED_VERSIONS)) {
446                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
447                     SSLLogger.fine(
448                         &quot;Ignore unavailable extension: &quot; +
449                         HRR_SUPPORTED_VERSIONS.name);
450                 }
451                 return;     // ignore the extension
452             }
453 
454             // Parse the extension.
<span class="line-modified">455             SHSupportedVersionsSpec spec;</span>
<span class="line-modified">456             try {</span>
<span class="line-removed">457                 spec = new SHSupportedVersionsSpec(buffer);</span>
<span class="line-removed">458             } catch (IOException ioe) {</span>
<span class="line-removed">459                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">460             }</span>
461 
462             // Update the context.
463             chc.handshakeExtensions.put(HRR_SUPPORTED_VERSIONS, spec);
464 
465             // No impact on session resumption.
466             //
467             // Note that the protocol version negotiation happens before the
468             // session resumption negotiation.  And the session resumption
469             // negotiation depends on the negotiated protocol version.
470         }
471     }
472 
473     /**
474      * Network data producer of a &quot;supported_versions&quot; extension for stateless
475      * HelloRetryRequest reconstruction.
476      */
477     private static final
478             class HRRSupportedVersionsReproducer implements HandshakeProducer {
479         // Prevent instantiation of this class.
480         private HRRSupportedVersionsReproducer() {
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 56             new SHSupportedVersionsStringizer();
 57 
 58     static final HandshakeProducer hrrNetworkProducer =
 59             new HRRSupportedVersionsProducer();
 60     static final ExtensionConsumer hrrOnLoadConsumer =
 61             new HRRSupportedVersionsConsumer();
 62     static final HandshakeProducer hrrReproducer =
 63             new HRRSupportedVersionsReproducer();
 64     static final SSLStringizer hrrStringizer =
 65             new SHSupportedVersionsStringizer();
 66     /**
 67      * The &quot;supported_versions&quot; extension in ClientHello.
 68      */
 69     static final class CHSupportedVersionsSpec implements SSLExtensionSpec {
 70         final int[] requestedProtocols;
 71 
 72         private CHSupportedVersionsSpec(int[] requestedProtocols) {
 73             this.requestedProtocols = requestedProtocols;
 74         }
 75 
<span class="line-modified"> 76         private CHSupportedVersionsSpec(HandshakeContext hc,</span>
<span class="line-added"> 77                 ByteBuffer m) throws IOException  {</span>
 78             if (m.remaining() &lt; 3) {        //  1: the length of the list
 79                                             // +2: one version at least
<span class="line-modified"> 80                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 81                         new SSLProtocolException(</span>
<span class="line-added"> 82                     &quot;Invalid supported_versions extension: insufficient data&quot;));</span>
 83             }
 84 
 85             byte[] vbs = Record.getBytes8(m);   // Get the version bytes.
 86             if (m.hasRemaining()) {
<span class="line-modified"> 87                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 88                         new SSLProtocolException(</span>
<span class="line-added"> 89                     &quot;Invalid supported_versions extension: unknown extra data&quot;));</span>
 90             }
 91 
 92             if (vbs == null || vbs.length == 0 || (vbs.length &amp; 0x01) != 0) {
<span class="line-modified"> 93                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 94                         new SSLProtocolException(</span>
<span class="line-added"> 95                     &quot;Invalid supported_versions extension: incomplete data&quot;));</span>
 96             }
 97 
 98             int[] protocols = new int[vbs.length &gt;&gt; 1];
 99             for (int i = 0, j = 0; i &lt; vbs.length;) {
100                 byte major = vbs[i++];
101                 byte minor = vbs[i++];
102                 protocols[j++] = ((major &amp; 0xFF) &lt;&lt; 8) | (minor &amp; 0xFF);
103             }
104 
105             this.requestedProtocols = protocols;
106         }
107 
108         @Override
109         public String toString() {
110             MessageFormat messageFormat = new MessageFormat(
111                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
112 
113             if (requestedProtocols == null || requestedProtocols.length == 0) {
114                 Object[] messageFields = {
115                         &quot;&lt;no supported version specified&gt;&quot;
</pre>
<hr />
<pre>
123                         isFirst = false;
124                     } else {
125                         builder.append(&quot;, &quot;);
126                     }
127 
128                     builder.append(ProtocolVersion.nameOf(pv));
129                 }
130 
131                 Object[] messageFields = {
132                         builder.toString()
133                     };
134 
135                 return messageFormat.format(messageFields);
136             }
137         }
138     }
139 
140     private static final
141             class CHSupportedVersionsStringizer implements SSLStringizer {
142         @Override
<span class="line-modified">143         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
144             try {
<span class="line-modified">145                 return (new CHSupportedVersionsSpec(hc, buffer)).toString();</span>
146             } catch (IOException ioe) {
147                 // For debug logging only, so please swallow exceptions.
148                 return ioe.getMessage();
149             }
150         }
151     }
152 
153     /**
154      * Network data producer of a &quot;supported_versions&quot; extension in ClientHello.
155      */
156     private static final
157             class CHSupportedVersionsProducer implements HandshakeProducer {
158         // Prevent instantiation of this class.
159         private CHSupportedVersionsProducer() {
160             // blank
161         }
162 
163         @Override
164         public byte[] produce(ConnectionContext context,
165                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
208             // blank
209         }
210 
211         @Override
212         public void consume(ConnectionContext context,
213             HandshakeMessage message, ByteBuffer buffer) throws IOException {
214             // The consuming happens in server side only.
215             ServerHandshakeContext shc = (ServerHandshakeContext)context;
216 
217             // Is it a supported and enabled extension?
218             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_VERSIONS)) {
219                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
220                     SSLLogger.fine(
221                         &quot;Ignore unavailable extension: &quot; +
222                         CH_SUPPORTED_VERSIONS.name);
223                 }
224                 return;     // ignore the extension
225             }
226 
227             // Parse the extension.
<span class="line-modified">228             CHSupportedVersionsSpec spec =</span>
<span class="line-modified">229                     new CHSupportedVersionsSpec(shc, buffer);</span>




230 
231             // Update the context.
232             shc.handshakeExtensions.put(CH_SUPPORTED_VERSIONS, spec);
233 
234             // No impact on session resumption.
235             //
236             // Note that the protocol version negotiation happens before the
237             // session resumption negotiation.  And the session resumption
238             // negotiation depends on the negotiated protocol version.
239         }
240     }
241 
242     /**
243      * The &quot;supported_versions&quot; extension in ServerHello and HelloRetryRequest.
244      */
245     static final class SHSupportedVersionsSpec implements SSLExtensionSpec {
246         final int selectedVersion;
247 
248         private SHSupportedVersionsSpec(ProtocolVersion selectedVersion) {
249             this.selectedVersion = selectedVersion.id;
250         }
251 
<span class="line-modified">252         private SHSupportedVersionsSpec(HandshakeContext hc,</span>
<span class="line-added">253                 ByteBuffer m) throws IOException  {</span>
254             if (m.remaining() != 2) {       // 2: the selected version
<span class="line-modified">255                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">256                         new SSLProtocolException(</span>
<span class="line-added">257                     &quot;Invalid supported_versions: insufficient data&quot;));</span>
258             }
259 
260             byte major = m.get();
261             byte minor = m.get();
262             this.selectedVersion = ((major &amp; 0xFF) &lt;&lt; 8) | (minor &amp; 0xFF);
263         }
264 
265         @Override
266         public String toString() {
267             MessageFormat messageFormat = new MessageFormat(
268                 &quot;\&quot;selected version\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
269 
270             Object[] messageFields = {
271                     ProtocolVersion.nameOf(selectedVersion)
272                 };
273             return messageFormat.format(messageFields);
274         }
275     }
276 
277     private static final
278             class SHSupportedVersionsStringizer implements SSLStringizer {
279         @Override
<span class="line-modified">280         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
281             try {
<span class="line-modified">282                 return (new SHSupportedVersionsSpec(hc, buffer)).toString();</span>
283             } catch (IOException ioe) {
284                 // For debug logging only, so please swallow exceptions.
285                 return ioe.getMessage();
286             }
287         }
288     }
289 
290     /**
291      * Network data producer of a &quot;supported_versions&quot; extension in ServerHello.
292      */
293     private static final
294             class SHSupportedVersionsProducer implements HandshakeProducer {
295         // Prevent instantiation of this class.
296         private SHSupportedVersionsProducer() {
297             // blank
298         }
299 
300         @Override
301         public byte[] produce(ConnectionContext context,
302                 HandshakeMessage message) throws IOException {
</pre>
<hr />
<pre>
348             // blank
349         }
350 
351         @Override
352         public void consume(ConnectionContext context,
353             HandshakeMessage message, ByteBuffer buffer) throws IOException {
354             // The consuming happens in client side only.
355             ClientHandshakeContext chc = (ClientHandshakeContext)context;
356 
357             // Is it a supported and enabled extension?
358             if (!chc.sslConfig.isAvailable(SH_SUPPORTED_VERSIONS)) {
359                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
360                     SSLLogger.fine(
361                         &quot;Ignore unavailable extension: &quot; +
362                         SH_SUPPORTED_VERSIONS.name);
363                 }
364                 return;     // ignore the extension
365             }
366 
367             // Parse the extension.
<span class="line-modified">368             SHSupportedVersionsSpec spec =</span>
<span class="line-modified">369                     new SHSupportedVersionsSpec(chc, buffer);</span>




370 
371             // Update the context.
372             chc.handshakeExtensions.put(SH_SUPPORTED_VERSIONS, spec);
373 
374             // No impact on session resumption.
375             //
376             // Note that the protocol version negotiation happens before the
377             // session resumption negotiation.  And the session resumption
378             // negotiation depends on the negotiated protocol version.
379         }
380     }
381 
382     /**
383      * Network data producer of a &quot;supported_versions&quot; extension in
384      * HelloRetryRequest.
385      */
386     private static final
387             class HRRSupportedVersionsProducer implements HandshakeProducer {
388 
389         // Prevent instantiation of this class.
</pre>
<hr />
<pre>
433         }
434 
435         @Override
436         public void consume(ConnectionContext context,
437             HandshakeMessage message, ByteBuffer buffer) throws IOException {
438 
439             // The consuming happens in client side only.
440             ClientHandshakeContext chc = (ClientHandshakeContext)context;
441 
442             // Is it a supported and enabled extension?
443             if (!chc.sslConfig.isAvailable(HRR_SUPPORTED_VERSIONS)) {
444                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
445                     SSLLogger.fine(
446                         &quot;Ignore unavailable extension: &quot; +
447                         HRR_SUPPORTED_VERSIONS.name);
448                 }
449                 return;     // ignore the extension
450             }
451 
452             // Parse the extension.
<span class="line-modified">453             SHSupportedVersionsSpec spec =</span>
<span class="line-modified">454                     new SHSupportedVersionsSpec(chc, buffer);</span>




455 
456             // Update the context.
457             chc.handshakeExtensions.put(HRR_SUPPORTED_VERSIONS, spec);
458 
459             // No impact on session resumption.
460             //
461             // Note that the protocol version negotiation happens before the
462             // session resumption negotiation.  And the session resumption
463             // negotiation depends on the negotiated protocol version.
464         }
465     }
466 
467     /**
468      * Network data producer of a &quot;supported_versions&quot; extension for stateless
469      * HelloRetryRequest reconstruction.
470      */
471     private static final
472             class HRRSupportedVersionsReproducer implements HandshakeProducer {
473         // Prevent instantiation of this class.
474         private HRRSupportedVersionsReproducer() {
</pre>
</td>
</tr>
</table>
<center><a href="SupportedGroupsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="TransportContext.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
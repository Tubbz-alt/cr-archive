<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/sun/security/ssl/SupportedGroupsExtension.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="SignatureAlgorithmsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SupportedVersionsExtension.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/sun/security/ssl/SupportedGroupsExtension.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 35 import java.util.List;
 36 import java.util.Locale;
 37 import javax.net.ssl.SSLProtocolException;
 38 import sun.security.action.GetPropertyAction;
 39 import sun.security.ssl.NamedGroup.NamedGroupSpec;
 40 import static sun.security.ssl.SSLExtension.CH_SUPPORTED_GROUPS;
 41 import static sun.security.ssl.SSLExtension.EE_SUPPORTED_GROUPS;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 
 46 
 47 /**
 48  * Pack of the &quot;supported_groups&quot; extensions [RFC 4492/7919].
 49  */
 50 final class SupportedGroupsExtension {
 51     static final HandshakeProducer chNetworkProducer =
 52             new CHSupportedGroupsProducer();
 53     static final ExtensionConsumer chOnLoadConsumer =
 54             new CHSupportedGroupsConsumer();


 55     static final SSLStringizer sgsStringizer =
 56             new SupportedGroupsStringizer();
 57 
 58     static final HandshakeProducer eeNetworkProducer =
 59             new EESupportedGroupsProducer();
 60     static final ExtensionConsumer eeOnLoadConsumer =
 61             new EESupportedGroupsConsumer();
 62 
 63     /**
 64      * The &quot;supported_groups&quot; extension.
 65      */
 66     static final class SupportedGroupsSpec implements SSLExtensionSpec {
 67         final int[] namedGroupsIds;
 68 
 69         private SupportedGroupsSpec(int[] namedGroupsIds) {
 70             this.namedGroupsIds = namedGroupsIds;
 71         }
 72 
 73         private SupportedGroupsSpec(List&lt;NamedGroup&gt; namedGroups) {
 74             this.namedGroupsIds = new int[namedGroups.size()];
 75             int i = 0;
 76             for (NamedGroup ng : namedGroups) {
 77                 namedGroupsIds[i++] = ng.id;
 78             }
 79         }
 80 
<span class="line-modified"> 81         private SupportedGroupsSpec(ByteBuffer m) throws IOException  {</span>

 82             if (m.remaining() &lt; 2) {      // 2: the length of the list
<span class="line-modified"> 83                 throw new SSLProtocolException(</span>
<span class="line-modified"> 84                     &quot;Invalid supported_groups extension: insufficient data&quot;);</span>

 85             }
 86 
 87             byte[] ngs = Record.getBytes16(m);
 88             if (m.hasRemaining()) {
<span class="line-modified"> 89                 throw new SSLProtocolException(</span>
<span class="line-modified"> 90                     &quot;Invalid supported_groups extension: unknown extra data&quot;);</span>

 91             }
 92 
 93             if ((ngs == null) || (ngs.length == 0) || (ngs.length % 2 != 0)) {
<span class="line-modified"> 94                 throw new SSLProtocolException(</span>
<span class="line-modified"> 95                     &quot;Invalid supported_groups extension: incomplete data&quot;);</span>

 96             }
 97 
 98             int[] ids = new int[ngs.length / 2];
 99             for (int i = 0, j = 0; i &lt; ngs.length;) {
100                 ids[j++] = ((ngs[i++] &amp; 0xFF) &lt;&lt; 8) | (ngs[i++] &amp; 0xFF);
101             }
102 
103             this.namedGroupsIds = ids;
104         }
105 
106         @Override
107         public String toString() {
108             MessageFormat messageFormat = new MessageFormat(
109                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
110 
111             if (namedGroupsIds == null || namedGroupsIds.length == 0) {
112                 Object[] messageFields = {
113                         &quot;&lt;no supported named group specified&gt;&quot;
114                     };
115                 return messageFormat.format(messageFields);
</pre>
<hr />
<pre>
121                         isFirst = false;
122                     } else {
123                         builder.append(&quot;, &quot;);
124                     }
125 
126                     builder.append(NamedGroup.nameOf(ngid));
127                 }
128 
129                 Object[] messageFields = {
130                         builder.toString()
131                     };
132 
133                 return messageFormat.format(messageFields);
134             }
135         }
136     }
137 
138     private static final
139             class SupportedGroupsStringizer implements SSLStringizer {
140         @Override
<span class="line-modified">141         public String toString(ByteBuffer buffer) {</span>
142             try {
<span class="line-modified">143                 return (new SupportedGroupsSpec(buffer)).toString();</span>
144             } catch (IOException ioe) {
145                 // For debug logging only, so please swallow exceptions.
146                 return ioe.getMessage();
147             }
148         }
149     }
150 
151     static class SupportedGroups {
152         // To switch off the supported_groups extension for DHE cipher suite.
153         static final boolean enableFFDHE =
154                 Utilities.getBooleanProperty(&quot;jsse.enableFFDHE&quot;, true);
155 
156         // the supported named groups
157         static final NamedGroup[] supportedNamedGroups;
158 
159         static {
160             // The value of the System Property defines a list of enabled named
161             // groups in preference order, separated with comma.  For example:
162             //
163             //      jdk.tls.namedGroups=&quot;secp521r1, secp256r1, ffdhe2048&quot;
</pre>
<hr />
<pre>
397         private CHSupportedGroupsConsumer() {
398             // blank
399         }
400 
401         @Override
402         public void consume(ConnectionContext context,
403             HandshakeMessage message, ByteBuffer buffer) throws IOException {
404             // The consuming happens in server side only.
405             ServerHandshakeContext shc = (ServerHandshakeContext)context;
406 
407             // Is it a supported and enabled extension?
408             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
409                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
410                     SSLLogger.fine(
411                         &quot;Ignore unavailable supported_groups extension&quot;);
412                 }
413                 return;     // ignore the extension
414             }
415 
416             // Parse the extension.
<span class="line-modified">417             SupportedGroupsSpec spec;</span>
<span class="line-removed">418             try {</span>
<span class="line-removed">419                 spec = new SupportedGroupsSpec(buffer);</span>
<span class="line-removed">420             } catch (IOException ioe) {</span>
<span class="line-removed">421                 throw shc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">422             }</span>
423 
424             // Update the context.
425             List&lt;NamedGroup&gt; knownNamedGroups = new LinkedList&lt;&gt;();
426             for (int id : spec.namedGroupsIds) {
427                 NamedGroup ng = NamedGroup.valueOf(id);
428                 if (ng != null) {
429                     knownNamedGroups.add(ng);
430                 }
431             }
432 
433             shc.clientRequestedNamedGroups = knownNamedGroups;
434             shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);
435 
436             // No impact on session resumption.
437         }
438     }
439 





























440     /**
441      * Network data producer of a &quot;supported_groups&quot; extension in
442      * the EncryptedExtensions handshake message.
443      */
444     private static final class EESupportedGroupsProducer
445             extends SupportedGroups implements HandshakeProducer {
446 
447         // Prevent instantiation of this class.
448         private EESupportedGroupsProducer() {
449             // blank
450         }
451 
452         @Override
453         public byte[] produce(ConnectionContext context,
454                 HandshakeMessage message) throws IOException {
455             // The producing happens in server side only.
456             ServerHandshakeContext shc = (ServerHandshakeContext)context;
457 
458             // Is it a supported and enabled extension?
459             if (!shc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
</pre>
<hr />
<pre>
518         private EESupportedGroupsConsumer() {
519             // blank
520         }
521 
522         @Override
523         public void consume(ConnectionContext context,
524             HandshakeMessage message, ByteBuffer buffer) throws IOException {
525             // The consuming happens in client side only.
526             ClientHandshakeContext chc = (ClientHandshakeContext)context;
527 
528             // Is it a supported and enabled extension?
529             if (!chc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
530                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
531                     SSLLogger.fine(
532                         &quot;Ignore unavailable supported_groups extension&quot;);
533                 }
534                 return;     // ignore the extension
535             }
536 
537             // Parse the extension.
<span class="line-modified">538             SupportedGroupsSpec spec;</span>
<span class="line-removed">539             try {</span>
<span class="line-removed">540                 spec = new SupportedGroupsSpec(buffer);</span>
<span class="line-removed">541             } catch (IOException ioe) {</span>
<span class="line-removed">542                 throw chc.conContext.fatal(Alert.UNEXPECTED_MESSAGE, ioe);</span>
<span class="line-removed">543             }</span>
544 
545             // Update the context.
546             List&lt;NamedGroup&gt; knownNamedGroups =
547                     new ArrayList&lt;&gt;(spec.namedGroupsIds.length);
548             for (int id : spec.namedGroupsIds) {
549                 NamedGroup ng = NamedGroup.valueOf(id);
550                 if (ng != null) {
551                     knownNamedGroups.add(ng);
552                 }
553             }
554 
555             chc.conContext.serverRequestedNamedGroups = knownNamedGroups;
556             chc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
557 
558             // No impact on session resumption.
559         }
560     }
561 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
 35 import java.util.List;
 36 import java.util.Locale;
 37 import javax.net.ssl.SSLProtocolException;
 38 import sun.security.action.GetPropertyAction;
 39 import sun.security.ssl.NamedGroup.NamedGroupSpec;
 40 import static sun.security.ssl.SSLExtension.CH_SUPPORTED_GROUPS;
 41 import static sun.security.ssl.SSLExtension.EE_SUPPORTED_GROUPS;
 42 import sun.security.ssl.SSLExtension.ExtensionConsumer;
 43 import sun.security.ssl.SSLExtension.SSLExtensionSpec;
 44 import sun.security.ssl.SSLHandshake.HandshakeMessage;
 45 
 46 
 47 /**
 48  * Pack of the &quot;supported_groups&quot; extensions [RFC 4492/7919].
 49  */
 50 final class SupportedGroupsExtension {
 51     static final HandshakeProducer chNetworkProducer =
 52             new CHSupportedGroupsProducer();
 53     static final ExtensionConsumer chOnLoadConsumer =
 54             new CHSupportedGroupsConsumer();
<span class="line-added"> 55     static final HandshakeAbsence chOnTradAbsence =</span>
<span class="line-added"> 56             new CHSupportedGroupsOnTradeAbsence();</span>
 57     static final SSLStringizer sgsStringizer =
 58             new SupportedGroupsStringizer();
 59 
 60     static final HandshakeProducer eeNetworkProducer =
 61             new EESupportedGroupsProducer();
 62     static final ExtensionConsumer eeOnLoadConsumer =
 63             new EESupportedGroupsConsumer();
 64 
 65     /**
 66      * The &quot;supported_groups&quot; extension.
 67      */
 68     static final class SupportedGroupsSpec implements SSLExtensionSpec {
 69         final int[] namedGroupsIds;
 70 
 71         private SupportedGroupsSpec(int[] namedGroupsIds) {
 72             this.namedGroupsIds = namedGroupsIds;
 73         }
 74 
 75         private SupportedGroupsSpec(List&lt;NamedGroup&gt; namedGroups) {
 76             this.namedGroupsIds = new int[namedGroups.size()];
 77             int i = 0;
 78             for (NamedGroup ng : namedGroups) {
 79                 namedGroupsIds[i++] = ng.id;
 80             }
 81         }
 82 
<span class="line-modified"> 83         private SupportedGroupsSpec(HandshakeContext hc,</span>
<span class="line-added"> 84                 ByteBuffer m) throws IOException  {</span>
 85             if (m.remaining() &lt; 2) {      // 2: the length of the list
<span class="line-modified"> 86                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 87                         new SSLProtocolException(</span>
<span class="line-added"> 88                     &quot;Invalid supported_groups extension: insufficient data&quot;));</span>
 89             }
 90 
 91             byte[] ngs = Record.getBytes16(m);
 92             if (m.hasRemaining()) {
<span class="line-modified"> 93                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified"> 94                         new SSLProtocolException(</span>
<span class="line-added"> 95                     &quot;Invalid supported_groups extension: unknown extra data&quot;));</span>
 96             }
 97 
 98             if ((ngs == null) || (ngs.length == 0) || (ngs.length % 2 != 0)) {
<span class="line-modified"> 99                 throw hc.conContext.fatal(Alert.DECODE_ERROR,</span>
<span class="line-modified">100                         new SSLProtocolException(</span>
<span class="line-added">101                     &quot;Invalid supported_groups extension: incomplete data&quot;));</span>
102             }
103 
104             int[] ids = new int[ngs.length / 2];
105             for (int i = 0, j = 0; i &lt; ngs.length;) {
106                 ids[j++] = ((ngs[i++] &amp; 0xFF) &lt;&lt; 8) | (ngs[i++] &amp; 0xFF);
107             }
108 
109             this.namedGroupsIds = ids;
110         }
111 
112         @Override
113         public String toString() {
114             MessageFormat messageFormat = new MessageFormat(
115                 &quot;\&quot;versions\&quot;: &#39;[&#39;{0}&#39;]&#39;&quot;, Locale.ENGLISH);
116 
117             if (namedGroupsIds == null || namedGroupsIds.length == 0) {
118                 Object[] messageFields = {
119                         &quot;&lt;no supported named group specified&gt;&quot;
120                     };
121                 return messageFormat.format(messageFields);
</pre>
<hr />
<pre>
127                         isFirst = false;
128                     } else {
129                         builder.append(&quot;, &quot;);
130                     }
131 
132                     builder.append(NamedGroup.nameOf(ngid));
133                 }
134 
135                 Object[] messageFields = {
136                         builder.toString()
137                     };
138 
139                 return messageFormat.format(messageFields);
140             }
141         }
142     }
143 
144     private static final
145             class SupportedGroupsStringizer implements SSLStringizer {
146         @Override
<span class="line-modified">147         public String toString(HandshakeContext hc, ByteBuffer buffer) {</span>
148             try {
<span class="line-modified">149                 return (new SupportedGroupsSpec(hc, buffer)).toString();</span>
150             } catch (IOException ioe) {
151                 // For debug logging only, so please swallow exceptions.
152                 return ioe.getMessage();
153             }
154         }
155     }
156 
157     static class SupportedGroups {
158         // To switch off the supported_groups extension for DHE cipher suite.
159         static final boolean enableFFDHE =
160                 Utilities.getBooleanProperty(&quot;jsse.enableFFDHE&quot;, true);
161 
162         // the supported named groups
163         static final NamedGroup[] supportedNamedGroups;
164 
165         static {
166             // The value of the System Property defines a list of enabled named
167             // groups in preference order, separated with comma.  For example:
168             //
169             //      jdk.tls.namedGroups=&quot;secp521r1, secp256r1, ffdhe2048&quot;
</pre>
<hr />
<pre>
403         private CHSupportedGroupsConsumer() {
404             // blank
405         }
406 
407         @Override
408         public void consume(ConnectionContext context,
409             HandshakeMessage message, ByteBuffer buffer) throws IOException {
410             // The consuming happens in server side only.
411             ServerHandshakeContext shc = (ServerHandshakeContext)context;
412 
413             // Is it a supported and enabled extension?
414             if (!shc.sslConfig.isAvailable(CH_SUPPORTED_GROUPS)) {
415                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
416                     SSLLogger.fine(
417                         &quot;Ignore unavailable supported_groups extension&quot;);
418                 }
419                 return;     // ignore the extension
420             }
421 
422             // Parse the extension.
<span class="line-modified">423             SupportedGroupsSpec spec = new SupportedGroupsSpec(shc, buffer);</span>





424 
425             // Update the context.
426             List&lt;NamedGroup&gt; knownNamedGroups = new LinkedList&lt;&gt;();
427             for (int id : spec.namedGroupsIds) {
428                 NamedGroup ng = NamedGroup.valueOf(id);
429                 if (ng != null) {
430                     knownNamedGroups.add(ng);
431                 }
432             }
433 
434             shc.clientRequestedNamedGroups = knownNamedGroups;
435             shc.handshakeExtensions.put(CH_SUPPORTED_GROUPS, spec);
436 
437             // No impact on session resumption.
438         }
439     }
440 
<span class="line-added">441     /**</span>
<span class="line-added">442      * The absence processing if the extension is not present in</span>
<span class="line-added">443      * a ClientHello handshake message.</span>
<span class="line-added">444      */</span>
<span class="line-added">445     private static final class CHSupportedGroupsOnTradeAbsence</span>
<span class="line-added">446             implements HandshakeAbsence {</span>
<span class="line-added">447         @Override</span>
<span class="line-added">448         public void absent(ConnectionContext context,</span>
<span class="line-added">449                 HandshakeMessage message) throws IOException {</span>
<span class="line-added">450             // The producing happens in server side only.</span>
<span class="line-added">451             ServerHandshakeContext shc = (ServerHandshakeContext)context;</span>
<span class="line-added">452 </span>
<span class="line-added">453             // A client is considered to be attempting to negotiate using this</span>
<span class="line-added">454             // specification if the ClientHello contains a &quot;supported_versions&quot;</span>
<span class="line-added">455             // extension with 0x0304 contained in its body.  Such a ClientHello</span>
<span class="line-added">456             // message MUST meet the following requirements:</span>
<span class="line-added">457             //    -  If containing a &quot;supported_groups&quot; extension, it MUST also</span>
<span class="line-added">458             //       contain a &quot;key_share&quot; extension, and vice versa.  An empty</span>
<span class="line-added">459             //       KeyShare.client_shares vector is permitted.</span>
<span class="line-added">460             if (shc.negotiatedProtocol.useTLS13PlusSpec() &amp;&amp;</span>
<span class="line-added">461                     shc.handshakeExtensions.containsKey(</span>
<span class="line-added">462                             SSLExtension.CH_KEY_SHARE)) {</span>
<span class="line-added">463                 throw shc.conContext.fatal(Alert.MISSING_EXTENSION,</span>
<span class="line-added">464                         &quot;No supported_groups extension to work with &quot; +</span>
<span class="line-added">465                         &quot;the key_share extension&quot;);</span>
<span class="line-added">466             }</span>
<span class="line-added">467         }</span>
<span class="line-added">468     }</span>
<span class="line-added">469 </span>
470     /**
471      * Network data producer of a &quot;supported_groups&quot; extension in
472      * the EncryptedExtensions handshake message.
473      */
474     private static final class EESupportedGroupsProducer
475             extends SupportedGroups implements HandshakeProducer {
476 
477         // Prevent instantiation of this class.
478         private EESupportedGroupsProducer() {
479             // blank
480         }
481 
482         @Override
483         public byte[] produce(ConnectionContext context,
484                 HandshakeMessage message) throws IOException {
485             // The producing happens in server side only.
486             ServerHandshakeContext shc = (ServerHandshakeContext)context;
487 
488             // Is it a supported and enabled extension?
489             if (!shc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
</pre>
<hr />
<pre>
548         private EESupportedGroupsConsumer() {
549             // blank
550         }
551 
552         @Override
553         public void consume(ConnectionContext context,
554             HandshakeMessage message, ByteBuffer buffer) throws IOException {
555             // The consuming happens in client side only.
556             ClientHandshakeContext chc = (ClientHandshakeContext)context;
557 
558             // Is it a supported and enabled extension?
559             if (!chc.sslConfig.isAvailable(EE_SUPPORTED_GROUPS)) {
560                 if (SSLLogger.isOn &amp;&amp; SSLLogger.isOn(&quot;ssl,handshake&quot;)) {
561                     SSLLogger.fine(
562                         &quot;Ignore unavailable supported_groups extension&quot;);
563                 }
564                 return;     // ignore the extension
565             }
566 
567             // Parse the extension.
<span class="line-modified">568             SupportedGroupsSpec spec = new SupportedGroupsSpec(chc, buffer);</span>





569 
570             // Update the context.
571             List&lt;NamedGroup&gt; knownNamedGroups =
572                     new ArrayList&lt;&gt;(spec.namedGroupsIds.length);
573             for (int id : spec.namedGroupsIds) {
574                 NamedGroup ng = NamedGroup.valueOf(id);
575                 if (ng != null) {
576                     knownNamedGroups.add(ng);
577                 }
578             }
579 
580             chc.conContext.serverRequestedNamedGroups = knownNamedGroups;
581             chc.handshakeExtensions.put(EE_SUPPORTED_GROUPS, spec);
582 
583             // No impact on session resumption.
584         }
585     }
586 }
</pre>
</td>
</tr>
</table>
<center><a href="SignatureAlgorithmsExtension.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="SupportedVersionsExtension.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
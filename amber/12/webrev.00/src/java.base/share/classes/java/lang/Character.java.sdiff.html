<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Character.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Boolean.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Class.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Character.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 /*
<span class="line-modified">    2  * Copyright (c) 2002, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  225      * @since   1.1
  226      */
  227     public static final byte NON_SPACING_MARK = 6;
  228 
  229     /**
  230      * General category &quot;Me&quot; in the Unicode specification.
  231      * @since   1.1
  232      */
  233     public static final byte ENCLOSING_MARK = 7;
  234 
  235     /**
  236      * General category &quot;Mc&quot; in the Unicode specification.
  237      * @since   1.1
  238      */
  239     public static final byte COMBINING_SPACING_MARK = 8;
  240 
  241     /**
  242      * General category &quot;Nd&quot; in the Unicode specification.
  243      * @since   1.1
  244      */
<span class="line-modified">  245     public static final byte DECIMAL_DIGIT_NUMBER        = 9;</span>
  246 
  247     /**
  248      * General category &quot;Nl&quot; in the Unicode specification.
  249      * @since   1.1
  250      */
  251     public static final byte LETTER_NUMBER = 10;
  252 
  253     /**
  254      * General category &quot;No&quot; in the Unicode specification.
  255      * @since   1.1
  256      */
  257     public static final byte OTHER_NUMBER = 11;
  258 
  259     /**
  260      * General category &quot;Zs&quot; in the Unicode specification.
  261      * @since   1.1
  262      */
  263     public static final byte SPACE_SEPARATOR = 12;
  264 
  265     /**
</pre>
<hr />
<pre>
  373     /**
  374      * Undefined bidirectional character type. Undefined {@code char}
  375      * values have undefined directionality in the Unicode specification.
  376      * @since 1.4
  377      */
  378     public static final byte DIRECTIONALITY_UNDEFINED = -1;
  379 
  380     /**
  381      * Strong bidirectional character type &quot;L&quot; in the Unicode specification.
  382      * @since 1.4
  383      */
  384     public static final byte DIRECTIONALITY_LEFT_TO_RIGHT = 0;
  385 
  386     /**
  387      * Strong bidirectional character type &quot;R&quot; in the Unicode specification.
  388      * @since 1.4
  389      */
  390     public static final byte DIRECTIONALITY_RIGHT_TO_LEFT = 1;
  391 
  392     /**
<span class="line-modified">  393     * Strong bidirectional character type &quot;AL&quot; in the Unicode specification.</span>
  394      * @since 1.4
  395      */
  396     public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC = 2;
  397 
  398     /**
  399      * Weak bidirectional character type &quot;EN&quot; in the Unicode specification.
  400      * @since 1.4
  401      */
  402     public static final byte DIRECTIONALITY_EUROPEAN_NUMBER = 3;
  403 
  404     /**
  405      * Weak bidirectional character type &quot;ES&quot; in the Unicode specification.
  406      * @since 1.4
  407      */
  408     public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR = 4;
  409 
  410     /**
  411      * Weak bidirectional character type &quot;ET&quot; in the Unicode specification.
  412      * @since 1.4
  413      */
</pre>
<hr />
<pre>
 3164             new UnicodeBlock(&quot;MAKASAR&quot;);
 3165 
 3166         /**
 3167          * Constant for the &quot;Medefaidrin&quot; Unicode
 3168          * character block.
 3169          * @since 12
 3170          */
 3171         public static final UnicodeBlock MEDEFAIDRIN =
 3172             new UnicodeBlock(&quot;MEDEFAIDRIN&quot;);
 3173 
 3174         /**
 3175          * Constant for the &quot;Mayan Numerals&quot; Unicode
 3176          * character block.
 3177          * @since 12
 3178          */
 3179         public static final UnicodeBlock MAYAN_NUMERALS =
 3180             new UnicodeBlock(&quot;MAYAN_NUMERALS&quot;,
 3181                              &quot;MAYAN NUMERALS&quot;,
 3182                              &quot;MAYANNUMERALS&quot;);
 3183 
<span class="line-modified"> 3184        /**</span>
 3185          * Constant for the &quot;Indic Siyaq Numbers&quot; Unicode
 3186          * character block.
 3187          * @since 12
 3188          */
 3189         public static final UnicodeBlock INDIC_SIYAQ_NUMBERS =
 3190             new UnicodeBlock(&quot;INDIC_SIYAQ_NUMBERS&quot;,
 3191                              &quot;INDIC SIYAQ NUMBERS&quot;,
 3192                              &quot;INDICSIYAQNUMBERS&quot;);
 3193 
 3194         /**
 3195          * Constant for the &quot;Chess Symbols&quot; Unicode
 3196          * character block.
 3197          * @since 12
 3198          */
 3199         public static final UnicodeBlock CHESS_SYMBOLS =
 3200             new UnicodeBlock(&quot;CHESS_SYMBOLS&quot;,
 3201                              &quot;CHESS SYMBOLS&quot;,
 3202                              &quot;CHESSSYMBOLS&quot;);
 3203 
 3204         /**
</pre>
<hr />
<pre>
 3268         /**
 3269          * Constant for the &quot;Ottoman Siyaq Numbers&quot; Unicode
 3270          * character block.
 3271          * @since 13
 3272          */
 3273         public static final UnicodeBlock OTTOMAN_SIYAQ_NUMBERS =
 3274             new UnicodeBlock(&quot;OTTOMAN_SIYAQ_NUMBERS&quot;,
 3275                              &quot;OTTOMAN SIYAQ NUMBERS&quot;,
 3276                              &quot;OTTOMANSIYAQNUMBERS&quot;);
 3277 
 3278         /**
 3279          * Constant for the &quot;Symbols and Pictographs Extended-A&quot; Unicode
 3280          * character block.
 3281          * @since 13
 3282          */
 3283         public static final UnicodeBlock SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A =
 3284             new UnicodeBlock(&quot;SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A&quot;,
 3285                              &quot;SYMBOLS AND PICTOGRAPHS EXTENDED-A&quot;,
 3286                              &quot;SYMBOLSANDPICTOGRAPHSEXTENDED-A&quot;);
 3287 
<span class="line-modified"> 3288         private static final int blockStarts[] = {</span>
 3289             0x0000,   // 0000..007F; Basic Latin
 3290             0x0080,   // 0080..00FF; Latin-1 Supplement
 3291             0x0100,   // 0100..017F; Latin Extended-A
 3292             0x0180,   // 0180..024F; Latin Extended-B
 3293             0x0250,   // 0250..02AF; IPA Extensions
 3294             0x02B0,   // 02B0..02FF; Spacing Modifier Letters
 3295             0x0300,   // 0300..036F; Combining Diacritical Marks
 3296             0x0370,   // 0370..03FF; Greek and Coptic
 3297             0x0400,   // 0400..04FF; Cyrillic
 3298             0x0500,   // 0500..052F; Cyrillic Supplement
 3299             0x0530,   // 0530..058F; Armenian
 3300             0x0590,   // 0590..05FF; Hebrew
 3301             0x0600,   // 0600..06FF; Arabic
 3302             0x0700,   // 0700..074F; Syriac
 3303             0x0750,   // 0750..077F; Arabic Supplement
 3304             0x0780,   // 0780..07BF; Thaana
 3305             0x07C0,   // 07C0..07FF; NKo
 3306             0x0800,   // 0800..083F; Samaritan
 3307             0x0840,   // 0840..085F; Mandaic
 3308             0x0860,   // 0860..086F; Syriac Supplement
</pre>
<hr />
<pre>
 4756         SIDDHAM,
 4757 
 4758         /**
 4759          * Unicode script &quot;Khudawadi&quot;.
 4760          * @since 9
 4761          */
 4762         KHUDAWADI,
 4763 
 4764         /**
 4765          * Unicode script &quot;Tirhuta&quot;.
 4766          * @since 9
 4767          */
 4768         TIRHUTA,
 4769 
 4770         /**
 4771          * Unicode script &quot;Warang Citi&quot;.
 4772          * @since 9
 4773          */
 4774         WARANG_CITI,
 4775 
<span class="line-modified"> 4776          /**</span>
 4777          * Unicode script &quot;Ahom&quot;.
 4778          * @since 9
 4779          */
 4780         AHOM,
 4781 
 4782         /**
 4783          * Unicode script &quot;Anatolian Hieroglyphs&quot;.
 4784          * @since 9
 4785          */
 4786         ANATOLIAN_HIEROGLYPHS,
 4787 
 4788         /**
 4789          * Unicode script &quot;Hatran&quot;.
 4790          * @since 9
 4791          */
 4792         HATRAN,
 4793 
 4794         /**
 4795          * Unicode script &quot;Multani&quot;.
 4796          * @since 9
</pre>
<hr />
<pre>
 8051             HAN,                      // 20000..2A6D6
 8052             UNKNOWN,                  // 2A6D7..2A6FF
 8053             HAN,                      // 2A700..2B734
 8054             UNKNOWN,                  // 2B735..2B73F
 8055             HAN,                      // 2B740..2B81D
 8056             UNKNOWN,                  // 2B81E..2B81F
 8057             HAN,                      // 2B820..2CEA1
 8058             UNKNOWN,                  // 2CEA2..2CEAF
 8059             HAN,                      // 2CEB0..2EBE0
 8060             UNKNOWN,                  // 2EBE1..2F7FF
 8061             HAN,                      // 2F800..2FA1D
 8062             UNKNOWN,                  // 2FA1E..E0000
 8063             COMMON,                   // E0001
 8064             UNKNOWN,                  // E0002..E001F
 8065             COMMON,                   // E0020..E007F
 8066             UNKNOWN,                  // E0080..E00FF
 8067             INHERITED,                // E0100..E01EF
 8068             UNKNOWN,                  // E01F0..10FFFF
 8069         };
 8070 
<span class="line-modified"> 8071         private static HashMap&lt;String, Character.UnicodeScript&gt; aliases;</span>
 8072         static {
 8073             aliases = new HashMap&lt;&gt;((int)(153 / 0.75f + 1.0f));
 8074             aliases.put(&quot;ADLM&quot;, ADLAM);
 8075             aliases.put(&quot;AGHB&quot;, CAUCASIAN_ALBANIAN);
 8076             aliases.put(&quot;AHOM&quot;, AHOM);
 8077             aliases.put(&quot;ARAB&quot;, ARABIC);
 8078             aliases.put(&quot;ARMI&quot;, IMPERIAL_ARAMAIC);
 8079             aliases.put(&quot;ARMN&quot;, ARMENIAN);
 8080             aliases.put(&quot;AVST&quot;, AVESTAN);
 8081             aliases.put(&quot;BALI&quot;, BALINESE);
 8082             aliases.put(&quot;BAMU&quot;, BAMUM);
 8083             aliases.put(&quot;BASS&quot;, BASSA_VAH);
 8084             aliases.put(&quot;BATK&quot;, BATAK);
 8085             aliases.put(&quot;BENG&quot;, BENGALI);
 8086             aliases.put(&quot;BHKS&quot;, BHAIKSUKI);
 8087             aliases.put(&quot;BOPO&quot;, BOPOMOFO);
 8088             aliases.put(&quot;BRAH&quot;, BRAHMI);
 8089             aliases.put(&quot;BRAI&quot;, BRAILLE);
 8090             aliases.put(&quot;BUGI&quot;, BUGINESE);
 8091             aliases.put(&quot;BUHD&quot;, BUHID);
</pre>
<hr />
<pre>
 8404      * @return  {@code true} if the objects are the same;
 8405      *          {@code false} otherwise.
 8406      */
 8407     public boolean equals(Object obj) {
 8408         if (obj instanceof Character) {
 8409             return value == ((Character)obj).charValue();
 8410         }
 8411         return false;
 8412     }
 8413 
 8414     /**
 8415      * Returns a {@code String} object representing this
 8416      * {@code Character}&#39;s value.  The result is a string of
 8417      * length 1 whose sole component is the primitive
 8418      * {@code char} value represented by this
 8419      * {@code Character} object.
 8420      *
 8421      * @return  a string representation of this object.
 8422      */
 8423     public String toString() {
<span class="line-modified"> 8424         char buf[] = {value};</span>
<span class="line-removed"> 8425         return String.valueOf(buf);</span>
 8426     }
 8427 
 8428     /**
 8429      * Returns a {@code String} object representing the
 8430      * specified {@code char}.  The result is a string of length
 8431      * 1 consisting solely of the specified {@code char}.
 8432      *
 8433      * @apiNote This method cannot handle &lt;a
 8434      * href=&quot;#supplementary&quot;&gt; supplementary characters&lt;/a&gt;. To support
 8435      * all Unicode characters, including supplementary characters, use
 8436      * the {@link #toString(int)} method.
 8437      *
 8438      * @param c the {@code char} to be converted
 8439      * @return the string representation of the specified {@code char}
 8440      * @since 1.4
 8441      */
 8442     public static String toString(char c) {
 8443         return String.valueOf(c);
 8444     }
 8445 
</pre>
<hr />
<pre>
 8573      * &lt;p&gt;A char value is a surrogate code unit if and only if it is either
 8574      * a {@linkplain #isLowSurrogate(char) low-surrogate code unit} or
 8575      * a {@linkplain #isHighSurrogate(char) high-surrogate code unit}.
 8576      *
 8577      * @param  ch the {@code char} value to be tested.
 8578      * @return {@code true} if the {@code char} value is between
 8579      *         {@link #MIN_SURROGATE} and
 8580      *         {@link #MAX_SURROGATE} inclusive;
 8581      *         {@code false} otherwise.
 8582      * @since  1.7
 8583      */
 8584     public static boolean isSurrogate(char ch) {
 8585         return ch &gt;= MIN_SURROGATE &amp;&amp; ch &lt; (MAX_SURROGATE + 1);
 8586     }
 8587 
 8588     /**
 8589      * Determines whether the specified pair of {@code char}
 8590      * values is a valid
 8591      * &lt;a href=&quot;http://www.unicode.org/glossary/#surrogate_pair&quot;&gt;
 8592      * Unicode surrogate pair&lt;/a&gt;.
<span class="line-modified"> 8593 </span>
 8594      * &lt;p&gt;This method is equivalent to the expression:
 8595      * &lt;blockquote&gt;&lt;pre&gt;{@code
 8596      * isHighSurrogate(high) &amp;&amp; isLowSurrogate(low)
 8597      * }&lt;/pre&gt;&lt;/blockquote&gt;
 8598      *
 8599      * @param  high the high-surrogate code value to be tested
 8600      * @param  low the low-surrogate code value to be tested
 8601      * @return {@code true} if the specified high and
 8602      * low-surrogate code values represent a valid surrogate pair;
 8603      * {@code false} otherwise.
 8604      * @since  1.5
 8605      */
 8606     public static boolean isSurrogatePair(char high, char low) {
 8607         return isHighSurrogate(high) &amp;&amp; isLowSurrogate(low);
 8608     }
 8609 
 8610     /**
 8611      * Determines the number of {@code char} values needed to
 8612      * represent the specified character (Unicode code point). If the
 8613      * specified character is equal to or greater than 0x10000, then
</pre>
<hr />
<pre>
 9715      *
 9716      * @param   ch the character to be tested.
 9717      * @return  {@code true} if the character may be part of a
 9718      *          Java identifier; {@code false} otherwise.
 9719      * @see     Character#isJavaLetter(char)
 9720      * @see     Character#isJavaIdentifierStart(char)
 9721      * @see     Character#isJavaIdentifierPart(char)
 9722      * @see     Character#isLetter(char)
 9723      * @see     Character#isLetterOrDigit(char)
 9724      * @see     Character#isUnicodeIdentifierPart(char)
 9725      * @see     Character#isIdentifierIgnorable(char)
 9726      * @since   1.0.2
 9727      * @deprecated Replaced by isJavaIdentifierPart(char).
 9728      */
 9729     @Deprecated(since=&quot;1.1&quot;)
 9730     public static boolean isJavaLetterOrDigit(char ch) {
 9731         return isJavaIdentifierPart(ch);
 9732     }
 9733 
 9734     /**
<span class="line-modified"> 9735      * Determines if the specified character (Unicode code point) is an alphabet.</span>
 9736      * &lt;p&gt;
 9737      * A character is considered to be alphabetic if its general category type,
 9738      * provided by {@link Character#getType(int) getType(codePoint)}, is any of
 9739      * the following:
 9740      * &lt;ul&gt;
 9741      * &lt;li&gt; {@code UPPERCASE_LETTER}
 9742      * &lt;li&gt; {@code LOWERCASE_LETTER}
 9743      * &lt;li&gt; {@code TITLECASE_LETTER}
 9744      * &lt;li&gt; {@code MODIFIER_LETTER}
 9745      * &lt;li&gt; {@code OTHER_LETTER}
 9746      * &lt;li&gt; {@code LETTER_NUMBER}
 9747      * &lt;/ul&gt;
 9748      * or it has contributory property Other_Alphabetic as defined by the
 9749      * Unicode Standard.
 9750      *
 9751      * @param   codePoint the character (Unicode code point) to be tested.
 9752      * @return  {@code true} if the character is a Unicode alphabet
 9753      *          character, {@code false} otherwise.
 9754      * @since   1.7
 9755      */
</pre>
<hr />
<pre>
10950      * characters should have their glyphs horizontally mirrored when
10951      * displayed in text that is right-to-left.  For example,
10952      * {@code &#39;\u005Cu0028&#39;} LEFT PARENTHESIS is semantically
10953      * defined to be an &lt;i&gt;opening parenthesis&lt;/i&gt;.  This will appear
10954      * as a &quot;(&quot; in text that is left-to-right but as a &quot;)&quot; in text
10955      * that is right-to-left.
10956      *
10957      * @param   codePoint the character (Unicode code point) to be tested.
10958      * @return  {@code true} if the character is mirrored, {@code false}
10959      *          if the character is not mirrored or is not defined.
10960      * @since   1.5
10961      */
10962     public static boolean isMirrored(int codePoint) {
10963         return CharacterData.of(codePoint).isMirrored(codePoint);
10964     }
10965 
10966     /**
10967      * Compares two {@code Character} objects numerically.
10968      *
10969      * @param   anotherCharacter   the {@code Character} to be compared.
<span class="line-removed">10970 </span>
10971      * @return  the value {@code 0} if the argument {@code Character}
10972      *          is equal to this {@code Character}; a value less than
10973      *          {@code 0} if this {@code Character} is numerically less
10974      *          than the {@code Character} argument; and a value greater than
10975      *          {@code 0} if this {@code Character} is numerically greater
10976      *          than the {@code Character} argument (unsigned comparison).
10977      *          Note that this is strictly a numerical comparison; it is not
10978      *          locale-dependent.
10979      * @since   1.2
10980      */
10981     public int compareTo(Character anotherCharacter) {
10982         return compare(this.value, anotherCharacter.value);
10983     }
10984 
10985     /**
10986      * Compares two {@code char} values numerically.
10987      * The value returned is identical to what would be returned by:
10988      * &lt;pre&gt;
10989      *    Character.valueOf(x).compareTo(Character.valueOf(y))
10990      * &lt;/pre&gt;
</pre>
<hr />
<pre>
11057      * specified {@code char} value.
11058      *
11059      * @param ch The {@code char} of which to reverse the byte order.
11060      * @return the value obtained by reversing (or, equivalently, swapping)
11061      *     the bytes in the specified {@code char} value.
11062      * @since 1.5
11063      */
11064     @HotSpotIntrinsicCandidate
11065     public static char reverseBytes(char ch) {
11066         return (char) (((ch &amp; 0xFF00) &gt;&gt; 8) | (ch &lt;&lt; 8));
11067     }
11068 
11069     /**
11070      * Returns the Unicode name of the specified character
11071      * {@code codePoint}, or null if the code point is
11072      * {@link #UNASSIGNED unassigned}.
11073      * &lt;p&gt;
11074      * Note: if the specified character is not assigned a name by
11075      * the &lt;i&gt;UnicodeData&lt;/i&gt; file (part of the Unicode Character
11076      * Database maintained by the Unicode Consortium), the returned
<span class="line-modified">11077      * name is the same as the result of expression.</span>
11078      *
11079      * &lt;blockquote&gt;{@code
11080      *     Character.UnicodeBlock.of(codePoint).toString().replace(&#39;_&#39;, &#39; &#39;)
11081      *     + &quot; &quot;
11082      *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11083      *
11084      * }&lt;/blockquote&gt;
11085      *
11086      * @param  codePoint the character (Unicode code point)
11087      *
11088      * @return the Unicode name of the specified character, or null if
11089      *         the code point is unassigned.
11090      *
11091      * @throws IllegalArgumentException if the specified
11092      *            {@code codePoint} is not a valid Unicode
11093      *            code point.
11094      *
11095      * @since 1.7
11096      */
11097     public static String getName(int codePoint) {
</pre>
<hr />
<pre>
11101         }
11102         String name = CharacterName.getInstance().getName(codePoint);
11103         if (name != null)
11104             return name;
11105         if (getType(codePoint) == UNASSIGNED)
11106             return null;
11107         UnicodeBlock block = UnicodeBlock.of(codePoint);
11108         if (block != null)
11109             return block.toString().replace(&#39;_&#39;, &#39; &#39;) + &quot; &quot;
11110                    + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11111         // should never come here
11112         return Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11113     }
11114 
11115     /**
11116      * Returns the code point value of the Unicode character specified by
11117      * the given Unicode character name.
11118      * &lt;p&gt;
11119      * Note: if a character is not assigned a name by the &lt;i&gt;UnicodeData&lt;/i&gt;
11120      * file (part of the Unicode Character Database maintained by the Unicode
<span class="line-modified">11121      * Consortium), its name is defined as the result of expression</span>
11122      *
11123      * &lt;blockquote&gt;{@code
11124      *     Character.UnicodeBlock.of(codePoint).toString().replace(&#39;_&#39;, &#39; &#39;)
11125      *     + &quot; &quot;
11126      *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11127      *
11128      * }&lt;/blockquote&gt;
11129      * &lt;p&gt;
11130      * The {@code name} matching is case insensitive, with any leading and
11131      * trailing whitespace character removed.
11132      *
11133      * @param  name the Unicode character name
11134      *
11135      * @return the code point value of the character specified by its name.
11136      *
11137      * @throws IllegalArgumentException if the specified {@code name}
11138      *         is not a valid Unicode character name.
11139      * @throws NullPointerException if {@code name} is {@code null}
11140      *
11141      * @since 9
</pre>
</td>
<td>
<hr />
<pre>
    1 /*
<span class="line-modified">    2  * Copyright (c) 2002, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4  *
    5  * This code is free software; you can redistribute it and/or modify it
    6  * under the terms of the GNU General Public License version 2 only, as
    7  * published by the Free Software Foundation.  Oracle designates this
    8  * particular file as subject to the &quot;Classpath&quot; exception as provided
    9  * by Oracle in the LICENSE file that accompanied this code.
   10  *
   11  * This code is distributed in the hope that it will be useful, but WITHOUT
   12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   14  * version 2 for more details (a copy is included in the LICENSE file that
   15  * accompanied this code).
   16  *
   17  * You should have received a copy of the GNU General Public License version
   18  * 2 along with this work; if not, write to the Free Software Foundation,
   19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   20  *
   21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  225      * @since   1.1
  226      */
  227     public static final byte NON_SPACING_MARK = 6;
  228 
  229     /**
  230      * General category &quot;Me&quot; in the Unicode specification.
  231      * @since   1.1
  232      */
  233     public static final byte ENCLOSING_MARK = 7;
  234 
  235     /**
  236      * General category &quot;Mc&quot; in the Unicode specification.
  237      * @since   1.1
  238      */
  239     public static final byte COMBINING_SPACING_MARK = 8;
  240 
  241     /**
  242      * General category &quot;Nd&quot; in the Unicode specification.
  243      * @since   1.1
  244      */
<span class="line-modified">  245     public static final byte DECIMAL_DIGIT_NUMBER = 9;</span>
  246 
  247     /**
  248      * General category &quot;Nl&quot; in the Unicode specification.
  249      * @since   1.1
  250      */
  251     public static final byte LETTER_NUMBER = 10;
  252 
  253     /**
  254      * General category &quot;No&quot; in the Unicode specification.
  255      * @since   1.1
  256      */
  257     public static final byte OTHER_NUMBER = 11;
  258 
  259     /**
  260      * General category &quot;Zs&quot; in the Unicode specification.
  261      * @since   1.1
  262      */
  263     public static final byte SPACE_SEPARATOR = 12;
  264 
  265     /**
</pre>
<hr />
<pre>
  373     /**
  374      * Undefined bidirectional character type. Undefined {@code char}
  375      * values have undefined directionality in the Unicode specification.
  376      * @since 1.4
  377      */
  378     public static final byte DIRECTIONALITY_UNDEFINED = -1;
  379 
  380     /**
  381      * Strong bidirectional character type &quot;L&quot; in the Unicode specification.
  382      * @since 1.4
  383      */
  384     public static final byte DIRECTIONALITY_LEFT_TO_RIGHT = 0;
  385 
  386     /**
  387      * Strong bidirectional character type &quot;R&quot; in the Unicode specification.
  388      * @since 1.4
  389      */
  390     public static final byte DIRECTIONALITY_RIGHT_TO_LEFT = 1;
  391 
  392     /**
<span class="line-modified">  393      * Strong bidirectional character type &quot;AL&quot; in the Unicode specification.</span>
  394      * @since 1.4
  395      */
  396     public static final byte DIRECTIONALITY_RIGHT_TO_LEFT_ARABIC = 2;
  397 
  398     /**
  399      * Weak bidirectional character type &quot;EN&quot; in the Unicode specification.
  400      * @since 1.4
  401      */
  402     public static final byte DIRECTIONALITY_EUROPEAN_NUMBER = 3;
  403 
  404     /**
  405      * Weak bidirectional character type &quot;ES&quot; in the Unicode specification.
  406      * @since 1.4
  407      */
  408     public static final byte DIRECTIONALITY_EUROPEAN_NUMBER_SEPARATOR = 4;
  409 
  410     /**
  411      * Weak bidirectional character type &quot;ET&quot; in the Unicode specification.
  412      * @since 1.4
  413      */
</pre>
<hr />
<pre>
 3164             new UnicodeBlock(&quot;MAKASAR&quot;);
 3165 
 3166         /**
 3167          * Constant for the &quot;Medefaidrin&quot; Unicode
 3168          * character block.
 3169          * @since 12
 3170          */
 3171         public static final UnicodeBlock MEDEFAIDRIN =
 3172             new UnicodeBlock(&quot;MEDEFAIDRIN&quot;);
 3173 
 3174         /**
 3175          * Constant for the &quot;Mayan Numerals&quot; Unicode
 3176          * character block.
 3177          * @since 12
 3178          */
 3179         public static final UnicodeBlock MAYAN_NUMERALS =
 3180             new UnicodeBlock(&quot;MAYAN_NUMERALS&quot;,
 3181                              &quot;MAYAN NUMERALS&quot;,
 3182                              &quot;MAYANNUMERALS&quot;);
 3183 
<span class="line-modified"> 3184         /**</span>
 3185          * Constant for the &quot;Indic Siyaq Numbers&quot; Unicode
 3186          * character block.
 3187          * @since 12
 3188          */
 3189         public static final UnicodeBlock INDIC_SIYAQ_NUMBERS =
 3190             new UnicodeBlock(&quot;INDIC_SIYAQ_NUMBERS&quot;,
 3191                              &quot;INDIC SIYAQ NUMBERS&quot;,
 3192                              &quot;INDICSIYAQNUMBERS&quot;);
 3193 
 3194         /**
 3195          * Constant for the &quot;Chess Symbols&quot; Unicode
 3196          * character block.
 3197          * @since 12
 3198          */
 3199         public static final UnicodeBlock CHESS_SYMBOLS =
 3200             new UnicodeBlock(&quot;CHESS_SYMBOLS&quot;,
 3201                              &quot;CHESS SYMBOLS&quot;,
 3202                              &quot;CHESSSYMBOLS&quot;);
 3203 
 3204         /**
</pre>
<hr />
<pre>
 3268         /**
 3269          * Constant for the &quot;Ottoman Siyaq Numbers&quot; Unicode
 3270          * character block.
 3271          * @since 13
 3272          */
 3273         public static final UnicodeBlock OTTOMAN_SIYAQ_NUMBERS =
 3274             new UnicodeBlock(&quot;OTTOMAN_SIYAQ_NUMBERS&quot;,
 3275                              &quot;OTTOMAN SIYAQ NUMBERS&quot;,
 3276                              &quot;OTTOMANSIYAQNUMBERS&quot;);
 3277 
 3278         /**
 3279          * Constant for the &quot;Symbols and Pictographs Extended-A&quot; Unicode
 3280          * character block.
 3281          * @since 13
 3282          */
 3283         public static final UnicodeBlock SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A =
 3284             new UnicodeBlock(&quot;SYMBOLS_AND_PICTOGRAPHS_EXTENDED_A&quot;,
 3285                              &quot;SYMBOLS AND PICTOGRAPHS EXTENDED-A&quot;,
 3286                              &quot;SYMBOLSANDPICTOGRAPHSEXTENDED-A&quot;);
 3287 
<span class="line-modified"> 3288         private static final int[] blockStarts = {</span>
 3289             0x0000,   // 0000..007F; Basic Latin
 3290             0x0080,   // 0080..00FF; Latin-1 Supplement
 3291             0x0100,   // 0100..017F; Latin Extended-A
 3292             0x0180,   // 0180..024F; Latin Extended-B
 3293             0x0250,   // 0250..02AF; IPA Extensions
 3294             0x02B0,   // 02B0..02FF; Spacing Modifier Letters
 3295             0x0300,   // 0300..036F; Combining Diacritical Marks
 3296             0x0370,   // 0370..03FF; Greek and Coptic
 3297             0x0400,   // 0400..04FF; Cyrillic
 3298             0x0500,   // 0500..052F; Cyrillic Supplement
 3299             0x0530,   // 0530..058F; Armenian
 3300             0x0590,   // 0590..05FF; Hebrew
 3301             0x0600,   // 0600..06FF; Arabic
 3302             0x0700,   // 0700..074F; Syriac
 3303             0x0750,   // 0750..077F; Arabic Supplement
 3304             0x0780,   // 0780..07BF; Thaana
 3305             0x07C0,   // 07C0..07FF; NKo
 3306             0x0800,   // 0800..083F; Samaritan
 3307             0x0840,   // 0840..085F; Mandaic
 3308             0x0860,   // 0860..086F; Syriac Supplement
</pre>
<hr />
<pre>
 4756         SIDDHAM,
 4757 
 4758         /**
 4759          * Unicode script &quot;Khudawadi&quot;.
 4760          * @since 9
 4761          */
 4762         KHUDAWADI,
 4763 
 4764         /**
 4765          * Unicode script &quot;Tirhuta&quot;.
 4766          * @since 9
 4767          */
 4768         TIRHUTA,
 4769 
 4770         /**
 4771          * Unicode script &quot;Warang Citi&quot;.
 4772          * @since 9
 4773          */
 4774         WARANG_CITI,
 4775 
<span class="line-modified"> 4776         /**</span>
 4777          * Unicode script &quot;Ahom&quot;.
 4778          * @since 9
 4779          */
 4780         AHOM,
 4781 
 4782         /**
 4783          * Unicode script &quot;Anatolian Hieroglyphs&quot;.
 4784          * @since 9
 4785          */
 4786         ANATOLIAN_HIEROGLYPHS,
 4787 
 4788         /**
 4789          * Unicode script &quot;Hatran&quot;.
 4790          * @since 9
 4791          */
 4792         HATRAN,
 4793 
 4794         /**
 4795          * Unicode script &quot;Multani&quot;.
 4796          * @since 9
</pre>
<hr />
<pre>
 8051             HAN,                      // 20000..2A6D6
 8052             UNKNOWN,                  // 2A6D7..2A6FF
 8053             HAN,                      // 2A700..2B734
 8054             UNKNOWN,                  // 2B735..2B73F
 8055             HAN,                      // 2B740..2B81D
 8056             UNKNOWN,                  // 2B81E..2B81F
 8057             HAN,                      // 2B820..2CEA1
 8058             UNKNOWN,                  // 2CEA2..2CEAF
 8059             HAN,                      // 2CEB0..2EBE0
 8060             UNKNOWN,                  // 2EBE1..2F7FF
 8061             HAN,                      // 2F800..2FA1D
 8062             UNKNOWN,                  // 2FA1E..E0000
 8063             COMMON,                   // E0001
 8064             UNKNOWN,                  // E0002..E001F
 8065             COMMON,                   // E0020..E007F
 8066             UNKNOWN,                  // E0080..E00FF
 8067             INHERITED,                // E0100..E01EF
 8068             UNKNOWN,                  // E01F0..10FFFF
 8069         };
 8070 
<span class="line-modified"> 8071         private static final HashMap&lt;String, Character.UnicodeScript&gt; aliases;</span>
 8072         static {
 8073             aliases = new HashMap&lt;&gt;((int)(153 / 0.75f + 1.0f));
 8074             aliases.put(&quot;ADLM&quot;, ADLAM);
 8075             aliases.put(&quot;AGHB&quot;, CAUCASIAN_ALBANIAN);
 8076             aliases.put(&quot;AHOM&quot;, AHOM);
 8077             aliases.put(&quot;ARAB&quot;, ARABIC);
 8078             aliases.put(&quot;ARMI&quot;, IMPERIAL_ARAMAIC);
 8079             aliases.put(&quot;ARMN&quot;, ARMENIAN);
 8080             aliases.put(&quot;AVST&quot;, AVESTAN);
 8081             aliases.put(&quot;BALI&quot;, BALINESE);
 8082             aliases.put(&quot;BAMU&quot;, BAMUM);
 8083             aliases.put(&quot;BASS&quot;, BASSA_VAH);
 8084             aliases.put(&quot;BATK&quot;, BATAK);
 8085             aliases.put(&quot;BENG&quot;, BENGALI);
 8086             aliases.put(&quot;BHKS&quot;, BHAIKSUKI);
 8087             aliases.put(&quot;BOPO&quot;, BOPOMOFO);
 8088             aliases.put(&quot;BRAH&quot;, BRAHMI);
 8089             aliases.put(&quot;BRAI&quot;, BRAILLE);
 8090             aliases.put(&quot;BUGI&quot;, BUGINESE);
 8091             aliases.put(&quot;BUHD&quot;, BUHID);
</pre>
<hr />
<pre>
 8404      * @return  {@code true} if the objects are the same;
 8405      *          {@code false} otherwise.
 8406      */
 8407     public boolean equals(Object obj) {
 8408         if (obj instanceof Character) {
 8409             return value == ((Character)obj).charValue();
 8410         }
 8411         return false;
 8412     }
 8413 
 8414     /**
 8415      * Returns a {@code String} object representing this
 8416      * {@code Character}&#39;s value.  The result is a string of
 8417      * length 1 whose sole component is the primitive
 8418      * {@code char} value represented by this
 8419      * {@code Character} object.
 8420      *
 8421      * @return  a string representation of this object.
 8422      */
 8423     public String toString() {
<span class="line-modified"> 8424         return String.valueOf(value);</span>

 8425     }
 8426 
 8427     /**
 8428      * Returns a {@code String} object representing the
 8429      * specified {@code char}.  The result is a string of length
 8430      * 1 consisting solely of the specified {@code char}.
 8431      *
 8432      * @apiNote This method cannot handle &lt;a
 8433      * href=&quot;#supplementary&quot;&gt; supplementary characters&lt;/a&gt;. To support
 8434      * all Unicode characters, including supplementary characters, use
 8435      * the {@link #toString(int)} method.
 8436      *
 8437      * @param c the {@code char} to be converted
 8438      * @return the string representation of the specified {@code char}
 8439      * @since 1.4
 8440      */
 8441     public static String toString(char c) {
 8442         return String.valueOf(c);
 8443     }
 8444 
</pre>
<hr />
<pre>
 8572      * &lt;p&gt;A char value is a surrogate code unit if and only if it is either
 8573      * a {@linkplain #isLowSurrogate(char) low-surrogate code unit} or
 8574      * a {@linkplain #isHighSurrogate(char) high-surrogate code unit}.
 8575      *
 8576      * @param  ch the {@code char} value to be tested.
 8577      * @return {@code true} if the {@code char} value is between
 8578      *         {@link #MIN_SURROGATE} and
 8579      *         {@link #MAX_SURROGATE} inclusive;
 8580      *         {@code false} otherwise.
 8581      * @since  1.7
 8582      */
 8583     public static boolean isSurrogate(char ch) {
 8584         return ch &gt;= MIN_SURROGATE &amp;&amp; ch &lt; (MAX_SURROGATE + 1);
 8585     }
 8586 
 8587     /**
 8588      * Determines whether the specified pair of {@code char}
 8589      * values is a valid
 8590      * &lt;a href=&quot;http://www.unicode.org/glossary/#surrogate_pair&quot;&gt;
 8591      * Unicode surrogate pair&lt;/a&gt;.
<span class="line-modified"> 8592      *</span>
 8593      * &lt;p&gt;This method is equivalent to the expression:
 8594      * &lt;blockquote&gt;&lt;pre&gt;{@code
 8595      * isHighSurrogate(high) &amp;&amp; isLowSurrogate(low)
 8596      * }&lt;/pre&gt;&lt;/blockquote&gt;
 8597      *
 8598      * @param  high the high-surrogate code value to be tested
 8599      * @param  low the low-surrogate code value to be tested
 8600      * @return {@code true} if the specified high and
 8601      * low-surrogate code values represent a valid surrogate pair;
 8602      * {@code false} otherwise.
 8603      * @since  1.5
 8604      */
 8605     public static boolean isSurrogatePair(char high, char low) {
 8606         return isHighSurrogate(high) &amp;&amp; isLowSurrogate(low);
 8607     }
 8608 
 8609     /**
 8610      * Determines the number of {@code char} values needed to
 8611      * represent the specified character (Unicode code point). If the
 8612      * specified character is equal to or greater than 0x10000, then
</pre>
<hr />
<pre>
 9714      *
 9715      * @param   ch the character to be tested.
 9716      * @return  {@code true} if the character may be part of a
 9717      *          Java identifier; {@code false} otherwise.
 9718      * @see     Character#isJavaLetter(char)
 9719      * @see     Character#isJavaIdentifierStart(char)
 9720      * @see     Character#isJavaIdentifierPart(char)
 9721      * @see     Character#isLetter(char)
 9722      * @see     Character#isLetterOrDigit(char)
 9723      * @see     Character#isUnicodeIdentifierPart(char)
 9724      * @see     Character#isIdentifierIgnorable(char)
 9725      * @since   1.0.2
 9726      * @deprecated Replaced by isJavaIdentifierPart(char).
 9727      */
 9728     @Deprecated(since=&quot;1.1&quot;)
 9729     public static boolean isJavaLetterOrDigit(char ch) {
 9730         return isJavaIdentifierPart(ch);
 9731     }
 9732 
 9733     /**
<span class="line-modified"> 9734      * Determines if the specified character (Unicode code point) is alphabetic.</span>
 9735      * &lt;p&gt;
 9736      * A character is considered to be alphabetic if its general category type,
 9737      * provided by {@link Character#getType(int) getType(codePoint)}, is any of
 9738      * the following:
 9739      * &lt;ul&gt;
 9740      * &lt;li&gt; {@code UPPERCASE_LETTER}
 9741      * &lt;li&gt; {@code LOWERCASE_LETTER}
 9742      * &lt;li&gt; {@code TITLECASE_LETTER}
 9743      * &lt;li&gt; {@code MODIFIER_LETTER}
 9744      * &lt;li&gt; {@code OTHER_LETTER}
 9745      * &lt;li&gt; {@code LETTER_NUMBER}
 9746      * &lt;/ul&gt;
 9747      * or it has contributory property Other_Alphabetic as defined by the
 9748      * Unicode Standard.
 9749      *
 9750      * @param   codePoint the character (Unicode code point) to be tested.
 9751      * @return  {@code true} if the character is a Unicode alphabet
 9752      *          character, {@code false} otherwise.
 9753      * @since   1.7
 9754      */
</pre>
<hr />
<pre>
10949      * characters should have their glyphs horizontally mirrored when
10950      * displayed in text that is right-to-left.  For example,
10951      * {@code &#39;\u005Cu0028&#39;} LEFT PARENTHESIS is semantically
10952      * defined to be an &lt;i&gt;opening parenthesis&lt;/i&gt;.  This will appear
10953      * as a &quot;(&quot; in text that is left-to-right but as a &quot;)&quot; in text
10954      * that is right-to-left.
10955      *
10956      * @param   codePoint the character (Unicode code point) to be tested.
10957      * @return  {@code true} if the character is mirrored, {@code false}
10958      *          if the character is not mirrored or is not defined.
10959      * @since   1.5
10960      */
10961     public static boolean isMirrored(int codePoint) {
10962         return CharacterData.of(codePoint).isMirrored(codePoint);
10963     }
10964 
10965     /**
10966      * Compares two {@code Character} objects numerically.
10967      *
10968      * @param   anotherCharacter   the {@code Character} to be compared.

10969      * @return  the value {@code 0} if the argument {@code Character}
10970      *          is equal to this {@code Character}; a value less than
10971      *          {@code 0} if this {@code Character} is numerically less
10972      *          than the {@code Character} argument; and a value greater than
10973      *          {@code 0} if this {@code Character} is numerically greater
10974      *          than the {@code Character} argument (unsigned comparison).
10975      *          Note that this is strictly a numerical comparison; it is not
10976      *          locale-dependent.
10977      * @since   1.2
10978      */
10979     public int compareTo(Character anotherCharacter) {
10980         return compare(this.value, anotherCharacter.value);
10981     }
10982 
10983     /**
10984      * Compares two {@code char} values numerically.
10985      * The value returned is identical to what would be returned by:
10986      * &lt;pre&gt;
10987      *    Character.valueOf(x).compareTo(Character.valueOf(y))
10988      * &lt;/pre&gt;
</pre>
<hr />
<pre>
11055      * specified {@code char} value.
11056      *
11057      * @param ch The {@code char} of which to reverse the byte order.
11058      * @return the value obtained by reversing (or, equivalently, swapping)
11059      *     the bytes in the specified {@code char} value.
11060      * @since 1.5
11061      */
11062     @HotSpotIntrinsicCandidate
11063     public static char reverseBytes(char ch) {
11064         return (char) (((ch &amp; 0xFF00) &gt;&gt; 8) | (ch &lt;&lt; 8));
11065     }
11066 
11067     /**
11068      * Returns the Unicode name of the specified character
11069      * {@code codePoint}, or null if the code point is
11070      * {@link #UNASSIGNED unassigned}.
11071      * &lt;p&gt;
11072      * Note: if the specified character is not assigned a name by
11073      * the &lt;i&gt;UnicodeData&lt;/i&gt; file (part of the Unicode Character
11074      * Database maintained by the Unicode Consortium), the returned
<span class="line-modified">11075      * name is the same as the result of expression:</span>
11076      *
11077      * &lt;blockquote&gt;{@code
11078      *     Character.UnicodeBlock.of(codePoint).toString().replace(&#39;_&#39;, &#39; &#39;)
11079      *     + &quot; &quot;
11080      *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11081      *
11082      * }&lt;/blockquote&gt;
11083      *
11084      * @param  codePoint the character (Unicode code point)
11085      *
11086      * @return the Unicode name of the specified character, or null if
11087      *         the code point is unassigned.
11088      *
11089      * @throws IllegalArgumentException if the specified
11090      *            {@code codePoint} is not a valid Unicode
11091      *            code point.
11092      *
11093      * @since 1.7
11094      */
11095     public static String getName(int codePoint) {
</pre>
<hr />
<pre>
11099         }
11100         String name = CharacterName.getInstance().getName(codePoint);
11101         if (name != null)
11102             return name;
11103         if (getType(codePoint) == UNASSIGNED)
11104             return null;
11105         UnicodeBlock block = UnicodeBlock.of(codePoint);
11106         if (block != null)
11107             return block.toString().replace(&#39;_&#39;, &#39; &#39;) + &quot; &quot;
11108                    + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11109         // should never come here
11110         return Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11111     }
11112 
11113     /**
11114      * Returns the code point value of the Unicode character specified by
11115      * the given Unicode character name.
11116      * &lt;p&gt;
11117      * Note: if a character is not assigned a name by the &lt;i&gt;UnicodeData&lt;/i&gt;
11118      * file (part of the Unicode Character Database maintained by the Unicode
<span class="line-modified">11119      * Consortium), its name is defined as the result of expression:</span>
11120      *
11121      * &lt;blockquote&gt;{@code
11122      *     Character.UnicodeBlock.of(codePoint).toString().replace(&#39;_&#39;, &#39; &#39;)
11123      *     + &quot; &quot;
11124      *     + Integer.toHexString(codePoint).toUpperCase(Locale.ROOT);
11125      *
11126      * }&lt;/blockquote&gt;
11127      * &lt;p&gt;
11128      * The {@code name} matching is case insensitive, with any leading and
11129      * trailing whitespace character removed.
11130      *
11131      * @param  name the Unicode character name
11132      *
11133      * @return the code point value of the character specified by its name.
11134      *
11135      * @throws IllegalArgumentException if the specified {@code name}
11136      *         is not a valid Unicode character name.
11137      * @throws NullPointerException if {@code name} is {@code null}
11138      *
11139      * @since 9
</pre>
</td>
</tr>
</table>
<center><a href="Boolean.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="Class.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
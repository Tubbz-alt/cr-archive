<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/lang/Thread.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1994, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.lang;
  27 
  28 import java.lang.ref.Reference;
  29 import java.lang.ref.ReferenceQueue;
  30 import java.lang.ref.WeakReference;
  31 import java.security.AccessController;
  32 import java.security.AccessControlContext;
  33 import java.security.PrivilegedAction;
  34 import java.util.Map;
  35 import java.util.HashMap;
  36 import java.util.concurrent.ConcurrentHashMap;
  37 import java.util.concurrent.ConcurrentMap;
  38 import java.util.concurrent.TimeUnit;
  39 import java.util.concurrent.locks.LockSupport;
  40 
  41 import jdk.internal.misc.TerminatingThreadLocal;
  42 import sun.nio.ch.Interruptible;
  43 import jdk.internal.reflect.CallerSensitive;
  44 import jdk.internal.reflect.Reflection;
  45 import sun.security.util.SecurityConstants;
  46 import jdk.internal.HotSpotIntrinsicCandidate;
  47 
  48 /**
  49  * A &lt;i&gt;thread&lt;/i&gt; is a thread of execution in a program. The Java
  50  * Virtual Machine allows an application to have multiple threads of
  51  * execution running concurrently.
  52  * &lt;p&gt;
  53  * Every thread has a priority. Threads with higher priority are
  54  * executed in preference to threads with lower priority. Each thread
  55  * may or may not also be marked as a daemon. When code running in
  56  * some thread creates a new {@code Thread} object, the new
  57  * thread has its priority initially set equal to the priority of the
  58  * creating thread, and is a daemon thread if and only if the
  59  * creating thread is a daemon.
  60  * &lt;p&gt;
  61  * When a Java Virtual Machine starts up, there is usually a single
  62  * non-daemon thread (which typically calls the method named
  63  * {@code main} of some designated class). The Java Virtual
  64  * Machine continues to execute threads until either of the following
  65  * occurs:
  66  * &lt;ul&gt;
  67  * &lt;li&gt;The {@code exit} method of class {@code Runtime} has been
  68  *     called and the security manager has permitted the exit operation
  69  *     to take place.
  70  * &lt;li&gt;All threads that are not daemon threads have died, either by
  71  *     returning from the call to the {@code run} method or by
  72  *     throwing an exception that propagates beyond the {@code run}
  73  *     method.
  74  * &lt;/ul&gt;
  75  * &lt;p&gt;
  76  * There are two ways to create a new thread of execution. One is to
  77  * declare a class to be a subclass of {@code Thread}. This
  78  * subclass should override the {@code run} method of class
  79  * {@code Thread}. An instance of the subclass can then be
  80  * allocated and started. For example, a thread that computes primes
  81  * larger than a stated value could be written as follows:
  82  * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
  83  *     class PrimeThread extends Thread {
  84  *         long minPrime;
  85  *         PrimeThread(long minPrime) {
  86  *             this.minPrime = minPrime;
  87  *         }
  88  *
  89  *         public void run() {
  90  *             // compute primes larger than minPrime
  91  *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
  92  *         }
  93  *     }
  94  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
  95  * &lt;p&gt;
  96  * The following code would then create a thread and start it running:
  97  * &lt;blockquote&gt;&lt;pre&gt;
  98  *     PrimeThread p = new PrimeThread(143);
  99  *     p.start();
 100  * &lt;/pre&gt;&lt;/blockquote&gt;
 101  * &lt;p&gt;
 102  * The other way to create a thread is to declare a class that
 103  * implements the {@code Runnable} interface. That class then
 104  * implements the {@code run} method. An instance of the class can
 105  * then be allocated, passed as an argument when creating
 106  * {@code Thread}, and started. The same example in this other
 107  * style looks like the following:
 108  * &lt;hr&gt;&lt;blockquote&gt;&lt;pre&gt;
 109  *     class PrimeRun implements Runnable {
 110  *         long minPrime;
 111  *         PrimeRun(long minPrime) {
 112  *             this.minPrime = minPrime;
 113  *         }
 114  *
 115  *         public void run() {
 116  *             // compute primes larger than minPrime
 117  *             &amp;nbsp;.&amp;nbsp;.&amp;nbsp;.
 118  *         }
 119  *     }
 120  * &lt;/pre&gt;&lt;/blockquote&gt;&lt;hr&gt;
 121  * &lt;p&gt;
 122  * The following code would then create a thread and start it running:
 123  * &lt;blockquote&gt;&lt;pre&gt;
 124  *     PrimeRun p = new PrimeRun(143);
 125  *     new Thread(p).start();
 126  * &lt;/pre&gt;&lt;/blockquote&gt;
 127  * &lt;p&gt;
 128  * Every thread has a name for identification purposes. More than
 129  * one thread may have the same name. If a name is not specified when
 130  * a thread is created, a new name is generated for it.
 131  * &lt;p&gt;
 132  * Unless otherwise noted, passing a {@code null} argument to a constructor
 133  * or method in this class will cause a {@link NullPointerException} to be
 134  * thrown.
 135  *
 136  * @author  unascribed
 137  * @see     Runnable
 138  * @see     Runtime#exit(int)
 139  * @see     #run()
 140  * @see     #stop()
 141  * @since   1.0
 142  */
 143 public class Thread implements Runnable {
 144     /* Make sure registerNatives is the first thing &lt;clinit&gt; does. */
 145     private static native void registerNatives();
 146     static {
 147         registerNatives();
 148     }
 149 
 150     private volatile String name;
 151     private int priority;
 152 
 153     /* Whether or not the thread is a daemon thread. */
 154     private boolean daemon = false;
 155 
 156     /* Interrupt state of the thread - read/written directly by JVM */
 157     private volatile boolean interrupted;
 158 
 159     /* Fields reserved for exclusive use by the JVM */
 160     private boolean stillborn = false;
 161     private long eetop;
 162 
 163     /* What will be run. */
 164     private Runnable target;
 165 
 166     /* The group of this thread */
 167     private ThreadGroup group;
 168 
 169     /* The context ClassLoader for this thread */
 170     private ClassLoader contextClassLoader;
 171 
 172     /* The inherited AccessControlContext of this thread */
 173     private AccessControlContext inheritedAccessControlContext;
 174 
 175     /* For autonumbering anonymous threads. */
 176     private static int threadInitNumber;
 177     private static synchronized int nextThreadNum() {
 178         return threadInitNumber++;
 179     }
 180 
 181     /* ThreadLocal values pertaining to this thread. This map is maintained
 182      * by the ThreadLocal class. */
 183     ThreadLocal.ThreadLocalMap threadLocals = null;
 184 
 185     /*
 186      * InheritableThreadLocal values pertaining to this thread. This map is
 187      * maintained by the InheritableThreadLocal class.
 188      */
 189     ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
 190 
 191     /*
 192      * The requested stack size for this thread, or 0 if the creator did
 193      * not specify a stack size.  It is up to the VM to do whatever it
 194      * likes with this number; some VMs will ignore it.
 195      */
 196     private final long stackSize;
 197 
 198     /*
 199      * Thread ID
 200      */
 201     private final long tid;
 202 
 203     /* For generating thread ID */
 204     private static long threadSeqNumber;
 205 
 206     private static synchronized long nextThreadID() {
 207         return ++threadSeqNumber;
 208     }
 209 
 210     /*
 211      * Java thread status for tools, default indicates thread &#39;not yet started&#39;
 212      */
 213     private volatile int threadStatus;
 214 
 215     /**
 216      * The argument supplied to the current call to
 217      * java.util.concurrent.locks.LockSupport.park.
 218      * Set by (private) java.util.concurrent.locks.LockSupport.setBlocker
 219      * Accessed using java.util.concurrent.locks.LockSupport.getBlocker
 220      */
 221     volatile Object parkBlocker;
 222 
 223     /* The object in which this thread is blocked in an interruptible I/O
 224      * operation, if any.  The blocker&#39;s interrupt method should be invoked
 225      * after setting this thread&#39;s interrupt status.
 226      */
 227     private volatile Interruptible blocker;
 228     private final Object blockerLock = new Object();
 229 
 230     /* Set the blocker field; invoked via jdk.internal.access.SharedSecrets
 231      * from java.nio code
 232      */
 233     static void blockedOn(Interruptible b) {
 234         Thread me = Thread.currentThread();
 235         synchronized (me.blockerLock) {
 236             me.blocker = b;
 237         }
 238     }
 239 
 240     /**
 241      * The minimum priority that a thread can have.
 242      */
 243     public static final int MIN_PRIORITY = 1;
 244 
 245    /**
 246      * The default priority that is assigned to a thread.
 247      */
 248     public static final int NORM_PRIORITY = 5;
 249 
 250     /**
 251      * The maximum priority that a thread can have.
 252      */
 253     public static final int MAX_PRIORITY = 10;
 254 
 255     /**
 256      * Returns a reference to the currently executing thread object.
 257      *
 258      * @return  the currently executing thread.
 259      */
 260     @HotSpotIntrinsicCandidate
 261     public static native Thread currentThread();
 262 
 263     /**
 264      * A hint to the scheduler that the current thread is willing to yield
 265      * its current use of a processor. The scheduler is free to ignore this
 266      * hint.
 267      *
 268      * &lt;p&gt; Yield is a heuristic attempt to improve relative progression
 269      * between threads that would otherwise over-utilise a CPU. Its use
 270      * should be combined with detailed profiling and benchmarking to
 271      * ensure that it actually has the desired effect.
 272      *
 273      * &lt;p&gt; It is rarely appropriate to use this method. It may be useful
 274      * for debugging or testing purposes, where it may help to reproduce
 275      * bugs due to race conditions. It may also be useful when designing
 276      * concurrency control constructs such as the ones in the
 277      * {@link java.util.concurrent.locks} package.
 278      */
 279     public static native void yield();
 280 
 281     /**
 282      * Causes the currently executing thread to sleep (temporarily cease
 283      * execution) for the specified number of milliseconds, subject to
 284      * the precision and accuracy of system timers and schedulers. The thread
 285      * does not lose ownership of any monitors.
 286      *
 287      * @param  millis
 288      *         the length of time to sleep in milliseconds
 289      *
 290      * @throws  IllegalArgumentException
 291      *          if the value of {@code millis} is negative
 292      *
 293      * @throws  InterruptedException
 294      *          if any thread has interrupted the current thread. The
 295      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 296      *          cleared when this exception is thrown.
 297      */
 298     public static native void sleep(long millis) throws InterruptedException;
 299 
 300     /**
 301      * Causes the currently executing thread to sleep (temporarily cease
 302      * execution) for the specified number of milliseconds plus the specified
 303      * number of nanoseconds, subject to the precision and accuracy of system
 304      * timers and schedulers. The thread does not lose ownership of any
 305      * monitors.
 306      *
 307      * @param  millis
 308      *         the length of time to sleep in milliseconds
 309      *
 310      * @param  nanos
 311      *         {@code 0-999999} additional nanoseconds to sleep
 312      *
 313      * @throws  IllegalArgumentException
 314      *          if the value of {@code millis} is negative, or the value of
 315      *          {@code nanos} is not in the range {@code 0-999999}
 316      *
 317      * @throws  InterruptedException
 318      *          if any thread has interrupted the current thread. The
 319      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
 320      *          cleared when this exception is thrown.
 321      */
 322     public static void sleep(long millis, int nanos)
 323     throws InterruptedException {
 324         if (millis &lt; 0) {
 325             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
 326         }
 327 
 328         if (nanos &lt; 0 || nanos &gt; 999999) {
 329             throw new IllegalArgumentException(
 330                                 &quot;nanosecond timeout value out of range&quot;);
 331         }
 332 
 333         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
 334             millis++;
 335         }
 336 
 337         sleep(millis);
 338     }
 339 
 340     /**
 341      * Indicates that the caller is momentarily unable to progress, until the
 342      * occurrence of one or more actions on the part of other activities. By
 343      * invoking this method within each iteration of a spin-wait loop construct,
 344      * the calling thread indicates to the runtime that it is busy-waiting.
 345      * The runtime may take action to improve the performance of invoking
 346      * spin-wait loop constructions.
 347      *
 348      * @apiNote
 349      * As an example consider a method in a class that spins in a loop until
 350      * some flag is set outside of that method. A call to the {@code onSpinWait}
 351      * method should be placed inside the spin loop.
 352      * &lt;pre&gt;{@code
 353      *     class EventHandler {
 354      *         volatile boolean eventNotificationNotReceived;
 355      *         void waitForEventAndHandleIt() {
 356      *             while ( eventNotificationNotReceived ) {
 357      *                 java.lang.Thread.onSpinWait();
 358      *             }
 359      *             readAndProcessEvent();
 360      *         }
 361      *
 362      *         void readAndProcessEvent() {
 363      *             // Read event from some source and process it
 364      *              . . .
 365      *         }
 366      *     }
 367      * }&lt;/pre&gt;
 368      * &lt;p&gt;
 369      * The code above would remain correct even if the {@code onSpinWait}
 370      * method was not called at all. However on some architectures the Java
 371      * Virtual Machine may issue the processor instructions to address such
 372      * code patterns in a more beneficial way.
 373      *
 374      * @since 9
 375      */
 376     @HotSpotIntrinsicCandidate
 377     public static void onSpinWait() {}
 378 
 379     /**
 380      * Initializes a Thread.
 381      *
 382      * @param g the Thread group
 383      * @param target the object whose run() method gets called
 384      * @param name the name of the new Thread
 385      * @param stackSize the desired stack size for the new thread, or
 386      *        zero to indicate that this parameter is to be ignored.
 387      * @param acc the AccessControlContext to inherit, or
 388      *            AccessController.getContext() if null
 389      * @param inheritThreadLocals if {@code true}, inherit initial values for
 390      *            inheritable thread-locals from the constructing thread
 391      */
 392     private Thread(ThreadGroup g, Runnable target, String name,
 393                    long stackSize, AccessControlContext acc,
 394                    boolean inheritThreadLocals) {
 395         if (name == null) {
 396             throw new NullPointerException(&quot;name cannot be null&quot;);
 397         }
 398 
 399         this.name = name;
 400 
 401         Thread parent = currentThread();
 402         SecurityManager security = System.getSecurityManager();
 403         if (g == null) {
 404             /* Determine if it&#39;s an applet or not */
 405 
 406             /* If there is a security manager, ask the security manager
 407                what to do. */
 408             if (security != null) {
 409                 g = security.getThreadGroup();
 410             }
 411 
 412             /* If the security manager doesn&#39;t have a strong opinion
 413                on the matter, use the parent thread group. */
 414             if (g == null) {
 415                 g = parent.getThreadGroup();
 416             }
 417         }
 418 
 419         /* checkAccess regardless of whether or not threadgroup is
 420            explicitly passed in. */
 421         g.checkAccess();
 422 
 423         /*
 424          * Do we have the required permissions?
 425          */
 426         if (security != null) {
 427             if (isCCLOverridden(getClass())) {
 428                 security.checkPermission(
 429                         SecurityConstants.SUBCLASS_IMPLEMENTATION_PERMISSION);
 430             }
 431         }
 432 
 433         g.addUnstarted();
 434 
 435         this.group = g;
 436         this.daemon = parent.isDaemon();
 437         this.priority = parent.getPriority();
 438         if (security == null || isCCLOverridden(parent.getClass()))
 439             this.contextClassLoader = parent.getContextClassLoader();
 440         else
 441             this.contextClassLoader = parent.contextClassLoader;
 442         this.inheritedAccessControlContext =
 443                 acc != null ? acc : AccessController.getContext();
 444         this.target = target;
 445         setPriority(priority);
 446         if (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != null)
 447             this.inheritableThreadLocals =
 448                 ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);
 449         /* Stash the specified stack size in case the VM cares */
 450         this.stackSize = stackSize;
 451 
 452         /* Set thread ID */
 453         this.tid = nextThreadID();
 454     }
 455 
 456     /**
 457      * Throws CloneNotSupportedException as a Thread can not be meaningfully
 458      * cloned. Construct a new Thread instead.
 459      *
 460      * @throws  CloneNotSupportedException
 461      *          always
 462      */
 463     @Override
 464     protected Object clone() throws CloneNotSupportedException {
 465         throw new CloneNotSupportedException();
 466     }
 467 
 468     /**
 469      * Allocates a new {@code Thread} object. This constructor has the same
 470      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 471      * {@code (null, null, gname)}, where {@code gname} is a newly generated
 472      * name. Automatically generated names are of the form
 473      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
 474      */
 475     public Thread() {
 476         this(null, null, &quot;Thread-&quot; + nextThreadNum(), 0);
 477     }
 478 
 479     /**
 480      * Allocates a new {@code Thread} object. This constructor has the same
 481      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 482      * {@code (null, target, gname)}, where {@code gname} is a newly generated
 483      * name. Automatically generated names are of the form
 484      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
 485      *
 486      * @param  target
 487      *         the object whose {@code run} method is invoked when this thread
 488      *         is started. If {@code null}, this classes {@code run} method does
 489      *         nothing.
 490      */
 491     public Thread(Runnable target) {
 492         this(null, target, &quot;Thread-&quot; + nextThreadNum(), 0);
 493     }
 494 
 495     /**
 496      * Creates a new Thread that inherits the given AccessControlContext
 497      * but thread-local variables are not inherited.
 498      * This is not a public constructor.
 499      */
 500     Thread(Runnable target, AccessControlContext acc) {
 501         this(null, target, &quot;Thread-&quot; + nextThreadNum(), 0, acc, false);
 502     }
 503 
 504     /**
 505      * Allocates a new {@code Thread} object. This constructor has the same
 506      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 507      * {@code (group, target, gname)} ,where {@code gname} is a newly generated
 508      * name. Automatically generated names are of the form
 509      * {@code &quot;Thread-&quot;+}&lt;i&gt;n&lt;/i&gt;, where &lt;i&gt;n&lt;/i&gt; is an integer.
 510      *
 511      * @param  group
 512      *         the thread group. If {@code null} and there is a security
 513      *         manager, the group is determined by {@linkplain
 514      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 515      *         If there is not a security manager or {@code
 516      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 517      *         is set to the current thread&#39;s thread group.
 518      *
 519      * @param  target
 520      *         the object whose {@code run} method is invoked when this thread
 521      *         is started. If {@code null}, this thread&#39;s run method is invoked.
 522      *
 523      * @throws  SecurityException
 524      *          if the current thread cannot create a thread in the specified
 525      *          thread group
 526      */
 527     public Thread(ThreadGroup group, Runnable target) {
 528         this(group, target, &quot;Thread-&quot; + nextThreadNum(), 0);
 529     }
 530 
 531     /**
 532      * Allocates a new {@code Thread} object. This constructor has the same
 533      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 534      * {@code (null, null, name)}.
 535      *
 536      * @param   name
 537      *          the name of the new thread
 538      */
 539     public Thread(String name) {
 540         this(null, null, name, 0);
 541     }
 542 
 543     /**
 544      * Allocates a new {@code Thread} object. This constructor has the same
 545      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 546      * {@code (group, null, name)}.
 547      *
 548      * @param  group
 549      *         the thread group. If {@code null} and there is a security
 550      *         manager, the group is determined by {@linkplain
 551      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 552      *         If there is not a security manager or {@code
 553      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 554      *         is set to the current thread&#39;s thread group.
 555      *
 556      * @param  name
 557      *         the name of the new thread
 558      *
 559      * @throws  SecurityException
 560      *          if the current thread cannot create a thread in the specified
 561      *          thread group
 562      */
 563     public Thread(ThreadGroup group, String name) {
 564         this(group, null, name, 0);
 565     }
 566 
 567     /**
 568      * Allocates a new {@code Thread} object. This constructor has the same
 569      * effect as {@linkplain #Thread(ThreadGroup,Runnable,String) Thread}
 570      * {@code (null, target, name)}.
 571      *
 572      * @param  target
 573      *         the object whose {@code run} method is invoked when this thread
 574      *         is started. If {@code null}, this thread&#39;s run method is invoked.
 575      *
 576      * @param  name
 577      *         the name of the new thread
 578      */
 579     public Thread(Runnable target, String name) {
 580         this(null, target, name, 0);
 581     }
 582 
 583     /**
 584      * Allocates a new {@code Thread} object so that it has {@code target}
 585      * as its run object, has the specified {@code name} as its name,
 586      * and belongs to the thread group referred to by {@code group}.
 587      *
 588      * &lt;p&gt;If there is a security manager, its
 589      * {@link SecurityManager#checkAccess(ThreadGroup) checkAccess}
 590      * method is invoked with the ThreadGroup as its argument.
 591      *
 592      * &lt;p&gt;In addition, its {@code checkPermission} method is invoked with
 593      * the {@code RuntimePermission(&quot;enableContextClassLoaderOverride&quot;)}
 594      * permission when invoked directly or indirectly by the constructor
 595      * of a subclass which overrides the {@code getContextClassLoader}
 596      * or {@code setContextClassLoader} methods.
 597      *
 598      * &lt;p&gt;The priority of the newly created thread is set equal to the
 599      * priority of the thread creating it, that is, the currently running
 600      * thread. The method {@linkplain #setPriority setPriority} may be
 601      * used to change the priority to a new value.
 602      *
 603      * &lt;p&gt;The newly created thread is initially marked as being a daemon
 604      * thread if and only if the thread creating it is currently marked
 605      * as a daemon thread. The method {@linkplain #setDaemon setDaemon}
 606      * may be used to change whether or not a thread is a daemon.
 607      *
 608      * @param  group
 609      *         the thread group. If {@code null} and there is a security
 610      *         manager, the group is determined by {@linkplain
 611      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 612      *         If there is not a security manager or {@code
 613      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 614      *         is set to the current thread&#39;s thread group.
 615      *
 616      * @param  target
 617      *         the object whose {@code run} method is invoked when this thread
 618      *         is started. If {@code null}, this thread&#39;s run method is invoked.
 619      *
 620      * @param  name
 621      *         the name of the new thread
 622      *
 623      * @throws  SecurityException
 624      *          if the current thread cannot create a thread in the specified
 625      *          thread group or cannot override the context class loader methods.
 626      */
 627     public Thread(ThreadGroup group, Runnable target, String name) {
 628         this(group, target, name, 0);
 629     }
 630 
 631     /**
 632      * Allocates a new {@code Thread} object so that it has {@code target}
 633      * as its run object, has the specified {@code name} as its name,
 634      * and belongs to the thread group referred to by {@code group}, and has
 635      * the specified &lt;i&gt;stack size&lt;/i&gt;.
 636      *
 637      * &lt;p&gt;This constructor is identical to {@link
 638      * #Thread(ThreadGroup,Runnable,String)} with the exception of the fact
 639      * that it allows the thread stack size to be specified.  The stack size
 640      * is the approximate number of bytes of address space that the virtual
 641      * machine is to allocate for this thread&#39;s stack.  &lt;b&gt;The effect of the
 642      * {@code stackSize} parameter, if any, is highly platform dependent.&lt;/b&gt;
 643      *
 644      * &lt;p&gt;On some platforms, specifying a higher value for the
 645      * {@code stackSize} parameter may allow a thread to achieve greater
 646      * recursion depth before throwing a {@link StackOverflowError}.
 647      * Similarly, specifying a lower value may allow a greater number of
 648      * threads to exist concurrently without throwing an {@link
 649      * OutOfMemoryError} (or other internal error).  The details of
 650      * the relationship between the value of the {@code stackSize} parameter
 651      * and the maximum recursion depth and concurrency level are
 652      * platform-dependent.  &lt;b&gt;On some platforms, the value of the
 653      * {@code stackSize} parameter may have no effect whatsoever.&lt;/b&gt;
 654      *
 655      * &lt;p&gt;The virtual machine is free to treat the {@code stackSize}
 656      * parameter as a suggestion.  If the specified value is unreasonably low
 657      * for the platform, the virtual machine may instead use some
 658      * platform-specific minimum value; if the specified value is unreasonably
 659      * high, the virtual machine may instead use some platform-specific
 660      * maximum.  Likewise, the virtual machine is free to round the specified
 661      * value up or down as it sees fit (or to ignore it completely).
 662      *
 663      * &lt;p&gt;Specifying a value of zero for the {@code stackSize} parameter will
 664      * cause this constructor to behave exactly like the
 665      * {@code Thread(ThreadGroup, Runnable, String)} constructor.
 666      *
 667      * &lt;p&gt;&lt;i&gt;Due to the platform-dependent nature of the behavior of this
 668      * constructor, extreme care should be exercised in its use.
 669      * The thread stack size necessary to perform a given computation will
 670      * likely vary from one JRE implementation to another.  In light of this
 671      * variation, careful tuning of the stack size parameter may be required,
 672      * and the tuning may need to be repeated for each JRE implementation on
 673      * which an application is to run.&lt;/i&gt;
 674      *
 675      * &lt;p&gt;Implementation note: Java platform implementers are encouraged to
 676      * document their implementation&#39;s behavior with respect to the
 677      * {@code stackSize} parameter.
 678      *
 679      *
 680      * @param  group
 681      *         the thread group. If {@code null} and there is a security
 682      *         manager, the group is determined by {@linkplain
 683      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 684      *         If there is not a security manager or {@code
 685      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 686      *         is set to the current thread&#39;s thread group.
 687      *
 688      * @param  target
 689      *         the object whose {@code run} method is invoked when this thread
 690      *         is started. If {@code null}, this thread&#39;s run method is invoked.
 691      *
 692      * @param  name
 693      *         the name of the new thread
 694      *
 695      * @param  stackSize
 696      *         the desired stack size for the new thread, or zero to indicate
 697      *         that this parameter is to be ignored.
 698      *
 699      * @throws  SecurityException
 700      *          if the current thread cannot create a thread in the specified
 701      *          thread group
 702      *
 703      * @since 1.4
 704      */
 705     public Thread(ThreadGroup group, Runnable target, String name,
 706                   long stackSize) {
 707         this(group, target, name, stackSize, null, true);
 708     }
 709 
 710     /**
 711      * Allocates a new {@code Thread} object so that it has {@code target}
 712      * as its run object, has the specified {@code name} as its name,
 713      * belongs to the thread group referred to by {@code group}, has
 714      * the specified {@code stackSize}, and inherits initial values for
 715      * {@linkplain InheritableThreadLocal inheritable thread-local} variables
 716      * if {@code inheritThreadLocals} is {@code true}.
 717      *
 718      * &lt;p&gt; This constructor is identical to {@link
 719      * #Thread(ThreadGroup,Runnable,String,long)} with the added ability to
 720      * suppress, or not, the inheriting of initial values for inheritable
 721      * thread-local variables from the constructing thread. This allows for
 722      * finer grain control over inheritable thread-locals. Care must be taken
 723      * when passing a value of {@code false} for {@code inheritThreadLocals},
 724      * as it may lead to unexpected behavior if the new thread executes code
 725      * that expects a specific thread-local value to be inherited.
 726      *
 727      * &lt;p&gt; Specifying a value of {@code true} for the {@code inheritThreadLocals}
 728      * parameter will cause this constructor to behave exactly like the
 729      * {@code Thread(ThreadGroup, Runnable, String, long)} constructor.
 730      *
 731      * @param  group
 732      *         the thread group. If {@code null} and there is a security
 733      *         manager, the group is determined by {@linkplain
 734      *         SecurityManager#getThreadGroup SecurityManager.getThreadGroup()}.
 735      *         If there is not a security manager or {@code
 736      *         SecurityManager.getThreadGroup()} returns {@code null}, the group
 737      *         is set to the current thread&#39;s thread group.
 738      *
 739      * @param  target
 740      *         the object whose {@code run} method is invoked when this thread
 741      *         is started. If {@code null}, this thread&#39;s run method is invoked.
 742      *
 743      * @param  name
 744      *         the name of the new thread
 745      *
 746      * @param  stackSize
 747      *         the desired stack size for the new thread, or zero to indicate
 748      *         that this parameter is to be ignored
 749      *
 750      * @param  inheritThreadLocals
 751      *         if {@code true}, inherit initial values for inheritable
 752      *         thread-locals from the constructing thread, otherwise no initial
 753      *         values are inherited
 754      *
 755      * @throws  SecurityException
 756      *          if the current thread cannot create a thread in the specified
 757      *          thread group
 758      *
 759      * @since 9
 760      */
 761     public Thread(ThreadGroup group, Runnable target, String name,
 762                   long stackSize, boolean inheritThreadLocals) {
 763         this(group, target, name, stackSize, null, inheritThreadLocals);
 764     }
 765 
 766     /**
 767      * Causes this thread to begin execution; the Java Virtual Machine
 768      * calls the {@code run} method of this thread.
 769      * &lt;p&gt;
 770      * The result is that two threads are running concurrently: the
 771      * current thread (which returns from the call to the
 772      * {@code start} method) and the other thread (which executes its
 773      * {@code run} method).
 774      * &lt;p&gt;
 775      * It is never legal to start a thread more than once.
 776      * In particular, a thread may not be restarted once it has completed
 777      * execution.
 778      *
 779      * @throws     IllegalThreadStateException  if the thread was already started.
 780      * @see        #run()
 781      * @see        #stop()
 782      */
 783     public synchronized void start() {
 784         /**
 785          * This method is not invoked for the main method thread or &quot;system&quot;
 786          * group threads created/set up by the VM. Any new functionality added
 787          * to this method in the future may have to also be added to the VM.
 788          *
 789          * A zero status value corresponds to state &quot;NEW&quot;.
 790          */
 791         if (threadStatus != 0)
 792             throw new IllegalThreadStateException();
 793 
 794         /* Notify the group that this thread is about to be started
 795          * so that it can be added to the group&#39;s list of threads
 796          * and the group&#39;s unstarted count can be decremented. */
 797         group.add(this);
 798 
 799         boolean started = false;
 800         try {
 801             start0();
 802             started = true;
 803         } finally {
 804             try {
 805                 if (!started) {
 806                     group.threadStartFailed(this);
 807                 }
 808             } catch (Throwable ignore) {
 809                 /* do nothing. If start0 threw a Throwable then
 810                   it will be passed up the call stack */
 811             }
 812         }
 813     }
 814 
 815     private native void start0();
 816 
 817     /**
 818      * If this thread was constructed using a separate
 819      * {@code Runnable} run object, then that
 820      * {@code Runnable} object&#39;s {@code run} method is called;
 821      * otherwise, this method does nothing and returns.
 822      * &lt;p&gt;
 823      * Subclasses of {@code Thread} should override this method.
 824      *
 825      * @see     #start()
 826      * @see     #stop()
 827      * @see     #Thread(ThreadGroup, Runnable, String)
 828      */
 829     @Override
 830     public void run() {
 831         if (target != null) {
 832             target.run();
 833         }
 834     }
 835 
 836     /**
 837      * This method is called by the system to give a Thread
 838      * a chance to clean up before it actually exits.
 839      */
 840     private void exit() {
 841         if (threadLocals != null &amp;&amp; TerminatingThreadLocal.REGISTRY.isPresent()) {
 842             TerminatingThreadLocal.threadTerminated();
 843         }
 844         if (group != null) {
 845             group.threadTerminated(this);
 846             group = null;
 847         }
 848         /* Aggressively null out all reference fields: see bug 4006245 */
 849         target = null;
 850         /* Speed the release of some of these resources */
 851         threadLocals = null;
 852         inheritableThreadLocals = null;
 853         inheritedAccessControlContext = null;
 854         blocker = null;
 855         uncaughtExceptionHandler = null;
 856     }
 857 
 858     /**
 859      * Forces the thread to stop executing.
 860      * &lt;p&gt;
 861      * If there is a security manager installed, its {@code checkAccess}
 862      * method is called with {@code this}
 863      * as its argument. This may result in a
 864      * {@code SecurityException} being raised (in the current thread).
 865      * &lt;p&gt;
 866      * If this thread is different from the current thread (that is, the current
 867      * thread is trying to stop a thread other than itself), the
 868      * security manager&#39;s {@code checkPermission} method (with a
 869      * {@code RuntimePermission(&quot;stopThread&quot;)} argument) is called in
 870      * addition.
 871      * Again, this may result in throwing a
 872      * {@code SecurityException} (in the current thread).
 873      * &lt;p&gt;
 874      * The thread represented by this thread is forced to stop whatever
 875      * it is doing abnormally and to throw a newly created
 876      * {@code ThreadDeath} object as an exception.
 877      * &lt;p&gt;
 878      * It is permitted to stop a thread that has not yet been started.
 879      * If the thread is eventually started, it immediately terminates.
 880      * &lt;p&gt;
 881      * An application should not normally try to catch
 882      * {@code ThreadDeath} unless it must do some extraordinary
 883      * cleanup operation (note that the throwing of
 884      * {@code ThreadDeath} causes {@code finally} clauses of
 885      * {@code try} statements to be executed before the thread
 886      * officially dies).  If a {@code catch} clause catches a
 887      * {@code ThreadDeath} object, it is important to rethrow the
 888      * object so that the thread actually dies.
 889      * &lt;p&gt;
 890      * The top-level error handler that reacts to otherwise uncaught
 891      * exceptions does not print out a message or otherwise notify the
 892      * application if the uncaught exception is an instance of
 893      * {@code ThreadDeath}.
 894      *
 895      * @throws     SecurityException  if the current thread cannot
 896      *             modify this thread.
 897      * @see        #interrupt()
 898      * @see        #checkAccess()
 899      * @see        #run()
 900      * @see        #start()
 901      * @see        ThreadDeath
 902      * @see        ThreadGroup#uncaughtException(Thread,Throwable)
 903      * @see        SecurityManager#checkAccess(Thread)
 904      * @see        SecurityManager#checkPermission
 905      * @deprecated This method is inherently unsafe.  Stopping a thread with
 906      *       Thread.stop causes it to unlock all of the monitors that it
 907      *       has locked (as a natural consequence of the unchecked
 908      *       {@code ThreadDeath} exception propagating up the stack).  If
 909      *       any of the objects previously protected by these monitors were in
 910      *       an inconsistent state, the damaged objects become visible to
 911      *       other threads, potentially resulting in arbitrary behavior.  Many
 912      *       uses of {@code stop} should be replaced by code that simply
 913      *       modifies some variable to indicate that the target thread should
 914      *       stop running.  The target thread should check this variable
 915      *       regularly, and return from its run method in an orderly fashion
 916      *       if the variable indicates that it is to stop running.  If the
 917      *       target thread waits for long periods (on a condition variable,
 918      *       for example), the {@code interrupt} method should be used to
 919      *       interrupt the wait.
 920      *       For more information, see
 921      *       &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
 922      *       are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
 923      */
 924     @Deprecated(since=&quot;1.2&quot;)
 925     public final void stop() {
 926         SecurityManager security = System.getSecurityManager();
 927         if (security != null) {
 928             checkAccess();
 929             if (this != Thread.currentThread()) {
 930                 security.checkPermission(SecurityConstants.STOP_THREAD_PERMISSION);
 931             }
 932         }
 933         // A zero status value corresponds to &quot;NEW&quot;, it can&#39;t change to
 934         // not-NEW because we hold the lock.
 935         if (threadStatus != 0) {
 936             resume(); // Wake up thread if it was suspended; no-op otherwise
 937         }
 938 
 939         // The VM can handle all thread states
 940         stop0(new ThreadDeath());
 941     }
 942 
 943     /**
 944      * Interrupts this thread.
 945      *
 946      * &lt;p&gt; Unless the current thread is interrupting itself, which is
 947      * always permitted, the {@link #checkAccess() checkAccess} method
 948      * of this thread is invoked, which may cause a {@link
 949      * SecurityException} to be thrown.
 950      *
 951      * &lt;p&gt; If this thread is blocked in an invocation of the {@link
 952      * Object#wait() wait()}, {@link Object#wait(long) wait(long)}, or {@link
 953      * Object#wait(long, int) wait(long, int)} methods of the {@link Object}
 954      * class, or of the {@link #join()}, {@link #join(long)}, {@link
 955      * #join(long, int)}, {@link #sleep(long)}, or {@link #sleep(long, int)},
 956      * methods of this class, then its interrupt status will be cleared and it
 957      * will receive an {@link InterruptedException}.
 958      *
 959      * &lt;p&gt; If this thread is blocked in an I/O operation upon an {@link
 960      * java.nio.channels.InterruptibleChannel InterruptibleChannel}
 961      * then the channel will be closed, the thread&#39;s interrupt
 962      * status will be set, and the thread will receive a {@link
 963      * java.nio.channels.ClosedByInterruptException}.
 964      *
 965      * &lt;p&gt; If this thread is blocked in a {@link java.nio.channels.Selector}
 966      * then the thread&#39;s interrupt status will be set and it will return
 967      * immediately from the selection operation, possibly with a non-zero
 968      * value, just as if the selector&#39;s {@link
 969      * java.nio.channels.Selector#wakeup wakeup} method were invoked.
 970      *
 971      * &lt;p&gt; If none of the previous conditions hold then this thread&#39;s interrupt
 972      * status will be set. &lt;/p&gt;
 973      *
 974      * &lt;p&gt; Interrupting a thread that is not alive need not have any effect.
 975      *
 976      * @implNote In the JDK Reference Implementation, interruption of a thread
 977      * that is not alive still records that the interrupt request was made and
 978      * will report it via {@link #interrupted} and {@link #isInterrupted()}.
 979      *
 980      * @throws  SecurityException
 981      *          if the current thread cannot modify this thread
 982      *
 983      * @revised 6.0, 14
 984      * @spec JSR-51
 985      */
 986     public void interrupt() {
 987         if (this != Thread.currentThread()) {
 988             checkAccess();
 989 
 990             // thread may be blocked in an I/O operation
 991             synchronized (blockerLock) {
 992                 Interruptible b = blocker;
 993                 if (b != null) {
 994                     interrupted = true;
 995                     interrupt0();  // inform VM of interrupt
 996                     b.interrupt(this);
 997                     return;
 998                 }
 999             }
1000         }
1001         interrupted = true;
1002         // inform VM of interrupt
1003         interrupt0();
1004     }
1005 
1006     /**
1007      * Tests whether the current thread has been interrupted.  The
1008      * &lt;i&gt;interrupted status&lt;/i&gt; of the thread is cleared by this method.  In
1009      * other words, if this method were to be called twice in succession, the
1010      * second call would return false (unless the current thread were
1011      * interrupted again, after the first call had cleared its interrupted
1012      * status and before the second call had examined it).
1013      *
1014      * @return  {@code true} if the current thread has been interrupted;
1015      *          {@code false} otherwise.
1016      * @see #isInterrupted()
1017      * @revised 6.0, 14
1018      */
1019     public static boolean interrupted() {
1020         Thread t = currentThread();
1021         boolean interrupted = t.interrupted;
1022         // We may have been interrupted the moment after we read the field,
1023         // so only clear the field if we saw that it was set and will return
1024         // true; otherwise we could lose an interrupt.
1025         if (interrupted) {
1026             t.interrupted = false;
1027             clearInterruptEvent();
1028         }
1029         return interrupted;
1030     }
1031 
1032     /**
1033      * Tests whether this thread has been interrupted.  The &lt;i&gt;interrupted
1034      * status&lt;/i&gt; of the thread is unaffected by this method.
1035      *
1036      * @return  {@code true} if this thread has been interrupted;
1037      *          {@code false} otherwise.
1038      * @see     #interrupted()
1039      * @revised 6.0, 14
1040      */
1041     public boolean isInterrupted() {
1042         return interrupted;
1043     }
1044 
1045     /**
1046      * Tests if this thread is alive. A thread is alive if it has
1047      * been started and has not yet died.
1048      *
1049      * @return  {@code true} if this thread is alive;
1050      *          {@code false} otherwise.
1051      */
1052     public final native boolean isAlive();
1053 
1054     /**
1055      * Suspends this thread.
1056      * &lt;p&gt;
1057      * First, the {@code checkAccess} method of this thread is called
1058      * with no arguments. This may result in throwing a
1059      * {@code SecurityException }(in the current thread).
1060      * &lt;p&gt;
1061      * If the thread is alive, it is suspended and makes no further
1062      * progress unless and until it is resumed.
1063      *
1064      * @throws     SecurityException  if the current thread cannot modify
1065      *             this thread.
1066      * @see #checkAccess
1067      * @deprecated   This method has been deprecated, as it is
1068      *   inherently deadlock-prone.  If the target thread holds a lock on the
1069      *   monitor protecting a critical system resource when it is suspended, no
1070      *   thread can access this resource until the target thread is resumed. If
1071      *   the thread that would resume the target thread attempts to lock this
1072      *   monitor prior to calling {@code resume}, deadlock results.  Such
1073      *   deadlocks typically manifest themselves as &quot;frozen&quot; processes.
1074      *   For more information, see
1075      *   &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1076      *   are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1077      */
1078     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1079     public final void suspend() {
1080         checkAccess();
1081         suspend0();
1082     }
1083 
1084     /**
1085      * Resumes a suspended thread.
1086      * &lt;p&gt;
1087      * First, the {@code checkAccess} method of this thread is called
1088      * with no arguments. This may result in throwing a
1089      * {@code SecurityException} (in the current thread).
1090      * &lt;p&gt;
1091      * If the thread is alive but suspended, it is resumed and is
1092      * permitted to make progress in its execution.
1093      *
1094      * @throws     SecurityException  if the current thread cannot modify this
1095      *             thread.
1096      * @see        #checkAccess
1097      * @see        #suspend()
1098      * @deprecated This method exists solely for use with {@link #suspend},
1099      *     which has been deprecated because it is deadlock-prone.
1100      *     For more information, see
1101      *     &lt;a href=&quot;{@docRoot}/java.base/java/lang/doc-files/threadPrimitiveDeprecation.html&quot;&gt;Why
1102      *     are Thread.stop, Thread.suspend and Thread.resume Deprecated?&lt;/a&gt;.
1103      */
1104     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1105     public final void resume() {
1106         checkAccess();
1107         resume0();
1108     }
1109 
1110     /**
1111      * Changes the priority of this thread.
1112      * &lt;p&gt;
1113      * First the {@code checkAccess} method of this thread is called
1114      * with no arguments. This may result in throwing a {@code SecurityException}.
1115      * &lt;p&gt;
1116      * Otherwise, the priority of this thread is set to the smaller of
1117      * the specified {@code newPriority} and the maximum permitted
1118      * priority of the thread&#39;s thread group.
1119      *
1120      * @param newPriority priority to set this thread to
1121      * @throws     IllegalArgumentException  If the priority is not in the
1122      *               range {@code MIN_PRIORITY} to
1123      *               {@code MAX_PRIORITY}.
1124      * @throws     SecurityException  if the current thread cannot modify
1125      *               this thread.
1126      * @see        #getPriority
1127      * @see        #checkAccess()
1128      * @see        #getThreadGroup()
1129      * @see        #MAX_PRIORITY
1130      * @see        #MIN_PRIORITY
1131      * @see        ThreadGroup#getMaxPriority()
1132      */
1133     public final void setPriority(int newPriority) {
1134         ThreadGroup g;
1135         checkAccess();
1136         if (newPriority &gt; MAX_PRIORITY || newPriority &lt; MIN_PRIORITY) {
1137             throw new IllegalArgumentException();
1138         }
1139         if((g = getThreadGroup()) != null) {
1140             if (newPriority &gt; g.getMaxPriority()) {
1141                 newPriority = g.getMaxPriority();
1142             }
1143             setPriority0(priority = newPriority);
1144         }
1145     }
1146 
1147     /**
1148      * Returns this thread&#39;s priority.
1149      *
1150      * @return  this thread&#39;s priority.
1151      * @see     #setPriority
1152      */
1153     public final int getPriority() {
1154         return priority;
1155     }
1156 
1157     /**
1158      * Changes the name of this thread to be equal to the argument {@code name}.
1159      * &lt;p&gt;
1160      * First the {@code checkAccess} method of this thread is called
1161      * with no arguments. This may result in throwing a
1162      * {@code SecurityException}.
1163      *
1164      * @param      name   the new name for this thread.
1165      * @throws     SecurityException  if the current thread cannot modify this
1166      *             thread.
1167      * @see        #getName
1168      * @see        #checkAccess()
1169      */
1170     public final synchronized void setName(String name) {
1171         checkAccess();
1172         if (name == null) {
1173             throw new NullPointerException(&quot;name cannot be null&quot;);
1174         }
1175 
1176         this.name = name;
1177         if (threadStatus != 0) {
1178             setNativeName(name);
1179         }
1180     }
1181 
1182     /**
1183      * Returns this thread&#39;s name.
1184      *
1185      * @return  this thread&#39;s name.
1186      * @see     #setName(String)
1187      */
1188     public final String getName() {
1189         return name;
1190     }
1191 
1192     /**
1193      * Returns the thread group to which this thread belongs.
1194      * This method returns null if this thread has died
1195      * (been stopped).
1196      *
1197      * @return  this thread&#39;s thread group.
1198      */
1199     public final ThreadGroup getThreadGroup() {
1200         return group;
1201     }
1202 
1203     /**
1204      * Returns an estimate of the number of active threads in the current
1205      * thread&#39;s {@linkplain java.lang.ThreadGroup thread group} and its
1206      * subgroups. Recursively iterates over all subgroups in the current
1207      * thread&#39;s thread group.
1208      *
1209      * &lt;p&gt; The value returned is only an estimate because the number of
1210      * threads may change dynamically while this method traverses internal
1211      * data structures, and might be affected by the presence of certain
1212      * system threads. This method is intended primarily for debugging
1213      * and monitoring purposes.
1214      *
1215      * @return  an estimate of the number of active threads in the current
1216      *          thread&#39;s thread group and in any other thread group that
1217      *          has the current thread&#39;s thread group as an ancestor
1218      */
1219     public static int activeCount() {
1220         return currentThread().getThreadGroup().activeCount();
1221     }
1222 
1223     /**
1224      * Copies into the specified array every active thread in the current
1225      * thread&#39;s thread group and its subgroups. This method simply
1226      * invokes the {@link java.lang.ThreadGroup#enumerate(Thread[])}
1227      * method of the current thread&#39;s thread group.
1228      *
1229      * &lt;p&gt; An application might use the {@linkplain #activeCount activeCount}
1230      * method to get an estimate of how big the array should be, however
1231      * &lt;i&gt;if the array is too short to hold all the threads, the extra threads
1232      * are silently ignored.&lt;/i&gt;  If it is critical to obtain every active
1233      * thread in the current thread&#39;s thread group and its subgroups, the
1234      * invoker should verify that the returned int value is strictly less
1235      * than the length of {@code tarray}.
1236      *
1237      * &lt;p&gt; Due to the inherent race condition in this method, it is recommended
1238      * that the method only be used for debugging and monitoring purposes.
1239      *
1240      * @param  tarray
1241      *         an array into which to put the list of threads
1242      *
1243      * @return  the number of threads put into the array
1244      *
1245      * @throws  SecurityException
1246      *          if {@link java.lang.ThreadGroup#checkAccess} determines that
1247      *          the current thread cannot access its thread group
1248      */
1249     public static int enumerate(Thread tarray[]) {
1250         return currentThread().getThreadGroup().enumerate(tarray);
1251     }
1252 
1253     /**
1254      * Throws {@code UnsupportedOperationException}.
1255      *
1256      * @return     nothing
1257      *
1258      * @deprecated This method was originally designed to count the number of
1259      *             stack frames but the results were never well-defined and it
1260      *             depended on thread-suspension.
1261      *             This method is subject to removal in a future version of Java SE.
1262      * @see        StackWalker
1263      */
1264     @Deprecated(since=&quot;1.2&quot;, forRemoval=true)
1265     public int countStackFrames() {
1266         throw new UnsupportedOperationException();
1267     }
1268 
1269     /**
1270      * Waits at most {@code millis} milliseconds for this thread to
1271      * die. A timeout of {@code 0} means to wait forever.
1272      *
1273      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
1274      * conditioned on {@code this.isAlive}. As a thread terminates the
1275      * {@code this.notifyAll} method is invoked. It is recommended that
1276      * applications not use {@code wait}, {@code notify}, or
1277      * {@code notifyAll} on {@code Thread} instances.
1278      *
1279      * @param  millis
1280      *         the time to wait in milliseconds
1281      *
1282      * @throws  IllegalArgumentException
1283      *          if the value of {@code millis} is negative
1284      *
1285      * @throws  InterruptedException
1286      *          if any thread has interrupted the current thread. The
1287      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
1288      *          cleared when this exception is thrown.
1289      */
1290     public final synchronized void join(final long millis)
1291     throws InterruptedException {
1292         if (millis &gt; 0) {
1293             if (isAlive()) {
1294                 final long startTime = System.nanoTime();
1295                 long delay = millis;
1296                 do {
1297                     wait(delay);
1298                 } while (isAlive() &amp;&amp; (delay = millis -
1299                         TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime)) &gt; 0);
1300             }
1301         } else if (millis == 0) {
1302             while (isAlive()) {
1303                 wait(0);
1304             }
1305         } else {
1306             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
1307         }
1308     }
1309 
1310     /**
1311      * Waits at most {@code millis} milliseconds plus
1312      * {@code nanos} nanoseconds for this thread to die.
1313      * If both arguments are {@code 0}, it means to wait forever.
1314      *
1315      * &lt;p&gt; This implementation uses a loop of {@code this.wait} calls
1316      * conditioned on {@code this.isAlive}. As a thread terminates the
1317      * {@code this.notifyAll} method is invoked. It is recommended that
1318      * applications not use {@code wait}, {@code notify}, or
1319      * {@code notifyAll} on {@code Thread} instances.
1320      *
1321      * @param  millis
1322      *         the time to wait in milliseconds
1323      *
1324      * @param  nanos
1325      *         {@code 0-999999} additional nanoseconds to wait
1326      *
1327      * @throws  IllegalArgumentException
1328      *          if the value of {@code millis} is negative, or the value
1329      *          of {@code nanos} is not in the range {@code 0-999999}
1330      *
1331      * @throws  InterruptedException
1332      *          if any thread has interrupted the current thread. The
1333      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
1334      *          cleared when this exception is thrown.
1335      */
1336     public final synchronized void join(long millis, int nanos)
1337     throws InterruptedException {
1338 
1339         if (millis &lt; 0) {
1340             throw new IllegalArgumentException(&quot;timeout value is negative&quot;);
1341         }
1342 
1343         if (nanos &lt; 0 || nanos &gt; 999999) {
1344             throw new IllegalArgumentException(
1345                                 &quot;nanosecond timeout value out of range&quot;);
1346         }
1347 
1348         if (nanos &gt; 0 &amp;&amp; millis &lt; Long.MAX_VALUE) {
1349             millis++;
1350         }
1351 
1352         join(millis);
1353     }
1354 
1355     /**
1356      * Waits for this thread to die.
1357      *
1358      * &lt;p&gt; An invocation of this method behaves in exactly the same
1359      * way as the invocation
1360      *
1361      * &lt;blockquote&gt;
1362      * {@linkplain #join(long) join}{@code (0)}
1363      * &lt;/blockquote&gt;
1364      *
1365      * @throws  InterruptedException
1366      *          if any thread has interrupted the current thread. The
1367      *          &lt;i&gt;interrupted status&lt;/i&gt; of the current thread is
1368      *          cleared when this exception is thrown.
1369      */
1370     public final void join() throws InterruptedException {
1371         join(0);
1372     }
1373 
1374     /**
1375      * Prints a stack trace of the current thread to the standard error stream.
1376      * This method is used only for debugging.
1377      */
1378     public static void dumpStack() {
1379         new Exception(&quot;Stack trace&quot;).printStackTrace();
1380     }
1381 
1382     /**
1383      * Marks this thread as either a {@linkplain #isDaemon daemon} thread
1384      * or a user thread. The Java Virtual Machine exits when the only
1385      * threads running are all daemon threads.
1386      *
1387      * &lt;p&gt; This method must be invoked before the thread is started.
1388      *
1389      * @param  on
1390      *         if {@code true}, marks this thread as a daemon thread
1391      *
1392      * @throws  IllegalThreadStateException
1393      *          if this thread is {@linkplain #isAlive alive}
1394      *
1395      * @throws  SecurityException
1396      *          if {@link #checkAccess} determines that the current
1397      *          thread cannot modify this thread
1398      */
1399     public final void setDaemon(boolean on) {
1400         checkAccess();
1401         if (isAlive()) {
1402             throw new IllegalThreadStateException();
1403         }
1404         daemon = on;
1405     }
1406 
1407     /**
1408      * Tests if this thread is a daemon thread.
1409      *
1410      * @return  {@code true} if this thread is a daemon thread;
1411      *          {@code false} otherwise.
1412      * @see     #setDaemon(boolean)
1413      */
1414     public final boolean isDaemon() {
1415         return daemon;
1416     }
1417 
1418     /**
1419      * Determines if the currently running thread has permission to
1420      * modify this thread.
1421      * &lt;p&gt;
1422      * If there is a security manager, its {@code checkAccess} method
1423      * is called with this thread as its argument. This may result in
1424      * throwing a {@code SecurityException}.
1425      *
1426      * @throws  SecurityException  if the current thread is not allowed to
1427      *          access this thread.
1428      * @see        SecurityManager#checkAccess(Thread)
1429      */
1430     public final void checkAccess() {
1431         SecurityManager security = System.getSecurityManager();
1432         if (security != null) {
1433             security.checkAccess(this);
1434         }
1435     }
1436 
1437     /**
1438      * Returns a string representation of this thread, including the
1439      * thread&#39;s name, priority, and thread group.
1440      *
1441      * @return  a string representation of this thread.
1442      */
1443     public String toString() {
1444         ThreadGroup group = getThreadGroup();
1445         if (group != null) {
1446             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
1447                            group.getName() + &quot;]&quot;;
1448         } else {
1449             return &quot;Thread[&quot; + getName() + &quot;,&quot; + getPriority() + &quot;,&quot; +
1450                             &quot;&quot; + &quot;]&quot;;
1451         }
1452     }
1453 
1454     /**
1455      * Returns the context {@code ClassLoader} for this thread. The context
1456      * {@code ClassLoader} is provided by the creator of the thread for use
1457      * by code running in this thread when loading classes and resources.
1458      * If not {@linkplain #setContextClassLoader set}, the default is the
1459      * {@code ClassLoader} context of the parent thread. The context
1460      * {@code ClassLoader} of the
1461      * primordial thread is typically set to the class loader used to load the
1462      * application.
1463      *
1464      *
1465      * @return  the context {@code ClassLoader} for this thread, or {@code null}
1466      *          indicating the system class loader (or, failing that, the
1467      *          bootstrap class loader)
1468      *
1469      * @throws  SecurityException
1470      *          if a security manager is present, and the caller&#39;s class loader
1471      *          is not {@code null} and is not the same as or an ancestor of the
1472      *          context class loader, and the caller does not have the
1473      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
1474      *
1475      * @since 1.2
1476      */
1477     @CallerSensitive
1478     public ClassLoader getContextClassLoader() {
1479         if (contextClassLoader == null)
1480             return null;
1481         SecurityManager sm = System.getSecurityManager();
1482         if (sm != null) {
1483             ClassLoader.checkClassLoaderPermission(contextClassLoader,
1484                                                    Reflection.getCallerClass());
1485         }
1486         return contextClassLoader;
1487     }
1488 
1489     /**
1490      * Sets the context ClassLoader for this Thread. The context
1491      * ClassLoader can be set when a thread is created, and allows
1492      * the creator of the thread to provide the appropriate class loader,
1493      * through {@code getContextClassLoader}, to code running in the thread
1494      * when loading classes and resources.
1495      *
1496      * &lt;p&gt;If a security manager is present, its {@link
1497      * SecurityManager#checkPermission(java.security.Permission) checkPermission}
1498      * method is invoked with a {@link RuntimePermission RuntimePermission}{@code
1499      * (&quot;setContextClassLoader&quot;)} permission to see if setting the context
1500      * ClassLoader is permitted.
1501      *
1502      * @param  cl
1503      *         the context ClassLoader for this Thread, or null  indicating the
1504      *         system class loader (or, failing that, the bootstrap class loader)
1505      *
1506      * @throws  SecurityException
1507      *          if the current thread cannot set the context ClassLoader
1508      *
1509      * @since 1.2
1510      */
1511     public void setContextClassLoader(ClassLoader cl) {
1512         SecurityManager sm = System.getSecurityManager();
1513         if (sm != null) {
1514             sm.checkPermission(new RuntimePermission(&quot;setContextClassLoader&quot;));
1515         }
1516         contextClassLoader = cl;
1517     }
1518 
1519     /**
1520      * Returns {@code true} if and only if the current thread holds the
1521      * monitor lock on the specified object.
1522      *
1523      * &lt;p&gt;This method is designed to allow a program to assert that
1524      * the current thread already holds a specified lock:
1525      * &lt;pre&gt;
1526      *     assert Thread.holdsLock(obj);
1527      * &lt;/pre&gt;
1528      *
1529      * @param  obj the object on which to test lock ownership
1530      * @throws NullPointerException if obj is {@code null}
1531      * @return {@code true} if the current thread holds the monitor lock on
1532      *         the specified object.
1533      * @since 1.4
1534      */
1535     public static native boolean holdsLock(Object obj);
1536 
1537     private static final StackTraceElement[] EMPTY_STACK_TRACE
1538         = new StackTraceElement[0];
1539 
1540     /**
1541      * Returns an array of stack trace elements representing the stack dump
1542      * of this thread.  This method will return a zero-length array if
1543      * this thread has not started, has started but has not yet been
1544      * scheduled to run by the system, or has terminated.
1545      * If the returned array is of non-zero length then the first element of
1546      * the array represents the top of the stack, which is the most recent
1547      * method invocation in the sequence.  The last element of the array
1548      * represents the bottom of the stack, which is the least recent method
1549      * invocation in the sequence.
1550      *
1551      * &lt;p&gt;If there is a security manager, and this thread is not
1552      * the current thread, then the security manager&#39;s
1553      * {@code checkPermission} method is called with a
1554      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission
1555      * to see if it&#39;s ok to get the stack trace.
1556      *
1557      * &lt;p&gt;Some virtual machines may, under some circumstances, omit one
1558      * or more stack frames from the stack trace.  In the extreme case,
1559      * a virtual machine that has no stack trace information concerning
1560      * this thread is permitted to return a zero-length array from this
1561      * method.
1562      *
1563      * @return an array of {@code StackTraceElement},
1564      * each represents one stack frame.
1565      *
1566      * @throws SecurityException
1567      *        if a security manager exists and its
1568      *        {@code checkPermission} method doesn&#39;t allow
1569      *        getting the stack trace of thread.
1570      * @see SecurityManager#checkPermission
1571      * @see RuntimePermission
1572      * @see Throwable#getStackTrace
1573      *
1574      * @since 1.5
1575      */
1576     public StackTraceElement[] getStackTrace() {
1577         if (this != Thread.currentThread()) {
1578             // check for getStackTrace permission
1579             SecurityManager security = System.getSecurityManager();
1580             if (security != null) {
1581                 security.checkPermission(
1582                     SecurityConstants.GET_STACK_TRACE_PERMISSION);
1583             }
1584             // optimization so we do not call into the vm for threads that
1585             // have not yet started or have terminated
1586             if (!isAlive()) {
1587                 return EMPTY_STACK_TRACE;
1588             }
1589             StackTraceElement[][] stackTraceArray = dumpThreads(new Thread[] {this});
1590             StackTraceElement[] stackTrace = stackTraceArray[0];
1591             // a thread that was alive during the previous isAlive call may have
1592             // since terminated, therefore not having a stacktrace.
1593             if (stackTrace == null) {
1594                 stackTrace = EMPTY_STACK_TRACE;
1595             }
1596             return stackTrace;
1597         } else {
1598             return (new Exception()).getStackTrace();
1599         }
1600     }
1601 
1602     /**
1603      * Returns a map of stack traces for all live threads.
1604      * The map keys are threads and each map value is an array of
1605      * {@code StackTraceElement} that represents the stack dump
1606      * of the corresponding {@code Thread}.
1607      * The returned stack traces are in the format specified for
1608      * the {@link #getStackTrace getStackTrace} method.
1609      *
1610      * &lt;p&gt;The threads may be executing while this method is called.
1611      * The stack trace of each thread only represents a snapshot and
1612      * each stack trace may be obtained at different time.  A zero-length
1613      * array will be returned in the map value if the virtual machine has
1614      * no stack trace information about a thread.
1615      *
1616      * &lt;p&gt;If there is a security manager, then the security manager&#39;s
1617      * {@code checkPermission} method is called with a
1618      * {@code RuntimePermission(&quot;getStackTrace&quot;)} permission as well as
1619      * {@code RuntimePermission(&quot;modifyThreadGroup&quot;)} permission
1620      * to see if it is ok to get the stack trace of all threads.
1621      *
1622      * @return a {@code Map} from {@code Thread} to an array of
1623      * {@code StackTraceElement} that represents the stack trace of
1624      * the corresponding thread.
1625      *
1626      * @throws SecurityException
1627      *        if a security manager exists and its
1628      *        {@code checkPermission} method doesn&#39;t allow
1629      *        getting the stack trace of thread.
1630      * @see #getStackTrace
1631      * @see SecurityManager#checkPermission
1632      * @see RuntimePermission
1633      * @see Throwable#getStackTrace
1634      *
1635      * @since 1.5
1636      */
1637     public static Map&lt;Thread, StackTraceElement[]&gt; getAllStackTraces() {
1638         // check for getStackTrace permission
1639         SecurityManager security = System.getSecurityManager();
1640         if (security != null) {
1641             security.checkPermission(
1642                 SecurityConstants.GET_STACK_TRACE_PERMISSION);
1643             security.checkPermission(
1644                 SecurityConstants.MODIFY_THREADGROUP_PERMISSION);
1645         }
1646 
1647         // Get a snapshot of the list of all threads
1648         Thread[] threads = getThreads();
1649         StackTraceElement[][] traces = dumpThreads(threads);
1650         Map&lt;Thread, StackTraceElement[]&gt; m = new HashMap&lt;&gt;(threads.length);
1651         for (int i = 0; i &lt; threads.length; i++) {
1652             StackTraceElement[] stackTrace = traces[i];
1653             if (stackTrace != null) {
1654                 m.put(threads[i], stackTrace);
1655             }
1656             // else terminated so we don&#39;t put it in the map
1657         }
1658         return m;
1659     }
1660 
1661     /** cache of subclass security audit results */
1662     /* Replace with ConcurrentReferenceHashMap when/if it appears in a future
1663      * release */
1664     private static class Caches {
1665         /** cache of subclass security audit results */
1666         static final ConcurrentMap&lt;WeakClassKey,Boolean&gt; subclassAudits =
1667             new ConcurrentHashMap&lt;&gt;();
1668 
1669         /** queue for WeakReferences to audited subclasses */
1670         static final ReferenceQueue&lt;Class&lt;?&gt;&gt; subclassAuditsQueue =
1671             new ReferenceQueue&lt;&gt;();
1672     }
1673 
1674     /**
1675      * Verifies that this (possibly subclass) instance can be constructed
1676      * without violating security constraints: the subclass must not override
1677      * security-sensitive non-final methods, or else the
1678      * &quot;enableContextClassLoaderOverride&quot; RuntimePermission is checked.
1679      */
1680     private static boolean isCCLOverridden(Class&lt;?&gt; cl) {
1681         if (cl == Thread.class)
1682             return false;
1683 
1684         processQueue(Caches.subclassAuditsQueue, Caches.subclassAudits);
1685         WeakClassKey key = new WeakClassKey(cl, Caches.subclassAuditsQueue);
1686         Boolean result = Caches.subclassAudits.get(key);
1687         if (result == null) {
1688             result = Boolean.valueOf(auditSubclass(cl));
1689             Caches.subclassAudits.putIfAbsent(key, result);
1690         }
1691 
1692         return result.booleanValue();
1693     }
1694 
1695     /**
1696      * Performs reflective checks on given subclass to verify that it doesn&#39;t
1697      * override security-sensitive non-final methods.  Returns true if the
1698      * subclass overrides any of the methods, false otherwise.
1699      */
1700     private static boolean auditSubclass(final Class&lt;?&gt; subcl) {
1701         Boolean result = AccessController.doPrivileged(
1702             new PrivilegedAction&lt;&gt;() {
1703                 public Boolean run() {
1704                     for (Class&lt;?&gt; cl = subcl;
1705                          cl != Thread.class;
1706                          cl = cl.getSuperclass())
1707                     {
1708                         try {
1709                             cl.getDeclaredMethod(&quot;getContextClassLoader&quot;, new Class&lt;?&gt;[0]);
1710                             return Boolean.TRUE;
1711                         } catch (NoSuchMethodException ex) {
1712                         }
1713                         try {
1714                             Class&lt;?&gt;[] params = {ClassLoader.class};
1715                             cl.getDeclaredMethod(&quot;setContextClassLoader&quot;, params);
1716                             return Boolean.TRUE;
1717                         } catch (NoSuchMethodException ex) {
1718                         }
1719                     }
1720                     return Boolean.FALSE;
1721                 }
1722             }
1723         );
1724         return result.booleanValue();
1725     }
1726 
1727     private static native StackTraceElement[][] dumpThreads(Thread[] threads);
1728     private static native Thread[] getThreads();
1729 
1730     /**
1731      * Returns the identifier of this Thread.  The thread ID is a positive
1732      * {@code long} number generated when this thread was created.
1733      * The thread ID is unique and remains unchanged during its lifetime.
1734      * When a thread is terminated, this thread ID may be reused.
1735      *
1736      * @return this thread&#39;s ID.
1737      * @since 1.5
1738      */
1739     public long getId() {
1740         return tid;
1741     }
1742 
1743     /**
1744      * A thread state.  A thread can be in one of the following states:
1745      * &lt;ul&gt;
1746      * &lt;li&gt;{@link #NEW}&lt;br&gt;
1747      *     A thread that has not yet started is in this state.
1748      *     &lt;/li&gt;
1749      * &lt;li&gt;{@link #RUNNABLE}&lt;br&gt;
1750      *     A thread executing in the Java virtual machine is in this state.
1751      *     &lt;/li&gt;
1752      * &lt;li&gt;{@link #BLOCKED}&lt;br&gt;
1753      *     A thread that is blocked waiting for a monitor lock
1754      *     is in this state.
1755      *     &lt;/li&gt;
1756      * &lt;li&gt;{@link #WAITING}&lt;br&gt;
1757      *     A thread that is waiting indefinitely for another thread to
1758      *     perform a particular action is in this state.
1759      *     &lt;/li&gt;
1760      * &lt;li&gt;{@link #TIMED_WAITING}&lt;br&gt;
1761      *     A thread that is waiting for another thread to perform an action
1762      *     for up to a specified waiting time is in this state.
1763      *     &lt;/li&gt;
1764      * &lt;li&gt;{@link #TERMINATED}&lt;br&gt;
1765      *     A thread that has exited is in this state.
1766      *     &lt;/li&gt;
1767      * &lt;/ul&gt;
1768      *
1769      * &lt;p&gt;
1770      * A thread can be in only one state at a given point in time.
1771      * These states are virtual machine states which do not reflect
1772      * any operating system thread states.
1773      *
1774      * @since   1.5
1775      * @see #getState
1776      */
1777     public enum State {
1778         /**
1779          * Thread state for a thread which has not yet started.
1780          */
1781         NEW,
1782 
1783         /**
1784          * Thread state for a runnable thread.  A thread in the runnable
1785          * state is executing in the Java virtual machine but it may
1786          * be waiting for other resources from the operating system
1787          * such as processor.
1788          */
1789         RUNNABLE,
1790 
1791         /**
1792          * Thread state for a thread blocked waiting for a monitor lock.
1793          * A thread in the blocked state is waiting for a monitor lock
1794          * to enter a synchronized block/method or
1795          * reenter a synchronized block/method after calling
1796          * {@link Object#wait() Object.wait}.
1797          */
1798         BLOCKED,
1799 
1800         /**
1801          * Thread state for a waiting thread.
1802          * A thread is in the waiting state due to calling one of the
1803          * following methods:
1804          * &lt;ul&gt;
1805          *   &lt;li&gt;{@link Object#wait() Object.wait} with no timeout&lt;/li&gt;
1806          *   &lt;li&gt;{@link #join() Thread.join} with no timeout&lt;/li&gt;
1807          *   &lt;li&gt;{@link LockSupport#park() LockSupport.park}&lt;/li&gt;
1808          * &lt;/ul&gt;
1809          *
1810          * &lt;p&gt;A thread in the waiting state is waiting for another thread to
1811          * perform a particular action.
1812          *
1813          * For example, a thread that has called {@code Object.wait()}
1814          * on an object is waiting for another thread to call
1815          * {@code Object.notify()} or {@code Object.notifyAll()} on
1816          * that object. A thread that has called {@code Thread.join()}
1817          * is waiting for a specified thread to terminate.
1818          */
1819         WAITING,
1820 
1821         /**
1822          * Thread state for a waiting thread with a specified waiting time.
1823          * A thread is in the timed waiting state due to calling one of
1824          * the following methods with a specified positive waiting time:
1825          * &lt;ul&gt;
1826          *   &lt;li&gt;{@link #sleep Thread.sleep}&lt;/li&gt;
1827          *   &lt;li&gt;{@link Object#wait(long) Object.wait} with timeout&lt;/li&gt;
1828          *   &lt;li&gt;{@link #join(long) Thread.join} with timeout&lt;/li&gt;
1829          *   &lt;li&gt;{@link LockSupport#parkNanos LockSupport.parkNanos}&lt;/li&gt;
1830          *   &lt;li&gt;{@link LockSupport#parkUntil LockSupport.parkUntil}&lt;/li&gt;
1831          * &lt;/ul&gt;
1832          */
1833         TIMED_WAITING,
1834 
1835         /**
1836          * Thread state for a terminated thread.
1837          * The thread has completed execution.
1838          */
1839         TERMINATED;
1840     }
1841 
1842     /**
1843      * Returns the state of this thread.
1844      * This method is designed for use in monitoring of the system state,
1845      * not for synchronization control.
1846      *
1847      * @return this thread&#39;s state.
1848      * @since 1.5
1849      */
1850     public State getState() {
1851         // get current thread state
1852         return jdk.internal.misc.VM.toThreadState(threadStatus);
1853     }
1854 
1855     // Added in JSR-166
1856 
1857     /**
1858      * Interface for handlers invoked when a {@code Thread} abruptly
1859      * terminates due to an uncaught exception.
1860      * &lt;p&gt;When a thread is about to terminate due to an uncaught exception
1861      * the Java Virtual Machine will query the thread for its
1862      * {@code UncaughtExceptionHandler} using
1863      * {@link #getUncaughtExceptionHandler} and will invoke the handler&#39;s
1864      * {@code uncaughtException} method, passing the thread and the
1865      * exception as arguments.
1866      * If a thread has not had its {@code UncaughtExceptionHandler}
1867      * explicitly set, then its {@code ThreadGroup} object acts as its
1868      * {@code UncaughtExceptionHandler}. If the {@code ThreadGroup} object
1869      * has no
1870      * special requirements for dealing with the exception, it can forward
1871      * the invocation to the {@linkplain #getDefaultUncaughtExceptionHandler
1872      * default uncaught exception handler}.
1873      *
1874      * @see #setDefaultUncaughtExceptionHandler
1875      * @see #setUncaughtExceptionHandler
1876      * @see ThreadGroup#uncaughtException
1877      * @since 1.5
1878      */
1879     @FunctionalInterface
1880     public interface UncaughtExceptionHandler {
1881         /**
1882          * Method invoked when the given thread terminates due to the
1883          * given uncaught exception.
1884          * &lt;p&gt;Any exception thrown by this method will be ignored by the
1885          * Java Virtual Machine.
1886          * @param t the thread
1887          * @param e the exception
1888          */
1889         void uncaughtException(Thread t, Throwable e);
1890     }
1891 
1892     // null unless explicitly set
1893     private volatile UncaughtExceptionHandler uncaughtExceptionHandler;
1894 
1895     // null unless explicitly set
1896     private static volatile UncaughtExceptionHandler defaultUncaughtExceptionHandler;
1897 
1898     /**
1899      * Set the default handler invoked when a thread abruptly terminates
1900      * due to an uncaught exception, and no other handler has been defined
1901      * for that thread.
1902      *
1903      * &lt;p&gt;Uncaught exception handling is controlled first by the thread, then
1904      * by the thread&#39;s {@link ThreadGroup} object and finally by the default
1905      * uncaught exception handler. If the thread does not have an explicit
1906      * uncaught exception handler set, and the thread&#39;s thread group
1907      * (including parent thread groups)  does not specialize its
1908      * {@code uncaughtException} method, then the default handler&#39;s
1909      * {@code uncaughtException} method will be invoked.
1910      * &lt;p&gt;By setting the default uncaught exception handler, an application
1911      * can change the way in which uncaught exceptions are handled (such as
1912      * logging to a specific device, or file) for those threads that would
1913      * already accept whatever &amp;quot;default&amp;quot; behavior the system
1914      * provided.
1915      *
1916      * &lt;p&gt;Note that the default uncaught exception handler should not usually
1917      * defer to the thread&#39;s {@code ThreadGroup} object, as that could cause
1918      * infinite recursion.
1919      *
1920      * @param eh the object to use as the default uncaught exception handler.
1921      * If {@code null} then there is no default handler.
1922      *
1923      * @throws SecurityException if a security manager is present and it denies
1924      *         {@link RuntimePermission}{@code (&quot;setDefaultUncaughtExceptionHandler&quot;)}
1925      *
1926      * @see #setUncaughtExceptionHandler
1927      * @see #getUncaughtExceptionHandler
1928      * @see ThreadGroup#uncaughtException
1929      * @since 1.5
1930      */
1931     public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
1932         SecurityManager sm = System.getSecurityManager();
1933         if (sm != null) {
1934             sm.checkPermission(
1935                 new RuntimePermission(&quot;setDefaultUncaughtExceptionHandler&quot;)
1936                     );
1937         }
1938 
1939          defaultUncaughtExceptionHandler = eh;
1940      }
1941 
1942     /**
1943      * Returns the default handler invoked when a thread abruptly terminates
1944      * due to an uncaught exception. If the returned value is {@code null},
1945      * there is no default.
1946      * @since 1.5
1947      * @see #setDefaultUncaughtExceptionHandler
1948      * @return the default uncaught exception handler for all threads
1949      */
1950     public static UncaughtExceptionHandler getDefaultUncaughtExceptionHandler(){
1951         return defaultUncaughtExceptionHandler;
1952     }
1953 
1954     /**
1955      * Returns the handler invoked when this thread abruptly terminates
1956      * due to an uncaught exception. If this thread has not had an
1957      * uncaught exception handler explicitly set then this thread&#39;s
1958      * {@code ThreadGroup} object is returned, unless this thread
1959      * has terminated, in which case {@code null} is returned.
1960      * @since 1.5
1961      * @return the uncaught exception handler for this thread
1962      */
1963     public UncaughtExceptionHandler getUncaughtExceptionHandler() {
1964         return uncaughtExceptionHandler != null ?
1965             uncaughtExceptionHandler : group;
1966     }
1967 
1968     /**
1969      * Set the handler invoked when this thread abruptly terminates
1970      * due to an uncaught exception.
1971      * &lt;p&gt;A thread can take full control of how it responds to uncaught
1972      * exceptions by having its uncaught exception handler explicitly set.
1973      * If no such handler is set then the thread&#39;s {@code ThreadGroup}
1974      * object acts as its handler.
1975      * @param eh the object to use as this thread&#39;s uncaught exception
1976      * handler. If {@code null} then this thread has no explicit handler.
1977      * @throws  SecurityException  if the current thread is not allowed to
1978      *          modify this thread.
1979      * @see #setDefaultUncaughtExceptionHandler
1980      * @see ThreadGroup#uncaughtException
1981      * @since 1.5
1982      */
1983     public void setUncaughtExceptionHandler(UncaughtExceptionHandler eh) {
1984         checkAccess();
1985         uncaughtExceptionHandler = eh;
1986     }
1987 
1988     /**
1989      * Dispatch an uncaught exception to the handler. This method is
1990      * intended to be called only by the JVM.
1991      */
1992     private void dispatchUncaughtException(Throwable e) {
1993         getUncaughtExceptionHandler().uncaughtException(this, e);
1994     }
1995 
1996     /**
1997      * Removes from the specified map any keys that have been enqueued
1998      * on the specified reference queue.
1999      */
2000     static void processQueue(ReferenceQueue&lt;Class&lt;?&gt;&gt; queue,
2001                              ConcurrentMap&lt;? extends
2002                              WeakReference&lt;Class&lt;?&gt;&gt;, ?&gt; map)
2003     {
2004         Reference&lt;? extends Class&lt;?&gt;&gt; ref;
2005         while((ref = queue.poll()) != null) {
2006             map.remove(ref);
2007         }
2008     }
2009 
2010     /**
2011      *  Weak key for Class objects.
2012      **/
2013     static class WeakClassKey extends WeakReference&lt;Class&lt;?&gt;&gt; {
2014         /**
2015          * saved value of the referent&#39;s identity hash code, to maintain
2016          * a consistent hash code after the referent has been cleared
2017          */
2018         private final int hash;
2019 
2020         /**
2021          * Create a new WeakClassKey to the given object, registered
2022          * with a queue.
2023          */
2024         WeakClassKey(Class&lt;?&gt; cl, ReferenceQueue&lt;Class&lt;?&gt;&gt; refQueue) {
2025             super(cl, refQueue);
2026             hash = System.identityHashCode(cl);
2027         }
2028 
2029         /**
2030          * Returns the identity hash code of the original referent.
2031          */
2032         @Override
2033         public int hashCode() {
2034             return hash;
2035         }
2036 
2037         /**
2038          * Returns true if the given object is this identical
2039          * WeakClassKey instance, or, if this object&#39;s referent has not
2040          * been cleared, if the given object is another WeakClassKey
2041          * instance with the identical non-null referent as this one.
2042          */
2043         @Override
2044         public boolean equals(Object obj) {
2045             if (obj == this)
2046                 return true;
2047 
2048             if (obj instanceof WeakClassKey) {
2049                 Object referent = get();
2050                 return (referent != null) &amp;&amp;
2051                        (referent == ((WeakClassKey) obj).get());
2052             } else {
2053                 return false;
2054             }
2055         }
2056     }
2057 
2058 
2059     // The following three initially uninitialized fields are exclusively
2060     // managed by class java.util.concurrent.ThreadLocalRandom. These
2061     // fields are used to build the high-performance PRNGs in the
2062     // concurrent code, and we can not risk accidental false sharing.
2063     // Hence, the fields are isolated with @Contended.
2064 
2065     /** The current seed for a ThreadLocalRandom */
2066     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2067     long threadLocalRandomSeed;
2068 
2069     /** Probe hash value; nonzero if threadLocalRandomSeed initialized */
2070     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2071     int threadLocalRandomProbe;
2072 
2073     /** Secondary seed isolated from public ThreadLocalRandom sequence */
2074     @jdk.internal.vm.annotation.Contended(&quot;tlr&quot;)
2075     int threadLocalRandomSecondarySeed;
2076 
2077     /* Some private helper methods */
2078     private native void setPriority0(int newPriority);
2079     private native void stop0(Object o);
2080     private native void suspend0();
2081     private native void resume0();
2082     private native void interrupt0();
2083     private static native void clearInterruptEvent();
2084     private native void setNativeName(String name);
2085 }
    </pre>
  </body>
</html>
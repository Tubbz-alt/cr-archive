<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/util/TreeMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StringJoiner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="regex/CharPredicates.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/util/TreeMap.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.Serializable;
  29 import java.util.function.BiConsumer;
  30 import java.util.function.BiFunction;
  31 import java.util.function.Consumer;

  32 
  33 /**
  34  * A Red-Black tree based {@link NavigableMap} implementation.
  35  * The map is sorted according to the {@linkplain Comparable natural
  36  * ordering} of its keys, or by a {@link Comparator} provided at map
  37  * creation time, depending on which constructor is used.
  38  *
  39  * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the
  40  * {@code containsKey}, {@code get}, {@code put} and {@code remove}
  41  * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and
  42  * Rivest&#39;s &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.
  43  *
  44  * &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and
  45  * whether or not an explicit comparator is provided, must be &lt;em&gt;consistent
  46  * with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the
  47  * {@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a
  48  * precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
  49  * the {@code Map} interface is defined in terms of the {@code equals}
  50  * operation, but a sorted map performs all key comparisons using its {@code
  51  * compareTo} (or {@code compare}) method, so two keys that are deemed equal by
</pre>
<hr />
<pre>
 324         }
 325         super.putAll(map);
 326     }
 327 
 328     /**
 329      * Returns this map&#39;s entry for the given key, or {@code null} if the map
 330      * does not contain an entry for the key.
 331      *
 332      * @return this map&#39;s entry for the given key, or {@code null} if the map
 333      *         does not contain an entry for the key
 334      * @throws ClassCastException if the specified key cannot be compared
 335      *         with the keys currently in the map
 336      * @throws NullPointerException if the specified key is null
 337      *         and this map uses natural ordering, or its comparator
 338      *         does not permit null keys
 339      */
 340     final Entry&lt;K,V&gt; getEntry(Object key) {
 341         // Offload comparator-based version for sake of performance
 342         if (comparator != null)
 343             return getEntryUsingComparator(key);
<span class="line-modified"> 344         if (key == null)</span>
<span class="line-removed"> 345             throw new NullPointerException();</span>
 346         @SuppressWarnings(&quot;unchecked&quot;)
 347             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 348         Entry&lt;K,V&gt; p = root;
 349         while (p != null) {
 350             int cmp = k.compareTo(p.key);
 351             if (cmp &lt; 0)
 352                 p = p.left;
 353             else if (cmp &gt; 0)
 354                 p = p.right;
 355             else
 356                 return p;
 357         }
 358         return null;
 359     }
 360 
 361     /**
 362      * Version of getEntry using comparator. Split off from getEntry
 363      * for performance. (This is not worth doing for most methods,
 364      * that are less dependent on comparator performance, but is
 365      * worthwhile here.)
</pre>
<hr />
<pre>
 514 
 515     /**
 516      * Associates the specified value with the specified key in this map.
 517      * If the map previously contained a mapping for the key, the old
 518      * value is replaced.
 519      *
 520      * @param key key with which the specified value is to be associated
 521      * @param value value to be associated with the specified key
 522      *
 523      * @return the previous value associated with {@code key}, or
 524      *         {@code null} if there was no mapping for {@code key}.
 525      *         (A {@code null} return can also indicate that the map
 526      *         previously associated {@code null} with {@code key}.)
 527      * @throws ClassCastException if the specified key cannot be compared
 528      *         with the keys currently in the map
 529      * @throws NullPointerException if the specified key is null
 530      *         and this map uses natural ordering, or its comparator
 531      *         does not permit null keys
 532      */
 533     public V put(K key, V value) {






















 534         Entry&lt;K,V&gt; t = root;
 535         if (t == null) {
<span class="line-modified"> 536             compare(key, key); // type (and possibly null) check</span>












































 537 
<span class="line-modified"> 538             root = new Entry&lt;&gt;(key, value, null);</span>
<span class="line-modified"> 539             size = 1;</span>
<span class="line-modified"> 540             modCount++;</span>














 541             return null;
 542         }


























 543         int cmp;
 544         Entry&lt;K,V&gt; parent;
 545         // split comparator and comparable paths
 546         Comparator&lt;? super K&gt; cpr = comparator;
 547         if (cpr != null) {
 548             do {
 549                 parent = t;
 550                 cmp = cpr.compare(key, t.key);
 551                 if (cmp &lt; 0)
 552                     t = t.left;
 553                 else if (cmp &gt; 0)
 554                     t = t.right;
 555                 else
<span class="line-modified"> 556                     return t.setValue(value);</span>
 557             } while (t != null);
<span class="line-modified"> 558         }</span>
<span class="line-modified"> 559         else {</span>
<span class="line-removed"> 560             if (key == null)</span>
<span class="line-removed"> 561                 throw new NullPointerException();</span>
 562             @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified"> 563                 Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
 564             do {
 565                 parent = t;
 566                 cmp = k.compareTo(t.key);
 567                 if (cmp &lt; 0)
 568                     t = t.left;
 569                 else if (cmp &gt; 0)
 570                     t = t.right;
 571                 else
<span class="line-modified"> 572                     return t.setValue(value);</span>
 573             } while (t != null);
 574         }














































































 575         Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
<span class="line-modified"> 576         if (cmp &lt; 0)</span>
 577             parent.left = e;
 578         else
 579             parent.right = e;
 580         fixAfterInsertion(e);
 581         size++;
 582         modCount++;
























































 583         return null;
 584     }
 585 


































 586     /**
 587      * Removes the mapping for this key from this TreeMap if present.
 588      *
 589      * @param  key key for which mapping should be removed
 590      * @return the previous value associated with {@code key}, or
 591      *         {@code null} if there was no mapping for {@code key}.
 592      *         (A {@code null} return can also indicate that the map
 593      *         previously associated {@code null} with {@code key}.)
 594      * @throws ClassCastException if the specified key cannot be compared
 595      *         with the keys currently in the map
 596      * @throws NullPointerException if the specified key is null
 597      *         and this map uses natural ordering, or its comparator
 598      *         does not permit null keys
 599      */
 600     public V remove(Object key) {
 601         Entry&lt;K,V&gt; p = getEntry(key);
 602         if (p == null)
 603             return null;
 604 
 605         V oldValue = p.value;
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.Serializable;
  29 import java.util.function.BiConsumer;
  30 import java.util.function.BiFunction;
  31 import java.util.function.Consumer;
<span class="line-added">  32 import java.util.function.Function;</span>
  33 
  34 /**
  35  * A Red-Black tree based {@link NavigableMap} implementation.
  36  * The map is sorted according to the {@linkplain Comparable natural
  37  * ordering} of its keys, or by a {@link Comparator} provided at map
  38  * creation time, depending on which constructor is used.
  39  *
  40  * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the
  41  * {@code containsKey}, {@code get}, {@code put} and {@code remove}
  42  * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and
  43  * Rivest&#39;s &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.
  44  *
  45  * &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and
  46  * whether or not an explicit comparator is provided, must be &lt;em&gt;consistent
  47  * with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the
  48  * {@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a
  49  * precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
  50  * the {@code Map} interface is defined in terms of the {@code equals}
  51  * operation, but a sorted map performs all key comparisons using its {@code
  52  * compareTo} (or {@code compare}) method, so two keys that are deemed equal by
</pre>
<hr />
<pre>
 325         }
 326         super.putAll(map);
 327     }
 328 
 329     /**
 330      * Returns this map&#39;s entry for the given key, or {@code null} if the map
 331      * does not contain an entry for the key.
 332      *
 333      * @return this map&#39;s entry for the given key, or {@code null} if the map
 334      *         does not contain an entry for the key
 335      * @throws ClassCastException if the specified key cannot be compared
 336      *         with the keys currently in the map
 337      * @throws NullPointerException if the specified key is null
 338      *         and this map uses natural ordering, or its comparator
 339      *         does not permit null keys
 340      */
 341     final Entry&lt;K,V&gt; getEntry(Object key) {
 342         // Offload comparator-based version for sake of performance
 343         if (comparator != null)
 344             return getEntryUsingComparator(key);
<span class="line-modified"> 345         Objects.requireNonNull(key);</span>

 346         @SuppressWarnings(&quot;unchecked&quot;)
 347             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 348         Entry&lt;K,V&gt; p = root;
 349         while (p != null) {
 350             int cmp = k.compareTo(p.key);
 351             if (cmp &lt; 0)
 352                 p = p.left;
 353             else if (cmp &gt; 0)
 354                 p = p.right;
 355             else
 356                 return p;
 357         }
 358         return null;
 359     }
 360 
 361     /**
 362      * Version of getEntry using comparator. Split off from getEntry
 363      * for performance. (This is not worth doing for most methods,
 364      * that are less dependent on comparator performance, but is
 365      * worthwhile here.)
</pre>
<hr />
<pre>
 514 
 515     /**
 516      * Associates the specified value with the specified key in this map.
 517      * If the map previously contained a mapping for the key, the old
 518      * value is replaced.
 519      *
 520      * @param key key with which the specified value is to be associated
 521      * @param value value to be associated with the specified key
 522      *
 523      * @return the previous value associated with {@code key}, or
 524      *         {@code null} if there was no mapping for {@code key}.
 525      *         (A {@code null} return can also indicate that the map
 526      *         previously associated {@code null} with {@code key}.)
 527      * @throws ClassCastException if the specified key cannot be compared
 528      *         with the keys currently in the map
 529      * @throws NullPointerException if the specified key is null
 530      *         and this map uses natural ordering, or its comparator
 531      *         does not permit null keys
 532      */
 533     public V put(K key, V value) {
<span class="line-added"> 534         return put(key, value, true);</span>
<span class="line-added"> 535     }</span>
<span class="line-added"> 536 </span>
<span class="line-added"> 537     @Override</span>
<span class="line-added"> 538     public V putIfAbsent(K key, V value) {</span>
<span class="line-added"> 539         return put(key, value, false);</span>
<span class="line-added"> 540     }</span>
<span class="line-added"> 541 </span>
<span class="line-added"> 542     /**</span>
<span class="line-added"> 543      * {@inheritDoc}</span>
<span class="line-added"> 544      *</span>
<span class="line-added"> 545      * &lt;p&gt;This method will, on a best-effort basis, throw a</span>
<span class="line-added"> 546      * {@link ConcurrentModificationException} if it is detected that the</span>
<span class="line-added"> 547      * mapping function modifies this map during computation.</span>
<span class="line-added"> 548      *</span>
<span class="line-added"> 549      * @throws ConcurrentModificationException if it is detected that the</span>
<span class="line-added"> 550      * mapping function modified this map</span>
<span class="line-added"> 551      */</span>
<span class="line-added"> 552     @Override</span>
<span class="line-added"> 553     public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {</span>
<span class="line-added"> 554         Objects.requireNonNull(mappingFunction);</span>
<span class="line-added"> 555         V newValue;</span>
 556         Entry&lt;K,V&gt; t = root;
 557         if (t == null) {
<span class="line-modified"> 558             newValue = callMappingFunctionWithCheck(key, mappingFunction);</span>
<span class="line-added"> 559             if (newValue != null) {</span>
<span class="line-added"> 560                 addEntryToEmptyMap(key, newValue);</span>
<span class="line-added"> 561                 return newValue;</span>
<span class="line-added"> 562             } else {</span>
<span class="line-added"> 563                 return null;</span>
<span class="line-added"> 564             }</span>
<span class="line-added"> 565         }</span>
<span class="line-added"> 566         int cmp;</span>
<span class="line-added"> 567         Entry&lt;K,V&gt; parent;</span>
<span class="line-added"> 568         // split comparator and comparable paths</span>
<span class="line-added"> 569         Comparator&lt;? super K&gt; cpr = comparator;</span>
<span class="line-added"> 570         if (cpr != null) {</span>
<span class="line-added"> 571             do {</span>
<span class="line-added"> 572                 parent = t;</span>
<span class="line-added"> 573                 cmp = cpr.compare(key, t.key);</span>
<span class="line-added"> 574                 if (cmp &lt; 0)</span>
<span class="line-added"> 575                     t = t.left;</span>
<span class="line-added"> 576                 else if (cmp &gt; 0)</span>
<span class="line-added"> 577                     t = t.right;</span>
<span class="line-added"> 578                 else</span>
<span class="line-added"> 579                     return t.value;</span>
<span class="line-added"> 580             } while (t != null);</span>
<span class="line-added"> 581         } else {</span>
<span class="line-added"> 582             Objects.requireNonNull(key);</span>
<span class="line-added"> 583             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added"> 584             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
<span class="line-added"> 585             do {</span>
<span class="line-added"> 586                 parent = t;</span>
<span class="line-added"> 587                 cmp = k.compareTo(t.key);</span>
<span class="line-added"> 588                 if (cmp &lt; 0)</span>
<span class="line-added"> 589                     t = t.left;</span>
<span class="line-added"> 590                 else if (cmp &gt; 0)</span>
<span class="line-added"> 591                     t = t.right;</span>
<span class="line-added"> 592                 else</span>
<span class="line-added"> 593                     return t.value;</span>
<span class="line-added"> 594             } while (t != null);</span>
<span class="line-added"> 595         }</span>
<span class="line-added"> 596         newValue = callMappingFunctionWithCheck(key, mappingFunction);</span>
<span class="line-added"> 597         if (newValue != null) {</span>
<span class="line-added"> 598             addEntry(key, newValue, parent, cmp &lt; 0);</span>
<span class="line-added"> 599             return newValue;</span>
<span class="line-added"> 600         }</span>
<span class="line-added"> 601         return null;</span>
<span class="line-added"> 602     }</span>
 603 
<span class="line-modified"> 604     /**</span>
<span class="line-modified"> 605      * {@inheritDoc}</span>
<span class="line-modified"> 606      *</span>
<span class="line-added"> 607      * &lt;p&gt;This method will, on a best-effort basis, throw a</span>
<span class="line-added"> 608      * {@link ConcurrentModificationException} if it is detected that the</span>
<span class="line-added"> 609      * remapping function modifies this map during computation.</span>
<span class="line-added"> 610      *</span>
<span class="line-added"> 611      * @throws ConcurrentModificationException if it is detected that the</span>
<span class="line-added"> 612      * remapping function modified this map</span>
<span class="line-added"> 613      */</span>
<span class="line-added"> 614     @Override</span>
<span class="line-added"> 615     public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</span>
<span class="line-added"> 616         Objects.requireNonNull(remappingFunction);</span>
<span class="line-added"> 617         Entry&lt;K,V&gt; oldEntry = getEntry(key);</span>
<span class="line-added"> 618         if (oldEntry != null &amp;&amp; oldEntry.value != null) {</span>
<span class="line-added"> 619             return remapValue(oldEntry, key, remappingFunction);</span>
<span class="line-added"> 620         } else {</span>
 621             return null;
 622         }
<span class="line-added"> 623     }</span>
<span class="line-added"> 624 </span>
<span class="line-added"> 625     /**</span>
<span class="line-added"> 626      * {@inheritDoc}</span>
<span class="line-added"> 627      *</span>
<span class="line-added"> 628      * &lt;p&gt;This method will, on a best-effort basis, throw a</span>
<span class="line-added"> 629      * {@link ConcurrentModificationException} if it is detected that the</span>
<span class="line-added"> 630      * remapping function modifies this map during computation.</span>
<span class="line-added"> 631      *</span>
<span class="line-added"> 632      * @throws ConcurrentModificationException if it is detected that the</span>
<span class="line-added"> 633      * remapping function modified this map</span>
<span class="line-added"> 634      */</span>
<span class="line-added"> 635     @Override</span>
<span class="line-added"> 636     public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</span>
<span class="line-added"> 637         Objects.requireNonNull(remappingFunction);</span>
<span class="line-added"> 638         V newValue;</span>
<span class="line-added"> 639         Entry&lt;K,V&gt; t = root;</span>
<span class="line-added"> 640         if (t == null) {</span>
<span class="line-added"> 641             newValue = callRemappingFunctionWithCheck(key, null, remappingFunction);</span>
<span class="line-added"> 642             if (newValue != null) {</span>
<span class="line-added"> 643                 addEntryToEmptyMap(key, newValue);</span>
<span class="line-added"> 644                 return newValue;</span>
<span class="line-added"> 645             } else {</span>
<span class="line-added"> 646                 return null;</span>
<span class="line-added"> 647             }</span>
<span class="line-added"> 648         }</span>
 649         int cmp;
 650         Entry&lt;K,V&gt; parent;
 651         // split comparator and comparable paths
 652         Comparator&lt;? super K&gt; cpr = comparator;
 653         if (cpr != null) {
 654             do {
 655                 parent = t;
 656                 cmp = cpr.compare(key, t.key);
 657                 if (cmp &lt; 0)
 658                     t = t.left;
 659                 else if (cmp &gt; 0)
 660                     t = t.right;
 661                 else
<span class="line-modified"> 662                     return remapValue(t, key, remappingFunction);</span>
 663             } while (t != null);
<span class="line-modified"> 664         } else {</span>
<span class="line-modified"> 665             Objects.requireNonNull(key);</span>


 666             @SuppressWarnings(&quot;unchecked&quot;)
<span class="line-modified"> 667             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
 668             do {
 669                 parent = t;
 670                 cmp = k.compareTo(t.key);
 671                 if (cmp &lt; 0)
 672                     t = t.left;
 673                 else if (cmp &gt; 0)
 674                     t = t.right;
 675                 else
<span class="line-modified"> 676                     return remapValue(t, key, remappingFunction);</span>
 677             } while (t != null);
 678         }
<span class="line-added"> 679         newValue = callRemappingFunctionWithCheck(key, null, remappingFunction);</span>
<span class="line-added"> 680         if (newValue != null) {</span>
<span class="line-added"> 681             addEntry(key, newValue, parent, cmp &lt; 0);</span>
<span class="line-added"> 682             return newValue;</span>
<span class="line-added"> 683         }</span>
<span class="line-added"> 684         return null;</span>
<span class="line-added"> 685     }</span>
<span class="line-added"> 686 </span>
<span class="line-added"> 687     /**</span>
<span class="line-added"> 688      * {@inheritDoc}</span>
<span class="line-added"> 689      *</span>
<span class="line-added"> 690      * &lt;p&gt;This method will, on a best-effort basis, throw a</span>
<span class="line-added"> 691      * {@link ConcurrentModificationException} if it is detected that the</span>
<span class="line-added"> 692      * remapping function modifies this map during computation.</span>
<span class="line-added"> 693      *</span>
<span class="line-added"> 694      * @throws ConcurrentModificationException if it is detected that the</span>
<span class="line-added"> 695      * remapping function modified this map</span>
<span class="line-added"> 696      */</span>
<span class="line-added"> 697     @Override</span>
<span class="line-added"> 698     public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {</span>
<span class="line-added"> 699         Objects.requireNonNull(remappingFunction);</span>
<span class="line-added"> 700         Objects.requireNonNull(value);</span>
<span class="line-added"> 701         Entry&lt;K,V&gt; t = root;</span>
<span class="line-added"> 702         if (t == null) {</span>
<span class="line-added"> 703             addEntryToEmptyMap(key, value);</span>
<span class="line-added"> 704             return value;</span>
<span class="line-added"> 705         }</span>
<span class="line-added"> 706         int cmp;</span>
<span class="line-added"> 707         Entry&lt;K,V&gt; parent;</span>
<span class="line-added"> 708         // split comparator and comparable paths</span>
<span class="line-added"> 709         Comparator&lt;? super K&gt; cpr = comparator;</span>
<span class="line-added"> 710         if (cpr != null) {</span>
<span class="line-added"> 711             do {</span>
<span class="line-added"> 712                 parent = t;</span>
<span class="line-added"> 713                 cmp = cpr.compare(key, t.key);</span>
<span class="line-added"> 714                 if (cmp &lt; 0)</span>
<span class="line-added"> 715                     t = t.left;</span>
<span class="line-added"> 716                 else if (cmp &gt; 0)</span>
<span class="line-added"> 717                     t = t.right;</span>
<span class="line-added"> 718                 else return mergeValue(t, value, remappingFunction);</span>
<span class="line-added"> 719             } while (t != null);</span>
<span class="line-added"> 720         } else {</span>
<span class="line-added"> 721             Objects.requireNonNull(key);</span>
<span class="line-added"> 722             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added"> 723             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
<span class="line-added"> 724             do {</span>
<span class="line-added"> 725                 parent = t;</span>
<span class="line-added"> 726                 cmp = k.compareTo(t.key);</span>
<span class="line-added"> 727                 if (cmp &lt; 0)</span>
<span class="line-added"> 728                     t = t.left;</span>
<span class="line-added"> 729                 else if (cmp &gt; 0)</span>
<span class="line-added"> 730                     t = t.right;</span>
<span class="line-added"> 731                 else return mergeValue(t, value, remappingFunction);</span>
<span class="line-added"> 732             } while (t != null);</span>
<span class="line-added"> 733         }</span>
<span class="line-added"> 734         addEntry(key, value, parent, cmp &lt; 0);</span>
<span class="line-added"> 735         return value;</span>
<span class="line-added"> 736     }</span>
<span class="line-added"> 737 </span>
<span class="line-added"> 738     private V callMappingFunctionWithCheck(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {</span>
<span class="line-added"> 739         int mc = modCount;</span>
<span class="line-added"> 740         V newValue = mappingFunction.apply(key);</span>
<span class="line-added"> 741         if (mc != modCount) {</span>
<span class="line-added"> 742             throw new ConcurrentModificationException();</span>
<span class="line-added"> 743         }</span>
<span class="line-added"> 744         return newValue;</span>
<span class="line-added"> 745     }</span>
<span class="line-added"> 746 </span>
<span class="line-added"> 747     private V callRemappingFunctionWithCheck(K key, V oldValue, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</span>
<span class="line-added"> 748         int mc = modCount;</span>
<span class="line-added"> 749         V newValue = remappingFunction.apply(key, oldValue);</span>
<span class="line-added"> 750         if (mc != modCount) {</span>
<span class="line-added"> 751             throw new ConcurrentModificationException();</span>
<span class="line-added"> 752         }</span>
<span class="line-added"> 753         return newValue;</span>
<span class="line-added"> 754     }</span>
<span class="line-added"> 755 </span>
<span class="line-added"> 756     private void addEntry(K key, V value, Entry&lt;K, V&gt; parent, boolean addToLeft) {</span>
 757         Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
<span class="line-modified"> 758         if (addToLeft)</span>
 759             parent.left = e;
 760         else
 761             parent.right = e;
 762         fixAfterInsertion(e);
 763         size++;
 764         modCount++;
<span class="line-added"> 765     }</span>
<span class="line-added"> 766 </span>
<span class="line-added"> 767     private void addEntryToEmptyMap(K key, V value) {</span>
<span class="line-added"> 768         compare(key, key); // type (and possibly null) check</span>
<span class="line-added"> 769         root = new Entry&lt;&gt;(key, value, null);</span>
<span class="line-added"> 770         size = 1;</span>
<span class="line-added"> 771         modCount++;</span>
<span class="line-added"> 772     }</span>
<span class="line-added"> 773 </span>
<span class="line-added"> 774     private V put(K key, V value, boolean replaceOld) {</span>
<span class="line-added"> 775         Entry&lt;K,V&gt; t = root;</span>
<span class="line-added"> 776         if (t == null) {</span>
<span class="line-added"> 777             addEntryToEmptyMap(key, value);</span>
<span class="line-added"> 778             return null;</span>
<span class="line-added"> 779         }</span>
<span class="line-added"> 780         int cmp;</span>
<span class="line-added"> 781         Entry&lt;K,V&gt; parent;</span>
<span class="line-added"> 782         // split comparator and comparable paths</span>
<span class="line-added"> 783         Comparator&lt;? super K&gt; cpr = comparator;</span>
<span class="line-added"> 784         if (cpr != null) {</span>
<span class="line-added"> 785             do {</span>
<span class="line-added"> 786                 parent = t;</span>
<span class="line-added"> 787                 cmp = cpr.compare(key, t.key);</span>
<span class="line-added"> 788                 if (cmp &lt; 0)</span>
<span class="line-added"> 789                     t = t.left;</span>
<span class="line-added"> 790                 else if (cmp &gt; 0)</span>
<span class="line-added"> 791                     t = t.right;</span>
<span class="line-added"> 792                 else {</span>
<span class="line-added"> 793                     V oldValue = t.value;</span>
<span class="line-added"> 794                     if (replaceOld || oldValue == null) {</span>
<span class="line-added"> 795                         t.value = value;</span>
<span class="line-added"> 796                     }</span>
<span class="line-added"> 797                     return oldValue;</span>
<span class="line-added"> 798                 }</span>
<span class="line-added"> 799             } while (t != null);</span>
<span class="line-added"> 800         } else {</span>
<span class="line-added"> 801             Objects.requireNonNull(key);</span>
<span class="line-added"> 802             @SuppressWarnings(&quot;unchecked&quot;)</span>
<span class="line-added"> 803             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</span>
<span class="line-added"> 804             do {</span>
<span class="line-added"> 805                 parent = t;</span>
<span class="line-added"> 806                 cmp = k.compareTo(t.key);</span>
<span class="line-added"> 807                 if (cmp &lt; 0)</span>
<span class="line-added"> 808                     t = t.left;</span>
<span class="line-added"> 809                 else if (cmp &gt; 0)</span>
<span class="line-added"> 810                     t = t.right;</span>
<span class="line-added"> 811                 else {</span>
<span class="line-added"> 812                     V oldValue = t.value;</span>
<span class="line-added"> 813                     if (replaceOld || oldValue == null) {</span>
<span class="line-added"> 814                         t.value = value;</span>
<span class="line-added"> 815                     }</span>
<span class="line-added"> 816                     return oldValue;</span>
<span class="line-added"> 817                 }</span>
<span class="line-added"> 818             } while (t != null);</span>
<span class="line-added"> 819         }</span>
<span class="line-added"> 820         addEntry(key, value, parent, cmp &lt; 0);</span>
 821         return null;
 822     }
 823 
<span class="line-added"> 824     private V remapValue(Entry&lt;K,V&gt; t, K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {</span>
<span class="line-added"> 825         V newValue = callRemappingFunctionWithCheck(key, t.value, remappingFunction);</span>
<span class="line-added"> 826         if (newValue == null) {</span>
<span class="line-added"> 827             deleteEntry(t);</span>
<span class="line-added"> 828             return null;</span>
<span class="line-added"> 829         } else {</span>
<span class="line-added"> 830             // replace old mapping</span>
<span class="line-added"> 831             t.value = newValue;</span>
<span class="line-added"> 832             return newValue;</span>
<span class="line-added"> 833         }</span>
<span class="line-added"> 834     }</span>
<span class="line-added"> 835 </span>
<span class="line-added"> 836     private V mergeValue(Entry&lt;K,V&gt; t, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {</span>
<span class="line-added"> 837         V oldValue = t.value;</span>
<span class="line-added"> 838         V newValue;</span>
<span class="line-added"> 839         if (t.value == null) {</span>
<span class="line-added"> 840             newValue = value;</span>
<span class="line-added"> 841         } else {</span>
<span class="line-added"> 842             int mc = modCount;</span>
<span class="line-added"> 843             newValue = remappingFunction.apply(oldValue, value);</span>
<span class="line-added"> 844             if (mc != modCount) {</span>
<span class="line-added"> 845                 throw new ConcurrentModificationException();</span>
<span class="line-added"> 846             }</span>
<span class="line-added"> 847         }</span>
<span class="line-added"> 848         if (newValue == null) {</span>
<span class="line-added"> 849             deleteEntry(t);</span>
<span class="line-added"> 850             return null;</span>
<span class="line-added"> 851         } else {</span>
<span class="line-added"> 852             // replace old mapping</span>
<span class="line-added"> 853             t.value = newValue;</span>
<span class="line-added"> 854             return newValue;</span>
<span class="line-added"> 855         }</span>
<span class="line-added"> 856     }</span>
<span class="line-added"> 857 </span>
 858     /**
 859      * Removes the mapping for this key from this TreeMap if present.
 860      *
 861      * @param  key key for which mapping should be removed
 862      * @return the previous value associated with {@code key}, or
 863      *         {@code null} if there was no mapping for {@code key}.
 864      *         (A {@code null} return can also indicate that the map
 865      *         previously associated {@code null} with {@code key}.)
 866      * @throws ClassCastException if the specified key cannot be compared
 867      *         with the keys currently in the map
 868      * @throws NullPointerException if the specified key is null
 869      *         and this map uses natural ordering, or its comparator
 870      *         does not permit null keys
 871      */
 872     public V remove(Object key) {
 873         Entry&lt;K,V&gt; p = getEntry(key);
 874         if (p == null)
 875             return null;
 876 
 877         V oldValue = p.value;
</pre>
</td>
</tr>
</table>
<center><a href="StringJoiner.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="regex/CharPredicates.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
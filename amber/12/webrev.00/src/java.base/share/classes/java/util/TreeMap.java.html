<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/java.base/share/classes/java/util/TreeMap.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package java.util;
  27 
  28 import java.io.Serializable;
  29 import java.util.function.BiConsumer;
  30 import java.util.function.BiFunction;
  31 import java.util.function.Consumer;
  32 import java.util.function.Function;
  33 
  34 /**
  35  * A Red-Black tree based {@link NavigableMap} implementation.
  36  * The map is sorted according to the {@linkplain Comparable natural
  37  * ordering} of its keys, or by a {@link Comparator} provided at map
  38  * creation time, depending on which constructor is used.
  39  *
  40  * &lt;p&gt;This implementation provides guaranteed log(n) time cost for the
  41  * {@code containsKey}, {@code get}, {@code put} and {@code remove}
  42  * operations.  Algorithms are adaptations of those in Cormen, Leiserson, and
  43  * Rivest&#39;s &lt;em&gt;Introduction to Algorithms&lt;/em&gt;.
  44  *
  45  * &lt;p&gt;Note that the ordering maintained by a tree map, like any sorted map, and
  46  * whether or not an explicit comparator is provided, must be &lt;em&gt;consistent
  47  * with {@code equals}&lt;/em&gt; if this sorted map is to correctly implement the
  48  * {@code Map} interface.  (See {@code Comparable} or {@code Comparator} for a
  49  * precise definition of &lt;em&gt;consistent with equals&lt;/em&gt;.)  This is so because
  50  * the {@code Map} interface is defined in terms of the {@code equals}
  51  * operation, but a sorted map performs all key comparisons using its {@code
  52  * compareTo} (or {@code compare}) method, so two keys that are deemed equal by
  53  * this method are, from the standpoint of the sorted map, equal.  The behavior
  54  * of a sorted map &lt;em&gt;is&lt;/em&gt; well-defined even if its ordering is
  55  * inconsistent with {@code equals}; it just fails to obey the general contract
  56  * of the {@code Map} interface.
  57  *
  58  * &lt;p&gt;&lt;strong&gt;Note that this implementation is not synchronized.&lt;/strong&gt;
  59  * If multiple threads access a map concurrently, and at least one of the
  60  * threads modifies the map structurally, it &lt;em&gt;must&lt;/em&gt; be synchronized
  61  * externally.  (A structural modification is any operation that adds or
  62  * deletes one or more mappings; merely changing the value associated
  63  * with an existing key is not a structural modification.)  This is
  64  * typically accomplished by synchronizing on some object that naturally
  65  * encapsulates the map.
  66  * If no such object exists, the map should be &quot;wrapped&quot; using the
  67  * {@link Collections#synchronizedSortedMap Collections.synchronizedSortedMap}
  68  * method.  This is best done at creation time, to prevent accidental
  69  * unsynchronized access to the map: &lt;pre&gt;
  70  *   SortedMap m = Collections.synchronizedSortedMap(new TreeMap(...));&lt;/pre&gt;
  71  *
  72  * &lt;p&gt;The iterators returned by the {@code iterator} method of the collections
  73  * returned by all of this class&#39;s &quot;collection view methods&quot; are
  74  * &lt;em&gt;fail-fast&lt;/em&gt;: if the map is structurally modified at any time after
  75  * the iterator is created, in any way except through the iterator&#39;s own
  76  * {@code remove} method, the iterator will throw a {@link
  77  * ConcurrentModificationException}.  Thus, in the face of concurrent
  78  * modification, the iterator fails quickly and cleanly, rather than risking
  79  * arbitrary, non-deterministic behavior at an undetermined time in the future.
  80  *
  81  * &lt;p&gt;Note that the fail-fast behavior of an iterator cannot be guaranteed
  82  * as it is, generally speaking, impossible to make any hard guarantees in the
  83  * presence of unsynchronized concurrent modification.  Fail-fast iterators
  84  * throw {@code ConcurrentModificationException} on a best-effort basis.
  85  * Therefore, it would be wrong to write a program that depended on this
  86  * exception for its correctness:   &lt;em&gt;the fail-fast behavior of iterators
  87  * should be used only to detect bugs.&lt;/em&gt;
  88  *
  89  * &lt;p&gt;All {@code Map.Entry} pairs returned by methods in this class
  90  * and its views represent snapshots of mappings at the time they were
  91  * produced. They do &lt;strong&gt;not&lt;/strong&gt; support the {@code Entry.setValue}
  92  * method. (Note however that it is possible to change mappings in the
  93  * associated map using {@code put}.)
  94  *
  95  * &lt;p&gt;This class is a member of the
  96  * &lt;a href=&quot;{@docRoot}/java.base/java/util/package-summary.html#CollectionsFramework&quot;&gt;
  97  * Java Collections Framework&lt;/a&gt;.
  98  *
  99  * @param &lt;K&gt; the type of keys maintained by this map
 100  * @param &lt;V&gt; the type of mapped values
 101  *
 102  * @author  Josh Bloch and Doug Lea
 103  * @see Map
 104  * @see HashMap
 105  * @see Hashtable
 106  * @see Comparable
 107  * @see Comparator
 108  * @see Collection
 109  * @since 1.2
 110  */
 111 
 112 public class TreeMap&lt;K,V&gt;
 113     extends AbstractMap&lt;K,V&gt;
 114     implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable
 115 {
 116     /**
 117      * The comparator used to maintain order in this tree map, or
 118      * null if it uses the natural ordering of its keys.
 119      *
 120      * @serial
 121      */
 122     @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
 123     private final Comparator&lt;? super K&gt; comparator;
 124 
 125     private transient Entry&lt;K,V&gt; root;
 126 
 127     /**
 128      * The number of entries in the tree
 129      */
 130     private transient int size = 0;
 131 
 132     /**
 133      * The number of structural modifications to the tree.
 134      */
 135     private transient int modCount = 0;
 136 
 137     /**
 138      * Constructs a new, empty tree map, using the natural ordering of its
 139      * keys.  All keys inserted into the map must implement the {@link
 140      * Comparable} interface.  Furthermore, all such keys must be
 141      * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
 142      * a {@code ClassCastException} for any keys {@code k1} and
 143      * {@code k2} in the map.  If the user attempts to put a key into the
 144      * map that violates this constraint (for example, the user attempts to
 145      * put a string key into a map whose keys are integers), the
 146      * {@code put(Object key, Object value)} call will throw a
 147      * {@code ClassCastException}.
 148      */
 149     public TreeMap() {
 150         comparator = null;
 151     }
 152 
 153     /**
 154      * Constructs a new, empty tree map, ordered according to the given
 155      * comparator.  All keys inserted into the map must be &lt;em&gt;mutually
 156      * comparable&lt;/em&gt; by the given comparator: {@code comparator.compare(k1,
 157      * k2)} must not throw a {@code ClassCastException} for any keys
 158      * {@code k1} and {@code k2} in the map.  If the user attempts to put
 159      * a key into the map that violates this constraint, the {@code put(Object
 160      * key, Object value)} call will throw a
 161      * {@code ClassCastException}.
 162      *
 163      * @param comparator the comparator that will be used to order this map.
 164      *        If {@code null}, the {@linkplain Comparable natural
 165      *        ordering} of the keys will be used.
 166      */
 167     public TreeMap(Comparator&lt;? super K&gt; comparator) {
 168         this.comparator = comparator;
 169     }
 170 
 171     /**
 172      * Constructs a new tree map containing the same mappings as the given
 173      * map, ordered according to the &lt;em&gt;natural ordering&lt;/em&gt; of its keys.
 174      * All keys inserted into the new map must implement the {@link
 175      * Comparable} interface.  Furthermore, all such keys must be
 176      * &lt;em&gt;mutually comparable&lt;/em&gt;: {@code k1.compareTo(k2)} must not throw
 177      * a {@code ClassCastException} for any keys {@code k1} and
 178      * {@code k2} in the map.  This method runs in n*log(n) time.
 179      *
 180      * @param  m the map whose mappings are to be placed in this map
 181      * @throws ClassCastException if the keys in m are not {@link Comparable},
 182      *         or are not mutually comparable
 183      * @throws NullPointerException if the specified map is null
 184      */
 185     public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {
 186         comparator = null;
 187         putAll(m);
 188     }
 189 
 190     /**
 191      * Constructs a new tree map containing the same mappings and
 192      * using the same ordering as the specified sorted map.  This
 193      * method runs in linear time.
 194      *
 195      * @param  m the sorted map whose mappings are to be placed in this map,
 196      *         and whose comparator is to be used to sort this map
 197      * @throws NullPointerException if the specified map is null
 198      */
 199     public TreeMap(SortedMap&lt;K, ? extends V&gt; m) {
 200         comparator = m.comparator();
 201         try {
 202             buildFromSorted(m.size(), m.entrySet().iterator(), null, null);
 203         } catch (java.io.IOException | ClassNotFoundException cannotHappen) {
 204         }
 205     }
 206 
 207 
 208     // Query Operations
 209 
 210     /**
 211      * Returns the number of key-value mappings in this map.
 212      *
 213      * @return the number of key-value mappings in this map
 214      */
 215     public int size() {
 216         return size;
 217     }
 218 
 219     /**
 220      * Returns {@code true} if this map contains a mapping for the specified
 221      * key.
 222      *
 223      * @param key key whose presence in this map is to be tested
 224      * @return {@code true} if this map contains a mapping for the
 225      *         specified key
 226      * @throws ClassCastException if the specified key cannot be compared
 227      *         with the keys currently in the map
 228      * @throws NullPointerException if the specified key is null
 229      *         and this map uses natural ordering, or its comparator
 230      *         does not permit null keys
 231      */
 232     public boolean containsKey(Object key) {
 233         return getEntry(key) != null;
 234     }
 235 
 236     /**
 237      * Returns {@code true} if this map maps one or more keys to the
 238      * specified value.  More formally, returns {@code true} if and only if
 239      * this map contains at least one mapping to a value {@code v} such
 240      * that {@code (value==null ? v==null : value.equals(v))}.  This
 241      * operation will probably require time linear in the map size for
 242      * most implementations.
 243      *
 244      * @param value value whose presence in this map is to be tested
 245      * @return {@code true} if a mapping to {@code value} exists;
 246      *         {@code false} otherwise
 247      * @since 1.2
 248      */
 249     public boolean containsValue(Object value) {
 250         for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e))
 251             if (valEquals(value, e.value))
 252                 return true;
 253         return false;
 254     }
 255 
 256     /**
 257      * Returns the value to which the specified key is mapped,
 258      * or {@code null} if this map contains no mapping for the key.
 259      *
 260      * &lt;p&gt;More formally, if this map contains a mapping from a key
 261      * {@code k} to a value {@code v} such that {@code key} compares
 262      * equal to {@code k} according to the map&#39;s ordering, then this
 263      * method returns {@code v}; otherwise it returns {@code null}.
 264      * (There can be at most one such mapping.)
 265      *
 266      * &lt;p&gt;A return value of {@code null} does not &lt;em&gt;necessarily&lt;/em&gt;
 267      * indicate that the map contains no mapping for the key; it&#39;s also
 268      * possible that the map explicitly maps the key to {@code null}.
 269      * The {@link #containsKey containsKey} operation may be used to
 270      * distinguish these two cases.
 271      *
 272      * @throws ClassCastException if the specified key cannot be compared
 273      *         with the keys currently in the map
 274      * @throws NullPointerException if the specified key is null
 275      *         and this map uses natural ordering, or its comparator
 276      *         does not permit null keys
 277      */
 278     public V get(Object key) {
 279         Entry&lt;K,V&gt; p = getEntry(key);
 280         return (p==null ? null : p.value);
 281     }
 282 
 283     public Comparator&lt;? super K&gt; comparator() {
 284         return comparator;
 285     }
 286 
 287     /**
 288      * @throws NoSuchElementException {@inheritDoc}
 289      */
 290     public K firstKey() {
 291         return key(getFirstEntry());
 292     }
 293 
 294     /**
 295      * @throws NoSuchElementException {@inheritDoc}
 296      */
 297     public K lastKey() {
 298         return key(getLastEntry());
 299     }
 300 
 301     /**
 302      * Copies all of the mappings from the specified map to this map.
 303      * These mappings replace any mappings that this map had for any
 304      * of the keys currently in the specified map.
 305      *
 306      * @param  map mappings to be stored in this map
 307      * @throws ClassCastException if the class of a key or value in
 308      *         the specified map prevents it from being stored in this map
 309      * @throws NullPointerException if the specified map is null or
 310      *         the specified map contains a null key and this map does not
 311      *         permit null keys
 312      */
 313     public void putAll(Map&lt;? extends K, ? extends V&gt; map) {
 314         int mapSize = map.size();
 315         if (size==0 &amp;&amp; mapSize!=0 &amp;&amp; map instanceof SortedMap) {
 316             if (Objects.equals(comparator, ((SortedMap&lt;?,?&gt;)map).comparator())) {
 317                 ++modCount;
 318                 try {
 319                     buildFromSorted(mapSize, map.entrySet().iterator(),
 320                                     null, null);
 321                 } catch (java.io.IOException | ClassNotFoundException cannotHappen) {
 322                 }
 323                 return;
 324             }
 325         }
 326         super.putAll(map);
 327     }
 328 
 329     /**
 330      * Returns this map&#39;s entry for the given key, or {@code null} if the map
 331      * does not contain an entry for the key.
 332      *
 333      * @return this map&#39;s entry for the given key, or {@code null} if the map
 334      *         does not contain an entry for the key
 335      * @throws ClassCastException if the specified key cannot be compared
 336      *         with the keys currently in the map
 337      * @throws NullPointerException if the specified key is null
 338      *         and this map uses natural ordering, or its comparator
 339      *         does not permit null keys
 340      */
 341     final Entry&lt;K,V&gt; getEntry(Object key) {
 342         // Offload comparator-based version for sake of performance
 343         if (comparator != null)
 344             return getEntryUsingComparator(key);
 345         Objects.requireNonNull(key);
 346         @SuppressWarnings(&quot;unchecked&quot;)
 347             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 348         Entry&lt;K,V&gt; p = root;
 349         while (p != null) {
 350             int cmp = k.compareTo(p.key);
 351             if (cmp &lt; 0)
 352                 p = p.left;
 353             else if (cmp &gt; 0)
 354                 p = p.right;
 355             else
 356                 return p;
 357         }
 358         return null;
 359     }
 360 
 361     /**
 362      * Version of getEntry using comparator. Split off from getEntry
 363      * for performance. (This is not worth doing for most methods,
 364      * that are less dependent on comparator performance, but is
 365      * worthwhile here.)
 366      */
 367     final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) {
 368         @SuppressWarnings(&quot;unchecked&quot;)
 369             K k = (K) key;
 370         Comparator&lt;? super K&gt; cpr = comparator;
 371         if (cpr != null) {
 372             Entry&lt;K,V&gt; p = root;
 373             while (p != null) {
 374                 int cmp = cpr.compare(k, p.key);
 375                 if (cmp &lt; 0)
 376                     p = p.left;
 377                 else if (cmp &gt; 0)
 378                     p = p.right;
 379                 else
 380                     return p;
 381             }
 382         }
 383         return null;
 384     }
 385 
 386     /**
 387      * Gets the entry corresponding to the specified key; if no such entry
 388      * exists, returns the entry for the least key greater than the specified
 389      * key; if no such entry exists (i.e., the greatest key in the Tree is less
 390      * than the specified key), returns {@code null}.
 391      */
 392     final Entry&lt;K,V&gt; getCeilingEntry(K key) {
 393         Entry&lt;K,V&gt; p = root;
 394         while (p != null) {
 395             int cmp = compare(key, p.key);
 396             if (cmp &lt; 0) {
 397                 if (p.left != null)
 398                     p = p.left;
 399                 else
 400                     return p;
 401             } else if (cmp &gt; 0) {
 402                 if (p.right != null) {
 403                     p = p.right;
 404                 } else {
 405                     Entry&lt;K,V&gt; parent = p.parent;
 406                     Entry&lt;K,V&gt; ch = p;
 407                     while (parent != null &amp;&amp; ch == parent.right) {
 408                         ch = parent;
 409                         parent = parent.parent;
 410                     }
 411                     return parent;
 412                 }
 413             } else
 414                 return p;
 415         }
 416         return null;
 417     }
 418 
 419     /**
 420      * Gets the entry corresponding to the specified key; if no such entry
 421      * exists, returns the entry for the greatest key less than the specified
 422      * key; if no such entry exists, returns {@code null}.
 423      */
 424     final Entry&lt;K,V&gt; getFloorEntry(K key) {
 425         Entry&lt;K,V&gt; p = root;
 426         while (p != null) {
 427             int cmp = compare(key, p.key);
 428             if (cmp &gt; 0) {
 429                 if (p.right != null)
 430                     p = p.right;
 431                 else
 432                     return p;
 433             } else if (cmp &lt; 0) {
 434                 if (p.left != null) {
 435                     p = p.left;
 436                 } else {
 437                     Entry&lt;K,V&gt; parent = p.parent;
 438                     Entry&lt;K,V&gt; ch = p;
 439                     while (parent != null &amp;&amp; ch == parent.left) {
 440                         ch = parent;
 441                         parent = parent.parent;
 442                     }
 443                     return parent;
 444                 }
 445             } else
 446                 return p;
 447 
 448         }
 449         return null;
 450     }
 451 
 452     /**
 453      * Gets the entry for the least key greater than the specified
 454      * key; if no such entry exists, returns the entry for the least
 455      * key greater than the specified key; if no such entry exists
 456      * returns {@code null}.
 457      */
 458     final Entry&lt;K,V&gt; getHigherEntry(K key) {
 459         Entry&lt;K,V&gt; p = root;
 460         while (p != null) {
 461             int cmp = compare(key, p.key);
 462             if (cmp &lt; 0) {
 463                 if (p.left != null)
 464                     p = p.left;
 465                 else
 466                     return p;
 467             } else {
 468                 if (p.right != null) {
 469                     p = p.right;
 470                 } else {
 471                     Entry&lt;K,V&gt; parent = p.parent;
 472                     Entry&lt;K,V&gt; ch = p;
 473                     while (parent != null &amp;&amp; ch == parent.right) {
 474                         ch = parent;
 475                         parent = parent.parent;
 476                     }
 477                     return parent;
 478                 }
 479             }
 480         }
 481         return null;
 482     }
 483 
 484     /**
 485      * Returns the entry for the greatest key less than the specified key; if
 486      * no such entry exists (i.e., the least key in the Tree is greater than
 487      * the specified key), returns {@code null}.
 488      */
 489     final Entry&lt;K,V&gt; getLowerEntry(K key) {
 490         Entry&lt;K,V&gt; p = root;
 491         while (p != null) {
 492             int cmp = compare(key, p.key);
 493             if (cmp &gt; 0) {
 494                 if (p.right != null)
 495                     p = p.right;
 496                 else
 497                     return p;
 498             } else {
 499                 if (p.left != null) {
 500                     p = p.left;
 501                 } else {
 502                     Entry&lt;K,V&gt; parent = p.parent;
 503                     Entry&lt;K,V&gt; ch = p;
 504                     while (parent != null &amp;&amp; ch == parent.left) {
 505                         ch = parent;
 506                         parent = parent.parent;
 507                     }
 508                     return parent;
 509                 }
 510             }
 511         }
 512         return null;
 513     }
 514 
 515     /**
 516      * Associates the specified value with the specified key in this map.
 517      * If the map previously contained a mapping for the key, the old
 518      * value is replaced.
 519      *
 520      * @param key key with which the specified value is to be associated
 521      * @param value value to be associated with the specified key
 522      *
 523      * @return the previous value associated with {@code key}, or
 524      *         {@code null} if there was no mapping for {@code key}.
 525      *         (A {@code null} return can also indicate that the map
 526      *         previously associated {@code null} with {@code key}.)
 527      * @throws ClassCastException if the specified key cannot be compared
 528      *         with the keys currently in the map
 529      * @throws NullPointerException if the specified key is null
 530      *         and this map uses natural ordering, or its comparator
 531      *         does not permit null keys
 532      */
 533     public V put(K key, V value) {
 534         return put(key, value, true);
 535     }
 536 
 537     @Override
 538     public V putIfAbsent(K key, V value) {
 539         return put(key, value, false);
 540     }
 541 
 542     /**
 543      * {@inheritDoc}
 544      *
 545      * &lt;p&gt;This method will, on a best-effort basis, throw a
 546      * {@link ConcurrentModificationException} if it is detected that the
 547      * mapping function modifies this map during computation.
 548      *
 549      * @throws ConcurrentModificationException if it is detected that the
 550      * mapping function modified this map
 551      */
 552     @Override
 553     public V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {
 554         Objects.requireNonNull(mappingFunction);
 555         V newValue;
 556         Entry&lt;K,V&gt; t = root;
 557         if (t == null) {
 558             newValue = callMappingFunctionWithCheck(key, mappingFunction);
 559             if (newValue != null) {
 560                 addEntryToEmptyMap(key, newValue);
 561                 return newValue;
 562             } else {
 563                 return null;
 564             }
 565         }
 566         int cmp;
 567         Entry&lt;K,V&gt; parent;
 568         // split comparator and comparable paths
 569         Comparator&lt;? super K&gt; cpr = comparator;
 570         if (cpr != null) {
 571             do {
 572                 parent = t;
 573                 cmp = cpr.compare(key, t.key);
 574                 if (cmp &lt; 0)
 575                     t = t.left;
 576                 else if (cmp &gt; 0)
 577                     t = t.right;
 578                 else
 579                     return t.value;
 580             } while (t != null);
 581         } else {
 582             Objects.requireNonNull(key);
 583             @SuppressWarnings(&quot;unchecked&quot;)
 584             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 585             do {
 586                 parent = t;
 587                 cmp = k.compareTo(t.key);
 588                 if (cmp &lt; 0)
 589                     t = t.left;
 590                 else if (cmp &gt; 0)
 591                     t = t.right;
 592                 else
 593                     return t.value;
 594             } while (t != null);
 595         }
 596         newValue = callMappingFunctionWithCheck(key, mappingFunction);
 597         if (newValue != null) {
 598             addEntry(key, newValue, parent, cmp &lt; 0);
 599             return newValue;
 600         }
 601         return null;
 602     }
 603 
 604     /**
 605      * {@inheritDoc}
 606      *
 607      * &lt;p&gt;This method will, on a best-effort basis, throw a
 608      * {@link ConcurrentModificationException} if it is detected that the
 609      * remapping function modifies this map during computation.
 610      *
 611      * @throws ConcurrentModificationException if it is detected that the
 612      * remapping function modified this map
 613      */
 614     @Override
 615     public V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
 616         Objects.requireNonNull(remappingFunction);
 617         Entry&lt;K,V&gt; oldEntry = getEntry(key);
 618         if (oldEntry != null &amp;&amp; oldEntry.value != null) {
 619             return remapValue(oldEntry, key, remappingFunction);
 620         } else {
 621             return null;
 622         }
 623     }
 624 
 625     /**
 626      * {@inheritDoc}
 627      *
 628      * &lt;p&gt;This method will, on a best-effort basis, throw a
 629      * {@link ConcurrentModificationException} if it is detected that the
 630      * remapping function modifies this map during computation.
 631      *
 632      * @throws ConcurrentModificationException if it is detected that the
 633      * remapping function modified this map
 634      */
 635     @Override
 636     public V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
 637         Objects.requireNonNull(remappingFunction);
 638         V newValue;
 639         Entry&lt;K,V&gt; t = root;
 640         if (t == null) {
 641             newValue = callRemappingFunctionWithCheck(key, null, remappingFunction);
 642             if (newValue != null) {
 643                 addEntryToEmptyMap(key, newValue);
 644                 return newValue;
 645             } else {
 646                 return null;
 647             }
 648         }
 649         int cmp;
 650         Entry&lt;K,V&gt; parent;
 651         // split comparator and comparable paths
 652         Comparator&lt;? super K&gt; cpr = comparator;
 653         if (cpr != null) {
 654             do {
 655                 parent = t;
 656                 cmp = cpr.compare(key, t.key);
 657                 if (cmp &lt; 0)
 658                     t = t.left;
 659                 else if (cmp &gt; 0)
 660                     t = t.right;
 661                 else
 662                     return remapValue(t, key, remappingFunction);
 663             } while (t != null);
 664         } else {
 665             Objects.requireNonNull(key);
 666             @SuppressWarnings(&quot;unchecked&quot;)
 667             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 668             do {
 669                 parent = t;
 670                 cmp = k.compareTo(t.key);
 671                 if (cmp &lt; 0)
 672                     t = t.left;
 673                 else if (cmp &gt; 0)
 674                     t = t.right;
 675                 else
 676                     return remapValue(t, key, remappingFunction);
 677             } while (t != null);
 678         }
 679         newValue = callRemappingFunctionWithCheck(key, null, remappingFunction);
 680         if (newValue != null) {
 681             addEntry(key, newValue, parent, cmp &lt; 0);
 682             return newValue;
 683         }
 684         return null;
 685     }
 686 
 687     /**
 688      * {@inheritDoc}
 689      *
 690      * &lt;p&gt;This method will, on a best-effort basis, throw a
 691      * {@link ConcurrentModificationException} if it is detected that the
 692      * remapping function modifies this map during computation.
 693      *
 694      * @throws ConcurrentModificationException if it is detected that the
 695      * remapping function modified this map
 696      */
 697     @Override
 698     public V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
 699         Objects.requireNonNull(remappingFunction);
 700         Objects.requireNonNull(value);
 701         Entry&lt;K,V&gt; t = root;
 702         if (t == null) {
 703             addEntryToEmptyMap(key, value);
 704             return value;
 705         }
 706         int cmp;
 707         Entry&lt;K,V&gt; parent;
 708         // split comparator and comparable paths
 709         Comparator&lt;? super K&gt; cpr = comparator;
 710         if (cpr != null) {
 711             do {
 712                 parent = t;
 713                 cmp = cpr.compare(key, t.key);
 714                 if (cmp &lt; 0)
 715                     t = t.left;
 716                 else if (cmp &gt; 0)
 717                     t = t.right;
 718                 else return mergeValue(t, value, remappingFunction);
 719             } while (t != null);
 720         } else {
 721             Objects.requireNonNull(key);
 722             @SuppressWarnings(&quot;unchecked&quot;)
 723             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 724             do {
 725                 parent = t;
 726                 cmp = k.compareTo(t.key);
 727                 if (cmp &lt; 0)
 728                     t = t.left;
 729                 else if (cmp &gt; 0)
 730                     t = t.right;
 731                 else return mergeValue(t, value, remappingFunction);
 732             } while (t != null);
 733         }
 734         addEntry(key, value, parent, cmp &lt; 0);
 735         return value;
 736     }
 737 
 738     private V callMappingFunctionWithCheck(K key, Function&lt;? super K, ? extends V&gt; mappingFunction) {
 739         int mc = modCount;
 740         V newValue = mappingFunction.apply(key);
 741         if (mc != modCount) {
 742             throw new ConcurrentModificationException();
 743         }
 744         return newValue;
 745     }
 746 
 747     private V callRemappingFunctionWithCheck(K key, V oldValue, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
 748         int mc = modCount;
 749         V newValue = remappingFunction.apply(key, oldValue);
 750         if (mc != modCount) {
 751             throw new ConcurrentModificationException();
 752         }
 753         return newValue;
 754     }
 755 
 756     private void addEntry(K key, V value, Entry&lt;K, V&gt; parent, boolean addToLeft) {
 757         Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);
 758         if (addToLeft)
 759             parent.left = e;
 760         else
 761             parent.right = e;
 762         fixAfterInsertion(e);
 763         size++;
 764         modCount++;
 765     }
 766 
 767     private void addEntryToEmptyMap(K key, V value) {
 768         compare(key, key); // type (and possibly null) check
 769         root = new Entry&lt;&gt;(key, value, null);
 770         size = 1;
 771         modCount++;
 772     }
 773 
 774     private V put(K key, V value, boolean replaceOld) {
 775         Entry&lt;K,V&gt; t = root;
 776         if (t == null) {
 777             addEntryToEmptyMap(key, value);
 778             return null;
 779         }
 780         int cmp;
 781         Entry&lt;K,V&gt; parent;
 782         // split comparator and comparable paths
 783         Comparator&lt;? super K&gt; cpr = comparator;
 784         if (cpr != null) {
 785             do {
 786                 parent = t;
 787                 cmp = cpr.compare(key, t.key);
 788                 if (cmp &lt; 0)
 789                     t = t.left;
 790                 else if (cmp &gt; 0)
 791                     t = t.right;
 792                 else {
 793                     V oldValue = t.value;
 794                     if (replaceOld || oldValue == null) {
 795                         t.value = value;
 796                     }
 797                     return oldValue;
 798                 }
 799             } while (t != null);
 800         } else {
 801             Objects.requireNonNull(key);
 802             @SuppressWarnings(&quot;unchecked&quot;)
 803             Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;
 804             do {
 805                 parent = t;
 806                 cmp = k.compareTo(t.key);
 807                 if (cmp &lt; 0)
 808                     t = t.left;
 809                 else if (cmp &gt; 0)
 810                     t = t.right;
 811                 else {
 812                     V oldValue = t.value;
 813                     if (replaceOld || oldValue == null) {
 814                         t.value = value;
 815                     }
 816                     return oldValue;
 817                 }
 818             } while (t != null);
 819         }
 820         addEntry(key, value, parent, cmp &lt; 0);
 821         return null;
 822     }
 823 
 824     private V remapValue(Entry&lt;K,V&gt; t, K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction) {
 825         V newValue = callRemappingFunctionWithCheck(key, t.value, remappingFunction);
 826         if (newValue == null) {
 827             deleteEntry(t);
 828             return null;
 829         } else {
 830             // replace old mapping
 831             t.value = newValue;
 832             return newValue;
 833         }
 834     }
 835 
 836     private V mergeValue(Entry&lt;K,V&gt; t, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction) {
 837         V oldValue = t.value;
 838         V newValue;
 839         if (t.value == null) {
 840             newValue = value;
 841         } else {
 842             int mc = modCount;
 843             newValue = remappingFunction.apply(oldValue, value);
 844             if (mc != modCount) {
 845                 throw new ConcurrentModificationException();
 846             }
 847         }
 848         if (newValue == null) {
 849             deleteEntry(t);
 850             return null;
 851         } else {
 852             // replace old mapping
 853             t.value = newValue;
 854             return newValue;
 855         }
 856     }
 857 
 858     /**
 859      * Removes the mapping for this key from this TreeMap if present.
 860      *
 861      * @param  key key for which mapping should be removed
 862      * @return the previous value associated with {@code key}, or
 863      *         {@code null} if there was no mapping for {@code key}.
 864      *         (A {@code null} return can also indicate that the map
 865      *         previously associated {@code null} with {@code key}.)
 866      * @throws ClassCastException if the specified key cannot be compared
 867      *         with the keys currently in the map
 868      * @throws NullPointerException if the specified key is null
 869      *         and this map uses natural ordering, or its comparator
 870      *         does not permit null keys
 871      */
 872     public V remove(Object key) {
 873         Entry&lt;K,V&gt; p = getEntry(key);
 874         if (p == null)
 875             return null;
 876 
 877         V oldValue = p.value;
 878         deleteEntry(p);
 879         return oldValue;
 880     }
 881 
 882     /**
 883      * Removes all of the mappings from this map.
 884      * The map will be empty after this call returns.
 885      */
 886     public void clear() {
 887         modCount++;
 888         size = 0;
 889         root = null;
 890     }
 891 
 892     /**
 893      * Returns a shallow copy of this {@code TreeMap} instance. (The keys and
 894      * values themselves are not cloned.)
 895      *
 896      * @return a shallow copy of this map
 897      */
 898     public Object clone() {
 899         TreeMap&lt;?,?&gt; clone;
 900         try {
 901             clone = (TreeMap&lt;?,?&gt;) super.clone();
 902         } catch (CloneNotSupportedException e) {
 903             throw new InternalError(e);
 904         }
 905 
 906         // Put clone into &quot;virgin&quot; state (except for comparator)
 907         clone.root = null;
 908         clone.size = 0;
 909         clone.modCount = 0;
 910         clone.entrySet = null;
 911         clone.navigableKeySet = null;
 912         clone.descendingMap = null;
 913 
 914         // Initialize clone with our mappings
 915         try {
 916             clone.buildFromSorted(size, entrySet().iterator(), null, null);
 917         } catch (java.io.IOException | ClassNotFoundException cannotHappen) {
 918         }
 919 
 920         return clone;
 921     }
 922 
 923     // NavigableMap API methods
 924 
 925     /**
 926      * @since 1.6
 927      */
 928     public Map.Entry&lt;K,V&gt; firstEntry() {
 929         return exportEntry(getFirstEntry());
 930     }
 931 
 932     /**
 933      * @since 1.6
 934      */
 935     public Map.Entry&lt;K,V&gt; lastEntry() {
 936         return exportEntry(getLastEntry());
 937     }
 938 
 939     /**
 940      * @since 1.6
 941      */
 942     public Map.Entry&lt;K,V&gt; pollFirstEntry() {
 943         Entry&lt;K,V&gt; p = getFirstEntry();
 944         Map.Entry&lt;K,V&gt; result = exportEntry(p);
 945         if (p != null)
 946             deleteEntry(p);
 947         return result;
 948     }
 949 
 950     /**
 951      * @since 1.6
 952      */
 953     public Map.Entry&lt;K,V&gt; pollLastEntry() {
 954         Entry&lt;K,V&gt; p = getLastEntry();
 955         Map.Entry&lt;K,V&gt; result = exportEntry(p);
 956         if (p != null)
 957             deleteEntry(p);
 958         return result;
 959     }
 960 
 961     /**
 962      * @throws ClassCastException {@inheritDoc}
 963      * @throws NullPointerException if the specified key is null
 964      *         and this map uses natural ordering, or its comparator
 965      *         does not permit null keys
 966      * @since 1.6
 967      */
 968     public Map.Entry&lt;K,V&gt; lowerEntry(K key) {
 969         return exportEntry(getLowerEntry(key));
 970     }
 971 
 972     /**
 973      * @throws ClassCastException {@inheritDoc}
 974      * @throws NullPointerException if the specified key is null
 975      *         and this map uses natural ordering, or its comparator
 976      *         does not permit null keys
 977      * @since 1.6
 978      */
 979     public K lowerKey(K key) {
 980         return keyOrNull(getLowerEntry(key));
 981     }
 982 
 983     /**
 984      * @throws ClassCastException {@inheritDoc}
 985      * @throws NullPointerException if the specified key is null
 986      *         and this map uses natural ordering, or its comparator
 987      *         does not permit null keys
 988      * @since 1.6
 989      */
 990     public Map.Entry&lt;K,V&gt; floorEntry(K key) {
 991         return exportEntry(getFloorEntry(key));
 992     }
 993 
 994     /**
 995      * @throws ClassCastException {@inheritDoc}
 996      * @throws NullPointerException if the specified key is null
 997      *         and this map uses natural ordering, or its comparator
 998      *         does not permit null keys
 999      * @since 1.6
1000      */
1001     public K floorKey(K key) {
1002         return keyOrNull(getFloorEntry(key));
1003     }
1004 
1005     /**
1006      * @throws ClassCastException {@inheritDoc}
1007      * @throws NullPointerException if the specified key is null
1008      *         and this map uses natural ordering, or its comparator
1009      *         does not permit null keys
1010      * @since 1.6
1011      */
1012     public Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
1013         return exportEntry(getCeilingEntry(key));
1014     }
1015 
1016     /**
1017      * @throws ClassCastException {@inheritDoc}
1018      * @throws NullPointerException if the specified key is null
1019      *         and this map uses natural ordering, or its comparator
1020      *         does not permit null keys
1021      * @since 1.6
1022      */
1023     public K ceilingKey(K key) {
1024         return keyOrNull(getCeilingEntry(key));
1025     }
1026 
1027     /**
1028      * @throws ClassCastException {@inheritDoc}
1029      * @throws NullPointerException if the specified key is null
1030      *         and this map uses natural ordering, or its comparator
1031      *         does not permit null keys
1032      * @since 1.6
1033      */
1034     public Map.Entry&lt;K,V&gt; higherEntry(K key) {
1035         return exportEntry(getHigherEntry(key));
1036     }
1037 
1038     /**
1039      * @throws ClassCastException {@inheritDoc}
1040      * @throws NullPointerException if the specified key is null
1041      *         and this map uses natural ordering, or its comparator
1042      *         does not permit null keys
1043      * @since 1.6
1044      */
1045     public K higherKey(K key) {
1046         return keyOrNull(getHigherEntry(key));
1047     }
1048 
1049     // Views
1050 
1051     /**
1052      * Fields initialized to contain an instance of the entry set view
1053      * the first time this view is requested.  Views are stateless, so
1054      * there&#39;s no reason to create more than one.
1055      */
1056     private transient EntrySet entrySet;
1057     private transient KeySet&lt;K&gt; navigableKeySet;
1058     private transient NavigableMap&lt;K,V&gt; descendingMap;
1059 
1060     /**
1061      * Returns a {@link Set} view of the keys contained in this map.
1062      *
1063      * &lt;p&gt;The set&#39;s iterator returns the keys in ascending order.
1064      * The set&#39;s spliterator is
1065      * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
1066      * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#SORTED}
1067      * and {@link Spliterator#ORDERED} with an encounter order that is ascending
1068      * key order.  The spliterator&#39;s comparator (see
1069      * {@link java.util.Spliterator#getComparator()}) is {@code null} if
1070      * the tree map&#39;s comparator (see {@link #comparator()}) is {@code null}.
1071      * Otherwise, the spliterator&#39;s comparator is the same as or imposes the
1072      * same total ordering as the tree map&#39;s comparator.
1073      *
1074      * &lt;p&gt;The set is backed by the map, so changes to the map are
1075      * reflected in the set, and vice-versa.  If the map is modified
1076      * while an iteration over the set is in progress (except through
1077      * the iterator&#39;s own {@code remove} operation), the results of
1078      * the iteration are undefined.  The set supports element removal,
1079      * which removes the corresponding mapping from the map, via the
1080      * {@code Iterator.remove}, {@code Set.remove},
1081      * {@code removeAll}, {@code retainAll}, and {@code clear}
1082      * operations.  It does not support the {@code add} or {@code addAll}
1083      * operations.
1084      */
1085     public Set&lt;K&gt; keySet() {
1086         return navigableKeySet();
1087     }
1088 
1089     /**
1090      * @since 1.6
1091      */
1092     public NavigableSet&lt;K&gt; navigableKeySet() {
1093         KeySet&lt;K&gt; nks = navigableKeySet;
1094         return (nks != null) ? nks : (navigableKeySet = new KeySet&lt;&gt;(this));
1095     }
1096 
1097     /**
1098      * @since 1.6
1099      */
1100     public NavigableSet&lt;K&gt; descendingKeySet() {
1101         return descendingMap().navigableKeySet();
1102     }
1103 
1104     /**
1105      * Returns a {@link Collection} view of the values contained in this map.
1106      *
1107      * &lt;p&gt;The collection&#39;s iterator returns the values in ascending order
1108      * of the corresponding keys. The collection&#39;s spliterator is
1109      * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
1110      * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#ORDERED}
1111      * with an encounter order that is ascending order of the corresponding
1112      * keys.
1113      *
1114      * &lt;p&gt;The collection is backed by the map, so changes to the map are
1115      * reflected in the collection, and vice-versa.  If the map is
1116      * modified while an iteration over the collection is in progress
1117      * (except through the iterator&#39;s own {@code remove} operation),
1118      * the results of the iteration are undefined.  The collection
1119      * supports element removal, which removes the corresponding
1120      * mapping from the map, via the {@code Iterator.remove},
1121      * {@code Collection.remove}, {@code removeAll},
1122      * {@code retainAll} and {@code clear} operations.  It does not
1123      * support the {@code add} or {@code addAll} operations.
1124      */
1125     public Collection&lt;V&gt; values() {
1126         Collection&lt;V&gt; vs = values;
1127         if (vs == null) {
1128             vs = new Values();
1129             values = vs;
1130         }
1131         return vs;
1132     }
1133 
1134     /**
1135      * Returns a {@link Set} view of the mappings contained in this map.
1136      *
1137      * &lt;p&gt;The set&#39;s iterator returns the entries in ascending key order. The
1138      * set&#39;s spliterator is
1139      * &lt;em&gt;&lt;a href=&quot;Spliterator.html#binding&quot;&gt;late-binding&lt;/a&gt;&lt;/em&gt;,
1140      * &lt;em&gt;fail-fast&lt;/em&gt;, and additionally reports {@link Spliterator#SORTED} and
1141      * {@link Spliterator#ORDERED} with an encounter order that is ascending key
1142      * order.
1143      *
1144      * &lt;p&gt;The set is backed by the map, so changes to the map are
1145      * reflected in the set, and vice-versa.  If the map is modified
1146      * while an iteration over the set is in progress (except through
1147      * the iterator&#39;s own {@code remove} operation, or through the
1148      * {@code setValue} operation on a map entry returned by the
1149      * iterator) the results of the iteration are undefined.  The set
1150      * supports element removal, which removes the corresponding
1151      * mapping from the map, via the {@code Iterator.remove},
1152      * {@code Set.remove}, {@code removeAll}, {@code retainAll} and
1153      * {@code clear} operations.  It does not support the
1154      * {@code add} or {@code addAll} operations.
1155      */
1156     public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
1157         EntrySet es = entrySet;
1158         return (es != null) ? es : (entrySet = new EntrySet());
1159     }
1160 
1161     /**
1162      * @since 1.6
1163      */
1164     public NavigableMap&lt;K, V&gt; descendingMap() {
1165         NavigableMap&lt;K, V&gt; km = descendingMap;
1166         return (km != null) ? km :
1167             (descendingMap = new DescendingSubMap&lt;&gt;(this,
1168                                                     true, null, true,
1169                                                     true, null, true));
1170     }
1171 
1172     /**
1173      * @throws ClassCastException       {@inheritDoc}
1174      * @throws NullPointerException if {@code fromKey} or {@code toKey} is
1175      *         null and this map uses natural ordering, or its comparator
1176      *         does not permit null keys
1177      * @throws IllegalArgumentException {@inheritDoc}
1178      * @since 1.6
1179      */
1180     public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
1181                                     K toKey,   boolean toInclusive) {
1182         return new AscendingSubMap&lt;&gt;(this,
1183                                      false, fromKey, fromInclusive,
1184                                      false, toKey,   toInclusive);
1185     }
1186 
1187     /**
1188      * @throws ClassCastException       {@inheritDoc}
1189      * @throws NullPointerException if {@code toKey} is null
1190      *         and this map uses natural ordering, or its comparator
1191      *         does not permit null keys
1192      * @throws IllegalArgumentException {@inheritDoc}
1193      * @since 1.6
1194      */
1195     public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
1196         return new AscendingSubMap&lt;&gt;(this,
1197                                      true,  null,  true,
1198                                      false, toKey, inclusive);
1199     }
1200 
1201     /**
1202      * @throws ClassCastException       {@inheritDoc}
1203      * @throws NullPointerException if {@code fromKey} is null
1204      *         and this map uses natural ordering, or its comparator
1205      *         does not permit null keys
1206      * @throws IllegalArgumentException {@inheritDoc}
1207      * @since 1.6
1208      */
1209     public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
1210         return new AscendingSubMap&lt;&gt;(this,
1211                                      false, fromKey, inclusive,
1212                                      true,  null,    true);
1213     }
1214 
1215     /**
1216      * @throws ClassCastException       {@inheritDoc}
1217      * @throws NullPointerException if {@code fromKey} or {@code toKey} is
1218      *         null and this map uses natural ordering, or its comparator
1219      *         does not permit null keys
1220      * @throws IllegalArgumentException {@inheritDoc}
1221      */
1222     public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
1223         return subMap(fromKey, true, toKey, false);
1224     }
1225 
1226     /**
1227      * @throws ClassCastException       {@inheritDoc}
1228      * @throws NullPointerException if {@code toKey} is null
1229      *         and this map uses natural ordering, or its comparator
1230      *         does not permit null keys
1231      * @throws IllegalArgumentException {@inheritDoc}
1232      */
1233     public SortedMap&lt;K,V&gt; headMap(K toKey) {
1234         return headMap(toKey, false);
1235     }
1236 
1237     /**
1238      * @throws ClassCastException       {@inheritDoc}
1239      * @throws NullPointerException if {@code fromKey} is null
1240      *         and this map uses natural ordering, or its comparator
1241      *         does not permit null keys
1242      * @throws IllegalArgumentException {@inheritDoc}
1243      */
1244     public SortedMap&lt;K,V&gt; tailMap(K fromKey) {
1245         return tailMap(fromKey, true);
1246     }
1247 
1248     @Override
1249     public boolean replace(K key, V oldValue, V newValue) {
1250         Entry&lt;K,V&gt; p = getEntry(key);
1251         if (p!=null &amp;&amp; Objects.equals(oldValue, p.value)) {
1252             p.value = newValue;
1253             return true;
1254         }
1255         return false;
1256     }
1257 
1258     @Override
1259     public V replace(K key, V value) {
1260         Entry&lt;K,V&gt; p = getEntry(key);
1261         if (p!=null) {
1262             V oldValue = p.value;
1263             p.value = value;
1264             return oldValue;
1265         }
1266         return null;
1267     }
1268 
1269     @Override
1270     public void forEach(BiConsumer&lt;? super K, ? super V&gt; action) {
1271         Objects.requireNonNull(action);
1272         int expectedModCount = modCount;
1273         for (Entry&lt;K, V&gt; e = getFirstEntry(); e != null; e = successor(e)) {
1274             action.accept(e.key, e.value);
1275 
1276             if (expectedModCount != modCount) {
1277                 throw new ConcurrentModificationException();
1278             }
1279         }
1280     }
1281 
1282     @Override
1283     public void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function) {
1284         Objects.requireNonNull(function);
1285         int expectedModCount = modCount;
1286 
1287         for (Entry&lt;K, V&gt; e = getFirstEntry(); e != null; e = successor(e)) {
1288             e.value = function.apply(e.key, e.value);
1289 
1290             if (expectedModCount != modCount) {
1291                 throw new ConcurrentModificationException();
1292             }
1293         }
1294     }
1295 
1296     // View class support
1297 
1298     class Values extends AbstractCollection&lt;V&gt; {
1299         public Iterator&lt;V&gt; iterator() {
1300             return new ValueIterator(getFirstEntry());
1301         }
1302 
1303         public int size() {
1304             return TreeMap.this.size();
1305         }
1306 
1307         public boolean contains(Object o) {
1308             return TreeMap.this.containsValue(o);
1309         }
1310 
1311         public boolean remove(Object o) {
1312             for (Entry&lt;K,V&gt; e = getFirstEntry(); e != null; e = successor(e)) {
1313                 if (valEquals(e.getValue(), o)) {
1314                     deleteEntry(e);
1315                     return true;
1316                 }
1317             }
1318             return false;
1319         }
1320 
1321         public void clear() {
1322             TreeMap.this.clear();
1323         }
1324 
1325         public Spliterator&lt;V&gt; spliterator() {
1326             return new ValueSpliterator&lt;&gt;(TreeMap.this, null, null, 0, -1, 0);
1327         }
1328     }
1329 
1330     class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
1331         public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
1332             return new EntryIterator(getFirstEntry());
1333         }
1334 
1335         public boolean contains(Object o) {
1336             if (!(o instanceof Map.Entry))
1337                 return false;
1338             Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;
1339             Object value = entry.getValue();
1340             Entry&lt;K,V&gt; p = getEntry(entry.getKey());
1341             return p != null &amp;&amp; valEquals(p.getValue(), value);
1342         }
1343 
1344         public boolean remove(Object o) {
1345             if (!(o instanceof Map.Entry))
1346                 return false;
1347             Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;
1348             Object value = entry.getValue();
1349             Entry&lt;K,V&gt; p = getEntry(entry.getKey());
1350             if (p != null &amp;&amp; valEquals(p.getValue(), value)) {
1351                 deleteEntry(p);
1352                 return true;
1353             }
1354             return false;
1355         }
1356 
1357         public int size() {
1358             return TreeMap.this.size();
1359         }
1360 
1361         public void clear() {
1362             TreeMap.this.clear();
1363         }
1364 
1365         public Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; spliterator() {
1366             return new EntrySpliterator&lt;&gt;(TreeMap.this, null, null, 0, -1, 0);
1367         }
1368     }
1369 
1370     /*
1371      * Unlike Values and EntrySet, the KeySet class is static,
1372      * delegating to a NavigableMap to allow use by SubMaps, which
1373      * outweighs the ugliness of needing type-tests for the following
1374      * Iterator methods that are defined appropriately in main versus
1375      * submap classes.
1376      */
1377 
1378     Iterator&lt;K&gt; keyIterator() {
1379         return new KeyIterator(getFirstEntry());
1380     }
1381 
1382     Iterator&lt;K&gt; descendingKeyIterator() {
1383         return new DescendingKeyIterator(getLastEntry());
1384     }
1385 
1386     static final class KeySet&lt;E&gt; extends AbstractSet&lt;E&gt; implements NavigableSet&lt;E&gt; {
1387         private final NavigableMap&lt;E, ?&gt; m;
1388         KeySet(NavigableMap&lt;E,?&gt; map) { m = map; }
1389 
1390         public Iterator&lt;E&gt; iterator() {
1391             if (m instanceof TreeMap)
1392                 return ((TreeMap&lt;E,?&gt;)m).keyIterator();
1393             else
1394                 return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).keyIterator();
1395         }
1396 
1397         public Iterator&lt;E&gt; descendingIterator() {
1398             if (m instanceof TreeMap)
1399                 return ((TreeMap&lt;E,?&gt;)m).descendingKeyIterator();
1400             else
1401                 return ((TreeMap.NavigableSubMap&lt;E,?&gt;)m).descendingKeyIterator();
1402         }
1403 
1404         public int size() { return m.size(); }
1405         public boolean isEmpty() { return m.isEmpty(); }
1406         public boolean contains(Object o) { return m.containsKey(o); }
1407         public void clear() { m.clear(); }
1408         public E lower(E e) { return m.lowerKey(e); }
1409         public E floor(E e) { return m.floorKey(e); }
1410         public E ceiling(E e) { return m.ceilingKey(e); }
1411         public E higher(E e) { return m.higherKey(e); }
1412         public E first() { return m.firstKey(); }
1413         public E last() { return m.lastKey(); }
1414         public Comparator&lt;? super E&gt; comparator() { return m.comparator(); }
1415         public E pollFirst() {
1416             Map.Entry&lt;E,?&gt; e = m.pollFirstEntry();
1417             return (e == null) ? null : e.getKey();
1418         }
1419         public E pollLast() {
1420             Map.Entry&lt;E,?&gt; e = m.pollLastEntry();
1421             return (e == null) ? null : e.getKey();
1422         }
1423         public boolean remove(Object o) {
1424             int oldSize = size();
1425             m.remove(o);
1426             return size() != oldSize;
1427         }
1428         public NavigableSet&lt;E&gt; subSet(E fromElement, boolean fromInclusive,
1429                                       E toElement,   boolean toInclusive) {
1430             return new KeySet&lt;&gt;(m.subMap(fromElement, fromInclusive,
1431                                           toElement,   toInclusive));
1432         }
1433         public NavigableSet&lt;E&gt; headSet(E toElement, boolean inclusive) {
1434             return new KeySet&lt;&gt;(m.headMap(toElement, inclusive));
1435         }
1436         public NavigableSet&lt;E&gt; tailSet(E fromElement, boolean inclusive) {
1437             return new KeySet&lt;&gt;(m.tailMap(fromElement, inclusive));
1438         }
1439         public SortedSet&lt;E&gt; subSet(E fromElement, E toElement) {
1440             return subSet(fromElement, true, toElement, false);
1441         }
1442         public SortedSet&lt;E&gt; headSet(E toElement) {
1443             return headSet(toElement, false);
1444         }
1445         public SortedSet&lt;E&gt; tailSet(E fromElement) {
1446             return tailSet(fromElement, true);
1447         }
1448         public NavigableSet&lt;E&gt; descendingSet() {
1449             return new KeySet&lt;&gt;(m.descendingMap());
1450         }
1451 
1452         public Spliterator&lt;E&gt; spliterator() {
1453             return keySpliteratorFor(m);
1454         }
1455     }
1456 
1457     /**
1458      * Base class for TreeMap Iterators
1459      */
1460     abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {
1461         Entry&lt;K,V&gt; next;
1462         Entry&lt;K,V&gt; lastReturned;
1463         int expectedModCount;
1464 
1465         PrivateEntryIterator(Entry&lt;K,V&gt; first) {
1466             expectedModCount = modCount;
1467             lastReturned = null;
1468             next = first;
1469         }
1470 
1471         public final boolean hasNext() {
1472             return next != null;
1473         }
1474 
1475         final Entry&lt;K,V&gt; nextEntry() {
1476             Entry&lt;K,V&gt; e = next;
1477             if (e == null)
1478                 throw new NoSuchElementException();
1479             if (modCount != expectedModCount)
1480                 throw new ConcurrentModificationException();
1481             next = successor(e);
1482             lastReturned = e;
1483             return e;
1484         }
1485 
1486         final Entry&lt;K,V&gt; prevEntry() {
1487             Entry&lt;K,V&gt; e = next;
1488             if (e == null)
1489                 throw new NoSuchElementException();
1490             if (modCount != expectedModCount)
1491                 throw new ConcurrentModificationException();
1492             next = predecessor(e);
1493             lastReturned = e;
1494             return e;
1495         }
1496 
1497         public void remove() {
1498             if (lastReturned == null)
1499                 throw new IllegalStateException();
1500             if (modCount != expectedModCount)
1501                 throw new ConcurrentModificationException();
1502             // deleted entries are replaced by their successors
1503             if (lastReturned.left != null &amp;&amp; lastReturned.right != null)
1504                 next = lastReturned;
1505             deleteEntry(lastReturned);
1506             expectedModCount = modCount;
1507             lastReturned = null;
1508         }
1509     }
1510 
1511     final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
1512         EntryIterator(Entry&lt;K,V&gt; first) {
1513             super(first);
1514         }
1515         public Map.Entry&lt;K,V&gt; next() {
1516             return nextEntry();
1517         }
1518     }
1519 
1520     final class ValueIterator extends PrivateEntryIterator&lt;V&gt; {
1521         ValueIterator(Entry&lt;K,V&gt; first) {
1522             super(first);
1523         }
1524         public V next() {
1525             return nextEntry().value;
1526         }
1527     }
1528 
1529     final class KeyIterator extends PrivateEntryIterator&lt;K&gt; {
1530         KeyIterator(Entry&lt;K,V&gt; first) {
1531             super(first);
1532         }
1533         public K next() {
1534             return nextEntry().key;
1535         }
1536     }
1537 
1538     final class DescendingKeyIterator extends PrivateEntryIterator&lt;K&gt; {
1539         DescendingKeyIterator(Entry&lt;K,V&gt; first) {
1540             super(first);
1541         }
1542         public K next() {
1543             return prevEntry().key;
1544         }
1545         public void remove() {
1546             if (lastReturned == null)
1547                 throw new IllegalStateException();
1548             if (modCount != expectedModCount)
1549                 throw new ConcurrentModificationException();
1550             deleteEntry(lastReturned);
1551             lastReturned = null;
1552             expectedModCount = modCount;
1553         }
1554     }
1555 
1556     // Little utilities
1557 
1558     /**
1559      * Compares two keys using the correct comparison method for this TreeMap.
1560      */
1561     @SuppressWarnings(&quot;unchecked&quot;)
1562     final int compare(Object k1, Object k2) {
1563         return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)
1564             : comparator.compare((K)k1, (K)k2);
1565     }
1566 
1567     /**
1568      * Test two values for equality.  Differs from o1.equals(o2) only in
1569      * that it copes with {@code null} o1 properly.
1570      */
1571     static final boolean valEquals(Object o1, Object o2) {
1572         return (o1==null ? o2==null : o1.equals(o2));
1573     }
1574 
1575     /**
1576      * Return SimpleImmutableEntry for entry, or null if null
1577      */
1578     static &lt;K,V&gt; Map.Entry&lt;K,V&gt; exportEntry(TreeMap.Entry&lt;K,V&gt; e) {
1579         return (e == null) ? null :
1580             new AbstractMap.SimpleImmutableEntry&lt;&gt;(e);
1581     }
1582 
1583     /**
1584      * Return key for entry, or null if null
1585      */
1586     static &lt;K,V&gt; K keyOrNull(TreeMap.Entry&lt;K,V&gt; e) {
1587         return (e == null) ? null : e.key;
1588     }
1589 
1590     /**
1591      * Returns the key corresponding to the specified Entry.
1592      * @throws NoSuchElementException if the Entry is null
1593      */
1594     static &lt;K&gt; K key(Entry&lt;K,?&gt; e) {
1595         if (e==null)
1596             throw new NoSuchElementException();
1597         return e.key;
1598     }
1599 
1600 
1601     // SubMaps
1602 
1603     /**
1604      * Dummy value serving as unmatchable fence key for unbounded
1605      * SubMapIterators
1606      */
1607     private static final Object UNBOUNDED = new Object();
1608 
1609     /**
1610      * @serial include
1611      */
1612     abstract static class NavigableSubMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;
1613         implements NavigableMap&lt;K,V&gt;, java.io.Serializable {
1614         @java.io.Serial
1615         private static final long serialVersionUID = -2102997345730753016L;
1616         /**
1617          * The backing map.
1618          */
1619         final TreeMap&lt;K,V&gt; m;
1620 
1621         /**
1622          * Endpoints are represented as triples (fromStart, lo,
1623          * loInclusive) and (toEnd, hi, hiInclusive). If fromStart is
1624          * true, then the low (absolute) bound is the start of the
1625          * backing map, and the other values are ignored. Otherwise,
1626          * if loInclusive is true, lo is the inclusive bound, else lo
1627          * is the exclusive bound. Similarly for the upper bound.
1628          */
1629         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
1630         final K lo;
1631         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
1632         final K hi;
1633         final boolean fromStart, toEnd;
1634         final boolean loInclusive, hiInclusive;
1635 
1636         NavigableSubMap(TreeMap&lt;K,V&gt; m,
1637                         boolean fromStart, K lo, boolean loInclusive,
1638                         boolean toEnd,     K hi, boolean hiInclusive) {
1639             if (!fromStart &amp;&amp; !toEnd) {
1640                 if (m.compare(lo, hi) &gt; 0)
1641                     throw new IllegalArgumentException(&quot;fromKey &gt; toKey&quot;);
1642             } else {
1643                 if (!fromStart) // type check
1644                     m.compare(lo, lo);
1645                 if (!toEnd)
1646                     m.compare(hi, hi);
1647             }
1648 
1649             this.m = m;
1650             this.fromStart = fromStart;
1651             this.lo = lo;
1652             this.loInclusive = loInclusive;
1653             this.toEnd = toEnd;
1654             this.hi = hi;
1655             this.hiInclusive = hiInclusive;
1656         }
1657 
1658         // internal utilities
1659 
1660         final boolean tooLow(Object key) {
1661             if (!fromStart) {
1662                 int c = m.compare(key, lo);
1663                 if (c &lt; 0 || (c == 0 &amp;&amp; !loInclusive))
1664                     return true;
1665             }
1666             return false;
1667         }
1668 
1669         final boolean tooHigh(Object key) {
1670             if (!toEnd) {
1671                 int c = m.compare(key, hi);
1672                 if (c &gt; 0 || (c == 0 &amp;&amp; !hiInclusive))
1673                     return true;
1674             }
1675             return false;
1676         }
1677 
1678         final boolean inRange(Object key) {
1679             return !tooLow(key) &amp;&amp; !tooHigh(key);
1680         }
1681 
1682         final boolean inClosedRange(Object key) {
1683             return (fromStart || m.compare(key, lo) &gt;= 0)
1684                 &amp;&amp; (toEnd || m.compare(hi, key) &gt;= 0);
1685         }
1686 
1687         final boolean inRange(Object key, boolean inclusive) {
1688             return inclusive ? inRange(key) : inClosedRange(key);
1689         }
1690 
1691         /*
1692          * Absolute versions of relation operations.
1693          * Subclasses map to these using like-named &quot;sub&quot;
1694          * versions that invert senses for descending maps
1695          */
1696 
1697         final TreeMap.Entry&lt;K,V&gt; absLowest() {
1698             TreeMap.Entry&lt;K,V&gt; e =
1699                 (fromStart ?  m.getFirstEntry() :
1700                  (loInclusive ? m.getCeilingEntry(lo) :
1701                                 m.getHigherEntry(lo)));
1702             return (e == null || tooHigh(e.key)) ? null : e;
1703         }
1704 
1705         final TreeMap.Entry&lt;K,V&gt; absHighest() {
1706             TreeMap.Entry&lt;K,V&gt; e =
1707                 (toEnd ?  m.getLastEntry() :
1708                  (hiInclusive ?  m.getFloorEntry(hi) :
1709                                  m.getLowerEntry(hi)));
1710             return (e == null || tooLow(e.key)) ? null : e;
1711         }
1712 
1713         final TreeMap.Entry&lt;K,V&gt; absCeiling(K key) {
1714             if (tooLow(key))
1715                 return absLowest();
1716             TreeMap.Entry&lt;K,V&gt; e = m.getCeilingEntry(key);
1717             return (e == null || tooHigh(e.key)) ? null : e;
1718         }
1719 
1720         final TreeMap.Entry&lt;K,V&gt; absHigher(K key) {
1721             if (tooLow(key))
1722                 return absLowest();
1723             TreeMap.Entry&lt;K,V&gt; e = m.getHigherEntry(key);
1724             return (e == null || tooHigh(e.key)) ? null : e;
1725         }
1726 
1727         final TreeMap.Entry&lt;K,V&gt; absFloor(K key) {
1728             if (tooHigh(key))
1729                 return absHighest();
1730             TreeMap.Entry&lt;K,V&gt; e = m.getFloorEntry(key);
1731             return (e == null || tooLow(e.key)) ? null : e;
1732         }
1733 
1734         final TreeMap.Entry&lt;K,V&gt; absLower(K key) {
1735             if (tooHigh(key))
1736                 return absHighest();
1737             TreeMap.Entry&lt;K,V&gt; e = m.getLowerEntry(key);
1738             return (e == null || tooLow(e.key)) ? null : e;
1739         }
1740 
1741         /** Returns the absolute high fence for ascending traversal */
1742         final TreeMap.Entry&lt;K,V&gt; absHighFence() {
1743             return (toEnd ? null : (hiInclusive ?
1744                                     m.getHigherEntry(hi) :
1745                                     m.getCeilingEntry(hi)));
1746         }
1747 
1748         /** Return the absolute low fence for descending traversal  */
1749         final TreeMap.Entry&lt;K,V&gt; absLowFence() {
1750             return (fromStart ? null : (loInclusive ?
1751                                         m.getLowerEntry(lo) :
1752                                         m.getFloorEntry(lo)));
1753         }
1754 
1755         // Abstract methods defined in ascending vs descending classes
1756         // These relay to the appropriate absolute versions
1757 
1758         abstract TreeMap.Entry&lt;K,V&gt; subLowest();
1759         abstract TreeMap.Entry&lt;K,V&gt; subHighest();
1760         abstract TreeMap.Entry&lt;K,V&gt; subCeiling(K key);
1761         abstract TreeMap.Entry&lt;K,V&gt; subHigher(K key);
1762         abstract TreeMap.Entry&lt;K,V&gt; subFloor(K key);
1763         abstract TreeMap.Entry&lt;K,V&gt; subLower(K key);
1764 
1765         /** Returns ascending iterator from the perspective of this submap */
1766         abstract Iterator&lt;K&gt; keyIterator();
1767 
1768         abstract Spliterator&lt;K&gt; keySpliterator();
1769 
1770         /** Returns descending iterator from the perspective of this submap */
1771         abstract Iterator&lt;K&gt; descendingKeyIterator();
1772 
1773         // public methods
1774 
1775         public boolean isEmpty() {
1776             return (fromStart &amp;&amp; toEnd) ? m.isEmpty() : entrySet().isEmpty();
1777         }
1778 
1779         public int size() {
1780             return (fromStart &amp;&amp; toEnd) ? m.size() : entrySet().size();
1781         }
1782 
1783         public final boolean containsKey(Object key) {
1784             return inRange(key) &amp;&amp; m.containsKey(key);
1785         }
1786 
1787         public final V put(K key, V value) {
1788             if (!inRange(key))
1789                 throw new IllegalArgumentException(&quot;key out of range&quot;);
1790             return m.put(key, value);
1791         }
1792 
1793         public final V get(Object key) {
1794             return !inRange(key) ? null :  m.get(key);
1795         }
1796 
1797         public final V remove(Object key) {
1798             return !inRange(key) ? null : m.remove(key);
1799         }
1800 
1801         public final Map.Entry&lt;K,V&gt; ceilingEntry(K key) {
1802             return exportEntry(subCeiling(key));
1803         }
1804 
1805         public final K ceilingKey(K key) {
1806             return keyOrNull(subCeiling(key));
1807         }
1808 
1809         public final Map.Entry&lt;K,V&gt; higherEntry(K key) {
1810             return exportEntry(subHigher(key));
1811         }
1812 
1813         public final K higherKey(K key) {
1814             return keyOrNull(subHigher(key));
1815         }
1816 
1817         public final Map.Entry&lt;K,V&gt; floorEntry(K key) {
1818             return exportEntry(subFloor(key));
1819         }
1820 
1821         public final K floorKey(K key) {
1822             return keyOrNull(subFloor(key));
1823         }
1824 
1825         public final Map.Entry&lt;K,V&gt; lowerEntry(K key) {
1826             return exportEntry(subLower(key));
1827         }
1828 
1829         public final K lowerKey(K key) {
1830             return keyOrNull(subLower(key));
1831         }
1832 
1833         public final K firstKey() {
1834             return key(subLowest());
1835         }
1836 
1837         public final K lastKey() {
1838             return key(subHighest());
1839         }
1840 
1841         public final Map.Entry&lt;K,V&gt; firstEntry() {
1842             return exportEntry(subLowest());
1843         }
1844 
1845         public final Map.Entry&lt;K,V&gt; lastEntry() {
1846             return exportEntry(subHighest());
1847         }
1848 
1849         public final Map.Entry&lt;K,V&gt; pollFirstEntry() {
1850             TreeMap.Entry&lt;K,V&gt; e = subLowest();
1851             Map.Entry&lt;K,V&gt; result = exportEntry(e);
1852             if (e != null)
1853                 m.deleteEntry(e);
1854             return result;
1855         }
1856 
1857         public final Map.Entry&lt;K,V&gt; pollLastEntry() {
1858             TreeMap.Entry&lt;K,V&gt; e = subHighest();
1859             Map.Entry&lt;K,V&gt; result = exportEntry(e);
1860             if (e != null)
1861                 m.deleteEntry(e);
1862             return result;
1863         }
1864 
1865         // Views
1866         transient NavigableMap&lt;K,V&gt; descendingMapView;
1867         transient EntrySetView entrySetView;
1868         transient KeySet&lt;K&gt; navigableKeySetView;
1869 
1870         public final NavigableSet&lt;K&gt; navigableKeySet() {
1871             KeySet&lt;K&gt; nksv = navigableKeySetView;
1872             return (nksv != null) ? nksv :
1873                 (navigableKeySetView = new TreeMap.KeySet&lt;&gt;(this));
1874         }
1875 
1876         public final Set&lt;K&gt; keySet() {
1877             return navigableKeySet();
1878         }
1879 
1880         public NavigableSet&lt;K&gt; descendingKeySet() {
1881             return descendingMap().navigableKeySet();
1882         }
1883 
1884         public final SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) {
1885             return subMap(fromKey, true, toKey, false);
1886         }
1887 
1888         public final SortedMap&lt;K,V&gt; headMap(K toKey) {
1889             return headMap(toKey, false);
1890         }
1891 
1892         public final SortedMap&lt;K,V&gt; tailMap(K fromKey) {
1893             return tailMap(fromKey, true);
1894         }
1895 
1896         // View classes
1897 
1898         abstract class EntrySetView extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {
1899             private transient int size = -1, sizeModCount;
1900 
1901             public int size() {
1902                 if (fromStart &amp;&amp; toEnd)
1903                     return m.size();
1904                 if (size == -1 || sizeModCount != m.modCount) {
1905                     sizeModCount = m.modCount;
1906                     size = 0;
1907                     Iterator&lt;?&gt; i = iterator();
1908                     while (i.hasNext()) {
1909                         size++;
1910                         i.next();
1911                     }
1912                 }
1913                 return size;
1914             }
1915 
1916             public boolean isEmpty() {
1917                 TreeMap.Entry&lt;K,V&gt; n = absLowest();
1918                 return n == null || tooHigh(n.key);
1919             }
1920 
1921             public boolean contains(Object o) {
1922                 if (!(o instanceof Map.Entry))
1923                     return false;
1924                 Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;
1925                 Object key = entry.getKey();
1926                 if (!inRange(key))
1927                     return false;
1928                 TreeMap.Entry&lt;?,?&gt; node = m.getEntry(key);
1929                 return node != null &amp;&amp;
1930                     valEquals(node.getValue(), entry.getValue());
1931             }
1932 
1933             public boolean remove(Object o) {
1934                 if (!(o instanceof Map.Entry))
1935                     return false;
1936                 Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;) o;
1937                 Object key = entry.getKey();
1938                 if (!inRange(key))
1939                     return false;
1940                 TreeMap.Entry&lt;K,V&gt; node = m.getEntry(key);
1941                 if (node!=null &amp;&amp; valEquals(node.getValue(),
1942                                             entry.getValue())) {
1943                     m.deleteEntry(node);
1944                     return true;
1945                 }
1946                 return false;
1947             }
1948         }
1949 
1950         /**
1951          * Iterators for SubMaps
1952          */
1953         abstract class SubMapIterator&lt;T&gt; implements Iterator&lt;T&gt; {
1954             TreeMap.Entry&lt;K,V&gt; lastReturned;
1955             TreeMap.Entry&lt;K,V&gt; next;
1956             final Object fenceKey;
1957             int expectedModCount;
1958 
1959             SubMapIterator(TreeMap.Entry&lt;K,V&gt; first,
1960                            TreeMap.Entry&lt;K,V&gt; fence) {
1961                 expectedModCount = m.modCount;
1962                 lastReturned = null;
1963                 next = first;
1964                 fenceKey = fence == null ? UNBOUNDED : fence.key;
1965             }
1966 
1967             public final boolean hasNext() {
1968                 return next != null &amp;&amp; next.key != fenceKey;
1969             }
1970 
1971             final TreeMap.Entry&lt;K,V&gt; nextEntry() {
1972                 TreeMap.Entry&lt;K,V&gt; e = next;
1973                 if (e == null || e.key == fenceKey)
1974                     throw new NoSuchElementException();
1975                 if (m.modCount != expectedModCount)
1976                     throw new ConcurrentModificationException();
1977                 next = successor(e);
1978                 lastReturned = e;
1979                 return e;
1980             }
1981 
1982             final TreeMap.Entry&lt;K,V&gt; prevEntry() {
1983                 TreeMap.Entry&lt;K,V&gt; e = next;
1984                 if (e == null || e.key == fenceKey)
1985                     throw new NoSuchElementException();
1986                 if (m.modCount != expectedModCount)
1987                     throw new ConcurrentModificationException();
1988                 next = predecessor(e);
1989                 lastReturned = e;
1990                 return e;
1991             }
1992 
1993             final void removeAscending() {
1994                 if (lastReturned == null)
1995                     throw new IllegalStateException();
1996                 if (m.modCount != expectedModCount)
1997                     throw new ConcurrentModificationException();
1998                 // deleted entries are replaced by their successors
1999                 if (lastReturned.left != null &amp;&amp; lastReturned.right != null)
2000                     next = lastReturned;
2001                 m.deleteEntry(lastReturned);
2002                 lastReturned = null;
2003                 expectedModCount = m.modCount;
2004             }
2005 
2006             final void removeDescending() {
2007                 if (lastReturned == null)
2008                     throw new IllegalStateException();
2009                 if (m.modCount != expectedModCount)
2010                     throw new ConcurrentModificationException();
2011                 m.deleteEntry(lastReturned);
2012                 lastReturned = null;
2013                 expectedModCount = m.modCount;
2014             }
2015 
2016         }
2017 
2018         final class SubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
2019             SubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; first,
2020                                 TreeMap.Entry&lt;K,V&gt; fence) {
2021                 super(first, fence);
2022             }
2023             public Map.Entry&lt;K,V&gt; next() {
2024                 return nextEntry();
2025             }
2026             public void remove() {
2027                 removeAscending();
2028             }
2029         }
2030 
2031         final class DescendingSubMapEntryIterator extends SubMapIterator&lt;Map.Entry&lt;K,V&gt;&gt; {
2032             DescendingSubMapEntryIterator(TreeMap.Entry&lt;K,V&gt; last,
2033                                           TreeMap.Entry&lt;K,V&gt; fence) {
2034                 super(last, fence);
2035             }
2036 
2037             public Map.Entry&lt;K,V&gt; next() {
2038                 return prevEntry();
2039             }
2040             public void remove() {
2041                 removeDescending();
2042             }
2043         }
2044 
2045         // Implement minimal Spliterator as KeySpliterator backup
2046         final class SubMapKeyIterator extends SubMapIterator&lt;K&gt;
2047             implements Spliterator&lt;K&gt; {
2048             SubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; first,
2049                               TreeMap.Entry&lt;K,V&gt; fence) {
2050                 super(first, fence);
2051             }
2052             public K next() {
2053                 return nextEntry().key;
2054             }
2055             public void remove() {
2056                 removeAscending();
2057             }
2058             public Spliterator&lt;K&gt; trySplit() {
2059                 return null;
2060             }
2061             public void forEachRemaining(Consumer&lt;? super K&gt; action) {
2062                 while (hasNext())
2063                     action.accept(next());
2064             }
2065             public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
2066                 if (hasNext()) {
2067                     action.accept(next());
2068                     return true;
2069                 }
2070                 return false;
2071             }
2072             public long estimateSize() {
2073                 return Long.MAX_VALUE;
2074             }
2075             public int characteristics() {
2076                 return Spliterator.DISTINCT | Spliterator.ORDERED |
2077                     Spliterator.SORTED;
2078             }
2079             public final Comparator&lt;? super K&gt;  getComparator() {
2080                 return NavigableSubMap.this.comparator();
2081             }
2082         }
2083 
2084         final class DescendingSubMapKeyIterator extends SubMapIterator&lt;K&gt;
2085             implements Spliterator&lt;K&gt; {
2086             DescendingSubMapKeyIterator(TreeMap.Entry&lt;K,V&gt; last,
2087                                         TreeMap.Entry&lt;K,V&gt; fence) {
2088                 super(last, fence);
2089             }
2090             public K next() {
2091                 return prevEntry().key;
2092             }
2093             public void remove() {
2094                 removeDescending();
2095             }
2096             public Spliterator&lt;K&gt; trySplit() {
2097                 return null;
2098             }
2099             public void forEachRemaining(Consumer&lt;? super K&gt; action) {
2100                 while (hasNext())
2101                     action.accept(next());
2102             }
2103             public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
2104                 if (hasNext()) {
2105                     action.accept(next());
2106                     return true;
2107                 }
2108                 return false;
2109             }
2110             public long estimateSize() {
2111                 return Long.MAX_VALUE;
2112             }
2113             public int characteristics() {
2114                 return Spliterator.DISTINCT | Spliterator.ORDERED;
2115             }
2116         }
2117     }
2118 
2119     /**
2120      * @serial include
2121      */
2122     static final class AscendingSubMap&lt;K,V&gt; extends NavigableSubMap&lt;K,V&gt; {
2123         @java.io.Serial
2124         private static final long serialVersionUID = 912986545866124060L;
2125 
2126         AscendingSubMap(TreeMap&lt;K,V&gt; m,
2127                         boolean fromStart, K lo, boolean loInclusive,
2128                         boolean toEnd,     K hi, boolean hiInclusive) {
2129             super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
2130         }
2131 
2132         public Comparator&lt;? super K&gt; comparator() {
2133             return m.comparator();
2134         }
2135 
2136         public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
2137                                         K toKey,   boolean toInclusive) {
2138             if (!inRange(fromKey, fromInclusive))
2139                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
2140             if (!inRange(toKey, toInclusive))
2141                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
2142             return new AscendingSubMap&lt;&gt;(m,
2143                                          false, fromKey, fromInclusive,
2144                                          false, toKey,   toInclusive);
2145         }
2146 
2147         public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
2148             if (!inRange(toKey, inclusive))
2149                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
2150             return new AscendingSubMap&lt;&gt;(m,
2151                                          fromStart, lo,    loInclusive,
2152                                          false,     toKey, inclusive);
2153         }
2154 
2155         public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
2156             if (!inRange(fromKey, inclusive))
2157                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
2158             return new AscendingSubMap&lt;&gt;(m,
2159                                          false, fromKey, inclusive,
2160                                          toEnd, hi,      hiInclusive);
2161         }
2162 
2163         public NavigableMap&lt;K,V&gt; descendingMap() {
2164             NavigableMap&lt;K,V&gt; mv = descendingMapView;
2165             return (mv != null) ? mv :
2166                 (descendingMapView =
2167                  new DescendingSubMap&lt;&gt;(m,
2168                                         fromStart, lo, loInclusive,
2169                                         toEnd,     hi, hiInclusive));
2170         }
2171 
2172         Iterator&lt;K&gt; keyIterator() {
2173             return new SubMapKeyIterator(absLowest(), absHighFence());
2174         }
2175 
2176         Spliterator&lt;K&gt; keySpliterator() {
2177             return new SubMapKeyIterator(absLowest(), absHighFence());
2178         }
2179 
2180         Iterator&lt;K&gt; descendingKeyIterator() {
2181             return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
2182         }
2183 
2184         final class AscendingEntrySetView extends EntrySetView {
2185             public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2186                 return new SubMapEntryIterator(absLowest(), absHighFence());
2187             }
2188         }
2189 
2190         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2191             EntrySetView es = entrySetView;
2192             return (es != null) ? es : (entrySetView = new AscendingEntrySetView());
2193         }
2194 
2195         TreeMap.Entry&lt;K,V&gt; subLowest()       { return absLowest(); }
2196         TreeMap.Entry&lt;K,V&gt; subHighest()      { return absHighest(); }
2197         TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absCeiling(key); }
2198         TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absHigher(key); }
2199         TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absFloor(key); }
2200         TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absLower(key); }
2201     }
2202 
2203     /**
2204      * @serial include
2205      */
2206     static final class DescendingSubMap&lt;K,V&gt;  extends NavigableSubMap&lt;K,V&gt; {
2207         @java.io.Serial
2208         private static final long serialVersionUID = 912986545866120460L;
2209         DescendingSubMap(TreeMap&lt;K,V&gt; m,
2210                         boolean fromStart, K lo, boolean loInclusive,
2211                         boolean toEnd,     K hi, boolean hiInclusive) {
2212             super(m, fromStart, lo, loInclusive, toEnd, hi, hiInclusive);
2213         }
2214 
2215         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
2216         private final Comparator&lt;? super K&gt; reverseComparator =
2217             Collections.reverseOrder(m.comparator);
2218 
2219         public Comparator&lt;? super K&gt; comparator() {
2220             return reverseComparator;
2221         }
2222 
2223         public NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive,
2224                                         K toKey,   boolean toInclusive) {
2225             if (!inRange(fromKey, fromInclusive))
2226                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
2227             if (!inRange(toKey, toInclusive))
2228                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
2229             return new DescendingSubMap&lt;&gt;(m,
2230                                           false, toKey,   toInclusive,
2231                                           false, fromKey, fromInclusive);
2232         }
2233 
2234         public NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive) {
2235             if (!inRange(toKey, inclusive))
2236                 throw new IllegalArgumentException(&quot;toKey out of range&quot;);
2237             return new DescendingSubMap&lt;&gt;(m,
2238                                           false, toKey, inclusive,
2239                                           toEnd, hi,    hiInclusive);
2240         }
2241 
2242         public NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive) {
2243             if (!inRange(fromKey, inclusive))
2244                 throw new IllegalArgumentException(&quot;fromKey out of range&quot;);
2245             return new DescendingSubMap&lt;&gt;(m,
2246                                           fromStart, lo, loInclusive,
2247                                           false, fromKey, inclusive);
2248         }
2249 
2250         public NavigableMap&lt;K,V&gt; descendingMap() {
2251             NavigableMap&lt;K,V&gt; mv = descendingMapView;
2252             return (mv != null) ? mv :
2253                 (descendingMapView =
2254                  new AscendingSubMap&lt;&gt;(m,
2255                                        fromStart, lo, loInclusive,
2256                                        toEnd,     hi, hiInclusive));
2257         }
2258 
2259         Iterator&lt;K&gt; keyIterator() {
2260             return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
2261         }
2262 
2263         Spliterator&lt;K&gt; keySpliterator() {
2264             return new DescendingSubMapKeyIterator(absHighest(), absLowFence());
2265         }
2266 
2267         Iterator&lt;K&gt; descendingKeyIterator() {
2268             return new SubMapKeyIterator(absLowest(), absHighFence());
2269         }
2270 
2271         final class DescendingEntrySetView extends EntrySetView {
2272             public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {
2273                 return new DescendingSubMapEntryIterator(absHighest(), absLowFence());
2274             }
2275         }
2276 
2277         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {
2278             EntrySetView es = entrySetView;
2279             return (es != null) ? es : (entrySetView = new DescendingEntrySetView());
2280         }
2281 
2282         TreeMap.Entry&lt;K,V&gt; subLowest()       { return absHighest(); }
2283         TreeMap.Entry&lt;K,V&gt; subHighest()      { return absLowest(); }
2284         TreeMap.Entry&lt;K,V&gt; subCeiling(K key) { return absFloor(key); }
2285         TreeMap.Entry&lt;K,V&gt; subHigher(K key)  { return absLower(key); }
2286         TreeMap.Entry&lt;K,V&gt; subFloor(K key)   { return absCeiling(key); }
2287         TreeMap.Entry&lt;K,V&gt; subLower(K key)   { return absHigher(key); }
2288     }
2289 
2290     /**
2291      * This class exists solely for the sake of serialization
2292      * compatibility with previous releases of TreeMap that did not
2293      * support NavigableMap.  It translates an old-version SubMap into
2294      * a new-version AscendingSubMap. This class is never otherwise
2295      * used.
2296      *
2297      * @serial include
2298      */
2299     private class SubMap extends AbstractMap&lt;K,V&gt;
2300         implements SortedMap&lt;K,V&gt;, java.io.Serializable {
2301         @java.io.Serial
2302         private static final long serialVersionUID = -6520786458950516097L;
2303         private boolean fromStart = false, toEnd = false;
2304         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
2305         private K fromKey;
2306         @SuppressWarnings(&quot;serial&quot;) // Conditionally serializable
2307         private K toKey;
2308         @java.io.Serial
2309         private Object readResolve() {
2310             return new AscendingSubMap&lt;&gt;(TreeMap.this,
2311                                          fromStart, fromKey, true,
2312                                          toEnd, toKey, false);
2313         }
2314         public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() { throw new InternalError(); }
2315         public K lastKey() { throw new InternalError(); }
2316         public K firstKey() { throw new InternalError(); }
2317         public SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey) { throw new InternalError(); }
2318         public SortedMap&lt;K,V&gt; headMap(K toKey) { throw new InternalError(); }
2319         public SortedMap&lt;K,V&gt; tailMap(K fromKey) { throw new InternalError(); }
2320         public Comparator&lt;? super K&gt; comparator() { throw new InternalError(); }
2321     }
2322 
2323 
2324     // Red-black mechanics
2325 
2326     private static final boolean RED   = false;
2327     private static final boolean BLACK = true;
2328 
2329     /**
2330      * Node in the Tree.  Doubles as a means to pass key-value pairs back to
2331      * user (see Map.Entry).
2332      */
2333 
2334     static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {
2335         K key;
2336         V value;
2337         Entry&lt;K,V&gt; left;
2338         Entry&lt;K,V&gt; right;
2339         Entry&lt;K,V&gt; parent;
2340         boolean color = BLACK;
2341 
2342         /**
2343          * Make a new cell with given key, value, and parent, and with
2344          * {@code null} child links, and BLACK color.
2345          */
2346         Entry(K key, V value, Entry&lt;K,V&gt; parent) {
2347             this.key = key;
2348             this.value = value;
2349             this.parent = parent;
2350         }
2351 
2352         /**
2353          * Returns the key.
2354          *
2355          * @return the key
2356          */
2357         public K getKey() {
2358             return key;
2359         }
2360 
2361         /**
2362          * Returns the value associated with the key.
2363          *
2364          * @return the value associated with the key
2365          */
2366         public V getValue() {
2367             return value;
2368         }
2369 
2370         /**
2371          * Replaces the value currently associated with the key with the given
2372          * value.
2373          *
2374          * @return the value associated with the key before this method was
2375          *         called
2376          */
2377         public V setValue(V value) {
2378             V oldValue = this.value;
2379             this.value = value;
2380             return oldValue;
2381         }
2382 
2383         public boolean equals(Object o) {
2384             if (!(o instanceof Map.Entry))
2385                 return false;
2386             Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
2387 
2388             return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());
2389         }
2390 
2391         public int hashCode() {
2392             int keyHash = (key==null ? 0 : key.hashCode());
2393             int valueHash = (value==null ? 0 : value.hashCode());
2394             return keyHash ^ valueHash;
2395         }
2396 
2397         public String toString() {
2398             return key + &quot;=&quot; + value;
2399         }
2400     }
2401 
2402     /**
2403      * Returns the first Entry in the TreeMap (according to the TreeMap&#39;s
2404      * key-sort function).  Returns null if the TreeMap is empty.
2405      */
2406     final Entry&lt;K,V&gt; getFirstEntry() {
2407         Entry&lt;K,V&gt; p = root;
2408         if (p != null)
2409             while (p.left != null)
2410                 p = p.left;
2411         return p;
2412     }
2413 
2414     /**
2415      * Returns the last Entry in the TreeMap (according to the TreeMap&#39;s
2416      * key-sort function).  Returns null if the TreeMap is empty.
2417      */
2418     final Entry&lt;K,V&gt; getLastEntry() {
2419         Entry&lt;K,V&gt; p = root;
2420         if (p != null)
2421             while (p.right != null)
2422                 p = p.right;
2423         return p;
2424     }
2425 
2426     /**
2427      * Returns the successor of the specified Entry, or null if no such.
2428      */
2429     static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {
2430         if (t == null)
2431             return null;
2432         else if (t.right != null) {
2433             Entry&lt;K,V&gt; p = t.right;
2434             while (p.left != null)
2435                 p = p.left;
2436             return p;
2437         } else {
2438             Entry&lt;K,V&gt; p = t.parent;
2439             Entry&lt;K,V&gt; ch = t;
2440             while (p != null &amp;&amp; ch == p.right) {
2441                 ch = p;
2442                 p = p.parent;
2443             }
2444             return p;
2445         }
2446     }
2447 
2448     /**
2449      * Returns the predecessor of the specified Entry, or null if no such.
2450      */
2451     static &lt;K,V&gt; Entry&lt;K,V&gt; predecessor(Entry&lt;K,V&gt; t) {
2452         if (t == null)
2453             return null;
2454         else if (t.left != null) {
2455             Entry&lt;K,V&gt; p = t.left;
2456             while (p.right != null)
2457                 p = p.right;
2458             return p;
2459         } else {
2460             Entry&lt;K,V&gt; p = t.parent;
2461             Entry&lt;K,V&gt; ch = t;
2462             while (p != null &amp;&amp; ch == p.left) {
2463                 ch = p;
2464                 p = p.parent;
2465             }
2466             return p;
2467         }
2468     }
2469 
2470     /**
2471      * Balancing operations.
2472      *
2473      * Implementations of rebalancings during insertion and deletion are
2474      * slightly different than the CLR version.  Rather than using dummy
2475      * nilnodes, we use a set of accessors that deal properly with null.  They
2476      * are used to avoid messiness surrounding nullness checks in the main
2477      * algorithms.
2478      */
2479 
2480     private static &lt;K,V&gt; boolean colorOf(Entry&lt;K,V&gt; p) {
2481         return (p == null ? BLACK : p.color);
2482     }
2483 
2484     private static &lt;K,V&gt; Entry&lt;K,V&gt; parentOf(Entry&lt;K,V&gt; p) {
2485         return (p == null ? null: p.parent);
2486     }
2487 
2488     private static &lt;K,V&gt; void setColor(Entry&lt;K,V&gt; p, boolean c) {
2489         if (p != null)
2490             p.color = c;
2491     }
2492 
2493     private static &lt;K,V&gt; Entry&lt;K,V&gt; leftOf(Entry&lt;K,V&gt; p) {
2494         return (p == null) ? null: p.left;
2495     }
2496 
2497     private static &lt;K,V&gt; Entry&lt;K,V&gt; rightOf(Entry&lt;K,V&gt; p) {
2498         return (p == null) ? null: p.right;
2499     }
2500 
2501     /** From CLR */
2502     private void rotateLeft(Entry&lt;K,V&gt; p) {
2503         if (p != null) {
2504             Entry&lt;K,V&gt; r = p.right;
2505             p.right = r.left;
2506             if (r.left != null)
2507                 r.left.parent = p;
2508             r.parent = p.parent;
2509             if (p.parent == null)
2510                 root = r;
2511             else if (p.parent.left == p)
2512                 p.parent.left = r;
2513             else
2514                 p.parent.right = r;
2515             r.left = p;
2516             p.parent = r;
2517         }
2518     }
2519 
2520     /** From CLR */
2521     private void rotateRight(Entry&lt;K,V&gt; p) {
2522         if (p != null) {
2523             Entry&lt;K,V&gt; l = p.left;
2524             p.left = l.right;
2525             if (l.right != null) l.right.parent = p;
2526             l.parent = p.parent;
2527             if (p.parent == null)
2528                 root = l;
2529             else if (p.parent.right == p)
2530                 p.parent.right = l;
2531             else p.parent.left = l;
2532             l.right = p;
2533             p.parent = l;
2534         }
2535     }
2536 
2537     /** From CLR */
2538     private void fixAfterInsertion(Entry&lt;K,V&gt; x) {
2539         x.color = RED;
2540 
2541         while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {
2542             if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {
2543                 Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));
2544                 if (colorOf(y) == RED) {
2545                     setColor(parentOf(x), BLACK);
2546                     setColor(y, BLACK);
2547                     setColor(parentOf(parentOf(x)), RED);
2548                     x = parentOf(parentOf(x));
2549                 } else {
2550                     if (x == rightOf(parentOf(x))) {
2551                         x = parentOf(x);
2552                         rotateLeft(x);
2553                     }
2554                     setColor(parentOf(x), BLACK);
2555                     setColor(parentOf(parentOf(x)), RED);
2556                     rotateRight(parentOf(parentOf(x)));
2557                 }
2558             } else {
2559                 Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));
2560                 if (colorOf(y) == RED) {
2561                     setColor(parentOf(x), BLACK);
2562                     setColor(y, BLACK);
2563                     setColor(parentOf(parentOf(x)), RED);
2564                     x = parentOf(parentOf(x));
2565                 } else {
2566                     if (x == leftOf(parentOf(x))) {
2567                         x = parentOf(x);
2568                         rotateRight(x);
2569                     }
2570                     setColor(parentOf(x), BLACK);
2571                     setColor(parentOf(parentOf(x)), RED);
2572                     rotateLeft(parentOf(parentOf(x)));
2573                 }
2574             }
2575         }
2576         root.color = BLACK;
2577     }
2578 
2579     /**
2580      * Delete node p, and then rebalance the tree.
2581      */
2582     private void deleteEntry(Entry&lt;K,V&gt; p) {
2583         modCount++;
2584         size--;
2585 
2586         // If strictly internal, copy successor&#39;s element to p and then make p
2587         // point to successor.
2588         if (p.left != null &amp;&amp; p.right != null) {
2589             Entry&lt;K,V&gt; s = successor(p);
2590             p.key = s.key;
2591             p.value = s.value;
2592             p = s;
2593         } // p has 2 children
2594 
2595         // Start fixup at replacement node, if it exists.
2596         Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right);
2597 
2598         if (replacement != null) {
2599             // Link replacement to parent
2600             replacement.parent = p.parent;
2601             if (p.parent == null)
2602                 root = replacement;
2603             else if (p == p.parent.left)
2604                 p.parent.left  = replacement;
2605             else
2606                 p.parent.right = replacement;
2607 
2608             // Null out links so they are OK to use by fixAfterDeletion.
2609             p.left = p.right = p.parent = null;
2610 
2611             // Fix replacement
2612             if (p.color == BLACK)
2613                 fixAfterDeletion(replacement);
2614         } else if (p.parent == null) { // return if we are the only node.
2615             root = null;
2616         } else { //  No children. Use self as phantom replacement and unlink.
2617             if (p.color == BLACK)
2618                 fixAfterDeletion(p);
2619 
2620             if (p.parent != null) {
2621                 if (p == p.parent.left)
2622                     p.parent.left = null;
2623                 else if (p == p.parent.right)
2624                     p.parent.right = null;
2625                 p.parent = null;
2626             }
2627         }
2628     }
2629 
2630     /** From CLR */
2631     private void fixAfterDeletion(Entry&lt;K,V&gt; x) {
2632         while (x != root &amp;&amp; colorOf(x) == BLACK) {
2633             if (x == leftOf(parentOf(x))) {
2634                 Entry&lt;K,V&gt; sib = rightOf(parentOf(x));
2635 
2636                 if (colorOf(sib) == RED) {
2637                     setColor(sib, BLACK);
2638                     setColor(parentOf(x), RED);
2639                     rotateLeft(parentOf(x));
2640                     sib = rightOf(parentOf(x));
2641                 }
2642 
2643                 if (colorOf(leftOf(sib))  == BLACK &amp;&amp;
2644                     colorOf(rightOf(sib)) == BLACK) {
2645                     setColor(sib, RED);
2646                     x = parentOf(x);
2647                 } else {
2648                     if (colorOf(rightOf(sib)) == BLACK) {
2649                         setColor(leftOf(sib), BLACK);
2650                         setColor(sib, RED);
2651                         rotateRight(sib);
2652                         sib = rightOf(parentOf(x));
2653                     }
2654                     setColor(sib, colorOf(parentOf(x)));
2655                     setColor(parentOf(x), BLACK);
2656                     setColor(rightOf(sib), BLACK);
2657                     rotateLeft(parentOf(x));
2658                     x = root;
2659                 }
2660             } else { // symmetric
2661                 Entry&lt;K,V&gt; sib = leftOf(parentOf(x));
2662 
2663                 if (colorOf(sib) == RED) {
2664                     setColor(sib, BLACK);
2665                     setColor(parentOf(x), RED);
2666                     rotateRight(parentOf(x));
2667                     sib = leftOf(parentOf(x));
2668                 }
2669 
2670                 if (colorOf(rightOf(sib)) == BLACK &amp;&amp;
2671                     colorOf(leftOf(sib)) == BLACK) {
2672                     setColor(sib, RED);
2673                     x = parentOf(x);
2674                 } else {
2675                     if (colorOf(leftOf(sib)) == BLACK) {
2676                         setColor(rightOf(sib), BLACK);
2677                         setColor(sib, RED);
2678                         rotateLeft(sib);
2679                         sib = leftOf(parentOf(x));
2680                     }
2681                     setColor(sib, colorOf(parentOf(x)));
2682                     setColor(parentOf(x), BLACK);
2683                     setColor(leftOf(sib), BLACK);
2684                     rotateRight(parentOf(x));
2685                     x = root;
2686                 }
2687             }
2688         }
2689 
2690         setColor(x, BLACK);
2691     }
2692 
2693     @java.io.Serial
2694     private static final long serialVersionUID = 919286545866124006L;
2695 
2696     /**
2697      * Save the state of the {@code TreeMap} instance to a stream (i.e.,
2698      * serialize it).
2699      *
2700      * @serialData The &lt;em&gt;size&lt;/em&gt; of the TreeMap (the number of key-value
2701      *             mappings) is emitted (int), followed by the key (Object)
2702      *             and value (Object) for each key-value mapping represented
2703      *             by the TreeMap. The key-value mappings are emitted in
2704      *             key-order (as determined by the TreeMap&#39;s Comparator,
2705      *             or by the keys&#39; natural ordering if the TreeMap has no
2706      *             Comparator).
2707      */
2708     @java.io.Serial
2709     private void writeObject(java.io.ObjectOutputStream s)
2710         throws java.io.IOException {
2711         // Write out the Comparator and any hidden stuff
2712         s.defaultWriteObject();
2713 
2714         // Write out size (number of Mappings)
2715         s.writeInt(size);
2716 
2717         // Write out keys and values (alternating)
2718         for (Map.Entry&lt;K, V&gt; e : entrySet()) {
2719             s.writeObject(e.getKey());
2720             s.writeObject(e.getValue());
2721         }
2722     }
2723 
2724     /**
2725      * Reconstitute the {@code TreeMap} instance from a stream (i.e.,
2726      * deserialize it).
2727      */
2728     @java.io.Serial
2729     private void readObject(final java.io.ObjectInputStream s)
2730         throws java.io.IOException, ClassNotFoundException {
2731         // Read in the Comparator and any hidden stuff
2732         s.defaultReadObject();
2733 
2734         // Read in size
2735         int size = s.readInt();
2736 
2737         buildFromSorted(size, null, s, null);
2738     }
2739 
2740     /** Intended to be called only from TreeSet.readObject */
2741     void readTreeSet(int size, java.io.ObjectInputStream s, V defaultVal)
2742         throws java.io.IOException, ClassNotFoundException {
2743         buildFromSorted(size, null, s, defaultVal);
2744     }
2745 
2746     /** Intended to be called only from TreeSet.addAll */
2747     void addAllForTreeSet(SortedSet&lt;? extends K&gt; set, V defaultVal) {
2748         try {
2749             buildFromSorted(set.size(), set.iterator(), null, defaultVal);
2750         } catch (java.io.IOException | ClassNotFoundException cannotHappen) {
2751         }
2752     }
2753 
2754 
2755     /**
2756      * Linear time tree building algorithm from sorted data.  Can accept keys
2757      * and/or values from iterator or stream. This leads to too many
2758      * parameters, but seems better than alternatives.  The four formats
2759      * that this method accepts are:
2760      *
2761      *    1) An iterator of Map.Entries.  (it != null, defaultVal == null).
2762      *    2) An iterator of keys.         (it != null, defaultVal != null).
2763      *    3) A stream of alternating serialized keys and values.
2764      *                                   (it == null, defaultVal == null).
2765      *    4) A stream of serialized keys. (it == null, defaultVal != null).
2766      *
2767      * It is assumed that the comparator of the TreeMap is already set prior
2768      * to calling this method.
2769      *
2770      * @param size the number of keys (or key-value pairs) to be read from
2771      *        the iterator or stream
2772      * @param it If non-null, new entries are created from entries
2773      *        or keys read from this iterator.
2774      * @param str If non-null, new entries are created from keys and
2775      *        possibly values read from this stream in serialized form.
2776      *        Exactly one of it and str should be non-null.
2777      * @param defaultVal if non-null, this default value is used for
2778      *        each value in the map.  If null, each value is read from
2779      *        iterator or stream, as described above.
2780      * @throws java.io.IOException propagated from stream reads. This cannot
2781      *         occur if str is null.
2782      * @throws ClassNotFoundException propagated from readObject.
2783      *         This cannot occur if str is null.
2784      */
2785     private void buildFromSorted(int size, Iterator&lt;?&gt; it,
2786                                  java.io.ObjectInputStream str,
2787                                  V defaultVal)
2788         throws  java.io.IOException, ClassNotFoundException {
2789         this.size = size;
2790         root = buildFromSorted(0, 0, size-1, computeRedLevel(size),
2791                                it, str, defaultVal);
2792     }
2793 
2794     /**
2795      * Recursive &quot;helper method&quot; that does the real work of the
2796      * previous method.  Identically named parameters have
2797      * identical definitions.  Additional parameters are documented below.
2798      * It is assumed that the comparator and size fields of the TreeMap are
2799      * already set prior to calling this method.  (It ignores both fields.)
2800      *
2801      * @param level the current level of tree. Initial call should be 0.
2802      * @param lo the first element index of this subtree. Initial should be 0.
2803      * @param hi the last element index of this subtree.  Initial should be
2804      *        size-1.
2805      * @param redLevel the level at which nodes should be red.
2806      *        Must be equal to computeRedLevel for tree of this size.
2807      */
2808     @SuppressWarnings(&quot;unchecked&quot;)
2809     private final Entry&lt;K,V&gt; buildFromSorted(int level, int lo, int hi,
2810                                              int redLevel,
2811                                              Iterator&lt;?&gt; it,
2812                                              java.io.ObjectInputStream str,
2813                                              V defaultVal)
2814         throws  java.io.IOException, ClassNotFoundException {
2815         /*
2816          * Strategy: The root is the middlemost element. To get to it, we
2817          * have to first recursively construct the entire left subtree,
2818          * so as to grab all of its elements. We can then proceed with right
2819          * subtree.
2820          *
2821          * The lo and hi arguments are the minimum and maximum
2822          * indices to pull out of the iterator or stream for current subtree.
2823          * They are not actually indexed, we just proceed sequentially,
2824          * ensuring that items are extracted in corresponding order.
2825          */
2826 
2827         if (hi &lt; lo) return null;
2828 
2829         int mid = (lo + hi) &gt;&gt;&gt; 1;
2830 
2831         Entry&lt;K,V&gt; left  = null;
2832         if (lo &lt; mid)
2833             left = buildFromSorted(level+1, lo, mid - 1, redLevel,
2834                                    it, str, defaultVal);
2835 
2836         // extract key and/or value from iterator or stream
2837         K key;
2838         V value;
2839         if (it != null) {
2840             if (defaultVal==null) {
2841                 Map.Entry&lt;?,?&gt; entry = (Map.Entry&lt;?,?&gt;)it.next();
2842                 key = (K)entry.getKey();
2843                 value = (V)entry.getValue();
2844             } else {
2845                 key = (K)it.next();
2846                 value = defaultVal;
2847             }
2848         } else { // use stream
2849             key = (K) str.readObject();
2850             value = (defaultVal != null ? defaultVal : (V) str.readObject());
2851         }
2852 
2853         Entry&lt;K,V&gt; middle =  new Entry&lt;&gt;(key, value, null);
2854 
2855         // color nodes in non-full bottommost level red
2856         if (level == redLevel)
2857             middle.color = RED;
2858 
2859         if (left != null) {
2860             middle.left = left;
2861             left.parent = middle;
2862         }
2863 
2864         if (mid &lt; hi) {
2865             Entry&lt;K,V&gt; right = buildFromSorted(level+1, mid+1, hi, redLevel,
2866                                                it, str, defaultVal);
2867             middle.right = right;
2868             right.parent = middle;
2869         }
2870 
2871         return middle;
2872     }
2873 
2874     /**
2875      * Finds the level down to which to assign all nodes BLACK.  This is the
2876      * last `full&#39; level of the complete binary tree produced by buildTree.
2877      * The remaining nodes are colored RED. (This makes a `nice&#39; set of
2878      * color assignments wrt future insertions.) This level number is
2879      * computed by finding the number of splits needed to reach the zeroeth
2880      * node.
2881      *
2882      * @param size the (non-negative) number of keys in the tree to be built
2883      */
2884     private static int computeRedLevel(int size) {
2885         return 31 - Integer.numberOfLeadingZeros(size + 1);
2886     }
2887 
2888     /**
2889      * Currently, we support Spliterator-based versions only for the
2890      * full map, in either plain of descending form, otherwise relying
2891      * on defaults because size estimation for submaps would dominate
2892      * costs. The type tests needed to check these for key views are
2893      * not very nice but avoid disrupting existing class
2894      * structures. Callers must use plain default spliterators if this
2895      * returns null.
2896      */
2897     static &lt;K&gt; Spliterator&lt;K&gt; keySpliteratorFor(NavigableMap&lt;K,?&gt; m) {
2898         if (m instanceof TreeMap) {
2899             @SuppressWarnings(&quot;unchecked&quot;) TreeMap&lt;K,Object&gt; t =
2900                 (TreeMap&lt;K,Object&gt;) m;
2901             return t.keySpliterator();
2902         }
2903         if (m instanceof DescendingSubMap) {
2904             @SuppressWarnings(&quot;unchecked&quot;) DescendingSubMap&lt;K,?&gt; dm =
2905                 (DescendingSubMap&lt;K,?&gt;) m;
2906             TreeMap&lt;K,?&gt; tm = dm.m;
2907             if (dm == tm.descendingMap) {
2908                 @SuppressWarnings(&quot;unchecked&quot;) TreeMap&lt;K,Object&gt; t =
2909                     (TreeMap&lt;K,Object&gt;) tm;
2910                 return t.descendingKeySpliterator();
2911             }
2912         }
2913         @SuppressWarnings(&quot;unchecked&quot;) NavigableSubMap&lt;K,?&gt; sm =
2914             (NavigableSubMap&lt;K,?&gt;) m;
2915         return sm.keySpliterator();
2916     }
2917 
2918     final Spliterator&lt;K&gt; keySpliterator() {
2919         return new KeySpliterator&lt;&gt;(this, null, null, 0, -1, 0);
2920     }
2921 
2922     final Spliterator&lt;K&gt; descendingKeySpliterator() {
2923         return new DescendingKeySpliterator&lt;&gt;(this, null, null, 0, -2, 0);
2924     }
2925 
2926     /**
2927      * Base class for spliterators.  Iteration starts at a given
2928      * origin and continues up to but not including a given fence (or
2929      * null for end).  At top-level, for ascending cases, the first
2930      * split uses the root as left-fence/right-origin. From there,
2931      * right-hand splits replace the current fence with its left
2932      * child, also serving as origin for the split-off spliterator.
2933      * Left-hands are symmetric. Descending versions place the origin
2934      * at the end and invert ascending split rules.  This base class
2935      * is non-committal about directionality, or whether the top-level
2936      * spliterator covers the whole tree. This means that the actual
2937      * split mechanics are located in subclasses. Some of the subclass
2938      * trySplit methods are identical (except for return types), but
2939      * not nicely factorable.
2940      *
2941      * Currently, subclass versions exist only for the full map
2942      * (including descending keys via its descendingMap).  Others are
2943      * possible but currently not worthwhile because submaps require
2944      * O(n) computations to determine size, which substantially limits
2945      * potential speed-ups of using custom Spliterators versus default
2946      * mechanics.
2947      *
2948      * To boostrap initialization, external constructors use
2949      * negative size estimates: -1 for ascend, -2 for descend.
2950      */
2951     static class TreeMapSpliterator&lt;K,V&gt; {
2952         final TreeMap&lt;K,V&gt; tree;
2953         TreeMap.Entry&lt;K,V&gt; current; // traverser; initially first node in range
2954         TreeMap.Entry&lt;K,V&gt; fence;   // one past last, or null
2955         int side;                   // 0: top, -1: is a left split, +1: right
2956         int est;                    // size estimate (exact only for top-level)
2957         int expectedModCount;       // for CME checks
2958 
2959         TreeMapSpliterator(TreeMap&lt;K,V&gt; tree,
2960                            TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
2961                            int side, int est, int expectedModCount) {
2962             this.tree = tree;
2963             this.current = origin;
2964             this.fence = fence;
2965             this.side = side;
2966             this.est = est;
2967             this.expectedModCount = expectedModCount;
2968         }
2969 
2970         final int getEstimate() { // force initialization
2971             int s; TreeMap&lt;K,V&gt; t;
2972             if ((s = est) &lt; 0) {
2973                 if ((t = tree) != null) {
2974                     current = (s == -1) ? t.getFirstEntry() : t.getLastEntry();
2975                     s = est = t.size;
2976                     expectedModCount = t.modCount;
2977                 }
2978                 else
2979                     s = est = 0;
2980             }
2981             return s;
2982         }
2983 
2984         public final long estimateSize() {
2985             return (long)getEstimate();
2986         }
2987     }
2988 
2989     static final class KeySpliterator&lt;K,V&gt;
2990         extends TreeMapSpliterator&lt;K,V&gt;
2991         implements Spliterator&lt;K&gt; {
2992         KeySpliterator(TreeMap&lt;K,V&gt; tree,
2993                        TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
2994                        int side, int est, int expectedModCount) {
2995             super(tree, origin, fence, side, est, expectedModCount);
2996         }
2997 
2998         public KeySpliterator&lt;K,V&gt; trySplit() {
2999             if (est &lt; 0)
3000                 getEstimate(); // force initialization
3001             int d = side;
3002             TreeMap.Entry&lt;K,V&gt; e = current, f = fence,
3003                 s = ((e == null || e == f) ? null :      // empty
3004                      (d == 0)              ? tree.root : // was top
3005                      (d &gt;  0)              ? e.right :   // was right
3006                      (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left
3007                      null);
3008             if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;
3009                 tree.compare(e.key, s.key) &lt; 0) {        // e not already past s
3010                 side = 1;
3011                 return new KeySpliterator&lt;&gt;
3012                     (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
3013             }
3014             return null;
3015         }
3016 
3017         public void forEachRemaining(Consumer&lt;? super K&gt; action) {
3018             if (action == null)
3019                 throw new NullPointerException();
3020             if (est &lt; 0)
3021                 getEstimate(); // force initialization
3022             TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;
3023             if ((e = current) != null &amp;&amp; e != f) {
3024                 current = f; // exhaust
3025                 do {
3026                     action.accept(e.key);
3027                     if ((p = e.right) != null) {
3028                         while ((pl = p.left) != null)
3029                             p = pl;
3030                     }
3031                     else {
3032                         while ((p = e.parent) != null &amp;&amp; e == p.right)
3033                             e = p;
3034                     }
3035                 } while ((e = p) != null &amp;&amp; e != f);
3036                 if (tree.modCount != expectedModCount)
3037                     throw new ConcurrentModificationException();
3038             }
3039         }
3040 
3041         public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
3042             TreeMap.Entry&lt;K,V&gt; e;
3043             if (action == null)
3044                 throw new NullPointerException();
3045             if (est &lt; 0)
3046                 getEstimate(); // force initialization
3047             if ((e = current) == null || e == fence)
3048                 return false;
3049             current = successor(e);
3050             action.accept(e.key);
3051             if (tree.modCount != expectedModCount)
3052                 throw new ConcurrentModificationException();
3053             return true;
3054         }
3055 
3056         public int characteristics() {
3057             return (side == 0 ? Spliterator.SIZED : 0) |
3058                 Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED;
3059         }
3060 
3061         public final Comparator&lt;? super K&gt;  getComparator() {
3062             return tree.comparator;
3063         }
3064 
3065     }
3066 
3067     static final class DescendingKeySpliterator&lt;K,V&gt;
3068         extends TreeMapSpliterator&lt;K,V&gt;
3069         implements Spliterator&lt;K&gt; {
3070         DescendingKeySpliterator(TreeMap&lt;K,V&gt; tree,
3071                                  TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
3072                                  int side, int est, int expectedModCount) {
3073             super(tree, origin, fence, side, est, expectedModCount);
3074         }
3075 
3076         public DescendingKeySpliterator&lt;K,V&gt; trySplit() {
3077             if (est &lt; 0)
3078                 getEstimate(); // force initialization
3079             int d = side;
3080             TreeMap.Entry&lt;K,V&gt; e = current, f = fence,
3081                     s = ((e == null || e == f) ? null :      // empty
3082                          (d == 0)              ? tree.root : // was top
3083                          (d &lt;  0)              ? e.left :    // was left
3084                          (d &gt;  0 &amp;&amp; f != null) ? f.right :   // was right
3085                          null);
3086             if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;
3087                 tree.compare(e.key, s.key) &gt; 0) {       // e not already past s
3088                 side = 1;
3089                 return new DescendingKeySpliterator&lt;&gt;
3090                         (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
3091             }
3092             return null;
3093         }
3094 
3095         public void forEachRemaining(Consumer&lt;? super K&gt; action) {
3096             if (action == null)
3097                 throw new NullPointerException();
3098             if (est &lt; 0)
3099                 getEstimate(); // force initialization
3100             TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pr;
3101             if ((e = current) != null &amp;&amp; e != f) {
3102                 current = f; // exhaust
3103                 do {
3104                     action.accept(e.key);
3105                     if ((p = e.left) != null) {
3106                         while ((pr = p.right) != null)
3107                             p = pr;
3108                     }
3109                     else {
3110                         while ((p = e.parent) != null &amp;&amp; e == p.left)
3111                             e = p;
3112                     }
3113                 } while ((e = p) != null &amp;&amp; e != f);
3114                 if (tree.modCount != expectedModCount)
3115                     throw new ConcurrentModificationException();
3116             }
3117         }
3118 
3119         public boolean tryAdvance(Consumer&lt;? super K&gt; action) {
3120             TreeMap.Entry&lt;K,V&gt; e;
3121             if (action == null)
3122                 throw new NullPointerException();
3123             if (est &lt; 0)
3124                 getEstimate(); // force initialization
3125             if ((e = current) == null || e == fence)
3126                 return false;
3127             current = predecessor(e);
3128             action.accept(e.key);
3129             if (tree.modCount != expectedModCount)
3130                 throw new ConcurrentModificationException();
3131             return true;
3132         }
3133 
3134         public int characteristics() {
3135             return (side == 0 ? Spliterator.SIZED : 0) |
3136                 Spliterator.DISTINCT | Spliterator.ORDERED;
3137         }
3138     }
3139 
3140     static final class ValueSpliterator&lt;K,V&gt;
3141             extends TreeMapSpliterator&lt;K,V&gt;
3142             implements Spliterator&lt;V&gt; {
3143         ValueSpliterator(TreeMap&lt;K,V&gt; tree,
3144                          TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
3145                          int side, int est, int expectedModCount) {
3146             super(tree, origin, fence, side, est, expectedModCount);
3147         }
3148 
3149         public ValueSpliterator&lt;K,V&gt; trySplit() {
3150             if (est &lt; 0)
3151                 getEstimate(); // force initialization
3152             int d = side;
3153             TreeMap.Entry&lt;K,V&gt; e = current, f = fence,
3154                     s = ((e == null || e == f) ? null :      // empty
3155                          (d == 0)              ? tree.root : // was top
3156                          (d &gt;  0)              ? e.right :   // was right
3157                          (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left
3158                          null);
3159             if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;
3160                 tree.compare(e.key, s.key) &lt; 0) {        // e not already past s
3161                 side = 1;
3162                 return new ValueSpliterator&lt;&gt;
3163                         (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
3164             }
3165             return null;
3166         }
3167 
3168         public void forEachRemaining(Consumer&lt;? super V&gt; action) {
3169             if (action == null)
3170                 throw new NullPointerException();
3171             if (est &lt; 0)
3172                 getEstimate(); // force initialization
3173             TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;
3174             if ((e = current) != null &amp;&amp; e != f) {
3175                 current = f; // exhaust
3176                 do {
3177                     action.accept(e.value);
3178                     if ((p = e.right) != null) {
3179                         while ((pl = p.left) != null)
3180                             p = pl;
3181                     }
3182                     else {
3183                         while ((p = e.parent) != null &amp;&amp; e == p.right)
3184                             e = p;
3185                     }
3186                 } while ((e = p) != null &amp;&amp; e != f);
3187                 if (tree.modCount != expectedModCount)
3188                     throw new ConcurrentModificationException();
3189             }
3190         }
3191 
3192         public boolean tryAdvance(Consumer&lt;? super V&gt; action) {
3193             TreeMap.Entry&lt;K,V&gt; e;
3194             if (action == null)
3195                 throw new NullPointerException();
3196             if (est &lt; 0)
3197                 getEstimate(); // force initialization
3198             if ((e = current) == null || e == fence)
3199                 return false;
3200             current = successor(e);
3201             action.accept(e.value);
3202             if (tree.modCount != expectedModCount)
3203                 throw new ConcurrentModificationException();
3204             return true;
3205         }
3206 
3207         public int characteristics() {
3208             return (side == 0 ? Spliterator.SIZED : 0) | Spliterator.ORDERED;
3209         }
3210     }
3211 
3212     static final class EntrySpliterator&lt;K,V&gt;
3213         extends TreeMapSpliterator&lt;K,V&gt;
3214         implements Spliterator&lt;Map.Entry&lt;K,V&gt;&gt; {
3215         EntrySpliterator(TreeMap&lt;K,V&gt; tree,
3216                          TreeMap.Entry&lt;K,V&gt; origin, TreeMap.Entry&lt;K,V&gt; fence,
3217                          int side, int est, int expectedModCount) {
3218             super(tree, origin, fence, side, est, expectedModCount);
3219         }
3220 
3221         public EntrySpliterator&lt;K,V&gt; trySplit() {
3222             if (est &lt; 0)
3223                 getEstimate(); // force initialization
3224             int d = side;
3225             TreeMap.Entry&lt;K,V&gt; e = current, f = fence,
3226                     s = ((e == null || e == f) ? null :      // empty
3227                          (d == 0)              ? tree.root : // was top
3228                          (d &gt;  0)              ? e.right :   // was right
3229                          (d &lt;  0 &amp;&amp; f != null) ? f.left :    // was left
3230                          null);
3231             if (s != null &amp;&amp; s != e &amp;&amp; s != f &amp;&amp;
3232                 tree.compare(e.key, s.key) &lt; 0) {        // e not already past s
3233                 side = 1;
3234                 return new EntrySpliterator&lt;&gt;
3235                         (tree, e, current = s, -1, est &gt;&gt;&gt;= 1, expectedModCount);
3236             }
3237             return null;
3238         }
3239 
3240         public void forEachRemaining(Consumer&lt;? super Map.Entry&lt;K, V&gt;&gt; action) {
3241             if (action == null)
3242                 throw new NullPointerException();
3243             if (est &lt; 0)
3244                 getEstimate(); // force initialization
3245             TreeMap.Entry&lt;K,V&gt; f = fence, e, p, pl;
3246             if ((e = current) != null &amp;&amp; e != f) {
3247                 current = f; // exhaust
3248                 do {
3249                     action.accept(e);
3250                     if ((p = e.right) != null) {
3251                         while ((pl = p.left) != null)
3252                             p = pl;
3253                     }
3254                     else {
3255                         while ((p = e.parent) != null &amp;&amp; e == p.right)
3256                             e = p;
3257                     }
3258                 } while ((e = p) != null &amp;&amp; e != f);
3259                 if (tree.modCount != expectedModCount)
3260                     throw new ConcurrentModificationException();
3261             }
3262         }
3263 
3264         public boolean tryAdvance(Consumer&lt;? super Map.Entry&lt;K,V&gt;&gt; action) {
3265             TreeMap.Entry&lt;K,V&gt; e;
3266             if (action == null)
3267                 throw new NullPointerException();
3268             if (est &lt; 0)
3269                 getEstimate(); // force initialization
3270             if ((e = current) == null || e == fence)
3271                 return false;
3272             current = successor(e);
3273             action.accept(e);
3274             if (tree.modCount != expectedModCount)
3275                 throw new ConcurrentModificationException();
3276             return true;
3277         }
3278 
3279         public int characteristics() {
3280             return (side == 0 ? Spliterator.SIZED : 0) |
3281                     Spliterator.DISTINCT | Spliterator.SORTED | Spliterator.ORDERED;
3282         }
3283 
3284         @Override
3285         public Comparator&lt;Map.Entry&lt;K, V&gt;&gt; getComparator() {
3286             // Adapt or create a key-based comparator
3287             if (tree.comparator != null) {
3288                 return Map.Entry.comparingByKey(tree.comparator);
3289             }
3290             else {
3291                 return (Comparator&lt;Map.Entry&lt;K, V&gt;&gt; &amp; Serializable) (e1, e2) -&gt; {
3292                     @SuppressWarnings(&quot;unchecked&quot;)
3293                     Comparable&lt;? super K&gt; k1 = (Comparable&lt;? super K&gt;) e1.getKey();
3294                     return k1.compareTo(e2.getKey());
3295                 };
3296             }
3297         }
3298     }
3299 }
    </pre>
  </body>
</html>
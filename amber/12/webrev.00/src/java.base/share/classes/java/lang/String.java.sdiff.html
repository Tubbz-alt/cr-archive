<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/String.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="StrictMath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/String.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 445 
 446     /**
 447      * Constructs a new {@code String} by decoding the specified subarray of
 448      * bytes using the specified charset.  The length of the new {@code String}
 449      * is a function of the charset, and hence may not be equal to the length
 450      * of the subarray.
 451      *
 452      * &lt;p&gt; The behavior of this constructor when the given bytes are not valid
 453      * in the given charset is unspecified.  The {@link
 454      * java.nio.charset.CharsetDecoder} class should be used when more control
 455      * over the decoding process is required.
 456      *
 457      * @param  bytes
 458      *         The bytes to be decoded into characters
 459      *
 460      * @param  offset
 461      *         The index of the first byte to decode
 462      *
 463      * @param  length
 464      *         The number of bytes to decode
<span class="line-modified"> 465 </span>
 466      * @param  charsetName
 467      *         The name of a supported {@linkplain java.nio.charset.Charset
 468      *         charset}
 469      *
 470      * @throws  UnsupportedEncodingException
 471      *          If the named charset is not supported
 472      *
 473      * @throws  IndexOutOfBoundsException
 474      *          If {@code offset} is negative, {@code length} is negative, or
 475      *          {@code offset} is greater than {@code bytes.length - length}
 476      *
 477      * @since  1.1
 478      */
 479     public String(byte bytes[], int offset, int length, String charsetName)
 480             throws UnsupportedEncodingException {
 481         if (charsetName == null)
 482             throw new NullPointerException(&quot;charsetName&quot;);
 483         checkBoundsOffCount(offset, length, bytes.length);
 484         StringCoding.Result ret =
 485             StringCoding.decode(charsetName, bytes, offset, length);
</pre>
<hr />
<pre>
1366      * this {@code String} object to be compared begins at index
1367      * {@code toffset} and has length {@code len}. The substring of
1368      * {@code other} to be compared begins at index {@code ooffset} and
1369      * has length {@code len}. The result is {@code false} if and only if
1370      * at least one of the following is true:
1371      * &lt;ul&gt;&lt;li&gt;{@code toffset} is negative.
1372      * &lt;li&gt;{@code ooffset} is negative.
1373      * &lt;li&gt;{@code toffset+len} is greater than the length of this
1374      * {@code String} object.
1375      * &lt;li&gt;{@code ooffset+len} is greater than the length of the other
1376      * argument.
1377      * &lt;li&gt;{@code ignoreCase} is {@code false} and there is some nonnegative
1378      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1379      * &lt;blockquote&gt;&lt;pre&gt;
1380      * this.charAt(toffset+k) != other.charAt(ooffset+k)
1381      * &lt;/pre&gt;&lt;/blockquote&gt;
1382      * &lt;li&gt;{@code ignoreCase} is {@code true} and there is some nonnegative
1383      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1384      * &lt;blockquote&gt;&lt;pre&gt;
1385      * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=
<span class="line-modified">1386      Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))</span>
1387      * &lt;/pre&gt;&lt;/blockquote&gt;
1388      * &lt;/ul&gt;
1389      *
1390      * &lt;p&gt;Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,
1391      * and will result in unsatisfactory results for certain locales when
1392      * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class
1393      * provides locale-sensitive comparison.
1394      *
1395      * @param   ignoreCase   if {@code true}, ignore case when comparing
1396      *                       characters.
1397      * @param   toffset      the starting offset of the subregion in this
1398      *                       string.
1399      * @param   other        the string argument.
1400      * @param   ooffset      the starting offset of the subregion in the string
1401      *                       argument.
1402      * @param   len          the number of characters to compare.
1403      * @return  {@code true} if the specified subregion of this string
1404      *          matches the specified subregion of the string argument;
1405      *          {@code false} otherwise. Whether the matching is exact
1406      *          or case insensitive depends on the {@code ignoreCase}
</pre>
<hr />
<pre>
2046      * @param s the sequence to search for
2047      * @return true if this string contains {@code s}, false otherwise
2048      * @since 1.5
2049      */
2050     public boolean contains(CharSequence s) {
2051         return indexOf(s.toString()) &gt;= 0;
2052     }
2053 
2054     /**
2055      * Replaces the first substring of this string that matches the given &lt;a
2056      * href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt; with the
2057      * given replacement.
2058      *
2059      * &lt;p&gt; An invocation of this method of the form
2060      * &lt;i&gt;str&lt;/i&gt;{@code .replaceFirst(}&lt;i&gt;regex&lt;/i&gt;{@code ,} &lt;i&gt;repl&lt;/i&gt;{@code )}
2061      * yields exactly the same result as the expression
2062      *
2063      * &lt;blockquote&gt;
2064      * &lt;code&gt;
2065      * {@link java.util.regex.Pattern}.{@link
<span class="line-modified">2066      * java.util.regex.Pattern#compile compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span>
2067      * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(&lt;i&gt;str&lt;/i&gt;).{@link
<span class="line-modified">2068      * java.util.regex.Matcher#replaceFirst replaceFirst}(&lt;i&gt;repl&lt;/i&gt;)</span>
2069      * &lt;/code&gt;
2070      * &lt;/blockquote&gt;
2071      *
2072      *&lt;p&gt;
2073      * Note that backslashes ({@code \}) and dollar signs ({@code $}) in the
2074      * replacement string may cause the results to be different than if it were
2075      * being treated as a literal replacement string; see
2076      * {@link java.util.regex.Matcher#replaceFirst}.
2077      * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special
2078      * meaning of these characters, if desired.
2079      *
2080      * @param   regex
2081      *          the regular expression to which this string is to be matched
2082      * @param   replacement
2083      *          the string to be substituted for the first match
2084      *
2085      * @return  The resulting {@code String}
2086      *
2087      * @throws  PatternSyntaxException
2088      *          if the regular expression&#39;s syntax is invalid
</pre>
<hr />
<pre>
2091      *
2092      * @since 1.4
2093      * @spec JSR-51
2094      */
2095     public String replaceFirst(String regex, String replacement) {
2096         return Pattern.compile(regex).matcher(this).replaceFirst(replacement);
2097     }
2098 
2099     /**
2100      * Replaces each substring of this string that matches the given &lt;a
2101      * href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt; with the
2102      * given replacement.
2103      *
2104      * &lt;p&gt; An invocation of this method of the form
2105      * &lt;i&gt;str&lt;/i&gt;{@code .replaceAll(}&lt;i&gt;regex&lt;/i&gt;{@code ,} &lt;i&gt;repl&lt;/i&gt;{@code )}
2106      * yields exactly the same result as the expression
2107      *
2108      * &lt;blockquote&gt;
2109      * &lt;code&gt;
2110      * {@link java.util.regex.Pattern}.{@link
<span class="line-modified">2111      * java.util.regex.Pattern#compile compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span>
2112      * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(&lt;i&gt;str&lt;/i&gt;).{@link
<span class="line-modified">2113      * java.util.regex.Matcher#replaceAll replaceAll}(&lt;i&gt;repl&lt;/i&gt;)</span>
2114      * &lt;/code&gt;
2115      * &lt;/blockquote&gt;
2116      *
2117      *&lt;p&gt;
2118      * Note that backslashes ({@code \}) and dollar signs ({@code $}) in the
2119      * replacement string may cause the results to be different than if it were
2120      * being treated as a literal replacement string; see
2121      * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.
2122      * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special
2123      * meaning of these characters, if desired.
2124      *
2125      * @param   regex
2126      *          the regular expression to which this string is to be matched
2127      * @param   replacement
2128      *          the string to be substituted for each match
2129      *
2130      * @return  The resulting {@code String}
2131      *
2132      * @throws  PatternSyntaxException
2133      *          if the regular expression&#39;s syntax is invalid
</pre>
<hr />
<pre>
2258      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
2259      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;font-weight:normal&quot;&gt;o&lt;/th&gt;
2260      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;5&lt;/th&gt;
2261      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
2262      * &lt;tr&gt;&lt;!-- o --&gt;
2263      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;-2&lt;/th&gt;
2264      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
2265      * &lt;tr&gt;&lt;!-- o --&gt;
2266      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;0&lt;/th&gt;
2267      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;
2268      * &lt;/tbody&gt;
2269      * &lt;/table&gt;&lt;/blockquote&gt;
2270      *
2271      * &lt;p&gt; An invocation of this method of the form
2272      * &lt;i&gt;str.&lt;/i&gt;{@code split(}&lt;i&gt;regex&lt;/i&gt;{@code ,}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;{@code )}
2273      * yields the same result as the expression
2274      *
2275      * &lt;blockquote&gt;
2276      * &lt;code&gt;
2277      * {@link java.util.regex.Pattern}.{@link
<span class="line-modified">2278      * java.util.regex.Pattern#compile compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span>
2279      * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(&lt;i&gt;str&lt;/i&gt;,&amp;nbsp;&lt;i&gt;n&lt;/i&gt;)
2280      * &lt;/code&gt;
2281      * &lt;/blockquote&gt;
2282      *
2283      *
2284      * @param  regex
2285      *         the delimiting regular expression
2286      *
2287      * @param  limit
2288      *         the result threshold, as described above
2289      *
2290      * @return  the array of strings computed by splitting this string
2291      *          around matches of the given regular expression
2292      *
2293      * @throws  PatternSyntaxException
2294      *          if the regular expression&#39;s syntax is invalid
2295      *
2296      * @see java.util.regex.Pattern
2297      *
2298      * @since 1.4
2299      * @spec JSR-51
2300      */
2301     public String[] split(String regex, int limit) {
2302         /* fastpath if the regex is a
<span class="line-modified">2303          (1)one-char String and this character is not one of the</span>
<span class="line-modified">2304             RegEx&#39;s meta characters &quot;.$|()[{^?*+\\&quot;, or</span>
<span class="line-modified">2305          (2)two-char String and the first char is the backslash and</span>
<span class="line-modified">2306             the second is not the ascii digit or ascii letter.</span>
2307          */
2308         char ch = 0;
2309         if (((regex.length() == 1 &amp;&amp;
2310              &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
2311              (regex.length() == 2 &amp;&amp;
2312               regex.charAt(0) == &#39;\\&#39; &amp;&amp;
2313               (((ch = regex.charAt(1))-&#39;0&#39;)|(&#39;9&#39;-ch)) &lt; 0 &amp;&amp;
2314               ((ch-&#39;a&#39;)|(&#39;z&#39;-ch)) &lt; 0 &amp;&amp;
2315               ((ch-&#39;A&#39;)|(&#39;Z&#39;-ch)) &lt; 0)) &amp;&amp;
2316             (ch &lt; Character.MIN_HIGH_SURROGATE ||
2317              ch &gt; Character.MAX_LOW_SURROGATE))
2318         {
2319             int off = 0;
2320             int next = 0;
2321             boolean limited = limit &gt; 0;
2322             ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
2323             while ((next = indexOf(ch, off)) != -1) {
2324                 if (!limited || list.size() &lt; limit - 1) {
2325                     list.add(substring(off, next));
2326                     off = next + 1;
</pre>
<hr />
<pre>
2428     public static String join(CharSequence delimiter, CharSequence... elements) {
2429         Objects.requireNonNull(delimiter);
2430         Objects.requireNonNull(elements);
2431         // Number of elements not likely worth Arrays.stream overhead.
2432         StringJoiner joiner = new StringJoiner(delimiter);
2433         for (CharSequence cs: elements) {
2434             joiner.add(cs);
2435         }
2436         return joiner.toString();
2437     }
2438 
2439     /**
2440      * Returns a new {@code String} composed of copies of the
2441      * {@code CharSequence elements} joined together with a copy of the
2442      * specified {@code delimiter}.
2443      *
2444      * &lt;blockquote&gt;For example,
2445      * &lt;pre&gt;{@code
2446      *     List&lt;String&gt; strings = List.of(&quot;Java&quot;, &quot;is&quot;, &quot;cool&quot;);
2447      *     String message = String.join(&quot; &quot;, strings);
<span class="line-modified">2448      *     //message returned is: &quot;Java is cool&quot;</span>
2449      *
2450      *     Set&lt;String&gt; strings =
2451      *         new LinkedHashSet&lt;&gt;(List.of(&quot;Java&quot;, &quot;is&quot;, &quot;very&quot;, &quot;cool&quot;));
2452      *     String message = String.join(&quot;-&quot;, strings);
<span class="line-modified">2453      *     //message returned is: &quot;Java-is-very-cool&quot;</span>
2454      * }&lt;/pre&gt;&lt;/blockquote&gt;
2455      *
2456      * Note that if an individual element is {@code null}, then {@code &quot;null&quot;} is added.
2457      *
2458      * @param  delimiter a sequence of characters that is used to separate each
2459      *         of the {@code elements} in the resulting {@code String}
2460      * @param  elements an {@code Iterable} that will have its {@code elements}
2461      *         joined together.
2462      *
2463      * @return a new {@code String} that is composed from the {@code elements}
2464      *         argument
2465      *
2466      * @throws NullPointerException If {@code delimiter} or {@code elements}
2467      *         is {@code null}
2468      *
2469      * @see    #join(CharSequence,CharSequence...)
2470      * @see    java.util.StringJoiner
2471      * @since 1.8
2472      */
2473     public static String join(CharSequence delimiter,
</pre>
<hr />
<pre>
2956      * If this string ends with a line terminator then the result will end
2957      * with a line terminator.
2958      *
2959      * @implNote
2960      * This method treats all {@linkplain Character#isWhitespace(int) white space}
2961      * characters as having equal width. As long as the indentation on every
2962      * line is consistently composed of the same character sequences, then the
2963      * result will be as described above.
2964      *
2965      * @return string with incidental indentation removed and line
2966      *         terminators normalized
2967      *
2968      * @see String#lines()
2969      * @see String#isBlank()
2970      * @see String#indent(int)
2971      * @see Character#isWhitespace(int)
2972      *
2973      * @since 13
2974      *
2975      */
<span class="line-removed">2976     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="line-removed">2977                                  essentialAPI=true)</span>
2978     public String stripIndent() {
2979         int length = length();
2980         if (length == 0) {
2981             return &quot;&quot;;
2982         }
2983         char lastChar = charAt(length - 1);
2984         boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;
2985         List&lt;String&gt; lines = lines().collect(Collectors.toList());
2986         final int outdent = optOut ? 0 : outdent(lines);
2987         return lines.stream()
2988             .map(line -&gt; {
2989                 int firstNonWhitespace = line.indexOfNonWhitespace();
2990                 int lastNonWhitespace = line.lastIndexOfNonWhitespace();
2991                 int incidentalWhitespace = Math.min(outdent, firstNonWhitespace);
2992                 return firstNonWhitespace &gt; lastNonWhitespace
2993                     ? &quot;&quot; : line.substring(incidentalWhitespace, lastNonWhitespace);
2994             })
2995             .collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, optOut ? &quot;\n&quot; : &quot;&quot;));
2996     }
2997 
</pre>
<hr />
<pre>
3090      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&lt;line-terminator&gt;}&lt;/th&gt;
3091      *     &lt;td&gt;continuation&lt;/td&gt;
3092      *     &lt;td&gt;discard&lt;/td&gt;
3093      *   &lt;/tr&gt;
3094      *   &lt;/tbody&gt;
3095      * &lt;/table&gt;
3096      *
3097      * @implNote
3098      * This method does &lt;em&gt;not&lt;/em&gt; translate Unicode escapes such as &quot;{@code \u005cu2022}&quot;.
3099      * Unicode escapes are translated by the Java compiler when reading input characters and
3100      * are not part of the string literal specification.
3101      *
3102      * @throws IllegalArgumentException when an escape sequence is malformed.
3103      *
3104      * @return String with escape sequences translated.
3105      *
3106      * @jls 3.10.7 Escape Sequences
3107      *
3108      * @since 13
3109      */
<span class="line-removed">3110     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="line-removed">3111                                  essentialAPI=true)</span>
3112     public String translateEscapes() {
3113         if (isEmpty()) {
3114             return &quot;&quot;;
3115         }
3116         char[] chars = toCharArray();
3117         int length = chars.length;
3118         int from = 0;
3119         int to = 0;
3120         while (from &lt; length) {
3121             char ch = chars[from++];
3122             if (ch == &#39;\\&#39;) {
3123                 ch = from &lt; length ? chars[from++] : &#39;\0&#39;;
3124                 switch (ch) {
3125                 case &#39;b&#39;:
3126                     ch = &#39;\b&#39;;
3127                     break;
3128                 case &#39;f&#39;:
3129                     ch = &#39;\f&#39;;
3130                     break;
3131                 case &#39;n&#39;:
</pre>
<hr />
<pre>
3352      *           method when preview features are enabled. Preview features
3353      *           may be removed in a future release, or upgraded to permanent
3354      *           features of the Java language.}
3355      *
3356      * Formats using this string as the format string, and the supplied
3357      * arguments.
3358      *
3359      * @implSpec This method is equivalent to {@code String.format(this, args)}.
3360      *
3361      * @param  args
3362      *         Arguments referenced by the format specifiers in this string.
3363      *
3364      * @return  A formatted string
3365      *
3366      * @see  java.lang.String#format(String,Object...)
3367      * @see  java.util.Formatter
3368      *
3369      * @since 13
3370      *
3371      */
<span class="line-removed">3372     @jdk.internal.PreviewFeature(feature=jdk.internal.PreviewFeature.Feature.TEXT_BLOCKS,</span>
<span class="line-removed">3373                                  essentialAPI=true)</span>
3374     public String formatted(Object... args) {
3375         return new Formatter().format(this, args).toString();
3376     }
3377 
3378     /**
3379      * Returns the string representation of the {@code Object} argument.
3380      *
3381      * @param   obj   an {@code Object}.
3382      * @return  if the argument is {@code null}, then a string equal to
3383      *          {@code &quot;null&quot;}; otherwise, the value of
3384      *          {@code obj.toString()} is returned.
3385      * @see     java.lang.Object#toString()
3386      */
3387     public static String valueOf(Object obj) {
3388         return (obj == null) ? &quot;null&quot; : obj.toString();
3389     }
3390 
3391     /**
3392      * Returns the string representation of the {@code char} array
3393      * argument. The contents of the character array are copied; subsequent
</pre>
</td>
<td>
<hr />
<pre>
 445 
 446     /**
 447      * Constructs a new {@code String} by decoding the specified subarray of
 448      * bytes using the specified charset.  The length of the new {@code String}
 449      * is a function of the charset, and hence may not be equal to the length
 450      * of the subarray.
 451      *
 452      * &lt;p&gt; The behavior of this constructor when the given bytes are not valid
 453      * in the given charset is unspecified.  The {@link
 454      * java.nio.charset.CharsetDecoder} class should be used when more control
 455      * over the decoding process is required.
 456      *
 457      * @param  bytes
 458      *         The bytes to be decoded into characters
 459      *
 460      * @param  offset
 461      *         The index of the first byte to decode
 462      *
 463      * @param  length
 464      *         The number of bytes to decode
<span class="line-modified"> 465      *</span>
 466      * @param  charsetName
 467      *         The name of a supported {@linkplain java.nio.charset.Charset
 468      *         charset}
 469      *
 470      * @throws  UnsupportedEncodingException
 471      *          If the named charset is not supported
 472      *
 473      * @throws  IndexOutOfBoundsException
 474      *          If {@code offset} is negative, {@code length} is negative, or
 475      *          {@code offset} is greater than {@code bytes.length - length}
 476      *
 477      * @since  1.1
 478      */
 479     public String(byte bytes[], int offset, int length, String charsetName)
 480             throws UnsupportedEncodingException {
 481         if (charsetName == null)
 482             throw new NullPointerException(&quot;charsetName&quot;);
 483         checkBoundsOffCount(offset, length, bytes.length);
 484         StringCoding.Result ret =
 485             StringCoding.decode(charsetName, bytes, offset, length);
</pre>
<hr />
<pre>
1366      * this {@code String} object to be compared begins at index
1367      * {@code toffset} and has length {@code len}. The substring of
1368      * {@code other} to be compared begins at index {@code ooffset} and
1369      * has length {@code len}. The result is {@code false} if and only if
1370      * at least one of the following is true:
1371      * &lt;ul&gt;&lt;li&gt;{@code toffset} is negative.
1372      * &lt;li&gt;{@code ooffset} is negative.
1373      * &lt;li&gt;{@code toffset+len} is greater than the length of this
1374      * {@code String} object.
1375      * &lt;li&gt;{@code ooffset+len} is greater than the length of the other
1376      * argument.
1377      * &lt;li&gt;{@code ignoreCase} is {@code false} and there is some nonnegative
1378      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1379      * &lt;blockquote&gt;&lt;pre&gt;
1380      * this.charAt(toffset+k) != other.charAt(ooffset+k)
1381      * &lt;/pre&gt;&lt;/blockquote&gt;
1382      * &lt;li&gt;{@code ignoreCase} is {@code true} and there is some nonnegative
1383      * integer &lt;i&gt;k&lt;/i&gt; less than {@code len} such that:
1384      * &lt;blockquote&gt;&lt;pre&gt;
1385      * Character.toLowerCase(Character.toUpperCase(this.charAt(toffset+k))) !=
<span class="line-modified">1386      * Character.toLowerCase(Character.toUpperCase(other.charAt(ooffset+k)))</span>
1387      * &lt;/pre&gt;&lt;/blockquote&gt;
1388      * &lt;/ul&gt;
1389      *
1390      * &lt;p&gt;Note that this method does &lt;em&gt;not&lt;/em&gt; take locale into account,
1391      * and will result in unsatisfactory results for certain locales when
1392      * {@code ignoreCase} is {@code true}.  The {@link java.text.Collator} class
1393      * provides locale-sensitive comparison.
1394      *
1395      * @param   ignoreCase   if {@code true}, ignore case when comparing
1396      *                       characters.
1397      * @param   toffset      the starting offset of the subregion in this
1398      *                       string.
1399      * @param   other        the string argument.
1400      * @param   ooffset      the starting offset of the subregion in the string
1401      *                       argument.
1402      * @param   len          the number of characters to compare.
1403      * @return  {@code true} if the specified subregion of this string
1404      *          matches the specified subregion of the string argument;
1405      *          {@code false} otherwise. Whether the matching is exact
1406      *          or case insensitive depends on the {@code ignoreCase}
</pre>
<hr />
<pre>
2046      * @param s the sequence to search for
2047      * @return true if this string contains {@code s}, false otherwise
2048      * @since 1.5
2049      */
2050     public boolean contains(CharSequence s) {
2051         return indexOf(s.toString()) &gt;= 0;
2052     }
2053 
2054     /**
2055      * Replaces the first substring of this string that matches the given &lt;a
2056      * href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt; with the
2057      * given replacement.
2058      *
2059      * &lt;p&gt; An invocation of this method of the form
2060      * &lt;i&gt;str&lt;/i&gt;{@code .replaceFirst(}&lt;i&gt;regex&lt;/i&gt;{@code ,} &lt;i&gt;repl&lt;/i&gt;{@code )}
2061      * yields exactly the same result as the expression
2062      *
2063      * &lt;blockquote&gt;
2064      * &lt;code&gt;
2065      * {@link java.util.regex.Pattern}.{@link
<span class="line-modified">2066      * java.util.regex.Pattern#compile(String) compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span>
2067      * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(&lt;i&gt;str&lt;/i&gt;).{@link
<span class="line-modified">2068      * java.util.regex.Matcher#replaceFirst(String) replaceFirst}(&lt;i&gt;repl&lt;/i&gt;)</span>
2069      * &lt;/code&gt;
2070      * &lt;/blockquote&gt;
2071      *
2072      *&lt;p&gt;
2073      * Note that backslashes ({@code \}) and dollar signs ({@code $}) in the
2074      * replacement string may cause the results to be different than if it were
2075      * being treated as a literal replacement string; see
2076      * {@link java.util.regex.Matcher#replaceFirst}.
2077      * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special
2078      * meaning of these characters, if desired.
2079      *
2080      * @param   regex
2081      *          the regular expression to which this string is to be matched
2082      * @param   replacement
2083      *          the string to be substituted for the first match
2084      *
2085      * @return  The resulting {@code String}
2086      *
2087      * @throws  PatternSyntaxException
2088      *          if the regular expression&#39;s syntax is invalid
</pre>
<hr />
<pre>
2091      *
2092      * @since 1.4
2093      * @spec JSR-51
2094      */
2095     public String replaceFirst(String regex, String replacement) {
2096         return Pattern.compile(regex).matcher(this).replaceFirst(replacement);
2097     }
2098 
2099     /**
2100      * Replaces each substring of this string that matches the given &lt;a
2101      * href=&quot;../util/regex/Pattern.html#sum&quot;&gt;regular expression&lt;/a&gt; with the
2102      * given replacement.
2103      *
2104      * &lt;p&gt; An invocation of this method of the form
2105      * &lt;i&gt;str&lt;/i&gt;{@code .replaceAll(}&lt;i&gt;regex&lt;/i&gt;{@code ,} &lt;i&gt;repl&lt;/i&gt;{@code )}
2106      * yields exactly the same result as the expression
2107      *
2108      * &lt;blockquote&gt;
2109      * &lt;code&gt;
2110      * {@link java.util.regex.Pattern}.{@link
<span class="line-modified">2111      * java.util.regex.Pattern#compile(String) compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span>
2112      * java.util.regex.Pattern#matcher(java.lang.CharSequence) matcher}(&lt;i&gt;str&lt;/i&gt;).{@link
<span class="line-modified">2113      * java.util.regex.Matcher#replaceAll(String) replaceAll}(&lt;i&gt;repl&lt;/i&gt;)</span>
2114      * &lt;/code&gt;
2115      * &lt;/blockquote&gt;
2116      *
2117      *&lt;p&gt;
2118      * Note that backslashes ({@code \}) and dollar signs ({@code $}) in the
2119      * replacement string may cause the results to be different than if it were
2120      * being treated as a literal replacement string; see
2121      * {@link java.util.regex.Matcher#replaceAll Matcher.replaceAll}.
2122      * Use {@link java.util.regex.Matcher#quoteReplacement} to suppress the special
2123      * meaning of these characters, if desired.
2124      *
2125      * @param   regex
2126      *          the regular expression to which this string is to be matched
2127      * @param   replacement
2128      *          the string to be substituted for each match
2129      *
2130      * @return  The resulting {@code String}
2131      *
2132      * @throws  PatternSyntaxException
2133      *          if the regular expression&#39;s syntax is invalid
</pre>
<hr />
<pre>
2258      *     &lt;td&gt;{@code { &quot;boo&quot;, &quot;and&quot;, &quot;foo&quot; }}&lt;/td&gt;&lt;/tr&gt;
2259      * &lt;tr&gt;&lt;th scope=&quot;row&quot; rowspan=&quot;3&quot; style=&quot;font-weight:normal&quot;&gt;o&lt;/th&gt;
2260      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;5&lt;/th&gt;
2261      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
2262      * &lt;tr&gt;&lt;!-- o --&gt;
2263      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;-2&lt;/th&gt;
2264      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot;, &quot;&quot;, &quot;&quot; }}&lt;/td&gt;&lt;/tr&gt;
2265      * &lt;tr&gt;&lt;!-- o --&gt;
2266      *     &lt;th scope=&quot;row&quot; style=&quot;font-weight:normal; text-align:right; padding-right:1em&quot;&gt;0&lt;/th&gt;
2267      *     &lt;td&gt;{@code { &quot;b&quot;, &quot;&quot;, &quot;:and:f&quot; }}&lt;/td&gt;&lt;/tr&gt;
2268      * &lt;/tbody&gt;
2269      * &lt;/table&gt;&lt;/blockquote&gt;
2270      *
2271      * &lt;p&gt; An invocation of this method of the form
2272      * &lt;i&gt;str.&lt;/i&gt;{@code split(}&lt;i&gt;regex&lt;/i&gt;{@code ,}&amp;nbsp;&lt;i&gt;n&lt;/i&gt;{@code )}
2273      * yields the same result as the expression
2274      *
2275      * &lt;blockquote&gt;
2276      * &lt;code&gt;
2277      * {@link java.util.regex.Pattern}.{@link
<span class="line-modified">2278      * java.util.regex.Pattern#compile(String) compile}(&lt;i&gt;regex&lt;/i&gt;).{@link</span>
2279      * java.util.regex.Pattern#split(java.lang.CharSequence,int) split}(&lt;i&gt;str&lt;/i&gt;,&amp;nbsp;&lt;i&gt;n&lt;/i&gt;)
2280      * &lt;/code&gt;
2281      * &lt;/blockquote&gt;
2282      *
2283      *
2284      * @param  regex
2285      *         the delimiting regular expression
2286      *
2287      * @param  limit
2288      *         the result threshold, as described above
2289      *
2290      * @return  the array of strings computed by splitting this string
2291      *          around matches of the given regular expression
2292      *
2293      * @throws  PatternSyntaxException
2294      *          if the regular expression&#39;s syntax is invalid
2295      *
2296      * @see java.util.regex.Pattern
2297      *
2298      * @since 1.4
2299      * @spec JSR-51
2300      */
2301     public String[] split(String regex, int limit) {
2302         /* fastpath if the regex is a
<span class="line-modified">2303          * (1) one-char String and this character is not one of the</span>
<span class="line-modified">2304          *     RegEx&#39;s meta characters &quot;.$|()[{^?*+\\&quot;, or</span>
<span class="line-modified">2305          * (2) two-char String and the first char is the backslash and</span>
<span class="line-modified">2306          *     the second is not the ascii digit or ascii letter.</span>
2307          */
2308         char ch = 0;
2309         if (((regex.length() == 1 &amp;&amp;
2310              &quot;.$|()[{^?*+\\&quot;.indexOf(ch = regex.charAt(0)) == -1) ||
2311              (regex.length() == 2 &amp;&amp;
2312               regex.charAt(0) == &#39;\\&#39; &amp;&amp;
2313               (((ch = regex.charAt(1))-&#39;0&#39;)|(&#39;9&#39;-ch)) &lt; 0 &amp;&amp;
2314               ((ch-&#39;a&#39;)|(&#39;z&#39;-ch)) &lt; 0 &amp;&amp;
2315               ((ch-&#39;A&#39;)|(&#39;Z&#39;-ch)) &lt; 0)) &amp;&amp;
2316             (ch &lt; Character.MIN_HIGH_SURROGATE ||
2317              ch &gt; Character.MAX_LOW_SURROGATE))
2318         {
2319             int off = 0;
2320             int next = 0;
2321             boolean limited = limit &gt; 0;
2322             ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();
2323             while ((next = indexOf(ch, off)) != -1) {
2324                 if (!limited || list.size() &lt; limit - 1) {
2325                     list.add(substring(off, next));
2326                     off = next + 1;
</pre>
<hr />
<pre>
2428     public static String join(CharSequence delimiter, CharSequence... elements) {
2429         Objects.requireNonNull(delimiter);
2430         Objects.requireNonNull(elements);
2431         // Number of elements not likely worth Arrays.stream overhead.
2432         StringJoiner joiner = new StringJoiner(delimiter);
2433         for (CharSequence cs: elements) {
2434             joiner.add(cs);
2435         }
2436         return joiner.toString();
2437     }
2438 
2439     /**
2440      * Returns a new {@code String} composed of copies of the
2441      * {@code CharSequence elements} joined together with a copy of the
2442      * specified {@code delimiter}.
2443      *
2444      * &lt;blockquote&gt;For example,
2445      * &lt;pre&gt;{@code
2446      *     List&lt;String&gt; strings = List.of(&quot;Java&quot;, &quot;is&quot;, &quot;cool&quot;);
2447      *     String message = String.join(&quot; &quot;, strings);
<span class="line-modified">2448      *     // message returned is: &quot;Java is cool&quot;</span>
2449      *
2450      *     Set&lt;String&gt; strings =
2451      *         new LinkedHashSet&lt;&gt;(List.of(&quot;Java&quot;, &quot;is&quot;, &quot;very&quot;, &quot;cool&quot;));
2452      *     String message = String.join(&quot;-&quot;, strings);
<span class="line-modified">2453      *     // message returned is: &quot;Java-is-very-cool&quot;</span>
2454      * }&lt;/pre&gt;&lt;/blockquote&gt;
2455      *
2456      * Note that if an individual element is {@code null}, then {@code &quot;null&quot;} is added.
2457      *
2458      * @param  delimiter a sequence of characters that is used to separate each
2459      *         of the {@code elements} in the resulting {@code String}
2460      * @param  elements an {@code Iterable} that will have its {@code elements}
2461      *         joined together.
2462      *
2463      * @return a new {@code String} that is composed from the {@code elements}
2464      *         argument
2465      *
2466      * @throws NullPointerException If {@code delimiter} or {@code elements}
2467      *         is {@code null}
2468      *
2469      * @see    #join(CharSequence,CharSequence...)
2470      * @see    java.util.StringJoiner
2471      * @since 1.8
2472      */
2473     public static String join(CharSequence delimiter,
</pre>
<hr />
<pre>
2956      * If this string ends with a line terminator then the result will end
2957      * with a line terminator.
2958      *
2959      * @implNote
2960      * This method treats all {@linkplain Character#isWhitespace(int) white space}
2961      * characters as having equal width. As long as the indentation on every
2962      * line is consistently composed of the same character sequences, then the
2963      * result will be as described above.
2964      *
2965      * @return string with incidental indentation removed and line
2966      *         terminators normalized
2967      *
2968      * @see String#lines()
2969      * @see String#isBlank()
2970      * @see String#indent(int)
2971      * @see Character#isWhitespace(int)
2972      *
2973      * @since 13
2974      *
2975      */


2976     public String stripIndent() {
2977         int length = length();
2978         if (length == 0) {
2979             return &quot;&quot;;
2980         }
2981         char lastChar = charAt(length - 1);
2982         boolean optOut = lastChar == &#39;\n&#39; || lastChar == &#39;\r&#39;;
2983         List&lt;String&gt; lines = lines().collect(Collectors.toList());
2984         final int outdent = optOut ? 0 : outdent(lines);
2985         return lines.stream()
2986             .map(line -&gt; {
2987                 int firstNonWhitespace = line.indexOfNonWhitespace();
2988                 int lastNonWhitespace = line.lastIndexOfNonWhitespace();
2989                 int incidentalWhitespace = Math.min(outdent, firstNonWhitespace);
2990                 return firstNonWhitespace &gt; lastNonWhitespace
2991                     ? &quot;&quot; : line.substring(incidentalWhitespace, lastNonWhitespace);
2992             })
2993             .collect(Collectors.joining(&quot;\n&quot;, &quot;&quot;, optOut ? &quot;\n&quot; : &quot;&quot;));
2994     }
2995 
</pre>
<hr />
<pre>
3088      *     &lt;th scope=&quot;row&quot;&gt;{@code \u005C&lt;line-terminator&gt;}&lt;/th&gt;
3089      *     &lt;td&gt;continuation&lt;/td&gt;
3090      *     &lt;td&gt;discard&lt;/td&gt;
3091      *   &lt;/tr&gt;
3092      *   &lt;/tbody&gt;
3093      * &lt;/table&gt;
3094      *
3095      * @implNote
3096      * This method does &lt;em&gt;not&lt;/em&gt; translate Unicode escapes such as &quot;{@code \u005cu2022}&quot;.
3097      * Unicode escapes are translated by the Java compiler when reading input characters and
3098      * are not part of the string literal specification.
3099      *
3100      * @throws IllegalArgumentException when an escape sequence is malformed.
3101      *
3102      * @return String with escape sequences translated.
3103      *
3104      * @jls 3.10.7 Escape Sequences
3105      *
3106      * @since 13
3107      */


3108     public String translateEscapes() {
3109         if (isEmpty()) {
3110             return &quot;&quot;;
3111         }
3112         char[] chars = toCharArray();
3113         int length = chars.length;
3114         int from = 0;
3115         int to = 0;
3116         while (from &lt; length) {
3117             char ch = chars[from++];
3118             if (ch == &#39;\\&#39;) {
3119                 ch = from &lt; length ? chars[from++] : &#39;\0&#39;;
3120                 switch (ch) {
3121                 case &#39;b&#39;:
3122                     ch = &#39;\b&#39;;
3123                     break;
3124                 case &#39;f&#39;:
3125                     ch = &#39;\f&#39;;
3126                     break;
3127                 case &#39;n&#39;:
</pre>
<hr />
<pre>
3348      *           method when preview features are enabled. Preview features
3349      *           may be removed in a future release, or upgraded to permanent
3350      *           features of the Java language.}
3351      *
3352      * Formats using this string as the format string, and the supplied
3353      * arguments.
3354      *
3355      * @implSpec This method is equivalent to {@code String.format(this, args)}.
3356      *
3357      * @param  args
3358      *         Arguments referenced by the format specifiers in this string.
3359      *
3360      * @return  A formatted string
3361      *
3362      * @see  java.lang.String#format(String,Object...)
3363      * @see  java.util.Formatter
3364      *
3365      * @since 13
3366      *
3367      */


3368     public String formatted(Object... args) {
3369         return new Formatter().format(this, args).toString();
3370     }
3371 
3372     /**
3373      * Returns the string representation of the {@code Object} argument.
3374      *
3375      * @param   obj   an {@code Object}.
3376      * @return  if the argument is {@code null}, then a string equal to
3377      *          {@code &quot;null&quot;}; otherwise, the value of
3378      *          {@code obj.toString()} is returned.
3379      * @see     java.lang.Object#toString()
3380      */
3381     public static String valueOf(Object obj) {
3382         return (obj == null) ? &quot;null&quot; : obj.toString();
3383     }
3384 
3385     /**
3386      * Returns the string representation of the {@code char} array
3387      * argument. The contents of the character array are copied; subsequent
</pre>
</td>
</tr>
</table>
<center><a href="StrictMath.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="System.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
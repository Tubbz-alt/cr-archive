<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/classes/java/text/MessageFormat.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1996, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * (C) Copyright Taligent, Inc. 1996, 1997 - All Rights Reserved
  28  * (C) Copyright IBM Corp. 1996 - 1998 - All Rights Reserved
  29  *
  30  *   The original version of this source code and documentation is copyrighted
  31  * and owned by Taligent, Inc., a wholly-owned subsidiary of IBM. These
  32  * materials are provided under terms of a License Agreement between Taligent
  33  * and Sun. This technology is protected by multiple US and International
  34  * patents. This notice and attribution to Taligent may not be removed.
  35  *   Taligent is a registered trademark of Taligent, Inc.
  36  *
  37  */
  38 
  39 package java.text;
  40 
  41 import java.io.InvalidObjectException;
  42 import java.io.IOException;
  43 import java.io.ObjectInputStream;
  44 import java.text.DecimalFormat;
  45 import java.util.ArrayList;
  46 import java.util.Arrays;
  47 import java.util.Date;
  48 import java.util.List;
  49 import java.util.Locale;
  50 
  51 
  52 /**
  53  * {@code MessageFormat} provides a means to produce concatenated
  54  * messages in a language-neutral way. Use this to construct messages
  55  * displayed for end users.
  56  *
  57  * &lt;p&gt;
  58  * {@code MessageFormat} takes a set of objects, formats them, then
  59  * inserts the formatted strings into the pattern at the appropriate places.
  60  *
  61  * &lt;p&gt;
  62  * &lt;strong&gt;Note:&lt;/strong&gt;
  63  * {@code MessageFormat} differs from the other {@code Format}
  64  * classes in that you create a {@code MessageFormat} object with one
  65  * of its constructors (not with a {@code getInstance} style factory
  66  * method). The factory methods aren&#39;t necessary because {@code MessageFormat}
  67  * itself doesn&#39;t implement locale specific behavior. Any locale specific
  68  * behavior is defined by the pattern that you provide as well as the
  69  * subformats used for inserted arguments.
  70  *
  71  * &lt;h2&gt;&lt;a id=&quot;patterns&quot;&gt;Patterns and Their Interpretation&lt;/a&gt;&lt;/h2&gt;
  72  *
  73  * {@code MessageFormat} uses patterns of the following form:
  74  * &lt;blockquote&gt;&lt;pre&gt;
  75  * &lt;i&gt;MessageFormatPattern:&lt;/i&gt;
  76  *         &lt;i&gt;String&lt;/i&gt;
  77  *         &lt;i&gt;MessageFormatPattern&lt;/i&gt; &lt;i&gt;FormatElement&lt;/i&gt; &lt;i&gt;String&lt;/i&gt;
  78  *
  79  * &lt;i&gt;FormatElement:&lt;/i&gt;
  80  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; }
  81  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; }
  82  *         { &lt;i&gt;ArgumentIndex&lt;/i&gt; , &lt;i&gt;FormatType&lt;/i&gt; , &lt;i&gt;FormatStyle&lt;/i&gt; }
  83  *
  84  * &lt;i&gt;FormatType: one of &lt;/i&gt;
  85  *         number date time choice
  86  *
  87  * &lt;i&gt;FormatStyle:&lt;/i&gt;
  88  *         short
  89  *         medium
  90  *         long
  91  *         full
  92  *         integer
  93  *         currency
  94  *         percent
  95  *         &lt;i&gt;SubformatPattern&lt;/i&gt;
  96  * &lt;/pre&gt;&lt;/blockquote&gt;
  97  *
  98  * &lt;p&gt;Within a &lt;i&gt;String&lt;/i&gt;, a pair of single quotes can be used to
  99  * quote any arbitrary characters except single quotes. For example,
 100  * pattern string &lt;code&gt;&quot;&#39;{0}&#39;&quot;&lt;/code&gt; represents string
 101  * &lt;code&gt;&quot;{0}&quot;&lt;/code&gt;, not a &lt;i&gt;FormatElement&lt;/i&gt;. A single quote itself
 102  * must be represented by doubled single quotes {@code &#39;&#39;} throughout a
 103  * &lt;i&gt;String&lt;/i&gt;.  For example, pattern string &lt;code&gt;&quot;&#39;{&#39;&#39;}&#39;&quot;&lt;/code&gt; is
 104  * interpreted as a sequence of &lt;code&gt;&#39;{&lt;/code&gt; (start of quoting and a
 105  * left curly brace), {@code &#39;&#39;} (a single quote), and
 106  * &lt;code&gt;}&#39;&lt;/code&gt; (a right curly brace and end of quoting),
 107  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&#39;{&#39;&lt;/code&gt; and &lt;code&gt;&#39;}&#39;&lt;/code&gt; (quoted left and
 108  * right curly braces): representing string &lt;code&gt;&quot;{&#39;}&quot;&lt;/code&gt;,
 109  * &lt;em&gt;not&lt;/em&gt; &lt;code&gt;&quot;{}&quot;&lt;/code&gt;.
 110  *
 111  * &lt;p&gt;A &lt;i&gt;SubformatPattern&lt;/i&gt; is interpreted by its corresponding
 112  * subformat, and subformat-dependent pattern rules apply. For example,
 113  * pattern string &lt;code&gt;&quot;{1,number,&lt;u&gt;$&#39;#&#39;,##&lt;/u&gt;}&quot;&lt;/code&gt;
 114  * (&lt;i&gt;SubformatPattern&lt;/i&gt; with underline) will produce a number format
 115  * with the pound-sign quoted, with a result such as: {@code
 116  * &quot;$#31,45&quot;}. Refer to each {@code Format} subclass documentation for
 117  * details.
 118  *
 119  * &lt;p&gt;Any unmatched quote is treated as closed at the end of the given
 120  * pattern. For example, pattern string {@code &quot;&#39;{0}&quot;} is treated as
 121  * pattern {@code &quot;&#39;{0}&#39;&quot;}.
 122  *
 123  * &lt;p&gt;Any curly braces within an unquoted pattern must be balanced. For
 124  * example, &lt;code&gt;&quot;ab {0} de&quot;&lt;/code&gt; and &lt;code&gt;&quot;ab &#39;}&#39; de&quot;&lt;/code&gt; are
 125  * valid patterns, but &lt;code&gt;&quot;ab {0&#39;}&#39; de&quot;&lt;/code&gt;, &lt;code&gt;&quot;ab } de&quot;&lt;/code&gt;
 126  * and &lt;code&gt;&quot;&#39;&#39;{&#39;&#39;&quot;&lt;/code&gt; are not.
 127  *
 128  * &lt;dl&gt;&lt;dt&gt;&lt;b&gt;Warning:&lt;/b&gt;&lt;dd&gt;The rules for using quotes within message
 129  * format patterns unfortunately have shown to be somewhat confusing.
 130  * In particular, it isn&#39;t always obvious to localizers whether single
 131  * quotes need to be doubled or not. Make sure to inform localizers about
 132  * the rules, and tell them (for example, by using comments in resource
 133  * bundle source files) which strings will be processed by {@code MessageFormat}.
 134  * Note that localizers may need to use single quotes in translated
 135  * strings where the original version doesn&#39;t have them.
 136  * &lt;/dl&gt;
 137  * &lt;p&gt;
 138  * The &lt;i&gt;ArgumentIndex&lt;/i&gt; value is a non-negative integer written
 139  * using the digits {@code &#39;0&#39;} through {@code &#39;9&#39;}, and represents an index into the
 140  * {@code arguments} array passed to the {@code format} methods
 141  * or the result array returned by the {@code parse} methods.
 142  * &lt;p&gt;
 143  * The &lt;i&gt;FormatType&lt;/i&gt; and &lt;i&gt;FormatStyle&lt;/i&gt; values are used to create
 144  * a {@code Format} instance for the format element. The following
 145  * table shows how the values map to {@code Format} instances. Combinations not
 146  * shown in the table are illegal. A &lt;i&gt;SubformatPattern&lt;/i&gt; must
 147  * be a valid pattern string for the {@code Format} subclass used.
 148  *
 149  * &lt;table class=&quot;plain&quot;&gt;
 150  * &lt;caption style=&quot;display:none&quot;&gt;Shows how FormatType and FormatStyle values map to Format instances&lt;/caption&gt;
 151  * &lt;thead&gt;
 152  *    &lt;tr&gt;
 153  *       &lt;th scope=&quot;col&quot; class=&quot;TableHeadingColor&quot;&gt;FormatType
 154  *       &lt;th scope=&quot;col&quot; class=&quot;TableHeadingColor&quot;&gt;FormatStyle
 155  *       &lt;th scope=&quot;col&quot; class=&quot;TableHeadingColor&quot;&gt;Subformat Created
 156  * &lt;/thead&gt;
 157  * &lt;tbody&gt;
 158  *    &lt;tr&gt;
 159  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 160  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 161  *       &lt;td&gt;{@code null}
 162  *    &lt;tr&gt;
 163  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot; rowspan=5&gt;{@code number}
 164  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 165  *       &lt;td&gt;{@link NumberFormat#getInstance(Locale) NumberFormat.getInstance}{@code (getLocale())}
 166  *    &lt;tr&gt;
 167  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code integer}
 168  *       &lt;td&gt;{@link NumberFormat#getIntegerInstance(Locale) NumberFormat.getIntegerInstance}{@code (getLocale())}
 169  *    &lt;tr&gt;
 170  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code currency}
 171  *       &lt;td&gt;{@link NumberFormat#getCurrencyInstance(Locale) NumberFormat.getCurrencyInstance}{@code (getLocale())}
 172  *    &lt;tr&gt;
 173  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code percent}
 174  *       &lt;td&gt;{@link NumberFormat#getPercentInstance(Locale) NumberFormat.getPercentInstance}{@code (getLocale())}
 175  *    &lt;tr&gt;
 176  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 177  *       &lt;td&gt;{@code new} {@link DecimalFormat#DecimalFormat(String,DecimalFormatSymbols) DecimalFormat}{@code (subformatPattern,} {@link DecimalFormatSymbols#getInstance(Locale) DecimalFormatSymbols.getInstance}{@code (getLocale()))}
 178  *    &lt;tr&gt;
 179  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot; rowspan=6&gt;{@code date}
 180  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 181  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 182  *    &lt;tr&gt;
 183  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code short}
 184  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 185  *    &lt;tr&gt;
 186  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code medium}
 187  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 188  *    &lt;tr&gt;
 189  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code long}
 190  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 191  *    &lt;tr&gt;
 192  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code full}
 193  *       &lt;td&gt;{@link DateFormat#getDateInstance(int,Locale) DateFormat.getDateInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 194  *    &lt;tr&gt;
 195  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 196  *       &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 197  *    &lt;tr&gt;
 198  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot; rowspan=6&gt;{@code time}
 199  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;(none)&lt;/i&gt;
 200  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 201  *    &lt;tr&gt;
 202  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code short}
 203  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#SHORT}{@code , getLocale())}
 204  *    &lt;tr&gt;
 205  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code medium}
 206  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#DEFAULT}{@code , getLocale())}
 207  *    &lt;tr&gt;
 208  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code long}
 209  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#LONG}{@code , getLocale())}
 210  *    &lt;tr&gt;
 211  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code full}
 212  *       &lt;td&gt;{@link DateFormat#getTimeInstance(int,Locale) DateFormat.getTimeInstance}{@code (}{@link DateFormat#FULL}{@code , getLocale())}
 213  *    &lt;tr&gt;
 214  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 215  *       &lt;td&gt;{@code new} {@link SimpleDateFormat#SimpleDateFormat(String,Locale) SimpleDateFormat}{@code (subformatPattern, getLocale())}
 216  *    &lt;tr&gt;
 217  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;{@code choice}
 218  *       &lt;th scope=&quot;row&quot; style=&quot;text-weight: normal&quot;&gt;&lt;i&gt;SubformatPattern&lt;/i&gt;
 219  *       &lt;td&gt;{@code new} {@link ChoiceFormat#ChoiceFormat(String) ChoiceFormat}{@code (subformatPattern)}
 220  * &lt;/tbody&gt;
 221  * &lt;/table&gt;
 222  *
 223  * &lt;h3&gt;Usage Information&lt;/h3&gt;
 224  *
 225  * &lt;p&gt;
 226  * Here are some examples of usage.
 227  * In real internationalized programs, the message format pattern and other
 228  * static strings will, of course, be obtained from resource bundles.
 229  * Other parameters will be dynamically determined at runtime.
 230  * &lt;p&gt;
 231  * The first example uses the static method {@code MessageFormat.format},
 232  * which internally creates a {@code MessageFormat} for one-time use:
 233  * &lt;blockquote&gt;&lt;pre&gt;
 234  * int planet = 7;
 235  * String event = &quot;a disturbance in the Force&quot;;
 236  *
 237  * String result = MessageFormat.format(
 238  *     &quot;At {1,time} on {1,date}, there was {2} on planet {0,number,integer}.&quot;,
 239  *     planet, new Date(), event);
 240  * &lt;/pre&gt;&lt;/blockquote&gt;
 241  * The output is:
 242  * &lt;blockquote&gt;&lt;pre&gt;
 243  * At 12:30 PM on Jul 3, 2053, there was a disturbance in the Force on planet 7.
 244  * &lt;/pre&gt;&lt;/blockquote&gt;
 245  *
 246  * &lt;p&gt;
 247  * The following example creates a {@code MessageFormat} instance that
 248  * can be used repeatedly:
 249  * &lt;blockquote&gt;&lt;pre&gt;
 250  * int fileCount = 1273;
 251  * String diskName = &quot;MyDisk&quot;;
 252  * Object[] testArgs = {new Long(fileCount), diskName};
 253  *
 254  * MessageFormat form = new MessageFormat(
 255  *     &quot;The disk \&quot;{1}\&quot; contains {0} file(s).&quot;);
 256  *
 257  * System.out.println(form.format(testArgs));
 258  * &lt;/pre&gt;&lt;/blockquote&gt;
 259  * The output with different values for {@code fileCount}:
 260  * &lt;blockquote&gt;&lt;pre&gt;
 261  * The disk &quot;MyDisk&quot; contains 0 file(s).
 262  * The disk &quot;MyDisk&quot; contains 1 file(s).
 263  * The disk &quot;MyDisk&quot; contains 1,273 file(s).
 264  * &lt;/pre&gt;&lt;/blockquote&gt;
 265  *
 266  * &lt;p&gt;
 267  * For more sophisticated patterns, you can use a {@code ChoiceFormat}
 268  * to produce correct forms for singular and plural:
 269  * &lt;blockquote&gt;&lt;pre&gt;
 270  * MessageFormat form = new MessageFormat(&quot;The disk \&quot;{1}\&quot; contains {0}.&quot;);
 271  * double[] filelimits = {0,1,2};
 272  * String[] filepart = {&quot;no files&quot;,&quot;one file&quot;,&quot;{0,number} files&quot;};
 273  * ChoiceFormat fileform = new ChoiceFormat(filelimits, filepart);
 274  * form.setFormatByArgumentIndex(0, fileform);
 275  *
 276  * int fileCount = 1273;
 277  * String diskName = &quot;MyDisk&quot;;
 278  * Object[] testArgs = {new Long(fileCount), diskName};
 279  *
 280  * System.out.println(form.format(testArgs));
 281  * &lt;/pre&gt;&lt;/blockquote&gt;
 282  * The output with different values for {@code fileCount}:
 283  * &lt;blockquote&gt;&lt;pre&gt;
 284  * The disk &quot;MyDisk&quot; contains no files.
 285  * The disk &quot;MyDisk&quot; contains one file.
 286  * The disk &quot;MyDisk&quot; contains 1,273 files.
 287  * &lt;/pre&gt;&lt;/blockquote&gt;
 288  *
 289  * &lt;p&gt;
 290  * You can create the {@code ChoiceFormat} programmatically, as in the
 291  * above example, or by using a pattern. See {@link ChoiceFormat}
 292  * for more information.
 293  * &lt;blockquote&gt;&lt;pre&gt;{@code
 294  * form.applyPattern(
 295  *    &quot;There {0,choice,0#are no files|1#is one file|1&lt;are {0,number,integer} files}.&quot;);
 296  * }&lt;/pre&gt;&lt;/blockquote&gt;
 297  *
 298  * &lt;p&gt;
 299  * &lt;strong&gt;Note:&lt;/strong&gt; As we see above, the string produced
 300  * by a {@code ChoiceFormat} in {@code MessageFormat} is treated as special;
 301  * occurrences of &#39;{&#39; are used to indicate subformats, and cause recursion.
 302  * If you create both a {@code MessageFormat} and {@code ChoiceFormat}
 303  * programmatically (instead of using the string patterns), then be careful not to
 304  * produce a format that recurses on itself, which will cause an infinite loop.
 305  * &lt;p&gt;
 306  * When a single argument is parsed more than once in the string, the last match
 307  * will be the final result of the parsing.  For example,
 308  * &lt;blockquote&gt;&lt;pre&gt;
 309  * MessageFormat mf = new MessageFormat(&quot;{0,number,#.##}, {0,number,#.#}&quot;);
 310  * Object[] objs = {new Double(3.1415)};
 311  * String result = mf.format( objs );
 312  * // result now equals &quot;3.14, 3.1&quot;
 313  * objs = null;
 314  * objs = mf.parse(result, new ParsePosition(0));
 315  * // objs now equals {new Double(3.1)}
 316  * &lt;/pre&gt;&lt;/blockquote&gt;
 317  *
 318  * &lt;p&gt;
 319  * Likewise, parsing with a {@code MessageFormat} object using patterns containing
 320  * multiple occurrences of the same argument would return the last match.  For
 321  * example,
 322  * &lt;blockquote&gt;&lt;pre&gt;
 323  * MessageFormat mf = new MessageFormat(&quot;{0}, {0}, {0}&quot;);
 324  * String forParsing = &quot;x, y, z&quot;;
 325  * Object[] objs = mf.parse(forParsing, new ParsePosition(0));
 326  * // result now equals {new String(&quot;z&quot;)}
 327  * &lt;/pre&gt;&lt;/blockquote&gt;
 328  *
 329  * &lt;h3&gt;&lt;a id=&quot;synchronization&quot;&gt;Synchronization&lt;/a&gt;&lt;/h3&gt;
 330  *
 331  * &lt;p&gt;
 332  * Message formats are not synchronized.
 333  * It is recommended to create separate format instances for each thread.
 334  * If multiple threads access a format concurrently, it must be synchronized
 335  * externally.
 336  *
 337  * @see          java.util.Locale
 338  * @see          Format
 339  * @see          NumberFormat
 340  * @see          DecimalFormat
 341  * @see          DecimalFormatSymbols
 342  * @see          ChoiceFormat
 343  * @see          DateFormat
 344  * @see          SimpleDateFormat
 345  *
 346  * @author       Mark Davis
 347  * @since 1.1
 348  */
 349 
 350 public class MessageFormat extends Format {
 351 
 352     @java.io.Serial
 353     private static final long serialVersionUID = 6479157306784022952L;
 354 
 355     /**
 356      * Constructs a MessageFormat for the default
 357      * {@link java.util.Locale.Category#FORMAT FORMAT} locale and the
 358      * specified pattern.
 359      * The constructor first sets the locale, then parses the pattern and
 360      * creates a list of subformats for the format elements contained in it.
 361      * Patterns and their interpretation are specified in the
 362      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 363      *
 364      * @param pattern the pattern for this message format
 365      * @throws    IllegalArgumentException if the pattern is invalid
 366      * @throws    NullPointerException if {@code pattern} is
 367      *            {@code null}
 368      */
 369     public MessageFormat(String pattern) {
 370         this.locale = Locale.getDefault(Locale.Category.FORMAT);
 371         applyPattern(pattern);
 372     }
 373 
 374     /**
 375      * Constructs a MessageFormat for the specified locale and
 376      * pattern.
 377      * The constructor first sets the locale, then parses the pattern and
 378      * creates a list of subformats for the format elements contained in it.
 379      * Patterns and their interpretation are specified in the
 380      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 381      *
 382      * @param pattern the pattern for this message format
 383      * @param locale the locale for this message format
 384      * @throws    IllegalArgumentException if the pattern is invalid
 385      * @throws    NullPointerException if {@code pattern} is
 386      *            {@code null}
 387      * @since 1.4
 388      */
 389     public MessageFormat(String pattern, Locale locale) {
 390         this.locale = locale;
 391         applyPattern(pattern);
 392     }
 393 
 394     /**
 395      * Sets the locale to be used when creating or comparing subformats.
 396      * This affects subsequent calls
 397      * &lt;ul&gt;
 398      * &lt;li&gt;to the {@link #applyPattern applyPattern}
 399      *     and {@link #toPattern toPattern} methods if format elements specify
 400      *     a format type and therefore have the subformats created in the
 401      *     {@code applyPattern} method, as well as
 402      * &lt;li&gt;to the {@code format} and
 403      *     {@link #formatToCharacterIterator formatToCharacterIterator} methods
 404      *     if format elements do not specify a format type and therefore have
 405      *     the subformats created in the formatting methods.
 406      * &lt;/ul&gt;
 407      * Subformats that have already been created are not affected.
 408      *
 409      * @param locale the locale to be used when creating or comparing subformats
 410      */
 411     public void setLocale(Locale locale) {
 412         this.locale = locale;
 413     }
 414 
 415     /**
 416      * Gets the locale that&#39;s used when creating or comparing subformats.
 417      *
 418      * @return the locale used when creating or comparing subformats
 419      */
 420     public Locale getLocale() {
 421         return locale;
 422     }
 423 
 424 
 425     /**
 426      * Sets the pattern used by this message format.
 427      * The method parses the pattern and creates a list of subformats
 428      * for the format elements contained in it.
 429      * Patterns and their interpretation are specified in the
 430      * &lt;a href=&quot;#patterns&quot;&gt;class description&lt;/a&gt;.
 431      *
 432      * @param pattern the pattern for this message format
 433      * @throws    IllegalArgumentException if the pattern is invalid
 434      * @throws    NullPointerException if {@code pattern} is
 435      *            {@code null}
 436      */
 437     @SuppressWarnings(&quot;fallthrough&quot;) // fallthrough in switch is expected, suppress it
 438     public void applyPattern(String pattern) {
 439             StringBuilder[] segments = new StringBuilder[4];
 440             // Allocate only segments[SEG_RAW] here. The rest are
 441             // allocated on demand.
 442             segments[SEG_RAW] = new StringBuilder();
 443 
 444             int part = SEG_RAW;
 445             int formatNumber = 0;
 446             boolean inQuote = false;
 447             int braceStack = 0;
 448             maxOffset = -1;
 449             for (int i = 0; i &lt; pattern.length(); ++i) {
 450                 char ch = pattern.charAt(i);
 451                 if (part == SEG_RAW) {
 452                     if (ch == &#39;\&#39;&#39;) {
 453                         if (i + 1 &lt; pattern.length()
 454                             &amp;&amp; pattern.charAt(i+1) == &#39;\&#39;&#39;) {
 455                             segments[part].append(ch);  // handle doubles
 456                             ++i;
 457                         } else {
 458                             inQuote = !inQuote;
 459                         }
 460                     } else if (ch == &#39;{&#39; &amp;&amp; !inQuote) {
 461                         part = SEG_INDEX;
 462                         if (segments[SEG_INDEX] == null) {
 463                             segments[SEG_INDEX] = new StringBuilder();
 464                         }
 465                     } else {
 466                         segments[part].append(ch);
 467                     }
 468                 } else  {
 469                     if (inQuote) {              // just copy quotes in parts
 470                         segments[part].append(ch);
 471                         if (ch == &#39;\&#39;&#39;) {
 472                             inQuote = false;
 473                         }
 474                     } else {
 475                         switch (ch) {
 476                         case &#39;,&#39;:
 477                             if (part &lt; SEG_MODIFIER) {
 478                                 if (segments[++part] == null) {
 479                                     segments[part] = new StringBuilder();
 480                                 }
 481                             } else {
 482                                 segments[part].append(ch);
 483                             }
 484                             break;
 485                         case &#39;{&#39;:
 486                             ++braceStack;
 487                             segments[part].append(ch);
 488                             break;
 489                         case &#39;}&#39;:
 490                             if (braceStack == 0) {
 491                                 part = SEG_RAW;
 492                                 makeFormat(i, formatNumber, segments);
 493                                 formatNumber++;
 494                                 // throw away other segments
 495                                 segments[SEG_INDEX] = null;
 496                                 segments[SEG_TYPE] = null;
 497                                 segments[SEG_MODIFIER] = null;
 498                             } else {
 499                                 --braceStack;
 500                                 segments[part].append(ch);
 501                             }
 502                             break;
 503                         case &#39; &#39;:
 504                             // Skip any leading space chars for SEG_TYPE.
 505                             if (part != SEG_TYPE || segments[SEG_TYPE].length() &gt; 0) {
 506                                 segments[part].append(ch);
 507                             }
 508                             break;
 509                         case &#39;\&#39;&#39;:
 510                             inQuote = true;
 511                             // fall through, so we keep quotes in other parts
 512                         default:
 513                             segments[part].append(ch);
 514                             break;
 515                         }
 516                     }
 517                 }
 518             }
 519             if (braceStack == 0 &amp;&amp; part != 0) {
 520                 maxOffset = -1;
 521                 throw new IllegalArgumentException(&quot;Unmatched braces in the pattern.&quot;);
 522             }
 523             this.pattern = segments[0].toString();
 524     }
 525 
 526 
 527     /**
 528      * Returns a pattern representing the current state of the message format.
 529      * The string is constructed from internal information and therefore
 530      * does not necessarily equal the previously applied pattern.
 531      *
 532      * @return a pattern representing the current state of the message format
 533      */
 534     public String toPattern() {
 535         // later, make this more extensible
 536         int lastOffset = 0;
 537         StringBuilder result = new StringBuilder();
 538         for (int i = 0; i &lt;= maxOffset; ++i) {
 539             copyAndFixQuotes(pattern, lastOffset, offsets[i], result);
 540             lastOffset = offsets[i];
 541             result.append(&#39;{&#39;).append(argumentNumbers[i]);
 542             Format fmt = formats[i];
 543             if (fmt == null) {
 544                 // do nothing, string format
 545             } else if (fmt instanceof NumberFormat) {
 546                 if (fmt.equals(NumberFormat.getInstance(locale))) {
 547                     result.append(&quot;,number&quot;);
 548                 } else if (fmt.equals(NumberFormat.getCurrencyInstance(locale))) {
 549                     result.append(&quot;,number,currency&quot;);
 550                 } else if (fmt.equals(NumberFormat.getPercentInstance(locale))) {
 551                     result.append(&quot;,number,percent&quot;);
 552                 } else if (fmt.equals(NumberFormat.getIntegerInstance(locale))) {
 553                     result.append(&quot;,number,integer&quot;);
 554                 } else {
 555                     if (fmt instanceof DecimalFormat) {
 556                         result.append(&quot;,number,&quot;).append(((DecimalFormat)fmt).toPattern());
 557                     } else if (fmt instanceof ChoiceFormat) {
 558                         result.append(&quot;,choice,&quot;).append(((ChoiceFormat)fmt).toPattern());
 559                     } else {
 560                         // UNKNOWN
 561                     }
 562                 }
 563             } else if (fmt instanceof DateFormat) {
 564                 int index;
 565                 for (index = MODIFIER_DEFAULT; index &lt; DATE_TIME_MODIFIERS.length; index++) {
 566                     DateFormat df = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[index],
 567                                                                locale);
 568                     if (fmt.equals(df)) {
 569                         result.append(&quot;,date&quot;);
 570                         break;
 571                     }
 572                     df = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[index],
 573                                                     locale);
 574                     if (fmt.equals(df)) {
 575                         result.append(&quot;,time&quot;);
 576                         break;
 577                     }
 578                 }
 579                 if (index &gt;= DATE_TIME_MODIFIERS.length) {
 580                     if (fmt instanceof SimpleDateFormat) {
 581                         result.append(&quot;,date,&quot;).append(((SimpleDateFormat)fmt).toPattern());
 582                     } else {
 583                         // UNKNOWN
 584                     }
 585                 } else if (index != MODIFIER_DEFAULT) {
 586                     result.append(&#39;,&#39;).append(DATE_TIME_MODIFIER_KEYWORDS[index]);
 587                 }
 588             } else {
 589                 //result.append(&quot;, unknown&quot;);
 590             }
 591             result.append(&#39;}&#39;);
 592         }
 593         copyAndFixQuotes(pattern, lastOffset, pattern.length(), result);
 594         return result.toString();
 595     }
 596 
 597     /**
 598      * Sets the formats to use for the values passed into
 599      * {@code format} methods or returned from {@code parse}
 600      * methods. The indices of elements in {@code newFormats}
 601      * correspond to the argument indices used in the previously set
 602      * pattern string.
 603      * The order of formats in {@code newFormats} thus corresponds to
 604      * the order of elements in the {@code arguments} array passed
 605      * to the {@code format} methods or the result array returned
 606      * by the {@code parse} methods.
 607      * &lt;p&gt;
 608      * If an argument index is used for more than one format element
 609      * in the pattern string, then the corresponding new format is used
 610      * for all such format elements. If an argument index is not used
 611      * for any format element in the pattern string, then the
 612      * corresponding new format is ignored. If fewer formats are provided
 613      * than needed, then only the formats for argument indices less
 614      * than {@code newFormats.length} are replaced.
 615      *
 616      * @param newFormats the new formats to use
 617      * @throws    NullPointerException if {@code newFormats} is null
 618      * @since 1.4
 619      */
 620     public void setFormatsByArgumentIndex(Format[] newFormats) {
 621         for (int i = 0; i &lt;= maxOffset; i++) {
 622             int j = argumentNumbers[i];
 623             if (j &lt; newFormats.length) {
 624                 formats[i] = newFormats[j];
 625             }
 626         }
 627     }
 628 
 629     /**
 630      * Sets the formats to use for the format elements in the
 631      * previously set pattern string.
 632      * The order of formats in {@code newFormats} corresponds to
 633      * the order of format elements in the pattern string.
 634      * &lt;p&gt;
 635      * If more formats are provided than needed by the pattern string,
 636      * the remaining ones are ignored. If fewer formats are provided
 637      * than needed, then only the first {@code newFormats.length}
 638      * formats are replaced.
 639      * &lt;p&gt;
 640      * Since the order of format elements in a pattern string often
 641      * changes during localization, it is generally better to use the
 642      * {@link #setFormatsByArgumentIndex setFormatsByArgumentIndex}
 643      * method, which assumes an order of formats corresponding to the
 644      * order of elements in the {@code arguments} array passed to
 645      * the {@code format} methods or the result array returned by
 646      * the {@code parse} methods.
 647      *
 648      * @param newFormats the new formats to use
 649      * @throws    NullPointerException if {@code newFormats} is null
 650      */
 651     public void setFormats(Format[] newFormats) {
 652         int runsToCopy = newFormats.length;
 653         if (runsToCopy &gt; maxOffset + 1) {
 654             runsToCopy = maxOffset + 1;
 655         }
 656         for (int i = 0; i &lt; runsToCopy; i++) {
 657             formats[i] = newFormats[i];
 658         }
 659     }
 660 
 661     /**
 662      * Sets the format to use for the format elements within the
 663      * previously set pattern string that use the given argument
 664      * index.
 665      * The argument index is part of the format element definition and
 666      * represents an index into the {@code arguments} array passed
 667      * to the {@code format} methods or the result array returned
 668      * by the {@code parse} methods.
 669      * &lt;p&gt;
 670      * If the argument index is used for more than one format element
 671      * in the pattern string, then the new format is used for all such
 672      * format elements. If the argument index is not used for any format
 673      * element in the pattern string, then the new format is ignored.
 674      *
 675      * @param argumentIndex the argument index for which to use the new format
 676      * @param newFormat the new format to use
 677      * @since 1.4
 678      */
 679     public void setFormatByArgumentIndex(int argumentIndex, Format newFormat) {
 680         for (int j = 0; j &lt;= maxOffset; j++) {
 681             if (argumentNumbers[j] == argumentIndex) {
 682                 formats[j] = newFormat;
 683             }
 684         }
 685     }
 686 
 687     /**
 688      * Sets the format to use for the format element with the given
 689      * format element index within the previously set pattern string.
 690      * The format element index is the zero-based number of the format
 691      * element counting from the start of the pattern string.
 692      * &lt;p&gt;
 693      * Since the order of format elements in a pattern string often
 694      * changes during localization, it is generally better to use the
 695      * {@link #setFormatByArgumentIndex setFormatByArgumentIndex}
 696      * method, which accesses format elements based on the argument
 697      * index they specify.
 698      *
 699      * @param formatElementIndex the index of a format element within the pattern
 700      * @param newFormat the format to use for the specified format element
 701      * @throws    ArrayIndexOutOfBoundsException if {@code formatElementIndex} is equal to or
 702      *            larger than the number of format elements in the pattern string
 703      */
 704     public void setFormat(int formatElementIndex, Format newFormat) {
 705 
 706         if (formatElementIndex &gt; maxOffset) {
 707             throw new ArrayIndexOutOfBoundsException(formatElementIndex);
 708         }
 709         formats[formatElementIndex] = newFormat;
 710     }
 711 
 712     /**
 713      * Gets the formats used for the values passed into
 714      * {@code format} methods or returned from {@code parse}
 715      * methods. The indices of elements in the returned array
 716      * correspond to the argument indices used in the previously set
 717      * pattern string.
 718      * The order of formats in the returned array thus corresponds to
 719      * the order of elements in the {@code arguments} array passed
 720      * to the {@code format} methods or the result array returned
 721      * by the {@code parse} methods.
 722      * &lt;p&gt;
 723      * If an argument index is used for more than one format element
 724      * in the pattern string, then the format used for the last such
 725      * format element is returned in the array. If an argument index
 726      * is not used for any format element in the pattern string, then
 727      * null is returned in the array.
 728      *
 729      * @return the formats used for the arguments within the pattern
 730      * @since 1.4
 731      */
 732     public Format[] getFormatsByArgumentIndex() {
 733         int maximumArgumentNumber = -1;
 734         for (int i = 0; i &lt;= maxOffset; i++) {
 735             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 736                 maximumArgumentNumber = argumentNumbers[i];
 737             }
 738         }
 739         Format[] resultArray = new Format[maximumArgumentNumber + 1];
 740         for (int i = 0; i &lt;= maxOffset; i++) {
 741             resultArray[argumentNumbers[i]] = formats[i];
 742         }
 743         return resultArray;
 744     }
 745 
 746     /**
 747      * Gets the formats used for the format elements in the
 748      * previously set pattern string.
 749      * The order of formats in the returned array corresponds to
 750      * the order of format elements in the pattern string.
 751      * &lt;p&gt;
 752      * Since the order of format elements in a pattern string often
 753      * changes during localization, it&#39;s generally better to use the
 754      * {@link #getFormatsByArgumentIndex getFormatsByArgumentIndex}
 755      * method, which assumes an order of formats corresponding to the
 756      * order of elements in the {@code arguments} array passed to
 757      * the {@code format} methods or the result array returned by
 758      * the {@code parse} methods.
 759      *
 760      * @return the formats used for the format elements in the pattern
 761      */
 762     public Format[] getFormats() {
 763         Format[] resultArray = new Format[maxOffset + 1];
 764         System.arraycopy(formats, 0, resultArray, 0, maxOffset + 1);
 765         return resultArray;
 766     }
 767 
 768     /**
 769      * Formats an array of objects and appends the {@code MessageFormat}&#39;s
 770      * pattern, with format elements replaced by the formatted objects, to the
 771      * provided {@code StringBuffer}.
 772      * &lt;p&gt;
 773      * The text substituted for the individual format elements is derived from
 774      * the current subformat of the format element and the
 775      * {@code arguments} element at the format element&#39;s argument index
 776      * as indicated by the first matching line of the following table. An
 777      * argument is &lt;i&gt;unavailable&lt;/i&gt; if {@code arguments} is
 778      * {@code null} or has fewer than argumentIndex+1 elements.
 779      *
 780      * &lt;table class=&quot;plain&quot;&gt;
 781      * &lt;caption style=&quot;display:none&quot;&gt;Examples of subformat,argument,and formatted text&lt;/caption&gt;
 782      * &lt;thead&gt;
 783      *    &lt;tr&gt;
 784      *       &lt;th scope=&quot;col&quot;&gt;Subformat
 785      *       &lt;th scope=&quot;col&quot;&gt;Argument
 786      *       &lt;th scope=&quot;col&quot;&gt;Formatted Text
 787      * &lt;/thead&gt;
 788      * &lt;tbody&gt;
 789      *    &lt;tr&gt;
 790      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=2&gt;&lt;i&gt;any&lt;/i&gt;
 791      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;unavailable&lt;/i&gt;
 792      *       &lt;td&gt;&lt;code&gt;&quot;{&quot; + argumentIndex + &quot;}&quot;&lt;/code&gt;
 793      *    &lt;tr&gt;
 794      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code null}
 795      *       &lt;td&gt;{@code &quot;null&quot;}
 796      *    &lt;tr&gt;
 797      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof ChoiceFormat}
 798      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
 799      *       &lt;td&gt;&lt;code&gt;subformat.format(argument).indexOf(&#39;{&#39;) &amp;gt;= 0 ?&lt;br&gt;
 800      *           (new MessageFormat(subformat.format(argument), getLocale())).format(argument) :
 801      *           subformat.format(argument)&lt;/code&gt;
 802      *    &lt;tr&gt;
 803      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code != null}
 804      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
 805      *       &lt;td&gt;{@code subformat.format(argument)}
 806      *    &lt;tr&gt;
 807      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot; rowspan=4&gt;{@code null}
 808      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof Number}
 809      *       &lt;td&gt;{@code NumberFormat.getInstance(getLocale()).format(argument)}
 810      *    &lt;tr&gt;
 811      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof Date}
 812      *       &lt;td&gt;{@code DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, getLocale()).format(argument)}
 813      *    &lt;tr&gt;
 814      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;{@code instanceof String}
 815      *       &lt;td&gt;{@code argument}
 816      *    &lt;tr&gt;
 817      *       &lt;th scope=&quot;row&quot; style=&quot;text-weight-normal&quot;&gt;&lt;i&gt;any&lt;/i&gt;
 818      *       &lt;td&gt;{@code argument.toString()}
 819      * &lt;/tbody&gt;
 820      * &lt;/table&gt;
 821      * &lt;p&gt;
 822      * If {@code pos} is non-null, and refers to
 823      * {@code Field.ARGUMENT}, the location of the first formatted
 824      * string will be returned.
 825      *
 826      * @param arguments an array of objects to be formatted and substituted.
 827      * @param result where text is appended.
 828      * @param pos keeps track on the position of the first replaced argument
 829                   in the output string.
 830      * @return the string buffer passed in as {@code result}, with formatted
 831      * text appended
 832      * @throws    IllegalArgumentException if an argument in the
 833      *            {@code arguments} array is not of the type
 834      *            expected by the format element(s) that use it.
 835      * @throws    NullPointerException if {@code result} is {@code null}
 836      */
 837     public final StringBuffer format(Object[] arguments, StringBuffer result,
 838                                      FieldPosition pos)
 839     {
 840         return subformat(arguments, result, pos, null);
 841     }
 842 
 843     /**
 844      * Creates a MessageFormat with the given pattern and uses it
 845      * to format the given arguments. This is equivalent to
 846      * &lt;blockquote&gt;
 847      *     &lt;code&gt;(new {@link #MessageFormat(String) MessageFormat}(pattern)).{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 848      * &lt;/blockquote&gt;
 849      *
 850      * @param pattern   the pattern string
 851      * @param arguments object(s) to format
 852      * @return the formatted string
 853      * @throws    IllegalArgumentException if the pattern is invalid,
 854      *            or if an argument in the {@code arguments} array
 855      *            is not of the type expected by the format element(s)
 856      *            that use it.
 857      * @throws    NullPointerException if {@code pattern} is {@code null}
 858      */
 859     public static String format(String pattern, Object ... arguments) {
 860         MessageFormat temp = new MessageFormat(pattern);
 861         return temp.format(arguments);
 862     }
 863 
 864     // Overrides
 865     /**
 866      * Formats an array of objects and appends the {@code MessageFormat}&#39;s
 867      * pattern, with format elements replaced by the formatted objects, to the
 868      * provided {@code StringBuffer}.
 869      * This is equivalent to
 870      * &lt;blockquote&gt;
 871      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}((Object[]) arguments, result, pos)&lt;/code&gt;
 872      * &lt;/blockquote&gt;
 873      *
 874      * @param arguments an array of objects to be formatted and substituted.
 875      * @param result where text is appended.
 876      * @param pos keeps track on the position of the first replaced argument
 877      *            in the output string.
 878      * @throws    IllegalArgumentException if an argument in the
 879      *            {@code arguments} array is not of the type
 880      *            expected by the format element(s) that use it.
 881      * @throws    NullPointerException if {@code result} is {@code null}
 882      */
 883     public final StringBuffer format(Object arguments, StringBuffer result,
 884                                      FieldPosition pos)
 885     {
 886         return subformat((Object[]) arguments, result, pos, null);
 887     }
 888 
 889     /**
 890      * Formats an array of objects and inserts them into the
 891      * {@code MessageFormat}&#39;s pattern, producing an
 892      * {@code AttributedCharacterIterator}.
 893      * You can use the returned {@code AttributedCharacterIterator}
 894      * to build the resulting String, as well as to determine information
 895      * about the resulting String.
 896      * &lt;p&gt;
 897      * The text of the returned {@code AttributedCharacterIterator} is
 898      * the same that would be returned by
 899      * &lt;blockquote&gt;
 900      *     &lt;code&gt;{@link #format(java.lang.Object[], java.lang.StringBuffer, java.text.FieldPosition) format}(arguments, new StringBuffer(), null).toString()&lt;/code&gt;
 901      * &lt;/blockquote&gt;
 902      * &lt;p&gt;
 903      * In addition, the {@code AttributedCharacterIterator} contains at
 904      * least attributes indicating where text was generated from an
 905      * argument in the {@code arguments} array. The keys of these attributes are of
 906      * type {@code MessageFormat.Field}, their values are
 907      * {@code Integer} objects indicating the index in the {@code arguments}
 908      * array of the argument from which the text was generated.
 909      * &lt;p&gt;
 910      * The attributes/value from the underlying {@code Format}
 911      * instances that {@code MessageFormat} uses will also be
 912      * placed in the resulting {@code AttributedCharacterIterator}.
 913      * This allows you to not only find where an argument is placed in the
 914      * resulting String, but also which fields it contains in turn.
 915      *
 916      * @param arguments an array of objects to be formatted and substituted.
 917      * @return AttributedCharacterIterator describing the formatted value.
 918      * @throws    NullPointerException if {@code arguments} is null.
 919      * @throws    IllegalArgumentException if an argument in the
 920      *            {@code arguments} array is not of the type
 921      *            expected by the format element(s) that use it.
 922      * @since 1.4
 923      */
 924     public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
 925         StringBuffer result = new StringBuffer();
 926         ArrayList&lt;AttributedCharacterIterator&gt; iterators = new ArrayList&lt;&gt;();
 927 
 928         if (arguments == null) {
 929             throw new NullPointerException(
 930                    &quot;formatToCharacterIterator must be passed non-null object&quot;);
 931         }
 932         subformat((Object[]) arguments, result, null, iterators);
 933         if (iterators.size() == 0) {
 934             return createAttributedCharacterIterator(&quot;&quot;);
 935         }
 936         return createAttributedCharacterIterator(
 937                      iterators.toArray(
 938                      new AttributedCharacterIterator[iterators.size()]));
 939     }
 940 
 941     /**
 942      * Parses the string.
 943      *
 944      * &lt;p&gt;Caveats: The parse may fail in a number of circumstances.
 945      * For example:
 946      * &lt;ul&gt;
 947      * &lt;li&gt;If one of the arguments does not occur in the pattern.
 948      * &lt;li&gt;If the format of an argument loses information, such as
 949      *     with a choice format where a large number formats to &quot;many&quot;.
 950      * &lt;li&gt;Does not yet handle recursion (where
 951      *     the substituted strings contain {n} references.)
 952      * &lt;li&gt;Will not always find a match (or the correct match)
 953      *     if some part of the parse is ambiguous.
 954      *     For example, if the pattern &quot;{1},{2}&quot; is used with the
 955      *     string arguments {&quot;a,b&quot;, &quot;c&quot;}, it will format as &quot;a,b,c&quot;.
 956      *     When the result is parsed, it will return {&quot;a&quot;, &quot;b,c&quot;}.
 957      * &lt;li&gt;If a single argument is parsed more than once in the string,
 958      *     then the later parse wins.
 959      * &lt;/ul&gt;
 960      * When the parse fails, use ParsePosition.getErrorIndex() to find out
 961      * where in the string the parsing failed.  The returned error
 962      * index is the starting offset of the sub-patterns that the string
 963      * is comparing with.  For example, if the parsing string &quot;AAA {0} BBB&quot;
 964      * is comparing against the pattern &quot;AAD {0} BBB&quot;, the error index is
 965      * 0. When an error occurs, the call to this method will return null.
 966      * If the source is null, return an empty array.
 967      *
 968      * @param source the string to parse
 969      * @param pos    the parse position
 970      * @return an array of parsed objects
 971      * @throws    NullPointerException if {@code pos} is {@code null}
 972      *            for a non-null {@code source} string.
 973      */
 974     public Object[] parse(String source, ParsePosition pos) {
 975         if (source == null) {
 976             Object[] empty = {};
 977             return empty;
 978         }
 979 
 980         int maximumArgumentNumber = -1;
 981         for (int i = 0; i &lt;= maxOffset; i++) {
 982             if (argumentNumbers[i] &gt; maximumArgumentNumber) {
 983                 maximumArgumentNumber = argumentNumbers[i];
 984             }
 985         }
 986         Object[] resultArray = new Object[maximumArgumentNumber + 1];
 987 
 988         int patternOffset = 0;
 989         int sourceOffset = pos.index;
 990         ParsePosition tempStatus = new ParsePosition(0);
 991         for (int i = 0; i &lt;= maxOffset; ++i) {
 992             // match up to format
 993             int len = offsets[i] - patternOffset;
 994             if (len == 0 || pattern.regionMatches(patternOffset,
 995                                                   source, sourceOffset, len)) {
 996                 sourceOffset += len;
 997                 patternOffset += len;
 998             } else {
 999                 pos.errorIndex = sourceOffset;
1000                 return null; // leave index as is to signal error
1001             }
1002 
1003             // now use format
1004             if (formats[i] == null) {   // string format
1005                 // if at end, use longest possible match
1006                 // otherwise uses first match to intervening string
1007                 // does NOT recursively try all possibilities
1008                 int tempLength = (i != maxOffset) ? offsets[i+1] : pattern.length();
1009 
1010                 int next;
1011                 if (patternOffset &gt;= tempLength) {
1012                     next = source.length();
1013                 }else{
1014                     next = source.indexOf(pattern.substring(patternOffset, tempLength),
1015                                           sourceOffset);
1016                 }
1017 
1018                 if (next &lt; 0) {
1019                     pos.errorIndex = sourceOffset;
1020                     return null; // leave index as is to signal error
1021                 } else {
1022                     String strValue= source.substring(sourceOffset,next);
1023                     if (!strValue.equals(&quot;{&quot;+argumentNumbers[i]+&quot;}&quot;))
1024                         resultArray[argumentNumbers[i]]
1025                             = source.substring(sourceOffset,next);
1026                     sourceOffset = next;
1027                 }
1028             } else {
1029                 tempStatus.index = sourceOffset;
1030                 resultArray[argumentNumbers[i]]
1031                     = formats[i].parseObject(source,tempStatus);
1032                 if (tempStatus.index == sourceOffset) {
1033                     pos.errorIndex = sourceOffset;
1034                     return null; // leave index as is to signal error
1035                 }
1036                 sourceOffset = tempStatus.index; // update
1037             }
1038         }
1039         int len = pattern.length() - patternOffset;
1040         if (len == 0 || pattern.regionMatches(patternOffset,
1041                                               source, sourceOffset, len)) {
1042             pos.index = sourceOffset + len;
1043         } else {
1044             pos.errorIndex = sourceOffset;
1045             return null; // leave index as is to signal error
1046         }
1047         return resultArray;
1048     }
1049 
1050     /**
1051      * Parses text from the beginning of the given string to produce an object
1052      * array.
1053      * The method may not use the entire text of the given string.
1054      * &lt;p&gt;
1055      * See the {@link #parse(String, ParsePosition)} method for more information
1056      * on message parsing.
1057      *
1058      * @param source A {@code String} whose beginning should be parsed.
1059      * @return An {@code Object} array parsed from the string.
1060      * @throws    ParseException if the beginning of the specified string
1061      *            cannot be parsed.
1062      */
1063     public Object[] parse(String source) throws ParseException {
1064         ParsePosition pos  = new ParsePosition(0);
1065         Object[] result = parse(source, pos);
1066         if (pos.index == 0)  // unchanged, returned object is null
1067             throw new ParseException(&quot;MessageFormat parse error!&quot;, pos.errorIndex);
1068 
1069         return result;
1070     }
1071 
1072     /**
1073      * Parses text from a string to produce an object array.
1074      * &lt;p&gt;
1075      * The method attempts to parse text starting at the index given by
1076      * {@code pos}.
1077      * If parsing succeeds, then the index of {@code pos} is updated
1078      * to the index after the last character used (parsing does not necessarily
1079      * use all characters up to the end of the string), and the parsed
1080      * object array is returned. The updated {@code pos} can be used to
1081      * indicate the starting point for the next call to this method.
1082      * If an error occurs, then the index of {@code pos} is not
1083      * changed, the error index of {@code pos} is set to the index of
1084      * the character where the error occurred, and null is returned.
1085      * &lt;p&gt;
1086      * See the {@link #parse(String, ParsePosition)} method for more information
1087      * on message parsing.
1088      *
1089      * @param source A {@code String}, part of which should be parsed.
1090      * @param pos A {@code ParsePosition} object with index and error
1091      *            index information as described above.
1092      * @return An {@code Object} array parsed from the string. In case of
1093      *         error, returns null.
1094      * @throws NullPointerException if {@code pos} is null.
1095      */
1096     public Object parseObject(String source, ParsePosition pos) {
1097         return parse(source, pos);
1098     }
1099 
1100     /**
1101      * Creates and returns a copy of this object.
1102      *
1103      * @return a clone of this instance.
1104      */
1105     public Object clone() {
1106         MessageFormat other = (MessageFormat) super.clone();
1107 
1108         // clone arrays. Can&#39;t do with utility because of bug in Cloneable
1109         other.formats = formats.clone(); // shallow clone
1110         for (int i = 0; i &lt; formats.length; ++i) {
1111             if (formats[i] != null)
1112                 other.formats[i] = (Format)formats[i].clone();
1113         }
1114         // for primitives or immutables, shallow clone is enough
1115         other.offsets = offsets.clone();
1116         other.argumentNumbers = argumentNumbers.clone();
1117 
1118         return other;
1119     }
1120 
1121     /**
1122      * Equality comparison between two message format objects
1123      */
1124     public boolean equals(Object obj) {
1125         if (this == obj)                      // quick check
1126             return true;
1127         if (obj == null || getClass() != obj.getClass())
1128             return false;
1129         MessageFormat other = (MessageFormat) obj;
1130         return (maxOffset == other.maxOffset
1131                 &amp;&amp; pattern.equals(other.pattern)
1132                 &amp;&amp; ((locale != null &amp;&amp; locale.equals(other.locale))
1133                  || (locale == null &amp;&amp; other.locale == null))
1134                 &amp;&amp; Arrays.equals(offsets,other.offsets)
1135                 &amp;&amp; Arrays.equals(argumentNumbers,other.argumentNumbers)
1136                 &amp;&amp; Arrays.equals(formats,other.formats));
1137     }
1138 
1139     /**
1140      * Generates a hash code for the message format object.
1141      */
1142     public int hashCode() {
1143         return pattern.hashCode(); // enough for reasonable distribution
1144     }
1145 
1146 
1147     /**
1148      * Defines constants that are used as attribute keys in the
1149      * {@code AttributedCharacterIterator} returned
1150      * from {@code MessageFormat.formatToCharacterIterator}.
1151      *
1152      * @since 1.4
1153      */
1154     public static class Field extends Format.Field {
1155 
1156         // Proclaim serial compatibility with 1.4 FCS
1157         @java.io.Serial
1158         private static final long serialVersionUID = 7899943957617360810L;
1159 
1160         /**
1161          * Creates a Field with the specified name.
1162          *
1163          * @param name Name of the attribute
1164          */
1165         protected Field(String name) {
1166             super(name);
1167         }
1168 
1169         /**
1170          * Resolves instances being deserialized to the predefined constants.
1171          *
1172          * @throws InvalidObjectException if the constant could not be
1173          *         resolved.
1174          * @return resolved MessageFormat.Field constant
1175          */
1176         @java.io.Serial
1177         protected Object readResolve() throws InvalidObjectException {
1178             if (this.getClass() != MessageFormat.Field.class) {
1179                 throw new InvalidObjectException(&quot;subclass didn&#39;t correctly implement readResolve&quot;);
1180             }
1181 
1182             return ARGUMENT;
1183         }
1184 
1185         //
1186         // The constants
1187         //
1188 
1189         /**
1190          * Constant identifying a portion of a message that was generated
1191          * from an argument passed into {@code formatToCharacterIterator}.
1192          * The value associated with the key will be an {@code Integer}
1193          * indicating the index in the {@code arguments} array of the
1194          * argument from which the text was generated.
1195          */
1196         public static final Field ARGUMENT =
1197                            new Field(&quot;message argument field&quot;);
1198     }
1199 
1200     // ===========================privates============================
1201 
1202     /**
1203      * The locale to use for formatting numbers and dates.
1204      * @serial
1205      */
1206     private Locale locale;
1207 
1208     /**
1209      * The string that the formatted values are to be plugged into.  In other words, this
1210      * is the pattern supplied on construction with all of the {} expressions taken out.
1211      * @serial
1212      */
1213     private String pattern = &quot;&quot;;
1214 
1215     /** The initially expected number of subformats in the format */
1216     private static final int INITIAL_FORMATS = 10;
1217 
1218     /**
1219      * An array of formatters, which are used to format the arguments.
1220      * @serial
1221      */
1222     private Format[] formats = new Format[INITIAL_FORMATS];
1223 
1224     /**
1225      * The positions where the results of formatting each argument are to be inserted
1226      * into the pattern.
1227      * @serial
1228      */
1229     private int[] offsets = new int[INITIAL_FORMATS];
1230 
1231     /**
1232      * The argument numbers corresponding to each formatter.  (The formatters are stored
1233      * in the order they occur in the pattern, not in the order in which the arguments
1234      * are specified.)
1235      * @serial
1236      */
1237     private int[] argumentNumbers = new int[INITIAL_FORMATS];
1238 
1239     /**
1240      * One less than the number of entries in {@code offsets}.  Can also be thought of
1241      * as the index of the highest-numbered element in {@code offsets} that is being used.
1242      * All of these arrays should have the same number of elements being used as {@code offsets}
1243      * does, and so this variable suffices to tell us how many entries are in all of them.
1244      * @serial
1245      */
1246     private int maxOffset = -1;
1247 
1248     /**
1249      * Internal routine used by format. If {@code characterIterators} is
1250      * {@code non-null}, AttributedCharacterIterator will be created from the
1251      * subformats as necessary. If {@code characterIterators} is {@code null}
1252      * and {@code fp} is {@code non-null} and identifies
1253      * {@code Field.ARGUMENT} as the field attribute, the location of
1254      * the first replaced argument will be set in it.
1255      *
1256      * @throws    IllegalArgumentException if an argument in the
1257      *            {@code arguments} array is not of the type
1258      *            expected by the format element(s) that use it.
1259      */
1260     private StringBuffer subformat(Object[] arguments, StringBuffer result,
1261                                    FieldPosition fp, List&lt;AttributedCharacterIterator&gt; characterIterators) {
1262         // note: this implementation assumes a fast substring &amp; index.
1263         // if this is not true, would be better to append chars one by one.
1264         int lastOffset = 0;
1265         int last = result.length();
1266         for (int i = 0; i &lt;= maxOffset; ++i) {
1267             result.append(pattern, lastOffset, offsets[i]);
1268             lastOffset = offsets[i];
1269             int argumentNumber = argumentNumbers[i];
1270             if (arguments == null || argumentNumber &gt;= arguments.length) {
1271                 result.append(&#39;{&#39;).append(argumentNumber).append(&#39;}&#39;);
1272                 continue;
1273             }
1274             // int argRecursion = ((recursionProtection &gt;&gt; (argumentNumber*2)) &amp; 0x3);
1275             if (false) { // if (argRecursion == 3){
1276                 // prevent loop!!!
1277                 result.append(&#39;\uFFFD&#39;);
1278             } else {
1279                 Object obj = arguments[argumentNumber];
1280                 String arg = null;
1281                 Format subFormatter = null;
1282                 if (obj == null) {
1283                     arg = &quot;null&quot;;
1284                 } else if (formats[i] != null) {
1285                     subFormatter = formats[i];
1286                     if (subFormatter instanceof ChoiceFormat) {
1287                         arg = formats[i].format(obj);
1288                         if (arg.indexOf(&#39;{&#39;) &gt;= 0) {
1289                             subFormatter = new MessageFormat(arg, locale);
1290                             obj = arguments;
1291                             arg = null;
1292                         }
1293                     }
1294                 } else if (obj instanceof Number) {
1295                     // format number if can
1296                     subFormatter = NumberFormat.getInstance(locale);
1297                 } else if (obj instanceof Date) {
1298                     // format a Date if can
1299                     subFormatter = DateFormat.getDateTimeInstance(
1300                              DateFormat.SHORT, DateFormat.SHORT, locale);//fix
1301                 } else if (obj instanceof String) {
1302                     arg = (String) obj;
1303 
1304                 } else {
1305                     arg = obj.toString();
1306                     if (arg == null) arg = &quot;null&quot;;
1307                 }
1308 
1309                 // At this point we are in two states, either subFormatter
1310                 // is non-null indicating we should format obj using it,
1311                 // or arg is non-null and we should use it as the value.
1312 
1313                 if (characterIterators != null) {
1314                     // If characterIterators is non-null, it indicates we need
1315                     // to get the CharacterIterator from the child formatter.
1316                     if (last != result.length()) {
1317                         characterIterators.add(
1318                             createAttributedCharacterIterator(result.substring
1319                                                               (last)));
1320                         last = result.length();
1321                     }
1322                     if (subFormatter != null) {
1323                         AttributedCharacterIterator subIterator =
1324                                    subFormatter.formatToCharacterIterator(obj);
1325 
1326                         append(result, subIterator);
1327                         if (last != result.length()) {
1328                             characterIterators.add(
1329                                          createAttributedCharacterIterator(
1330                                          subIterator, Field.ARGUMENT,
1331                                          Integer.valueOf(argumentNumber)));
1332                             last = result.length();
1333                         }
1334                         arg = null;
1335                     }
1336                     if (arg != null &amp;&amp; !arg.isEmpty()) {
1337                         result.append(arg);
1338                         characterIterators.add(
1339                                  createAttributedCharacterIterator(
1340                                  arg, Field.ARGUMENT,
1341                                  Integer.valueOf(argumentNumber)));
1342                         last = result.length();
1343                     }
1344                 }
1345                 else {
1346                     if (subFormatter != null) {
1347                         arg = subFormatter.format(obj);
1348                     }
1349                     last = result.length();
1350                     result.append(arg);
1351                     if (i == 0 &amp;&amp; fp != null &amp;&amp; Field.ARGUMENT.equals(
1352                                   fp.getFieldAttribute())) {
1353                         fp.setBeginIndex(last);
1354                         fp.setEndIndex(result.length());
1355                     }
1356                     last = result.length();
1357                 }
1358             }
1359         }
1360         result.append(pattern, lastOffset, pattern.length());
1361         if (characterIterators != null &amp;&amp; last != result.length()) {
1362             characterIterators.add(createAttributedCharacterIterator(
1363                                    result.substring(last)));
1364         }
1365         return result;
1366     }
1367 
1368     /**
1369      * Convenience method to append all the characters in
1370      * {@code iterator} to the StringBuffer {@code result}.
1371      */
1372     private void append(StringBuffer result, CharacterIterator iterator) {
1373         if (iterator.first() != CharacterIterator.DONE) {
1374             char aChar;
1375 
1376             result.append(iterator.first());
1377             while ((aChar = iterator.next()) != CharacterIterator.DONE) {
1378                 result.append(aChar);
1379             }
1380         }
1381     }
1382 
1383     // Indices for segments
1384     private static final int SEG_RAW      = 0;
1385     private static final int SEG_INDEX    = 1;
1386     private static final int SEG_TYPE     = 2;
1387     private static final int SEG_MODIFIER = 3; // modifier or subformat
1388 
1389     // Indices for type keywords
1390     private static final int TYPE_NULL    = 0;
1391     private static final int TYPE_NUMBER  = 1;
1392     private static final int TYPE_DATE    = 2;
1393     private static final int TYPE_TIME    = 3;
1394     private static final int TYPE_CHOICE  = 4;
1395 
1396     private static final String[] TYPE_KEYWORDS = {
1397         &quot;&quot;,
1398         &quot;number&quot;,
1399         &quot;date&quot;,
1400         &quot;time&quot;,
1401         &quot;choice&quot;
1402     };
1403 
1404     // Indices for number modifiers
1405     private static final int MODIFIER_DEFAULT  = 0; // common in number and date-time
1406     private static final int MODIFIER_CURRENCY = 1;
1407     private static final int MODIFIER_PERCENT  = 2;
1408     private static final int MODIFIER_INTEGER  = 3;
1409 
1410     private static final String[] NUMBER_MODIFIER_KEYWORDS = {
1411         &quot;&quot;,
1412         &quot;currency&quot;,
1413         &quot;percent&quot;,
1414         &quot;integer&quot;
1415     };
1416 
1417     // Indices for date-time modifiers
1418     private static final int MODIFIER_SHORT   = 1;
1419     private static final int MODIFIER_MEDIUM  = 2;
1420     private static final int MODIFIER_LONG    = 3;
1421     private static final int MODIFIER_FULL    = 4;
1422 
1423     private static final String[] DATE_TIME_MODIFIER_KEYWORDS = {
1424         &quot;&quot;,
1425         &quot;short&quot;,
1426         &quot;medium&quot;,
1427         &quot;long&quot;,
1428         &quot;full&quot;
1429     };
1430 
1431     // Date-time style values corresponding to the date-time modifiers.
1432     private static final int[] DATE_TIME_MODIFIERS = {
1433         DateFormat.DEFAULT,
1434         DateFormat.SHORT,
1435         DateFormat.MEDIUM,
1436         DateFormat.LONG,
1437         DateFormat.FULL,
1438     };
1439 
1440     private void makeFormat(int position, int offsetNumber,
1441                             StringBuilder[] textSegments)
1442     {
1443         String[] segments = new String[textSegments.length];
1444         for (int i = 0; i &lt; textSegments.length; i++) {
1445             StringBuilder oneseg = textSegments[i];
1446             segments[i] = (oneseg != null) ? oneseg.toString() : &quot;&quot;;
1447         }
1448 
1449         // get the argument number
1450         int argumentNumber;
1451         try {
1452             argumentNumber = Integer.parseInt(segments[SEG_INDEX]); // always unlocalized!
1453         } catch (NumberFormatException e) {
1454             throw new IllegalArgumentException(&quot;can&#39;t parse argument number: &quot;
1455                                                + segments[SEG_INDEX], e);
1456         }
1457         if (argumentNumber &lt; 0) {
1458             throw new IllegalArgumentException(&quot;negative argument number: &quot;
1459                                                + argumentNumber);
1460         }
1461 
1462         // resize format information arrays if necessary
1463         if (offsetNumber &gt;= formats.length) {
1464             int newLength = formats.length * 2;
1465             Format[] newFormats = new Format[newLength];
1466             int[] newOffsets = new int[newLength];
1467             int[] newArgumentNumbers = new int[newLength];
1468             System.arraycopy(formats, 0, newFormats, 0, maxOffset + 1);
1469             System.arraycopy(offsets, 0, newOffsets, 0, maxOffset + 1);
1470             System.arraycopy(argumentNumbers, 0, newArgumentNumbers, 0, maxOffset + 1);
1471             formats = newFormats;
1472             offsets = newOffsets;
1473             argumentNumbers = newArgumentNumbers;
1474         }
1475         int oldMaxOffset = maxOffset;
1476         maxOffset = offsetNumber;
1477         offsets[offsetNumber] = segments[SEG_RAW].length();
1478         argumentNumbers[offsetNumber] = argumentNumber;
1479 
1480         // now get the format
1481         Format newFormat = null;
1482         if (!segments[SEG_TYPE].isEmpty()) {
1483             int type = findKeyword(segments[SEG_TYPE], TYPE_KEYWORDS);
1484             switch (type) {
1485             case TYPE_NULL:
1486                 // Type &quot;&quot; is allowed. e.g., &quot;{0,}&quot;, &quot;{0,,}&quot;, and &quot;{0,,#}&quot;
1487                 // are treated as &quot;{0}&quot;.
1488                 break;
1489 
1490             case TYPE_NUMBER:
1491                 switch (findKeyword(segments[SEG_MODIFIER], NUMBER_MODIFIER_KEYWORDS)) {
1492                 case MODIFIER_DEFAULT:
1493                     newFormat = NumberFormat.getInstance(locale);
1494                     break;
1495                 case MODIFIER_CURRENCY:
1496                     newFormat = NumberFormat.getCurrencyInstance(locale);
1497                     break;
1498                 case MODIFIER_PERCENT:
1499                     newFormat = NumberFormat.getPercentInstance(locale);
1500                     break;
1501                 case MODIFIER_INTEGER:
1502                     newFormat = NumberFormat.getIntegerInstance(locale);
1503                     break;
1504                 default: // DecimalFormat pattern
1505                     try {
1506                         newFormat = new DecimalFormat(segments[SEG_MODIFIER],
1507                                                       DecimalFormatSymbols.getInstance(locale));
1508                     } catch (IllegalArgumentException e) {
1509                         maxOffset = oldMaxOffset;
1510                         throw e;
1511                     }
1512                     break;
1513                 }
1514                 break;
1515 
1516             case TYPE_DATE:
1517             case TYPE_TIME:
1518                 int mod = findKeyword(segments[SEG_MODIFIER], DATE_TIME_MODIFIER_KEYWORDS);
1519                 if (mod &gt;= 0 &amp;&amp; mod &lt; DATE_TIME_MODIFIER_KEYWORDS.length) {
1520                     if (type == TYPE_DATE) {
1521                         newFormat = DateFormat.getDateInstance(DATE_TIME_MODIFIERS[mod],
1522                                                                locale);
1523                     } else {
1524                         newFormat = DateFormat.getTimeInstance(DATE_TIME_MODIFIERS[mod],
1525                                                                locale);
1526                     }
1527                 } else {
1528                     // SimpleDateFormat pattern
1529                     try {
1530                         newFormat = new SimpleDateFormat(segments[SEG_MODIFIER], locale);
1531                     } catch (IllegalArgumentException e) {
1532                         maxOffset = oldMaxOffset;
1533                         throw e;
1534                     }
1535                 }
1536                 break;
1537 
1538             case TYPE_CHOICE:
1539                 try {
1540                     // ChoiceFormat pattern
1541                     newFormat = new ChoiceFormat(segments[SEG_MODIFIER]);
1542                 } catch (Exception e) {
1543                     maxOffset = oldMaxOffset;
1544                     throw new IllegalArgumentException(&quot;Choice Pattern incorrect: &quot;
1545                                                        + segments[SEG_MODIFIER], e);
1546                 }
1547                 break;
1548 
1549             default:
1550                 maxOffset = oldMaxOffset;
1551                 throw new IllegalArgumentException(&quot;unknown format type: &quot; +
1552                                                    segments[SEG_TYPE]);
1553             }
1554         }
1555         formats[offsetNumber] = newFormat;
1556     }
1557 
1558     private static final int findKeyword(String s, String[] list) {
1559         for (int i = 0; i &lt; list.length; ++i) {
1560             if (s.equals(list[i]))
1561                 return i;
1562         }
1563 
1564         // Try trimmed lowercase.
1565         String ls = s.trim().toLowerCase(Locale.ROOT);
1566         if (ls != s) {
1567             for (int i = 0; i &lt; list.length; ++i) {
1568                 if (ls.equals(list[i]))
1569                     return i;
1570             }
1571         }
1572         return -1;
1573     }
1574 
1575     private static final void copyAndFixQuotes(String source, int start, int end,
1576                                                StringBuilder target) {
1577         boolean quoted = false;
1578 
1579         for (int i = start; i &lt; end; ++i) {
1580             char ch = source.charAt(i);
1581             if (ch == &#39;{&#39;) {
1582                 if (!quoted) {
1583                     target.append(&#39;\&#39;&#39;);
1584                     quoted = true;
1585                 }
1586                 target.append(ch);
1587             } else if (ch == &#39;\&#39;&#39;) {
1588                 target.append(&quot;&#39;&#39;&quot;);
1589             } else {
1590                 if (quoted) {
1591                     target.append(&#39;\&#39;&#39;);
1592                     quoted = false;
1593                 }
1594                 target.append(ch);
1595             }
1596         }
1597         if (quoted) {
1598             target.append(&#39;\&#39;&#39;);
1599         }
1600     }
1601 
1602     /**
1603      * After reading an object from the input stream, do a simple verification
1604      * to maintain class invariants.
1605      * @throws InvalidObjectException if the objects read from the stream is invalid.
1606      */
1607     @java.io.Serial
1608     private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {
1609         in.defaultReadObject();
1610         boolean isValid = maxOffset &gt;= -1
1611                 &amp;&amp; formats.length &gt; maxOffset
1612                 &amp;&amp; offsets.length &gt; maxOffset
1613                 &amp;&amp; argumentNumbers.length &gt; maxOffset;
1614         if (isValid) {
1615             int lastOffset = pattern.length() + 1;
1616             for (int i = maxOffset; i &gt;= 0; --i) {
1617                 if ((offsets[i] &lt; 0) || (offsets[i] &gt; lastOffset)) {
1618                     isValid = false;
1619                     break;
1620                 } else {
1621                     lastOffset = offsets[i];
1622                 }
1623             }
1624         }
1625         if (!isValid) {
1626             throw new InvalidObjectException(&quot;Could not reconstruct MessageFormat from corrupt stream.&quot;);
1627         }
1628     }
1629 }
    </pre>
  </body>
</html>
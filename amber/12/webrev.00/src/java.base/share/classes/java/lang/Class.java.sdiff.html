<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/java.base/share/classes/java/lang/Class.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="Character.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassLoader.java.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/java.base/share/classes/java/lang/Class.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 122  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 123  * belong to the nest; each of them in turn records it as the nest host.
 124  * The classes and interfaces which belong to a nest, including its host, are
 125  * determined when
 126  * {@code class} files are generated, for example, a Java compiler
 127  * will typically record a top-level class as the host of a nest where the
 128  * other members are the classes and interfaces whose declarations are
 129  * enclosed within the top-level class declaration.
 130  *
 131  * &lt;p&gt; The following example uses a {@code Class} object to print the
 132  * class name of an object:
 133  *
 134  * &lt;blockquote&gt;&lt;pre&gt;
 135  *     void printClassName(Object obj) {
 136  *         System.out.println(&quot;The class of &quot; + obj +
 137  *                            &quot; is &quot; + obj.getClass().getName());
 138  *     }
 139  * &lt;/pre&gt;&lt;/blockquote&gt;
 140  *
 141  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<span class="line-modified"> 142  * type (or for void) using a class literal.  See Section 15.8.2 of</span>
<span class="line-modified"> 143  * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 144  * For example:
 145  *
 146  * &lt;blockquote&gt;
<span class="line-modified"> 147  *     {@code System.out.println(&quot;The name of class Foo is: &quot;+Foo.class.getName());}</span>
 148  * &lt;/blockquote&gt;
 149  *
 150  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 151  * object.  For example, the type of {@code String.class} is {@code
 152  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 153  * unknown.
 154  *
 155  * @author  unascribed
 156  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 157  * @since   1.0
 158  */
 159 public final class Class&lt;T&gt; implements java.io.Serializable,
 160                               GenericDeclaration,
 161                               Type,
 162                               AnnotatedElement,
 163                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 164                               Constable {
 165     private static final int ANNOTATION= 0x00002000;
 166     private static final int ENUM      = 0x00004000;
 167     private static final int SYNTHETIC = 0x00001000;
</pre>
<hr />
<pre>
 176      * This constructor is not used and prevents the default constructor being
 177      * generated.
 178      */
 179     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 180         // Initialize final field for classLoader.  The initialization value of non-null
 181         // prevents future JIT optimizations from assuming this final field is null.
 182         classLoader = loader;
 183         componentType = arrayComponentType;
 184     }
 185 
 186     /**
 187      * Converts the object to a string. The string representation is the
 188      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 189      * fully qualified name of the class in the format returned by
 190      * {@code getName}.  If this {@code Class} object represents a
 191      * primitive type, this method returns the name of the primitive type.  If
 192      * this {@code Class} object represents void this method returns
 193      * &quot;void&quot;. If this {@code Class} object represents an array type,
 194      * this method returns &quot;class &quot; followed by {@code getName}.
 195      *
<span class="line-modified"> 196      * @return a string representation of this class object.</span>
 197      */
 198     public String toString() {
 199         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200             + getName();
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified"> 210      * &lt;code&gt;&amp;#64;&lt;/code&gt;{@code interface}, or {@code record} as appropriate), followed</span>
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
</pre>
<hr />
<pre>
 359      * obtain any of the {@code Class} objects representing primitive
 360      * types or void.
 361      *
 362      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 363      * the array class is loaded but not initialized.
 364      *
 365      * &lt;p&gt; For example, in an instance method the expression:
 366      *
 367      * &lt;blockquote&gt;
 368      *  {@code Class.forName(&quot;Foo&quot;)}
 369      * &lt;/blockquote&gt;
 370      *
 371      * is equivalent to:
 372      *
 373      * &lt;blockquote&gt;
 374      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 375      * &lt;/blockquote&gt;
 376      *
 377      * Note that this method throws errors related to loading, linking
 378      * or initializing as specified in Sections {@jls 12.2}, {@jls
<span class="line-modified"> 379      * 12.3}, and {@jls 12.4} of &lt;em&gt;The Java Language</span>
<span class="line-modified"> 380      * Specification&lt;/em&gt;.</span>
 381      * Note that this method does not check whether the requested class
 382      * is accessible to its caller.
 383      *
 384      * @param name       fully qualified name of the desired class
<span class="line-modified"> 385      * @param initialize if {@code true} the class will be initialized (which implies linking).</span>
<span class="line-modified"> 386      *                   See Section {@jls 12.4} of &lt;em&gt;The Java Language Specification&lt;/em&gt;.</span>



 387      * @param loader     class loader from which the class must be loaded
 388      * @return           class object representing the desired class
 389      *
 390      * @throws    LinkageError if the linkage fails
 391      * @throws    ExceptionInInitializerError if the initialization provoked
 392      *            by this method fails
 393      * @throws    ClassNotFoundException if the class cannot be located by
 394      *            the specified class loader
 395      * @throws    SecurityException
 396      *            if a security manager is present, and the {@code loader} is
 397      *            {@code null}, and the caller&#39;s class loader is not
 398      *            {@code null}, and the caller does not have the
 399      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 400      *
 401      * @see       java.lang.Class#forName(String)
 402      * @see       java.lang.ClassLoader
 403      *
 404      * @jls 12.2 Loading of Classes and Interfaces
 405      * @jls 12.3 Linking of Classes and Interfaces
 406      * @jls 12.4 Initialization of Classes and Interfaces
</pre>
<hr />
<pre>
 643      * @since 1.1
 644      */
 645     @HotSpotIntrinsicCandidate
 646     public native boolean isInstance(Object obj);
 647 
 648 
 649     /**
 650      * Determines if the class or interface represented by this
 651      * {@code Class} object is either the same as, or is a superclass or
 652      * superinterface of, the class or interface represented by the specified
 653      * {@code Class} parameter. It returns {@code true} if so;
 654      * otherwise it returns {@code false}. If this {@code Class}
 655      * object represents a primitive type, this method returns
 656      * {@code true} if the specified {@code Class} parameter is
 657      * exactly this {@code Class} object; otherwise it returns
 658      * {@code false}.
 659      *
 660      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 661      * specified {@code Class} parameter can be converted to the type
 662      * represented by this {@code Class} object via an identity conversion
<span class="line-modified"> 663      * or via a widening reference conversion. See &lt;em&gt;The Java Language</span>
<span class="line-modified"> 664      * Specification&lt;/em&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
 665      * for details.
 666      *
 667      * @param     cls the {@code Class} object to be checked
 668      * @return    the {@code boolean} value indicating whether objects of the
 669      *            type {@code cls} can be assigned to objects of this class
 670      * @throws    NullPointerException if the specified Class parameter is
 671      *            null.
 672      * @since     1.1
 673      */
 674     @HotSpotIntrinsicCandidate
 675     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 676 
 677 
 678     /**
<span class="line-modified"> 679      * Determines if the specified {@code Class} object represents an</span>
 680      * interface type.
 681      *
<span class="line-modified"> 682      * @return  {@code true} if this object represents an interface;</span>
 683      *          {@code false} otherwise.
 684      */
 685     @HotSpotIntrinsicCandidate
 686     public native boolean isInterface();
 687 
 688 
 689     /**
 690      * Determines if this {@code Class} object represents an array class.
 691      *
<span class="line-modified"> 692      * @return  {@code true} if this object represents an array class;</span>
 693      *          {@code false} otherwise.
 694      * @since   1.1
 695      */
 696     @HotSpotIntrinsicCandidate
 697     public native boolean isArray();
 698 
 699 
 700     /**
 701      * Determines if the specified {@code Class} object represents a
 702      * primitive type.
 703      *
 704      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 705      * the eight primitive types and void.  These are created by the Java
 706      * Virtual Machine, and have the same names as the primitive types that
 707      * they represent, namely {@code boolean}, {@code byte},
 708      * {@code char}, {@code short}, {@code int},
 709      * {@code long}, {@code float}, and {@code double}.
 710      *
 711      * &lt;p&gt; These objects may only be accessed via the following public static
 712      * final variables, and are the only {@code Class} objects for which
</pre>
<hr />
<pre>
 716      *
 717      * @see     java.lang.Boolean#TYPE
 718      * @see     java.lang.Character#TYPE
 719      * @see     java.lang.Byte#TYPE
 720      * @see     java.lang.Short#TYPE
 721      * @see     java.lang.Integer#TYPE
 722      * @see     java.lang.Long#TYPE
 723      * @see     java.lang.Float#TYPE
 724      * @see     java.lang.Double#TYPE
 725      * @see     java.lang.Void#TYPE
 726      * @since 1.1
 727      */
 728     @HotSpotIntrinsicCandidate
 729     public native boolean isPrimitive();
 730 
 731     /**
 732      * Returns true if this {@code Class} object represents an annotation
 733      * type.  Note that if this method returns true, {@link #isInterface()}
 734      * would also return true, as all annotation types are also interfaces.
 735      *
<span class="line-modified"> 736      * @return {@code true} if this class object represents an annotation</span>
 737      *      type; {@code false} otherwise
 738      * @since 1.5
 739      */
 740     public boolean isAnnotation() {
 741         return (getModifiers() &amp; ANNOTATION) != 0;
 742     }
 743 
 744     /**
 745      * Returns {@code true} if this class is a synthetic class;
 746      * returns {@code false} otherwise.
 747      * @return {@code true} if and only if this class is a synthetic class as
<span class="line-modified"> 748      *         defined by the Java Language Specification.</span>
 749      * @jls 13.1 The Form of a Binary
 750      * @since 1.5
 751      */
 752     public boolean isSynthetic() {
 753         return (getModifiers() &amp; SYNTHETIC) != 0;
 754     }
 755 
 756     /**
 757      * Returns the  name of the entity (class, interface, array class,
 758      * primitive type, or void) represented by this {@code Class} object,
 759      * as a {@code String}.
 760      *
<span class="line-modified"> 761      * &lt;p&gt; If this class object represents a reference type that is not an</span>
<span class="line-modified"> 762      * array type then the binary name of the class is returned, as specified</span>
<span class="line-modified"> 763      * by</span>
<span class="line-modified"> 764      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 765      *
<span class="line-modified"> 766      * &lt;p&gt; If this class object represents a primitive type or void, then the</span>
 767      * name returned is a {@code String} equal to the Java language
 768      * keyword corresponding to the primitive type or void.
 769      *
<span class="line-modified"> 770      * &lt;p&gt; If this class object represents a class of arrays, then the internal</span>
 771      * form of the name consists of the name of the element type preceded by
 772      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 773      * nesting.  The encoding of element type names is as follows:
 774      *
 775      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 776      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 777      * &lt;thead&gt;
 778      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 779      * &lt;/thead&gt;
 780      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 781      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 782      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 783      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 784      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 785      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
 786      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 787      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 788      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 789      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 790      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 791      * &lt;/tbody&gt;
 792      * &lt;/table&gt;&lt;/blockquote&gt;
 793      *
 794      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 795      * the class specified above.
 796      *
 797      * &lt;p&gt; Examples:
 798      * &lt;blockquote&gt;&lt;pre&gt;
 799      * String.class.getName()
 800      *     returns &quot;java.lang.String&quot;
 801      * byte.class.getName()
 802      *     returns &quot;byte&quot;
 803      * (new Object[3]).getClass().getName()
 804      *     returns &quot;[Ljava.lang.Object;&quot;
 805      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 806      *     returns &quot;[[[[[[[I&quot;
 807      * &lt;/pre&gt;&lt;/blockquote&gt;
 808      *
 809      * @return  the name of the class or interface
<span class="line-modified"> 810      *          represented by this object.</span>
 811      */
 812     public String getName() {
 813         String name = this.name;
 814         return name != null ? name : initClassName();
 815     }
 816 
 817     // Cache the name to reduce the number of calls into the VM.
 818     // This field would be set by VM itself during initClassName call.
 819     private transient String name;
 820     private native String initClassName();
 821 
 822     /**
 823      * Returns the class loader for the class.  Some implementations may use
 824      * null to represent the bootstrap class loader. This method will return
 825      * null in such implementations if this class was loaded by the bootstrap
 826      * class loader.
 827      *
<span class="line-modified"> 828      * &lt;p&gt;If this object</span>
 829      * represents a primitive type or void, null is returned.
 830      *
 831      * @return  the class loader that loaded the class or interface
<span class="line-modified"> 832      *          represented by this object.</span>
 833      * @throws  SecurityException
 834      *          if a security manager is present, and the caller&#39;s class loader
 835      *          is not {@code null} and is not the same as or an ancestor of the
 836      *          class loader for the class whose class loader is requested,
 837      *          and the caller does not have the
 838      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 839      * @see java.lang.ClassLoader
 840      * @see SecurityManager#checkPermission
 841      * @see java.lang.RuntimePermission
 842      */
 843     @CallerSensitive
 844     @ForceInline // to ensure Reflection.getCallerClass optimization
 845     public ClassLoader getClassLoader() {
 846         ClassLoader cl = getClassLoader0();
 847         if (cl == null)
 848             return null;
 849         SecurityManager sm = System.getSecurityManager();
 850         if (sm != null) {
 851             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 852         }
</pre>
<hr />
<pre>
 879 
 880     // set by VM
 881     private transient Module module;
 882 
 883     // Initialized in JVM not by private constructor
 884     // This field is filtered from reflection access, i.e. getDeclaredField
 885     // will throw NoSuchFieldException
 886     private final ClassLoader classLoader;
 887 
 888     /**
 889      * Returns an array of {@code TypeVariable} objects that represent the
 890      * type variables declared by the generic declaration represented by this
 891      * {@code GenericDeclaration} object, in declaration order.  Returns an
 892      * array of length 0 if the underlying generic declaration declares no type
 893      * variables.
 894      *
 895      * @return an array of {@code TypeVariable} objects that represent
 896      *     the type variables declared by this generic declaration
 897      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 898      *     signature of this generic declaration does not conform to
<span class="line-modified"> 899      *     the format specified in</span>
<span class="line-modified"> 900      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
 901      * @since 1.5
 902      */
 903     @SuppressWarnings(&quot;unchecked&quot;)
 904     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 905         ClassRepository info = getGenericInfo();
 906         if (info != null)
 907             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
 908         else
 909             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 910     }
 911 
 912 
 913     /**
 914      * Returns the {@code Class} representing the direct superclass of the
 915      * entity (class, interface, primitive type or void) represented by
 916      * this {@code Class}.  If this {@code Class} represents either the
 917      * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified"> 918      * null is returned.  If this object represents an array class then the</span>
<span class="line-modified"> 919      * {@code Class} object representing the {@code Object} class is</span>
 920      * returned.
 921      *
<span class="line-modified"> 922      * @return the direct superclass of the class represented by this object</span>
 923      */
 924     @HotSpotIntrinsicCandidate
 925     public native Class&lt;? super T&gt; getSuperclass();
 926 
 927 
 928     /**
 929      * Returns the {@code Type} representing the direct superclass of
 930      * the entity (class, interface, primitive type or void) represented by
<span class="line-modified"> 931      * this {@code Class}.</span>
 932      *
 933      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 934      * object returned must accurately reflect the actual type
 935      * arguments used in the source code. The parameterized type
 936      * representing the superclass is created if it had not been
 937      * created before. See the declaration of {@link
 938      * java.lang.reflect.ParameterizedType ParameterizedType} for the
 939      * semantics of the creation process for parameterized types.  If
<span class="line-modified"> 940      * this {@code Class} represents either the {@code Object}</span>
 941      * class, an interface, a primitive type, or void, then null is
<span class="line-modified"> 942      * returned.  If this object represents an array class then the</span>
<span class="line-modified"> 943      * {@code Class} object representing the {@code Object} class is</span>
 944      * returned.
 945      *
 946      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 947      *     class signature does not conform to the format specified in
<span class="line-modified"> 948      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>

 949      * @throws TypeNotPresentException if the generic superclass
 950      *     refers to a non-existent type declaration
 951      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
 952      *     generic superclass refers to a parameterized type that cannot be
 953      *     instantiated  for any reason
<span class="line-modified"> 954      * @return the direct superclass of the class represented by this object</span>
 955      * @since 1.5
 956      */
 957     public Type getGenericSuperclass() {
 958         ClassRepository info = getGenericInfo();
 959         if (info == null) {
 960             return getSuperclass();
 961         }
 962 
 963         // Historical irregularity:
 964         // Generic signature marks interfaces with superclass = Object
 965         // but this API returns null for interfaces
 966         if (isInterface()) {
 967             return null;
 968         }
 969 
 970         return info.getSuperclass();
 971     }
 972 
 973     /**
 974      * Gets the package of this class.
</pre>
<hr />
<pre>
1023             while (c.isArray()) {
1024                 c = c.getComponentType();
1025             }
1026             if (c.isPrimitive()) {
1027                 pn = &quot;java.lang&quot;;
1028             } else {
1029                 String cn = c.getName();
1030                 int dot = cn.lastIndexOf(&#39;.&#39;);
1031                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1032             }
1033             this.packageName = pn;
1034         }
1035         return pn;
1036     }
1037 
1038     // cached package name
1039     private transient String packageName;
1040 
1041     /**
1042      * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">1043      * represented by this object.</span>
1044      *
<span class="line-modified">1045      * &lt;p&gt;If this object represents a class, the return value is an array</span>
1046      * containing objects representing all interfaces directly implemented by
1047      * the class.  The order of the interface objects in the array corresponds
1048      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1049      * the declaration of the class represented by this object.  For example,</span>
1050      * given the declaration:
1051      * &lt;blockquote&gt;
1052      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1053      * &lt;/blockquote&gt;
1054      * suppose the value of {@code s} is an instance of
1055      * {@code Shimmer}; the value of the expression:
1056      * &lt;blockquote&gt;
1057      * {@code s.getClass().getInterfaces()[0]}
1058      * &lt;/blockquote&gt;
1059      * is the {@code Class} object that represents interface
1060      * {@code FloorWax}; and the value of:
1061      * &lt;blockquote&gt;
1062      * {@code s.getClass().getInterfaces()[1]}
1063      * &lt;/blockquote&gt;
1064      * is the {@code Class} object that represents interface
1065      * {@code DessertTopping}.
1066      *
<span class="line-modified">1067      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
1068      * representing all interfaces directly extended by the interface.  The
1069      * order of the interface objects in the array corresponds to the order of
1070      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1071      * the interface represented by this object.</span>
1072      *
<span class="line-modified">1073      * &lt;p&gt;If this object represents a class or interface that implements no</span>
1074      * interfaces, the method returns an array of length 0.
1075      *
<span class="line-modified">1076      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
1077      * returns an array of length 0.
1078      *
1079      * &lt;p&gt;If this {@code Class} object represents an array type, the
1080      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1081      * returned in that order.
1082      *
1083      * @return an array of interfaces directly implemented by this class
1084      */
1085     public Class&lt;?&gt;[] getInterfaces() {
1086         // defensively copy before handing over to user code
1087         return getInterfaces(true);
1088     }
1089 
1090     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1091         ReflectionData&lt;T&gt; rd = reflectionData();
1092         if (rd == null) {
1093             // no cloning required
1094             return getInterfaces0();
1095         } else {
1096             Class&lt;?&gt;[] interfaces = rd.interfaces;
1097             if (interfaces == null) {
1098                 interfaces = getInterfaces0();
1099                 rd.interfaces = interfaces;
1100             }
1101             // defensively copy if requested
1102             return cloneArray ? interfaces.clone() : interfaces;
1103         }
1104     }
1105 
1106     private native Class&lt;?&gt;[] getInterfaces0();
1107 
1108     /**
1109      * Returns the {@code Type}s representing the interfaces
1110      * directly implemented by the class or interface represented by
<span class="line-modified">1111      * this object.</span>
1112      *
1113      * &lt;p&gt;If a superinterface is a parameterized type, the
1114      * {@code Type} object returned for it must accurately reflect
1115      * the actual type arguments used in the source code. The
1116      * parameterized type representing each superinterface is created
1117      * if it had not been created before. See the declaration of
1118      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1119      * for the semantics of the creation process for parameterized
1120      * types.
1121      *
<span class="line-modified">1122      * &lt;p&gt;If this object represents a class, the return value is an array</span>
1123      * containing objects representing all interfaces directly implemented by
1124      * the class.  The order of the interface objects in the array corresponds
1125      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1126      * the declaration of the class represented by this object.</span>
1127      *
<span class="line-modified">1128      * &lt;p&gt;If this object represents an interface, the array contains objects</span>
1129      * representing all interfaces directly extended by the interface.  The
1130      * order of the interface objects in the array corresponds to the order of
1131      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1132      * the interface represented by this object.</span>
1133      *
<span class="line-modified">1134      * &lt;p&gt;If this object represents a class or interface that implements no</span>
1135      * interfaces, the method returns an array of length 0.
1136      *
<span class="line-modified">1137      * &lt;p&gt;If this object represents a primitive type or void, the method</span>
1138      * returns an array of length 0.
1139      *
1140      * &lt;p&gt;If this {@code Class} object represents an array type, the
1141      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1142      * returned in that order.
1143      *
1144      * @throws java.lang.reflect.GenericSignatureFormatError
<span class="line-modified">1145      *     if the generic class signature does not conform to the format</span>
<span class="line-modified">1146      *     specified in</span>
<span class="line-modified">1147      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1148      * @throws TypeNotPresentException if any of the generic
1149      *     superinterfaces refers to a non-existent type declaration
1150      * @throws java.lang.reflect.MalformedParameterizedTypeException
1151      *     if any of the generic superinterfaces refer to a parameterized
1152      *     type that cannot be instantiated for any reason
1153      * @return an array of interfaces directly implemented by this class
1154      * @since 1.5
1155      */
1156     public Type[] getGenericInterfaces() {
1157         ClassRepository info = getGenericInfo();
1158         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1159     }
1160 
1161 
1162     /**
1163      * Returns the {@code Class} representing the component type of an
1164      * array.  If this class does not represent an array class this method
1165      * returns null.
1166      *
1167      * @return the {@code Class} representing the component type of this
</pre>
<hr />
<pre>
1175             return componentType;
1176         } else {
1177             return null;
1178         }
1179     }
1180 
1181     private final Class&lt;?&gt; componentType;
1182 
1183 
1184     /**
1185      * Returns the Java language modifiers for this class or interface, encoded
1186      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1187      * constants for {@code public}, {@code protected},
1188      * {@code private}, {@code final}, {@code static},
1189      * {@code abstract} and {@code interface}; they should be decoded
1190      * using the methods of class {@code Modifier}.
1191      *
1192      * &lt;p&gt; If the underlying class is an array class, then its
1193      * {@code public}, {@code private} and {@code protected}
1194      * modifiers are the same as those of its component type.  If this
<span class="line-modified">1195      * {@code Class} represents a primitive type or void, its</span>
1196      * {@code public} modifier is always {@code true}, and its
1197      * {@code protected} and {@code private} modifiers are always
<span class="line-modified">1198      * {@code false}. If this object represents an array class, a</span>
1199      * primitive type or void, then its {@code final} modifier is always
1200      * {@code true} and its interface modifier is always
1201      * {@code false}. The values of its other modifiers are not determined
1202      * by this specification.
1203      *
<span class="line-modified">1204      * &lt;p&gt; The modifier encodings are defined in &lt;em&gt;The Java Virtual Machine</span>
<span class="line-modified">1205      * Specification&lt;/em&gt;, table 4.1.</span>
1206      *
1207      * @return the {@code int} representing the modifiers for this class
1208      * @see     java.lang.reflect.Modifier
1209      * @since 1.1
1210      */
1211     @HotSpotIntrinsicCandidate
1212     public native int getModifiers();
1213 
1214 
1215     /**
1216      * Gets the signers of this class.
1217      *
1218      * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">1219      *          particular, this method returns null if this object represents</span>
1220      *          a primitive type or void.
1221      * @since   1.1
1222      */
1223     public native Object[] getSigners();
1224 
1225 
1226     /**
1227      * Set the signers of this class.
1228      */
1229     native void setSigners(Object[] signers);
1230 
1231 
1232     /**
1233      * If this {@code Class} object represents a local or anonymous
1234      * class within a method, returns a {@link
1235      * java.lang.reflect.Method Method} object representing the
1236      * immediately enclosing method of the underlying class. Returns
1237      * {@code null} otherwise.
1238      *
1239      * In particular, this method returns {@code null} if the underlying
</pre>
<hr />
<pre>
1593      *
1594      * @return an informative string for the name of this type
1595      * @since 1.8
1596      */
1597     public String getTypeName() {
1598         if (isArray()) {
1599             try {
1600                 Class&lt;?&gt; cl = this;
1601                 int dimensions = 0;
1602                 do {
1603                     dimensions++;
1604                     cl = cl.getComponentType();
1605                 } while (cl.isArray());
1606                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);
1607             } catch (Throwable e) { /*FALLTHRU*/ }
1608         }
1609         return getName();
1610     }
1611 
1612     /**
<span class="line-modified">1613      * Returns the canonical name of the underlying class as</span>
<span class="line-modified">1614      * defined by the Java Language Specification.  Returns null if</span>
<span class="line-modified">1615      * the underlying class does not have a canonical name (i.e., if</span>
<span class="line-modified">1616      * it is a local or anonymous class or an array whose component</span>
<span class="line-modified">1617      * type does not have a canonical name).</span>
1618      * @return the canonical name of the underlying class if it exists, and
1619      * {@code null} otherwise.
1620      * @since 1.5
1621      */
1622     public String getCanonicalName() {
1623         ReflectionData&lt;T&gt; rd = reflectionData();
1624         String canonicalName = rd.canonicalName;
1625         if (canonicalName == null) {
1626             rd.canonicalName = canonicalName = getCanonicalName0();
1627         }
1628         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1629     }
1630 
1631     private String getCanonicalName0() {
1632         if (isArray()) {
1633             String canonicalName = getComponentType().getCanonicalName();
1634             if (canonicalName != null)
1635                 return canonicalName + &quot;[]&quot;;
1636             else
1637                 return ReflectionData.NULL_SENTINEL;
</pre>
<hr />
<pre>
1911      * @jls 8.4 Method Declarations
1912      * @since 1.1
1913      */
1914     @CallerSensitive
1915     public Method[] getMethods() throws SecurityException {
1916         SecurityManager sm = System.getSecurityManager();
1917         if (sm != null) {
1918             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1919         }
1920         return copyMethods(privateGetPublicMethods());
1921     }
1922 
1923 
1924     /**
1925      * Returns an array containing {@code Constructor} objects reflecting
1926      * all the public constructors of the class represented by this
1927      * {@code Class} object.  An array of length 0 is returned if the
1928      * class has no public constructors, or if the class is an array class, or
1929      * if the class reflects a primitive type or void.
1930      *
<span class="line-modified">1931      * Note that while this method returns an array of {@code</span>

1932      * Constructor&lt;T&gt;} objects (that is an array of constructors from
1933      * this class), the return type of this method is {@code
1934      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
1935      * might be expected.  This less informative return type is
1936      * necessary since after being returned from this method, the
1937      * array could be modified to hold {@code Constructor} objects for
1938      * different classes, which would violate the type guarantees of
1939      * {@code Constructor&lt;T&gt;[]}.
1940      *
1941      * @return the array of {@code Constructor} objects representing the
1942      *         public constructors of this class
1943      * @throws SecurityException
1944      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1945      *         the caller&#39;s class loader is not the same as or an
1946      *         ancestor of the class loader for the current class and
1947      *         invocation of {@link SecurityManager#checkPackageAccess
1948      *         s.checkPackageAccess()} denies access to the package
1949      *         of this class.
1950      *
1951      * @since 1.1
1952      */
1953     @CallerSensitive
1954     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
1955         SecurityManager sm = System.getSecurityManager();
1956         if (sm != null) {
1957             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1958         }
1959         return copyConstructors(privateGetDeclaredConstructors(true));
1960     }
1961 
1962 
1963     /**
1964      * Returns a {@code Field} object that reflects the specified public member
1965      * field of the class or interface represented by this {@code Class}
1966      * object. The {@code name} parameter is a {@code String} specifying the
1967      * simple name of the desired field.
1968      *
1969      * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">1970      * follows.  Let C be the class or interface represented by this object:</span>
1971      *
1972      * &lt;OL&gt;
1973      * &lt;LI&gt; If C declares a public field with the name specified, that is the
1974      *      field to be reflected.&lt;/LI&gt;
1975      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
1976      *      recursively to each direct superinterface of C. The direct
1977      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
1978      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
1979      *      superclass S, then this algorithm is invoked recursively upon S.
1980      *      If C has no superclass, then a {@code NoSuchFieldException}
1981      *      is thrown.&lt;/LI&gt;
1982      * &lt;/OL&gt;
1983      *
1984      * &lt;p&gt; If this {@code Class} object represents an array type, then this
1985      * method does not find the {@code length} field of the array type.
1986      *
1987      * @param name the field name
1988      * @return the {@code Field} object of this class specified by
1989      *         {@code name}
1990      * @throws NoSuchFieldException if a field with the specified name is
</pre>
<hr />
<pre>
2384     public Method[] getDeclaredMethods() throws SecurityException {
2385         SecurityManager sm = System.getSecurityManager();
2386         if (sm != null) {
2387             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2388         }
2389         return copyMethods(privateGetDeclaredMethods(false));
2390     }
2391 
2392 
2393     /**
2394      * Returns an array of {@code Constructor} objects reflecting all the
2395      * constructors declared by the class represented by this
2396      * {@code Class} object. These are public, protected, default
2397      * (package) access, and private constructors.  The elements in the array
2398      * returned are not sorted and are not in any particular order.  If the
2399      * class has a default constructor, it is included in the returned array.
2400      * This method returns an array of length 0 if this {@code Class}
2401      * object represents an interface, a primitive type, an array class, or
2402      * void.
2403      *
<span class="line-modified">2404      * &lt;p&gt; See &lt;em&gt;The Java Language Specification&lt;/em&gt;, section {@jls 8.2}.</span>

2405      *
2406      * @return  the array of {@code Constructor} objects representing all the
2407      *          declared constructors of this class
2408      * @throws  SecurityException
2409      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2410      *          following conditions is met:
2411      *
2412      *          &lt;ul&gt;
2413      *
2414      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2415      *          class loader of this class and invocation of
2416      *          {@link SecurityManager#checkPermission
2417      *          s.checkPermission} method with
2418      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2419      *          denies access to the declared constructors within this class
2420      *
2421      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2422      *          ancestor of the class loader for the current class and
2423      *          invocation of {@link SecurityManager#checkPackageAccess
2424      *          s.checkPackageAccess()} denies access to the package
</pre>
<hr />
<pre>
2634     }
2635 
2636     /**
2637      * Finds a resource with a given name.
2638      *
2639      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2640      * will attempt to find the resource in the module. This is done by
2641      * delegating to the module&#39;s class loader {@link
2642      * ClassLoader#findResource(String,String) findResource(String,String)}
2643      * method, invoking it with the module name and the absolute name of the
2644      * resource. Resources in named modules are subject to the rules for
2645      * encapsulation specified in the {@code Module} {@link
2646      * Module#getResourceAsStream getResourceAsStream} method and so this
2647      * method returns {@code null} when the resource is a
2648      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2649      * caller&#39;s module.
2650      *
2651      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2652      * searching resources associated with a given class are implemented by the
2653      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2654      * delegates to this object&#39;s class loader.  If this object was loaded by</span>
<span class="line-modified">2655      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">2656      * ClassLoader#getSystemResourceAsStream}.</span>
2657      *
2658      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2659      * given resource name using this algorithm:
2660      *
2661      * &lt;ul&gt;
2662      *
2663      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2664      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2665      * portion of the {@code name} following the {@code &#39;/&#39;}.
2666      *
2667      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2668      *
2669      * &lt;blockquote&gt;
2670      *   {@code modified_package_name/name}
2671      * &lt;/blockquote&gt;
2672      *
2673      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2674      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2675      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2676      *
</pre>
<hr />
<pre>
2732     }
2733 
2734     /**
2735      * Finds a resource with a given name.
2736      *
2737      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2738      * will attempt to find the resource in the module. This is done by
2739      * delegating to the module&#39;s class loader {@link
2740      * ClassLoader#findResource(String,String) findResource(String,String)}
2741      * method, invoking it with the module name and the absolute name of the
2742      * resource. Resources in named modules are subject to the rules for
2743      * encapsulation specified in the {@code Module} {@link
2744      * Module#getResourceAsStream getResourceAsStream} method and so this
2745      * method returns {@code null} when the resource is a
2746      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2747      * caller&#39;s module.
2748      *
2749      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2750      * searching resources associated with a given class are implemented by the
2751      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2752      * delegates to this object&#39;s class loader. If this object was loaded by</span>
<span class="line-modified">2753      * the bootstrap class loader, the method delegates to {@link</span>
<span class="line-modified">2754      * ClassLoader#getSystemResource}.</span>
2755      *
2756      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2757      * given resource name using this algorithm:
2758      *
2759      * &lt;ul&gt;
2760      *
2761      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2762      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2763      * portion of the {@code name} following the {@code &#39;/&#39;}.
2764      *
2765      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2766      *
2767      * &lt;blockquote&gt;
2768      *   {@code modified_package_name/name}
2769      * &lt;/blockquote&gt;
2770      *
2771      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2772      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2773      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2774      *
</pre>
<hr />
<pre>
3521      * is written into the stream. Future references to the class descriptor
3522      * are written as references to the initial class descriptor instance.
3523      *
3524      * @see java.io.ObjectStreamClass
3525      */
3526     @java.io.Serial
3527     private static final ObjectStreamField[] serialPersistentFields =
3528         new ObjectStreamField[0];
3529 
3530 
3531     /**
3532      * Returns the assertion status that would be assigned to this
3533      * class if it were to be initialized at the time this method is invoked.
3534      * If this class has had its assertion status set, the most recent
3535      * setting will be returned; otherwise, if any package default assertion
3536      * status pertains to this class, the most recent setting for the most
3537      * specific pertinent package default assertion status is returned;
3538      * otherwise, if this class is not a system class (i.e., it has a
3539      * class loader) its class loader&#39;s default assertion status is returned;
3540      * otherwise, the system class default assertion status is returned.
<span class="line-modified">3541      * &lt;p&gt;</span>

3542      * Few programmers will have any need for this method; it is provided
<span class="line-modified">3543      * for the benefit of the JRE itself.  (It allows a class to determine at</span>
3544      * the time that it is initialized whether assertions should be enabled.)
3545      * Note that this method is not guaranteed to return the actual
3546      * assertion status that was (or will be) associated with the specified
3547      * class when it was (or will be) initialized.
3548      *
3549      * @return the desired assertion status of the specified class.
3550      * @see    java.lang.ClassLoader#setClassAssertionStatus
3551      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3552      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3553      * @since  1.4
3554      */
3555     public boolean desiredAssertionStatus() {
3556         ClassLoader loader = getClassLoader0();
3557         // If the loader is null this is a system class, so ask the VM
3558         if (loader == null)
3559             return desiredAssertionStatus0(this);
3560 
3561         // If the classloader has been initialized with the assertion
3562         // directives, ask it. Otherwise, ask the VM.
3563         synchronized(loader.assertionLock) {
</pre>
<hr />
<pre>
3634     public boolean isRecord() {
3635         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3636     }
3637 
3638     // Fetches the factory for reflective objects
3639     private static ReflectionFactory getReflectionFactory() {
3640         if (reflectionFactory == null) {
3641             reflectionFactory =
3642                 java.security.AccessController.doPrivileged
3643                     (new ReflectionFactory.GetReflectionFactoryAction());
3644         }
3645         return reflectionFactory;
3646     }
3647     private static ReflectionFactory reflectionFactory;
3648 
3649     /**
3650      * Returns the elements of this enum class or null if this
3651      * Class object does not represent an enum type.
3652      *
3653      * @return an array containing the values comprising the enum class
<span class="line-modified">3654      *     represented by this Class object in the order they&#39;re</span>
<span class="line-modified">3655      *     declared, or null if this Class object does not</span>
3656      *     represent an enum type
3657      * @since 1.5
3658      */
3659     public T[] getEnumConstants() {
3660         T[] values = getEnumConstantsShared();
3661         return (values != null) ? values.clone() : null;
3662     }
3663 
3664     /**
3665      * Returns the elements of this enum class or null if this
3666      * Class object does not represent an enum type;
3667      * identical to getEnumConstants except that the result is
3668      * uncloned, cached, and shared by all callers.
3669      */
3670     T[] getEnumConstantsShared() {
3671         T[] constants = enumConstants;
3672         if (constants == null) {
3673             if (!isEnum()) return null;
3674             try {
3675                 final Method values = getMethod(&quot;values&quot;);
</pre>
<hr />
<pre>
3728      * null and is not assignable to the type T.
3729      *
3730      * @since 1.5
3731      */
3732     @SuppressWarnings(&quot;unchecked&quot;)
3733     @HotSpotIntrinsicCandidate
3734     public T cast(Object obj) {
3735         if (obj != null &amp;&amp; !isInstance(obj))
3736             throw new ClassCastException(cannotCastMsg(obj));
3737         return (T) obj;
3738     }
3739 
3740     private String cannotCastMsg(Object obj) {
3741         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3742     }
3743 
3744     /**
3745      * Casts this {@code Class} object to represent a subclass of the class
3746      * represented by the specified class object.  Checks that the cast
3747      * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">3748      * this method succeeds, it always returns a reference to this class object.</span>
3749      *
3750      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3751      * a {@code Class} object to pass it to an API that restricts the
3752      * {@code Class} objects that it is willing to accept.  A cast would
3753      * generate a compile-time warning, as the correctness of the cast
3754      * could not be checked at runtime (because generic types are implemented
3755      * by erasure).
3756      *
<span class="line-modified">3757      * @param &lt;U&gt; the type to cast this class object to</span>
<span class="line-modified">3758      * @param clazz the class of the type to cast this class object to</span>
3759      * @return this {@code Class} object, cast to represent a subclass of
3760      *    the specified class object.
3761      * @throws ClassCastException if this {@code Class} object does not
3762      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3763      *    the class itself).
3764      * @since 1.5
3765      */
3766     @SuppressWarnings(&quot;unchecked&quot;)
3767     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3768         if (clazz.isAssignableFrom(this))
3769             return (Class&lt;? extends U&gt;) this;
3770         else
3771             throw new ClassCastException(this.toString());
3772     }
3773 
3774     /**




3775      * @throws NullPointerException {@inheritDoc}
3776      * @since 1.5
3777      */

3778     @SuppressWarnings(&quot;unchecked&quot;)
3779     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3780         Objects.requireNonNull(annotationClass);
3781 
3782         return (A) annotationData().annotations.get(annotationClass);
3783     }
3784 
3785     /**
3786      * {@inheritDoc}
3787      * @throws NullPointerException {@inheritDoc}
3788      * @since 1.5
3789      */
3790     @Override
3791     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3792         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3793     }
3794 
3795     /**




3796      * @throws NullPointerException {@inheritDoc}
3797      * @since 1.8
3798      */
3799     @Override
3800     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3801         Objects.requireNonNull(annotationClass);
3802 
3803         AnnotationData annotationData = annotationData();
3804         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3805                                                           this,
3806                                                           annotationClass);
3807     }
3808 
3809     /**




3810      * @since 1.5
3811      */

3812     public Annotation[] getAnnotations() {
3813         return AnnotationParser.toArray(annotationData().annotations);
3814     }
3815 
3816     /**




3817      * @throws NullPointerException {@inheritDoc}
3818      * @since 1.8
3819      */
3820     @Override
3821     @SuppressWarnings(&quot;unchecked&quot;)
3822     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3823         Objects.requireNonNull(annotationClass);
3824 
3825         return (A) annotationData().declaredAnnotations.get(annotationClass);
3826     }
3827 
3828     /**




3829      * @throws NullPointerException {@inheritDoc}
3830      * @since 1.8
3831      */
3832     @Override
3833     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3834         Objects.requireNonNull(annotationClass);
3835 
3836         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3837                                                                  annotationClass);
3838     }
3839 
3840     /**




3841      * @since 1.5
3842      */

3843     public Annotation[] getDeclaredAnnotations()  {
3844         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3845     }
3846 
3847     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3848     private static class AnnotationData {
3849         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
3850         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
3851 
3852         // Value of classRedefinedCount when we created this AnnotationData instance
3853         final int redefinedCount;
3854 
3855         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
3856                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
3857                        int redefinedCount) {
3858             this.annotations = annotations;
3859             this.declaredAnnotations = declaredAnnotations;
3860             this.redefinedCount = redefinedCount;
3861         }
3862     }
</pre>
<hr />
<pre>
4008     /**
4009      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4010      * or interface represented by this {@code Class} object belongs.
4011      * Every class and interface is a member of exactly one nest.
4012      * A class or interface that is not recorded as belonging to a nest
4013      * belongs to the nest consisting only of itself, and is the nest
4014      * host.
4015      *
4016      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4017      * primitive types, and {@code void} returns {@code this} to indicate
4018      * that the represented entity belongs to the nest consisting only of
4019      * itself, and is the nest host.
4020      *
4021      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4022      * the nest host, or if this class or interface is not enumerated as
4023      * a member of the nest by the nest host, then it is considered to belong
4024      * to its own nest and {@code this} is returned as the host.
4025      *
4026      * @apiNote A {@code class} file of version 55.0 or greater may record the
4027      * host of the nest to which it belongs by using the {@code NestHost}
<span class="line-modified">4028      * attribute (JVMS 4.7.28). Alternatively, a {@code class} file of</span>
4029      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4030      * other members with the
<span class="line-modified">4031      * {@code NestMembers} attribute (JVMS 4.7.29).</span>
4032      * A {@code class} file of version 54.0 or lower does not use these
4033      * attributes.
4034      *
4035      * @return the nest host of this class or interface
4036      *
4037      * @throws SecurityException
4038      *         If the returned class is not the current class, and
4039      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4040      *         class loader is not the same as or an ancestor of the class
4041      *         loader for the returned class and invocation of {@link
4042      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4043      *         denies access to the package of the returned class
4044      * @since 11
4045      * @jvms 4.7.28 The {@code NestHost} Attribute
4046      * @jvms 4.7.29 The {@code NestMembers} Attribute
4047      * @jvms 5.4.4 Access Control
4048      */
4049     @CallerSensitive
4050     public Class&lt;?&gt; getNestHost() {
4051         if (isPrimitive() || isArray()) {
</pre>
</td>
<td>
<hr />
<pre>
 122  * &lt;em&gt;nest host&lt;/em&gt;, and enumerates the other nestmates which
 123  * belong to the nest; each of them in turn records it as the nest host.
 124  * The classes and interfaces which belong to a nest, including its host, are
 125  * determined when
 126  * {@code class} files are generated, for example, a Java compiler
 127  * will typically record a top-level class as the host of a nest where the
 128  * other members are the classes and interfaces whose declarations are
 129  * enclosed within the top-level class declaration.
 130  *
 131  * &lt;p&gt; The following example uses a {@code Class} object to print the
 132  * class name of an object:
 133  *
 134  * &lt;blockquote&gt;&lt;pre&gt;
 135  *     void printClassName(Object obj) {
 136  *         System.out.println(&quot;The class of &quot; + obj +
 137  *                            &quot; is &quot; + obj.getClass().getName());
 138  *     }
 139  * &lt;/pre&gt;&lt;/blockquote&gt;
 140  *
 141  * &lt;p&gt; It is also possible to get the {@code Class} object for a named
<span class="line-modified"> 142  * type (or for void) using a class literal.  See Section {@jls</span>
<span class="line-modified"> 143  * 15.8.2} of &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 144  * For example:
 145  *
 146  * &lt;blockquote&gt;
<span class="line-modified"> 147  *     {@code System.out.println(&quot;The name of class Foo is: &quot; + Foo.class.getName());}</span>
 148  * &lt;/blockquote&gt;
 149  *
 150  * @param &lt;T&gt; the type of the class modeled by this {@code Class}
 151  * object.  For example, the type of {@code String.class} is {@code
 152  * Class&lt;String&gt;}.  Use {@code Class&lt;?&gt;} if the class being modeled is
 153  * unknown.
 154  *
 155  * @author  unascribed
 156  * @see     java.lang.ClassLoader#defineClass(byte[], int, int)
 157  * @since   1.0
 158  */
 159 public final class Class&lt;T&gt; implements java.io.Serializable,
 160                               GenericDeclaration,
 161                               Type,
 162                               AnnotatedElement,
 163                               TypeDescriptor.OfField&lt;Class&lt;?&gt;&gt;,
 164                               Constable {
 165     private static final int ANNOTATION= 0x00002000;
 166     private static final int ENUM      = 0x00004000;
 167     private static final int SYNTHETIC = 0x00001000;
</pre>
<hr />
<pre>
 176      * This constructor is not used and prevents the default constructor being
 177      * generated.
 178      */
 179     private Class(ClassLoader loader, Class&lt;?&gt; arrayComponentType) {
 180         // Initialize final field for classLoader.  The initialization value of non-null
 181         // prevents future JIT optimizations from assuming this final field is null.
 182         classLoader = loader;
 183         componentType = arrayComponentType;
 184     }
 185 
 186     /**
 187      * Converts the object to a string. The string representation is the
 188      * string &quot;class&quot; or &quot;interface&quot;, followed by a space, and then by the
 189      * fully qualified name of the class in the format returned by
 190      * {@code getName}.  If this {@code Class} object represents a
 191      * primitive type, this method returns the name of the primitive type.  If
 192      * this {@code Class} object represents void this method returns
 193      * &quot;void&quot;. If this {@code Class} object represents an array type,
 194      * this method returns &quot;class &quot; followed by {@code getName}.
 195      *
<span class="line-modified"> 196      * @return a string representation of this {@code Class} object.</span>
 197      */
 198     public String toString() {
 199         return (isInterface() ? &quot;interface &quot; : (isPrimitive() ? &quot;&quot; : &quot;class &quot;))
 200             + getName();
 201     }
 202 
 203     /**
 204      * Returns a string describing this {@code Class}, including
 205      * information about modifiers and type parameters.
 206      *
 207      * The string is formatted as a list of type modifiers, if any,
 208      * followed by the kind of type (empty string for primitive types
 209      * and {@code class}, {@code enum}, {@code interface},
<span class="line-modified"> 210      * {@code @interface}, or {@code record} as appropriate), followed</span>
 211      * by the type&#39;s name, followed by an angle-bracketed
 212      * comma-separated list of the type&#39;s type parameters, if any,
 213      * including informative bounds on the type parameters, if any.
 214      *
 215      * A space is used to separate modifiers from one another and to
 216      * separate any modifiers from the kind of type. The modifiers
 217      * occur in canonical order. If there are no type parameters, the
 218      * type parameter list is elided.
 219      *
 220      * For an array type, the string starts with the type name,
 221      * followed by an angle-bracketed comma-separated list of the
 222      * type&#39;s type parameters, if any, followed by a sequence of
 223      * {@code []} characters, one set of brackets per dimension of
 224      * the array.
 225      *
 226      * &lt;p&gt;Note that since information about the runtime representation
 227      * of a type is being generated, modifiers not present on the
 228      * originating source code or illegal on the originating source
 229      * code may be present.
 230      *
</pre>
<hr />
<pre>
 359      * obtain any of the {@code Class} objects representing primitive
 360      * types or void.
 361      *
 362      * &lt;p&gt; If {@code name} denotes an array class, the component type of
 363      * the array class is loaded but not initialized.
 364      *
 365      * &lt;p&gt; For example, in an instance method the expression:
 366      *
 367      * &lt;blockquote&gt;
 368      *  {@code Class.forName(&quot;Foo&quot;)}
 369      * &lt;/blockquote&gt;
 370      *
 371      * is equivalent to:
 372      *
 373      * &lt;blockquote&gt;
 374      *  {@code Class.forName(&quot;Foo&quot;, true, this.getClass().getClassLoader())}
 375      * &lt;/blockquote&gt;
 376      *
 377      * Note that this method throws errors related to loading, linking
 378      * or initializing as specified in Sections {@jls 12.2}, {@jls
<span class="line-modified"> 379      * 12.3}, and {@jls 12.4} of &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified"> 380      * Specification&lt;/cite&gt;.</span>
 381      * Note that this method does not check whether the requested class
 382      * is accessible to its caller.
 383      *
 384      * @param name       fully qualified name of the desired class
<span class="line-modified"> 385 </span>
<span class="line-modified"> 386      * @param initialize if {@code true} the class will be initialized</span>
<span class="line-added"> 387      *                   (which implies linking). See Section {@jls</span>
<span class="line-added"> 388      *                   12.4} of &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-added"> 389      *                   Specification&lt;/cite&gt;.</span>
 390      * @param loader     class loader from which the class must be loaded
 391      * @return           class object representing the desired class
 392      *
 393      * @throws    LinkageError if the linkage fails
 394      * @throws    ExceptionInInitializerError if the initialization provoked
 395      *            by this method fails
 396      * @throws    ClassNotFoundException if the class cannot be located by
 397      *            the specified class loader
 398      * @throws    SecurityException
 399      *            if a security manager is present, and the {@code loader} is
 400      *            {@code null}, and the caller&#39;s class loader is not
 401      *            {@code null}, and the caller does not have the
 402      *            {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 403      *
 404      * @see       java.lang.Class#forName(String)
 405      * @see       java.lang.ClassLoader
 406      *
 407      * @jls 12.2 Loading of Classes and Interfaces
 408      * @jls 12.3 Linking of Classes and Interfaces
 409      * @jls 12.4 Initialization of Classes and Interfaces
</pre>
<hr />
<pre>
 646      * @since 1.1
 647      */
 648     @HotSpotIntrinsicCandidate
 649     public native boolean isInstance(Object obj);
 650 
 651 
 652     /**
 653      * Determines if the class or interface represented by this
 654      * {@code Class} object is either the same as, or is a superclass or
 655      * superinterface of, the class or interface represented by the specified
 656      * {@code Class} parameter. It returns {@code true} if so;
 657      * otherwise it returns {@code false}. If this {@code Class}
 658      * object represents a primitive type, this method returns
 659      * {@code true} if the specified {@code Class} parameter is
 660      * exactly this {@code Class} object; otherwise it returns
 661      * {@code false}.
 662      *
 663      * &lt;p&gt; Specifically, this method tests whether the type represented by the
 664      * specified {@code Class} parameter can be converted to the type
 665      * represented by this {@code Class} object via an identity conversion
<span class="line-modified"> 666      * or via a widening reference conversion. See &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified"> 667      * Specification&lt;/cite&gt;, sections {@jls 5.1.1} and {@jls 5.1.4},</span>
 668      * for details.
 669      *
 670      * @param     cls the {@code Class} object to be checked
 671      * @return    the {@code boolean} value indicating whether objects of the
 672      *            type {@code cls} can be assigned to objects of this class
 673      * @throws    NullPointerException if the specified Class parameter is
 674      *            null.
 675      * @since     1.1
 676      */
 677     @HotSpotIntrinsicCandidate
 678     public native boolean isAssignableFrom(Class&lt;?&gt; cls);
 679 
 680 
 681     /**
<span class="line-modified"> 682      * Determines if this {@code Class} object represents an</span>
 683      * interface type.
 684      *
<span class="line-modified"> 685      * @return  {@code true} if this {@code Class} object represents an interface;</span>
 686      *          {@code false} otherwise.
 687      */
 688     @HotSpotIntrinsicCandidate
 689     public native boolean isInterface();
 690 
 691 
 692     /**
 693      * Determines if this {@code Class} object represents an array class.
 694      *
<span class="line-modified"> 695      * @return  {@code true} if this {@code Class} object represents an array class;</span>
 696      *          {@code false} otherwise.
 697      * @since   1.1
 698      */
 699     @HotSpotIntrinsicCandidate
 700     public native boolean isArray();
 701 
 702 
 703     /**
 704      * Determines if the specified {@code Class} object represents a
 705      * primitive type.
 706      *
 707      * &lt;p&gt; There are nine predefined {@code Class} objects to represent
 708      * the eight primitive types and void.  These are created by the Java
 709      * Virtual Machine, and have the same names as the primitive types that
 710      * they represent, namely {@code boolean}, {@code byte},
 711      * {@code char}, {@code short}, {@code int},
 712      * {@code long}, {@code float}, and {@code double}.
 713      *
 714      * &lt;p&gt; These objects may only be accessed via the following public static
 715      * final variables, and are the only {@code Class} objects for which
</pre>
<hr />
<pre>
 719      *
 720      * @see     java.lang.Boolean#TYPE
 721      * @see     java.lang.Character#TYPE
 722      * @see     java.lang.Byte#TYPE
 723      * @see     java.lang.Short#TYPE
 724      * @see     java.lang.Integer#TYPE
 725      * @see     java.lang.Long#TYPE
 726      * @see     java.lang.Float#TYPE
 727      * @see     java.lang.Double#TYPE
 728      * @see     java.lang.Void#TYPE
 729      * @since 1.1
 730      */
 731     @HotSpotIntrinsicCandidate
 732     public native boolean isPrimitive();
 733 
 734     /**
 735      * Returns true if this {@code Class} object represents an annotation
 736      * type.  Note that if this method returns true, {@link #isInterface()}
 737      * would also return true, as all annotation types are also interfaces.
 738      *
<span class="line-modified"> 739      * @return {@code true} if this {@code Class} object represents an annotation</span>
 740      *      type; {@code false} otherwise
 741      * @since 1.5
 742      */
 743     public boolean isAnnotation() {
 744         return (getModifiers() &amp; ANNOTATION) != 0;
 745     }
 746 
 747     /**
 748      * Returns {@code true} if this class is a synthetic class;
 749      * returns {@code false} otherwise.
 750      * @return {@code true} if and only if this class is a synthetic class as
<span class="line-modified"> 751      *         defined by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;.</span>
 752      * @jls 13.1 The Form of a Binary
 753      * @since 1.5
 754      */
 755     public boolean isSynthetic() {
 756         return (getModifiers() &amp; SYNTHETIC) != 0;
 757     }
 758 
 759     /**
 760      * Returns the  name of the entity (class, interface, array class,
 761      * primitive type, or void) represented by this {@code Class} object,
 762      * as a {@code String}.
 763      *
<span class="line-modified"> 764      * &lt;p&gt; If this {@code Class} object represents a reference type that is</span>
<span class="line-modified"> 765      * not an array type then the binary name of the class is</span>
<span class="line-modified"> 766      * returned, as specified by &lt;cite&gt;The Java&amp;trade; Language</span>
<span class="line-modified"> 767      * Specification&lt;/cite&gt;.</span>
 768      *
<span class="line-modified"> 769      * &lt;p&gt; If this {@code Class} object represents a primitive type or void, then the</span>
 770      * name returned is a {@code String} equal to the Java language
 771      * keyword corresponding to the primitive type or void.
 772      *
<span class="line-modified"> 773      * &lt;p&gt; If this {@code Class} object represents a class of arrays, then the internal</span>
 774      * form of the name consists of the name of the element type preceded by
 775      * one or more &#39;{@code [}&#39; characters representing the depth of the array
 776      * nesting.  The encoding of element type names is as follows:
 777      *
 778      * &lt;blockquote&gt;&lt;table class=&quot;striped&quot;&gt;
 779      * &lt;caption style=&quot;display:none&quot;&gt;Element types and encodings&lt;/caption&gt;
 780      * &lt;thead&gt;
 781      * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt; Element Type &lt;th scope=&quot;col&quot;&gt; Encoding
 782      * &lt;/thead&gt;
 783      * &lt;tbody style=&quot;text-align:left&quot;&gt;
 784      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; boolean      &lt;td style=&quot;text-align:center&quot;&gt; Z
 785      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; byte         &lt;td style=&quot;text-align:center&quot;&gt; B
 786      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; char         &lt;td style=&quot;text-align:center&quot;&gt; C
 787      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; class or interface
 788      *                                   &lt;td style=&quot;text-align:center&quot;&gt; L&lt;i&gt;classname&lt;/i&gt;;
 789      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; double       &lt;td style=&quot;text-align:center&quot;&gt; D
 790      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; float        &lt;td style=&quot;text-align:center&quot;&gt; F
 791      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; int          &lt;td style=&quot;text-align:center&quot;&gt; I
 792      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; long         &lt;td style=&quot;text-align:center&quot;&gt; J
 793      * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt; short        &lt;td style=&quot;text-align:center&quot;&gt; S
 794      * &lt;/tbody&gt;
 795      * &lt;/table&gt;&lt;/blockquote&gt;
 796      *
 797      * &lt;p&gt; The class or interface name &lt;i&gt;classname&lt;/i&gt; is the binary name of
 798      * the class specified above.
 799      *
 800      * &lt;p&gt; Examples:
 801      * &lt;blockquote&gt;&lt;pre&gt;
 802      * String.class.getName()
 803      *     returns &quot;java.lang.String&quot;
 804      * byte.class.getName()
 805      *     returns &quot;byte&quot;
 806      * (new Object[3]).getClass().getName()
 807      *     returns &quot;[Ljava.lang.Object;&quot;
 808      * (new int[3][4][5][6][7][8][9]).getClass().getName()
 809      *     returns &quot;[[[[[[[I&quot;
 810      * &lt;/pre&gt;&lt;/blockquote&gt;
 811      *
 812      * @return  the name of the class or interface
<span class="line-modified"> 813      *          represented by this {@code Class} object.</span>
 814      */
 815     public String getName() {
 816         String name = this.name;
 817         return name != null ? name : initClassName();
 818     }
 819 
 820     // Cache the name to reduce the number of calls into the VM.
 821     // This field would be set by VM itself during initClassName call.
 822     private transient String name;
 823     private native String initClassName();
 824 
 825     /**
 826      * Returns the class loader for the class.  Some implementations may use
 827      * null to represent the bootstrap class loader. This method will return
 828      * null in such implementations if this class was loaded by the bootstrap
 829      * class loader.
 830      *
<span class="line-modified"> 831      * &lt;p&gt;If this {@code Class} object</span>
 832      * represents a primitive type or void, null is returned.
 833      *
 834      * @return  the class loader that loaded the class or interface
<span class="line-modified"> 835      *          represented by this {@code Class} object.</span>
 836      * @throws  SecurityException
 837      *          if a security manager is present, and the caller&#39;s class loader
 838      *          is not {@code null} and is not the same as or an ancestor of the
 839      *          class loader for the class whose class loader is requested,
 840      *          and the caller does not have the
 841      *          {@link RuntimePermission}{@code (&quot;getClassLoader&quot;)}
 842      * @see java.lang.ClassLoader
 843      * @see SecurityManager#checkPermission
 844      * @see java.lang.RuntimePermission
 845      */
 846     @CallerSensitive
 847     @ForceInline // to ensure Reflection.getCallerClass optimization
 848     public ClassLoader getClassLoader() {
 849         ClassLoader cl = getClassLoader0();
 850         if (cl == null)
 851             return null;
 852         SecurityManager sm = System.getSecurityManager();
 853         if (sm != null) {
 854             ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass());
 855         }
</pre>
<hr />
<pre>
 882 
 883     // set by VM
 884     private transient Module module;
 885 
 886     // Initialized in JVM not by private constructor
 887     // This field is filtered from reflection access, i.e. getDeclaredField
 888     // will throw NoSuchFieldException
 889     private final ClassLoader classLoader;
 890 
 891     /**
 892      * Returns an array of {@code TypeVariable} objects that represent the
 893      * type variables declared by the generic declaration represented by this
 894      * {@code GenericDeclaration} object, in declaration order.  Returns an
 895      * array of length 0 if the underlying generic declaration declares no type
 896      * variables.
 897      *
 898      * @return an array of {@code TypeVariable} objects that represent
 899      *     the type variables declared by this generic declaration
 900      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 901      *     signature of this generic declaration does not conform to
<span class="line-modified"> 902      *     the format specified in section {@jvms 4.7.9} of</span>
<span class="line-modified"> 903      *     &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;,</span>
 904      * @since 1.5
 905      */
 906     @SuppressWarnings(&quot;unchecked&quot;)
 907     public TypeVariable&lt;Class&lt;T&gt;&gt;[] getTypeParameters() {
 908         ClassRepository info = getGenericInfo();
 909         if (info != null)
 910             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])info.getTypeParameters();
 911         else
 912             return (TypeVariable&lt;Class&lt;T&gt;&gt;[])new TypeVariable&lt;?&gt;[0];
 913     }
 914 
 915 
 916     /**
 917      * Returns the {@code Class} representing the direct superclass of the
 918      * entity (class, interface, primitive type or void) represented by
 919      * this {@code Class}.  If this {@code Class} represents either the
 920      * {@code Object} class, an interface, a primitive type, or void, then
<span class="line-modified"> 921      * null is returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified"> 922      * then the {@code Class} object representing the {@code Object} class is</span>
 923      * returned.
 924      *
<span class="line-modified"> 925      * @return the direct superclass of the class represented by this {@code Class} object</span>
 926      */
 927     @HotSpotIntrinsicCandidate
 928     public native Class&lt;? super T&gt; getSuperclass();
 929 
 930 
 931     /**
 932      * Returns the {@code Type} representing the direct superclass of
 933      * the entity (class, interface, primitive type or void) represented by
<span class="line-modified"> 934      * this {@code Class} object.</span>
 935      *
 936      * &lt;p&gt;If the superclass is a parameterized type, the {@code Type}
 937      * object returned must accurately reflect the actual type
 938      * arguments used in the source code. The parameterized type
 939      * representing the superclass is created if it had not been
 940      * created before. See the declaration of {@link
 941      * java.lang.reflect.ParameterizedType ParameterizedType} for the
 942      * semantics of the creation process for parameterized types.  If
<span class="line-modified"> 943      * this {@code Class} object represents either the {@code Object}</span>
 944      * class, an interface, a primitive type, or void, then null is
<span class="line-modified"> 945      * returned.  If this {@code Class} object represents an array class</span>
<span class="line-modified"> 946      * then the {@code Class} object representing the {@code Object} class is</span>
 947      * returned.
 948      *
 949      * @throws java.lang.reflect.GenericSignatureFormatError if the generic
 950      *     class signature does not conform to the format specified in
<span class="line-modified"> 951      *     section {@jvms 4.7.9} of &lt;cite&gt;The Java&amp;trade; Virtual</span>
<span class="line-added"> 952      *     Machine Specification&lt;/cite&gt;</span>
 953      * @throws TypeNotPresentException if the generic superclass
 954      *     refers to a non-existent type declaration
 955      * @throws java.lang.reflect.MalformedParameterizedTypeException if the
 956      *     generic superclass refers to a parameterized type that cannot be
 957      *     instantiated  for any reason
<span class="line-modified"> 958      * @return the direct superclass of the class represented by this {@code Class} object</span>
 959      * @since 1.5
 960      */
 961     public Type getGenericSuperclass() {
 962         ClassRepository info = getGenericInfo();
 963         if (info == null) {
 964             return getSuperclass();
 965         }
 966 
 967         // Historical irregularity:
 968         // Generic signature marks interfaces with superclass = Object
 969         // but this API returns null for interfaces
 970         if (isInterface()) {
 971             return null;
 972         }
 973 
 974         return info.getSuperclass();
 975     }
 976 
 977     /**
 978      * Gets the package of this class.
</pre>
<hr />
<pre>
1027             while (c.isArray()) {
1028                 c = c.getComponentType();
1029             }
1030             if (c.isPrimitive()) {
1031                 pn = &quot;java.lang&quot;;
1032             } else {
1033                 String cn = c.getName();
1034                 int dot = cn.lastIndexOf(&#39;.&#39;);
1035                 pn = (dot != -1) ? cn.substring(0, dot).intern() : &quot;&quot;;
1036             }
1037             this.packageName = pn;
1038         }
1039         return pn;
1040     }
1041 
1042     // cached package name
1043     private transient String packageName;
1044 
1045     /**
1046      * Returns the interfaces directly implemented by the class or interface
<span class="line-modified">1047      * represented by this {@code Class} object.</span>
1048      *
<span class="line-modified">1049      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
1050      * containing objects representing all interfaces directly implemented by
1051      * the class.  The order of the interface objects in the array corresponds
1052      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1053      * the declaration of the class represented by this {@code Class} object.  For example,</span>
1054      * given the declaration:
1055      * &lt;blockquote&gt;
1056      * {@code class Shimmer implements FloorWax, DessertTopping { ... }}
1057      * &lt;/blockquote&gt;
1058      * suppose the value of {@code s} is an instance of
1059      * {@code Shimmer}; the value of the expression:
1060      * &lt;blockquote&gt;
1061      * {@code s.getClass().getInterfaces()[0]}
1062      * &lt;/blockquote&gt;
1063      * is the {@code Class} object that represents interface
1064      * {@code FloorWax}; and the value of:
1065      * &lt;blockquote&gt;
1066      * {@code s.getClass().getInterfaces()[1]}
1067      * &lt;/blockquote&gt;
1068      * is the {@code Class} object that represents interface
1069      * {@code DessertTopping}.
1070      *
<span class="line-modified">1071      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
1072      * representing all interfaces directly extended by the interface.  The
1073      * order of the interface objects in the array corresponds to the order of
1074      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1075      * the interface represented by this {@code Class} object.</span>
1076      *
<span class="line-modified">1077      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
1078      * interfaces, the method returns an array of length 0.
1079      *
<span class="line-modified">1080      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
1081      * returns an array of length 0.
1082      *
1083      * &lt;p&gt;If this {@code Class} object represents an array type, the
1084      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1085      * returned in that order.
1086      *
1087      * @return an array of interfaces directly implemented by this class
1088      */
1089     public Class&lt;?&gt;[] getInterfaces() {
1090         // defensively copy before handing over to user code
1091         return getInterfaces(true);
1092     }
1093 
1094     private Class&lt;?&gt;[] getInterfaces(boolean cloneArray) {
1095         ReflectionData&lt;T&gt; rd = reflectionData();
1096         if (rd == null) {
1097             // no cloning required
1098             return getInterfaces0();
1099         } else {
1100             Class&lt;?&gt;[] interfaces = rd.interfaces;
1101             if (interfaces == null) {
1102                 interfaces = getInterfaces0();
1103                 rd.interfaces = interfaces;
1104             }
1105             // defensively copy if requested
1106             return cloneArray ? interfaces.clone() : interfaces;
1107         }
1108     }
1109 
1110     private native Class&lt;?&gt;[] getInterfaces0();
1111 
1112     /**
1113      * Returns the {@code Type}s representing the interfaces
1114      * directly implemented by the class or interface represented by
<span class="line-modified">1115      * this {@code Class} object.</span>
1116      *
1117      * &lt;p&gt;If a superinterface is a parameterized type, the
1118      * {@code Type} object returned for it must accurately reflect
1119      * the actual type arguments used in the source code. The
1120      * parameterized type representing each superinterface is created
1121      * if it had not been created before. See the declaration of
1122      * {@link java.lang.reflect.ParameterizedType ParameterizedType}
1123      * for the semantics of the creation process for parameterized
1124      * types.
1125      *
<span class="line-modified">1126      * &lt;p&gt;If this {@code Class} object represents a class, the return value is an array</span>
1127      * containing objects representing all interfaces directly implemented by
1128      * the class.  The order of the interface objects in the array corresponds
1129      * to the order of the interface names in the {@code implements} clause of
<span class="line-modified">1130      * the declaration of the class represented by this {@code Class} object.</span>
1131      *
<span class="line-modified">1132      * &lt;p&gt;If this {@code Class} object represents an interface, the array contains objects</span>
1133      * representing all interfaces directly extended by the interface.  The
1134      * order of the interface objects in the array corresponds to the order of
1135      * the interface names in the {@code extends} clause of the declaration of
<span class="line-modified">1136      * the interface represented by this {@code Class} object.</span>
1137      *
<span class="line-modified">1138      * &lt;p&gt;If this {@code Class} object represents a class or interface that implements no</span>
1139      * interfaces, the method returns an array of length 0.
1140      *
<span class="line-modified">1141      * &lt;p&gt;If this {@code Class} object represents a primitive type or void, the method</span>
1142      * returns an array of length 0.
1143      *
1144      * &lt;p&gt;If this {@code Class} object represents an array type, the
1145      * interfaces {@code Cloneable} and {@code java.io.Serializable} are
1146      * returned in that order.
1147      *
1148      * @throws java.lang.reflect.GenericSignatureFormatError
<span class="line-modified">1149      *     if the generic class signature does not conform to the</span>
<span class="line-modified">1150      *     format specified in section {@jvms 4.7.9} of &lt;cite&gt;The</span>
<span class="line-modified">1151      *     Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;</span>
1152      * @throws TypeNotPresentException if any of the generic
1153      *     superinterfaces refers to a non-existent type declaration
1154      * @throws java.lang.reflect.MalformedParameterizedTypeException
1155      *     if any of the generic superinterfaces refer to a parameterized
1156      *     type that cannot be instantiated for any reason
1157      * @return an array of interfaces directly implemented by this class
1158      * @since 1.5
1159      */
1160     public Type[] getGenericInterfaces() {
1161         ClassRepository info = getGenericInfo();
1162         return (info == null) ?  getInterfaces() : info.getSuperInterfaces();
1163     }
1164 
1165 
1166     /**
1167      * Returns the {@code Class} representing the component type of an
1168      * array.  If this class does not represent an array class this method
1169      * returns null.
1170      *
1171      * @return the {@code Class} representing the component type of this
</pre>
<hr />
<pre>
1179             return componentType;
1180         } else {
1181             return null;
1182         }
1183     }
1184 
1185     private final Class&lt;?&gt; componentType;
1186 
1187 
1188     /**
1189      * Returns the Java language modifiers for this class or interface, encoded
1190      * in an integer. The modifiers consist of the Java Virtual Machine&#39;s
1191      * constants for {@code public}, {@code protected},
1192      * {@code private}, {@code final}, {@code static},
1193      * {@code abstract} and {@code interface}; they should be decoded
1194      * using the methods of class {@code Modifier}.
1195      *
1196      * &lt;p&gt; If the underlying class is an array class, then its
1197      * {@code public}, {@code private} and {@code protected}
1198      * modifiers are the same as those of its component type.  If this
<span class="line-modified">1199      * {@code Class} object represents a primitive type or void, its</span>
1200      * {@code public} modifier is always {@code true}, and its
1201      * {@code protected} and {@code private} modifiers are always
<span class="line-modified">1202      * {@code false}. If this {@code Class} object represents an array class, a</span>
1203      * primitive type or void, then its {@code final} modifier is always
1204      * {@code true} and its interface modifier is always
1205      * {@code false}. The values of its other modifiers are not determined
1206      * by this specification.
1207      *
<span class="line-modified">1208      * &lt;p&gt; The modifier encodings are defined in section {@jvms 4.1}</span>
<span class="line-modified">1209      * of &lt;cite&gt;The Java&amp;trade; Virtual Machine Specification&lt;/cite&gt;.</span>
1210      *
1211      * @return the {@code int} representing the modifiers for this class
1212      * @see     java.lang.reflect.Modifier
1213      * @since 1.1
1214      */
1215     @HotSpotIntrinsicCandidate
1216     public native int getModifiers();
1217 
1218 
1219     /**
1220      * Gets the signers of this class.
1221      *
1222      * @return  the signers of this class, or null if there are no signers.  In
<span class="line-modified">1223      *          particular, this method returns null if this {@code Class} object represents</span>
1224      *          a primitive type or void.
1225      * @since   1.1
1226      */
1227     public native Object[] getSigners();
1228 
1229 
1230     /**
1231      * Set the signers of this class.
1232      */
1233     native void setSigners(Object[] signers);
1234 
1235 
1236     /**
1237      * If this {@code Class} object represents a local or anonymous
1238      * class within a method, returns a {@link
1239      * java.lang.reflect.Method Method} object representing the
1240      * immediately enclosing method of the underlying class. Returns
1241      * {@code null} otherwise.
1242      *
1243      * In particular, this method returns {@code null} if the underlying
</pre>
<hr />
<pre>
1597      *
1598      * @return an informative string for the name of this type
1599      * @since 1.8
1600      */
1601     public String getTypeName() {
1602         if (isArray()) {
1603             try {
1604                 Class&lt;?&gt; cl = this;
1605                 int dimensions = 0;
1606                 do {
1607                     dimensions++;
1608                     cl = cl.getComponentType();
1609                 } while (cl.isArray());
1610                 return cl.getName() + &quot;[]&quot;.repeat(dimensions);
1611             } catch (Throwable e) { /*FALLTHRU*/ }
1612         }
1613         return getName();
1614     }
1615 
1616     /**
<span class="line-modified">1617      * Returns the canonical name of the underlying class as defined</span>
<span class="line-modified">1618      * by &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;, section</span>
<span class="line-modified">1619      * {@jls 6.7}.  Returns null if the underlying class does not have</span>
<span class="line-modified">1620      * a canonical name (i.e., if it is a local or anonymous class or</span>
<span class="line-modified">1621      * an array whose component type does not have a canonical name).</span>
1622      * @return the canonical name of the underlying class if it exists, and
1623      * {@code null} otherwise.
1624      * @since 1.5
1625      */
1626     public String getCanonicalName() {
1627         ReflectionData&lt;T&gt; rd = reflectionData();
1628         String canonicalName = rd.canonicalName;
1629         if (canonicalName == null) {
1630             rd.canonicalName = canonicalName = getCanonicalName0();
1631         }
1632         return canonicalName == ReflectionData.NULL_SENTINEL? null : canonicalName;
1633     }
1634 
1635     private String getCanonicalName0() {
1636         if (isArray()) {
1637             String canonicalName = getComponentType().getCanonicalName();
1638             if (canonicalName != null)
1639                 return canonicalName + &quot;[]&quot;;
1640             else
1641                 return ReflectionData.NULL_SENTINEL;
</pre>
<hr />
<pre>
1915      * @jls 8.4 Method Declarations
1916      * @since 1.1
1917      */
1918     @CallerSensitive
1919     public Method[] getMethods() throws SecurityException {
1920         SecurityManager sm = System.getSecurityManager();
1921         if (sm != null) {
1922             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1923         }
1924         return copyMethods(privateGetPublicMethods());
1925     }
1926 
1927 
1928     /**
1929      * Returns an array containing {@code Constructor} objects reflecting
1930      * all the public constructors of the class represented by this
1931      * {@code Class} object.  An array of length 0 is returned if the
1932      * class has no public constructors, or if the class is an array class, or
1933      * if the class reflects a primitive type or void.
1934      *
<span class="line-modified">1935      * @apiNote</span>
<span class="line-added">1936      * While this method returns an array of {@code</span>
1937      * Constructor&lt;T&gt;} objects (that is an array of constructors from
1938      * this class), the return type of this method is {@code
1939      * Constructor&lt;?&gt;[]} and &lt;em&gt;not&lt;/em&gt; {@code Constructor&lt;T&gt;[]} as
1940      * might be expected.  This less informative return type is
1941      * necessary since after being returned from this method, the
1942      * array could be modified to hold {@code Constructor} objects for
1943      * different classes, which would violate the type guarantees of
1944      * {@code Constructor&lt;T&gt;[]}.
1945      *
1946      * @return the array of {@code Constructor} objects representing the
1947      *         public constructors of this class
1948      * @throws SecurityException
1949      *         If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and
1950      *         the caller&#39;s class loader is not the same as or an
1951      *         ancestor of the class loader for the current class and
1952      *         invocation of {@link SecurityManager#checkPackageAccess
1953      *         s.checkPackageAccess()} denies access to the package
1954      *         of this class.
1955      *
1956      * @since 1.1
1957      */
1958     @CallerSensitive
1959     public Constructor&lt;?&gt;[] getConstructors() throws SecurityException {
1960         SecurityManager sm = System.getSecurityManager();
1961         if (sm != null) {
1962             checkMemberAccess(sm, Member.PUBLIC, Reflection.getCallerClass(), true);
1963         }
1964         return copyConstructors(privateGetDeclaredConstructors(true));
1965     }
1966 
1967 
1968     /**
1969      * Returns a {@code Field} object that reflects the specified public member
1970      * field of the class or interface represented by this {@code Class}
1971      * object. The {@code name} parameter is a {@code String} specifying the
1972      * simple name of the desired field.
1973      *
1974      * &lt;p&gt; The field to be reflected is determined by the algorithm that
<span class="line-modified">1975      * follows.  Let C be the class or interface represented by this {@code Class} object:</span>
1976      *
1977      * &lt;OL&gt;
1978      * &lt;LI&gt; If C declares a public field with the name specified, that is the
1979      *      field to be reflected.&lt;/LI&gt;
1980      * &lt;LI&gt; If no field was found in step 1 above, this algorithm is applied
1981      *      recursively to each direct superinterface of C. The direct
1982      *      superinterfaces are searched in the order they were declared.&lt;/LI&gt;
1983      * &lt;LI&gt; If no field was found in steps 1 and 2 above, and C has a
1984      *      superclass S, then this algorithm is invoked recursively upon S.
1985      *      If C has no superclass, then a {@code NoSuchFieldException}
1986      *      is thrown.&lt;/LI&gt;
1987      * &lt;/OL&gt;
1988      *
1989      * &lt;p&gt; If this {@code Class} object represents an array type, then this
1990      * method does not find the {@code length} field of the array type.
1991      *
1992      * @param name the field name
1993      * @return the {@code Field} object of this class specified by
1994      *         {@code name}
1995      * @throws NoSuchFieldException if a field with the specified name is
</pre>
<hr />
<pre>
2389     public Method[] getDeclaredMethods() throws SecurityException {
2390         SecurityManager sm = System.getSecurityManager();
2391         if (sm != null) {
2392             checkMemberAccess(sm, Member.DECLARED, Reflection.getCallerClass(), true);
2393         }
2394         return copyMethods(privateGetDeclaredMethods(false));
2395     }
2396 
2397 
2398     /**
2399      * Returns an array of {@code Constructor} objects reflecting all the
2400      * constructors declared by the class represented by this
2401      * {@code Class} object. These are public, protected, default
2402      * (package) access, and private constructors.  The elements in the array
2403      * returned are not sorted and are not in any particular order.  If the
2404      * class has a default constructor, it is included in the returned array.
2405      * This method returns an array of length 0 if this {@code Class}
2406      * object represents an interface, a primitive type, an array class, or
2407      * void.
2408      *
<span class="line-modified">2409      * &lt;p&gt; See &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;,</span>
<span class="line-added">2410      * section {@jls 8.2}.</span>
2411      *
2412      * @return  the array of {@code Constructor} objects representing all the
2413      *          declared constructors of this class
2414      * @throws  SecurityException
2415      *          If a security manager, &lt;i&gt;s&lt;/i&gt;, is present and any of the
2416      *          following conditions is met:
2417      *
2418      *          &lt;ul&gt;
2419      *
2420      *          &lt;li&gt; the caller&#39;s class loader is not the same as the
2421      *          class loader of this class and invocation of
2422      *          {@link SecurityManager#checkPermission
2423      *          s.checkPermission} method with
2424      *          {@code RuntimePermission(&quot;accessDeclaredMembers&quot;)}
2425      *          denies access to the declared constructors within this class
2426      *
2427      *          &lt;li&gt; the caller&#39;s class loader is not the same as or an
2428      *          ancestor of the class loader for the current class and
2429      *          invocation of {@link SecurityManager#checkPackageAccess
2430      *          s.checkPackageAccess()} denies access to the package
</pre>
<hr />
<pre>
2640     }
2641 
2642     /**
2643      * Finds a resource with a given name.
2644      *
2645      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2646      * will attempt to find the resource in the module. This is done by
2647      * delegating to the module&#39;s class loader {@link
2648      * ClassLoader#findResource(String,String) findResource(String,String)}
2649      * method, invoking it with the module name and the absolute name of the
2650      * resource. Resources in named modules are subject to the rules for
2651      * encapsulation specified in the {@code Module} {@link
2652      * Module#getResourceAsStream getResourceAsStream} method and so this
2653      * method returns {@code null} when the resource is a
2654      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2655      * caller&#39;s module.
2656      *
2657      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2658      * searching resources associated with a given class are implemented by the
2659      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2660      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">2661      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">2662      * the method delegates to {@link ClassLoader#getSystemResourceAsStream}.</span>
2663      *
2664      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2665      * given resource name using this algorithm:
2666      *
2667      * &lt;ul&gt;
2668      *
2669      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2670      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2671      * portion of the {@code name} following the {@code &#39;/&#39;}.
2672      *
2673      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2674      *
2675      * &lt;blockquote&gt;
2676      *   {@code modified_package_name/name}
2677      * &lt;/blockquote&gt;
2678      *
2679      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2680      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2681      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2682      *
</pre>
<hr />
<pre>
2738     }
2739 
2740     /**
2741      * Finds a resource with a given name.
2742      *
2743      * &lt;p&gt; If this class is in a named {@link Module Module} then this method
2744      * will attempt to find the resource in the module. This is done by
2745      * delegating to the module&#39;s class loader {@link
2746      * ClassLoader#findResource(String,String) findResource(String,String)}
2747      * method, invoking it with the module name and the absolute name of the
2748      * resource. Resources in named modules are subject to the rules for
2749      * encapsulation specified in the {@code Module} {@link
2750      * Module#getResourceAsStream getResourceAsStream} method and so this
2751      * method returns {@code null} when the resource is a
2752      * non-&quot;{@code .class}&quot; resource in a package that is not open to the
2753      * caller&#39;s module.
2754      *
2755      * &lt;p&gt; Otherwise, if this class is not in a named module then the rules for
2756      * searching resources associated with a given class are implemented by the
2757      * defining {@linkplain ClassLoader class loader} of the class.  This method
<span class="line-modified">2758      * delegates to this {@code Class} object&#39;s class loader.</span>
<span class="line-modified">2759      * If this {@code Class} object was loaded by the bootstrap class loader,</span>
<span class="line-modified">2760      * the method delegates to {@link ClassLoader#getSystemResource}.</span>
2761      *
2762      * &lt;p&gt; Before delegation, an absolute resource name is constructed from the
2763      * given resource name using this algorithm:
2764      *
2765      * &lt;ul&gt;
2766      *
2767      * &lt;li&gt; If the {@code name} begins with a {@code &#39;/&#39;}
2768      * (&lt;code&gt;&#39;&amp;#92;u002f&#39;&lt;/code&gt;), then the absolute name of the resource is the
2769      * portion of the {@code name} following the {@code &#39;/&#39;}.
2770      *
2771      * &lt;li&gt; Otherwise, the absolute name is of the following form:
2772      *
2773      * &lt;blockquote&gt;
2774      *   {@code modified_package_name/name}
2775      * &lt;/blockquote&gt;
2776      *
2777      * &lt;p&gt; Where the {@code modified_package_name} is the package name of this
2778      * object with {@code &#39;/&#39;} substituted for {@code &#39;.&#39;}
2779      * (&lt;code&gt;&#39;&amp;#92;u002e&#39;&lt;/code&gt;).
2780      *
</pre>
<hr />
<pre>
3527      * is written into the stream. Future references to the class descriptor
3528      * are written as references to the initial class descriptor instance.
3529      *
3530      * @see java.io.ObjectStreamClass
3531      */
3532     @java.io.Serial
3533     private static final ObjectStreamField[] serialPersistentFields =
3534         new ObjectStreamField[0];
3535 
3536 
3537     /**
3538      * Returns the assertion status that would be assigned to this
3539      * class if it were to be initialized at the time this method is invoked.
3540      * If this class has had its assertion status set, the most recent
3541      * setting will be returned; otherwise, if any package default assertion
3542      * status pertains to this class, the most recent setting for the most
3543      * specific pertinent package default assertion status is returned;
3544      * otherwise, if this class is not a system class (i.e., it has a
3545      * class loader) its class loader&#39;s default assertion status is returned;
3546      * otherwise, the system class default assertion status is returned.
<span class="line-modified">3547      *</span>
<span class="line-added">3548      * @apiNote</span>
3549      * Few programmers will have any need for this method; it is provided
<span class="line-modified">3550      * for the benefit of the JDK itself.  (It allows a class to determine at</span>
3551      * the time that it is initialized whether assertions should be enabled.)
3552      * Note that this method is not guaranteed to return the actual
3553      * assertion status that was (or will be) associated with the specified
3554      * class when it was (or will be) initialized.
3555      *
3556      * @return the desired assertion status of the specified class.
3557      * @see    java.lang.ClassLoader#setClassAssertionStatus
3558      * @see    java.lang.ClassLoader#setPackageAssertionStatus
3559      * @see    java.lang.ClassLoader#setDefaultAssertionStatus
3560      * @since  1.4
3561      */
3562     public boolean desiredAssertionStatus() {
3563         ClassLoader loader = getClassLoader0();
3564         // If the loader is null this is a system class, so ask the VM
3565         if (loader == null)
3566             return desiredAssertionStatus0(this);
3567 
3568         // If the classloader has been initialized with the assertion
3569         // directives, ask it. Otherwise, ask the VM.
3570         synchronized(loader.assertionLock) {
</pre>
<hr />
<pre>
3641     public boolean isRecord() {
3642         return getSuperclass() == JAVA_LANG_RECORD_CLASS &amp;&amp; isRecord0();
3643     }
3644 
3645     // Fetches the factory for reflective objects
3646     private static ReflectionFactory getReflectionFactory() {
3647         if (reflectionFactory == null) {
3648             reflectionFactory =
3649                 java.security.AccessController.doPrivileged
3650                     (new ReflectionFactory.GetReflectionFactoryAction());
3651         }
3652         return reflectionFactory;
3653     }
3654     private static ReflectionFactory reflectionFactory;
3655 
3656     /**
3657      * Returns the elements of this enum class or null if this
3658      * Class object does not represent an enum type.
3659      *
3660      * @return an array containing the values comprising the enum class
<span class="line-modified">3661      *     represented by this {@code Class} object in the order they&#39;re</span>
<span class="line-modified">3662      *     declared, or null if this {@code Class} object does not</span>
3663      *     represent an enum type
3664      * @since 1.5
3665      */
3666     public T[] getEnumConstants() {
3667         T[] values = getEnumConstantsShared();
3668         return (values != null) ? values.clone() : null;
3669     }
3670 
3671     /**
3672      * Returns the elements of this enum class or null if this
3673      * Class object does not represent an enum type;
3674      * identical to getEnumConstants except that the result is
3675      * uncloned, cached, and shared by all callers.
3676      */
3677     T[] getEnumConstantsShared() {
3678         T[] constants = enumConstants;
3679         if (constants == null) {
3680             if (!isEnum()) return null;
3681             try {
3682                 final Method values = getMethod(&quot;values&quot;);
</pre>
<hr />
<pre>
3735      * null and is not assignable to the type T.
3736      *
3737      * @since 1.5
3738      */
3739     @SuppressWarnings(&quot;unchecked&quot;)
3740     @HotSpotIntrinsicCandidate
3741     public T cast(Object obj) {
3742         if (obj != null &amp;&amp; !isInstance(obj))
3743             throw new ClassCastException(cannotCastMsg(obj));
3744         return (T) obj;
3745     }
3746 
3747     private String cannotCastMsg(Object obj) {
3748         return &quot;Cannot cast &quot; + obj.getClass().getName() + &quot; to &quot; + getName();
3749     }
3750 
3751     /**
3752      * Casts this {@code Class} object to represent a subclass of the class
3753      * represented by the specified class object.  Checks that the cast
3754      * is valid, and throws a {@code ClassCastException} if it is not.  If
<span class="line-modified">3755      * this method succeeds, it always returns a reference to this {@code Class} object.</span>
3756      *
3757      * &lt;p&gt;This method is useful when a client needs to &quot;narrow&quot; the type of
3758      * a {@code Class} object to pass it to an API that restricts the
3759      * {@code Class} objects that it is willing to accept.  A cast would
3760      * generate a compile-time warning, as the correctness of the cast
3761      * could not be checked at runtime (because generic types are implemented
3762      * by erasure).
3763      *
<span class="line-modified">3764      * @param &lt;U&gt; the type to cast this {@code Class} object to</span>
<span class="line-modified">3765      * @param clazz the class of the type to cast this {@code Class} object to</span>
3766      * @return this {@code Class} object, cast to represent a subclass of
3767      *    the specified class object.
3768      * @throws ClassCastException if this {@code Class} object does not
3769      *    represent a subclass of the specified class (here &quot;subclass&quot; includes
3770      *    the class itself).
3771      * @since 1.5
3772      */
3773     @SuppressWarnings(&quot;unchecked&quot;)
3774     public &lt;U&gt; Class&lt;? extends U&gt; asSubclass(Class&lt;U&gt; clazz) {
3775         if (clazz.isAssignableFrom(this))
3776             return (Class&lt;? extends U&gt;) this;
3777         else
3778             throw new ClassCastException(this.toString());
3779     }
3780 
3781     /**
<span class="line-added">3782      * {@inheritDoc}</span>
<span class="line-added">3783      * &lt;p&gt;Note that any annotation returned by this method is a</span>
<span class="line-added">3784      * declaration annotation.</span>
<span class="line-added">3785      *</span>
3786      * @throws NullPointerException {@inheritDoc}
3787      * @since 1.5
3788      */
<span class="line-added">3789     @Override</span>
3790     @SuppressWarnings(&quot;unchecked&quot;)
3791     public &lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass) {
3792         Objects.requireNonNull(annotationClass);
3793 
3794         return (A) annotationData().annotations.get(annotationClass);
3795     }
3796 
3797     /**
3798      * {@inheritDoc}
3799      * @throws NullPointerException {@inheritDoc}
3800      * @since 1.5
3801      */
3802     @Override
3803     public boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass) {
3804         return GenericDeclaration.super.isAnnotationPresent(annotationClass);
3805     }
3806 
3807     /**
<span class="line-added">3808      * {@inheritDoc}</span>
<span class="line-added">3809      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">3810      * declaration annotations.</span>
<span class="line-added">3811      *</span>
3812      * @throws NullPointerException {@inheritDoc}
3813      * @since 1.8
3814      */
3815     @Override
3816     public &lt;A extends Annotation&gt; A[] getAnnotationsByType(Class&lt;A&gt; annotationClass) {
3817         Objects.requireNonNull(annotationClass);
3818 
3819         AnnotationData annotationData = annotationData();
3820         return AnnotationSupport.getAssociatedAnnotations(annotationData.declaredAnnotations,
3821                                                           this,
3822                                                           annotationClass);
3823     }
3824 
3825     /**
<span class="line-added">3826      * {@inheritDoc}</span>
<span class="line-added">3827      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">3828      * declaration annotations.</span>
<span class="line-added">3829      *</span>
3830      * @since 1.5
3831      */
<span class="line-added">3832     @Override</span>
3833     public Annotation[] getAnnotations() {
3834         return AnnotationParser.toArray(annotationData().annotations);
3835     }
3836 
3837     /**
<span class="line-added">3838      * {@inheritDoc}</span>
<span class="line-added">3839      * &lt;p&gt;Note that any annotation returned by this method is a</span>
<span class="line-added">3840      * declaration annotation.</span>
<span class="line-added">3841      *</span>
3842      * @throws NullPointerException {@inheritDoc}
3843      * @since 1.8
3844      */
3845     @Override
3846     @SuppressWarnings(&quot;unchecked&quot;)
3847     public &lt;A extends Annotation&gt; A getDeclaredAnnotation(Class&lt;A&gt; annotationClass) {
3848         Objects.requireNonNull(annotationClass);
3849 
3850         return (A) annotationData().declaredAnnotations.get(annotationClass);
3851     }
3852 
3853     /**
<span class="line-added">3854      * {@inheritDoc}</span>
<span class="line-added">3855      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">3856      * declaration annotations.</span>
<span class="line-added">3857      *</span>
3858      * @throws NullPointerException {@inheritDoc}
3859      * @since 1.8
3860      */
3861     @Override
3862     public &lt;A extends Annotation&gt; A[] getDeclaredAnnotationsByType(Class&lt;A&gt; annotationClass) {
3863         Objects.requireNonNull(annotationClass);
3864 
3865         return AnnotationSupport.getDirectlyAndIndirectlyPresent(annotationData().declaredAnnotations,
3866                                                                  annotationClass);
3867     }
3868 
3869     /**
<span class="line-added">3870      * {@inheritDoc}</span>
<span class="line-added">3871      * &lt;p&gt;Note that any annotations returned by this method are</span>
<span class="line-added">3872      * declaration annotations.</span>
<span class="line-added">3873      *</span>
3874      * @since 1.5
3875      */
<span class="line-added">3876     @Override</span>
3877     public Annotation[] getDeclaredAnnotations()  {
3878         return AnnotationParser.toArray(annotationData().declaredAnnotations);
3879     }
3880 
3881     // annotation data that might get invalidated when JVM TI RedefineClasses() is called
3882     private static class AnnotationData {
3883         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations;
3884         final Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations;
3885 
3886         // Value of classRedefinedCount when we created this AnnotationData instance
3887         final int redefinedCount;
3888 
3889         AnnotationData(Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; annotations,
3890                        Map&lt;Class&lt;? extends Annotation&gt;, Annotation&gt; declaredAnnotations,
3891                        int redefinedCount) {
3892             this.annotations = annotations;
3893             this.declaredAnnotations = declaredAnnotations;
3894             this.redefinedCount = redefinedCount;
3895         }
3896     }
</pre>
<hr />
<pre>
4042     /**
4043      * Returns the nest host of the &lt;a href=#nest&gt;nest&lt;/a&gt; to which the class
4044      * or interface represented by this {@code Class} object belongs.
4045      * Every class and interface is a member of exactly one nest.
4046      * A class or interface that is not recorded as belonging to a nest
4047      * belongs to the nest consisting only of itself, and is the nest
4048      * host.
4049      *
4050      * &lt;p&gt;Each of the {@code Class} objects representing array types,
4051      * primitive types, and {@code void} returns {@code this} to indicate
4052      * that the represented entity belongs to the nest consisting only of
4053      * itself, and is the nest host.
4054      *
4055      * &lt;p&gt;If there is a {@linkplain LinkageError linkage error} accessing
4056      * the nest host, or if this class or interface is not enumerated as
4057      * a member of the nest by the nest host, then it is considered to belong
4058      * to its own nest and {@code this} is returned as the host.
4059      *
4060      * @apiNote A {@code class} file of version 55.0 or greater may record the
4061      * host of the nest to which it belongs by using the {@code NestHost}
<span class="line-modified">4062      * attribute (JVMS {@jvms 4.7.28}). Alternatively, a {@code class} file of</span>
4063      * version 55.0 or greater may act as a nest host by enumerating the nest&#39;s
4064      * other members with the
<span class="line-modified">4065      * {@code NestMembers} attribute (JVMS {@jvms 4.7.29}).</span>
4066      * A {@code class} file of version 54.0 or lower does not use these
4067      * attributes.
4068      *
4069      * @return the nest host of this class or interface
4070      *
4071      * @throws SecurityException
4072      *         If the returned class is not the current class, and
4073      *         if a security manager, &lt;i&gt;s&lt;/i&gt;, is present and the caller&#39;s
4074      *         class loader is not the same as or an ancestor of the class
4075      *         loader for the returned class and invocation of {@link
4076      *         SecurityManager#checkPackageAccess s.checkPackageAccess()}
4077      *         denies access to the package of the returned class
4078      * @since 11
4079      * @jvms 4.7.28 The {@code NestHost} Attribute
4080      * @jvms 4.7.29 The {@code NestMembers} Attribute
4081      * @jvms 5.4.4 Access Control
4082      */
4083     @CallerSensitive
4084     public Class&lt;?&gt; getNestHost() {
4085         if (isPrimitive() || isArray()) {
</pre>
</td>
</tr>
</table>
<center><a href="Character.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="ClassLoader.java.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.base/share/classes/java/math/BigDecimal.java</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1996, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 /*
  27  * Portions Copyright IBM Corporation, 2001. All Rights Reserved.
  28  */
  29 
  30 package java.math;
  31 
  32 import static java.math.BigInteger.LONG_MASK;
  33 import java.util.Arrays;
  34 import java.util.Objects;
  35 
  36 /**
  37  * Immutable, arbitrary-precision signed decimal numbers.  A
  38  * {@code BigDecimal} consists of an arbitrary precision integer
  39  * &lt;i&gt;unscaled value&lt;/i&gt; and a 32-bit integer &lt;i&gt;scale&lt;/i&gt;.  If zero
  40  * or positive, the scale is the number of digits to the right of the
  41  * decimal point.  If negative, the unscaled value of the number is
  42  * multiplied by ten to the power of the negation of the scale.  The
  43  * value of the number represented by the {@code BigDecimal} is
  44  * therefore &lt;code&gt;(unscaledValue &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/code&gt;.
  45  *
  46  * &lt;p&gt;The {@code BigDecimal} class provides operations for
  47  * arithmetic, scale manipulation, rounding, comparison, hashing, and
  48  * format conversion.  The {@link #toString} method provides a
  49  * canonical representation of a {@code BigDecimal}.
  50  *
  51  * &lt;p&gt;The {@code BigDecimal} class gives its user complete control
  52  * over rounding behavior.  If no rounding mode is specified and the
  53  * exact result cannot be represented, an exception is thrown;
  54  * otherwise, calculations can be carried out to a chosen precision
  55  * and rounding mode by supplying an appropriate {@link MathContext}
  56  * object to the operation.  In either case, eight &lt;em&gt;rounding
  57  * modes&lt;/em&gt; are provided for the control of rounding.  Using the
  58  * integer fields in this class (such as {@link #ROUND_HALF_UP}) to
  59  * represent rounding mode is deprecated; the enumeration values
  60  * of the {@code RoundingMode} {@code enum}, (such as {@link
  61  * RoundingMode#HALF_UP}) should be used instead.
  62  *
  63  * &lt;p&gt;When a {@code MathContext} object is supplied with a precision
  64  * setting of 0 (for example, {@link MathContext#UNLIMITED}),
  65  * arithmetic operations are exact, as are the arithmetic methods
  66  * which take no {@code MathContext} object.  (This is the only
  67  * behavior that was supported in releases prior to 5.)  As a
  68  * corollary of computing the exact result, the rounding mode setting
  69  * of a {@code MathContext} object with a precision setting of 0 is
  70  * not used and thus irrelevant.  In the case of divide, the exact
  71  * quotient could have an infinitely long decimal expansion; for
  72  * example, 1 divided by 3.  If the quotient has a nonterminating
  73  * decimal expansion and the operation is specified to return an exact
  74  * result, an {@code ArithmeticException} is thrown.  Otherwise, the
  75  * exact result of the division is returned, as done for other
  76  * operations.
  77  *
  78  * &lt;p&gt;When the precision setting is not 0, the rules of
  79  * {@code BigDecimal} arithmetic are broadly compatible with selected
  80  * modes of operation of the arithmetic defined in ANSI X3.274-1996
  81  * and ANSI X3.274-1996/AM 1-2000 (section 7.4).  Unlike those
  82  * standards, {@code BigDecimal} includes many rounding modes, which
  83  * were mandatory for division in {@code BigDecimal} releases prior
  84  * to 5.  Any conflicts between these ANSI standards and the
  85  * {@code BigDecimal} specification are resolved in favor of
  86  * {@code BigDecimal}.
  87  *
  88  * &lt;p&gt;Since the same numerical value can have different
  89  * representations (with different scales), the rules of arithmetic
  90  * and rounding must specify both the numerical result and the scale
  91  * used in the result&#39;s representation.
  92  *
  93  *
  94  * &lt;p&gt;In general the rounding modes and precision setting determine
  95  * how operations return results with a limited number of digits when
  96  * the exact result has more digits (perhaps infinitely many in the
  97  * case of division and square root) than the number of digits returned.
  98  *
  99  * First, the
 100  * total number of digits to return is specified by the
 101  * {@code MathContext}&#39;s {@code precision} setting; this determines
 102  * the result&#39;s &lt;i&gt;precision&lt;/i&gt;.  The digit count starts from the
 103  * leftmost nonzero digit of the exact result.  The rounding mode
 104  * determines how any discarded trailing digits affect the returned
 105  * result.
 106  *
<a name="1" id="anc1"></a><span class="line-modified"> 107  * &lt;p&gt;For all arithmetic operators , the operation is carried out as</span>
 108  * though an exact intermediate result were first calculated and then
 109  * rounded to the number of digits specified by the precision setting
 110  * (if necessary), using the selected rounding mode.  If the exact
 111  * result is not returned, some digit positions of the exact result
 112  * are discarded.  When rounding increases the magnitude of the
 113  * returned result, it is possible for a new digit position to be
 114  * created by a carry propagating to a leading {@literal &quot;9&quot;} digit.
 115  * For example, rounding the value 999.9 to three digits rounding up
 116  * would be numerically equal to one thousand, represented as
 117  * 100&amp;times;10&lt;sup&gt;1&lt;/sup&gt;.  In such cases, the new {@literal &quot;1&quot;} is
 118  * the leading digit position of the returned result.
 119  *
 120  * &lt;p&gt;Besides a logical exact result, each arithmetic operation has a
 121  * preferred scale for representing a result.  The preferred
 122  * scale for each operation is listed in the table below.
 123  *
 124  * &lt;table class=&quot;striped&quot; style=&quot;text-align:left&quot;&gt;
 125  * &lt;caption&gt;Preferred Scales for Results of Arithmetic Operations
 126  * &lt;/caption&gt;
 127  * &lt;thead&gt;
 128  * &lt;tr&gt;&lt;th scope=&quot;col&quot;&gt;Operation&lt;/th&gt;&lt;th scope=&quot;col&quot;&gt;Preferred Scale of Result&lt;/th&gt;&lt;/tr&gt;
 129  * &lt;/thead&gt;
 130  * &lt;tbody&gt;
 131  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Add&lt;/th&gt;&lt;td&gt;max(addend.scale(), augend.scale())&lt;/td&gt;
 132  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Subtract&lt;/th&gt;&lt;td&gt;max(minuend.scale(), subtrahend.scale())&lt;/td&gt;
 133  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Multiply&lt;/th&gt;&lt;td&gt;multiplier.scale() + multiplicand.scale()&lt;/td&gt;
 134  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Divide&lt;/th&gt;&lt;td&gt;dividend.scale() - divisor.scale()&lt;/td&gt;
 135  * &lt;tr&gt;&lt;th scope=&quot;row&quot;&gt;Square root&lt;/th&gt;&lt;td&gt;radicand.scale()/2&lt;/td&gt;
 136  * &lt;/tbody&gt;
 137  * &lt;/table&gt;
 138  *
 139  * These scales are the ones used by the methods which return exact
 140  * arithmetic results; except that an exact divide may have to use a
 141  * larger scale since the exact result may have more digits.  For
 142  * example, {@code 1/32} is {@code 0.03125}.
 143  *
 144  * &lt;p&gt;Before rounding, the scale of the logical exact intermediate
 145  * result is the preferred scale for that operation.  If the exact
 146  * numerical result cannot be represented in {@code precision}
 147  * digits, rounding selects the set of digits to return and the scale
 148  * of the result is reduced from the scale of the intermediate result
 149  * to the least scale which can represent the {@code precision}
 150  * digits actually returned.  If the exact result can be represented
 151  * with at most {@code precision} digits, the representation
 152  * of the result with the scale closest to the preferred scale is
 153  * returned.  In particular, an exactly representable quotient may be
 154  * represented in fewer than {@code precision} digits by removing
 155  * trailing zeros and decreasing the scale.  For example, rounding to
 156  * three digits using the {@linkplain RoundingMode#FLOOR floor}
 157  * rounding mode, &lt;br&gt;
 158  *
 159  * {@code 19/100 = 0.19   // integer=19,  scale=2} &lt;br&gt;
 160  *
 161  * but&lt;br&gt;
 162  *
 163  * {@code 21/110 = 0.190  // integer=190, scale=3} &lt;br&gt;
 164  *
 165  * &lt;p&gt;Note that for add, subtract, and multiply, the reduction in
 166  * scale will equal the number of digit positions of the exact result
 167  * which are discarded. If the rounding causes a carry propagation to
 168  * create a new high-order digit position, an additional digit of the
 169  * result is discarded than when no new digit position is created.
 170  *
 171  * &lt;p&gt;Other methods may have slightly different rounding semantics.
 172  * For example, the result of the {@code pow} method using the
 173  * {@linkplain #pow(int, MathContext) specified algorithm} can
 174  * occasionally differ from the rounded mathematical result by more
 175  * than one unit in the last place, one &lt;i&gt;{@linkplain #ulp() ulp}&lt;/i&gt;.
 176  *
 177  * &lt;p&gt;Two types of operations are provided for manipulating the scale
 178  * of a {@code BigDecimal}: scaling/rounding operations and decimal
 179  * point motion operations.  Scaling/rounding operations ({@link
 180  * #setScale setScale} and {@link #round round}) return a
 181  * {@code BigDecimal} whose value is approximately (or exactly) equal
 182  * to that of the operand, but whose scale or precision is the
 183  * specified value; that is, they increase or decrease the precision
 184  * of the stored number with minimal effect on its value.  Decimal
 185  * point motion operations ({@link #movePointLeft movePointLeft} and
 186  * {@link #movePointRight movePointRight}) return a
 187  * {@code BigDecimal} created from the operand by moving the decimal
 188  * point a specified distance in the specified direction.
 189  *
 190  * &lt;p&gt;For the sake of brevity and clarity, pseudo-code is used
 191  * throughout the descriptions of {@code BigDecimal} methods.  The
 192  * pseudo-code expression {@code (i + j)} is shorthand for &quot;a
 193  * {@code BigDecimal} whose value is that of the {@code BigDecimal}
 194  * {@code i} added to that of the {@code BigDecimal}
 195  * {@code j}.&quot; The pseudo-code expression {@code (i == j)} is
 196  * shorthand for &quot;{@code true} if and only if the
 197  * {@code BigDecimal} {@code i} represents the same value as the
 198  * {@code BigDecimal} {@code j}.&quot; Other pseudo-code expressions
 199  * are interpreted similarly.  Square brackets are used to represent
 200  * the particular {@code BigInteger} and scale pair defining a
 201  * {@code BigDecimal} value; for example [19, 2] is the
 202  * {@code BigDecimal} numerically equal to 0.19 having a scale of 2.
 203  *
 204  *
 205  * &lt;p&gt;All methods and constructors for this class throw
 206  * {@code NullPointerException} when passed a {@code null} object
 207  * reference for any input parameter.
 208  *
 209  * @apiNote Care should be exercised if {@code BigDecimal} objects
 210  * are used as keys in a {@link java.util.SortedMap SortedMap} or
 211  * elements in a {@link java.util.SortedSet SortedSet} since
 212  * {@code BigDecimal}&#39;s &lt;i&gt;natural ordering&lt;/i&gt; is &lt;em&gt;inconsistent
 213  * with equals&lt;/em&gt;.  See {@link Comparable}, {@link
 214  * java.util.SortedMap} or {@link java.util.SortedSet} for more
 215  * information.
 216  *
 217  * @see     BigInteger
 218  * @see     MathContext
 219  * @see     RoundingMode
 220  * @see     java.util.SortedMap
 221  * @see     java.util.SortedSet
 222  * @author  Josh Bloch
 223  * @author  Mike Cowlishaw
 224  * @author  Joseph D. Darcy
 225  * @author  Sergey V. Kuksenko
 226  * @since 1.1
 227  */
 228 public class BigDecimal extends Number implements Comparable&lt;BigDecimal&gt; {
 229     /**
 230      * The unscaled value of this BigDecimal, as returned by {@link
 231      * #unscaledValue}.
 232      *
 233      * @serial
 234      * @see #unscaledValue
 235      */
 236     private final BigInteger intVal;
 237 
 238     /**
 239      * The scale of this BigDecimal, as returned by {@link #scale}.
 240      *
 241      * @serial
 242      * @see #scale
 243      */
 244     private final int scale;  // Note: this may have any value, so
 245                               // calculations must be done in longs
 246 
 247     /**
 248      * The number of decimal digits in this BigDecimal, or 0 if the
 249      * number of digits are not known (lookaside information).  If
 250      * nonzero, the value is guaranteed correct.  Use the precision()
 251      * method to obtain and set the value if it might be 0.  This
 252      * field is mutable until set nonzero.
 253      *
 254      * @since  1.5
 255      */
 256     private transient int precision;
 257 
 258     /**
 259      * Used to store the canonical string representation, if computed.
 260      */
 261     private transient String stringCache;
 262 
 263     /**
 264      * Sentinel value for {@link #intCompact} indicating the
 265      * significand information is only available from {@code intVal}.
 266      */
 267     static final long INFLATED = Long.MIN_VALUE;
 268 
 269     private static final BigInteger INFLATED_BIGINT = BigInteger.valueOf(INFLATED);
 270 
 271     /**
 272      * If the absolute value of the significand of this BigDecimal is
 273      * less than or equal to {@code Long.MAX_VALUE}, the value can be
 274      * compactly stored in this field and used in computations.
 275      */
 276     private final transient long intCompact;
 277 
 278     // All 18-digit base ten strings fit into a long; not all 19-digit
 279     // strings will
 280     private static final int MAX_COMPACT_DIGITS = 18;
 281 
 282     /* Appease the serialization gods */
 283     @java.io.Serial
 284     private static final long serialVersionUID = 6108874887143696463L;
 285 
 286     private static final ThreadLocal&lt;StringBuilderHelper&gt;
 287         threadLocalStringBuilderHelper = new ThreadLocal&lt;StringBuilderHelper&gt;() {
 288         @Override
 289         protected StringBuilderHelper initialValue() {
 290             return new StringBuilderHelper();
 291         }
 292     };
 293 
 294     // Cache of common small BigDecimal values.
 295     private static final BigDecimal ZERO_THROUGH_TEN[] = {
 296         new BigDecimal(BigInteger.ZERO,       0,  0, 1),
 297         new BigDecimal(BigInteger.ONE,        1,  0, 1),
 298         new BigDecimal(BigInteger.TWO,        2,  0, 1),
 299         new BigDecimal(BigInteger.valueOf(3), 3,  0, 1),
 300         new BigDecimal(BigInteger.valueOf(4), 4,  0, 1),
 301         new BigDecimal(BigInteger.valueOf(5), 5,  0, 1),
 302         new BigDecimal(BigInteger.valueOf(6), 6,  0, 1),
 303         new BigDecimal(BigInteger.valueOf(7), 7,  0, 1),
 304         new BigDecimal(BigInteger.valueOf(8), 8,  0, 1),
 305         new BigDecimal(BigInteger.valueOf(9), 9,  0, 1),
 306         new BigDecimal(BigInteger.TEN,        10, 0, 2),
 307     };
 308 
 309     // Cache of zero scaled by 0 - 15
 310     private static final BigDecimal[] ZERO_SCALED_BY = {
 311         ZERO_THROUGH_TEN[0],
 312         new BigDecimal(BigInteger.ZERO, 0, 1, 1),
 313         new BigDecimal(BigInteger.ZERO, 0, 2, 1),
 314         new BigDecimal(BigInteger.ZERO, 0, 3, 1),
 315         new BigDecimal(BigInteger.ZERO, 0, 4, 1),
 316         new BigDecimal(BigInteger.ZERO, 0, 5, 1),
 317         new BigDecimal(BigInteger.ZERO, 0, 6, 1),
 318         new BigDecimal(BigInteger.ZERO, 0, 7, 1),
 319         new BigDecimal(BigInteger.ZERO, 0, 8, 1),
 320         new BigDecimal(BigInteger.ZERO, 0, 9, 1),
 321         new BigDecimal(BigInteger.ZERO, 0, 10, 1),
 322         new BigDecimal(BigInteger.ZERO, 0, 11, 1),
 323         new BigDecimal(BigInteger.ZERO, 0, 12, 1),
 324         new BigDecimal(BigInteger.ZERO, 0, 13, 1),
 325         new BigDecimal(BigInteger.ZERO, 0, 14, 1),
 326         new BigDecimal(BigInteger.ZERO, 0, 15, 1),
 327     };
 328 
 329     // Half of Long.MIN_VALUE &amp; Long.MAX_VALUE.
 330     private static final long HALF_LONG_MAX_VALUE = Long.MAX_VALUE / 2;
 331     private static final long HALF_LONG_MIN_VALUE = Long.MIN_VALUE / 2;
 332 
 333     // Constants
 334     /**
 335      * The value 0, with a scale of 0.
 336      *
 337      * @since  1.5
 338      */
 339     public static final BigDecimal ZERO =
 340         ZERO_THROUGH_TEN[0];
 341 
 342     /**
 343      * The value 1, with a scale of 0.
 344      *
 345      * @since  1.5
 346      */
 347     public static final BigDecimal ONE =
 348         ZERO_THROUGH_TEN[1];
 349 
 350     /**
 351      * The value 10, with a scale of 0.
 352      *
 353      * @since  1.5
 354      */
 355     public static final BigDecimal TEN =
 356         ZERO_THROUGH_TEN[10];
 357 
 358     /**
 359      * The value 0.1, with a scale of 1.
 360      */
 361     private static final BigDecimal ONE_TENTH = valueOf(1L, 1);
 362 
 363     /**
 364      * The value 0.5, with a scale of 1.
 365      */
 366     private static final BigDecimal ONE_HALF = valueOf(5L, 1);
 367 
 368     // Constructors
 369 
 370     /**
 371      * Trusted package private constructor.
 372      * Trusted simply means if val is INFLATED, intVal could not be null and
 373      * if intVal is null, val could not be INFLATED.
 374      */
 375     BigDecimal(BigInteger intVal, long val, int scale, int prec) {
 376         this.scale = scale;
 377         this.precision = prec;
 378         this.intCompact = val;
 379         this.intVal = intVal;
 380     }
 381 
 382     /**
 383      * Translates a character array representation of a
 384      * {@code BigDecimal} into a {@code BigDecimal}, accepting the
 385      * same sequence of characters as the {@link #BigDecimal(String)}
 386      * constructor, while allowing a sub-array to be specified.
 387      *
 388      * @implNote If the sequence of characters is already available
 389      * within a character array, using this constructor is faster than
 390      * converting the {@code char} array to string and using the
 391      * {@code BigDecimal(String)} constructor.
 392      *
 393      * @param  in {@code char} array that is the source of characters.
 394      * @param  offset first character in the array to inspect.
 395      * @param  len number of characters to consider.
 396      * @throws NumberFormatException if {@code in} is not a valid
 397      *         representation of a {@code BigDecimal} or the defined subarray
 398      *         is not wholly within {@code in}.
 399      * @since  1.5
 400      */
 401     public BigDecimal(char[] in, int offset, int len) {
 402         this(in,offset,len,MathContext.UNLIMITED);
 403     }
 404 
 405     /**
 406      * Translates a character array representation of a
 407      * {@code BigDecimal} into a {@code BigDecimal}, accepting the
 408      * same sequence of characters as the {@link #BigDecimal(String)}
 409      * constructor, while allowing a sub-array to be specified and
 410      * with rounding according to the context settings.
 411      *
 412      * @implNote If the sequence of characters is already available
 413      * within a character array, using this constructor is faster than
 414      * converting the {@code char} array to string and using the
 415      * {@code BigDecimal(String)} constructor.
 416      *
 417      * @param  in {@code char} array that is the source of characters.
 418      * @param  offset first character in the array to inspect.
 419      * @param  len number of characters to consider.
 420      * @param  mc the context to use.
 421      * @throws ArithmeticException if the result is inexact but the
 422      *         rounding mode is {@code UNNECESSARY}.
 423      * @throws NumberFormatException if {@code in} is not a valid
 424      *         representation of a {@code BigDecimal} or the defined subarray
 425      *         is not wholly within {@code in}.
 426      * @since  1.5
 427      */
 428     public BigDecimal(char[] in, int offset, int len, MathContext mc) {
 429         // protect against huge length, negative values, and integer overflow
 430         try {
 431             Objects.checkFromIndexSize(offset, len, in.length);
 432         } catch (IndexOutOfBoundsException e) {
 433             throw new NumberFormatException
 434                 (&quot;Bad offset or len arguments for char[] input.&quot;);
 435         }
 436 
 437         // This is the primary string to BigDecimal constructor; all
 438         // incoming strings end up here; it uses explicit (inline)
 439         // parsing for speed and generates at most one intermediate
 440         // (temporary) object (a char[] array) for non-compact case.
 441 
 442         // Use locals for all fields values until completion
 443         int prec = 0;                 // record precision value
 444         int scl = 0;                  // record scale value
 445         long rs = 0;                  // the compact value in long
 446         BigInteger rb = null;         // the inflated value in BigInteger
 447         // use array bounds checking to handle too-long, len == 0,
 448         // bad offset, etc.
 449         try {
 450             // handle the sign
 451             boolean isneg = false;          // assume positive
 452             if (in[offset] == &#39;-&#39;) {
 453                 isneg = true;               // leading minus means negative
 454                 offset++;
 455                 len--;
 456             } else if (in[offset] == &#39;+&#39;) { // leading + allowed
 457                 offset++;
 458                 len--;
 459             }
 460 
 461             // should now be at numeric part of the significand
 462             boolean dot = false;             // true when there is a &#39;.&#39;
 463             long exp = 0;                    // exponent
 464             char c;                          // current character
 465             boolean isCompact = (len &lt;= MAX_COMPACT_DIGITS);
 466             // integer significand array &amp; idx is the index to it. The array
 467             // is ONLY used when we can&#39;t use a compact representation.
 468             int idx = 0;
 469             if (isCompact) {
 470                 // First compact case, we need not to preserve the character
 471                 // and we can just compute the value in place.
 472                 for (; len &gt; 0; offset++, len--) {
 473                     c = in[offset];
 474                     if ((c == &#39;0&#39;)) { // have zero
 475                         if (prec == 0)
 476                             prec = 1;
 477                         else if (rs != 0) {
 478                             rs *= 10;
 479                             ++prec;
 480                         } // else digit is a redundant leading zero
 481                         if (dot)
 482                             ++scl;
 483                     } else if ((c &gt;= &#39;1&#39; &amp;&amp; c &lt;= &#39;9&#39;)) { // have digit
 484                         int digit = c - &#39;0&#39;;
 485                         if (prec != 1 || rs != 0)
 486                             ++prec; // prec unchanged if preceded by 0s
 487                         rs = rs * 10 + digit;
 488                         if (dot)
 489                             ++scl;
 490                     } else if (c == &#39;.&#39;) {   // have dot
 491                         // have dot
 492                         if (dot) // two dots
 493                             throw new NumberFormatException(&quot;Character array&quot;
 494                                 + &quot; contains more than one decimal point.&quot;);
 495                         dot = true;
 496                     } else if (Character.isDigit(c)) { // slow path
 497                         int digit = Character.digit(c, 10);
 498                         if (digit == 0) {
 499                             if (prec == 0)
 500                                 prec = 1;
 501                             else if (rs != 0) {
 502                                 rs *= 10;
 503                                 ++prec;
 504                             } // else digit is a redundant leading zero
 505                         } else {
 506                             if (prec != 1 || rs != 0)
 507                                 ++prec; // prec unchanged if preceded by 0s
 508                             rs = rs * 10 + digit;
 509                         }
 510                         if (dot)
 511                             ++scl;
 512                     } else if ((c == &#39;e&#39;) || (c == &#39;E&#39;)) {
 513                         exp = parseExp(in, offset, len);
 514                         // Next test is required for backwards compatibility
 515                         if ((int) exp != exp) // overflow
 516                             throw new NumberFormatException(&quot;Exponent overflow.&quot;);
 517                         break; // [saves a test]
 518                     } else {
 519                         throw new NumberFormatException(&quot;Character &quot; + c
 520                             + &quot; is neither a decimal digit number, decimal point, nor&quot;
 521                             + &quot; \&quot;e\&quot; notation exponential mark.&quot;);
 522                     }
 523                 }
 524                 if (prec == 0) // no digits found
 525                     throw new NumberFormatException(&quot;No digits found.&quot;);
 526                 // Adjust scale if exp is not zero.
 527                 if (exp != 0) { // had significant exponent
 528                     scl = adjustScale(scl, exp);
 529                 }
 530                 rs = isneg ? -rs : rs;
 531                 int mcp = mc.precision;
 532                 int drop = prec - mcp; // prec has range [1, MAX_INT], mcp has range [0, MAX_INT];
 533                                        // therefore, this subtract cannot overflow
 534                 if (mcp &gt; 0 &amp;&amp; drop &gt; 0) {  // do rounding
 535                     while (drop &gt; 0) {
 536                         scl = checkScaleNonZero((long) scl - drop);
 537                         rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
 538                         prec = longDigitLength(rs);
 539                         drop = prec - mcp;
 540                     }
 541                 }
 542             } else {
 543                 char coeff[] = new char[len];
 544                 for (; len &gt; 0; offset++, len--) {
 545                     c = in[offset];
 546                     // have digit
 547                     if ((c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) || Character.isDigit(c)) {
 548                         // First compact case, we need not to preserve the character
 549                         // and we can just compute the value in place.
 550                         if (c == &#39;0&#39; || Character.digit(c, 10) == 0) {
 551                             if (prec == 0) {
 552                                 coeff[idx] = c;
 553                                 prec = 1;
 554                             } else if (idx != 0) {
 555                                 coeff[idx++] = c;
 556                                 ++prec;
 557                             } // else c must be a redundant leading zero
 558                         } else {
 559                             if (prec != 1 || idx != 0)
 560                                 ++prec; // prec unchanged if preceded by 0s
 561                             coeff[idx++] = c;
 562                         }
 563                         if (dot)
 564                             ++scl;
 565                         continue;
 566                     }
 567                     // have dot
 568                     if (c == &#39;.&#39;) {
 569                         // have dot
 570                         if (dot) // two dots
 571                             throw new NumberFormatException(&quot;Character array&quot;
 572                                 + &quot; contains more than one decimal point.&quot;);
 573                         dot = true;
 574                         continue;
 575                     }
 576                     // exponent expected
 577                     if ((c != &#39;e&#39;) &amp;&amp; (c != &#39;E&#39;))
 578                         throw new NumberFormatException(&quot;Character array&quot;
 579                             + &quot; is missing \&quot;e\&quot; notation exponential mark.&quot;);
 580                     exp = parseExp(in, offset, len);
 581                     // Next test is required for backwards compatibility
 582                     if ((int) exp != exp) // overflow
 583                         throw new NumberFormatException(&quot;Exponent overflow.&quot;);
 584                     break; // [saves a test]
 585                 }
 586                 // here when no characters left
 587                 if (prec == 0) // no digits found
 588                     throw new NumberFormatException(&quot;No digits found.&quot;);
 589                 // Adjust scale if exp is not zero.
 590                 if (exp != 0) { // had significant exponent
 591                     scl = adjustScale(scl, exp);
 592                 }
 593                 // Remove leading zeros from precision (digits count)
 594                 rb = new BigInteger(coeff, isneg ? -1 : 1, prec);
 595                 rs = compactValFor(rb);
 596                 int mcp = mc.precision;
 597                 if (mcp &gt; 0 &amp;&amp; (prec &gt; mcp)) {
 598                     if (rs == INFLATED) {
 599                         int drop = prec - mcp;
 600                         while (drop &gt; 0) {
 601                             scl = checkScaleNonZero((long) scl - drop);
 602                             rb = divideAndRoundByTenPow(rb, drop, mc.roundingMode.oldMode);
 603                             rs = compactValFor(rb);
 604                             if (rs != INFLATED) {
 605                                 prec = longDigitLength(rs);
 606                                 break;
 607                             }
 608                             prec = bigDigitLength(rb);
 609                             drop = prec - mcp;
 610                         }
 611                     }
 612                     if (rs != INFLATED) {
 613                         int drop = prec - mcp;
 614                         while (drop &gt; 0) {
 615                             scl = checkScaleNonZero((long) scl - drop);
 616                             rs = divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
 617                             prec = longDigitLength(rs);
 618                             drop = prec - mcp;
 619                         }
 620                         rb = null;
 621                     }
 622                 }
 623             }
 624         } catch (ArrayIndexOutOfBoundsException | NegativeArraySizeException e) {
 625             NumberFormatException nfe = new NumberFormatException();
 626             nfe.initCause(e);
 627             throw nfe;
 628         }
 629         this.scale = scl;
 630         this.precision = prec;
 631         this.intCompact = rs;
 632         this.intVal = rb;
 633     }
 634 
 635     private int adjustScale(int scl, long exp) {
 636         long adjustedScale = scl - exp;
 637         if (adjustedScale &gt; Integer.MAX_VALUE || adjustedScale &lt; Integer.MIN_VALUE)
 638             throw new NumberFormatException(&quot;Scale out of range.&quot;);
 639         scl = (int) adjustedScale;
 640         return scl;
 641     }
 642 
 643     /*
 644      * parse exponent
 645      */
 646     private static long parseExp(char[] in, int offset, int len){
 647         long exp = 0;
 648         offset++;
 649         char c = in[offset];
 650         len--;
 651         boolean negexp = (c == &#39;-&#39;);
 652         // optional sign
 653         if (negexp || c == &#39;+&#39;) {
 654             offset++;
 655             c = in[offset];
 656             len--;
 657         }
 658         if (len &lt;= 0) // no exponent digits
 659             throw new NumberFormatException(&quot;No exponent digits.&quot;);
 660         // skip leading zeros in the exponent
 661         while (len &gt; 10 &amp;&amp; (c==&#39;0&#39; || (Character.digit(c, 10) == 0))) {
 662             offset++;
 663             c = in[offset];
 664             len--;
 665         }
 666         if (len &gt; 10) // too many nonzero exponent digits
 667             throw new NumberFormatException(&quot;Too many nonzero exponent digits.&quot;);
 668         // c now holds first digit of exponent
 669         for (;; len--) {
 670             int v;
 671             if (c &gt;= &#39;0&#39; &amp;&amp; c &lt;= &#39;9&#39;) {
 672                 v = c - &#39;0&#39;;
 673             } else {
 674                 v = Character.digit(c, 10);
 675                 if (v &lt; 0) // not a digit
 676                     throw new NumberFormatException(&quot;Not a digit.&quot;);
 677             }
 678             exp = exp * 10 + v;
 679             if (len == 1)
 680                 break; // that was final character
 681             offset++;
 682             c = in[offset];
 683         }
 684         if (negexp) // apply sign
 685             exp = -exp;
 686         return exp;
 687     }
 688 
 689     /**
 690      * Translates a character array representation of a
 691      * {@code BigDecimal} into a {@code BigDecimal}, accepting the
 692      * same sequence of characters as the {@link #BigDecimal(String)}
 693      * constructor.
 694      *
 695      * @implNote If the sequence of characters is already available
 696      * as a character array, using this constructor is faster than
 697      * converting the {@code char} array to string and using the
 698      * {@code BigDecimal(String)} constructor.
 699      *
 700      * @param in {@code char} array that is the source of characters.
 701      * @throws NumberFormatException if {@code in} is not a valid
 702      *         representation of a {@code BigDecimal}.
 703      * @since  1.5
 704      */
 705     public BigDecimal(char[] in) {
 706         this(in, 0, in.length);
 707     }
 708 
 709     /**
 710      * Translates a character array representation of a
 711      * {@code BigDecimal} into a {@code BigDecimal}, accepting the
 712      * same sequence of characters as the {@link #BigDecimal(String)}
 713      * constructor and with rounding according to the context
 714      * settings.
 715      *
 716      * @implNote If the sequence of characters is already available
 717      * as a character array, using this constructor is faster than
 718      * converting the {@code char} array to string and using the
 719      * {@code BigDecimal(String)} constructor.
 720      *
 721      * @param  in {@code char} array that is the source of characters.
 722      * @param  mc the context to use.
 723      * @throws ArithmeticException if the result is inexact but the
 724      *         rounding mode is {@code UNNECESSARY}.
 725      * @throws NumberFormatException if {@code in} is not a valid
 726      *         representation of a {@code BigDecimal}.
 727      * @since  1.5
 728      */
 729     public BigDecimal(char[] in, MathContext mc) {
 730         this(in, 0, in.length, mc);
 731     }
 732 
 733     /**
 734      * Translates the string representation of a {@code BigDecimal}
 735      * into a {@code BigDecimal}.  The string representation consists
 736      * of an optional sign, {@code &#39;+&#39;} (&lt;code&gt; &#39;&amp;#92;u002B&#39;&lt;/code&gt;) or
 737      * {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002D&#39;&lt;/code&gt;), followed by a sequence of
 738      * zero or more decimal digits (&quot;the integer&quot;), optionally
 739      * followed by a fraction, optionally followed by an exponent.
 740      *
 741      * &lt;p&gt;The fraction consists of a decimal point followed by zero
 742      * or more decimal digits.  The string must contain at least one
 743      * digit in either the integer or the fraction.  The number formed
 744      * by the sign, the integer and the fraction is referred to as the
 745      * &lt;i&gt;significand&lt;/i&gt;.
 746      *
 747      * &lt;p&gt;The exponent consists of the character {@code &#39;e&#39;}
 748      * (&lt;code&gt;&#39;&amp;#92;u0065&#39;&lt;/code&gt;) or {@code &#39;E&#39;} (&lt;code&gt;&#39;&amp;#92;u0045&#39;&lt;/code&gt;)
 749      * followed by one or more decimal digits.  The value of the
 750      * exponent must lie between -{@link Integer#MAX_VALUE} ({@link
 751      * Integer#MIN_VALUE}+1) and {@link Integer#MAX_VALUE}, inclusive.
 752      *
 753      * &lt;p&gt;More formally, the strings this constructor accepts are
 754      * described by the following grammar:
 755      * &lt;blockquote&gt;
 756      * &lt;dl&gt;
 757      * &lt;dt&gt;&lt;i&gt;BigDecimalString:&lt;/i&gt;
 758      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; Significand Exponent&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 759      * &lt;dt&gt;&lt;i&gt;Sign:&lt;/i&gt;
 760      * &lt;dd&gt;{@code +}
 761      * &lt;dd&gt;{@code -}
 762      * &lt;dt&gt;&lt;i&gt;Significand:&lt;/i&gt;
 763      * &lt;dd&gt;&lt;i&gt;IntegerPart&lt;/i&gt; {@code .} &lt;i&gt;FractionPart&lt;sub&gt;opt&lt;/sub&gt;&lt;/i&gt;
 764      * &lt;dd&gt;{@code .} &lt;i&gt;FractionPart&lt;/i&gt;
 765      * &lt;dd&gt;&lt;i&gt;IntegerPart&lt;/i&gt;
 766      * &lt;dt&gt;&lt;i&gt;IntegerPart:&lt;/i&gt;
 767      * &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
 768      * &lt;dt&gt;&lt;i&gt;FractionPart:&lt;/i&gt;
 769      * &lt;dd&gt;&lt;i&gt;Digits&lt;/i&gt;
 770      * &lt;dt&gt;&lt;i&gt;Exponent:&lt;/i&gt;
 771      * &lt;dd&gt;&lt;i&gt;ExponentIndicator SignedInteger&lt;/i&gt;
 772      * &lt;dt&gt;&lt;i&gt;ExponentIndicator:&lt;/i&gt;
 773      * &lt;dd&gt;{@code e}
 774      * &lt;dd&gt;{@code E}
 775      * &lt;dt&gt;&lt;i&gt;SignedInteger:&lt;/i&gt;
 776      * &lt;dd&gt;&lt;i&gt;Sign&lt;sub&gt;opt&lt;/sub&gt; Digits&lt;/i&gt;
 777      * &lt;dt&gt;&lt;i&gt;Digits:&lt;/i&gt;
 778      * &lt;dd&gt;&lt;i&gt;Digit&lt;/i&gt;
 779      * &lt;dd&gt;&lt;i&gt;Digits Digit&lt;/i&gt;
 780      * &lt;dt&gt;&lt;i&gt;Digit:&lt;/i&gt;
 781      * &lt;dd&gt;any character for which {@link Character#isDigit}
 782      * returns {@code true}, including 0, 1, 2 ...
 783      * &lt;/dl&gt;
 784      * &lt;/blockquote&gt;
 785      *
 786      * &lt;p&gt;The scale of the returned {@code BigDecimal} will be the
 787      * number of digits in the fraction, or zero if the string
 788      * contains no decimal point, subject to adjustment for any
 789      * exponent; if the string contains an exponent, the exponent is
 790      * subtracted from the scale.  The value of the resulting scale
 791      * must lie between {@code Integer.MIN_VALUE} and
 792      * {@code Integer.MAX_VALUE}, inclusive.
 793      *
 794      * &lt;p&gt;The character-to-digit mapping is provided by {@link
 795      * java.lang.Character#digit} set to convert to radix 10.  The
 796      * String may not contain any extraneous characters (whitespace,
 797      * for example).
 798      *
 799      * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;&lt;br&gt;
 800      * The value of the returned {@code BigDecimal} is equal to
 801      * &lt;i&gt;significand&lt;/i&gt; &amp;times; 10&lt;sup&gt;&amp;nbsp;&lt;i&gt;exponent&lt;/i&gt;&lt;/sup&gt;.
 802      * For each string on the left, the resulting representation
 803      * [{@code BigInteger}, {@code scale}] is shown on the right.
 804      * &lt;pre&gt;
 805      * &quot;0&quot;            [0,0]
 806      * &quot;0.00&quot;         [0,2]
 807      * &quot;123&quot;          [123,0]
 808      * &quot;-123&quot;         [-123,0]
 809      * &quot;1.23E3&quot;       [123,-1]
 810      * &quot;1.23E+3&quot;      [123,-1]
 811      * &quot;12.3E+7&quot;      [123,-6]
 812      * &quot;12.0&quot;         [120,1]
 813      * &quot;12.3&quot;         [123,1]
 814      * &quot;0.00123&quot;      [123,5]
 815      * &quot;-1.23E-12&quot;    [-123,14]
 816      * &quot;1234.5E-4&quot;    [12345,5]
 817      * &quot;0E+7&quot;         [0,-7]
 818      * &quot;-0&quot;           [0,0]
 819      * &lt;/pre&gt;
 820      *
 821      * @apiNote For values other than {@code float} and
 822      * {@code double} NaN and &amp;plusmn;Infinity, this constructor is
 823      * compatible with the values returned by {@link Float#toString}
 824      * and {@link Double#toString}.  This is generally the preferred
 825      * way to convert a {@code float} or {@code double} into a
 826      * BigDecimal, as it doesn&#39;t suffer from the unpredictability of
 827      * the {@link #BigDecimal(double)} constructor.
 828      *
 829      * @param val String representation of {@code BigDecimal}.
 830      *
 831      * @throws NumberFormatException if {@code val} is not a valid
 832      *         representation of a {@code BigDecimal}.
 833      */
 834     public BigDecimal(String val) {
 835         this(val.toCharArray(), 0, val.length());
 836     }
 837 
 838     /**
 839      * Translates the string representation of a {@code BigDecimal}
 840      * into a {@code BigDecimal}, accepting the same strings as the
 841      * {@link #BigDecimal(String)} constructor, with rounding
 842      * according to the context settings.
 843      *
 844      * @param  val string representation of a {@code BigDecimal}.
 845      * @param  mc the context to use.
 846      * @throws ArithmeticException if the result is inexact but the
 847      *         rounding mode is {@code UNNECESSARY}.
 848      * @throws NumberFormatException if {@code val} is not a valid
 849      *         representation of a BigDecimal.
 850      * @since  1.5
 851      */
 852     public BigDecimal(String val, MathContext mc) {
 853         this(val.toCharArray(), 0, val.length(), mc);
 854     }
 855 
 856     /**
 857      * Translates a {@code double} into a {@code BigDecimal} which
 858      * is the exact decimal representation of the {@code double}&#39;s
 859      * binary floating-point value.  The scale of the returned
 860      * {@code BigDecimal} is the smallest value such that
 861      * &lt;code&gt;(10&lt;sup&gt;scale&lt;/sup&gt; &amp;times; val)&lt;/code&gt; is an integer.
 862      * &lt;p&gt;
 863      * &lt;b&gt;Notes:&lt;/b&gt;
 864      * &lt;ol&gt;
 865      * &lt;li&gt;
 866      * The results of this constructor can be somewhat unpredictable.
 867      * One might assume that writing {@code new BigDecimal(0.1)} in
 868      * Java creates a {@code BigDecimal} which is exactly equal to
 869      * 0.1 (an unscaled value of 1, with a scale of 1), but it is
 870      * actually equal to
 871      * 0.1000000000000000055511151231257827021181583404541015625.
 872      * This is because 0.1 cannot be represented exactly as a
 873      * {@code double} (or, for that matter, as a binary fraction of
 874      * any finite length).  Thus, the value that is being passed
 875      * &lt;em&gt;in&lt;/em&gt; to the constructor is not exactly equal to 0.1,
 876      * appearances notwithstanding.
 877      *
 878      * &lt;li&gt;
 879      * The {@code String} constructor, on the other hand, is
 880      * perfectly predictable: writing {@code new BigDecimal(&quot;0.1&quot;)}
 881      * creates a {@code BigDecimal} which is &lt;em&gt;exactly&lt;/em&gt; equal to
 882      * 0.1, as one would expect.  Therefore, it is generally
 883      * recommended that the {@linkplain #BigDecimal(String)
 884      * String constructor} be used in preference to this one.
 885      *
 886      * &lt;li&gt;
 887      * When a {@code double} must be used as a source for a
 888      * {@code BigDecimal}, note that this constructor provides an
 889      * exact conversion; it does not give the same result as
 890      * converting the {@code double} to a {@code String} using the
 891      * {@link Double#toString(double)} method and then using the
 892      * {@link #BigDecimal(String)} constructor.  To get that result,
 893      * use the {@code static} {@link #valueOf(double)} method.
 894      * &lt;/ol&gt;
 895      *
 896      * @param val {@code double} value to be converted to
 897      *        {@code BigDecimal}.
 898      * @throws NumberFormatException if {@code val} is infinite or NaN.
 899      */
 900     public BigDecimal(double val) {
 901         this(val,MathContext.UNLIMITED);
 902     }
 903 
 904     /**
 905      * Translates a {@code double} into a {@code BigDecimal}, with
 906      * rounding according to the context settings.  The scale of the
 907      * {@code BigDecimal} is the smallest value such that
 908      * &lt;code&gt;(10&lt;sup&gt;scale&lt;/sup&gt; &amp;times; val)&lt;/code&gt; is an integer.
 909      *
 910      * &lt;p&gt;The results of this constructor can be somewhat unpredictable
 911      * and its use is generally not recommended; see the notes under
 912      * the {@link #BigDecimal(double)} constructor.
 913      *
 914      * @param  val {@code double} value to be converted to
 915      *         {@code BigDecimal}.
 916      * @param  mc the context to use.
 917      * @throws ArithmeticException if the result is inexact but the
 918      *         RoundingMode is UNNECESSARY.
 919      * @throws NumberFormatException if {@code val} is infinite or NaN.
 920      * @since  1.5
 921      */
 922     public BigDecimal(double val, MathContext mc) {
 923         if (Double.isInfinite(val) || Double.isNaN(val))
 924             throw new NumberFormatException(&quot;Infinite or NaN&quot;);
 925         // Translate the double into sign, exponent and significand, according
 926         // to the formulae in JLS, Section 20.10.22.
 927         long valBits = Double.doubleToLongBits(val);
 928         int sign = ((valBits &gt;&gt; 63) == 0 ? 1 : -1);
 929         int exponent = (int) ((valBits &gt;&gt; 52) &amp; 0x7ffL);
 930         long significand = (exponent == 0
 931                 ? (valBits &amp; ((1L &lt;&lt; 52) - 1)) &lt;&lt; 1
 932                 : (valBits &amp; ((1L &lt;&lt; 52) - 1)) | (1L &lt;&lt; 52));
 933         exponent -= 1075;
 934         // At this point, val == sign * significand * 2**exponent.
 935 
 936         /*
 937          * Special case zero to supress nonterminating normalization and bogus
 938          * scale calculation.
 939          */
 940         if (significand == 0) {
 941             this.intVal = BigInteger.ZERO;
 942             this.scale = 0;
 943             this.intCompact = 0;
 944             this.precision = 1;
 945             return;
 946         }
 947         // Normalize
 948         while ((significand &amp; 1) == 0) { // i.e., significand is even
 949             significand &gt;&gt;= 1;
 950             exponent++;
 951         }
 952         int scl = 0;
 953         // Calculate intVal and scale
 954         BigInteger rb;
 955         long compactVal = sign * significand;
 956         if (exponent == 0) {
 957             rb = (compactVal == INFLATED) ? INFLATED_BIGINT : null;
 958         } else {
 959             if (exponent &lt; 0) {
 960                 rb = BigInteger.valueOf(5).pow(-exponent).multiply(compactVal);
 961                 scl = -exponent;
 962             } else { //  (exponent &gt; 0)
 963                 rb = BigInteger.TWO.pow(exponent).multiply(compactVal);
 964             }
 965             compactVal = compactValFor(rb);
 966         }
 967         int prec = 0;
 968         int mcp = mc.precision;
 969         if (mcp &gt; 0) { // do rounding
 970             int mode = mc.roundingMode.oldMode;
 971             int drop;
 972             if (compactVal == INFLATED) {
 973                 prec = bigDigitLength(rb);
 974                 drop = prec - mcp;
 975                 while (drop &gt; 0) {
 976                     scl = checkScaleNonZero((long) scl - drop);
 977                     rb = divideAndRoundByTenPow(rb, drop, mode);
 978                     compactVal = compactValFor(rb);
 979                     if (compactVal != INFLATED) {
 980                         break;
 981                     }
 982                     prec = bigDigitLength(rb);
 983                     drop = prec - mcp;
 984                 }
 985             }
 986             if (compactVal != INFLATED) {
 987                 prec = longDigitLength(compactVal);
 988                 drop = prec - mcp;
 989                 while (drop &gt; 0) {
 990                     scl = checkScaleNonZero((long) scl - drop);
 991                     compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
 992                     prec = longDigitLength(compactVal);
 993                     drop = prec - mcp;
 994                 }
 995                 rb = null;
 996             }
 997         }
 998         this.intVal = rb;
 999         this.intCompact = compactVal;
1000         this.scale = scl;
1001         this.precision = prec;
1002     }
1003 
1004     /**
1005      * Translates a {@code BigInteger} into a {@code BigDecimal}.
1006      * The scale of the {@code BigDecimal} is zero.
1007      *
1008      * @param val {@code BigInteger} value to be converted to
1009      *            {@code BigDecimal}.
1010      */
1011     public BigDecimal(BigInteger val) {
1012         scale = 0;
1013         intVal = val;
1014         intCompact = compactValFor(val);
1015     }
1016 
1017     /**
1018      * Translates a {@code BigInteger} into a {@code BigDecimal}
1019      * rounding according to the context settings.  The scale of the
1020      * {@code BigDecimal} is zero.
1021      *
1022      * @param val {@code BigInteger} value to be converted to
1023      *            {@code BigDecimal}.
1024      * @param  mc the context to use.
1025      * @throws ArithmeticException if the result is inexact but the
1026      *         rounding mode is {@code UNNECESSARY}.
1027      * @since  1.5
1028      */
1029     public BigDecimal(BigInteger val, MathContext mc) {
1030         this(val,0,mc);
1031     }
1032 
1033     /**
1034      * Translates a {@code BigInteger} unscaled value and an
1035      * {@code int} scale into a {@code BigDecimal}.  The value of
1036      * the {@code BigDecimal} is
1037      * &lt;code&gt;(unscaledVal &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/code&gt;.
1038      *
1039      * @param unscaledVal unscaled value of the {@code BigDecimal}.
1040      * @param scale scale of the {@code BigDecimal}.
1041      */
1042     public BigDecimal(BigInteger unscaledVal, int scale) {
1043         // Negative scales are now allowed
1044         this.intVal = unscaledVal;
1045         this.intCompact = compactValFor(unscaledVal);
1046         this.scale = scale;
1047     }
1048 
1049     /**
1050      * Translates a {@code BigInteger} unscaled value and an
1051      * {@code int} scale into a {@code BigDecimal}, with rounding
1052      * according to the context settings.  The value of the
1053      * {@code BigDecimal} is &lt;code&gt;(unscaledVal &amp;times;
1054      * 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/code&gt;, rounded according to the
1055      * {@code precision} and rounding mode settings.
1056      *
1057      * @param  unscaledVal unscaled value of the {@code BigDecimal}.
1058      * @param  scale scale of the {@code BigDecimal}.
1059      * @param  mc the context to use.
1060      * @throws ArithmeticException if the result is inexact but the
1061      *         rounding mode is {@code UNNECESSARY}.
1062      * @since  1.5
1063      */
1064     public BigDecimal(BigInteger unscaledVal, int scale, MathContext mc) {
1065         long compactVal = compactValFor(unscaledVal);
1066         int mcp = mc.precision;
1067         int prec = 0;
1068         if (mcp &gt; 0) { // do rounding
1069             int mode = mc.roundingMode.oldMode;
1070             if (compactVal == INFLATED) {
1071                 prec = bigDigitLength(unscaledVal);
1072                 int drop = prec - mcp;
1073                 while (drop &gt; 0) {
1074                     scale = checkScaleNonZero((long) scale - drop);
1075                     unscaledVal = divideAndRoundByTenPow(unscaledVal, drop, mode);
1076                     compactVal = compactValFor(unscaledVal);
1077                     if (compactVal != INFLATED) {
1078                         break;
1079                     }
1080                     prec = bigDigitLength(unscaledVal);
1081                     drop = prec - mcp;
1082                 }
1083             }
1084             if (compactVal != INFLATED) {
1085                 prec = longDigitLength(compactVal);
1086                 int drop = prec - mcp;     // drop can&#39;t be more than 18
1087                 while (drop &gt; 0) {
1088                     scale = checkScaleNonZero((long) scale - drop);
1089                     compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mode);
1090                     prec = longDigitLength(compactVal);
1091                     drop = prec - mcp;
1092                 }
1093                 unscaledVal = null;
1094             }
1095         }
1096         this.intVal = unscaledVal;
1097         this.intCompact = compactVal;
1098         this.scale = scale;
1099         this.precision = prec;
1100     }
1101 
1102     /**
1103      * Translates an {@code int} into a {@code BigDecimal}.  The
1104      * scale of the {@code BigDecimal} is zero.
1105      *
1106      * @param val {@code int} value to be converted to
1107      *            {@code BigDecimal}.
1108      * @since  1.5
1109      */
1110     public BigDecimal(int val) {
1111         this.intCompact = val;
1112         this.scale = 0;
1113         this.intVal = null;
1114     }
1115 
1116     /**
1117      * Translates an {@code int} into a {@code BigDecimal}, with
1118      * rounding according to the context settings.  The scale of the
1119      * {@code BigDecimal}, before any rounding, is zero.
1120      *
1121      * @param  val {@code int} value to be converted to {@code BigDecimal}.
1122      * @param  mc the context to use.
1123      * @throws ArithmeticException if the result is inexact but the
1124      *         rounding mode is {@code UNNECESSARY}.
1125      * @since  1.5
1126      */
1127     public BigDecimal(int val, MathContext mc) {
1128         int mcp = mc.precision;
1129         long compactVal = val;
1130         int scl = 0;
1131         int prec = 0;
1132         if (mcp &gt; 0) { // do rounding
1133             prec = longDigitLength(compactVal);
1134             int drop = prec - mcp; // drop can&#39;t be more than 18
1135             while (drop &gt; 0) {
1136                 scl = checkScaleNonZero((long) scl - drop);
1137                 compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
1138                 prec = longDigitLength(compactVal);
1139                 drop = prec - mcp;
1140             }
1141         }
1142         this.intVal = null;
1143         this.intCompact = compactVal;
1144         this.scale = scl;
1145         this.precision = prec;
1146     }
1147 
1148     /**
1149      * Translates a {@code long} into a {@code BigDecimal}.  The
1150      * scale of the {@code BigDecimal} is zero.
1151      *
1152      * @param val {@code long} value to be converted to {@code BigDecimal}.
1153      * @since  1.5
1154      */
1155     public BigDecimal(long val) {
1156         this.intCompact = val;
1157         this.intVal = (val == INFLATED) ? INFLATED_BIGINT : null;
1158         this.scale = 0;
1159     }
1160 
1161     /**
1162      * Translates a {@code long} into a {@code BigDecimal}, with
1163      * rounding according to the context settings.  The scale of the
1164      * {@code BigDecimal}, before any rounding, is zero.
1165      *
1166      * @param  val {@code long} value to be converted to {@code BigDecimal}.
1167      * @param  mc the context to use.
1168      * @throws ArithmeticException if the result is inexact but the
1169      *         rounding mode is {@code UNNECESSARY}.
1170      * @since  1.5
1171      */
1172     public BigDecimal(long val, MathContext mc) {
1173         int mcp = mc.precision;
1174         int mode = mc.roundingMode.oldMode;
1175         int prec = 0;
1176         int scl = 0;
1177         BigInteger rb = (val == INFLATED) ? INFLATED_BIGINT : null;
1178         if (mcp &gt; 0) { // do rounding
1179             if (val == INFLATED) {
1180                 prec = 19;
1181                 int drop = prec - mcp;
1182                 while (drop &gt; 0) {
1183                     scl = checkScaleNonZero((long) scl - drop);
1184                     rb = divideAndRoundByTenPow(rb, drop, mode);
1185                     val = compactValFor(rb);
1186                     if (val != INFLATED) {
1187                         break;
1188                     }
1189                     prec = bigDigitLength(rb);
1190                     drop = prec - mcp;
1191                 }
1192             }
1193             if (val != INFLATED) {
1194                 prec = longDigitLength(val);
1195                 int drop = prec - mcp;
1196                 while (drop &gt; 0) {
1197                     scl = checkScaleNonZero((long) scl - drop);
1198                     val = divideAndRound(val, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
1199                     prec = longDigitLength(val);
1200                     drop = prec - mcp;
1201                 }
1202                 rb = null;
1203             }
1204         }
1205         this.intVal = rb;
1206         this.intCompact = val;
1207         this.scale = scl;
1208         this.precision = prec;
1209     }
1210 
1211     // Static Factory Methods
1212 
1213     /**
1214      * Translates a {@code long} unscaled value and an
1215      * {@code int} scale into a {@code BigDecimal}.
1216      *
1217      * @apiNote This static factory method is provided in preference
1218      * to a ({@code long}, {@code int}) constructor because it allows
1219      * for reuse of frequently used {@code BigDecimal} values.
1220      *
1221      * @param unscaledVal unscaled value of the {@code BigDecimal}.
1222      * @param scale scale of the {@code BigDecimal}.
1223      * @return a {@code BigDecimal} whose value is
1224      *         &lt;code&gt;(unscaledVal &amp;times; 10&lt;sup&gt;-scale&lt;/sup&gt;)&lt;/code&gt;.
1225      */
1226     public static BigDecimal valueOf(long unscaledVal, int scale) {
1227         if (scale == 0)
1228             return valueOf(unscaledVal);
1229         else if (unscaledVal == 0) {
1230             return zeroValueOf(scale);
1231         }
1232         return new BigDecimal(unscaledVal == INFLATED ?
1233                               INFLATED_BIGINT : null,
1234                               unscaledVal, scale, 0);
1235     }
1236 
1237     /**
1238      * Translates a {@code long} value into a {@code BigDecimal}
1239      * with a scale of zero.
1240      *
1241      * @apiNote This static factory method is provided in preference
1242      * to a ({@code long}) constructor because it allows for reuse of
1243      * frequently used {@code BigDecimal} values.
1244      *
1245      * @param val value of the {@code BigDecimal}.
1246      * @return a {@code BigDecimal} whose value is {@code val}.
1247      */
1248     public static BigDecimal valueOf(long val) {
1249         if (val &gt;= 0 &amp;&amp; val &lt; ZERO_THROUGH_TEN.length)
1250             return ZERO_THROUGH_TEN[(int)val];
1251         else if (val != INFLATED)
1252             return new BigDecimal(null, val, 0, 0);
1253         return new BigDecimal(INFLATED_BIGINT, val, 0, 0);
1254     }
1255 
1256     static BigDecimal valueOf(long unscaledVal, int scale, int prec) {
1257         if (scale == 0 &amp;&amp; unscaledVal &gt;= 0 &amp;&amp; unscaledVal &lt; ZERO_THROUGH_TEN.length) {
1258             return ZERO_THROUGH_TEN[(int) unscaledVal];
1259         } else if (unscaledVal == 0) {
1260             return zeroValueOf(scale);
1261         }
1262         return new BigDecimal(unscaledVal == INFLATED ? INFLATED_BIGINT : null,
1263                 unscaledVal, scale, prec);
1264     }
1265 
1266     static BigDecimal valueOf(BigInteger intVal, int scale, int prec) {
1267         long val = compactValFor(intVal);
1268         if (val == 0) {
1269             return zeroValueOf(scale);
1270         } else if (scale == 0 &amp;&amp; val &gt;= 0 &amp;&amp; val &lt; ZERO_THROUGH_TEN.length) {
1271             return ZERO_THROUGH_TEN[(int) val];
1272         }
1273         return new BigDecimal(intVal, val, scale, prec);
1274     }
1275 
1276     static BigDecimal zeroValueOf(int scale) {
1277         if (scale &gt;= 0 &amp;&amp; scale &lt; ZERO_SCALED_BY.length)
1278             return ZERO_SCALED_BY[scale];
1279         else
1280             return new BigDecimal(BigInteger.ZERO, 0, scale, 1);
1281     }
1282 
1283     /**
1284      * Translates a {@code double} into a {@code BigDecimal}, using
1285      * the {@code double}&#39;s canonical string representation provided
1286      * by the {@link Double#toString(double)} method.
1287      *
1288      * @apiNote This is generally the preferred way to convert a
1289      * {@code double} (or {@code float}) into a {@code BigDecimal}, as
1290      * the value returned is equal to that resulting from constructing
1291      * a {@code BigDecimal} from the result of using {@link
1292      * Double#toString(double)}.
1293      *
1294      * @param  val {@code double} to convert to a {@code BigDecimal}.
1295      * @return a {@code BigDecimal} whose value is equal to or approximately
1296      *         equal to the value of {@code val}.
1297      * @throws NumberFormatException if {@code val} is infinite or NaN.
1298      * @since  1.5
1299      */
1300     public static BigDecimal valueOf(double val) {
1301         // Reminder: a zero double returns &#39;0.0&#39;, so we cannot fastpath
1302         // to use the constant ZERO.  This might be important enough to
1303         // justify a factory approach, a cache, or a few private
1304         // constants, later.
1305         return new BigDecimal(Double.toString(val));
1306     }
1307 
1308     // Arithmetic Operations
1309     /**
1310      * Returns a {@code BigDecimal} whose value is {@code (this +
1311      * augend)}, and whose scale is {@code max(this.scale(),
1312      * augend.scale())}.
1313      *
1314      * @param  augend value to be added to this {@code BigDecimal}.
1315      * @return {@code this + augend}
1316      */
1317     public BigDecimal add(BigDecimal augend) {
1318         if (this.intCompact != INFLATED) {
1319             if ((augend.intCompact != INFLATED)) {
1320                 return add(this.intCompact, this.scale, augend.intCompact, augend.scale);
1321             } else {
1322                 return add(this.intCompact, this.scale, augend.intVal, augend.scale);
1323             }
1324         } else {
1325             if ((augend.intCompact != INFLATED)) {
1326                 return add(augend.intCompact, augend.scale, this.intVal, this.scale);
1327             } else {
1328                 return add(this.intVal, this.scale, augend.intVal, augend.scale);
1329             }
1330         }
1331     }
1332 
1333     /**
1334      * Returns a {@code BigDecimal} whose value is {@code (this + augend)},
1335      * with rounding according to the context settings.
1336      *
1337      * If either number is zero and the precision setting is nonzero then
1338      * the other number, rounded if necessary, is used as the result.
1339      *
1340      * @param  augend value to be added to this {@code BigDecimal}.
1341      * @param  mc the context to use.
1342      * @return {@code this + augend}, rounded as necessary.
1343      * @throws ArithmeticException if the result is inexact but the
1344      *         rounding mode is {@code UNNECESSARY}.
1345      * @since  1.5
1346      */
1347     public BigDecimal add(BigDecimal augend, MathContext mc) {
1348         if (mc.precision == 0)
1349             return add(augend);
1350         BigDecimal lhs = this;
1351 
1352         // If either number is zero then the other number, rounded and
1353         // scaled if necessary, is used as the result.
1354         {
1355             boolean lhsIsZero = lhs.signum() == 0;
1356             boolean augendIsZero = augend.signum() == 0;
1357 
1358             if (lhsIsZero || augendIsZero) {
1359                 int preferredScale = Math.max(lhs.scale(), augend.scale());
1360                 BigDecimal result;
1361 
1362                 if (lhsIsZero &amp;&amp; augendIsZero)
1363                     return zeroValueOf(preferredScale);
1364                 result = lhsIsZero ? doRound(augend, mc) : doRound(lhs, mc);
1365 
1366                 if (result.scale() == preferredScale)
1367                     return result;
1368                 else if (result.scale() &gt; preferredScale) {
1369                     return stripZerosToMatchScale(result.intVal, result.intCompact, result.scale, preferredScale);
1370                 } else { // result.scale &lt; preferredScale
1371                     int precisionDiff = mc.precision - result.precision();
1372                     int scaleDiff     = preferredScale - result.scale();
1373 
1374                     if (precisionDiff &gt;= scaleDiff)
1375                         return result.setScale(preferredScale); // can achieve target scale
1376                     else
1377                         return result.setScale(result.scale() + precisionDiff);
1378                 }
1379             }
1380         }
1381 
1382         long padding = (long) lhs.scale - augend.scale;
1383         if (padding != 0) { // scales differ; alignment needed
1384             BigDecimal arg[] = preAlign(lhs, augend, padding, mc);
1385             matchScale(arg);
1386             lhs = arg[0];
1387             augend = arg[1];
1388         }
1389         return doRound(lhs.inflated().add(augend.inflated()), lhs.scale, mc);
1390     }
1391 
1392     /**
1393      * Returns an array of length two, the sum of whose entries is
1394      * equal to the rounded sum of the {@code BigDecimal} arguments.
1395      *
1396      * &lt;p&gt;If the digit positions of the arguments have a sufficient
1397      * gap between them, the value smaller in magnitude can be
1398      * condensed into a {@literal &quot;sticky bit&quot;} and the end result will
1399      * round the same way &lt;em&gt;if&lt;/em&gt; the precision of the final
1400      * result does not include the high order digit of the small
1401      * magnitude operand.
1402      *
1403      * &lt;p&gt;Note that while strictly speaking this is an optimization,
1404      * it makes a much wider range of additions practical.
1405      *
1406      * &lt;p&gt;This corresponds to a pre-shift operation in a fixed
1407      * precision floating-point adder; this method is complicated by
1408      * variable precision of the result as determined by the
1409      * MathContext.  A more nuanced operation could implement a
1410      * {@literal &quot;right shift&quot;} on the smaller magnitude operand so
1411      * that the number of digits of the smaller operand could be
1412      * reduced even though the significands partially overlapped.
1413      */
1414     private BigDecimal[] preAlign(BigDecimal lhs, BigDecimal augend, long padding, MathContext mc) {
1415         assert padding != 0;
1416         BigDecimal big;
1417         BigDecimal small;
1418 
1419         if (padding &lt; 0) { // lhs is big; augend is small
1420             big = lhs;
1421             small = augend;
1422         } else { // lhs is small; augend is big
1423             big = augend;
1424             small = lhs;
1425         }
1426 
1427         /*
1428          * This is the estimated scale of an ulp of the result; it assumes that
1429          * the result doesn&#39;t have a carry-out on a true add (e.g. 999 + 1 =&gt;
1430          * 1000) or any subtractive cancellation on borrowing (e.g. 100 - 1.2 =&gt;
1431          * 98.8)
1432          */
1433         long estResultUlpScale = (long) big.scale - big.precision() + mc.precision;
1434 
1435         /*
1436          * The low-order digit position of big is big.scale().  This
1437          * is true regardless of whether big has a positive or
1438          * negative scale.  The high-order digit position of small is
1439          * small.scale - (small.precision() - 1).  To do the full
1440          * condensation, the digit positions of big and small must be
1441          * disjoint *and* the digit positions of small should not be
1442          * directly visible in the result.
1443          */
1444         long smallHighDigitPos = (long) small.scale - small.precision() + 1;
1445         if (smallHighDigitPos &gt; big.scale + 2 &amp;&amp; // big and small disjoint
1446             smallHighDigitPos &gt; estResultUlpScale + 2) { // small digits not visible
1447             small = BigDecimal.valueOf(small.signum(), this.checkScale(Math.max(big.scale, estResultUlpScale) + 3));
1448         }
1449 
1450         // Since addition is symmetric, preserving input order in
1451         // returned operands doesn&#39;t matter
1452         BigDecimal[] result = {big, small};
1453         return result;
1454     }
1455 
1456     /**
1457      * Returns a {@code BigDecimal} whose value is {@code (this -
1458      * subtrahend)}, and whose scale is {@code max(this.scale(),
1459      * subtrahend.scale())}.
1460      *
1461      * @param  subtrahend value to be subtracted from this {@code BigDecimal}.
1462      * @return {@code this - subtrahend}
1463      */
1464     public BigDecimal subtract(BigDecimal subtrahend) {
1465         if (this.intCompact != INFLATED) {
1466             if ((subtrahend.intCompact != INFLATED)) {
1467                 return add(this.intCompact, this.scale, -subtrahend.intCompact, subtrahend.scale);
1468             } else {
1469                 return add(this.intCompact, this.scale, subtrahend.intVal.negate(), subtrahend.scale);
1470             }
1471         } else {
1472             if ((subtrahend.intCompact != INFLATED)) {
1473                 // Pair of subtrahend values given before pair of
1474                 // values from this BigDecimal to avoid need for
1475                 // method overloading on the specialized add method
1476                 return add(-subtrahend.intCompact, subtrahend.scale, this.intVal, this.scale);
1477             } else {
1478                 return add(this.intVal, this.scale, subtrahend.intVal.negate(), subtrahend.scale);
1479             }
1480         }
1481     }
1482 
1483     /**
1484      * Returns a {@code BigDecimal} whose value is {@code (this - subtrahend)},
1485      * with rounding according to the context settings.
1486      *
1487      * If {@code subtrahend} is zero then this, rounded if necessary, is used as the
1488      * result.  If this is zero then the result is {@code subtrahend.negate(mc)}.
1489      *
1490      * @param  subtrahend value to be subtracted from this {@code BigDecimal}.
1491      * @param  mc the context to use.
1492      * @return {@code this - subtrahend}, rounded as necessary.
1493      * @throws ArithmeticException if the result is inexact but the
1494      *         rounding mode is {@code UNNECESSARY}.
1495      * @since  1.5
1496      */
1497     public BigDecimal subtract(BigDecimal subtrahend, MathContext mc) {
1498         if (mc.precision == 0)
1499             return subtract(subtrahend);
1500         // share the special rounding code in add()
1501         return add(subtrahend.negate(), mc);
1502     }
1503 
1504     /**
1505      * Returns a {@code BigDecimal} whose value is &lt;code&gt;(this &amp;times;
1506      * multiplicand)&lt;/code&gt;, and whose scale is {@code (this.scale() +
1507      * multiplicand.scale())}.
1508      *
1509      * @param  multiplicand value to be multiplied by this {@code BigDecimal}.
1510      * @return {@code this * multiplicand}
1511      */
1512     public BigDecimal multiply(BigDecimal multiplicand) {
1513         int productScale = checkScale((long) scale + multiplicand.scale);
1514         if (this.intCompact != INFLATED) {
1515             if ((multiplicand.intCompact != INFLATED)) {
1516                 return multiply(this.intCompact, multiplicand.intCompact, productScale);
1517             } else {
1518                 return multiply(this.intCompact, multiplicand.intVal, productScale);
1519             }
1520         } else {
1521             if ((multiplicand.intCompact != INFLATED)) {
1522                 return multiply(multiplicand.intCompact, this.intVal, productScale);
1523             } else {
1524                 return multiply(this.intVal, multiplicand.intVal, productScale);
1525             }
1526         }
1527     }
1528 
1529     /**
1530      * Returns a {@code BigDecimal} whose value is &lt;code&gt;(this &amp;times;
1531      * multiplicand)&lt;/code&gt;, with rounding according to the context settings.
1532      *
1533      * @param  multiplicand value to be multiplied by this {@code BigDecimal}.
1534      * @param  mc the context to use.
1535      * @return {@code this * multiplicand}, rounded as necessary.
1536      * @throws ArithmeticException if the result is inexact but the
1537      *         rounding mode is {@code UNNECESSARY}.
1538      * @since  1.5
1539      */
1540     public BigDecimal multiply(BigDecimal multiplicand, MathContext mc) {
1541         if (mc.precision == 0)
1542             return multiply(multiplicand);
1543         int productScale = checkScale((long) scale + multiplicand.scale);
1544         if (this.intCompact != INFLATED) {
1545             if ((multiplicand.intCompact != INFLATED)) {
1546                 return multiplyAndRound(this.intCompact, multiplicand.intCompact, productScale, mc);
1547             } else {
1548                 return multiplyAndRound(this.intCompact, multiplicand.intVal, productScale, mc);
1549             }
1550         } else {
1551             if ((multiplicand.intCompact != INFLATED)) {
1552                 return multiplyAndRound(multiplicand.intCompact, this.intVal, productScale, mc);
1553             } else {
1554                 return multiplyAndRound(this.intVal, multiplicand.intVal, productScale, mc);
1555             }
1556         }
1557     }
1558 
1559     /**
1560      * Returns a {@code BigDecimal} whose value is {@code (this /
1561      * divisor)}, and whose scale is as specified.  If rounding must
1562      * be performed to generate a result with the specified scale, the
1563      * specified rounding mode is applied.
1564      *
1565      * @deprecated The method {@link #divide(BigDecimal, int, RoundingMode)}
1566      * should be used in preference to this legacy method.
1567      *
1568      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1569      * @param  scale scale of the {@code BigDecimal} quotient to be returned.
1570      * @param  roundingMode rounding mode to apply.
1571      * @return {@code this / divisor}
1572      * @throws ArithmeticException if {@code divisor} is zero,
1573      *         {@code roundingMode==ROUND_UNNECESSARY} and
1574      *         the specified scale is insufficient to represent the result
1575      *         of the division exactly.
1576      * @throws IllegalArgumentException if {@code roundingMode} does not
1577      *         represent a valid rounding mode.
1578      * @see    #ROUND_UP
1579      * @see    #ROUND_DOWN
1580      * @see    #ROUND_CEILING
1581      * @see    #ROUND_FLOOR
1582      * @see    #ROUND_HALF_UP
1583      * @see    #ROUND_HALF_DOWN
1584      * @see    #ROUND_HALF_EVEN
1585      * @see    #ROUND_UNNECESSARY
1586      */
1587     @Deprecated(since=&quot;9&quot;)
1588     public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) {
1589         if (roundingMode &lt; ROUND_UP || roundingMode &gt; ROUND_UNNECESSARY)
1590             throw new IllegalArgumentException(&quot;Invalid rounding mode&quot;);
1591         if (this.intCompact != INFLATED) {
1592             if ((divisor.intCompact != INFLATED)) {
1593                 return divide(this.intCompact, this.scale, divisor.intCompact, divisor.scale, scale, roundingMode);
1594             } else {
1595                 return divide(this.intCompact, this.scale, divisor.intVal, divisor.scale, scale, roundingMode);
1596             }
1597         } else {
1598             if ((divisor.intCompact != INFLATED)) {
1599                 return divide(this.intVal, this.scale, divisor.intCompact, divisor.scale, scale, roundingMode);
1600             } else {
1601                 return divide(this.intVal, this.scale, divisor.intVal, divisor.scale, scale, roundingMode);
1602             }
1603         }
1604     }
1605 
1606     /**
1607      * Returns a {@code BigDecimal} whose value is {@code (this /
1608      * divisor)}, and whose scale is as specified.  If rounding must
1609      * be performed to generate a result with the specified scale, the
1610      * specified rounding mode is applied.
1611      *
1612      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1613      * @param  scale scale of the {@code BigDecimal} quotient to be returned.
1614      * @param  roundingMode rounding mode to apply.
1615      * @return {@code this / divisor}
1616      * @throws ArithmeticException if {@code divisor} is zero,
1617      *         {@code roundingMode==RoundingMode.UNNECESSARY} and
1618      *         the specified scale is insufficient to represent the result
1619      *         of the division exactly.
1620      * @since 1.5
1621      */
1622     public BigDecimal divide(BigDecimal divisor, int scale, RoundingMode roundingMode) {
1623         return divide(divisor, scale, roundingMode.oldMode);
1624     }
1625 
1626     /**
1627      * Returns a {@code BigDecimal} whose value is {@code (this /
1628      * divisor)}, and whose scale is {@code this.scale()}.  If
1629      * rounding must be performed to generate a result with the given
1630      * scale, the specified rounding mode is applied.
1631      *
1632      * @deprecated The method {@link #divide(BigDecimal, RoundingMode)}
1633      * should be used in preference to this legacy method.
1634      *
1635      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1636      * @param  roundingMode rounding mode to apply.
1637      * @return {@code this / divisor}
1638      * @throws ArithmeticException if {@code divisor==0}, or
1639      *         {@code roundingMode==ROUND_UNNECESSARY} and
1640      *         {@code this.scale()} is insufficient to represent the result
1641      *         of the division exactly.
1642      * @throws IllegalArgumentException if {@code roundingMode} does not
1643      *         represent a valid rounding mode.
1644      * @see    #ROUND_UP
1645      * @see    #ROUND_DOWN
1646      * @see    #ROUND_CEILING
1647      * @see    #ROUND_FLOOR
1648      * @see    #ROUND_HALF_UP
1649      * @see    #ROUND_HALF_DOWN
1650      * @see    #ROUND_HALF_EVEN
1651      * @see    #ROUND_UNNECESSARY
1652      */
1653     @Deprecated(since=&quot;9&quot;)
1654     public BigDecimal divide(BigDecimal divisor, int roundingMode) {
1655         return this.divide(divisor, scale, roundingMode);
1656     }
1657 
1658     /**
1659      * Returns a {@code BigDecimal} whose value is {@code (this /
1660      * divisor)}, and whose scale is {@code this.scale()}.  If
1661      * rounding must be performed to generate a result with the given
1662      * scale, the specified rounding mode is applied.
1663      *
1664      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1665      * @param  roundingMode rounding mode to apply.
1666      * @return {@code this / divisor}
1667      * @throws ArithmeticException if {@code divisor==0}, or
1668      *         {@code roundingMode==RoundingMode.UNNECESSARY} and
1669      *         {@code this.scale()} is insufficient to represent the result
1670      *         of the division exactly.
1671      * @since 1.5
1672      */
1673     public BigDecimal divide(BigDecimal divisor, RoundingMode roundingMode) {
1674         return this.divide(divisor, scale, roundingMode.oldMode);
1675     }
1676 
1677     /**
1678      * Returns a {@code BigDecimal} whose value is {@code (this /
1679      * divisor)}, and whose preferred scale is {@code (this.scale() -
1680      * divisor.scale())}; if the exact quotient cannot be
1681      * represented (because it has a non-terminating decimal
1682      * expansion) an {@code ArithmeticException} is thrown.
1683      *
1684      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1685      * @throws ArithmeticException if the exact quotient does not have a
1686      *         terminating decimal expansion
1687      * @return {@code this / divisor}
1688      * @since 1.5
1689      * @author Joseph D. Darcy
1690      */
1691     public BigDecimal divide(BigDecimal divisor) {
1692         /*
1693          * Handle zero cases first.
1694          */
1695         if (divisor.signum() == 0) {   // x/0
1696             if (this.signum() == 0)    // 0/0
1697                 throw new ArithmeticException(&quot;Division undefined&quot;);  // NaN
1698             throw new ArithmeticException(&quot;Division by zero&quot;);
1699         }
1700 
1701         // Calculate preferred scale
1702         int preferredScale = saturateLong((long) this.scale - divisor.scale);
1703 
1704         if (this.signum() == 0) // 0/y
1705             return zeroValueOf(preferredScale);
1706         else {
1707             /*
1708              * If the quotient this/divisor has a terminating decimal
1709              * expansion, the expansion can have no more than
1710              * (a.precision() + ceil(10*b.precision)/3) digits.
1711              * Therefore, create a MathContext object with this
1712              * precision and do a divide with the UNNECESSARY rounding
1713              * mode.
1714              */
1715             MathContext mc = new MathContext( (int)Math.min(this.precision() +
1716                                                             (long)Math.ceil(10.0*divisor.precision()/3.0),
1717                                                             Integer.MAX_VALUE),
1718                                               RoundingMode.UNNECESSARY);
1719             BigDecimal quotient;
1720             try {
1721                 quotient = this.divide(divisor, mc);
1722             } catch (ArithmeticException e) {
1723                 throw new ArithmeticException(&quot;Non-terminating decimal expansion; &quot; +
1724                                               &quot;no exact representable decimal result.&quot;);
1725             }
1726 
1727             int quotientScale = quotient.scale();
1728 
1729             // divide(BigDecimal, mc) tries to adjust the quotient to
1730             // the desired one by removing trailing zeros; since the
1731             // exact divide method does not have an explicit digit
1732             // limit, we can add zeros too.
1733             if (preferredScale &gt; quotientScale)
1734                 return quotient.setScale(preferredScale, ROUND_UNNECESSARY);
1735 
1736             return quotient;
1737         }
1738     }
1739 
1740     /**
1741      * Returns a {@code BigDecimal} whose value is {@code (this /
1742      * divisor)}, with rounding according to the context settings.
1743      *
1744      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1745      * @param  mc the context to use.
1746      * @return {@code this / divisor}, rounded as necessary.
1747      * @throws ArithmeticException if the result is inexact but the
1748      *         rounding mode is {@code UNNECESSARY} or
1749      *         {@code mc.precision == 0} and the quotient has a
1750      *         non-terminating decimal expansion.
1751      * @since  1.5
1752      */
1753     public BigDecimal divide(BigDecimal divisor, MathContext mc) {
1754         int mcp = mc.precision;
1755         if (mcp == 0)
1756             return divide(divisor);
1757 
1758         BigDecimal dividend = this;
1759         long preferredScale = (long)dividend.scale - divisor.scale;
1760         // Now calculate the answer.  We use the existing
1761         // divide-and-round method, but as this rounds to scale we have
1762         // to normalize the values here to achieve the desired result.
1763         // For x/y we first handle y=0 and x=0, and then normalize x and
1764         // y to give x&#39; and y&#39; with the following constraints:
1765         //   (a) 0.1 &lt;= x&#39; &lt; 1
1766         //   (b)  x&#39; &lt;= y&#39; &lt; 10*x&#39;
1767         // Dividing x&#39;/y&#39; with the required scale set to mc.precision then
1768         // will give a result in the range 0.1 to 1 rounded to exactly
1769         // the right number of digits (except in the case of a result of
1770         // 1.000... which can arise when x=y, or when rounding overflows
1771         // The 1.000... case will reduce properly to 1.
1772         if (divisor.signum() == 0) {      // x/0
1773             if (dividend.signum() == 0)    // 0/0
1774                 throw new ArithmeticException(&quot;Division undefined&quot;);  // NaN
1775             throw new ArithmeticException(&quot;Division by zero&quot;);
1776         }
1777         if (dividend.signum() == 0) // 0/y
1778             return zeroValueOf(saturateLong(preferredScale));
1779         int xscale = dividend.precision();
1780         int yscale = divisor.precision();
1781         if(dividend.intCompact!=INFLATED) {
1782             if(divisor.intCompact!=INFLATED) {
1783                 return divide(dividend.intCompact, xscale, divisor.intCompact, yscale, preferredScale, mc);
1784             } else {
1785                 return divide(dividend.intCompact, xscale, divisor.intVal, yscale, preferredScale, mc);
1786             }
1787         } else {
1788             if(divisor.intCompact!=INFLATED) {
1789                 return divide(dividend.intVal, xscale, divisor.intCompact, yscale, preferredScale, mc);
1790             } else {
1791                 return divide(dividend.intVal, xscale, divisor.intVal, yscale, preferredScale, mc);
1792             }
1793         }
1794     }
1795 
1796     /**
1797      * Returns a {@code BigDecimal} whose value is the integer part
1798      * of the quotient {@code (this / divisor)} rounded down.  The
1799      * preferred scale of the result is {@code (this.scale() -
1800      * divisor.scale())}.
1801      *
1802      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1803      * @return The integer part of {@code this / divisor}.
1804      * @throws ArithmeticException if {@code divisor==0}
1805      * @since  1.5
1806      */
1807     public BigDecimal divideToIntegralValue(BigDecimal divisor) {
1808         // Calculate preferred scale
1809         int preferredScale = saturateLong((long) this.scale - divisor.scale);
1810         if (this.compareMagnitude(divisor) &lt; 0) {
1811             // much faster when this &lt;&lt; divisor
1812             return zeroValueOf(preferredScale);
1813         }
1814 
1815         if (this.signum() == 0 &amp;&amp; divisor.signum() != 0)
1816             return this.setScale(preferredScale, ROUND_UNNECESSARY);
1817 
1818         // Perform a divide with enough digits to round to a correct
1819         // integer value; then remove any fractional digits
1820 
1821         int maxDigits = (int)Math.min(this.precision() +
1822                                       (long)Math.ceil(10.0*divisor.precision()/3.0) +
1823                                       Math.abs((long)this.scale() - divisor.scale()) + 2,
1824                                       Integer.MAX_VALUE);
1825         BigDecimal quotient = this.divide(divisor, new MathContext(maxDigits,
1826                                                                    RoundingMode.DOWN));
1827         if (quotient.scale &gt; 0) {
1828             quotient = quotient.setScale(0, RoundingMode.DOWN);
1829             quotient = stripZerosToMatchScale(quotient.intVal, quotient.intCompact, quotient.scale, preferredScale);
1830         }
1831 
1832         if (quotient.scale &lt; preferredScale) {
1833             // pad with zeros if necessary
1834             quotient = quotient.setScale(preferredScale, ROUND_UNNECESSARY);
1835         }
1836 
1837         return quotient;
1838     }
1839 
1840     /**
1841      * Returns a {@code BigDecimal} whose value is the integer part
1842      * of {@code (this / divisor)}.  Since the integer part of the
1843      * exact quotient does not depend on the rounding mode, the
1844      * rounding mode does not affect the values returned by this
1845      * method.  The preferred scale of the result is
1846      * {@code (this.scale() - divisor.scale())}.  An
1847      * {@code ArithmeticException} is thrown if the integer part of
1848      * the exact quotient needs more than {@code mc.precision}
1849      * digits.
1850      *
1851      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1852      * @param  mc the context to use.
1853      * @return The integer part of {@code this / divisor}.
1854      * @throws ArithmeticException if {@code divisor==0}
1855      * @throws ArithmeticException if {@code mc.precision} {@literal &gt;} 0 and the result
1856      *         requires a precision of more than {@code mc.precision} digits.
1857      * @since  1.5
1858      * @author Joseph D. Darcy
1859      */
1860     public BigDecimal divideToIntegralValue(BigDecimal divisor, MathContext mc) {
1861         if (mc.precision == 0 || // exact result
1862             (this.compareMagnitude(divisor) &lt; 0)) // zero result
1863             return divideToIntegralValue(divisor);
1864 
1865         // Calculate preferred scale
1866         int preferredScale = saturateLong((long)this.scale - divisor.scale);
1867 
1868         /*
1869          * Perform a normal divide to mc.precision digits.  If the
1870          * remainder has absolute value less than the divisor, the
1871          * integer portion of the quotient fits into mc.precision
1872          * digits.  Next, remove any fractional digits from the
1873          * quotient and adjust the scale to the preferred value.
1874          */
1875         BigDecimal result = this.divide(divisor, new MathContext(mc.precision, RoundingMode.DOWN));
1876 
1877         if (result.scale() &lt; 0) {
1878             /*
1879              * Result is an integer. See if quotient represents the
1880              * full integer portion of the exact quotient; if it does,
1881              * the computed remainder will be less than the divisor.
1882              */
1883             BigDecimal product = result.multiply(divisor);
1884             // If the quotient is the full integer value,
1885             // |dividend-product| &lt; |divisor|.
1886             if (this.subtract(product).compareMagnitude(divisor) &gt;= 0) {
1887                 throw new ArithmeticException(&quot;Division impossible&quot;);
1888             }
1889         } else if (result.scale() &gt; 0) {
1890             /*
1891              * Integer portion of quotient will fit into precision
1892              * digits; recompute quotient to scale 0 to avoid double
1893              * rounding and then try to adjust, if necessary.
1894              */
1895             result = result.setScale(0, RoundingMode.DOWN);
1896         }
1897         // else result.scale() == 0;
1898 
1899         int precisionDiff;
1900         if ((preferredScale &gt; result.scale()) &amp;&amp;
1901             (precisionDiff = mc.precision - result.precision()) &gt; 0) {
1902             return result.setScale(result.scale() +
1903                                    Math.min(precisionDiff, preferredScale - result.scale) );
1904         } else {
1905             return stripZerosToMatchScale(result.intVal,result.intCompact,result.scale,preferredScale);
1906         }
1907     }
1908 
1909     /**
1910      * Returns a {@code BigDecimal} whose value is {@code (this % divisor)}.
1911      *
1912      * &lt;p&gt;The remainder is given by
1913      * {@code this.subtract(this.divideToIntegralValue(divisor).multiply(divisor))}.
1914      * Note that this is &lt;em&gt;not&lt;/em&gt; the modulo operation (the result can be
1915      * negative).
1916      *
1917      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1918      * @return {@code this % divisor}.
1919      * @throws ArithmeticException if {@code divisor==0}
1920      * @since  1.5
1921      */
1922     public BigDecimal remainder(BigDecimal divisor) {
1923         BigDecimal divrem[] = this.divideAndRemainder(divisor);
1924         return divrem[1];
1925     }
1926 
1927 
1928     /**
1929      * Returns a {@code BigDecimal} whose value is {@code (this %
1930      * divisor)}, with rounding according to the context settings.
1931      * The {@code MathContext} settings affect the implicit divide
1932      * used to compute the remainder.  The remainder computation
1933      * itself is by definition exact.  Therefore, the remainder may
1934      * contain more than {@code mc.getPrecision()} digits.
1935      *
1936      * &lt;p&gt;The remainder is given by
1937      * {@code this.subtract(this.divideToIntegralValue(divisor,
1938      * mc).multiply(divisor))}.  Note that this is not the modulo
1939      * operation (the result can be negative).
1940      *
1941      * @param  divisor value by which this {@code BigDecimal} is to be divided.
1942      * @param  mc the context to use.
1943      * @return {@code this % divisor}, rounded as necessary.
1944      * @throws ArithmeticException if {@code divisor==0}
1945      * @throws ArithmeticException if the result is inexact but the
1946      *         rounding mode is {@code UNNECESSARY}, or {@code mc.precision}
1947      *         {@literal &gt;} 0 and the result of {@code this.divideToIntgralValue(divisor)} would
1948      *         require a precision of more than {@code mc.precision} digits.
1949      * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
1950      * @since  1.5
1951      */
1952     public BigDecimal remainder(BigDecimal divisor, MathContext mc) {
1953         BigDecimal divrem[] = this.divideAndRemainder(divisor, mc);
1954         return divrem[1];
1955     }
1956 
1957     /**
1958      * Returns a two-element {@code BigDecimal} array containing the
1959      * result of {@code divideToIntegralValue} followed by the result of
1960      * {@code remainder} on the two operands.
1961      *
1962      * &lt;p&gt;Note that if both the integer quotient and remainder are
1963      * needed, this method is faster than using the
1964      * {@code divideToIntegralValue} and {@code remainder} methods
1965      * separately because the division need only be carried out once.
1966      *
1967      * @param  divisor value by which this {@code BigDecimal} is to be divided,
1968      *         and the remainder computed.
1969      * @return a two element {@code BigDecimal} array: the quotient
1970      *         (the result of {@code divideToIntegralValue}) is the initial element
1971      *         and the remainder is the final element.
1972      * @throws ArithmeticException if {@code divisor==0}
1973      * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
1974      * @see    #remainder(java.math.BigDecimal, java.math.MathContext)
1975      * @since  1.5
1976      */
1977     public BigDecimal[] divideAndRemainder(BigDecimal divisor) {
1978         // we use the identity  x = i * y + r to determine r
1979         BigDecimal[] result = new BigDecimal[2];
1980 
1981         result[0] = this.divideToIntegralValue(divisor);
1982         result[1] = this.subtract(result[0].multiply(divisor));
1983         return result;
1984     }
1985 
1986     /**
1987      * Returns a two-element {@code BigDecimal} array containing the
1988      * result of {@code divideToIntegralValue} followed by the result of
1989      * {@code remainder} on the two operands calculated with rounding
1990      * according to the context settings.
1991      *
1992      * &lt;p&gt;Note that if both the integer quotient and remainder are
1993      * needed, this method is faster than using the
1994      * {@code divideToIntegralValue} and {@code remainder} methods
1995      * separately because the division need only be carried out once.
1996      *
1997      * @param  divisor value by which this {@code BigDecimal} is to be divided,
1998      *         and the remainder computed.
1999      * @param  mc the context to use.
2000      * @return a two element {@code BigDecimal} array: the quotient
2001      *         (the result of {@code divideToIntegralValue}) is the
2002      *         initial element and the remainder is the final element.
2003      * @throws ArithmeticException if {@code divisor==0}
2004      * @throws ArithmeticException if the result is inexact but the
2005      *         rounding mode is {@code UNNECESSARY}, or {@code mc.precision}
2006      *         {@literal &gt;} 0 and the result of {@code this.divideToIntgralValue(divisor)} would
2007      *         require a precision of more than {@code mc.precision} digits.
2008      * @see    #divideToIntegralValue(java.math.BigDecimal, java.math.MathContext)
2009      * @see    #remainder(java.math.BigDecimal, java.math.MathContext)
2010      * @since  1.5
2011      */
2012     public BigDecimal[] divideAndRemainder(BigDecimal divisor, MathContext mc) {
2013         if (mc.precision == 0)
2014             return divideAndRemainder(divisor);
2015 
2016         BigDecimal[] result = new BigDecimal[2];
2017         BigDecimal lhs = this;
2018 
2019         result[0] = lhs.divideToIntegralValue(divisor, mc);
2020         result[1] = lhs.subtract(result[0].multiply(divisor));
2021         return result;
2022     }
2023 
2024     /**
2025      * Returns an approximation to the square root of {@code this}
2026      * with rounding according to the context settings.
2027      *
2028      * &lt;p&gt;The preferred scale of the returned result is equal to
2029      * {@code this.scale()/2}. The value of the returned result is
2030      * always within one ulp of the exact decimal value for the
2031      * precision in question.  If the rounding mode is {@link
2032      * RoundingMode#HALF_UP HALF_UP}, {@link RoundingMode#HALF_DOWN
2033      * HALF_DOWN}, or {@link RoundingMode#HALF_EVEN HALF_EVEN}, the
2034      * result is within one half an ulp of the exact decimal value.
2035      *
2036      * &lt;p&gt;Special case:
2037      * &lt;ul&gt;
2038      * &lt;li&gt; The square root of a number numerically equal to {@code
2039      * ZERO} is numerically equal to {@code ZERO} with a preferred
2040      * scale according to the general rule above. In particular, for
2041      * {@code ZERO}, {@code ZERO.sqrt(mc).equals(ZERO)} is true with
2042      * any {@code MathContext} as an argument.
2043      * &lt;/ul&gt;
2044      *
2045      * @param mc the context to use.
2046      * @return the square root of {@code this}.
2047      * @throws ArithmeticException if {@code this} is less than zero.
2048      * @throws ArithmeticException if an exact result is requested
2049      * ({@code mc.getPrecision()==0}) and there is no finite decimal
2050      * expansion of the exact result
2051      * @throws ArithmeticException if
2052      * {@code (mc.getRoundingMode()==RoundingMode.UNNECESSARY}) and
2053      * the exact result cannot fit in {@code mc.getPrecision()}
2054      * digits.
2055      * @see BigInteger#sqrt()
2056      * @since  9
2057      */
2058     public BigDecimal sqrt(MathContext mc) {
2059         int signum = signum();
2060         if (signum == 1) {
2061             /*
2062              * The following code draws on the algorithm presented in
2063              * &quot;Properly Rounded Variable Precision Square Root,&quot; Hull and
2064              * Abrham, ACM Transactions on Mathematical Software, Vol 11,
2065              * No. 3, September 1985, Pages 229-237.
2066              *
2067              * The BigDecimal computational model differs from the one
2068              * presented in the paper in several ways: first BigDecimal
2069              * numbers aren&#39;t necessarily normalized, second many more
2070              * rounding modes are supported, including UNNECESSARY, and
2071              * exact results can be requested.
2072              *
2073              * The main steps of the algorithm below are as follows,
2074              * first argument reduce the value to the numerical range
2075              * [1, 10) using the following relations:
2076              *
2077              * x = y * 10 ^ exp
2078              * sqrt(x) = sqrt(y) * 10^(exp / 2) if exp is even
2079              * sqrt(x) = sqrt(y/10) * 10 ^((exp+1)/2) is exp is odd
2080              *
2081              * Then use Newton&#39;s iteration on the reduced value to compute
2082              * the numerical digits of the desired result.
2083              *
2084              * Finally, scale back to the desired exponent range and
2085              * perform any adjustment to get the preferred scale in the
2086              * representation.
2087              */
2088 
2089             // The code below favors relative simplicity over checking
2090             // for special cases that could run faster.
2091 
2092             int preferredScale = this.scale()/2;
2093             BigDecimal zeroWithFinalPreferredScale = valueOf(0L, preferredScale);
2094 
2095             // First phase of numerical normalization, strip trailing
2096             // zeros and check for even powers of 10.
2097             BigDecimal stripped = this.stripTrailingZeros();
2098             int strippedScale = stripped.scale();
2099 
2100             // Numerically sqrt(10^2N) = 10^N
2101             if (stripped.isPowerOfTen() &amp;&amp;
2102                 strippedScale % 2 == 0) {
2103                 BigDecimal result = valueOf(1L, strippedScale/2);
2104                 if (result.scale() != preferredScale) {
2105                     // Adjust to requested precision and preferred
2106                     // scale as appropriate.
2107                     result = result.add(zeroWithFinalPreferredScale, mc);
2108                 }
2109                 return result;
2110             }
2111 
2112             // After stripTrailingZeros, the representation is normalized as
2113             //
2114             // unscaledValue * 10^(-scale)
2115             //
2116             // where unscaledValue is an integer with the mimimum
2117             // precision for the cohort of the numerical value. To
2118             // allow binary floating-point hardware to be used to get
2119             // approximately a 15 digit approximation to the square
2120             // root, it is helpful to instead normalize this so that
2121             // the significand portion is to right of the decimal
2122             // point by roughly (scale() - precision() + 1).
2123 
2124             // Now the precision / scale adjustment
2125             int scaleAdjust = 0;
2126             int scale = stripped.scale() - stripped.precision() + 1;
2127             if (scale % 2 == 0) {
2128                 scaleAdjust = scale;
2129             } else {
2130                 scaleAdjust = scale - 1;
2131             }
2132 
2133             BigDecimal working = stripped.scaleByPowerOfTen(scaleAdjust);
2134 
2135             assert  // Verify 0.1 &lt;= working &lt; 10
2136                 ONE_TENTH.compareTo(working) &lt;= 0 &amp;&amp; working.compareTo(TEN) &lt; 0;
2137 
2138             // Use good ole&#39; Math.sqrt to get the initial guess for
2139             // the Newton iteration, good to at least 15 decimal
2140             // digits. This approach does incur the cost of a
2141             //
2142             // BigDecimal -&gt; double -&gt; BigDecimal
2143             //
2144             // conversion cycle, but it avoids the need for several
2145             // Newton iterations in BigDecimal arithmetic to get the
2146             // working answer to 15 digits of precision. If many fewer
2147             // than 15 digits were needed, it might be faster to do
2148             // the loop entirely in BigDecimal arithmetic.
2149             //
2150             // (A double value might have as many as 17 decimal
2151             // digits of precision; it depends on the relative density
2152             // of binary and decimal numbers at different regions of
2153             // the number line.)
2154             //
2155             // (It would be possible to check for certain special
2156             // cases to avoid doing any Newton iterations. For
2157             // example, if the BigDecimal -&gt; double conversion was
2158             // known to be exact and the rounding mode had a
2159             // low-enough precision, the post-Newton rounding logic
2160             // could be applied directly.)
2161 
2162             BigDecimal guess = new BigDecimal(Math.sqrt(working.doubleValue()));
2163             int guessPrecision = 15;
2164             int originalPrecision = mc.getPrecision();
2165             int targetPrecision;
2166 
2167             // If an exact value is requested, it must only need about
2168             // half of the input digits to represent since multiplying
2169             // an N digit number by itself yield a 2N-1 digit or 2N
2170             // digit result.
2171             if (originalPrecision == 0) {
2172                 targetPrecision = stripped.precision()/2 + 1;
2173             } else {
2174                 /*
2175                  * To avoid the need for post-Newton fix-up logic, in
2176                  * the case of half-way rounding modes, double the
2177                  * target precision so that the &quot;2p + 2&quot; property can
2178                  * be relied on to accomplish the final rounding.
2179                  */
2180                 switch (mc.getRoundingMode()) {
2181                 case HALF_UP:
2182                 case HALF_DOWN:
2183                 case HALF_EVEN:
2184                     targetPrecision = 2 * originalPrecision;
2185                     if (targetPrecision &lt; 0) // Overflow
2186                         targetPrecision = Integer.MAX_VALUE - 2;
2187                     break;
2188 
2189                 default:
2190                     targetPrecision = originalPrecision;
2191                     break;
2192                 }
2193             }
2194 
2195             // When setting the precision to use inside the Newton
2196             // iteration loop, take care to avoid the case where the
2197             // precision of the input exceeds the requested precision
2198             // and rounding the input value too soon.
2199             BigDecimal approx = guess;
2200             int workingPrecision = working.precision();
2201             do {
2202                 int tmpPrecision = Math.max(Math.max(guessPrecision, targetPrecision + 2),
2203                                            workingPrecision);
2204                 MathContext mcTmp = new MathContext(tmpPrecision, RoundingMode.HALF_EVEN);
2205                 // approx = 0.5 * (approx + fraction / approx)
2206                 approx = ONE_HALF.multiply(approx.add(working.divide(approx, mcTmp), mcTmp));
2207                 guessPrecision *= 2;
2208             } while (guessPrecision &lt; targetPrecision + 2);
2209 
2210             BigDecimal result;
2211             RoundingMode targetRm = mc.getRoundingMode();
2212             if (targetRm == RoundingMode.UNNECESSARY || originalPrecision == 0) {
2213                 RoundingMode tmpRm =
2214                     (targetRm == RoundingMode.UNNECESSARY) ? RoundingMode.DOWN : targetRm;
2215                 MathContext mcTmp = new MathContext(targetPrecision, tmpRm);
2216                 result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mcTmp);
2217 
2218                 // If result*result != this numerically, the square
2219                 // root isn&#39;t exact
2220                 if (this.subtract(result.square()).compareTo(ZERO) != 0) {
2221                     throw new ArithmeticException(&quot;Computed square root not exact.&quot;);
2222                 }
2223             } else {
2224                 result = approx.scaleByPowerOfTen(-scaleAdjust/2).round(mc);
2225 
2226                 switch (targetRm) {
2227                 case DOWN:
2228                 case FLOOR:
2229                     // Check if too big
2230                     if (result.square().compareTo(this) &gt; 0) {
2231                         BigDecimal ulp = result.ulp();
2232                         // Adjust increment down in case of 1.0 = 10^0
2233                         // since the next smaller number is only 1/10
2234                         // as far way as the next larger at exponent
2235                         // boundaries. Test approx and *not* result to
2236                         // avoid having to detect an arbitrary power
2237                         // of ten.
2238                         if (approx.compareTo(ONE) == 0) {
2239                             ulp = ulp.multiply(ONE_TENTH);
2240                         }
2241                         result = result.subtract(ulp);
2242                     }
2243                     break;
2244 
2245                 case UP:
2246                 case CEILING:
2247                     // Check if too small
2248                     if (result.square().compareTo(this) &lt; 0) {
2249                         result = result.add(result.ulp());
2250                     }
2251                     break;
2252 
2253                 default:
2254                     // No additional work, rely on &quot;2p + 2&quot; property
2255                     // for correct rounding. Alternatively, could
2256                     // instead run the Newton iteration to around p
2257                     // digits and then do tests and fix-ups on the
2258                     // rounded value. One possible set of tests and
2259                     // fix-ups is given in the Hull and Abrham paper;
2260                     // however, additional half-way cases can occur
2261                     // for BigDecimal given the more varied
2262                     // combinations of input and output precisions
2263                     // supported.
2264                     break;
2265                 }
2266 
2267             }
2268 
2269             // Test numerical properties at full precision before any
2270             // scale adjustments.
2271             assert squareRootResultAssertions(result, mc);
2272             if (result.scale() != preferredScale) {
2273                 // The preferred scale of an add is
2274                 // max(addend.scale(), augend.scale()). Therefore, if
2275                 // the scale of the result is first minimized using
2276                 // stripTrailingZeros(), adding a zero of the
2277                 // preferred scale rounding to the correct precision
2278                 // will perform the proper scale vs precision
2279                 // tradeoffs.
2280                 result = result.stripTrailingZeros().
2281                     add(zeroWithFinalPreferredScale,
2282                         new MathContext(originalPrecision, RoundingMode.UNNECESSARY));
2283             }
2284             return result;
2285         } else {
2286             BigDecimal result = null;
2287             switch (signum) {
2288             case -1:
2289                 throw new ArithmeticException(&quot;Attempted square root &quot; +
2290                                               &quot;of negative BigDecimal&quot;);
2291             case 0:
2292                 result = valueOf(0L, scale()/2);
2293                 assert squareRootResultAssertions(result, mc);
2294                 return result;
2295 
2296             default:
2297                 throw new AssertionError(&quot;Bad value from signum&quot;);
2298             }
2299         }
2300     }
2301 
2302     private BigDecimal square() {
2303         return this.multiply(this);
2304     }
2305 
2306     private boolean isPowerOfTen() {
2307         return BigInteger.ONE.equals(this.unscaledValue());
2308     }
2309 
2310     /**
2311      * For nonzero values, check numerical correctness properties of
2312      * the computed result for the chosen rounding mode.
2313      *
2314      * For the directed rounding modes:
2315      *
2316      * &lt;ul&gt;
2317      *
2318      * &lt;li&gt; For DOWN and FLOOR, result^2 must be {@code &lt;=} the input
2319      * and (result+ulp)^2 must be {@code &gt;} the input.
2320      *
2321      * &lt;li&gt;Conversely, for UP and CEIL, result^2 must be {@code &gt;=}
2322      * the input and (result-ulp)^2 must be {@code &lt;} the input.
2323      * &lt;/ul&gt;
2324      */
2325     private boolean squareRootResultAssertions(BigDecimal result, MathContext mc) {
2326         if (result.signum() == 0) {
2327             return squareRootZeroResultAssertions(result, mc);
2328         } else {
2329             RoundingMode rm = mc.getRoundingMode();
2330             BigDecimal ulp = result.ulp();
2331             BigDecimal neighborUp   = result.add(ulp);
2332             // Make neighbor down accurate even for powers of ten
2333             if (result.isPowerOfTen()) {
2334                 ulp = ulp.divide(TEN);
2335             }
2336             BigDecimal neighborDown = result.subtract(ulp);
2337 
2338             // Both the starting value and result should be nonzero and positive.
2339             assert (result.signum() == 1 &amp;&amp;
2340                     this.signum() == 1) :
2341                 &quot;Bad signum of this and/or its sqrt.&quot;;
2342 
2343             switch (rm) {
2344             case DOWN:
2345             case FLOOR:
2346                 assert
2347                     result.square().compareTo(this)     &lt;= 0 &amp;&amp;
2348                     neighborUp.square().compareTo(this) &gt; 0:
2349                 &quot;Square of result out for bounds rounding &quot; + rm;
2350                 return true;
2351 
2352             case UP:
2353             case CEILING:
2354                 assert
2355                     result.square().compareTo(this)       &gt;= 0 &amp;&amp;
2356                     neighborDown.square().compareTo(this) &lt; 0:
2357                 &quot;Square of result out for bounds rounding &quot; + rm;
2358                 return true;
2359 
2360 
2361             case HALF_DOWN:
2362             case HALF_EVEN:
2363             case HALF_UP:
2364                 BigDecimal err = result.square().subtract(this).abs();
2365                 BigDecimal errUp = neighborUp.square().subtract(this);
2366                 BigDecimal errDown =  this.subtract(neighborDown.square());
2367                 // All error values should be positive so don&#39;t need to
2368                 // compare absolute values.
2369 
2370                 int err_comp_errUp = err.compareTo(errUp);
2371                 int err_comp_errDown = err.compareTo(errDown);
2372 
2373                 assert
2374                     errUp.signum()   == 1 &amp;&amp;
2375                     errDown.signum() == 1 :
2376                 &quot;Errors of neighbors squared don&#39;t have correct signs&quot;;
2377 
2378                 // For breaking a half-way tie, the return value may
2379                 // have a larger error than one of the neighbors. For
2380                 // example, the square root of 2.25 to a precision of
2381                 // 1 digit is either 1 or 2 depending on how the exact
2382                 // value of 1.5 is rounded. If 2 is returned, it will
2383                 // have a larger rounding error than its neighbor 1.
2384                 assert
2385                     err_comp_errUp   &lt;= 0 ||
2386                     err_comp_errDown &lt;= 0 :
2387                 &quot;Computed square root has larger error than neighbors for &quot; + rm;
2388 
2389                 assert
2390                     ((err_comp_errUp   == 0 ) ? err_comp_errDown &lt; 0 : true) &amp;&amp;
2391                     ((err_comp_errDown == 0 ) ? err_comp_errUp   &lt; 0 : true) :
2392                         &quot;Incorrect error relationships&quot;;
2393                 // &amp;&amp; could check for digit conditions for ties too
2394                 return true;
2395 
2396             default: // Definition of UNNECESSARY already verified.
2397                 return true;
2398             }
2399         }
2400     }
2401 
2402     private boolean squareRootZeroResultAssertions(BigDecimal result, MathContext mc) {
2403         return this.compareTo(ZERO) == 0;
2404     }
2405 
2406     /**
2407      * Returns a {@code BigDecimal} whose value is
2408      * &lt;code&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;, The power is computed exactly, to
2409      * unlimited precision.
2410      *
2411      * &lt;p&gt;The parameter {@code n} must be in the range 0 through
2412      * 999999999, inclusive.  {@code ZERO.pow(0)} returns {@link
2413      * #ONE}.
2414      *
2415      * Note that future releases may expand the allowable exponent
2416      * range of this method.
2417      *
2418      * @param  n power to raise this {@code BigDecimal} to.
2419      * @return &lt;code&gt;this&lt;sup&gt;n&lt;/sup&gt;&lt;/code&gt;
2420      * @throws ArithmeticException if {@code n} is out of range.
2421      * @since  1.5
2422      */
2423     public BigDecimal pow(int n) {
2424         if (n &lt; 0 || n &gt; 999999999)
2425             throw new ArithmeticException(&quot;Invalid operation&quot;);
2426         // No need to calculate pow(n) if result will over/underflow.
2427         // Don&#39;t attempt to support &quot;supernormal&quot; numbers.
2428         int newScale = checkScale((long)scale * n);
2429         return new BigDecimal(this.inflated().pow(n), newScale);
2430     }
2431 
2432 
2433     /**
2434      * Returns a {@code BigDecimal} whose value is
2435      * &lt;code&gt;(this&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt;.  The current implementation uses
2436      * the core algorithm defined in ANSI standard X3.274-1996 with
2437      * rounding according to the context settings.  In general, the
2438      * returned numerical value is within two ulps of the exact
2439      * numerical value for the chosen precision.  Note that future
2440      * releases may use a different algorithm with a decreased
2441      * allowable error bound and increased allowable exponent range.
2442      *
2443      * &lt;p&gt;The X3.274-1996 algorithm is:
2444      *
2445      * &lt;ul&gt;
2446      * &lt;li&gt; An {@code ArithmeticException} exception is thrown if
2447      *  &lt;ul&gt;
2448      *    &lt;li&gt;{@code abs(n) &gt; 999999999}
2449      *    &lt;li&gt;{@code mc.precision == 0} and {@code n &lt; 0}
2450      *    &lt;li&gt;{@code mc.precision &gt; 0} and {@code n} has more than
2451      *    {@code mc.precision} decimal digits
2452      *  &lt;/ul&gt;
2453      *
2454      * &lt;li&gt; if {@code n} is zero, {@link #ONE} is returned even if
2455      * {@code this} is zero, otherwise
2456      * &lt;ul&gt;
2457      *   &lt;li&gt; if {@code n} is positive, the result is calculated via
2458      *   the repeated squaring technique into a single accumulator.
2459      *   The individual multiplications with the accumulator use the
2460      *   same math context settings as in {@code mc} except for a
2461      *   precision increased to {@code mc.precision + elength + 1}
2462      *   where {@code elength} is the number of decimal digits in
2463      *   {@code n}.
2464      *
2465      *   &lt;li&gt; if {@code n} is negative, the result is calculated as if
2466      *   {@code n} were positive; this value is then divided into one
2467      *   using the working precision specified above.
2468      *
2469      *   &lt;li&gt; The final value from either the positive or negative case
2470      *   is then rounded to the destination precision.
2471      *   &lt;/ul&gt;
2472      * &lt;/ul&gt;
2473      *
2474      * @param  n power to raise this {@code BigDecimal} to.
2475      * @param  mc the context to use.
2476      * @return &lt;code&gt;this&lt;sup&gt;n&lt;/sup&gt;&lt;/code&gt; using the ANSI standard X3.274-1996
2477      *         algorithm
2478      * @throws ArithmeticException if the result is inexact but the
2479      *         rounding mode is {@code UNNECESSARY}, or {@code n} is out
2480      *         of range.
2481      * @since  1.5
2482      */
2483     public BigDecimal pow(int n, MathContext mc) {
2484         if (mc.precision == 0)
2485             return pow(n);
2486         if (n &lt; -999999999 || n &gt; 999999999)
2487             throw new ArithmeticException(&quot;Invalid operation&quot;);
2488         if (n == 0)
2489             return ONE;                      // x**0 == 1 in X3.274
2490         BigDecimal lhs = this;
2491         MathContext workmc = mc;           // working settings
2492         int mag = Math.abs(n);               // magnitude of n
2493         if (mc.precision &gt; 0) {
2494             int elength = longDigitLength(mag); // length of n in digits
2495             if (elength &gt; mc.precision)        // X3.274 rule
2496                 throw new ArithmeticException(&quot;Invalid operation&quot;);
2497             workmc = new MathContext(mc.precision + elength + 1,
2498                                       mc.roundingMode);
2499         }
2500         // ready to carry out power calculation...
2501         BigDecimal acc = ONE;           // accumulator
2502         boolean seenbit = false;        // set once we&#39;ve seen a 1-bit
2503         for (int i=1;;i++) {            // for each bit [top bit ignored]
2504             mag += mag;                 // shift left 1 bit
2505             if (mag &lt; 0) {              // top bit is set
2506                 seenbit = true;         // OK, we&#39;re off
2507                 acc = acc.multiply(lhs, workmc); // acc=acc*x
2508             }
2509             if (i == 31)
2510                 break;                  // that was the last bit
2511             if (seenbit)
2512                 acc=acc.multiply(acc, workmc);   // acc=acc*acc [square]
2513                 // else (!seenbit) no point in squaring ONE
2514         }
2515         // if negative n, calculate the reciprocal using working precision
2516         if (n &lt; 0) // [hence mc.precision&gt;0]
2517             acc=ONE.divide(acc, workmc);
2518         // round to final precision and strip zeros
2519         return doRound(acc, mc);
2520     }
2521 
2522     /**
2523      * Returns a {@code BigDecimal} whose value is the absolute value
2524      * of this {@code BigDecimal}, and whose scale is
2525      * {@code this.scale()}.
2526      *
2527      * @return {@code abs(this)}
2528      */
2529     public BigDecimal abs() {
2530         return (signum() &lt; 0 ? negate() : this);
2531     }
2532 
2533     /**
2534      * Returns a {@code BigDecimal} whose value is the absolute value
2535      * of this {@code BigDecimal}, with rounding according to the
2536      * context settings.
2537      *
2538      * @param mc the context to use.
2539      * @return {@code abs(this)}, rounded as necessary.
2540      * @throws ArithmeticException if the result is inexact but the
2541      *         rounding mode is {@code UNNECESSARY}.
2542      * @since 1.5
2543      */
2544     public BigDecimal abs(MathContext mc) {
2545         return (signum() &lt; 0 ? negate(mc) : plus(mc));
2546     }
2547 
2548     /**
2549      * Returns a {@code BigDecimal} whose value is {@code (-this)},
2550      * and whose scale is {@code this.scale()}.
2551      *
2552      * @return {@code -this}.
2553      */
2554     public BigDecimal negate() {
2555         if (intCompact == INFLATED) {
2556             return new BigDecimal(intVal.negate(), INFLATED, scale, precision);
2557         } else {
2558             return valueOf(-intCompact, scale, precision);
2559         }
2560     }
2561 
2562     /**
2563      * Returns a {@code BigDecimal} whose value is {@code (-this)},
2564      * with rounding according to the context settings.
2565      *
2566      * @param mc the context to use.
2567      * @return {@code -this}, rounded as necessary.
2568      * @throws ArithmeticException if the result is inexact but the
2569      *         rounding mode is {@code UNNECESSARY}.
2570      * @since  1.5
2571      */
2572     public BigDecimal negate(MathContext mc) {
2573         return negate().plus(mc);
2574     }
2575 
2576     /**
2577      * Returns a {@code BigDecimal} whose value is {@code (+this)}, and whose
2578      * scale is {@code this.scale()}.
2579      *
2580      * &lt;p&gt;This method, which simply returns this {@code BigDecimal}
2581      * is included for symmetry with the unary minus method {@link
2582      * #negate()}.
2583      *
2584      * @return {@code this}.
2585      * @see #negate()
2586      * @since  1.5
2587      */
2588     public BigDecimal plus() {
2589         return this;
2590     }
2591 
2592     /**
2593      * Returns a {@code BigDecimal} whose value is {@code (+this)},
2594      * with rounding according to the context settings.
2595      *
2596      * &lt;p&gt;The effect of this method is identical to that of the {@link
2597      * #round(MathContext)} method.
2598      *
2599      * @param mc the context to use.
2600      * @return {@code this}, rounded as necessary.  A zero result will
2601      *         have a scale of 0.
2602      * @throws ArithmeticException if the result is inexact but the
2603      *         rounding mode is {@code UNNECESSARY}.
2604      * @see    #round(MathContext)
2605      * @since  1.5
2606      */
2607     public BigDecimal plus(MathContext mc) {
2608         if (mc.precision == 0)                 // no rounding please
2609             return this;
2610         return doRound(this, mc);
2611     }
2612 
2613     /**
2614      * Returns the signum function of this {@code BigDecimal}.
2615      *
2616      * @return -1, 0, or 1 as the value of this {@code BigDecimal}
2617      *         is negative, zero, or positive.
2618      */
2619     public int signum() {
2620         return (intCompact != INFLATED)?
2621             Long.signum(intCompact):
2622             intVal.signum();
2623     }
2624 
2625     /**
2626      * Returns the &lt;i&gt;scale&lt;/i&gt; of this {@code BigDecimal}.  If zero
2627      * or positive, the scale is the number of digits to the right of
2628      * the decimal point.  If negative, the unscaled value of the
2629      * number is multiplied by ten to the power of the negation of the
2630      * scale.  For example, a scale of {@code -3} means the unscaled
2631      * value is multiplied by 1000.
2632      *
2633      * @return the scale of this {@code BigDecimal}.
2634      */
2635     public int scale() {
2636         return scale;
2637     }
2638 
2639     /**
2640      * Returns the &lt;i&gt;precision&lt;/i&gt; of this {@code BigDecimal}.  (The
2641      * precision is the number of digits in the unscaled value.)
2642      *
2643      * &lt;p&gt;The precision of a zero value is 1.
2644      *
2645      * @return the precision of this {@code BigDecimal}.
2646      * @since  1.5
2647      */
2648     public int precision() {
2649         int result = precision;
2650         if (result == 0) {
2651             long s = intCompact;
2652             if (s != INFLATED)
2653                 result = longDigitLength(s);
2654             else
2655                 result = bigDigitLength(intVal);
2656             precision = result;
2657         }
2658         return result;
2659     }
2660 
2661 
2662     /**
2663      * Returns a {@code BigInteger} whose value is the &lt;i&gt;unscaled
2664      * value&lt;/i&gt; of this {@code BigDecimal}.  (Computes &lt;code&gt;(this *
2665      * 10&lt;sup&gt;this.scale()&lt;/sup&gt;)&lt;/code&gt;.)
2666      *
2667      * @return the unscaled value of this {@code BigDecimal}.
2668      * @since  1.2
2669      */
2670     public BigInteger unscaledValue() {
2671         return this.inflated();
2672     }
2673 
2674     // Rounding Modes
2675 
2676     /**
2677      * Rounding mode to round away from zero.  Always increments the
2678      * digit prior to a nonzero discarded fraction.  Note that this rounding
2679      * mode never decreases the magnitude of the calculated value.
2680      *
2681      * @deprecated Use {@link RoundingMode#UP} instead.
2682      */
2683     @Deprecated(since=&quot;9&quot;)
2684     public static final int ROUND_UP =           0;
2685 
2686     /**
2687      * Rounding mode to round towards zero.  Never increments the digit
2688      * prior to a discarded fraction (i.e., truncates).  Note that this
2689      * rounding mode never increases the magnitude of the calculated value.
2690      *
2691      * @deprecated Use {@link RoundingMode#DOWN} instead.
2692      */
2693     @Deprecated(since=&quot;9&quot;)
2694     public static final int ROUND_DOWN =         1;
2695 
2696     /**
2697      * Rounding mode to round towards positive infinity.  If the
2698      * {@code BigDecimal} is positive, behaves as for
2699      * {@code ROUND_UP}; if negative, behaves as for
2700      * {@code ROUND_DOWN}.  Note that this rounding mode never
2701      * decreases the calculated value.
2702      *
2703      * @deprecated Use {@link RoundingMode#CEILING} instead.
2704      */
2705     @Deprecated(since=&quot;9&quot;)
2706     public static final int ROUND_CEILING =      2;
2707 
2708     /**
2709      * Rounding mode to round towards negative infinity.  If the
2710      * {@code BigDecimal} is positive, behave as for
2711      * {@code ROUND_DOWN}; if negative, behave as for
2712      * {@code ROUND_UP}.  Note that this rounding mode never
2713      * increases the calculated value.
2714      *
2715      * @deprecated Use {@link RoundingMode#FLOOR} instead.
2716      */
2717     @Deprecated(since=&quot;9&quot;)
2718     public static final int ROUND_FLOOR =        3;
2719 
2720     /**
2721      * Rounding mode to round towards {@literal &quot;nearest neighbor&quot;}
2722      * unless both neighbors are equidistant, in which case round up.
2723      * Behaves as for {@code ROUND_UP} if the discarded fraction is
2724      * &amp;ge; 0.5; otherwise, behaves as for {@code ROUND_DOWN}.  Note
2725      * that this is the rounding mode that most of us were taught in
2726      * grade school.
2727      *
2728      * @deprecated Use {@link RoundingMode#HALF_UP} instead.
2729      */
2730     @Deprecated(since=&quot;9&quot;)
2731     public static final int ROUND_HALF_UP =      4;
2732 
2733     /**
2734      * Rounding mode to round towards {@literal &quot;nearest neighbor&quot;}
2735      * unless both neighbors are equidistant, in which case round
2736      * down.  Behaves as for {@code ROUND_UP} if the discarded
2737      * fraction is {@literal &gt;} 0.5; otherwise, behaves as for
2738      * {@code ROUND_DOWN}.
2739      *
2740      * @deprecated Use {@link RoundingMode#HALF_DOWN} instead.
2741      */
2742     @Deprecated(since=&quot;9&quot;)
2743     public static final int ROUND_HALF_DOWN =    5;
2744 
2745     /**
2746      * Rounding mode to round towards the {@literal &quot;nearest neighbor&quot;}
2747      * unless both neighbors are equidistant, in which case, round
2748      * towards the even neighbor.  Behaves as for
2749      * {@code ROUND_HALF_UP} if the digit to the left of the
2750      * discarded fraction is odd; behaves as for
2751      * {@code ROUND_HALF_DOWN} if it&#39;s even.  Note that this is the
2752      * rounding mode that minimizes cumulative error when applied
2753      * repeatedly over a sequence of calculations.
2754      *
2755      * @deprecated Use {@link RoundingMode#HALF_EVEN} instead.
2756      */
2757     @Deprecated(since=&quot;9&quot;)
2758     public static final int ROUND_HALF_EVEN =    6;
2759 
2760     /**
2761      * Rounding mode to assert that the requested operation has an exact
2762      * result, hence no rounding is necessary.  If this rounding mode is
2763      * specified on an operation that yields an inexact result, an
2764      * {@code ArithmeticException} is thrown.
2765      *
2766      * @deprecated Use {@link RoundingMode#UNNECESSARY} instead.
2767      */
2768     @Deprecated(since=&quot;9&quot;)
2769     public static final int ROUND_UNNECESSARY =  7;
2770 
2771 
2772     // Scaling/Rounding Operations
2773 
2774     /**
2775      * Returns a {@code BigDecimal} rounded according to the
2776      * {@code MathContext} settings.  If the precision setting is 0 then
2777      * no rounding takes place.
2778      *
2779      * &lt;p&gt;The effect of this method is identical to that of the
2780      * {@link #plus(MathContext)} method.
2781      *
2782      * @param mc the context to use.
2783      * @return a {@code BigDecimal} rounded according to the
2784      *         {@code MathContext} settings.
2785      * @throws ArithmeticException if the rounding mode is
2786      *         {@code UNNECESSARY} and the
2787      *         {@code BigDecimal}  operation would require rounding.
2788      * @see    #plus(MathContext)
2789      * @since  1.5
2790      */
2791     public BigDecimal round(MathContext mc) {
2792         return plus(mc);
2793     }
2794 
2795     /**
2796      * Returns a {@code BigDecimal} whose scale is the specified
2797      * value, and whose unscaled value is determined by multiplying or
2798      * dividing this {@code BigDecimal}&#39;s unscaled value by the
2799      * appropriate power of ten to maintain its overall value.  If the
2800      * scale is reduced by the operation, the unscaled value must be
2801      * divided (rather than multiplied), and the value may be changed;
2802      * in this case, the specified rounding mode is applied to the
2803      * division.
2804      *
2805      * @apiNote Since BigDecimal objects are immutable, calls of
2806      * this method do &lt;em&gt;not&lt;/em&gt; result in the original object being
2807      * modified, contrary to the usual convention of having methods
2808      * named &lt;code&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; mutate field &lt;i&gt;{@code X}&lt;/i&gt;.
2809      * Instead, {@code setScale} returns an object with the proper
2810      * scale; the returned object may or may not be newly allocated.
2811      *
2812      * @param  newScale scale of the {@code BigDecimal} value to be returned.
2813      * @param  roundingMode The rounding mode to apply.
2814      * @return a {@code BigDecimal} whose scale is the specified value,
2815      *         and whose unscaled value is determined by multiplying or
2816      *         dividing this {@code BigDecimal}&#39;s unscaled value by the
2817      *         appropriate power of ten to maintain its overall value.
2818      * @throws ArithmeticException if {@code roundingMode==UNNECESSARY}
2819      *         and the specified scaling operation would require
2820      *         rounding.
2821      * @see    RoundingMode
2822      * @since  1.5
2823      */
2824     public BigDecimal setScale(int newScale, RoundingMode roundingMode) {
2825         return setScale(newScale, roundingMode.oldMode);
2826     }
2827 
2828     /**
2829      * Returns a {@code BigDecimal} whose scale is the specified
2830      * value, and whose unscaled value is determined by multiplying or
2831      * dividing this {@code BigDecimal}&#39;s unscaled value by the
2832      * appropriate power of ten to maintain its overall value.  If the
2833      * scale is reduced by the operation, the unscaled value must be
2834      * divided (rather than multiplied), and the value may be changed;
2835      * in this case, the specified rounding mode is applied to the
2836      * division.
2837      *
2838      * @apiNote Since BigDecimal objects are immutable, calls of
2839      * this method do &lt;em&gt;not&lt;/em&gt; result in the original object being
2840      * modified, contrary to the usual convention of having methods
2841      * named &lt;code&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; mutate field &lt;i&gt;{@code X}&lt;/i&gt;.
2842      * Instead, {@code setScale} returns an object with the proper
2843      * scale; the returned object may or may not be newly allocated.
2844      *
2845      * @deprecated The method {@link #setScale(int, RoundingMode)} should
2846      * be used in preference to this legacy method.
2847      *
2848      * @param  newScale scale of the {@code BigDecimal} value to be returned.
2849      * @param  roundingMode The rounding mode to apply.
2850      * @return a {@code BigDecimal} whose scale is the specified value,
2851      *         and whose unscaled value is determined by multiplying or
2852      *         dividing this {@code BigDecimal}&#39;s unscaled value by the
2853      *         appropriate power of ten to maintain its overall value.
2854      * @throws ArithmeticException if {@code roundingMode==ROUND_UNNECESSARY}
2855      *         and the specified scaling operation would require
2856      *         rounding.
2857      * @throws IllegalArgumentException if {@code roundingMode} does not
2858      *         represent a valid rounding mode.
2859      * @see    #ROUND_UP
2860      * @see    #ROUND_DOWN
2861      * @see    #ROUND_CEILING
2862      * @see    #ROUND_FLOOR
2863      * @see    #ROUND_HALF_UP
2864      * @see    #ROUND_HALF_DOWN
2865      * @see    #ROUND_HALF_EVEN
2866      * @see    #ROUND_UNNECESSARY
2867      */
2868     @Deprecated(since=&quot;9&quot;)
2869     public BigDecimal setScale(int newScale, int roundingMode) {
2870         if (roundingMode &lt; ROUND_UP || roundingMode &gt; ROUND_UNNECESSARY)
2871             throw new IllegalArgumentException(&quot;Invalid rounding mode&quot;);
2872 
2873         int oldScale = this.scale;
2874         if (newScale == oldScale)        // easy case
2875             return this;
2876         if (this.signum() == 0)            // zero can have any scale
2877             return zeroValueOf(newScale);
2878         if(this.intCompact!=INFLATED) {
2879             long rs = this.intCompact;
2880             if (newScale &gt; oldScale) {
2881                 int raise = checkScale((long) newScale - oldScale);
2882                 if ((rs = longMultiplyPowerTen(rs, raise)) != INFLATED) {
2883                     return valueOf(rs,newScale);
2884                 }
2885                 BigInteger rb = bigMultiplyPowerTen(raise);
2886                 return new BigDecimal(rb, INFLATED, newScale, (precision &gt; 0) ? precision + raise : 0);
2887             } else {
2888                 // newScale &lt; oldScale -- drop some digits
2889                 // Can&#39;t predict the precision due to the effect of rounding.
2890                 int drop = checkScale((long) oldScale - newScale);
2891                 if (drop &lt; LONG_TEN_POWERS_TABLE.length) {
2892                     return divideAndRound(rs, LONG_TEN_POWERS_TABLE[drop], newScale, roundingMode, newScale);
2893                 } else {
2894                     return divideAndRound(this.inflated(), bigTenToThe(drop), newScale, roundingMode, newScale);
2895                 }
2896             }
2897         } else {
2898             if (newScale &gt; oldScale) {
2899                 int raise = checkScale((long) newScale - oldScale);
2900                 BigInteger rb = bigMultiplyPowerTen(this.intVal,raise);
2901                 return new BigDecimal(rb, INFLATED, newScale, (precision &gt; 0) ? precision + raise : 0);
2902             } else {
2903                 // newScale &lt; oldScale -- drop some digits
2904                 // Can&#39;t predict the precision due to the effect of rounding.
2905                 int drop = checkScale((long) oldScale - newScale);
2906                 if (drop &lt; LONG_TEN_POWERS_TABLE.length)
2907                     return divideAndRound(this.intVal, LONG_TEN_POWERS_TABLE[drop], newScale, roundingMode,
2908                                           newScale);
2909                 else
2910                     return divideAndRound(this.intVal,  bigTenToThe(drop), newScale, roundingMode, newScale);
2911             }
2912         }
2913     }
2914 
2915     /**
2916      * Returns a {@code BigDecimal} whose scale is the specified
2917      * value, and whose value is numerically equal to this
2918      * {@code BigDecimal}&#39;s.  Throws an {@code ArithmeticException}
2919      * if this is not possible.
2920      *
2921      * &lt;p&gt;This call is typically used to increase the scale, in which
2922      * case it is guaranteed that there exists a {@code BigDecimal}
2923      * of the specified scale and the correct value.  The call can
2924      * also be used to reduce the scale if the caller knows that the
2925      * {@code BigDecimal} has sufficiently many zeros at the end of
2926      * its fractional part (i.e., factors of ten in its integer value)
2927      * to allow for the rescaling without changing its value.
2928      *
2929      * &lt;p&gt;This method returns the same result as the two-argument
2930      * versions of {@code setScale}, but saves the caller the trouble
2931      * of specifying a rounding mode in cases where it is irrelevant.
2932      *
2933      * @apiNote Since {@code BigDecimal} objects are immutable,
2934      * calls of this method do &lt;em&gt;not&lt;/em&gt; result in the original
2935      * object being modified, contrary to the usual convention of
2936      * having methods named &lt;code&gt;set&lt;i&gt;X&lt;/i&gt;&lt;/code&gt; mutate field
2937      * &lt;i&gt;{@code X}&lt;/i&gt;.  Instead, {@code setScale} returns an
2938      * object with the proper scale; the returned object may or may
2939      * not be newly allocated.
2940      *
2941      * @param  newScale scale of the {@code BigDecimal} value to be returned.
2942      * @return a {@code BigDecimal} whose scale is the specified value, and
2943      *         whose unscaled value is determined by multiplying or dividing
2944      *         this {@code BigDecimal}&#39;s unscaled value by the appropriate
2945      *         power of ten to maintain its overall value.
2946      * @throws ArithmeticException if the specified scaling operation would
2947      *         require rounding.
2948      * @see    #setScale(int, int)
2949      * @see    #setScale(int, RoundingMode)
2950      */
2951     public BigDecimal setScale(int newScale) {
2952         return setScale(newScale, ROUND_UNNECESSARY);
2953     }
2954 
2955     // Decimal Point Motion Operations
2956 
2957     /**
2958      * Returns a {@code BigDecimal} which is equivalent to this one
2959      * with the decimal point moved {@code n} places to the left.  If
2960      * {@code n} is non-negative, the call merely adds {@code n} to
2961      * the scale.  If {@code n} is negative, the call is equivalent
2962      * to {@code movePointRight(-n)}.  The {@code BigDecimal}
2963      * returned by this call has value &lt;code&gt;(this &amp;times;
2964      * 10&lt;sup&gt;-n&lt;/sup&gt;)&lt;/code&gt; and scale {@code max(this.scale()+n,
2965      * 0)}.
2966      *
2967      * @param  n number of places to move the decimal point to the left.
2968      * @return a {@code BigDecimal} which is equivalent to this one with the
2969      *         decimal point moved {@code n} places to the left.
2970      * @throws ArithmeticException if scale overflows.
2971      */
2972     public BigDecimal movePointLeft(int n) {
2973         if (n == 0) return this;
2974 
2975         // Cannot use movePointRight(-n) in case of n==Integer.MIN_VALUE
2976         int newScale = checkScale((long)scale + n);
2977         BigDecimal num = new BigDecimal(intVal, intCompact, newScale, 0);
2978         return num.scale &lt; 0 ? num.setScale(0, ROUND_UNNECESSARY) : num;
2979     }
2980 
2981     /**
2982      * Returns a {@code BigDecimal} which is equivalent to this one
2983      * with the decimal point moved {@code n} places to the right.
2984      * If {@code n} is non-negative, the call merely subtracts
2985      * {@code n} from the scale.  If {@code n} is negative, the call
2986      * is equivalent to {@code movePointLeft(-n)}.  The
2987      * {@code BigDecimal} returned by this call has value &lt;code&gt;(this
2988      * &amp;times; 10&lt;sup&gt;n&lt;/sup&gt;)&lt;/code&gt; and scale {@code max(this.scale()-n,
2989      * 0)}.
2990      *
2991      * @param  n number of places to move the decimal point to the right.
2992      * @return a {@code BigDecimal} which is equivalent to this one
2993      *         with the decimal point moved {@code n} places to the right.
2994      * @throws ArithmeticException if scale overflows.
2995      */
2996     public BigDecimal movePointRight(int n) {
2997         if (n == 0) return this;
2998 
2999         // Cannot use movePointLeft(-n) in case of n==Integer.MIN_VALUE
3000         int newScale = checkScale((long)scale - n);
3001         BigDecimal num = new BigDecimal(intVal, intCompact, newScale, 0);
3002         return num.scale &lt; 0 ? num.setScale(0, ROUND_UNNECESSARY) : num;
3003     }
3004 
3005     /**
3006      * Returns a BigDecimal whose numerical value is equal to
3007      * ({@code this} * 10&lt;sup&gt;n&lt;/sup&gt;).  The scale of
3008      * the result is {@code (this.scale() - n)}.
3009      *
3010      * @param n the exponent power of ten to scale by
3011      * @return a BigDecimal whose numerical value is equal to
3012      * ({@code this} * 10&lt;sup&gt;n&lt;/sup&gt;)
3013      * @throws ArithmeticException if the scale would be
3014      *         outside the range of a 32-bit integer.
3015      *
3016      * @since 1.5
3017      */
3018     public BigDecimal scaleByPowerOfTen(int n) {
3019         return new BigDecimal(intVal, intCompact,
3020                               checkScale((long)scale - n), precision);
3021     }
3022 
3023     /**
3024      * Returns a {@code BigDecimal} which is numerically equal to
3025      * this one but with any trailing zeros removed from the
3026      * representation.  For example, stripping the trailing zeros from
3027      * the {@code BigDecimal} value {@code 600.0}, which has
<a name="2" id="anc2"></a><span class="line-modified">3028      * [{@code BigInteger}, {@code scale}] components equals to</span>
3029      * [6000, 1], yields {@code 6E2} with [{@code BigInteger},
<a name="3" id="anc3"></a><span class="line-modified">3030      * {@code scale}] components equals to [6, -2].  If</span>
3031      * this BigDecimal is numerically equal to zero, then
3032      * {@code BigDecimal.ZERO} is returned.
3033      *
3034      * @return a numerically equal {@code BigDecimal} with any
3035      * trailing zeros removed.
3036      * @since 1.5
3037      */
3038     public BigDecimal stripTrailingZeros() {
3039         if (intCompact == 0 || (intVal != null &amp;&amp; intVal.signum() == 0)) {
3040             return BigDecimal.ZERO;
3041         } else if (intCompact != INFLATED) {
3042             return createAndStripZerosToMatchScale(intCompact, scale, Long.MIN_VALUE);
3043         } else {
3044             return createAndStripZerosToMatchScale(intVal, scale, Long.MIN_VALUE);
3045         }
3046     }
3047 
3048     // Comparison Operations
3049 
3050     /**
3051      * Compares this {@code BigDecimal} with the specified
3052      * {@code BigDecimal}.  Two {@code BigDecimal} objects that are
3053      * equal in value but have a different scale (like 2.0 and 2.00)
3054      * are considered equal by this method.  This method is provided
3055      * in preference to individual methods for each of the six boolean
3056      * comparison operators ({@literal &lt;}, ==,
3057      * {@literal &gt;}, {@literal &gt;=}, !=, {@literal &lt;=}).  The
3058      * suggested idiom for performing these comparisons is:
3059      * {@code (x.compareTo(y)} &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; {@code 0)}, where
3060      * &amp;lt;&lt;i&gt;op&lt;/i&gt;&amp;gt; is one of the six comparison operators.
3061      *
3062      * @param  val {@code BigDecimal} to which this {@code BigDecimal} is
3063      *         to be compared.
3064      * @return -1, 0, or 1 as this {@code BigDecimal} is numerically
3065      *          less than, equal to, or greater than {@code val}.
3066      */
3067     @Override
3068     public int compareTo(BigDecimal val) {
3069         // Quick path for equal scale and non-inflated case.
3070         if (scale == val.scale) {
3071             long xs = intCompact;
3072             long ys = val.intCompact;
3073             if (xs != INFLATED &amp;&amp; ys != INFLATED)
3074                 return xs != ys ? ((xs &gt; ys) ? 1 : -1) : 0;
3075         }
3076         int xsign = this.signum();
3077         int ysign = val.signum();
3078         if (xsign != ysign)
3079             return (xsign &gt; ysign) ? 1 : -1;
3080         if (xsign == 0)
3081             return 0;
3082         int cmp = compareMagnitude(val);
3083         return (xsign &gt; 0) ? cmp : -cmp;
3084     }
3085 
3086     /**
3087      * Version of compareTo that ignores sign.
3088      */
3089     private int compareMagnitude(BigDecimal val) {
3090         // Match scales, avoid unnecessary inflation
3091         long ys = val.intCompact;
3092         long xs = this.intCompact;
3093         if (xs == 0)
3094             return (ys == 0) ? 0 : -1;
3095         if (ys == 0)
3096             return 1;
3097 
3098         long sdiff = (long)this.scale - val.scale;
3099         if (sdiff != 0) {
3100             // Avoid matching scales if the (adjusted) exponents differ
3101             long xae = (long)this.precision() - this.scale;   // [-1]
3102             long yae = (long)val.precision() - val.scale;     // [-1]
3103             if (xae &lt; yae)
3104                 return -1;
3105             if (xae &gt; yae)
3106                 return 1;
3107             if (sdiff &lt; 0) {
3108                 // The cases sdiff &lt;= Integer.MIN_VALUE intentionally fall through.
3109                 if ( sdiff &gt; Integer.MIN_VALUE &amp;&amp;
3110                       (xs == INFLATED ||
3111                       (xs = longMultiplyPowerTen(xs, (int)-sdiff)) == INFLATED) &amp;&amp;
3112                      ys == INFLATED) {
3113                     BigInteger rb = bigMultiplyPowerTen((int)-sdiff);
3114                     return rb.compareMagnitude(val.intVal);
3115                 }
3116             } else { // sdiff &gt; 0
3117                 // The cases sdiff &gt; Integer.MAX_VALUE intentionally fall through.
3118                 if ( sdiff &lt;= Integer.MAX_VALUE &amp;&amp;
3119                       (ys == INFLATED ||
3120                       (ys = longMultiplyPowerTen(ys, (int)sdiff)) == INFLATED) &amp;&amp;
3121                      xs == INFLATED) {
3122                     BigInteger rb = val.bigMultiplyPowerTen((int)sdiff);
3123                     return this.intVal.compareMagnitude(rb);
3124                 }
3125             }
3126         }
3127         if (xs != INFLATED)
3128             return (ys != INFLATED) ? longCompareMagnitude(xs, ys) : -1;
3129         else if (ys != INFLATED)
3130             return 1;
3131         else
3132             return this.intVal.compareMagnitude(val.intVal);
3133     }
3134 
3135     /**
3136      * Compares this {@code BigDecimal} with the specified
3137      * {@code Object} for equality.  Unlike {@link
3138      * #compareTo(BigDecimal) compareTo}, this method considers two
3139      * {@code BigDecimal} objects equal only if they are equal in
3140      * value and scale (thus 2.0 is not equal to 2.00 when compared by
3141      * this method).
3142      *
3143      * @param  x {@code Object} to which this {@code BigDecimal} is
3144      *         to be compared.
3145      * @return {@code true} if and only if the specified {@code Object} is a
3146      *         {@code BigDecimal} whose value and scale are equal to this
3147      *         {@code BigDecimal}&#39;s.
3148      * @see    #compareTo(java.math.BigDecimal)
3149      * @see    #hashCode
3150      */
3151     @Override
3152     public boolean equals(Object x) {
3153         if (!(x instanceof BigDecimal))
3154             return false;
3155         BigDecimal xDec = (BigDecimal) x;
3156         if (x == this)
3157             return true;
3158         if (scale != xDec.scale)
3159             return false;
3160         long s = this.intCompact;
3161         long xs = xDec.intCompact;
3162         if (s != INFLATED) {
3163             if (xs == INFLATED)
3164                 xs = compactValFor(xDec.intVal);
3165             return xs == s;
3166         } else if (xs != INFLATED)
3167             return xs == compactValFor(this.intVal);
3168 
3169         return this.inflated().equals(xDec.inflated());
3170     }
3171 
3172     /**
3173      * Returns the minimum of this {@code BigDecimal} and
3174      * {@code val}.
3175      *
3176      * @param  val value with which the minimum is to be computed.
3177      * @return the {@code BigDecimal} whose value is the lesser of this
3178      *         {@code BigDecimal} and {@code val}.  If they are equal,
3179      *         as defined by the {@link #compareTo(BigDecimal) compareTo}
3180      *         method, {@code this} is returned.
3181      * @see    #compareTo(java.math.BigDecimal)
3182      */
3183     public BigDecimal min(BigDecimal val) {
3184         return (compareTo(val) &lt;= 0 ? this : val);
3185     }
3186 
3187     /**
3188      * Returns the maximum of this {@code BigDecimal} and {@code val}.
3189      *
3190      * @param  val value with which the maximum is to be computed.
3191      * @return the {@code BigDecimal} whose value is the greater of this
3192      *         {@code BigDecimal} and {@code val}.  If they are equal,
3193      *         as defined by the {@link #compareTo(BigDecimal) compareTo}
3194      *         method, {@code this} is returned.
3195      * @see    #compareTo(java.math.BigDecimal)
3196      */
3197     public BigDecimal max(BigDecimal val) {
3198         return (compareTo(val) &gt;= 0 ? this : val);
3199     }
3200 
3201     // Hash Function
3202 
3203     /**
3204      * Returns the hash code for this {@code BigDecimal}.  Note that
3205      * two {@code BigDecimal} objects that are numerically equal but
3206      * differ in scale (like 2.0 and 2.00) will generally &lt;em&gt;not&lt;/em&gt;
3207      * have the same hash code.
3208      *
3209      * @return hash code for this {@code BigDecimal}.
3210      * @see #equals(Object)
3211      */
3212     @Override
3213     public int hashCode() {
3214         if (intCompact != INFLATED) {
3215             long val2 = (intCompact &lt; 0)? -intCompact : intCompact;
3216             int temp = (int)( ((int)(val2 &gt;&gt;&gt; 32)) * 31  +
3217                               (val2 &amp; LONG_MASK));
3218             return 31*((intCompact &lt; 0) ?-temp:temp) + scale;
3219         } else
3220             return 31*intVal.hashCode() + scale;
3221     }
3222 
3223     // Format Converters
3224 
3225     /**
3226      * Returns the string representation of this {@code BigDecimal},
3227      * using scientific notation if an exponent is needed.
3228      *
3229      * &lt;p&gt;A standard canonical string form of the {@code BigDecimal}
3230      * is created as though by the following steps: first, the
3231      * absolute value of the unscaled value of the {@code BigDecimal}
3232      * is converted to a string in base ten using the characters
3233      * {@code &#39;0&#39;} through {@code &#39;9&#39;} with no leading zeros (except
3234      * if its value is zero, in which case a single {@code &#39;0&#39;}
3235      * character is used).
3236      *
3237      * &lt;p&gt;Next, an &lt;i&gt;adjusted exponent&lt;/i&gt; is calculated; this is the
3238      * negated scale, plus the number of characters in the converted
3239      * unscaled value, less one.  That is,
3240      * {@code -scale+(ulength-1)}, where {@code ulength} is the
3241      * length of the absolute value of the unscaled value in decimal
3242      * digits (its &lt;i&gt;precision&lt;/i&gt;).
3243      *
3244      * &lt;p&gt;If the scale is greater than or equal to zero and the
3245      * adjusted exponent is greater than or equal to {@code -6}, the
3246      * number will be converted to a character form without using
3247      * exponential notation.  In this case, if the scale is zero then
3248      * no decimal point is added and if the scale is positive a
3249      * decimal point will be inserted with the scale specifying the
3250      * number of characters to the right of the decimal point.
3251      * {@code &#39;0&#39;} characters are added to the left of the converted
3252      * unscaled value as necessary.  If no character precedes the
3253      * decimal point after this insertion then a conventional
3254      * {@code &#39;0&#39;} character is prefixed.
3255      *
3256      * &lt;p&gt;Otherwise (that is, if the scale is negative, or the
3257      * adjusted exponent is less than {@code -6}), the number will be
3258      * converted to a character form using exponential notation.  In
3259      * this case, if the converted {@code BigInteger} has more than
3260      * one digit a decimal point is inserted after the first digit.
3261      * An exponent in character form is then suffixed to the converted
3262      * unscaled value (perhaps with inserted decimal point); this
3263      * comprises the letter {@code &#39;E&#39;} followed immediately by the
3264      * adjusted exponent converted to a character form.  The latter is
3265      * in base ten, using the characters {@code &#39;0&#39;} through
3266      * {@code &#39;9&#39;} with no leading zeros, and is always prefixed by a
3267      * sign character {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002D&#39;&lt;/code&gt;) if the
3268      * adjusted exponent is negative, {@code &#39;+&#39;}
3269      * (&lt;code&gt;&#39;&amp;#92;u002B&#39;&lt;/code&gt;) otherwise).
3270      *
3271      * &lt;p&gt;Finally, the entire string is prefixed by a minus sign
3272      * character {@code &#39;-&#39;} (&lt;code&gt;&#39;&amp;#92;u002D&#39;&lt;/code&gt;) if the unscaled
3273      * value is less than zero.  No sign character is prefixed if the
3274      * unscaled value is zero or positive.
3275      *
3276      * &lt;p&gt;&lt;b&gt;Examples:&lt;/b&gt;
3277      * &lt;p&gt;For each representation [&lt;i&gt;unscaled value&lt;/i&gt;, &lt;i&gt;scale&lt;/i&gt;]
3278      * on the left, the resulting string is shown on the right.
3279      * &lt;pre&gt;
3280      * [123,0]      &quot;123&quot;
3281      * [-123,0]     &quot;-123&quot;
3282      * [123,-1]     &quot;1.23E+3&quot;
3283      * [123,-3]     &quot;1.23E+5&quot;
3284      * [123,1]      &quot;12.3&quot;
3285      * [123,5]      &quot;0.00123&quot;
3286      * [123,10]     &quot;1.23E-8&quot;
3287      * [-123,12]    &quot;-1.23E-10&quot;
3288      * &lt;/pre&gt;
3289      *
3290      * &lt;b&gt;Notes:&lt;/b&gt;
3291      * &lt;ol&gt;
3292      *
3293      * &lt;li&gt;There is a one-to-one mapping between the distinguishable
3294      * {@code BigDecimal} values and the result of this conversion.
3295      * That is, every distinguishable {@code BigDecimal} value
3296      * (unscaled value and scale) has a unique string representation
3297      * as a result of using {@code toString}.  If that string
3298      * representation is converted back to a {@code BigDecimal} using
3299      * the {@link #BigDecimal(String)} constructor, then the original
3300      * value will be recovered.
3301      *
3302      * &lt;li&gt;The string produced for a given number is always the same;
3303      * it is not affected by locale.  This means that it can be used
3304      * as a canonical string representation for exchanging decimal
3305      * data, or as a key for a Hashtable, etc.  Locale-sensitive
3306      * number formatting and parsing is handled by the {@link
3307      * java.text.NumberFormat} class and its subclasses.
3308      *
3309      * &lt;li&gt;The {@link #toEngineeringString} method may be used for
3310      * presenting numbers with exponents in engineering notation, and the
3311      * {@link #setScale(int,RoundingMode) setScale} method may be used for
3312      * rounding a {@code BigDecimal} so it has a known number of digits after
3313      * the decimal point.
3314      *
3315      * &lt;li&gt;The digit-to-character mapping provided by
3316      * {@code Character.forDigit} is used.
3317      *
3318      * &lt;/ol&gt;
3319      *
3320      * @return string representation of this {@code BigDecimal}.
3321      * @see    Character#forDigit
3322      * @see    #BigDecimal(java.lang.String)
3323      */
3324     @Override
3325     public String toString() {
3326         String sc = stringCache;
3327         if (sc == null) {
3328             stringCache = sc = layoutChars(true);
3329         }
3330         return sc;
3331     }
3332 
3333     /**
3334      * Returns a string representation of this {@code BigDecimal},
3335      * using engineering notation if an exponent is needed.
3336      *
3337      * &lt;p&gt;Returns a string that represents the {@code BigDecimal} as
3338      * described in the {@link #toString()} method, except that if
3339      * exponential notation is used, the power of ten is adjusted to
3340      * be a multiple of three (engineering notation) such that the
3341      * integer part of nonzero values will be in the range 1 through
3342      * 999.  If exponential notation is used for zero values, a
3343      * decimal point and one or two fractional zero digits are used so
3344      * that the scale of the zero value is preserved.  Note that
3345      * unlike the output of {@link #toString()}, the output of this
3346      * method is &lt;em&gt;not&lt;/em&gt; guaranteed to recover the same [integer,
3347      * scale] pair of this {@code BigDecimal} if the output string is
3348      * converting back to a {@code BigDecimal} using the {@linkplain
3349      * #BigDecimal(String) string constructor}.  The result of this method meets
3350      * the weaker constraint of always producing a numerically equal
3351      * result from applying the string constructor to the method&#39;s output.
3352      *
3353      * @return string representation of this {@code BigDecimal}, using
3354      *         engineering notation if an exponent is needed.
3355      * @since  1.5
3356      */
3357     public String toEngineeringString() {
3358         return layoutChars(false);
3359     }
3360 
3361     /**
3362      * Returns a string representation of this {@code BigDecimal}
3363      * without an exponent field.  For values with a positive scale,
3364      * the number of digits to the right of the decimal point is used
3365      * to indicate scale.  For values with a zero or negative scale,
3366      * the resulting string is generated as if the value were
3367      * converted to a numerically equal value with zero scale and as
3368      * if all the trailing zeros of the zero scale value were present
3369      * in the result.
3370      *
3371      * The entire string is prefixed by a minus sign character &#39;-&#39;
3372      * (&lt;code&gt;&#39;&amp;#92;u002D&#39;&lt;/code&gt;) if the unscaled value is less than
3373      * zero. No sign character is prefixed if the unscaled value is
3374      * zero or positive.
3375      *
3376      * Note that if the result of this method is passed to the
3377      * {@linkplain #BigDecimal(String) string constructor}, only the
3378      * numerical value of this {@code BigDecimal} will necessarily be
3379      * recovered; the representation of the new {@code BigDecimal}
3380      * may have a different scale.  In particular, if this
3381      * {@code BigDecimal} has a negative scale, the string resulting
3382      * from this method will have a scale of zero when processed by
3383      * the string constructor.
3384      *
3385      * (This method behaves analogously to the {@code toString}
3386      * method in 1.4 and earlier releases.)
3387      *
3388      * @return a string representation of this {@code BigDecimal}
3389      * without an exponent field.
3390      * @since 1.5
3391      * @see #toString()
3392      * @see #toEngineeringString()
3393      */
3394     public String toPlainString() {
3395         if(scale==0) {
3396             if(intCompact!=INFLATED) {
3397                 return Long.toString(intCompact);
3398             } else {
3399                 return intVal.toString();
3400             }
3401         }
3402         if(this.scale&lt;0) { // No decimal point
3403             if(signum()==0) {
3404                 return &quot;0&quot;;
3405             }
3406             int trailingZeros = checkScaleNonZero((-(long)scale));
3407             StringBuilder buf;
3408             if(intCompact!=INFLATED) {
3409                 buf = new StringBuilder(20+trailingZeros);
3410                 buf.append(intCompact);
3411             } else {
3412                 String str = intVal.toString();
3413                 buf = new StringBuilder(str.length()+trailingZeros);
3414                 buf.append(str);
3415             }
3416             for (int i = 0; i &lt; trailingZeros; i++) {
3417                 buf.append(&#39;0&#39;);
3418             }
3419             return buf.toString();
3420         }
3421         String str ;
3422         if(intCompact!=INFLATED) {
3423             str = Long.toString(Math.abs(intCompact));
3424         } else {
3425             str = intVal.abs().toString();
3426         }
3427         return getValueString(signum(), str, scale);
3428     }
3429 
3430     /* Returns a digit.digit string */
3431     private String getValueString(int signum, String intString, int scale) {
3432         /* Insert decimal point */
3433         StringBuilder buf;
3434         int insertionPoint = intString.length() - scale;
3435         if (insertionPoint == 0) {  /* Point goes right before intVal */
3436             return (signum&lt;0 ? &quot;-0.&quot; : &quot;0.&quot;) + intString;
3437         } else if (insertionPoint &gt; 0) { /* Point goes inside intVal */
3438             buf = new StringBuilder(intString);
3439             buf.insert(insertionPoint, &#39;.&#39;);
3440             if (signum &lt; 0)
3441                 buf.insert(0, &#39;-&#39;);
3442         } else { /* We must insert zeros between point and intVal */
3443             buf = new StringBuilder(3-insertionPoint + intString.length());
3444             buf.append(signum&lt;0 ? &quot;-0.&quot; : &quot;0.&quot;);
3445             for (int i=0; i&lt;-insertionPoint; i++) {
3446                 buf.append(&#39;0&#39;);
3447             }
3448             buf.append(intString);
3449         }
3450         return buf.toString();
3451     }
3452 
3453     /**
3454      * Converts this {@code BigDecimal} to a {@code BigInteger}.
3455      * This conversion is analogous to the
3456      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3457      * {@code long} as defined in
3458      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3459      * any fractional part of this
3460      * {@code BigDecimal} will be discarded.  Note that this
3461      * conversion can lose information about the precision of the
3462      * {@code BigDecimal} value.
3463      * &lt;p&gt;
3464      * To have an exception thrown if the conversion is inexact (in
3465      * other words if a nonzero fractional part is discarded), use the
3466      * {@link #toBigIntegerExact()} method.
3467      *
3468      * @return this {@code BigDecimal} converted to a {@code BigInteger}.
3469      * @jls 5.1.3 Narrowing Primitive Conversion
3470      */
3471     public BigInteger toBigInteger() {
3472         // force to an integer, quietly
3473         return this.setScale(0, ROUND_DOWN).inflated();
3474     }
3475 
3476     /**
3477      * Converts this {@code BigDecimal} to a {@code BigInteger},
3478      * checking for lost information.  An exception is thrown if this
3479      * {@code BigDecimal} has a nonzero fractional part.
3480      *
3481      * @return this {@code BigDecimal} converted to a {@code BigInteger}.
3482      * @throws ArithmeticException if {@code this} has a nonzero
3483      *         fractional part.
3484      * @since  1.5
3485      */
3486     public BigInteger toBigIntegerExact() {
3487         // round to an integer, with Exception if decimal part non-0
3488         return this.setScale(0, ROUND_UNNECESSARY).inflated();
3489     }
3490 
3491     /**
3492      * Converts this {@code BigDecimal} to a {@code long}.
3493      * This conversion is analogous to the
3494      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3495      * {@code short} as defined in
3496      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3497      * any fractional part of this
3498      * {@code BigDecimal} will be discarded, and if the resulting
3499      * &quot;{@code BigInteger}&quot; is too big to fit in a
3500      * {@code long}, only the low-order 64 bits are returned.
3501      * Note that this conversion can lose information about the
3502      * overall magnitude and precision of this {@code BigDecimal} value as well
3503      * as return a result with the opposite sign.
3504      *
3505      * @return this {@code BigDecimal} converted to a {@code long}.
3506      * @jls 5.1.3 Narrowing Primitive Conversion
3507      */
3508     @Override
3509     public long longValue(){
3510         if (intCompact != INFLATED &amp;&amp; scale == 0) {
3511             return intCompact;
3512         } else {
3513             // Fastpath zero and small values
3514             if (this.signum() == 0 || fractionOnly() ||
3515                 // Fastpath very large-scale values that will result
3516                 // in a truncated value of zero. If the scale is -64
3517                 // or less, there are at least 64 powers of 10 in the
3518                 // value of the numerical result. Since 10 = 2*5, in
3519                 // that case there would also be 64 powers of 2 in the
3520                 // result, meaning all 64 bits of a long will be zero.
3521                 scale &lt;= -64) {
3522                 return 0;
3523             } else {
3524                 return toBigInteger().longValue();
3525             }
3526         }
3527     }
3528 
3529     /**
3530      * Return true if a nonzero BigDecimal has an absolute value less
3531      * than one; i.e. only has fraction digits.
3532      */
3533     private boolean fractionOnly() {
3534         assert this.signum() != 0;
3535         return (this.precision() - this.scale) &lt;= 0;
3536     }
3537 
3538     /**
3539      * Converts this {@code BigDecimal} to a {@code long}, checking
3540      * for lost information.  If this {@code BigDecimal} has a
3541      * nonzero fractional part or is out of the possible range for a
3542      * {@code long} result then an {@code ArithmeticException} is
3543      * thrown.
3544      *
3545      * @return this {@code BigDecimal} converted to a {@code long}.
3546      * @throws ArithmeticException if {@code this} has a nonzero
3547      *         fractional part, or will not fit in a {@code long}.
3548      * @since  1.5
3549      */
3550     public long longValueExact() {
3551         if (intCompact != INFLATED &amp;&amp; scale == 0)
3552             return intCompact;
3553 
3554         // Fastpath zero
3555         if (this.signum() == 0)
3556             return 0;
3557 
3558         // Fastpath numbers less than 1.0 (the latter can be very slow
3559         // to round if very small)
3560         if (fractionOnly())
3561             throw new ArithmeticException(&quot;Rounding necessary&quot;);
3562 
3563         // If more than 19 digits in integer part it cannot possibly fit
3564         if ((precision() - scale) &gt; 19) // [OK for negative scale too]
3565             throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3566 
3567         // round to an integer, with Exception if decimal part non-0
3568         BigDecimal num = this.setScale(0, ROUND_UNNECESSARY);
3569         if (num.precision() &gt;= 19) // need to check carefully
3570             LongOverflow.check(num);
3571         return num.inflated().longValue();
3572     }
3573 
3574     private static class LongOverflow {
3575         /** BigInteger equal to Long.MIN_VALUE. */
3576         private static final BigInteger LONGMIN = BigInteger.valueOf(Long.MIN_VALUE);
3577 
3578         /** BigInteger equal to Long.MAX_VALUE. */
3579         private static final BigInteger LONGMAX = BigInteger.valueOf(Long.MAX_VALUE);
3580 
3581         public static void check(BigDecimal num) {
3582             BigInteger intVal = num.inflated();
3583             if (intVal.compareTo(LONGMIN) &lt; 0 ||
3584                 intVal.compareTo(LONGMAX) &gt; 0)
3585                 throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3586         }
3587     }
3588 
3589     /**
3590      * Converts this {@code BigDecimal} to an {@code int}.
3591      * This conversion is analogous to the
3592      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3593      * {@code short} as defined in
3594      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3595      * any fractional part of this
3596      * {@code BigDecimal} will be discarded, and if the resulting
3597      * &quot;{@code BigInteger}&quot; is too big to fit in an
3598      * {@code int}, only the low-order 32 bits are returned.
3599      * Note that this conversion can lose information about the
3600      * overall magnitude and precision of this {@code BigDecimal}
3601      * value as well as return a result with the opposite sign.
3602      *
3603      * @return this {@code BigDecimal} converted to an {@code int}.
3604      * @jls 5.1.3 Narrowing Primitive Conversion
3605      */
3606     @Override
3607     public int intValue() {
3608         return  (intCompact != INFLATED &amp;&amp; scale == 0) ?
3609             (int)intCompact :
3610             (int)longValue();
3611     }
3612 
3613     /**
3614      * Converts this {@code BigDecimal} to an {@code int}, checking
3615      * for lost information.  If this {@code BigDecimal} has a
3616      * nonzero fractional part or is out of the possible range for an
3617      * {@code int} result then an {@code ArithmeticException} is
3618      * thrown.
3619      *
3620      * @return this {@code BigDecimal} converted to an {@code int}.
3621      * @throws ArithmeticException if {@code this} has a nonzero
3622      *         fractional part, or will not fit in an {@code int}.
3623      * @since  1.5
3624      */
3625     public int intValueExact() {
3626        long num;
3627        num = this.longValueExact();     // will check decimal part
3628        if ((int)num != num)
3629            throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3630        return (int)num;
3631     }
3632 
3633     /**
3634      * Converts this {@code BigDecimal} to a {@code short}, checking
3635      * for lost information.  If this {@code BigDecimal} has a
3636      * nonzero fractional part or is out of the possible range for a
3637      * {@code short} result then an {@code ArithmeticException} is
3638      * thrown.
3639      *
3640      * @return this {@code BigDecimal} converted to a {@code short}.
3641      * @throws ArithmeticException if {@code this} has a nonzero
3642      *         fractional part, or will not fit in a {@code short}.
3643      * @since  1.5
3644      */
3645     public short shortValueExact() {
3646        long num;
3647        num = this.longValueExact();     // will check decimal part
3648        if ((short)num != num)
3649            throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3650        return (short)num;
3651     }
3652 
3653     /**
3654      * Converts this {@code BigDecimal} to a {@code byte}, checking
3655      * for lost information.  If this {@code BigDecimal} has a
3656      * nonzero fractional part or is out of the possible range for a
3657      * {@code byte} result then an {@code ArithmeticException} is
3658      * thrown.
3659      *
3660      * @return this {@code BigDecimal} converted to a {@code byte}.
3661      * @throws ArithmeticException if {@code this} has a nonzero
3662      *         fractional part, or will not fit in a {@code byte}.
3663      * @since  1.5
3664      */
3665     public byte byteValueExact() {
3666        long num;
3667        num = this.longValueExact();     // will check decimal part
3668        if ((byte)num != num)
3669            throw new java.lang.ArithmeticException(&quot;Overflow&quot;);
3670        return (byte)num;
3671     }
3672 
3673     /**
3674      * Converts this {@code BigDecimal} to a {@code float}.
3675      * This conversion is similar to the
3676      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3677      * {@code float} as defined in
3678      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3679      * if this {@code BigDecimal} has too great a
3680      * magnitude to represent as a {@code float}, it will be
3681      * converted to {@link Float#NEGATIVE_INFINITY} or {@link
3682      * Float#POSITIVE_INFINITY} as appropriate.  Note that even when
3683      * the return value is finite, this conversion can lose
3684      * information about the precision of the {@code BigDecimal}
3685      * value.
3686      *
3687      * @return this {@code BigDecimal} converted to a {@code float}.
3688      * @jls 5.1.3 Narrowing Primitive Conversion
3689      */
3690     @Override
3691     public float floatValue(){
3692         if(intCompact != INFLATED) {
3693             if (scale == 0) {
3694                 return (float)intCompact;
3695             } else {
3696                 /*
3697                  * If both intCompact and the scale can be exactly
3698                  * represented as float values, perform a single float
3699                  * multiply or divide to compute the (properly
3700                  * rounded) result.
3701                  */
3702                 if (Math.abs(intCompact) &lt; 1L&lt;&lt;22 ) {
3703                     // Don&#39;t have too guard against
3704                     // Math.abs(MIN_VALUE) because of outer check
3705                     // against INFLATED.
3706                     if (scale &gt; 0 &amp;&amp; scale &lt; FLOAT_10_POW.length) {
3707                         return (float)intCompact / FLOAT_10_POW[scale];
3708                     } else if (scale &lt; 0 &amp;&amp; scale &gt; -FLOAT_10_POW.length) {
3709                         return (float)intCompact * FLOAT_10_POW[-scale];
3710                     }
3711                 }
3712             }
3713         }
3714         // Somewhat inefficient, but guaranteed to work.
3715         return Float.parseFloat(this.toString());
3716     }
3717 
3718     /**
3719      * Converts this {@code BigDecimal} to a {@code double}.
3720      * This conversion is similar to the
3721      * &lt;i&gt;narrowing primitive conversion&lt;/i&gt; from {@code double} to
3722      * {@code float} as defined in
3723      * &lt;cite&gt;The Java&amp;trade; Language Specification&lt;/cite&gt;:
3724      * if this {@code BigDecimal} has too great a
3725      * magnitude represent as a {@code double}, it will be
3726      * converted to {@link Double#NEGATIVE_INFINITY} or {@link
3727      * Double#POSITIVE_INFINITY} as appropriate.  Note that even when
3728      * the return value is finite, this conversion can lose
3729      * information about the precision of the {@code BigDecimal}
3730      * value.
3731      *
3732      * @return this {@code BigDecimal} converted to a {@code double}.
3733      * @jls 5.1.3 Narrowing Primitive Conversion
3734      */
3735     @Override
3736     public double doubleValue(){
3737         if(intCompact != INFLATED) {
3738             if (scale == 0) {
3739                 return (double)intCompact;
3740             } else {
3741                 /*
3742                  * If both intCompact and the scale can be exactly
3743                  * represented as double values, perform a single
3744                  * double multiply or divide to compute the (properly
3745                  * rounded) result.
3746                  */
3747                 if (Math.abs(intCompact) &lt; 1L&lt;&lt;52 ) {
3748                     // Don&#39;t have too guard against
3749                     // Math.abs(MIN_VALUE) because of outer check
3750                     // against INFLATED.
3751                     if (scale &gt; 0 &amp;&amp; scale &lt; DOUBLE_10_POW.length) {
3752                         return (double)intCompact / DOUBLE_10_POW[scale];
3753                     } else if (scale &lt; 0 &amp;&amp; scale &gt; -DOUBLE_10_POW.length) {
3754                         return (double)intCompact * DOUBLE_10_POW[-scale];
3755                     }
3756                 }
3757             }
3758         }
3759         // Somewhat inefficient, but guaranteed to work.
3760         return Double.parseDouble(this.toString());
3761     }
3762 
3763     /**
3764      * Powers of 10 which can be represented exactly in {@code
3765      * double}.
3766      */
3767     private static final double DOUBLE_10_POW[] = {
3768         1.0e0,  1.0e1,  1.0e2,  1.0e3,  1.0e4,  1.0e5,
3769         1.0e6,  1.0e7,  1.0e8,  1.0e9,  1.0e10, 1.0e11,
3770         1.0e12, 1.0e13, 1.0e14, 1.0e15, 1.0e16, 1.0e17,
3771         1.0e18, 1.0e19, 1.0e20, 1.0e21, 1.0e22
3772     };
3773 
3774     /**
3775      * Powers of 10 which can be represented exactly in {@code
3776      * float}.
3777      */
3778     private static final float FLOAT_10_POW[] = {
3779         1.0e0f, 1.0e1f, 1.0e2f, 1.0e3f, 1.0e4f, 1.0e5f,
3780         1.0e6f, 1.0e7f, 1.0e8f, 1.0e9f, 1.0e10f
3781     };
3782 
3783     /**
3784      * Returns the size of an ulp, a unit in the last place, of this
3785      * {@code BigDecimal}.  An ulp of a nonzero {@code BigDecimal}
3786      * value is the positive distance between this value and the
3787      * {@code BigDecimal} value next larger in magnitude with the
3788      * same number of digits.  An ulp of a zero value is numerically
3789      * equal to 1 with the scale of {@code this}.  The result is
3790      * stored with the same scale as {@code this} so the result
3791      * for zero and nonzero values is equal to {@code [1,
3792      * this.scale()]}.
3793      *
3794      * @return the size of an ulp of {@code this}
3795      * @since 1.5
3796      */
3797     public BigDecimal ulp() {
3798         return BigDecimal.valueOf(1, this.scale(), 1);
3799     }
3800 
3801     // Private class to build a string representation for BigDecimal object.
3802     // &quot;StringBuilderHelper&quot; is constructed as a thread local variable so it is
3803     // thread safe. The StringBuilder field acts as a buffer to hold the temporary
3804     // representation of BigDecimal. The cmpCharArray holds all the characters for
3805     // the compact representation of BigDecimal (except for &#39;-&#39; sign&#39; if it is
3806     // negative) if its intCompact field is not INFLATED. It is shared by all
3807     // calls to toString() and its variants in that particular thread.
3808     static class StringBuilderHelper {
3809         final StringBuilder sb;    // Placeholder for BigDecimal string
3810         final char[] cmpCharArray; // character array to place the intCompact
3811 
3812         StringBuilderHelper() {
3813             sb = new StringBuilder();
3814             // All non negative longs can be made to fit into 19 character array.
3815             cmpCharArray = new char[19];
3816         }
3817 
3818         // Accessors.
3819         StringBuilder getStringBuilder() {
3820             sb.setLength(0);
3821             return sb;
3822         }
3823 
3824         char[] getCompactCharArray() {
3825             return cmpCharArray;
3826         }
3827 
3828         /**
3829          * Places characters representing the intCompact in {@code long} into
3830          * cmpCharArray and returns the offset to the array where the
3831          * representation starts.
3832          *
3833          * @param intCompact the number to put into the cmpCharArray.
3834          * @return offset to the array where the representation starts.
3835          * Note: intCompact must be greater or equal to zero.
3836          */
3837         int putIntCompact(long intCompact) {
3838             assert intCompact &gt;= 0;
3839 
3840             long q;
3841             int r;
3842             // since we start from the least significant digit, charPos points to
3843             // the last character in cmpCharArray.
3844             int charPos = cmpCharArray.length;
3845 
3846             // Get 2 digits/iteration using longs until quotient fits into an int
3847             while (intCompact &gt; Integer.MAX_VALUE) {
3848                 q = intCompact / 100;
3849                 r = (int)(intCompact - q * 100);
3850                 intCompact = q;
3851                 cmpCharArray[--charPos] = DIGIT_ONES[r];
3852                 cmpCharArray[--charPos] = DIGIT_TENS[r];
3853             }
3854 
3855             // Get 2 digits/iteration using ints when i2 &gt;= 100
3856             int q2;
3857             int i2 = (int)intCompact;
3858             while (i2 &gt;= 100) {
3859                 q2 = i2 / 100;
3860                 r  = i2 - q2 * 100;
3861                 i2 = q2;
3862                 cmpCharArray[--charPos] = DIGIT_ONES[r];
3863                 cmpCharArray[--charPos] = DIGIT_TENS[r];
3864             }
3865 
3866             cmpCharArray[--charPos] = DIGIT_ONES[i2];
3867             if (i2 &gt;= 10)
3868                 cmpCharArray[--charPos] = DIGIT_TENS[i2];
3869 
3870             return charPos;
3871         }
3872 
3873         static final char[] DIGIT_TENS = {
3874             &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;, &#39;0&#39;,
3875             &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;, &#39;1&#39;,
3876             &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;, &#39;2&#39;,
3877             &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;, &#39;3&#39;,
3878             &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;, &#39;4&#39;,
3879             &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;, &#39;5&#39;,
3880             &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;, &#39;6&#39;,
3881             &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;, &#39;7&#39;,
3882             &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;, &#39;8&#39;,
3883             &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;, &#39;9&#39;,
3884         };
3885 
3886         static final char[] DIGIT_ONES = {
3887             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3888             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3889             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3890             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3891             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3892             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3893             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3894             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3895             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3896             &#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;,
3897         };
3898     }
3899 
3900     /**
3901      * Lay out this {@code BigDecimal} into a {@code char[]} array.
3902      * The Java 1.2 equivalent to this was called {@code getValueString}.
3903      *
3904      * @param  sci {@code true} for Scientific exponential notation;
3905      *          {@code false} for Engineering
3906      * @return string with canonical string representation of this
3907      *         {@code BigDecimal}
3908      */
3909     private String layoutChars(boolean sci) {
3910         if (scale == 0)                      // zero scale is trivial
3911             return (intCompact != INFLATED) ?
3912                 Long.toString(intCompact):
3913                 intVal.toString();
3914         if (scale == 2  &amp;&amp;
3915             intCompact &gt;= 0 &amp;&amp; intCompact &lt; Integer.MAX_VALUE) {
3916             // currency fast path
3917             int lowInt = (int)intCompact % 100;
3918             int highInt = (int)intCompact / 100;
3919             return (Integer.toString(highInt) + &#39;.&#39; +
3920                     StringBuilderHelper.DIGIT_TENS[lowInt] +
3921                     StringBuilderHelper.DIGIT_ONES[lowInt]) ;
3922         }
3923 
3924         StringBuilderHelper sbHelper = threadLocalStringBuilderHelper.get();
3925         char[] coeff;
3926         int offset;  // offset is the starting index for coeff array
3927         // Get the significand as an absolute value
3928         if (intCompact != INFLATED) {
3929             offset = sbHelper.putIntCompact(Math.abs(intCompact));
3930             coeff  = sbHelper.getCompactCharArray();
3931         } else {
3932             offset = 0;
3933             coeff  = intVal.abs().toString().toCharArray();
3934         }
3935 
3936         // Construct a buffer, with sufficient capacity for all cases.
3937         // If E-notation is needed, length will be: +1 if negative, +1
3938         // if &#39;.&#39; needed, +2 for &quot;E+&quot;, + up to 10 for adjusted exponent.
3939         // Otherwise it could have +1 if negative, plus leading &quot;0.00000&quot;
3940         StringBuilder buf = sbHelper.getStringBuilder();
3941         if (signum() &lt; 0)             // prefix &#39;-&#39; if negative
3942             buf.append(&#39;-&#39;);
3943         int coeffLen = coeff.length - offset;
3944         long adjusted = -(long)scale + (coeffLen -1);
3945         if ((scale &gt;= 0) &amp;&amp; (adjusted &gt;= -6)) { // plain number
3946             int pad = scale - coeffLen;         // count of padding zeros
3947             if (pad &gt;= 0) {                     // 0.xxx form
3948                 buf.append(&#39;0&#39;);
3949                 buf.append(&#39;.&#39;);
3950                 for (; pad&gt;0; pad--) {
3951                     buf.append(&#39;0&#39;);
3952                 }
3953                 buf.append(coeff, offset, coeffLen);
3954             } else {                         // xx.xx form
3955                 buf.append(coeff, offset, -pad);
3956                 buf.append(&#39;.&#39;);
3957                 buf.append(coeff, -pad + offset, scale);
3958             }
3959         } else { // E-notation is needed
3960             if (sci) {                       // Scientific notation
3961                 buf.append(coeff[offset]);   // first character
3962                 if (coeffLen &gt; 1) {          // more to come
3963                     buf.append(&#39;.&#39;);
3964                     buf.append(coeff, offset + 1, coeffLen - 1);
3965                 }
3966             } else {                         // Engineering notation
3967                 int sig = (int)(adjusted % 3);
3968                 if (sig &lt; 0)
3969                     sig += 3;                // [adjusted was negative]
3970                 adjusted -= sig;             // now a multiple of 3
3971                 sig++;
3972                 if (signum() == 0) {
3973                     switch (sig) {
3974                     case 1:
3975                         buf.append(&#39;0&#39;); // exponent is a multiple of three
3976                         break;
3977                     case 2:
3978                         buf.append(&quot;0.00&quot;);
3979                         adjusted += 3;
3980                         break;
3981                     case 3:
3982                         buf.append(&quot;0.0&quot;);
3983                         adjusted += 3;
3984                         break;
3985                     default:
3986                         throw new AssertionError(&quot;Unexpected sig value &quot; + sig);
3987                     }
3988                 } else if (sig &gt;= coeffLen) {   // significand all in integer
3989                     buf.append(coeff, offset, coeffLen);
3990                     // may need some zeros, too
3991                     for (int i = sig - coeffLen; i &gt; 0; i--) {
3992                         buf.append(&#39;0&#39;);
3993                     }
3994                 } else {                     // xx.xxE form
3995                     buf.append(coeff, offset, sig);
3996                     buf.append(&#39;.&#39;);
3997                     buf.append(coeff, offset + sig, coeffLen - sig);
3998                 }
3999             }
4000             if (adjusted != 0) {             // [!sci could have made 0]
4001                 buf.append(&#39;E&#39;);
4002                 if (adjusted &gt; 0)            // force sign for positive
4003                     buf.append(&#39;+&#39;);
4004                 buf.append(adjusted);
4005             }
4006         }
4007         return buf.toString();
4008     }
4009 
4010     /**
4011      * Return 10 to the power n, as a {@code BigInteger}.
4012      *
4013      * @param  n the power of ten to be returned (&gt;=0)
4014      * @return a {@code BigInteger} with the value (10&lt;sup&gt;n&lt;/sup&gt;)
4015      */
4016     private static BigInteger bigTenToThe(int n) {
4017         if (n &lt; 0)
4018             return BigInteger.ZERO;
4019 
4020         if (n &lt; BIG_TEN_POWERS_TABLE_MAX) {
4021             BigInteger[] pows = BIG_TEN_POWERS_TABLE;
4022             if (n &lt; pows.length)
4023                 return pows[n];
4024             else
4025                 return expandBigIntegerTenPowers(n);
4026         }
4027 
4028         return BigInteger.TEN.pow(n);
4029     }
4030 
4031     /**
4032      * Expand the BIG_TEN_POWERS_TABLE array to contain at least 10**n.
4033      *
4034      * @param n the power of ten to be returned (&gt;=0)
4035      * @return a {@code BigDecimal} with the value (10&lt;sup&gt;n&lt;/sup&gt;) and
4036      *         in the meantime, the BIG_TEN_POWERS_TABLE array gets
4037      *         expanded to the size greater than n.
4038      */
4039     private static BigInteger expandBigIntegerTenPowers(int n) {
4040         synchronized(BigDecimal.class) {
4041             BigInteger[] pows = BIG_TEN_POWERS_TABLE;
4042             int curLen = pows.length;
4043             // The following comparison and the above synchronized statement is
4044             // to prevent multiple threads from expanding the same array.
4045             if (curLen &lt;= n) {
4046                 int newLen = curLen &lt;&lt; 1;
4047                 while (newLen &lt;= n) {
4048                     newLen &lt;&lt;= 1;
4049                 }
4050                 pows = Arrays.copyOf(pows, newLen);
4051                 for (int i = curLen; i &lt; newLen; i++) {
4052                     pows[i] = pows[i - 1].multiply(BigInteger.TEN);
4053                 }
4054                 // Based on the following facts:
4055                 // 1. pows is a private local varible;
4056                 // 2. the following store is a volatile store.
4057                 // the newly created array elements can be safely published.
4058                 BIG_TEN_POWERS_TABLE = pows;
4059             }
4060             return pows[n];
4061         }
4062     }
4063 
4064     private static final long[] LONG_TEN_POWERS_TABLE = {
4065         1,                     // 0 / 10^0
4066         10,                    // 1 / 10^1
4067         100,                   // 2 / 10^2
4068         1000,                  // 3 / 10^3
4069         10000,                 // 4 / 10^4
4070         100000,                // 5 / 10^5
4071         1000000,               // 6 / 10^6
4072         10000000,              // 7 / 10^7
4073         100000000,             // 8 / 10^8
4074         1000000000,            // 9 / 10^9
4075         10000000000L,          // 10 / 10^10
4076         100000000000L,         // 11 / 10^11
4077         1000000000000L,        // 12 / 10^12
4078         10000000000000L,       // 13 / 10^13
4079         100000000000000L,      // 14 / 10^14
4080         1000000000000000L,     // 15 / 10^15
4081         10000000000000000L,    // 16 / 10^16
4082         100000000000000000L,   // 17 / 10^17
4083         1000000000000000000L   // 18 / 10^18
4084     };
4085 
4086     private static volatile BigInteger BIG_TEN_POWERS_TABLE[] = {
4087         BigInteger.ONE,
4088         BigInteger.valueOf(10),
4089         BigInteger.valueOf(100),
4090         BigInteger.valueOf(1000),
4091         BigInteger.valueOf(10000),
4092         BigInteger.valueOf(100000),
4093         BigInteger.valueOf(1000000),
4094         BigInteger.valueOf(10000000),
4095         BigInteger.valueOf(100000000),
4096         BigInteger.valueOf(1000000000),
4097         BigInteger.valueOf(10000000000L),
4098         BigInteger.valueOf(100000000000L),
4099         BigInteger.valueOf(1000000000000L),
4100         BigInteger.valueOf(10000000000000L),
4101         BigInteger.valueOf(100000000000000L),
4102         BigInteger.valueOf(1000000000000000L),
4103         BigInteger.valueOf(10000000000000000L),
4104         BigInteger.valueOf(100000000000000000L),
4105         BigInteger.valueOf(1000000000000000000L)
4106     };
4107 
4108     private static final int BIG_TEN_POWERS_TABLE_INITLEN =
4109         BIG_TEN_POWERS_TABLE.length;
4110     private static final int BIG_TEN_POWERS_TABLE_MAX =
4111         16 * BIG_TEN_POWERS_TABLE_INITLEN;
4112 
4113     private static final long THRESHOLDS_TABLE[] = {
4114         Long.MAX_VALUE,                     // 0
4115         Long.MAX_VALUE/10L,                 // 1
4116         Long.MAX_VALUE/100L,                // 2
4117         Long.MAX_VALUE/1000L,               // 3
4118         Long.MAX_VALUE/10000L,              // 4
4119         Long.MAX_VALUE/100000L,             // 5
4120         Long.MAX_VALUE/1000000L,            // 6
4121         Long.MAX_VALUE/10000000L,           // 7
4122         Long.MAX_VALUE/100000000L,          // 8
4123         Long.MAX_VALUE/1000000000L,         // 9
4124         Long.MAX_VALUE/10000000000L,        // 10
4125         Long.MAX_VALUE/100000000000L,       // 11
4126         Long.MAX_VALUE/1000000000000L,      // 12
4127         Long.MAX_VALUE/10000000000000L,     // 13
4128         Long.MAX_VALUE/100000000000000L,    // 14
4129         Long.MAX_VALUE/1000000000000000L,   // 15
4130         Long.MAX_VALUE/10000000000000000L,  // 16
4131         Long.MAX_VALUE/100000000000000000L, // 17
4132         Long.MAX_VALUE/1000000000000000000L // 18
4133     };
4134 
4135     /**
4136      * Compute val * 10 ^ n; return this product if it is
4137      * representable as a long, INFLATED otherwise.
4138      */
4139     private static long longMultiplyPowerTen(long val, int n) {
4140         if (val == 0 || n &lt;= 0)
4141             return val;
4142         long[] tab = LONG_TEN_POWERS_TABLE;
4143         long[] bounds = THRESHOLDS_TABLE;
4144         if (n &lt; tab.length &amp;&amp; n &lt; bounds.length) {
4145             long tenpower = tab[n];
4146             if (val == 1)
4147                 return tenpower;
4148             if (Math.abs(val) &lt;= bounds[n])
4149                 return val * tenpower;
4150         }
4151         return INFLATED;
4152     }
4153 
4154     /**
4155      * Compute this * 10 ^ n.
4156      * Needed mainly to allow special casing to trap zero value
4157      */
4158     private BigInteger bigMultiplyPowerTen(int n) {
4159         if (n &lt;= 0)
4160             return this.inflated();
4161 
4162         if (intCompact != INFLATED)
4163             return bigTenToThe(n).multiply(intCompact);
4164         else
4165             return intVal.multiply(bigTenToThe(n));
4166     }
4167 
4168     /**
4169      * Returns appropriate BigInteger from intVal field if intVal is
4170      * null, i.e. the compact representation is in use.
4171      */
4172     private BigInteger inflated() {
4173         if (intVal == null) {
4174             return BigInteger.valueOf(intCompact);
4175         }
4176         return intVal;
4177     }
4178 
4179     /**
4180      * Match the scales of two {@code BigDecimal}s to align their
4181      * least significant digits.
4182      *
4183      * &lt;p&gt;If the scales of val[0] and val[1] differ, rescale
4184      * (non-destructively) the lower-scaled {@code BigDecimal} so
4185      * they match.  That is, the lower-scaled reference will be
4186      * replaced by a reference to a new object with the same scale as
4187      * the other {@code BigDecimal}.
4188      *
4189      * @param  val array of two elements referring to the two
4190      *         {@code BigDecimal}s to be aligned.
4191      */
4192     private static void matchScale(BigDecimal[] val) {
4193         if (val[0].scale &lt; val[1].scale) {
4194             val[0] = val[0].setScale(val[1].scale, ROUND_UNNECESSARY);
4195         } else if (val[1].scale &lt; val[0].scale) {
4196             val[1] = val[1].setScale(val[0].scale, ROUND_UNNECESSARY);
4197         }
4198     }
4199 
4200     private static class UnsafeHolder {
4201         private static final jdk.internal.misc.Unsafe unsafe
4202                 = jdk.internal.misc.Unsafe.getUnsafe();
4203         private static final long intCompactOffset
4204                 = unsafe.objectFieldOffset(BigDecimal.class, &quot;intCompact&quot;);
4205         private static final long intValOffset
4206                 = unsafe.objectFieldOffset(BigDecimal.class, &quot;intVal&quot;);
4207 
4208         static void setIntCompact(BigDecimal bd, long val) {
4209             unsafe.putLong(bd, intCompactOffset, val);
4210         }
4211 
4212         static void setIntValVolatile(BigDecimal bd, BigInteger val) {
4213             unsafe.putReferenceVolatile(bd, intValOffset, val);
4214         }
4215     }
4216 
4217     /**
4218      * Reconstitute the {@code BigDecimal} instance from a stream (that is,
4219      * deserialize it).
4220      *
4221      * @param s the stream being read.
4222      */
4223     @java.io.Serial
4224     private void readObject(java.io.ObjectInputStream s)
4225         throws java.io.IOException, ClassNotFoundException {
4226         // Read in all fields
4227         s.defaultReadObject();
4228         // validate possibly bad fields
4229         if (intVal == null) {
4230             String message = &quot;BigDecimal: null intVal in stream&quot;;
4231             throw new java.io.StreamCorruptedException(message);
4232         // [all values of scale are now allowed]
4233         }
4234         UnsafeHolder.setIntCompact(this, compactValFor(intVal));
4235     }
4236 
4237    /**
4238     * Serialize this {@code BigDecimal} to the stream in question
4239     *
4240     * @param s the stream to serialize to.
4241     */
4242     @java.io.Serial
4243    private void writeObject(java.io.ObjectOutputStream s)
4244        throws java.io.IOException {
4245        // Must inflate to maintain compatible serial form.
4246        if (this.intVal == null)
4247            UnsafeHolder.setIntValVolatile(this, BigInteger.valueOf(this.intCompact));
4248        // Could reset intVal back to null if it has to be set.
4249        s.defaultWriteObject();
4250    }
4251 
4252     /**
4253      * Returns the length of the absolute value of a {@code long}, in decimal
4254      * digits.
4255      *
4256      * @param x the {@code long}
4257      * @return the length of the unscaled value, in deciaml digits.
4258      */
4259     static int longDigitLength(long x) {
4260         /*
4261          * As described in &quot;Bit Twiddling Hacks&quot; by Sean Anderson,
4262          * (http://graphics.stanford.edu/~seander/bithacks.html)
4263          * integer log 10 of x is within 1 of (1233/4096)* (1 +
4264          * integer log 2 of x). The fraction 1233/4096 approximates
4265          * log10(2). So we first do a version of log2 (a variant of
4266          * Long class with pre-checks and opposite directionality) and
4267          * then scale and check against powers table. This is a little
4268          * simpler in present context than the version in Hacker&#39;s
4269          * Delight sec 11-4. Adding one to bit length allows comparing
4270          * downward from the LONG_TEN_POWERS_TABLE that we need
4271          * anyway.
4272          */
4273         assert x != BigDecimal.INFLATED;
4274         if (x &lt; 0)
4275             x = -x;
4276         if (x &lt; 10) // must screen for 0, might as well 10
4277             return 1;
4278         int r = ((64 - Long.numberOfLeadingZeros(x) + 1) * 1233) &gt;&gt;&gt; 12;
4279         long[] tab = LONG_TEN_POWERS_TABLE;
4280         // if r &gt;= length, must have max possible digits for long
4281         return (r &gt;= tab.length || x &lt; tab[r]) ? r : r + 1;
4282     }
4283 
4284     /**
4285      * Returns the length of the absolute value of a BigInteger, in
4286      * decimal digits.
4287      *
4288      * @param b the BigInteger
4289      * @return the length of the unscaled value, in decimal digits
4290      */
4291     private static int bigDigitLength(BigInteger b) {
4292         /*
4293          * Same idea as the long version, but we need a better
4294          * approximation of log10(2). Using 646456993/2^31
4295          * is accurate up to max possible reported bitLength.
4296          */
4297         if (b.signum == 0)
4298             return 1;
4299         int r = (int)((((long)b.bitLength() + 1) * 646456993) &gt;&gt;&gt; 31);
4300         return b.compareMagnitude(bigTenToThe(r)) &lt; 0? r : r+1;
4301     }
4302 
4303     /**
4304      * Check a scale for Underflow or Overflow.  If this BigDecimal is
4305      * nonzero, throw an exception if the scale is outof range. If this
4306      * is zero, saturate the scale to the extreme value of the right
4307      * sign if the scale is out of range.
4308      *
4309      * @param val The new scale.
4310      * @throws ArithmeticException (overflow or underflow) if the new
4311      *         scale is out of range.
4312      * @return validated scale as an int.
4313      */
4314     private int checkScale(long val) {
4315         int asInt = (int)val;
4316         if (asInt != val) {
4317             asInt = val&gt;Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;
4318             BigInteger b;
4319             if (intCompact != 0 &amp;&amp;
4320                 ((b = intVal) == null || b.signum() != 0))
4321                 throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);
4322         }
4323         return asInt;
4324     }
4325 
<a name="4" id="anc4"></a><span class="line-modified">4326    /**</span>
4327      * Returns the compact value for given {@code BigInteger}, or
4328      * INFLATED if too big. Relies on internal representation of
4329      * {@code BigInteger}.
4330      */
4331     private static long compactValFor(BigInteger b) {
4332         int[] m = b.mag;
4333         int len = m.length;
4334         if (len == 0)
4335             return 0;
4336         int d = m[0];
4337         if (len &gt; 2 || (len == 2 &amp;&amp; d &lt; 0))
4338             return INFLATED;
4339 
4340         long u = (len == 2)?
4341             (((long) m[1] &amp; LONG_MASK) + (((long)d) &lt;&lt; 32)) :
4342             (((long)d)   &amp; LONG_MASK);
4343         return (b.signum &lt; 0)? -u : u;
4344     }
4345 
4346     private static int longCompareMagnitude(long x, long y) {
4347         if (x &lt; 0)
4348             x = -x;
4349         if (y &lt; 0)
4350             y = -y;
4351         return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);
4352     }
4353 
4354     private static int saturateLong(long s) {
4355         int i = (int)s;
4356         return (s == i) ? i : (s &lt; 0 ? Integer.MIN_VALUE : Integer.MAX_VALUE);
4357     }
4358 
4359     /*
4360      * Internal printing routine
4361      */
4362     private static void print(String name, BigDecimal bd) {
4363         System.err.format(&quot;%s:\tintCompact %d\tintVal %d\tscale %d\tprecision %d%n&quot;,
4364                           name,
4365                           bd.intCompact,
4366                           bd.intVal,
4367                           bd.scale,
4368                           bd.precision);
4369     }
4370 
4371     /**
4372      * Check internal invariants of this BigDecimal.  These invariants
4373      * include:
4374      *
4375      * &lt;ul&gt;
4376      *
4377      * &lt;li&gt;The object must be initialized; either intCompact must not be
4378      * INFLATED or intVal is non-null.  Both of these conditions may
4379      * be true.
4380      *
4381      * &lt;li&gt;If both intCompact and intVal and set, their values must be
4382      * consistent.
4383      *
4384      * &lt;li&gt;If precision is nonzero, it must have the right value.
4385      * &lt;/ul&gt;
4386      *
4387      * Note: Since this is an audit method, we are not supposed to change the
4388      * state of this BigDecimal object.
4389      */
4390     private BigDecimal audit() {
4391         if (intCompact == INFLATED) {
4392             if (intVal == null) {
4393                 print(&quot;audit&quot;, this);
4394                 throw new AssertionError(&quot;null intVal&quot;);
4395             }
4396             // Check precision
4397             if (precision &gt; 0 &amp;&amp; precision != bigDigitLength(intVal)) {
4398                 print(&quot;audit&quot;, this);
4399                 throw new AssertionError(&quot;precision mismatch&quot;);
4400             }
4401         } else {
4402             if (intVal != null) {
4403                 long val = intVal.longValue();
4404                 if (val != intCompact) {
4405                     print(&quot;audit&quot;, this);
4406                     throw new AssertionError(&quot;Inconsistent state, intCompact=&quot; +
4407                                              intCompact + &quot;\t intVal=&quot; + val);
4408                 }
4409             }
4410             // Check precision
4411             if (precision &gt; 0 &amp;&amp; precision != longDigitLength(intCompact)) {
4412                 print(&quot;audit&quot;, this);
4413                 throw new AssertionError(&quot;precision mismatch&quot;);
4414             }
4415         }
4416         return this;
4417     }
4418 
4419     /* the same as checkScale where value!=0 */
4420     private static int checkScaleNonZero(long val) {
4421         int asInt = (int)val;
4422         if (asInt != val) {
4423             throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);
4424         }
4425         return asInt;
4426     }
4427 
4428     private static int checkScale(long intCompact, long val) {
4429         int asInt = (int)val;
4430         if (asInt != val) {
4431             asInt = val&gt;Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;
4432             if (intCompact != 0)
4433                 throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);
4434         }
4435         return asInt;
4436     }
4437 
4438     private static int checkScale(BigInteger intVal, long val) {
4439         int asInt = (int)val;
4440         if (asInt != val) {
4441             asInt = val&gt;Integer.MAX_VALUE ? Integer.MAX_VALUE : Integer.MIN_VALUE;
4442             if (intVal.signum() != 0)
4443                 throw new ArithmeticException(asInt&gt;0 ? &quot;Underflow&quot;:&quot;Overflow&quot;);
4444         }
4445         return asInt;
4446     }
4447 
4448     /**
4449      * Returns a {@code BigDecimal} rounded according to the MathContext
4450      * settings;
4451      * If rounding is needed a new {@code BigDecimal} is created and returned.
4452      *
4453      * @param val the value to be rounded
4454      * @param mc the context to use.
4455      * @return a {@code BigDecimal} rounded according to the MathContext
4456      *         settings.  May return {@code value}, if no rounding needed.
4457      * @throws ArithmeticException if the rounding mode is
4458      *         {@code RoundingMode.UNNECESSARY} and the
4459      *         result is inexact.
4460      */
4461     private static BigDecimal doRound(BigDecimal val, MathContext mc) {
4462         int mcp = mc.precision;
4463         boolean wasDivided = false;
4464         if (mcp &gt; 0) {
4465             BigInteger intVal = val.intVal;
4466             long compactVal = val.intCompact;
4467             int scale = val.scale;
4468             int prec = val.precision();
4469             int mode = mc.roundingMode.oldMode;
4470             int drop;
4471             if (compactVal == INFLATED) {
4472                 drop = prec - mcp;
4473                 while (drop &gt; 0) {
4474                     scale = checkScaleNonZero((long) scale - drop);
4475                     intVal = divideAndRoundByTenPow(intVal, drop, mode);
4476                     wasDivided = true;
4477                     compactVal = compactValFor(intVal);
4478                     if (compactVal != INFLATED) {
4479                         prec = longDigitLength(compactVal);
4480                         break;
4481                     }
4482                     prec = bigDigitLength(intVal);
4483                     drop = prec - mcp;
4484                 }
4485             }
4486             if (compactVal != INFLATED) {
4487                 drop = prec - mcp;  // drop can&#39;t be more than 18
4488                 while (drop &gt; 0) {
4489                     scale = checkScaleNonZero((long) scale - drop);
4490                     compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
4491                     wasDivided = true;
4492                     prec = longDigitLength(compactVal);
4493                     drop = prec - mcp;
4494                     intVal = null;
4495                 }
4496             }
4497             return wasDivided ? new BigDecimal(intVal,compactVal,scale,prec) : val;
4498         }
4499         return val;
4500     }
4501 
4502     /*
4503      * Returns a {@code BigDecimal} created from {@code long} value with
4504      * given scale rounded according to the MathContext settings
4505      */
4506     private static BigDecimal doRound(long compactVal, int scale, MathContext mc) {
4507         int mcp = mc.precision;
4508         if (mcp &gt; 0 &amp;&amp; mcp &lt; 19) {
4509             int prec = longDigitLength(compactVal);
4510             int drop = prec - mcp;  // drop can&#39;t be more than 18
4511             while (drop &gt; 0) {
4512                 scale = checkScaleNonZero((long) scale - drop);
4513                 compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
4514                 prec = longDigitLength(compactVal);
4515                 drop = prec - mcp;
4516             }
4517             return valueOf(compactVal, scale, prec);
4518         }
4519         return valueOf(compactVal, scale);
4520     }
4521 
4522     /*
4523      * Returns a {@code BigDecimal} created from {@code BigInteger} value with
4524      * given scale rounded according to the MathContext settings
4525      */
4526     private static BigDecimal doRound(BigInteger intVal, int scale, MathContext mc) {
4527         int mcp = mc.precision;
4528         int prec = 0;
4529         if (mcp &gt; 0) {
4530             long compactVal = compactValFor(intVal);
4531             int mode = mc.roundingMode.oldMode;
4532             int drop;
4533             if (compactVal == INFLATED) {
4534                 prec = bigDigitLength(intVal);
4535                 drop = prec - mcp;
4536                 while (drop &gt; 0) {
4537                     scale = checkScaleNonZero((long) scale - drop);
4538                     intVal = divideAndRoundByTenPow(intVal, drop, mode);
4539                     compactVal = compactValFor(intVal);
4540                     if (compactVal != INFLATED) {
4541                         break;
4542                     }
4543                     prec = bigDigitLength(intVal);
4544                     drop = prec - mcp;
4545                 }
4546             }
4547             if (compactVal != INFLATED) {
4548                 prec = longDigitLength(compactVal);
4549                 drop = prec - mcp;     // drop can&#39;t be more than 18
4550                 while (drop &gt; 0) {
4551                     scale = checkScaleNonZero((long) scale - drop);
4552                     compactVal = divideAndRound(compactVal, LONG_TEN_POWERS_TABLE[drop], mc.roundingMode.oldMode);
4553                     prec = longDigitLength(compactVal);
4554                     drop = prec - mcp;
4555                 }
4556                 return valueOf(compactVal,scale,prec);
4557             }
4558         }
4559         return new BigDecimal(intVal,INFLATED,scale,prec);
4560     }
4561 
4562     /*
4563      * Divides {@code BigInteger} value by ten power.
4564      */
4565     private static BigInteger divideAndRoundByTenPow(BigInteger intVal, int tenPow, int roundingMode) {
4566         if (tenPow &lt; LONG_TEN_POWERS_TABLE.length)
4567             intVal = divideAndRound(intVal, LONG_TEN_POWERS_TABLE[tenPow], roundingMode);
4568         else
4569             intVal = divideAndRound(intVal, bigTenToThe(tenPow), roundingMode);
4570         return intVal;
4571     }
4572 
4573     /**
4574      * Internally used for division operation for division {@code long} by
4575      * {@code long}.
4576      * The returned {@code BigDecimal} object is the quotient whose scale is set
4577      * to the passed in scale. If the remainder is not zero, it will be rounded
4578      * based on the passed in roundingMode. Also, if the remainder is zero and
4579      * the last parameter, i.e. preferredScale is NOT equal to scale, the
4580      * trailing zeros of the result is stripped to match the preferredScale.
4581      */
4582     private static BigDecimal divideAndRound(long ldividend, long ldivisor, int scale, int roundingMode,
4583                                              int preferredScale) {
4584 
4585         int qsign; // quotient sign
4586         long q = ldividend / ldivisor; // store quotient in long
4587         if (roundingMode == ROUND_DOWN &amp;&amp; scale == preferredScale)
4588             return valueOf(q, scale);
4589         long r = ldividend % ldivisor; // store remainder in long
4590         qsign = ((ldividend &lt; 0) == (ldivisor &lt; 0)) ? 1 : -1;
4591         if (r != 0) {
4592             boolean increment = needIncrement(ldivisor, roundingMode, qsign, q, r);
4593             return valueOf((increment ? q + qsign : q), scale);
4594         } else {
4595             if (preferredScale != scale)
4596                 return createAndStripZerosToMatchScale(q, scale, preferredScale);
4597             else
4598                 return valueOf(q, scale);
4599         }
4600     }
4601 
4602     /**
4603      * Divides {@code long} by {@code long} and do rounding based on the
4604      * passed in roundingMode.
4605      */
4606     private static long divideAndRound(long ldividend, long ldivisor, int roundingMode) {
4607         int qsign; // quotient sign
4608         long q = ldividend / ldivisor; // store quotient in long
4609         if (roundingMode == ROUND_DOWN)
4610             return q;
4611         long r = ldividend % ldivisor; // store remainder in long
4612         qsign = ((ldividend &lt; 0) == (ldivisor &lt; 0)) ? 1 : -1;
4613         if (r != 0) {
4614             boolean increment = needIncrement(ldivisor, roundingMode, qsign, q,     r);
4615             return increment ? q + qsign : q;
4616         } else {
4617             return q;
4618         }
4619     }
4620 
4621     /**
4622      * Shared logic of need increment computation.
4623      */
4624     private static boolean commonNeedIncrement(int roundingMode, int qsign,
4625                                         int cmpFracHalf, boolean oddQuot) {
4626         switch(roundingMode) {
4627         case ROUND_UNNECESSARY:
4628             throw new ArithmeticException(&quot;Rounding necessary&quot;);
4629 
4630         case ROUND_UP: // Away from zero
4631             return true;
4632 
4633         case ROUND_DOWN: // Towards zero
4634             return false;
4635 
4636         case ROUND_CEILING: // Towards +infinity
4637             return qsign &gt; 0;
4638 
4639         case ROUND_FLOOR: // Towards -infinity
4640             return qsign &lt; 0;
4641 
4642         default: // Some kind of half-way rounding
4643             assert roundingMode &gt;= ROUND_HALF_UP &amp;&amp;
4644                 roundingMode &lt;= ROUND_HALF_EVEN: &quot;Unexpected rounding mode&quot; + RoundingMode.valueOf(roundingMode);
4645 
4646             if (cmpFracHalf &lt; 0 ) // We&#39;re closer to higher digit
4647                 return false;
4648             else if (cmpFracHalf &gt; 0 ) // We&#39;re closer to lower digit
4649                 return true;
4650             else { // half-way
4651                 assert cmpFracHalf == 0;
4652 
4653                 switch(roundingMode) {
4654                 case ROUND_HALF_DOWN:
4655                     return false;
4656 
4657                 case ROUND_HALF_UP:
4658                     return true;
4659 
4660                 case ROUND_HALF_EVEN:
4661                     return oddQuot;
4662 
4663                 default:
4664                     throw new AssertionError(&quot;Unexpected rounding mode&quot; + roundingMode);
4665                 }
4666             }
4667         }
4668     }
4669 
4670     /**
4671      * Tests if quotient has to be incremented according the roundingMode
4672      */
4673     private static boolean needIncrement(long ldivisor, int roundingMode,
4674                                          int qsign, long q, long r) {
4675         assert r != 0L;
4676 
4677         int cmpFracHalf;
4678         if (r &lt;= HALF_LONG_MIN_VALUE || r &gt; HALF_LONG_MAX_VALUE) {
4679             cmpFracHalf = 1; // 2 * r can&#39;t fit into long
4680         } else {
4681             cmpFracHalf = longCompareMagnitude(2 * r, ldivisor);
4682         }
4683 
4684         return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, (q &amp; 1L) != 0L);
4685     }
4686 
4687     /**
4688      * Divides {@code BigInteger} value by {@code long} value and
4689      * do rounding based on the passed in roundingMode.
4690      */
4691     private static BigInteger divideAndRound(BigInteger bdividend, long ldivisor, int roundingMode) {
4692         // Descend into mutables for faster remainder checks
4693         MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);
4694         // store quotient
4695         MutableBigInteger mq = new MutableBigInteger();
4696         // store quotient &amp; remainder in long
4697         long r = mdividend.divide(ldivisor, mq);
4698         // record remainder is zero or not
4699         boolean isRemainderZero = (r == 0);
4700         // quotient sign
4701         int qsign = (ldivisor &lt; 0) ? -bdividend.signum : bdividend.signum;
4702         if (!isRemainderZero) {
4703             if(needIncrement(ldivisor, roundingMode, qsign, mq, r)) {
4704                 mq.add(MutableBigInteger.ONE);
4705             }
4706         }
4707         return mq.toBigInteger(qsign);
4708     }
4709 
4710     /**
4711      * Internally used for division operation for division {@code BigInteger}
4712      * by {@code long}.
4713      * The returned {@code BigDecimal} object is the quotient whose scale is set
4714      * to the passed in scale. If the remainder is not zero, it will be rounded
4715      * based on the passed in roundingMode. Also, if the remainder is zero and
4716      * the last parameter, i.e. preferredScale is NOT equal to scale, the
4717      * trailing zeros of the result is stripped to match the preferredScale.
4718      */
4719     private static BigDecimal divideAndRound(BigInteger bdividend,
4720                                              long ldivisor, int scale, int roundingMode, int preferredScale) {
4721         // Descend into mutables for faster remainder checks
4722         MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);
4723         // store quotient
4724         MutableBigInteger mq = new MutableBigInteger();
4725         // store quotient &amp; remainder in long
4726         long r = mdividend.divide(ldivisor, mq);
4727         // record remainder is zero or not
4728         boolean isRemainderZero = (r == 0);
4729         // quotient sign
4730         int qsign = (ldivisor &lt; 0) ? -bdividend.signum : bdividend.signum;
4731         if (!isRemainderZero) {
4732             if(needIncrement(ldivisor, roundingMode, qsign, mq, r)) {
4733                 mq.add(MutableBigInteger.ONE);
4734             }
4735             return mq.toBigDecimal(qsign, scale);
4736         } else {
4737             if (preferredScale != scale) {
4738                 long compactVal = mq.toCompactValue(qsign);
4739                 if(compactVal!=INFLATED) {
4740                     return createAndStripZerosToMatchScale(compactVal, scale, preferredScale);
4741                 }
4742                 BigInteger intVal =  mq.toBigInteger(qsign);
4743                 return createAndStripZerosToMatchScale(intVal,scale, preferredScale);
4744             } else {
4745                 return mq.toBigDecimal(qsign, scale);
4746             }
4747         }
4748     }
4749 
4750     /**
4751      * Tests if quotient has to be incremented according the roundingMode
4752      */
4753     private static boolean needIncrement(long ldivisor, int roundingMode,
4754                                          int qsign, MutableBigInteger mq, long r) {
4755         assert r != 0L;
4756 
4757         int cmpFracHalf;
4758         if (r &lt;= HALF_LONG_MIN_VALUE || r &gt; HALF_LONG_MAX_VALUE) {
4759             cmpFracHalf = 1; // 2 * r can&#39;t fit into long
4760         } else {
4761             cmpFracHalf = longCompareMagnitude(2 * r, ldivisor);
4762         }
4763 
4764         return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.isOdd());
4765     }
4766 
4767     /**
4768      * Divides {@code BigInteger} value by {@code BigInteger} value and
4769      * do rounding based on the passed in roundingMode.
4770      */
4771     private static BigInteger divideAndRound(BigInteger bdividend, BigInteger bdivisor, int roundingMode) {
4772         boolean isRemainderZero; // record remainder is zero or not
4773         int qsign; // quotient sign
4774         // Descend into mutables for faster remainder checks
4775         MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);
4776         MutableBigInteger mq = new MutableBigInteger();
4777         MutableBigInteger mdivisor = new MutableBigInteger(bdivisor.mag);
4778         MutableBigInteger mr = mdividend.divide(mdivisor, mq);
4779         isRemainderZero = mr.isZero();
4780         qsign = (bdividend.signum != bdivisor.signum) ? -1 : 1;
4781         if (!isRemainderZero) {
4782             if (needIncrement(mdivisor, roundingMode, qsign, mq, mr)) {
4783                 mq.add(MutableBigInteger.ONE);
4784             }
4785         }
4786         return mq.toBigInteger(qsign);
4787     }
4788 
4789     /**
4790      * Internally used for division operation for division {@code BigInteger}
4791      * by {@code BigInteger}.
4792      * The returned {@code BigDecimal} object is the quotient whose scale is set
4793      * to the passed in scale. If the remainder is not zero, it will be rounded
4794      * based on the passed in roundingMode. Also, if the remainder is zero and
4795      * the last parameter, i.e. preferredScale is NOT equal to scale, the
4796      * trailing zeros of the result is stripped to match the preferredScale.
4797      */
4798     private static BigDecimal divideAndRound(BigInteger bdividend, BigInteger bdivisor, int scale, int roundingMode,
4799                                              int preferredScale) {
4800         boolean isRemainderZero; // record remainder is zero or not
4801         int qsign; // quotient sign
4802         // Descend into mutables for faster remainder checks
4803         MutableBigInteger mdividend = new MutableBigInteger(bdividend.mag);
4804         MutableBigInteger mq = new MutableBigInteger();
4805         MutableBigInteger mdivisor = new MutableBigInteger(bdivisor.mag);
4806         MutableBigInteger mr = mdividend.divide(mdivisor, mq);
4807         isRemainderZero = mr.isZero();
4808         qsign = (bdividend.signum != bdivisor.signum) ? -1 : 1;
4809         if (!isRemainderZero) {
4810             if (needIncrement(mdivisor, roundingMode, qsign, mq, mr)) {
4811                 mq.add(MutableBigInteger.ONE);
4812             }
4813             return mq.toBigDecimal(qsign, scale);
4814         } else {
4815             if (preferredScale != scale) {
4816                 long compactVal = mq.toCompactValue(qsign);
4817                 if (compactVal != INFLATED) {
4818                     return createAndStripZerosToMatchScale(compactVal, scale, preferredScale);
4819                 }
4820                 BigInteger intVal = mq.toBigInteger(qsign);
4821                 return createAndStripZerosToMatchScale(intVal, scale, preferredScale);
4822             } else {
4823                 return mq.toBigDecimal(qsign, scale);
4824             }
4825         }
4826     }
4827 
4828     /**
4829      * Tests if quotient has to be incremented according the roundingMode
4830      */
4831     private static boolean needIncrement(MutableBigInteger mdivisor, int roundingMode,
4832                                          int qsign, MutableBigInteger mq, MutableBigInteger mr) {
4833         assert !mr.isZero();
4834         int cmpFracHalf = mr.compareHalf(mdivisor);
4835         return commonNeedIncrement(roundingMode, qsign, cmpFracHalf, mq.isOdd());
4836     }
4837 
4838     /**
4839      * Remove insignificant trailing zeros from this
4840      * {@code BigInteger} value until the preferred scale is reached or no
4841      * more zeros can be removed.  If the preferred scale is less than
4842      * Integer.MIN_VALUE, all the trailing zeros will be removed.
4843      *
4844      * @return new {@code BigDecimal} with a scale possibly reduced
4845      * to be closed to the preferred scale.
4846      */
4847     private static BigDecimal createAndStripZerosToMatchScale(BigInteger intVal, int scale, long preferredScale) {
4848         BigInteger qr[]; // quotient-remainder pair
4849         while (intVal.compareMagnitude(BigInteger.TEN) &gt;= 0
4850                &amp;&amp; scale &gt; preferredScale) {
4851             if (intVal.testBit(0))
4852                 break; // odd number cannot end in 0
4853             qr = intVal.divideAndRemainder(BigInteger.TEN);
4854             if (qr[1].signum() != 0)
4855                 break; // non-0 remainder
4856             intVal = qr[0];
4857             scale = checkScale(intVal,(long) scale - 1); // could Overflow
4858         }
4859         return valueOf(intVal, scale, 0);
4860     }
4861 
4862     /**
4863      * Remove insignificant trailing zeros from this
4864      * {@code long} value until the preferred scale is reached or no
4865      * more zeros can be removed.  If the preferred scale is less than
4866      * Integer.MIN_VALUE, all the trailing zeros will be removed.
4867      *
4868      * @return new {@code BigDecimal} with a scale possibly reduced
4869      * to be closed to the preferred scale.
4870      */
4871     private static BigDecimal createAndStripZerosToMatchScale(long compactVal, int scale, long preferredScale) {
4872         while (Math.abs(compactVal) &gt;= 10L &amp;&amp; scale &gt; preferredScale) {
4873             if ((compactVal &amp; 1L) != 0L)
4874                 break; // odd number cannot end in 0
4875             long r = compactVal % 10L;
4876             if (r != 0L)
4877                 break; // non-0 remainder
4878             compactVal /= 10;
4879             scale = checkScale(compactVal, (long) scale - 1); // could Overflow
4880         }
4881         return valueOf(compactVal, scale);
4882     }
4883 
4884     private static BigDecimal stripZerosToMatchScale(BigInteger intVal, long intCompact, int scale, int preferredScale) {
4885         if(intCompact!=INFLATED) {
4886             return createAndStripZerosToMatchScale(intCompact, scale, preferredScale);
4887         } else {
4888             return createAndStripZerosToMatchScale(intVal==null ? INFLATED_BIGINT : intVal,
4889                                                    scale, preferredScale);
4890         }
4891     }
4892 
4893     /*
4894      * returns INFLATED if oveflow
4895      */
4896     private static long add(long xs, long ys){
4897         long sum = xs + ys;
4898         // See &quot;Hacker&#39;s Delight&quot; section 2-12 for explanation of
4899         // the overflow test.
4900         if ( (((sum ^ xs) &amp; (sum ^ ys))) &gt;= 0L) { // not overflowed
4901             return sum;
4902         }
4903         return INFLATED;
4904     }
4905 
4906     private static BigDecimal add(long xs, long ys, int scale){
4907         long sum = add(xs, ys);
4908         if (sum!=INFLATED)
4909             return BigDecimal.valueOf(sum, scale);
4910         return new BigDecimal(BigInteger.valueOf(xs).add(ys), scale);
4911     }
4912 
4913     private static BigDecimal add(final long xs, int scale1, final long ys, int scale2) {
4914         long sdiff = (long) scale1 - scale2;
4915         if (sdiff == 0) {
4916             return add(xs, ys, scale1);
4917         } else if (sdiff &lt; 0) {
4918             int raise = checkScale(xs,-sdiff);
4919             long scaledX = longMultiplyPowerTen(xs, raise);
4920             if (scaledX != INFLATED) {
4921                 return add(scaledX, ys, scale2);
4922             } else {
4923                 BigInteger bigsum = bigMultiplyPowerTen(xs,raise).add(ys);
4924                 return ((xs^ys)&gt;=0) ? // same sign test
4925                     new BigDecimal(bigsum, INFLATED, scale2, 0)
4926                     : valueOf(bigsum, scale2, 0);
4927             }
4928         } else {
4929             int raise = checkScale(ys,sdiff);
4930             long scaledY = longMultiplyPowerTen(ys, raise);
4931             if (scaledY != INFLATED) {
4932                 return add(xs, scaledY, scale1);
4933             } else {
4934                 BigInteger bigsum = bigMultiplyPowerTen(ys,raise).add(xs);
4935                 return ((xs^ys)&gt;=0) ?
4936                     new BigDecimal(bigsum, INFLATED, scale1, 0)
4937                     : valueOf(bigsum, scale1, 0);
4938             }
4939         }
4940     }
4941 
4942     private static BigDecimal add(final long xs, int scale1, BigInteger snd, int scale2) {
4943         int rscale = scale1;
4944         long sdiff = (long)rscale - scale2;
4945         boolean sameSigns =  (Long.signum(xs) == snd.signum);
4946         BigInteger sum;
4947         if (sdiff &lt; 0) {
4948             int raise = checkScale(xs,-sdiff);
4949             rscale = scale2;
4950             long scaledX = longMultiplyPowerTen(xs, raise);
4951             if (scaledX == INFLATED) {
4952                 sum = snd.add(bigMultiplyPowerTen(xs,raise));
4953             } else {
4954                 sum = snd.add(scaledX);
4955             }
4956         } else { //if (sdiff &gt; 0) {
4957             int raise = checkScale(snd,sdiff);
4958             snd = bigMultiplyPowerTen(snd,raise);
4959             sum = snd.add(xs);
4960         }
4961         return (sameSigns) ?
4962             new BigDecimal(sum, INFLATED, rscale, 0) :
4963             valueOf(sum, rscale, 0);
4964     }
4965 
4966     private static BigDecimal add(BigInteger fst, int scale1, BigInteger snd, int scale2) {
4967         int rscale = scale1;
4968         long sdiff = (long)rscale - scale2;
4969         if (sdiff != 0) {
4970             if (sdiff &lt; 0) {
4971                 int raise = checkScale(fst,-sdiff);
4972                 rscale = scale2;
4973                 fst = bigMultiplyPowerTen(fst,raise);
4974             } else {
4975                 int raise = checkScale(snd,sdiff);
4976                 snd = bigMultiplyPowerTen(snd,raise);
4977             }
4978         }
4979         BigInteger sum = fst.add(snd);
4980         return (fst.signum == snd.signum) ?
4981                 new BigDecimal(sum, INFLATED, rscale, 0) :
4982                 valueOf(sum, rscale, 0);
4983     }
4984 
4985     private static BigInteger bigMultiplyPowerTen(long value, int n) {
4986         if (n &lt;= 0)
4987             return BigInteger.valueOf(value);
4988         return bigTenToThe(n).multiply(value);
4989     }
4990 
4991     private static BigInteger bigMultiplyPowerTen(BigInteger value, int n) {
4992         if (n &lt;= 0)
4993             return value;
4994         if(n&lt;LONG_TEN_POWERS_TABLE.length) {
4995                 return value.multiply(LONG_TEN_POWERS_TABLE[n]);
4996         }
4997         return value.multiply(bigTenToThe(n));
4998     }
4999 
5000     /**
5001      * Returns a {@code BigDecimal} whose value is {@code (xs /
5002      * ys)}, with rounding according to the context settings.
5003      *
5004      * Fast path - used only when (xscale &lt;= yscale &amp;&amp; yscale &lt; 18
5005      *  &amp;&amp; mc.presision&lt;18) {
5006      */
5007     private static BigDecimal divideSmallFastPath(final long xs, int xscale,
5008                                                   final long ys, int yscale,
5009                                                   long preferredScale, MathContext mc) {
5010         int mcp = mc.precision;
5011         int roundingMode = mc.roundingMode.oldMode;
5012 
5013         assert (xscale &lt;= yscale) &amp;&amp; (yscale &lt; 18) &amp;&amp; (mcp &lt; 18);
5014         int xraise = yscale - xscale; // xraise &gt;=0
5015         long scaledX = (xraise==0) ? xs :
5016             longMultiplyPowerTen(xs, xraise); // can&#39;t overflow here!
5017         BigDecimal quotient;
5018 
5019         int cmp = longCompareMagnitude(scaledX, ys);
5020         if(cmp &gt; 0) { // satisfy constraint (b)
5021             yscale -= 1; // [that is, divisor *= 10]
5022             int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);
5023             if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {
5024                 // assert newScale &gt;= xscale
5025                 int raise = checkScaleNonZero((long) mcp + yscale - xscale);
5026                 long scaledXs;
5027                 if ((scaledXs = longMultiplyPowerTen(xs, raise)) == INFLATED) {
5028                     quotient = null;
5029                     if((mcp-1) &gt;=0 &amp;&amp; (mcp-1)&lt;LONG_TEN_POWERS_TABLE.length) {
5030                         quotient = multiplyDivideAndRound(LONG_TEN_POWERS_TABLE[mcp-1], scaledX, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5031                     }
5032                     if(quotient==null) {
5033                         BigInteger rb = bigMultiplyPowerTen(scaledX,mcp-1);
5034                         quotient = divideAndRound(rb, ys,
5035                                                   scl, roundingMode, checkScaleNonZero(preferredScale));
5036                     }
5037                 } else {
5038                     quotient = divideAndRound(scaledXs, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5039                 }
5040             } else {
5041                 int newScale = checkScaleNonZero((long) xscale - mcp);
5042                 // assert newScale &gt;= yscale
5043                 if (newScale == yscale) { // easy case
5044                     quotient = divideAndRound(xs, ys, scl, roundingMode,checkScaleNonZero(preferredScale));
5045                 } else {
5046                     int raise = checkScaleNonZero((long) newScale - yscale);
5047                     long scaledYs;
5048                     if ((scaledYs = longMultiplyPowerTen(ys, raise)) == INFLATED) {
5049                         BigInteger rb = bigMultiplyPowerTen(ys,raise);
5050                         quotient = divideAndRound(BigInteger.valueOf(xs),
5051                                                   rb, scl, roundingMode,checkScaleNonZero(preferredScale));
5052                     } else {
5053                         quotient = divideAndRound(xs, scaledYs, scl, roundingMode,checkScaleNonZero(preferredScale));
5054                     }
5055                 }
5056             }
5057         } else {
5058             // abs(scaledX) &lt;= abs(ys)
5059             // result is &quot;scaledX * 10^msp / ys&quot;
5060             int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);
5061             if(cmp==0) {
5062                 // abs(scaleX)== abs(ys) =&gt; result will be scaled 10^mcp + correct sign
5063                 quotient = roundedTenPower(((scaledX &lt; 0) == (ys &lt; 0)) ? 1 : -1, mcp, scl, checkScaleNonZero(preferredScale));
5064             } else {
5065                 // abs(scaledX) &lt; abs(ys)
5066                 long scaledXs;
5067                 if ((scaledXs = longMultiplyPowerTen(scaledX, mcp)) == INFLATED) {
5068                     quotient = null;
5069                     if(mcp&lt;LONG_TEN_POWERS_TABLE.length) {
5070                         quotient = multiplyDivideAndRound(LONG_TEN_POWERS_TABLE[mcp], scaledX, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5071                     }
5072                     if(quotient==null) {
5073                         BigInteger rb = bigMultiplyPowerTen(scaledX,mcp);
5074                         quotient = divideAndRound(rb, ys,
5075                                                   scl, roundingMode, checkScaleNonZero(preferredScale));
5076                     }
5077                 } else {
5078                     quotient = divideAndRound(scaledXs, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5079                 }
5080             }
5081         }
5082         // doRound, here, only affects 1000000000 case.
5083         return doRound(quotient,mc);
5084     }
5085 
5086     /**
5087      * Returns a {@code BigDecimal} whose value is {@code (xs /
5088      * ys)}, with rounding according to the context settings.
5089      */
5090     private static BigDecimal divide(final long xs, int xscale, final long ys, int yscale, long preferredScale, MathContext mc) {
5091         int mcp = mc.precision;
5092         if(xscale &lt;= yscale &amp;&amp; yscale &lt; 18 &amp;&amp; mcp&lt;18) {
5093             return divideSmallFastPath(xs, xscale, ys, yscale, preferredScale, mc);
5094         }
5095         if (compareMagnitudeNormalized(xs, xscale, ys, yscale) &gt; 0) {// satisfy constraint (b)
5096             yscale -= 1; // [that is, divisor *= 10]
5097         }
5098         int roundingMode = mc.roundingMode.oldMode;
5099         // In order to find out whether the divide generates the exact result,
5100         // we avoid calling the above divide method. &#39;quotient&#39; holds the
5101         // return BigDecimal object whose scale will be set to &#39;scl&#39;.
5102         int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);
5103         BigDecimal quotient;
5104         if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {
5105             int raise = checkScaleNonZero((long) mcp + yscale - xscale);
5106             long scaledXs;
5107             if ((scaledXs = longMultiplyPowerTen(xs, raise)) == INFLATED) {
5108                 BigInteger rb = bigMultiplyPowerTen(xs,raise);
5109                 quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5110             } else {
5111                 quotient = divideAndRound(scaledXs, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5112             }
5113         } else {
5114             int newScale = checkScaleNonZero((long) xscale - mcp);
5115             // assert newScale &gt;= yscale
5116             if (newScale == yscale) { // easy case
5117                 quotient = divideAndRound(xs, ys, scl, roundingMode,checkScaleNonZero(preferredScale));
5118             } else {
5119                 int raise = checkScaleNonZero((long) newScale - yscale);
5120                 long scaledYs;
5121                 if ((scaledYs = longMultiplyPowerTen(ys, raise)) == INFLATED) {
5122                     BigInteger rb = bigMultiplyPowerTen(ys,raise);
5123                     quotient = divideAndRound(BigInteger.valueOf(xs),
5124                                               rb, scl, roundingMode,checkScaleNonZero(preferredScale));
5125                 } else {
5126                     quotient = divideAndRound(xs, scaledYs, scl, roundingMode,checkScaleNonZero(preferredScale));
5127                 }
5128             }
5129         }
5130         // doRound, here, only affects 1000000000 case.
5131         return doRound(quotient,mc);
5132     }
5133 
5134     /**
5135      * Returns a {@code BigDecimal} whose value is {@code (xs /
5136      * ys)}, with rounding according to the context settings.
5137      */
5138     private static BigDecimal divide(BigInteger xs, int xscale, long ys, int yscale, long preferredScale, MathContext mc) {
5139         // Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
5140         if ((-compareMagnitudeNormalized(ys, yscale, xs, xscale)) &gt; 0) {// satisfy constraint (b)
5141             yscale -= 1; // [that is, divisor *= 10]
5142         }
5143         int mcp = mc.precision;
5144         int roundingMode = mc.roundingMode.oldMode;
5145 
5146         // In order to find out whether the divide generates the exact result,
5147         // we avoid calling the above divide method. &#39;quotient&#39; holds the
5148         // return BigDecimal object whose scale will be set to &#39;scl&#39;.
5149         BigDecimal quotient;
5150         int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);
5151         if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {
5152             int raise = checkScaleNonZero((long) mcp + yscale - xscale);
5153             BigInteger rb = bigMultiplyPowerTen(xs,raise);
5154             quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5155         } else {
5156             int newScale = checkScaleNonZero((long) xscale - mcp);
5157             // assert newScale &gt;= yscale
5158             if (newScale == yscale) { // easy case
5159                 quotient = divideAndRound(xs, ys, scl, roundingMode,checkScaleNonZero(preferredScale));
5160             } else {
5161                 int raise = checkScaleNonZero((long) newScale - yscale);
5162                 long scaledYs;
5163                 if ((scaledYs = longMultiplyPowerTen(ys, raise)) == INFLATED) {
5164                     BigInteger rb = bigMultiplyPowerTen(ys,raise);
5165                     quotient = divideAndRound(xs, rb, scl, roundingMode,checkScaleNonZero(preferredScale));
5166                 } else {
5167                     quotient = divideAndRound(xs, scaledYs, scl, roundingMode,checkScaleNonZero(preferredScale));
5168                 }
5169             }
5170         }
5171         // doRound, here, only affects 1000000000 case.
5172         return doRound(quotient, mc);
5173     }
5174 
5175     /**
5176      * Returns a {@code BigDecimal} whose value is {@code (xs /
5177      * ys)}, with rounding according to the context settings.
5178      */
5179     private static BigDecimal divide(long xs, int xscale, BigInteger ys, int yscale, long preferredScale, MathContext mc) {
5180         // Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
5181         if (compareMagnitudeNormalized(xs, xscale, ys, yscale) &gt; 0) {// satisfy constraint (b)
5182             yscale -= 1; // [that is, divisor *= 10]
5183         }
5184         int mcp = mc.precision;
5185         int roundingMode = mc.roundingMode.oldMode;
5186 
5187         // In order to find out whether the divide generates the exact result,
5188         // we avoid calling the above divide method. &#39;quotient&#39; holds the
5189         // return BigDecimal object whose scale will be set to &#39;scl&#39;.
5190         BigDecimal quotient;
5191         int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);
5192         if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {
5193             int raise = checkScaleNonZero((long) mcp + yscale - xscale);
5194             BigInteger rb = bigMultiplyPowerTen(xs,raise);
5195             quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5196         } else {
5197             int newScale = checkScaleNonZero((long) xscale - mcp);
5198             int raise = checkScaleNonZero((long) newScale - yscale);
5199             BigInteger rb = bigMultiplyPowerTen(ys,raise);
5200             quotient = divideAndRound(BigInteger.valueOf(xs), rb, scl, roundingMode,checkScaleNonZero(preferredScale));
5201         }
5202         // doRound, here, only affects 1000000000 case.
5203         return doRound(quotient, mc);
5204     }
5205 
5206     /**
5207      * Returns a {@code BigDecimal} whose value is {@code (xs /
5208      * ys)}, with rounding according to the context settings.
5209      */
5210     private static BigDecimal divide(BigInteger xs, int xscale, BigInteger ys, int yscale, long preferredScale, MathContext mc) {
5211         // Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
5212         if (compareMagnitudeNormalized(xs, xscale, ys, yscale) &gt; 0) {// satisfy constraint (b)
5213             yscale -= 1; // [that is, divisor *= 10]
5214         }
5215         int mcp = mc.precision;
5216         int roundingMode = mc.roundingMode.oldMode;
5217 
5218         // In order to find out whether the divide generates the exact result,
5219         // we avoid calling the above divide method. &#39;quotient&#39; holds the
5220         // return BigDecimal object whose scale will be set to &#39;scl&#39;.
5221         BigDecimal quotient;
5222         int scl = checkScaleNonZero(preferredScale + yscale - xscale + mcp);
5223         if (checkScaleNonZero((long) mcp + yscale - xscale) &gt; 0) {
5224             int raise = checkScaleNonZero((long) mcp + yscale - xscale);
5225             BigInteger rb = bigMultiplyPowerTen(xs,raise);
5226             quotient = divideAndRound(rb, ys, scl, roundingMode, checkScaleNonZero(preferredScale));
5227         } else {
5228             int newScale = checkScaleNonZero((long) xscale - mcp);
5229             int raise = checkScaleNonZero((long) newScale - yscale);
5230             BigInteger rb = bigMultiplyPowerTen(ys,raise);
5231             quotient = divideAndRound(xs, rb, scl, roundingMode,checkScaleNonZero(preferredScale));
5232         }
5233         // doRound, here, only affects 1000000000 case.
5234         return doRound(quotient, mc);
5235     }
5236 
5237     /*
5238      * performs divideAndRound for (dividend0*dividend1, divisor)
5239      * returns null if quotient can&#39;t fit into long value;
5240      */
5241     private static BigDecimal multiplyDivideAndRound(long dividend0, long dividend1, long divisor, int scale, int roundingMode,
5242                                                      int preferredScale) {
5243         int qsign = Long.signum(dividend0)*Long.signum(dividend1)*Long.signum(divisor);
5244         dividend0 = Math.abs(dividend0);
5245         dividend1 = Math.abs(dividend1);
5246         divisor = Math.abs(divisor);
5247         // multiply dividend0 * dividend1
5248         long d0_hi = dividend0 &gt;&gt;&gt; 32;
5249         long d0_lo = dividend0 &amp; LONG_MASK;
5250         long d1_hi = dividend1 &gt;&gt;&gt; 32;
5251         long d1_lo = dividend1 &amp; LONG_MASK;
5252         long product = d0_lo * d1_lo;
5253         long d0 = product &amp; LONG_MASK;
5254         long d1 = product &gt;&gt;&gt; 32;
5255         product = d0_hi * d1_lo + d1;
5256         d1 = product &amp; LONG_MASK;
5257         long d2 = product &gt;&gt;&gt; 32;
5258         product = d0_lo * d1_hi + d1;
5259         d1 = product &amp; LONG_MASK;
5260         d2 += product &gt;&gt;&gt; 32;
5261         long d3 = d2&gt;&gt;&gt;32;
5262         d2 &amp;= LONG_MASK;
5263         product = d0_hi*d1_hi + d2;
5264         d2 = product &amp; LONG_MASK;
5265         d3 = ((product&gt;&gt;&gt;32) + d3) &amp; LONG_MASK;
5266         final long dividendHi = make64(d3,d2);
5267         final long dividendLo = make64(d1,d0);
5268         // divide
5269         return divideAndRound128(dividendHi, dividendLo, divisor, qsign, scale, roundingMode, preferredScale);
5270     }
5271 
5272     private static final long DIV_NUM_BASE = (1L&lt;&lt;32); // Number base (32 bits).
5273 
5274     /*
5275      * divideAndRound 128-bit value by long divisor.
5276      * returns null if quotient can&#39;t fit into long value;
5277      * Specialized version of Knuth&#39;s division
5278      */
5279     private static BigDecimal divideAndRound128(final long dividendHi, final long dividendLo, long divisor, int sign,
5280                                                 int scale, int roundingMode, int preferredScale) {
5281         if (dividendHi &gt;= divisor) {
5282             return null;
5283         }
5284 
5285         final int shift = Long.numberOfLeadingZeros(divisor);
5286         divisor &lt;&lt;= shift;
5287 
5288         final long v1 = divisor &gt;&gt;&gt; 32;
5289         final long v0 = divisor &amp; LONG_MASK;
5290 
5291         long tmp = dividendLo &lt;&lt; shift;
5292         long u1 = tmp &gt;&gt;&gt; 32;
5293         long u0 = tmp &amp; LONG_MASK;
5294 
5295         tmp = (dividendHi &lt;&lt; shift) | (dividendLo &gt;&gt;&gt; 64 - shift);
5296         long u2 = tmp &amp; LONG_MASK;
5297         long q1, r_tmp;
5298         if (v1 == 1) {
5299             q1 = tmp;
5300             r_tmp = 0;
5301         } else if (tmp &gt;= 0) {
5302             q1 = tmp / v1;
5303             r_tmp = tmp - q1 * v1;
5304         } else {
5305             long[] rq = divRemNegativeLong(tmp, v1);
5306             q1 = rq[1];
5307             r_tmp = rq[0];
5308         }
5309 
5310         while(q1 &gt;= DIV_NUM_BASE || unsignedLongCompare(q1*v0, make64(r_tmp, u1))) {
5311             q1--;
5312             r_tmp += v1;
5313             if (r_tmp &gt;= DIV_NUM_BASE)
5314                 break;
5315         }
5316 
5317         tmp = mulsub(u2,u1,v1,v0,q1);
5318         u1 = tmp &amp; LONG_MASK;
5319         long q0;
5320         if (v1 == 1) {
5321             q0 = tmp;
5322             r_tmp = 0;
5323         } else if (tmp &gt;= 0) {
5324             q0 = tmp / v1;
5325             r_tmp = tmp - q0 * v1;
5326         } else {
5327             long[] rq = divRemNegativeLong(tmp, v1);
5328             q0 = rq[1];
5329             r_tmp = rq[0];
5330         }
5331 
5332         while(q0 &gt;= DIV_NUM_BASE || unsignedLongCompare(q0*v0,make64(r_tmp,u0))) {
5333             q0--;
5334             r_tmp += v1;
5335             if (r_tmp &gt;= DIV_NUM_BASE)
5336                 break;
5337         }
5338 
5339         if((int)q1 &lt; 0) {
5340             // result (which is positive and unsigned here)
5341             // can&#39;t fit into long due to sign bit is used for value
5342             MutableBigInteger mq = new MutableBigInteger(new int[]{(int)q1, (int)q0});
5343             if (roundingMode == ROUND_DOWN &amp;&amp; scale == preferredScale) {
5344                 return mq.toBigDecimal(sign, scale);
5345             }
5346             long r = mulsub(u1, u0, v1, v0, q0) &gt;&gt;&gt; shift;
5347             if (r != 0) {
5348                 if(needIncrement(divisor &gt;&gt;&gt; shift, roundingMode, sign, mq, r)){
5349                     mq.add(MutableBigInteger.ONE);
5350                 }
5351                 return mq.toBigDecimal(sign, scale);
5352             } else {
5353                 if (preferredScale != scale) {
5354                     BigInteger intVal =  mq.toBigInteger(sign);
5355                     return createAndStripZerosToMatchScale(intVal,scale, preferredScale);
5356                 } else {
5357                     return mq.toBigDecimal(sign, scale);
5358                 }
5359             }
5360         }
5361 
5362         long q = make64(q1,q0);
5363         q*=sign;
5364 
5365         if (roundingMode == ROUND_DOWN &amp;&amp; scale == preferredScale)
5366             return valueOf(q, scale);
5367 
5368         long r = mulsub(u1, u0, v1, v0, q0) &gt;&gt;&gt; shift;
5369         if (r != 0) {
5370             boolean increment = needIncrement(divisor &gt;&gt;&gt; shift, roundingMode, sign, q, r);
5371             return valueOf((increment ? q + sign : q), scale);
5372         } else {
5373             if (preferredScale != scale) {
5374                 return createAndStripZerosToMatchScale(q, scale, preferredScale);
5375             } else {
5376                 return valueOf(q, scale);
5377             }
5378         }
5379     }
5380 
5381     /*
5382      * calculate divideAndRound for ldividend*10^raise / divisor
5383      * when abs(dividend)==abs(divisor);
5384      */
5385     private static BigDecimal roundedTenPower(int qsign, int raise, int scale, int preferredScale) {
5386         if (scale &gt; preferredScale) {
5387             int diff = scale - preferredScale;
5388             if(diff &lt; raise) {
5389                 return scaledTenPow(raise - diff, qsign, preferredScale);
5390             } else {
5391                 return valueOf(qsign,scale-raise);
5392             }
5393         } else {
5394             return scaledTenPow(raise, qsign, scale);
5395         }
5396     }
5397 
5398     static BigDecimal scaledTenPow(int n, int sign, int scale) {
5399         if (n &lt; LONG_TEN_POWERS_TABLE.length)
5400             return valueOf(sign*LONG_TEN_POWERS_TABLE[n],scale);
5401         else {
5402             BigInteger unscaledVal = bigTenToThe(n);
5403             if(sign==-1) {
5404                 unscaledVal = unscaledVal.negate();
5405             }
5406             return new BigDecimal(unscaledVal, INFLATED, scale, n+1);
5407         }
5408     }
5409 
5410     /**
5411      * Calculate the quotient and remainder of dividing a negative long by
5412      * another long.
5413      *
5414      * @param n the numerator; must be negative
5415      * @param d the denominator; must not be unity
5416      * @return a two-element {@long} array with the remainder and quotient in
5417      *         the initial and final elements, respectively
5418      */
5419     private static long[] divRemNegativeLong(long n, long d) {
5420         assert n &lt; 0 : &quot;Non-negative numerator &quot; + n;
5421         assert d != 1 : &quot;Unity denominator&quot;;
5422 
5423         // Approximate the quotient and remainder
5424         long q = (n &gt;&gt;&gt; 1) / (d &gt;&gt;&gt; 1);
5425         long r = n - q * d;
5426 
5427         // Correct the approximation
5428         while (r &lt; 0) {
5429             r += d;
5430             q--;
5431         }
5432         while (r &gt;= d) {
5433             r -= d;
5434             q++;
5435         }
5436 
5437         // n - q*d == r &amp;&amp; 0 &lt;= r &lt; d, hence we&#39;re done.
5438         return new long[] {r, q};
5439     }
5440 
5441     private static long make64(long hi, long lo) {
5442         return hi&lt;&lt;32 | lo;
5443     }
5444 
5445     private static long mulsub(long u1, long u0, final long v1, final long v0, long q0) {
5446         long tmp = u0 - q0*v0;
5447         return make64(u1 + (tmp&gt;&gt;&gt;32) - q0*v1,tmp &amp; LONG_MASK);
5448     }
5449 
5450     private static boolean unsignedLongCompare(long one, long two) {
5451         return (one+Long.MIN_VALUE) &gt; (two+Long.MIN_VALUE);
5452     }
5453 
5454     private static boolean unsignedLongCompareEq(long one, long two) {
5455         return (one+Long.MIN_VALUE) &gt;= (two+Long.MIN_VALUE);
5456     }
5457 
5458 
5459     // Compare Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
5460     private static int compareMagnitudeNormalized(long xs, int xscale, long ys, int yscale) {
5461         // assert xs!=0 &amp;&amp; ys!=0
5462         int sdiff = xscale - yscale;
5463         if (sdiff != 0) {
5464             if (sdiff &lt; 0) {
5465                 xs = longMultiplyPowerTen(xs, -sdiff);
5466             } else { // sdiff &gt; 0
5467                 ys = longMultiplyPowerTen(ys, sdiff);
5468             }
5469         }
5470         if (xs != INFLATED)
5471             return (ys != INFLATED) ? longCompareMagnitude(xs, ys) : -1;
5472         else
5473             return 1;
5474     }
5475 
5476     // Compare Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
5477     private static int compareMagnitudeNormalized(long xs, int xscale, BigInteger ys, int yscale) {
5478         // assert &quot;ys can&#39;t be represented as long&quot;
5479         if (xs == 0)
5480             return -1;
5481         int sdiff = xscale - yscale;
5482         if (sdiff &lt; 0) {
5483             if (longMultiplyPowerTen(xs, -sdiff) == INFLATED ) {
5484                 return bigMultiplyPowerTen(xs, -sdiff).compareMagnitude(ys);
5485             }
5486         }
5487         return -1;
5488     }
5489 
5490     // Compare Normalize dividend &amp; divisor so that both fall into [0.1, 0.999...]
5491     private static int compareMagnitudeNormalized(BigInteger xs, int xscale, BigInteger ys, int yscale) {
5492         int sdiff = xscale - yscale;
5493         if (sdiff &lt; 0) {
5494             return bigMultiplyPowerTen(xs, -sdiff).compareMagnitude(ys);
5495         } else { // sdiff &gt;= 0
5496             return xs.compareMagnitude(bigMultiplyPowerTen(ys, sdiff));
5497         }
5498     }
5499 
5500     private static long multiply(long x, long y){
5501                 long product = x * y;
5502         long ax = Math.abs(x);
5503         long ay = Math.abs(y);
5504         if (((ax | ay) &gt;&gt;&gt; 31 == 0) || (y == 0) || (product / y == x)){
5505                         return product;
5506                 }
5507         return INFLATED;
5508     }
5509 
5510     private static BigDecimal multiply(long x, long y, int scale) {
5511         long product = multiply(x, y);
5512         if(product!=INFLATED) {
5513             return valueOf(product,scale);
5514         }
5515         return new BigDecimal(BigInteger.valueOf(x).multiply(y),INFLATED,scale,0);
5516     }
5517 
5518     private static BigDecimal multiply(long x, BigInteger y, int scale) {
5519         if(x==0) {
5520             return zeroValueOf(scale);
5521         }
5522         return new BigDecimal(y.multiply(x),INFLATED,scale,0);
5523     }
5524 
5525     private static BigDecimal multiply(BigInteger x, BigInteger y, int scale) {
5526         return new BigDecimal(x.multiply(y),INFLATED,scale,0);
5527     }
5528 
5529     /**
5530      * Multiplies two long values and rounds according {@code MathContext}
5531      */
5532     private static BigDecimal multiplyAndRound(long x, long y, int scale, MathContext mc) {
5533         long product = multiply(x, y);
5534         if(product!=INFLATED) {
5535             return doRound(product, scale, mc);
5536         }
5537         // attempt to do it in 128 bits
5538         int rsign = 1;
5539         if(x &lt; 0) {
5540             x = -x;
5541             rsign = -1;
5542         }
5543         if(y &lt; 0) {
5544             y = -y;
5545             rsign *= -1;
5546         }
5547         // multiply dividend0 * dividend1
5548         long m0_hi = x &gt;&gt;&gt; 32;
5549         long m0_lo = x &amp; LONG_MASK;
5550         long m1_hi = y &gt;&gt;&gt; 32;
5551         long m1_lo = y &amp; LONG_MASK;
5552         product = m0_lo * m1_lo;
5553         long m0 = product &amp; LONG_MASK;
5554         long m1 = product &gt;&gt;&gt; 32;
5555         product = m0_hi * m1_lo + m1;
5556         m1 = product &amp; LONG_MASK;
5557         long m2 = product &gt;&gt;&gt; 32;
5558         product = m0_lo * m1_hi + m1;
5559         m1 = product &amp; LONG_MASK;
5560         m2 += product &gt;&gt;&gt; 32;
5561         long m3 = m2&gt;&gt;&gt;32;
5562         m2 &amp;= LONG_MASK;
5563         product = m0_hi*m1_hi + m2;
5564         m2 = product &amp; LONG_MASK;
5565         m3 = ((product&gt;&gt;&gt;32) + m3) &amp; LONG_MASK;
5566         final long mHi = make64(m3,m2);
5567         final long mLo = make64(m1,m0);
5568         BigDecimal res = doRound128(mHi, mLo, rsign, scale, mc);
5569         if(res!=null) {
5570             return res;
5571         }
5572         res = new BigDecimal(BigInteger.valueOf(x).multiply(y*rsign), INFLATED, scale, 0);
5573         return doRound(res,mc);
5574     }
5575 
5576     private static BigDecimal multiplyAndRound(long x, BigInteger y, int scale, MathContext mc) {
5577         if(x==0) {
5578             return zeroValueOf(scale);
5579         }
5580         return doRound(y.multiply(x), scale, mc);
5581     }
5582 
5583     private static BigDecimal multiplyAndRound(BigInteger x, BigInteger y, int scale, MathContext mc) {
5584         return doRound(x.multiply(y), scale, mc);
5585     }
5586 
5587     /**
5588      * rounds 128-bit value according {@code MathContext}
5589      * returns null if result can&#39;t be repsented as compact BigDecimal.
5590      */
5591     private static BigDecimal doRound128(long hi, long lo, int sign, int scale, MathContext mc) {
5592         int mcp = mc.precision;
5593         int drop;
5594         BigDecimal res = null;
5595         if(((drop = precision(hi, lo) - mcp) &gt; 0)&amp;&amp;(drop&lt;LONG_TEN_POWERS_TABLE.length)) {
5596             scale = checkScaleNonZero((long)scale - drop);
5597             res = divideAndRound128(hi, lo, LONG_TEN_POWERS_TABLE[drop], sign, scale, mc.roundingMode.oldMode, scale);
5598         }
5599         if(res!=null) {
5600             return doRound(res,mc);
5601         }
5602         return null;
5603     }
5604 
5605     private static final long[][] LONGLONG_TEN_POWERS_TABLE = {
5606         {   0L, 0x8AC7230489E80000L },  //10^19
5607         {       0x5L, 0x6bc75e2d63100000L },  //10^20
5608         {       0x36L, 0x35c9adc5dea00000L },  //10^21
5609         {       0x21eL, 0x19e0c9bab2400000L  },  //10^22
5610         {       0x152dL, 0x02c7e14af6800000L  },  //10^23
5611         {       0xd3c2L, 0x1bcecceda1000000L  },  //10^24
5612         {       0x84595L, 0x161401484a000000L  },  //10^25
5613         {       0x52b7d2L, 0xdcc80cd2e4000000L  },  //10^26
5614         {       0x33b2e3cL, 0x9fd0803ce8000000L  },  //10^27
5615         {       0x204fce5eL, 0x3e25026110000000L  },  //10^28
5616         {       0x1431e0faeL, 0x6d7217caa0000000L  },  //10^29
5617         {       0xc9f2c9cd0L, 0x4674edea40000000L  },  //10^30
5618         {       0x7e37be2022L, 0xc0914b2680000000L  },  //10^31
5619         {       0x4ee2d6d415bL, 0x85acef8100000000L  },  //10^32
5620         {       0x314dc6448d93L, 0x38c15b0a00000000L  },  //10^33
5621         {       0x1ed09bead87c0L, 0x378d8e6400000000L  },  //10^34
5622         {       0x13426172c74d82L, 0x2b878fe800000000L  },  //10^35
5623         {       0xc097ce7bc90715L, 0xb34b9f1000000000L  },  //10^36
5624         {       0x785ee10d5da46d9L, 0x00f436a000000000L  },  //10^37
5625         {       0x4b3b4ca85a86c47aL, 0x098a224000000000L  },  //10^38
5626     };
5627 
5628     /*
5629      * returns precision of 128-bit value
5630      */
5631     private static int precision(long hi, long lo){
5632         if(hi==0) {
5633             if(lo&gt;=0) {
5634                 return longDigitLength(lo);
5635             }
5636             return (unsignedLongCompareEq(lo, LONGLONG_TEN_POWERS_TABLE[0][1])) ? 20 : 19;
5637             // 0x8AC7230489E80000L  = unsigned 2^19
5638         }
5639         int r = ((128 - Long.numberOfLeadingZeros(hi) + 1) * 1233) &gt;&gt;&gt; 12;
5640         int idx = r-19;
5641         return (idx &gt;= LONGLONG_TEN_POWERS_TABLE.length || longLongCompareMagnitude(hi, lo,
5642                                                                                     LONGLONG_TEN_POWERS_TABLE[idx][0], LONGLONG_TEN_POWERS_TABLE[idx][1])) ? r : r + 1;
5643     }
5644 
5645     /*
5646      * returns true if 128 bit number &lt;hi0,lo0&gt; is less than &lt;hi1,lo1&gt;
5647      * hi0 &amp; hi1 should be non-negative
5648      */
5649     private static boolean longLongCompareMagnitude(long hi0, long lo0, long hi1, long lo1) {
5650         if(hi0!=hi1) {
5651             return hi0&lt;hi1;
5652         }
5653         return (lo0+Long.MIN_VALUE) &lt;(lo1+Long.MIN_VALUE);
5654     }
5655 
5656     private static BigDecimal divide(long dividend, int dividendScale, long divisor, int divisorScale, int scale, int roundingMode) {
5657         if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {
5658             int newScale = scale + divisorScale;
5659             int raise = newScale - dividendScale;
5660             if(raise&lt;LONG_TEN_POWERS_TABLE.length) {
5661                 long xs = dividend;
5662                 if ((xs = longMultiplyPowerTen(xs, raise)) != INFLATED) {
5663                     return divideAndRound(xs, divisor, scale, roundingMode, scale);
5664                 }
5665                 BigDecimal q = multiplyDivideAndRound(LONG_TEN_POWERS_TABLE[raise], dividend, divisor, scale, roundingMode, scale);
5666                 if(q!=null) {
5667                     return q;
5668                 }
5669             }
5670             BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);
5671             return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);
5672         } else {
5673             int newScale = checkScale(divisor,(long)dividendScale - scale);
5674             int raise = newScale - divisorScale;
5675             if(raise&lt;LONG_TEN_POWERS_TABLE.length) {
5676                 long ys = divisor;
5677                 if ((ys = longMultiplyPowerTen(ys, raise)) != INFLATED) {
5678                     return divideAndRound(dividend, ys, scale, roundingMode, scale);
5679                 }
5680             }
5681             BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);
5682             return divideAndRound(BigInteger.valueOf(dividend), scaledDivisor, scale, roundingMode, scale);
5683         }
5684     }
5685 
5686     private static BigDecimal divide(BigInteger dividend, int dividendScale, long divisor, int divisorScale, int scale, int roundingMode) {
5687         if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {
5688             int newScale = scale + divisorScale;
5689             int raise = newScale - dividendScale;
5690             BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);
5691             return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);
5692         } else {
5693             int newScale = checkScale(divisor,(long)dividendScale - scale);
5694             int raise = newScale - divisorScale;
5695             if(raise&lt;LONG_TEN_POWERS_TABLE.length) {
5696                 long ys = divisor;
5697                 if ((ys = longMultiplyPowerTen(ys, raise)) != INFLATED) {
5698                     return divideAndRound(dividend, ys, scale, roundingMode, scale);
5699                 }
5700             }
5701             BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);
5702             return divideAndRound(dividend, scaledDivisor, scale, roundingMode, scale);
5703         }
5704     }
5705 
5706     private static BigDecimal divide(long dividend, int dividendScale, BigInteger divisor, int divisorScale, int scale, int roundingMode) {
5707         if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {
5708             int newScale = scale + divisorScale;
5709             int raise = newScale - dividendScale;
5710             BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);
5711             return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);
5712         } else {
5713             int newScale = checkScale(divisor,(long)dividendScale - scale);
5714             int raise = newScale - divisorScale;
5715             BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);
5716             return divideAndRound(BigInteger.valueOf(dividend), scaledDivisor, scale, roundingMode, scale);
5717         }
5718     }
5719 
5720     private static BigDecimal divide(BigInteger dividend, int dividendScale, BigInteger divisor, int divisorScale, int scale, int roundingMode) {
5721         if (checkScale(dividend,(long)scale + divisorScale) &gt; dividendScale) {
5722             int newScale = scale + divisorScale;
5723             int raise = newScale - dividendScale;
5724             BigInteger scaledDividend = bigMultiplyPowerTen(dividend, raise);
5725             return divideAndRound(scaledDividend, divisor, scale, roundingMode, scale);
5726         } else {
5727             int newScale = checkScale(divisor,(long)dividendScale - scale);
5728             int raise = newScale - divisorScale;
5729             BigInteger scaledDivisor = bigMultiplyPowerTen(divisor, raise);
5730             return divideAndRound(dividend, scaledDivisor, scale, roundingMode, scale);
5731         }
5732     }
5733 
5734 }
<a name="5" id="anc5"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="5" type="hidden" />
</body>
</html>
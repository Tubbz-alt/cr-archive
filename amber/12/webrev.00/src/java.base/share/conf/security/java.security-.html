<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/java.base/share/conf/security/java.security</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
  <body>
    <pre>
   1 #
   2 # This is the &quot;master security properties file&quot;.
   3 #
   4 # An alternate java.security properties file may be specified
   5 # from the command line via the system property
   6 #
   7 #    -Djava.security.properties=&lt;URL&gt;
   8 #
   9 # This properties file appends to the master security properties file.
  10 # If both properties files specify values for the same key, the value
  11 # from the command-line properties file is selected, as it is the last
  12 # one loaded.
  13 #
  14 # Also, if you specify
  15 #
  16 #    -Djava.security.properties==&lt;URL&gt; (2 equals),
  17 #
  18 # then that properties file completely overrides the master security
  19 # properties file.
  20 #
  21 # To disable the ability to specify an additional properties file from
  22 # the command line, set the key security.overridePropertiesFile
  23 # to false in the master security properties file. It is set to true
  24 # by default.
  25 
  26 # In this file, various security properties are set for use by
  27 # java.security classes. This is where users can statically register
  28 # Cryptography Package Providers (&quot;providers&quot; for short). The term
  29 # &quot;provider&quot; refers to a package or set of packages that supply a
  30 # concrete implementation of a subset of the cryptography aspects of
  31 # the Java Security API. A provider may, for example, implement one or
  32 # more digital signature algorithms or message digest algorithms.
  33 #
  34 # Each provider must implement a subclass of the Provider class.
  35 # To register a provider in this master security properties file,
  36 # specify the provider and priority in the format
  37 #
  38 #    security.provider.&lt;n&gt;=&lt;provName | className&gt;
  39 #
  40 # This declares a provider, and specifies its preference
  41 # order n. The preference order is the order in which providers are
  42 # searched for requested algorithms (when no specific provider is
  43 # requested). The order is 1-based; 1 is the most preferred, followed
  44 # by 2, and so on.
  45 #
  46 # &lt;provName&gt; must specify the name of the Provider as passed to its super
  47 # class java.security.Provider constructor. This is for providers loaded
  48 # through the ServiceLoader mechanism.
  49 #
  50 # &lt;className&gt; must specify the subclass of the Provider class whose
  51 # constructor sets the values of various properties that are required
  52 # for the Java Security API to look up the algorithms or other
  53 # facilities implemented by the provider. This is for providers loaded
  54 # through classpath.
  55 #
  56 # Note: Providers can be dynamically registered instead by calls to
  57 # either the addProvider or insertProviderAt method in the Security
  58 # class.
  59 
  60 #
  61 # List of providers and their preference orders (see above):
  62 #
  63 #ifdef solaris
  64 # Note: The OracleUcrypto provider is deprecated and subject to removal in
  65 # a future version of the JDK.
  66 security.provider.tbd=OracleUcrypto
  67 security.provider.tbd=SunPKCS11 ${java.home}/conf/security/sunpkcs11-solaris.cfg
  68 #endif
  69 security.provider.tbd=SUN
  70 security.provider.tbd=SunRsaSign
  71 security.provider.tbd=SunEC
  72 security.provider.tbd=SunJSSE
  73 security.provider.tbd=SunJCE
  74 security.provider.tbd=SunJGSS
  75 security.provider.tbd=SunSASL
  76 security.provider.tbd=XMLDSig
  77 security.provider.tbd=SunPCSC
  78 security.provider.tbd=JdkLDAP
  79 security.provider.tbd=JdkSASL
  80 #ifdef windows
  81 security.provider.tbd=SunMSCAPI
  82 #endif
  83 #ifdef macosx
  84 security.provider.tbd=Apple
  85 #endif
  86 #ifndef solaris
  87 security.provider.tbd=SunPKCS11
  88 #endif
  89 
  90 #
  91 # A list of preferred providers for specific algorithms. These providers will
  92 # be searched for matching algorithms before the list of registered providers.
  93 # Entries containing errors (parsing, etc) will be ignored. Use the
  94 # -Djava.security.debug=jca property to debug these errors.
  95 #
  96 # The property is a comma-separated list of serviceType.algorithm:provider
  97 # entries. The serviceType (example: &quot;MessageDigest&quot;) is optional, and if
  98 # not specified, the algorithm applies to all service types that support it.
  99 # The algorithm is the standard algorithm name or transformation.
 100 # Transformations can be specified in their full standard name
 101 # (ex: AES/CBC/PKCS5Padding), or as partial matches (ex: AES, AES/CBC).
 102 # The provider is the name of the provider. Any provider that does not
 103 # also appear in the registered list will be ignored.
 104 #
 105 # There is a special serviceType for this property only to group a set of
 106 # algorithms together. The type is &quot;Group&quot; and is followed by an algorithm
 107 # keyword. Groups are to simplify and lessen the entries on the property
 108 # line. Current groups are:
 109 #   Group.SHA2 = SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224, SHA-512/256
 110 #   Group.HmacSHA2 = HmacSHA224, HmacSHA256, HmacSHA384, HmacSHA512
 111 #   Group.SHA2RSA = SHA224withRSA, SHA256withRSA, SHA384withRSA, SHA512withRSA
 112 #   Group.SHA2DSA = SHA224withDSA, SHA256withDSA, SHA384withDSA, SHA512withDSA
 113 #   Group.SHA2ECDSA = SHA224withECDSA, SHA256withECDSA, SHA384withECDSA, \
 114 #                     SHA512withECDSA
 115 #   Group.SHA3 = SHA3-224, SHA3-256, SHA3-384, SHA3-512
 116 #   Group.HmacSHA3 = HmacSHA3-224, HmacSHA3-256, HmacSHA3-384, HmacSHA3-512
 117 #
 118 # Example:
 119 #   jdk.security.provider.preferred=AES/GCM/NoPadding:SunJCE, \
 120 #         MessageDigest.SHA-256:SUN, Group.HmacSHA2:SunJCE
 121 #
 122 #ifdef solaris-sparc
 123 # Optional Solaris-SPARC configuration for non-FIPS 140 configurations.
 124 #   jdk.security.provider.preferred=AES:SunJCE, SHA1:SUN, Group.SHA2:SUN, \
 125 #   HmacSHA1:SunJCE, Group.HmacSHA2:SunJCE
 126 #
 127 #endif
 128 #jdk.security.provider.preferred=
 129 
 130 
 131 #
 132 # Sun Provider SecureRandom seed source.
 133 #
 134 # Select the primary source of seed data for the &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot;
 135 # and &quot;DRBG&quot; SecureRandom implementations in the &quot;Sun&quot; provider.
 136 # (Other SecureRandom implementations might also use this property.)
 137 #
 138 # On Unix-like systems (for example, Solaris/Linux/MacOS), the
 139 # &quot;NativePRNG&quot;, &quot;SHA1PRNG&quot; and &quot;DRBG&quot; implementations obtains seed data from
 140 # special device files such as file:/dev/random.
 141 #
 142 # On Windows systems, specifying the URLs &quot;file:/dev/random&quot; or
 143 # &quot;file:/dev/urandom&quot; will enable the native Microsoft CryptoAPI seeding
 144 # mechanism for SHA1PRNG and DRBG.
 145 #
 146 # By default, an attempt is made to use the entropy gathering device
 147 # specified by the &quot;securerandom.source&quot; Security property.  If an
 148 # exception occurs while accessing the specified URL:
 149 #
 150 #     NativePRNG:
 151 #         a default value of /dev/random will be used.  If neither
 152 #         are available, the implementation will be disabled.
 153 #         &quot;file&quot; is the only currently supported protocol type.
 154 #
 155 #     SHA1PRNG and DRBG:
 156 #         the traditional system/thread activity algorithm will be used.
 157 #
 158 # The entropy gathering device can also be specified with the System
 159 # property &quot;java.security.egd&quot;. For example:
 160 #
 161 #   % java -Djava.security.egd=file:/dev/random MainClass
 162 #
 163 # Specifying this System property will override the
 164 # &quot;securerandom.source&quot; Security property.
 165 #
 166 # In addition, if &quot;file:/dev/random&quot; or &quot;file:/dev/urandom&quot; is
 167 # specified, the &quot;NativePRNG&quot; implementation will be more preferred than
 168 # DRBG and SHA1PRNG in the Sun provider.
 169 #
 170 securerandom.source=file:/dev/random
 171 
 172 #
 173 # A list of known strong SecureRandom implementations.
 174 #
 175 # To help guide applications in selecting a suitable strong
 176 # java.security.SecureRandom implementation, Java distributions should
 177 # indicate a list of known strong implementations using the property.
 178 #
 179 # This is a comma-separated list of algorithm and/or algorithm:provider
 180 # entries.
 181 #
 182 #ifdef windows
 183 securerandom.strongAlgorithms=Windows-PRNG:SunMSCAPI,DRBG:SUN
 184 #endif
 185 #ifndef windows
 186 securerandom.strongAlgorithms=NativePRNGBlocking:SUN,DRBG:SUN
 187 #endif
 188 
 189 #
 190 # Sun provider DRBG configuration and default instantiation request.
 191 #
 192 # NIST SP 800-90Ar1 lists several DRBG mechanisms. Each can be configured
 193 # with a DRBG algorithm name, and can be instantiated with a security strength,
 194 # prediction resistance support, etc. This property defines the configuration
 195 # and the default instantiation request of &quot;DRBG&quot; SecureRandom implementations
 196 # in the SUN provider. (Other DRBG implementations can also use this property.)
 197 # Applications can request different instantiation parameters like security
 198 # strength, capability, personalization string using one of the
 199 # getInstance(...,SecureRandomParameters,...) methods with a
 200 # DrbgParameters.Instantiation argument, but other settings such as the
 201 # mechanism and DRBG algorithm names are not currently configurable by any API.
 202 #
 203 # Please note that the SUN implementation of DRBG always supports reseeding.
 204 #
 205 # The value of this property is a comma-separated list of all configurable
 206 # aspects. The aspects can appear in any order but the same aspect can only
 207 # appear at most once. Its BNF-style definition is:
 208 #
 209 #   Value:
 210 #     aspect { &quot;,&quot; aspect }
 211 #
 212 #   aspect:
 213 #     mech_name | algorithm_name | strength | capability | df
 214 #
 215 #   // The DRBG mechanism to use. Default &quot;Hash_DRBG&quot;
 216 #   mech_name:
 217 #     &quot;Hash_DRBG&quot; | &quot;HMAC_DRBG&quot; | &quot;CTR_DRBG&quot;
 218 #
 219 #   // The DRBG algorithm name. The &quot;SHA-***&quot; names are for Hash_DRBG and
 220 #   // HMAC_DRBG, default &quot;SHA-256&quot;. The &quot;AES-***&quot; names are for CTR_DRBG,
 221 #   // default &quot;AES-128&quot; when using the limited cryptographic or &quot;AES-256&quot;
 222 #   // when using the unlimited.
 223 #   algorithm_name:
 224 #     &quot;SHA-224&quot; | &quot;SHA-512/224&quot; | &quot;SHA-256&quot; |
 225 #     &quot;SHA-512/256&quot; | &quot;SHA-384&quot; | &quot;SHA-512&quot; |
 226 #     &quot;AES-128&quot; | &quot;AES-192&quot; | &quot;AES-256&quot;
 227 #
 228 #   // Security strength requested. Default &quot;128&quot;
 229 #   strength:
 230 #     &quot;112&quot; | &quot;128&quot; | &quot;192&quot; | &quot;256&quot;
 231 #
 232 #   // Prediction resistance and reseeding request. Default &quot;none&quot;
 233 #   //  &quot;pr_and_reseed&quot; - Both prediction resistance and reseeding
 234 #   //                    support requested
 235 #   //  &quot;reseed_only&quot;   - Only reseeding support requested
 236 #   //  &quot;none&quot;          - Neither prediction resistance not reseeding
 237 #   //                    support requested
 238 #   pr:
 239 #     &quot;pr_and_reseed&quot; | &quot;reseed_only&quot; | &quot;none&quot;
 240 #
 241 #   // Whether a derivation function should be used. only applicable
 242 #   // to CTR_DRBG. Default &quot;use_df&quot;
 243 #   df:
 244 #     &quot;use_df&quot; | &quot;no_df&quot;
 245 #
 246 # Examples,
 247 #   securerandom.drbg.config=Hash_DRBG,SHA-224,112,none
 248 #   securerandom.drbg.config=CTR_DRBG,AES-256,192,pr_and_reseed,use_df
 249 #
 250 # The default value is an empty string, which is equivalent to
 251 #   securerandom.drbg.config=Hash_DRBG,SHA-256,128,none
 252 #
 253 securerandom.drbg.config=
 254 
 255 #
 256 # Class to instantiate as the javax.security.auth.login.Configuration
 257 # provider.
 258 #
 259 login.configuration.provider=sun.security.provider.ConfigFile
 260 
 261 #
 262 # Default login configuration file
 263 #
 264 #login.config.url.1=file:${user.home}/.java.login.config
 265 
 266 #
 267 # Class to instantiate as the system Policy. This is the name of the class
 268 # that will be used as the Policy object. The system class loader is used to
 269 # locate this class.
 270 #
 271 policy.provider=sun.security.provider.PolicyFile
 272 
 273 # The default is to have a single system-wide policy file,
 274 # and a policy file in the user&#39;s home directory.
 275 #
 276 policy.url.1=file:${java.home}/conf/security/java.policy
 277 policy.url.2=file:${user.home}/.java.policy
 278 
 279 # Controls whether or not properties are expanded in policy and login
 280 # configuration files. If set to false, properties (${...}) will not
 281 # be expanded in policy and login configuration files. If commented out or
 282 # set to an empty string, the default value is &quot;false&quot; for policy files and
 283 # &quot;true&quot; for login configuration files.
 284 #
 285 policy.expandProperties=true
 286 
 287 # Controls whether or not an extra policy or login configuration file is
 288 # allowed to be passed on the command line with -Djava.security.policy=somefile
 289 # or -Djava.security.auth.login.config=somefile. If commented out or set to
 290 # an empty string, the default value is &quot;false&quot;.
 291 #
 292 policy.allowSystemProperty=true
 293 
 294 # whether or not we look into the IdentityScope for trusted Identities
 295 # when encountering a 1.1 signed JAR file. If the identity is found
 296 # and is trusted, we grant it AllPermission. Note: the default policy
 297 # provider (sun.security.provider.PolicyFile) does not support this property.
 298 #
 299 policy.ignoreIdentityScope=false
 300 
 301 #
 302 # Default keystore type.
 303 #
 304 keystore.type=pkcs12
 305 
 306 #
 307 # Controls compatibility mode for JKS and PKCS12 keystore types.
 308 #
 309 # When set to &#39;true&#39;, both JKS and PKCS12 keystore types support loading
 310 # keystore files in either JKS or PKCS12 format. When set to &#39;false&#39; the
 311 # JKS keystore type supports loading only JKS keystore files and the PKCS12
 312 # keystore type supports loading only PKCS12 keystore files.
 313 #
 314 keystore.type.compat=true
 315 
 316 #
 317 # List of comma-separated packages that start with or equal this string
 318 # will cause a security exception to be thrown when passed to the
 319 # SecurityManager::checkPackageAccess method unless the corresponding
 320 # RuntimePermission(&quot;accessClassInPackage.&quot;+package) has been granted.
 321 #
 322 package.access=sun.misc.,\
 323                sun.reflect.,\
 324 
 325 #
 326 # List of comma-separated packages that start with or equal this string
 327 # will cause a security exception to be thrown when passed to the
 328 # SecurityManager::checkPackageDefinition method unless the corresponding
 329 # RuntimePermission(&quot;defineClassInPackage.&quot;+package) has been granted.
 330 #
 331 # By default, none of the class loaders supplied with the JDK call
 332 # checkPackageDefinition.
 333 #
 334 package.definition=sun.misc.,\
 335                    sun.reflect.,\
 336 
 337 #
 338 # Determines whether this properties file can be appended to
 339 # or overridden on the command line via -Djava.security.properties
 340 #
 341 security.overridePropertiesFile=true
 342 
 343 #
 344 # Determines the default key and trust manager factory algorithms for
 345 # the javax.net.ssl package.
 346 #
 347 ssl.KeyManagerFactory.algorithm=SunX509
 348 ssl.TrustManagerFactory.algorithm=PKIX
 349 
 350 #
 351 # The Java-level namelookup cache policy for successful lookups:
 352 #
 353 # any negative value: caching forever
 354 # any positive value: the number of seconds to cache an address for
 355 # zero: do not cache
 356 #
 357 # default value is forever (FOREVER). For security reasons, this
 358 # caching is made forever when a security manager is set. When a security
 359 # manager is not set, the default behavior in this implementation
 360 # is to cache for 30 seconds.
 361 #
 362 # NOTE: setting this to anything other than the default value can have
 363 #       serious security implications. Do not set it unless
 364 #       you are sure you are not exposed to DNS spoofing attack.
 365 #
 366 #networkaddress.cache.ttl=-1
 367 
 368 # The Java-level namelookup cache policy for failed lookups:
 369 #
 370 # any negative value: cache forever
 371 # any positive value: the number of seconds to cache negative lookup results
 372 # zero: do not cache
 373 #
 374 # In some Microsoft Windows networking environments that employ
 375 # the WINS name service in addition to DNS, name service lookups
 376 # that fail may take a noticeably long time to return (approx. 5 seconds).
 377 # For this reason the default caching policy is to maintain these
 378 # results for 10 seconds.
 379 #
 380 networkaddress.cache.negative.ttl=10
 381 
 382 #
 383 # Properties to configure OCSP for certificate revocation checking
 384 #
 385 
 386 # Enable OCSP
 387 #
 388 # By default, OCSP is not used for certificate revocation checking.
 389 # This property enables the use of OCSP when set to the value &quot;true&quot;.
 390 #
 391 # NOTE: SocketPermission is required to connect to an OCSP responder.
 392 #
 393 # Example,
 394 #   ocsp.enable=true
 395 
 396 #
 397 # Location of the OCSP responder
 398 #
 399 # By default, the location of the OCSP responder is determined implicitly
 400 # from the certificate being validated. This property explicitly specifies
 401 # the location of the OCSP responder. The property is used when the
 402 # Authority Information Access extension (defined in RFC 5280) is absent
 403 # from the certificate or when it requires overriding.
 404 #
 405 # Example,
 406 #   ocsp.responderURL=http://ocsp.example.net:80
 407 
 408 #
 409 # Subject name of the OCSP responder&#39;s certificate
 410 #
 411 # By default, the certificate of the OCSP responder is that of the issuer
 412 # of the certificate being validated. This property identifies the certificate
 413 # of the OCSP responder when the default does not apply. Its value is a string
 414 # distinguished name (defined in RFC 2253) which identifies a certificate in
 415 # the set of certificates supplied during cert path validation. In cases where
 416 # the subject name alone is not sufficient to uniquely identify the certificate
 417 # then both the &quot;ocsp.responderCertIssuerName&quot; and
 418 # &quot;ocsp.responderCertSerialNumber&quot; properties must be used instead. When this
 419 # property is set then those two properties are ignored.
 420 #
 421 # Example,
 422 #   ocsp.responderCertSubjectName=CN=OCSP Responder, O=XYZ Corp
 423 
 424 #
 425 # Issuer name of the OCSP responder&#39;s certificate
 426 #
 427 # By default, the certificate of the OCSP responder is that of the issuer
 428 # of the certificate being validated. This property identifies the certificate
 429 # of the OCSP responder when the default does not apply. Its value is a string
 430 # distinguished name (defined in RFC 2253) which identifies a certificate in
 431 # the set of certificates supplied during cert path validation. When this
 432 # property is set then the &quot;ocsp.responderCertSerialNumber&quot; property must also
 433 # be set. When the &quot;ocsp.responderCertSubjectName&quot; property is set then this
 434 # property is ignored.
 435 #
 436 # Example,
 437 #   ocsp.responderCertIssuerName=CN=Enterprise CA, O=XYZ Corp
 438 
 439 #
 440 # Serial number of the OCSP responder&#39;s certificate
 441 #
 442 # By default, the certificate of the OCSP responder is that of the issuer
 443 # of the certificate being validated. This property identifies the certificate
 444 # of the OCSP responder when the default does not apply. Its value is a string
 445 # of hexadecimal digits (colon or space separators may be present) which
 446 # identifies a certificate in the set of certificates supplied during cert path
 447 # validation. When this property is set then the &quot;ocsp.responderCertIssuerName&quot;
 448 # property must also be set. When the &quot;ocsp.responderCertSubjectName&quot; property
 449 # is set then this property is ignored.
 450 #
 451 # Example,
 452 #   ocsp.responderCertSerialNumber=2A:FF:00
 453 
 454 #
 455 # Policy for failed Kerberos KDC lookups:
 456 #
 457 # When a KDC is unavailable (network error, service failure, etc), it is
 458 # put inside a blacklist and accessed less often for future requests. The
 459 # value (case-insensitive) for this policy can be:
 460 #
 461 # tryLast
 462 #    KDCs in the blacklist are always tried after those not on the list.
 463 #
 464 # tryLess[:max_retries,timeout]
 465 #    KDCs in the blacklist are still tried by their order in the configuration,
 466 #    but with smaller max_retries and timeout values. max_retries and timeout
 467 #    are optional numerical parameters (default 1 and 5000, which means once
 468 #    and 5 seconds). Please notes that if any of the values defined here is
 469 #    more than what is defined in krb5.conf, it will be ignored.
 470 #
 471 # Whenever a KDC is detected as available, it is removed from the blacklist.
 472 # The blacklist is reset when krb5.conf is reloaded. You can add
 473 # refreshKrb5Config=true to a JAAS configuration file so that krb5.conf is
 474 # reloaded whenever a JAAS authentication is attempted.
 475 #
 476 # Example,
 477 #   krb5.kdc.bad.policy = tryLast
 478 #   krb5.kdc.bad.policy = tryLess:2,2000
 479 #
 480 krb5.kdc.bad.policy = tryLast
 481 
 482 #
 483 # Kerberos cross-realm referrals (RFC 6806)
 484 #
 485 # OpenJDK&#39;s Kerberos client supports cross-realm referrals as defined in
 486 # RFC 6806. This allows to setup more dynamic environments in which clients
 487 # do not need to know in advance how to reach the realm of a target principal
 488 # (either a user or service).
 489 #
 490 # When a client issues an AS or a TGS request, the &quot;canonicalize&quot; option
 491 # is set to announce support of this feature. A KDC server may fulfill the
 492 # request or reply referring the client to a different one. If referred,
 493 # the client will issue a new request and the cycle repeats.
 494 #
 495 # In addition to referrals, the &quot;canonicalize&quot; option allows the KDC server
 496 # to change the client name in response to an AS request. For security reasons,
 497 # RFC 6806 (section 11) FAST scheme is enforced.
 498 #
 499 # Disable Kerberos cross-realm referrals. Value may be overwritten with a
 500 # System property (-Dsun.security.krb5.disableReferrals).
 501 sun.security.krb5.disableReferrals=false
 502 
 503 # Maximum number of AS or TGS referrals to avoid infinite loops. Value may
 504 # be overwritten with a System property (-Dsun.security.krb5.maxReferrals).
 505 sun.security.krb5.maxReferrals=5
 506 
 507 #
 508 # This property contains a list of disabled EC Named Curves that can be included
 509 # in the jdk.[tls|certpath|jar].disabledAlgorithms properties.  To include this
 510 # list in any of the disabledAlgorithms properties, add the property name as
 511 # an entry.
 512 jdk.disabled.namedCurves = secp112r1, secp112r2, secp128r1, secp128r2, \
 513     secp160k1, secp160r1, secp160r2, secp192k1, secp192r1, secp224k1, \
 514     secp224r1, secp256k1, sect113r1, sect113r2, sect131r1, sect131r2, \
 515     sect163k1, sect163r1, sect163r2, sect193r1, sect193r2, sect233k1, \
 516     sect233r1, sect239k1, sect283k1, sect283r1, sect409k1, sect409r1, \
 517     sect571k1, sect571r1, X9.62 c2tnb191v1, X9.62 c2tnb191v2, \
 518     X9.62 c2tnb191v3, X9.62 c2tnb239v1, X9.62 c2tnb239v2, X9.62 c2tnb239v3, \
 519     X9.62 c2tnb359v1, X9.62 c2tnb431r1, X9.62 prime192v2, X9.62 prime192v3, \
 520     X9.62 prime239v1, X9.62 prime239v2, X9.62 prime239v3, brainpoolP256r1, \
 521     brainpoolP320r1, brainpoolP384r1, brainpoolP512r1
 522 
 523 #
 524 # Algorithm restrictions for certification path (CertPath) processing
 525 #
 526 # In some environments, certain algorithms or key lengths may be undesirable
 527 # for certification path building and validation.  For example, &quot;MD2&quot; is
 528 # generally no longer considered to be a secure hash algorithm.  This section
 529 # describes the mechanism for disabling algorithms based on algorithm name
 530 # and/or key length.  This includes algorithms used in certificates, as well
 531 # as revocation information such as CRLs and signed OCSP Responses.
 532 # The syntax of the disabled algorithm string is described as follows:
 533 #   DisabledAlgorithms:
 534 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 535 #
 536 #   DisabledAlgorithm:
 537 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint } | IncludeProperty
 538 #
 539 #   AlgorithmName:
 540 #       (see below)
 541 #
 542 #   Constraint:
 543 #       KeySizeConstraint | CAConstraint | DenyAfterConstraint |
 544 #       UsageConstraint
 545 #
 546 #   KeySizeConstraint:
 547 #       keySize Operator KeyLength
 548 #
 549 #   Operator:
 550 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 551 #
 552 #   KeyLength:
 553 #       Integer value of the algorithm&#39;s key length in bits
 554 #
 555 #   CAConstraint:
 556 #       jdkCA
 557 #
 558 #   DenyAfterConstraint:
 559 #       denyAfter YYYY-MM-DD
 560 #
 561 #   UsageConstraint:
 562 #       usage [TLSServer] [TLSClient] [SignedJAR]
 563 #
 564 #   IncludeProperty:
 565 #       include &lt;security property&gt;
 566 #
 567 # The &quot;AlgorithmName&quot; is the standard algorithm name of the disabled
 568 # algorithm. See the Java Security Standard Algorithm Names Specification
 569 # for information about Standard Algorithm Names.  Matching is
 570 # performed using a case-insensitive sub-element matching rule.  (For
 571 # example, in &quot;SHA1withECDSA&quot; the sub-elements are &quot;SHA1&quot; for hashing and
 572 # &quot;ECDSA&quot; for signatures.)  If the assertion &quot;AlgorithmName&quot; is a
 573 # sub-element of the certificate algorithm name, the algorithm will be
 574 # rejected during certification path building and validation.  For example,
 575 # the assertion algorithm name &quot;DSA&quot; will disable all certificate algorithms
 576 # that rely on DSA, such as NONEwithDSA, SHA1withDSA.  However, the assertion
 577 # will not disable algorithms related to &quot;ECDSA&quot;.
 578 #
 579 # The &quot;IncludeProperty&quot; allows a implementation-defined security property that
 580 # can be included in the disabledAlgorithms properties.  These properties are
 581 # to help manage common actions easier across multiple disabledAlgorithm
 582 # properties.
 583 # There is one defined security property:  jdk.disabled.NamedCurves
 584 # See the property for more specific details.
 585 #
 586 #
 587 # A &quot;Constraint&quot; defines restrictions on the keys and/or certificates for
 588 # a specified AlgorithmName:
 589 #
 590 #   KeySizeConstraint:
 591 #     keySize Operator KeyLength
 592 #       The constraint requires a key of a valid size range if the
 593 #       &quot;AlgorithmName&quot; is of a key algorithm.  The &quot;KeyLength&quot; indicates
 594 #       the key size specified in number of bits.  For example,
 595 #       &quot;RSA keySize &lt;= 1024&quot; indicates that any RSA key with key size less
 596 #       than or equal to 1024 bits should be disabled, and
 597 #       &quot;RSA keySize &lt; 1024, RSA keySize &gt; 2048&quot; indicates that any RSA key
 598 #       with key size less than 1024 or greater than 2048 should be disabled.
 599 #       This constraint is only used on algorithms that have a key size.
 600 #
 601 #   CAConstraint:
 602 #     jdkCA
 603 #       This constraint prohibits the specified algorithm only if the
 604 #       algorithm is used in a certificate chain that terminates at a marked
 605 #       trust anchor in the lib/security/cacerts keystore.  If the jdkCA
 606 #       constraint is not set, then all chains using the specified algorithm
 607 #       are restricted.  jdkCA may only be used once in a DisabledAlgorithm
 608 #       expression.
 609 #       Example:  To apply this constraint to SHA-1 certificates, include
 610 #       the following:  &quot;SHA1 jdkCA&quot;
 611 #
 612 #   DenyAfterConstraint:
 613 #     denyAfter YYYY-MM-DD
 614 #       This constraint prohibits a certificate with the specified algorithm
 615 #       from being used after the date regardless of the certificate&#39;s
 616 #       validity.  JAR files that are signed and timestamped before the
 617 #       constraint date with certificates containing the disabled algorithm
 618 #       will not be restricted.  The date is processed in the UTC timezone.
 619 #       This constraint can only be used once in a DisabledAlgorithm
 620 #       expression.
 621 #       Example:  To deny usage of RSA 2048 bit certificates after Feb 3 2020,
 622 #       use the following:  &quot;RSA keySize == 2048 &amp; denyAfter 2020-02-03&quot;
 623 #
 624 #   UsageConstraint:
 625 #     usage [TLSServer] [TLSClient] [SignedJAR]
 626 #       This constraint prohibits the specified algorithm for
 627 #       a specified usage.  This should be used when disabling an algorithm
 628 #       for all usages is not practical. &#39;TLSServer&#39; restricts the algorithm
 629 #       in TLS server certificate chains when server authentication is
 630 #       performed. &#39;TLSClient&#39; restricts the algorithm in TLS client
 631 #       certificate chains when client authentication is performed.
 632 #       &#39;SignedJAR&#39; constrains use of certificates in signed jar files.
 633 #       The usage type follows the keyword and more than one usage type can
 634 #       be specified with a whitespace delimiter.
 635 #       Example:  &quot;SHA1 usage TLSServer TLSClient&quot;
 636 #
 637 # When an algorithm must satisfy more than one constraint, it must be
 638 # delimited by an ampersand &#39;&amp;&#39;.  For example, to restrict certificates in a
 639 # chain that terminate at a distribution provided trust anchor and contain
 640 # RSA keys that are less than or equal to 1024 bits, add the following
 641 # constraint:  &quot;RSA keySize &lt;= 1024 &amp; jdkCA&quot;.
 642 #
 643 # All DisabledAlgorithms expressions are processed in the order defined in the
 644 # property.  This requires lower keysize constraints to be specified
 645 # before larger keysize constraints of the same algorithm.  For example:
 646 # &quot;RSA keySize &lt; 1024 &amp; jdkCA, RSA keySize &lt; 2048&quot;.
 647 #
 648 # Note: The algorithm restrictions do not apply to trust anchors or
 649 # self-signed certificates.
 650 #
 651 # Note: This property is currently used by Oracle&#39;s PKIX implementation. It
 652 # is not guaranteed to be examined and used by other implementations.
 653 #
 654 # Example:
 655 #   jdk.certpath.disabledAlgorithms=MD2, DSA, RSA keySize &lt; 2048
 656 #
 657 #
 658 jdk.certpath.disabledAlgorithms=MD2, MD5, SHA1 jdkCA &amp; usage TLSServer, \
 659     RSA keySize &lt; 1024, DSA keySize &lt; 1024, EC keySize &lt; 224, \
 660     include jdk.disabled.namedCurves
 661 
 662 #
 663 # Algorithm restrictions for signed JAR files
 664 #
 665 # In some environments, certain algorithms or key lengths may be undesirable
 666 # for signed JAR validation.  For example, &quot;MD2&quot; is generally no longer
 667 # considered to be a secure hash algorithm.  This section describes the
 668 # mechanism for disabling algorithms based on algorithm name and/or key length.
 669 # JARs signed with any of the disabled algorithms or key sizes will be treated
 670 # as unsigned.
 671 #
 672 # The syntax of the disabled algorithm string is described as follows:
 673 #   DisabledAlgorithms:
 674 #       &quot; DisabledAlgorithm { , DisabledAlgorithm } &quot;
 675 #
 676 #   DisabledAlgorithm:
 677 #       AlgorithmName [Constraint] { &#39;&amp;&#39; Constraint }
 678 #
 679 #   AlgorithmName:
 680 #       (see below)
 681 #
 682 #   Constraint:
 683 #       KeySizeConstraint | DenyAfterConstraint
 684 #
 685 #   KeySizeConstraint:
 686 #       keySize Operator KeyLength
 687 #
 688 #   DenyAfterConstraint:
 689 #       denyAfter YYYY-MM-DD
 690 #
 691 #   Operator:
 692 #       &lt;= | &lt; | == | != | &gt;= | &gt;
 693 #
 694 #   KeyLength:
 695 #       Integer value of the algorithm&#39;s key length in bits
 696 #
 697 # Note: This property is currently used by the JDK Reference
 698 # implementation. It is not guaranteed to be examined and used by other
 699 # implementations.
 700 #
 701 # See &quot;jdk.certpath.disabledAlgorithms&quot; for syntax descriptions.
 702 #
 703 jdk.jar.disabledAlgorithms=MD2, MD5, RSA keySize &lt; 1024, \
 704       DSA keySize &lt; 1024, include jdk.disabled.namedCurves
 705 
 706 #
 707 # Algorithm restrictions for Secure Socket Layer/Transport Layer Security
 708 # (SSL/TLS/DTLS) processing
 709 #
 710 # In some environments, certain algorithms or key lengths may be undesirable
 711 # when using SSL/TLS/DTLS.  This section describes the mechanism for disabling
 712 # algorithms during SSL/TLS/DTLS security parameters negotiation, including
 713 # protocol version negotiation, cipher suites selection, named groups
 714 # selection, signature schemes selection, peer authentication and key
 715 # exchange mechanisms.
 716 #
 717 # Disabled algorithms will not be negotiated for SSL/TLS connections, even
 718 # if they are enabled explicitly in an application.
 719 #
 720 # For PKI-based peer authentication and key exchange mechanisms, this list
 721 # of disabled algorithms will also be checked during certification path
 722 # building and validation, including algorithms used in certificates, as
 723 # well as revocation information such as CRLs and signed OCSP Responses.
 724 # This is in addition to the jdk.certpath.disabledAlgorithms property above.
 725 #
 726 # See the specification of &quot;jdk.certpath.disabledAlgorithms&quot; for the
 727 # syntax of the disabled algorithm string.
 728 #
 729 # Note: The algorithm restrictions do not apply to trust anchors or
 730 # self-signed certificates.
 731 #
 732 # Note: This property is currently used by the JDK Reference implementation.
 733 # It is not guaranteed to be examined and used by other implementations.
 734 #
 735 # Example:
 736 #   jdk.tls.disabledAlgorithms=MD5, SSLv3, DSA, RSA keySize &lt; 2048, \
 737 #       rsa_pkcs1_sha1, secp224r1
 738 jdk.tls.disabledAlgorithms=SSLv3, RC4, DES, MD5withRSA, DH keySize &lt; 1024, \
 739     EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \
 740     include jdk.disabled.namedCurves
 741 
 742 #
 743 # Legacy algorithms for Secure Socket Layer/Transport Layer Security (SSL/TLS)
 744 # processing in JSSE implementation.
 745 #
 746 # In some environments, a certain algorithm may be undesirable but it
 747 # cannot be disabled because of its use in legacy applications.  Legacy
 748 # algorithms may still be supported, but applications should not use them
 749 # as the security strength of legacy algorithms are usually not strong enough
 750 # in practice.
 751 #
 752 # During SSL/TLS security parameters negotiation, legacy algorithms will
 753 # not be negotiated unless there are no other candidates.
 754 #
 755 # The syntax of the legacy algorithms string is described as this Java
 756 # BNF-style:
 757 #   LegacyAlgorithms:
 758 #       &quot; LegacyAlgorithm { , LegacyAlgorithm } &quot;
 759 #
 760 #   LegacyAlgorithm:
 761 #       AlgorithmName (standard JSSE algorithm name)
 762 #
 763 # See the specification of security property &quot;jdk.certpath.disabledAlgorithms&quot;
 764 # for the syntax and description of the &quot;AlgorithmName&quot; notation.
 765 #
 766 # Per SSL/TLS specifications, cipher suites have the form:
 767 #       SSL_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 768 # or
 769 #       TLS_KeyExchangeAlg_WITH_CipherAlg_MacAlg
 770 #
 771 # For example, the cipher suite TLS_RSA_WITH_AES_128_CBC_SHA uses RSA as the
 772 # key exchange algorithm, AES_128_CBC (128 bits AES cipher algorithm in CBC
 773 # mode) as the cipher (encryption) algorithm, and SHA-1 as the message digest
 774 # algorithm for HMAC.
 775 #
 776 # The LegacyAlgorithm can be one of the following standard algorithm names:
 777 #     1. JSSE cipher suite name, e.g., TLS_RSA_WITH_AES_128_CBC_SHA
 778 #     2. JSSE key exchange algorithm name, e.g., RSA
 779 #     3. JSSE cipher (encryption) algorithm name, e.g., AES_128_CBC
 780 #     4. JSSE message digest algorithm name, e.g., SHA
 781 #
 782 # See SSL/TLS specifications and the Java Security Standard Algorithm Names
 783 # Specification for information about the algorithm names.
 784 #
 785 # Note: If a legacy algorithm is also restricted through the
 786 # jdk.tls.disabledAlgorithms property or the
 787 # java.security.AlgorithmConstraints API (See
 788 # javax.net.ssl.SSLParameters.setAlgorithmConstraints()),
 789 # then the algorithm is completely disabled and will not be negotiated.
 790 #
 791 # Note: This property is currently used by the JDK Reference implementation.
 792 # It is not guaranteed to be examined and used by other implementations.
 793 # There is no guarantee the property will continue to exist or be of the
 794 # same syntax in future releases.
 795 #
 796 # Example:
 797 #   jdk.tls.legacyAlgorithms=DH_anon, DES_CBC, SSL_RSA_WITH_RC4_128_MD5
 798 #
 799 jdk.tls.legacyAlgorithms=NULL, anon, RC4, DES, 3DES_EDE_CBC
 800 
 801 #
 802 # The pre-defined default finite field Diffie-Hellman ephemeral (DHE)
 803 # parameters for Transport Layer Security (SSL/TLS/DTLS) processing.
 804 #
 805 # In traditional SSL/TLS/DTLS connections where finite field DHE parameters
 806 # negotiation mechanism is not used, the server offers the client group
 807 # parameters, base generator g and prime modulus p, for DHE key exchange.
 808 # It is recommended to use dynamic group parameters.  This property defines
 809 # a mechanism that allows you to specify custom group parameters.
 810 #
 811 # The syntax of this property string is described as this Java BNF-style:
 812 #   DefaultDHEParameters:
 813 #       DefinedDHEParameters { , DefinedDHEParameters }
 814 #
 815 #   DefinedDHEParameters:
 816 #       &quot;{&quot; DHEPrimeModulus , DHEBaseGenerator &quot;}&quot;
 817 #
 818 #   DHEPrimeModulus:
 819 #       HexadecimalDigits
 820 #
 821 #   DHEBaseGenerator:
 822 #       HexadecimalDigits
 823 #
 824 #   HexadecimalDigits:
 825 #       HexadecimalDigit { HexadecimalDigit }
 826 #
 827 #   HexadecimalDigit: one of
 828 #       0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f
 829 #
 830 # Whitespace characters are ignored.
 831 #
 832 # The &quot;DefinedDHEParameters&quot; defines the custom group parameters, prime
 833 # modulus p and base generator g, for a particular size of prime modulus p.
 834 # The &quot;DHEPrimeModulus&quot; defines the hexadecimal prime modulus p, and the
 835 # &quot;DHEBaseGenerator&quot; defines the hexadecimal base generator g of a group
 836 # parameter.  It is recommended to use safe primes for the custom group
 837 # parameters.
 838 #
 839 # If this property is not defined or the value is empty, the underlying JSSE
 840 # provider&#39;s default group parameter is used for each connection.
 841 #
 842 # If the property value does not follow the grammar, or a particular group
 843 # parameter is not valid, the connection will fall back and use the
 844 # underlying JSSE provider&#39;s default group parameter.
 845 #
 846 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 847 # is not guaranteed to be examined and used by other implementations.
 848 #
 849 # Example:
 850 #   jdk.tls.server.defaultDHEParameters=
 851 #       { \
 852 #       FFFFFFFF FFFFFFFF C90FDAA2 2168C234 C4C6628B 80DC1CD1 \
 853 #       29024E08 8A67CC74 020BBEA6 3B139B22 514A0879 8E3404DD \
 854 #       EF9519B3 CD3A431B 302B0A6D F25F1437 4FE1356D 6D51C245 \
 855 #       E485B576 625E7EC6 F44C42E9 A637ED6B 0BFF5CB6 F406B7ED \
 856 #       EE386BFB 5A899FA5 AE9F2411 7C4B1FE6 49286651 ECE65381 \
 857 #       FFFFFFFF FFFFFFFF, 2}
 858 
 859 #
 860 # TLS key limits on symmetric cryptographic algorithms
 861 #
 862 # This security property sets limits on algorithms key usage in TLS 1.3.
 863 # When the amount of data encrypted exceeds the algorithm value listed below,
 864 # a KeyUpdate message will trigger a key change.  This is for symmetric ciphers
 865 # with TLS 1.3 only.
 866 #
 867 # The syntax for the property is described below:
 868 #   KeyLimits:
 869 #       &quot; KeyLimit { , KeyLimit } &quot;
 870 #
 871 #   WeakKeyLimit:
 872 #       AlgorithmName Action Length
 873 #
 874 #   AlgorithmName:
 875 #       A full algorithm transformation.
 876 #
 877 #   Action:
 878 #       KeyUpdate
 879 #
 880 #   Length:
 881 #       The amount of encrypted data in a session before the Action occurs
 882 #       This value may be an integer value in bytes, or as a power of two, 2^29.
 883 #
 884 #   KeyUpdate:
 885 #       The TLS 1.3 KeyUpdate handshake process begins when the Length amount
 886 #       is fulfilled.
 887 #
 888 # Note: This property is currently used by OpenJDK&#39;s JSSE implementation. It
 889 # is not guaranteed to be examined and used by other implementations.
 890 #
 891 jdk.tls.keyLimits=AES/GCM/NoPadding KeyUpdate 2^37
 892 
 893 #
 894 # Cryptographic Jurisdiction Policy defaults
 895 #
 896 # Import and export control rules on cryptographic software vary from
 897 # country to country.  By default, Java provides two different sets of
 898 # cryptographic policy files[1]:
 899 #
 900 #     unlimited:  These policy files contain no restrictions on cryptographic
 901 #                 strengths or algorithms
 902 #
 903 #     limited:    These policy files contain more restricted cryptographic
 904 #                 strengths
 905 #
 906 # The default setting is determined by the value of the &quot;crypto.policy&quot;
 907 # Security property below. If your country or usage requires the
 908 # traditional restrictive policy, the &quot;limited&quot; Java cryptographic
 909 # policy is still available and may be appropriate for your environment.
 910 #
 911 # If you have restrictions that do not fit either use case mentioned
 912 # above, Java provides the capability to customize these policy files.
 913 # The &quot;crypto.policy&quot; security property points to a subdirectory
 914 # within &lt;java-home&gt;/conf/security/policy/ which can be customized.
 915 # Please see the &lt;java-home&gt;/conf/security/policy/README.txt file or consult
 916 # the Java Security Guide/JCA documentation for more information.
 917 #
 918 # YOU ARE ADVISED TO CONSULT YOUR EXPORT/IMPORT CONTROL COUNSEL OR ATTORNEY
 919 # TO DETERMINE THE EXACT REQUIREMENTS.
 920 #
 921 # [1] Please note that the JCE for Java SE, including the JCE framework,
 922 # cryptographic policy files, and standard JCE providers provided with
 923 # the Java SE, have been reviewed and approved for export as mass market
 924 # encryption item by the US Bureau of Industry and Security.
 925 #
 926 # Note: This property is currently used by the JDK Reference implementation.
 927 # It is not guaranteed to be examined and used by other implementations.
 928 #
 929 crypto.policy=crypto.policydir-tbd
 930 
 931 #
 932 # The policy for the XML Signature secure validation mode. The mode is
 933 # enabled by setting the property &quot;org.jcp.xml.dsig.secureValidation&quot; to
 934 # true with the javax.xml.crypto.XMLCryptoContext.setProperty() method,
 935 # or by running the code with a SecurityManager.
 936 #
 937 #   Policy:
 938 #       Constraint {&quot;,&quot; Constraint }
 939 #   Constraint:
 940 #       AlgConstraint | MaxTransformsConstraint | MaxReferencesConstraint |
 941 #       ReferenceUriSchemeConstraint | KeySizeConstraint | OtherConstraint
 942 #   AlgConstraint
 943 #       &quot;disallowAlg&quot; Uri
 944 #   MaxTransformsConstraint:
 945 #       &quot;maxTransforms&quot; Integer
 946 #   MaxReferencesConstraint:
 947 #       &quot;maxReferences&quot; Integer
 948 #   ReferenceUriSchemeConstraint:
 949 #       &quot;disallowReferenceUriSchemes&quot; String { String }
 950 #   KeySizeConstraint:
 951 #       &quot;minKeySize&quot; KeyAlg Integer
 952 #   OtherConstraint:
 953 #       &quot;noDuplicateIds&quot; | &quot;noRetrievalMethodLoops&quot;
 954 #
 955 # For AlgConstraint, Uri is the algorithm URI String that is not allowed.
 956 # See the XML Signature Recommendation for more information on algorithm
 957 # URI Identifiers. For KeySizeConstraint, KeyAlg is the standard algorithm
 958 # name of the key type (ex: &quot;RSA&quot;). If the MaxTransformsConstraint,
 959 # MaxReferencesConstraint or KeySizeConstraint (for the same key type) is
 960 # specified more than once, only the last entry is enforced.
 961 #
 962 # Note: This property is currently used by the JDK Reference implementation. It
 963 # is not guaranteed to be examined and used by other implementations.
 964 #
 965 jdk.xml.dsig.secureValidationPolicy=\
 966     disallowAlg http://www.w3.org/TR/1999/REC-xslt-19991116,\
 967     disallowAlg http://www.w3.org/2001/04/xmldsig-more#rsa-md5,\
 968     disallowAlg http://www.w3.org/2001/04/xmldsig-more#hmac-md5,\
 969     disallowAlg http://www.w3.org/2001/04/xmldsig-more#md5,\
 970     maxTransforms 5,\
 971     maxReferences 30,\
 972     disallowReferenceUriSchemes file http https,\
 973     minKeySize RSA 1024,\
 974     minKeySize DSA 1024,\
 975     minKeySize EC 224,\
 976     noDuplicateIds,\
 977     noRetrievalMethodLoops
 978 
 979 #
 980 # Serialization system-wide filter
 981 #
 982 # A filter, if configured, is used by java.io.ObjectInputStream during
 983 # deserialization to check the contents of the stream.
 984 # A filter is configured as a sequence of patterns, each pattern is either
 985 # matched against the name of a class in the stream or defines a limit.
 986 # Patterns are separated by &quot;;&quot; (semicolon).
 987 # Whitespace is significant and is considered part of the pattern.
 988 #
 989 # If the system property jdk.serialFilter is also specified, it supersedes
 990 # the security property value defined here.
 991 #
 992 # If a pattern includes a &quot;=&quot;, it sets a limit.
 993 # If a limit appears more than once the last value is used.
 994 # Limits are checked before classes regardless of the order in the
 995 # sequence of patterns.
 996 # If any of the limits are exceeded, the filter status is REJECTED.
 997 #
 998 #   maxdepth=value - the maximum depth of a graph
 999 #   maxrefs=value  - the maximum number of internal references
1000 #   maxbytes=value - the maximum number of bytes in the input stream
1001 #   maxarray=value - the maximum array length allowed
1002 #
1003 # Other patterns, from left to right, match the class or package name as
1004 # returned from Class.getName.
1005 # If the class is an array type, the class or package to be matched is the
1006 # element type.
1007 # Arrays of any number of dimensions are treated the same as the element type.
1008 # For example, a pattern of &quot;!example.Foo&quot;, rejects creation of any instance or
1009 # array of example.Foo.
1010 #
1011 # If the pattern starts with &quot;!&quot;, the status is REJECTED if the remaining
1012 # pattern is matched; otherwise the status is ALLOWED if the pattern matches.
1013 # If the pattern contains &quot;/&quot;, the non-empty prefix up to the &quot;/&quot; is the
1014 # module name;
1015 #   if the module name matches the module name of the class then
1016 #   the remaining pattern is matched with the class name.
1017 #   If there is no &quot;/&quot;, the module name is not compared.
1018 # If the pattern ends with &quot;.**&quot; it matches any class in the package and all
1019 # subpackages.
1020 # If the pattern ends with &quot;.*&quot; it matches any class in the package.
1021 # If the pattern ends with &quot;*&quot;, it matches any class with the pattern as a
1022 # prefix.
1023 # If the pattern is equal to the class name, it matches.
1024 # Otherwise, the status is UNDECIDED.
1025 #
1026 #jdk.serialFilter=pattern;pattern
1027 
1028 #
1029 # RMI Registry Serial Filter
1030 #
1031 # The filter pattern uses the same format as jdk.serialFilter.
1032 # This filter can override the builtin filter if additional types need to be
1033 # allowed or rejected from the RMI Registry or to decrease limits but not
1034 # to increase limits.
1035 # If the limits (maxdepth, maxrefs, or maxbytes) are exceeded, the object is rejected.
1036 #
1037 # Each non-array type is allowed or rejected if it matches one of the patterns,
1038 # evaluated from left to right, and is otherwise allowed. Arrays of any
1039 # component type, including subarrays and arrays of primitives, are allowed.
1040 #
1041 # Array construction of any component type, including subarrays and arrays of
1042 # primitives, are allowed unless the length is greater than the maxarray limit.
1043 # The filter is applied to each array element.
1044 #
1045 # Note: This property is currently used by the JDK Reference implementation.
1046 # It is not guaranteed to be examined and used by other implementations.
1047 #
1048 # The built-in filter allows subclasses of allowed classes and
1049 # can approximately be represented as the pattern:
1050 #
1051 #sun.rmi.registry.registryFilter=\
1052 #    maxarray=1000000;\
1053 #    maxdepth=20;\
1054 #    java.lang.String;\
1055 #    java.lang.Number;\
1056 #    java.lang.reflect.Proxy;\
1057 #    java.rmi.Remote;\
1058 #    sun.rmi.server.UnicastRef;\
1059 #    sun.rmi.server.RMIClientSocketFactory;\
1060 #    sun.rmi.server.RMIServerSocketFactory;\
1061 #    java.rmi.activation.ActivationID;\
1062 #    java.rmi.server.UID
1063 #
1064 # RMI Distributed Garbage Collector (DGC) Serial Filter
1065 #
1066 # The filter pattern uses the same format as jdk.serialFilter.
1067 # This filter can override the builtin filter if additional types need to be
1068 # allowed or rejected from the RMI DGC.
1069 #
1070 # Note: This property is currently used by the JDK Reference implementation.
1071 # It is not guaranteed to be examined and used by other implementations.
1072 #
1073 # The builtin DGC filter can approximately be represented as the filter pattern:
1074 #
1075 #sun.rmi.transport.dgcFilter=\
1076 #    java.rmi.server.ObjID;\
1077 #    java.rmi.server.UID;\
1078 #    java.rmi.dgc.VMID;\
1079 #    java.rmi.dgc.Lease;\
1080 #    maxdepth=5;maxarray=10000
1081 
1082 #
1083 # JCEKS Encrypted Key Serial Filter
1084 #
1085 # This filter, if configured, is used by the JCEKS KeyStore during the
1086 # deserialization of the encrypted Key object stored inside a key entry.
1087 # If not configured or the filter result is UNDECIDED (i.e. none of the patterns
1088 # matches), the filter configured by jdk.serialFilter will be consulted.
1089 #
1090 # If the system property jceks.key.serialFilter is also specified, it supersedes
1091 # the security property value defined here.
1092 #
1093 # The filter pattern uses the same format as jdk.serialFilter. The default
1094 # pattern allows java.lang.Enum, java.security.KeyRep, java.security.KeyRep$Type,
1095 # and javax.crypto.spec.SecretKeySpec and rejects all the others.
1096 jceks.key.serialFilter = java.base/java.lang.Enum;java.base/java.security.KeyRep;\
1097   java.base/java.security.KeyRep$Type;java.base/javax.crypto.spec.SecretKeySpec;!*
1098 
1099 # The iteration count used for password-based encryption (PBE) in JCEKS
1100 # keystores. Values in the range 10000 to 5000000 are considered valid.
1101 # If the value is out of this range, or is not a number, or is unspecified;
1102 # a default of 200000 is used.
1103 #
1104 # If the system property jdk.jceks.iterationCount is also specified, it
1105 # supersedes the security property value defined here.
1106 #
1107 #jdk.jceks.iterationCount = 200000
1108 
1109 #
1110 # PKCS12 KeyStore properties
1111 #
1112 # The following properties, if configured, are used by the PKCS12 KeyStore
1113 # implementation during the creation of a new keystore. Several of the
1114 # properties may also be used when modifying an existing keystore. The
1115 # properties can be overridden by a KeyStore API that specifies its own
1116 # algorithms and parameters.
1117 #
1118 # If an existing PKCS12 keystore is loaded and then stored, the algorithm and
1119 # parameter used to generate the existing Mac will be reused. If the existing
1120 # keystore does not have a Mac, no Mac will be created while storing. If there
1121 # is at least one certificate in the existing keystore, the algorithm and
1122 # parameters used to encrypt the last certificate in the existing keystore will
1123 # be reused to encrypt all certificates while storing. If the last certificate
1124 # in the existing keystore is not encrypted, all certificates will be stored
1125 # unencrypted. If there is no certificate in the existing keystore, any newly
1126 # added certificate will be encrypted (or stored unencrypted if algorithm
1127 # value is &quot;NONE&quot;) using the &quot;keystore.pkcs12.certProtectionAlgorithm&quot; and
1128 # &quot;keystore.pkcs12.certPbeIterationCount&quot; values defined here. Existing private
1129 # and secret key(s) are not changed. Newly set private and secret key(s) will
1130 # be encrypted using the &quot;keystore.pkcs12.keyProtectionAlgorithm&quot; and
1131 # &quot;keystore.pkcs12.keyPbeIterationCount&quot; values defined here.
1132 #
1133 # In order to apply new algorithms and parameters to all entries in an
1134 # existing keystore, one can create a new keystore and add entries in the
1135 # existing keystore into the new keystore. This can be achieved by calling the
1136 # &quot;keytool -importkeystore&quot; command.
1137 #
1138 # If a system property of the same name is also specified, it supersedes the
1139 # security property value defined here.
1140 #
1141 # If the property is set to an illegal value,
1142 # an iteration count that is not a positive integer, or an unknown algorithm
1143 # name, an exception will be thrown when the property is used.
1144 # If the property is not set or empty, a default value will be used.
1145 #
1146 # Note: These properties are currently used by the JDK Reference implementation.
1147 # They are not guaranteed to be examined and used by other implementations.
1148 
1149 # The algorithm used to encrypt a certificate. This can be any non-Hmac PBE
1150 # algorithm defined in the Cipher section of the Java Security Standard
1151 # Algorithm Names Specification. When set to &quot;NONE&quot;, the certificate
1152 # is not encrypted. The default value is &quot;PBEWithSHA1AndRC2_40&quot;.
1153 #keystore.pkcs12.certProtectionAlgorithm = PBEWithSHA1AndRC2_40
1154 
1155 # The iteration count used by the PBE algorithm when encrypting a certificate.
1156 # This value must be a positive integer. The default value is 50000.
1157 #keystore.pkcs12.certPbeIterationCount = 50000
1158 
1159 # The algorithm used to encrypt a private key or secret key. This can be
1160 # any non-Hmac PBE algorithm defined in the Cipher section of the Java
1161 # Security Standard Algorithm Names Specification. The value must not be &quot;NONE&quot;.
1162 # The default value is &quot;PBEWithSHA1AndDESede&quot;.
1163 #keystore.pkcs12.keyProtectionAlgorithm = PBEWithSHA1AndDESede
1164 
1165 # The iteration count used by the PBE algorithm when encrypting a private key
1166 # or a secret key. This value must be a positive integer. The default value
1167 # is 50000.
1168 #keystore.pkcs12.keyPbeIterationCount = 50000
1169 
1170 # The algorithm used to calculate the optional MacData at the end of a PKCS12
1171 # file. This can be any HmacPBE algorithm defined in the Mac section of the
1172 # Java Security Standard Algorithm Names Specification. When set to &quot;NONE&quot;,
1173 # no Mac is generated. The default value is &quot;HmacPBESHA1&quot;.
1174 #keystore.pkcs12.macAlgorithm = HmacPBESHA1
1175 
1176 # The iteration count used by the MacData algorithm. This value must be a
1177 # positive integer. The default value is 100000.
1178 #keystore.pkcs12.macIterationCount = 100000
1179 
1180 #
1181 # Enhanced exception message information
1182 #
1183 # By default, exception messages should not include potentially sensitive
1184 # information such as file names, host names, or port numbers. This property
1185 # accepts one or more comma separated values, each of which represents a
1186 # category of enhanced exception message information to enable. Values are
1187 # case-insensitive. Leading and trailing whitespaces, surrounding each value,
1188 # are ignored. Unknown values are ignored.
1189 #
1190 # NOTE: Use caution before setting this property. Setting this property
1191 # exposes sensitive information in Exceptions, which could, for example,
1192 # propagate to untrusted code or be emitted in stack traces that are
1193 # inadvertently disclosed and made accessible over a public network.
1194 #
1195 # The categories are:
1196 #
1197 #  hostInfo - IOExceptions thrown by java.net.Socket and the socket types in the
1198 #             java.nio.channels package will contain enhanced exception
1199 #             message information
1200 #
1201 #  jar      - enables more detailed information in the IOExceptions thrown
1202 #             by classes in the java.util.jar package
1203 #
1204 # The property setting in this file can be overridden by a system property of
1205 # the same name, with the same syntax and possible values.
1206 #
1207 #jdk.includeInExceptions=hostInfo,jar
1208 
1209 #
1210 # Disabled mechanisms for the Simple Authentication and Security Layer (SASL)
1211 #
1212 # Disabled mechanisms will not be negotiated by both SASL clients and servers.
1213 # These mechanisms will be ignored if they are specified in the &quot;mechanisms&quot;
1214 # argument of &quot;Sasl.createSaslClient&quot; or the &quot;mechanism&quot; argument of
1215 # &quot;Sasl.createSaslServer&quot;.
1216 #
1217 # The value of this property is a comma-separated list of SASL mechanisms.
1218 # The mechanisms are case-sensitive. Whitespaces around the commas are ignored.
1219 #
1220 # Note: This property is currently used by the JDK Reference implementation.
1221 # It is not guaranteed to be examined and used by other implementations.
1222 #
1223 # Example:
1224 #   jdk.sasl.disabledMechanisms=PLAIN, CRAM-MD5, DIGEST-MD5
1225 jdk.sasl.disabledMechanisms=
1226 
1227 #
1228 # Policies for distrusting Certificate Authorities (CAs).
1229 #
1230 # This is a comma separated value of one or more case-sensitive strings, each
1231 # of which represents a policy for determining if a CA should be distrusted.
1232 # The supported values are:
1233 #
1234 #   SYMANTEC_TLS : Distrust TLS Server certificates anchored by a Symantec
1235 #   root CA and issued after April 16, 2019 unless issued by one of the
1236 #   following subordinate CAs which have a later distrust date:
1237 #     1. Apple IST CA 2 - G1, SHA-256 fingerprint:
1238 #        AC2B922ECFD5E01711772FEA8ED372DE9D1E2245FCE3F57A9CDBEC77296A424B
1239 #        Distrust after December 31, 2019.
1240 #     2. Apple IST CA 8 - G1, SHA-256 fingerprint:
1241 #        A4FE7C7F15155F3F0AEF7AAA83CF6E06DEB97CA3F909DF920AC1490882D488ED
1242 #        Distrust after December 31, 2019.
1243 #
1244 # Leading and trailing whitespace surrounding each value are ignored.
1245 # Unknown values are ignored. If the property is commented out or set to the
1246 # empty String, no policies are enforced.
1247 #
1248 # Note: This property is currently used by the JDK Reference implementation.
1249 # It is not guaranteed to be supported by other SE implementations. Also, this
1250 # property does not override other security properties which can restrict
1251 # certificates such as jdk.tls.disabledAlgorithms or
1252 # jdk.certpath.disabledAlgorithms; those restrictions are still enforced even
1253 # if this property is not enabled.
1254 #
1255 jdk.security.caDistrustPolicies=SYMANTEC_TLS
1256 
1257 #
1258 # FilePermission path canonicalization
1259 #
1260 # This security property dictates how the path argument is processed and stored
1261 # while constructing a FilePermission object. If the value is set to true, the
1262 # path argument is canonicalized and FilePermission methods (such as implies,
1263 # equals, and hashCode) are implemented based on this canonicalized result.
1264 # Otherwise, the path argument is not canonicalized and FilePermission methods are
1265 # implemented based on the original input. See the implementation note of the
1266 # FilePermission class for more details.
1267 #
1268 # If a system property of the same name is also specified, it supersedes the
1269 # security property value defined here.
1270 #
1271 # The default value for this property is false.
1272 #
1273 jdk.io.permissionsUseCanonicalPath=false
1274 
1275 
1276 #
1277 # Policies for the proxy_impersonator Kerberos ccache configuration entry
1278 #
1279 # The proxy_impersonator ccache configuration entry indicates that the ccache
1280 # is a synthetic delegated credential for use with S4U2Proxy by an intermediate
1281 # server. The ccache file should also contain the TGT of this server and
1282 # an evidence ticket from the default principal of the ccache to this server.
1283 #
1284 # This security property determines how Java uses this configuration entry.
1285 # There are 3 possible values:
1286 #
1287 #  no-impersonate     - Ignore this configuration entry, and always act as
1288 #                       the owner of the TGT (if it exists).
1289 #
1290 #  try-impersonate    - Try impersonation when this configuration entry exists.
1291 #                       If no matching TGT or evidence ticket is found,
1292 #                       fallback to no-impersonate.
1293 #
1294 #  always-impersonate - Always impersonate when this configuration entry exists.
1295 #                       If no matching TGT or evidence ticket is found,
1296 #                       no initial credential is read from the ccache.
1297 #
1298 # The default value is &quot;always-impersonate&quot;.
1299 #
1300 # If a system property of the same name is also specified, it supersedes the
1301 # security property value defined here.
1302 #
1303 #jdk.security.krb5.default.initiate.credential=always-impersonate
    </pre>
  </body>
</html>
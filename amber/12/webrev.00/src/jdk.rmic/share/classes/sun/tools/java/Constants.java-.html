<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/jdk.rmic/share/classes/sun/tools/java/Constants.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
  <body>
    <pre>
  1 /*
  2  * Copyright (c) 1994, 2004, Oracle and/or its affiliates. All rights reserved.
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.  Oracle designates this
  8  * particular file as subject to the &quot;Classpath&quot; exception as provided
  9  * by Oracle in the LICENSE file that accompanied this code.
 10  *
 11  * This code is distributed in the hope that it will be useful, but WITHOUT
 12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 14  * version 2 for more details (a copy is included in the LICENSE file that
 15  * accompanied this code).
 16  *
 17  * You should have received a copy of the GNU General Public License version
 18  * 2 along with this work; if not, write to the Free Software Foundation,
 19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 20  *
 21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 22  * or visit www.oracle.com if you need additional information or have any
 23  * questions.
 24  */
 25 
 26 
 27 package sun.tools.java;
 28 
 29 /**
 30  * This interface defines constant that are used
 31  * throughout the compiler. It inherits from RuntimeConstants,
 32  * which is an autogenerated class that contains contstants
 33  * defined in the interpreter.
 34  *
 35  * WARNING: The contents of this source file are not part of any
 36  * supported API.  Code that depends on them does so at its own risk:
 37  * they are subject to change or removal without notice.
 38  *
 39  * @author      Arthur van Hoff
 40  */
 41 
 42 public
 43 interface Constants extends RuntimeConstants {
 44 
 45     /*
 46      * Enable/disable inclusion of certain debug tracing code in the
 47      * compiler.  When included, the tracing code may be selectively
 48      * enabled at runtime, otherwise we save the space/time overhead.
 49      * Should normally be &#39;false&#39; for a release version.
 50      */
 51     public static final boolean tracing = true;
 52 
 53     /*
 54      * Frequently used identifiers
 55      */
 56     Identifier idAppend = Identifier.lookup(&quot;append&quot;);
 57     Identifier idClassInit = Identifier.lookup(&quot;&lt;clinit&gt;&quot;);
 58     Identifier idCode = Identifier.lookup(&quot;Code&quot;);
 59     Identifier idInit = Identifier.lookup(&quot;&lt;init&gt;&quot;);
 60     Identifier idLength = Identifier.lookup(&quot;length&quot;);
 61     Identifier idNull = Identifier.lookup(&quot;&quot;);
 62     Identifier idStar = Identifier.lookup(&quot;*&quot;);
 63     Identifier idSuper = Identifier.lookup(&quot;super&quot;);
 64     Identifier idThis = Identifier.lookup(&quot;this&quot;);
 65     Identifier idClass = Identifier.lookup(&quot;class&quot;);
 66     Identifier idToString = Identifier.lookup(&quot;toString&quot;);
 67     Identifier idValueOf = Identifier.lookup(&quot;valueOf&quot;);
 68     Identifier idNew = Identifier.lookup(&quot;new&quot;);
 69     Identifier idGetClass = Identifier.lookup(&quot;getClass&quot;);
 70     Identifier idTYPE = Identifier.lookup(&quot;TYPE&quot;);
 71     Identifier idFinallyReturnValue = Identifier.lookup(&quot;&lt;return&gt;&quot;);
 72 
 73     Identifier idJavaLang = Identifier.lookup(&quot;java.lang&quot;);
 74 
 75     Identifier idJavaLangCloneable = Identifier.lookup(&quot;java.lang.Cloneable&quot;);
 76 
 77     Identifier idJavaLangError = Identifier.lookup(&quot;java.lang.Error&quot;);
 78     Identifier idJavaLangException = Identifier.lookup(&quot;java.lang.Exception&quot;);
 79     Identifier idJavaLangObject = Identifier.lookup(&quot;java.lang.Object&quot;);
 80     Identifier idJavaLangClass = Identifier.lookup(&quot;java.lang.Class&quot;);
 81     Identifier idJavaLangRuntimeException =
 82           Identifier.lookup(&quot;java.lang.RuntimeException&quot;);
 83     Identifier idJavaLangString = Identifier.lookup(&quot;java.lang.String&quot;);
 84     Identifier idJavaLangStringBuffer =
 85           Identifier.lookup(&quot;java.lang.StringBuffer&quot;);
 86     Identifier idJavaLangThrowable = Identifier.lookup(&quot;java.lang.Throwable&quot;);
 87 
 88     Identifier idJavaIoSerializable = Identifier.lookup(&quot;java.io.Serializable&quot;);
 89 
 90 
 91     Identifier idConstantValue = Identifier.lookup(&quot;ConstantValue&quot;);
 92     Identifier idLocalVariableTable = Identifier.lookup(&quot;LocalVariableTable&quot;);
 93     Identifier idLineNumberTable = Identifier.lookup(&quot;LineNumberTable&quot;);
 94 // JCOV
 95     Identifier idCoverageTable = Identifier.lookup(&quot;CoverageTable&quot;);
 96 // end JCOV
 97     Identifier idSourceFile = Identifier.lookup(&quot;SourceFile&quot;);
 98     Identifier idDocumentation = Identifier.lookup(&quot;Documentation&quot;);
 99     Identifier idDeprecated = Identifier.lookup(&quot;Deprecated&quot;);
100     Identifier idSynthetic = Identifier.lookup(&quot;Synthetic&quot;);
101     Identifier idExceptions = Identifier.lookup(&quot;Exceptions&quot;);
102     Identifier idInnerClasses = Identifier.lookup(&quot;InnerClasses&quot;);
103 
104     /* methods we need to know about */
105     Identifier idClone = Identifier.lookup(&quot;clone&quot;);
106 
107 
108     /* This is not a real signature marker, since it is also
109      * an identifier constituent character.
110      */
111     char   SIGC_INNERCLASS      = &#39;$&#39;;
112     String SIG_INNERCLASS       = &quot;$&quot;;
113 
114     String prefixThis           = &quot;this$&quot;;
115     String prefixVal            = &quot;val$&quot;;
116     String prefixLoc            = &quot;loc$&quot;;
117     String prefixAccess         = &quot;access$&quot;;
118     String prefixClass          = &quot;class$&quot;;
119     String prefixArray          = &quot;array$&quot;;
120 
121     /*
122      * Flags
123      */
124     int F_VERBOSE               = 1 &lt;&lt; 0;
125     int F_DUMP                  = 1 &lt;&lt; 1;
126     int F_WARNINGS              = 1 &lt;&lt; 2;
127 
128     // The meaning of -g has changed, so F_DEBUG flag is removed.
129     // public static final int F_DEBUG          = 1 &lt;&lt; 3;
130     int F_DEBUG_LINES           = 1 &lt;&lt; 12;
131     int F_DEBUG_VARS            = 1 &lt;&lt; 13;
132     int F_DEBUG_SOURCE          = 1 &lt;&lt; 18;
133 
134     // The meaning of -O has changed, so F_OPTIMIZE flag is removed.
135     // public static final int F_OPTIMIZE       = 1 &lt;&lt; 4;
136     int F_OPT                   = 1 &lt;&lt; 14;
137     int F_OPT_INTERCLASS        = 1 &lt;&lt; 15;
138 
139     int F_DEPENDENCIES          = 1 &lt;&lt; 5;
140 
141 // JCOV
142     int F_COVERAGE              = 1 &lt;&lt; 6;
143     int F_COVDATA               = 1 &lt;&lt; 7;
144 // end JCOV
145 
146     int F_DEPRECATION           = 1 &lt;&lt; 9;
147     int F_PRINT_DEPENDENCIES    = 1 &lt;&lt; 10;
148     int F_VERSION12             = 1 &lt;&lt; 11;
149 
150 
151     int F_ERRORSREPORTED        = 1 &lt;&lt; 16;
152 
153     int F_STRICTDEFAULT         = 1 &lt;&lt; 17;
154 
155     /*
156      * Modifiers.
157      *
158      * There has been much confusion regarding modifiers.  There
159      * are a number of distinct usages:
160      *
161      *    - in classfiles to annotate classes, as per JVM pg. 102.
162      *    - in classfiles to annotate methods, as per JVM pg. 104.
163      *    - in classfiles to annotate InnerClass attributes, as per
164      *          http://java.sun.com/products/jdk/1.1/docs/guide/innerclasses
165      *    - in the compiler to record java source level modifiers,
166      *          as per JLS pg. 157 et al., plus misc. info such as whether
167      *          a method is deprecated
168      *    - in the JVM to record misc. info, such as whether a method has
169      *          has been compiled
170      *
171      * To make matters worse, the terms &quot;access flags&quot; and &quot;modifiers&quot;
172      * are often used interchangably, and some information that might
173      * make sense as a flag is expressed using attributes (ie. Synthetic).
174      *
175      * The constants defined herein have been divided by whether they
176      * make sense only within the compiler (M_* and MM_*) or whether
177      * they only make sense to the JVM (ACC_* and ACCM_*).  At an earlier
178      * time these were all lumped together.  Future maintenance should
179      * strive to keep the distinction clear.
180      *
181      * Note that modifier M_STRICTFP is not in general recoverable from
182      * the ACC_STRICT bit in classfiles.
183      *
184      * Note also that the modifiers M_LOCAL and M_ANONYMOUS do not appear
185      * in the InnerClass attribute, as they are above the first 16 bits.
186      */
187 
188     // Modifiers meaningful to both Java source and the JVM.  These
189     // have been kept the same bit in the M_* and ACC_* forms
190     // to avoid destabilizing the compiler.
191     int M_PUBLIC                = ACC_PUBLIC;
192     int M_PRIVATE               = ACC_PRIVATE;
193     int M_PROTECTED             = ACC_PROTECTED;
194     int M_STATIC                = ACC_STATIC;
195     int M_TRANSIENT             = ACC_TRANSIENT;
196     int M_SYNCHRONIZED          = ACC_SYNCHRONIZED; // collides with ACC_SUPER
197     int M_ABSTRACT              = ACC_ABSTRACT;
198     int M_NATIVE                = ACC_NATIVE;
199     int M_FINAL                 = ACC_FINAL;
200     int M_VOLATILE              = ACC_VOLATILE;
201     int M_INTERFACE             = ACC_INTERFACE;
202 
203     // Modifiers not meaningful to the JVM.  The JVM only allows 16 bits
204     // for modifiers, so keeping these in the unusable bits after the first
205     // 16 is a good idea.
206     int M_ANONYMOUS             = 0x00010000;
207     int M_LOCAL                 = 0x00020000;
208     int M_DEPRECATED            = 0x00040000;
209     int M_SYNTHETIC             = 0x00080000;
210     int M_INLINEABLE            = 0x00100000;
211 
212     int M_STRICTFP              = 0x00200000;
213 
214     String paraDeprecated       = &quot;@deprecated&quot;;
215 
216     // Masks for modifiers that apply to Java source code
217     int MM_CLASS  = M_PUBLIC
218                         | M_INTERFACE
219                         | M_FINAL
220                         | M_ABSTRACT
221                         | M_STRICTFP;
222     int MM_MEMBER = M_PUBLIC
223                         | M_PRIVATE
224                         | M_PROTECTED
225                         | M_FINAL
226                         | M_STATIC;
227     int MM_FIELD  = MM_MEMBER
228                         | M_TRANSIENT
229                         | M_VOLATILE;
230     int MM_METHOD = MM_MEMBER
231                         | M_SYNCHRONIZED
232                         | M_ABSTRACT
233                         | M_NATIVE
234                         | M_STRICTFP;
235 
236     // Masks for modifiers that apply to class files.
237     // Note that the M_SYNTHETIC modifier is never written out to a class file.
238     // Synthetic members are indicated using the &quot;Synthetic&quot; attribute.
239     int ACCM_CLASS  = ACC_PUBLIC
240                         | ACC_INTERFACE
241                         | ACC_FINAL
242                         | ACC_ABSTRACT
243                         | ACC_SUPER
244                         | ACC_STRICT;
245     int ACCM_MEMBER = ACC_PUBLIC
246                         | ACC_PRIVATE
247                         | ACC_PROTECTED
248                         | ACC_FINAL
249                         | ACC_STATIC;
250     // The M_ANONYMOUS and M_LOCAL modifiers are not mentioned in the
251     // inner classes specification and are never written to classfiles.
252     // Also note that ACC_SUPER should never be set in an InnerClass
253     // attribute.
254     int ACCM_INNERCLASS = ACC_PUBLIC
255                         | ACC_PRIVATE
256                         | ACC_PROTECTED
257                         | ACC_STATIC
258                         | ACC_ABSTRACT
259                         | ACC_FINAL
260                         | ACC_INTERFACE
261                         | ACC_STRICT;
262     int ACCM_FIELD  = ACCM_MEMBER
263                         | ACC_TRANSIENT
264                         | ACC_VOLATILE;
265     int ACCM_METHOD = ACCM_MEMBER
266                         | ACC_SYNCHRONIZED
267                         | ACC_ABSTRACT
268                         | ACC_NATIVE
269                         | ACC_STRICT;
270 
271     /*
272      * Type codes
273      */
274     int TC_BOOLEAN   = 0;
275     int TC_BYTE      = 1;
276     int TC_CHAR      = 2;
277     int TC_SHORT     = 3;
278     int TC_INT       = 4;
279     int TC_LONG      = 5;
280     int TC_FLOAT     = 6;
281     int TC_DOUBLE    = 7;
282     int TC_NULL      = 8;
283     int TC_ARRAY     = 9;
284     int TC_CLASS     = 10;
285     int TC_VOID      = 11;
286     int TC_METHOD    = 12;
287     int TC_ERROR     = 13;
288 
289 // JCOV
290     /*
291      * Cover&#39;s types
292      */
293     int CT_FIRST_KIND   = 1;
294     int CT_METHOD       = 1;
295     int CT_FIKT_METHOD  = 2;
296     int CT_BLOCK        = 3;
297     int CT_FIKT_RET     = 4;
298     int CT_CASE         = 5;
299     int CT_SWITH_WO_DEF = 6;
300     int CT_BRANCH_TRUE  = 7;
301     int CT_BRANCH_FALSE = 8;
302     int CT_LAST_KIND    = 8;
303 // end JCOV
304 
305     /*
306      * Type Masks
307      */
308     int TM_NULL      = 1 &lt;&lt; TC_NULL;
309     int TM_VOID      = 1 &lt;&lt; TC_VOID;
310     int TM_BOOLEAN   = 1 &lt;&lt; TC_BOOLEAN;
311     int TM_BYTE      = 1 &lt;&lt; TC_BYTE;
312     int TM_CHAR      = 1 &lt;&lt; TC_CHAR;
313     int TM_SHORT     = 1 &lt;&lt; TC_SHORT;
314     int TM_INT       = 1 &lt;&lt; TC_INT;
315     int TM_LONG      = 1 &lt;&lt; TC_LONG;
316     int TM_FLOAT     = 1 &lt;&lt; TC_FLOAT;
317     int TM_DOUBLE    = 1 &lt;&lt; TC_DOUBLE;
318     int TM_ARRAY     = 1 &lt;&lt; TC_ARRAY;
319     int TM_CLASS     = 1 &lt;&lt; TC_CLASS;
320     int TM_METHOD    = 1 &lt;&lt; TC_METHOD;
321     int TM_ERROR     = 1 &lt;&lt; TC_ERROR;
322 
323     int TM_INT32     = TM_BYTE | TM_SHORT | TM_CHAR | TM_INT;
324     int TM_NUM32     = TM_INT32 | TM_FLOAT;
325     int TM_NUM64     = TM_LONG | TM_DOUBLE;
326     int TM_INTEGER   = TM_INT32 | TM_LONG;
327     int TM_REAL      = TM_FLOAT | TM_DOUBLE;
328     int TM_NUMBER    = TM_INTEGER | TM_REAL;
329     int TM_REFERENCE = TM_ARRAY | TM_CLASS | TM_NULL;
330 
331     /*
332      * Class status
333      */
334     int CS_UNDEFINED    = 0;
335     int CS_UNDECIDED    = 1;
336     int CS_BINARY       = 2;
337     int CS_SOURCE       = 3;
338     int CS_PARSED       = 4;
339     int CS_CHECKED      = 5;
340     int CS_COMPILED     = 6;
341     int CS_NOTFOUND     = 7;
342 
343 
344     /*
345      * Attributes
346      */
347     int ATT_ALL         = 0xFFFFFFFF;
348     int ATT_CODE        = 1 &lt;&lt; 1;
349     int ATT_ALLCLASSES  = 1 &lt;&lt; 2;
350 
351     /*
352      * Number of bits used in file offsets.  The line number and
353      * file offset are concatenated into a long, with enough room
354      * for other information to be added later if desired (such as
355      * token lengths).  For the moment explicit bit manipulations
356      * are used to modify the fields.  This makes sense for efficiency
357      * but at some point these ought to be better encapsulated.
358      */
359     int WHEREOFFSETBITS = 32;
360     long MAXFILESIZE    = (1L &lt;&lt; WHEREOFFSETBITS) - 1;
361     long MAXLINENUMBER  = (1L &lt;&lt; (64 - WHEREOFFSETBITS)) - 1;
362 
363     /*
364      * Operators
365      */
366     int COMMA           = 0;
367     int ASSIGN          = 1;
368 
369     int ASGMUL          = 2;
370     int ASGDIV          = 3;
371     int ASGREM          = 4;
372     int ASGADD          = 5;
373     int ASGSUB          = 6;
374     int ASGLSHIFT       = 7;
375     int ASGRSHIFT       = 8;
376     int ASGURSHIFT      = 9;
377     int ASGBITAND       = 10;
378     int ASGBITOR        = 11;
379     int ASGBITXOR       = 12;
380 
381     int COND            = 13;
382     int OR              = 14;
383     int AND             = 15;
384     int BITOR           = 16;
385     int BITXOR          = 17;
386     int BITAND          = 18;
387     int NE              = 19;
388     int EQ              = 20;
389     int GE              = 21;
390     int GT              = 22;
391     int LE              = 23;
392     int LT              = 24;
393     int INSTANCEOF      = 25;
394     int LSHIFT          = 26;
395     int RSHIFT          = 27;
396     int URSHIFT         = 28;
397     int ADD             = 29;
398     int SUB             = 30;
399     int DIV             = 31;
400     int REM             = 32;
401     int MUL             = 33;
402     int CAST            = 34;           // (x)y
403     int POS             = 35;           // +x
404     int NEG             = 36;           // -x
405     int NOT             = 37;
406     int BITNOT          = 38;
407     int PREINC          = 39;           // ++x
408     int PREDEC          = 40;           // --x
409     int NEWARRAY        = 41;
410     int NEWINSTANCE     = 42;
411     int NEWFROMNAME     = 43;
412     int POSTINC         = 44;           // x++
413     int POSTDEC         = 45;           // x--
414     int FIELD           = 46;
415     int METHOD          = 47;           // x(y)
416     int ARRAYACCESS     = 48;           // x[y]
417     int NEW             = 49;
418     int INC             = 50;
419     int DEC             = 51;
420 
421     int CONVERT         = 55;           // implicit conversion
422     int EXPR            = 56;           // (x)
423     int ARRAY           = 57;           // {x, y, ...}
424     int GOTO            = 58;
425 
426     /*
427      * Value tokens
428      */
429     int IDENT           = 60;
430     int BOOLEANVAL      = 61;
431     int BYTEVAL         = 62;
432     int CHARVAL         = 63;
433     int SHORTVAL        = 64;
434     int INTVAL          = 65;
435     int LONGVAL         = 66;
436     int FLOATVAL        = 67;
437     int DOUBLEVAL       = 68;
438     int STRINGVAL       = 69;
439 
440     /*
441      * Type keywords
442      */
443     int BYTE            = 70;
444     int CHAR            = 71;
445     int SHORT           = 72;
446     int INT             = 73;
447     int LONG            = 74;
448     int FLOAT           = 75;
449     int DOUBLE          = 76;
450     int VOID            = 77;
451     int BOOLEAN         = 78;
452 
453     /*
454      * Expression keywords
455      */
456     int TRUE            = 80;
457     int FALSE           = 81;
458     int THIS            = 82;
459     int SUPER           = 83;
460     int NULL            = 84;
461 
462     /*
463      * Statement keywords
464      */
465     int IF              = 90;
466     int ELSE            = 91;
467     int FOR             = 92;
468     int WHILE           = 93;
469     int DO              = 94;
470     int SWITCH          = 95;
471     int CASE            = 96;
472     int DEFAULT         = 97;
473     int BREAK           = 98;
474     int CONTINUE        = 99;
475     int RETURN          = 100;
476     int TRY             = 101;
477     int CATCH           = 102;
478     int FINALLY         = 103;
479     int THROW           = 104;
480     int STAT            = 105;
481     int EXPRESSION      = 106;
482     int DECLARATION     = 107;
483     int VARDECLARATION  = 108;
484 
485     /*
486      * Declaration keywords
487      */
488     int IMPORT          = 110;
489     int CLASS           = 111;
490     int EXTENDS         = 112;
491     int IMPLEMENTS      = 113;
492     int INTERFACE       = 114;
493     int PACKAGE         = 115;
494 
495     /*
496      * Modifier keywords
497      */
498     int PRIVATE         = 120;
499     int PUBLIC          = 121;
500     int PROTECTED       = 122;
501     int CONST           = 123;
502     int STATIC          = 124;
503     int TRANSIENT       = 125;
504     int SYNCHRONIZED    = 126;
505     int NATIVE          = 127;
506     int FINAL           = 128;
507     int VOLATILE        = 129;
508     int ABSTRACT        = 130;
509     int STRICTFP        = 131;
510 
511     /*
512      * Punctuation
513      */
514     int SEMICOLON       = 135;
515     int COLON           = 136;
516     int QUESTIONMARK    = 137;
517     int LBRACE          = 138;
518     int RBRACE          = 139;
519     int LPAREN          = 140;
520     int RPAREN          = 141;
521     int LSQBRACKET      = 142;
522     int RSQBRACKET      = 143;
523     int THROWS          = 144;
524 
525     /*
526      * Special tokens
527      */
528     int ERROR           = 145;          // an error
529     int COMMENT         = 146;          // not used anymore.
530     int TYPE            = 147;
531     int LENGTH          = 148;
532     int INLINERETURN    = 149;
533     int INLINEMETHOD    = 150;
534     int INLINENEWINSTANCE       = 151;
535 
536     /*
537      * Operator precedence
538      */
539     int opPrecedence[] = {
540         10, 11, 11, 11, 11, 11, 11, 11, 11, 11,
541         11, 11, 11, 12, 13, 14, 15, 16, 17, 18,
542         18, 19, 19, 19, 19, 19, 20, 20, 20, 21,
543         21, 22, 22, 22, 23, 24, 24, 24, 24, 24,
544         24, 25, 25, 26, 26, 26, 26, 26, 26
545     };
546 
547     /*
548      * Operator names
549      */
550     String opNames[] = {
551         &quot;,&quot;,    &quot;=&quot;,    &quot;*=&quot;,   &quot;/=&quot;,   &quot;%=&quot;,
552         &quot;+=&quot;,   &quot;-=&quot;,   &quot;&lt;&lt;=&quot;,  &quot;&gt;&gt;=&quot;,  &quot;&gt;&gt;&gt;=&quot;,
553         &quot;&amp;=&quot;,   &quot;|=&quot;,   &quot;^=&quot;,   &quot;?:&quot;,   &quot;||&quot;,
554         &quot;&amp;&amp;&quot;,   &quot;|&quot;,    &quot;^&quot;,    &quot;&amp;&quot;,    &quot;!=&quot;,
555         &quot;==&quot;,   &quot;&gt;=&quot;,   &quot;&gt;&quot;,    &quot;&lt;=&quot;,   &quot;&lt;&quot;,
556         &quot;instanceof&quot;, &quot;&lt;&lt;&quot;, &quot;&gt;&gt;&quot;, &quot;&gt;&gt;&gt;&quot;, &quot;+&quot;,
557         &quot;-&quot;,    &quot;/&quot;,    &quot;%&quot;,    &quot;*&quot;,    &quot;cast&quot;,
558         &quot;+&quot;,    &quot;-&quot;,    &quot;!&quot;,    &quot;~&quot;,    &quot;++&quot;,
559         &quot;--&quot;,   &quot;new&quot;,  &quot;new&quot;,  &quot;new&quot;,  &quot;++&quot;,
560         &quot;--&quot;,   &quot;field&quot;,&quot;method&quot;,&quot;[]&quot;,  &quot;new&quot;,
561         &quot;++&quot;,   &quot;--&quot;,   null,   null,   null,
562 
563         &quot;convert&quot;, &quot;expr&quot;, &quot;array&quot;, &quot;goto&quot;, null,
564 
565         &quot;Identifier&quot;, &quot;boolean&quot;, &quot;byte&quot;, &quot;char&quot;, &quot;short&quot;,
566         &quot;int&quot;, &quot;long&quot;, &quot;float&quot;, &quot;double&quot;, &quot;string&quot;,
567 
568         &quot;byte&quot;, &quot;char&quot;, &quot;short&quot;, &quot;int&quot;, &quot;long&quot;,
569         &quot;float&quot;, &quot;double&quot;, &quot;void&quot;, &quot;boolean&quot;, null,
570 
571         &quot;true&quot;, &quot;false&quot;, &quot;this&quot;, &quot;super&quot;, &quot;null&quot;,
572         null,   null,   null,   null,   null,
573 
574         &quot;if&quot;,   &quot;else&quot;, &quot;for&quot;,  &quot;while&quot;,&quot;do&quot;,
575         &quot;switch&quot;, &quot;case&quot;, &quot;default&quot;, &quot;break&quot;, &quot;continue&quot;,
576         &quot;return&quot;, &quot;try&quot;, &quot;catch&quot;, &quot;finally&quot;, &quot;throw&quot;,
577         &quot;stat&quot;, &quot;expression&quot;, &quot;declaration&quot;, &quot;declaration&quot;, null,
578 
579         &quot;import&quot;, &quot;class&quot;, &quot;extends&quot;, &quot;implements&quot;, &quot;interface&quot;,
580         &quot;package&quot;, null, null,  null,   null,
581 
582         &quot;private&quot;, &quot;public&quot;, &quot;protected&quot;, &quot;const&quot;, &quot;static&quot;,
583         &quot;transient&quot;, &quot;synchronized&quot;, &quot;native&quot;, &quot;final&quot;, &quot;volatile&quot;,
584         &quot;abstract&quot;, &quot;strictfp&quot;, null, null, null,
585 
586         &quot;;&quot;,    &quot;:&quot;,    &quot;?&quot;,    &quot;{&quot;,    &quot;}&quot;,
587         &quot;(&quot;,    &quot;)&quot;,    &quot;[&quot;,    &quot;]&quot;,    &quot;throws&quot;,
588         &quot;error&quot;, &quot;comment&quot;, &quot;type&quot;, &quot;length&quot;, &quot;inline-return&quot;,
589         &quot;inline-method&quot;, &quot;inline-new&quot;
590     };
591 }
    </pre>
  </body>
</html>
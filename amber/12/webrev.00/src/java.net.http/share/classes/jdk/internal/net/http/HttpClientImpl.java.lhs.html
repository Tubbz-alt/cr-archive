<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/HttpClientImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import javax.net.ssl.SSLContext;
  29 import javax.net.ssl.SSLException;
  30 import javax.net.ssl.SSLHandshakeException;
  31 import javax.net.ssl.SSLParameters;
  32 import java.io.IOException;
  33 import java.io.UncheckedIOException;
  34 import java.lang.ref.Reference;
  35 import java.lang.ref.WeakReference;
  36 import java.net.Authenticator;
  37 import java.net.ConnectException;
  38 import java.net.CookieHandler;
  39 import java.net.ProxySelector;
  40 import java.net.http.HttpConnectTimeoutException;
  41 import java.net.http.HttpTimeoutException;
  42 import java.nio.ByteBuffer;
  43 import java.nio.channels.CancelledKeyException;
  44 import java.nio.channels.ClosedChannelException;
  45 import java.nio.channels.SelectableChannel;
  46 import java.nio.channels.SelectionKey;
  47 import java.nio.channels.Selector;
  48 import java.nio.channels.SocketChannel;
  49 import java.security.AccessControlContext;
  50 import java.security.AccessController;
  51 import java.security.NoSuchAlgorithmException;
  52 import java.security.PrivilegedAction;
  53 import java.time.Duration;
  54 import java.time.Instant;
  55 import java.time.temporal.ChronoUnit;
  56 import java.util.ArrayList;
  57 import java.util.HashSet;
  58 import java.util.Iterator;
  59 import java.util.LinkedList;
  60 import java.util.List;
  61 import java.util.Objects;
  62 import java.util.Optional;
  63 import java.util.Set;
  64 import java.util.TreeSet;
  65 import java.util.concurrent.CompletableFuture;
  66 import java.util.concurrent.CompletionException;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.concurrent.Executor;
  69 import java.util.concurrent.Executors;
  70 import java.util.concurrent.ThreadFactory;
  71 import java.util.concurrent.atomic.AtomicInteger;
  72 import java.util.concurrent.atomic.AtomicLong;
  73 import java.util.function.BooleanSupplier;
  74 import java.util.stream.Stream;
  75 import java.net.http.HttpClient;
  76 import java.net.http.HttpRequest;
  77 import java.net.http.HttpResponse;
  78 import java.net.http.HttpResponse.BodyHandler;
  79 import java.net.http.HttpResponse.PushPromiseHandler;
  80 import java.net.http.WebSocket;
  81 import jdk.internal.net.http.common.BufferSupplier;
  82 import jdk.internal.net.http.common.Log;
  83 import jdk.internal.net.http.common.Logger;
  84 import jdk.internal.net.http.common.Pair;
  85 import jdk.internal.net.http.common.Utils;
  86 import jdk.internal.net.http.common.OperationTrackers.Trackable;
  87 import jdk.internal.net.http.common.OperationTrackers.Tracker;
  88 import jdk.internal.net.http.websocket.BuilderImpl;
  89 import jdk.internal.misc.InnocuousThread;
  90 
  91 /**
  92  * Client implementation. Contains all configuration information and also
  93  * the selector manager thread which allows async events to be registered
  94  * and delivered when they occur. See AsyncEvent.
  95  */
  96 final class HttpClientImpl extends HttpClient implements Trackable {
  97 
  98     static final boolean DEBUGELAPSED = Utils.TESTING || Utils.DEBUG;  // dev flag
  99     static final boolean DEBUGTIMEOUT = false; // dev flag
 100     final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG);
 101     final Logger debugelapsed = Utils.getDebugLogger(this::dbgString, DEBUGELAPSED);
 102     final Logger debugtimeout = Utils.getDebugLogger(this::dbgString, DEBUGTIMEOUT);
 103     static final AtomicLong CLIENT_IDS = new AtomicLong();
 104 
 105     // Define the default factory as a static inner class
 106     // that embeds all the necessary logic to avoid
 107     // the risk of using a lambda that might keep a reference on the
 108     // HttpClient instance from which it was created (helps with
 109     // heapdump analysis).
 110     private static final class DefaultThreadFactory implements ThreadFactory {
 111         private final String namePrefix;
 112         private final AtomicInteger nextId = new AtomicInteger();
 113 
 114         DefaultThreadFactory(long clientID) {
 115             namePrefix = &quot;HttpClient-&quot; + clientID + &quot;-Worker-&quot;;
 116         }
 117 
 118         @Override
 119         public Thread newThread(Runnable r) {
 120             String name = namePrefix + nextId.getAndIncrement();
 121             Thread t;
 122             if (System.getSecurityManager() == null) {
 123                 t = new Thread(null, r, name, 0, false);
 124             } else {
 125                 t = InnocuousThread.newThread(name, r);
 126             }
 127             t.setDaemon(true);
 128             return t;
 129         }
 130     }
 131 
 132     /**
 133      * A DelegatingExecutor is an executor that delegates tasks to
 134      * a wrapped executor when it detects that the current thread
 135      * is the SelectorManager thread. If the current thread is not
 136      * the selector manager thread the given task is executed inline.
 137      */
 138     final static class DelegatingExecutor implements Executor {
 139         private final BooleanSupplier isInSelectorThread;
 140         private final Executor delegate;
 141         DelegatingExecutor(BooleanSupplier isInSelectorThread, Executor delegate) {
 142             this.isInSelectorThread = isInSelectorThread;
 143             this.delegate = delegate;
 144         }
 145 
 146         Executor delegate() {
 147             return delegate;
 148         }
 149 
 150         @Override
 151         public void execute(Runnable command) {
 152             if (isInSelectorThread.getAsBoolean()) {
 153                 delegate.execute(command);
 154             } else {
 155                 command.run();
 156             }
 157         }
 158     }
 159 
 160     private final CookieHandler cookieHandler;
 161     private final Duration connectTimeout;
 162     private final Redirect followRedirects;
 163     private final ProxySelector userProxySelector;
 164     private final ProxySelector proxySelector;
 165     private final Authenticator authenticator;
 166     private final Version version;
 167     private final ConnectionPool connections;
 168     private final DelegatingExecutor delegatingExecutor;
 169     private final boolean isDefaultExecutor;
 170     // Security parameters
 171     private final SSLContext sslContext;
 172     private final SSLParameters sslParams;
 173     private final SelectorManager selmgr;
 174     private final FilterFactory filters;
 175     private final Http2ClientImpl client2;
 176     private final long id;
 177     private final String dbgTag;
 178 
 179     // The SSL DirectBuffer Supplier provides the ability to recycle
 180     // buffers used between the socket reader and the SSLEngine, or
 181     // more precisely between the SocketTube publisher and the
 182     // SSLFlowDelegate reader.
 183     private final SSLDirectBufferSupplier sslBufferSupplier
 184             = new SSLDirectBufferSupplier(this);
 185 
 186     // This reference is used to keep track of the facade HttpClient
 187     // that was returned to the application code.
 188     // It makes it possible to know when the application no longer
 189     // holds any reference to the HttpClient.
 190     // Unfortunately, this information is not enough to know when
 191     // to exit the SelectorManager thread. Because of the asynchronous
 192     // nature of the API, we also need to wait until all pending operations
 193     // have completed.
 194     private final WeakReference&lt;HttpClientFacade&gt; facadeRef;
 195 
 196     // This counter keeps track of the number of operations pending
 197     // on the HttpClient. The SelectorManager thread will wait
 198     // until there are no longer any pending operations and the
 199     // facadeRef is cleared before exiting.
 200     //
 201     // The pendingOperationCount is incremented every time a send/sendAsync
 202     // operation is invoked on the HttpClient, and is decremented when
 203     // the HttpResponse&lt;T&gt; object is returned to the user.
 204     // However, at this point, the body may not have been fully read yet.
 205     // This is the case when the response T is implemented as a streaming
 206     // subscriber (such as an InputStream).
 207     //
 208     // To take care of this issue the pendingOperationCount will additionally
 209     // be incremented/decremented in the following cases:
 210     //
 211     // 1. For HTTP/2  it is incremented when a stream is added to the
 212     //    Http2Connection streams map, and decreased when the stream is removed
 213     //    from the map. This should also take care of push promises.
 214     // 2. For WebSocket the count is increased when creating a
 215     //    DetachedConnectionChannel for the socket, and decreased
 216     //    when the channel is closed.
 217     //    In addition, the HttpClient facade is passed to the WebSocket builder,
 218     //    (instead of the client implementation delegate).
 219     // 3. For HTTP/1.1 the count is incremented before starting to parse the body
 220     //    response, and decremented when the parser has reached the end of the
 221     //    response body flow.
 222     //
 223     // This should ensure that the selector manager thread remains alive until
 224     // the response has been fully received or the web socket is closed.
 225     private final AtomicLong pendingOperationCount = new AtomicLong();
 226     private final AtomicLong pendingWebSocketCount = new AtomicLong();
 227     private final AtomicLong pendingHttpRequestCount = new AtomicLong();
 228     private final AtomicLong pendingHttp2StreamCount = new AtomicLong();
 229 
 230     /** A Set of, deadline first, ordered timeout events. */
 231     private final TreeSet&lt;TimeoutEvent&gt; timeouts;
 232 
 233     /**
 234      * This is a bit tricky:
 235      * 1. an HttpClientFacade has a final HttpClientImpl field.
 236      * 2. an HttpClientImpl has a final WeakReference&lt;HttpClientFacade&gt; field,
 237      *    where the referent is the facade created for that instance.
 238      * 3. We cannot just create the HttpClientFacade in the HttpClientImpl
 239      *    constructor, because it would be only weakly referenced and could
 240      *    be GC&#39;ed before we can return it.
 241      * The solution is to use an instance of SingleFacadeFactory which will
 242      * allow the caller of new HttpClientImpl(...) to retrieve the facade
 243      * after the HttpClientImpl has been created.
 244      */
 245     private static final class SingleFacadeFactory {
 246         HttpClientFacade facade;
 247         HttpClientFacade createFacade(HttpClientImpl impl) {
 248             assert facade == null;
 249             return (facade = new HttpClientFacade(impl));
 250         }
 251     }
 252 
 253     static HttpClientFacade create(HttpClientBuilderImpl builder) {
 254         SingleFacadeFactory facadeFactory = new SingleFacadeFactory();
 255         HttpClientImpl impl = new HttpClientImpl(builder, facadeFactory);
 256         impl.start();
 257         assert facadeFactory.facade != null;
 258         assert impl.facadeRef.get() == facadeFactory.facade;
 259         return facadeFactory.facade;
 260     }
 261 
 262     private HttpClientImpl(HttpClientBuilderImpl builder,
 263                            SingleFacadeFactory facadeFactory) {
 264         id = CLIENT_IDS.incrementAndGet();
 265         dbgTag = &quot;HttpClientImpl(&quot; + id +&quot;)&quot;;
 266         if (builder.sslContext == null) {
 267             try {
 268                 sslContext = SSLContext.getDefault();
 269             } catch (NoSuchAlgorithmException ex) {
 270                 throw new InternalError(ex);
 271             }
 272         } else {
 273             sslContext = builder.sslContext;
 274         }
 275         Executor ex = builder.executor;
 276         if (ex == null) {
 277             ex = Executors.newCachedThreadPool(new DefaultThreadFactory(id));
 278             isDefaultExecutor = true;
 279         } else {
 280             isDefaultExecutor = false;
 281         }
 282         delegatingExecutor = new DelegatingExecutor(this::isSelectorThread, ex);
 283         facadeRef = new WeakReference&lt;&gt;(facadeFactory.createFacade(this));
 284         client2 = new Http2ClientImpl(this);
 285         cookieHandler = builder.cookieHandler;
 286         connectTimeout = builder.connectTimeout;
 287         followRedirects = builder.followRedirects == null ?
 288                 Redirect.NEVER : builder.followRedirects;
 289         this.userProxySelector = builder.proxy;
 290         this.proxySelector = Optional.ofNullable(userProxySelector)
 291                 .orElseGet(HttpClientImpl::getDefaultProxySelector);
 292         if (debug.on())
 293             debug.log(&quot;proxySelector is %s (user-supplied=%s)&quot;,
 294                       this.proxySelector, userProxySelector != null);
 295         authenticator = builder.authenticator;
 296         if (builder.version == null) {
 297             version = HttpClient.Version.HTTP_2;
 298         } else {
 299             version = builder.version;
 300         }
 301         if (builder.sslParams == null) {
 302             sslParams = getDefaultParams(sslContext);
 303         } else {
 304             sslParams = builder.sslParams;
 305         }
 306         connections = new ConnectionPool(id);
 307         connections.start();
 308         timeouts = new TreeSet&lt;&gt;();
 309         try {
 310             selmgr = new SelectorManager(this);
 311         } catch (IOException e) {
 312             // unlikely
 313             throw new InternalError(e);
 314         }
 315         selmgr.setDaemon(true);
 316         filters = new FilterFactory();
 317         initFilters();
 318         assert facadeRef.get() != null;
 319     }
 320 
 321     private void start() {
 322         selmgr.start();
 323     }
 324 
 325     // Called from the SelectorManager thread, just before exiting.
 326     // Clears the HTTP/1.1 and HTTP/2 cache, ensuring that the connections
 327     // that may be still lingering there are properly closed (and their
 328     // possibly still opened SocketChannel released).
 329     private void stop() {
 330         // Clears HTTP/1.1 cache and close its connections
 331         connections.stop();
 332         // Clears HTTP/2 cache and close its connections.
 333         client2.stop();
 334     }
 335 
 336     private static SSLParameters getDefaultParams(SSLContext ctx) {
<a name="2" id="anc2"></a><span class="line-modified"> 337         SSLParameters params = ctx.getSupportedSSLParameters();</span>
<span class="line-removed"> 338         String[] protocols = params.getProtocols();</span>
<span class="line-removed"> 339         boolean found13 = false;</span>
<span class="line-removed"> 340         for (String proto : protocols) {</span>
<span class="line-removed"> 341             if (proto.equals(&quot;TLSv1.3&quot;)) {</span>
<span class="line-removed"> 342                 found13 = true;</span>
<span class="line-removed"> 343                 break;</span>
<span class="line-removed"> 344             }</span>
<span class="line-removed"> 345         }</span>
<span class="line-removed"> 346         if (found13)</span>
<span class="line-removed"> 347             params.setProtocols(new String[] {&quot;TLSv1.3&quot;, &quot;TLSv1.2&quot;});</span>
<span class="line-removed"> 348         else</span>
<span class="line-removed"> 349             params.setProtocols(new String[] {&quot;TLSv1.2&quot;});</span>
 350         return params;
 351     }
 352 
 353     private static ProxySelector getDefaultProxySelector() {
 354         PrivilegedAction&lt;ProxySelector&gt; action = ProxySelector::getDefault;
 355         return AccessController.doPrivileged(action);
 356     }
 357 
 358     // Returns the facade that was returned to the application code.
 359     // May be null if that facade is no longer referenced.
 360     final HttpClientFacade facade() {
 361         return facadeRef.get();
 362     }
 363 
 364     // Increments the pendingOperationCount.
 365     final long reference() {
 366         pendingHttpRequestCount.incrementAndGet();
 367         return pendingOperationCount.incrementAndGet();
 368     }
 369 
 370     // Decrements the pendingOperationCount.
 371     final long unreference() {
 372         final long count = pendingOperationCount.decrementAndGet();
 373         final long httpCount = pendingHttpRequestCount.decrementAndGet();
 374         final long http2Count = pendingHttp2StreamCount.get();
 375         final long webSocketCount = pendingWebSocketCount.get();
 376         if (count == 0 &amp;&amp; facade() == null) {
 377             selmgr.wakeupSelector();
 378         }
 379         assert httpCount &gt;= 0 : &quot;count of HTTP/1.1 operations &lt; 0&quot;;
 380         assert http2Count &gt;= 0 : &quot;count of HTTP/2 operations &lt; 0&quot;;
 381         assert webSocketCount &gt;= 0 : &quot;count of WS operations &lt; 0&quot;;
 382         assert count &gt;= 0 : &quot;count of pending operations &lt; 0&quot;;
 383         return count;
 384     }
 385 
 386     // Increments the pendingOperationCount.
 387     final long streamReference() {
 388         pendingHttp2StreamCount.incrementAndGet();
 389         return pendingOperationCount.incrementAndGet();
 390     }
 391 
 392     // Decrements the pendingOperationCount.
 393     final long streamUnreference() {
 394         final long count = pendingOperationCount.decrementAndGet();
 395         final long http2Count = pendingHttp2StreamCount.decrementAndGet();
 396         final long httpCount = pendingHttpRequestCount.get();
 397         final long webSocketCount = pendingWebSocketCount.get();
 398         if (count == 0 &amp;&amp; facade() == null) {
 399             selmgr.wakeupSelector();
 400         }
 401         assert httpCount &gt;= 0 : &quot;count of HTTP/1.1 operations &lt; 0&quot;;
 402         assert http2Count &gt;= 0 : &quot;count of HTTP/2 operations &lt; 0&quot;;
 403         assert webSocketCount &gt;= 0 : &quot;count of WS operations &lt; 0&quot;;
 404         assert count &gt;= 0 : &quot;count of pending operations &lt; 0&quot;;
 405         return count;
 406     }
 407 
 408     // Increments the pendingOperationCount.
 409     final long webSocketOpen() {
 410         pendingWebSocketCount.incrementAndGet();
 411         return pendingOperationCount.incrementAndGet();
 412     }
 413 
 414     // Decrements the pendingOperationCount.
 415     final long webSocketClose() {
 416         final long count = pendingOperationCount.decrementAndGet();
 417         final long webSocketCount = pendingWebSocketCount.decrementAndGet();
 418         final long httpCount = pendingHttpRequestCount.get();
 419         final long http2Count = pendingHttp2StreamCount.get();
 420         if (count == 0 &amp;&amp; facade() == null) {
 421             selmgr.wakeupSelector();
 422         }
 423         assert httpCount &gt;= 0 : &quot;count of HTTP/1.1 operations &lt; 0&quot;;
 424         assert http2Count &gt;= 0 : &quot;count of HTTP/2 operations &lt; 0&quot;;
 425         assert webSocketCount &gt;= 0 : &quot;count of WS operations &lt; 0&quot;;
 426         assert count &gt;= 0 : &quot;count of pending operations &lt; 0&quot;;
 427         return count;
 428     }
 429 
 430     // Returns the pendingOperationCount.
 431     final long referenceCount() {
 432         return pendingOperationCount.get();
 433     }
 434 
 435     final static class HttpClientTracker implements Tracker {
 436         final AtomicLong httpCount;
 437         final AtomicLong http2Count;
 438         final AtomicLong websocketCount;
 439         final AtomicLong operationsCount;
 440         final Reference&lt;?&gt; reference;
 441         final String name;
 442         HttpClientTracker(AtomicLong http,
 443                           AtomicLong http2,
 444                           AtomicLong ws,
 445                           AtomicLong ops,
 446                           Reference&lt;?&gt; ref,
 447                           String name) {
 448             this.httpCount = http;
 449             this.http2Count = http2;
 450             this.websocketCount = ws;
 451             this.operationsCount = ops;
 452             this.reference = ref;
 453             this.name = name;
 454         }
 455         @Override
 456         public long getOutstandingOperations() {
 457             return operationsCount.get();
 458         }
 459         @Override
 460         public long getOutstandingHttpOperations() {
 461             return httpCount.get();
 462         }
 463         @Override
 464         public long getOutstandingHttp2Streams() { return http2Count.get(); }
 465         @Override
 466         public long getOutstandingWebSocketOperations() {
 467             return websocketCount.get();
 468         }
 469         @Override
 470         public boolean isFacadeReferenced() {
 471             return reference.get() != null;
 472         }
 473         @Override
 474         public String getName() {
 475             return name;
 476         }
 477     }
 478 
 479     public Tracker getOperationsTracker() {
 480         return new HttpClientTracker(pendingHttpRequestCount,
 481                 pendingHttp2StreamCount,
 482                 pendingWebSocketCount,
 483                 pendingOperationCount,
 484                 facadeRef,
 485                 dbgTag);
 486     }
 487 
 488     // Called by the SelectorManager thread to figure out whether it&#39;s time
 489     // to terminate.
 490     final boolean isReferenced() {
 491         HttpClient facade = facade();
 492         return facade != null || referenceCount() &gt; 0;
 493     }
 494 
 495     /**
 496      * Wait for activity on given exchange.
 497      * The following occurs in the SelectorManager thread.
 498      *
 499      *  1) add to selector
 500      *  2) If selector fires for this exchange then
 501      *     call AsyncEvent.handle()
 502      *
 503      * If exchange needs to change interest ops, then call registerEvent() again.
 504      */
 505     void registerEvent(AsyncEvent exchange) throws IOException {
 506         selmgr.register(exchange);
 507     }
 508 
 509     /**
 510      * Allows an AsyncEvent to modify its interestOps.
 511      * @param event The modified event.
 512      */
 513     void eventUpdated(AsyncEvent event) throws ClosedChannelException {
 514         assert !(event instanceof AsyncTriggerEvent);
 515         selmgr.eventUpdated(event);
 516     }
 517 
 518     boolean isSelectorThread() {
 519         return Thread.currentThread() == selmgr;
 520     }
 521 
 522     Http2ClientImpl client2() {
 523         return client2;
 524     }
 525 
 526     private void debugCompleted(String tag, long startNanos, HttpRequest req) {
 527         if (debugelapsed.on()) {
 528             debugelapsed.log(tag + &quot; elapsed &quot;
 529                     + (System.nanoTime() - startNanos)/1000_000L
 530                     + &quot; millis for &quot; + req.method()
 531                     + &quot; to &quot; + req.uri());
 532         }
 533     }
 534 
 535     @Override
 536     public &lt;T&gt; HttpResponse&lt;T&gt;
 537     send(HttpRequest req, BodyHandler&lt;T&gt; responseHandler)
 538         throws IOException, InterruptedException
 539     {
 540         CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; cf = null;
 541         try {
 542             cf = sendAsync(req, responseHandler, null, null);
 543             return cf.get();
 544         } catch (InterruptedException ie) {
 545             if (cf != null )
 546                 cf.cancel(true);
 547             throw ie;
 548         } catch (ExecutionException e) {
 549             final Throwable throwable = e.getCause();
 550             final String msg = throwable.getMessage();
 551 
 552             if (throwable instanceof IllegalArgumentException) {
 553                 throw new IllegalArgumentException(msg, throwable);
 554             } else if (throwable instanceof SecurityException) {
 555                 throw new SecurityException(msg, throwable);
 556             } else if (throwable instanceof HttpConnectTimeoutException) {
 557                 HttpConnectTimeoutException hcte = new HttpConnectTimeoutException(msg);
 558                 hcte.initCause(throwable);
 559                 throw hcte;
 560             } else if (throwable instanceof HttpTimeoutException) {
 561                 throw new HttpTimeoutException(msg);
 562             } else if (throwable instanceof ConnectException) {
 563                 ConnectException ce = new ConnectException(msg);
 564                 ce.initCause(throwable);
 565                 throw ce;
 566             } else if (throwable instanceof SSLHandshakeException) {
 567                 // special case for SSLHandshakeException
 568                 SSLHandshakeException he = new SSLHandshakeException(msg);
 569                 he.initCause(throwable);
 570                 throw he;
 571             } else if (throwable instanceof SSLException) {
 572                 // any other SSLException is wrapped in a plain
 573                 // SSLException
 574                 throw new SSLException(msg, throwable);
 575             } else if (throwable instanceof IOException) {
 576                 throw new IOException(msg, throwable);
 577             } else {
 578                 throw new IOException(msg, throwable);
 579             }
 580         }
 581     }
 582 
 583     private static final Executor ASYNC_POOL = new CompletableFuture&lt;Void&gt;().defaultExecutor();
 584 
 585     @Override
 586     public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;
 587     sendAsync(HttpRequest userRequest, BodyHandler&lt;T&gt; responseHandler)
 588     {
 589         return sendAsync(userRequest, responseHandler, null);
 590     }
 591 
 592     @Override
 593     public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;
 594     sendAsync(HttpRequest userRequest,
 595               BodyHandler&lt;T&gt; responseHandler,
 596               PushPromiseHandler&lt;T&gt; pushPromiseHandler) {
 597         return sendAsync(userRequest, responseHandler, pushPromiseHandler, delegatingExecutor.delegate);
 598     }
 599 
 600     private &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;
 601     sendAsync(HttpRequest userRequest,
 602               BodyHandler&lt;T&gt; responseHandler,
 603               PushPromiseHandler&lt;T&gt; pushPromiseHandler,
 604               Executor exchangeExecutor)    {
 605 
 606         Objects.requireNonNull(userRequest);
 607         Objects.requireNonNull(responseHandler);
 608 
 609         AccessControlContext acc = null;
 610         if (System.getSecurityManager() != null)
 611             acc = AccessController.getContext();
 612 
 613         // Clone the, possibly untrusted, HttpRequest
 614         HttpRequestImpl requestImpl = new HttpRequestImpl(userRequest, proxySelector);
 615         if (requestImpl.method().equals(&quot;CONNECT&quot;))
 616             throw new IllegalArgumentException(&quot;Unsupported method CONNECT&quot;);
 617 
 618         long start = DEBUGELAPSED ? System.nanoTime() : 0;
 619         reference();
 620         try {
 621             if (debugelapsed.on())
 622                 debugelapsed.log(&quot;ClientImpl (async) send %s&quot;, userRequest);
 623 
 624             // When using sendAsync(...) we explicitly pass the
 625             // executor&#39;s delegate as exchange executor to force
 626             // asynchronous scheduling of the exchange.
 627             // When using send(...) we don&#39;t specify any executor
 628             // and default to using the client&#39;s delegating executor
 629             // which only spawns asynchronous tasks if it detects
 630             // that the current thread is the selector manager
 631             // thread. This will cause everything to execute inline
 632             // until we need to schedule some event with the selector.
 633             Executor executor = exchangeExecutor == null
 634                     ? this.delegatingExecutor : exchangeExecutor;
 635 
 636             MultiExchange&lt;T&gt; mex = new MultiExchange&lt;&gt;(userRequest,
 637                                                             requestImpl,
 638                                                             this,
 639                                                             responseHandler,
 640                                                             pushPromiseHandler,
 641                                                             acc);
 642             CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; res =
 643                     mex.responseAsync(executor).whenComplete((b,t) -&gt; unreference());
 644             if (DEBUGELAPSED) {
 645                 res = res.whenComplete(
 646                         (b,t) -&gt; debugCompleted(&quot;ClientImpl (async)&quot;, start, userRequest));
 647             }
 648 
 649             // makes sure that any dependent actions happen in the CF default
 650             // executor. This is only needed for sendAsync(...), when
 651             // exchangeExecutor is non-null.
 652             if (exchangeExecutor != null) {
 653                 res = res.whenCompleteAsync((r, t) -&gt; { /* do nothing */}, ASYNC_POOL);
 654             }
 655             return res;
 656         } catch(Throwable t) {
 657             unreference();
 658             debugCompleted(&quot;ClientImpl (async)&quot;, start, userRequest);
 659             throw t;
 660         }
 661     }
 662 
 663     // Main loop for this client&#39;s selector
 664     private final static class SelectorManager extends Thread {
 665 
 666         // For testing purposes we have an internal System property that
 667         // can control the frequency at which the selector manager will wake
 668         // up when there are no pending operations.
 669         // Increasing the frequency (shorter delays) might allow the selector
 670         // to observe that the facade is no longer referenced and might allow
 671         // the selector thread to terminate more timely - for when nothing is
 672         // ongoing it will only check for that condition every NODEADLINE ms.
 673         // To avoid misuse of the property, the delay that can be specified
 674         // is comprised between [MIN_NODEADLINE, MAX_NODEADLINE], and its default
 675         // value if unspecified (or &lt;= 0) is DEF_NODEADLINE = 3000ms
 676         // The property is -Djdk.internal.httpclient.selectorTimeout=&lt;millis&gt;
 677         private static final int MIN_NODEADLINE = 1000; // ms
 678         private static final int MAX_NODEADLINE = 1000 * 1200; // ms
 679         private static final int DEF_NODEADLINE = 3000; // ms
 680         private static final long NODEADLINE; // default is DEF_NODEADLINE ms
 681         static {
 682             // ensure NODEADLINE is initialized with some valid value.
 683             long deadline =  Utils.getIntegerProperty(
 684                 &quot;jdk.internal.httpclient.selectorTimeout&quot;,
 685                 DEF_NODEADLINE); // millis
 686             if (deadline &lt;= 0) deadline = DEF_NODEADLINE;
 687             deadline = Math.max(deadline, MIN_NODEADLINE);
 688             NODEADLINE = Math.min(deadline, MAX_NODEADLINE);
 689         }
 690 
 691         private final Selector selector;
 692         private volatile boolean closed;
 693         private final List&lt;AsyncEvent&gt; registrations;
 694         private final List&lt;AsyncTriggerEvent&gt; deregistrations;
 695         private final Logger debug;
 696         private final Logger debugtimeout;
 697         HttpClientImpl owner;
 698         ConnectionPool pool;
 699 
 700         SelectorManager(HttpClientImpl ref) throws IOException {
 701             super(null, null,
 702                   &quot;HttpClient-&quot; + ref.id + &quot;-SelectorManager&quot;,
 703                   0, false);
 704             owner = ref;
 705             debug = ref.debug;
 706             debugtimeout = ref.debugtimeout;
 707             pool = ref.connectionPool();
 708             registrations = new ArrayList&lt;&gt;();
 709             deregistrations = new ArrayList&lt;&gt;();
 710             selector = Selector.open();
 711         }
 712 
 713         void eventUpdated(AsyncEvent e) throws ClosedChannelException {
 714             if (Thread.currentThread() == this) {
 715                 SelectionKey key = e.channel().keyFor(selector);
 716                 if (key != null &amp;&amp; key.isValid()) {
 717                     SelectorAttachment sa = (SelectorAttachment) key.attachment();
 718                     sa.register(e);
 719                 } else if (e.interestOps() != 0){
 720                     // We don&#39;t care about paused events.
 721                     // These are actually handled by
 722                     // SelectorAttachment::resetInterestOps later on.
 723                     // But if we reach here when trying to resume an
 724                     // event then it&#39;s better to fail fast.
 725                     if (debug.on()) debug.log(&quot;No key for channel&quot;);
 726                     e.abort(new IOException(&quot;No key for channel&quot;));
 727                 }
 728             } else {
 729                 register(e);
 730             }
 731         }
 732 
 733         // This returns immediately. So caller not allowed to send/receive
 734         // on connection.
 735         synchronized void register(AsyncEvent e) {
 736             registrations.add(e);
 737             selector.wakeup();
 738         }
 739 
 740         synchronized void cancel(SocketChannel e) {
 741             SelectionKey key = e.keyFor(selector);
 742             if (key != null) {
 743                 key.cancel();
 744             }
 745             selector.wakeup();
 746         }
 747 
 748         void wakeupSelector() {
 749             selector.wakeup();
 750         }
 751 
 752         synchronized void shutdown() {
 753             Log.logTrace(&quot;{0}: shutting down&quot;, getName());
 754             if (debug.on()) debug.log(&quot;SelectorManager shutting down&quot;);
 755             closed = true;
 756             try {
 757                 selector.close();
 758             } catch (IOException ignored) {
 759             } finally {
 760                 owner.stop();
 761             }
 762         }
 763 
 764         @Override
 765         public void run() {
 766             List&lt;Pair&lt;AsyncEvent,IOException&gt;&gt; errorList = new ArrayList&lt;&gt;();
 767             List&lt;AsyncEvent&gt; readyList = new ArrayList&lt;&gt;();
 768             List&lt;Runnable&gt; resetList = new ArrayList&lt;&gt;();
 769             try {
 770                 if (Log.channel()) Log.logChannel(getName() + &quot;: starting&quot;);
 771                 while (!Thread.currentThread().isInterrupted()) {
 772                     synchronized (this) {
 773                         assert errorList.isEmpty();
 774                         assert readyList.isEmpty();
 775                         assert resetList.isEmpty();
 776                         for (AsyncTriggerEvent event : deregistrations) {
 777                             event.handle();
 778                         }
 779                         deregistrations.clear();
 780                         for (AsyncEvent event : registrations) {
 781                             if (event instanceof AsyncTriggerEvent) {
 782                                 readyList.add(event);
 783                                 continue;
 784                             }
 785                             SelectableChannel chan = event.channel();
 786                             SelectionKey key = null;
 787                             try {
 788                                 key = chan.keyFor(selector);
 789                                 SelectorAttachment sa;
 790                                 if (key == null || !key.isValid()) {
 791                                     if (key != null) {
 792                                         // key is canceled.
 793                                         // invoke selectNow() to purge it
 794                                         // before registering the new event.
 795                                         selector.selectNow();
 796                                     }
 797                                     sa = new SelectorAttachment(chan, selector);
 798                                 } else {
 799                                     sa = (SelectorAttachment) key.attachment();
 800                                 }
 801                                 // may throw IOE if channel closed: that&#39;s OK
 802                                 sa.register(event);
 803                                 if (!chan.isOpen()) {
 804                                     throw new IOException(&quot;Channel closed&quot;);
 805                                 }
 806                             } catch (IOException e) {
 807                                 Log.logTrace(&quot;{0}: {1}&quot;, getName(), e);
 808                                 if (debug.on())
 809                                     debug.log(&quot;Got &quot; + e.getClass().getName()
 810                                               + &quot; while handling registration events&quot;);
 811                                 chan.close();
 812                                 // let the event abort deal with it
 813                                 errorList.add(new Pair&lt;&gt;(event, e));
 814                                 if (key != null) {
 815                                     key.cancel();
 816                                     selector.selectNow();
 817                                 }
 818                             }
 819                         }
 820                         registrations.clear();
 821                         selector.selectedKeys().clear();
 822                     }
 823 
 824                     for (AsyncEvent event : readyList) {
 825                         assert event instanceof AsyncTriggerEvent;
 826                         event.handle();
 827                     }
 828                     readyList.clear();
 829 
 830                     for (Pair&lt;AsyncEvent,IOException&gt; error : errorList) {
 831                         // an IOException was raised and the channel closed.
 832                         handleEvent(error.first, error.second);
 833                     }
 834                     errorList.clear();
 835 
 836                     // Check whether client is still alive, and if not,
 837                     // gracefully stop this thread
 838                     if (!owner.isReferenced()) {
 839                         Log.logTrace(&quot;{0}: {1}&quot;,
 840                                 getName(),
 841                                 &quot;HttpClient no longer referenced. Exiting...&quot;);
 842                         return;
 843                     }
 844 
 845                     // Timeouts will have milliseconds granularity. It is important
 846                     // to handle them in a timely fashion.
 847                     long nextTimeout = owner.purgeTimeoutsAndReturnNextDeadline();
 848                     if (debugtimeout.on())
 849                         debugtimeout.log(&quot;next timeout: %d&quot;, nextTimeout);
 850 
 851                     // Keep-alive have seconds granularity. It&#39;s not really an
 852                     // issue if we keep connections linger a bit more in the keep
 853                     // alive cache.
 854                     long nextExpiry = pool.purgeExpiredConnectionsAndReturnNextDeadline();
 855                     if (debugtimeout.on())
 856                         debugtimeout.log(&quot;next expired: %d&quot;, nextExpiry);
 857 
 858                     assert nextTimeout &gt;= 0;
 859                     assert nextExpiry &gt;= 0;
 860 
 861                     // Don&#39;t wait for ever as it might prevent the thread to
 862                     // stop gracefully. millis will be 0 if no deadline was found.
 863                     if (nextTimeout &lt;= 0) nextTimeout = NODEADLINE;
 864 
 865                     // Clip nextExpiry at NODEADLINE limit. The default
 866                     // keep alive is 1200 seconds (half an hour) - we don&#39;t
 867                     // want to wait that long.
 868                     if (nextExpiry &lt;= 0) nextExpiry = NODEADLINE;
 869                     else nextExpiry = Math.min(NODEADLINE, nextExpiry);
 870 
 871                     // takes the least of the two.
 872                     long millis = Math.min(nextExpiry, nextTimeout);
 873 
 874                     if (debugtimeout.on())
 875                         debugtimeout.log(&quot;Next deadline is %d&quot;,
 876                                          (millis == 0 ? NODEADLINE : millis));
 877                     //debugPrint(selector);
 878                     int n = selector.select(millis == 0 ? NODEADLINE : millis);
 879                     if (n == 0) {
 880                         // Check whether client is still alive, and if not,
 881                         // gracefully stop this thread
 882                         if (!owner.isReferenced()) {
 883                             Log.logTrace(&quot;{0}: {1}&quot;,
 884                                     getName(),
 885                                     &quot;HttpClient no longer referenced. Exiting...&quot;);
 886                             return;
 887                         }
 888                         owner.purgeTimeoutsAndReturnNextDeadline();
 889                         continue;
 890                     }
 891 
 892                     Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
 893                     assert errorList.isEmpty();
 894 
 895                     for (SelectionKey key : keys) {
 896                         SelectorAttachment sa = (SelectorAttachment) key.attachment();
 897                         if (!key.isValid()) {
 898                             IOException ex = sa.chan.isOpen()
 899                                     ? new IOException(&quot;Invalid key&quot;)
 900                                     : new ClosedChannelException();
 901                             sa.pending.forEach(e -&gt; errorList.add(new Pair&lt;&gt;(e,ex)));
 902                             sa.pending.clear();
 903                             continue;
 904                         }
 905 
 906                         int eventsOccurred;
 907                         try {
 908                             eventsOccurred = key.readyOps();
 909                         } catch (CancelledKeyException ex) {
 910                             IOException io = Utils.getIOException(ex);
 911                             sa.pending.forEach(e -&gt; errorList.add(new Pair&lt;&gt;(e,io)));
 912                             sa.pending.clear();
 913                             continue;
 914                         }
 915                         sa.events(eventsOccurred).forEach(readyList::add);
 916                         resetList.add(() -&gt; sa.resetInterestOps(eventsOccurred));
 917                     }
 918 
 919                     selector.selectNow(); // complete cancellation
 920                     selector.selectedKeys().clear();
 921 
 922                     // handle selected events
 923                     readyList.forEach((e) -&gt; handleEvent(e, null));
 924                     readyList.clear();
 925 
 926                     // handle errors (closed channels etc...)
 927                     errorList.forEach((p) -&gt; handleEvent(p.first, p.second));
 928                     errorList.clear();
 929 
 930                     // reset interest ops for selected channels
 931                     resetList.forEach(r -&gt; r.run());
 932                     resetList.clear();
 933 
 934                 }
 935             } catch (Throwable e) {
 936                 if (!closed) {
 937                     // This terminates thread. So, better just print stack trace
 938                     String err = Utils.stackTrace(e);
 939                     Log.logError(&quot;{0}: {1}: {2}&quot;, getName(),
 940                             &quot;HttpClientImpl shutting down due to fatal error&quot;, err);
 941                 }
 942                 if (debug.on()) debug.log(&quot;shutting down&quot;, e);
 943                 if (Utils.ASSERTIONSENABLED &amp;&amp; !debug.on()) {
 944                     e.printStackTrace(System.err); // always print the stack
 945                 }
 946             } finally {
 947                 if (Log.channel()) Log.logChannel(getName() + &quot;: stopping&quot;);
 948                 shutdown();
 949             }
 950         }
 951 
 952 //        void debugPrint(Selector selector) {
 953 //            System.err.println(&quot;Selector: debugprint start&quot;);
 954 //            Set&lt;SelectionKey&gt; keys = selector.keys();
 955 //            for (SelectionKey key : keys) {
 956 //                SelectableChannel c = key.channel();
 957 //                int ops = key.interestOps();
 958 //                System.err.printf(&quot;selector chan:%s ops:%d\n&quot;, c, ops);
 959 //            }
 960 //            System.err.println(&quot;Selector: debugprint end&quot;);
 961 //        }
 962 
 963         /** Handles the given event. The given ioe may be null. */
 964         void handleEvent(AsyncEvent event, IOException ioe) {
 965             if (closed || ioe != null) {
 966                 event.abort(ioe);
 967             } else {
 968                 event.handle();
 969             }
 970         }
 971     }
 972 
 973     final String debugInterestOps(SelectableChannel channel) {
 974         try {
 975             SelectionKey key = channel.keyFor(selmgr.selector);
 976             if (key == null) return &quot;channel not registered with selector&quot;;
 977             String keyInterestOps = key.isValid()
 978                     ? &quot;key.interestOps=&quot; + key.interestOps() : &quot;invalid key&quot;;
 979             return String.format(&quot;channel registered with selector, %s, sa.interestOps=%s&quot;,
 980                                  keyInterestOps,
 981                                  ((SelectorAttachment)key.attachment()).interestOps);
 982         } catch (Throwable t) {
 983             return String.valueOf(t);
 984         }
 985     }
 986 
 987     /**
 988      * Tracks multiple user level registrations associated with one NIO
 989      * registration (SelectionKey). In this implementation, registrations
 990      * are one-off and when an event is posted the registration is cancelled
 991      * until explicitly registered again.
 992      *
 993      * &lt;p&gt; No external synchronization required as this class is only used
 994      * by the SelectorManager thread. One of these objects required per
 995      * connection.
 996      */
 997     private static class SelectorAttachment {
 998         private final SelectableChannel chan;
 999         private final Selector selector;
1000         private final Set&lt;AsyncEvent&gt; pending;
1001         private final static Logger debug =
1002                 Utils.getDebugLogger(&quot;SelectorAttachment&quot;::toString, Utils.DEBUG);
1003         private int interestOps;
1004 
1005         SelectorAttachment(SelectableChannel chan, Selector selector) {
1006             this.pending = new HashSet&lt;&gt;();
1007             this.chan = chan;
1008             this.selector = selector;
1009         }
1010 
1011         void register(AsyncEvent e) throws ClosedChannelException {
1012             int newOps = e.interestOps();
1013             // re register interest if we are not already interested
1014             // in the event. If the event is paused, then the pause will
1015             // be taken into account later when resetInterestOps is called.
1016             boolean reRegister = (interestOps &amp; newOps) != newOps;
1017             interestOps |= newOps;
1018             pending.add(e);
1019             if (debug.on())
1020                 debug.log(&quot;Registering %s for %d (%s)&quot;, e, newOps, reRegister);
1021             if (reRegister) {
1022                 // first time registration happens here also
1023                 try {
1024                     chan.register(selector, interestOps, this);
1025                 } catch (Throwable x) {
1026                     abortPending(x);
1027                 }
1028             } else if (!chan.isOpen()) {
1029                 abortPending(new ClosedChannelException());
1030             }
1031         }
1032 
1033         /**
1034          * Returns a Stream&lt;AsyncEvents&gt; containing only events that are
1035          * registered with the given {@code interestOps}.
1036          */
1037         Stream&lt;AsyncEvent&gt; events(int interestOps) {
1038             return pending.stream()
1039                     .filter(ev -&gt; (ev.interestOps() &amp; interestOps) != 0);
1040         }
1041 
1042         /**
1043          * Removes any events with the given {@code interestOps}, and if no
1044          * events remaining, cancels the associated SelectionKey.
1045          */
1046         void resetInterestOps(int interestOps) {
1047             int newOps = 0;
1048 
1049             Iterator&lt;AsyncEvent&gt; itr = pending.iterator();
1050             while (itr.hasNext()) {
1051                 AsyncEvent event = itr.next();
1052                 int evops = event.interestOps();
1053                 if (event.repeating()) {
1054                     newOps |= evops;
1055                     continue;
1056                 }
1057                 if ((evops &amp; interestOps) != 0) {
1058                     itr.remove();
1059                 } else {
1060                     newOps |= evops;
1061                 }
1062             }
1063 
1064             this.interestOps = newOps;
1065             SelectionKey key = chan.keyFor(selector);
1066             if (newOps == 0 &amp;&amp; key != null &amp;&amp; pending.isEmpty()) {
1067                 key.cancel();
1068             } else {
1069                 try {
1070                     if (key == null || !key.isValid()) {
1071                         throw new CancelledKeyException();
1072                     }
1073                     key.interestOps(newOps);
1074                     // double check after
1075                     if (!chan.isOpen()) {
1076                         abortPending(new ClosedChannelException());
1077                         return;
1078                     }
1079                     assert key.interestOps() == newOps;
1080                 } catch (CancelledKeyException x) {
1081                     // channel may have been closed
1082                     if (debug.on()) debug.log(&quot;key cancelled for &quot; + chan);
1083                     abortPending(x);
1084                 }
1085             }
1086         }
1087 
1088         void abortPending(Throwable x) {
1089             if (!pending.isEmpty()) {
1090                 AsyncEvent[] evts = pending.toArray(new AsyncEvent[0]);
1091                 pending.clear();
1092                 IOException io = Utils.getIOException(x);
1093                 for (AsyncEvent event : evts) {
1094                     event.abort(io);
1095                 }
1096             }
1097         }
1098     }
1099 
1100     /*package-private*/ SSLContext theSSLContext() {
1101         return sslContext;
1102     }
1103 
1104     @Override
1105     public SSLContext sslContext() {
1106         return sslContext;
1107     }
1108 
1109     @Override
1110     public SSLParameters sslParameters() {
1111         return Utils.copySSLParameters(sslParams);
1112     }
1113 
1114     @Override
1115     public Optional&lt;Authenticator&gt; authenticator() {
1116         return Optional.ofNullable(authenticator);
1117     }
1118 
1119     /*package-private*/ final DelegatingExecutor theExecutor() {
1120         return delegatingExecutor;
1121     }
1122 
1123     @Override
1124     public final Optional&lt;Executor&gt; executor() {
1125         return isDefaultExecutor
1126                 ? Optional.empty()
1127                 : Optional.of(delegatingExecutor.delegate());
1128     }
1129 
1130     ConnectionPool connectionPool() {
1131         return connections;
1132     }
1133 
1134     @Override
1135     public Redirect followRedirects() {
1136         return followRedirects;
1137     }
1138 
1139 
1140     @Override
1141     public Optional&lt;CookieHandler&gt; cookieHandler() {
1142         return Optional.ofNullable(cookieHandler);
1143     }
1144 
1145     @Override
1146     public Optional&lt;Duration&gt; connectTimeout() {
1147         return Optional.ofNullable(connectTimeout);
1148     }
1149 
1150     @Override
1151     public Optional&lt;ProxySelector&gt; proxy() {
1152         return Optional.ofNullable(userProxySelector);
1153     }
1154 
1155     // Return the effective proxy that this client uses.
1156     ProxySelector proxySelector() {
1157         return proxySelector;
1158     }
1159 
1160     @Override
1161     public WebSocket.Builder newWebSocketBuilder() {
1162         // Make sure to pass the HttpClientFacade to the WebSocket builder.
1163         // This will ensure that the facade is not released before the
1164         // WebSocket has been created, at which point the pendingOperationCount
1165         // will have been incremented by the RawChannelTube.
1166         // See RawChannelTube.
1167         return new BuilderImpl(this.facade(), proxySelector);
1168     }
1169 
1170     @Override
1171     public Version version() {
1172         return version;
1173     }
1174 
1175     String dbgString() {
1176         return dbgTag;
1177     }
1178 
1179     @Override
1180     public String toString() {
1181         // Used by tests to get the client&#39;s id and compute the
1182         // name of the SelectorManager thread.
1183         return super.toString() + (&quot;(&quot; + id + &quot;)&quot;);
1184     }
1185 
1186     private void initFilters() {
1187         addFilter(AuthenticationFilter.class);
1188         addFilter(RedirectFilter.class);
1189         if (this.cookieHandler != null) {
1190             addFilter(CookieFilter.class);
1191         }
1192     }
1193 
1194     private void addFilter(Class&lt;? extends HeaderFilter&gt; f) {
1195         filters.addFilter(f);
1196     }
1197 
1198     final LinkedList&lt;HeaderFilter&gt; filterChain() {
1199         return filters.getFilterChain();
1200     }
1201 
1202     // Timer controls.
1203     // Timers are implemented through timed Selector.select() calls.
1204 
1205     synchronized void registerTimer(TimeoutEvent event) {
1206         Log.logTrace(&quot;Registering timer {0}&quot;, event);
1207         timeouts.add(event);
1208         selmgr.wakeupSelector();
1209     }
1210 
1211     synchronized void cancelTimer(TimeoutEvent event) {
1212         Log.logTrace(&quot;Canceling timer {0}&quot;, event);
1213         timeouts.remove(event);
1214     }
1215 
1216     /**
1217      * Purges ( handles ) timer events that have passed their deadline, and
1218      * returns the amount of time, in milliseconds, until the next earliest
1219      * event. A return value of 0 means that there are no events.
1220      */
1221     private long purgeTimeoutsAndReturnNextDeadline() {
1222         long diff = 0L;
1223         List&lt;TimeoutEvent&gt; toHandle = null;
1224         int remaining = 0;
1225         // enter critical section to retrieve the timeout event to handle
1226         synchronized(this) {
1227             if (timeouts.isEmpty()) return 0L;
1228 
1229             Instant now = Instant.now();
1230             Iterator&lt;TimeoutEvent&gt; itr = timeouts.iterator();
1231             while (itr.hasNext()) {
1232                 TimeoutEvent event = itr.next();
1233                 diff = now.until(event.deadline(), ChronoUnit.MILLIS);
1234                 if (diff &lt;= 0) {
1235                     itr.remove();
1236                     toHandle = (toHandle == null) ? new ArrayList&lt;&gt;() : toHandle;
1237                     toHandle.add(event);
1238                 } else {
1239                     break;
1240                 }
1241             }
1242             remaining = timeouts.size();
1243         }
1244 
1245         // can be useful for debugging
1246         if (toHandle != null &amp;&amp; Log.trace()) {
1247             Log.logTrace(&quot;purgeTimeoutsAndReturnNextDeadline: handling &quot;
1248                     +  toHandle.size() + &quot; events, &quot;
1249                     + &quot;remaining &quot; + remaining
1250                     + &quot;, next deadline: &quot; + (diff &lt; 0 ? 0L : diff));
1251         }
1252 
1253         // handle timeout events out of critical section
1254         if (toHandle != null) {
1255             Throwable failed = null;
1256             for (TimeoutEvent event : toHandle) {
1257                 try {
1258                    Log.logTrace(&quot;Firing timer {0}&quot;, event);
1259                    event.handle();
1260                 } catch (Error | RuntimeException e) {
1261                     // Not expected. Handle remaining events then throw...
1262                     // If e is an OOME or SOE it might simply trigger a new
1263                     // error from here - but in this case there&#39;s not much we
1264                     // could do anyway. Just let it flow...
1265                     if (failed == null) failed = e;
1266                     else failed.addSuppressed(e);
1267                     Log.logTrace(&quot;Failed to handle event {0}: {1}&quot;, event, e);
1268                 }
1269             }
1270             if (failed instanceof Error) throw (Error) failed;
1271             if (failed instanceof RuntimeException) throw (RuntimeException) failed;
1272         }
1273 
1274         // return time to wait until next event. 0L if there&#39;s no more events.
1275         return diff &lt; 0 ? 0L : diff;
1276     }
1277 
1278     // used for the connection window
1279     int getReceiveBufferSize() {
1280         return Utils.getIntegerNetProperty(
1281                 &quot;jdk.httpclient.receiveBufferSize&quot;,
1282                 0 // only set the size if &gt; 0
1283         );
1284     }
1285 
1286     // Optimization for reading SSL encrypted data
1287     // --------------------------------------------
1288 
1289     // Returns a BufferSupplier that can be used for reading
1290     // encrypted bytes of the channel. These buffers can then
1291     // be recycled by the SSLFlowDelegate::Reader after their
1292     // content has been copied in the SSLFlowDelegate::Reader
1293     // readBuf.
1294     // Because allocating, reading, copying, and recycling
1295     // all happen in the SelectorManager thread,
1296     // then this BufferSupplier can be shared between all
1297     // the SSL connections managed by this client.
1298     BufferSupplier getSSLBufferSupplier() {
1299         return sslBufferSupplier;
1300     }
1301 
1302     // An implementation of BufferSupplier that manages a pool of
1303     // maximum 3 direct byte buffers (SocketTube.MAX_BUFFERS) that
1304     // are used for reading encrypted bytes off the channel before
1305     // copying and subsequent unwrapping.
1306     private static final class SSLDirectBufferSupplier implements BufferSupplier {
1307         private static final int POOL_SIZE = SocketTube.MAX_BUFFERS;
1308         private final ByteBuffer[] pool = new ByteBuffer[POOL_SIZE];
1309         private final HttpClientImpl client;
1310         private final Logger debug;
1311         private int tail, count; // no need for volatile: only accessed in SM thread.
1312 
1313         SSLDirectBufferSupplier(HttpClientImpl client) {
1314             this.client = Objects.requireNonNull(client);
1315             this.debug = client.debug;
1316         }
1317 
1318         // Gets a buffer from the pool, or allocates a new one if needed.
1319         @Override
1320         public ByteBuffer get() {
1321             assert client.isSelectorThread();
1322             assert tail &lt;= POOL_SIZE : &quot;allocate tail is &quot; + tail;
1323             ByteBuffer buf;
1324             if (tail == 0) {
1325                 if (debug.on()) {
1326                     // should not appear more than SocketTube.MAX_BUFFERS
1327                     debug.log(&quot;ByteBuffer.allocateDirect(%d)&quot;, Utils.BUFSIZE);
1328                 }
1329                 assert count++ &lt; POOL_SIZE : &quot;trying to allocate more than &quot;
1330                             + POOL_SIZE + &quot; buffers&quot;;
1331                 buf = ByteBuffer.allocateDirect(Utils.BUFSIZE);
1332             } else {
1333                 assert tail &gt; 0 : &quot;non positive tail value: &quot; + tail;
1334                 tail--;
1335                 buf = pool[tail];
1336                 pool[tail] = null;
1337             }
1338             assert buf.isDirect();
1339             assert buf.position() == 0;
1340             assert buf.hasRemaining();
1341             assert buf.limit() == Utils.BUFSIZE;
1342             assert tail &lt; POOL_SIZE;
1343             assert tail &gt;= 0;
1344             return buf;
1345         }
1346 
1347         // Returns the given buffer to the pool.
1348         @Override
1349         public void recycle(ByteBuffer buffer) {
1350             assert client.isSelectorThread();
1351             assert buffer.isDirect();
1352             assert !buffer.hasRemaining();
1353             assert tail &lt; POOL_SIZE : &quot;recycle tail is &quot; + tail;
1354             assert tail &gt;= 0;
1355             buffer.position(0);
1356             buffer.limit(buffer.capacity());
1357             // don&#39;t fail if assertions are off. we have asserted above.
1358             if (tail &lt; POOL_SIZE) {
1359                 pool[tail] = buffer;
1360                 tail++;
1361             }
1362             assert tail &lt;= POOL_SIZE;
1363             assert tail &gt; 0;
1364         }
1365     }
1366 
1367 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/java.net.http/share/classes/jdk/internal/net/http/HttpClientImpl.java</title>
    <link rel="stylesheet" href="../../../../../../../../style.css" />
    <script type="text/javascript" src="../../../../../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package jdk.internal.net.http;
  27 
  28 import javax.net.ssl.SSLContext;
  29 import javax.net.ssl.SSLException;
  30 import javax.net.ssl.SSLHandshakeException;
  31 import javax.net.ssl.SSLParameters;
  32 import java.io.IOException;
  33 import java.io.UncheckedIOException;
  34 import java.lang.ref.Reference;
  35 import java.lang.ref.WeakReference;
  36 import java.net.Authenticator;
  37 import java.net.ConnectException;
  38 import java.net.CookieHandler;
  39 import java.net.ProxySelector;
  40 import java.net.http.HttpConnectTimeoutException;
  41 import java.net.http.HttpTimeoutException;
  42 import java.nio.ByteBuffer;
  43 import java.nio.channels.CancelledKeyException;
  44 import java.nio.channels.ClosedChannelException;
  45 import java.nio.channels.SelectableChannel;
  46 import java.nio.channels.SelectionKey;
  47 import java.nio.channels.Selector;
  48 import java.nio.channels.SocketChannel;
  49 import java.security.AccessControlContext;
  50 import java.security.AccessController;
  51 import java.security.NoSuchAlgorithmException;
  52 import java.security.PrivilegedAction;
  53 import java.time.Duration;
  54 import java.time.Instant;
  55 import java.time.temporal.ChronoUnit;
  56 import java.util.ArrayList;
  57 import java.util.HashSet;
  58 import java.util.Iterator;
  59 import java.util.LinkedList;
  60 import java.util.List;
  61 import java.util.Objects;
  62 import java.util.Optional;
  63 import java.util.Set;
  64 import java.util.TreeSet;
  65 import java.util.concurrent.CompletableFuture;
  66 import java.util.concurrent.CompletionException;
  67 import java.util.concurrent.ExecutionException;
  68 import java.util.concurrent.Executor;
  69 import java.util.concurrent.Executors;
  70 import java.util.concurrent.ThreadFactory;
  71 import java.util.concurrent.atomic.AtomicInteger;
  72 import java.util.concurrent.atomic.AtomicLong;
  73 import java.util.function.BooleanSupplier;
  74 import java.util.stream.Stream;
  75 import java.net.http.HttpClient;
  76 import java.net.http.HttpRequest;
  77 import java.net.http.HttpResponse;
  78 import java.net.http.HttpResponse.BodyHandler;
  79 import java.net.http.HttpResponse.PushPromiseHandler;
  80 import java.net.http.WebSocket;
  81 import jdk.internal.net.http.common.BufferSupplier;
  82 import jdk.internal.net.http.common.Log;
  83 import jdk.internal.net.http.common.Logger;
  84 import jdk.internal.net.http.common.Pair;
  85 import jdk.internal.net.http.common.Utils;
  86 import jdk.internal.net.http.common.OperationTrackers.Trackable;
  87 import jdk.internal.net.http.common.OperationTrackers.Tracker;
  88 import jdk.internal.net.http.websocket.BuilderImpl;
  89 import jdk.internal.misc.InnocuousThread;
  90 
  91 /**
  92  * Client implementation. Contains all configuration information and also
  93  * the selector manager thread which allows async events to be registered
  94  * and delivered when they occur. See AsyncEvent.
  95  */
  96 final class HttpClientImpl extends HttpClient implements Trackable {
  97 
  98     static final boolean DEBUGELAPSED = Utils.TESTING || Utils.DEBUG;  // dev flag
  99     static final boolean DEBUGTIMEOUT = false; // dev flag
 100     final Logger debug = Utils.getDebugLogger(this::dbgString, Utils.DEBUG);
 101     final Logger debugelapsed = Utils.getDebugLogger(this::dbgString, DEBUGELAPSED);
 102     final Logger debugtimeout = Utils.getDebugLogger(this::dbgString, DEBUGTIMEOUT);
 103     static final AtomicLong CLIENT_IDS = new AtomicLong();
 104 
 105     // Define the default factory as a static inner class
 106     // that embeds all the necessary logic to avoid
 107     // the risk of using a lambda that might keep a reference on the
 108     // HttpClient instance from which it was created (helps with
 109     // heapdump analysis).
 110     private static final class DefaultThreadFactory implements ThreadFactory {
 111         private final String namePrefix;
 112         private final AtomicInteger nextId = new AtomicInteger();
 113 
 114         DefaultThreadFactory(long clientID) {
 115             namePrefix = &quot;HttpClient-&quot; + clientID + &quot;-Worker-&quot;;
 116         }
 117 
 118         @Override
 119         public Thread newThread(Runnable r) {
 120             String name = namePrefix + nextId.getAndIncrement();
 121             Thread t;
 122             if (System.getSecurityManager() == null) {
 123                 t = new Thread(null, r, name, 0, false);
 124             } else {
 125                 t = InnocuousThread.newThread(name, r);
 126             }
 127             t.setDaemon(true);
 128             return t;
 129         }
 130     }
 131 
 132     /**
 133      * A DelegatingExecutor is an executor that delegates tasks to
 134      * a wrapped executor when it detects that the current thread
 135      * is the SelectorManager thread. If the current thread is not
 136      * the selector manager thread the given task is executed inline.
 137      */
 138     final static class DelegatingExecutor implements Executor {
 139         private final BooleanSupplier isInSelectorThread;
 140         private final Executor delegate;
 141         DelegatingExecutor(BooleanSupplier isInSelectorThread, Executor delegate) {
 142             this.isInSelectorThread = isInSelectorThread;
 143             this.delegate = delegate;
 144         }
 145 
 146         Executor delegate() {
 147             return delegate;
 148         }
 149 
 150         @Override
 151         public void execute(Runnable command) {
 152             if (isInSelectorThread.getAsBoolean()) {
 153                 delegate.execute(command);
 154             } else {
 155                 command.run();
 156             }
 157         }
 158     }
 159 
 160     private final CookieHandler cookieHandler;
 161     private final Duration connectTimeout;
 162     private final Redirect followRedirects;
 163     private final ProxySelector userProxySelector;
 164     private final ProxySelector proxySelector;
 165     private final Authenticator authenticator;
 166     private final Version version;
 167     private final ConnectionPool connections;
 168     private final DelegatingExecutor delegatingExecutor;
 169     private final boolean isDefaultExecutor;
 170     // Security parameters
 171     private final SSLContext sslContext;
 172     private final SSLParameters sslParams;
 173     private final SelectorManager selmgr;
 174     private final FilterFactory filters;
 175     private final Http2ClientImpl client2;
 176     private final long id;
 177     private final String dbgTag;
 178 
 179     // The SSL DirectBuffer Supplier provides the ability to recycle
 180     // buffers used between the socket reader and the SSLEngine, or
 181     // more precisely between the SocketTube publisher and the
 182     // SSLFlowDelegate reader.
 183     private final SSLDirectBufferSupplier sslBufferSupplier
 184             = new SSLDirectBufferSupplier(this);
 185 
 186     // This reference is used to keep track of the facade HttpClient
 187     // that was returned to the application code.
 188     // It makes it possible to know when the application no longer
 189     // holds any reference to the HttpClient.
 190     // Unfortunately, this information is not enough to know when
 191     // to exit the SelectorManager thread. Because of the asynchronous
 192     // nature of the API, we also need to wait until all pending operations
 193     // have completed.
 194     private final WeakReference&lt;HttpClientFacade&gt; facadeRef;
 195 
 196     // This counter keeps track of the number of operations pending
 197     // on the HttpClient. The SelectorManager thread will wait
 198     // until there are no longer any pending operations and the
 199     // facadeRef is cleared before exiting.
 200     //
 201     // The pendingOperationCount is incremented every time a send/sendAsync
 202     // operation is invoked on the HttpClient, and is decremented when
 203     // the HttpResponse&lt;T&gt; object is returned to the user.
 204     // However, at this point, the body may not have been fully read yet.
 205     // This is the case when the response T is implemented as a streaming
 206     // subscriber (such as an InputStream).
 207     //
 208     // To take care of this issue the pendingOperationCount will additionally
 209     // be incremented/decremented in the following cases:
 210     //
 211     // 1. For HTTP/2  it is incremented when a stream is added to the
 212     //    Http2Connection streams map, and decreased when the stream is removed
 213     //    from the map. This should also take care of push promises.
 214     // 2. For WebSocket the count is increased when creating a
 215     //    DetachedConnectionChannel for the socket, and decreased
 216     //    when the channel is closed.
 217     //    In addition, the HttpClient facade is passed to the WebSocket builder,
 218     //    (instead of the client implementation delegate).
 219     // 3. For HTTP/1.1 the count is incremented before starting to parse the body
 220     //    response, and decremented when the parser has reached the end of the
 221     //    response body flow.
 222     //
 223     // This should ensure that the selector manager thread remains alive until
 224     // the response has been fully received or the web socket is closed.
 225     private final AtomicLong pendingOperationCount = new AtomicLong();
 226     private final AtomicLong pendingWebSocketCount = new AtomicLong();
 227     private final AtomicLong pendingHttpRequestCount = new AtomicLong();
 228     private final AtomicLong pendingHttp2StreamCount = new AtomicLong();
 229 
 230     /** A Set of, deadline first, ordered timeout events. */
 231     private final TreeSet&lt;TimeoutEvent&gt; timeouts;
 232 
 233     /**
 234      * This is a bit tricky:
 235      * 1. an HttpClientFacade has a final HttpClientImpl field.
 236      * 2. an HttpClientImpl has a final WeakReference&lt;HttpClientFacade&gt; field,
 237      *    where the referent is the facade created for that instance.
 238      * 3. We cannot just create the HttpClientFacade in the HttpClientImpl
 239      *    constructor, because it would be only weakly referenced and could
 240      *    be GC&#39;ed before we can return it.
 241      * The solution is to use an instance of SingleFacadeFactory which will
 242      * allow the caller of new HttpClientImpl(...) to retrieve the facade
 243      * after the HttpClientImpl has been created.
 244      */
 245     private static final class SingleFacadeFactory {
 246         HttpClientFacade facade;
 247         HttpClientFacade createFacade(HttpClientImpl impl) {
 248             assert facade == null;
 249             return (facade = new HttpClientFacade(impl));
 250         }
 251     }
 252 
 253     static HttpClientFacade create(HttpClientBuilderImpl builder) {
 254         SingleFacadeFactory facadeFactory = new SingleFacadeFactory();
 255         HttpClientImpl impl = new HttpClientImpl(builder, facadeFactory);
 256         impl.start();
 257         assert facadeFactory.facade != null;
 258         assert impl.facadeRef.get() == facadeFactory.facade;
 259         return facadeFactory.facade;
 260     }
 261 
 262     private HttpClientImpl(HttpClientBuilderImpl builder,
 263                            SingleFacadeFactory facadeFactory) {
 264         id = CLIENT_IDS.incrementAndGet();
 265         dbgTag = &quot;HttpClientImpl(&quot; + id +&quot;)&quot;;
 266         if (builder.sslContext == null) {
 267             try {
 268                 sslContext = SSLContext.getDefault();
 269             } catch (NoSuchAlgorithmException ex) {
 270                 throw new InternalError(ex);
 271             }
 272         } else {
 273             sslContext = builder.sslContext;
 274         }
 275         Executor ex = builder.executor;
 276         if (ex == null) {
 277             ex = Executors.newCachedThreadPool(new DefaultThreadFactory(id));
 278             isDefaultExecutor = true;
 279         } else {
 280             isDefaultExecutor = false;
 281         }
 282         delegatingExecutor = new DelegatingExecutor(this::isSelectorThread, ex);
 283         facadeRef = new WeakReference&lt;&gt;(facadeFactory.createFacade(this));
 284         client2 = new Http2ClientImpl(this);
 285         cookieHandler = builder.cookieHandler;
 286         connectTimeout = builder.connectTimeout;
 287         followRedirects = builder.followRedirects == null ?
 288                 Redirect.NEVER : builder.followRedirects;
 289         this.userProxySelector = builder.proxy;
 290         this.proxySelector = Optional.ofNullable(userProxySelector)
 291                 .orElseGet(HttpClientImpl::getDefaultProxySelector);
 292         if (debug.on())
 293             debug.log(&quot;proxySelector is %s (user-supplied=%s)&quot;,
 294                       this.proxySelector, userProxySelector != null);
 295         authenticator = builder.authenticator;
 296         if (builder.version == null) {
 297             version = HttpClient.Version.HTTP_2;
 298         } else {
 299             version = builder.version;
 300         }
 301         if (builder.sslParams == null) {
 302             sslParams = getDefaultParams(sslContext);
 303         } else {
 304             sslParams = builder.sslParams;
 305         }
 306         connections = new ConnectionPool(id);
 307         connections.start();
 308         timeouts = new TreeSet&lt;&gt;();
 309         try {
 310             selmgr = new SelectorManager(this);
 311         } catch (IOException e) {
 312             // unlikely
 313             throw new InternalError(e);
 314         }
 315         selmgr.setDaemon(true);
 316         filters = new FilterFactory();
 317         initFilters();
 318         assert facadeRef.get() != null;
 319     }
 320 
 321     private void start() {
 322         selmgr.start();
 323     }
 324 
 325     // Called from the SelectorManager thread, just before exiting.
 326     // Clears the HTTP/1.1 and HTTP/2 cache, ensuring that the connections
 327     // that may be still lingering there are properly closed (and their
 328     // possibly still opened SocketChannel released).
 329     private void stop() {
 330         // Clears HTTP/1.1 cache and close its connections
 331         connections.stop();
 332         // Clears HTTP/2 cache and close its connections.
 333         client2.stop();
 334     }
 335 
 336     private static SSLParameters getDefaultParams(SSLContext ctx) {
<a name="2" id="anc2"></a><span class="line-modified"> 337         SSLParameters params = ctx.getDefaultSSLParameters();</span>












 338         return params;
 339     }
 340 
 341     private static ProxySelector getDefaultProxySelector() {
 342         PrivilegedAction&lt;ProxySelector&gt; action = ProxySelector::getDefault;
 343         return AccessController.doPrivileged(action);
 344     }
 345 
 346     // Returns the facade that was returned to the application code.
 347     // May be null if that facade is no longer referenced.
 348     final HttpClientFacade facade() {
 349         return facadeRef.get();
 350     }
 351 
 352     // Increments the pendingOperationCount.
 353     final long reference() {
 354         pendingHttpRequestCount.incrementAndGet();
 355         return pendingOperationCount.incrementAndGet();
 356     }
 357 
 358     // Decrements the pendingOperationCount.
 359     final long unreference() {
 360         final long count = pendingOperationCount.decrementAndGet();
 361         final long httpCount = pendingHttpRequestCount.decrementAndGet();
 362         final long http2Count = pendingHttp2StreamCount.get();
 363         final long webSocketCount = pendingWebSocketCount.get();
 364         if (count == 0 &amp;&amp; facade() == null) {
 365             selmgr.wakeupSelector();
 366         }
 367         assert httpCount &gt;= 0 : &quot;count of HTTP/1.1 operations &lt; 0&quot;;
 368         assert http2Count &gt;= 0 : &quot;count of HTTP/2 operations &lt; 0&quot;;
 369         assert webSocketCount &gt;= 0 : &quot;count of WS operations &lt; 0&quot;;
 370         assert count &gt;= 0 : &quot;count of pending operations &lt; 0&quot;;
 371         return count;
 372     }
 373 
 374     // Increments the pendingOperationCount.
 375     final long streamReference() {
 376         pendingHttp2StreamCount.incrementAndGet();
 377         return pendingOperationCount.incrementAndGet();
 378     }
 379 
 380     // Decrements the pendingOperationCount.
 381     final long streamUnreference() {
 382         final long count = pendingOperationCount.decrementAndGet();
 383         final long http2Count = pendingHttp2StreamCount.decrementAndGet();
 384         final long httpCount = pendingHttpRequestCount.get();
 385         final long webSocketCount = pendingWebSocketCount.get();
 386         if (count == 0 &amp;&amp; facade() == null) {
 387             selmgr.wakeupSelector();
 388         }
 389         assert httpCount &gt;= 0 : &quot;count of HTTP/1.1 operations &lt; 0&quot;;
 390         assert http2Count &gt;= 0 : &quot;count of HTTP/2 operations &lt; 0&quot;;
 391         assert webSocketCount &gt;= 0 : &quot;count of WS operations &lt; 0&quot;;
 392         assert count &gt;= 0 : &quot;count of pending operations &lt; 0&quot;;
 393         return count;
 394     }
 395 
 396     // Increments the pendingOperationCount.
 397     final long webSocketOpen() {
 398         pendingWebSocketCount.incrementAndGet();
 399         return pendingOperationCount.incrementAndGet();
 400     }
 401 
 402     // Decrements the pendingOperationCount.
 403     final long webSocketClose() {
 404         final long count = pendingOperationCount.decrementAndGet();
 405         final long webSocketCount = pendingWebSocketCount.decrementAndGet();
 406         final long httpCount = pendingHttpRequestCount.get();
 407         final long http2Count = pendingHttp2StreamCount.get();
 408         if (count == 0 &amp;&amp; facade() == null) {
 409             selmgr.wakeupSelector();
 410         }
 411         assert httpCount &gt;= 0 : &quot;count of HTTP/1.1 operations &lt; 0&quot;;
 412         assert http2Count &gt;= 0 : &quot;count of HTTP/2 operations &lt; 0&quot;;
 413         assert webSocketCount &gt;= 0 : &quot;count of WS operations &lt; 0&quot;;
 414         assert count &gt;= 0 : &quot;count of pending operations &lt; 0&quot;;
 415         return count;
 416     }
 417 
 418     // Returns the pendingOperationCount.
 419     final long referenceCount() {
 420         return pendingOperationCount.get();
 421     }
 422 
 423     final static class HttpClientTracker implements Tracker {
 424         final AtomicLong httpCount;
 425         final AtomicLong http2Count;
 426         final AtomicLong websocketCount;
 427         final AtomicLong operationsCount;
 428         final Reference&lt;?&gt; reference;
 429         final String name;
 430         HttpClientTracker(AtomicLong http,
 431                           AtomicLong http2,
 432                           AtomicLong ws,
 433                           AtomicLong ops,
 434                           Reference&lt;?&gt; ref,
 435                           String name) {
 436             this.httpCount = http;
 437             this.http2Count = http2;
 438             this.websocketCount = ws;
 439             this.operationsCount = ops;
 440             this.reference = ref;
 441             this.name = name;
 442         }
 443         @Override
 444         public long getOutstandingOperations() {
 445             return operationsCount.get();
 446         }
 447         @Override
 448         public long getOutstandingHttpOperations() {
 449             return httpCount.get();
 450         }
 451         @Override
 452         public long getOutstandingHttp2Streams() { return http2Count.get(); }
 453         @Override
 454         public long getOutstandingWebSocketOperations() {
 455             return websocketCount.get();
 456         }
 457         @Override
 458         public boolean isFacadeReferenced() {
 459             return reference.get() != null;
 460         }
 461         @Override
 462         public String getName() {
 463             return name;
 464         }
 465     }
 466 
 467     public Tracker getOperationsTracker() {
 468         return new HttpClientTracker(pendingHttpRequestCount,
 469                 pendingHttp2StreamCount,
 470                 pendingWebSocketCount,
 471                 pendingOperationCount,
 472                 facadeRef,
 473                 dbgTag);
 474     }
 475 
 476     // Called by the SelectorManager thread to figure out whether it&#39;s time
 477     // to terminate.
 478     final boolean isReferenced() {
 479         HttpClient facade = facade();
 480         return facade != null || referenceCount() &gt; 0;
 481     }
 482 
 483     /**
 484      * Wait for activity on given exchange.
 485      * The following occurs in the SelectorManager thread.
 486      *
 487      *  1) add to selector
 488      *  2) If selector fires for this exchange then
 489      *     call AsyncEvent.handle()
 490      *
 491      * If exchange needs to change interest ops, then call registerEvent() again.
 492      */
 493     void registerEvent(AsyncEvent exchange) throws IOException {
 494         selmgr.register(exchange);
 495     }
 496 
 497     /**
 498      * Allows an AsyncEvent to modify its interestOps.
 499      * @param event The modified event.
 500      */
 501     void eventUpdated(AsyncEvent event) throws ClosedChannelException {
 502         assert !(event instanceof AsyncTriggerEvent);
 503         selmgr.eventUpdated(event);
 504     }
 505 
 506     boolean isSelectorThread() {
 507         return Thread.currentThread() == selmgr;
 508     }
 509 
 510     Http2ClientImpl client2() {
 511         return client2;
 512     }
 513 
 514     private void debugCompleted(String tag, long startNanos, HttpRequest req) {
 515         if (debugelapsed.on()) {
 516             debugelapsed.log(tag + &quot; elapsed &quot;
 517                     + (System.nanoTime() - startNanos)/1000_000L
 518                     + &quot; millis for &quot; + req.method()
 519                     + &quot; to &quot; + req.uri());
 520         }
 521     }
 522 
 523     @Override
 524     public &lt;T&gt; HttpResponse&lt;T&gt;
 525     send(HttpRequest req, BodyHandler&lt;T&gt; responseHandler)
 526         throws IOException, InterruptedException
 527     {
 528         CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; cf = null;
 529         try {
 530             cf = sendAsync(req, responseHandler, null, null);
 531             return cf.get();
 532         } catch (InterruptedException ie) {
 533             if (cf != null )
 534                 cf.cancel(true);
 535             throw ie;
 536         } catch (ExecutionException e) {
 537             final Throwable throwable = e.getCause();
 538             final String msg = throwable.getMessage();
 539 
 540             if (throwable instanceof IllegalArgumentException) {
 541                 throw new IllegalArgumentException(msg, throwable);
 542             } else if (throwable instanceof SecurityException) {
 543                 throw new SecurityException(msg, throwable);
 544             } else if (throwable instanceof HttpConnectTimeoutException) {
 545                 HttpConnectTimeoutException hcte = new HttpConnectTimeoutException(msg);
 546                 hcte.initCause(throwable);
 547                 throw hcte;
 548             } else if (throwable instanceof HttpTimeoutException) {
 549                 throw new HttpTimeoutException(msg);
 550             } else if (throwable instanceof ConnectException) {
 551                 ConnectException ce = new ConnectException(msg);
 552                 ce.initCause(throwable);
 553                 throw ce;
 554             } else if (throwable instanceof SSLHandshakeException) {
 555                 // special case for SSLHandshakeException
 556                 SSLHandshakeException he = new SSLHandshakeException(msg);
 557                 he.initCause(throwable);
 558                 throw he;
 559             } else if (throwable instanceof SSLException) {
 560                 // any other SSLException is wrapped in a plain
 561                 // SSLException
 562                 throw new SSLException(msg, throwable);
 563             } else if (throwable instanceof IOException) {
 564                 throw new IOException(msg, throwable);
 565             } else {
 566                 throw new IOException(msg, throwable);
 567             }
 568         }
 569     }
 570 
 571     private static final Executor ASYNC_POOL = new CompletableFuture&lt;Void&gt;().defaultExecutor();
 572 
 573     @Override
 574     public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;
 575     sendAsync(HttpRequest userRequest, BodyHandler&lt;T&gt; responseHandler)
 576     {
 577         return sendAsync(userRequest, responseHandler, null);
 578     }
 579 
 580     @Override
 581     public &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;
 582     sendAsync(HttpRequest userRequest,
 583               BodyHandler&lt;T&gt; responseHandler,
 584               PushPromiseHandler&lt;T&gt; pushPromiseHandler) {
 585         return sendAsync(userRequest, responseHandler, pushPromiseHandler, delegatingExecutor.delegate);
 586     }
 587 
 588     private &lt;T&gt; CompletableFuture&lt;HttpResponse&lt;T&gt;&gt;
 589     sendAsync(HttpRequest userRequest,
 590               BodyHandler&lt;T&gt; responseHandler,
 591               PushPromiseHandler&lt;T&gt; pushPromiseHandler,
 592               Executor exchangeExecutor)    {
 593 
 594         Objects.requireNonNull(userRequest);
 595         Objects.requireNonNull(responseHandler);
 596 
 597         AccessControlContext acc = null;
 598         if (System.getSecurityManager() != null)
 599             acc = AccessController.getContext();
 600 
 601         // Clone the, possibly untrusted, HttpRequest
 602         HttpRequestImpl requestImpl = new HttpRequestImpl(userRequest, proxySelector);
 603         if (requestImpl.method().equals(&quot;CONNECT&quot;))
 604             throw new IllegalArgumentException(&quot;Unsupported method CONNECT&quot;);
 605 
 606         long start = DEBUGELAPSED ? System.nanoTime() : 0;
 607         reference();
 608         try {
 609             if (debugelapsed.on())
 610                 debugelapsed.log(&quot;ClientImpl (async) send %s&quot;, userRequest);
 611 
 612             // When using sendAsync(...) we explicitly pass the
 613             // executor&#39;s delegate as exchange executor to force
 614             // asynchronous scheduling of the exchange.
 615             // When using send(...) we don&#39;t specify any executor
 616             // and default to using the client&#39;s delegating executor
 617             // which only spawns asynchronous tasks if it detects
 618             // that the current thread is the selector manager
 619             // thread. This will cause everything to execute inline
 620             // until we need to schedule some event with the selector.
 621             Executor executor = exchangeExecutor == null
 622                     ? this.delegatingExecutor : exchangeExecutor;
 623 
 624             MultiExchange&lt;T&gt; mex = new MultiExchange&lt;&gt;(userRequest,
 625                                                             requestImpl,
 626                                                             this,
 627                                                             responseHandler,
 628                                                             pushPromiseHandler,
 629                                                             acc);
 630             CompletableFuture&lt;HttpResponse&lt;T&gt;&gt; res =
 631                     mex.responseAsync(executor).whenComplete((b,t) -&gt; unreference());
 632             if (DEBUGELAPSED) {
 633                 res = res.whenComplete(
 634                         (b,t) -&gt; debugCompleted(&quot;ClientImpl (async)&quot;, start, userRequest));
 635             }
 636 
 637             // makes sure that any dependent actions happen in the CF default
 638             // executor. This is only needed for sendAsync(...), when
 639             // exchangeExecutor is non-null.
 640             if (exchangeExecutor != null) {
 641                 res = res.whenCompleteAsync((r, t) -&gt; { /* do nothing */}, ASYNC_POOL);
 642             }
 643             return res;
 644         } catch(Throwable t) {
 645             unreference();
 646             debugCompleted(&quot;ClientImpl (async)&quot;, start, userRequest);
 647             throw t;
 648         }
 649     }
 650 
 651     // Main loop for this client&#39;s selector
 652     private final static class SelectorManager extends Thread {
 653 
 654         // For testing purposes we have an internal System property that
 655         // can control the frequency at which the selector manager will wake
 656         // up when there are no pending operations.
 657         // Increasing the frequency (shorter delays) might allow the selector
 658         // to observe that the facade is no longer referenced and might allow
 659         // the selector thread to terminate more timely - for when nothing is
 660         // ongoing it will only check for that condition every NODEADLINE ms.
 661         // To avoid misuse of the property, the delay that can be specified
 662         // is comprised between [MIN_NODEADLINE, MAX_NODEADLINE], and its default
 663         // value if unspecified (or &lt;= 0) is DEF_NODEADLINE = 3000ms
 664         // The property is -Djdk.internal.httpclient.selectorTimeout=&lt;millis&gt;
 665         private static final int MIN_NODEADLINE = 1000; // ms
 666         private static final int MAX_NODEADLINE = 1000 * 1200; // ms
 667         private static final int DEF_NODEADLINE = 3000; // ms
 668         private static final long NODEADLINE; // default is DEF_NODEADLINE ms
 669         static {
 670             // ensure NODEADLINE is initialized with some valid value.
 671             long deadline =  Utils.getIntegerProperty(
 672                 &quot;jdk.internal.httpclient.selectorTimeout&quot;,
 673                 DEF_NODEADLINE); // millis
 674             if (deadline &lt;= 0) deadline = DEF_NODEADLINE;
 675             deadline = Math.max(deadline, MIN_NODEADLINE);
 676             NODEADLINE = Math.min(deadline, MAX_NODEADLINE);
 677         }
 678 
 679         private final Selector selector;
 680         private volatile boolean closed;
 681         private final List&lt;AsyncEvent&gt; registrations;
 682         private final List&lt;AsyncTriggerEvent&gt; deregistrations;
 683         private final Logger debug;
 684         private final Logger debugtimeout;
 685         HttpClientImpl owner;
 686         ConnectionPool pool;
 687 
 688         SelectorManager(HttpClientImpl ref) throws IOException {
 689             super(null, null,
 690                   &quot;HttpClient-&quot; + ref.id + &quot;-SelectorManager&quot;,
 691                   0, false);
 692             owner = ref;
 693             debug = ref.debug;
 694             debugtimeout = ref.debugtimeout;
 695             pool = ref.connectionPool();
 696             registrations = new ArrayList&lt;&gt;();
 697             deregistrations = new ArrayList&lt;&gt;();
 698             selector = Selector.open();
 699         }
 700 
 701         void eventUpdated(AsyncEvent e) throws ClosedChannelException {
 702             if (Thread.currentThread() == this) {
 703                 SelectionKey key = e.channel().keyFor(selector);
 704                 if (key != null &amp;&amp; key.isValid()) {
 705                     SelectorAttachment sa = (SelectorAttachment) key.attachment();
 706                     sa.register(e);
 707                 } else if (e.interestOps() != 0){
 708                     // We don&#39;t care about paused events.
 709                     // These are actually handled by
 710                     // SelectorAttachment::resetInterestOps later on.
 711                     // But if we reach here when trying to resume an
 712                     // event then it&#39;s better to fail fast.
 713                     if (debug.on()) debug.log(&quot;No key for channel&quot;);
 714                     e.abort(new IOException(&quot;No key for channel&quot;));
 715                 }
 716             } else {
 717                 register(e);
 718             }
 719         }
 720 
 721         // This returns immediately. So caller not allowed to send/receive
 722         // on connection.
 723         synchronized void register(AsyncEvent e) {
 724             registrations.add(e);
 725             selector.wakeup();
 726         }
 727 
 728         synchronized void cancel(SocketChannel e) {
 729             SelectionKey key = e.keyFor(selector);
 730             if (key != null) {
 731                 key.cancel();
 732             }
 733             selector.wakeup();
 734         }
 735 
 736         void wakeupSelector() {
 737             selector.wakeup();
 738         }
 739 
 740         synchronized void shutdown() {
 741             Log.logTrace(&quot;{0}: shutting down&quot;, getName());
 742             if (debug.on()) debug.log(&quot;SelectorManager shutting down&quot;);
 743             closed = true;
 744             try {
 745                 selector.close();
 746             } catch (IOException ignored) {
 747             } finally {
 748                 owner.stop();
 749             }
 750         }
 751 
 752         @Override
 753         public void run() {
 754             List&lt;Pair&lt;AsyncEvent,IOException&gt;&gt; errorList = new ArrayList&lt;&gt;();
 755             List&lt;AsyncEvent&gt; readyList = new ArrayList&lt;&gt;();
 756             List&lt;Runnable&gt; resetList = new ArrayList&lt;&gt;();
 757             try {
 758                 if (Log.channel()) Log.logChannel(getName() + &quot;: starting&quot;);
 759                 while (!Thread.currentThread().isInterrupted()) {
 760                     synchronized (this) {
 761                         assert errorList.isEmpty();
 762                         assert readyList.isEmpty();
 763                         assert resetList.isEmpty();
 764                         for (AsyncTriggerEvent event : deregistrations) {
 765                             event.handle();
 766                         }
 767                         deregistrations.clear();
 768                         for (AsyncEvent event : registrations) {
 769                             if (event instanceof AsyncTriggerEvent) {
 770                                 readyList.add(event);
 771                                 continue;
 772                             }
 773                             SelectableChannel chan = event.channel();
 774                             SelectionKey key = null;
 775                             try {
 776                                 key = chan.keyFor(selector);
 777                                 SelectorAttachment sa;
 778                                 if (key == null || !key.isValid()) {
 779                                     if (key != null) {
 780                                         // key is canceled.
 781                                         // invoke selectNow() to purge it
 782                                         // before registering the new event.
 783                                         selector.selectNow();
 784                                     }
 785                                     sa = new SelectorAttachment(chan, selector);
 786                                 } else {
 787                                     sa = (SelectorAttachment) key.attachment();
 788                                 }
 789                                 // may throw IOE if channel closed: that&#39;s OK
 790                                 sa.register(event);
 791                                 if (!chan.isOpen()) {
 792                                     throw new IOException(&quot;Channel closed&quot;);
 793                                 }
 794                             } catch (IOException e) {
 795                                 Log.logTrace(&quot;{0}: {1}&quot;, getName(), e);
 796                                 if (debug.on())
 797                                     debug.log(&quot;Got &quot; + e.getClass().getName()
 798                                               + &quot; while handling registration events&quot;);
 799                                 chan.close();
 800                                 // let the event abort deal with it
 801                                 errorList.add(new Pair&lt;&gt;(event, e));
 802                                 if (key != null) {
 803                                     key.cancel();
 804                                     selector.selectNow();
 805                                 }
 806                             }
 807                         }
 808                         registrations.clear();
 809                         selector.selectedKeys().clear();
 810                     }
 811 
 812                     for (AsyncEvent event : readyList) {
 813                         assert event instanceof AsyncTriggerEvent;
 814                         event.handle();
 815                     }
 816                     readyList.clear();
 817 
 818                     for (Pair&lt;AsyncEvent,IOException&gt; error : errorList) {
 819                         // an IOException was raised and the channel closed.
 820                         handleEvent(error.first, error.second);
 821                     }
 822                     errorList.clear();
 823 
 824                     // Check whether client is still alive, and if not,
 825                     // gracefully stop this thread
 826                     if (!owner.isReferenced()) {
 827                         Log.logTrace(&quot;{0}: {1}&quot;,
 828                                 getName(),
 829                                 &quot;HttpClient no longer referenced. Exiting...&quot;);
 830                         return;
 831                     }
 832 
 833                     // Timeouts will have milliseconds granularity. It is important
 834                     // to handle them in a timely fashion.
 835                     long nextTimeout = owner.purgeTimeoutsAndReturnNextDeadline();
 836                     if (debugtimeout.on())
 837                         debugtimeout.log(&quot;next timeout: %d&quot;, nextTimeout);
 838 
 839                     // Keep-alive have seconds granularity. It&#39;s not really an
 840                     // issue if we keep connections linger a bit more in the keep
 841                     // alive cache.
 842                     long nextExpiry = pool.purgeExpiredConnectionsAndReturnNextDeadline();
 843                     if (debugtimeout.on())
 844                         debugtimeout.log(&quot;next expired: %d&quot;, nextExpiry);
 845 
 846                     assert nextTimeout &gt;= 0;
 847                     assert nextExpiry &gt;= 0;
 848 
 849                     // Don&#39;t wait for ever as it might prevent the thread to
 850                     // stop gracefully. millis will be 0 if no deadline was found.
 851                     if (nextTimeout &lt;= 0) nextTimeout = NODEADLINE;
 852 
 853                     // Clip nextExpiry at NODEADLINE limit. The default
 854                     // keep alive is 1200 seconds (half an hour) - we don&#39;t
 855                     // want to wait that long.
 856                     if (nextExpiry &lt;= 0) nextExpiry = NODEADLINE;
 857                     else nextExpiry = Math.min(NODEADLINE, nextExpiry);
 858 
 859                     // takes the least of the two.
 860                     long millis = Math.min(nextExpiry, nextTimeout);
 861 
 862                     if (debugtimeout.on())
 863                         debugtimeout.log(&quot;Next deadline is %d&quot;,
 864                                          (millis == 0 ? NODEADLINE : millis));
 865                     //debugPrint(selector);
 866                     int n = selector.select(millis == 0 ? NODEADLINE : millis);
 867                     if (n == 0) {
 868                         // Check whether client is still alive, and if not,
 869                         // gracefully stop this thread
 870                         if (!owner.isReferenced()) {
 871                             Log.logTrace(&quot;{0}: {1}&quot;,
 872                                     getName(),
 873                                     &quot;HttpClient no longer referenced. Exiting...&quot;);
 874                             return;
 875                         }
 876                         owner.purgeTimeoutsAndReturnNextDeadline();
 877                         continue;
 878                     }
 879 
 880                     Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
 881                     assert errorList.isEmpty();
 882 
 883                     for (SelectionKey key : keys) {
 884                         SelectorAttachment sa = (SelectorAttachment) key.attachment();
 885                         if (!key.isValid()) {
 886                             IOException ex = sa.chan.isOpen()
 887                                     ? new IOException(&quot;Invalid key&quot;)
 888                                     : new ClosedChannelException();
 889                             sa.pending.forEach(e -&gt; errorList.add(new Pair&lt;&gt;(e,ex)));
 890                             sa.pending.clear();
 891                             continue;
 892                         }
 893 
 894                         int eventsOccurred;
 895                         try {
 896                             eventsOccurred = key.readyOps();
 897                         } catch (CancelledKeyException ex) {
 898                             IOException io = Utils.getIOException(ex);
 899                             sa.pending.forEach(e -&gt; errorList.add(new Pair&lt;&gt;(e,io)));
 900                             sa.pending.clear();
 901                             continue;
 902                         }
 903                         sa.events(eventsOccurred).forEach(readyList::add);
 904                         resetList.add(() -&gt; sa.resetInterestOps(eventsOccurred));
 905                     }
 906 
 907                     selector.selectNow(); // complete cancellation
 908                     selector.selectedKeys().clear();
 909 
 910                     // handle selected events
 911                     readyList.forEach((e) -&gt; handleEvent(e, null));
 912                     readyList.clear();
 913 
 914                     // handle errors (closed channels etc...)
 915                     errorList.forEach((p) -&gt; handleEvent(p.first, p.second));
 916                     errorList.clear();
 917 
 918                     // reset interest ops for selected channels
 919                     resetList.forEach(r -&gt; r.run());
 920                     resetList.clear();
 921 
 922                 }
 923             } catch (Throwable e) {
 924                 if (!closed) {
 925                     // This terminates thread. So, better just print stack trace
 926                     String err = Utils.stackTrace(e);
 927                     Log.logError(&quot;{0}: {1}: {2}&quot;, getName(),
 928                             &quot;HttpClientImpl shutting down due to fatal error&quot;, err);
 929                 }
 930                 if (debug.on()) debug.log(&quot;shutting down&quot;, e);
 931                 if (Utils.ASSERTIONSENABLED &amp;&amp; !debug.on()) {
 932                     e.printStackTrace(System.err); // always print the stack
 933                 }
 934             } finally {
 935                 if (Log.channel()) Log.logChannel(getName() + &quot;: stopping&quot;);
 936                 shutdown();
 937             }
 938         }
 939 
 940 //        void debugPrint(Selector selector) {
 941 //            System.err.println(&quot;Selector: debugprint start&quot;);
 942 //            Set&lt;SelectionKey&gt; keys = selector.keys();
 943 //            for (SelectionKey key : keys) {
 944 //                SelectableChannel c = key.channel();
 945 //                int ops = key.interestOps();
 946 //                System.err.printf(&quot;selector chan:%s ops:%d\n&quot;, c, ops);
 947 //            }
 948 //            System.err.println(&quot;Selector: debugprint end&quot;);
 949 //        }
 950 
 951         /** Handles the given event. The given ioe may be null. */
 952         void handleEvent(AsyncEvent event, IOException ioe) {
 953             if (closed || ioe != null) {
 954                 event.abort(ioe);
 955             } else {
 956                 event.handle();
 957             }
 958         }
 959     }
 960 
 961     final String debugInterestOps(SelectableChannel channel) {
 962         try {
 963             SelectionKey key = channel.keyFor(selmgr.selector);
 964             if (key == null) return &quot;channel not registered with selector&quot;;
 965             String keyInterestOps = key.isValid()
 966                     ? &quot;key.interestOps=&quot; + key.interestOps() : &quot;invalid key&quot;;
 967             return String.format(&quot;channel registered with selector, %s, sa.interestOps=%s&quot;,
 968                                  keyInterestOps,
 969                                  ((SelectorAttachment)key.attachment()).interestOps);
 970         } catch (Throwable t) {
 971             return String.valueOf(t);
 972         }
 973     }
 974 
 975     /**
 976      * Tracks multiple user level registrations associated with one NIO
 977      * registration (SelectionKey). In this implementation, registrations
 978      * are one-off and when an event is posted the registration is cancelled
 979      * until explicitly registered again.
 980      *
 981      * &lt;p&gt; No external synchronization required as this class is only used
 982      * by the SelectorManager thread. One of these objects required per
 983      * connection.
 984      */
 985     private static class SelectorAttachment {
 986         private final SelectableChannel chan;
 987         private final Selector selector;
 988         private final Set&lt;AsyncEvent&gt; pending;
 989         private final static Logger debug =
 990                 Utils.getDebugLogger(&quot;SelectorAttachment&quot;::toString, Utils.DEBUG);
 991         private int interestOps;
 992 
 993         SelectorAttachment(SelectableChannel chan, Selector selector) {
 994             this.pending = new HashSet&lt;&gt;();
 995             this.chan = chan;
 996             this.selector = selector;
 997         }
 998 
 999         void register(AsyncEvent e) throws ClosedChannelException {
1000             int newOps = e.interestOps();
1001             // re register interest if we are not already interested
1002             // in the event. If the event is paused, then the pause will
1003             // be taken into account later when resetInterestOps is called.
1004             boolean reRegister = (interestOps &amp; newOps) != newOps;
1005             interestOps |= newOps;
1006             pending.add(e);
1007             if (debug.on())
1008                 debug.log(&quot;Registering %s for %d (%s)&quot;, e, newOps, reRegister);
1009             if (reRegister) {
1010                 // first time registration happens here also
1011                 try {
1012                     chan.register(selector, interestOps, this);
1013                 } catch (Throwable x) {
1014                     abortPending(x);
1015                 }
1016             } else if (!chan.isOpen()) {
1017                 abortPending(new ClosedChannelException());
1018             }
1019         }
1020 
1021         /**
1022          * Returns a Stream&lt;AsyncEvents&gt; containing only events that are
1023          * registered with the given {@code interestOps}.
1024          */
1025         Stream&lt;AsyncEvent&gt; events(int interestOps) {
1026             return pending.stream()
1027                     .filter(ev -&gt; (ev.interestOps() &amp; interestOps) != 0);
1028         }
1029 
1030         /**
1031          * Removes any events with the given {@code interestOps}, and if no
1032          * events remaining, cancels the associated SelectionKey.
1033          */
1034         void resetInterestOps(int interestOps) {
1035             int newOps = 0;
1036 
1037             Iterator&lt;AsyncEvent&gt; itr = pending.iterator();
1038             while (itr.hasNext()) {
1039                 AsyncEvent event = itr.next();
1040                 int evops = event.interestOps();
1041                 if (event.repeating()) {
1042                     newOps |= evops;
1043                     continue;
1044                 }
1045                 if ((evops &amp; interestOps) != 0) {
1046                     itr.remove();
1047                 } else {
1048                     newOps |= evops;
1049                 }
1050             }
1051 
1052             this.interestOps = newOps;
1053             SelectionKey key = chan.keyFor(selector);
1054             if (newOps == 0 &amp;&amp; key != null &amp;&amp; pending.isEmpty()) {
1055                 key.cancel();
1056             } else {
1057                 try {
1058                     if (key == null || !key.isValid()) {
1059                         throw new CancelledKeyException();
1060                     }
1061                     key.interestOps(newOps);
1062                     // double check after
1063                     if (!chan.isOpen()) {
1064                         abortPending(new ClosedChannelException());
1065                         return;
1066                     }
1067                     assert key.interestOps() == newOps;
1068                 } catch (CancelledKeyException x) {
1069                     // channel may have been closed
1070                     if (debug.on()) debug.log(&quot;key cancelled for &quot; + chan);
1071                     abortPending(x);
1072                 }
1073             }
1074         }
1075 
1076         void abortPending(Throwable x) {
1077             if (!pending.isEmpty()) {
1078                 AsyncEvent[] evts = pending.toArray(new AsyncEvent[0]);
1079                 pending.clear();
1080                 IOException io = Utils.getIOException(x);
1081                 for (AsyncEvent event : evts) {
1082                     event.abort(io);
1083                 }
1084             }
1085         }
1086     }
1087 
1088     /*package-private*/ SSLContext theSSLContext() {
1089         return sslContext;
1090     }
1091 
1092     @Override
1093     public SSLContext sslContext() {
1094         return sslContext;
1095     }
1096 
1097     @Override
1098     public SSLParameters sslParameters() {
1099         return Utils.copySSLParameters(sslParams);
1100     }
1101 
1102     @Override
1103     public Optional&lt;Authenticator&gt; authenticator() {
1104         return Optional.ofNullable(authenticator);
1105     }
1106 
1107     /*package-private*/ final DelegatingExecutor theExecutor() {
1108         return delegatingExecutor;
1109     }
1110 
1111     @Override
1112     public final Optional&lt;Executor&gt; executor() {
1113         return isDefaultExecutor
1114                 ? Optional.empty()
1115                 : Optional.of(delegatingExecutor.delegate());
1116     }
1117 
1118     ConnectionPool connectionPool() {
1119         return connections;
1120     }
1121 
1122     @Override
1123     public Redirect followRedirects() {
1124         return followRedirects;
1125     }
1126 
1127 
1128     @Override
1129     public Optional&lt;CookieHandler&gt; cookieHandler() {
1130         return Optional.ofNullable(cookieHandler);
1131     }
1132 
1133     @Override
1134     public Optional&lt;Duration&gt; connectTimeout() {
1135         return Optional.ofNullable(connectTimeout);
1136     }
1137 
1138     @Override
1139     public Optional&lt;ProxySelector&gt; proxy() {
1140         return Optional.ofNullable(userProxySelector);
1141     }
1142 
1143     // Return the effective proxy that this client uses.
1144     ProxySelector proxySelector() {
1145         return proxySelector;
1146     }
1147 
1148     @Override
1149     public WebSocket.Builder newWebSocketBuilder() {
1150         // Make sure to pass the HttpClientFacade to the WebSocket builder.
1151         // This will ensure that the facade is not released before the
1152         // WebSocket has been created, at which point the pendingOperationCount
1153         // will have been incremented by the RawChannelTube.
1154         // See RawChannelTube.
1155         return new BuilderImpl(this.facade(), proxySelector);
1156     }
1157 
1158     @Override
1159     public Version version() {
1160         return version;
1161     }
1162 
1163     String dbgString() {
1164         return dbgTag;
1165     }
1166 
1167     @Override
1168     public String toString() {
1169         // Used by tests to get the client&#39;s id and compute the
1170         // name of the SelectorManager thread.
1171         return super.toString() + (&quot;(&quot; + id + &quot;)&quot;);
1172     }
1173 
1174     private void initFilters() {
1175         addFilter(AuthenticationFilter.class);
1176         addFilter(RedirectFilter.class);
1177         if (this.cookieHandler != null) {
1178             addFilter(CookieFilter.class);
1179         }
1180     }
1181 
1182     private void addFilter(Class&lt;? extends HeaderFilter&gt; f) {
1183         filters.addFilter(f);
1184     }
1185 
1186     final LinkedList&lt;HeaderFilter&gt; filterChain() {
1187         return filters.getFilterChain();
1188     }
1189 
1190     // Timer controls.
1191     // Timers are implemented through timed Selector.select() calls.
1192 
1193     synchronized void registerTimer(TimeoutEvent event) {
1194         Log.logTrace(&quot;Registering timer {0}&quot;, event);
1195         timeouts.add(event);
1196         selmgr.wakeupSelector();
1197     }
1198 
1199     synchronized void cancelTimer(TimeoutEvent event) {
1200         Log.logTrace(&quot;Canceling timer {0}&quot;, event);
1201         timeouts.remove(event);
1202     }
1203 
1204     /**
1205      * Purges ( handles ) timer events that have passed their deadline, and
1206      * returns the amount of time, in milliseconds, until the next earliest
1207      * event. A return value of 0 means that there are no events.
1208      */
1209     private long purgeTimeoutsAndReturnNextDeadline() {
1210         long diff = 0L;
1211         List&lt;TimeoutEvent&gt; toHandle = null;
1212         int remaining = 0;
1213         // enter critical section to retrieve the timeout event to handle
1214         synchronized(this) {
1215             if (timeouts.isEmpty()) return 0L;
1216 
1217             Instant now = Instant.now();
1218             Iterator&lt;TimeoutEvent&gt; itr = timeouts.iterator();
1219             while (itr.hasNext()) {
1220                 TimeoutEvent event = itr.next();
1221                 diff = now.until(event.deadline(), ChronoUnit.MILLIS);
1222                 if (diff &lt;= 0) {
1223                     itr.remove();
1224                     toHandle = (toHandle == null) ? new ArrayList&lt;&gt;() : toHandle;
1225                     toHandle.add(event);
1226                 } else {
1227                     break;
1228                 }
1229             }
1230             remaining = timeouts.size();
1231         }
1232 
1233         // can be useful for debugging
1234         if (toHandle != null &amp;&amp; Log.trace()) {
1235             Log.logTrace(&quot;purgeTimeoutsAndReturnNextDeadline: handling &quot;
1236                     +  toHandle.size() + &quot; events, &quot;
1237                     + &quot;remaining &quot; + remaining
1238                     + &quot;, next deadline: &quot; + (diff &lt; 0 ? 0L : diff));
1239         }
1240 
1241         // handle timeout events out of critical section
1242         if (toHandle != null) {
1243             Throwable failed = null;
1244             for (TimeoutEvent event : toHandle) {
1245                 try {
1246                    Log.logTrace(&quot;Firing timer {0}&quot;, event);
1247                    event.handle();
1248                 } catch (Error | RuntimeException e) {
1249                     // Not expected. Handle remaining events then throw...
1250                     // If e is an OOME or SOE it might simply trigger a new
1251                     // error from here - but in this case there&#39;s not much we
1252                     // could do anyway. Just let it flow...
1253                     if (failed == null) failed = e;
1254                     else failed.addSuppressed(e);
1255                     Log.logTrace(&quot;Failed to handle event {0}: {1}&quot;, event, e);
1256                 }
1257             }
1258             if (failed instanceof Error) throw (Error) failed;
1259             if (failed instanceof RuntimeException) throw (RuntimeException) failed;
1260         }
1261 
1262         // return time to wait until next event. 0L if there&#39;s no more events.
1263         return diff &lt; 0 ? 0L : diff;
1264     }
1265 
1266     // used for the connection window
1267     int getReceiveBufferSize() {
1268         return Utils.getIntegerNetProperty(
1269                 &quot;jdk.httpclient.receiveBufferSize&quot;,
1270                 0 // only set the size if &gt; 0
1271         );
1272     }
1273 
1274     // Optimization for reading SSL encrypted data
1275     // --------------------------------------------
1276 
1277     // Returns a BufferSupplier that can be used for reading
1278     // encrypted bytes of the channel. These buffers can then
1279     // be recycled by the SSLFlowDelegate::Reader after their
1280     // content has been copied in the SSLFlowDelegate::Reader
1281     // readBuf.
1282     // Because allocating, reading, copying, and recycling
1283     // all happen in the SelectorManager thread,
1284     // then this BufferSupplier can be shared between all
1285     // the SSL connections managed by this client.
1286     BufferSupplier getSSLBufferSupplier() {
1287         return sslBufferSupplier;
1288     }
1289 
1290     // An implementation of BufferSupplier that manages a pool of
1291     // maximum 3 direct byte buffers (SocketTube.MAX_BUFFERS) that
1292     // are used for reading encrypted bytes off the channel before
1293     // copying and subsequent unwrapping.
1294     private static final class SSLDirectBufferSupplier implements BufferSupplier {
1295         private static final int POOL_SIZE = SocketTube.MAX_BUFFERS;
1296         private final ByteBuffer[] pool = new ByteBuffer[POOL_SIZE];
1297         private final HttpClientImpl client;
1298         private final Logger debug;
1299         private int tail, count; // no need for volatile: only accessed in SM thread.
1300 
1301         SSLDirectBufferSupplier(HttpClientImpl client) {
1302             this.client = Objects.requireNonNull(client);
1303             this.debug = client.debug;
1304         }
1305 
1306         // Gets a buffer from the pool, or allocates a new one if needed.
1307         @Override
1308         public ByteBuffer get() {
1309             assert client.isSelectorThread();
1310             assert tail &lt;= POOL_SIZE : &quot;allocate tail is &quot; + tail;
1311             ByteBuffer buf;
1312             if (tail == 0) {
1313                 if (debug.on()) {
1314                     // should not appear more than SocketTube.MAX_BUFFERS
1315                     debug.log(&quot;ByteBuffer.allocateDirect(%d)&quot;, Utils.BUFSIZE);
1316                 }
1317                 assert count++ &lt; POOL_SIZE : &quot;trying to allocate more than &quot;
1318                             + POOL_SIZE + &quot; buffers&quot;;
1319                 buf = ByteBuffer.allocateDirect(Utils.BUFSIZE);
1320             } else {
1321                 assert tail &gt; 0 : &quot;non positive tail value: &quot; + tail;
1322                 tail--;
1323                 buf = pool[tail];
1324                 pool[tail] = null;
1325             }
1326             assert buf.isDirect();
1327             assert buf.position() == 0;
1328             assert buf.hasRemaining();
1329             assert buf.limit() == Utils.BUFSIZE;
1330             assert tail &lt; POOL_SIZE;
1331             assert tail &gt;= 0;
1332             return buf;
1333         }
1334 
1335         // Returns the given buffer to the pool.
1336         @Override
1337         public void recycle(ByteBuffer buffer) {
1338             assert client.isSelectorThread();
1339             assert buffer.isDirect();
1340             assert !buffer.hasRemaining();
1341             assert tail &lt; POOL_SIZE : &quot;recycle tail is &quot; + tail;
1342             assert tail &gt;= 0;
1343             buffer.position(0);
1344             buffer.limit(buffer.capacity());
1345             // don&#39;t fail if assertions are off. we have asserted above.
1346             if (tail &lt; POOL_SIZE) {
1347                 pool[tail] = buffer;
1348                 tail++;
1349             }
1350             assert tail &lt;= POOL_SIZE;
1351             assert tail &gt; 0;
1352         }
1353     }
1354 
1355 }
<a name="3" id="anc3"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="3" type="hidden" />
</body>
</html>
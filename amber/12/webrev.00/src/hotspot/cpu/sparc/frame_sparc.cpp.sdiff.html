<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/frame_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="c1_LIRAssembler_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalDefinitions_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/frame_sparc.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
533     // Update the locations of implicitly saved registers to be their
534     // addresses in the register save area.
535     // For %o registers, the addresses of %i registers in the next younger
536     // frame are used.
537     map-&gt;shift_window(sp, younger_sp);
538     if (map-&gt;update_map()) {
539       // Tell GC to use argument oopmaps for some runtime stubs that need it.
540       // For C1, the runtime stub might not have oop maps, so set this flag
541       // outside of update_register_map.
542       map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));
543       if (_cb-&gt;oop_maps() != NULL) {
544         OopMapSet::update_register_map(this, map);
545       }
546     }
547   }
548   return frame(sp, younger_sp, frame_is_interpreted);
549 }
550 
551 
552 void frame::patch_pc(Thread* thread, address pc) {

553   vmassert(_deopt_state != unknown, &quot;frame is unpatchable&quot;);
<span class="line-modified">554   if(thread == Thread::current()) {</span>
<span class="line-modified">555    StubRoutines::Sparc::flush_callers_register_windows_func()();</span>
556   }
557   if (TracePcPatching) {
558     // QQQ this assert is invalid (or too strong anyway) sice _pc could
559     // be original pc and frame could have the deopt pc.
560     // assert(_pc == *O7_addr() + pc_return_offset, &quot;frame has wrong pc&quot;);
561     tty-&gt;print_cr(&quot;patch_pc at address &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot; -&gt; &quot; INTPTR_FORMAT &quot;]&quot;,
562                   p2i(O7_addr()), p2i(_pc), p2i(pc));
563   }
<span class="line-removed">564   _cb = CodeCache::find_blob(pc);</span>
565   *O7_addr() = pc - pc_return_offset;
<span class="line-removed">566   _cb = CodeCache::find_blob(_pc);</span>
567   address original_pc = CompiledMethod::get_deopt_original_pc(this);
568   if (original_pc != NULL) {
569     assert(original_pc == _pc, &quot;expected original to be stored before patching&quot;);
570     _deopt_state = is_deoptimized;
571   } else {
572     _deopt_state = not_deoptimized;
573   }
574 }
575 
576 
577 static bool sp_is_valid(intptr_t* old_sp, intptr_t* young_sp, intptr_t* sp) {
578   return (((intptr_t)sp &amp; (2*wordSize-1)) == 0 &amp;&amp;
579           sp &lt;= old_sp &amp;&amp;
580           sp &gt;= young_sp);
581 }
582 
583 
584 /*
585   Find the (biased) sp that is just younger than old_sp starting at sp.
586   If not found return NULL. Register windows are assumed to be flushed.
</pre>
</td>
<td>
<hr />
<pre>
533     // Update the locations of implicitly saved registers to be their
534     // addresses in the register save area.
535     // For %o registers, the addresses of %i registers in the next younger
536     // frame are used.
537     map-&gt;shift_window(sp, younger_sp);
538     if (map-&gt;update_map()) {
539       // Tell GC to use argument oopmaps for some runtime stubs that need it.
540       // For C1, the runtime stub might not have oop maps, so set this flag
541       // outside of update_register_map.
542       map-&gt;set_include_argument_oops(_cb-&gt;caller_must_gc_arguments(map-&gt;thread()));
543       if (_cb-&gt;oop_maps() != NULL) {
544         OopMapSet::update_register_map(this, map);
545       }
546     }
547   }
548   return frame(sp, younger_sp, frame_is_interpreted);
549 }
550 
551 
552 void frame::patch_pc(Thread* thread, address pc) {
<span class="line-added">553   assert(_cb == CodeCache::find_blob(pc), &quot;unexpected pc&quot;);</span>
554   vmassert(_deopt_state != unknown, &quot;frame is unpatchable&quot;);
<span class="line-modified">555   if (thread == Thread::current()) {</span>
<span class="line-modified">556     StubRoutines::Sparc::flush_callers_register_windows_func()();</span>
557   }
558   if (TracePcPatching) {
559     // QQQ this assert is invalid (or too strong anyway) sice _pc could
560     // be original pc and frame could have the deopt pc.
561     // assert(_pc == *O7_addr() + pc_return_offset, &quot;frame has wrong pc&quot;);
562     tty-&gt;print_cr(&quot;patch_pc at address &quot; INTPTR_FORMAT &quot; [&quot; INTPTR_FORMAT &quot; -&gt; &quot; INTPTR_FORMAT &quot;]&quot;,
563                   p2i(O7_addr()), p2i(_pc), p2i(pc));
564   }

565   *O7_addr() = pc - pc_return_offset;

566   address original_pc = CompiledMethod::get_deopt_original_pc(this);
567   if (original_pc != NULL) {
568     assert(original_pc == _pc, &quot;expected original to be stored before patching&quot;);
569     _deopt_state = is_deoptimized;
570   } else {
571     _deopt_state = not_deoptimized;
572   }
573 }
574 
575 
576 static bool sp_is_valid(intptr_t* old_sp, intptr_t* young_sp, intptr_t* sp) {
577   return (((intptr_t)sp &amp; (2*wordSize-1)) == 0 &amp;&amp;
578           sp &lt;= old_sp &amp;&amp;
579           sp &gt;= young_sp);
580 }
581 
582 
583 /*
584   Find the (biased) sp that is just younger than old_sp starting at sp.
585   If not found return NULL. Register windows are assumed to be flushed.
</pre>
</td>
</tr>
</table>
<center><a href="c1_LIRAssembler_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="globalDefinitions_sparc.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
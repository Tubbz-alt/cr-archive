<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Old src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  30 #include &quot;c1/c1_Runtime1.hpp&quot;
  31 #include &quot;c1/c1_ValueStack.hpp&quot;
  32 #include &quot;ci/ciArrayKlass.hpp&quot;
  33 #include &quot;ci/ciInstance.hpp&quot;
  34 #include &quot;gc/shared/collectedHeap.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;nativeInst_sparc.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  40 #include &quot;runtime/jniHandles.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 
  48 //------------------------------------------------------------
  49 
  50 
  51 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  52   if (opr-&gt;is_constant()) {
  53     LIR_Const* constant = opr-&gt;as_constant_ptr();
  54     switch (constant-&gt;type()) {
  55       case T_INT: {
  56         jint value = constant-&gt;as_jint();
  57         return Assembler::is_simm13(value);
  58       }
  59 
  60       default:
  61         return false;
  62     }
  63   }
  64   return false;
  65 }
  66 
  67 
  68 bool LIR_Assembler::is_single_instruction(LIR_Op* op) {
  69   switch (op-&gt;code()) {
  70     case lir_null_check:
  71     return true;
  72 
  73 
  74     case lir_add:
  75     case lir_ushr:
  76     case lir_shr:
  77     case lir_shl:
  78       // integer shifts and adds are always one instruction
  79       return op-&gt;result_opr()-&gt;is_single_cpu();
  80 
  81 
  82     case lir_move: {
  83       LIR_Op1* op1 = op-&gt;as_Op1();
  84       LIR_Opr src = op1-&gt;in_opr();
  85       LIR_Opr dst = op1-&gt;result_opr();
  86 
  87       if (src == dst) {
  88         NEEDS_CLEANUP;
  89         // this works around a problem where moves with the same src and dst
  90         // end up in the delay slot and then the assembler swallows the mov
  91         // since it has no effect and then it complains because the delay slot
  92         // is empty.  returning false stops the optimizer from putting this in
  93         // the delay slot
  94         return false;
  95       }
  96 
  97       // don&#39;t put moves involving oops into the delay slot since the VerifyOops code
  98       // will make it much larger than a single instruction.
  99       if (VerifyOops) {
 100         return false;
 101       }
 102 
 103       if (src-&gt;is_double_cpu() || dst-&gt;is_double_cpu() || op1-&gt;patch_code() != lir_patch_none ||
 104           ((src-&gt;is_double_fpu() || dst-&gt;is_double_fpu()) &amp;&amp; op1-&gt;move_kind() != lir_move_normal)) {
 105         return false;
 106       }
 107 
 108       if (UseCompressedOops) {
 109         if (dst-&gt;is_address() &amp;&amp; !dst-&gt;is_stack() &amp;&amp; is_reference_type(dst-&gt;type())) return false;
 110         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; is_reference_type(src-&gt;type())) return false;
 111       }
 112 
 113       if (UseCompressedClassPointers) {
 114         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; src-&gt;type() == T_ADDRESS &amp;&amp;
 115             src-&gt;as_address_ptr()-&gt;disp() == oopDesc::klass_offset_in_bytes()) return false;
 116       }
 117 
 118       if (dst-&gt;is_register()) {
 119         if (src-&gt;is_address() &amp;&amp; Assembler::is_simm13(src-&gt;as_address_ptr()-&gt;disp())) {
 120           return !PatchALot;
 121         } else if (src-&gt;is_single_stack()) {
 122           return true;
 123         }
 124       }
 125 
 126       if (src-&gt;is_register()) {
 127         if (dst-&gt;is_address() &amp;&amp; Assembler::is_simm13(dst-&gt;as_address_ptr()-&gt;disp())) {
 128           return !PatchALot;
 129         } else if (dst-&gt;is_single_stack()) {
 130           return true;
 131         }
 132       }
 133 
 134       if (dst-&gt;is_register() &amp;&amp;
 135           ((src-&gt;is_register() &amp;&amp; src-&gt;is_single_word() &amp;&amp; src-&gt;is_same_type(dst)) ||
 136            (src-&gt;is_constant() &amp;&amp; LIR_Assembler::is_small_constant(op-&gt;as_Op1()-&gt;in_opr())))) {
 137         return true;
 138       }
 139 
 140       return false;
 141     }
 142 
 143     default:
 144       return false;
 145   }
 146   ShouldNotReachHere();
 147 }
 148 
 149 
 150 LIR_Opr LIR_Assembler::receiverOpr() {
 151   return FrameMap::O0_oop_opr;
 152 }
 153 
 154 
 155 LIR_Opr LIR_Assembler::osrBufferPointer() {
 156   return FrameMap::I0_opr;
 157 }
 158 
 159 
 160 int LIR_Assembler::initial_frame_size_in_bytes() const {
 161   return in_bytes(frame_map()-&gt;framesize_in_bytes());
 162 }
 163 
 164 
 165 // inline cache check: the inline cached class is in G5_inline_cache_reg(G5);
 166 // we fetch the class of the receiver (O0) and compare it with the cached class.
 167 // If they do not match we jump to slow case.
 168 int LIR_Assembler::check_icache() {
 169   int offset = __ offset();
 170   __ inline_cache_check(O0, G5_inline_cache_reg);
 171   return offset;
 172 }
 173 
 174 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 175   ShouldNotReachHere(); // not implemented
 176 }
 177 
 178 void LIR_Assembler::osr_entry() {
 179   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
 180   //
 181   //   1. Create a new compiled activation.
 182   //   2. Initialize local variables in the compiled activation.  The expression stack must be empty
 183   //      at the osr_bci; it is not initialized.
 184   //   3. Jump to the continuation address in compiled code to resume execution.
 185 
 186   // OSR entry point
 187   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 188   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 189   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 190   int number_of_locks = entry_state-&gt;locks_size();
 191 
 192   // Create a frame for the compiled activation.
 193   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 194 
 195   // OSR buffer is
 196   //
 197   // locals[nlocals-1..0]
 198   // monitors[number_of_locks-1..0]
 199   //
 200   // locals is a direct copy of the interpreter frame so in the osr buffer
 201   // so first slot in the local array is the last local from the interpreter
 202   // and last slot is local[0] (receiver) from the interpreter
 203   //
 204   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 205   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 206   // in the interpreter frame (the method lock if a sync method)
 207 
 208   // Initialize monitors in the compiled activation.
 209   //   I0: pointer to osr buffer
 210   //
 211   // All other registers are dead at this point and the locals will be
 212   // copied into place by code emitted in the IR.
 213 
 214   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 215   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 216     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 217       (2 * BytesPerWord) * (number_of_locks - 1);
 218     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 219     // the OSR buffer using 2 word entries: first the lock and then
 220     // the oop.
 221     for (int i = 0; i &lt; number_of_locks; i++) {
 222       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 223 #ifdef ASSERT
 224       // verify the interpreter&#39;s monitor has a non-null object
 225       {
 226         Label L;
 227         __ ld_ptr(OSR_buf, slot_offset + 1*BytesPerWord, O7);
 228         __ cmp_and_br_short(O7, G0, Assembler::notEqual, Assembler::pt, L);
 229         __ stop(&quot;locked object is NULL&quot;);
 230         __ bind(L);
 231       }
 232 #endif // ASSERT
 233       // Copy the lock field into the compiled activation.
 234       __ ld_ptr(OSR_buf, slot_offset + 0, O7);
 235       __ st_ptr(O7, frame_map()-&gt;address_for_monitor_lock(i));
 236       __ ld_ptr(OSR_buf, slot_offset + 1*BytesPerWord, O7);
 237       __ st_ptr(O7, frame_map()-&gt;address_for_monitor_object(i));
 238     }
 239   }
 240 }
 241 
 242 
 243 // --------------------------------------------------------------------------------------------
 244 
 245 void LIR_Assembler::monitorexit(LIR_Opr obj_opr, LIR_Opr lock_opr, Register hdr, int monitor_no) {
 246   if (!GenerateSynchronizationCode) return;
 247 
 248   Register obj_reg = obj_opr-&gt;as_register();
 249   Register lock_reg = lock_opr-&gt;as_register();
 250 
 251   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
 252   Register reg = mon_addr.base();
 253   int offset = mon_addr.disp();
 254   // compute pointer to BasicLock
 255   if (mon_addr.is_simm13()) {
 256     __ add(reg, offset, lock_reg);
 257   }
 258   else {
 259     __ set(offset, lock_reg);
 260     __ add(reg, lock_reg, lock_reg);
 261   }
 262   // unlock object
 263   MonitorAccessStub* slow_case = new MonitorExitStub(lock_opr, UseFastLocking, monitor_no);
 264   // _slow_case_stubs-&gt;append(slow_case);
 265   // temporary fix: must be created after exceptionhandler, therefore as call stub
 266   _slow_case_stubs-&gt;append(slow_case);
 267   if (UseFastLocking) {
 268     // try inlined fast unlocking first, revert to slow locking if it fails
 269     // note: lock_reg points to the displaced header since the displaced header offset is 0!
 270     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
 271     __ unlock_object(hdr, obj_reg, lock_reg, *slow_case-&gt;entry());
 272   } else {
 273     // always do slow unlocking
 274     // note: the slow unlocking code could be inlined here, however if we use
 275     //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
 276     //       simpler and requires less duplicated code - additionally, the
 277     //       slow unlocking code is the same in either case which simplifies
 278     //       debugging
 279     __ br(Assembler::always, false, Assembler::pt, *slow_case-&gt;entry());
 280     __ delayed()-&gt;nop();
 281   }
 282   // done
 283   __ bind(*slow_case-&gt;continuation());
 284 }
 285 
 286 
 287 int LIR_Assembler::emit_exception_handler() {
 288   // if the last instruction is a call (typically to do a throw which
 289   // is coming at the end after block reordering) the return address
 290   // must still point into the code area in order to avoid assertion
 291   // failures when searching for the corresponding bci =&gt; add a nop
 292   // (was bug 5/14/1999 - gri)
 293   __ nop();
 294 
 295   // generate code for exception handler
 296   ciMethod* method = compilation()-&gt;method();
 297 
 298   address handler_base = __ start_a_stub(exception_handler_size());
 299 
 300   if (handler_base == NULL) {
 301     // not enough space left for the handler
 302     bailout(&quot;exception handler overflow&quot;);
 303     return -1;
 304   }
 305 
 306   int offset = code_offset();
 307 
 308   __ call(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id), relocInfo::runtime_call_type);
 309   __ delayed()-&gt;nop();
 310   __ should_not_reach_here();
 311   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 312   __ end_a_stub();
 313 
 314   return offset;
 315 }
 316 
 317 
 318 // Emit the code to remove the frame from the stack in the exception
 319 // unwind path.
 320 int LIR_Assembler::emit_unwind_handler() {
 321 #ifndef PRODUCT
 322   if (CommentedAssembly) {
 323     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 324   }
 325 #endif
 326 
 327   int offset = code_offset();
 328 
 329   // Fetch the exception from TLS and clear out exception related thread state
 330   __ ld_ptr(G2_thread, in_bytes(JavaThread::exception_oop_offset()), O0);
 331   __ st_ptr(G0, G2_thread, in_bytes(JavaThread::exception_oop_offset()));
 332   __ st_ptr(G0, G2_thread, in_bytes(JavaThread::exception_pc_offset()));
 333 
 334   __ bind(_unwind_handler_entry);
 335   __ verify_not_null_oop(O0);
 336   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 337     __ mov(O0, I0);  // Preserve the exception
 338   }
 339 
 340   // Preform needed unlocking
 341   MonitorExitStub* stub = NULL;
 342   if (method()-&gt;is_synchronized()) {
 343     monitor_address(0, FrameMap::I1_opr);
 344     stub = new MonitorExitStub(FrameMap::I1_opr, true, 0);
 345     __ unlock_object(I3, I2, I1, *stub-&gt;entry());
 346     __ bind(*stub-&gt;continuation());
 347   }
 348 
 349   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 350     __ mov(G2_thread, O0);
 351     __ save_thread(I1); // need to preserve thread in G2 across
 352                         // runtime call
 353     metadata2reg(method()-&gt;constant_encoding(), O1);
 354     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), relocInfo::runtime_call_type);
 355     __ delayed()-&gt;nop();
 356     __ restore_thread(I1);
 357   }
 358 
 359   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 360     __ mov(I0, O0);  // Restore the exception
 361   }
 362 
 363   // dispatch to the unwind logic
 364   __ call(Runtime1::entry_for(Runtime1::unwind_exception_id), relocInfo::runtime_call_type);
 365   __ delayed()-&gt;nop();
 366 
 367   // Emit the slow path assembly
 368   if (stub != NULL) {
 369     stub-&gt;emit_code(this);
 370   }
 371 
 372   return offset;
 373 }
 374 
 375 
 376 int LIR_Assembler::emit_deopt_handler() {
 377   // if the last instruction is a call (typically to do a throw which
 378   // is coming at the end after block reordering) the return address
 379   // must still point into the code area in order to avoid assertion
 380   // failures when searching for the corresponding bci =&gt; add a nop
 381   // (was bug 5/14/1999 - gri)
 382   __ nop();
 383 
 384   // generate code for deopt handler
 385   ciMethod* method = compilation()-&gt;method();
 386   address handler_base = __ start_a_stub(deopt_handler_size());
 387   if (handler_base == NULL) {
 388     // not enough space left for the handler
 389     bailout(&quot;deopt handler overflow&quot;);
 390     return -1;
 391   }
 392 
 393   int offset = code_offset();
 394   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
 395   __ JUMP(deopt_blob, G3_scratch, 0); // sethi;jmp
 396   __ delayed()-&gt;nop();
 397   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 398   __ end_a_stub();
 399 
 400   return offset;
 401 }
 402 
 403 
 404 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 405   if (o == NULL) {
 406     __ set(NULL_WORD, reg);
 407   } else {
 408 #ifdef ASSERT
 409     {
 410       ThreadInVMfromNative tiv(JavaThread::current());
 411       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(o)), &quot;should be real oop&quot;);
 412     }
 413 #endif
 414     int oop_index = __ oop_recorder()-&gt;find_index(o);
 415     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 416     __ set(NULL_WORD, reg, rspec); // Will be set when the nmethod is created
 417   }
 418 }
 419 
 420 
 421 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 422   // Allocate a new index in table to hold the object once it&#39;s been patched
 423   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 424   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 425 
 426   AddressLiteral addrlit(NULL, oop_Relocation::spec(oop_index));
 427   assert(addrlit.rspec().type() == relocInfo::oop_type, &quot;must be an oop reloc&quot;);
 428   // It may not seem necessary to use a sethi/add pair to load a NULL into dest, but the
 429   // NULL will be dynamically patched later and the patched value may be large.  We must
 430   // therefore generate the sethi/add as a placeholders
 431   __ patchable_set(addrlit, reg);
 432 
 433   patching_epilog(patch, lir_patch_normal, reg, info);
 434 }
 435 
 436 
 437 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 438   __ set_metadata_constant(o, reg);
 439 }
 440 
 441 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 442   // Allocate a new index in table to hold the klass once it&#39;s been patched
 443   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 444   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 445   AddressLiteral addrlit(NULL, metadata_Relocation::spec(index));
 446   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 447   // It may not seem necessary to use a sethi/add pair to load a NULL into dest, but the
 448   // NULL will be dynamically patched later and the patched value may be large.  We must
 449   // therefore generate the sethi/add as a placeholders
 450   __ patchable_set(addrlit, reg);
 451 
 452   patching_epilog(patch, lir_patch_normal, reg, info);
 453 }
 454 
 455 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 456   switch (op-&gt;code()) {
 457     case lir_idiv:
 458     case lir_irem:  // Both idiv &amp; irem are handled after the switch (below).
 459       break;
 460     case lir_fmaf:
 461       __ fmadd(FloatRegisterImpl::S,
 462                op-&gt;in_opr1()-&gt;as_float_reg(),
 463                op-&gt;in_opr2()-&gt;as_float_reg(),
 464                op-&gt;in_opr3()-&gt;as_float_reg(),
 465                op-&gt;result_opr()-&gt;as_float_reg());
 466       return;
 467     case lir_fmad:
 468       __ fmadd(FloatRegisterImpl::D,
 469                op-&gt;in_opr1()-&gt;as_double_reg(),
 470                op-&gt;in_opr2()-&gt;as_double_reg(),
 471                op-&gt;in_opr3()-&gt;as_double_reg(),
 472                op-&gt;result_opr()-&gt;as_double_reg());
 473       return;
 474     default:
 475       ShouldNotReachHere();
 476       break;
 477   }
 478 
 479   // Handle idiv &amp; irem:
 480 
 481   Register Rdividend = op-&gt;in_opr1()-&gt;as_register();
 482   Register Rdivisor  = noreg;
 483   Register Rscratch  = op-&gt;in_opr3()-&gt;as_register();
 484   Register Rresult   = op-&gt;result_opr()-&gt;as_register();
 485   int divisor = -1;
 486 
 487   if (op-&gt;in_opr2()-&gt;is_register()) {
 488     Rdivisor = op-&gt;in_opr2()-&gt;as_register();
 489   } else {
 490     divisor = op-&gt;in_opr2()-&gt;as_constant_ptr()-&gt;as_jint();
 491     assert(Assembler::is_simm13(divisor), &quot;can only handle simm13&quot;);
 492   }
 493 
 494   assert(Rdividend != Rscratch, &quot;&quot;);
 495   assert(Rdivisor  != Rscratch, &quot;&quot;);
 496   assert(op-&gt;code() == lir_idiv || op-&gt;code() == lir_irem, &quot;Must be irem or idiv&quot;);
 497 
 498   if (Rdivisor == noreg &amp;&amp; is_power_of_2(divisor)) {
 499     // convert division by a power of two into some shifts and logical operations
 500     if (op-&gt;code() == lir_idiv) {
 501       if (divisor == 2) {
 502         __ srl(Rdividend, 31, Rscratch);
 503       } else {
 504         __ sra(Rdividend, 31, Rscratch);
 505         __ and3(Rscratch, divisor - 1, Rscratch);
 506       }
 507       __ add(Rdividend, Rscratch, Rscratch);
 508       __ sra(Rscratch, log2_int(divisor), Rresult);
 509       return;
 510     } else {
 511       if (divisor == 2) {
 512         __ srl(Rdividend, 31, Rscratch);
 513       } else {
 514         __ sra(Rdividend, 31, Rscratch);
 515         __ and3(Rscratch, divisor - 1,Rscratch);
 516       }
 517       __ add(Rdividend, Rscratch, Rscratch);
 518       __ andn(Rscratch, divisor - 1,Rscratch);
 519       __ sub(Rdividend, Rscratch, Rresult);
 520       return;
 521     }
 522   }
 523 
 524   __ sra(Rdividend, 31, Rscratch);
 525   __ wry(Rscratch);
 526 
 527   add_debug_info_for_div0_here(op-&gt;info());
 528 
 529   if (Rdivisor != noreg) {
 530     __ sdivcc(Rdividend, Rdivisor, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 531   } else {
 532     assert(Assembler::is_simm13(divisor), &quot;can only handle simm13&quot;);
 533     __ sdivcc(Rdividend, divisor, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 534   }
 535 
 536   Label skip;
 537   __ br(Assembler::overflowSet, true, Assembler::pn, skip);
 538   __ delayed()-&gt;Assembler::sethi(0x80000000, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 539   __ bind(skip);
 540 
 541   if (op-&gt;code() == lir_irem) {
 542     if (Rdivisor != noreg) {
 543       __ smul(Rscratch, Rdivisor, Rscratch);
 544     } else {
 545       __ smul(Rscratch, divisor, Rscratch);
 546     }
 547     __ sub(Rdividend, Rscratch, Rresult);
 548   }
 549 }
 550 
 551 
 552 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 553 #ifdef ASSERT
 554   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 555   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 556   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 557 #endif
 558   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 559 
 560   if (op-&gt;cond() == lir_cond_always) {
 561     __ br(Assembler::always, false, Assembler::pt, *(op-&gt;label()));
 562   } else if (op-&gt;code() == lir_cond_float_branch) {
 563     assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 564     bool is_unordered = (op-&gt;ublock() == op-&gt;block());
 565     Assembler::Condition acond;
 566     switch (op-&gt;cond()) {
 567       case lir_cond_equal:         acond = Assembler::f_equal;    break;
 568       case lir_cond_notEqual:      acond = Assembler::f_notEqual; break;
 569       case lir_cond_less:          acond = (is_unordered ? Assembler::f_unorderedOrLess          : Assembler::f_less);           break;
 570       case lir_cond_greater:       acond = (is_unordered ? Assembler::f_unorderedOrGreater       : Assembler::f_greater);        break;
 571       case lir_cond_lessEqual:     acond = (is_unordered ? Assembler::f_unorderedOrLessOrEqual   : Assembler::f_lessOrEqual);    break;
 572       case lir_cond_greaterEqual:  acond = (is_unordered ? Assembler::f_unorderedOrGreaterOrEqual: Assembler::f_greaterOrEqual); break;
 573       default :                         ShouldNotReachHere();
 574     }
 575     __ fb( acond, false, Assembler::pn, *(op-&gt;label()));
 576   } else {
 577     assert (op-&gt;code() == lir_branch, &quot;just checking&quot;);
 578 
 579     Assembler::Condition acond;
 580     switch (op-&gt;cond()) {
 581       case lir_cond_equal:        acond = Assembler::equal;                break;
 582       case lir_cond_notEqual:     acond = Assembler::notEqual;             break;
 583       case lir_cond_less:         acond = Assembler::less;                 break;
 584       case lir_cond_lessEqual:    acond = Assembler::lessEqual;            break;
 585       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;         break;
 586       case lir_cond_greater:      acond = Assembler::greater;              break;
 587       case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned; break;
 588       case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;    break;
 589       default:                         ShouldNotReachHere();
 590     };
 591 
 592     // sparc has different condition codes for testing 32-bit
 593     // vs. 64-bit values.  We could always test xcc is we could
 594     // guarantee that 32-bit loads always sign extended but that isn&#39;t
 595     // true and since sign extension isn&#39;t free, it would impose a
 596     // slight cost.
 597     if  (op-&gt;type() == T_INT) {
 598       __ br(acond, false, Assembler::pn, *(op-&gt;label()));
 599     } else
 600       __ brx(acond, false, Assembler::pn, *(op-&gt;label()));
 601   }
 602   // The peephole pass fills the delay slot
 603 }
 604 
 605 
 606 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 607   Bytecodes::Code code = op-&gt;bytecode();
 608   LIR_Opr dst = op-&gt;result_opr();
 609 
 610   switch(code) {
 611     case Bytecodes::_i2l: {
 612       Register rlo  = dst-&gt;as_register_lo();
 613       Register rhi  = dst-&gt;as_register_hi();
 614       Register rval = op-&gt;in_opr()-&gt;as_register();
 615       __ sra(rval, 0, rlo);
 616       break;
 617     }
 618     case Bytecodes::_i2d:
 619     case Bytecodes::_i2f: {
 620       bool is_double = (code == Bytecodes::_i2d);
 621       FloatRegister rdst = is_double ? dst-&gt;as_double_reg() : dst-&gt;as_float_reg();
 622       FloatRegisterImpl::Width w = is_double ? FloatRegisterImpl::D : FloatRegisterImpl::S;
 623       FloatRegister rsrc = op-&gt;in_opr()-&gt;as_float_reg();
 624       if (rsrc != rdst) {
 625         __ fmov(FloatRegisterImpl::S, rsrc, rdst);
 626       }
 627       __ fitof(w, rdst, rdst);
 628       break;
 629     }
 630     case Bytecodes::_f2i:{
 631       FloatRegister rsrc = op-&gt;in_opr()-&gt;as_float_reg();
 632       Address       addr = frame_map()-&gt;address_for_slot(dst-&gt;single_stack_ix());
 633       Label L;
 634       // result must be 0 if value is NaN; test by comparing value to itself
 635       __ fcmp(FloatRegisterImpl::S, Assembler::fcc0, rsrc, rsrc);
 636       __ fb(Assembler::f_unordered, true, Assembler::pn, L);
 637       __ delayed()-&gt;st(G0, addr); // annuled if contents of rsrc is not NaN
 638       __ ftoi(FloatRegisterImpl::S, rsrc, rsrc);
 639       // move integer result from float register to int register
 640       __ stf(FloatRegisterImpl::S, rsrc, addr.base(), addr.disp());
 641       __ bind (L);
 642       break;
 643     }
 644     case Bytecodes::_l2i: {
 645       Register rlo  = op-&gt;in_opr()-&gt;as_register_lo();
 646       Register rhi  = op-&gt;in_opr()-&gt;as_register_hi();
 647       Register rdst = dst-&gt;as_register();
 648       __ sra(rlo, 0, rdst);
 649       break;
 650     }
 651     case Bytecodes::_d2f:
 652     case Bytecodes::_f2d: {
 653       bool is_double = (code == Bytecodes::_f2d);
 654       assert((!is_double &amp;&amp; dst-&gt;is_single_fpu()) || (is_double &amp;&amp; dst-&gt;is_double_fpu()), &quot;check&quot;);
 655       LIR_Opr val = op-&gt;in_opr();
 656       FloatRegister rval = (code == Bytecodes::_d2f) ? val-&gt;as_double_reg() : val-&gt;as_float_reg();
 657       FloatRegister rdst = is_double ? dst-&gt;as_double_reg() : dst-&gt;as_float_reg();
 658       FloatRegisterImpl::Width vw = is_double ? FloatRegisterImpl::S : FloatRegisterImpl::D;
 659       FloatRegisterImpl::Width dw = is_double ? FloatRegisterImpl::D : FloatRegisterImpl::S;
 660       __ ftof(vw, dw, rval, rdst);
 661       break;
 662     }
 663     case Bytecodes::_i2s:
 664     case Bytecodes::_i2b: {
 665       Register rval = op-&gt;in_opr()-&gt;as_register();
 666       Register rdst = dst-&gt;as_register();
 667       int shift = (code == Bytecodes::_i2b) ? (BitsPerInt - T_BYTE_aelem_bytes * BitsPerByte) : (BitsPerInt - BitsPerShort);
 668       __ sll (rval, shift, rdst);
 669       __ sra (rdst, shift, rdst);
 670       break;
 671     }
 672     case Bytecodes::_i2c: {
 673       Register rval = op-&gt;in_opr()-&gt;as_register();
 674       Register rdst = dst-&gt;as_register();
 675       int shift = BitsPerInt - T_CHAR_aelem_bytes * BitsPerByte;
 676       __ sll (rval, shift, rdst);
 677       __ srl (rdst, shift, rdst);
 678       break;
 679     }
 680 
 681     default: ShouldNotReachHere();
 682   }
 683 }
 684 
 685 
 686 void LIR_Assembler::align_call(LIR_Code) {
 687   // do nothing since all instructions are word aligned on sparc
 688 }
 689 
 690 
 691 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 692   __ call(op-&gt;addr(), rtype);
 693   // The peephole pass fills the delay slot, add_call_info is done in
 694   // LIR_Assembler::emit_delay.
 695 }
 696 
 697 
 698 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 699   __ ic_call(op-&gt;addr(), false);
 700   // The peephole pass fills the delay slot, add_call_info is done in
 701   // LIR_Assembler::emit_delay.
 702 }
 703 
 704 
 705 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 706   add_debug_info_for_null_check_here(op-&gt;info());
 707   __ load_klass(O0, G3_scratch);
 708   if (Assembler::is_simm13(op-&gt;vtable_offset())) {
 709     __ ld_ptr(G3_scratch, op-&gt;vtable_offset(), G5_method);
 710   } else {
 711     // This will generate 2 instructions
 712     __ set(op-&gt;vtable_offset(), G5_method);
 713     // ld_ptr, set_hi, set
 714     __ ld_ptr(G3_scratch, G5_method, G5_method);
 715   }
 716   __ ld_ptr(G5_method, Method::from_compiled_offset(), G3_scratch);
 717   __ callr(G3_scratch, G0);
 718   // the peephole pass fills the delay slot
 719 }
 720 
 721 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 722   int store_offset;
 723   if (!Assembler::is_simm13(offset + (type == T_LONG) ? wordSize : 0)) {
 724     assert(base != O7, &quot;destroying register&quot;);
 725     assert(!unaligned, &quot;can&#39;t handle this&quot;);
 726     // for offsets larger than a simm13 we setup the offset in O7
 727     __ set(offset, O7);
 728     store_offset = store(from_reg, base, O7, type, wide);
 729   } else {
 730     if (is_reference_type(type)) {
 731       __ verify_oop(from_reg-&gt;as_register());
 732     }
 733     store_offset = code_offset();
 734     switch (type) {
 735       case T_BOOLEAN: // fall through
 736       case T_BYTE  : __ stb(from_reg-&gt;as_register(), base, offset); break;
 737       case T_CHAR  : __ sth(from_reg-&gt;as_register(), base, offset); break;
 738       case T_SHORT : __ sth(from_reg-&gt;as_register(), base, offset); break;
 739       case T_INT   : __ stw(from_reg-&gt;as_register(), base, offset); break;
 740       case T_LONG  :
 741         if (unaligned || PatchALot) {
 742           // Don&#39;t use O7 here because it may be equal to &#39;base&#39; (see LIR_Assembler::reg2mem)
 743           assert(G3_scratch != base, &quot;can&#39;t handle this&quot;);
 744           assert(G3_scratch != from_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 745           __ srax(from_reg-&gt;as_register_lo(), 32, G3_scratch);
 746           __ stw(from_reg-&gt;as_register_lo(), base, offset + lo_word_offset_in_bytes);
 747           __ stw(G3_scratch,                 base, offset + hi_word_offset_in_bytes);
 748         } else {
 749           __ stx(from_reg-&gt;as_register_lo(), base, offset);
 750         }
 751         break;
 752       case T_ADDRESS:
 753       case T_METADATA:
 754         __ st_ptr(from_reg-&gt;as_register(), base, offset);
 755         break;
 756       case T_ARRAY : // fall through
 757       case T_OBJECT:
 758         {
 759           if (UseCompressedOops &amp;&amp; !wide) {
 760             __ encode_heap_oop(from_reg-&gt;as_register(), G3_scratch);
 761             store_offset = code_offset();
 762             __ stw(G3_scratch, base, offset);
 763           } else {
 764             __ st_ptr(from_reg-&gt;as_register(), base, offset);
 765           }
 766           break;
 767         }
 768 
 769       case T_FLOAT : __ stf(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), base, offset); break;
 770       case T_DOUBLE:
 771         {
 772           FloatRegister reg = from_reg-&gt;as_double_reg();
 773           // split unaligned stores
 774           if (unaligned || PatchALot) {
 775             assert(Assembler::is_simm13(offset + 4), &quot;must be&quot;);
 776             __ stf(FloatRegisterImpl::S, reg-&gt;successor(), base, offset + 4);
 777             __ stf(FloatRegisterImpl::S, reg,              base, offset);
 778           } else {
 779             __ stf(FloatRegisterImpl::D, reg, base, offset);
 780           }
 781           break;
 782         }
 783       default      : ShouldNotReachHere();
 784     }
 785   }
 786   return store_offset;
 787 }
 788 
 789 
 790 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 791   if (is_reference_type(type)) {
 792     __ verify_oop(from_reg-&gt;as_register());
 793   }
 794   int store_offset = code_offset();
 795   switch (type) {
 796     case T_BOOLEAN: // fall through
 797     case T_BYTE  : __ stb(from_reg-&gt;as_register(), base, disp); break;
 798     case T_CHAR  : __ sth(from_reg-&gt;as_register(), base, disp); break;
 799     case T_SHORT : __ sth(from_reg-&gt;as_register(), base, disp); break;
 800     case T_INT   : __ stw(from_reg-&gt;as_register(), base, disp); break;
 801     case T_LONG  :
 802       __ stx(from_reg-&gt;as_register_lo(), base, disp);
 803       break;
 804     case T_ADDRESS:
 805       __ st_ptr(from_reg-&gt;as_register(), base, disp);
 806       break;
 807     case T_ARRAY : // fall through
 808     case T_OBJECT:
 809       {
 810         if (UseCompressedOops &amp;&amp; !wide) {
 811           __ encode_heap_oop(from_reg-&gt;as_register(), G3_scratch);
 812           store_offset = code_offset();
 813           __ stw(G3_scratch, base, disp);
 814         } else {
 815           __ st_ptr(from_reg-&gt;as_register(), base, disp);
 816         }
 817         break;
 818       }
 819     case T_FLOAT : __ stf(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), base, disp); break;
 820     case T_DOUBLE: __ stf(FloatRegisterImpl::D, from_reg-&gt;as_double_reg(), base, disp); break;
 821     default      : ShouldNotReachHere();
 822   }
 823   return store_offset;
 824 }
 825 
 826 
 827 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 828   int load_offset;
 829   if (!Assembler::is_simm13(offset + (type == T_LONG) ? wordSize : 0)) {
 830     assert(base != O7, &quot;destroying register&quot;);
 831     assert(!unaligned, &quot;can&#39;t handle this&quot;);
 832     // for offsets larger than a simm13 we setup the offset in O7
 833     __ set(offset, O7);
 834     load_offset = load(base, O7, to_reg, type, wide);
 835   } else {
 836     load_offset = code_offset();
 837     switch(type) {
 838       case T_BOOLEAN: // fall through
 839       case T_BYTE  : __ ldsb(base, offset, to_reg-&gt;as_register()); break;
 840       case T_CHAR  : __ lduh(base, offset, to_reg-&gt;as_register()); break;
 841       case T_SHORT : __ ldsh(base, offset, to_reg-&gt;as_register()); break;
 842       case T_INT   : __ ld(base, offset, to_reg-&gt;as_register()); break;
 843       case T_LONG  :
 844         if (!unaligned &amp;&amp; !PatchALot) {
 845           __ ldx(base, offset, to_reg-&gt;as_register_lo());
 846         } else {
 847           assert(base != to_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 848           assert(O7 != to_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 849           __ ld(base, offset + hi_word_offset_in_bytes, to_reg-&gt;as_register_lo());
 850           __ lduw(base, offset + lo_word_offset_in_bytes, O7); // in case O7 is base or offset, use it last
 851           __ sllx(to_reg-&gt;as_register_lo(), 32, to_reg-&gt;as_register_lo());
 852           __ or3(to_reg-&gt;as_register_lo(), O7, to_reg-&gt;as_register_lo());
 853         }
 854         break;
 855       case T_METADATA:  __ ld_ptr(base, offset, to_reg-&gt;as_register()); break;
 856       case T_ADDRESS:
 857         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 858           __ lduw(base, offset, to_reg-&gt;as_register());
 859           __ decode_klass_not_null(to_reg-&gt;as_register());
 860         } else
 861         {
 862           __ ld_ptr(base, offset, to_reg-&gt;as_register());
 863         }
 864         break;
 865       case T_ARRAY : // fall through
 866       case T_OBJECT:
 867         {
 868           if (UseCompressedOops &amp;&amp; !wide) {
 869             __ lduw(base, offset, to_reg-&gt;as_register());
 870             __ decode_heap_oop(to_reg-&gt;as_register());
 871           } else {
 872             __ ld_ptr(base, offset, to_reg-&gt;as_register());
 873           }
 874           break;
 875         }
 876       case T_FLOAT:  __ ldf(FloatRegisterImpl::S, base, offset, to_reg-&gt;as_float_reg()); break;
 877       case T_DOUBLE:
 878         {
 879           FloatRegister reg = to_reg-&gt;as_double_reg();
 880           // split unaligned loads
 881           if (unaligned || PatchALot) {
 882             __ ldf(FloatRegisterImpl::S, base, offset + 4, reg-&gt;successor());
 883             __ ldf(FloatRegisterImpl::S, base, offset,     reg);
 884           } else {
 885             __ ldf(FloatRegisterImpl::D, base, offset, to_reg-&gt;as_double_reg());
 886           }
 887           break;
 888         }
 889       default      : ShouldNotReachHere();
 890     }
 891     if (is_reference_type(type)) {
 892       __ verify_oop(to_reg-&gt;as_register());
 893     }
 894   }
 895   return load_offset;
 896 }
 897 
 898 
 899 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 900   int load_offset = code_offset();
 901   switch(type) {
 902     case T_BOOLEAN: // fall through
 903     case T_BYTE  :  __ ldsb(base, disp, to_reg-&gt;as_register()); break;
 904     case T_CHAR  :  __ lduh(base, disp, to_reg-&gt;as_register()); break;
 905     case T_SHORT :  __ ldsh(base, disp, to_reg-&gt;as_register()); break;
 906     case T_INT   :  __ ld(base, disp, to_reg-&gt;as_register()); break;
 907     case T_ADDRESS: __ ld_ptr(base, disp, to_reg-&gt;as_register()); break;
 908     case T_ARRAY : // fall through
 909     case T_OBJECT:
 910       {
 911           if (UseCompressedOops &amp;&amp; !wide) {
 912             __ lduw(base, disp, to_reg-&gt;as_register());
 913             __ decode_heap_oop(to_reg-&gt;as_register());
 914           } else {
 915             __ ld_ptr(base, disp, to_reg-&gt;as_register());
 916           }
 917           break;
 918       }
 919     case T_FLOAT:  __ ldf(FloatRegisterImpl::S, base, disp, to_reg-&gt;as_float_reg()); break;
 920     case T_DOUBLE: __ ldf(FloatRegisterImpl::D, base, disp, to_reg-&gt;as_double_reg()); break;
 921     case T_LONG  :
 922       __ ldx(base, disp, to_reg-&gt;as_register_lo());
 923       break;
 924     default      : ShouldNotReachHere();
 925   }
 926   if (is_reference_type(type)) {
 927     __ verify_oop(to_reg-&gt;as_register());
 928   }
 929   return load_offset;
 930 }
 931 
 932 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 933   LIR_Const* c = src-&gt;as_constant_ptr();
 934   switch (c-&gt;type()) {
 935     case T_INT:
 936     case T_FLOAT: {
 937       Register src_reg = O7;
 938       int value = c-&gt;as_jint_bits();
 939       if (value == 0) {
 940         src_reg = G0;
 941       } else {
 942         __ set(value, O7);
 943       }
 944       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 945       __ stw(src_reg, addr.base(), addr.disp());
 946       break;
 947     }
 948     case T_ADDRESS: {
 949       Register src_reg = O7;
 950       int value = c-&gt;as_jint_bits();
 951       if (value == 0) {
 952         src_reg = G0;
 953       } else {
 954         __ set(value, O7);
 955       }
 956       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 957       __ st_ptr(src_reg, addr.base(), addr.disp());
 958       break;
 959     }
 960     case T_OBJECT: {
 961       Register src_reg = O7;
 962       jobject2reg(c-&gt;as_jobject(), src_reg);
 963       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 964       __ st_ptr(src_reg, addr.base(), addr.disp());
 965       break;
 966     }
 967     case T_LONG:
 968     case T_DOUBLE: {
 969       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 970 
 971       Register tmp = O7;
 972       int value_lo = c-&gt;as_jint_lo_bits();
 973       if (value_lo == 0) {
 974         tmp = G0;
 975       } else {
 976         __ set(value_lo, O7);
 977       }
 978       __ stw(tmp, addr.base(), addr.disp() + lo_word_offset_in_bytes);
 979       int value_hi = c-&gt;as_jint_hi_bits();
 980       if (value_hi == 0) {
 981         tmp = G0;
 982       } else {
 983         __ set(value_hi, O7);
 984       }
 985       __ stw(tmp, addr.base(), addr.disp() + hi_word_offset_in_bytes);
 986       break;
 987     }
 988     default:
 989       Unimplemented();
 990   }
 991 }
 992 
 993 
 994 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 995   LIR_Const* c = src-&gt;as_constant_ptr();
 996   LIR_Address* addr     = dest-&gt;as_address_ptr();
 997   Register base = addr-&gt;base()-&gt;as_pointer_register();
 998   int offset = -1;
 999 
1000   switch (c-&gt;type()) {
1001     case T_FLOAT: type = T_INT; // Float constants are stored by int store instructions.
1002     case T_INT:
1003     case T_ADDRESS: {
1004       LIR_Opr tmp = FrameMap::O7_opr;
1005       int value = c-&gt;as_jint_bits();
1006       if (value == 0) {
1007         tmp = FrameMap::G0_opr;
1008       } else if (Assembler::is_simm13(value)) {
1009         __ set(value, O7);
1010       }
1011       if (addr-&gt;index()-&gt;is_valid()) {
1012         assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
1013         offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
1014       } else {
1015         assert(Assembler::is_simm13(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
1016         offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
1017       }
1018       break;
1019     }
1020     case T_LONG:
1021     case T_DOUBLE: {
1022       assert(!addr-&gt;index()-&gt;is_valid(), &quot;can&#39;t handle reg reg address here&quot;);
1023       assert(Assembler::is_simm13(addr-&gt;disp()) &amp;&amp;
1024              Assembler::is_simm13(addr-&gt;disp() + 4), &quot;can&#39;t handle larger addresses&quot;);
1025 
1026       LIR_Opr tmp = FrameMap::O7_opr;
1027       int value_lo = c-&gt;as_jint_lo_bits();
1028       if (value_lo == 0) {
1029         tmp = FrameMap::G0_opr;
1030       } else {
1031         __ set(value_lo, O7);
1032       }
1033       offset = store(tmp, base, addr-&gt;disp() + lo_word_offset_in_bytes, T_INT, wide, false);
1034       int value_hi = c-&gt;as_jint_hi_bits();
1035       if (value_hi == 0) {
1036         tmp = FrameMap::G0_opr;
1037       } else {
1038         __ set(value_hi, O7);
1039       }
1040       store(tmp, base, addr-&gt;disp() + hi_word_offset_in_bytes, T_INT, wide, false);
1041       break;
1042     }
1043     case T_OBJECT: {
1044       jobject obj = c-&gt;as_jobject();
1045       LIR_Opr tmp;
1046       if (obj == NULL) {
1047         tmp = FrameMap::G0_opr;
1048       } else {
1049         tmp = FrameMap::O7_opr;
1050         jobject2reg(c-&gt;as_jobject(), O7);
1051       }
1052       // handle either reg+reg or reg+disp address
1053       if (addr-&gt;index()-&gt;is_valid()) {
1054         assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
1055         offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
1056       } else {
1057         assert(Assembler::is_simm13(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
1058         offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
1059       }
1060 
1061       break;
1062     }
1063     default:
1064       Unimplemented();
1065   }
1066   if (info != NULL) {
1067     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
1068     add_debug_info_for_null_check(offset, info);
1069   }
1070 }
1071 
1072 
1073 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
1074   LIR_Const* c = src-&gt;as_constant_ptr();
1075   LIR_Opr to_reg = dest;
1076 
1077   switch (c-&gt;type()) {
1078     case T_INT:
1079     case T_ADDRESS:
1080       {
1081         jint con = c-&gt;as_jint();
1082         if (to_reg-&gt;is_single_cpu()) {
1083           assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
1084           __ set(con, to_reg-&gt;as_register());
1085         } else {
1086           ShouldNotReachHere();
1087           assert(to_reg-&gt;is_single_fpu(), &quot;wrong register kind&quot;);
1088 
1089           __ set(con, O7);
1090           Address temp_slot(SP, (frame::register_save_words * wordSize) + STACK_BIAS);
1091           __ st(O7, temp_slot);
1092           __ ldf(FloatRegisterImpl::S, temp_slot, to_reg-&gt;as_float_reg());
1093         }
1094       }
1095       break;
1096 
1097     case T_LONG:
1098       {
1099         jlong con = c-&gt;as_jlong();
1100 
1101         if (to_reg-&gt;is_double_cpu()) {
1102           __ set(con,  to_reg-&gt;as_register_lo());
1103         } else if (to_reg-&gt;is_single_cpu()) {
1104           __ set(con, to_reg-&gt;as_register());
1105         } else {
1106           ShouldNotReachHere();
1107           assert(to_reg-&gt;is_double_fpu(), &quot;wrong register kind&quot;);
1108           Address temp_slot_lo(SP, ((frame::register_save_words  ) * wordSize) + STACK_BIAS);
1109           Address temp_slot_hi(SP, ((frame::register_save_words) * wordSize) + (longSize/2) + STACK_BIAS);
1110           __ set(low(con),  O7);
1111           __ st(O7, temp_slot_lo);
1112           __ set(high(con), O7);
1113           __ st(O7, temp_slot_hi);
1114           __ ldf(FloatRegisterImpl::D, temp_slot_lo, to_reg-&gt;as_double_reg());
1115         }
1116       }
1117       break;
1118 
1119     case T_OBJECT:
1120       {
1121         if (patch_code == lir_patch_none) {
1122           jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
1123         } else {
1124           jobject2reg_with_patching(to_reg-&gt;as_register(), info);
1125         }
1126       }
1127       break;
1128 
1129     case T_METADATA:
1130       {
1131         if (patch_code == lir_patch_none) {
1132           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1133         } else {
1134           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1135         }
1136       }
1137       break;
1138 
1139     case T_FLOAT:
1140       {
1141         address const_addr = __ float_constant(c-&gt;as_jfloat());
1142         if (const_addr == NULL) {
1143           bailout(&quot;const section overflow&quot;);
1144           break;
1145         }
1146         RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1147         AddressLiteral const_addrlit(const_addr, rspec);
1148         if (to_reg-&gt;is_single_fpu()) {
1149           __ patchable_sethi(const_addrlit, O7);
1150           __ relocate(rspec);
1151           __ ldf(FloatRegisterImpl::S, O7, const_addrlit.low10(), to_reg-&gt;as_float_reg());
1152 
1153         } else {
1154           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1155 
1156           __ set(const_addrlit, O7);
1157           __ ld(O7, 0, to_reg-&gt;as_register());
1158         }
1159       }
1160       break;
1161 
1162     case T_DOUBLE:
1163       {
1164         address const_addr = __ double_constant(c-&gt;as_jdouble());
1165         if (const_addr == NULL) {
1166           bailout(&quot;const section overflow&quot;);
1167           break;
1168         }
1169         RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1170 
1171         if (to_reg-&gt;is_double_fpu()) {
1172           AddressLiteral const_addrlit(const_addr, rspec);
1173           __ patchable_sethi(const_addrlit, O7);
1174           __ relocate(rspec);
1175           __ ldf (FloatRegisterImpl::D, O7, const_addrlit.low10(), to_reg-&gt;as_double_reg());
1176         } else {
1177           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1178           __ set(jlong_cast(c-&gt;as_jdouble()), to_reg-&gt;as_register_lo());
1179         }
1180 
1181       }
1182       break;
1183 
1184     default:
1185       ShouldNotReachHere();
1186   }
1187 }
1188 
1189 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1190   Register reg = addr-&gt;base()-&gt;as_pointer_register();
1191   LIR_Opr index = addr-&gt;index();
1192   if (index-&gt;is_illegal()) {
1193     return Address(reg, addr-&gt;disp());
1194   } else {
1195     assert (addr-&gt;disp() == 0, &quot;unsupported address mode&quot;);
1196     return Address(reg, index-&gt;as_pointer_register());
1197   }
1198 }
1199 
1200 
1201 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1202   switch (type) {
1203     case T_INT:
1204     case T_FLOAT: {
1205       Register tmp = O7;
1206       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1207       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1208       __ lduw(from.base(), from.disp(), tmp);
1209       __ stw(tmp, to.base(), to.disp());
1210       break;
1211     }
1212     case T_ADDRESS:
1213     case T_OBJECT: {
1214       Register tmp = O7;
1215       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1216       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1217       __ ld_ptr(from.base(), from.disp(), tmp);
1218       __ st_ptr(tmp, to.base(), to.disp());
1219       break;
1220     }
1221     case T_LONG:
1222     case T_DOUBLE: {
1223       Register tmp = O7;
1224       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1225       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1226       __ lduw(from.base(), from.disp(), tmp);
1227       __ stw(tmp, to.base(), to.disp());
1228       __ lduw(from.base(), from.disp() + 4, tmp);
1229       __ stw(tmp, to.base(), to.disp() + 4);
1230       break;
1231     }
1232 
1233     default:
1234       ShouldNotReachHere();
1235   }
1236 }
1237 
1238 
1239 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1240   Address base = as_Address(addr);
1241   return Address(base.base(), base.disp() + hi_word_offset_in_bytes);
1242 }
1243 
1244 
1245 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1246   Address base = as_Address(addr);
1247   return Address(base.base(), base.disp() + lo_word_offset_in_bytes);
1248 }
1249 
1250 
1251 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1252                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1253 
1254   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1255   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1256   LIR_Opr to_reg = dest;
1257 
1258   Register src = addr-&gt;base()-&gt;as_pointer_register();
1259   Register disp_reg = noreg;
1260   int disp_value = addr-&gt;disp();
1261   bool needs_patching = (patch_code != lir_patch_none);
1262 
1263   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1264     __ verify_oop(src);
1265   }
1266 
1267   PatchingStub* patch = NULL;
1268   if (needs_patching) {
1269     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1270     assert(!to_reg-&gt;is_double_cpu() ||
1271            patch_code == lir_patch_none ||
1272            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1273   }
1274 
1275   if (addr-&gt;index()-&gt;is_illegal()) {
1276     if (!Assembler::is_simm13(disp_value) &amp;&amp; (!unaligned || Assembler::is_simm13(disp_value + 4))) {
1277       if (needs_patching) {
1278         __ patchable_set(0, O7);
1279       } else {
1280         __ set(disp_value, O7);
1281       }
1282       disp_reg = O7;
1283     }
1284   } else if (unaligned || PatchALot) {
1285     __ add(src, addr-&gt;index()-&gt;as_pointer_register(), O7);
1286     src = O7;
1287   } else {
1288     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1289     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1290   }
1291 
1292   // remember the offset of the load.  The patching_epilog must be done
1293   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1294   // entered in increasing order.
1295   int offset = code_offset();
1296 
1297   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1298   if (disp_reg == noreg) {
1299     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1300   } else {
1301     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1302     offset = load(src, disp_reg, to_reg, type, wide);
1303   }
1304 
1305   if (patch != NULL) {
1306     patching_epilog(patch, patch_code, src, info);
1307   }
1308   if (info != NULL) add_debug_info_for_null_check(offset, info);
1309 }
1310 
1311 
1312 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1313   Address addr;
1314   if (src-&gt;is_single_word()) {
1315     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1316   } else if (src-&gt;is_double_word())  {
1317     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1318   }
1319 
1320   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1321   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1322 }
1323 
1324 
1325 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1326   Address addr;
1327   if (dest-&gt;is_single_word()) {
1328     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1329   } else if (dest-&gt;is_double_word())  {
1330     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1331   }
1332   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1333   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1334 }
1335 
1336 
1337 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1338   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1339     if (from_reg-&gt;is_double_fpu()) {
1340       // double to double moves
1341       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1342       __ fmov(FloatRegisterImpl::D, from_reg-&gt;as_double_reg(), to_reg-&gt;as_double_reg());
1343     } else {
1344       // float to float moves
1345       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1346       __ fmov(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), to_reg-&gt;as_float_reg());
1347     }
1348   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1349     if (from_reg-&gt;is_double_cpu()) {
1350       __ mov(from_reg-&gt;as_pointer_register(), to_reg-&gt;as_pointer_register());
1351     } else if (to_reg-&gt;is_double_cpu()) {
1352       // int to int moves
1353       __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register_lo());
1354     } else {
1355       // int to int moves
1356       __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register());
1357     }
1358   } else {
1359     ShouldNotReachHere();
1360   }
1361   if (is_reference_type(to_reg-&gt;type())) {
1362     __ verify_oop(to_reg-&gt;as_register());
1363   }
1364 }
1365 
1366 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1367                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1368                             bool wide, bool unaligned) {
1369   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1370   LIR_Address* addr = dest-&gt;as_address_ptr();
1371 
1372   Register src = addr-&gt;base()-&gt;as_pointer_register();
1373   Register disp_reg = noreg;
1374   int disp_value = addr-&gt;disp();
1375   bool needs_patching = (patch_code != lir_patch_none);
1376 
1377   if (addr-&gt;base()-&gt;is_oop_register()) {
1378     __ verify_oop(src);
1379   }
1380 
1381   PatchingStub* patch = NULL;
1382   if (needs_patching) {
1383     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1384     assert(!from_reg-&gt;is_double_cpu() ||
1385            patch_code == lir_patch_none ||
1386            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1387   }
1388 
1389   if (addr-&gt;index()-&gt;is_illegal()) {
1390     if (!Assembler::is_simm13(disp_value) &amp;&amp; (!unaligned || Assembler::is_simm13(disp_value + 4))) {
1391       if (needs_patching) {
1392         __ patchable_set(0, O7);
1393       } else {
1394         __ set(disp_value, O7);
1395       }
1396       disp_reg = O7;
1397     }
1398   } else if (unaligned || PatchALot) {
1399     __ add(src, addr-&gt;index()-&gt;as_pointer_register(), O7);
1400     src = O7;
1401   } else {
1402     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1403     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1404   }
1405 
1406   // remember the offset of the store.  The patching_epilog must be done
1407   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1408   // entered in increasing order.
1409   int offset;
1410 
1411   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1412   if (disp_reg == noreg) {
1413     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1414   } else {
1415     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1416     offset = store(from_reg, src, disp_reg, type, wide);
1417   }
1418 
1419   if (patch != NULL) {
1420     patching_epilog(patch, patch_code, src, info);
1421   }
1422 
1423   if (info != NULL) add_debug_info_for_null_check(offset, info);
1424 }
1425 
1426 
1427 void LIR_Assembler::return_op(LIR_Opr result) {
1428   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1429     __ reserved_stack_check();
1430   }
1431   if (SafepointMechanism::uses_thread_local_poll()) {
1432     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
1433   } else {
1434     __ set((intptr_t)os::get_polling_page(), L0);
1435   }
1436   __ relocate(relocInfo::poll_return_type);
1437   __ ld_ptr(L0, 0, G0);
1438   __ ret();
1439   __ delayed()-&gt;restore();
1440 }
1441 
1442 
1443 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1444   if (SafepointMechanism::uses_thread_local_poll()) {
1445     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), tmp-&gt;as_register());
1446   } else {
1447     __ set((intptr_t)os::get_polling_page(), tmp-&gt;as_register());
1448   }
1449   if (info != NULL) {
1450     add_debug_info_for_branch(info);
1451   }
1452   int offset = __ offset();
1453 
1454   __ relocate(relocInfo::poll_type);
1455   __ ld_ptr(tmp-&gt;as_register(), 0, G0);
1456   return offset;
1457 }
1458 
1459 
1460 void LIR_Assembler::emit_static_call_stub() {
1461   address call_pc = __ pc();
1462   address stub = __ start_a_stub(call_stub_size());
1463   if (stub == NULL) {
1464     bailout(&quot;static call stub overflow&quot;);
1465     return;
1466   }
1467 
1468   int start = __ offset();
1469   __ relocate(static_stub_Relocation::spec(call_pc));
1470 
1471   __ set_metadata(NULL, G5);
1472   // must be set to -1 at code generation time
1473   AddressLiteral addrlit(-1);
1474   __ jump_to(addrlit, G3);
1475   __ delayed()-&gt;nop();
1476 
1477   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1478   __ end_a_stub();
1479 }
1480 
1481 
1482 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1483   if (opr1-&gt;is_single_fpu()) {
1484     __ fcmp(FloatRegisterImpl::S, Assembler::fcc0, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1485   } else if (opr1-&gt;is_double_fpu()) {
1486     __ fcmp(FloatRegisterImpl::D, Assembler::fcc0, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1487   } else if (opr1-&gt;is_single_cpu()) {
1488     if (opr2-&gt;is_constant()) {
1489       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1490         case T_INT:
1491           { jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1492             if (Assembler::is_simm13(con)) {
1493               __ cmp(opr1-&gt;as_register(), con);
1494             } else {
1495               __ set(con, O7);
1496               __ cmp(opr1-&gt;as_register(), O7);
1497             }
1498           }
1499           break;
1500 
1501         case T_OBJECT:
1502           // there are only equal/notequal comparisions on objects
1503           { jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1504             if (con == NULL) {
1505               __ cmp(opr1-&gt;as_register(), 0);
1506             } else {
1507               jobject2reg(con, O7);
1508               __ cmp(opr1-&gt;as_register(), O7);
1509             }
1510           }
1511           break;
1512 
1513         case T_METADATA:
1514           // We only need, for now, comparison with NULL for metadata.
1515           { assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1516             Metadata* m = opr2-&gt;as_constant_ptr()-&gt;as_metadata();
1517             if (m == NULL) {
1518               __ cmp(opr1-&gt;as_register(), 0);
1519             } else {
1520               ShouldNotReachHere();
1521             }
1522           }
1523           break;
1524 
1525         default:
1526           ShouldNotReachHere();
1527           break;
1528       }
1529     } else {
1530       if (opr2-&gt;is_address()) {
1531         LIR_Address * addr = opr2-&gt;as_address_ptr();
1532         BasicType type = addr-&gt;type();
1533         if ( type == T_OBJECT ) __ ld_ptr(as_Address(addr), O7);
1534         else                    __ ld(as_Address(addr), O7);
1535         __ cmp(opr1-&gt;as_register(), O7);
1536       } else {
1537         __ cmp(opr1-&gt;as_register(), opr2-&gt;as_register());
1538       }
1539     }
1540   } else if (opr1-&gt;is_double_cpu()) {
1541     Register xlo = opr1-&gt;as_register_lo();
1542     Register xhi = opr1-&gt;as_register_hi();
1543     if (opr2-&gt;is_constant() &amp;&amp; opr2-&gt;as_jlong() == 0) {
1544       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles these cases&quot;);
1545       __ orcc(xhi, G0, G0);
1546     } else if (opr2-&gt;is_register()) {
1547       Register ylo = opr2-&gt;as_register_lo();
1548       Register yhi = opr2-&gt;as_register_hi();
1549       __ cmp(xlo, ylo);
1550     } else {
1551       ShouldNotReachHere();
1552     }
1553   } else if (opr1-&gt;is_address()) {
1554     LIR_Address * addr = opr1-&gt;as_address_ptr();
1555     BasicType type = addr-&gt;type();
1556     assert (opr2-&gt;is_constant(), &quot;Checking&quot;);
1557     if ( type == T_OBJECT ) __ ld_ptr(as_Address(addr), O7);
1558     else                    __ ld(as_Address(addr), O7);
1559     __ cmp(O7, opr2-&gt;as_constant_ptr()-&gt;as_jint());
1560   } else {
1561     ShouldNotReachHere();
1562   }
1563 }
1564 
1565 
1566 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1567   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1568     bool is_unordered_less = (code == lir_ucmp_fd2i);
1569     if (left-&gt;is_single_fpu()) {
1570       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
1571     } else if (left-&gt;is_double_fpu()) {
1572       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
1573     } else {
1574       ShouldNotReachHere();
1575     }
1576   } else if (code == lir_cmp_l2i) {
1577     __ lcmp(left-&gt;as_register_lo(), right-&gt;as_register_lo(), dst-&gt;as_register());
1578   } else {
1579     ShouldNotReachHere();
1580   }
1581 }
1582 
1583 
1584 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1585   Assembler::Condition acond;
1586   switch (condition) {
1587     case lir_cond_equal:        acond = Assembler::equal;        break;
1588     case lir_cond_notEqual:     acond = Assembler::notEqual;     break;
1589     case lir_cond_less:         acond = Assembler::less;         break;
1590     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    break;
1591     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; break;
1592     case lir_cond_greater:      acond = Assembler::greater;      break;
1593     case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned;      break;
1594     case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;      break;
1595     default:                         ShouldNotReachHere();
1596   };
1597 
1598   if (opr1-&gt;is_constant() &amp;&amp; opr1-&gt;type() == T_INT) {
1599     Register dest = result-&gt;as_register();
1600     // load up first part of constant before branch
1601     // and do the rest in the delay slot.
1602     if (!Assembler::is_simm13(opr1-&gt;as_jint())) {
1603       __ sethi(opr1-&gt;as_jint(), dest);
1604     }
1605   } else if (opr1-&gt;is_constant()) {
1606     const2reg(opr1, result, lir_patch_none, NULL);
1607   } else if (opr1-&gt;is_register()) {
1608     reg2reg(opr1, result);
1609   } else if (opr1-&gt;is_stack()) {
1610     stack2reg(opr1, result, result-&gt;type());
1611   } else {
1612     ShouldNotReachHere();
1613   }
1614   Label skip;
1615     if  (type == T_INT) {
1616       __ br(acond, false, Assembler::pt, skip);
1617     } else {
1618       __ brx(acond, false, Assembler::pt, skip); // checks icc on 32bit and xcc on 64bit
1619     }
1620   if (opr1-&gt;is_constant() &amp;&amp; opr1-&gt;type() == T_INT) {
1621     Register dest = result-&gt;as_register();
1622     if (Assembler::is_simm13(opr1-&gt;as_jint())) {
1623       __ delayed()-&gt;or3(G0, opr1-&gt;as_jint(), dest);
1624     } else {
1625       // the sethi has been done above, so just put in the low 10 bits
1626       __ delayed()-&gt;or3(dest, opr1-&gt;as_jint() &amp; 0x3ff, dest);
1627     }
1628   } else {
1629     // can&#39;t do anything useful in the delay slot
1630     __ delayed()-&gt;nop();
1631   }
1632   if (opr2-&gt;is_constant()) {
1633     const2reg(opr2, result, lir_patch_none, NULL);
1634   } else if (opr2-&gt;is_register()) {
1635     reg2reg(opr2, result);
1636   } else if (opr2-&gt;is_stack()) {
1637     stack2reg(opr2, result, result-&gt;type());
1638   } else {
1639     ShouldNotReachHere();
1640   }
1641   __ bind(skip);
1642 }
1643 
1644 
1645 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1646   assert(info == NULL, &quot;unused on this code path&quot;);
1647   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1648   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1649 
1650   if (right-&gt;is_register()) {
1651     if (dest-&gt;is_float_kind()) {
1652 
1653       FloatRegister lreg, rreg, res;
1654       FloatRegisterImpl::Width w;
1655       if (right-&gt;is_single_fpu()) {
1656         w = FloatRegisterImpl::S;
1657         lreg = left-&gt;as_float_reg();
1658         rreg = right-&gt;as_float_reg();
1659         res  = dest-&gt;as_float_reg();
1660       } else {
1661         w = FloatRegisterImpl::D;
1662         lreg = left-&gt;as_double_reg();
1663         rreg = right-&gt;as_double_reg();
1664         res  = dest-&gt;as_double_reg();
1665       }
1666 
1667       switch (code) {
1668         case lir_add: __ fadd(w, lreg, rreg, res); break;
1669         case lir_sub: __ fsub(w, lreg, rreg, res); break;
1670         case lir_mul: // fall through
1671         case lir_mul_strictfp: __ fmul(w, lreg, rreg, res); break;
1672         case lir_div: // fall through
1673         case lir_div_strictfp: __ fdiv(w, lreg, rreg, res); break;
1674         default: ShouldNotReachHere();
1675       }
1676 
1677     } else if (dest-&gt;is_double_cpu()) {
1678       Register dst_lo = dest-&gt;as_register_lo();
1679       Register op1_lo = left-&gt;as_pointer_register();
1680       Register op2_lo = right-&gt;as_pointer_register();
1681 
1682       switch (code) {
1683         case lir_add:
1684           __ add(op1_lo, op2_lo, dst_lo);
1685           break;
1686 
1687         case lir_sub:
1688           __ sub(op1_lo, op2_lo, dst_lo);
1689           break;
1690 
1691         default: ShouldNotReachHere();
1692       }
1693     } else {
1694       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1695 
1696       Register lreg = left-&gt;as_register();
1697       Register res  = dest-&gt;as_register();
1698       Register rreg = right-&gt;as_register();
1699       switch (code) {
1700         case lir_add:  __ add  (lreg, rreg, res); break;
1701         case lir_sub:  __ sub  (lreg, rreg, res); break;
1702         case lir_mul:  __ mulx (lreg, rreg, res); break;
1703         default: ShouldNotReachHere();
1704       }
1705     }
1706   } else {
1707     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1708 
1709     if (dest-&gt;is_single_cpu()) {
1710       Register lreg = left-&gt;as_register();
1711       Register res  = dest-&gt;as_register();
1712       int    simm13 = right-&gt;as_constant_ptr()-&gt;as_jint();
1713 
1714       switch (code) {
1715         case lir_add:  __ add  (lreg, simm13, res); break;
1716         case lir_sub:  __ sub  (lreg, simm13, res); break;
1717         case lir_mul:  __ mulx (lreg, simm13, res); break;
1718         default: ShouldNotReachHere();
1719       }
1720     } else {
1721       Register lreg = left-&gt;as_pointer_register();
1722       Register res  = dest-&gt;as_register_lo();
1723       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1724       assert(Assembler::is_simm13(con), &quot;must be simm13&quot;);
1725 
1726       switch (code) {
1727         case lir_add:  __ add  (lreg, (int)con, res); break;
1728         case lir_sub:  __ sub  (lreg, (int)con, res); break;
1729         case lir_mul:  __ mulx (lreg, (int)con, res); break;
1730         default: ShouldNotReachHere();
1731       }
1732     }
1733   }
1734 }
1735 
1736 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1737   switch (code) {
1738     case lir_tan: {
1739       assert(thread-&gt;is_valid(), &quot;preserve the thread object for performance reasons&quot;);
1740       assert(dest-&gt;as_double_reg() == F0, &quot;the result will be in f0/f1&quot;);
1741       break;
1742     }
1743     case lir_sqrt: {
1744       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1745       FloatRegister src_reg = value-&gt;as_double_reg();
1746       FloatRegister dst_reg = dest-&gt;as_double_reg();
1747       __ fsqrt(FloatRegisterImpl::D, src_reg, dst_reg);
1748       break;
1749     }
1750     case lir_abs: {
1751       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1752       FloatRegister src_reg = value-&gt;as_double_reg();
1753       FloatRegister dst_reg = dest-&gt;as_double_reg();
1754       __ fabs(FloatRegisterImpl::D, src_reg, dst_reg);
1755       break;
1756     }
1757     default: {
1758       ShouldNotReachHere();
1759       break;
1760     }
1761   }
1762 }
1763 
1764 
1765 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1766   if (right-&gt;is_constant()) {
1767     if (dest-&gt;is_single_cpu()) {
1768       int simm13 = right-&gt;as_constant_ptr()-&gt;as_jint();
1769       switch (code) {
1770         case lir_logic_and:   __ and3 (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1771         case lir_logic_or:    __ or3  (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1772         case lir_logic_xor:   __ xor3 (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1773         default: ShouldNotReachHere();
1774       }
1775     } else {
1776       long c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1777       assert(c == (int)c &amp;&amp; Assembler::is_simm13(c), &quot;out of range&quot;);
1778       int simm13 = (int)c;
1779       switch (code) {
1780         case lir_logic_and:
1781           __ and3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1782           break;
1783 
1784         case lir_logic_or:
1785           __ or3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1786           break;
1787 
1788         case lir_logic_xor:
1789           __ xor3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1790           break;
1791 
1792         default: ShouldNotReachHere();
1793       }
1794     }
1795   } else {
1796     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1797 
1798     if (dest-&gt;is_single_cpu()) {
1799       switch (code) {
1800         case lir_logic_and:   __ and3 (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1801         case lir_logic_or:    __ or3  (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1802         case lir_logic_xor:   __ xor3 (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1803         default: ShouldNotReachHere();
1804       }
1805     } else {
1806       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1807                                                                         left-&gt;as_register_lo();
1808       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1809                                                                           right-&gt;as_register_lo();
1810 
1811       switch (code) {
1812         case lir_logic_and: __ and3 (l, r, dest-&gt;as_register_lo()); break;
1813         case lir_logic_or:  __ or3  (l, r, dest-&gt;as_register_lo()); break;
1814         case lir_logic_xor: __ xor3 (l, r, dest-&gt;as_register_lo()); break;
1815         default: ShouldNotReachHere();
1816       }
1817     }
1818   }
1819 }
1820 
1821 
1822 int LIR_Assembler::shift_amount(BasicType t) {
1823   int elem_size = type2aelembytes(t);
1824   switch (elem_size) {
1825     case 1 : return 0;
1826     case 2 : return 1;
1827     case 4 : return 2;
1828     case 8 : return 3;
1829   }
1830   ShouldNotReachHere();
1831   return -1;
1832 }
1833 
1834 
1835 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1836   assert(exceptionOop-&gt;as_register() == Oexception, &quot;should match&quot;);
1837   assert(exceptionPC-&gt;as_register() == Oissuing_pc, &quot;should match&quot;);
1838 
1839   info-&gt;add_register_oop(exceptionOop);
1840 
1841   // reuse the debug info from the safepoint poll for the throw op itself
1842   address pc_for_athrow  = __ pc();
1843   int pc_for_athrow_offset = __ offset();
1844   RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1845   __ set(pc_for_athrow, Oissuing_pc, rspec);
1846   add_call_info(pc_for_athrow_offset, info); // for exception handler
1847 
1848   __ call(Runtime1::entry_for(Runtime1::handle_exception_id), relocInfo::runtime_call_type);
1849   __ delayed()-&gt;nop();
1850 }
1851 
1852 
1853 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1854   assert(exceptionOop-&gt;as_register() == Oexception, &quot;should match&quot;);
1855 
1856   __ br(Assembler::always, false, Assembler::pt, _unwind_handler_entry);
1857   __ delayed()-&gt;nop();
1858 }
1859 
1860 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1861   Register src = op-&gt;src()-&gt;as_register();
1862   Register dst = op-&gt;dst()-&gt;as_register();
1863   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1864   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1865   Register length  = op-&gt;length()-&gt;as_register();
1866   Register tmp = op-&gt;tmp()-&gt;as_register();
1867   Register tmp2 = O7;
1868 
1869   int flags = op-&gt;flags();
1870   ciArrayKlass* default_type = op-&gt;expected_type();
1871   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1872   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1873 
1874   // higher 32bits must be null
1875   __ sra(dst_pos, 0, dst_pos);
1876   __ sra(src_pos, 0, src_pos);
1877   __ sra(length, 0, length);
1878 
1879   // set up the arraycopy stub information
1880   ArrayCopyStub* stub = op-&gt;stub();
1881 
1882   // always do stub if no type information is available.  it&#39;s ok if
1883   // the known type isn&#39;t loaded since the code sanity checks
1884   // in debug mode and the type isn&#39;t required when we know the exact type
1885   // also check that the type is an array type.
1886   if (op-&gt;expected_type() == NULL) {
1887     __ mov(src,     O0);
1888     __ mov(src_pos, O1);
1889     __ mov(dst,     O2);
1890     __ mov(dst_pos, O3);
1891     __ mov(length,  O4);
1892     address copyfunc_addr = StubRoutines::generic_arraycopy();
1893     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1894 
1895 #ifndef PRODUCT
1896     if (PrintC1Statistics) {
1897       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1898       __ inc_counter(counter, G1, G3);
1899     }
1900 #endif
1901     __ call_VM_leaf(tmp, copyfunc_addr);
1902 
1903     __ xor3(O0, -1, tmp);
1904     __ sub(length, tmp, length);
1905     __ add(src_pos, tmp, src_pos);
1906     __ cmp_zero_and_br(Assembler::less, O0, *stub-&gt;entry());
1907     __ delayed()-&gt;add(dst_pos, tmp, dst_pos);
1908     __ bind(*stub-&gt;continuation());
1909     return;
1910   }
1911 
1912   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1913 
1914   // make sure src and dst are non-null and load array length
1915   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1916     __ tst(src);
1917     __ brx(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
1918     __ delayed()-&gt;nop();
1919   }
1920 
1921   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1922     __ tst(dst);
1923     __ brx(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
1924     __ delayed()-&gt;nop();
1925   }
1926 
1927   // If the compiler was not able to prove that exact type of the source or the destination
1928   // of the arraycopy is an array type, check at runtime if the source or the destination is
1929   // an instance type.
1930   if (flags &amp; LIR_OpArrayCopy::type_check) {
1931     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
1932       __ load_klass(dst, tmp);
1933       __ lduw(tmp, in_bytes(Klass::layout_helper_offset()), tmp2);
1934       __ cmp(tmp2, Klass::_lh_neutral_value);
1935       __ br(Assembler::greaterEqual, false, Assembler::pn, *stub-&gt;entry());
1936       __ delayed()-&gt;nop();
1937     }
1938 
1939     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
1940       __ load_klass(src, tmp);
1941       __ lduw(tmp, in_bytes(Klass::layout_helper_offset()), tmp2);
1942       __ cmp(tmp2, Klass::_lh_neutral_value);
1943       __ br(Assembler::greaterEqual, false, Assembler::pn, *stub-&gt;entry());
1944       __ delayed()-&gt;nop();
1945     }
1946   }
1947 
1948   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1949     // test src_pos register
1950     __ cmp_zero_and_br(Assembler::less, src_pos, *stub-&gt;entry());
1951     __ delayed()-&gt;nop();
1952   }
1953 
1954   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1955     // test dst_pos register
1956     __ cmp_zero_and_br(Assembler::less, dst_pos, *stub-&gt;entry());
1957     __ delayed()-&gt;nop();
1958   }
1959 
1960   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1961     // make sure length isn&#39;t negative
1962     __ cmp_zero_and_br(Assembler::less, length, *stub-&gt;entry());
1963     __ delayed()-&gt;nop();
1964   }
1965 
1966   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1967     __ ld(src, arrayOopDesc::length_offset_in_bytes(), tmp2);
1968     __ add(length, src_pos, tmp);
1969     __ cmp(tmp2, tmp);
1970     __ br(Assembler::carrySet, false, Assembler::pn, *stub-&gt;entry());
1971     __ delayed()-&gt;nop();
1972   }
1973 
1974   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1975     __ ld(dst, arrayOopDesc::length_offset_in_bytes(), tmp2);
1976     __ add(length, dst_pos, tmp);
1977     __ cmp(tmp2, tmp);
1978     __ br(Assembler::carrySet, false, Assembler::pn, *stub-&gt;entry());
1979     __ delayed()-&gt;nop();
1980   }
1981 
1982   int shift = shift_amount(basic_type);
1983 
1984   if (flags &amp; LIR_OpArrayCopy::type_check) {
1985     // We don&#39;t know the array types are compatible
1986     if (basic_type != T_OBJECT) {
1987       // Simple test for basic type arrays
1988       if (UseCompressedClassPointers) {
1989         // We don&#39;t need decode because we just need to compare
1990         __ lduw(src, oopDesc::klass_offset_in_bytes(), tmp);
1991         __ lduw(dst, oopDesc::klass_offset_in_bytes(), tmp2);
1992         __ cmp(tmp, tmp2);
1993         __ br(Assembler::notEqual, false, Assembler::pt, *stub-&gt;entry());
1994       } else {
1995         __ ld_ptr(src, oopDesc::klass_offset_in_bytes(), tmp);
1996         __ ld_ptr(dst, oopDesc::klass_offset_in_bytes(), tmp2);
1997         __ cmp(tmp, tmp2);
1998         __ brx(Assembler::notEqual, false, Assembler::pt, *stub-&gt;entry());
1999       }
2000       __ delayed()-&gt;nop();
2001     } else {
2002       // For object arrays, if src is a sub class of dst then we can
2003       // safely do the copy.
2004       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2005 
2006       Label cont, slow;
2007       assert_different_registers(tmp, tmp2, G3, G1);
2008 
2009       __ load_klass(src, G3);
2010       __ load_klass(dst, G1);
2011 
2012       __ check_klass_subtype_fast_path(G3, G1, tmp, tmp2, &amp;cont, copyfunc_addr == NULL ? stub-&gt;entry() : &amp;slow, NULL);
2013 
2014       __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2015       __ delayed()-&gt;nop();
2016 
2017       __ cmp(G3, 0);
2018       if (copyfunc_addr != NULL) { // use stub if available
2019         // src is not a sub class of dst so we have to do a
2020         // per-element check.
2021         __ br(Assembler::notEqual, false, Assembler::pt, cont);
2022         __ delayed()-&gt;nop();
2023 
2024         __ bind(slow);
2025 
2026         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2027         if ((flags &amp; mask) != mask) {
2028           // Check that at least both of them object arrays.
2029           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2030 
2031           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2032             __ load_klass(src, tmp);
2033           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2034             __ load_klass(dst, tmp);
2035           }
2036           int lh_offset = in_bytes(Klass::layout_helper_offset());
2037 
2038           __ lduw(tmp, lh_offset, tmp2);
2039 
2040           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2041           __ set(objArray_lh, tmp);
2042           __ cmp(tmp, tmp2);
2043           __ br(Assembler::notEqual, false, Assembler::pt,  *stub-&gt;entry());
2044           __ delayed()-&gt;nop();
2045         }
2046 
2047         Register src_ptr = O0;
2048         Register dst_ptr = O1;
2049         Register len     = O2;
2050         Register chk_off = O3;
2051         Register super_k = O4;
2052 
2053         __ add(src, arrayOopDesc::base_offset_in_bytes(basic_type), src_ptr);
2054         if (shift == 0) {
2055           __ add(src_ptr, src_pos, src_ptr);
2056         } else {
2057           __ sll(src_pos, shift, tmp);
2058           __ add(src_ptr, tmp, src_ptr);
2059         }
2060 
2061         __ add(dst, arrayOopDesc::base_offset_in_bytes(basic_type), dst_ptr);
2062         if (shift == 0) {
2063           __ add(dst_ptr, dst_pos, dst_ptr);
2064         } else {
2065           __ sll(dst_pos, shift, tmp);
2066           __ add(dst_ptr, tmp, dst_ptr);
2067         }
2068         __ mov(length, len);
2069         __ load_klass(dst, tmp);
2070 
2071         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2072         __ ld_ptr(tmp, ek_offset, super_k);
2073 
2074         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2075         __ lduw(super_k, sco_offset, chk_off);
2076 
2077         __ call_VM_leaf(tmp, copyfunc_addr);
2078 
2079 #ifndef PRODUCT
2080         if (PrintC1Statistics) {
2081           Label failed;
2082           __ br_notnull_short(O0, Assembler::pn, failed);
2083           __ inc_counter((address)&amp;Runtime1::_arraycopy_checkcast_cnt, G1, G3);
2084           __ bind(failed);
2085         }
2086 #endif
2087 
2088         __ br_null(O0, false, Assembler::pt,  *stub-&gt;continuation());
2089         __ delayed()-&gt;xor3(O0, -1, tmp);
2090 
2091 #ifndef PRODUCT
2092         if (PrintC1Statistics) {
2093           __ inc_counter((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt, G1, G3);
2094         }
2095 #endif
2096 
2097         __ sub(length, tmp, length);
2098         __ add(src_pos, tmp, src_pos);
2099         __ br(Assembler::always, false, Assembler::pt, *stub-&gt;entry());
2100         __ delayed()-&gt;add(dst_pos, tmp, dst_pos);
2101 
2102         __ bind(cont);
2103       } else {
2104         __ br(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
2105         __ delayed()-&gt;nop();
2106         __ bind(cont);
2107       }
2108     }
2109   }
2110 
2111 #ifdef ASSERT
2112   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2113     // Sanity check the known type with the incoming class.  For the
2114     // primitive case the types must match exactly with src.klass and
2115     // dst.klass each exactly matching the default type.  For the
2116     // object array case, if no type check is needed then either the
2117     // dst type is exactly the expected type and the src type is a
2118     // subtype which we can&#39;t check or src is the same array as dst
2119     // but not necessarily exactly of type default_type.
2120     Label known_ok, halt;
2121     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2122     if (UseCompressedClassPointers) {
2123       // tmp holds the default type. It currently comes uncompressed after the
2124       // load of a constant, so encode it.
2125       __ encode_klass_not_null(tmp);
2126       // load the raw value of the dst klass, since we will be comparing
2127       // uncompressed values directly.
2128       __ lduw(dst, oopDesc::klass_offset_in_bytes(), tmp2);
2129       if (basic_type != T_OBJECT) {
2130         __ cmp(tmp, tmp2);
2131         __ br(Assembler::notEqual, false, Assembler::pn, halt);
2132         // load the raw value of the src klass.
2133         __ delayed()-&gt;lduw(src, oopDesc::klass_offset_in_bytes(), tmp2);
2134         __ cmp_and_br_short(tmp, tmp2, Assembler::equal, Assembler::pn, known_ok);
2135       } else {
2136         __ cmp(tmp, tmp2);
2137         __ br(Assembler::equal, false, Assembler::pn, known_ok);
2138         __ delayed()-&gt;cmp(src, dst);
2139         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2140         __ delayed()-&gt;nop();
2141       }
2142     } else {
2143       __ ld_ptr(dst, oopDesc::klass_offset_in_bytes(), tmp2);
2144       if (basic_type != T_OBJECT) {
2145         __ cmp(tmp, tmp2);
2146         __ brx(Assembler::notEqual, false, Assembler::pn, halt);
2147         __ delayed()-&gt;ld_ptr(src, oopDesc::klass_offset_in_bytes(), tmp2);
2148         __ cmp_and_brx_short(tmp, tmp2, Assembler::equal, Assembler::pn, known_ok);
2149       } else {
2150         __ cmp(tmp, tmp2);
2151         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2152         __ delayed()-&gt;cmp(src, dst);
2153         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2154         __ delayed()-&gt;nop();
2155       }
2156     }
2157     __ bind(halt);
2158     __ stop(&quot;incorrect type information in arraycopy&quot;);
2159     __ bind(known_ok);
2160   }
2161 #endif
2162 
2163 #ifndef PRODUCT
2164   if (PrintC1Statistics) {
2165     address counter = Runtime1::arraycopy_count_address(basic_type);
2166     __ inc_counter(counter, G1, G3);
2167   }
2168 #endif
2169 
2170   Register src_ptr = O0;
2171   Register dst_ptr = O1;
2172   Register len     = O2;
2173 
2174   __ add(src, arrayOopDesc::base_offset_in_bytes(basic_type), src_ptr);
2175   if (shift == 0) {
2176     __ add(src_ptr, src_pos, src_ptr);
2177   } else {
2178     __ sll(src_pos, shift, tmp);
2179     __ add(src_ptr, tmp, src_ptr);
2180   }
2181 
2182   __ add(dst, arrayOopDesc::base_offset_in_bytes(basic_type), dst_ptr);
2183   if (shift == 0) {
2184     __ add(dst_ptr, dst_pos, dst_ptr);
2185   } else {
2186     __ sll(dst_pos, shift, tmp);
2187     __ add(dst_ptr, tmp, dst_ptr);
2188   }
2189 
2190   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2191   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2192   const char *name;
2193   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2194 
2195   // arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2196   __ mov(length, len);
2197   __ call_VM_leaf(tmp, entry);
2198 
2199   __ bind(*stub-&gt;continuation());
2200 }
2201 
2202 
2203 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2204   if (dest-&gt;is_single_cpu()) {
2205     if (left-&gt;type() == T_OBJECT) {
2206       switch (code) {
2207         case lir_shl:  __ sllx  (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2208         case lir_shr:  __ srax  (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2209         case lir_ushr: __ srl   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2210         default: ShouldNotReachHere();
2211       }
2212     } else
2213       switch (code) {
2214         case lir_shl:  __ sll   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2215         case lir_shr:  __ sra   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2216         case lir_ushr: __ srl   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2217         default: ShouldNotReachHere();
2218       }
2219   } else {
2220     switch (code) {
2221       case lir_shl:  __ sllx  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2222       case lir_shr:  __ srax  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2223       case lir_ushr: __ srlx  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2224       default: ShouldNotReachHere();
2225     }
2226   }
2227 }
2228 
2229 
2230 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2231   if (left-&gt;type() == T_OBJECT) {
2232     count = count &amp; 63;  // shouldn&#39;t shift by more than sizeof(intptr_t)
2233     Register l = left-&gt;as_register();
2234     Register d = dest-&gt;as_register_lo();
2235     switch (code) {
2236       case lir_shl:  __ sllx  (l, count, d); break;
2237       case lir_shr:  __ srax  (l, count, d); break;
2238       case lir_ushr: __ srlx  (l, count, d); break;
2239       default: ShouldNotReachHere();
2240     }
2241     return;
2242   }
2243 
2244   if (dest-&gt;is_single_cpu()) {
2245     count = count &amp; 0x1F; // Java spec
2246     switch (code) {
2247       case lir_shl:  __ sll   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2248       case lir_shr:  __ sra   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2249       case lir_ushr: __ srl   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2250       default: ShouldNotReachHere();
2251     }
2252   } else if (dest-&gt;is_double_cpu()) {
2253     count = count &amp; 63; // Java spec
2254     switch (code) {
2255       case lir_shl:  __ sllx  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2256       case lir_shr:  __ srax  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2257       case lir_ushr: __ srlx  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2258       default: ShouldNotReachHere();
2259     }
2260   } else {
2261     ShouldNotReachHere();
2262   }
2263 }
2264 
2265 
2266 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2267   assert(op-&gt;tmp1()-&gt;as_register()  == G1 &amp;&amp;
2268          op-&gt;tmp2()-&gt;as_register()  == G3 &amp;&amp;
2269          op-&gt;tmp3()-&gt;as_register()  == G4 &amp;&amp;
2270          op-&gt;obj()-&gt;as_register()   == O0 &amp;&amp;
2271          op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
2272   if (op-&gt;init_check()) {
2273     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2274     __ ldub(op-&gt;klass()-&gt;as_register(),
2275           in_bytes(InstanceKlass::init_state_offset()),
2276           op-&gt;tmp1()-&gt;as_register());
2277     __ cmp(op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2278     __ br(Assembler::notEqual, false, Assembler::pn, *op-&gt;stub()-&gt;entry());
2279     __ delayed()-&gt;nop();
2280   }
2281   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2282                      op-&gt;tmp1()-&gt;as_register(),
2283                      op-&gt;tmp2()-&gt;as_register(),
2284                      op-&gt;tmp3()-&gt;as_register(),
2285                      op-&gt;header_size(),
2286                      op-&gt;object_size(),
2287                      op-&gt;klass()-&gt;as_register(),
2288                      *op-&gt;stub()-&gt;entry());
2289   __ bind(*op-&gt;stub()-&gt;continuation());
2290   __ verify_oop(op-&gt;obj()-&gt;as_register());
2291 }
2292 
2293 
2294 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2295   assert(op-&gt;tmp1()-&gt;as_register()  == G1 &amp;&amp;
2296          op-&gt;tmp2()-&gt;as_register()  == G3 &amp;&amp;
2297          op-&gt;tmp3()-&gt;as_register()  == G4 &amp;&amp;
2298          op-&gt;tmp4()-&gt;as_register()  == O1 &amp;&amp;
2299          op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
2300 
2301   __ signx(op-&gt;len()-&gt;as_register());
2302   if (UseSlowPath ||
2303       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
2304       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
2305     __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2306     __ delayed()-&gt;nop();
2307   } else {
2308     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2309                       op-&gt;len()-&gt;as_register(),
2310                       op-&gt;tmp1()-&gt;as_register(),
2311                       op-&gt;tmp2()-&gt;as_register(),
2312                       op-&gt;tmp3()-&gt;as_register(),
2313                       arrayOopDesc::header_size(op-&gt;type()),
2314                       type2aelembytes(op-&gt;type()),
2315                       op-&gt;klass()-&gt;as_register(),
2316                       *op-&gt;stub()-&gt;entry());
2317   }
2318   __ bind(*op-&gt;stub()-&gt;continuation());
2319 }
2320 
2321 
2322 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2323                                         ciMethodData *md, ciProfileData *data,
2324                                         Register recv, Register tmp1, Label* update_done) {
2325   uint i;
2326   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2327     Label next_test;
2328     // See if the receiver is receiver[n].
2329     Address receiver_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) -
2330                           mdo_offset_bias);
2331     __ ld_ptr(receiver_addr, tmp1);
2332     __ verify_klass_ptr(tmp1);
2333     __ cmp_and_brx_short(recv, tmp1, Assembler::notEqual, Assembler::pt, next_test);
2334     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) -
2335                       mdo_offset_bias);
2336     __ ld_ptr(data_addr, tmp1);
2337     __ add(tmp1, DataLayout::counter_increment, tmp1);
2338     __ st_ptr(tmp1, data_addr);
2339     __ ba(*update_done);
2340     __ delayed()-&gt;nop();
2341     __ bind(next_test);
2342   }
2343 
2344   // Didn&#39;t find receiver; find next empty slot and fill it in
2345   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2346     Label next_test;
2347     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) -
2348                       mdo_offset_bias);
2349     __ ld_ptr(recv_addr, tmp1);
2350     __ br_notnull_short(tmp1, Assembler::pt, next_test);
2351     __ st_ptr(recv, recv_addr);
2352     __ set(DataLayout::counter_increment, tmp1);
2353     __ st_ptr(tmp1, mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) -
2354               mdo_offset_bias);
2355     __ ba(*update_done);
2356     __ delayed()-&gt;nop();
2357     __ bind(next_test);
2358   }
2359 }
2360 
2361 
2362 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2363                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2364   md = method-&gt;method_data_or_null();
2365   assert(md != NULL, &quot;Sanity&quot;);
2366   data = md-&gt;bci_to_data(bci);
2367   assert(data != NULL,       &quot;need data for checkcast&quot;);
2368   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2369   if (!Assembler::is_simm13(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2370     // The offset is large so bias the mdo by the base of the slot so
2371     // that the ld can use simm13s to reference the slots of the data
2372     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2373   }
2374 }
2375 
2376 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2377   // we always need a stub for the failure case.
2378   CodeStub* stub = op-&gt;stub();
2379   Register obj = op-&gt;object()-&gt;as_register();
2380   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2381   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2382   Register dst = op-&gt;result_opr()-&gt;as_register();
2383   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2384   ciKlass* k = op-&gt;klass();
2385 
2386 
2387   if (obj == k_RInfo) {
2388     k_RInfo = klass_RInfo;
2389     klass_RInfo = obj;
2390   }
2391 
2392   ciMethodData* md;
2393   ciProfileData* data;
2394   int mdo_offset_bias = 0;
2395   if (op-&gt;should_profile()) {
2396     ciMethod* method = op-&gt;profiled_method();
2397     assert(method != NULL, &quot;Should have method&quot;);
2398     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2399 
2400     Label not_null;
2401     __ br_notnull_short(obj, Assembler::pn, not_null);
2402     Register mdo      = k_RInfo;
2403     Register data_val = Rtmp1;
2404     metadata2reg(md-&gt;constant_encoding(), mdo);
2405     if (mdo_offset_bias &gt; 0) {
2406       __ set(mdo_offset_bias, data_val);
2407       __ add(mdo, data_val, mdo);
2408     }
2409     Address flags_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias);
2410     __ ldub(flags_addr, data_val);
2411     __ or3(data_val, BitData::null_seen_byte_constant(), data_val);
2412     __ stb(data_val, flags_addr);
2413     __ ba(*obj_is_null);
2414     __ delayed()-&gt;nop();
2415     __ bind(not_null);
2416   } else {
2417     __ br_null(obj, false, Assembler::pn, *obj_is_null);
2418     __ delayed()-&gt;nop();
2419   }
2420 
2421   Label profile_cast_failure, profile_cast_success;
2422   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2423   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2424 
2425   // patching may screw with our temporaries on sparc,
2426   // so let&#39;s do it before loading the class
2427   if (k-&gt;is_loaded()) {
2428     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2429   } else {
2430     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2431   }
2432   assert(obj != k_RInfo, &quot;must be different&quot;);
2433 
2434   // get object class
2435   // not a safepoint as obj null check happens earlier
2436   __ load_klass(obj, klass_RInfo);
2437   if (op-&gt;fast_check()) {
2438     assert_different_registers(klass_RInfo, k_RInfo);
2439     __ cmp(k_RInfo, klass_RInfo);
2440     __ brx(Assembler::notEqual, false, Assembler::pt, *failure_target);
2441     __ delayed()-&gt;nop();
2442   } else {
2443     bool need_slow_path = true;
2444     if (k-&gt;is_loaded()) {
2445       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset()))
2446         need_slow_path = false;
2447       // perform the fast part of the checking logic
2448       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, noreg,
2449                                        (need_slow_path ? success_target : NULL),
2450                                        failure_target, NULL,
2451                                        RegisterOrConstant(k-&gt;super_check_offset()));
2452     } else {
2453       // perform the fast part of the checking logic
2454       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, O7, success_target,
2455                                        failure_target, NULL);
2456     }
2457     if (need_slow_path) {
2458       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
2459       assert(klass_RInfo == G3 &amp;&amp; k_RInfo == G1, &quot;incorrect call setup&quot;);
2460       __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2461       __ delayed()-&gt;nop();
2462       __ cmp(G3, 0);
2463       __ br(Assembler::equal, false, Assembler::pn, *failure_target);
2464       __ delayed()-&gt;nop();
2465       // Fall through to success case
2466     }
2467   }
2468 
2469   if (op-&gt;should_profile()) {
2470     Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2471     assert_different_registers(obj, mdo, recv, tmp1);
2472     __ bind(profile_cast_success);
2473     metadata2reg(md-&gt;constant_encoding(), mdo);
2474     if (mdo_offset_bias &gt; 0) {
2475       __ set(mdo_offset_bias, tmp1);
2476       __ add(mdo, tmp1, mdo);
2477     }
2478     __ load_klass(obj, recv);
2479     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, success);
2480     // Jump over the failure case
2481     __ ba(*success);
2482     __ delayed()-&gt;nop();
2483     // Cast failure case
2484     __ bind(profile_cast_failure);
2485     metadata2reg(md-&gt;constant_encoding(), mdo);
2486     if (mdo_offset_bias &gt; 0) {
2487       __ set(mdo_offset_bias, tmp1);
2488       __ add(mdo, tmp1, mdo);
2489     }
2490     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2491     __ ld_ptr(data_addr, tmp1);
2492     __ sub(tmp1, DataLayout::counter_increment, tmp1);
2493     __ st_ptr(tmp1, data_addr);
2494     __ ba(*failure);
2495     __ delayed()-&gt;nop();
2496   }
2497   __ ba(*success);
2498   __ delayed()-&gt;nop();
2499 }
2500 
2501 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2502   LIR_Code code = op-&gt;code();
2503   if (code == lir_store_check) {
2504     Register value = op-&gt;object()-&gt;as_register();
2505     Register array = op-&gt;array()-&gt;as_register();
2506     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2507     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2508     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2509 
2510     __ verify_oop(value);
2511     CodeStub* stub = op-&gt;stub();
2512     // check if it needs to be profiled
2513     ciMethodData* md;
2514     ciProfileData* data;
2515     int mdo_offset_bias = 0;
2516     if (op-&gt;should_profile()) {
2517       ciMethod* method = op-&gt;profiled_method();
2518       assert(method != NULL, &quot;Should have method&quot;);
2519       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2520     }
2521     Label profile_cast_success, profile_cast_failure, done;
2522     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
2523     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
2524 
2525     if (op-&gt;should_profile()) {
2526       Label not_null;
2527       __ br_notnull_short(value, Assembler::pn, not_null);
2528       Register mdo      = k_RInfo;
2529       Register data_val = Rtmp1;
2530       metadata2reg(md-&gt;constant_encoding(), mdo);
2531       if (mdo_offset_bias &gt; 0) {
2532         __ set(mdo_offset_bias, data_val);
2533         __ add(mdo, data_val, mdo);
2534       }
2535       Address flags_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias);
2536       __ ldub(flags_addr, data_val);
2537       __ or3(data_val, BitData::null_seen_byte_constant(), data_val);
2538       __ stb(data_val, flags_addr);
2539       __ ba_short(done);
2540       __ bind(not_null);
2541     } else {
2542       __ br_null_short(value, Assembler::pn, done);
2543     }
2544     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2545     __ load_klass(array, k_RInfo);
2546     __ load_klass(value, klass_RInfo);
2547 
2548     // get instance klass
2549     __ ld_ptr(Address(k_RInfo, ObjArrayKlass::element_klass_offset()), k_RInfo);
2550     // perform the fast part of the checking logic
2551     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, O7, success_target, failure_target, NULL);
2552 
2553     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
2554     assert(klass_RInfo == G3 &amp;&amp; k_RInfo == G1, &quot;incorrect call setup&quot;);
2555     __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2556     __ delayed()-&gt;nop();
2557     __ cmp(G3, 0);
2558     __ br(Assembler::equal, false, Assembler::pn, *failure_target);
2559     __ delayed()-&gt;nop();
2560     // fall through to the success case
2561 
2562     if (op-&gt;should_profile()) {
2563       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2564       assert_different_registers(value, mdo, recv, tmp1);
2565       __ bind(profile_cast_success);
2566       metadata2reg(md-&gt;constant_encoding(), mdo);
2567       if (mdo_offset_bias &gt; 0) {
2568         __ set(mdo_offset_bias, tmp1);
2569         __ add(mdo, tmp1, mdo);
2570       }
2571       __ load_klass(value, recv);
2572       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2573       __ ba_short(done);
2574       // Cast failure case
2575       __ bind(profile_cast_failure);
2576       metadata2reg(md-&gt;constant_encoding(), mdo);
2577       if (mdo_offset_bias &gt; 0) {
2578         __ set(mdo_offset_bias, tmp1);
2579         __ add(mdo, tmp1, mdo);
2580       }
2581       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2582       __ ld_ptr(data_addr, tmp1);
2583       __ sub(tmp1, DataLayout::counter_increment, tmp1);
2584       __ st_ptr(tmp1, data_addr);
2585       __ ba(*stub-&gt;entry());
2586       __ delayed()-&gt;nop();
2587     }
2588     __ bind(done);
2589   } else if (code == lir_checkcast) {
2590     Register obj = op-&gt;object()-&gt;as_register();
2591     Register dst = op-&gt;result_opr()-&gt;as_register();
2592     Label success;
2593     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2594     __ bind(success);
2595     __ mov(obj, dst);
2596   } else if (code == lir_instanceof) {
2597     Register obj = op-&gt;object()-&gt;as_register();
2598     Register dst = op-&gt;result_opr()-&gt;as_register();
2599     Label success, failure, done;
2600     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2601     __ bind(failure);
2602     __ set(0, dst);
2603     __ ba_short(done);
2604     __ bind(success);
2605     __ set(1, dst);
2606     __ bind(done);
2607   } else {
2608     ShouldNotReachHere();
2609   }
2610 
2611 }
2612 
2613 
2614 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2615   if (op-&gt;code() == lir_cas_long) {
2616     assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
2617     Register addr = op-&gt;addr()-&gt;as_pointer_register();
2618     Register cmp_value_lo = op-&gt;cmp_value()-&gt;as_register_lo();
2619     Register cmp_value_hi = op-&gt;cmp_value()-&gt;as_register_hi();
2620     Register new_value_lo = op-&gt;new_value()-&gt;as_register_lo();
2621     Register new_value_hi = op-&gt;new_value()-&gt;as_register_hi();
2622     Register t1 = op-&gt;tmp1()-&gt;as_register();
2623     Register t2 = op-&gt;tmp2()-&gt;as_register();
2624     __ mov(cmp_value_lo, t1);
2625     __ mov(new_value_lo, t2);
2626     // perform the compare and swap operation
2627     __ casx(addr, t1, t2);
2628     // generate condition code - if the swap succeeded, t2 (&quot;new value&quot; reg) was
2629     // overwritten with the original value in &quot;addr&quot; and will be equal to t1.
2630     __ cmp(t1, t2);
2631   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2632     Register addr = op-&gt;addr()-&gt;as_pointer_register();
2633     Register cmp_value = op-&gt;cmp_value()-&gt;as_register();
2634     Register new_value = op-&gt;new_value()-&gt;as_register();
2635     Register t1 = op-&gt;tmp1()-&gt;as_register();
2636     Register t2 = op-&gt;tmp2()-&gt;as_register();
2637     __ mov(cmp_value, t1);
2638     __ mov(new_value, t2);
2639     if (op-&gt;code() == lir_cas_obj) {
2640       if (UseCompressedOops) {
2641         __ encode_heap_oop(t1);
2642         __ encode_heap_oop(t2);
2643         __ cas(addr, t1, t2);
2644       } else {
2645         __ cas_ptr(addr, t1, t2);
2646       }
2647     } else {
2648       __ cas(addr, t1, t2);
2649     }
2650     __ cmp(t1, t2);
2651   } else {
2652     Unimplemented();
2653   }
2654 }
2655 
2656 void LIR_Assembler::breakpoint() {
2657   __ breakpoint_trap();
2658 }
2659 
2660 
2661 void LIR_Assembler::push(LIR_Opr opr) {
2662   Unimplemented();
2663 }
2664 
2665 
2666 void LIR_Assembler::pop(LIR_Opr opr) {
2667   Unimplemented();
2668 }
2669 
2670 
2671 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2672   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2673   Register dst = dst_opr-&gt;as_register();
2674   Register reg = mon_addr.base();
2675   int offset = mon_addr.disp();
2676   // compute pointer to BasicLock
2677   if (mon_addr.is_simm13()) {
2678     __ add(reg, offset, dst);
2679   } else {
2680     __ set(offset, dst);
2681     __ add(dst, reg, dst);
2682   }
2683 }
2684 
2685 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2686   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2687   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2688   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2689   Register crc = op-&gt;crc()-&gt;as_register();
2690   Register val = op-&gt;val()-&gt;as_register();
2691   Register table = op-&gt;result_opr()-&gt;as_register();
2692   Register res   = op-&gt;result_opr()-&gt;as_register();
2693 
2694   assert_different_registers(val, crc, table);
2695 
2696   __ set(ExternalAddress(StubRoutines::crc_table_addr()), table);
2697   __ not1(crc);
2698   __ clruwu(crc);
2699   __ update_byte_crc32(crc, val, table);
2700   __ not1(crc);
2701 
2702   __ mov(crc, res);
2703 }
2704 
2705 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2706   Register obj = op-&gt;obj_opr()-&gt;as_register();
2707   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2708   Register lock = op-&gt;lock_opr()-&gt;as_register();
2709 
2710   // obj may not be an oop
2711   if (op-&gt;code() == lir_lock) {
2712     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2713     if (UseFastLocking) {
2714       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2715       // add debug info for NullPointerException only if one is possible
2716       if (op-&gt;info() != NULL) {
2717         add_debug_info_for_null_check_here(op-&gt;info());
2718       }
2719       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2720     } else {
2721       // always do slow locking
2722       // note: the slow locking code could be inlined here, however if we use
2723       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2724       //       simpler and requires less duplicated code - additionally, the
2725       //       slow locking code is the same in either case which simplifies
2726       //       debugging
2727       __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2728       __ delayed()-&gt;nop();
2729     }
2730   } else {
2731     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2732     if (UseFastLocking) {
2733       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2734       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2735     } else {
2736       // always do slow unlocking
2737       // note: the slow unlocking code could be inlined here, however if we use
2738       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2739       //       simpler and requires less duplicated code - additionally, the
2740       //       slow unlocking code is the same in either case which simplifies
2741       //       debugging
2742       __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2743       __ delayed()-&gt;nop();
2744     }
2745   }
2746   __ bind(*op-&gt;stub()-&gt;continuation());
2747 }
2748 
2749 
2750 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2751   ciMethod* method = op-&gt;profiled_method();
2752   int bci          = op-&gt;profiled_bci();
2753   ciMethod* callee = op-&gt;profiled_callee();
2754 
2755   // Update counter for all call types
2756   ciMethodData* md = method-&gt;method_data_or_null();
2757   assert(md != NULL, &quot;Sanity&quot;);
2758   ciProfileData* data = md-&gt;bci_to_data(bci);
2759   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2760   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2761   Register mdo  = op-&gt;mdo()-&gt;as_register();
2762   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2763   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2764   metadata2reg(md-&gt;constant_encoding(), mdo);
2765   int mdo_offset_bias = 0;
2766   if (!Assembler::is_simm13(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2767                             data-&gt;size_in_bytes())) {
2768     // The offset is large so bias the mdo by the base of the slot so
2769     // that the ld can use simm13s to reference the slots of the data
2770     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2771     __ set(mdo_offset_bias, O7);
2772     __ add(mdo, O7, mdo);
2773   }
2774 
2775   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2776   // Perform additional virtual call profiling for invokevirtual and
2777   // invokeinterface bytecodes
2778   if (op-&gt;should_profile_receiver_type()) {
2779     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2780     Register recv = op-&gt;recv()-&gt;as_register();
2781     assert_different_registers(mdo, tmp1, recv);
2782     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2783     ciKlass* known_klass = op-&gt;known_holder();
2784     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2785       // We know the type that will be seen at this call site; we can
2786       // statically update the MethodData* rather than needing to do
2787       // dynamic tests on the receiver type
2788 
2789       // NOTE: we should probably put a lock around this search to
2790       // avoid collisions by concurrent compilations
2791       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2792       uint i;
2793       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2794         ciKlass* receiver = vc_data-&gt;receiver(i);
2795         if (known_klass-&gt;equals(receiver)) {
2796           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data,
2797                                                          VirtualCallData::receiver_count_offset(i)) -
2798                             mdo_offset_bias);
2799           __ ld_ptr(data_addr, tmp1);
2800           __ add(tmp1, DataLayout::counter_increment, tmp1);
2801           __ st_ptr(tmp1, data_addr);
2802           return;
2803         }
2804       }
2805 
2806       // Receiver type not found in profile data; select an empty slot
2807 
2808       // Note that this is less efficient than it should be because it
2809       // always does a write to the receiver part of the
2810       // VirtualCallData rather than just the first time
2811       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2812         ciKlass* receiver = vc_data-&gt;receiver(i);
2813         if (receiver == NULL) {
2814           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) -
2815                             mdo_offset_bias);
2816           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2817           __ st_ptr(tmp1, recv_addr);
2818           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) -
2819                             mdo_offset_bias);
2820           __ ld_ptr(data_addr, tmp1);
2821           __ add(tmp1, DataLayout::counter_increment, tmp1);
2822           __ st_ptr(tmp1, data_addr);
2823           return;
2824         }
2825       }
2826     } else {
2827       __ load_klass(recv, recv);
2828       Label update_done;
2829       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2830       // Receiver did not match any saved receiver and there is no empty row for it.
2831       // Increment total counter to indicate polymorphic case.
2832       __ ld_ptr(counter_addr, tmp1);
2833       __ add(tmp1, DataLayout::counter_increment, tmp1);
2834       __ st_ptr(tmp1, counter_addr);
2835 
2836       __ bind(update_done);
2837     }
2838   } else {
2839     // Static call
2840     __ ld_ptr(counter_addr, tmp1);
2841     __ add(tmp1, DataLayout::counter_increment, tmp1);
2842     __ st_ptr(tmp1, counter_addr);
2843   }
2844 }
2845 
2846 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2847   Register obj = op-&gt;obj()-&gt;as_register();
2848   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2849   Register tmp2 = G1;
2850   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2851   ciKlass* exact_klass = op-&gt;exact_klass();
2852   intptr_t current_klass = op-&gt;current_klass();
2853   bool not_null = op-&gt;not_null();
2854   bool no_conflict = op-&gt;no_conflict();
2855 
2856   Label update, next, none;
2857 
2858   bool do_null = !not_null;
2859   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2860   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2861 
2862   assert(do_null || do_update, &quot;why are we here?&quot;);
2863   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2864 
2865   __ verify_oop(obj);
2866 
2867   if (tmp1 != obj) {
2868     __ mov(obj, tmp1);
2869   }
2870   if (do_null) {
2871     __ br_notnull_short(tmp1, Assembler::pt, update);
2872     if (!TypeEntries::was_null_seen(current_klass)) {
2873       __ ld_ptr(mdo_addr, tmp1);
2874       __ or3(tmp1, TypeEntries::null_seen, tmp1);
2875       __ st_ptr(tmp1, mdo_addr);
2876     }
2877     if (do_update) {
2878       __ ba(next);
2879       __ delayed()-&gt;nop();
2880     }
2881 #ifdef ASSERT
2882   } else {
2883     __ br_notnull_short(tmp1, Assembler::pt, update);
2884     __ stop(&quot;unexpect null obj&quot;);
2885 #endif
2886   }
2887 
2888   __ bind(update);
2889 
2890   if (do_update) {
2891 #ifdef ASSERT
2892     if (exact_klass != NULL) {
2893       Label ok;
2894       __ load_klass(tmp1, tmp1);
2895       metadata2reg(exact_klass-&gt;constant_encoding(), tmp2);
2896       __ cmp_and_br_short(tmp1, tmp2, Assembler::equal, Assembler::pt, ok);
2897       __ stop(&quot;exact klass and actual klass differ&quot;);
2898       __ bind(ok);
2899     }
2900 #endif
2901 
2902     Label do_update;
2903     __ ld_ptr(mdo_addr, tmp2);
2904 
2905     if (!no_conflict) {
2906       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2907         if (exact_klass != NULL) {
2908           metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
2909         } else {
2910           __ load_klass(tmp1, tmp1);
2911         }
2912 
2913         __ xor3(tmp1, tmp2, tmp1);
2914         __ btst(TypeEntries::type_klass_mask, tmp1);
2915         // klass seen before, nothing to do. The unknown bit may have been
2916         // set already but no need to check.
2917         __ brx(Assembler::zero, false, Assembler::pt, next);
2918         __ delayed()-&gt;
2919 
2920            btst(TypeEntries::type_unknown, tmp1);
2921         // already unknown. Nothing to do anymore.
2922         __ brx(Assembler::notZero, false, Assembler::pt, next);
2923 
2924         if (TypeEntries::is_type_none(current_klass)) {
2925           __ delayed()-&gt;btst(TypeEntries::type_mask, tmp2);
2926           __ brx(Assembler::zero, true, Assembler::pt, do_update);
2927           // first time here. Set profile type.
2928           __ delayed()-&gt;or3(tmp2, tmp1, tmp2);
2929         } else {
2930           __ delayed()-&gt;nop();
2931         }
2932       } else {
2933         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2934                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2935 
2936         __ btst(TypeEntries::type_unknown, tmp2);
2937         // already unknown. Nothing to do anymore.
2938         __ brx(Assembler::notZero, false, Assembler::pt, next);
2939         __ delayed()-&gt;nop();
2940       }
2941 
2942       // different than before. Cannot keep accurate profile.
2943       __ or3(tmp2, TypeEntries::type_unknown, tmp2);
2944     } else {
2945       // There&#39;s a single possible klass at this profile point
2946       assert(exact_klass != NULL, &quot;should be&quot;);
2947       if (TypeEntries::is_type_none(current_klass)) {
2948         metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
2949         __ xor3(tmp1, tmp2, tmp1);
2950         __ btst(TypeEntries::type_klass_mask, tmp1);
2951         __ brx(Assembler::zero, false, Assembler::pt, next);
2952 #ifdef ASSERT
2953 
2954         {
2955           Label ok;
2956           __ delayed()-&gt;btst(TypeEntries::type_mask, tmp2);
2957           __ brx(Assembler::zero, true, Assembler::pt, ok);
2958           __ delayed()-&gt;nop();
2959 
2960           __ stop(&quot;unexpected profiling mismatch&quot;);
2961           __ bind(ok);
2962         }
2963         // first time here. Set profile type.
2964         __ or3(tmp2, tmp1, tmp2);
2965 #else
2966         // first time here. Set profile type.
2967         __ delayed()-&gt;or3(tmp2, tmp1, tmp2);
2968 #endif
2969 
2970       } else {
2971         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2972                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2973 
2974         // already unknown. Nothing to do anymore.
2975         __ btst(TypeEntries::type_unknown, tmp2);
2976         __ brx(Assembler::notZero, false, Assembler::pt, next);
2977         __ delayed()-&gt;or3(tmp2, TypeEntries::type_unknown, tmp2);
2978       }
2979     }
2980 
2981     __ bind(do_update);
2982     __ st_ptr(tmp2, mdo_addr);
2983 
2984     __ bind(next);
2985   }
2986 }
2987 
2988 void LIR_Assembler::align_backward_branch_target() {
2989   __ align(OptoLoopAlignment);
2990 }
2991 
2992 
2993 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2994   // make sure we are expecting a delay
2995   // this has the side effect of clearing the delay state
2996   // so we can use _masm instead of _masm-&gt;delayed() to do the
2997   // code generation.
2998   __ delayed();
2999 
3000   // make sure we only emit one instruction
3001   int offset = code_offset();
3002   op-&gt;delay_op()-&gt;emit_code(this);
3003 #ifdef ASSERT
3004   if (code_offset() - offset != NativeInstruction::nop_instruction_size) {
3005     op-&gt;delay_op()-&gt;print();
3006   }
3007   assert(code_offset() - offset == NativeInstruction::nop_instruction_size,
3008          &quot;only one instruction can go in a delay slot&quot;);
3009 #endif
3010 
3011   // we may also be emitting the call info for the instruction
3012   // which we are the delay slot of.
3013   CodeEmitInfo* call_info = op-&gt;call_info();
3014   if (call_info) {
3015     add_call_info(code_offset(), call_info);
3016   }
3017 
3018   if (VerifyStackAtCalls) {
3019     _masm-&gt;sub(FP, SP, O7);
3020     _masm-&gt;cmp(O7, initial_frame_size_in_bytes());
3021     _masm-&gt;trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2 );
3022   }
3023 }
3024 
3025 
3026 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3027   // tmp must be unused
3028   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3029   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
3030 
3031   if (left-&gt;is_single_cpu()) {
3032     __ neg(left-&gt;as_register(), dest-&gt;as_register());
3033   } else if (left-&gt;is_single_fpu()) {
3034     __ fneg(FloatRegisterImpl::S, left-&gt;as_float_reg(), dest-&gt;as_float_reg());
3035   } else if (left-&gt;is_double_fpu()) {
3036     __ fneg(FloatRegisterImpl::D, left-&gt;as_double_reg(), dest-&gt;as_double_reg());
3037   } else {
3038     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
3039     Register Rlow = left-&gt;as_register_lo();
3040     Register Rhi = left-&gt;as_register_hi();
3041     __ sub(G0, Rlow, dest-&gt;as_register_lo());
3042   }
3043 }
3044 
3045 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
3046                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3047 
3048   // if tmp is invalid, then the function being called doesn&#39;t destroy the thread
3049   if (tmp-&gt;is_valid()) {
3050     __ save_thread(tmp-&gt;as_pointer_register());
3051   }
3052   __ call(dest, relocInfo::runtime_call_type);
3053   __ delayed()-&gt;nop();
3054   if (info != NULL) {
3055     add_call_info_here(info);
3056   }
3057   if (tmp-&gt;is_valid()) {
3058     __ restore_thread(tmp-&gt;as_pointer_register());
3059   }
3060 
3061 #ifdef ASSERT
3062   __ verify_thread();
3063 #endif // ASSERT
3064 }
3065 
3066 
3067 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3068   ShouldNotReachHere();
3069 
3070   NEEDS_CLEANUP;
3071   if (type == T_LONG) {
3072     LIR_Address* mem_addr = dest-&gt;is_address() ? dest-&gt;as_address_ptr() : src-&gt;as_address_ptr();
3073 
3074     // (extended to allow indexed as well as constant displaced for JSR-166)
3075     Register idx = noreg; // contains either constant offset or index
3076 
3077     int disp = mem_addr-&gt;disp();
3078     if (mem_addr-&gt;index() == LIR_OprFact::illegalOpr) {
3079       if (!Assembler::is_simm13(disp)) {
3080         idx = O7;
3081         __ set(disp, idx);
3082       }
3083     } else {
3084       assert(disp == 0, &quot;not both indexed and disp&quot;);
3085       idx = mem_addr-&gt;index()-&gt;as_register();
3086     }
3087 
3088     int null_check_offset = -1;
3089 
3090     Register base = mem_addr-&gt;base()-&gt;as_register();
3091     if (src-&gt;is_register() &amp;&amp; dest-&gt;is_address()) {
3092       // G4 is high half, G5 is low half
3093       // clear the top bits of G5, and scale up G4
3094       __ srl (src-&gt;as_register_lo(),  0, G5);
3095       __ sllx(src-&gt;as_register_hi(), 32, G4);
3096       // combine the two halves into the 64 bits of G4
3097       __ or3(G4, G5, G4);
3098       null_check_offset = __ offset();
3099       if (idx == noreg) {
3100         __ stx(G4, base, disp);
3101       } else {
3102         __ stx(G4, base, idx);
3103       }
3104     } else if (src-&gt;is_address() &amp;&amp; dest-&gt;is_register()) {
3105       null_check_offset = __ offset();
3106       if (idx == noreg) {
3107         __ ldx(base, disp, G5);
3108       } else {
3109         __ ldx(base, idx, G5);
3110       }
3111       __ srax(G5, 32, dest-&gt;as_register_hi()); // fetch the high half into hi
3112       __ mov (G5, dest-&gt;as_register_lo());     // copy low half into lo
3113     } else {
3114       Unimplemented();
3115     }
3116     if (info != NULL) {
3117       add_debug_info_for_null_check(null_check_offset, info);
3118     }
3119 
3120   } else {
3121     // use normal move for all other volatiles since they don&#39;t need
3122     // special handling to remain atomic.
3123     move_op(src, dest, type, lir_patch_none, info, false, false, false);
3124   }
3125 }
3126 
3127 void LIR_Assembler::membar() {
3128   // only StoreLoad membars are ever explicitly needed on sparcs in TSO mode
3129   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
3130 }
3131 
3132 void LIR_Assembler::membar_acquire() {
3133   // no-op on TSO
3134 }
3135 
3136 void LIR_Assembler::membar_release() {
3137   // no-op on TSO
3138 }
3139 
3140 void LIR_Assembler::membar_loadload() {
3141   // no-op
3142   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
3143 }
3144 
3145 void LIR_Assembler::membar_storestore() {
3146   // no-op
3147   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
3148 }
3149 
3150 void LIR_Assembler::membar_loadstore() {
3151   // no-op
3152   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
3153 }
3154 
3155 void LIR_Assembler::membar_storeload() {
3156   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
3157 }
3158 
3159 void LIR_Assembler::on_spin_wait() {
3160   Unimplemented();
3161 }
3162 
3163 // Pack two sequential registers containing 32 bit values
3164 // into a single 64 bit register.
3165 // src and src-&gt;successor() are packed into dst
3166 // src and dst may be the same register.
3167 // Note: src is destroyed
3168 void LIR_Assembler::pack64(LIR_Opr src, LIR_Opr dst) {
3169   Register rs = src-&gt;as_register();
3170   Register rd = dst-&gt;as_register_lo();
3171   __ sllx(rs, 32, rs);
3172   __ srl(rs-&gt;successor(), 0, rs-&gt;successor());
3173   __ or3(rs, rs-&gt;successor(), rd);
3174 }
3175 
3176 // Unpack a 64 bit value in a register into
3177 // two sequential registers.
3178 // src is unpacked into dst and dst-&gt;successor()
3179 void LIR_Assembler::unpack64(LIR_Opr src, LIR_Opr dst) {
3180   Register rs = src-&gt;as_register_lo();
3181   Register rd = dst-&gt;as_register_hi();
3182   assert_different_registers(rs, rd, rd-&gt;successor());
3183   __ srlx(rs, 32, rd);
3184   __ srl (rs,  0, rd-&gt;successor());
3185 }
3186 
3187 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3188   const LIR_Address* addr = addr_opr-&gt;as_address_ptr();
3189   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;can&#39;t handle complex addresses yet&quot;);
3190   const Register dest_reg = dest-&gt;as_pointer_register();
3191   const Register base_reg = addr-&gt;base()-&gt;as_pointer_register();
3192 
3193   if (patch_code != lir_patch_none) {
3194     PatchingStub* patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3195     assert(addr-&gt;disp() != 0, &quot;must have&quot;);
3196     assert(base_reg != G3_scratch, &quot;invariant&quot;);
3197     __ patchable_set(0, G3_scratch);
3198     patching_epilog(patch, patch_code, base_reg, info);
3199     assert(dest_reg != G3_scratch, &quot;invariant&quot;);
3200     if (addr-&gt;index()-&gt;is_valid()) {
3201       const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3202       assert(index_reg != G3_scratch, &quot;invariant&quot;);
3203       __ add(index_reg, G3_scratch, G3_scratch);
3204     }
3205     __ add(base_reg, G3_scratch, dest_reg);
3206   } else {
3207     if (Assembler::is_simm13(addr-&gt;disp())) {
3208       if (addr-&gt;index()-&gt;is_valid()) {
3209         const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3210         assert(index_reg != G3_scratch, &quot;invariant&quot;);
3211         __ add(base_reg, addr-&gt;disp(), G3_scratch);
3212         __ add(index_reg, G3_scratch, dest_reg);
3213       } else {
3214         __ add(base_reg, addr-&gt;disp(), dest_reg);
3215       }
3216     } else {
3217       __ set(addr-&gt;disp(), G3_scratch);
3218       if (addr-&gt;index()-&gt;is_valid()) {
3219         const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3220         assert(index_reg != G3_scratch, &quot;invariant&quot;);
3221         __ add(index_reg, G3_scratch, G3_scratch);
3222       }
3223       __ add(base_reg, G3_scratch, dest_reg);
3224     }
3225   }
3226 }
3227 
3228 
3229 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3230   assert(result_reg-&gt;is_register(), &quot;check&quot;);
3231   __ mov(G2_thread, result_reg-&gt;as_register());
3232 }
3233 
3234 #ifdef ASSERT
3235 // emit run-time assertion
3236 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3237   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3238 
3239   if (op-&gt;in_opr1()-&gt;is_valid()) {
3240     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3241     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3242   } else {
3243     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3244     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3245   }
3246 
3247   Label ok;
3248   if (op-&gt;condition() != lir_cond_always) {
3249     Assembler::Condition acond;
3250     switch (op-&gt;condition()) {
3251       case lir_cond_equal:        acond = Assembler::equal;                break;
3252       case lir_cond_notEqual:     acond = Assembler::notEqual;             break;
3253       case lir_cond_less:         acond = Assembler::less;                 break;
3254       case lir_cond_lessEqual:    acond = Assembler::lessEqual;            break;
3255       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;         break;
3256       case lir_cond_greater:      acond = Assembler::greater;              break;
3257       case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned; break;
3258       case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;    break;
3259       default:                         ShouldNotReachHere();
3260     };
3261     __ br(acond, false, Assembler::pt, ok);
3262     __ delayed()-&gt;nop();
3263   }
3264   if (op-&gt;halt()) {
3265     const char* str = __ code_string(op-&gt;msg());
3266     __ stop(str);
3267   } else {
3268     breakpoint();
3269   }
3270   __ bind(ok);
3271 }
3272 #endif
3273 
3274 void LIR_Assembler::peephole(LIR_List* lir) {
3275   LIR_OpList* inst = lir-&gt;instructions_list();
3276   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3277     LIR_Op* op = inst-&gt;at(i);
3278     switch (op-&gt;code()) {
3279       case lir_cond_float_branch:
3280       case lir_branch: {
3281         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3282         assert(branch-&gt;info() == NULL, &quot;shouldn&#39;t be state on branches anymore&quot;);
3283         LIR_Op* delay_op = NULL;
3284         // we&#39;d like to be able to pull following instructions into
3285         // this slot but we don&#39;t know enough to do it safely yet so
3286         // only optimize block to block control flow.
3287         if (LIRFillDelaySlots &amp;&amp; branch-&gt;block()) {
3288           LIR_Op* prev = inst-&gt;at(i - 1);
3289           if (prev &amp;&amp; LIR_Assembler::is_single_instruction(prev) &amp;&amp; prev-&gt;info() == NULL) {
3290             // swap previous instruction into delay slot
3291             inst-&gt;at_put(i - 1, op);
3292             inst-&gt;at_put(i, new LIR_OpDelay(prev, op-&gt;info()));
3293 #ifndef PRODUCT
3294             if (LIRTracePeephole) {
3295               tty-&gt;print_cr(&quot;delayed&quot;);
3296               inst-&gt;at(i - 1)-&gt;print();
3297               inst-&gt;at(i)-&gt;print();
3298               tty-&gt;cr();
3299             }
3300 #endif
3301             continue;
3302           }
3303         }
3304 
3305         if (!delay_op) {
3306           delay_op = new LIR_OpDelay(new LIR_Op0(lir_nop), NULL);
3307         }
3308         inst-&gt;insert_before(i + 1, delay_op);
3309         break;
3310       }
3311       case lir_static_call:
3312       case lir_virtual_call:
3313       case lir_icvirtual_call:
3314       case lir_optvirtual_call:
3315       case lir_dynamic_call: {
3316         LIR_Op* prev = inst-&gt;at(i - 1);
3317         if (LIRFillDelaySlots &amp;&amp; prev &amp;&amp; prev-&gt;code() == lir_move &amp;&amp; prev-&gt;info() == NULL &amp;&amp;
3318             (op-&gt;code() != lir_virtual_call ||
3319              !prev-&gt;result_opr()-&gt;is_single_cpu() ||
3320              prev-&gt;result_opr()-&gt;as_register() != O0) &amp;&amp;
3321             LIR_Assembler::is_single_instruction(prev)) {
3322           // Only moves without info can be put into the delay slot.
3323           // Also don&#39;t allow the setup of the receiver in the delay
3324           // slot for vtable calls.
3325           inst-&gt;at_put(i - 1, op);
3326           inst-&gt;at_put(i, new LIR_OpDelay(prev, op-&gt;info()));
3327 #ifndef PRODUCT
3328           if (LIRTracePeephole) {
3329             tty-&gt;print_cr(&quot;delayed&quot;);
3330             inst-&gt;at(i - 1)-&gt;print();
3331             inst-&gt;at(i)-&gt;print();
3332             tty-&gt;cr();
3333           }
3334 #endif
3335         } else {
3336           LIR_Op* delay_op = new LIR_OpDelay(new LIR_Op0(lir_nop), op-&gt;as_OpJavaCall()-&gt;info());
3337           inst-&gt;insert_before(i + 1, delay_op);
3338           i++;
3339         }
3340         break;
3341       }
3342     }
3343   }
3344 }
3345 
3346 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
3347   LIR_Address* addr = src-&gt;as_address_ptr();
3348 
3349   assert(data == dest, &quot;swap uses only 2 operands&quot;);
3350   assert (code == lir_xchg, &quot;no xadd on sparc&quot;);
3351 
3352   if (data-&gt;type() == T_INT) {
3353     __ swap(as_Address(addr), data-&gt;as_register());
3354   } else if (data-&gt;is_oop()) {
3355     Register obj = data-&gt;as_register();
3356     Register narrow = tmp-&gt;as_register();
3357     assert(UseCompressedOops, &quot;swap is 32bit only&quot;);
3358     __ encode_heap_oop(obj, narrow);
3359     __ swap(as_Address(addr), narrow);
3360     __ decode_heap_oop(narrow, obj);
3361   } else {
3362     ShouldNotReachHere();
3363   }
3364 }
3365 
3366 #undef __
    </pre>
  </body>
</html>
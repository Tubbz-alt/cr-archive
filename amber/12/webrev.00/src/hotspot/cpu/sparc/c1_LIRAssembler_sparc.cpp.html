<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/cpu/sparc/c1_LIRAssembler_sparc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.inline.hpp&quot;
  27 #include &quot;c1/c1_Compilation.hpp&quot;
  28 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  29 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  30 #include &quot;c1/c1_Runtime1.hpp&quot;
  31 #include &quot;c1/c1_ValueStack.hpp&quot;
  32 #include &quot;ci/ciArrayKlass.hpp&quot;
  33 #include &quot;ci/ciInstance.hpp&quot;
  34 #include &quot;gc/shared/collectedHeap.hpp&quot;
  35 #include &quot;memory/universe.hpp&quot;
  36 #include &quot;nativeInst_sparc.hpp&quot;
  37 #include &quot;oops/objArrayKlass.hpp&quot;
  38 #include &quot;runtime/frame.inline.hpp&quot;
  39 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  40 #include &quot;runtime/jniHandles.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 
  48 //------------------------------------------------------------
  49 
  50 
  51 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  52   if (opr-&gt;is_constant()) {
  53     LIR_Const* constant = opr-&gt;as_constant_ptr();
  54     switch (constant-&gt;type()) {
  55       case T_INT: {
  56         jint value = constant-&gt;as_jint();
  57         return Assembler::is_simm13(value);
  58       }
  59 
  60       default:
  61         return false;
  62     }
  63   }
  64   return false;
  65 }
  66 
  67 
  68 bool LIR_Assembler::is_single_instruction(LIR_Op* op) {
  69   switch (op-&gt;code()) {
  70     case lir_null_check:
  71     return true;
  72 
  73 
  74     case lir_add:
  75     case lir_ushr:
  76     case lir_shr:
  77     case lir_shl:
  78       // integer shifts and adds are always one instruction
  79       return op-&gt;result_opr()-&gt;is_single_cpu();
  80 
  81 
  82     case lir_move: {
  83       LIR_Op1* op1 = op-&gt;as_Op1();
  84       LIR_Opr src = op1-&gt;in_opr();
  85       LIR_Opr dst = op1-&gt;result_opr();
  86 
  87       if (src == dst) {
  88         NEEDS_CLEANUP;
  89         // this works around a problem where moves with the same src and dst
  90         // end up in the delay slot and then the assembler swallows the mov
  91         // since it has no effect and then it complains because the delay slot
  92         // is empty.  returning false stops the optimizer from putting this in
  93         // the delay slot
  94         return false;
  95       }
  96 
  97       // don&#39;t put moves involving oops into the delay slot since the VerifyOops code
  98       // will make it much larger than a single instruction.
  99       if (VerifyOops) {
 100         return false;
 101       }
 102 
 103       if (src-&gt;is_double_cpu() || dst-&gt;is_double_cpu() || op1-&gt;patch_code() != lir_patch_none ||
 104           ((src-&gt;is_double_fpu() || dst-&gt;is_double_fpu()) &amp;&amp; op1-&gt;move_kind() != lir_move_normal)) {
 105         return false;
 106       }
 107 
 108       if (UseCompressedOops) {
 109         if (dst-&gt;is_address() &amp;&amp; !dst-&gt;is_stack() &amp;&amp; is_reference_type(dst-&gt;type())) return false;
 110         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; is_reference_type(src-&gt;type())) return false;
 111       }
 112 
 113       if (UseCompressedClassPointers) {
 114         if (src-&gt;is_address() &amp;&amp; !src-&gt;is_stack() &amp;&amp; src-&gt;type() == T_ADDRESS &amp;&amp;
 115             src-&gt;as_address_ptr()-&gt;disp() == oopDesc::klass_offset_in_bytes()) return false;
 116       }
 117 
 118       if (dst-&gt;is_register()) {
 119         if (src-&gt;is_address() &amp;&amp; Assembler::is_simm13(src-&gt;as_address_ptr()-&gt;disp())) {
 120           return !PatchALot;
 121         } else if (src-&gt;is_single_stack()) {
 122           return true;
 123         }
 124       }
 125 
 126       if (src-&gt;is_register()) {
 127         if (dst-&gt;is_address() &amp;&amp; Assembler::is_simm13(dst-&gt;as_address_ptr()-&gt;disp())) {
 128           return !PatchALot;
 129         } else if (dst-&gt;is_single_stack()) {
 130           return true;
 131         }
 132       }
 133 
 134       if (dst-&gt;is_register() &amp;&amp;
 135           ((src-&gt;is_register() &amp;&amp; src-&gt;is_single_word() &amp;&amp; src-&gt;is_same_type(dst)) ||
 136            (src-&gt;is_constant() &amp;&amp; LIR_Assembler::is_small_constant(op-&gt;as_Op1()-&gt;in_opr())))) {
 137         return true;
 138       }
 139 
 140       return false;
 141     }
 142 
 143     default:
 144       return false;
 145   }
 146   ShouldNotReachHere();
 147 }
 148 
 149 
 150 LIR_Opr LIR_Assembler::receiverOpr() {
 151   return FrameMap::O0_oop_opr;
 152 }
 153 
 154 
 155 LIR_Opr LIR_Assembler::osrBufferPointer() {
 156   return FrameMap::I0_opr;
 157 }
 158 
 159 
 160 int LIR_Assembler::initial_frame_size_in_bytes() const {
 161   return in_bytes(frame_map()-&gt;framesize_in_bytes());
 162 }
 163 
 164 
 165 // inline cache check: the inline cached class is in G5_inline_cache_reg(G5);
 166 // we fetch the class of the receiver (O0) and compare it with the cached class.
 167 // If they do not match we jump to slow case.
 168 int LIR_Assembler::check_icache() {
 169   int offset = __ offset();
 170   __ inline_cache_check(O0, G5_inline_cache_reg);
 171   return offset;
 172 }
 173 
 174 void LIR_Assembler::clinit_barrier(ciMethod* method) {
 175   ShouldNotReachHere(); // not implemented
 176 }
 177 
 178 void LIR_Assembler::osr_entry() {
 179   // On-stack-replacement entry sequence (interpreter frame layout described in interpreter_sparc.cpp):
 180   //
 181   //   1. Create a new compiled activation.
 182   //   2. Initialize local variables in the compiled activation.  The expression stack must be empty
 183   //      at the osr_bci; it is not initialized.
 184   //   3. Jump to the continuation address in compiled code to resume execution.
 185 
 186   // OSR entry point
 187   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 188   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 189   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 190   int number_of_locks = entry_state-&gt;locks_size();
 191 
 192   // Create a frame for the compiled activation.
 193   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 194 
 195   // OSR buffer is
 196   //
 197   // locals[nlocals-1..0]
 198   // monitors[number_of_locks-1..0]
 199   //
 200   // locals is a direct copy of the interpreter frame so in the osr buffer
 201   // so first slot in the local array is the last local from the interpreter
 202   // and last slot is local[0] (receiver) from the interpreter
 203   //
 204   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 205   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 206   // in the interpreter frame (the method lock if a sync method)
 207 
 208   // Initialize monitors in the compiled activation.
 209   //   I0: pointer to osr buffer
 210   //
 211   // All other registers are dead at this point and the locals will be
 212   // copied into place by code emitted in the IR.
 213 
 214   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 215   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 216     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 217       (2 * BytesPerWord) * (number_of_locks - 1);
 218     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 219     // the OSR buffer using 2 word entries: first the lock and then
 220     // the oop.
 221     for (int i = 0; i &lt; number_of_locks; i++) {
 222       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 223 #ifdef ASSERT
 224       // verify the interpreter&#39;s monitor has a non-null object
 225       {
 226         Label L;
 227         __ ld_ptr(OSR_buf, slot_offset + 1*BytesPerWord, O7);
 228         __ cmp_and_br_short(O7, G0, Assembler::notEqual, Assembler::pt, L);
 229         __ stop(&quot;locked object is NULL&quot;);
 230         __ bind(L);
 231       }
 232 #endif // ASSERT
 233       // Copy the lock field into the compiled activation.
 234       __ ld_ptr(OSR_buf, slot_offset + 0, O7);
 235       __ st_ptr(O7, frame_map()-&gt;address_for_monitor_lock(i));
 236       __ ld_ptr(OSR_buf, slot_offset + 1*BytesPerWord, O7);
 237       __ st_ptr(O7, frame_map()-&gt;address_for_monitor_object(i));
 238     }
 239   }
 240 }
 241 
 242 
 243 // --------------------------------------------------------------------------------------------
 244 
 245 void LIR_Assembler::monitorexit(LIR_Opr obj_opr, LIR_Opr lock_opr, Register hdr, int monitor_no) {
 246   if (!GenerateSynchronizationCode) return;
 247 
 248   Register obj_reg = obj_opr-&gt;as_register();
 249   Register lock_reg = lock_opr-&gt;as_register();
 250 
 251   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
 252   Register reg = mon_addr.base();
 253   int offset = mon_addr.disp();
 254   // compute pointer to BasicLock
 255   if (mon_addr.is_simm13()) {
 256     __ add(reg, offset, lock_reg);
 257   }
 258   else {
 259     __ set(offset, lock_reg);
 260     __ add(reg, lock_reg, lock_reg);
 261   }
 262   // unlock object
 263   MonitorAccessStub* slow_case = new MonitorExitStub(lock_opr, UseFastLocking, monitor_no);
 264   // _slow_case_stubs-&gt;append(slow_case);
 265   // temporary fix: must be created after exceptionhandler, therefore as call stub
 266   _slow_case_stubs-&gt;append(slow_case);
 267   if (UseFastLocking) {
 268     // try inlined fast unlocking first, revert to slow locking if it fails
 269     // note: lock_reg points to the displaced header since the displaced header offset is 0!
 270     assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
 271     __ unlock_object(hdr, obj_reg, lock_reg, *slow_case-&gt;entry());
 272   } else {
 273     // always do slow unlocking
 274     // note: the slow unlocking code could be inlined here, however if we use
 275     //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
 276     //       simpler and requires less duplicated code - additionally, the
 277     //       slow unlocking code is the same in either case which simplifies
 278     //       debugging
 279     __ br(Assembler::always, false, Assembler::pt, *slow_case-&gt;entry());
 280     __ delayed()-&gt;nop();
 281   }
 282   // done
 283   __ bind(*slow_case-&gt;continuation());
 284 }
 285 
 286 
 287 int LIR_Assembler::emit_exception_handler() {
 288   // if the last instruction is a call (typically to do a throw which
 289   // is coming at the end after block reordering) the return address
 290   // must still point into the code area in order to avoid assertion
 291   // failures when searching for the corresponding bci =&gt; add a nop
 292   // (was bug 5/14/1999 - gri)
 293   __ nop();
 294 
 295   // generate code for exception handler
 296   ciMethod* method = compilation()-&gt;method();
 297 
 298   address handler_base = __ start_a_stub(exception_handler_size());
 299 
 300   if (handler_base == NULL) {
 301     // not enough space left for the handler
 302     bailout(&quot;exception handler overflow&quot;);
 303     return -1;
 304   }
 305 
 306   int offset = code_offset();
 307 
 308   __ call(Runtime1::entry_for(Runtime1::handle_exception_from_callee_id), relocInfo::runtime_call_type);
 309   __ delayed()-&gt;nop();
 310   __ should_not_reach_here();
 311   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 312   __ end_a_stub();
 313 
 314   return offset;
 315 }
 316 
 317 
 318 // Emit the code to remove the frame from the stack in the exception
 319 // unwind path.
 320 int LIR_Assembler::emit_unwind_handler() {
 321 #ifndef PRODUCT
 322   if (CommentedAssembly) {
 323     _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 324   }
 325 #endif
 326 
 327   int offset = code_offset();
 328 
 329   // Fetch the exception from TLS and clear out exception related thread state
 330   __ ld_ptr(G2_thread, in_bytes(JavaThread::exception_oop_offset()), O0);
 331   __ st_ptr(G0, G2_thread, in_bytes(JavaThread::exception_oop_offset()));
 332   __ st_ptr(G0, G2_thread, in_bytes(JavaThread::exception_pc_offset()));
 333 
 334   __ bind(_unwind_handler_entry);
 335   __ verify_not_null_oop(O0);
 336   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 337     __ mov(O0, I0);  // Preserve the exception
 338   }
 339 
 340   // Preform needed unlocking
 341   MonitorExitStub* stub = NULL;
 342   if (method()-&gt;is_synchronized()) {
 343     monitor_address(0, FrameMap::I1_opr);
 344     stub = new MonitorExitStub(FrameMap::I1_opr, true, 0);
 345     __ unlock_object(I3, I2, I1, *stub-&gt;entry());
 346     __ bind(*stub-&gt;continuation());
 347   }
 348 
 349   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 350     __ mov(G2_thread, O0);
 351     __ save_thread(I1); // need to preserve thread in G2 across
 352                         // runtime call
 353     metadata2reg(method()-&gt;constant_encoding(), O1);
 354     __ call(CAST_FROM_FN_PTR(address, SharedRuntime::dtrace_method_exit), relocInfo::runtime_call_type);
 355     __ delayed()-&gt;nop();
 356     __ restore_thread(I1);
 357   }
 358 
 359   if (method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 360     __ mov(I0, O0);  // Restore the exception
 361   }
 362 
 363   // dispatch to the unwind logic
 364   __ call(Runtime1::entry_for(Runtime1::unwind_exception_id), relocInfo::runtime_call_type);
 365   __ delayed()-&gt;nop();
 366 
 367   // Emit the slow path assembly
 368   if (stub != NULL) {
 369     stub-&gt;emit_code(this);
 370   }
 371 
 372   return offset;
 373 }
 374 
 375 
 376 int LIR_Assembler::emit_deopt_handler() {
 377   // if the last instruction is a call (typically to do a throw which
 378   // is coming at the end after block reordering) the return address
 379   // must still point into the code area in order to avoid assertion
 380   // failures when searching for the corresponding bci =&gt; add a nop
 381   // (was bug 5/14/1999 - gri)
 382   __ nop();
 383 
 384   // generate code for deopt handler
 385   ciMethod* method = compilation()-&gt;method();
 386   address handler_base = __ start_a_stub(deopt_handler_size());
 387   if (handler_base == NULL) {
 388     // not enough space left for the handler
 389     bailout(&quot;deopt handler overflow&quot;);
 390     return -1;
 391   }
 392 
 393   int offset = code_offset();
 394   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
 395   __ JUMP(deopt_blob, G3_scratch, 0); // sethi;jmp
 396   __ delayed()-&gt;nop();
 397   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 398   __ end_a_stub();
 399 
 400   return offset;
 401 }
 402 
 403 
 404 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 405   if (o == NULL) {
 406     __ set(NULL_WORD, reg);
 407   } else {
 408 #ifdef ASSERT
 409     {
 410       ThreadInVMfromNative tiv(JavaThread::current());
 411       assert(Universe::heap()-&gt;is_in(JNIHandles::resolve(o)), &quot;should be real oop&quot;);
 412     }
 413 #endif
 414     int oop_index = __ oop_recorder()-&gt;find_index(o);
 415     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 416     __ set(NULL_WORD, reg, rspec); // Will be set when the nmethod is created
 417   }
 418 }
 419 
 420 
 421 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 422   // Allocate a new index in table to hold the object once it&#39;s been patched
 423   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 424   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 425 
 426   AddressLiteral addrlit(NULL, oop_Relocation::spec(oop_index));
 427   assert(addrlit.rspec().type() == relocInfo::oop_type, &quot;must be an oop reloc&quot;);
 428   // It may not seem necessary to use a sethi/add pair to load a NULL into dest, but the
 429   // NULL will be dynamically patched later and the patched value may be large.  We must
 430   // therefore generate the sethi/add as a placeholders
 431   __ patchable_set(addrlit, reg);
 432 
 433   patching_epilog(patch, lir_patch_normal, reg, info);
 434 }
 435 
 436 
 437 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 438   __ set_metadata_constant(o, reg);
 439 }
 440 
 441 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 442   // Allocate a new index in table to hold the klass once it&#39;s been patched
 443   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 444   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 445   AddressLiteral addrlit(NULL, metadata_Relocation::spec(index));
 446   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 447   // It may not seem necessary to use a sethi/add pair to load a NULL into dest, but the
 448   // NULL will be dynamically patched later and the patched value may be large.  We must
 449   // therefore generate the sethi/add as a placeholders
 450   __ patchable_set(addrlit, reg);
 451 
 452   patching_epilog(patch, lir_patch_normal, reg, info);
 453 }
 454 
 455 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 456   switch (op-&gt;code()) {
 457     case lir_idiv:
 458     case lir_irem:  // Both idiv &amp; irem are handled after the switch (below).
 459       break;
 460     case lir_fmaf:
 461       __ fmadd(FloatRegisterImpl::S,
 462                op-&gt;in_opr1()-&gt;as_float_reg(),
 463                op-&gt;in_opr2()-&gt;as_float_reg(),
 464                op-&gt;in_opr3()-&gt;as_float_reg(),
 465                op-&gt;result_opr()-&gt;as_float_reg());
 466       return;
 467     case lir_fmad:
 468       __ fmadd(FloatRegisterImpl::D,
 469                op-&gt;in_opr1()-&gt;as_double_reg(),
 470                op-&gt;in_opr2()-&gt;as_double_reg(),
 471                op-&gt;in_opr3()-&gt;as_double_reg(),
 472                op-&gt;result_opr()-&gt;as_double_reg());
 473       return;
 474     default:
 475       ShouldNotReachHere();
 476       break;
 477   }
 478 
 479   // Handle idiv &amp; irem:
 480 
 481   Register Rdividend = op-&gt;in_opr1()-&gt;as_register();
 482   Register Rdivisor  = noreg;
 483   Register Rscratch  = op-&gt;in_opr3()-&gt;as_register();
 484   Register Rresult   = op-&gt;result_opr()-&gt;as_register();
 485   int divisor = -1;
 486 
 487   if (op-&gt;in_opr2()-&gt;is_register()) {
 488     Rdivisor = op-&gt;in_opr2()-&gt;as_register();
 489   } else {
 490     divisor = op-&gt;in_opr2()-&gt;as_constant_ptr()-&gt;as_jint();
 491     assert(Assembler::is_simm13(divisor), &quot;can only handle simm13&quot;);
 492   }
 493 
 494   assert(Rdividend != Rscratch, &quot;&quot;);
 495   assert(Rdivisor  != Rscratch, &quot;&quot;);
 496   assert(op-&gt;code() == lir_idiv || op-&gt;code() == lir_irem, &quot;Must be irem or idiv&quot;);
 497 
 498   if (Rdivisor == noreg &amp;&amp; is_power_of_2(divisor)) {
 499     // convert division by a power of two into some shifts and logical operations
 500     if (op-&gt;code() == lir_idiv) {
 501       if (divisor == 2) {
 502         __ srl(Rdividend, 31, Rscratch);
 503       } else {
 504         __ sra(Rdividend, 31, Rscratch);
 505         __ and3(Rscratch, divisor - 1, Rscratch);
 506       }
 507       __ add(Rdividend, Rscratch, Rscratch);
 508       __ sra(Rscratch, log2_int(divisor), Rresult);
 509       return;
 510     } else {
 511       if (divisor == 2) {
 512         __ srl(Rdividend, 31, Rscratch);
 513       } else {
 514         __ sra(Rdividend, 31, Rscratch);
 515         __ and3(Rscratch, divisor - 1,Rscratch);
 516       }
 517       __ add(Rdividend, Rscratch, Rscratch);
 518       __ andn(Rscratch, divisor - 1,Rscratch);
 519       __ sub(Rdividend, Rscratch, Rresult);
 520       return;
 521     }
 522   }
 523 
 524   __ sra(Rdividend, 31, Rscratch);
 525   __ wry(Rscratch);
 526 
 527   add_debug_info_for_div0_here(op-&gt;info());
 528 
 529   if (Rdivisor != noreg) {
 530     __ sdivcc(Rdividend, Rdivisor, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 531   } else {
 532     assert(Assembler::is_simm13(divisor), &quot;can only handle simm13&quot;);
 533     __ sdivcc(Rdividend, divisor, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 534   }
 535 
 536   Label skip;
 537   __ br(Assembler::overflowSet, true, Assembler::pn, skip);
 538   __ delayed()-&gt;Assembler::sethi(0x80000000, (op-&gt;code() == lir_idiv ? Rresult : Rscratch));
 539   __ bind(skip);
 540 
 541   if (op-&gt;code() == lir_irem) {
 542     if (Rdivisor != noreg) {
 543       __ smul(Rscratch, Rdivisor, Rscratch);
 544     } else {
 545       __ smul(Rscratch, divisor, Rscratch);
 546     }
 547     __ sub(Rdividend, Rscratch, Rresult);
 548   }
 549 }
 550 
 551 
 552 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 553 #ifdef ASSERT
 554   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 555   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 556   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 557 #endif
 558   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 559 
 560   if (op-&gt;cond() == lir_cond_always) {
 561     __ br(Assembler::always, false, Assembler::pt, *(op-&gt;label()));
 562   } else if (op-&gt;code() == lir_cond_float_branch) {
 563     assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 564     bool is_unordered = (op-&gt;ublock() == op-&gt;block());
 565     Assembler::Condition acond;
 566     switch (op-&gt;cond()) {
 567       case lir_cond_equal:         acond = Assembler::f_equal;    break;
 568       case lir_cond_notEqual:      acond = Assembler::f_notEqual; break;
 569       case lir_cond_less:          acond = (is_unordered ? Assembler::f_unorderedOrLess          : Assembler::f_less);           break;
 570       case lir_cond_greater:       acond = (is_unordered ? Assembler::f_unorderedOrGreater       : Assembler::f_greater);        break;
 571       case lir_cond_lessEqual:     acond = (is_unordered ? Assembler::f_unorderedOrLessOrEqual   : Assembler::f_lessOrEqual);    break;
 572       case lir_cond_greaterEqual:  acond = (is_unordered ? Assembler::f_unorderedOrGreaterOrEqual: Assembler::f_greaterOrEqual); break;
 573       default :                         ShouldNotReachHere();
 574     }
 575     __ fb( acond, false, Assembler::pn, *(op-&gt;label()));
 576   } else {
 577     assert (op-&gt;code() == lir_branch, &quot;just checking&quot;);
 578 
 579     Assembler::Condition acond;
 580     switch (op-&gt;cond()) {
 581       case lir_cond_equal:        acond = Assembler::equal;                break;
 582       case lir_cond_notEqual:     acond = Assembler::notEqual;             break;
 583       case lir_cond_less:         acond = Assembler::less;                 break;
 584       case lir_cond_lessEqual:    acond = Assembler::lessEqual;            break;
 585       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;         break;
 586       case lir_cond_greater:      acond = Assembler::greater;              break;
 587       case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned; break;
 588       case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;    break;
 589       default:                         ShouldNotReachHere();
 590     };
 591 
 592     // sparc has different condition codes for testing 32-bit
 593     // vs. 64-bit values.  We could always test xcc is we could
 594     // guarantee that 32-bit loads always sign extended but that isn&#39;t
 595     // true and since sign extension isn&#39;t free, it would impose a
 596     // slight cost.
 597     if  (op-&gt;type() == T_INT) {
 598       __ br(acond, false, Assembler::pn, *(op-&gt;label()));
 599     } else
 600       __ brx(acond, false, Assembler::pn, *(op-&gt;label()));
 601   }
 602   // The peephole pass fills the delay slot
 603 }
 604 
 605 
 606 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 607   Bytecodes::Code code = op-&gt;bytecode();
 608   LIR_Opr dst = op-&gt;result_opr();
 609 
 610   switch(code) {
 611     case Bytecodes::_i2l: {
 612       Register rlo  = dst-&gt;as_register_lo();
 613       Register rhi  = dst-&gt;as_register_hi();
 614       Register rval = op-&gt;in_opr()-&gt;as_register();
 615       __ sra(rval, 0, rlo);
 616       break;
 617     }
 618     case Bytecodes::_i2d:
 619     case Bytecodes::_i2f: {
 620       bool is_double = (code == Bytecodes::_i2d);
 621       FloatRegister rdst = is_double ? dst-&gt;as_double_reg() : dst-&gt;as_float_reg();
 622       FloatRegisterImpl::Width w = is_double ? FloatRegisterImpl::D : FloatRegisterImpl::S;
 623       FloatRegister rsrc = op-&gt;in_opr()-&gt;as_float_reg();
 624       if (rsrc != rdst) {
 625         __ fmov(FloatRegisterImpl::S, rsrc, rdst);
 626       }
 627       __ fitof(w, rdst, rdst);
 628       break;
 629     }
 630     case Bytecodes::_f2i:{
 631       FloatRegister rsrc = op-&gt;in_opr()-&gt;as_float_reg();
 632       Address       addr = frame_map()-&gt;address_for_slot(dst-&gt;single_stack_ix());
 633       Label L;
 634       // result must be 0 if value is NaN; test by comparing value to itself
 635       __ fcmp(FloatRegisterImpl::S, Assembler::fcc0, rsrc, rsrc);
 636       __ fb(Assembler::f_unordered, true, Assembler::pn, L);
 637       __ delayed()-&gt;st(G0, addr); // annuled if contents of rsrc is not NaN
 638       __ ftoi(FloatRegisterImpl::S, rsrc, rsrc);
 639       // move integer result from float register to int register
 640       __ stf(FloatRegisterImpl::S, rsrc, addr.base(), addr.disp());
 641       __ bind (L);
 642       break;
 643     }
 644     case Bytecodes::_l2i: {
 645       Register rlo  = op-&gt;in_opr()-&gt;as_register_lo();
 646       Register rhi  = op-&gt;in_opr()-&gt;as_register_hi();
 647       Register rdst = dst-&gt;as_register();
 648       __ sra(rlo, 0, rdst);
 649       break;
 650     }
 651     case Bytecodes::_d2f:
 652     case Bytecodes::_f2d: {
 653       bool is_double = (code == Bytecodes::_f2d);
 654       assert((!is_double &amp;&amp; dst-&gt;is_single_fpu()) || (is_double &amp;&amp; dst-&gt;is_double_fpu()), &quot;check&quot;);
 655       LIR_Opr val = op-&gt;in_opr();
 656       FloatRegister rval = (code == Bytecodes::_d2f) ? val-&gt;as_double_reg() : val-&gt;as_float_reg();
 657       FloatRegister rdst = is_double ? dst-&gt;as_double_reg() : dst-&gt;as_float_reg();
 658       FloatRegisterImpl::Width vw = is_double ? FloatRegisterImpl::S : FloatRegisterImpl::D;
 659       FloatRegisterImpl::Width dw = is_double ? FloatRegisterImpl::D : FloatRegisterImpl::S;
 660       __ ftof(vw, dw, rval, rdst);
 661       break;
 662     }
 663     case Bytecodes::_i2s:
 664     case Bytecodes::_i2b: {
 665       Register rval = op-&gt;in_opr()-&gt;as_register();
 666       Register rdst = dst-&gt;as_register();
 667       int shift = (code == Bytecodes::_i2b) ? (BitsPerInt - T_BYTE_aelem_bytes * BitsPerByte) : (BitsPerInt - BitsPerShort);
 668       __ sll (rval, shift, rdst);
 669       __ sra (rdst, shift, rdst);
 670       break;
 671     }
 672     case Bytecodes::_i2c: {
 673       Register rval = op-&gt;in_opr()-&gt;as_register();
 674       Register rdst = dst-&gt;as_register();
 675       int shift = BitsPerInt - T_CHAR_aelem_bytes * BitsPerByte;
 676       __ sll (rval, shift, rdst);
 677       __ srl (rdst, shift, rdst);
 678       break;
 679     }
 680 
 681     default: ShouldNotReachHere();
 682   }
 683 }
 684 
 685 
 686 void LIR_Assembler::align_call(LIR_Code) {
 687   // do nothing since all instructions are word aligned on sparc
 688 }
 689 
 690 
 691 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 692   __ call(op-&gt;addr(), rtype);
 693   // The peephole pass fills the delay slot, add_call_info is done in
 694   // LIR_Assembler::emit_delay.
 695 }
 696 
 697 
 698 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 699   __ ic_call(op-&gt;addr(), false);
 700   // The peephole pass fills the delay slot, add_call_info is done in
 701   // LIR_Assembler::emit_delay.
 702 }
 703 
 704 
 705 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 706   add_debug_info_for_null_check_here(op-&gt;info());
 707   __ load_klass(O0, G3_scratch);
 708   if (Assembler::is_simm13(op-&gt;vtable_offset())) {
 709     __ ld_ptr(G3_scratch, op-&gt;vtable_offset(), G5_method);
 710   } else {
 711     // This will generate 2 instructions
 712     __ set(op-&gt;vtable_offset(), G5_method);
 713     // ld_ptr, set_hi, set
 714     __ ld_ptr(G3_scratch, G5_method, G5_method);
 715   }
 716   __ ld_ptr(G5_method, Method::from_compiled_offset(), G3_scratch);
 717   __ callr(G3_scratch, G0);
 718   // the peephole pass fills the delay slot
 719 }
 720 
 721 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 722   int store_offset;
 723   if (!Assembler::is_simm13(offset + (type == T_LONG) ? wordSize : 0)) {
 724     assert(base != O7, &quot;destroying register&quot;);
 725     assert(!unaligned, &quot;can&#39;t handle this&quot;);
 726     // for offsets larger than a simm13 we setup the offset in O7
 727     __ set(offset, O7);
 728     store_offset = store(from_reg, base, O7, type, wide);
 729   } else {
 730     if (is_reference_type(type)) {
 731       __ verify_oop(from_reg-&gt;as_register());
 732     }
 733     store_offset = code_offset();
 734     switch (type) {
 735       case T_BOOLEAN: // fall through
 736       case T_BYTE  : __ stb(from_reg-&gt;as_register(), base, offset); break;
 737       case T_CHAR  : __ sth(from_reg-&gt;as_register(), base, offset); break;
 738       case T_SHORT : __ sth(from_reg-&gt;as_register(), base, offset); break;
 739       case T_INT   : __ stw(from_reg-&gt;as_register(), base, offset); break;
 740       case T_LONG  :
 741         if (unaligned || PatchALot) {
 742           // Don&#39;t use O7 here because it may be equal to &#39;base&#39; (see LIR_Assembler::reg2mem)
 743           assert(G3_scratch != base, &quot;can&#39;t handle this&quot;);
 744           assert(G3_scratch != from_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 745           __ srax(from_reg-&gt;as_register_lo(), 32, G3_scratch);
 746           __ stw(from_reg-&gt;as_register_lo(), base, offset + lo_word_offset_in_bytes);
 747           __ stw(G3_scratch,                 base, offset + hi_word_offset_in_bytes);
 748         } else {
 749           __ stx(from_reg-&gt;as_register_lo(), base, offset);
 750         }
 751         break;
 752       case T_ADDRESS:
 753       case T_METADATA:
 754         __ st_ptr(from_reg-&gt;as_register(), base, offset);
 755         break;
 756       case T_ARRAY : // fall through
 757       case T_OBJECT:
 758         {
 759           if (UseCompressedOops &amp;&amp; !wide) {
 760             __ encode_heap_oop(from_reg-&gt;as_register(), G3_scratch);
 761             store_offset = code_offset();
 762             __ stw(G3_scratch, base, offset);
 763           } else {
 764             __ st_ptr(from_reg-&gt;as_register(), base, offset);
 765           }
 766           break;
 767         }
 768 
 769       case T_FLOAT : __ stf(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), base, offset); break;
 770       case T_DOUBLE:
 771         {
 772           FloatRegister reg = from_reg-&gt;as_double_reg();
 773           // split unaligned stores
 774           if (unaligned || PatchALot) {
 775             assert(Assembler::is_simm13(offset + 4), &quot;must be&quot;);
 776             __ stf(FloatRegisterImpl::S, reg-&gt;successor(), base, offset + 4);
 777             __ stf(FloatRegisterImpl::S, reg,              base, offset);
 778           } else {
 779             __ stf(FloatRegisterImpl::D, reg, base, offset);
 780           }
 781           break;
 782         }
 783       default      : ShouldNotReachHere();
 784     }
 785   }
 786   return store_offset;
 787 }
 788 
 789 
 790 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 791   if (is_reference_type(type)) {
 792     __ verify_oop(from_reg-&gt;as_register());
 793   }
 794   int store_offset = code_offset();
 795   switch (type) {
 796     case T_BOOLEAN: // fall through
 797     case T_BYTE  : __ stb(from_reg-&gt;as_register(), base, disp); break;
 798     case T_CHAR  : __ sth(from_reg-&gt;as_register(), base, disp); break;
 799     case T_SHORT : __ sth(from_reg-&gt;as_register(), base, disp); break;
 800     case T_INT   : __ stw(from_reg-&gt;as_register(), base, disp); break;
 801     case T_LONG  :
 802       __ stx(from_reg-&gt;as_register_lo(), base, disp);
 803       break;
 804     case T_ADDRESS:
 805       __ st_ptr(from_reg-&gt;as_register(), base, disp);
 806       break;
 807     case T_ARRAY : // fall through
 808     case T_OBJECT:
 809       {
 810         if (UseCompressedOops &amp;&amp; !wide) {
 811           __ encode_heap_oop(from_reg-&gt;as_register(), G3_scratch);
 812           store_offset = code_offset();
 813           __ stw(G3_scratch, base, disp);
 814         } else {
 815           __ st_ptr(from_reg-&gt;as_register(), base, disp);
 816         }
 817         break;
 818       }
 819     case T_FLOAT : __ stf(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), base, disp); break;
 820     case T_DOUBLE: __ stf(FloatRegisterImpl::D, from_reg-&gt;as_double_reg(), base, disp); break;
 821     default      : ShouldNotReachHere();
 822   }
 823   return store_offset;
 824 }
 825 
 826 
 827 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 828   int load_offset;
 829   if (!Assembler::is_simm13(offset + (type == T_LONG) ? wordSize : 0)) {
 830     assert(base != O7, &quot;destroying register&quot;);
 831     assert(!unaligned, &quot;can&#39;t handle this&quot;);
 832     // for offsets larger than a simm13 we setup the offset in O7
 833     __ set(offset, O7);
 834     load_offset = load(base, O7, to_reg, type, wide);
 835   } else {
 836     load_offset = code_offset();
 837     switch(type) {
 838       case T_BOOLEAN: // fall through
 839       case T_BYTE  : __ ldsb(base, offset, to_reg-&gt;as_register()); break;
 840       case T_CHAR  : __ lduh(base, offset, to_reg-&gt;as_register()); break;
 841       case T_SHORT : __ ldsh(base, offset, to_reg-&gt;as_register()); break;
 842       case T_INT   : __ ld(base, offset, to_reg-&gt;as_register()); break;
 843       case T_LONG  :
 844         if (!unaligned &amp;&amp; !PatchALot) {
 845           __ ldx(base, offset, to_reg-&gt;as_register_lo());
 846         } else {
 847           assert(base != to_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 848           assert(O7 != to_reg-&gt;as_register_lo(), &quot;can&#39;t handle this&quot;);
 849           __ ld(base, offset + hi_word_offset_in_bytes, to_reg-&gt;as_register_lo());
 850           __ lduw(base, offset + lo_word_offset_in_bytes, O7); // in case O7 is base or offset, use it last
 851           __ sllx(to_reg-&gt;as_register_lo(), 32, to_reg-&gt;as_register_lo());
 852           __ or3(to_reg-&gt;as_register_lo(), O7, to_reg-&gt;as_register_lo());
 853         }
 854         break;
 855       case T_METADATA:  __ ld_ptr(base, offset, to_reg-&gt;as_register()); break;
 856       case T_ADDRESS:
 857         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 858           __ lduw(base, offset, to_reg-&gt;as_register());
 859           __ decode_klass_not_null(to_reg-&gt;as_register());
 860         } else
 861         {
 862           __ ld_ptr(base, offset, to_reg-&gt;as_register());
 863         }
 864         break;
 865       case T_ARRAY : // fall through
 866       case T_OBJECT:
 867         {
 868           if (UseCompressedOops &amp;&amp; !wide) {
 869             __ lduw(base, offset, to_reg-&gt;as_register());
 870             __ decode_heap_oop(to_reg-&gt;as_register());
 871           } else {
 872             __ ld_ptr(base, offset, to_reg-&gt;as_register());
 873           }
 874           break;
 875         }
 876       case T_FLOAT:  __ ldf(FloatRegisterImpl::S, base, offset, to_reg-&gt;as_float_reg()); break;
 877       case T_DOUBLE:
 878         {
 879           FloatRegister reg = to_reg-&gt;as_double_reg();
 880           // split unaligned loads
 881           if (unaligned || PatchALot) {
 882             __ ldf(FloatRegisterImpl::S, base, offset + 4, reg-&gt;successor());
 883             __ ldf(FloatRegisterImpl::S, base, offset,     reg);
 884           } else {
 885             __ ldf(FloatRegisterImpl::D, base, offset, to_reg-&gt;as_double_reg());
 886           }
 887           break;
 888         }
 889       default      : ShouldNotReachHere();
 890     }
 891     if (is_reference_type(type)) {
 892       __ verify_oop(to_reg-&gt;as_register());
 893     }
 894   }
 895   return load_offset;
 896 }
 897 
 898 
 899 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 900   int load_offset = code_offset();
 901   switch(type) {
 902     case T_BOOLEAN: // fall through
 903     case T_BYTE  :  __ ldsb(base, disp, to_reg-&gt;as_register()); break;
 904     case T_CHAR  :  __ lduh(base, disp, to_reg-&gt;as_register()); break;
 905     case T_SHORT :  __ ldsh(base, disp, to_reg-&gt;as_register()); break;
 906     case T_INT   :  __ ld(base, disp, to_reg-&gt;as_register()); break;
 907     case T_ADDRESS: __ ld_ptr(base, disp, to_reg-&gt;as_register()); break;
 908     case T_ARRAY : // fall through
 909     case T_OBJECT:
 910       {
 911           if (UseCompressedOops &amp;&amp; !wide) {
 912             __ lduw(base, disp, to_reg-&gt;as_register());
 913             __ decode_heap_oop(to_reg-&gt;as_register());
 914           } else {
 915             __ ld_ptr(base, disp, to_reg-&gt;as_register());
 916           }
 917           break;
 918       }
 919     case T_FLOAT:  __ ldf(FloatRegisterImpl::S, base, disp, to_reg-&gt;as_float_reg()); break;
 920     case T_DOUBLE: __ ldf(FloatRegisterImpl::D, base, disp, to_reg-&gt;as_double_reg()); break;
 921     case T_LONG  :
 922       __ ldx(base, disp, to_reg-&gt;as_register_lo());
 923       break;
 924     default      : ShouldNotReachHere();
 925   }
 926   if (is_reference_type(type)) {
 927     __ verify_oop(to_reg-&gt;as_register());
 928   }
 929   return load_offset;
 930 }
 931 
 932 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 933   LIR_Const* c = src-&gt;as_constant_ptr();
 934   switch (c-&gt;type()) {
 935     case T_INT:
 936     case T_FLOAT: {
 937       Register src_reg = O7;
 938       int value = c-&gt;as_jint_bits();
 939       if (value == 0) {
 940         src_reg = G0;
 941       } else {
 942         __ set(value, O7);
 943       }
 944       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 945       __ stw(src_reg, addr.base(), addr.disp());
 946       break;
 947     }
 948     case T_ADDRESS: {
 949       Register src_reg = O7;
 950       int value = c-&gt;as_jint_bits();
 951       if (value == 0) {
 952         src_reg = G0;
 953       } else {
 954         __ set(value, O7);
 955       }
 956       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 957       __ st_ptr(src_reg, addr.base(), addr.disp());
 958       break;
 959     }
 960     case T_OBJECT: {
 961       Register src_reg = O7;
 962       jobject2reg(c-&gt;as_jobject(), src_reg);
 963       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 964       __ st_ptr(src_reg, addr.base(), addr.disp());
 965       break;
 966     }
 967     case T_LONG:
 968     case T_DOUBLE: {
 969       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 970 
 971       Register tmp = O7;
 972       int value_lo = c-&gt;as_jint_lo_bits();
 973       if (value_lo == 0) {
 974         tmp = G0;
 975       } else {
 976         __ set(value_lo, O7);
 977       }
 978       __ stw(tmp, addr.base(), addr.disp() + lo_word_offset_in_bytes);
 979       int value_hi = c-&gt;as_jint_hi_bits();
 980       if (value_hi == 0) {
 981         tmp = G0;
 982       } else {
 983         __ set(value_hi, O7);
 984       }
 985       __ stw(tmp, addr.base(), addr.disp() + hi_word_offset_in_bytes);
 986       break;
 987     }
 988     default:
 989       Unimplemented();
 990   }
 991 }
 992 
 993 
 994 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 995   LIR_Const* c = src-&gt;as_constant_ptr();
 996   LIR_Address* addr     = dest-&gt;as_address_ptr();
 997   Register base = addr-&gt;base()-&gt;as_pointer_register();
 998   int offset = -1;
 999 
1000   switch (c-&gt;type()) {
1001     case T_FLOAT: type = T_INT; // Float constants are stored by int store instructions.
1002     case T_INT:
1003     case T_ADDRESS: {
1004       LIR_Opr tmp = FrameMap::O7_opr;
1005       int value = c-&gt;as_jint_bits();
1006       if (value == 0) {
1007         tmp = FrameMap::G0_opr;
1008       } else if (Assembler::is_simm13(value)) {
1009         __ set(value, O7);
1010       }
1011       if (addr-&gt;index()-&gt;is_valid()) {
1012         assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
1013         offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
1014       } else {
1015         assert(Assembler::is_simm13(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
1016         offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
1017       }
1018       break;
1019     }
1020     case T_LONG:
1021     case T_DOUBLE: {
1022       assert(!addr-&gt;index()-&gt;is_valid(), &quot;can&#39;t handle reg reg address here&quot;);
1023       assert(Assembler::is_simm13(addr-&gt;disp()) &amp;&amp;
1024              Assembler::is_simm13(addr-&gt;disp() + 4), &quot;can&#39;t handle larger addresses&quot;);
1025 
1026       LIR_Opr tmp = FrameMap::O7_opr;
1027       int value_lo = c-&gt;as_jint_lo_bits();
1028       if (value_lo == 0) {
1029         tmp = FrameMap::G0_opr;
1030       } else {
1031         __ set(value_lo, O7);
1032       }
1033       offset = store(tmp, base, addr-&gt;disp() + lo_word_offset_in_bytes, T_INT, wide, false);
1034       int value_hi = c-&gt;as_jint_hi_bits();
1035       if (value_hi == 0) {
1036         tmp = FrameMap::G0_opr;
1037       } else {
1038         __ set(value_hi, O7);
1039       }
1040       store(tmp, base, addr-&gt;disp() + hi_word_offset_in_bytes, T_INT, wide, false);
1041       break;
1042     }
1043     case T_OBJECT: {
1044       jobject obj = c-&gt;as_jobject();
1045       LIR_Opr tmp;
1046       if (obj == NULL) {
1047         tmp = FrameMap::G0_opr;
1048       } else {
1049         tmp = FrameMap::O7_opr;
1050         jobject2reg(c-&gt;as_jobject(), O7);
1051       }
1052       // handle either reg+reg or reg+disp address
1053       if (addr-&gt;index()-&gt;is_valid()) {
1054         assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
1055         offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
1056       } else {
1057         assert(Assembler::is_simm13(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
1058         offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
1059       }
1060 
1061       break;
1062     }
1063     default:
1064       Unimplemented();
1065   }
1066   if (info != NULL) {
1067     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
1068     add_debug_info_for_null_check(offset, info);
1069   }
1070 }
1071 
1072 
1073 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
1074   LIR_Const* c = src-&gt;as_constant_ptr();
1075   LIR_Opr to_reg = dest;
1076 
1077   switch (c-&gt;type()) {
1078     case T_INT:
1079     case T_ADDRESS:
1080       {
1081         jint con = c-&gt;as_jint();
1082         if (to_reg-&gt;is_single_cpu()) {
1083           assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
1084           __ set(con, to_reg-&gt;as_register());
1085         } else {
1086           ShouldNotReachHere();
1087           assert(to_reg-&gt;is_single_fpu(), &quot;wrong register kind&quot;);
1088 
1089           __ set(con, O7);
1090           Address temp_slot(SP, (frame::register_save_words * wordSize) + STACK_BIAS);
1091           __ st(O7, temp_slot);
1092           __ ldf(FloatRegisterImpl::S, temp_slot, to_reg-&gt;as_float_reg());
1093         }
1094       }
1095       break;
1096 
1097     case T_LONG:
1098       {
1099         jlong con = c-&gt;as_jlong();
1100 
1101         if (to_reg-&gt;is_double_cpu()) {
1102           __ set(con,  to_reg-&gt;as_register_lo());
1103         } else if (to_reg-&gt;is_single_cpu()) {
1104           __ set(con, to_reg-&gt;as_register());
1105         } else {
1106           ShouldNotReachHere();
1107           assert(to_reg-&gt;is_double_fpu(), &quot;wrong register kind&quot;);
1108           Address temp_slot_lo(SP, ((frame::register_save_words  ) * wordSize) + STACK_BIAS);
1109           Address temp_slot_hi(SP, ((frame::register_save_words) * wordSize) + (longSize/2) + STACK_BIAS);
1110           __ set(low(con),  O7);
1111           __ st(O7, temp_slot_lo);
1112           __ set(high(con), O7);
1113           __ st(O7, temp_slot_hi);
1114           __ ldf(FloatRegisterImpl::D, temp_slot_lo, to_reg-&gt;as_double_reg());
1115         }
1116       }
1117       break;
1118 
1119     case T_OBJECT:
1120       {
1121         if (patch_code == lir_patch_none) {
1122           jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
1123         } else {
1124           jobject2reg_with_patching(to_reg-&gt;as_register(), info);
1125         }
1126       }
1127       break;
1128 
1129     case T_METADATA:
1130       {
1131         if (patch_code == lir_patch_none) {
1132           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1133         } else {
1134           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1135         }
1136       }
1137       break;
1138 
1139     case T_FLOAT:
1140       {
1141         address const_addr = __ float_constant(c-&gt;as_jfloat());
1142         if (const_addr == NULL) {
1143           bailout(&quot;const section overflow&quot;);
1144           break;
1145         }
1146         RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1147         AddressLiteral const_addrlit(const_addr, rspec);
1148         if (to_reg-&gt;is_single_fpu()) {
1149           __ patchable_sethi(const_addrlit, O7);
1150           __ relocate(rspec);
1151           __ ldf(FloatRegisterImpl::S, O7, const_addrlit.low10(), to_reg-&gt;as_float_reg());
1152 
1153         } else {
1154           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1155 
1156           __ set(const_addrlit, O7);
1157           __ ld(O7, 0, to_reg-&gt;as_register());
1158         }
1159       }
1160       break;
1161 
1162     case T_DOUBLE:
1163       {
1164         address const_addr = __ double_constant(c-&gt;as_jdouble());
1165         if (const_addr == NULL) {
1166           bailout(&quot;const section overflow&quot;);
1167           break;
1168         }
1169         RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1170 
1171         if (to_reg-&gt;is_double_fpu()) {
1172           AddressLiteral const_addrlit(const_addr, rspec);
1173           __ patchable_sethi(const_addrlit, O7);
1174           __ relocate(rspec);
1175           __ ldf (FloatRegisterImpl::D, O7, const_addrlit.low10(), to_reg-&gt;as_double_reg());
1176         } else {
1177           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1178           __ set(jlong_cast(c-&gt;as_jdouble()), to_reg-&gt;as_register_lo());
1179         }
1180 
1181       }
1182       break;
1183 
1184     default:
1185       ShouldNotReachHere();
1186   }
1187 }
1188 
1189 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1190   Register reg = addr-&gt;base()-&gt;as_pointer_register();
1191   LIR_Opr index = addr-&gt;index();
1192   if (index-&gt;is_illegal()) {
1193     return Address(reg, addr-&gt;disp());
1194   } else {
1195     assert (addr-&gt;disp() == 0, &quot;unsupported address mode&quot;);
1196     return Address(reg, index-&gt;as_pointer_register());
1197   }
1198 }
1199 
1200 
1201 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1202   switch (type) {
1203     case T_INT:
1204     case T_FLOAT: {
1205       Register tmp = O7;
1206       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1207       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1208       __ lduw(from.base(), from.disp(), tmp);
1209       __ stw(tmp, to.base(), to.disp());
1210       break;
1211     }
1212     case T_ADDRESS:
1213     case T_OBJECT: {
1214       Register tmp = O7;
1215       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1216       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1217       __ ld_ptr(from.base(), from.disp(), tmp);
1218       __ st_ptr(tmp, to.base(), to.disp());
1219       break;
1220     }
1221     case T_LONG:
1222     case T_DOUBLE: {
1223       Register tmp = O7;
1224       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1225       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1226       __ lduw(from.base(), from.disp(), tmp);
1227       __ stw(tmp, to.base(), to.disp());
1228       __ lduw(from.base(), from.disp() + 4, tmp);
1229       __ stw(tmp, to.base(), to.disp() + 4);
1230       break;
1231     }
1232 
1233     default:
1234       ShouldNotReachHere();
1235   }
1236 }
1237 
1238 
1239 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1240   Address base = as_Address(addr);
1241   return Address(base.base(), base.disp() + hi_word_offset_in_bytes);
1242 }
1243 
1244 
1245 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1246   Address base = as_Address(addr);
1247   return Address(base.base(), base.disp() + lo_word_offset_in_bytes);
1248 }
1249 
1250 
1251 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1252                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1253 
1254   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1255   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1256   LIR_Opr to_reg = dest;
1257 
1258   Register src = addr-&gt;base()-&gt;as_pointer_register();
1259   Register disp_reg = noreg;
1260   int disp_value = addr-&gt;disp();
1261   bool needs_patching = (patch_code != lir_patch_none);
1262 
1263   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1264     __ verify_oop(src);
1265   }
1266 
1267   PatchingStub* patch = NULL;
1268   if (needs_patching) {
1269     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1270     assert(!to_reg-&gt;is_double_cpu() ||
1271            patch_code == lir_patch_none ||
1272            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1273   }
1274 
1275   if (addr-&gt;index()-&gt;is_illegal()) {
1276     if (!Assembler::is_simm13(disp_value) &amp;&amp; (!unaligned || Assembler::is_simm13(disp_value + 4))) {
1277       if (needs_patching) {
1278         __ patchable_set(0, O7);
1279       } else {
1280         __ set(disp_value, O7);
1281       }
1282       disp_reg = O7;
1283     }
1284   } else if (unaligned || PatchALot) {
1285     __ add(src, addr-&gt;index()-&gt;as_pointer_register(), O7);
1286     src = O7;
1287   } else {
1288     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1289     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1290   }
1291 
1292   // remember the offset of the load.  The patching_epilog must be done
1293   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1294   // entered in increasing order.
1295   int offset = code_offset();
1296 
1297   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1298   if (disp_reg == noreg) {
1299     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1300   } else {
1301     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1302     offset = load(src, disp_reg, to_reg, type, wide);
1303   }
1304 
1305   if (patch != NULL) {
1306     patching_epilog(patch, patch_code, src, info);
1307   }
1308   if (info != NULL) add_debug_info_for_null_check(offset, info);
1309 }
1310 
1311 
1312 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1313   Address addr;
1314   if (src-&gt;is_single_word()) {
1315     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1316   } else if (src-&gt;is_double_word())  {
1317     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1318   }
1319 
1320   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1321   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1322 }
1323 
1324 
1325 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1326   Address addr;
1327   if (dest-&gt;is_single_word()) {
1328     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1329   } else if (dest-&gt;is_double_word())  {
1330     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1331   }
1332   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1333   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1334 }
1335 
1336 
1337 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1338   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1339     if (from_reg-&gt;is_double_fpu()) {
1340       // double to double moves
1341       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1342       __ fmov(FloatRegisterImpl::D, from_reg-&gt;as_double_reg(), to_reg-&gt;as_double_reg());
1343     } else {
1344       // float to float moves
1345       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1346       __ fmov(FloatRegisterImpl::S, from_reg-&gt;as_float_reg(), to_reg-&gt;as_float_reg());
1347     }
1348   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1349     if (from_reg-&gt;is_double_cpu()) {
1350       __ mov(from_reg-&gt;as_pointer_register(), to_reg-&gt;as_pointer_register());
1351     } else if (to_reg-&gt;is_double_cpu()) {
1352       // int to int moves
1353       __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register_lo());
1354     } else {
1355       // int to int moves
1356       __ mov(from_reg-&gt;as_register(), to_reg-&gt;as_register());
1357     }
1358   } else {
1359     ShouldNotReachHere();
1360   }
1361   if (is_reference_type(to_reg-&gt;type())) {
1362     __ verify_oop(to_reg-&gt;as_register());
1363   }
1364 }
1365 
1366 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1367                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1368                             bool wide, bool unaligned) {
1369   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1370   LIR_Address* addr = dest-&gt;as_address_ptr();
1371 
1372   Register src = addr-&gt;base()-&gt;as_pointer_register();
1373   Register disp_reg = noreg;
1374   int disp_value = addr-&gt;disp();
1375   bool needs_patching = (patch_code != lir_patch_none);
1376 
1377   if (addr-&gt;base()-&gt;is_oop_register()) {
1378     __ verify_oop(src);
1379   }
1380 
1381   PatchingStub* patch = NULL;
1382   if (needs_patching) {
1383     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1384     assert(!from_reg-&gt;is_double_cpu() ||
1385            patch_code == lir_patch_none ||
1386            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1387   }
1388 
1389   if (addr-&gt;index()-&gt;is_illegal()) {
1390     if (!Assembler::is_simm13(disp_value) &amp;&amp; (!unaligned || Assembler::is_simm13(disp_value + 4))) {
1391       if (needs_patching) {
1392         __ patchable_set(0, O7);
1393       } else {
1394         __ set(disp_value, O7);
1395       }
1396       disp_reg = O7;
1397     }
1398   } else if (unaligned || PatchALot) {
1399     __ add(src, addr-&gt;index()-&gt;as_pointer_register(), O7);
1400     src = O7;
1401   } else {
1402     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1403     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1404   }
1405 
1406   // remember the offset of the store.  The patching_epilog must be done
1407   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1408   // entered in increasing order.
1409   int offset;
1410 
1411   assert(disp_reg != noreg || Assembler::is_simm13(disp_value), &quot;should have set this up&quot;);
1412   if (disp_reg == noreg) {
1413     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1414   } else {
1415     assert(!unaligned, &quot;can&#39;t handle this&quot;);
1416     offset = store(from_reg, src, disp_reg, type, wide);
1417   }
1418 
1419   if (patch != NULL) {
1420     patching_epilog(patch, patch_code, src, info);
1421   }
1422 
1423   if (info != NULL) add_debug_info_for_null_check(offset, info);
1424 }
1425 
1426 
1427 void LIR_Assembler::return_op(LIR_Opr result) {
1428   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1429     __ reserved_stack_check();
1430   }
1431   __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);
1432   __ relocate(relocInfo::poll_return_type);
1433   __ ld_ptr(L0, 0, G0);
1434   __ ret();
1435   __ delayed()-&gt;restore();
1436 }
1437 
1438 
1439 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1440   __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), tmp-&gt;as_register());
1441   if (info != NULL) {
1442     add_debug_info_for_branch(info);
1443   }
1444   int offset = __ offset();
1445 
1446   __ relocate(relocInfo::poll_type);
1447   __ ld_ptr(tmp-&gt;as_register(), 0, G0);
1448   return offset;
1449 }
1450 
1451 
1452 void LIR_Assembler::emit_static_call_stub() {
1453   address call_pc = __ pc();
1454   address stub = __ start_a_stub(call_stub_size());
1455   if (stub == NULL) {
1456     bailout(&quot;static call stub overflow&quot;);
1457     return;
1458   }
1459 
1460   int start = __ offset();
1461   __ relocate(static_stub_Relocation::spec(call_pc));
1462 
1463   __ set_metadata(NULL, G5);
1464   // must be set to -1 at code generation time
1465   AddressLiteral addrlit(-1);
1466   __ jump_to(addrlit, G3);
1467   __ delayed()-&gt;nop();
1468 
1469   assert(__ offset() - start &lt;= call_stub_size(), &quot;stub too big&quot;);
1470   __ end_a_stub();
1471 }
1472 
1473 
1474 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1475   if (opr1-&gt;is_single_fpu()) {
1476     __ fcmp(FloatRegisterImpl::S, Assembler::fcc0, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1477   } else if (opr1-&gt;is_double_fpu()) {
1478     __ fcmp(FloatRegisterImpl::D, Assembler::fcc0, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1479   } else if (opr1-&gt;is_single_cpu()) {
1480     if (opr2-&gt;is_constant()) {
1481       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1482         case T_INT:
1483           { jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1484             if (Assembler::is_simm13(con)) {
1485               __ cmp(opr1-&gt;as_register(), con);
1486             } else {
1487               __ set(con, O7);
1488               __ cmp(opr1-&gt;as_register(), O7);
1489             }
1490           }
1491           break;
1492 
1493         case T_OBJECT:
1494           // there are only equal/notequal comparisions on objects
1495           { jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1496             if (con == NULL) {
1497               __ cmp(opr1-&gt;as_register(), 0);
1498             } else {
1499               jobject2reg(con, O7);
1500               __ cmp(opr1-&gt;as_register(), O7);
1501             }
1502           }
1503           break;
1504 
1505         case T_METADATA:
1506           // We only need, for now, comparison with NULL for metadata.
1507           { assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1508             Metadata* m = opr2-&gt;as_constant_ptr()-&gt;as_metadata();
1509             if (m == NULL) {
1510               __ cmp(opr1-&gt;as_register(), 0);
1511             } else {
1512               ShouldNotReachHere();
1513             }
1514           }
1515           break;
1516 
1517         default:
1518           ShouldNotReachHere();
1519           break;
1520       }
1521     } else {
1522       if (opr2-&gt;is_address()) {
1523         LIR_Address * addr = opr2-&gt;as_address_ptr();
1524         BasicType type = addr-&gt;type();
1525         if ( type == T_OBJECT ) __ ld_ptr(as_Address(addr), O7);
1526         else                    __ ld(as_Address(addr), O7);
1527         __ cmp(opr1-&gt;as_register(), O7);
1528       } else {
1529         __ cmp(opr1-&gt;as_register(), opr2-&gt;as_register());
1530       }
1531     }
1532   } else if (opr1-&gt;is_double_cpu()) {
1533     Register xlo = opr1-&gt;as_register_lo();
1534     Register xhi = opr1-&gt;as_register_hi();
1535     if (opr2-&gt;is_constant() &amp;&amp; opr2-&gt;as_jlong() == 0) {
1536       assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;only handles these cases&quot;);
1537       __ orcc(xhi, G0, G0);
1538     } else if (opr2-&gt;is_register()) {
1539       Register ylo = opr2-&gt;as_register_lo();
1540       Register yhi = opr2-&gt;as_register_hi();
1541       __ cmp(xlo, ylo);
1542     } else {
1543       ShouldNotReachHere();
1544     }
1545   } else if (opr1-&gt;is_address()) {
1546     LIR_Address * addr = opr1-&gt;as_address_ptr();
1547     BasicType type = addr-&gt;type();
1548     assert (opr2-&gt;is_constant(), &quot;Checking&quot;);
1549     if ( type == T_OBJECT ) __ ld_ptr(as_Address(addr), O7);
1550     else                    __ ld(as_Address(addr), O7);
1551     __ cmp(O7, opr2-&gt;as_constant_ptr()-&gt;as_jint());
1552   } else {
1553     ShouldNotReachHere();
1554   }
1555 }
1556 
1557 
1558 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1559   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1560     bool is_unordered_less = (code == lir_ucmp_fd2i);
1561     if (left-&gt;is_single_fpu()) {
1562       __ float_cmp(true, is_unordered_less ? -1 : 1, left-&gt;as_float_reg(), right-&gt;as_float_reg(), dst-&gt;as_register());
1563     } else if (left-&gt;is_double_fpu()) {
1564       __ float_cmp(false, is_unordered_less ? -1 : 1, left-&gt;as_double_reg(), right-&gt;as_double_reg(), dst-&gt;as_register());
1565     } else {
1566       ShouldNotReachHere();
1567     }
1568   } else if (code == lir_cmp_l2i) {
1569     __ lcmp(left-&gt;as_register_lo(), right-&gt;as_register_lo(), dst-&gt;as_register());
1570   } else {
1571     ShouldNotReachHere();
1572   }
1573 }
1574 
1575 
1576 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1577   Assembler::Condition acond;
1578   switch (condition) {
1579     case lir_cond_equal:        acond = Assembler::equal;        break;
1580     case lir_cond_notEqual:     acond = Assembler::notEqual;     break;
1581     case lir_cond_less:         acond = Assembler::less;         break;
1582     case lir_cond_lessEqual:    acond = Assembler::lessEqual;    break;
1583     case lir_cond_greaterEqual: acond = Assembler::greaterEqual; break;
1584     case lir_cond_greater:      acond = Assembler::greater;      break;
1585     case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned;      break;
1586     case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;      break;
1587     default:                         ShouldNotReachHere();
1588   };
1589 
1590   if (opr1-&gt;is_constant() &amp;&amp; opr1-&gt;type() == T_INT) {
1591     Register dest = result-&gt;as_register();
1592     // load up first part of constant before branch
1593     // and do the rest in the delay slot.
1594     if (!Assembler::is_simm13(opr1-&gt;as_jint())) {
1595       __ sethi(opr1-&gt;as_jint(), dest);
1596     }
1597   } else if (opr1-&gt;is_constant()) {
1598     const2reg(opr1, result, lir_patch_none, NULL);
1599   } else if (opr1-&gt;is_register()) {
1600     reg2reg(opr1, result);
1601   } else if (opr1-&gt;is_stack()) {
1602     stack2reg(opr1, result, result-&gt;type());
1603   } else {
1604     ShouldNotReachHere();
1605   }
1606   Label skip;
1607     if  (type == T_INT) {
1608       __ br(acond, false, Assembler::pt, skip);
1609     } else {
1610       __ brx(acond, false, Assembler::pt, skip); // checks icc on 32bit and xcc on 64bit
1611     }
1612   if (opr1-&gt;is_constant() &amp;&amp; opr1-&gt;type() == T_INT) {
1613     Register dest = result-&gt;as_register();
1614     if (Assembler::is_simm13(opr1-&gt;as_jint())) {
1615       __ delayed()-&gt;or3(G0, opr1-&gt;as_jint(), dest);
1616     } else {
1617       // the sethi has been done above, so just put in the low 10 bits
1618       __ delayed()-&gt;or3(dest, opr1-&gt;as_jint() &amp; 0x3ff, dest);
1619     }
1620   } else {
1621     // can&#39;t do anything useful in the delay slot
1622     __ delayed()-&gt;nop();
1623   }
1624   if (opr2-&gt;is_constant()) {
1625     const2reg(opr2, result, lir_patch_none, NULL);
1626   } else if (opr2-&gt;is_register()) {
1627     reg2reg(opr2, result);
1628   } else if (opr2-&gt;is_stack()) {
1629     stack2reg(opr2, result, result-&gt;type());
1630   } else {
1631     ShouldNotReachHere();
1632   }
1633   __ bind(skip);
1634 }
1635 
1636 
1637 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest, CodeEmitInfo* info, bool pop_fpu_stack) {
1638   assert(info == NULL, &quot;unused on this code path&quot;);
1639   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1640   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1641 
1642   if (right-&gt;is_register()) {
1643     if (dest-&gt;is_float_kind()) {
1644 
1645       FloatRegister lreg, rreg, res;
1646       FloatRegisterImpl::Width w;
1647       if (right-&gt;is_single_fpu()) {
1648         w = FloatRegisterImpl::S;
1649         lreg = left-&gt;as_float_reg();
1650         rreg = right-&gt;as_float_reg();
1651         res  = dest-&gt;as_float_reg();
1652       } else {
1653         w = FloatRegisterImpl::D;
1654         lreg = left-&gt;as_double_reg();
1655         rreg = right-&gt;as_double_reg();
1656         res  = dest-&gt;as_double_reg();
1657       }
1658 
1659       switch (code) {
1660         case lir_add: __ fadd(w, lreg, rreg, res); break;
1661         case lir_sub: __ fsub(w, lreg, rreg, res); break;
1662         case lir_mul: // fall through
1663         case lir_mul_strictfp: __ fmul(w, lreg, rreg, res); break;
1664         case lir_div: // fall through
1665         case lir_div_strictfp: __ fdiv(w, lreg, rreg, res); break;
1666         default: ShouldNotReachHere();
1667       }
1668 
1669     } else if (dest-&gt;is_double_cpu()) {
1670       Register dst_lo = dest-&gt;as_register_lo();
1671       Register op1_lo = left-&gt;as_pointer_register();
1672       Register op2_lo = right-&gt;as_pointer_register();
1673 
1674       switch (code) {
1675         case lir_add:
1676           __ add(op1_lo, op2_lo, dst_lo);
1677           break;
1678 
1679         case lir_sub:
1680           __ sub(op1_lo, op2_lo, dst_lo);
1681           break;
1682 
1683         default: ShouldNotReachHere();
1684       }
1685     } else {
1686       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1687 
1688       Register lreg = left-&gt;as_register();
1689       Register res  = dest-&gt;as_register();
1690       Register rreg = right-&gt;as_register();
1691       switch (code) {
1692         case lir_add:  __ add  (lreg, rreg, res); break;
1693         case lir_sub:  __ sub  (lreg, rreg, res); break;
1694         case lir_mul:  __ mulx (lreg, rreg, res); break;
1695         default: ShouldNotReachHere();
1696       }
1697     }
1698   } else {
1699     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1700 
1701     if (dest-&gt;is_single_cpu()) {
1702       Register lreg = left-&gt;as_register();
1703       Register res  = dest-&gt;as_register();
1704       int    simm13 = right-&gt;as_constant_ptr()-&gt;as_jint();
1705 
1706       switch (code) {
1707         case lir_add:  __ add  (lreg, simm13, res); break;
1708         case lir_sub:  __ sub  (lreg, simm13, res); break;
1709         case lir_mul:  __ mulx (lreg, simm13, res); break;
1710         default: ShouldNotReachHere();
1711       }
1712     } else {
1713       Register lreg = left-&gt;as_pointer_register();
1714       Register res  = dest-&gt;as_register_lo();
1715       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1716       assert(Assembler::is_simm13(con), &quot;must be simm13&quot;);
1717 
1718       switch (code) {
1719         case lir_add:  __ add  (lreg, (int)con, res); break;
1720         case lir_sub:  __ sub  (lreg, (int)con, res); break;
1721         case lir_mul:  __ mulx (lreg, (int)con, res); break;
1722         default: ShouldNotReachHere();
1723       }
1724     }
1725   }
1726 }
1727 
1728 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1729   switch (code) {
1730     case lir_tan: {
1731       assert(thread-&gt;is_valid(), &quot;preserve the thread object for performance reasons&quot;);
1732       assert(dest-&gt;as_double_reg() == F0, &quot;the result will be in f0/f1&quot;);
1733       break;
1734     }
1735     case lir_sqrt: {
1736       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for dsqrt&quot;);
1737       FloatRegister src_reg = value-&gt;as_double_reg();
1738       FloatRegister dst_reg = dest-&gt;as_double_reg();
1739       __ fsqrt(FloatRegisterImpl::D, src_reg, dst_reg);
1740       break;
1741     }
1742     case lir_abs: {
1743       assert(!thread-&gt;is_valid(), &quot;there is no need for a thread_reg for fabs&quot;);
1744       FloatRegister src_reg = value-&gt;as_double_reg();
1745       FloatRegister dst_reg = dest-&gt;as_double_reg();
1746       __ fabs(FloatRegisterImpl::D, src_reg, dst_reg);
1747       break;
1748     }
1749     default: {
1750       ShouldNotReachHere();
1751       break;
1752     }
1753   }
1754 }
1755 
1756 
1757 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1758   if (right-&gt;is_constant()) {
1759     if (dest-&gt;is_single_cpu()) {
1760       int simm13 = right-&gt;as_constant_ptr()-&gt;as_jint();
1761       switch (code) {
1762         case lir_logic_and:   __ and3 (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1763         case lir_logic_or:    __ or3  (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1764         case lir_logic_xor:   __ xor3 (left-&gt;as_register(), simm13, dest-&gt;as_register()); break;
1765         default: ShouldNotReachHere();
1766       }
1767     } else {
1768       long c = right-&gt;as_constant_ptr()-&gt;as_jlong();
1769       assert(c == (int)c &amp;&amp; Assembler::is_simm13(c), &quot;out of range&quot;);
1770       int simm13 = (int)c;
1771       switch (code) {
1772         case lir_logic_and:
1773           __ and3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1774           break;
1775 
1776         case lir_logic_or:
1777           __ or3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1778           break;
1779 
1780         case lir_logic_xor:
1781           __ xor3 (left-&gt;as_register_lo(), simm13, dest-&gt;as_register_lo());
1782           break;
1783 
1784         default: ShouldNotReachHere();
1785       }
1786     }
1787   } else {
1788     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1789 
1790     if (dest-&gt;is_single_cpu()) {
1791       switch (code) {
1792         case lir_logic_and:   __ and3 (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1793         case lir_logic_or:    __ or3  (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1794         case lir_logic_xor:   __ xor3 (left-&gt;as_register(), right-&gt;as_register(), dest-&gt;as_register()); break;
1795         default: ShouldNotReachHere();
1796       }
1797     } else {
1798       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1799                                                                         left-&gt;as_register_lo();
1800       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1801                                                                           right-&gt;as_register_lo();
1802 
1803       switch (code) {
1804         case lir_logic_and: __ and3 (l, r, dest-&gt;as_register_lo()); break;
1805         case lir_logic_or:  __ or3  (l, r, dest-&gt;as_register_lo()); break;
1806         case lir_logic_xor: __ xor3 (l, r, dest-&gt;as_register_lo()); break;
1807         default: ShouldNotReachHere();
1808       }
1809     }
1810   }
1811 }
1812 
1813 
1814 int LIR_Assembler::shift_amount(BasicType t) {
1815   int elem_size = type2aelembytes(t);
1816   switch (elem_size) {
1817     case 1 : return 0;
1818     case 2 : return 1;
1819     case 4 : return 2;
1820     case 8 : return 3;
1821   }
1822   ShouldNotReachHere();
1823   return -1;
1824 }
1825 
1826 
1827 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1828   assert(exceptionOop-&gt;as_register() == Oexception, &quot;should match&quot;);
1829   assert(exceptionPC-&gt;as_register() == Oissuing_pc, &quot;should match&quot;);
1830 
1831   info-&gt;add_register_oop(exceptionOop);
1832 
1833   // reuse the debug info from the safepoint poll for the throw op itself
1834   address pc_for_athrow  = __ pc();
1835   int pc_for_athrow_offset = __ offset();
1836   RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1837   __ set(pc_for_athrow, Oissuing_pc, rspec);
1838   add_call_info(pc_for_athrow_offset, info); // for exception handler
1839 
1840   __ call(Runtime1::entry_for(Runtime1::handle_exception_id), relocInfo::runtime_call_type);
1841   __ delayed()-&gt;nop();
1842 }
1843 
1844 
1845 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1846   assert(exceptionOop-&gt;as_register() == Oexception, &quot;should match&quot;);
1847 
1848   __ br(Assembler::always, false, Assembler::pt, _unwind_handler_entry);
1849   __ delayed()-&gt;nop();
1850 }
1851 
1852 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1853   Register src = op-&gt;src()-&gt;as_register();
1854   Register dst = op-&gt;dst()-&gt;as_register();
1855   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1856   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1857   Register length  = op-&gt;length()-&gt;as_register();
1858   Register tmp = op-&gt;tmp()-&gt;as_register();
1859   Register tmp2 = O7;
1860 
1861   int flags = op-&gt;flags();
1862   ciArrayKlass* default_type = op-&gt;expected_type();
1863   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1864   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1865 
1866   // higher 32bits must be null
1867   __ sra(dst_pos, 0, dst_pos);
1868   __ sra(src_pos, 0, src_pos);
1869   __ sra(length, 0, length);
1870 
1871   // set up the arraycopy stub information
1872   ArrayCopyStub* stub = op-&gt;stub();
1873 
1874   // always do stub if no type information is available.  it&#39;s ok if
1875   // the known type isn&#39;t loaded since the code sanity checks
1876   // in debug mode and the type isn&#39;t required when we know the exact type
1877   // also check that the type is an array type.
1878   if (op-&gt;expected_type() == NULL) {
1879     __ mov(src,     O0);
1880     __ mov(src_pos, O1);
1881     __ mov(dst,     O2);
1882     __ mov(dst_pos, O3);
1883     __ mov(length,  O4);
1884     address copyfunc_addr = StubRoutines::generic_arraycopy();
1885     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1886 
1887 #ifndef PRODUCT
1888     if (PrintC1Statistics) {
1889       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1890       __ inc_counter(counter, G1, G3);
1891     }
1892 #endif
1893     __ call_VM_leaf(tmp, copyfunc_addr);
1894 
1895     __ xor3(O0, -1, tmp);
1896     __ sub(length, tmp, length);
1897     __ add(src_pos, tmp, src_pos);
1898     __ cmp_zero_and_br(Assembler::less, O0, *stub-&gt;entry());
1899     __ delayed()-&gt;add(dst_pos, tmp, dst_pos);
1900     __ bind(*stub-&gt;continuation());
1901     return;
1902   }
1903 
1904   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1905 
1906   // make sure src and dst are non-null and load array length
1907   if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1908     __ tst(src);
1909     __ brx(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
1910     __ delayed()-&gt;nop();
1911   }
1912 
1913   if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1914     __ tst(dst);
1915     __ brx(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
1916     __ delayed()-&gt;nop();
1917   }
1918 
1919   // If the compiler was not able to prove that exact type of the source or the destination
1920   // of the arraycopy is an array type, check at runtime if the source or the destination is
1921   // an instance type.
1922   if (flags &amp; LIR_OpArrayCopy::type_check) {
1923     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::dst_objarray)) {
1924       __ load_klass(dst, tmp);
1925       __ lduw(tmp, in_bytes(Klass::layout_helper_offset()), tmp2);
1926       __ cmp(tmp2, Klass::_lh_neutral_value);
1927       __ br(Assembler::greaterEqual, false, Assembler::pn, *stub-&gt;entry());
1928       __ delayed()-&gt;nop();
1929     }
1930 
1931     if (!(flags &amp; LIR_OpArrayCopy::LIR_OpArrayCopy::src_objarray)) {
1932       __ load_klass(src, tmp);
1933       __ lduw(tmp, in_bytes(Klass::layout_helper_offset()), tmp2);
1934       __ cmp(tmp2, Klass::_lh_neutral_value);
1935       __ br(Assembler::greaterEqual, false, Assembler::pn, *stub-&gt;entry());
1936       __ delayed()-&gt;nop();
1937     }
1938   }
1939 
1940   if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1941     // test src_pos register
1942     __ cmp_zero_and_br(Assembler::less, src_pos, *stub-&gt;entry());
1943     __ delayed()-&gt;nop();
1944   }
1945 
1946   if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1947     // test dst_pos register
1948     __ cmp_zero_and_br(Assembler::less, dst_pos, *stub-&gt;entry());
1949     __ delayed()-&gt;nop();
1950   }
1951 
1952   if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1953     // make sure length isn&#39;t negative
1954     __ cmp_zero_and_br(Assembler::less, length, *stub-&gt;entry());
1955     __ delayed()-&gt;nop();
1956   }
1957 
1958   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1959     __ ld(src, arrayOopDesc::length_offset_in_bytes(), tmp2);
1960     __ add(length, src_pos, tmp);
1961     __ cmp(tmp2, tmp);
1962     __ br(Assembler::carrySet, false, Assembler::pn, *stub-&gt;entry());
1963     __ delayed()-&gt;nop();
1964   }
1965 
1966   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1967     __ ld(dst, arrayOopDesc::length_offset_in_bytes(), tmp2);
1968     __ add(length, dst_pos, tmp);
1969     __ cmp(tmp2, tmp);
1970     __ br(Assembler::carrySet, false, Assembler::pn, *stub-&gt;entry());
1971     __ delayed()-&gt;nop();
1972   }
1973 
1974   int shift = shift_amount(basic_type);
1975 
1976   if (flags &amp; LIR_OpArrayCopy::type_check) {
1977     // We don&#39;t know the array types are compatible
1978     if (basic_type != T_OBJECT) {
1979       // Simple test for basic type arrays
1980       if (UseCompressedClassPointers) {
1981         // We don&#39;t need decode because we just need to compare
1982         __ lduw(src, oopDesc::klass_offset_in_bytes(), tmp);
1983         __ lduw(dst, oopDesc::klass_offset_in_bytes(), tmp2);
1984         __ cmp(tmp, tmp2);
1985         __ br(Assembler::notEqual, false, Assembler::pt, *stub-&gt;entry());
1986       } else {
1987         __ ld_ptr(src, oopDesc::klass_offset_in_bytes(), tmp);
1988         __ ld_ptr(dst, oopDesc::klass_offset_in_bytes(), tmp2);
1989         __ cmp(tmp, tmp2);
1990         __ brx(Assembler::notEqual, false, Assembler::pt, *stub-&gt;entry());
1991       }
1992       __ delayed()-&gt;nop();
1993     } else {
1994       // For object arrays, if src is a sub class of dst then we can
1995       // safely do the copy.
1996       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
1997 
1998       Label cont, slow;
1999       assert_different_registers(tmp, tmp2, G3, G1);
2000 
2001       __ load_klass(src, G3);
2002       __ load_klass(dst, G1);
2003 
2004       __ check_klass_subtype_fast_path(G3, G1, tmp, tmp2, &amp;cont, copyfunc_addr == NULL ? stub-&gt;entry() : &amp;slow, NULL);
2005 
2006       __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2007       __ delayed()-&gt;nop();
2008 
2009       __ cmp(G3, 0);
2010       if (copyfunc_addr != NULL) { // use stub if available
2011         // src is not a sub class of dst so we have to do a
2012         // per-element check.
2013         __ br(Assembler::notEqual, false, Assembler::pt, cont);
2014         __ delayed()-&gt;nop();
2015 
2016         __ bind(slow);
2017 
2018         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2019         if ((flags &amp; mask) != mask) {
2020           // Check that at least both of them object arrays.
2021           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2022 
2023           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2024             __ load_klass(src, tmp);
2025           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2026             __ load_klass(dst, tmp);
2027           }
2028           int lh_offset = in_bytes(Klass::layout_helper_offset());
2029 
2030           __ lduw(tmp, lh_offset, tmp2);
2031 
2032           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2033           __ set(objArray_lh, tmp);
2034           __ cmp(tmp, tmp2);
2035           __ br(Assembler::notEqual, false, Assembler::pt,  *stub-&gt;entry());
2036           __ delayed()-&gt;nop();
2037         }
2038 
2039         Register src_ptr = O0;
2040         Register dst_ptr = O1;
2041         Register len     = O2;
2042         Register chk_off = O3;
2043         Register super_k = O4;
2044 
2045         __ add(src, arrayOopDesc::base_offset_in_bytes(basic_type), src_ptr);
2046         if (shift == 0) {
2047           __ add(src_ptr, src_pos, src_ptr);
2048         } else {
2049           __ sll(src_pos, shift, tmp);
2050           __ add(src_ptr, tmp, src_ptr);
2051         }
2052 
2053         __ add(dst, arrayOopDesc::base_offset_in_bytes(basic_type), dst_ptr);
2054         if (shift == 0) {
2055           __ add(dst_ptr, dst_pos, dst_ptr);
2056         } else {
2057           __ sll(dst_pos, shift, tmp);
2058           __ add(dst_ptr, tmp, dst_ptr);
2059         }
2060         __ mov(length, len);
2061         __ load_klass(dst, tmp);
2062 
2063         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2064         __ ld_ptr(tmp, ek_offset, super_k);
2065 
2066         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2067         __ lduw(super_k, sco_offset, chk_off);
2068 
2069         __ call_VM_leaf(tmp, copyfunc_addr);
2070 
2071 #ifndef PRODUCT
2072         if (PrintC1Statistics) {
2073           Label failed;
2074           __ br_notnull_short(O0, Assembler::pn, failed);
2075           __ inc_counter((address)&amp;Runtime1::_arraycopy_checkcast_cnt, G1, G3);
2076           __ bind(failed);
2077         }
2078 #endif
2079 
2080         __ br_null(O0, false, Assembler::pt,  *stub-&gt;continuation());
2081         __ delayed()-&gt;xor3(O0, -1, tmp);
2082 
2083 #ifndef PRODUCT
2084         if (PrintC1Statistics) {
2085           __ inc_counter((address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt, G1, G3);
2086         }
2087 #endif
2088 
2089         __ sub(length, tmp, length);
2090         __ add(src_pos, tmp, src_pos);
2091         __ br(Assembler::always, false, Assembler::pt, *stub-&gt;entry());
2092         __ delayed()-&gt;add(dst_pos, tmp, dst_pos);
2093 
2094         __ bind(cont);
2095       } else {
2096         __ br(Assembler::equal, false, Assembler::pn, *stub-&gt;entry());
2097         __ delayed()-&gt;nop();
2098         __ bind(cont);
2099       }
2100     }
2101   }
2102 
2103 #ifdef ASSERT
2104   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2105     // Sanity check the known type with the incoming class.  For the
2106     // primitive case the types must match exactly with src.klass and
2107     // dst.klass each exactly matching the default type.  For the
2108     // object array case, if no type check is needed then either the
2109     // dst type is exactly the expected type and the src type is a
2110     // subtype which we can&#39;t check or src is the same array as dst
2111     // but not necessarily exactly of type default_type.
2112     Label known_ok, halt;
2113     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2114     if (UseCompressedClassPointers) {
2115       // tmp holds the default type. It currently comes uncompressed after the
2116       // load of a constant, so encode it.
2117       __ encode_klass_not_null(tmp);
2118       // load the raw value of the dst klass, since we will be comparing
2119       // uncompressed values directly.
2120       __ lduw(dst, oopDesc::klass_offset_in_bytes(), tmp2);
2121       if (basic_type != T_OBJECT) {
2122         __ cmp(tmp, tmp2);
2123         __ br(Assembler::notEqual, false, Assembler::pn, halt);
2124         // load the raw value of the src klass.
2125         __ delayed()-&gt;lduw(src, oopDesc::klass_offset_in_bytes(), tmp2);
2126         __ cmp_and_br_short(tmp, tmp2, Assembler::equal, Assembler::pn, known_ok);
2127       } else {
2128         __ cmp(tmp, tmp2);
2129         __ br(Assembler::equal, false, Assembler::pn, known_ok);
2130         __ delayed()-&gt;cmp(src, dst);
2131         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2132         __ delayed()-&gt;nop();
2133       }
2134     } else {
2135       __ ld_ptr(dst, oopDesc::klass_offset_in_bytes(), tmp2);
2136       if (basic_type != T_OBJECT) {
2137         __ cmp(tmp, tmp2);
2138         __ brx(Assembler::notEqual, false, Assembler::pn, halt);
2139         __ delayed()-&gt;ld_ptr(src, oopDesc::klass_offset_in_bytes(), tmp2);
2140         __ cmp_and_brx_short(tmp, tmp2, Assembler::equal, Assembler::pn, known_ok);
2141       } else {
2142         __ cmp(tmp, tmp2);
2143         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2144         __ delayed()-&gt;cmp(src, dst);
2145         __ brx(Assembler::equal, false, Assembler::pn, known_ok);
2146         __ delayed()-&gt;nop();
2147       }
2148     }
2149     __ bind(halt);
2150     __ stop(&quot;incorrect type information in arraycopy&quot;);
2151     __ bind(known_ok);
2152   }
2153 #endif
2154 
2155 #ifndef PRODUCT
2156   if (PrintC1Statistics) {
2157     address counter = Runtime1::arraycopy_count_address(basic_type);
2158     __ inc_counter(counter, G1, G3);
2159   }
2160 #endif
2161 
2162   Register src_ptr = O0;
2163   Register dst_ptr = O1;
2164   Register len     = O2;
2165 
2166   __ add(src, arrayOopDesc::base_offset_in_bytes(basic_type), src_ptr);
2167   if (shift == 0) {
2168     __ add(src_ptr, src_pos, src_ptr);
2169   } else {
2170     __ sll(src_pos, shift, tmp);
2171     __ add(src_ptr, tmp, src_ptr);
2172   }
2173 
2174   __ add(dst, arrayOopDesc::base_offset_in_bytes(basic_type), dst_ptr);
2175   if (shift == 0) {
2176     __ add(dst_ptr, dst_pos, dst_ptr);
2177   } else {
2178     __ sll(dst_pos, shift, tmp);
2179     __ add(dst_ptr, tmp, dst_ptr);
2180   }
2181 
2182   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2183   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2184   const char *name;
2185   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2186 
2187   // arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2188   __ mov(length, len);
2189   __ call_VM_leaf(tmp, entry);
2190 
2191   __ bind(*stub-&gt;continuation());
2192 }
2193 
2194 
2195 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2196   if (dest-&gt;is_single_cpu()) {
2197     if (left-&gt;type() == T_OBJECT) {
2198       switch (code) {
2199         case lir_shl:  __ sllx  (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2200         case lir_shr:  __ srax  (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2201         case lir_ushr: __ srl   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2202         default: ShouldNotReachHere();
2203       }
2204     } else
2205       switch (code) {
2206         case lir_shl:  __ sll   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2207         case lir_shr:  __ sra   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2208         case lir_ushr: __ srl   (left-&gt;as_register(), count-&gt;as_register(), dest-&gt;as_register()); break;
2209         default: ShouldNotReachHere();
2210       }
2211   } else {
2212     switch (code) {
2213       case lir_shl:  __ sllx  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2214       case lir_shr:  __ srax  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2215       case lir_ushr: __ srlx  (left-&gt;as_register_lo(), count-&gt;as_register(), dest-&gt;as_register_lo()); break;
2216       default: ShouldNotReachHere();
2217     }
2218   }
2219 }
2220 
2221 
2222 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2223   if (left-&gt;type() == T_OBJECT) {
2224     count = count &amp; 63;  // shouldn&#39;t shift by more than sizeof(intptr_t)
2225     Register l = left-&gt;as_register();
2226     Register d = dest-&gt;as_register_lo();
2227     switch (code) {
2228       case lir_shl:  __ sllx  (l, count, d); break;
2229       case lir_shr:  __ srax  (l, count, d); break;
2230       case lir_ushr: __ srlx  (l, count, d); break;
2231       default: ShouldNotReachHere();
2232     }
2233     return;
2234   }
2235 
2236   if (dest-&gt;is_single_cpu()) {
2237     count = count &amp; 0x1F; // Java spec
2238     switch (code) {
2239       case lir_shl:  __ sll   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2240       case lir_shr:  __ sra   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2241       case lir_ushr: __ srl   (left-&gt;as_register(), count, dest-&gt;as_register()); break;
2242       default: ShouldNotReachHere();
2243     }
2244   } else if (dest-&gt;is_double_cpu()) {
2245     count = count &amp; 63; // Java spec
2246     switch (code) {
2247       case lir_shl:  __ sllx  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2248       case lir_shr:  __ srax  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2249       case lir_ushr: __ srlx  (left-&gt;as_pointer_register(), count, dest-&gt;as_pointer_register()); break;
2250       default: ShouldNotReachHere();
2251     }
2252   } else {
2253     ShouldNotReachHere();
2254   }
2255 }
2256 
2257 
2258 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2259   assert(op-&gt;tmp1()-&gt;as_register()  == G1 &amp;&amp;
2260          op-&gt;tmp2()-&gt;as_register()  == G3 &amp;&amp;
2261          op-&gt;tmp3()-&gt;as_register()  == G4 &amp;&amp;
2262          op-&gt;obj()-&gt;as_register()   == O0 &amp;&amp;
2263          op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
2264   if (op-&gt;init_check()) {
2265     add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2266     __ ldub(op-&gt;klass()-&gt;as_register(),
2267           in_bytes(InstanceKlass::init_state_offset()),
2268           op-&gt;tmp1()-&gt;as_register());
2269     __ cmp(op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2270     __ br(Assembler::notEqual, false, Assembler::pn, *op-&gt;stub()-&gt;entry());
2271     __ delayed()-&gt;nop();
2272   }
2273   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2274                      op-&gt;tmp1()-&gt;as_register(),
2275                      op-&gt;tmp2()-&gt;as_register(),
2276                      op-&gt;tmp3()-&gt;as_register(),
2277                      op-&gt;header_size(),
2278                      op-&gt;object_size(),
2279                      op-&gt;klass()-&gt;as_register(),
2280                      *op-&gt;stub()-&gt;entry());
2281   __ bind(*op-&gt;stub()-&gt;continuation());
2282   __ verify_oop(op-&gt;obj()-&gt;as_register());
2283 }
2284 
2285 
2286 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2287   assert(op-&gt;tmp1()-&gt;as_register()  == G1 &amp;&amp;
2288          op-&gt;tmp2()-&gt;as_register()  == G3 &amp;&amp;
2289          op-&gt;tmp3()-&gt;as_register()  == G4 &amp;&amp;
2290          op-&gt;tmp4()-&gt;as_register()  == O1 &amp;&amp;
2291          op-&gt;klass()-&gt;as_register() == G5, &quot;must be&quot;);
2292 
2293   __ signx(op-&gt;len()-&gt;as_register());
2294   if (UseSlowPath ||
2295       (!UseFastNewObjectArray &amp;&amp; is_reference_type(op-&gt;type())) ||
2296       (!UseFastNewTypeArray   &amp;&amp; !is_reference_type(op-&gt;type()))) {
2297     __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2298     __ delayed()-&gt;nop();
2299   } else {
2300     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2301                       op-&gt;len()-&gt;as_register(),
2302                       op-&gt;tmp1()-&gt;as_register(),
2303                       op-&gt;tmp2()-&gt;as_register(),
2304                       op-&gt;tmp3()-&gt;as_register(),
2305                       arrayOopDesc::header_size(op-&gt;type()),
2306                       type2aelembytes(op-&gt;type()),
2307                       op-&gt;klass()-&gt;as_register(),
2308                       *op-&gt;stub()-&gt;entry());
2309   }
2310   __ bind(*op-&gt;stub()-&gt;continuation());
2311 }
2312 
2313 
2314 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2315                                         ciMethodData *md, ciProfileData *data,
2316                                         Register recv, Register tmp1, Label* update_done) {
2317   uint i;
2318   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2319     Label next_test;
2320     // See if the receiver is receiver[n].
2321     Address receiver_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) -
2322                           mdo_offset_bias);
2323     __ ld_ptr(receiver_addr, tmp1);
2324     __ verify_klass_ptr(tmp1);
2325     __ cmp_and_brx_short(recv, tmp1, Assembler::notEqual, Assembler::pt, next_test);
2326     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) -
2327                       mdo_offset_bias);
2328     __ ld_ptr(data_addr, tmp1);
2329     __ add(tmp1, DataLayout::counter_increment, tmp1);
2330     __ st_ptr(tmp1, data_addr);
2331     __ ba(*update_done);
2332     __ delayed()-&gt;nop();
2333     __ bind(next_test);
2334   }
2335 
2336   // Didn&#39;t find receiver; find next empty slot and fill it in
2337   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2338     Label next_test;
2339     Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) -
2340                       mdo_offset_bias);
2341     __ ld_ptr(recv_addr, tmp1);
2342     __ br_notnull_short(tmp1, Assembler::pt, next_test);
2343     __ st_ptr(recv, recv_addr);
2344     __ set(DataLayout::counter_increment, tmp1);
2345     __ st_ptr(tmp1, mdo, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) -
2346               mdo_offset_bias);
2347     __ ba(*update_done);
2348     __ delayed()-&gt;nop();
2349     __ bind(next_test);
2350   }
2351 }
2352 
2353 
2354 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2355                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2356   md = method-&gt;method_data_or_null();
2357   assert(md != NULL, &quot;Sanity&quot;);
2358   data = md-&gt;bci_to_data(bci);
2359   assert(data != NULL,       &quot;need data for checkcast&quot;);
2360   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2361   if (!Assembler::is_simm13(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2362     // The offset is large so bias the mdo by the base of the slot so
2363     // that the ld can use simm13s to reference the slots of the data
2364     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2365   }
2366 }
2367 
2368 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2369   // we always need a stub for the failure case.
2370   CodeStub* stub = op-&gt;stub();
2371   Register obj = op-&gt;object()-&gt;as_register();
2372   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2373   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2374   Register dst = op-&gt;result_opr()-&gt;as_register();
2375   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2376   ciKlass* k = op-&gt;klass();
2377 
2378 
2379   if (obj == k_RInfo) {
2380     k_RInfo = klass_RInfo;
2381     klass_RInfo = obj;
2382   }
2383 
2384   ciMethodData* md;
2385   ciProfileData* data;
2386   int mdo_offset_bias = 0;
2387   if (op-&gt;should_profile()) {
2388     ciMethod* method = op-&gt;profiled_method();
2389     assert(method != NULL, &quot;Should have method&quot;);
2390     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2391 
2392     Label not_null;
2393     __ br_notnull_short(obj, Assembler::pn, not_null);
2394     Register mdo      = k_RInfo;
2395     Register data_val = Rtmp1;
2396     metadata2reg(md-&gt;constant_encoding(), mdo);
2397     if (mdo_offset_bias &gt; 0) {
2398       __ set(mdo_offset_bias, data_val);
2399       __ add(mdo, data_val, mdo);
2400     }
2401     Address flags_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias);
2402     __ ldub(flags_addr, data_val);
2403     __ or3(data_val, BitData::null_seen_byte_constant(), data_val);
2404     __ stb(data_val, flags_addr);
2405     __ ba(*obj_is_null);
2406     __ delayed()-&gt;nop();
2407     __ bind(not_null);
2408   } else {
2409     __ br_null(obj, false, Assembler::pn, *obj_is_null);
2410     __ delayed()-&gt;nop();
2411   }
2412 
2413   Label profile_cast_failure, profile_cast_success;
2414   Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : failure;
2415   Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : success;
2416 
2417   // patching may screw with our temporaries on sparc,
2418   // so let&#39;s do it before loading the class
2419   if (k-&gt;is_loaded()) {
2420     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2421   } else {
2422     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2423   }
2424   assert(obj != k_RInfo, &quot;must be different&quot;);
2425 
2426   // get object class
2427   // not a safepoint as obj null check happens earlier
2428   __ load_klass(obj, klass_RInfo);
2429   if (op-&gt;fast_check()) {
2430     assert_different_registers(klass_RInfo, k_RInfo);
2431     __ cmp(k_RInfo, klass_RInfo);
2432     __ brx(Assembler::notEqual, false, Assembler::pt, *failure_target);
2433     __ delayed()-&gt;nop();
2434   } else {
2435     bool need_slow_path = true;
2436     if (k-&gt;is_loaded()) {
2437       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset()))
2438         need_slow_path = false;
2439       // perform the fast part of the checking logic
2440       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, noreg,
2441                                        (need_slow_path ? success_target : NULL),
2442                                        failure_target, NULL,
2443                                        RegisterOrConstant(k-&gt;super_check_offset()));
2444     } else {
2445       // perform the fast part of the checking logic
2446       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, O7, success_target,
2447                                        failure_target, NULL);
2448     }
2449     if (need_slow_path) {
2450       // call out-of-line instance of __ check_klass_subtype_slow_path(...):
2451       assert(klass_RInfo == G3 &amp;&amp; k_RInfo == G1, &quot;incorrect call setup&quot;);
2452       __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2453       __ delayed()-&gt;nop();
2454       __ cmp(G3, 0);
2455       __ br(Assembler::equal, false, Assembler::pn, *failure_target);
2456       __ delayed()-&gt;nop();
2457       // Fall through to success case
2458     }
2459   }
2460 
2461   if (op-&gt;should_profile()) {
2462     Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2463     assert_different_registers(obj, mdo, recv, tmp1);
2464     __ bind(profile_cast_success);
2465     metadata2reg(md-&gt;constant_encoding(), mdo);
2466     if (mdo_offset_bias &gt; 0) {
2467       __ set(mdo_offset_bias, tmp1);
2468       __ add(mdo, tmp1, mdo);
2469     }
2470     __ load_klass(obj, recv);
2471     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, success);
2472     // Jump over the failure case
2473     __ ba(*success);
2474     __ delayed()-&gt;nop();
2475     // Cast failure case
2476     __ bind(profile_cast_failure);
2477     metadata2reg(md-&gt;constant_encoding(), mdo);
2478     if (mdo_offset_bias &gt; 0) {
2479       __ set(mdo_offset_bias, tmp1);
2480       __ add(mdo, tmp1, mdo);
2481     }
2482     Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2483     __ ld_ptr(data_addr, tmp1);
2484     __ sub(tmp1, DataLayout::counter_increment, tmp1);
2485     __ st_ptr(tmp1, data_addr);
2486     __ ba(*failure);
2487     __ delayed()-&gt;nop();
2488   }
2489   __ ba(*success);
2490   __ delayed()-&gt;nop();
2491 }
2492 
2493 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2494   LIR_Code code = op-&gt;code();
2495   if (code == lir_store_check) {
2496     Register value = op-&gt;object()-&gt;as_register();
2497     Register array = op-&gt;array()-&gt;as_register();
2498     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2499     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2500     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2501 
2502     __ verify_oop(value);
2503     CodeStub* stub = op-&gt;stub();
2504     // check if it needs to be profiled
2505     ciMethodData* md;
2506     ciProfileData* data;
2507     int mdo_offset_bias = 0;
2508     if (op-&gt;should_profile()) {
2509       ciMethod* method = op-&gt;profiled_method();
2510       assert(method != NULL, &quot;Should have method&quot;);
2511       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2512     }
2513     Label profile_cast_success, profile_cast_failure, done;
2514     Label *success_target = op-&gt;should_profile() ? &amp;profile_cast_success : &amp;done;
2515     Label *failure_target = op-&gt;should_profile() ? &amp;profile_cast_failure : stub-&gt;entry();
2516 
2517     if (op-&gt;should_profile()) {
2518       Label not_null;
2519       __ br_notnull_short(value, Assembler::pn, not_null);
2520       Register mdo      = k_RInfo;
2521       Register data_val = Rtmp1;
2522       metadata2reg(md-&gt;constant_encoding(), mdo);
2523       if (mdo_offset_bias &gt; 0) {
2524         __ set(mdo_offset_bias, data_val);
2525         __ add(mdo, data_val, mdo);
2526       }
2527       Address flags_addr(mdo, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias);
2528       __ ldub(flags_addr, data_val);
2529       __ or3(data_val, BitData::null_seen_byte_constant(), data_val);
2530       __ stb(data_val, flags_addr);
2531       __ ba_short(done);
2532       __ bind(not_null);
2533     } else {
2534       __ br_null_short(value, Assembler::pn, done);
2535     }
2536     add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2537     __ load_klass(array, k_RInfo);
2538     __ load_klass(value, klass_RInfo);
2539 
2540     // get instance klass
2541     __ ld_ptr(Address(k_RInfo, ObjArrayKlass::element_klass_offset()), k_RInfo);
2542     // perform the fast part of the checking logic
2543     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, O7, success_target, failure_target, NULL);
2544 
2545     // call out-of-line instance of __ check_klass_subtype_slow_path(...):
2546     assert(klass_RInfo == G3 &amp;&amp; k_RInfo == G1, &quot;incorrect call setup&quot;);
2547     __ call(Runtime1::entry_for(Runtime1::slow_subtype_check_id), relocInfo::runtime_call_type);
2548     __ delayed()-&gt;nop();
2549     __ cmp(G3, 0);
2550     __ br(Assembler::equal, false, Assembler::pn, *failure_target);
2551     __ delayed()-&gt;nop();
2552     // fall through to the success case
2553 
2554     if (op-&gt;should_profile()) {
2555       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2556       assert_different_registers(value, mdo, recv, tmp1);
2557       __ bind(profile_cast_success);
2558       metadata2reg(md-&gt;constant_encoding(), mdo);
2559       if (mdo_offset_bias &gt; 0) {
2560         __ set(mdo_offset_bias, tmp1);
2561         __ add(mdo, tmp1, mdo);
2562       }
2563       __ load_klass(value, recv);
2564       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2565       __ ba_short(done);
2566       // Cast failure case
2567       __ bind(profile_cast_failure);
2568       metadata2reg(md-&gt;constant_encoding(), mdo);
2569       if (mdo_offset_bias &gt; 0) {
2570         __ set(mdo_offset_bias, tmp1);
2571         __ add(mdo, tmp1, mdo);
2572       }
2573       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2574       __ ld_ptr(data_addr, tmp1);
2575       __ sub(tmp1, DataLayout::counter_increment, tmp1);
2576       __ st_ptr(tmp1, data_addr);
2577       __ ba(*stub-&gt;entry());
2578       __ delayed()-&gt;nop();
2579     }
2580     __ bind(done);
2581   } else if (code == lir_checkcast) {
2582     Register obj = op-&gt;object()-&gt;as_register();
2583     Register dst = op-&gt;result_opr()-&gt;as_register();
2584     Label success;
2585     emit_typecheck_helper(op, &amp;success, op-&gt;stub()-&gt;entry(), &amp;success);
2586     __ bind(success);
2587     __ mov(obj, dst);
2588   } else if (code == lir_instanceof) {
2589     Register obj = op-&gt;object()-&gt;as_register();
2590     Register dst = op-&gt;result_opr()-&gt;as_register();
2591     Label success, failure, done;
2592     emit_typecheck_helper(op, &amp;success, &amp;failure, &amp;failure);
2593     __ bind(failure);
2594     __ set(0, dst);
2595     __ ba_short(done);
2596     __ bind(success);
2597     __ set(1, dst);
2598     __ bind(done);
2599   } else {
2600     ShouldNotReachHere();
2601   }
2602 
2603 }
2604 
2605 
2606 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2607   if (op-&gt;code() == lir_cas_long) {
2608     assert(VM_Version::supports_cx8(), &quot;wrong machine&quot;);
2609     Register addr = op-&gt;addr()-&gt;as_pointer_register();
2610     Register cmp_value_lo = op-&gt;cmp_value()-&gt;as_register_lo();
2611     Register cmp_value_hi = op-&gt;cmp_value()-&gt;as_register_hi();
2612     Register new_value_lo = op-&gt;new_value()-&gt;as_register_lo();
2613     Register new_value_hi = op-&gt;new_value()-&gt;as_register_hi();
2614     Register t1 = op-&gt;tmp1()-&gt;as_register();
2615     Register t2 = op-&gt;tmp2()-&gt;as_register();
2616     __ mov(cmp_value_lo, t1);
2617     __ mov(new_value_lo, t2);
2618     // perform the compare and swap operation
2619     __ casx(addr, t1, t2);
2620     // generate condition code - if the swap succeeded, t2 (&quot;new value&quot; reg) was
2621     // overwritten with the original value in &quot;addr&quot; and will be equal to t1.
2622     __ cmp(t1, t2);
2623   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2624     Register addr = op-&gt;addr()-&gt;as_pointer_register();
2625     Register cmp_value = op-&gt;cmp_value()-&gt;as_register();
2626     Register new_value = op-&gt;new_value()-&gt;as_register();
2627     Register t1 = op-&gt;tmp1()-&gt;as_register();
2628     Register t2 = op-&gt;tmp2()-&gt;as_register();
2629     __ mov(cmp_value, t1);
2630     __ mov(new_value, t2);
2631     if (op-&gt;code() == lir_cas_obj) {
2632       if (UseCompressedOops) {
2633         __ encode_heap_oop(t1);
2634         __ encode_heap_oop(t2);
2635         __ cas(addr, t1, t2);
2636       } else {
2637         __ cas_ptr(addr, t1, t2);
2638       }
2639     } else {
2640       __ cas(addr, t1, t2);
2641     }
2642     __ cmp(t1, t2);
2643   } else {
2644     Unimplemented();
2645   }
2646 }
2647 
2648 void LIR_Assembler::breakpoint() {
2649   __ breakpoint_trap();
2650 }
2651 
2652 
2653 void LIR_Assembler::push(LIR_Opr opr) {
2654   Unimplemented();
2655 }
2656 
2657 
2658 void LIR_Assembler::pop(LIR_Opr opr) {
2659   Unimplemented();
2660 }
2661 
2662 
2663 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2664   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2665   Register dst = dst_opr-&gt;as_register();
2666   Register reg = mon_addr.base();
2667   int offset = mon_addr.disp();
2668   // compute pointer to BasicLock
2669   if (mon_addr.is_simm13()) {
2670     __ add(reg, offset, dst);
2671   } else {
2672     __ set(offset, dst);
2673     __ add(dst, reg, dst);
2674   }
2675 }
2676 
2677 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
2678   assert(op-&gt;crc()-&gt;is_single_cpu(),  &quot;crc must be register&quot;);
2679   assert(op-&gt;val()-&gt;is_single_cpu(),  &quot;byte value must be register&quot;);
2680   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
2681   Register crc = op-&gt;crc()-&gt;as_register();
2682   Register val = op-&gt;val()-&gt;as_register();
2683   Register table = op-&gt;result_opr()-&gt;as_register();
2684   Register res   = op-&gt;result_opr()-&gt;as_register();
2685 
2686   assert_different_registers(val, crc, table);
2687 
2688   __ set(ExternalAddress(StubRoutines::crc_table_addr()), table);
2689   __ not1(crc);
2690   __ clruwu(crc);
2691   __ update_byte_crc32(crc, val, table);
2692   __ not1(crc);
2693 
2694   __ mov(crc, res);
2695 }
2696 
2697 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2698   Register obj = op-&gt;obj_opr()-&gt;as_register();
2699   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2700   Register lock = op-&gt;lock_opr()-&gt;as_register();
2701 
2702   // obj may not be an oop
2703   if (op-&gt;code() == lir_lock) {
2704     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2705     if (UseFastLocking) {
2706       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2707       // add debug info for NullPointerException only if one is possible
2708       if (op-&gt;info() != NULL) {
2709         add_debug_info_for_null_check_here(op-&gt;info());
2710       }
2711       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2712     } else {
2713       // always do slow locking
2714       // note: the slow locking code could be inlined here, however if we use
2715       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2716       //       simpler and requires less duplicated code - additionally, the
2717       //       slow locking code is the same in either case which simplifies
2718       //       debugging
2719       __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2720       __ delayed()-&gt;nop();
2721     }
2722   } else {
2723     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2724     if (UseFastLocking) {
2725       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2726       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2727     } else {
2728       // always do slow unlocking
2729       // note: the slow unlocking code could be inlined here, however if we use
2730       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2731       //       simpler and requires less duplicated code - additionally, the
2732       //       slow unlocking code is the same in either case which simplifies
2733       //       debugging
2734       __ br(Assembler::always, false, Assembler::pt, *op-&gt;stub()-&gt;entry());
2735       __ delayed()-&gt;nop();
2736     }
2737   }
2738   __ bind(*op-&gt;stub()-&gt;continuation());
2739 }
2740 
2741 
2742 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2743   ciMethod* method = op-&gt;profiled_method();
2744   int bci          = op-&gt;profiled_bci();
2745   ciMethod* callee = op-&gt;profiled_callee();
2746 
2747   // Update counter for all call types
2748   ciMethodData* md = method-&gt;method_data_or_null();
2749   assert(md != NULL, &quot;Sanity&quot;);
2750   ciProfileData* data = md-&gt;bci_to_data(bci);
2751   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2752   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2753   Register mdo  = op-&gt;mdo()-&gt;as_register();
2754   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2755   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2756   metadata2reg(md-&gt;constant_encoding(), mdo);
2757   int mdo_offset_bias = 0;
2758   if (!Assembler::is_simm13(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2759                             data-&gt;size_in_bytes())) {
2760     // The offset is large so bias the mdo by the base of the slot so
2761     // that the ld can use simm13s to reference the slots of the data
2762     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2763     __ set(mdo_offset_bias, O7);
2764     __ add(mdo, O7, mdo);
2765   }
2766 
2767   Address counter_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2768   // Perform additional virtual call profiling for invokevirtual and
2769   // invokeinterface bytecodes
2770   if (op-&gt;should_profile_receiver_type()) {
2771     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2772     Register recv = op-&gt;recv()-&gt;as_register();
2773     assert_different_registers(mdo, tmp1, recv);
2774     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2775     ciKlass* known_klass = op-&gt;known_holder();
2776     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2777       // We know the type that will be seen at this call site; we can
2778       // statically update the MethodData* rather than needing to do
2779       // dynamic tests on the receiver type
2780 
2781       // NOTE: we should probably put a lock around this search to
2782       // avoid collisions by concurrent compilations
2783       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2784       uint i;
2785       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2786         ciKlass* receiver = vc_data-&gt;receiver(i);
2787         if (known_klass-&gt;equals(receiver)) {
2788           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data,
2789                                                          VirtualCallData::receiver_count_offset(i)) -
2790                             mdo_offset_bias);
2791           __ ld_ptr(data_addr, tmp1);
2792           __ add(tmp1, DataLayout::counter_increment, tmp1);
2793           __ st_ptr(tmp1, data_addr);
2794           return;
2795         }
2796       }
2797 
2798       // Receiver type not found in profile data; select an empty slot
2799 
2800       // Note that this is less efficient than it should be because it
2801       // always does a write to the receiver part of the
2802       // VirtualCallData rather than just the first time
2803       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2804         ciKlass* receiver = vc_data-&gt;receiver(i);
2805         if (receiver == NULL) {
2806           Address recv_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) -
2807                             mdo_offset_bias);
2808           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2809           __ st_ptr(tmp1, recv_addr);
2810           Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) -
2811                             mdo_offset_bias);
2812           __ ld_ptr(data_addr, tmp1);
2813           __ add(tmp1, DataLayout::counter_increment, tmp1);
2814           __ st_ptr(tmp1, data_addr);
2815           return;
2816         }
2817       }
2818     } else {
2819       __ load_klass(recv, recv);
2820       Label update_done;
2821       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2822       // Receiver did not match any saved receiver and there is no empty row for it.
2823       // Increment total counter to indicate polymorphic case.
2824       __ ld_ptr(counter_addr, tmp1);
2825       __ add(tmp1, DataLayout::counter_increment, tmp1);
2826       __ st_ptr(tmp1, counter_addr);
2827 
2828       __ bind(update_done);
2829     }
2830   } else {
2831     // Static call
2832     __ ld_ptr(counter_addr, tmp1);
2833     __ add(tmp1, DataLayout::counter_increment, tmp1);
2834     __ st_ptr(tmp1, counter_addr);
2835   }
2836 }
2837 
2838 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
2839   Register obj = op-&gt;obj()-&gt;as_register();
2840   Register tmp1 = op-&gt;tmp()-&gt;as_pointer_register();
2841   Register tmp2 = G1;
2842   Address mdo_addr = as_Address(op-&gt;mdp()-&gt;as_address_ptr());
2843   ciKlass* exact_klass = op-&gt;exact_klass();
2844   intptr_t current_klass = op-&gt;current_klass();
2845   bool not_null = op-&gt;not_null();
2846   bool no_conflict = op-&gt;no_conflict();
2847 
2848   Label update, next, none;
2849 
2850   bool do_null = !not_null;
2851   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
2852   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
2853 
2854   assert(do_null || do_update, &quot;why are we here?&quot;);
2855   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
2856 
2857   __ verify_oop(obj);
2858 
2859   if (tmp1 != obj) {
2860     __ mov(obj, tmp1);
2861   }
2862   if (do_null) {
2863     __ br_notnull_short(tmp1, Assembler::pt, update);
2864     if (!TypeEntries::was_null_seen(current_klass)) {
2865       __ ld_ptr(mdo_addr, tmp1);
2866       __ or3(tmp1, TypeEntries::null_seen, tmp1);
2867       __ st_ptr(tmp1, mdo_addr);
2868     }
2869     if (do_update) {
2870       __ ba(next);
2871       __ delayed()-&gt;nop();
2872     }
2873 #ifdef ASSERT
2874   } else {
2875     __ br_notnull_short(tmp1, Assembler::pt, update);
2876     __ stop(&quot;unexpect null obj&quot;);
2877 #endif
2878   }
2879 
2880   __ bind(update);
2881 
2882   if (do_update) {
2883 #ifdef ASSERT
2884     if (exact_klass != NULL) {
2885       Label ok;
2886       __ load_klass(tmp1, tmp1);
2887       metadata2reg(exact_klass-&gt;constant_encoding(), tmp2);
2888       __ cmp_and_br_short(tmp1, tmp2, Assembler::equal, Assembler::pt, ok);
2889       __ stop(&quot;exact klass and actual klass differ&quot;);
2890       __ bind(ok);
2891     }
2892 #endif
2893 
2894     Label do_update;
2895     __ ld_ptr(mdo_addr, tmp2);
2896 
2897     if (!no_conflict) {
2898       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
2899         if (exact_klass != NULL) {
2900           metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
2901         } else {
2902           __ load_klass(tmp1, tmp1);
2903         }
2904 
2905         __ xor3(tmp1, tmp2, tmp1);
2906         __ btst(TypeEntries::type_klass_mask, tmp1);
2907         // klass seen before, nothing to do. The unknown bit may have been
2908         // set already but no need to check.
2909         __ brx(Assembler::zero, false, Assembler::pt, next);
2910         __ delayed()-&gt;
2911 
2912            btst(TypeEntries::type_unknown, tmp1);
2913         // already unknown. Nothing to do anymore.
2914         __ brx(Assembler::notZero, false, Assembler::pt, next);
2915 
2916         if (TypeEntries::is_type_none(current_klass)) {
2917           __ delayed()-&gt;btst(TypeEntries::type_mask, tmp2);
2918           __ brx(Assembler::zero, true, Assembler::pt, do_update);
2919           // first time here. Set profile type.
2920           __ delayed()-&gt;or3(tmp2, tmp1, tmp2);
2921         } else {
2922           __ delayed()-&gt;nop();
2923         }
2924       } else {
2925         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2926                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
2927 
2928         __ btst(TypeEntries::type_unknown, tmp2);
2929         // already unknown. Nothing to do anymore.
2930         __ brx(Assembler::notZero, false, Assembler::pt, next);
2931         __ delayed()-&gt;nop();
2932       }
2933 
2934       // different than before. Cannot keep accurate profile.
2935       __ or3(tmp2, TypeEntries::type_unknown, tmp2);
2936     } else {
2937       // There&#39;s a single possible klass at this profile point
2938       assert(exact_klass != NULL, &quot;should be&quot;);
2939       if (TypeEntries::is_type_none(current_klass)) {
2940         metadata2reg(exact_klass-&gt;constant_encoding(), tmp1);
2941         __ xor3(tmp1, tmp2, tmp1);
2942         __ btst(TypeEntries::type_klass_mask, tmp1);
2943         __ brx(Assembler::zero, false, Assembler::pt, next);
2944 #ifdef ASSERT
2945 
2946         {
2947           Label ok;
2948           __ delayed()-&gt;btst(TypeEntries::type_mask, tmp2);
2949           __ brx(Assembler::zero, true, Assembler::pt, ok);
2950           __ delayed()-&gt;nop();
2951 
2952           __ stop(&quot;unexpected profiling mismatch&quot;);
2953           __ bind(ok);
2954         }
2955         // first time here. Set profile type.
2956         __ or3(tmp2, tmp1, tmp2);
2957 #else
2958         // first time here. Set profile type.
2959         __ delayed()-&gt;or3(tmp2, tmp1, tmp2);
2960 #endif
2961 
2962       } else {
2963         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
2964                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
2965 
2966         // already unknown. Nothing to do anymore.
2967         __ btst(TypeEntries::type_unknown, tmp2);
2968         __ brx(Assembler::notZero, false, Assembler::pt, next);
2969         __ delayed()-&gt;or3(tmp2, TypeEntries::type_unknown, tmp2);
2970       }
2971     }
2972 
2973     __ bind(do_update);
2974     __ st_ptr(tmp2, mdo_addr);
2975 
2976     __ bind(next);
2977   }
2978 }
2979 
2980 void LIR_Assembler::align_backward_branch_target() {
2981   __ align(OptoLoopAlignment);
2982 }
2983 
2984 
2985 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2986   // make sure we are expecting a delay
2987   // this has the side effect of clearing the delay state
2988   // so we can use _masm instead of _masm-&gt;delayed() to do the
2989   // code generation.
2990   __ delayed();
2991 
2992   // make sure we only emit one instruction
2993   int offset = code_offset();
2994   op-&gt;delay_op()-&gt;emit_code(this);
2995 #ifdef ASSERT
2996   if (code_offset() - offset != NativeInstruction::nop_instruction_size) {
2997     op-&gt;delay_op()-&gt;print();
2998   }
2999   assert(code_offset() - offset == NativeInstruction::nop_instruction_size,
3000          &quot;only one instruction can go in a delay slot&quot;);
3001 #endif
3002 
3003   // we may also be emitting the call info for the instruction
3004   // which we are the delay slot of.
3005   CodeEmitInfo* call_info = op-&gt;call_info();
3006   if (call_info) {
3007     add_call_info(code_offset(), call_info);
3008   }
3009 
3010   if (VerifyStackAtCalls) {
3011     _masm-&gt;sub(FP, SP, O7);
3012     _masm-&gt;cmp(O7, initial_frame_size_in_bytes());
3013     _masm-&gt;trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2 );
3014   }
3015 }
3016 
3017 
3018 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
3019   // tmp must be unused
3020   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
3021   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
3022 
3023   if (left-&gt;is_single_cpu()) {
3024     __ neg(left-&gt;as_register(), dest-&gt;as_register());
3025   } else if (left-&gt;is_single_fpu()) {
3026     __ fneg(FloatRegisterImpl::S, left-&gt;as_float_reg(), dest-&gt;as_float_reg());
3027   } else if (left-&gt;is_double_fpu()) {
3028     __ fneg(FloatRegisterImpl::D, left-&gt;as_double_reg(), dest-&gt;as_double_reg());
3029   } else {
3030     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
3031     Register Rlow = left-&gt;as_register_lo();
3032     Register Rhi = left-&gt;as_register_hi();
3033     __ sub(G0, Rlow, dest-&gt;as_register_lo());
3034   }
3035 }
3036 
3037 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
3038                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
3039 
3040   // if tmp is invalid, then the function being called doesn&#39;t destroy the thread
3041   if (tmp-&gt;is_valid()) {
3042     __ save_thread(tmp-&gt;as_pointer_register());
3043   }
3044   __ call(dest, relocInfo::runtime_call_type);
3045   __ delayed()-&gt;nop();
3046   if (info != NULL) {
3047     add_call_info_here(info);
3048   }
3049   if (tmp-&gt;is_valid()) {
3050     __ restore_thread(tmp-&gt;as_pointer_register());
3051   }
3052 
3053 #ifdef ASSERT
3054   __ verify_thread();
3055 #endif // ASSERT
3056 }
3057 
3058 
3059 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
3060   ShouldNotReachHere();
3061 
3062   NEEDS_CLEANUP;
3063   if (type == T_LONG) {
3064     LIR_Address* mem_addr = dest-&gt;is_address() ? dest-&gt;as_address_ptr() : src-&gt;as_address_ptr();
3065 
3066     // (extended to allow indexed as well as constant displaced for JSR-166)
3067     Register idx = noreg; // contains either constant offset or index
3068 
3069     int disp = mem_addr-&gt;disp();
3070     if (mem_addr-&gt;index() == LIR_OprFact::illegalOpr) {
3071       if (!Assembler::is_simm13(disp)) {
3072         idx = O7;
3073         __ set(disp, idx);
3074       }
3075     } else {
3076       assert(disp == 0, &quot;not both indexed and disp&quot;);
3077       idx = mem_addr-&gt;index()-&gt;as_register();
3078     }
3079 
3080     int null_check_offset = -1;
3081 
3082     Register base = mem_addr-&gt;base()-&gt;as_register();
3083     if (src-&gt;is_register() &amp;&amp; dest-&gt;is_address()) {
3084       // G4 is high half, G5 is low half
3085       // clear the top bits of G5, and scale up G4
3086       __ srl (src-&gt;as_register_lo(),  0, G5);
3087       __ sllx(src-&gt;as_register_hi(), 32, G4);
3088       // combine the two halves into the 64 bits of G4
3089       __ or3(G4, G5, G4);
3090       null_check_offset = __ offset();
3091       if (idx == noreg) {
3092         __ stx(G4, base, disp);
3093       } else {
3094         __ stx(G4, base, idx);
3095       }
3096     } else if (src-&gt;is_address() &amp;&amp; dest-&gt;is_register()) {
3097       null_check_offset = __ offset();
3098       if (idx == noreg) {
3099         __ ldx(base, disp, G5);
3100       } else {
3101         __ ldx(base, idx, G5);
3102       }
3103       __ srax(G5, 32, dest-&gt;as_register_hi()); // fetch the high half into hi
3104       __ mov (G5, dest-&gt;as_register_lo());     // copy low half into lo
3105     } else {
3106       Unimplemented();
3107     }
3108     if (info != NULL) {
3109       add_debug_info_for_null_check(null_check_offset, info);
3110     }
3111 
3112   } else {
3113     // use normal move for all other volatiles since they don&#39;t need
3114     // special handling to remain atomic.
3115     move_op(src, dest, type, lir_patch_none, info, false, false, false);
3116   }
3117 }
3118 
3119 void LIR_Assembler::membar() {
3120   // only StoreLoad membars are ever explicitly needed on sparcs in TSO mode
3121   __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
3122 }
3123 
3124 void LIR_Assembler::membar_acquire() {
3125   // no-op on TSO
3126 }
3127 
3128 void LIR_Assembler::membar_release() {
3129   // no-op on TSO
3130 }
3131 
3132 void LIR_Assembler::membar_loadload() {
3133   // no-op
3134   //__ membar(Assembler::Membar_mask_bits(Assembler::loadload));
3135 }
3136 
3137 void LIR_Assembler::membar_storestore() {
3138   // no-op
3139   //__ membar(Assembler::Membar_mask_bits(Assembler::storestore));
3140 }
3141 
3142 void LIR_Assembler::membar_loadstore() {
3143   // no-op
3144   //__ membar(Assembler::Membar_mask_bits(Assembler::loadstore));
3145 }
3146 
3147 void LIR_Assembler::membar_storeload() {
3148   __ membar(Assembler::Membar_mask_bits(Assembler::StoreLoad));
3149 }
3150 
3151 void LIR_Assembler::on_spin_wait() {
3152   Unimplemented();
3153 }
3154 
3155 // Pack two sequential registers containing 32 bit values
3156 // into a single 64 bit register.
3157 // src and src-&gt;successor() are packed into dst
3158 // src and dst may be the same register.
3159 // Note: src is destroyed
3160 void LIR_Assembler::pack64(LIR_Opr src, LIR_Opr dst) {
3161   Register rs = src-&gt;as_register();
3162   Register rd = dst-&gt;as_register_lo();
3163   __ sllx(rs, 32, rs);
3164   __ srl(rs-&gt;successor(), 0, rs-&gt;successor());
3165   __ or3(rs, rs-&gt;successor(), rd);
3166 }
3167 
3168 // Unpack a 64 bit value in a register into
3169 // two sequential registers.
3170 // src is unpacked into dst and dst-&gt;successor()
3171 void LIR_Assembler::unpack64(LIR_Opr src, LIR_Opr dst) {
3172   Register rs = src-&gt;as_register_lo();
3173   Register rd = dst-&gt;as_register_hi();
3174   assert_different_registers(rs, rd, rd-&gt;successor());
3175   __ srlx(rs, 32, rd);
3176   __ srl (rs,  0, rd-&gt;successor());
3177 }
3178 
3179 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
3180   const LIR_Address* addr = addr_opr-&gt;as_address_ptr();
3181   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;can&#39;t handle complex addresses yet&quot;);
3182   const Register dest_reg = dest-&gt;as_pointer_register();
3183   const Register base_reg = addr-&gt;base()-&gt;as_pointer_register();
3184 
3185   if (patch_code != lir_patch_none) {
3186     PatchingStub* patch = new PatchingStub(_masm, PatchingStub::access_field_id);
3187     assert(addr-&gt;disp() != 0, &quot;must have&quot;);
3188     assert(base_reg != G3_scratch, &quot;invariant&quot;);
3189     __ patchable_set(0, G3_scratch);
3190     patching_epilog(patch, patch_code, base_reg, info);
3191     assert(dest_reg != G3_scratch, &quot;invariant&quot;);
3192     if (addr-&gt;index()-&gt;is_valid()) {
3193       const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3194       assert(index_reg != G3_scratch, &quot;invariant&quot;);
3195       __ add(index_reg, G3_scratch, G3_scratch);
3196     }
3197     __ add(base_reg, G3_scratch, dest_reg);
3198   } else {
3199     if (Assembler::is_simm13(addr-&gt;disp())) {
3200       if (addr-&gt;index()-&gt;is_valid()) {
3201         const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3202         assert(index_reg != G3_scratch, &quot;invariant&quot;);
3203         __ add(base_reg, addr-&gt;disp(), G3_scratch);
3204         __ add(index_reg, G3_scratch, dest_reg);
3205       } else {
3206         __ add(base_reg, addr-&gt;disp(), dest_reg);
3207       }
3208     } else {
3209       __ set(addr-&gt;disp(), G3_scratch);
3210       if (addr-&gt;index()-&gt;is_valid()) {
3211         const Register index_reg = addr-&gt;index()-&gt;as_pointer_register();
3212         assert(index_reg != G3_scratch, &quot;invariant&quot;);
3213         __ add(index_reg, G3_scratch, G3_scratch);
3214       }
3215       __ add(base_reg, G3_scratch, dest_reg);
3216     }
3217   }
3218 }
3219 
3220 
3221 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
3222   assert(result_reg-&gt;is_register(), &quot;check&quot;);
3223   __ mov(G2_thread, result_reg-&gt;as_register());
3224 }
3225 
3226 #ifdef ASSERT
3227 // emit run-time assertion
3228 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
3229   assert(op-&gt;code() == lir_assert, &quot;must be&quot;);
3230 
3231   if (op-&gt;in_opr1()-&gt;is_valid()) {
3232     assert(op-&gt;in_opr2()-&gt;is_valid(), &quot;both operands must be valid&quot;);
3233     comp_op(op-&gt;condition(), op-&gt;in_opr1(), op-&gt;in_opr2(), op);
3234   } else {
3235     assert(op-&gt;in_opr2()-&gt;is_illegal(), &quot;both operands must be illegal&quot;);
3236     assert(op-&gt;condition() == lir_cond_always, &quot;no other conditions allowed&quot;);
3237   }
3238 
3239   Label ok;
3240   if (op-&gt;condition() != lir_cond_always) {
3241     Assembler::Condition acond;
3242     switch (op-&gt;condition()) {
3243       case lir_cond_equal:        acond = Assembler::equal;                break;
3244       case lir_cond_notEqual:     acond = Assembler::notEqual;             break;
3245       case lir_cond_less:         acond = Assembler::less;                 break;
3246       case lir_cond_lessEqual:    acond = Assembler::lessEqual;            break;
3247       case lir_cond_greaterEqual: acond = Assembler::greaterEqual;         break;
3248       case lir_cond_greater:      acond = Assembler::greater;              break;
3249       case lir_cond_aboveEqual:   acond = Assembler::greaterEqualUnsigned; break;
3250       case lir_cond_belowEqual:   acond = Assembler::lessEqualUnsigned;    break;
3251       default:                         ShouldNotReachHere();
3252     };
3253     __ br(acond, false, Assembler::pt, ok);
3254     __ delayed()-&gt;nop();
3255   }
3256   if (op-&gt;halt()) {
3257     const char* str = __ code_string(op-&gt;msg());
3258     __ stop(str);
3259   } else {
3260     breakpoint();
3261   }
3262   __ bind(ok);
3263 }
3264 #endif
3265 
3266 void LIR_Assembler::peephole(LIR_List* lir) {
3267   LIR_OpList* inst = lir-&gt;instructions_list();
3268   for (int i = 0; i &lt; inst-&gt;length(); i++) {
3269     LIR_Op* op = inst-&gt;at(i);
3270     switch (op-&gt;code()) {
3271       case lir_cond_float_branch:
3272       case lir_branch: {
3273         LIR_OpBranch* branch = op-&gt;as_OpBranch();
3274         assert(branch-&gt;info() == NULL, &quot;shouldn&#39;t be state on branches anymore&quot;);
3275         LIR_Op* delay_op = NULL;
3276         // we&#39;d like to be able to pull following instructions into
3277         // this slot but we don&#39;t know enough to do it safely yet so
3278         // only optimize block to block control flow.
3279         if (LIRFillDelaySlots &amp;&amp; branch-&gt;block()) {
3280           LIR_Op* prev = inst-&gt;at(i - 1);
3281           if (prev &amp;&amp; LIR_Assembler::is_single_instruction(prev) &amp;&amp; prev-&gt;info() == NULL) {
3282             // swap previous instruction into delay slot
3283             inst-&gt;at_put(i - 1, op);
3284             inst-&gt;at_put(i, new LIR_OpDelay(prev, op-&gt;info()));
3285 #ifndef PRODUCT
3286             if (LIRTracePeephole) {
3287               tty-&gt;print_cr(&quot;delayed&quot;);
3288               inst-&gt;at(i - 1)-&gt;print();
3289               inst-&gt;at(i)-&gt;print();
3290               tty-&gt;cr();
3291             }
3292 #endif
3293             continue;
3294           }
3295         }
3296 
3297         if (!delay_op) {
3298           delay_op = new LIR_OpDelay(new LIR_Op0(lir_nop), NULL);
3299         }
3300         inst-&gt;insert_before(i + 1, delay_op);
3301         break;
3302       }
3303       case lir_static_call:
3304       case lir_virtual_call:
3305       case lir_icvirtual_call:
3306       case lir_optvirtual_call:
3307       case lir_dynamic_call: {
3308         LIR_Op* prev = inst-&gt;at(i - 1);
3309         if (LIRFillDelaySlots &amp;&amp; prev &amp;&amp; prev-&gt;code() == lir_move &amp;&amp; prev-&gt;info() == NULL &amp;&amp;
3310             (op-&gt;code() != lir_virtual_call ||
3311              !prev-&gt;result_opr()-&gt;is_single_cpu() ||
3312              prev-&gt;result_opr()-&gt;as_register() != O0) &amp;&amp;
3313             LIR_Assembler::is_single_instruction(prev)) {
3314           // Only moves without info can be put into the delay slot.
3315           // Also don&#39;t allow the setup of the receiver in the delay
3316           // slot for vtable calls.
3317           inst-&gt;at_put(i - 1, op);
3318           inst-&gt;at_put(i, new LIR_OpDelay(prev, op-&gt;info()));
3319 #ifndef PRODUCT
3320           if (LIRTracePeephole) {
3321             tty-&gt;print_cr(&quot;delayed&quot;);
3322             inst-&gt;at(i - 1)-&gt;print();
3323             inst-&gt;at(i)-&gt;print();
3324             tty-&gt;cr();
3325           }
3326 #endif
3327         } else {
3328           LIR_Op* delay_op = new LIR_OpDelay(new LIR_Op0(lir_nop), op-&gt;as_OpJavaCall()-&gt;info());
3329           inst-&gt;insert_before(i + 1, delay_op);
3330           i++;
3331         }
3332         break;
3333       }
3334     }
3335   }
3336 }
3337 
3338 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
3339   LIR_Address* addr = src-&gt;as_address_ptr();
3340 
3341   assert(data == dest, &quot;swap uses only 2 operands&quot;);
3342   assert (code == lir_xchg, &quot;no xadd on sparc&quot;);
3343 
3344   if (data-&gt;type() == T_INT) {
3345     __ swap(as_Address(addr), data-&gt;as_register());
3346   } else if (data-&gt;is_oop()) {
3347     Register obj = data-&gt;as_register();
3348     Register narrow = tmp-&gt;as_register();
3349     assert(UseCompressedOops, &quot;swap is 32bit only&quot;);
3350     __ encode_heap_oop(obj, narrow);
3351     __ swap(as_Address(addr), narrow);
3352     __ decode_heap_oop(narrow, obj);
3353   } else {
3354     ShouldNotReachHere();
3355   }
3356 }
3357 
3358 #undef __
    </pre>
  </body>
</html>
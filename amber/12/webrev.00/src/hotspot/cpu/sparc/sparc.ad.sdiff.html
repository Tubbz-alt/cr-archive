<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/sparc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="sharedRuntime_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/sparc.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  454     return 0; // no call trampolines on this platform
  455   }
  456 };
  457 
  458 class HandlerImpl {
  459 
  460  public:
  461 
  462   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  463   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  464 
  465   static uint size_exception_handler() {
  466     return ( NativeJump::instruction_size ); // sethi;jmp;nop
  467   }
  468 
  469   static uint size_deopt_handler() {
  470     return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
  471   }
  472 };
  473 







  474 %}
  475 
  476 source %{
  477 #define __ _masm.
  478 
  479 // tertiary op of a LoadP or StoreP encoding
  480 #define REGP_OP true
  481 
  482 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  483 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  484 static Register reg_to_register_object(int register_encoding);
  485 











  486 // Used by the DFA in dfa_sparc.cpp.
  487 // Check for being able to use a V9 branch-on-register.  Requires a
  488 // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  489 // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  490 // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
  491 // 32-bit V9 systems, interrupts currently blow away the high-order 32 bits and
  492 // replace them with zero, which could become sign-extension in a different OS
  493 // release.  There&#39;s no obvious reason why an interrupt will ever fill these
  494 // bits with non-zero junk (the registers are reloaded with standard LD
  495 // instructions which either zero-fill or sign-fill).
  496 bool can_branch_register( Node *bol, Node *cmp ) {
  497   if( !BranchOnRegister ) return false;
  498   if( cmp-&gt;Opcode() == Op_CmpP )
  499     return true;  // No problems with pointer compares
  500   if( cmp-&gt;Opcode() == Op_CmpL )
  501     return true;  // No problems with long compares
  502 
  503   if( !SparcV9RegsHiBitsZero ) return false;
  504   if( bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne &amp;&amp;
  505       bol-&gt;as_Bool()-&gt;_test._test != BoolTest::eq )
</pre>
<hr />
<pre>
  575     }
  576   }
  577 }
  578 
  579 int MachCallRuntimeNode::ret_addr_offset() {
  580   if (MacroAssembler::is_far_target(entry_point())) {
  581     return NativeFarCall::instruction_size;
  582   } else {
  583     return NativeCall::instruction_size;
  584   }
  585 }
  586 
  587 // Indicate if the safepoint node needs the polling page as an input.
  588 // Since Sparc does not have absolute addressing, it does.
  589 bool SafePointNode::needs_polling_address_input() {
  590   return true;
  591 }
  592 
  593 // emit an interrupt that is caught by the debugger (for debugging compiler)
  594 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  595   MacroAssembler _masm(&amp;cbuf);</span>
  596   __ breakpoint_trap();
  597 }
  598 
  599 #ifndef PRODUCT
  600 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  601   st-&gt;print(&quot;TA&quot;);
  602 }
  603 #endif
  604 
  605 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  606   emit_break(cbuf);
  607 }
  608 
  609 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  610   return MachNode::size(ra_);
  611 }
  612 
  613 // Traceable jump
  614 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  615   MacroAssembler _masm(&amp;cbuf);</span>
  616   Register rdest = reg_to_register_object(jump_target);
  617   __ JMP(rdest, 0);
  618   __ delayed()-&gt;nop();
  619 }
  620 
  621 // Traceable jump and set exception pc
  622 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  623   MacroAssembler _masm(&amp;cbuf);</span>
  624   Register rdest = reg_to_register_object(jump_target);
  625   __ JMP(rdest, 0);
  626   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  627 }
  628 
  629 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  630   MacroAssembler _masm(&amp;cbuf);</span>
  631   __ nop();
  632 }
  633 
  634 void emit_illtrap(CodeBuffer &amp;cbuf) {
<span class="line-modified">  635   MacroAssembler _masm(&amp;cbuf);</span>
  636   __ illtrap(0);
  637 }
  638 
  639 
  640 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  641   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  642 
  643   intptr_t offset = 0;
  644   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  645   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  646   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  647   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  648   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  649   atype = atype-&gt;add_offset(offset);
  650   assert(disp32 == offset, &quot;wrong disp32&quot;);
  651   return atype-&gt;_offset;
  652 }
  653 
  654 
  655 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
</pre>
<hr />
<pre>
  891             ShouldNotReachHere();
  892           }
  893         }
  894       }
  895     }
  896   }
  897 #endif
  898 
  899   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  900              | (dst_enc        &lt;&lt; 25)
  901              | (primary        &lt;&lt; 19)
  902              | (src1_enc       &lt;&lt; 14);
  903 
  904   uint index = src2_enc;
  905   int disp = disp32;
  906 
  907   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  908     disp += STACK_BIAS;
  909     // Check that stack offset fits, load into O7 if not
  910     if (!Assembler::is_simm13(disp)) {
<span class="line-modified">  911       MacroAssembler _masm(&amp;cbuf);</span>
  912       __ set(disp, O7);
  913       if (index != R_G0_enc) {
  914         __ add(O7, reg_to_register_object(index), O7);
  915       }
  916       index = R_O7_enc;
  917       disp = 0;
  918     }
  919   }
  920 
  921   if( disp == 0 ) {
  922     // use reg-reg form
  923     // bit 13 is already zero
  924     instr |= index;
  925   } else {
  926     // use reg-imm form
  927     instr |= 0x00002000;          // set bit 13 to one
  928     instr |= disp &amp; 0x1FFF;
  929   }
  930 
  931   cbuf.insts()-&gt;emit_int32(instr);
  932 
  933 #ifdef ASSERT
  934   if (VerifyOops) {
<span class="line-modified">  935     MacroAssembler _masm(&amp;cbuf);</span>
  936     if (is_verified_oop_base) {
  937       __ verify_oop(reg_to_register_object(src1_enc));
  938     }
  939     if (is_verified_oop_store) {
  940       __ verify_oop(reg_to_register_object(dst_enc));
  941     }
  942     if (tmp_enc != -1) {
  943       __ mov(O7, reg_to_register_object(tmp_enc));
  944     }
  945     if (is_verified_oop_load) {
  946       __ verify_oop(reg_to_register_object(dst_enc));
  947     }
  948   }
  949 #endif
  950 }
  951 
  952 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  953   // The method which records debug information at every safepoint
  954   // expects the call to be the first instruction in the snippet as
  955   // it creates a PcDesc structure which tracks the offset of a call
  956   // from the start of the codeBlob. This offset is computed as
  957   // code_end() - code_begin() of the code which has been emitted
  958   // so far.
  959   // In this particular case we have skirted around the problem by
  960   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  961   // may bite us again at some other point and a cleaner/generic
  962   // solution using relocations would be needed.
<span class="line-modified">  963   MacroAssembler _masm(&amp;cbuf);</span>
  964   __ set_inst_mark();
  965 
  966   // We flush the current window just so that there is a valid stack copy
  967   // the fact that the current window becomes active again instantly is
  968   // not a problem there is nothing live in it.
  969 
  970 #ifdef ASSERT
  971   int startpos = __ offset();
  972 #endif /* ASSERT */
  973 
  974   __ call((address)entry_point, rspec);
  975 
  976   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  977   else __ delayed()-&gt;nop();
  978 
  979   if (preserve_g2)   __ mov(L7, G2);
  980 
  981 #ifdef ASSERT
  982   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
  983     // Trash argument dump slots.
</pre>
<hr />
<pre>
  985     __ mov(G1, G5);
  986     __ stx(G1, SP, STACK_BIAS + 0x80);
  987     __ stx(G1, SP, STACK_BIAS + 0x88);
  988     __ stx(G1, SP, STACK_BIAS + 0x90);
  989     __ stx(G1, SP, STACK_BIAS + 0x98);
  990     __ stx(G1, SP, STACK_BIAS + 0xA0);
  991     __ stx(G1, SP, STACK_BIAS + 0xA8);
  992   }
  993 #endif /*ASSERT*/
  994 }
  995 
  996 //=============================================================================
  997 // REQUIRED FUNCTIONALITY for encoding
  998 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  999 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1000 
 1001 
 1002 //=============================================================================
 1003 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1004 
<span class="line-modified"> 1005 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
 1006   if (UseRDPCForConstantTableBase) {
 1007     // The table base offset might be less but then it fits into
 1008     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1009     return Assembler::min_simm13();
 1010   } else {
 1011     int offset = -(size() / 2);
 1012     if (!Assembler::is_simm13(offset)) {
 1013       offset = Assembler::min_simm13();
 1014     }
 1015     return offset;
 1016   }
 1017 }
 1018 
 1019 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1020 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1021   ShouldNotReachHere();
 1022 }
 1023 
 1024 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1025   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1026   Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="line-modified"> 1027   MacroAssembler _masm(&amp;cbuf);</span>
 1028 
 1029   Register r = as_Register(ra_-&gt;get_encode(this));
 1030   CodeSection* consts_section = __ code()-&gt;consts();
 1031   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1032   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1033 
 1034   if (UseRDPCForConstantTableBase) {
 1035     // For the following RDPC logic to work correctly the consts
 1036     // section must be allocated right before the insts section.  This
 1037     // assert checks for that.  The layout and the SECT_* constants
 1038     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1039     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1040     int insts_offset = __ offset();
 1041 
 1042     // Layout:
 1043     //
 1044     // |----------- consts section ------------|----------- insts section -----------...
 1045     // |------ constant table -----|- padding -|------------------x----
 1046     //                                                            \ current PC (RDPC instruction)
 1047     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
</pre>
<hr />
<pre>
 1111     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1112   }
 1113 }
 1114 #endif
 1115 
 1116 
 1117 //=============================================================================
 1118 
 1119 #ifndef PRODUCT
 1120 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1121   Compile* C = ra_-&gt;C;
 1122 
 1123   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1124     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1125   }
 1126 
 1127   if( VerifyThread ) {
 1128     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1129   }
 1130 
<span class="line-modified"> 1131   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 1132   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1133 
 1134   // Calls to C2R adapters often do not accept exceptional returns.
 1135   // We require that their callers must bang for them.  But be careful, because
 1136   // some VM calls (such as call site linkage) can use several kilobytes of
 1137   // stack.  But the stack safety zone should account for that.
 1138   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1139   if (C-&gt;need_stack_bang(bangsize)) {</span>
 1140     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1141   }
 1142 
 1143   if (Assembler::is_simm13(-framesize)) {
 1144     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1145   } else {
 1146     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1147     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1148     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1149   }
 1150 
 1151 }
 1152 #endif
 1153 
 1154 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1155   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1156   MacroAssembler _masm(&amp;cbuf);</span>
 1157 
 1158   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1159     __ nop();
 1160   }
 1161 
 1162   __ verify_thread();
 1163 
<span class="line-modified"> 1164   size_t framesize = C-&gt;frame_size_in_bytes();</span>
 1165   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1166   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<span class="line-modified"> 1167   int bangsize = C-&gt;bang_size_in_bytes();</span>
 1168 
 1169   // Calls to C2R adapters often do not accept exceptional returns.
 1170   // We require that their callers must bang for them.  But be careful, because
 1171   // some VM calls (such as call site linkage) can use several kilobytes of
 1172   // stack.  But the stack safety zone should account for that.
 1173   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1174   if (C-&gt;need_stack_bang(bangsize)) {</span>
 1175     __ generate_stack_overflow_check(bangsize);
 1176   }
 1177 
 1178   if (Assembler::is_simm13(-framesize)) {
 1179     __ save(SP, -framesize, SP);
 1180   } else {
 1181     __ sethi(-framesize &amp; ~0x3ff, G3);
 1182     __ add(G3, -framesize &amp; 0x3ff, G3);
 1183     __ save(SP, G3, SP);
 1184   }
<span class="line-modified"> 1185   C-&gt;set_frame_complete( __ offset() );</span>
 1186 
 1187   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1188     // NOTE: We set the table base offset here because users might be
 1189     // emitted before MachConstantBaseNode.
<span class="line-modified"> 1190     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
 1191     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1192   }
 1193 }
 1194 
 1195 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1196   return MachNode::size(ra_);
 1197 }
 1198 
 1199 int MachPrologNode::reloc() const {
 1200   return 10; // a large enough number
 1201 }
 1202 
 1203 //=============================================================================
 1204 #ifndef PRODUCT
 1205 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1206   Compile* C = ra_-&gt;C;
 1207 
 1208   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified"> 1209     if (SafepointMechanism::uses_global_page_poll()) {</span>
<span class="line-removed"> 1210       st-&gt;print(&quot;SETHI  #PollAddr,L0\t! Load Polling address\n\t&quot;);</span>
<span class="line-removed"> 1211     } else {</span>
<span class="line-removed"> 1212       st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);</span>
<span class="line-removed"> 1213     }</span>
 1214     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1215   }
 1216 
 1217   if(do_polling()) {
 1218     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1219       st-&gt;print(&quot;NOP\n\t&quot;);
 1220     }
 1221     st-&gt;print(&quot;RET\n\t&quot;);
 1222   }
 1223 
 1224   st-&gt;print(&quot;RESTORE&quot;);
 1225 }
 1226 #endif
 1227 
 1228 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1229   MacroAssembler _masm(&amp;cbuf);</span>
 1230   Compile* C = ra_-&gt;C;
 1231 
 1232   __ verify_thread();
 1233 
 1234   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1235     __ reserved_stack_check();
 1236   }
 1237 
 1238   // If this does safepoint polling, then do it here
 1239   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified"> 1240     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed"> 1241       __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>
<span class="line-removed"> 1242     } else {</span>
<span class="line-removed"> 1243       AddressLiteral polling_page(os::get_polling_page());</span>
<span class="line-removed"> 1244       __ sethi(polling_page, L0);</span>
<span class="line-removed"> 1245     }</span>
 1246     __ relocate(relocInfo::poll_return_type);
 1247     __ ld_ptr(L0, 0, G0);
 1248   }
 1249 
 1250   // If this is a return, then stuff the restore in the delay slot
 1251   if(do_polling()) {
 1252     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1253       // Insert extra padding for the case when the epilogue is preceded by
 1254       // a cbcond jump, which can&#39;t be followed by a CTI instruction
 1255       __ nop();
 1256     }
 1257     __ ret();
 1258     __ delayed()-&gt;restore();
 1259   } else {
 1260     __ restore();
 1261   }
 1262 }
 1263 
 1264 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1265   return MachNode::size(ra_);
 1266 }
 1267 
 1268 int MachEpilogNode::reloc() const {
 1269   return 16; // a large enough number
 1270 }
 1271 
 1272 const Pipeline * MachEpilogNode::pipeline() const {
 1273   return MachNode::pipeline_class();
 1274 }
 1275 
<span class="line-removed"> 1276 int MachEpilogNode::safepoint_offset() const {</span>
<span class="line-removed"> 1277   assert(SafepointMechanism::uses_global_page_poll(), &quot;sanity&quot;);</span>
<span class="line-removed"> 1278   assert( do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="line-removed"> 1279   return MacroAssembler::insts_for_sethi(os::get_polling_page()) * BytesPerInstWord;</span>
<span class="line-removed"> 1280 }</span>
<span class="line-removed"> 1281 </span>
 1282 //=============================================================================
 1283 
 1284 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
 1285 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1286 static enum RC rc_class( OptoReg::Name reg ) {
 1287   if (!OptoReg::is_valid(reg)) return rc_bad;
 1288   if (OptoReg::is_stack(reg)) return rc_stack;
 1289   VMReg r = OptoReg::as_VMReg(reg);
 1290   if (r-&gt;is_Register()) return rc_int;
 1291   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
 1292   return rc_float;
 1293 }
 1294 
 1295 #ifndef PRODUCT
 1296 ATTRIBUTE_PRINTF(2, 3)
 1297 static void print_helper(outputStream* st, const char* format, ...) {
 1298   const int tab_size = 8;
 1299   if (st-&gt;position() &gt; tab_size) {
 1300     st-&gt;cr();
 1301     st-&gt;sp();
</pre>
<hr />
<pre>
 1517   implementation( NULL, ra_, false, st );
 1518 }
 1519 #endif
 1520 
 1521 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1522   implementation( &amp;cbuf, ra_, false, NULL );
 1523 }
 1524 
 1525 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1526   return MachNode::size(ra_);
 1527 }
 1528 
 1529 //=============================================================================
 1530 #ifndef PRODUCT
 1531 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1532   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1533 }
 1534 #endif
 1535 
 1536 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="line-modified"> 1537   MacroAssembler _masm(&amp;cbuf);</span>
 1538   for (int i = 0; i &lt; _count; i += 1) {
 1539     __ nop();
 1540   }
 1541 }
 1542 
 1543 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1544   return 4 * _count;
 1545 }
 1546 
 1547 
 1548 //=============================================================================
 1549 #ifndef PRODUCT
 1550 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1551   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1552   int reg = ra_-&gt;get_reg_first(this);
 1553   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1554 }
 1555 #endif
 1556 
 1557 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1558   MacroAssembler _masm(&amp;cbuf);</span>
 1559   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1560   int reg = ra_-&gt;get_encode(this);
 1561 
 1562   if (Assembler::is_simm13(offset)) {
 1563      __ add(SP, offset, reg_to_register_object(reg));
 1564   } else {
 1565      __ set(offset, O7);
 1566      __ add(SP, O7, reg_to_register_object(reg));
 1567   }
 1568 }
 1569 
 1570 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1571   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1572   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified"> 1573   return ra_-&gt;C-&gt;scratch_emit_size(this);</span>
 1574 }
 1575 
 1576 //=============================================================================
 1577 #ifndef PRODUCT
 1578 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1579   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1580   if (UseCompressedClassPointers) {
 1581     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1582     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1583     if (CompressedKlassPointers::base() != 0) {
 1584       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1585       if (CompressedKlassPointers::shift() != 0) {
 1586         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1587       }
 1588       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1589       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1590     } else {
 1591       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1592     }
 1593   } else {
 1594     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1595   }
 1596   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1597   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1598 }
 1599 #endif
 1600 
 1601 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1602   MacroAssembler _masm(&amp;cbuf);</span>
 1603   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1604   Register temp_reg   = G3;
 1605   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1606 
 1607   // Load klass from receiver
 1608   __ load_klass(O0, temp_reg);
 1609   // Compare against expected klass
 1610   __ cmp(temp_reg, G5_ic_reg);
 1611   // Branch to miss code, checks xcc or icc depending
 1612   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1613 }
 1614 
 1615 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1616   return MachNode::size(ra_);
 1617 }
 1618 
 1619 
 1620 //=============================================================================
 1621 
 1622 
 1623 // Emit exception handler code.
 1624 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1625   Register temp_reg = G3;
 1626   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<span class="line-modified"> 1627   MacroAssembler _masm(&amp;cbuf);</span>
 1628 
 1629   address base = __ start_a_stub(size_exception_handler());
 1630   if (base == NULL) {
 1631     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1632     return 0;  // CodeBuffer::expand failed
 1633   }
 1634 
 1635   int offset = __ offset();
 1636 
 1637   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1638   __ delayed()-&gt;nop();
 1639 
 1640   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1641 
 1642   __ end_a_stub();
 1643 
 1644   return offset;
 1645 }
 1646 
 1647 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1648   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1649   // at a poll and everything (including G3) can be live.
 1650   Register temp_reg = L0;
 1651   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-modified"> 1652   MacroAssembler _masm(&amp;cbuf);</span>
 1653 
 1654   address base = __ start_a_stub(size_deopt_handler());
 1655   if (base == NULL) {
 1656     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1657     return 0;  // CodeBuffer::expand failed
 1658   }
 1659 
 1660   int offset = __ offset();
 1661   __ save_frame(0);
 1662   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1663   __ delayed()-&gt;restore();
 1664 
 1665   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1666 
 1667   __ end_a_stub();
 1668   return offset;
 1669 
 1670 }
 1671 
 1672 // Given a register encoding, produce a Integer Register object
</pre>
<hr />
<pre>
 1942 
 1943 // Register for DIVL projection of divmodL
 1944 RegMask Matcher::divL_proj_mask() {
 1945   ShouldNotReachHere();
 1946   return RegMask();
 1947 }
 1948 
 1949 // Register for MODL projection of divmodL
 1950 RegMask Matcher::modL_proj_mask() {
 1951   ShouldNotReachHere();
 1952   return RegMask();
 1953 }
 1954 
 1955 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1956   return L7_REGP_mask();
 1957 }
 1958 
 1959 
 1960 const bool Matcher::convi2l_type_required = true;
 1961 





 1962 // Should the Matcher clone shifts on addressing modes, expecting them
 1963 // to be subsumed into complex addressing expressions or compute them
 1964 // into registers?
<span class="line-modified"> 1965 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1966   return clone_base_plus_offset_address(m, mstack, address_visited);
 1967 }
 1968 
 1969 void Compile::reshape_address(AddPNode* addp) {
 1970 }
 1971 
 1972 %}
 1973 
 1974 
 1975 // The intptr_t operand types, defined by textual substitution.
 1976 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
 1977 #define immX      immL
 1978 #define immX13    immL13
 1979 #define immX13m7  immL13m7
 1980 #define iRegX     iRegL
 1981 #define g1RegX    g1RegL
 1982 
 1983 //----------ENCODING BLOCK-----------------------------------------------------
 1984 // This block specifies the encoding classes used by the compiler to output
 1985 // byte streams.  Encoding classes are parameterized macros used by
</pre>
<hr />
<pre>
 1990 // operand to generate a function which returns its register number when
 1991 // queried.   CONST_INTER causes an operand to generate a function which
 1992 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1993 // operand to generate four functions which return the Base Register, the
 1994 // Index Register, the Scale Value, and the Offset Value of the operand when
 1995 // queried.  COND_INTER causes an operand to generate six functions which
 1996 // return the encoding code (ie - encoding bits for the instruction)
 1997 // associated with each basic boolean condition for a conditional instruction.
 1998 //
 1999 // Instructions specify two basic values for encoding.  Again, a function
 2000 // is available to check if the constant displacement is an oop. They use the
 2001 // ins_encode keyword to specify their encoding classes (which must be
 2002 // a sequence of enc_class names, and their parameters, specified in
 2003 // the encoding block), and they use the
 2004 // opcode keyword to specify, in order, their primary, secondary, and
 2005 // tertiary opcode.  Only the opcode sections which a particular instruction
 2006 // needs for encoding need to be specified.
 2007 encode %{
 2008   enc_class enc_untested %{
 2009 #ifdef ASSERT
<span class="line-modified"> 2010     MacroAssembler _masm(&amp;cbuf);</span>
 2011     __ untested(&quot;encoding&quot;);
 2012 #endif
 2013   %}
 2014 
 2015   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2016     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2017                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2018   %}
 2019 
 2020   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2021     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2022                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2023   %}
 2024 
 2025   enc_class form3_mem_prefetch_read( memory mem ) %{
 2026     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2027                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2028   %}
 2029 
 2030   enc_class form3_mem_prefetch_write( memory mem ) %{
</pre>
<hr />
<pre>
 2125   %}
 2126 
 2127   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2128     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2129   %}
 2130 
 2131   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2132     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2133   %}
 2134 
 2135   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2136     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2137   %}
 2138 
 2139   enc_class move_return_pc_to_o1() %{
 2140     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2141   %}
 2142 
 2143   /* %%% merge with enc_to_bool */
 2144   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<span class="line-modified"> 2145     MacroAssembler _masm(&amp;cbuf);</span>
 2146 
 2147     Register   src_reg = reg_to_register_object($src$$reg);
 2148     Register   dst_reg = reg_to_register_object($dst$$reg);
 2149     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2150   %}
 2151 
 2152   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2153     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<span class="line-modified"> 2154     MacroAssembler _masm(&amp;cbuf);</span>
 2155 
 2156     Register   p_reg = reg_to_register_object($p$$reg);
 2157     Register   q_reg = reg_to_register_object($q$$reg);
 2158     Register   y_reg = reg_to_register_object($y$$reg);
 2159     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2160 
 2161     __ subcc( p_reg, q_reg,   p_reg );
 2162     __ add  ( p_reg, y_reg, tmp_reg );
 2163     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2164   %}
 2165 
 2166   enc_class form_d2i_helper(regD src, regF dst) %{
 2167     // fcmp %fcc0,$src,$src
 2168     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2169     // branch %fcc0 not-nan, predict taken
 2170     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2171     // fdtoi $src,$dst
 2172     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2173     // fitos $dst,$dst (if nan)
 2174     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
</pre>
<hr />
<pre>
 2267   %}
 2268 
 2269 
 2270   // Compare longs and convert into -1, 0, 1.
 2271   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2272     // CMP $src1,$src2
 2273     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2274     // blt,a,pn done
 2275     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2276     // mov dst,-1 in delay slot
 2277     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2278     // bgt,a,pn done
 2279     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2280     // mov dst,1 in delay slot
 2281     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2282     // CLR    $dst
 2283     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2284   %}
 2285 
 2286   enc_class enc_PartialSubtypeCheck() %{
<span class="line-modified"> 2287     MacroAssembler _masm(&amp;cbuf);</span>
 2288     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2289     __ delayed()-&gt;nop();
 2290   %}
 2291 
 2292   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<span class="line-modified"> 2293     MacroAssembler _masm(&amp;cbuf);</span>
 2294     Label* L = $labl$$label;
 2295     Assembler::Predict predict_taken =
 2296       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2297 
 2298     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2299     __ delayed()-&gt;nop();
 2300   %}
 2301 
 2302   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<span class="line-modified"> 2303     MacroAssembler _masm(&amp;cbuf);</span>
 2304     Label* L = $labl$$label;
 2305     Assembler::Predict predict_taken =
 2306       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2307 
 2308     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2309     __ delayed()-&gt;nop();
 2310   %}
 2311 
 2312   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2313     int op = (Assembler::arith_op &lt;&lt; 30) |
 2314              ($dst$$reg &lt;&lt; 25) |
 2315              (Assembler::movcc_op3 &lt;&lt; 19) |
 2316              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2317              ($cmp$$cmpcode &lt;&lt; 14) |
 2318              (0 &lt;&lt; 13) |                    // select register move
 2319              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2320              ($src$$reg &lt;&lt; 0);
 2321     cbuf.insts()-&gt;emit_int32(op);
 2322   %}
 2323 
</pre>
<hr />
<pre>
 2402     int op = (Assembler::arith_op &lt;&lt; 30) |
 2403              ($dst$$reg &lt;&lt; 25) |
 2404              (Assembler::movcc_op3 &lt;&lt; 19) |
 2405              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2406              ($primary &lt;&lt; 14) |
 2407              (0 &lt;&lt; 13) |                    // select register move
 2408              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2409              ($src$$reg &lt;&lt; 0);
 2410     cbuf.insts()-&gt;emit_int32(op);
 2411   %}
 2412 
 2413   enc_class Set13( immI13 src, iRegI rd ) %{
 2414     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2415   %}
 2416 
 2417   enc_class SetHi22( immI src, iRegI rd ) %{
 2418     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2419   %}
 2420 
 2421   enc_class Set32( immI src, iRegI rd ) %{
<span class="line-modified"> 2422     MacroAssembler _masm(&amp;cbuf);</span>
 2423     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2424   %}
 2425 
 2426   enc_class call_epilog %{
 2427     if( VerifyStackAtCalls ) {
<span class="line-modified"> 2428       MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 2429       int framesize = ra_-&gt;C-&gt;frame_size_in_bytes();</span>
 2430       Register temp_reg = G3;
 2431       __ add(SP, framesize, temp_reg);
 2432       __ cmp(temp_reg, FP);
 2433       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2434     }
 2435   %}
 2436 
 2437   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2438   // to G1 so the register allocator will not have to deal with the misaligned register
 2439   // pair.
 2440   enc_class adjust_long_from_native_call %{
 2441   %}
 2442 
 2443   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2444     // CALL directly to the runtime
 2445     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2446     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2447   %}
 2448 
 2449   enc_class preserve_SP %{
<span class="line-modified"> 2450     MacroAssembler _masm(&amp;cbuf);</span>
 2451     __ mov(SP, L7_mh_SP_save);
 2452   %}
 2453 
 2454   enc_class restore_SP %{
<span class="line-modified"> 2455     MacroAssembler _masm(&amp;cbuf);</span>
 2456     __ mov(L7_mh_SP_save, SP);
 2457   %}
 2458 
 2459   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2460     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2461     // who we intended to call.
 2462     if (!_method) {
 2463       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2464     } else {
 2465       int method_index = resolved_method_index(cbuf);
 2466       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2467                                                   : static_call_Relocation::spec(method_index);
 2468       emit_call_reloc(cbuf, $meth$$method, rspec);
 2469 
 2470       // Emit stub for static call.
 2471       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2472       if (stub == NULL) {
 2473         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2474         return;
 2475       }
 2476     }
 2477   %}
 2478 
 2479   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<span class="line-modified"> 2480     MacroAssembler _masm(&amp;cbuf);</span>
 2481     __ set_inst_mark();
 2482     int vtable_index = this-&gt;_vtable_index;
 2483     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2484     if (vtable_index &lt; 0) {
 2485       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2486       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2487       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2488       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2489       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2490       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2491     } else {
 2492       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2493       // Just go thru the vtable
 2494       // get receiver klass (receiver already checked for non-null)
 2495       // If we end up going thru a c2i adapter interpreter expects method in G5
 2496       int off = __ offset();
 2497       __ load_klass(O0, G3_scratch);
 2498       int klass_load_size;
 2499       if (UseCompressedClassPointers) {
 2500         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
</pre>
<hr />
<pre>
 2509       } else {
 2510         // Generate 2 instructions
 2511         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2512         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2513         // ld_ptr, set_hi, set
 2514         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2515                &quot;Unexpected instruction size(s)&quot;);
 2516         __ ld_ptr(G3, G5_method, G5_method);
 2517       }
 2518       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2519       // However it may very well end up in handle_wrong_method if the
 2520       // method is abstract for the particular class.
 2521       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2522       // jump to target (either compiled code or c2iadapter)
 2523       __ jmpl(G3_scratch, G0, O7);
 2524       __ delayed()-&gt;nop();
 2525     }
 2526   %}
 2527 
 2528   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<span class="line-modified"> 2529     MacroAssembler _masm(&amp;cbuf);</span>
 2530 
 2531     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2532     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2533                               // we might be calling a C2I adapter which needs it.
 2534 
 2535     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2536     // Load nmethod
 2537     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2538 
 2539     // CALL to compiled java, indirect the contents of G3
 2540     __ set_inst_mark();
 2541     __ callr(temp_reg, G0);
 2542     __ delayed()-&gt;nop();
 2543   %}
 2544 
 2545 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<span class="line-modified"> 2546     MacroAssembler _masm(&amp;cbuf);</span>
 2547     Register Rdividend = reg_to_register_object($src1$$reg);
 2548     Register Rdivisor = reg_to_register_object($src2$$reg);
 2549     Register Rresult = reg_to_register_object($dst$$reg);
 2550 
 2551     __ sra(Rdivisor, 0, Rdivisor);
 2552     __ sra(Rdividend, 0, Rdividend);
 2553     __ sdivx(Rdividend, Rdivisor, Rresult);
 2554 %}
 2555 
 2556 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<span class="line-modified"> 2557     MacroAssembler _masm(&amp;cbuf);</span>
 2558 
 2559     Register Rdividend = reg_to_register_object($src1$$reg);
 2560     int divisor = $imm$$constant;
 2561     Register Rresult = reg_to_register_object($dst$$reg);
 2562 
 2563     __ sra(Rdividend, 0, Rdividend);
 2564     __ sdivx(Rdividend, divisor, Rresult);
 2565 %}
 2566 
 2567 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<span class="line-modified"> 2568     MacroAssembler _masm(&amp;cbuf);</span>
 2569     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2570     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2571     Register Rdst  = reg_to_register_object($dst$$reg);
 2572 
 2573     __ sra( Rsrc1, 0, Rsrc1 );
 2574     __ sra( Rsrc2, 0, Rsrc2 );
 2575     __ mulx( Rsrc1, Rsrc2, Rdst );
 2576     __ srlx( Rdst, 32, Rdst );
 2577 %}
 2578 
 2579 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2580     MacroAssembler _masm(&amp;cbuf);</span>
 2581     Register Rdividend = reg_to_register_object($src1$$reg);
 2582     Register Rdivisor = reg_to_register_object($src2$$reg);
 2583     Register Rresult = reg_to_register_object($dst$$reg);
 2584     Register Rscratch = reg_to_register_object($scratch$$reg);
 2585 
 2586     assert(Rdividend != Rscratch, &quot;&quot;);
 2587     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2588 
 2589     __ sra(Rdividend, 0, Rdividend);
 2590     __ sra(Rdivisor, 0, Rdivisor);
 2591     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2592     __ mulx(Rscratch, Rdivisor, Rscratch);
 2593     __ sub(Rdividend, Rscratch, Rresult);
 2594 %}
 2595 
 2596 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2597     MacroAssembler _masm(&amp;cbuf);</span>
 2598 
 2599     Register Rdividend = reg_to_register_object($src1$$reg);
 2600     int divisor = $imm$$constant;
 2601     Register Rresult = reg_to_register_object($dst$$reg);
 2602     Register Rscratch = reg_to_register_object($scratch$$reg);
 2603 
 2604     assert(Rdividend != Rscratch, &quot;&quot;);
 2605 
 2606     __ sra(Rdividend, 0, Rdividend);
 2607     __ sdivx(Rdividend, divisor, Rscratch);
 2608     __ mulx(Rscratch, divisor, Rscratch);
 2609     __ sub(Rdividend, Rscratch, Rresult);
 2610 %}
 2611 
 2612 enc_class fabss (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2613     MacroAssembler _masm(&amp;cbuf);</span>
 2614 
 2615     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2616     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2617 
 2618     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2619 %}
 2620 
 2621 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2622     MacroAssembler _masm(&amp;cbuf);</span>
 2623 
 2624     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2625     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2626 
 2627     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2628 %}
 2629 
 2630 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2631     MacroAssembler _masm(&amp;cbuf);</span>
 2632 
 2633     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2634     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2635 
 2636     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2637 %}
 2638 
 2639 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2640     MacroAssembler _masm(&amp;cbuf);</span>
 2641 
 2642     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2643     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2644 
 2645     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2646 %}
 2647 
 2648 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2649     MacroAssembler _masm(&amp;cbuf);</span>
 2650 
 2651     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2652     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2653 
 2654     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2655 %}
 2656 
 2657 
 2658 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2659     MacroAssembler _masm(&amp;cbuf);</span>
 2660 
 2661     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2662     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2663     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2664     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2665 
 2666     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2667 %}
 2668 
 2669 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2670     MacroAssembler _masm(&amp;cbuf);</span>
 2671 
 2672     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2673     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2674     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2675     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2676 
 2677     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2678 %}
 2679 
 2680 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2681     MacroAssembler _masm(&amp;cbuf);</span>
 2682 
 2683     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2684     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2685     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2686     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2687 
 2688     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2689 %}
 2690 
 2691 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2692     MacroAssembler _masm(&amp;cbuf);</span>
 2693 
 2694     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2695     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2696     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2697     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2698 
 2699     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2700 %}
 2701 
 2702 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2703     MacroAssembler _masm(&amp;cbuf);</span>
 2704 
 2705     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2706     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2707     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2708     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2709 
 2710     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2711 %}
 2712 
 2713 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2714     MacroAssembler _masm(&amp;cbuf);</span>
 2715 
 2716     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2717     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2718     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2719     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2720 
 2721     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2722 %}
 2723 
 2724 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2725     MacroAssembler _masm(&amp;cbuf);</span>
 2726 
 2727     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2728     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2729     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2730     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2731 
 2732     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2733 %}
 2734 
 2735 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2736     MacroAssembler _masm(&amp;cbuf);</span>
 2737 
 2738     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2739     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2740     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2741     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2742 
 2743     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2744 %}
 2745 
 2746 
 2747 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2748     MacroAssembler _masm(&amp;cbuf);</span>
 2749 
 2750     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2751     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2752 
 2753     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2754 %}
 2755 
 2756 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2757     MacroAssembler _masm(&amp;cbuf);</span>
 2758 
 2759     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2760     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2761 
 2762     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2763 %}
 2764 
 2765 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2766     MacroAssembler _masm(&amp;cbuf);</span>
 2767 
 2768     Register Roop  = reg_to_register_object($oop$$reg);
 2769     Register Rbox  = reg_to_register_object($box$$reg);
 2770     Register Rscratch = reg_to_register_object($scratch$$reg);
 2771     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2772 
 2773     assert(Roop  != Rscratch, &quot;&quot;);
 2774     assert(Roop  != Rmark, &quot;&quot;);
 2775     assert(Rbox  != Rscratch, &quot;&quot;);
 2776     assert(Rbox  != Rmark, &quot;&quot;);
 2777 
 2778     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2779 %}
 2780 
 2781 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2782     MacroAssembler _masm(&amp;cbuf);</span>
 2783 
 2784     Register Roop  = reg_to_register_object($oop$$reg);
 2785     Register Rbox  = reg_to_register_object($box$$reg);
 2786     Register Rscratch = reg_to_register_object($scratch$$reg);
 2787     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2788 
 2789     assert(Roop  != Rscratch, &quot;&quot;);
 2790     assert(Roop  != Rmark, &quot;&quot;);
 2791     assert(Rbox  != Rscratch, &quot;&quot;);
 2792     assert(Rbox  != Rmark, &quot;&quot;);
 2793 
 2794     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2795   %}
 2796 
 2797   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<span class="line-modified"> 2798     MacroAssembler _masm(&amp;cbuf);</span>
 2799     Register Rmem = reg_to_register_object($mem$$reg);
 2800     Register Rold = reg_to_register_object($old$$reg);
 2801     Register Rnew = reg_to_register_object($new$$reg);
 2802 
 2803     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2804     __ cmp( Rold, Rnew );
 2805   %}
 2806 
 2807   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2808     Register Rmem = reg_to_register_object($mem$$reg);
 2809     Register Rold = reg_to_register_object($old$$reg);
 2810     Register Rnew = reg_to_register_object($new$$reg);
 2811 
<span class="line-modified"> 2812     MacroAssembler _masm(&amp;cbuf);</span>
 2813     __ mov(Rnew, O7);
 2814     __ casx(Rmem, Rold, O7);
 2815     __ cmp( Rold, O7 );
 2816   %}
 2817 
 2818   // raw int cas, used for compareAndSwap
 2819   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2820     Register Rmem = reg_to_register_object($mem$$reg);
 2821     Register Rold = reg_to_register_object($old$$reg);
 2822     Register Rnew = reg_to_register_object($new$$reg);
 2823 
<span class="line-modified"> 2824     MacroAssembler _masm(&amp;cbuf);</span>
 2825     __ mov(Rnew, O7);
 2826     __ cas(Rmem, Rold, O7);
 2827     __ cmp( Rold, O7 );
 2828   %}
 2829 
 2830   // raw int cas without using tmp register for compareAndExchange
 2831   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2832     Register Rmem = reg_to_register_object($mem$$reg);
 2833     Register Rold = reg_to_register_object($old$$reg);
 2834     Register Rnew = reg_to_register_object($new$$reg);
 2835 
<span class="line-modified"> 2836     MacroAssembler _masm(&amp;cbuf);</span>
 2837     __ cas(Rmem, Rold, Rnew);
 2838   %}
 2839 
 2840   // 64-bit cas without using tmp register for compareAndExchange
 2841   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2842     Register Rmem = reg_to_register_object($mem$$reg);
 2843     Register Rold = reg_to_register_object($old$$reg);
 2844     Register Rnew = reg_to_register_object($new$$reg);
 2845 
<span class="line-modified"> 2846     MacroAssembler _masm(&amp;cbuf);</span>
 2847     __ casx(Rmem, Rold, Rnew);
 2848   %}
 2849 
 2850   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2851     Register Rres = reg_to_register_object($res$$reg);
 2852 
<span class="line-modified"> 2853     MacroAssembler _masm(&amp;cbuf);</span>
 2854     __ mov(1, Rres);
 2855     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2856   %}
 2857 
 2858   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2859     Register Rres = reg_to_register_object($res$$reg);
 2860 
<span class="line-modified"> 2861     MacroAssembler _masm(&amp;cbuf);</span>
 2862     __ mov(1, Rres);
 2863     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2864   %}
 2865 
 2866   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<span class="line-modified"> 2867     MacroAssembler _masm(&amp;cbuf);</span>
 2868     Register Rdst = reg_to_register_object($dst$$reg);
 2869     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2870                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2871     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2872                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2873 
 2874     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2875     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2876   %}
 2877 
 2878   enc_class enc_rethrow() %{
 2879     cbuf.set_insts_mark();
 2880     Register temp_reg = G3;
 2881     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2882     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<span class="line-modified"> 2883     MacroAssembler _masm(&amp;cbuf);</span>
 2884 #ifdef ASSERT
 2885     __ save_frame(0);
 2886     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2887     __ sethi(last_rethrow_addrlit, L1);
 2888     Address addr(L1, last_rethrow_addrlit.low10());
 2889     __ rdpc(L2);
 2890     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2891     __ st_ptr(L2, addr);
 2892     __ restore();
 2893 #endif
 2894     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2895     __ delayed()-&gt;nop();
 2896   %}
 2897 
 2898   enc_class emit_mem_nop() %{
 2899     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2900     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2901   %}
 2902 
 2903   enc_class emit_fadd_nop() %{
 2904     // Generates the instruction FMOVS f31,f31
 2905     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2906   %}
 2907 
 2908   enc_class emit_br_nop() %{
 2909     // Generates the instruction BPN,PN .
 2910     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2911   %}
 2912 
 2913   enc_class enc_membar_acquire %{
<span class="line-modified"> 2914     MacroAssembler _masm(&amp;cbuf);</span>
 2915     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2916   %}
 2917 
 2918   enc_class enc_membar_release %{
<span class="line-modified"> 2919     MacroAssembler _masm(&amp;cbuf);</span>
 2920     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2921   %}
 2922 
 2923   enc_class enc_membar_volatile %{
<span class="line-modified"> 2924     MacroAssembler _masm(&amp;cbuf);</span>
 2925     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2926   %}
 2927 
 2928 %}
 2929 
 2930 //----------FRAME--------------------------------------------------------------
 2931 // Definition of frame structure and management information.
 2932 //
 2933 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2934 //                             |   (to get allocators register number
 2935 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2936 //  r   CALLER     |        |
 2937 //  o     |        +--------+      pad to even-align allocators stack-slot
 2938 //  w     V        |  pad0  |        numbers; owned by CALLER
 2939 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2940 //  h     ^        |   in   |  5
 2941 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2942 //  |     |        |        |  3
 2943 //  |     |        +--------+
 2944 //  V     |        | old out|      Empty on Intel, window on Sparc
</pre>
<hr />
<pre>
 3358 %}
 3359 
 3360 operand immP13() %{
 3361   predicate((-4096 &lt; n-&gt;get_ptr()) &amp;&amp; (n-&gt;get_ptr() &lt;= 4095));
 3362   match(ConP);
 3363   op_cost(0);
 3364 
 3365   format %{ %}
 3366   interface(CONST_INTER);
 3367 %}
 3368 
 3369 operand immP0() %{
 3370   predicate(n-&gt;get_ptr() == 0);
 3371   match(ConP);
 3372   op_cost(0);
 3373 
 3374   format %{ %}
 3375   interface(CONST_INTER);
 3376 %}
 3377 
<span class="line-removed"> 3378 operand immP_poll() %{</span>
<span class="line-removed"> 3379   predicate(n-&gt;get_ptr() != 0 &amp;&amp; n-&gt;get_ptr() == (intptr_t)os::get_polling_page());</span>
<span class="line-removed"> 3380   match(ConP);</span>
<span class="line-removed"> 3381 </span>
<span class="line-removed"> 3382   // formats are generated automatically for constants and base registers</span>
<span class="line-removed"> 3383   format %{ %}</span>
<span class="line-removed"> 3384   interface(CONST_INTER);</span>
<span class="line-removed"> 3385 %}</span>
<span class="line-removed"> 3386 </span>
 3387 // Pointer Immediate
 3388 operand immN()
 3389 %{
 3390   match(ConN);
 3391 
 3392   op_cost(10);
 3393   format %{ %}
 3394   interface(CONST_INTER);
 3395 %}
 3396 
 3397 operand immNKlass()
 3398 %{
 3399   match(ConNKlass);
 3400 
 3401   op_cost(10);
 3402   format %{ %}
 3403   interface(CONST_INTER);
 3404 %}
 3405 
 3406 // NULL Pointer Immediate
</pre>
<hr />
<pre>
 4475 pipe_class ialu_hi_lo_reg_temp(regF dst, immF src, g3RegP tmp) %{
 4476     instruction_count(1); multiple_bundles;
 4477     dst   : E(write)+1;
 4478     IALU  : R(2);
 4479 %}
 4480 
 4481 // Long Constant
 4482 pipe_class loadConL( iRegL dst, immL src ) %{
 4483     instruction_count(2); multiple_bundles;
 4484     dst   : E(write)+1;
 4485     IALU  : R(2);
 4486     IALU  : R(2);
 4487 %}
 4488 
 4489 // Pointer Constant
 4490 pipe_class loadConP( iRegP dst, immP src ) %{
 4491     instruction_count(0); multiple_bundles;
 4492     fixed_latency(6);
 4493 %}
 4494 
<span class="line-removed"> 4495 // Polling Address</span>
<span class="line-removed"> 4496 pipe_class loadConP_poll( iRegP dst, immP_poll src ) %{</span>
<span class="line-removed"> 4497     instruction_count(0); multiple_bundles;</span>
<span class="line-removed"> 4498     fixed_latency(6);</span>
<span class="line-removed"> 4499 %}</span>
<span class="line-removed"> 4500 </span>
 4501 // Long Constant small
 4502 pipe_class loadConLlo( iRegL dst, immL src ) %{
 4503     instruction_count(2);
 4504     dst   : E(write);
 4505     IALU  : R;
 4506     IALU  : R;
 4507 %}
 4508 
 4509 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 4510 pipe_class loadConFD(regF dst, immF src, g3RegP tmp) %{
 4511     instruction_count(1); multiple_bundles;
 4512     src   : R(read);
 4513     dst   : M(write)+1;
 4514     IALU  : R;
 4515     MS    : E;
 4516 %}
 4517 
 4518 // Integer ALU nop operation
 4519 pipe_class ialu_nop() %{
 4520     single_instruction;
</pre>
<hr />
<pre>
 5866     if (_opnds[1]-&gt;constant_reloc() == relocInfo::metadata_type) {
 5867       __ set_metadata_constant((Metadata*)$con$$constant, $dst$$Register);
 5868     } else {
 5869       __ set($con$$constant, $dst$$Register);
 5870     }
 5871   %}
 5872   ins_pipe(loadConP);
 5873 %}
 5874 
 5875 instruct loadConP0(iRegP dst, immP0 src) %{
 5876   match(Set dst src);
 5877 
 5878   size(4);
 5879   format %{ &quot;CLR    $dst\t!ptr&quot; %}
 5880   ins_encode %{
 5881     __ clr($dst$$Register);
 5882   %}
 5883   ins_pipe(ialu_imm);
 5884 %}
 5885 
<span class="line-removed"> 5886 instruct loadConP_poll(iRegP dst, immP_poll src) %{</span>
<span class="line-removed"> 5887   match(Set dst src);</span>
<span class="line-removed"> 5888   ins_cost(DEFAULT_COST);</span>
<span class="line-removed"> 5889   format %{ &quot;SET    $src,$dst\t!ptr&quot; %}</span>
<span class="line-removed"> 5890   ins_encode %{</span>
<span class="line-removed"> 5891     AddressLiteral polling_page(os::get_polling_page());</span>
<span class="line-removed"> 5892     __ sethi(polling_page, reg_to_register_object($dst$$reg));</span>
<span class="line-removed"> 5893   %}</span>
<span class="line-removed"> 5894   ins_pipe(loadConP_poll);</span>
<span class="line-removed"> 5895 %}</span>
<span class="line-removed"> 5896 </span>
 5897 instruct loadConN0(iRegN dst, immN0 src) %{
 5898   match(Set dst src);
 5899 
 5900   size(4);
 5901   format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
 5902   ins_encode %{
 5903     __ clr($dst$$Register);
 5904   %}
 5905   ins_pipe(ialu_imm);
 5906 %}
 5907 
 5908 instruct loadConN(iRegN dst, immN src) %{
 5909   match(Set dst src);
 5910   ins_cost(DEFAULT_COST * 3/2);
 5911   format %{ &quot;SET    $src,$dst\t! compressed ptr&quot; %}
 5912   ins_encode %{
 5913     Register dst = $dst$$Register;
 5914     __ set_narrow_oop((jobject)$src$$constant, dst);
 5915   %}
 5916   ins_pipe(ialu_hi_lo_reg);
</pre>
<hr />
<pre>
 8837 //----------Branches---------------------------------------------------------
 8838 // Jump
 8839 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8840 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8841   match(Jump switch_val);
 8842   effect(TEMP table);
 8843 
 8844   ins_cost(350);
 8845 
 8846   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8847              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8848              &quot;JUMP   O7&quot; %}
 8849   ins_encode %{
 8850     // Calculate table address into a register.
 8851     Register table_reg;
 8852     Register label_reg = O7;
 8853     // If we are calculating the size of this instruction don&#39;t trust
 8854     // zero offsets because they might change when
 8855     // MachConstantBaseNode decides to optimize the constant table
 8856     // base.
<span class="line-modified"> 8857     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;in_scratch_emit_size()) {</span>
 8858       table_reg = $constanttablebase;
 8859     } else {
 8860       table_reg = O7;
 8861       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8862       __ add($constanttablebase, con_offset, table_reg);
 8863     }
 8864 
 8865     // Jump to base address + switch value
 8866     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8867     __ jmp(label_reg, G0);
 8868     __ delayed()-&gt;nop();
 8869   %}
 8870   ins_pipe(ialu_reg_reg);
 8871 %}
 8872 
 8873 // Direct Branch.  Use V8 version with longer range.
 8874 instruct branch(label labl) %{
 8875   match(Goto);
 8876   effect(USE labl);
 8877 
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 1998, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
</pre>
<hr />
<pre>
  454     return 0; // no call trampolines on this platform
  455   }
  456 };
  457 
  458 class HandlerImpl {
  459 
  460  public:
  461 
  462   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  463   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  464 
  465   static uint size_exception_handler() {
  466     return ( NativeJump::instruction_size ); // sethi;jmp;nop
  467   }
  468 
  469   static uint size_deopt_handler() {
  470     return ( 4+  NativeJump::instruction_size ); // save;sethi;jmp;restore
  471   }
  472 };
  473 
<span class="line-added">  474 class Node::PD {</span>
<span class="line-added">  475 public:</span>
<span class="line-added">  476   enum NodeFlags {</span>
<span class="line-added">  477     _last_flag = Node::_last_flag</span>
<span class="line-added">  478   };</span>
<span class="line-added">  479 };</span>
<span class="line-added">  480 </span>
  481 %}
  482 
  483 source %{
  484 #define __ _masm.
  485 
  486 // tertiary op of a LoadP or StoreP encoding
  487 #define REGP_OP true
  488 
  489 static FloatRegister reg_to_SingleFloatRegister_object(int register_encoding);
  490 static FloatRegister reg_to_DoubleFloatRegister_object(int register_encoding);
  491 static Register reg_to_register_object(int register_encoding);
  492 
<span class="line-added">  493 void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">  494 }</span>
<span class="line-added">  495 </span>
<span class="line-added">  496 int MachNode::pd_alignment_required() const {</span>
<span class="line-added">  497   return 1;</span>
<span class="line-added">  498 }</span>
<span class="line-added">  499 </span>
<span class="line-added">  500 int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">  501   return 0;</span>
<span class="line-added">  502 }</span>
<span class="line-added">  503 </span>
  504 // Used by the DFA in dfa_sparc.cpp.
  505 // Check for being able to use a V9 branch-on-register.  Requires a
  506 // compare-vs-zero, equal/not-equal, of a value which was zero- or sign-
  507 // extended.  Doesn&#39;t work following an integer ADD, for example, because of
  508 // overflow (-1 incremented yields 0 plus a carry in the high-order word).  On
  509 // 32-bit V9 systems, interrupts currently blow away the high-order 32 bits and
  510 // replace them with zero, which could become sign-extension in a different OS
  511 // release.  There&#39;s no obvious reason why an interrupt will ever fill these
  512 // bits with non-zero junk (the registers are reloaded with standard LD
  513 // instructions which either zero-fill or sign-fill).
  514 bool can_branch_register( Node *bol, Node *cmp ) {
  515   if( !BranchOnRegister ) return false;
  516   if( cmp-&gt;Opcode() == Op_CmpP )
  517     return true;  // No problems with pointer compares
  518   if( cmp-&gt;Opcode() == Op_CmpL )
  519     return true;  // No problems with long compares
  520 
  521   if( !SparcV9RegsHiBitsZero ) return false;
  522   if( bol-&gt;as_Bool()-&gt;_test._test != BoolTest::ne &amp;&amp;
  523       bol-&gt;as_Bool()-&gt;_test._test != BoolTest::eq )
</pre>
<hr />
<pre>
  593     }
  594   }
  595 }
  596 
  597 int MachCallRuntimeNode::ret_addr_offset() {
  598   if (MacroAssembler::is_far_target(entry_point())) {
  599     return NativeFarCall::instruction_size;
  600   } else {
  601     return NativeCall::instruction_size;
  602   }
  603 }
  604 
  605 // Indicate if the safepoint node needs the polling page as an input.
  606 // Since Sparc does not have absolute addressing, it does.
  607 bool SafePointNode::needs_polling_address_input() {
  608   return true;
  609 }
  610 
  611 // emit an interrupt that is caught by the debugger (for debugging compiler)
  612 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  613   C2_MacroAssembler _masm(&amp;cbuf);</span>
  614   __ breakpoint_trap();
  615 }
  616 
  617 #ifndef PRODUCT
  618 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  619   st-&gt;print(&quot;TA&quot;);
  620 }
  621 #endif
  622 
  623 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  624   emit_break(cbuf);
  625 }
  626 
  627 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  628   return MachNode::size(ra_);
  629 }
  630 
  631 // Traceable jump
  632 void  emit_jmpl(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  633   C2_MacroAssembler _masm(&amp;cbuf);</span>
  634   Register rdest = reg_to_register_object(jump_target);
  635   __ JMP(rdest, 0);
  636   __ delayed()-&gt;nop();
  637 }
  638 
  639 // Traceable jump and set exception pc
  640 void  emit_jmpl_set_exception_pc(CodeBuffer &amp;cbuf, int jump_target) {
<span class="line-modified">  641   C2_MacroAssembler _masm(&amp;cbuf);</span>
  642   Register rdest = reg_to_register_object(jump_target);
  643   __ JMP(rdest, 0);
  644   __ delayed()-&gt;add(O7, frame::pc_return_offset, Oissuing_pc );
  645 }
  646 
  647 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  648   C2_MacroAssembler _masm(&amp;cbuf);</span>
  649   __ nop();
  650 }
  651 
  652 void emit_illtrap(CodeBuffer &amp;cbuf) {
<span class="line-modified">  653   C2_MacroAssembler _masm(&amp;cbuf);</span>
  654   __ illtrap(0);
  655 }
  656 
  657 
  658 intptr_t get_offset_from_base(const MachNode* n, const TypePtr* atype, int disp32) {
  659   assert(n-&gt;rule() != loadUB_rule, &quot;&quot;);
  660 
  661   intptr_t offset = 0;
  662   const TypePtr *adr_type = TYPE_PTR_SENTINAL;  // Check for base==RegI, disp==immP
  663   const Node* addr = n-&gt;get_base_and_disp(offset, adr_type);
  664   assert(adr_type == (const TypePtr*)-1, &quot;VerifyOops: no support for sparc operands with base==RegI, disp==immP&quot;);
  665   assert(addr != NULL &amp;&amp; addr != (Node*)-1, &quot;invalid addr&quot;);
  666   assert(addr-&gt;bottom_type()-&gt;isa_oopptr() == atype, &quot;&quot;);
  667   atype = atype-&gt;add_offset(offset);
  668   assert(disp32 == offset, &quot;wrong disp32&quot;);
  669   return atype-&gt;_offset;
  670 }
  671 
  672 
  673 intptr_t get_offset_from_base_2(const MachNode* n, const TypePtr* atype, int disp32) {
</pre>
<hr />
<pre>
  909             ShouldNotReachHere();
  910           }
  911         }
  912       }
  913     }
  914   }
  915 #endif
  916 
  917   uint instr = (Assembler::ldst_op &lt;&lt; 30)
  918              | (dst_enc        &lt;&lt; 25)
  919              | (primary        &lt;&lt; 19)
  920              | (src1_enc       &lt;&lt; 14);
  921 
  922   uint index = src2_enc;
  923   int disp = disp32;
  924 
  925   if (src1_enc == R_SP_enc || src1_enc == R_FP_enc) {
  926     disp += STACK_BIAS;
  927     // Check that stack offset fits, load into O7 if not
  928     if (!Assembler::is_simm13(disp)) {
<span class="line-modified">  929       C2_MacroAssembler _masm(&amp;cbuf);</span>
  930       __ set(disp, O7);
  931       if (index != R_G0_enc) {
  932         __ add(O7, reg_to_register_object(index), O7);
  933       }
  934       index = R_O7_enc;
  935       disp = 0;
  936     }
  937   }
  938 
  939   if( disp == 0 ) {
  940     // use reg-reg form
  941     // bit 13 is already zero
  942     instr |= index;
  943   } else {
  944     // use reg-imm form
  945     instr |= 0x00002000;          // set bit 13 to one
  946     instr |= disp &amp; 0x1FFF;
  947   }
  948 
  949   cbuf.insts()-&gt;emit_int32(instr);
  950 
  951 #ifdef ASSERT
  952   if (VerifyOops) {
<span class="line-modified">  953     C2_MacroAssembler _masm(&amp;cbuf);</span>
  954     if (is_verified_oop_base) {
  955       __ verify_oop(reg_to_register_object(src1_enc));
  956     }
  957     if (is_verified_oop_store) {
  958       __ verify_oop(reg_to_register_object(dst_enc));
  959     }
  960     if (tmp_enc != -1) {
  961       __ mov(O7, reg_to_register_object(tmp_enc));
  962     }
  963     if (is_verified_oop_load) {
  964       __ verify_oop(reg_to_register_object(dst_enc));
  965     }
  966   }
  967 #endif
  968 }
  969 
  970 void emit_call_reloc(CodeBuffer &amp;cbuf, intptr_t entry_point, RelocationHolder const&amp; rspec, bool preserve_g2 = false) {
  971   // The method which records debug information at every safepoint
  972   // expects the call to be the first instruction in the snippet as
  973   // it creates a PcDesc structure which tracks the offset of a call
  974   // from the start of the codeBlob. This offset is computed as
  975   // code_end() - code_begin() of the code which has been emitted
  976   // so far.
  977   // In this particular case we have skirted around the problem by
  978   // putting the &quot;mov&quot; instruction in the delay slot but the problem
  979   // may bite us again at some other point and a cleaner/generic
  980   // solution using relocations would be needed.
<span class="line-modified">  981   C2_MacroAssembler _masm(&amp;cbuf);</span>
  982   __ set_inst_mark();
  983 
  984   // We flush the current window just so that there is a valid stack copy
  985   // the fact that the current window becomes active again instantly is
  986   // not a problem there is nothing live in it.
  987 
  988 #ifdef ASSERT
  989   int startpos = __ offset();
  990 #endif /* ASSERT */
  991 
  992   __ call((address)entry_point, rspec);
  993 
  994   if (preserve_g2)   __ delayed()-&gt;mov(G2, L7);
  995   else __ delayed()-&gt;nop();
  996 
  997   if (preserve_g2)   __ mov(L7, G2);
  998 
  999 #ifdef ASSERT
 1000   if (preserve_g2 &amp;&amp; (VerifyCompiledCode || VerifyOops)) {
 1001     // Trash argument dump slots.
</pre>
<hr />
<pre>
 1003     __ mov(G1, G5);
 1004     __ stx(G1, SP, STACK_BIAS + 0x80);
 1005     __ stx(G1, SP, STACK_BIAS + 0x88);
 1006     __ stx(G1, SP, STACK_BIAS + 0x90);
 1007     __ stx(G1, SP, STACK_BIAS + 0x98);
 1008     __ stx(G1, SP, STACK_BIAS + 0xA0);
 1009     __ stx(G1, SP, STACK_BIAS + 0xA8);
 1010   }
 1011 #endif /*ASSERT*/
 1012 }
 1013 
 1014 //=============================================================================
 1015 // REQUIRED FUNCTIONALITY for encoding
 1016 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
 1017 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
 1018 
 1019 
 1020 //=============================================================================
 1021 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
 1022 
<span class="line-modified"> 1023 int ConstantTable::calculate_table_base_offset() const {</span>
 1024   if (UseRDPCForConstantTableBase) {
 1025     // The table base offset might be less but then it fits into
 1026     // simm13 anyway and we are good (cf. MachConstantBaseNode::emit).
 1027     return Assembler::min_simm13();
 1028   } else {
 1029     int offset = -(size() / 2);
 1030     if (!Assembler::is_simm13(offset)) {
 1031       offset = Assembler::min_simm13();
 1032     }
 1033     return offset;
 1034   }
 1035 }
 1036 
 1037 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 1038 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1039   ShouldNotReachHere();
 1040 }
 1041 
 1042 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1043   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1044   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified"> 1045   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1046 
 1047   Register r = as_Register(ra_-&gt;get_encode(this));
 1048   CodeSection* consts_section = __ code()-&gt;consts();
 1049   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
 1050   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
 1051 
 1052   if (UseRDPCForConstantTableBase) {
 1053     // For the following RDPC logic to work correctly the consts
 1054     // section must be allocated right before the insts section.  This
 1055     // assert checks for that.  The layout and the SECT_* constants
 1056     // are defined in src/share/vm/asm/codeBuffer.hpp.
 1057     assert(CodeBuffer::SECT_CONSTS + 1 == CodeBuffer::SECT_INSTS, &quot;must be&quot;);
 1058     int insts_offset = __ offset();
 1059 
 1060     // Layout:
 1061     //
 1062     // |----------- consts section ------------|----------- insts section -----------...
 1063     // |------ constant table -----|- padding -|------------------x----
 1064     //                                                            \ current PC (RDPC instruction)
 1065     // |&lt;------------- consts_size -----------&gt;|&lt;- insts_offset -&gt;|
</pre>
<hr />
<pre>
 1129     st-&gt;print(&quot;SET    &amp;constanttable,%s\t! constant table base&quot;, reg);
 1130   }
 1131 }
 1132 #endif
 1133 
 1134 
 1135 //=============================================================================
 1136 
 1137 #ifndef PRODUCT
 1138 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1139   Compile* C = ra_-&gt;C;
 1140 
 1141   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1142     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
 1143   }
 1144 
 1145   if( VerifyThread ) {
 1146     st-&gt;print_cr(&quot;Verify_Thread&quot;); st-&gt;print(&quot;\t&quot;);
 1147   }
 1148 
<span class="line-modified"> 1149   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified"> 1150   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1151 
 1152   // Calls to C2R adapters often do not accept exceptional returns.
 1153   // We require that their callers must bang for them.  But be careful, because
 1154   // some VM calls (such as call site linkage) can use several kilobytes of
 1155   // stack.  But the stack safety zone should account for that.
 1156   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1157   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
 1158     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
 1159   }
 1160 
 1161   if (Assembler::is_simm13(-framesize)) {
 1162     st-&gt;print   (&quot;SAVE   R_SP,-&quot; SIZE_FORMAT &quot;,R_SP&quot;,framesize);
 1163   } else {
 1164     st-&gt;print_cr(&quot;SETHI  R_SP,hi%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1165     st-&gt;print_cr(&quot;ADD    R_G3,lo%%(-&quot; SIZE_FORMAT &quot;),R_G3&quot;,framesize); st-&gt;print(&quot;\t&quot;);
 1166     st-&gt;print   (&quot;SAVE   R_SP,R_G3,R_SP&quot;);
 1167   }
 1168 
 1169 }
 1170 #endif
 1171 
 1172 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1173   Compile* C = ra_-&gt;C;
<span class="line-modified"> 1174   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1175 
 1176   for (int i = 0; i &lt; OptoPrologueNops; i++) {
 1177     __ nop();
 1178   }
 1179 
 1180   __ verify_thread();
 1181 
<span class="line-modified"> 1182   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1183   assert(framesize &gt;= 16*wordSize, &quot;must have room for reg. save area&quot;);
 1184   assert(framesize%(2*wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
<span class="line-modified"> 1185   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1186 
 1187   // Calls to C2R adapters often do not accept exceptional returns.
 1188   // We require that their callers must bang for them.  But be careful, because
 1189   // some VM calls (such as call site linkage) can use several kilobytes of
 1190   // stack.  But the stack safety zone should account for that.
 1191   // See bugs 4446381, 4468289, 4497237.
<span class="line-modified"> 1192   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
 1193     __ generate_stack_overflow_check(bangsize);
 1194   }
 1195 
 1196   if (Assembler::is_simm13(-framesize)) {
 1197     __ save(SP, -framesize, SP);
 1198   } else {
 1199     __ sethi(-framesize &amp; ~0x3ff, G3);
 1200     __ add(G3, -framesize &amp; 0x3ff, G3);
 1201     __ save(SP, G3, SP);
 1202   }
<span class="line-modified"> 1203   C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
 1204 
 1205   if (!UseRDPCForConstantTableBase &amp;&amp; C-&gt;has_mach_constant_base_node()) {
 1206     // NOTE: We set the table base offset here because users might be
 1207     // emitted before MachConstantBaseNode.
<span class="line-modified"> 1208     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
 1209     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
 1210   }
 1211 }
 1212 
 1213 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1214   return MachNode::size(ra_);
 1215 }
 1216 
 1217 int MachPrologNode::reloc() const {
 1218   return 10; // a large enough number
 1219 }
 1220 
 1221 //=============================================================================
 1222 #ifndef PRODUCT
 1223 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1224   Compile* C = ra_-&gt;C;
 1225 
 1226   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified"> 1227     st-&gt;print(&quot;LDX    [R_G2 + #poll_offset],L0\t! Load local polling address\n\t&quot;);</span>




 1228     st-&gt;print(&quot;LDX    [L0],G0\t!Poll for Safepointing\n\t&quot;);
 1229   }
 1230 
 1231   if(do_polling()) {
 1232     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1233       st-&gt;print(&quot;NOP\n\t&quot;);
 1234     }
 1235     st-&gt;print(&quot;RET\n\t&quot;);
 1236   }
 1237 
 1238   st-&gt;print(&quot;RESTORE&quot;);
 1239 }
 1240 #endif
 1241 
 1242 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1243   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1244   Compile* C = ra_-&gt;C;
 1245 
 1246   __ verify_thread();
 1247 
 1248   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1249     __ reserved_stack_check();
 1250   }
 1251 
 1252   // If this does safepoint polling, then do it here
 1253   if(do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
<span class="line-modified"> 1254     __ ld_ptr(Address(G2_thread, Thread::polling_page_offset()), L0);</span>





 1255     __ relocate(relocInfo::poll_return_type);
 1256     __ ld_ptr(L0, 0, G0);
 1257   }
 1258 
 1259   // If this is a return, then stuff the restore in the delay slot
 1260   if(do_polling()) {
 1261     if (UseCBCond &amp;&amp; !ra_-&gt;C-&gt;is_method_compilation()) {
 1262       // Insert extra padding for the case when the epilogue is preceded by
 1263       // a cbcond jump, which can&#39;t be followed by a CTI instruction
 1264       __ nop();
 1265     }
 1266     __ ret();
 1267     __ delayed()-&gt;restore();
 1268   } else {
 1269     __ restore();
 1270   }
 1271 }
 1272 
 1273 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1274   return MachNode::size(ra_);
 1275 }
 1276 
 1277 int MachEpilogNode::reloc() const {
 1278   return 16; // a large enough number
 1279 }
 1280 
 1281 const Pipeline * MachEpilogNode::pipeline() const {
 1282   return MachNode::pipeline_class();
 1283 }
 1284 






 1285 //=============================================================================
 1286 
 1287 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
 1288 enum RC { rc_bad, rc_int, rc_float, rc_stack };
 1289 static enum RC rc_class( OptoReg::Name reg ) {
 1290   if (!OptoReg::is_valid(reg)) return rc_bad;
 1291   if (OptoReg::is_stack(reg)) return rc_stack;
 1292   VMReg r = OptoReg::as_VMReg(reg);
 1293   if (r-&gt;is_Register()) return rc_int;
 1294   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
 1295   return rc_float;
 1296 }
 1297 
 1298 #ifndef PRODUCT
 1299 ATTRIBUTE_PRINTF(2, 3)
 1300 static void print_helper(outputStream* st, const char* format, ...) {
 1301   const int tab_size = 8;
 1302   if (st-&gt;position() &gt; tab_size) {
 1303     st-&gt;cr();
 1304     st-&gt;sp();
</pre>
<hr />
<pre>
 1520   implementation( NULL, ra_, false, st );
 1521 }
 1522 #endif
 1523 
 1524 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1525   implementation( &amp;cbuf, ra_, false, NULL );
 1526 }
 1527 
 1528 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1529   return MachNode::size(ra_);
 1530 }
 1531 
 1532 //=============================================================================
 1533 #ifndef PRODUCT
 1534 void MachNopNode::format(PhaseRegAlloc *, outputStream *st) const {
 1535   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
 1536 }
 1537 #endif
 1538 
 1539 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<span class="line-modified"> 1540   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1541   for (int i = 0; i &lt; _count; i += 1) {
 1542     __ nop();
 1543   }
 1544 }
 1545 
 1546 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1547   return 4 * _count;
 1548 }
 1549 
 1550 
 1551 //=============================================================================
 1552 #ifndef PRODUCT
 1553 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1554   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1555   int reg = ra_-&gt;get_reg_first(this);
 1556   st-&gt;print(&quot;LEA    [R_SP+#%d+BIAS],%s&quot;,offset,Matcher::regName[reg]);
 1557 }
 1558 #endif
 1559 
 1560 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1561   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1562   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem()) + STACK_BIAS;
 1563   int reg = ra_-&gt;get_encode(this);
 1564 
 1565   if (Assembler::is_simm13(offset)) {
 1566      __ add(SP, offset, reg_to_register_object(reg));
 1567   } else {
 1568      __ set(offset, O7);
 1569      __ add(SP, O7, reg_to_register_object(reg));
 1570   }
 1571 }
 1572 
 1573 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1574   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1575   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<span class="line-modified"> 1576   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
 1577 }
 1578 
 1579 //=============================================================================
 1580 #ifndef PRODUCT
 1581 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
 1582   st-&gt;print_cr(&quot;\nUEP:&quot;);
 1583   if (UseCompressedClassPointers) {
 1584     assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
 1585     st-&gt;print_cr(&quot;\tLDUW   [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check - compressed klass&quot;);
 1586     if (CompressedKlassPointers::base() != 0) {
 1587       st-&gt;print_cr(&quot;\tSET    CompressedKlassPointers::base,R_G6_heap_base&quot;);
 1588       if (CompressedKlassPointers::shift() != 0) {
 1589         st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1590       }
 1591       st-&gt;print_cr(&quot;\tADD    R_G5,R_G6_heap_base,R_G5&quot;);
 1592       st-&gt;print_cr(&quot;\tSET    CompressedOops::ptrs_base,R_G6_heap_base&quot;);
 1593     } else {
 1594       st-&gt;print_cr(&quot;\tSLL    R_G5,CompressedKlassPointers::shift,R_G5&quot;);
 1595     }
 1596   } else {
 1597     st-&gt;print_cr(&quot;\tLDX    [R_O0 + oopDesc::klass_offset_in_bytes],R_G5\t! Inline cache check&quot;);
 1598   }
 1599   st-&gt;print_cr(&quot;\tCMP    R_G5,R_G3&quot; );
 1600   st-&gt;print   (&quot;\tTne    xcc,R_G0+ST_RESERVED_FOR_USER_0+2&quot;);
 1601 }
 1602 #endif
 1603 
 1604 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1605   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1606   Register G5_ic_reg  = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1607   Register temp_reg   = G3;
 1608   assert( G5_ic_reg != temp_reg, &quot;conflicting registers&quot; );
 1609 
 1610   // Load klass from receiver
 1611   __ load_klass(O0, temp_reg);
 1612   // Compare against expected klass
 1613   __ cmp(temp_reg, G5_ic_reg);
 1614   // Branch to miss code, checks xcc or icc depending
 1615   __ trap(Assembler::notEqual, Assembler::ptr_cc, G0, ST_RESERVED_FOR_USER_0+2);
 1616 }
 1617 
 1618 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 1619   return MachNode::size(ra_);
 1620 }
 1621 
 1622 
 1623 //=============================================================================
 1624 
 1625 
 1626 // Emit exception handler code.
 1627 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
 1628   Register temp_reg = G3;
 1629   AddressLiteral exception_blob(OptoRuntime::exception_blob()-&gt;entry_point());
<span class="line-modified"> 1630   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1631 
 1632   address base = __ start_a_stub(size_exception_handler());
 1633   if (base == NULL) {
 1634     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1635     return 0;  // CodeBuffer::expand failed
 1636   }
 1637 
 1638   int offset = __ offset();
 1639 
 1640   __ JUMP(exception_blob, temp_reg, 0); // sethi;jmp
 1641   __ delayed()-&gt;nop();
 1642 
 1643   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1644 
 1645   __ end_a_stub();
 1646 
 1647   return offset;
 1648 }
 1649 
 1650 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
 1651   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
 1652   // at a poll and everything (including G3) can be live.
 1653   Register temp_reg = L0;
 1654   AddressLiteral deopt_blob(SharedRuntime::deopt_blob()-&gt;unpack());
<span class="line-modified"> 1655   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1656 
 1657   address base = __ start_a_stub(size_deopt_handler());
 1658   if (base == NULL) {
 1659     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1660     return 0;  // CodeBuffer::expand failed
 1661   }
 1662 
 1663   int offset = __ offset();
 1664   __ save_frame(0);
 1665   __ JUMP(deopt_blob, temp_reg, 0); // sethi;jmp
 1666   __ delayed()-&gt;restore();
 1667 
 1668   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
 1669 
 1670   __ end_a_stub();
 1671   return offset;
 1672 
 1673 }
 1674 
 1675 // Given a register encoding, produce a Integer Register object
</pre>
<hr />
<pre>
 1945 
 1946 // Register for DIVL projection of divmodL
 1947 RegMask Matcher::divL_proj_mask() {
 1948   ShouldNotReachHere();
 1949   return RegMask();
 1950 }
 1951 
 1952 // Register for MODL projection of divmodL
 1953 RegMask Matcher::modL_proj_mask() {
 1954   ShouldNotReachHere();
 1955   return RegMask();
 1956 }
 1957 
 1958 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1959   return L7_REGP_mask();
 1960 }
 1961 
 1962 
 1963 const bool Matcher::convi2l_type_required = true;
 1964 
<span class="line-added"> 1965 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added"> 1966 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added"> 1967   return false;</span>
<span class="line-added"> 1968 }</span>
<span class="line-added"> 1969 </span>
 1970 // Should the Matcher clone shifts on addressing modes, expecting them
 1971 // to be subsumed into complex addressing expressions or compute them
 1972 // into registers?
<span class="line-modified"> 1973 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1974   return clone_base_plus_offset_address(m, mstack, address_visited);
 1975 }
 1976 
 1977 void Compile::reshape_address(AddPNode* addp) {
 1978 }
 1979 
 1980 %}
 1981 
 1982 
 1983 // The intptr_t operand types, defined by textual substitution.
 1984 // (Cf. opto/type.hpp.  This lets us avoid many, many other ifdefs.)
 1985 #define immX      immL
 1986 #define immX13    immL13
 1987 #define immX13m7  immL13m7
 1988 #define iRegX     iRegL
 1989 #define g1RegX    g1RegL
 1990 
 1991 //----------ENCODING BLOCK-----------------------------------------------------
 1992 // This block specifies the encoding classes used by the compiler to output
 1993 // byte streams.  Encoding classes are parameterized macros used by
</pre>
<hr />
<pre>
 1998 // operand to generate a function which returns its register number when
 1999 // queried.   CONST_INTER causes an operand to generate a function which
 2000 // returns the value of the constant when queried.  MEMORY_INTER causes an
 2001 // operand to generate four functions which return the Base Register, the
 2002 // Index Register, the Scale Value, and the Offset Value of the operand when
 2003 // queried.  COND_INTER causes an operand to generate six functions which
 2004 // return the encoding code (ie - encoding bits for the instruction)
 2005 // associated with each basic boolean condition for a conditional instruction.
 2006 //
 2007 // Instructions specify two basic values for encoding.  Again, a function
 2008 // is available to check if the constant displacement is an oop. They use the
 2009 // ins_encode keyword to specify their encoding classes (which must be
 2010 // a sequence of enc_class names, and their parameters, specified in
 2011 // the encoding block), and they use the
 2012 // opcode keyword to specify, in order, their primary, secondary, and
 2013 // tertiary opcode.  Only the opcode sections which a particular instruction
 2014 // needs for encoding need to be specified.
 2015 encode %{
 2016   enc_class enc_untested %{
 2017 #ifdef ASSERT
<span class="line-modified"> 2018     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2019     __ untested(&quot;encoding&quot;);
 2020 #endif
 2021   %}
 2022 
 2023   enc_class form3_mem_reg( memory mem, iRegI dst ) %{
 2024     emit_form3_mem_reg(cbuf, ra_, this, $primary, $tertiary,
 2025                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2026   %}
 2027 
 2028   enc_class simple_form3_mem_reg( memory mem, iRegI dst ) %{
 2029     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2030                        $mem$$base, $mem$$disp, $mem$$index, $dst$$reg);
 2031   %}
 2032 
 2033   enc_class form3_mem_prefetch_read( memory mem ) %{
 2034     emit_form3_mem_reg(cbuf, ra_, this, $primary, -1,
 2035                        $mem$$base, $mem$$disp, $mem$$index, 0/*prefetch function many-reads*/);
 2036   %}
 2037 
 2038   enc_class form3_mem_prefetch_write( memory mem ) %{
</pre>
<hr />
<pre>
 2133   %}
 2134 
 2135   enc_class form3_sd_rs1_imm6_rd( iRegL rs1, immU6 imm6, iRegL rd ) %{
 2136     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, ($imm6$$constant &amp; 0x3F) | 0x1000 );
 2137   %}
 2138 
 2139   enc_class form3_sd_rs1_rs2_rd( iRegL rs1, iRegI rs2, iRegL rd ) %{
 2140     emit3( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, 0x80, $rs2$$reg );
 2141   %}
 2142 
 2143   enc_class form3_rs1_simm13_rd( iRegI rs1, immI13 simm13, iRegI rd ) %{
 2144     emit3_simm13( cbuf, $secondary, $rd$$reg, $primary, $rs1$$reg, $simm13$$constant );
 2145   %}
 2146 
 2147   enc_class move_return_pc_to_o1() %{
 2148     emit3_simm13( cbuf, Assembler::arith_op, R_O1_enc, Assembler::add_op3, R_O7_enc, frame::pc_return_offset );
 2149   %}
 2150 
 2151   /* %%% merge with enc_to_bool */
 2152   enc_class enc_convP2B( iRegI dst, iRegP src ) %{
<span class="line-modified"> 2153     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2154 
 2155     Register   src_reg = reg_to_register_object($src$$reg);
 2156     Register   dst_reg = reg_to_register_object($dst$$reg);
 2157     __ movr(Assembler::rc_nz, src_reg, 1, dst_reg);
 2158   %}
 2159 
 2160   enc_class enc_cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, iRegI tmp ) %{
 2161     // (Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)))
<span class="line-modified"> 2162     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2163 
 2164     Register   p_reg = reg_to_register_object($p$$reg);
 2165     Register   q_reg = reg_to_register_object($q$$reg);
 2166     Register   y_reg = reg_to_register_object($y$$reg);
 2167     Register tmp_reg = reg_to_register_object($tmp$$reg);
 2168 
 2169     __ subcc( p_reg, q_reg,   p_reg );
 2170     __ add  ( p_reg, y_reg, tmp_reg );
 2171     __ movcc( Assembler::less, false, Assembler::icc, tmp_reg, p_reg );
 2172   %}
 2173 
 2174   enc_class form_d2i_helper(regD src, regF dst) %{
 2175     // fcmp %fcc0,$src,$src
 2176     emit3( cbuf, Assembler::arith_op , Assembler::fcc0, Assembler::fpop2_op3, $src$$reg, Assembler::fcmpd_opf, $src$$reg );
 2177     // branch %fcc0 not-nan, predict taken
 2178     emit2_19( cbuf, Assembler::branch_op, 0/*annul*/, Assembler::f_ordered, Assembler::fbp_op2, Assembler::fcc0, 1/*predict taken*/, 4 );
 2179     // fdtoi $src,$dst
 2180     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fdtoi_opf, $src$$reg );
 2181     // fitos $dst,$dst (if nan)
 2182     emit3( cbuf, Assembler::arith_op , $dst$$reg, Assembler::fpop1_op3,         0, Assembler::fitos_opf, $dst$$reg );
</pre>
<hr />
<pre>
 2275   %}
 2276 
 2277 
 2278   // Compare longs and convert into -1, 0, 1.
 2279   enc_class cmpl_flag( iRegL src1, iRegL src2, iRegI dst ) %{
 2280     // CMP $src1,$src2
 2281     emit3( cbuf, Assembler::arith_op, 0, Assembler::subcc_op3, $src1$$reg, 0, $src2$$reg );
 2282     // blt,a,pn done
 2283     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::less   , Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 5 );
 2284     // mov dst,-1 in delay slot
 2285     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0, -1 );
 2286     // bgt,a,pn done
 2287     emit2_19( cbuf, Assembler::branch_op, 1/*annul*/, Assembler::greater, Assembler::bp_op2, Assembler::xcc, 0/*predict not taken*/, 3 );
 2288     // mov dst,1 in delay slot
 2289     emit3_simm13( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3, 0,  1 );
 2290     // CLR    $dst
 2291     emit3( cbuf, Assembler::arith_op, $dst$$reg, Assembler::or_op3 , 0, 0, 0 );
 2292   %}
 2293 
 2294   enc_class enc_PartialSubtypeCheck() %{
<span class="line-modified"> 2295     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2296     __ call(StubRoutines::Sparc::partial_subtype_check(), relocInfo::runtime_call_type);
 2297     __ delayed()-&gt;nop();
 2298   %}
 2299 
 2300   enc_class enc_bp( label labl, cmpOp cmp, flagsReg cc ) %{
<span class="line-modified"> 2301     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2302     Label* L = $labl$$label;
 2303     Assembler::Predict predict_taken =
 2304       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2305 
 2306     __ bp( (Assembler::Condition)($cmp$$cmpcode), false, Assembler::icc, predict_taken, *L);
 2307     __ delayed()-&gt;nop();
 2308   %}
 2309 
 2310   enc_class enc_bpr( label labl, cmpOp_reg cmp, iRegI op1 ) %{
<span class="line-modified"> 2311     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2312     Label* L = $labl$$label;
 2313     Assembler::Predict predict_taken =
 2314       cbuf.is_backward_branch(*L) ? Assembler::pt : Assembler::pn;
 2315 
 2316     __ bpr( (Assembler::RCondition)($cmp$$cmpcode), false, predict_taken, as_Register($op1$$reg), *L);
 2317     __ delayed()-&gt;nop();
 2318   %}
 2319 
 2320   enc_class enc_cmov_reg( cmpOp cmp, iRegI dst, iRegI src, immI pcc) %{
 2321     int op = (Assembler::arith_op &lt;&lt; 30) |
 2322              ($dst$$reg &lt;&lt; 25) |
 2323              (Assembler::movcc_op3 &lt;&lt; 19) |
 2324              (1 &lt;&lt; 18) |                    // cc2 bit for &#39;icc&#39;
 2325              ($cmp$$cmpcode &lt;&lt; 14) |
 2326              (0 &lt;&lt; 13) |                    // select register move
 2327              ($pcc$$constant &lt;&lt; 11) |       // cc1, cc0 bits for &#39;icc&#39; or &#39;xcc&#39;
 2328              ($src$$reg &lt;&lt; 0);
 2329     cbuf.insts()-&gt;emit_int32(op);
 2330   %}
 2331 
</pre>
<hr />
<pre>
 2410     int op = (Assembler::arith_op &lt;&lt; 30) |
 2411              ($dst$$reg &lt;&lt; 25) |
 2412              (Assembler::movcc_op3 &lt;&lt; 19) |
 2413              (6 &lt;&lt; 16) |                    // cc2 bit for &#39;xcc&#39;
 2414              ($primary &lt;&lt; 14) |
 2415              (0 &lt;&lt; 13) |                    // select register move
 2416              (0 &lt;&lt; 11) |                    // cc1, cc0 bits for &#39;icc&#39;
 2417              ($src$$reg &lt;&lt; 0);
 2418     cbuf.insts()-&gt;emit_int32(op);
 2419   %}
 2420 
 2421   enc_class Set13( immI13 src, iRegI rd ) %{
 2422     emit3_simm13( cbuf, Assembler::arith_op, $rd$$reg, Assembler::or_op3, 0, $src$$constant );
 2423   %}
 2424 
 2425   enc_class SetHi22( immI src, iRegI rd ) %{
 2426     emit2_22( cbuf, Assembler::branch_op, $rd$$reg, Assembler::sethi_op2, $src$$constant );
 2427   %}
 2428 
 2429   enc_class Set32( immI src, iRegI rd ) %{
<span class="line-modified"> 2430     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2431     __ set($src$$constant, reg_to_register_object($rd$$reg));
 2432   %}
 2433 
 2434   enc_class call_epilog %{
 2435     if( VerifyStackAtCalls ) {
<span class="line-modified"> 2436       C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 2437       int framesize = ra_-&gt;C-&gt;output()-&gt;frame_size_in_bytes();</span>
 2438       Register temp_reg = G3;
 2439       __ add(SP, framesize, temp_reg);
 2440       __ cmp(temp_reg, FP);
 2441       __ breakpoint_trap(Assembler::notEqual, Assembler::ptr_cc);
 2442     }
 2443   %}
 2444 
 2445   // Long values come back from native calls in O0:O1 in the 32-bit VM, copy the value
 2446   // to G1 so the register allocator will not have to deal with the misaligned register
 2447   // pair.
 2448   enc_class adjust_long_from_native_call %{
 2449   %}
 2450 
 2451   enc_class Java_To_Runtime (method meth) %{    // CALL Java_To_Runtime
 2452     // CALL directly to the runtime
 2453     // The user of this is responsible for ensuring that R_L7 is empty (killed).
 2454     emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec(), /*preserve_g2=*/true);
 2455   %}
 2456 
 2457   enc_class preserve_SP %{
<span class="line-modified"> 2458     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2459     __ mov(SP, L7_mh_SP_save);
 2460   %}
 2461 
 2462   enc_class restore_SP %{
<span class="line-modified"> 2463     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2464     __ mov(L7_mh_SP_save, SP);
 2465   %}
 2466 
 2467   enc_class Java_Static_Call (method meth) %{    // JAVA STATIC CALL
 2468     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 2469     // who we intended to call.
 2470     if (!_method) {
 2471       emit_call_reloc(cbuf, $meth$$method, runtime_call_Relocation::spec());
 2472     } else {
 2473       int method_index = resolved_method_index(cbuf);
 2474       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 2475                                                   : static_call_Relocation::spec(method_index);
 2476       emit_call_reloc(cbuf, $meth$$method, rspec);
 2477 
 2478       // Emit stub for static call.
 2479       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2480       if (stub == NULL) {
 2481         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2482         return;
 2483       }
 2484     }
 2485   %}
 2486 
 2487   enc_class Java_Dynamic_Call (method meth) %{    // JAVA DYNAMIC CALL
<span class="line-modified"> 2488     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2489     __ set_inst_mark();
 2490     int vtable_index = this-&gt;_vtable_index;
 2491     // MachCallDynamicJavaNode::ret_addr_offset uses this same test
 2492     if (vtable_index &lt; 0) {
 2493       // must be invalid_vtable_index, not nonvirtual_vtable_index
 2494       assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 2495       Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2496       assert(G5_ic_reg == G5_inline_cache_reg, &quot;G5_inline_cache_reg used in assemble_ic_buffer_code()&quot;);
 2497       assert(G5_ic_reg == G5_megamorphic_method, &quot;G5_megamorphic_method used in megamorphic call stub&quot;);
 2498       __ ic_call((address)$meth$$method, /*emit_delay=*/true, resolved_method_index(cbuf));
 2499     } else {
 2500       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 2501       // Just go thru the vtable
 2502       // get receiver klass (receiver already checked for non-null)
 2503       // If we end up going thru a c2i adapter interpreter expects method in G5
 2504       int off = __ offset();
 2505       __ load_klass(O0, G3_scratch);
 2506       int klass_load_size;
 2507       if (UseCompressedClassPointers) {
 2508         assert(Universe::heap() != NULL, &quot;java heap should be initialized&quot;);
</pre>
<hr />
<pre>
 2517       } else {
 2518         // Generate 2 instructions
 2519         __ Assembler::sethi(v_off &amp; ~0x3ff, G5_method);
 2520         __ or3(G5_method, v_off &amp; 0x3ff, G5_method);
 2521         // ld_ptr, set_hi, set
 2522         assert(__ offset() - off == klass_load_size + 2*BytesPerInstWord,
 2523                &quot;Unexpected instruction size(s)&quot;);
 2524         __ ld_ptr(G3, G5_method, G5_method);
 2525       }
 2526       // NOTE: for vtable dispatches, the vtable entry will never be null.
 2527       // However it may very well end up in handle_wrong_method if the
 2528       // method is abstract for the particular class.
 2529       __ ld_ptr(G5_method, in_bytes(Method::from_compiled_offset()), G3_scratch);
 2530       // jump to target (either compiled code or c2iadapter)
 2531       __ jmpl(G3_scratch, G0, O7);
 2532       __ delayed()-&gt;nop();
 2533     }
 2534   %}
 2535 
 2536   enc_class Java_Compiled_Call (method meth) %{    // JAVA COMPILED CALL
<span class="line-modified"> 2537     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2538 
 2539     Register G5_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2540     Register temp_reg = G3;   // caller must kill G3!  We cannot reuse G5_ic_reg here because
 2541                               // we might be calling a C2I adapter which needs it.
 2542 
 2543     assert(temp_reg != G5_ic_reg, &quot;conflicting registers&quot;);
 2544     // Load nmethod
 2545     __ ld_ptr(G5_ic_reg, in_bytes(Method::from_compiled_offset()), temp_reg);
 2546 
 2547     // CALL to compiled java, indirect the contents of G3
 2548     __ set_inst_mark();
 2549     __ callr(temp_reg, G0);
 2550     __ delayed()-&gt;nop();
 2551   %}
 2552 
 2553 enc_class idiv_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst) %{
<span class="line-modified"> 2554     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2555     Register Rdividend = reg_to_register_object($src1$$reg);
 2556     Register Rdivisor = reg_to_register_object($src2$$reg);
 2557     Register Rresult = reg_to_register_object($dst$$reg);
 2558 
 2559     __ sra(Rdivisor, 0, Rdivisor);
 2560     __ sra(Rdividend, 0, Rdividend);
 2561     __ sdivx(Rdividend, Rdivisor, Rresult);
 2562 %}
 2563 
 2564 enc_class idiv_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst) %{
<span class="line-modified"> 2565     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2566 
 2567     Register Rdividend = reg_to_register_object($src1$$reg);
 2568     int divisor = $imm$$constant;
 2569     Register Rresult = reg_to_register_object($dst$$reg);
 2570 
 2571     __ sra(Rdividend, 0, Rdividend);
 2572     __ sdivx(Rdividend, divisor, Rresult);
 2573 %}
 2574 
 2575 enc_class enc_mul_hi(iRegIsafe dst, iRegIsafe src1, iRegIsafe src2) %{
<span class="line-modified"> 2576     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2577     Register Rsrc1 = reg_to_register_object($src1$$reg);
 2578     Register Rsrc2 = reg_to_register_object($src2$$reg);
 2579     Register Rdst  = reg_to_register_object($dst$$reg);
 2580 
 2581     __ sra( Rsrc1, 0, Rsrc1 );
 2582     __ sra( Rsrc2, 0, Rsrc2 );
 2583     __ mulx( Rsrc1, Rsrc2, Rdst );
 2584     __ srlx( Rdst, 32, Rdst );
 2585 %}
 2586 
 2587 enc_class irem_reg(iRegIsafe src1, iRegIsafe src2, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2588     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2589     Register Rdividend = reg_to_register_object($src1$$reg);
 2590     Register Rdivisor = reg_to_register_object($src2$$reg);
 2591     Register Rresult = reg_to_register_object($dst$$reg);
 2592     Register Rscratch = reg_to_register_object($scratch$$reg);
 2593 
 2594     assert(Rdividend != Rscratch, &quot;&quot;);
 2595     assert(Rdivisor  != Rscratch, &quot;&quot;);
 2596 
 2597     __ sra(Rdividend, 0, Rdividend);
 2598     __ sra(Rdivisor, 0, Rdivisor);
 2599     __ sdivx(Rdividend, Rdivisor, Rscratch);
 2600     __ mulx(Rscratch, Rdivisor, Rscratch);
 2601     __ sub(Rdividend, Rscratch, Rresult);
 2602 %}
 2603 
 2604 enc_class irem_imm(iRegIsafe src1, immI13 imm, iRegIsafe dst, o7RegL scratch) %{
<span class="line-modified"> 2605     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2606 
 2607     Register Rdividend = reg_to_register_object($src1$$reg);
 2608     int divisor = $imm$$constant;
 2609     Register Rresult = reg_to_register_object($dst$$reg);
 2610     Register Rscratch = reg_to_register_object($scratch$$reg);
 2611 
 2612     assert(Rdividend != Rscratch, &quot;&quot;);
 2613 
 2614     __ sra(Rdividend, 0, Rdividend);
 2615     __ sdivx(Rdividend, divisor, Rscratch);
 2616     __ mulx(Rscratch, divisor, Rscratch);
 2617     __ sub(Rdividend, Rscratch, Rresult);
 2618 %}
 2619 
 2620 enc_class fabss (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2621     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2622 
 2623     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2624     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2625 
 2626     __ fabs(FloatRegisterImpl::S, Fsrc, Fdst);
 2627 %}
 2628 
 2629 enc_class fabsd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2630     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2631 
 2632     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2633     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2634 
 2635     __ fabs(FloatRegisterImpl::D, Fsrc, Fdst);
 2636 %}
 2637 
 2638 enc_class fnegd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2639     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2640 
 2641     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2642     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2643 
 2644     __ fneg(FloatRegisterImpl::D, Fsrc, Fdst);
 2645 %}
 2646 
 2647 enc_class fsqrts (sflt_reg dst, sflt_reg src) %{
<span class="line-modified"> 2648     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2649 
 2650     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2651     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2652 
 2653     __ fsqrt(FloatRegisterImpl::S, Fsrc, Fdst);
 2654 %}
 2655 
 2656 enc_class fsqrtd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2657     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2658 
 2659     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2660     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2661 
 2662     __ fsqrt(FloatRegisterImpl::D, Fsrc, Fdst);
 2663 %}
 2664 
 2665 
 2666 enc_class fmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2667     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2668 
 2669     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2670     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2671     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2672     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2673 
 2674     __ fmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2675 %}
 2676 
 2677 enc_class fmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2678     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2679 
 2680     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2681     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2682     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2683     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2684 
 2685     __ fmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2686 %}
 2687 
 2688 enc_class fmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2689     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2690 
 2691     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2692     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2693     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2694     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2695 
 2696     __ fmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2697 %}
 2698 
 2699 enc_class fmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2700     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2701 
 2702     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2703     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2704     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2705     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2706 
 2707     __ fmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2708 %}
 2709 
 2710 enc_class fnmadds (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2711     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2712 
 2713     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2714     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2715     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2716     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2717 
 2718     __ fnmadd(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2719 %}
 2720 
 2721 enc_class fnmaddd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2722     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2723 
 2724     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2725     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2726     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2727     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2728 
 2729     __ fnmadd(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2730 %}
 2731 
 2732 enc_class fnmsubs (sflt_reg dst, sflt_reg a, sflt_reg b, sflt_reg c) %{
<span class="line-modified"> 2733     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2734 
 2735     FloatRegister Frd = reg_to_SingleFloatRegister_object($dst$$reg);
 2736     FloatRegister Fra = reg_to_SingleFloatRegister_object($a$$reg);
 2737     FloatRegister Frb = reg_to_SingleFloatRegister_object($b$$reg);
 2738     FloatRegister Frc = reg_to_SingleFloatRegister_object($c$$reg);
 2739 
 2740     __ fnmsub(FloatRegisterImpl::S, Fra, Frb, Frc, Frd);
 2741 %}
 2742 
 2743 enc_class fnmsubd (dflt_reg dst, dflt_reg a, dflt_reg b, dflt_reg c) %{
<span class="line-modified"> 2744     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2745 
 2746     FloatRegister Frd = reg_to_DoubleFloatRegister_object($dst$$reg);
 2747     FloatRegister Fra = reg_to_DoubleFloatRegister_object($a$$reg);
 2748     FloatRegister Frb = reg_to_DoubleFloatRegister_object($b$$reg);
 2749     FloatRegister Frc = reg_to_DoubleFloatRegister_object($c$$reg);
 2750 
 2751     __ fnmsub(FloatRegisterImpl::D, Fra, Frb, Frc, Frd);
 2752 %}
 2753 
 2754 
 2755 enc_class fmovs (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2756     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2757 
 2758     FloatRegister Fdst = reg_to_SingleFloatRegister_object($dst$$reg);
 2759     FloatRegister Fsrc = reg_to_SingleFloatRegister_object($src$$reg);
 2760 
 2761     __ fmov(FloatRegisterImpl::S, Fsrc, Fdst);
 2762 %}
 2763 
 2764 enc_class fmovd (dflt_reg dst, dflt_reg src) %{
<span class="line-modified"> 2765     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2766 
 2767     FloatRegister Fdst = reg_to_DoubleFloatRegister_object($dst$$reg);
 2768     FloatRegister Fsrc = reg_to_DoubleFloatRegister_object($src$$reg);
 2769 
 2770     __ fmov(FloatRegisterImpl::D, Fsrc, Fdst);
 2771 %}
 2772 
 2773 enc_class Fast_Lock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2774     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2775 
 2776     Register Roop  = reg_to_register_object($oop$$reg);
 2777     Register Rbox  = reg_to_register_object($box$$reg);
 2778     Register Rscratch = reg_to_register_object($scratch$$reg);
 2779     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2780 
 2781     assert(Roop  != Rscratch, &quot;&quot;);
 2782     assert(Roop  != Rmark, &quot;&quot;);
 2783     assert(Rbox  != Rscratch, &quot;&quot;);
 2784     assert(Rbox  != Rmark, &quot;&quot;);
 2785 
 2786     __ compiler_lock_object(Roop, Rmark, Rbox, Rscratch, _counters, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2787 %}
 2788 
 2789 enc_class Fast_Unlock(iRegP oop, iRegP box, o7RegP scratch, iRegP scratch2) %{
<span class="line-modified"> 2790     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2791 
 2792     Register Roop  = reg_to_register_object($oop$$reg);
 2793     Register Rbox  = reg_to_register_object($box$$reg);
 2794     Register Rscratch = reg_to_register_object($scratch$$reg);
 2795     Register Rmark =    reg_to_register_object($scratch2$$reg);
 2796 
 2797     assert(Roop  != Rscratch, &quot;&quot;);
 2798     assert(Roop  != Rmark, &quot;&quot;);
 2799     assert(Rbox  != Rscratch, &quot;&quot;);
 2800     assert(Rbox  != Rmark, &quot;&quot;);
 2801 
 2802     __ compiler_unlock_object(Roop, Rmark, Rbox, Rscratch, UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 2803   %}
 2804 
 2805   enc_class enc_cas( iRegP mem, iRegP old, iRegP new ) %{
<span class="line-modified"> 2806     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2807     Register Rmem = reg_to_register_object($mem$$reg);
 2808     Register Rold = reg_to_register_object($old$$reg);
 2809     Register Rnew = reg_to_register_object($new$$reg);
 2810 
 2811     __ cas_ptr(Rmem, Rold, Rnew); // Swap(*Rmem,Rnew) if *Rmem == Rold
 2812     __ cmp( Rold, Rnew );
 2813   %}
 2814 
 2815   enc_class enc_casx( iRegP mem, iRegL old, iRegL new) %{
 2816     Register Rmem = reg_to_register_object($mem$$reg);
 2817     Register Rold = reg_to_register_object($old$$reg);
 2818     Register Rnew = reg_to_register_object($new$$reg);
 2819 
<span class="line-modified"> 2820     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2821     __ mov(Rnew, O7);
 2822     __ casx(Rmem, Rold, O7);
 2823     __ cmp( Rold, O7 );
 2824   %}
 2825 
 2826   // raw int cas, used for compareAndSwap
 2827   enc_class enc_casi( iRegP mem, iRegL old, iRegL new) %{
 2828     Register Rmem = reg_to_register_object($mem$$reg);
 2829     Register Rold = reg_to_register_object($old$$reg);
 2830     Register Rnew = reg_to_register_object($new$$reg);
 2831 
<span class="line-modified"> 2832     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2833     __ mov(Rnew, O7);
 2834     __ cas(Rmem, Rold, O7);
 2835     __ cmp( Rold, O7 );
 2836   %}
 2837 
 2838   // raw int cas without using tmp register for compareAndExchange
 2839   enc_class enc_casi_exch( iRegP mem, iRegL old, iRegL new) %{
 2840     Register Rmem = reg_to_register_object($mem$$reg);
 2841     Register Rold = reg_to_register_object($old$$reg);
 2842     Register Rnew = reg_to_register_object($new$$reg);
 2843 
<span class="line-modified"> 2844     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2845     __ cas(Rmem, Rold, Rnew);
 2846   %}
 2847 
 2848   // 64-bit cas without using tmp register for compareAndExchange
 2849   enc_class enc_casx_exch( iRegP mem, iRegL old, iRegL new) %{
 2850     Register Rmem = reg_to_register_object($mem$$reg);
 2851     Register Rold = reg_to_register_object($old$$reg);
 2852     Register Rnew = reg_to_register_object($new$$reg);
 2853 
<span class="line-modified"> 2854     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2855     __ casx(Rmem, Rold, Rnew);
 2856   %}
 2857 
 2858   enc_class enc_lflags_ne_to_boolean( iRegI res ) %{
 2859     Register Rres = reg_to_register_object($res$$reg);
 2860 
<span class="line-modified"> 2861     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2862     __ mov(1, Rres);
 2863     __ movcc( Assembler::notEqual, false, Assembler::xcc, G0, Rres );
 2864   %}
 2865 
 2866   enc_class enc_iflags_ne_to_boolean( iRegI res ) %{
 2867     Register Rres = reg_to_register_object($res$$reg);
 2868 
<span class="line-modified"> 2869     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2870     __ mov(1, Rres);
 2871     __ movcc( Assembler::notEqual, false, Assembler::icc, G0, Rres );
 2872   %}
 2873 
 2874   enc_class floating_cmp ( iRegP dst, regF src1, regF src2 ) %{
<span class="line-modified"> 2875     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2876     Register Rdst = reg_to_register_object($dst$$reg);
 2877     FloatRegister Fsrc1 = $primary ? reg_to_SingleFloatRegister_object($src1$$reg)
 2878                                      : reg_to_DoubleFloatRegister_object($src1$$reg);
 2879     FloatRegister Fsrc2 = $primary ? reg_to_SingleFloatRegister_object($src2$$reg)
 2880                                      : reg_to_DoubleFloatRegister_object($src2$$reg);
 2881 
 2882     // Convert condition code fcc0 into -1,0,1; unordered reports less-than (-1)
 2883     __ float_cmp( $primary, -1, Fsrc1, Fsrc2, Rdst);
 2884   %}
 2885 
 2886   enc_class enc_rethrow() %{
 2887     cbuf.set_insts_mark();
 2888     Register temp_reg = G3;
 2889     AddressLiteral rethrow_stub(OptoRuntime::rethrow_stub());
 2890     assert(temp_reg != reg_to_register_object(R_I0_num), &quot;temp must not break oop_reg&quot;);
<span class="line-modified"> 2891     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2892 #ifdef ASSERT
 2893     __ save_frame(0);
 2894     AddressLiteral last_rethrow_addrlit(&amp;last_rethrow);
 2895     __ sethi(last_rethrow_addrlit, L1);
 2896     Address addr(L1, last_rethrow_addrlit.low10());
 2897     __ rdpc(L2);
 2898     __ inc(L2, 3 * BytesPerInstWord);  // skip this &amp; 2 more insns to point at jump_to
 2899     __ st_ptr(L2, addr);
 2900     __ restore();
 2901 #endif
 2902     __ JUMP(rethrow_stub, temp_reg, 0); // sethi;jmp
 2903     __ delayed()-&gt;nop();
 2904   %}
 2905 
 2906   enc_class emit_mem_nop() %{
 2907     // Generates the instruction LDUXA [o6,g0],#0x82,g0
 2908     cbuf.insts()-&gt;emit_int32((unsigned int) 0xc0839040);
 2909   %}
 2910 
 2911   enc_class emit_fadd_nop() %{
 2912     // Generates the instruction FMOVS f31,f31
 2913     cbuf.insts()-&gt;emit_int32((unsigned int) 0xbfa0003f);
 2914   %}
 2915 
 2916   enc_class emit_br_nop() %{
 2917     // Generates the instruction BPN,PN .
 2918     cbuf.insts()-&gt;emit_int32((unsigned int) 0x00400000);
 2919   %}
 2920 
 2921   enc_class enc_membar_acquire %{
<span class="line-modified"> 2922     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2923     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::LoadLoad) );
 2924   %}
 2925 
 2926   enc_class enc_membar_release %{
<span class="line-modified"> 2927     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2928     __ membar( Assembler::Membar_mask_bits(Assembler::LoadStore | Assembler::StoreStore) );
 2929   %}
 2930 
 2931   enc_class enc_membar_volatile %{
<span class="line-modified"> 2932     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2933     __ membar( Assembler::Membar_mask_bits(Assembler::StoreLoad) );
 2934   %}
 2935 
 2936 %}
 2937 
 2938 //----------FRAME--------------------------------------------------------------
 2939 // Definition of frame structure and management information.
 2940 //
 2941 //  S T A C K   L A Y O U T    Allocators stack-slot number
 2942 //                             |   (to get allocators register number
 2943 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 2944 //  r   CALLER     |        |
 2945 //  o     |        +--------+      pad to even-align allocators stack-slot
 2946 //  w     V        |  pad0  |        numbers; owned by CALLER
 2947 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 2948 //  h     ^        |   in   |  5
 2949 //        |        |  args  |  4   Holes in incoming args owned by SELF
 2950 //  |     |        |        |  3
 2951 //  |     |        +--------+
 2952 //  V     |        | old out|      Empty on Intel, window on Sparc
</pre>
<hr />
<pre>
 3366 %}
 3367 
 3368 operand immP13() %{
 3369   predicate((-4096 &lt; n-&gt;get_ptr()) &amp;&amp; (n-&gt;get_ptr() &lt;= 4095));
 3370   match(ConP);
 3371   op_cost(0);
 3372 
 3373   format %{ %}
 3374   interface(CONST_INTER);
 3375 %}
 3376 
 3377 operand immP0() %{
 3378   predicate(n-&gt;get_ptr() == 0);
 3379   match(ConP);
 3380   op_cost(0);
 3381 
 3382   format %{ %}
 3383   interface(CONST_INTER);
 3384 %}
 3385 









 3386 // Pointer Immediate
 3387 operand immN()
 3388 %{
 3389   match(ConN);
 3390 
 3391   op_cost(10);
 3392   format %{ %}
 3393   interface(CONST_INTER);
 3394 %}
 3395 
 3396 operand immNKlass()
 3397 %{
 3398   match(ConNKlass);
 3399 
 3400   op_cost(10);
 3401   format %{ %}
 3402   interface(CONST_INTER);
 3403 %}
 3404 
 3405 // NULL Pointer Immediate
</pre>
<hr />
<pre>
 4474 pipe_class ialu_hi_lo_reg_temp(regF dst, immF src, g3RegP tmp) %{
 4475     instruction_count(1); multiple_bundles;
 4476     dst   : E(write)+1;
 4477     IALU  : R(2);
 4478 %}
 4479 
 4480 // Long Constant
 4481 pipe_class loadConL( iRegL dst, immL src ) %{
 4482     instruction_count(2); multiple_bundles;
 4483     dst   : E(write)+1;
 4484     IALU  : R(2);
 4485     IALU  : R(2);
 4486 %}
 4487 
 4488 // Pointer Constant
 4489 pipe_class loadConP( iRegP dst, immP src ) %{
 4490     instruction_count(0); multiple_bundles;
 4491     fixed_latency(6);
 4492 %}
 4493 






 4494 // Long Constant small
 4495 pipe_class loadConLlo( iRegL dst, immL src ) %{
 4496     instruction_count(2);
 4497     dst   : E(write);
 4498     IALU  : R;
 4499     IALU  : R;
 4500 %}
 4501 
 4502 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 4503 pipe_class loadConFD(regF dst, immF src, g3RegP tmp) %{
 4504     instruction_count(1); multiple_bundles;
 4505     src   : R(read);
 4506     dst   : M(write)+1;
 4507     IALU  : R;
 4508     MS    : E;
 4509 %}
 4510 
 4511 // Integer ALU nop operation
 4512 pipe_class ialu_nop() %{
 4513     single_instruction;
</pre>
<hr />
<pre>
 5859     if (_opnds[1]-&gt;constant_reloc() == relocInfo::metadata_type) {
 5860       __ set_metadata_constant((Metadata*)$con$$constant, $dst$$Register);
 5861     } else {
 5862       __ set($con$$constant, $dst$$Register);
 5863     }
 5864   %}
 5865   ins_pipe(loadConP);
 5866 %}
 5867 
 5868 instruct loadConP0(iRegP dst, immP0 src) %{
 5869   match(Set dst src);
 5870 
 5871   size(4);
 5872   format %{ &quot;CLR    $dst\t!ptr&quot; %}
 5873   ins_encode %{
 5874     __ clr($dst$$Register);
 5875   %}
 5876   ins_pipe(ialu_imm);
 5877 %}
 5878 











 5879 instruct loadConN0(iRegN dst, immN0 src) %{
 5880   match(Set dst src);
 5881 
 5882   size(4);
 5883   format %{ &quot;CLR    $dst\t! compressed NULL ptr&quot; %}
 5884   ins_encode %{
 5885     __ clr($dst$$Register);
 5886   %}
 5887   ins_pipe(ialu_imm);
 5888 %}
 5889 
 5890 instruct loadConN(iRegN dst, immN src) %{
 5891   match(Set dst src);
 5892   ins_cost(DEFAULT_COST * 3/2);
 5893   format %{ &quot;SET    $src,$dst\t! compressed ptr&quot; %}
 5894   ins_encode %{
 5895     Register dst = $dst$$Register;
 5896     __ set_narrow_oop((jobject)$src$$constant, dst);
 5897   %}
 5898   ins_pipe(ialu_hi_lo_reg);
</pre>
<hr />
<pre>
 8819 //----------Branches---------------------------------------------------------
 8820 // Jump
 8821 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8822 instruct jumpXtnd(iRegX switch_val, o7RegI table) %{
 8823   match(Jump switch_val);
 8824   effect(TEMP table);
 8825 
 8826   ins_cost(350);
 8827 
 8828   format %{  &quot;ADD    $constanttablebase, $constantoffset, O7\n\t&quot;
 8829              &quot;LD     [O7 + $switch_val], O7\n\t&quot;
 8830              &quot;JUMP   O7&quot; %}
 8831   ins_encode %{
 8832     // Calculate table address into a register.
 8833     Register table_reg;
 8834     Register label_reg = O7;
 8835     // If we are calculating the size of this instruction don&#39;t trust
 8836     // zero offsets because they might change when
 8837     // MachConstantBaseNode decides to optimize the constant table
 8838     // base.
<span class="line-modified"> 8839     if ((constant_offset() == 0) &amp;&amp; !Compile::current()-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 8840       table_reg = $constanttablebase;
 8841     } else {
 8842       table_reg = O7;
 8843       RegisterOrConstant con_offset = __ ensure_simm13_or_reg($constantoffset, O7);
 8844       __ add($constanttablebase, con_offset, table_reg);
 8845     }
 8846 
 8847     // Jump to base address + switch value
 8848     __ ld_ptr(table_reg, $switch_val$$Register, label_reg);
 8849     __ jmp(label_reg, G0);
 8850     __ delayed()-&gt;nop();
 8851   %}
 8852   ins_pipe(ialu_reg_reg);
 8853 %}
 8854 
 8855 // Direct Branch.  Use V8 version with longer range.
 8856 instruct branch(label labl) %{
 8857   match(Goto);
 8858   effect(USE labl);
 8859 
</pre>
</td>
</tr>
</table>
<center><a href="sharedRuntime_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="templateTable_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
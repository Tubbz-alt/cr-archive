<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/sparc/interp_masm_sparc.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/sparc/interp_masm_sparc.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
285 
286   void record_klass_in_profile(Register receiver, Register scratch, bool is_virtual_call);
287   void record_klass_in_profile_helper(Register receiver, Register scratch,
288                                       Label&amp; done, bool is_virtual_call);
289   void record_item_in_profile_helper(Register item,
290                                      Register scratch, int start_row, Label&amp; done, int total_rows,
291                                      OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,
292                                      int non_profiled_offset);
293 
294   void update_mdp_by_offset(int offset_of_disp, Register scratch);
295   void update_mdp_by_offset(Register reg, int offset_of_disp,
296                             Register scratch);
297   void update_mdp_by_constant(int constant);
298   void update_mdp_for_ret(TosState state, Register return_bci);
299 
300   void profile_taken_branch(Register scratch, Register bumped_count);
301   void profile_not_taken_branch(Register scratch);
302   void profile_call(Register scratch);
303   void profile_final_call(Register scratch);
304   void profile_virtual_call(Register receiver, Register scratch, bool receiver_can_be_null = false);
<span class="line-removed">305   void profile_called_method(Register method, Register scratch) NOT_JVMCI_RETURN;</span>
306   void profile_ret(TosState state, Register return_bci, Register scratch);
307   void profile_null_seen(Register scratch);
308   void profile_typecheck(Register klass, Register scratch);
309   void profile_typecheck_failed(Register scratch);
310   void profile_switch_default(Register scratch);
311   void profile_switch_case(Register index,
312                            Register scratch1,
313                            Register scratch2,
314                            Register scratch3);
315 
316   void profile_obj_type(Register obj, const Address&amp; mdo_addr, Register tmp);
317   void profile_arguments_type(Register callee, Register tmp1, Register tmp2, bool is_virtual);
318   void profile_return_type(Register ret, Register tmp1, Register tmp2);
319   void profile_parameters_type(Register tmp1, Register tmp2, Register tmp3, Register tmp4);
320 
321   // Debugging
322   void interp_verify_oop(Register reg, TosState state, const char * file, int line);    // only if +VerifyOops &amp;&amp; state == atos
323   void verify_oop_or_return_address(Register reg, Register rtmp); // for astore
324   void verify_FPU(int stack_depth, TosState state = ftos) {}      // No-op.
325 
</pre>
</td>
<td>
<hr />
<pre>
285 
286   void record_klass_in_profile(Register receiver, Register scratch, bool is_virtual_call);
287   void record_klass_in_profile_helper(Register receiver, Register scratch,
288                                       Label&amp; done, bool is_virtual_call);
289   void record_item_in_profile_helper(Register item,
290                                      Register scratch, int start_row, Label&amp; done, int total_rows,
291                                      OffsetFunction item_offset_fn, OffsetFunction item_count_offset_fn,
292                                      int non_profiled_offset);
293 
294   void update_mdp_by_offset(int offset_of_disp, Register scratch);
295   void update_mdp_by_offset(Register reg, int offset_of_disp,
296                             Register scratch);
297   void update_mdp_by_constant(int constant);
298   void update_mdp_for_ret(TosState state, Register return_bci);
299 
300   void profile_taken_branch(Register scratch, Register bumped_count);
301   void profile_not_taken_branch(Register scratch);
302   void profile_call(Register scratch);
303   void profile_final_call(Register scratch);
304   void profile_virtual_call(Register receiver, Register scratch, bool receiver_can_be_null = false);

305   void profile_ret(TosState state, Register return_bci, Register scratch);
306   void profile_null_seen(Register scratch);
307   void profile_typecheck(Register klass, Register scratch);
308   void profile_typecheck_failed(Register scratch);
309   void profile_switch_default(Register scratch);
310   void profile_switch_case(Register index,
311                            Register scratch1,
312                            Register scratch2,
313                            Register scratch3);
314 
315   void profile_obj_type(Register obj, const Address&amp; mdo_addr, Register tmp);
316   void profile_arguments_type(Register callee, Register tmp1, Register tmp2, bool is_virtual);
317   void profile_return_type(Register ret, Register tmp1, Register tmp2);
318   void profile_parameters_type(Register tmp1, Register tmp2, Register tmp3, Register tmp4);
319 
320   // Debugging
321   void interp_verify_oop(Register reg, TosState state, const char * file, int line);    // only if +VerifyOops &amp;&amp; state == atos
322   void verify_oop_or_return_address(Register reg, Register rtmp); // for astore
323   void verify_FPU(int stack_depth, TosState state = ftos) {}      // No-op.
324 
</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_sparc.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
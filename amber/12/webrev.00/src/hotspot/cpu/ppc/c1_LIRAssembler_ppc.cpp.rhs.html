<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/c1_LIRAssembler_ppc.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
<a name="1" id="anc1"></a><span class="line-modified">   2  * Copyright (c) 2000, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * Copyright (c) 2012, 2019, SAP SE. All rights reserved.
   4  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   5  *
   6  * This code is free software; you can redistribute it and/or modify it
   7  * under the terms of the GNU General Public License version 2 only, as
   8  * published by the Free Software Foundation.
   9  *
  10  * This code is distributed in the hope that it will be useful, but WITHOUT
  11  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  12  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  13  * version 2 for more details (a copy is included in the LICENSE file that
  14  * accompanied this code).
  15  *
  16  * You should have received a copy of the GNU General Public License version
  17  * 2 along with this work; if not, write to the Free Software Foundation,
  18  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  19  *
  20  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  21  * or visit www.oracle.com if you need additional information or have any
  22  * questions.
  23  *
  24  */
  25 
  26 #include &quot;precompiled.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;c1/c1_Compilation.hpp&quot;
  29 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  30 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  31 #include &quot;c1/c1_Runtime1.hpp&quot;
  32 #include &quot;c1/c1_ValueStack.hpp&quot;
  33 #include &quot;ci/ciArrayKlass.hpp&quot;
  34 #include &quot;ci/ciInstance.hpp&quot;
  35 #include &quot;gc/shared/collectedHeap.hpp&quot;
  36 #include &quot;memory/universe.hpp&quot;
  37 #include &quot;nativeInst_ppc.hpp&quot;
  38 #include &quot;oops/compressedOops.hpp&quot;
  39 #include &quot;oops/objArrayKlass.hpp&quot;
  40 #include &quot;runtime/frame.inline.hpp&quot;
  41 #include &quot;runtime/safepointMechanism.inline.hpp&quot;
  42 #include &quot;runtime/sharedRuntime.hpp&quot;
  43 #include &quot;utilities/powerOfTwo.hpp&quot;
  44 
  45 #define __ _masm-&gt;
  46 
  47 
  48 const ConditionRegister LIR_Assembler::BOOL_RESULT = CCR5;
  49 
  50 
  51 bool LIR_Assembler::is_small_constant(LIR_Opr opr) {
  52   Unimplemented(); return false; // Currently not used on this platform.
  53 }
  54 
  55 
  56 LIR_Opr LIR_Assembler::receiverOpr() {
  57   return FrameMap::R3_oop_opr;
  58 }
  59 
  60 
  61 LIR_Opr LIR_Assembler::osrBufferPointer() {
  62   return FrameMap::R3_opr;
  63 }
  64 
  65 
  66 // This specifies the stack pointer decrement needed to build the frame.
  67 int LIR_Assembler::initial_frame_size_in_bytes() const {
  68   return in_bytes(frame_map()-&gt;framesize_in_bytes());
  69 }
  70 
  71 
  72 // Inline cache check: the inline cached class is in inline_cache_reg;
  73 // we fetch the class of the receiver and compare it with the cached class.
  74 // If they do not match we jump to slow case.
  75 int LIR_Assembler::check_icache() {
  76   int offset = __ offset();
  77   __ inline_cache_check(R3_ARG1, R19_inline_cache_reg);
  78   return offset;
  79 }
  80 
  81 void LIR_Assembler::clinit_barrier(ciMethod* method) {
  82   assert(!method-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  83 
  84   Label L_skip_barrier;
  85   Register klass = R20;
  86 
  87   metadata2reg(method-&gt;holder()-&gt;constant_encoding(), klass);
  88   __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
  89 
  90   __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
  91   __ mtctr(klass);
  92   __ bctr();
  93 
  94   __ bind(L_skip_barrier);
  95 }
  96 
  97 void LIR_Assembler::osr_entry() {
  98   // On-stack-replacement entry sequence:
  99   //
 100   //   1. Create a new compiled activation.
 101   //   2. Initialize local variables in the compiled activation. The expression
 102   //      stack must be empty at the osr_bci; it is not initialized.
 103   //   3. Jump to the continuation address in compiled code to resume execution.
 104 
 105   // OSR entry point
 106   offsets()-&gt;set_value(CodeOffsets::OSR_Entry, code_offset());
 107   BlockBegin* osr_entry = compilation()-&gt;hir()-&gt;osr_entry();
 108   ValueStack* entry_state = osr_entry-&gt;end()-&gt;state();
 109   int number_of_locks = entry_state-&gt;locks_size();
 110 
 111   // Create a frame for the compiled activation.
 112   __ build_frame(initial_frame_size_in_bytes(), bang_size_in_bytes());
 113 
 114   // OSR buffer is
 115   //
 116   // locals[nlocals-1..0]
 117   // monitors[number_of_locks-1..0]
 118   //
 119   // Locals is a direct copy of the interpreter frame so in the osr buffer
 120   // the first slot in the local array is the last local from the interpreter
 121   // and the last slot is local[0] (receiver) from the interpreter.
 122   //
 123   // Similarly with locks. The first lock slot in the osr buffer is the nth lock
 124   // from the interpreter frame, the nth lock slot in the osr buffer is 0th lock
 125   // in the interpreter frame (the method lock if a sync method).
 126 
 127   // Initialize monitors in the compiled activation.
 128   //   R3: pointer to osr buffer
 129   //
 130   // All other registers are dead at this point and the locals will be
 131   // copied into place by code emitted in the IR.
 132 
 133   Register OSR_buf = osrBufferPointer()-&gt;as_register();
 134   { assert(frame::interpreter_frame_monitor_size() == BasicObjectLock::size(), &quot;adjust code below&quot;);
 135     int monitor_offset = BytesPerWord * method()-&gt;max_locals() +
 136       (2 * BytesPerWord) * (number_of_locks - 1);
 137     // SharedRuntime::OSR_migration_begin() packs BasicObjectLocks in
 138     // the OSR buffer using 2 word entries: first the lock and then
 139     // the oop.
 140     for (int i = 0; i &lt; number_of_locks; i++) {
 141       int slot_offset = monitor_offset - ((i * 2) * BytesPerWord);
 142 #ifdef ASSERT
 143       // Verify the interpreter&#39;s monitor has a non-null object.
 144       {
 145         Label L;
 146         __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 147         __ cmpdi(CCR0, R0, 0);
 148         __ bne(CCR0, L);
 149         __ stop(&quot;locked object is NULL&quot;);
 150         __ bind(L);
 151       }
 152 #endif // ASSERT
 153       // Copy the lock field into the compiled activation.
 154       Address ml = frame_map()-&gt;address_for_monitor_lock(i),
 155               mo = frame_map()-&gt;address_for_monitor_object(i);
 156       assert(ml.index() == noreg &amp;&amp; mo.index() == noreg, &quot;sanity&quot;);
 157       __ ld(R0, slot_offset + 0, OSR_buf);
 158       __ std(R0, ml.disp(), ml.base());
 159       __ ld(R0, slot_offset + 1*BytesPerWord, OSR_buf);
 160       __ std(R0, mo.disp(), mo.base());
 161     }
 162   }
 163 }
 164 
 165 
 166 int LIR_Assembler::emit_exception_handler() {
 167   // If the last instruction is a call (typically to do a throw which
 168   // is coming at the end after block reordering) the return address
 169   // must still point into the code area in order to avoid assertion
 170   // failures when searching for the corresponding bci =&gt; add a nop
 171   // (was bug 5/14/1999 - gri).
 172   __ nop();
 173 
 174   // Generate code for the exception handler.
 175   address handler_base = __ start_a_stub(exception_handler_size());
 176 
 177   if (handler_base == NULL) {
 178     // Not enough space left for the handler.
 179     bailout(&quot;exception handler overflow&quot;);
 180     return -1;
 181   }
 182 
 183   int offset = code_offset();
 184   address entry_point = CAST_FROM_FN_PTR(address, Runtime1::entry_for(Runtime1::handle_exception_from_callee_id));
 185   //__ load_const_optimized(R0, entry_point);
 186   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(entry_point));
 187   __ mtctr(R0);
 188   __ bctr();
 189 
 190   guarantee(code_offset() - offset &lt;= exception_handler_size(), &quot;overflow&quot;);
 191   __ end_a_stub();
 192 
 193   return offset;
 194 }
 195 
 196 
 197 // Emit the code to remove the frame from the stack in the exception
 198 // unwind path.
 199 int LIR_Assembler::emit_unwind_handler() {
 200   _masm-&gt;block_comment(&quot;Unwind handler&quot;);
 201 
 202   int offset = code_offset();
 203   bool preserve_exception = method()-&gt;is_synchronized() || compilation()-&gt;env()-&gt;dtrace_method_probes();
 204   const Register Rexception = R3 /*LIRGenerator::exceptionOopOpr()*/, Rexception_save = R31;
 205 
 206   // Fetch the exception from TLS and clear out exception related thread state.
 207   __ ld(Rexception, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 208   __ li(R0, 0);
 209   __ std(R0, in_bytes(JavaThread::exception_oop_offset()), R16_thread);
 210   __ std(R0, in_bytes(JavaThread::exception_pc_offset()), R16_thread);
 211 
 212   __ bind(_unwind_handler_entry);
 213   __ verify_not_null_oop(Rexception);
 214   if (preserve_exception) { __ mr(Rexception_save, Rexception); }
 215 
 216   // Perform needed unlocking
 217   MonitorExitStub* stub = NULL;
 218   if (method()-&gt;is_synchronized()) {
 219     monitor_address(0, FrameMap::R4_opr);
 220     stub = new MonitorExitStub(FrameMap::R4_opr, true, 0);
 221     __ unlock_object(R5, R6, R4, *stub-&gt;entry());
 222     __ bind(*stub-&gt;continuation());
 223   }
 224 
 225   if (compilation()-&gt;env()-&gt;dtrace_method_probes()) {
 226     Unimplemented();
 227   }
 228 
 229   // Dispatch to the unwind logic.
 230   address unwind_stub = Runtime1::entry_for(Runtime1::unwind_exception_id);
 231   //__ load_const_optimized(R0, unwind_stub);
 232   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(unwind_stub));
 233   if (preserve_exception) { __ mr(Rexception, Rexception_save); }
 234   __ mtctr(R0);
 235   __ bctr();
 236 
 237   // Emit the slow path assembly.
 238   if (stub != NULL) {
 239     stub-&gt;emit_code(this);
 240   }
 241 
 242   return offset;
 243 }
 244 
 245 
 246 int LIR_Assembler::emit_deopt_handler() {
 247   // If the last instruction is a call (typically to do a throw which
 248   // is coming at the end after block reordering) the return address
 249   // must still point into the code area in order to avoid assertion
 250   // failures when searching for the corresponding bci =&gt; add a nop
 251   // (was bug 5/14/1999 - gri).
 252   __ nop();
 253 
 254   // Generate code for deopt handler.
 255   address handler_base = __ start_a_stub(deopt_handler_size());
 256 
 257   if (handler_base == NULL) {
 258     // Not enough space left for the handler.
 259     bailout(&quot;deopt handler overflow&quot;);
 260     return -1;
 261   }
 262 
 263   int offset = code_offset();
 264   __ bl64_patchable(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type);
 265 
 266   guarantee(code_offset() - offset &lt;= deopt_handler_size(), &quot;overflow&quot;);
 267   __ end_a_stub();
 268 
 269   return offset;
 270 }
 271 
 272 
 273 void LIR_Assembler::jobject2reg(jobject o, Register reg) {
 274   if (o == NULL) {
 275     __ li(reg, 0);
 276   } else {
 277     AddressLiteral addrlit = __ constant_oop_address(o);
 278     __ load_const(reg, addrlit, (reg != R0) ? R0 : noreg);
 279   }
 280 }
 281 
 282 
 283 void LIR_Assembler::jobject2reg_with_patching(Register reg, CodeEmitInfo *info) {
 284   // Allocate a new index in table to hold the object once it&#39;s been patched.
 285   int oop_index = __ oop_recorder()-&gt;allocate_oop_index(NULL);
 286   PatchingStub* patch = new PatchingStub(_masm, patching_id(info), oop_index);
 287 
 288   AddressLiteral addrlit((address)NULL, oop_Relocation::spec(oop_index));
 289   __ load_const(reg, addrlit, R0);
 290 
 291   patching_epilog(patch, lir_patch_normal, reg, info);
 292 }
 293 
 294 
 295 void LIR_Assembler::metadata2reg(Metadata* o, Register reg) {
 296   AddressLiteral md = __ constant_metadata_address(o); // Notify OOP recorder (don&#39;t need the relocation)
 297   __ load_const_optimized(reg, md.value(), (reg != R0) ? R0 : noreg);
 298 }
 299 
 300 
 301 void LIR_Assembler::klass2reg_with_patching(Register reg, CodeEmitInfo *info) {
 302   // Allocate a new index in table to hold the klass once it&#39;s been patched.
 303   int index = __ oop_recorder()-&gt;allocate_metadata_index(NULL);
 304   PatchingStub* patch = new PatchingStub(_masm, PatchingStub::load_klass_id, index);
 305 
 306   AddressLiteral addrlit((address)NULL, metadata_Relocation::spec(index));
 307   assert(addrlit.rspec().type() == relocInfo::metadata_type, &quot;must be an metadata reloc&quot;);
 308   __ load_const(reg, addrlit, R0);
 309 
 310   patching_epilog(patch, lir_patch_normal, reg, info);
 311 }
 312 
 313 
 314 void LIR_Assembler::arithmetic_idiv(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr temp, LIR_Opr result, CodeEmitInfo* info) {
 315   const bool is_int = result-&gt;is_single_cpu();
 316   Register Rdividend = is_int ? left-&gt;as_register() : left-&gt;as_register_lo();
 317   Register Rdivisor  = noreg;
 318   Register Rscratch  = temp-&gt;as_register();
 319   Register Rresult   = is_int ? result-&gt;as_register() : result-&gt;as_register_lo();
 320   long divisor = -1;
 321 
 322   if (right-&gt;is_register()) {
 323     Rdivisor = is_int ? right-&gt;as_register() : right-&gt;as_register_lo();
 324   } else {
 325     divisor = is_int ? right-&gt;as_constant_ptr()-&gt;as_jint()
 326                      : right-&gt;as_constant_ptr()-&gt;as_jlong();
 327   }
 328 
 329   assert(Rdividend != Rscratch, &quot;&quot;);
 330   assert(Rdivisor  != Rscratch, &quot;&quot;);
 331   assert(code == lir_idiv || code == lir_irem, &quot;Must be irem or idiv&quot;);
 332 
 333   if (Rdivisor == noreg) {
 334     if (divisor == 1) { // stupid, but can happen
 335       if (code == lir_idiv) {
 336         __ mr_if_needed(Rresult, Rdividend);
 337       } else {
 338         __ li(Rresult, 0);
 339       }
 340 
 341     } else if (is_power_of_2(divisor)) {
 342       // Convert division by a power of two into some shifts and logical operations.
 343       int log2 = log2_intptr(divisor);
 344 
 345       // Round towards 0.
 346       if (divisor == 2) {
 347         if (is_int) {
 348           __ srwi(Rscratch, Rdividend, 31);
 349         } else {
 350           __ srdi(Rscratch, Rdividend, 63);
 351         }
 352       } else {
 353         if (is_int) {
 354           __ srawi(Rscratch, Rdividend, 31);
 355         } else {
 356           __ sradi(Rscratch, Rdividend, 63);
 357         }
 358         __ clrldi(Rscratch, Rscratch, 64-log2);
 359       }
 360       __ add(Rscratch, Rdividend, Rscratch);
 361 
 362       if (code == lir_idiv) {
 363         if (is_int) {
 364           __ srawi(Rresult, Rscratch, log2);
 365         } else {
 366           __ sradi(Rresult, Rscratch, log2);
 367         }
 368       } else { // lir_irem
 369         __ clrrdi(Rscratch, Rscratch, log2);
 370         __ sub(Rresult, Rdividend, Rscratch);
 371       }
 372 
 373     } else if (divisor == -1) {
 374       if (code == lir_idiv) {
 375         __ neg(Rresult, Rdividend);
 376       } else {
 377         __ li(Rresult, 0);
 378       }
 379 
 380     } else {
 381       __ load_const_optimized(Rscratch, divisor);
 382       if (code == lir_idiv) {
 383         if (is_int) {
 384           __ divw(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 385         } else {
 386           __ divd(Rresult, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 387         }
 388       } else {
 389         assert(Rscratch != R0, &quot;need both&quot;);
 390         if (is_int) {
 391           __ divw(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 392           __ mullw(Rscratch, R0, Rscratch);
 393         } else {
 394           __ divd(R0, Rdividend, Rscratch); // Can&#39;t divide minint/-1.
 395           __ mulld(Rscratch, R0, Rscratch);
 396         }
 397         __ sub(Rresult, Rdividend, Rscratch);
 398       }
 399 
 400     }
 401     return;
 402   }
 403 
 404   Label regular, done;
 405   if (is_int) {
 406     __ cmpwi(CCR0, Rdivisor, -1);
 407   } else {
 408     __ cmpdi(CCR0, Rdivisor, -1);
 409   }
 410   __ bne(CCR0, regular);
 411   if (code == lir_idiv) {
 412     __ neg(Rresult, Rdividend);
 413     __ b(done);
 414     __ bind(regular);
 415     if (is_int) {
 416       __ divw(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 417     } else {
 418       __ divd(Rresult, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 419     }
 420   } else { // lir_irem
 421     __ li(Rresult, 0);
 422     __ b(done);
 423     __ bind(regular);
 424     if (is_int) {
 425       __ divw(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 426       __ mullw(Rscratch, Rscratch, Rdivisor);
 427     } else {
 428       __ divd(Rscratch, Rdividend, Rdivisor); // Can&#39;t divide minint/-1.
 429       __ mulld(Rscratch, Rscratch, Rdivisor);
 430     }
 431     __ sub(Rresult, Rdividend, Rscratch);
 432   }
 433   __ bind(done);
 434 }
 435 
 436 
 437 void LIR_Assembler::emit_op3(LIR_Op3* op) {
 438   switch (op-&gt;code()) {
 439   case lir_idiv:
 440   case lir_irem:
 441     arithmetic_idiv(op-&gt;code(), op-&gt;in_opr1(), op-&gt;in_opr2(), op-&gt;in_opr3(),
 442                     op-&gt;result_opr(), op-&gt;info());
 443     break;
 444   case lir_fmad:
 445     __ fmadd(op-&gt;result_opr()-&gt;as_double_reg(), op-&gt;in_opr1()-&gt;as_double_reg(),
 446              op-&gt;in_opr2()-&gt;as_double_reg(), op-&gt;in_opr3()-&gt;as_double_reg());
 447     break;
 448   case lir_fmaf:
 449     __ fmadds(op-&gt;result_opr()-&gt;as_float_reg(), op-&gt;in_opr1()-&gt;as_float_reg(),
 450               op-&gt;in_opr2()-&gt;as_float_reg(), op-&gt;in_opr3()-&gt;as_float_reg());
 451     break;
 452   default: ShouldNotReachHere(); break;
 453   }
 454 }
 455 
 456 
 457 void LIR_Assembler::emit_opBranch(LIR_OpBranch* op) {
 458 #ifdef ASSERT
 459   assert(op-&gt;block() == NULL || op-&gt;block()-&gt;label() == op-&gt;label(), &quot;wrong label&quot;);
 460   if (op-&gt;block() != NULL)  _branch_target_blocks.append(op-&gt;block());
 461   if (op-&gt;ublock() != NULL) _branch_target_blocks.append(op-&gt;ublock());
 462   assert(op-&gt;info() == NULL, &quot;shouldn&#39;t have CodeEmitInfo&quot;);
 463 #endif
 464 
 465   Label *L = op-&gt;label();
 466   if (op-&gt;cond() == lir_cond_always) {
 467     __ b(*L);
 468   } else {
 469     Label done;
 470     bool is_unordered = false;
 471     if (op-&gt;code() == lir_cond_float_branch) {
 472       assert(op-&gt;ublock() != NULL, &quot;must have unordered successor&quot;);
 473       is_unordered = true;
 474     } else {
 475       assert(op-&gt;code() == lir_branch, &quot;just checking&quot;);
 476     }
 477 
 478     bool positive = false;
 479     Assembler::Condition cond = Assembler::equal;
 480     switch (op-&gt;cond()) {
 481       case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; is_unordered = false; break;
 482       case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; is_unordered = false; break;
 483       case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
 484       case lir_cond_belowEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 485       case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
 486       case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
 487       case lir_cond_aboveEqual:   assert(op-&gt;code() != lir_cond_float_branch, &quot;&quot;); // fallthru
 488       case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
 489       default:                    ShouldNotReachHere();
 490     }
 491     int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
 492     int bi = Assembler::bi0(BOOL_RESULT, cond);
 493     if (is_unordered) {
 494       if (positive) {
 495         if (op-&gt;ublock() == op-&gt;block()) {
 496           __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(BOOL_RESULT, Assembler::summary_overflow), *L);
 497         }
 498       } else {
 499         if (op-&gt;ublock() != op-&gt;block()) { __ bso(BOOL_RESULT, done); }
 500       }
 501     }
 502     __ bc_far_optimized(bo, bi, *L);
 503     __ bind(done);
 504   }
 505 }
 506 
 507 
 508 void LIR_Assembler::emit_opConvert(LIR_OpConvert* op) {
 509   Bytecodes::Code code = op-&gt;bytecode();
 510   LIR_Opr src = op-&gt;in_opr(),
 511           dst = op-&gt;result_opr();
 512 
 513   switch(code) {
 514     case Bytecodes::_i2l: {
 515       __ extsw(dst-&gt;as_register_lo(), src-&gt;as_register());
 516       break;
 517     }
 518     case Bytecodes::_l2i: {
 519       __ mr_if_needed(dst-&gt;as_register(), src-&gt;as_register_lo()); // high bits are garbage
 520       break;
 521     }
 522     case Bytecodes::_i2b: {
 523       __ extsb(dst-&gt;as_register(), src-&gt;as_register());
 524       break;
 525     }
 526     case Bytecodes::_i2c: {
 527       __ clrldi(dst-&gt;as_register(), src-&gt;as_register(), 64-16);
 528       break;
 529     }
 530     case Bytecodes::_i2s: {
 531       __ extsh(dst-&gt;as_register(), src-&gt;as_register());
 532       break;
 533     }
 534     case Bytecodes::_i2d:
 535     case Bytecodes::_l2d: {
 536       bool src_in_memory = !VM_Version::has_mtfprd();
 537       FloatRegister rdst = dst-&gt;as_double_reg();
 538       FloatRegister rsrc;
 539       if (src_in_memory) {
 540         rsrc = src-&gt;as_double_reg(); // via mem
 541       } else {
 542         // move src to dst register
 543         if (code == Bytecodes::_i2d) {
 544           __ mtfprwa(rdst, src-&gt;as_register());
 545         } else {
 546           __ mtfprd(rdst, src-&gt;as_register_lo());
 547         }
 548         rsrc = rdst;
 549       }
 550       __ fcfid(rdst, rsrc);
 551       break;
 552     }
 553     case Bytecodes::_i2f:
 554     case Bytecodes::_l2f: {
 555       bool src_in_memory = !VM_Version::has_mtfprd();
 556       FloatRegister rdst = dst-&gt;as_float_reg();
 557       FloatRegister rsrc;
 558       if (src_in_memory) {
 559         rsrc = src-&gt;as_double_reg(); // via mem
 560       } else {
 561         // move src to dst register
 562         if (code == Bytecodes::_i2f) {
 563           __ mtfprwa(rdst, src-&gt;as_register());
 564         } else {
 565           __ mtfprd(rdst, src-&gt;as_register_lo());
 566         }
 567         rsrc = rdst;
 568       }
 569       if (VM_Version::has_fcfids()) {
 570         __ fcfids(rdst, rsrc);
 571       } else {
 572         assert(code == Bytecodes::_i2f, &quot;fcfid+frsp needs fixup code to avoid rounding incompatibility&quot;);
 573         __ fcfid(rdst, rsrc);
 574         __ frsp(rdst, rdst);
 575       }
 576       break;
 577     }
 578     case Bytecodes::_f2d: {
 579       __ fmr_if_needed(dst-&gt;as_double_reg(), src-&gt;as_float_reg());
 580       break;
 581     }
 582     case Bytecodes::_d2f: {
 583       __ frsp(dst-&gt;as_float_reg(), src-&gt;as_double_reg());
 584       break;
 585     }
 586     case Bytecodes::_d2i:
 587     case Bytecodes::_f2i: {
 588       bool dst_in_memory = !VM_Version::has_mtfprd();
 589       FloatRegister rsrc = (code == Bytecodes::_d2i) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 590       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 591       Label L;
 592       // Result must be 0 if value is NaN; test by comparing value to itself.
 593       __ fcmpu(CCR0, rsrc, rsrc);
 594       if (dst_in_memory) {
 595         __ li(R0, 0); // 0 in case of NAN
 596         __ std(R0, addr.disp(), addr.base());
 597       } else {
 598         __ li(dst-&gt;as_register(), 0);
 599       }
 600       __ bso(CCR0, L);
 601       __ fctiwz(rsrc, rsrc); // USE_KILL
 602       if (dst_in_memory) {
 603         __ stfd(rsrc, addr.disp(), addr.base());
 604       } else {
 605         __ mffprd(dst-&gt;as_register(), rsrc);
 606       }
 607       __ bind(L);
 608       break;
 609     }
 610     case Bytecodes::_d2l:
 611     case Bytecodes::_f2l: {
 612       bool dst_in_memory = !VM_Version::has_mtfprd();
 613       FloatRegister rsrc = (code == Bytecodes::_d2l) ? src-&gt;as_double_reg() : src-&gt;as_float_reg();
 614       Address       addr = dst_in_memory ? frame_map()-&gt;address_for_slot(dst-&gt;double_stack_ix()) : NULL;
 615       Label L;
 616       // Result must be 0 if value is NaN; test by comparing value to itself.
 617       __ fcmpu(CCR0, rsrc, rsrc);
 618       if (dst_in_memory) {
 619         __ li(R0, 0); // 0 in case of NAN
 620         __ std(R0, addr.disp(), addr.base());
 621       } else {
 622         __ li(dst-&gt;as_register_lo(), 0);
 623       }
 624       __ bso(CCR0, L);
 625       __ fctidz(rsrc, rsrc); // USE_KILL
 626       if (dst_in_memory) {
 627         __ stfd(rsrc, addr.disp(), addr.base());
 628       } else {
 629         __ mffprd(dst-&gt;as_register_lo(), rsrc);
 630       }
 631       __ bind(L);
 632       break;
 633     }
 634 
 635     default: ShouldNotReachHere();
 636   }
 637 }
 638 
 639 
 640 void LIR_Assembler::align_call(LIR_Code) {
 641   // do nothing since all instructions are word aligned on ppc
 642 }
 643 
 644 
 645 bool LIR_Assembler::emit_trampoline_stub_for_call(address target, Register Rtoc) {
 646   int start_offset = __ offset();
 647   // Put the entry point as a constant into the constant pool.
 648   const address entry_point_toc_addr   = __ address_constant(target, RelocationHolder::none);
 649   if (entry_point_toc_addr == NULL) {
 650     bailout(&quot;const section overflow&quot;);
 651     return false;
 652   }
 653   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 654 
 655   // Emit the trampoline stub which will be related to the branch-and-link below.
 656   address stub = __ emit_trampoline_stub(entry_point_toc_offset, start_offset, Rtoc);
 657   if (!stub) {
 658     bailout(&quot;no space for trampoline stub&quot;);
 659     return false;
 660   }
 661   return true;
 662 }
 663 
 664 
 665 void LIR_Assembler::call(LIR_OpJavaCall* op, relocInfo::relocType rtype) {
 666   assert(rtype==relocInfo::opt_virtual_call_type || rtype==relocInfo::static_call_type, &quot;unexpected rtype&quot;);
 667 
 668   bool success = emit_trampoline_stub_for_call(op-&gt;addr());
 669   if (!success) { return; }
 670 
 671   __ relocate(rtype);
 672   // Note: At this point we do not have the address of the trampoline
 673   // stub, and the entry point might be too far away for bl, so __ pc()
 674   // serves as dummy and the bl will be patched later.
 675   __ code()-&gt;set_insts_mark();
 676   __ bl(__ pc());
 677   add_call_info(code_offset(), op-&gt;info());
 678 }
 679 
 680 
 681 void LIR_Assembler::ic_call(LIR_OpJavaCall* op) {
 682   __ calculate_address_from_global_toc(R2_TOC, __ method_toc());
 683 
 684   // Virtual call relocation will point to ic load.
 685   address virtual_call_meta_addr = __ pc();
 686   // Load a clear inline cache.
 687   AddressLiteral empty_ic((address) Universe::non_oop_word());
 688   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, empty_ic, R2_TOC);
 689   if (!success) {
 690     bailout(&quot;const section overflow&quot;);
 691     return;
 692   }
 693   // Call to fixup routine. Fixup routine uses ScopeDesc info
 694   // to determine who we intended to call.
 695   __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 696 
 697   success = emit_trampoline_stub_for_call(op-&gt;addr(), R2_TOC);
 698   if (!success) { return; }
 699 
 700   // Note: At this point we do not have the address of the trampoline
 701   // stub, and the entry point might be too far away for bl, so __ pc()
 702   // serves as dummy and the bl will be patched later.
 703   __ bl(__ pc());
 704   add_call_info(code_offset(), op-&gt;info());
 705 }
 706 
 707 
 708 void LIR_Assembler::vtable_call(LIR_OpJavaCall* op) {
 709   ShouldNotReachHere(); // ic_call is used instead.
 710 }
 711 
 712 
 713 void LIR_Assembler::explicit_null_check(Register addr, CodeEmitInfo* info) {
 714   ImplicitNullCheckStub* stub = new ImplicitNullCheckStub(code_offset(), info);
 715   __ null_check(addr, stub-&gt;entry());
 716   append_code_stub(stub);
 717 }
 718 
 719 
 720 // Attention: caller must encode oop if needed
 721 int LIR_Assembler::store(LIR_Opr from_reg, Register base, int offset, BasicType type, bool wide, bool unaligned) {
 722   int store_offset;
 723   if (!Assembler::is_simm16(offset)) {
 724     // For offsets larger than a simm16 we setup the offset.
 725     assert(wide &amp;&amp; !from_reg-&gt;is_same_register(FrameMap::R0_opr), &quot;large offset only supported in special case&quot;);
 726     __ load_const_optimized(R0, offset);
 727     store_offset = store(from_reg, base, R0, type, wide);
 728   } else {
 729     store_offset = code_offset();
 730     switch (type) {
 731       case T_BOOLEAN: // fall through
 732       case T_BYTE  : __ stb(from_reg-&gt;as_register(), offset, base); break;
 733       case T_CHAR  :
 734       case T_SHORT : __ sth(from_reg-&gt;as_register(), offset, base); break;
 735       case T_INT   : __ stw(from_reg-&gt;as_register(), offset, base); break;
 736       case T_LONG  : __ std(from_reg-&gt;as_register_lo(), offset, base); break;
 737       case T_ADDRESS:
 738       case T_METADATA: __ std(from_reg-&gt;as_register(), offset, base); break;
 739       case T_ARRAY : // fall through
 740       case T_OBJECT:
 741         {
 742           if (UseCompressedOops &amp;&amp; !wide) {
 743             // Encoding done in caller
 744             __ stw(from_reg-&gt;as_register(), offset, base);
 745             __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE);
 746           } else {
 747             __ std(from_reg-&gt;as_register(), offset, base);
 748             __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE);
 749           }
 750           break;
 751         }
 752       case T_FLOAT : __ stfs(from_reg-&gt;as_float_reg(), offset, base); break;
 753       case T_DOUBLE: __ stfd(from_reg-&gt;as_double_reg(), offset, base); break;
 754       default      : ShouldNotReachHere();
 755     }
 756   }
 757   return store_offset;
 758 }
 759 
 760 
 761 // Attention: caller must encode oop if needed
 762 int LIR_Assembler::store(LIR_Opr from_reg, Register base, Register disp, BasicType type, bool wide) {
 763   int store_offset = code_offset();
 764   switch (type) {
 765     case T_BOOLEAN: // fall through
 766     case T_BYTE  : __ stbx(from_reg-&gt;as_register(), base, disp); break;
 767     case T_CHAR  :
 768     case T_SHORT : __ sthx(from_reg-&gt;as_register(), base, disp); break;
 769     case T_INT   : __ stwx(from_reg-&gt;as_register(), base, disp); break;
 770     case T_LONG  :
 771 #ifdef _LP64
 772       __ stdx(from_reg-&gt;as_register_lo(), base, disp);
 773 #else
 774       Unimplemented();
 775 #endif
 776       break;
 777     case T_ADDRESS:
 778       __ stdx(from_reg-&gt;as_register(), base, disp);
 779       break;
 780     case T_ARRAY : // fall through
 781     case T_OBJECT:
 782       {
 783         if (UseCompressedOops &amp;&amp; !wide) {
 784           // Encoding done in caller.
 785           __ stwx(from_reg-&gt;as_register(), base, disp);
 786           __ verify_coop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0
 787         } else {
 788           __ stdx(from_reg-&gt;as_register(), base, disp);
 789           __ verify_oop(from_reg-&gt;as_register(), FILE_AND_LINE); // kills R0
 790         }
 791         break;
 792       }
 793     case T_FLOAT : __ stfsx(from_reg-&gt;as_float_reg(), base, disp); break;
 794     case T_DOUBLE: __ stfdx(from_reg-&gt;as_double_reg(), base, disp); break;
 795     default      : ShouldNotReachHere();
 796   }
 797   return store_offset;
 798 }
 799 
 800 
 801 int LIR_Assembler::load(Register base, int offset, LIR_Opr to_reg, BasicType type, bool wide, bool unaligned) {
 802   int load_offset;
 803   if (!Assembler::is_simm16(offset)) {
 804     // For offsets larger than a simm16 we setup the offset.
 805     __ load_const_optimized(R0, offset);
 806     load_offset = load(base, R0, to_reg, type, wide);
 807   } else {
 808     load_offset = code_offset();
 809     switch(type) {
 810       case T_BOOLEAN: // fall through
 811       case T_BYTE  :   __ lbz(to_reg-&gt;as_register(), offset, base);
 812                        __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 813       case T_CHAR  :   __ lhz(to_reg-&gt;as_register(), offset, base); break;
 814       case T_SHORT :   __ lha(to_reg-&gt;as_register(), offset, base); break;
 815       case T_INT   :   __ lwa(to_reg-&gt;as_register(), offset, base); break;
 816       case T_LONG  :   __ ld(to_reg-&gt;as_register_lo(), offset, base); break;
 817       case T_METADATA: __ ld(to_reg-&gt;as_register(), offset, base); break;
 818       case T_ADDRESS:
 819         if (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; UseCompressedClassPointers) {
 820           __ lwz(to_reg-&gt;as_register(), offset, base);
 821           __ decode_klass_not_null(to_reg-&gt;as_register());
 822         } else {
 823           __ ld(to_reg-&gt;as_register(), offset, base);
 824         }
 825         break;
 826       case T_ARRAY : // fall through
 827       case T_OBJECT:
 828         {
 829           if (UseCompressedOops &amp;&amp; !wide) {
 830             __ lwz(to_reg-&gt;as_register(), offset, base);
 831             __ decode_heap_oop(to_reg-&gt;as_register());
 832           } else {
 833             __ ld(to_reg-&gt;as_register(), offset, base);
 834           }
 835           __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
 836           break;
 837         }
 838       case T_FLOAT:  __ lfs(to_reg-&gt;as_float_reg(), offset, base); break;
 839       case T_DOUBLE: __ lfd(to_reg-&gt;as_double_reg(), offset, base); break;
 840       default      : ShouldNotReachHere();
 841     }
 842   }
 843   return load_offset;
 844 }
 845 
 846 
 847 int LIR_Assembler::load(Register base, Register disp, LIR_Opr to_reg, BasicType type, bool wide) {
 848   int load_offset = code_offset();
 849   switch(type) {
 850     case T_BOOLEAN: // fall through
 851     case T_BYTE  :  __ lbzx(to_reg-&gt;as_register(), base, disp);
 852                     __ extsb(to_reg-&gt;as_register(), to_reg-&gt;as_register()); break;
 853     case T_CHAR  :  __ lhzx(to_reg-&gt;as_register(), base, disp); break;
 854     case T_SHORT :  __ lhax(to_reg-&gt;as_register(), base, disp); break;
 855     case T_INT   :  __ lwax(to_reg-&gt;as_register(), base, disp); break;
 856     case T_ADDRESS: __ ldx(to_reg-&gt;as_register(), base, disp); break;
 857     case T_ARRAY : // fall through
 858     case T_OBJECT:
 859       {
 860         if (UseCompressedOops &amp;&amp; !wide) {
 861           __ lwzx(to_reg-&gt;as_register(), base, disp);
 862           __ decode_heap_oop(to_reg-&gt;as_register());
 863         } else {
 864           __ ldx(to_reg-&gt;as_register(), base, disp);
 865         }
 866         __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
 867         break;
 868       }
 869     case T_FLOAT:  __ lfsx(to_reg-&gt;as_float_reg() , base, disp); break;
 870     case T_DOUBLE: __ lfdx(to_reg-&gt;as_double_reg(), base, disp); break;
 871     case T_LONG  :
 872 #ifdef _LP64
 873       __ ldx(to_reg-&gt;as_register_lo(), base, disp);
 874 #else
 875       Unimplemented();
 876 #endif
 877       break;
 878     default      : ShouldNotReachHere();
 879   }
 880   return load_offset;
 881 }
 882 
 883 
 884 void LIR_Assembler::const2stack(LIR_Opr src, LIR_Opr dest) {
 885   LIR_Const* c = src-&gt;as_constant_ptr();
 886   Register src_reg = R0;
 887   switch (c-&gt;type()) {
 888     case T_INT:
 889     case T_FLOAT: {
 890       int value = c-&gt;as_jint_bits();
 891       __ load_const_optimized(src_reg, value);
 892       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 893       __ stw(src_reg, addr.disp(), addr.base());
 894       break;
 895     }
 896     case T_ADDRESS: {
 897       int value = c-&gt;as_jint_bits();
 898       __ load_const_optimized(src_reg, value);
 899       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 900       __ std(src_reg, addr.disp(), addr.base());
 901       break;
 902     }
 903     case T_OBJECT: {
 904       jobject2reg(c-&gt;as_jobject(), src_reg);
 905       Address addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
 906       __ std(src_reg, addr.disp(), addr.base());
 907       break;
 908     }
 909     case T_LONG:
 910     case T_DOUBLE: {
 911       int value = c-&gt;as_jlong_bits();
 912       __ load_const_optimized(src_reg, value);
 913       Address addr = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
 914       __ std(src_reg, addr.disp(), addr.base());
 915       break;
 916     }
 917     default:
 918       Unimplemented();
 919   }
 920 }
 921 
 922 
 923 void LIR_Assembler::const2mem(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info, bool wide) {
 924   LIR_Const* c = src-&gt;as_constant_ptr();
 925   LIR_Address* addr = dest-&gt;as_address_ptr();
 926   Register base = addr-&gt;base()-&gt;as_pointer_register();
 927   LIR_Opr tmp = LIR_OprFact::illegalOpr;
 928   int offset = -1;
 929   // Null check for large offsets in LIRGenerator::do_StoreField.
 930   bool needs_explicit_null_check = !ImplicitNullChecks;
 931 
 932   if (info != NULL &amp;&amp; needs_explicit_null_check) {
 933     explicit_null_check(base, info);
 934   }
 935 
 936   switch (c-&gt;type()) {
 937     case T_FLOAT: type = T_INT;
 938     case T_INT:
 939     case T_ADDRESS: {
 940       tmp = FrameMap::R0_opr;
 941       __ load_const_optimized(tmp-&gt;as_register(), c-&gt;as_jint_bits());
 942       break;
 943     }
 944     case T_DOUBLE: type = T_LONG;
 945     case T_LONG: {
 946       tmp = FrameMap::R0_long_opr;
 947       __ load_const_optimized(tmp-&gt;as_register_lo(), c-&gt;as_jlong_bits());
 948       break;
 949     }
 950     case T_OBJECT: {
 951       tmp = FrameMap::R0_opr;
 952       if (UseCompressedOops &amp;&amp; !wide &amp;&amp; c-&gt;as_jobject() != NULL) {
 953         AddressLiteral oop_addr = __ constant_oop_address(c-&gt;as_jobject());
 954         __ lis(R0, oop_addr.value() &gt;&gt; 16); // Don&#39;t care about sign extend (will use stw).
 955         __ relocate(oop_addr.rspec(), /*compressed format*/ 1);
 956         __ ori(R0, R0, oop_addr.value() &amp; 0xffff);
 957       } else {
 958         jobject2reg(c-&gt;as_jobject(), R0);
 959       }
 960       break;
 961     }
 962     default:
 963       Unimplemented();
 964   }
 965 
 966   // Handle either reg+reg or reg+disp address.
 967   if (addr-&gt;index()-&gt;is_valid()) {
 968     assert(addr-&gt;disp() == 0, &quot;must be zero&quot;);
 969     offset = store(tmp, base, addr-&gt;index()-&gt;as_pointer_register(), type, wide);
 970   } else {
 971     assert(Assembler::is_simm16(addr-&gt;disp()), &quot;can&#39;t handle larger addresses&quot;);
 972     offset = store(tmp, base, addr-&gt;disp(), type, wide, false);
 973   }
 974 
 975   if (info != NULL) {
 976     assert(offset != -1, &quot;offset should&#39;ve been set&quot;);
 977     if (!needs_explicit_null_check) {
 978       add_debug_info_for_null_check(offset, info);
 979     }
 980   }
 981 }
 982 
 983 
 984 void LIR_Assembler::const2reg(LIR_Opr src, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
 985   LIR_Const* c = src-&gt;as_constant_ptr();
 986   LIR_Opr to_reg = dest;
 987 
 988   switch (c-&gt;type()) {
 989     case T_INT: {
 990       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 991       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);
 992       break;
 993     }
 994     case T_ADDRESS: {
 995       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
 996       __ load_const_optimized(dest-&gt;as_register(), c-&gt;as_jint(), R0);  // Yes, as_jint ...
 997       break;
 998     }
 999     case T_LONG: {
1000       assert(patch_code == lir_patch_none, &quot;no patching handled here&quot;);
1001       __ load_const_optimized(dest-&gt;as_register_lo(), c-&gt;as_jlong(), R0);
1002       break;
1003     }
1004 
1005     case T_OBJECT: {
1006       if (patch_code == lir_patch_none) {
1007         jobject2reg(c-&gt;as_jobject(), to_reg-&gt;as_register());
1008       } else {
1009         jobject2reg_with_patching(to_reg-&gt;as_register(), info);
1010       }
1011       break;
1012     }
1013 
1014     case T_METADATA:
1015       {
1016         if (patch_code == lir_patch_none) {
1017           metadata2reg(c-&gt;as_metadata(), to_reg-&gt;as_register());
1018         } else {
1019           klass2reg_with_patching(to_reg-&gt;as_register(), info);
1020         }
1021       }
1022       break;
1023 
1024     case T_FLOAT:
1025       {
1026         if (to_reg-&gt;is_single_fpu()) {
1027           address const_addr = __ float_constant(c-&gt;as_jfloat());
1028           if (const_addr == NULL) {
1029             bailout(&quot;const section overflow&quot;);
1030             break;
1031           }
1032           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1033           __ relocate(rspec);
1034           __ load_const(R0, const_addr);
1035           __ lfsx(to_reg-&gt;as_float_reg(), R0);
1036         } else {
1037           assert(to_reg-&gt;is_single_cpu(), &quot;Must be a cpu register.&quot;);
1038           __ load_const_optimized(to_reg-&gt;as_register(), jint_cast(c-&gt;as_jfloat()), R0);
1039         }
1040       }
1041       break;
1042 
1043     case T_DOUBLE:
1044       {
1045         if (to_reg-&gt;is_double_fpu()) {
1046           address const_addr = __ double_constant(c-&gt;as_jdouble());
1047           if (const_addr == NULL) {
1048             bailout(&quot;const section overflow&quot;);
1049             break;
1050           }
1051           RelocationHolder rspec = internal_word_Relocation::spec(const_addr);
1052           __ relocate(rspec);
1053           __ load_const(R0, const_addr);
1054           __ lfdx(to_reg-&gt;as_double_reg(), R0);
1055         } else {
1056           assert(to_reg-&gt;is_double_cpu(), &quot;Must be a long register.&quot;);
1057           __ load_const_optimized(to_reg-&gt;as_register_lo(), jlong_cast(c-&gt;as_jdouble()), R0);
1058         }
1059       }
1060       break;
1061 
1062     default:
1063       ShouldNotReachHere();
1064   }
1065 }
1066 
1067 
1068 Address LIR_Assembler::as_Address(LIR_Address* addr) {
1069   Unimplemented(); return Address();
1070 }
1071 
1072 
1073 inline RegisterOrConstant index_or_disp(LIR_Address* addr) {
1074   if (addr-&gt;index()-&gt;is_illegal()) {
1075     return (RegisterOrConstant)(addr-&gt;disp());
1076   } else {
1077     return (RegisterOrConstant)(addr-&gt;index()-&gt;as_pointer_register());
1078   }
1079 }
1080 
1081 
1082 void LIR_Assembler::stack2stack(LIR_Opr src, LIR_Opr dest, BasicType type) {
1083   const Register tmp = R0;
1084   switch (type) {
1085     case T_INT:
1086     case T_FLOAT: {
1087       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1088       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1089       __ lwz(tmp, from.disp(), from.base());
1090       __ stw(tmp, to.disp(), to.base());
1091       break;
1092     }
1093     case T_ADDRESS:
1094     case T_OBJECT: {
1095       Address from = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1096       Address to   = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1097       __ ld(tmp, from.disp(), from.base());
1098       __ std(tmp, to.disp(), to.base());
1099       break;
1100     }
1101     case T_LONG:
1102     case T_DOUBLE: {
1103       Address from = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1104       Address to   = frame_map()-&gt;address_for_double_slot(dest-&gt;double_stack_ix());
1105       __ ld(tmp, from.disp(), from.base());
1106       __ std(tmp, to.disp(), to.base());
1107       break;
1108     }
1109 
1110     default:
1111       ShouldNotReachHere();
1112   }
1113 }
1114 
1115 
1116 Address LIR_Assembler::as_Address_hi(LIR_Address* addr) {
1117   Unimplemented(); return Address();
1118 }
1119 
1120 
1121 Address LIR_Assembler::as_Address_lo(LIR_Address* addr) {
1122   Unimplemented(); return Address();
1123 }
1124 
1125 
1126 void LIR_Assembler::mem2reg(LIR_Opr src_opr, LIR_Opr dest, BasicType type,
1127                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool wide, bool unaligned) {
1128 
1129   assert(type != T_METADATA, &quot;load of metadata ptr not supported&quot;);
1130   LIR_Address* addr = src_opr-&gt;as_address_ptr();
1131   LIR_Opr to_reg = dest;
1132 
1133   Register src = addr-&gt;base()-&gt;as_pointer_register();
1134   Register disp_reg = noreg;
1135   int disp_value = addr-&gt;disp();
1136   bool needs_patching = (patch_code != lir_patch_none);
1137   // null check for large offsets in LIRGenerator::do_LoadField
1138   bool needs_explicit_null_check = !os::zero_page_read_protected() || !ImplicitNullChecks;
1139 
1140   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1141     explicit_null_check(src, info);
1142   }
1143 
1144   if (addr-&gt;base()-&gt;type() == T_OBJECT) {
1145     __ verify_oop(src, FILE_AND_LINE);
1146   }
1147 
1148   PatchingStub* patch = NULL;
1149   if (needs_patching) {
1150     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1151     assert(!to_reg-&gt;is_double_cpu() ||
1152            patch_code == lir_patch_none ||
1153            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1154   }
1155 
1156   if (addr-&gt;index()-&gt;is_illegal()) {
1157     if (!Assembler::is_simm16(disp_value)) {
1158       if (needs_patching) {
1159         __ load_const32(R0, 0); // patchable int
1160       } else {
1161         __ load_const_optimized(R0, disp_value);
1162       }
1163       disp_reg = R0;
1164     }
1165   } else {
1166     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1167     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1168   }
1169 
1170   // Remember the offset of the load. The patching_epilog must be done
1171   // before the call to add_debug_info, otherwise the PcDescs don&#39;t get
1172   // entered in increasing order.
1173   int offset;
1174 
1175   if (disp_reg == noreg) {
1176     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1177     offset = load(src, disp_value, to_reg, type, wide, unaligned);
1178   } else {
1179     assert(!unaligned, &quot;unexpected&quot;);
1180     offset = load(src, disp_reg, to_reg, type, wide);
1181   }
1182 
1183   if (patch != NULL) {
1184     patching_epilog(patch, patch_code, src, info);
1185   }
1186   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1187     add_debug_info_for_null_check(offset, info);
1188   }
1189 }
1190 
1191 
1192 void LIR_Assembler::stack2reg(LIR_Opr src, LIR_Opr dest, BasicType type) {
1193   Address addr;
1194   if (src-&gt;is_single_word()) {
1195     addr = frame_map()-&gt;address_for_slot(src-&gt;single_stack_ix());
1196   } else if (src-&gt;is_double_word())  {
1197     addr = frame_map()-&gt;address_for_double_slot(src-&gt;double_stack_ix());
1198   }
1199 
1200   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1201   load(addr.base(), addr.disp(), dest, dest-&gt;type(), true /*wide*/, unaligned);
1202 }
1203 
1204 
1205 void LIR_Assembler::reg2stack(LIR_Opr from_reg, LIR_Opr dest, BasicType type, bool pop_fpu_stack) {
1206   Address addr;
1207   if (dest-&gt;is_single_word()) {
1208     addr = frame_map()-&gt;address_for_slot(dest-&gt;single_stack_ix());
1209   } else if (dest-&gt;is_double_word())  {
1210     addr = frame_map()-&gt;address_for_slot(dest-&gt;double_stack_ix());
1211   }
1212   bool unaligned = (addr.disp() - STACK_BIAS) % 8 != 0;
1213   store(from_reg, addr.base(), addr.disp(), from_reg-&gt;type(), true /*wide*/, unaligned);
1214 }
1215 
1216 
1217 void LIR_Assembler::reg2reg(LIR_Opr from_reg, LIR_Opr to_reg) {
1218   if (from_reg-&gt;is_float_kind() &amp;&amp; to_reg-&gt;is_float_kind()) {
1219     if (from_reg-&gt;is_double_fpu()) {
1220       // double to double moves
1221       assert(to_reg-&gt;is_double_fpu(), &quot;should match&quot;);
1222       __ fmr_if_needed(to_reg-&gt;as_double_reg(), from_reg-&gt;as_double_reg());
1223     } else {
1224       // float to float moves
1225       assert(to_reg-&gt;is_single_fpu(), &quot;should match&quot;);
1226       __ fmr_if_needed(to_reg-&gt;as_float_reg(), from_reg-&gt;as_float_reg());
1227     }
1228   } else if (!from_reg-&gt;is_float_kind() &amp;&amp; !to_reg-&gt;is_float_kind()) {
1229     if (from_reg-&gt;is_double_cpu()) {
1230       __ mr_if_needed(to_reg-&gt;as_pointer_register(), from_reg-&gt;as_pointer_register());
1231     } else if (to_reg-&gt;is_double_cpu()) {
1232       // int to int moves
1233       __ mr_if_needed(to_reg-&gt;as_register_lo(), from_reg-&gt;as_register());
1234     } else {
1235       // int to int moves
1236       __ mr_if_needed(to_reg-&gt;as_register(), from_reg-&gt;as_register());
1237     }
1238   } else {
1239     ShouldNotReachHere();
1240   }
1241   if (is_reference_type(to_reg-&gt;type())) {
1242     __ verify_oop(to_reg-&gt;as_register(), FILE_AND_LINE);
1243   }
1244 }
1245 
1246 
1247 void LIR_Assembler::reg2mem(LIR_Opr from_reg, LIR_Opr dest, BasicType type,
1248                             LIR_PatchCode patch_code, CodeEmitInfo* info, bool pop_fpu_stack,
1249                             bool wide, bool unaligned) {
1250   assert(type != T_METADATA, &quot;store of metadata ptr not supported&quot;);
1251   LIR_Address* addr = dest-&gt;as_address_ptr();
1252 
1253   Register src = addr-&gt;base()-&gt;as_pointer_register();
1254   Register disp_reg = noreg;
1255   int disp_value = addr-&gt;disp();
1256   bool needs_patching = (patch_code != lir_patch_none);
1257   bool compress_oop = (is_reference_type(type)) &amp;&amp; UseCompressedOops &amp;&amp; !wide &amp;&amp;
1258                       CompressedOops::mode() != CompressedOops::UnscaledNarrowOop;
1259   bool load_disp = addr-&gt;index()-&gt;is_illegal() &amp;&amp; !Assembler::is_simm16(disp_value);
1260   bool use_R29 = compress_oop &amp;&amp; load_disp; // Avoid register conflict, also do null check before killing R29.
1261   // Null check for large offsets in LIRGenerator::do_StoreField.
1262   bool needs_explicit_null_check = !ImplicitNullChecks || use_R29;
1263 
1264   if (info != NULL &amp;&amp; needs_explicit_null_check) {
1265     explicit_null_check(src, info);
1266   }
1267 
1268   if (addr-&gt;base()-&gt;is_oop_register()) {
1269     __ verify_oop(src, FILE_AND_LINE);
1270   }
1271 
1272   PatchingStub* patch = NULL;
1273   if (needs_patching) {
1274     patch = new PatchingStub(_masm, PatchingStub::access_field_id);
1275     assert(!from_reg-&gt;is_double_cpu() ||
1276            patch_code == lir_patch_none ||
1277            patch_code == lir_patch_normal, &quot;patching doesn&#39;t match register&quot;);
1278   }
1279 
1280   if (addr-&gt;index()-&gt;is_illegal()) {
1281     if (load_disp) {
1282       disp_reg = use_R29 ? R29_TOC : R0;
1283       if (needs_patching) {
1284         __ load_const32(disp_reg, 0); // patchable int
1285       } else {
1286         __ load_const_optimized(disp_reg, disp_value);
1287       }
1288     }
1289   } else {
1290     disp_reg = addr-&gt;index()-&gt;as_pointer_register();
1291     assert(disp_value == 0, &quot;can&#39;t handle 3 operand addresses&quot;);
1292   }
1293 
1294   // remember the offset of the store. The patching_epilog must be done
1295   // before the call to add_debug_info_for_null_check, otherwise the PcDescs don&#39;t get
1296   // entered in increasing order.
1297   int offset;
1298 
1299   if (compress_oop) {
1300     Register co = __ encode_heap_oop(R0, from_reg-&gt;as_register());
1301     from_reg = FrameMap::as_opr(co);
1302   }
1303 
1304   if (disp_reg == noreg) {
1305     assert(Assembler::is_simm16(disp_value), &quot;should have set this up&quot;);
1306     offset = store(from_reg, src, disp_value, type, wide, unaligned);
1307   } else {
1308     assert(!unaligned, &quot;unexpected&quot;);
1309     offset = store(from_reg, src, disp_reg, type, wide);
1310   }
1311 
1312   if (use_R29) {
1313     __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); // reinit
1314   }
1315 
1316   if (patch != NULL) {
1317     patching_epilog(patch, patch_code, src, info);
1318   }
1319 
1320   if (info != NULL &amp;&amp; !needs_explicit_null_check) {
1321     add_debug_info_for_null_check(offset, info);
1322   }
1323 }
1324 
1325 
1326 void LIR_Assembler::return_op(LIR_Opr result) {
1327   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
1328   const Register polling_page     = R12;
1329 
1330   // Pop the stack before the safepoint code.
1331   int frame_size = initial_frame_size_in_bytes();
1332   if (Assembler::is_simm(frame_size, 16)) {
1333     __ addi(R1_SP, R1_SP, frame_size);
1334   } else {
1335     __ pop_frame();
1336   }
1337 
<a name="2" id="anc2"></a><span class="line-modified">1338   __ ld(polling_page, in_bytes(Thread::polling_page_offset()), R16_thread);</span>




1339 
1340   // Restore return pc relative to callers&#39; sp.
1341   __ ld(return_pc, _abi(lr), R1_SP);
1342   // Move return pc to LR.
1343   __ mtlr(return_pc);
1344 
1345   if (StackReservedPages &gt; 0 &amp;&amp; compilation()-&gt;has_reserved_stack_access()) {
1346     __ reserved_stack_check(return_pc);
1347   }
1348 
1349   // We need to mark the code position where the load from the safepoint
1350   // polling page was emitted as relocInfo::poll_return_type here.
1351   __ relocate(relocInfo::poll_return_type);
1352   __ load_from_polling_page(polling_page);
1353 
1354   // Return.
1355   __ blr();
1356 }
1357 
1358 
1359 int LIR_Assembler::safepoint_poll(LIR_Opr tmp, CodeEmitInfo* info) {
1360   const Register poll_addr = tmp-&gt;as_register();
<a name="3" id="anc3"></a><span class="line-modified">1361   __ ld(poll_addr, in_bytes(Thread::polling_page_offset()), R16_thread);</span>




1362   if (info != NULL) {
1363     add_debug_info_for_branch(info);
1364   }
1365   int offset = __ offset();
1366   __ relocate(relocInfo::poll_type);
1367   __ load_from_polling_page(poll_addr);
1368 
1369   return offset;
1370 }
1371 
1372 
1373 void LIR_Assembler::emit_static_call_stub() {
1374   address call_pc = __ pc();
1375   address stub = __ start_a_stub(static_call_stub_size());
1376   if (stub == NULL) {
1377     bailout(&quot;static call stub overflow&quot;);
1378     return;
1379   }
1380 
1381   // For java_to_interp stubs we use R11_scratch1 as scratch register
1382   // and in call trampoline stubs we use R12_scratch2. This way we
1383   // can distinguish them (see is_NativeCallTrampolineStub_at()).
1384   const Register reg_scratch = R11_scratch1;
1385 
1386   // Create a static stub relocation which relates this stub
1387   // with the call instruction at insts_call_instruction_offset in the
1388   // instructions code-section.
1389   int start = __ offset();
1390   __ relocate(static_stub_Relocation::spec(call_pc));
1391 
1392   // Now, create the stub&#39;s code:
1393   // - load the TOC
1394   // - load the inline cache oop from the constant pool
1395   // - load the call target from the constant pool
1396   // - call
1397   __ calculate_address_from_global_toc(reg_scratch, __ method_toc());
1398   AddressLiteral ic = __ allocate_metadata_address((Metadata *)NULL);
1399   bool success = __ load_const_from_method_toc(R19_inline_cache_reg, ic, reg_scratch, /*fixed_size*/ true);
1400 
1401   if (ReoptimizeCallSequences) {
1402     __ b64_patchable((address)-1, relocInfo::none);
1403   } else {
1404     AddressLiteral a((address)-1);
1405     success = success &amp;&amp; __ load_const_from_method_toc(reg_scratch, a, reg_scratch, /*fixed_size*/ true);
1406     __ mtctr(reg_scratch);
1407     __ bctr();
1408   }
1409   if (!success) {
1410     bailout(&quot;const section overflow&quot;);
1411     return;
1412   }
1413 
1414   assert(__ offset() - start &lt;= static_call_stub_size(), &quot;stub too big&quot;);
1415   __ end_a_stub();
1416 }
1417 
1418 
1419 void LIR_Assembler::comp_op(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Op2* op) {
1420   bool unsigned_comp = (condition == lir_cond_belowEqual || condition == lir_cond_aboveEqual);
1421   if (opr1-&gt;is_single_fpu()) {
1422     __ fcmpu(BOOL_RESULT, opr1-&gt;as_float_reg(), opr2-&gt;as_float_reg());
1423   } else if (opr1-&gt;is_double_fpu()) {
1424     __ fcmpu(BOOL_RESULT, opr1-&gt;as_double_reg(), opr2-&gt;as_double_reg());
1425   } else if (opr1-&gt;is_single_cpu()) {
1426     if (opr2-&gt;is_constant()) {
1427       switch (opr2-&gt;as_constant_ptr()-&gt;type()) {
1428         case T_INT:
1429           {
1430             jint con = opr2-&gt;as_constant_ptr()-&gt;as_jint();
1431             if (unsigned_comp) {
1432               if (Assembler::is_uimm(con, 16)) {
1433                 __ cmplwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1434               } else {
1435                 __ load_const_optimized(R0, con);
1436                 __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1437               }
1438             } else {
1439               if (Assembler::is_simm(con, 16)) {
1440                 __ cmpwi(BOOL_RESULT, opr1-&gt;as_register(), con);
1441               } else {
1442                 __ load_const_optimized(R0, con);
1443                 __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), R0);
1444               }
1445             }
1446           }
1447           break;
1448 
1449         case T_OBJECT:
1450           // There are only equal/notequal comparisons on objects.
1451           {
1452             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1453             jobject con = opr2-&gt;as_constant_ptr()-&gt;as_jobject();
1454             if (con == NULL) {
1455               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);
1456             } else {
1457               jobject2reg(con, R0);
1458               __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), R0);
1459             }
1460           }
1461           break;
1462 
1463         case T_METADATA:
1464           // We only need, for now, comparison with NULL for metadata.
1465           {
1466             assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1467             Metadata* p = opr2-&gt;as_constant_ptr()-&gt;as_metadata();
1468             if (p == NULL) {
1469               __ cmpdi(BOOL_RESULT, opr1-&gt;as_register(), 0);
1470             } else {
1471               ShouldNotReachHere();
1472             }
1473           }
1474           break;
1475 
1476         default:
1477           ShouldNotReachHere();
1478           break;
1479       }
1480     } else {
1481       assert(opr1-&gt;type() != T_ADDRESS &amp;&amp; opr2-&gt;type() != T_ADDRESS, &quot;currently unsupported&quot;);
1482       if (is_reference_type(opr1-&gt;type())) {
1483         // There are only equal/notequal comparisons on objects.
1484         assert(condition == lir_cond_equal || condition == lir_cond_notEqual, &quot;oops&quot;);
1485         __ cmpd(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1486       } else {
1487         if (unsigned_comp) {
1488           __ cmplw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1489         } else {
1490           __ cmpw(BOOL_RESULT, opr1-&gt;as_register(), opr2-&gt;as_register());
1491         }
1492       }
1493     }
1494   } else if (opr1-&gt;is_double_cpu()) {
1495     if (opr2-&gt;is_constant()) {
1496       jlong con = opr2-&gt;as_constant_ptr()-&gt;as_jlong();
1497       if (unsigned_comp) {
1498         if (Assembler::is_uimm(con, 16)) {
1499           __ cmpldi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1500         } else {
1501           __ load_const_optimized(R0, con);
1502           __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1503         }
1504       } else {
1505         if (Assembler::is_simm(con, 16)) {
1506           __ cmpdi(BOOL_RESULT, opr1-&gt;as_register_lo(), con);
1507         } else {
1508           __ load_const_optimized(R0, con);
1509           __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), R0);
1510         }
1511       }
1512     } else if (opr2-&gt;is_register()) {
1513       if (unsigned_comp) {
1514         __ cmpld(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1515       } else {
1516         __ cmpd(BOOL_RESULT, opr1-&gt;as_register_lo(), opr2-&gt;as_register_lo());
1517       }
1518     } else {
1519       ShouldNotReachHere();
1520     }
1521   } else {
1522     ShouldNotReachHere();
1523   }
1524 }
1525 
1526 
1527 void LIR_Assembler::comp_fl2i(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dst, LIR_Op2* op){
1528   const Register Rdst = dst-&gt;as_register();
1529   Label done;
1530   if (code == lir_cmp_fd2i || code == lir_ucmp_fd2i) {
1531     bool is_unordered_less = (code == lir_ucmp_fd2i);
1532     if (left-&gt;is_single_fpu()) {
1533       __ fcmpu(CCR0, left-&gt;as_float_reg(), right-&gt;as_float_reg());
1534     } else if (left-&gt;is_double_fpu()) {
1535       __ fcmpu(CCR0, left-&gt;as_double_reg(), right-&gt;as_double_reg());
1536     } else {
1537       ShouldNotReachHere();
1538     }
1539     __ li(Rdst, is_unordered_less ? -1 : 1);
1540     __ bso(CCR0, done);
1541   } else if (code == lir_cmp_l2i) {
1542     __ cmpd(CCR0, left-&gt;as_register_lo(), right-&gt;as_register_lo());
1543   } else {
1544     ShouldNotReachHere();
1545   }
1546   __ mfcr(R0); // set bit 32..33 as follows: &lt;: 0b10, =: 0b00, &gt;: 0b01
1547   __ srwi(Rdst, R0, 30);
1548   __ srawi(R0, R0, 31);
1549   __ orr(Rdst, R0, Rdst); // set result as follows: &lt;: -1, =: 0, &gt;: 1
1550   __ bind(done);
1551 }
1552 
1553 
1554 inline void load_to_reg(LIR_Assembler *lasm, LIR_Opr src, LIR_Opr dst) {
1555   if (src-&gt;is_constant()) {
1556     lasm-&gt;const2reg(src, dst, lir_patch_none, NULL);
1557   } else if (src-&gt;is_register()) {
1558     lasm-&gt;reg2reg(src, dst);
1559   } else if (src-&gt;is_stack()) {
1560     lasm-&gt;stack2reg(src, dst, dst-&gt;type());
1561   } else {
1562     ShouldNotReachHere();
1563   }
1564 }
1565 
1566 
1567 void LIR_Assembler::cmove(LIR_Condition condition, LIR_Opr opr1, LIR_Opr opr2, LIR_Opr result, BasicType type) {
1568   if (opr1-&gt;is_equal(opr2) || opr1-&gt;is_same_register(opr2)) {
1569     load_to_reg(this, opr1, result); // Condition doesn&#39;t matter.
1570     return;
1571   }
1572 
1573   bool positive = false;
1574   Assembler::Condition cond = Assembler::equal;
1575   switch (condition) {
1576     case lir_cond_equal:        positive = true ; cond = Assembler::equal  ; break;
1577     case lir_cond_notEqual:     positive = false; cond = Assembler::equal  ; break;
1578     case lir_cond_less:         positive = true ; cond = Assembler::less   ; break;
1579     case lir_cond_belowEqual:
1580     case lir_cond_lessEqual:    positive = false; cond = Assembler::greater; break;
1581     case lir_cond_greater:      positive = true ; cond = Assembler::greater; break;
1582     case lir_cond_aboveEqual:
1583     case lir_cond_greaterEqual: positive = false; cond = Assembler::less   ; break;
1584     default:                    ShouldNotReachHere();
1585   }
1586 
1587   // Try to use isel on &gt;=Power7.
1588   if (VM_Version::has_isel() &amp;&amp; result-&gt;is_cpu_register()) {
1589     bool o1_is_reg = opr1-&gt;is_cpu_register(), o2_is_reg = opr2-&gt;is_cpu_register();
1590     const Register result_reg = result-&gt;is_single_cpu() ? result-&gt;as_register() : result-&gt;as_register_lo();
1591 
1592     // We can use result_reg to load one operand if not already in register.
1593     Register first  = o1_is_reg ? (opr1-&gt;is_single_cpu() ? opr1-&gt;as_register() : opr1-&gt;as_register_lo()) : result_reg,
1594              second = o2_is_reg ? (opr2-&gt;is_single_cpu() ? opr2-&gt;as_register() : opr2-&gt;as_register_lo()) : result_reg;
1595 
1596     if (first != second) {
1597       if (!o1_is_reg) {
1598         load_to_reg(this, opr1, result);
1599       }
1600 
1601       if (!o2_is_reg) {
1602         load_to_reg(this, opr2, result);
1603       }
1604 
1605       __ isel(result_reg, BOOL_RESULT, cond, !positive, first, second);
1606       return;
1607     }
1608   } // isel
1609 
1610   load_to_reg(this, opr1, result);
1611 
1612   Label skip;
1613   int bo = positive ? Assembler::bcondCRbiIs1 : Assembler::bcondCRbiIs0;
1614   int bi = Assembler::bi0(BOOL_RESULT, cond);
1615   __ bc(bo, bi, skip);
1616 
1617   load_to_reg(this, opr2, result);
1618   __ bind(skip);
1619 }
1620 
1621 
1622 void LIR_Assembler::arith_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest,
1623                              CodeEmitInfo* info, bool pop_fpu_stack) {
1624   assert(info == NULL, &quot;unused on this code path&quot;);
1625   assert(left-&gt;is_register(), &quot;wrong items state&quot;);
1626   assert(dest-&gt;is_register(), &quot;wrong items state&quot;);
1627 
1628   if (right-&gt;is_register()) {
1629     if (dest-&gt;is_float_kind()) {
1630 
1631       FloatRegister lreg, rreg, res;
1632       if (right-&gt;is_single_fpu()) {
1633         lreg = left-&gt;as_float_reg();
1634         rreg = right-&gt;as_float_reg();
1635         res  = dest-&gt;as_float_reg();
1636         switch (code) {
1637           case lir_add: __ fadds(res, lreg, rreg); break;
1638           case lir_sub: __ fsubs(res, lreg, rreg); break;
1639           case lir_mul: // fall through
1640           case lir_mul_strictfp: __ fmuls(res, lreg, rreg); break;
1641           case lir_div: // fall through
1642           case lir_div_strictfp: __ fdivs(res, lreg, rreg); break;
1643           default: ShouldNotReachHere();
1644         }
1645       } else {
1646         lreg = left-&gt;as_double_reg();
1647         rreg = right-&gt;as_double_reg();
1648         res  = dest-&gt;as_double_reg();
1649         switch (code) {
1650           case lir_add: __ fadd(res, lreg, rreg); break;
1651           case lir_sub: __ fsub(res, lreg, rreg); break;
1652           case lir_mul: // fall through
1653           case lir_mul_strictfp: __ fmul(res, lreg, rreg); break;
1654           case lir_div: // fall through
1655           case lir_div_strictfp: __ fdiv(res, lreg, rreg); break;
1656           default: ShouldNotReachHere();
1657         }
1658       }
1659 
1660     } else if (dest-&gt;is_double_cpu()) {
1661 
1662       Register dst_lo = dest-&gt;as_register_lo();
1663       Register op1_lo = left-&gt;as_pointer_register();
1664       Register op2_lo = right-&gt;as_pointer_register();
1665 
1666       switch (code) {
1667         case lir_add: __ add(dst_lo, op1_lo, op2_lo); break;
1668         case lir_sub: __ sub(dst_lo, op1_lo, op2_lo); break;
1669         case lir_mul: __ mulld(dst_lo, op1_lo, op2_lo); break;
1670         default: ShouldNotReachHere();
1671       }
1672     } else {
1673       assert (right-&gt;is_single_cpu(), &quot;Just Checking&quot;);
1674 
1675       Register lreg = left-&gt;as_register();
1676       Register res  = dest-&gt;as_register();
1677       Register rreg = right-&gt;as_register();
1678       switch (code) {
1679         case lir_add:  __ add  (res, lreg, rreg); break;
1680         case lir_sub:  __ sub  (res, lreg, rreg); break;
1681         case lir_mul:  __ mullw(res, lreg, rreg); break;
1682         default: ShouldNotReachHere();
1683       }
1684     }
1685   } else {
1686     assert (right-&gt;is_constant(), &quot;must be constant&quot;);
1687 
1688     if (dest-&gt;is_single_cpu()) {
1689       Register lreg = left-&gt;as_register();
1690       Register res  = dest-&gt;as_register();
1691       int    simm16 = right-&gt;as_constant_ptr()-&gt;as_jint();
1692 
1693       switch (code) {
1694         case lir_sub:  assert(Assembler::is_simm16(-simm16), &quot;cannot encode&quot;); // see do_ArithmeticOp_Int
1695                        simm16 = -simm16;
1696         case lir_add:  if (res == lreg &amp;&amp; simm16 == 0) break;
1697                        __ addi(res, lreg, simm16); break;
1698         case lir_mul:  if (res == lreg &amp;&amp; simm16 == 1) break;
1699                        __ mulli(res, lreg, simm16); break;
1700         default: ShouldNotReachHere();
1701       }
1702     } else {
1703       Register lreg = left-&gt;as_pointer_register();
1704       Register res  = dest-&gt;as_register_lo();
1705       long con = right-&gt;as_constant_ptr()-&gt;as_jlong();
1706       assert(Assembler::is_simm16(con), &quot;must be simm16&quot;);
1707 
1708       switch (code) {
1709         case lir_sub:  assert(Assembler::is_simm16(-con), &quot;cannot encode&quot;);  // see do_ArithmeticOp_Long
1710                        con = -con;
1711         case lir_add:  if (res == lreg &amp;&amp; con == 0) break;
1712                        __ addi(res, lreg, (int)con); break;
1713         case lir_mul:  if (res == lreg &amp;&amp; con == 1) break;
1714                        __ mulli(res, lreg, (int)con); break;
1715         default: ShouldNotReachHere();
1716       }
1717     }
1718   }
1719 }
1720 
1721 
1722 void LIR_Assembler::intrinsic_op(LIR_Code code, LIR_Opr value, LIR_Opr thread, LIR_Opr dest, LIR_Op* op) {
1723   switch (code) {
1724     case lir_sqrt: {
1725       __ fsqrt(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1726       break;
1727     }
1728     case lir_abs: {
1729       __ fabs(dest-&gt;as_double_reg(), value-&gt;as_double_reg());
1730       break;
1731     }
1732     default: {
1733       ShouldNotReachHere();
1734       break;
1735     }
1736   }
1737 }
1738 
1739 
1740 void LIR_Assembler::logic_op(LIR_Code code, LIR_Opr left, LIR_Opr right, LIR_Opr dest) {
1741   if (right-&gt;is_constant()) { // see do_LogicOp
1742     long uimm;
1743     Register d, l;
1744     if (dest-&gt;is_single_cpu()) {
1745       uimm = right-&gt;as_constant_ptr()-&gt;as_jint();
1746       d = dest-&gt;as_register();
1747       l = left-&gt;as_register();
1748     } else {
1749       uimm = right-&gt;as_constant_ptr()-&gt;as_jlong();
1750       d = dest-&gt;as_register_lo();
1751       l = left-&gt;as_register_lo();
1752     }
1753     long uimms  = (unsigned long)uimm &gt;&gt; 16,
1754          uimmss = (unsigned long)uimm &gt;&gt; 32;
1755 
1756     switch (code) {
1757       case lir_logic_and:
1758         if (uimmss != 0 || (uimms != 0 &amp;&amp; (uimm &amp; 0xFFFF) != 0) || is_power_of_2(uimm)) {
1759           __ andi(d, l, uimm); // special cases
1760         } else if (uimms != 0) { __ andis_(d, l, uimms); }
1761         else { __ andi_(d, l, uimm); }
1762         break;
1763 
1764       case lir_logic_or:
1765         if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ oris(d, l, uimms); }
1766         else { __ ori(d, l, uimm); }
1767         break;
1768 
1769       case lir_logic_xor:
1770         if (uimm == -1) { __ nand(d, l, l); } // special case
1771         else if (uimms != 0) { assert((uimm &amp; 0xFFFF) == 0, &quot;sanity&quot;); __ xoris(d, l, uimms); }
1772         else { __ xori(d, l, uimm); }
1773         break;
1774 
1775       default: ShouldNotReachHere();
1776     }
1777   } else {
1778     assert(right-&gt;is_register(), &quot;right should be in register&quot;);
1779 
1780     if (dest-&gt;is_single_cpu()) {
1781       switch (code) {
1782         case lir_logic_and: __ andr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1783         case lir_logic_or:  __ orr (dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1784         case lir_logic_xor: __ xorr(dest-&gt;as_register(), left-&gt;as_register(), right-&gt;as_register()); break;
1785         default: ShouldNotReachHere();
1786       }
1787     } else {
1788       Register l = (left-&gt;is_single_cpu() &amp;&amp; left-&gt;is_oop_register()) ? left-&gt;as_register() :
1789                                                                         left-&gt;as_register_lo();
1790       Register r = (right-&gt;is_single_cpu() &amp;&amp; right-&gt;is_oop_register()) ? right-&gt;as_register() :
1791                                                                           right-&gt;as_register_lo();
1792 
1793       switch (code) {
1794         case lir_logic_and: __ andr(dest-&gt;as_register_lo(), l, r); break;
1795         case lir_logic_or:  __ orr (dest-&gt;as_register_lo(), l, r); break;
1796         case lir_logic_xor: __ xorr(dest-&gt;as_register_lo(), l, r); break;
1797         default: ShouldNotReachHere();
1798       }
1799     }
1800   }
1801 }
1802 
1803 
1804 int LIR_Assembler::shift_amount(BasicType t) {
1805   int elem_size = type2aelembytes(t);
1806   switch (elem_size) {
1807     case 1 : return 0;
1808     case 2 : return 1;
1809     case 4 : return 2;
1810     case 8 : return 3;
1811   }
1812   ShouldNotReachHere();
1813   return -1;
1814 }
1815 
1816 
1817 void LIR_Assembler::throw_op(LIR_Opr exceptionPC, LIR_Opr exceptionOop, CodeEmitInfo* info) {
1818   info-&gt;add_register_oop(exceptionOop);
1819 
1820   // Reuse the debug info from the safepoint poll for the throw op itself.
1821   address pc_for_athrow = __ pc();
1822   int pc_for_athrow_offset = __ offset();
1823   //RelocationHolder rspec = internal_word_Relocation::spec(pc_for_athrow);
1824   //__ relocate(rspec);
1825   //__ load_const(exceptionPC-&gt;as_register(), pc_for_athrow, R0);
1826   __ calculate_address_from_global_toc(exceptionPC-&gt;as_register(), pc_for_athrow, true, true, /*add_relocation*/ true);
1827   add_call_info(pc_for_athrow_offset, info); // for exception handler
1828 
1829   address stub = Runtime1::entry_for(compilation()-&gt;has_fpu_code() ? Runtime1::handle_exception_id
1830                                                                    : Runtime1::handle_exception_nofpu_id);
1831   //__ load_const_optimized(R0, stub);
1832   __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(stub));
1833   __ mtctr(R0);
1834   __ bctr();
1835 }
1836 
1837 
1838 void LIR_Assembler::unwind_op(LIR_Opr exceptionOop) {
1839   // Note: Not used with EnableDebuggingOnDemand.
1840   assert(exceptionOop-&gt;as_register() == R3, &quot;should match&quot;);
1841   __ b(_unwind_handler_entry);
1842 }
1843 
1844 
1845 void LIR_Assembler::emit_arraycopy(LIR_OpArrayCopy* op) {
1846   Register src = op-&gt;src()-&gt;as_register();
1847   Register dst = op-&gt;dst()-&gt;as_register();
1848   Register src_pos = op-&gt;src_pos()-&gt;as_register();
1849   Register dst_pos = op-&gt;dst_pos()-&gt;as_register();
1850   Register length  = op-&gt;length()-&gt;as_register();
1851   Register tmp = op-&gt;tmp()-&gt;as_register();
1852   Register tmp2 = R0;
1853 
1854   int flags = op-&gt;flags();
1855   ciArrayKlass* default_type = op-&gt;expected_type();
1856   BasicType basic_type = default_type != NULL ? default_type-&gt;element_type()-&gt;basic_type() : T_ILLEGAL;
1857   if (basic_type == T_ARRAY) basic_type = T_OBJECT;
1858 
1859   // Set up the arraycopy stub information.
1860   ArrayCopyStub* stub = op-&gt;stub();
1861   const int frame_resize = frame::abi_reg_args_size - sizeof(frame::jit_abi); // C calls need larger frame.
1862 
1863   // Always do stub if no type information is available. It&#39;s ok if
1864   // the known type isn&#39;t loaded since the code sanity checks
1865   // in debug mode and the type isn&#39;t required when we know the exact type
1866   // also check that the type is an array type.
1867   if (op-&gt;expected_type() == NULL) {
1868     assert(src-&gt;is_nonvolatile() &amp;&amp; src_pos-&gt;is_nonvolatile() &amp;&amp; dst-&gt;is_nonvolatile() &amp;&amp; dst_pos-&gt;is_nonvolatile() &amp;&amp;
1869            length-&gt;is_nonvolatile(), &quot;must preserve&quot;);
1870     address copyfunc_addr = StubRoutines::generic_arraycopy();
1871     assert(copyfunc_addr != NULL, &quot;generic arraycopy stub required&quot;);
1872 
1873     // 3 parms are int. Convert to long.
1874     __ mr(R3_ARG1, src);
1875     __ extsw(R4_ARG2, src_pos);
1876     __ mr(R5_ARG3, dst);
1877     __ extsw(R6_ARG4, dst_pos);
1878     __ extsw(R7_ARG5, length);
1879 
1880 #ifndef PRODUCT
1881     if (PrintC1Statistics) {
1882       address counter = (address)&amp;Runtime1::_generic_arraycopystub_cnt;
1883       int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
1884       __ lwz(R11_scratch1, simm16_offs, tmp);
1885       __ addi(R11_scratch1, R11_scratch1, 1);
1886       __ stw(R11_scratch1, simm16_offs, tmp);
1887     }
1888 #endif
1889     __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
1890 
1891     __ nand(tmp, R3_RET, R3_RET);
1892     __ subf(length, tmp, length);
1893     __ add(src_pos, tmp, src_pos);
1894     __ add(dst_pos, tmp, dst_pos);
1895 
1896     __ cmpwi(CCR0, R3_RET, 0);
1897     __ bc_far_optimized(Assembler::bcondCRbiIs1, __ bi0(CCR0, Assembler::less), *stub-&gt;entry());
1898     __ bind(*stub-&gt;continuation());
1899     return;
1900   }
1901 
1902   assert(default_type != NULL &amp;&amp; default_type-&gt;is_array_klass(), &quot;must be true at this point&quot;);
1903   Label cont, slow, copyfunc;
1904 
1905   bool simple_check_flag_set = flags &amp; (LIR_OpArrayCopy::src_null_check |
1906                                         LIR_OpArrayCopy::dst_null_check |
1907                                         LIR_OpArrayCopy::src_pos_positive_check |
1908                                         LIR_OpArrayCopy::dst_pos_positive_check |
1909                                         LIR_OpArrayCopy::length_positive_check);
1910 
1911   // Use only one conditional branch for simple checks.
1912   if (simple_check_flag_set) {
1913     ConditionRegister combined_check = CCR1, tmp_check = CCR1;
1914 
1915     // Make sure src and dst are non-null.
1916     if (flags &amp; LIR_OpArrayCopy::src_null_check) {
1917       __ cmpdi(combined_check, src, 0);
1918       tmp_check = CCR0;
1919     }
1920 
1921     if (flags &amp; LIR_OpArrayCopy::dst_null_check) {
1922       __ cmpdi(tmp_check, dst, 0);
1923       if (tmp_check != combined_check) {
1924         __ cror(combined_check, Assembler::equal, tmp_check, Assembler::equal);
1925       }
1926       tmp_check = CCR0;
1927     }
1928 
1929     // Clear combined_check.eq if not already used.
1930     if (tmp_check == combined_check) {
1931       __ crandc(combined_check, Assembler::equal, combined_check, Assembler::equal);
1932       tmp_check = CCR0;
1933     }
1934 
1935     if (flags &amp; LIR_OpArrayCopy::src_pos_positive_check) {
1936       // Test src_pos register.
1937       __ cmpwi(tmp_check, src_pos, 0);
1938       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1939     }
1940 
1941     if (flags &amp; LIR_OpArrayCopy::dst_pos_positive_check) {
1942       // Test dst_pos register.
1943       __ cmpwi(tmp_check, dst_pos, 0);
1944       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1945     }
1946 
1947     if (flags &amp; LIR_OpArrayCopy::length_positive_check) {
1948       // Make sure length isn&#39;t negative.
1949       __ cmpwi(tmp_check, length, 0);
1950       __ cror(combined_check, Assembler::equal, tmp_check, Assembler::less);
1951     }
1952 
1953     __ beq(combined_check, slow);
1954   }
1955 
1956   // If the compiler was not able to prove that exact type of the source or the destination
1957   // of the arraycopy is an array type, check at runtime if the source or the destination is
1958   // an instance type.
1959   if (flags &amp; LIR_OpArrayCopy::type_check) {
1960     if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
1961       __ load_klass(tmp, dst);
1962       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1963       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1964       __ bge(CCR0, slow);
1965     }
1966 
1967     if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
1968       __ load_klass(tmp, src);
1969       __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
1970       __ cmpwi(CCR0, tmp2, Klass::_lh_neutral_value);
1971       __ bge(CCR0, slow);
1972     }
1973   }
1974 
1975   // Higher 32bits must be null.
1976   __ extsw(length, length);
1977 
1978   __ extsw(src_pos, src_pos);
1979   if (flags &amp; LIR_OpArrayCopy::src_range_check) {
1980     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), src);
1981     __ add(tmp, length, src_pos);
1982     __ cmpld(CCR0, tmp2, tmp);
1983     __ ble(CCR0, slow);
1984   }
1985 
1986   __ extsw(dst_pos, dst_pos);
1987   if (flags &amp; LIR_OpArrayCopy::dst_range_check) {
1988     __ lwz(tmp2, arrayOopDesc::length_offset_in_bytes(), dst);
1989     __ add(tmp, length, dst_pos);
1990     __ cmpld(CCR0, tmp2, tmp);
1991     __ ble(CCR0, slow);
1992   }
1993 
1994   int shift = shift_amount(basic_type);
1995 
1996   if (!(flags &amp; LIR_OpArrayCopy::type_check)) {
1997     __ b(cont);
1998   } else {
1999     // We don&#39;t know the array types are compatible.
2000     if (basic_type != T_OBJECT) {
2001       // Simple test for basic type arrays.
2002       if (UseCompressedClassPointers) {
2003         // We don&#39;t need decode because we just need to compare.
2004         __ lwz(tmp, oopDesc::klass_offset_in_bytes(), src);
2005         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2006         __ cmpw(CCR0, tmp, tmp2);
2007       } else {
2008         __ ld(tmp, oopDesc::klass_offset_in_bytes(), src);
2009         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2010         __ cmpd(CCR0, tmp, tmp2);
2011       }
2012       __ beq(CCR0, cont);
2013     } else {
2014       // For object arrays, if src is a sub class of dst then we can
2015       // safely do the copy.
2016       address copyfunc_addr = StubRoutines::checkcast_arraycopy();
2017 
2018       const Register sub_klass = R5, super_klass = R4; // like CheckCast/InstanceOf
2019       assert_different_registers(tmp, tmp2, sub_klass, super_klass);
2020 
2021       __ load_klass(sub_klass, src);
2022       __ load_klass(super_klass, dst);
2023 
2024       __ check_klass_subtype_fast_path(sub_klass, super_klass, tmp, tmp2,
2025                                        &amp;cont, copyfunc_addr != NULL ? &amp;copyfunc : &amp;slow, NULL);
2026 
2027       address slow_stc = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2028       //__ load_const_optimized(tmp, slow_stc, tmp2);
2029       __ calculate_address_from_global_toc(tmp, slow_stc, true, true, false);
2030       __ mtctr(tmp);
2031       __ bctrl(); // sets CR0
2032       __ beq(CCR0, cont);
2033 
2034       if (copyfunc_addr != NULL) { // Use stub if available.
2035         __ bind(copyfunc);
2036         // Src is not a sub class of dst so we have to do a
2037         // per-element check.
2038         int mask = LIR_OpArrayCopy::src_objarray|LIR_OpArrayCopy::dst_objarray;
2039         if ((flags &amp; mask) != mask) {
2040           assert(flags &amp; mask, &quot;one of the two should be known to be an object array&quot;);
2041 
2042           if (!(flags &amp; LIR_OpArrayCopy::src_objarray)) {
2043             __ load_klass(tmp, src);
2044           } else if (!(flags &amp; LIR_OpArrayCopy::dst_objarray)) {
2045             __ load_klass(tmp, dst);
2046           }
2047 
2048           __ lwz(tmp2, in_bytes(Klass::layout_helper_offset()), tmp);
2049 
2050           jint objArray_lh = Klass::array_layout_helper(T_OBJECT);
2051           __ load_const_optimized(tmp, objArray_lh);
2052           __ cmpw(CCR0, tmp, tmp2);
2053           __ bne(CCR0, slow);
2054         }
2055 
2056         Register src_ptr = R3_ARG1;
2057         Register dst_ptr = R4_ARG2;
2058         Register len     = R5_ARG3;
2059         Register chk_off = R6_ARG4;
2060         Register super_k = R7_ARG5;
2061 
2062         __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2063         __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2064         if (shift == 0) {
2065           __ add(src_ptr, src_pos, src_ptr);
2066           __ add(dst_ptr, dst_pos, dst_ptr);
2067         } else {
2068           __ sldi(tmp, src_pos, shift);
2069           __ sldi(tmp2, dst_pos, shift);
2070           __ add(src_ptr, tmp, src_ptr);
2071           __ add(dst_ptr, tmp2, dst_ptr);
2072         }
2073 
2074         __ load_klass(tmp, dst);
2075         __ mr(len, length);
2076 
2077         int ek_offset = in_bytes(ObjArrayKlass::element_klass_offset());
2078         __ ld(super_k, ek_offset, tmp);
2079 
2080         int sco_offset = in_bytes(Klass::super_check_offset_offset());
2081         __ lwz(chk_off, sco_offset, super_k);
2082 
2083         __ call_c_with_frame_resize(copyfunc_addr, /*stub does not need resized frame*/ 0);
2084 
2085 #ifndef PRODUCT
2086         if (PrintC1Statistics) {
2087           Label failed;
2088           __ cmpwi(CCR0, R3_RET, 0);
2089           __ bne(CCR0, failed);
2090           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_cnt;
2091           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2092           __ lwz(R11_scratch1, simm16_offs, tmp);
2093           __ addi(R11_scratch1, R11_scratch1, 1);
2094           __ stw(R11_scratch1, simm16_offs, tmp);
2095           __ bind(failed);
2096         }
2097 #endif
2098 
2099         __ nand(tmp, R3_RET, R3_RET);
2100         __ cmpwi(CCR0, R3_RET, 0);
2101         __ beq(CCR0, *stub-&gt;continuation());
2102 
2103 #ifndef PRODUCT
2104         if (PrintC1Statistics) {
2105           address counter = (address)&amp;Runtime1::_arraycopy_checkcast_attempt_cnt;
2106           int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2107           __ lwz(R11_scratch1, simm16_offs, tmp);
2108           __ addi(R11_scratch1, R11_scratch1, 1);
2109           __ stw(R11_scratch1, simm16_offs, tmp);
2110         }
2111 #endif
2112 
2113         __ subf(length, tmp, length);
2114         __ add(src_pos, tmp, src_pos);
2115         __ add(dst_pos, tmp, dst_pos);
2116       }
2117     }
2118   }
2119   __ bind(slow);
2120   __ b(*stub-&gt;entry());
2121   __ bind(cont);
2122 
2123 #ifdef ASSERT
2124   if (basic_type != T_OBJECT || !(flags &amp; LIR_OpArrayCopy::type_check)) {
2125     // Sanity check the known type with the incoming class. For the
2126     // primitive case the types must match exactly with src.klass and
2127     // dst.klass each exactly matching the default type. For the
2128     // object array case, if no type check is needed then either the
2129     // dst type is exactly the expected type and the src type is a
2130     // subtype which we can&#39;t check or src is the same array as dst
2131     // but not necessarily exactly of type default_type.
2132     Label known_ok, halt;
2133     metadata2reg(op-&gt;expected_type()-&gt;constant_encoding(), tmp);
2134     if (UseCompressedClassPointers) {
2135       // Tmp holds the default type. It currently comes uncompressed after the
2136       // load of a constant, so encode it.
2137       __ encode_klass_not_null(tmp);
2138       // Load the raw value of the dst klass, since we will be comparing
2139       // uncompressed values directly.
2140       __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2141       __ cmpw(CCR0, tmp, tmp2);
2142       if (basic_type != T_OBJECT) {
2143         __ bne(CCR0, halt);
2144         // Load the raw value of the src klass.
2145         __ lwz(tmp2, oopDesc::klass_offset_in_bytes(), src);
2146         __ cmpw(CCR0, tmp, tmp2);
2147         __ beq(CCR0, known_ok);
2148       } else {
2149         __ beq(CCR0, known_ok);
2150         __ cmpw(CCR0, src, dst);
2151         __ beq(CCR0, known_ok);
2152       }
2153     } else {
2154       __ ld(tmp2, oopDesc::klass_offset_in_bytes(), dst);
2155       __ cmpd(CCR0, tmp, tmp2);
2156       if (basic_type != T_OBJECT) {
2157         __ bne(CCR0, halt);
2158         // Load the raw value of the src klass.
2159         __ ld(tmp2, oopDesc::klass_offset_in_bytes(), src);
2160         __ cmpd(CCR0, tmp, tmp2);
2161         __ beq(CCR0, known_ok);
2162       } else {
2163         __ beq(CCR0, known_ok);
2164         __ cmpd(CCR0, src, dst);
2165         __ beq(CCR0, known_ok);
2166       }
2167     }
2168     __ bind(halt);
2169     __ stop(&quot;incorrect type information in arraycopy&quot;);
2170     __ bind(known_ok);
2171   }
2172 #endif
2173 
2174 #ifndef PRODUCT
2175   if (PrintC1Statistics) {
2176     address counter = Runtime1::arraycopy_count_address(basic_type);
2177     int simm16_offs = __ load_const_optimized(tmp, counter, tmp2, true);
2178     __ lwz(R11_scratch1, simm16_offs, tmp);
2179     __ addi(R11_scratch1, R11_scratch1, 1);
2180     __ stw(R11_scratch1, simm16_offs, tmp);
2181   }
2182 #endif
2183 
2184   Register src_ptr = R3_ARG1;
2185   Register dst_ptr = R4_ARG2;
2186   Register len     = R5_ARG3;
2187 
2188   __ addi(src_ptr, src, arrayOopDesc::base_offset_in_bytes(basic_type));
2189   __ addi(dst_ptr, dst, arrayOopDesc::base_offset_in_bytes(basic_type));
2190   if (shift == 0) {
2191     __ add(src_ptr, src_pos, src_ptr);
2192     __ add(dst_ptr, dst_pos, dst_ptr);
2193   } else {
2194     __ sldi(tmp, src_pos, shift);
2195     __ sldi(tmp2, dst_pos, shift);
2196     __ add(src_ptr, tmp, src_ptr);
2197     __ add(dst_ptr, tmp2, dst_ptr);
2198   }
2199 
2200   bool disjoint = (flags &amp; LIR_OpArrayCopy::overlapping) == 0;
2201   bool aligned = (flags &amp; LIR_OpArrayCopy::unaligned) == 0;
2202   const char *name;
2203   address entry = StubRoutines::select_arraycopy_function(basic_type, aligned, disjoint, name, false);
2204 
2205   // Arraycopy stubs takes a length in number of elements, so don&#39;t scale it.
2206   __ mr(len, length);
2207   __ call_c_with_frame_resize(entry, /*stub does not need resized frame*/ 0);
2208 
2209   __ bind(*stub-&gt;continuation());
2210 }
2211 
2212 
2213 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, LIR_Opr count, LIR_Opr dest, LIR_Opr tmp) {
2214   if (dest-&gt;is_single_cpu()) {
2215     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-5);
2216 #ifdef _LP64
2217     if (left-&gt;type() == T_OBJECT) {
2218       switch (code) {
2219         case lir_shl:  __ sld(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2220         case lir_shr:  __ srad(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2221         case lir_ushr: __ srd(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2222         default: ShouldNotReachHere();
2223       }
2224     } else
2225 #endif
2226       switch (code) {
2227         case lir_shl:  __ slw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2228         case lir_shr:  __ sraw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2229         case lir_ushr: __ srw(dest-&gt;as_register(), left-&gt;as_register(), tmp-&gt;as_register()); break;
2230         default: ShouldNotReachHere();
2231       }
2232   } else {
2233     __ rldicl(tmp-&gt;as_register(), count-&gt;as_register(), 0, 64-6);
2234     switch (code) {
2235       case lir_shl:  __ sld(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2236       case lir_shr:  __ srad(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2237       case lir_ushr: __ srd(dest-&gt;as_register_lo(), left-&gt;as_register_lo(), tmp-&gt;as_register()); break;
2238       default: ShouldNotReachHere();
2239     }
2240   }
2241 }
2242 
2243 
2244 void LIR_Assembler::shift_op(LIR_Code code, LIR_Opr left, jint count, LIR_Opr dest) {
2245 #ifdef _LP64
2246   if (left-&gt;type() == T_OBJECT) {
2247     count = count &amp; 63;  // Shouldn&#39;t shift by more than sizeof(intptr_t).
2248     if (count == 0) { __ mr_if_needed(dest-&gt;as_register_lo(), left-&gt;as_register()); }
2249     else {
2250       switch (code) {
2251         case lir_shl:  __ sldi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2252         case lir_shr:  __ sradi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2253         case lir_ushr: __ srdi(dest-&gt;as_register_lo(), left-&gt;as_register(), count); break;
2254         default: ShouldNotReachHere();
2255       }
2256     }
2257     return;
2258   }
2259 #endif
2260 
2261   if (dest-&gt;is_single_cpu()) {
2262     count = count &amp; 0x1F; // Java spec
2263     if (count == 0) { __ mr_if_needed(dest-&gt;as_register(), left-&gt;as_register()); }
2264     else {
2265       switch (code) {
2266         case lir_shl: __ slwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2267         case lir_shr:  __ srawi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2268         case lir_ushr: __ srwi(dest-&gt;as_register(), left-&gt;as_register(), count); break;
2269         default: ShouldNotReachHere();
2270       }
2271     }
2272   } else if (dest-&gt;is_double_cpu()) {
2273     count = count &amp; 63; // Java spec
2274     if (count == 0) { __ mr_if_needed(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register()); }
2275     else {
2276       switch (code) {
2277         case lir_shl:  __ sldi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2278         case lir_shr:  __ sradi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2279         case lir_ushr: __ srdi(dest-&gt;as_pointer_register(), left-&gt;as_pointer_register(), count); break;
2280         default: ShouldNotReachHere();
2281       }
2282     }
2283   } else {
2284     ShouldNotReachHere();
2285   }
2286 }
2287 
2288 
2289 void LIR_Assembler::emit_alloc_obj(LIR_OpAllocObj* op) {
2290   if (op-&gt;init_check()) {
2291     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2292       explicit_null_check(op-&gt;klass()-&gt;as_register(), op-&gt;stub()-&gt;info());
2293     } else {
2294       add_debug_info_for_null_check_here(op-&gt;stub()-&gt;info());
2295     }
2296     __ lbz(op-&gt;tmp1()-&gt;as_register(),
2297            in_bytes(InstanceKlass::init_state_offset()), op-&gt;klass()-&gt;as_register());
2298     __ cmpwi(CCR0, op-&gt;tmp1()-&gt;as_register(), InstanceKlass::fully_initialized);
2299     __ bc_far_optimized(Assembler::bcondCRbiIs0, __ bi0(CCR0, Assembler::equal), *op-&gt;stub()-&gt;entry());
2300   }
2301   __ allocate_object(op-&gt;obj()-&gt;as_register(),
2302                      op-&gt;tmp1()-&gt;as_register(),
2303                      op-&gt;tmp2()-&gt;as_register(),
2304                      op-&gt;tmp3()-&gt;as_register(),
2305                      op-&gt;header_size(),
2306                      op-&gt;object_size(),
2307                      op-&gt;klass()-&gt;as_register(),
2308                      *op-&gt;stub()-&gt;entry());
2309 
2310   __ bind(*op-&gt;stub()-&gt;continuation());
2311   __ verify_oop(op-&gt;obj()-&gt;as_register(), FILE_AND_LINE);
2312 }
2313 
2314 
2315 void LIR_Assembler::emit_alloc_array(LIR_OpAllocArray* op) {
2316   LP64_ONLY( __ extsw(op-&gt;len()-&gt;as_register(), op-&gt;len()-&gt;as_register()); )
2317   if (UseSlowPath ||
2318       (!UseFastNewObjectArray &amp;&amp; (is_reference_type(op-&gt;type()))) ||
2319       (!UseFastNewTypeArray   &amp;&amp; (!is_reference_type(op-&gt;type())))) {
2320     __ b(*op-&gt;stub()-&gt;entry());
2321   } else {
2322     __ allocate_array(op-&gt;obj()-&gt;as_register(),
2323                       op-&gt;len()-&gt;as_register(),
2324                       op-&gt;tmp1()-&gt;as_register(),
2325                       op-&gt;tmp2()-&gt;as_register(),
2326                       op-&gt;tmp3()-&gt;as_register(),
2327                       arrayOopDesc::header_size(op-&gt;type()),
2328                       type2aelembytes(op-&gt;type()),
2329                       op-&gt;klass()-&gt;as_register(),
2330                       *op-&gt;stub()-&gt;entry());
2331   }
2332   __ bind(*op-&gt;stub()-&gt;continuation());
2333 }
2334 
2335 
2336 void LIR_Assembler::type_profile_helper(Register mdo, int mdo_offset_bias,
2337                                         ciMethodData *md, ciProfileData *data,
2338                                         Register recv, Register tmp1, Label* update_done) {
2339   uint i;
2340   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2341     Label next_test;
2342     // See if the receiver is receiver[n].
2343     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2344     __ verify_klass_ptr(tmp1);
2345     __ cmpd(CCR0, recv, tmp1);
2346     __ bne(CCR0, next_test);
2347 
2348     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2349     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2350     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2351     __ b(*update_done);
2352 
2353     __ bind(next_test);
2354   }
2355 
2356   // Didn&#39;t find receiver; find next empty slot and fill it in.
2357   for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2358     Label next_test;
2359     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2360     __ cmpdi(CCR0, tmp1, 0);
2361     __ bne(CCR0, next_test);
2362     __ li(tmp1, DataLayout::counter_increment);
2363     __ std(recv, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_offset(i)) - mdo_offset_bias, mdo);
2364     __ std(tmp1, md-&gt;byte_offset_of_slot(data, ReceiverTypeData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2365     __ b(*update_done);
2366 
2367     __ bind(next_test);
2368   }
2369 }
2370 
2371 
2372 void LIR_Assembler::setup_md_access(ciMethod* method, int bci,
2373                                     ciMethodData*&amp; md, ciProfileData*&amp; data, int&amp; mdo_offset_bias) {
2374   md = method-&gt;method_data_or_null();
2375   assert(md != NULL, &quot;Sanity&quot;);
2376   data = md-&gt;bci_to_data(bci);
2377   assert(data != NULL,       &quot;need data for checkcast&quot;);
2378   assert(data-&gt;is_ReceiverTypeData(), &quot;need ReceiverTypeData for type check&quot;);
2379   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, DataLayout::header_offset()) + data-&gt;size_in_bytes())) {
2380     // The offset is large so bias the mdo by the base of the slot so
2381     // that the ld can use simm16s to reference the slots of the data.
2382     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, DataLayout::header_offset());
2383   }
2384 }
2385 
2386 
2387 void LIR_Assembler::emit_typecheck_helper(LIR_OpTypeCheck *op, Label* success, Label* failure, Label* obj_is_null) {
2388   const Register obj = op-&gt;object()-&gt;as_register(); // Needs to live in this register at safepoint (patching stub).
2389   Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2390   Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2391   Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2392   Register dst = op-&gt;result_opr()-&gt;as_register();
2393   ciKlass* k = op-&gt;klass();
2394   bool should_profile = op-&gt;should_profile();
2395   // Attention: do_temp(opTypeCheck-&gt;_object) is not used, i.e. obj may be same as one of the temps.
2396   bool reg_conflict = false;
2397   if (obj == k_RInfo) {
2398     k_RInfo = dst;
2399     reg_conflict = true;
2400   } else if (obj == klass_RInfo) {
2401     klass_RInfo = dst;
2402     reg_conflict = true;
2403   } else if (obj == Rtmp1) {
2404     Rtmp1 = dst;
2405     reg_conflict = true;
2406   }
2407   assert_different_registers(obj, k_RInfo, klass_RInfo, Rtmp1);
2408 
2409   __ cmpdi(CCR0, obj, 0);
2410 
2411   ciMethodData* md = NULL;
2412   ciProfileData* data = NULL;
2413   int mdo_offset_bias = 0;
2414   if (should_profile) {
2415     ciMethod* method = op-&gt;profiled_method();
2416     assert(method != NULL, &quot;Should have method&quot;);
2417     setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2418 
2419     Register mdo      = k_RInfo;
2420     Register data_val = Rtmp1;
2421     Label not_null;
2422     __ bne(CCR0, not_null);
2423     metadata2reg(md-&gt;constant_encoding(), mdo);
2424     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2425     __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2426     __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2427     __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2428     __ b(*obj_is_null);
2429     __ bind(not_null);
2430   } else {
2431     __ beq(CCR0, *obj_is_null);
2432   }
2433 
2434   // get object class
2435   __ load_klass(klass_RInfo, obj);
2436 
2437   if (k-&gt;is_loaded()) {
2438     metadata2reg(k-&gt;constant_encoding(), k_RInfo);
2439   } else {
2440     klass2reg_with_patching(k_RInfo, op-&gt;info_for_patch());
2441   }
2442 
2443   Label profile_cast_failure, failure_restore_obj, profile_cast_success;
2444   Label *failure_target = should_profile ? &amp;profile_cast_failure : failure;
2445   Label *success_target = should_profile ? &amp;profile_cast_success : success;
2446 
2447   if (op-&gt;fast_check()) {
2448     assert_different_registers(klass_RInfo, k_RInfo);
2449     __ cmpd(CCR0, k_RInfo, klass_RInfo);
2450     if (should_profile) {
2451       __ bne(CCR0, *failure_target);
2452       // Fall through to success case.
2453     } else {
2454       __ beq(CCR0, *success);
2455       // Fall through to failure case.
2456     }
2457   } else {
2458     bool need_slow_path = true;
2459     if (k-&gt;is_loaded()) {
2460       if ((int) k-&gt;super_check_offset() != in_bytes(Klass::secondary_super_cache_offset())) {
2461         need_slow_path = false;
2462       }
2463       // Perform the fast part of the checking logic.
2464       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, (need_slow_path ? success_target : NULL),
2465                                        failure_target, NULL, RegisterOrConstant(k-&gt;super_check_offset()));
2466     } else {
2467       // Perform the fast part of the checking logic.
2468       __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, failure_target);
2469     }
2470     if (!need_slow_path) {
2471       if (!should_profile) { __ b(*success); }
2472     } else {
2473       // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2474       address entry = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2475       // Stub needs fixed registers (tmp1-3).
2476       Register original_k_RInfo = op-&gt;tmp1()-&gt;as_register();
2477       Register original_klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2478       Register original_Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2479       bool keep_obj_alive = reg_conflict &amp;&amp; (op-&gt;code() == lir_checkcast);
2480       bool keep_klass_RInfo_alive = (obj == original_klass_RInfo) &amp;&amp; should_profile;
2481       if (keep_obj_alive &amp;&amp; (obj != original_Rtmp1)) { __ mr(R0, obj); }
2482       __ mr_if_needed(original_k_RInfo, k_RInfo);
2483       __ mr_if_needed(original_klass_RInfo, klass_RInfo);
2484       if (keep_obj_alive) { __ mr(dst, (obj == original_Rtmp1) ? obj : R0); }
2485       //__ load_const_optimized(original_Rtmp1, entry, R0);
2486       __ calculate_address_from_global_toc(original_Rtmp1, entry, true, true, false);
2487       __ mtctr(original_Rtmp1);
2488       __ bctrl(); // sets CR0
2489       if (keep_obj_alive) {
2490         if (keep_klass_RInfo_alive) { __ mr(R0, obj); }
2491         __ mr(obj, dst);
2492       }
2493       if (should_profile) {
2494         __ bne(CCR0, *failure_target);
2495         if (keep_klass_RInfo_alive) { __ mr(klass_RInfo, keep_obj_alive ? R0 : obj); }
2496         // Fall through to success case.
2497       } else {
2498         __ beq(CCR0, *success);
2499         // Fall through to failure case.
2500       }
2501     }
2502   }
2503 
2504   if (should_profile) {
2505     Register mdo = k_RInfo, recv = klass_RInfo;
2506     assert_different_registers(mdo, recv, Rtmp1);
2507     __ bind(profile_cast_success);
2508     metadata2reg(md-&gt;constant_encoding(), mdo);
2509     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2510     type_profile_helper(mdo, mdo_offset_bias, md, data, recv, Rtmp1, success);
2511     __ b(*success);
2512 
2513     // Cast failure case.
2514     __ bind(profile_cast_failure);
2515     metadata2reg(md-&gt;constant_encoding(), mdo);
2516     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2517     __ ld(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2518     __ addi(Rtmp1, Rtmp1, -DataLayout::counter_increment);
2519     __ std(Rtmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2520   }
2521 
2522   __ bind(*failure);
2523 }
2524 
2525 
2526 void LIR_Assembler::emit_opTypeCheck(LIR_OpTypeCheck* op) {
2527   LIR_Code code = op-&gt;code();
2528   if (code == lir_store_check) {
2529     Register value = op-&gt;object()-&gt;as_register();
2530     Register array = op-&gt;array()-&gt;as_register();
2531     Register k_RInfo = op-&gt;tmp1()-&gt;as_register();
2532     Register klass_RInfo = op-&gt;tmp2()-&gt;as_register();
2533     Register Rtmp1 = op-&gt;tmp3()-&gt;as_register();
2534     bool should_profile = op-&gt;should_profile();
2535 
2536     __ verify_oop(value, FILE_AND_LINE);
2537     CodeStub* stub = op-&gt;stub();
2538     // Check if it needs to be profiled.
2539     ciMethodData* md = NULL;
2540     ciProfileData* data = NULL;
2541     int mdo_offset_bias = 0;
2542     if (should_profile) {
2543       ciMethod* method = op-&gt;profiled_method();
2544       assert(method != NULL, &quot;Should have method&quot;);
2545       setup_md_access(method, op-&gt;profiled_bci(), md, data, mdo_offset_bias);
2546     }
2547     Label profile_cast_success, failure, done;
2548     Label *success_target = should_profile ? &amp;profile_cast_success : &amp;done;
2549 
2550     __ cmpdi(CCR0, value, 0);
2551     if (should_profile) {
2552       Label not_null;
2553       __ bne(CCR0, not_null);
2554       Register mdo      = k_RInfo;
2555       Register data_val = Rtmp1;
2556       metadata2reg(md-&gt;constant_encoding(), mdo);
2557       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2558       __ lbz(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2559       __ ori(data_val, data_val, BitData::null_seen_byte_constant());
2560       __ stb(data_val, md-&gt;byte_offset_of_slot(data, DataLayout::flags_offset()) - mdo_offset_bias, mdo);
2561       __ b(done);
2562       __ bind(not_null);
2563     } else {
2564       __ beq(CCR0, done);
2565     }
2566     if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2567       explicit_null_check(array, op-&gt;info_for_exception());
2568     } else {
2569       add_debug_info_for_null_check_here(op-&gt;info_for_exception());
2570     }
2571     __ load_klass(k_RInfo, array);
2572     __ load_klass(klass_RInfo, value);
2573 
2574     // Get instance klass.
2575     __ ld(k_RInfo, in_bytes(ObjArrayKlass::element_klass_offset()), k_RInfo);
2576     // Perform the fast part of the checking logic.
2577     __ check_klass_subtype_fast_path(klass_RInfo, k_RInfo, Rtmp1, R0, success_target, &amp;failure, NULL);
2578 
2579     // Call out-of-line instance of __ check_klass_subtype_slow_path(...):
2580     const address slow_path = Runtime1::entry_for(Runtime1::slow_subtype_check_id);
2581     //__ load_const_optimized(R0, slow_path);
2582     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(slow_path));
2583     __ mtctr(R0);
2584     __ bctrl(); // sets CR0
2585     if (!should_profile) {
2586       __ beq(CCR0, done);
2587       __ bind(failure);
2588     } else {
2589       __ bne(CCR0, failure);
2590       // Fall through to the success case.
2591 
2592       Register mdo  = klass_RInfo, recv = k_RInfo, tmp1 = Rtmp1;
2593       assert_different_registers(value, mdo, recv, tmp1);
2594       __ bind(profile_cast_success);
2595       metadata2reg(md-&gt;constant_encoding(), mdo);
2596       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2597       __ load_klass(recv, value);
2598       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;done);
2599       __ b(done);
2600 
2601       // Cast failure case.
2602       __ bind(failure);
2603       metadata2reg(md-&gt;constant_encoding(), mdo);
2604       __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2605       Address data_addr(mdo, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias);
2606       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2607       __ addi(tmp1, tmp1, -DataLayout::counter_increment);
2608       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2609     }
2610     __ b(*stub-&gt;entry());
2611     __ bind(done);
2612 
2613   } else if (code == lir_checkcast) {
2614     Label success, failure;
2615     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;success);
2616     __ b(*op-&gt;stub()-&gt;entry());
2617     __ align(32, 12);
2618     __ bind(success);
2619     __ mr_if_needed(op-&gt;result_opr()-&gt;as_register(), op-&gt;object()-&gt;as_register());
2620   } else if (code == lir_instanceof) {
2621     Register dst = op-&gt;result_opr()-&gt;as_register();
2622     Label success, failure, done;
2623     emit_typecheck_helper(op, &amp;success, /*fallthru*/&amp;failure, &amp;failure);
2624     __ li(dst, 0);
2625     __ b(done);
2626     __ align(32, 12);
2627     __ bind(success);
2628     __ li(dst, 1);
2629     __ bind(done);
2630   } else {
2631     ShouldNotReachHere();
2632   }
2633 }
2634 
2635 
2636 void LIR_Assembler::emit_compare_and_swap(LIR_OpCompareAndSwap* op) {
2637   Register addr = op-&gt;addr()-&gt;as_pointer_register();
2638   Register cmp_value = noreg, new_value = noreg;
2639   bool is_64bit = false;
2640 
2641   if (op-&gt;code() == lir_cas_long) {
2642     cmp_value = op-&gt;cmp_value()-&gt;as_register_lo();
2643     new_value = op-&gt;new_value()-&gt;as_register_lo();
2644     is_64bit = true;
2645   } else if (op-&gt;code() == lir_cas_int || op-&gt;code() == lir_cas_obj) {
2646     cmp_value = op-&gt;cmp_value()-&gt;as_register();
2647     new_value = op-&gt;new_value()-&gt;as_register();
2648     if (op-&gt;code() == lir_cas_obj) {
2649       if (UseCompressedOops) {
2650         Register t1 = op-&gt;tmp1()-&gt;as_register();
2651         Register t2 = op-&gt;tmp2()-&gt;as_register();
2652         cmp_value = __ encode_heap_oop(t1, cmp_value);
2653         new_value = __ encode_heap_oop(t2, new_value);
2654       } else {
2655         is_64bit = true;
2656       }
2657     }
2658   } else {
2659     Unimplemented();
2660   }
2661 
2662   if (is_64bit) {
2663     __ cmpxchgd(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2664                 MacroAssembler::MemBarNone,
2665                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2666                 noreg, NULL, /*check without ldarx first*/true);
2667   } else {
2668     __ cmpxchgw(BOOL_RESULT, /*current_value=*/R0, cmp_value, new_value, addr,
2669                 MacroAssembler::MemBarNone,
2670                 MacroAssembler::cmpxchgx_hint_atomic_update(),
2671                 noreg, /*check without ldarx first*/true);
2672   }
2673 
2674   if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
2675     __ isync();
2676   } else {
2677     __ sync();
2678   }
2679 }
2680 
2681 void LIR_Assembler::breakpoint() {
2682   __ illtrap();
2683 }
2684 
2685 
2686 void LIR_Assembler::push(LIR_Opr opr) {
2687   Unimplemented();
2688 }
2689 
2690 void LIR_Assembler::pop(LIR_Opr opr) {
2691   Unimplemented();
2692 }
2693 
2694 
2695 void LIR_Assembler::monitor_address(int monitor_no, LIR_Opr dst_opr) {
2696   Address mon_addr = frame_map()-&gt;address_for_monitor_lock(monitor_no);
2697   Register dst = dst_opr-&gt;as_register();
2698   Register reg = mon_addr.base();
2699   int offset = mon_addr.disp();
2700   // Compute pointer to BasicLock.
2701   __ add_const_optimized(dst, reg, offset);
2702 }
2703 
2704 
2705 void LIR_Assembler::emit_lock(LIR_OpLock* op) {
2706   Register obj = op-&gt;obj_opr()-&gt;as_register();
2707   Register hdr = op-&gt;hdr_opr()-&gt;as_register();
2708   Register lock = op-&gt;lock_opr()-&gt;as_register();
2709 
2710   // Obj may not be an oop.
2711   if (op-&gt;code() == lir_lock) {
2712     MonitorEnterStub* stub = (MonitorEnterStub*)op-&gt;stub();
2713     if (UseFastLocking) {
2714       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2715       // Add debug info for NullPointerException only if one is possible.
2716       if (op-&gt;info() != NULL) {
2717         if (!os::zero_page_read_protected() || !ImplicitNullChecks) {
2718           explicit_null_check(obj, op-&gt;info());
2719         } else {
2720           add_debug_info_for_null_check_here(op-&gt;info());
2721         }
2722       }
2723       __ lock_object(hdr, obj, lock, op-&gt;scratch_opr()-&gt;as_register(), *op-&gt;stub()-&gt;entry());
2724     } else {
2725       // always do slow locking
2726       // note: The slow locking code could be inlined here, however if we use
2727       //       slow locking, speed doesn&#39;t matter anyway and this solution is
2728       //       simpler and requires less duplicated code - additionally, the
2729       //       slow locking code is the same in either case which simplifies
2730       //       debugging.
2731       __ b(*op-&gt;stub()-&gt;entry());
2732     }
2733   } else {
2734     assert (op-&gt;code() == lir_unlock, &quot;Invalid code, expected lir_unlock&quot;);
2735     if (UseFastLocking) {
2736       assert(BasicLock::displaced_header_offset_in_bytes() == 0, &quot;lock_reg must point to the displaced header&quot;);
2737       __ unlock_object(hdr, obj, lock, *op-&gt;stub()-&gt;entry());
2738     } else {
2739       // always do slow unlocking
2740       // note: The slow unlocking code could be inlined here, however if we use
2741       //       slow unlocking, speed doesn&#39;t matter anyway and this solution is
2742       //       simpler and requires less duplicated code - additionally, the
2743       //       slow unlocking code is the same in either case which simplifies
2744       //       debugging.
2745       __ b(*op-&gt;stub()-&gt;entry());
2746     }
2747   }
2748   __ bind(*op-&gt;stub()-&gt;continuation());
2749 }
2750 
2751 
2752 void LIR_Assembler::emit_profile_call(LIR_OpProfileCall* op) {
2753   ciMethod* method = op-&gt;profiled_method();
2754   int bci          = op-&gt;profiled_bci();
2755   ciMethod* callee = op-&gt;profiled_callee();
2756 
2757   // Update counter for all call types.
2758   ciMethodData* md = method-&gt;method_data_or_null();
2759   assert(md != NULL, &quot;Sanity&quot;);
2760   ciProfileData* data = md-&gt;bci_to_data(bci);
2761   assert(data != NULL &amp;&amp; data-&gt;is_CounterData(), &quot;need CounterData for calls&quot;);
2762   assert(op-&gt;mdo()-&gt;is_single_cpu(),  &quot;mdo must be allocated&quot;);
2763   Register mdo = op-&gt;mdo()-&gt;as_register();
2764 #ifdef _LP64
2765   assert(op-&gt;tmp1()-&gt;is_double_cpu(), &quot;tmp1 must be allocated&quot;);
2766   Register tmp1 = op-&gt;tmp1()-&gt;as_register_lo();
2767 #else
2768   assert(op-&gt;tmp1()-&gt;is_single_cpu(), &quot;tmp1 must be allocated&quot;);
2769   Register tmp1 = op-&gt;tmp1()-&gt;as_register();
2770 #endif
2771   metadata2reg(md-&gt;constant_encoding(), mdo);
2772   int mdo_offset_bias = 0;
2773   if (!Assembler::is_simm16(md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) +
2774                             data-&gt;size_in_bytes())) {
2775     // The offset is large so bias the mdo by the base of the slot so
2776     // that the ld can use simm16s to reference the slots of the data.
2777     mdo_offset_bias = md-&gt;byte_offset_of_slot(data, CounterData::count_offset());
2778     __ add_const_optimized(mdo, mdo, mdo_offset_bias, R0);
2779   }
2780 
2781   // Perform additional virtual call profiling for invokevirtual and
2782   // invokeinterface bytecodes
2783   if (op-&gt;should_profile_receiver_type()) {
2784     assert(op-&gt;recv()-&gt;is_single_cpu(), &quot;recv must be allocated&quot;);
2785     Register recv = op-&gt;recv()-&gt;as_register();
2786     assert_different_registers(mdo, tmp1, recv);
2787     assert(data-&gt;is_VirtualCallData(), &quot;need VirtualCallData for virtual calls&quot;);
2788     ciKlass* known_klass = op-&gt;known_holder();
2789     if (C1OptimizeVirtualCallProfiling &amp;&amp; known_klass != NULL) {
2790       // We know the type that will be seen at this call site; we can
2791       // statically update the MethodData* rather than needing to do
2792       // dynamic tests on the receiver type.
2793 
2794       // NOTE: we should probably put a lock around this search to
2795       // avoid collisions by concurrent compilations.
2796       ciVirtualCallData* vc_data = (ciVirtualCallData*) data;
2797       uint i;
2798       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2799         ciKlass* receiver = vc_data-&gt;receiver(i);
2800         if (known_klass-&gt;equals(receiver)) {
2801           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2802           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2803           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2804           return;
2805         }
2806       }
2807 
2808       // Receiver type not found in profile data; select an empty slot.
2809 
2810       // Note that this is less efficient than it should be because it
2811       // always does a write to the receiver part of the
2812       // VirtualCallData rather than just the first time.
2813       for (i = 0; i &lt; VirtualCallData::row_limit(); i++) {
2814         ciKlass* receiver = vc_data-&gt;receiver(i);
2815         if (receiver == NULL) {
2816           metadata2reg(known_klass-&gt;constant_encoding(), tmp1);
2817           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_offset(i)) - mdo_offset_bias, mdo);
2818 
2819           __ ld(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2820           __ addi(tmp1, tmp1, DataLayout::counter_increment);
2821           __ std(tmp1, md-&gt;byte_offset_of_slot(data, VirtualCallData::receiver_count_offset(i)) - mdo_offset_bias, mdo);
2822           return;
2823         }
2824       }
2825     } else {
2826       __ load_klass(recv, recv);
2827       Label update_done;
2828       type_profile_helper(mdo, mdo_offset_bias, md, data, recv, tmp1, &amp;update_done);
2829       // Receiver did not match any saved receiver and there is no empty row for it.
2830       // Increment total counter to indicate polymorphic case.
2831       __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2832       __ addi(tmp1, tmp1, DataLayout::counter_increment);
2833       __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2834 
2835       __ bind(update_done);
2836     }
2837   } else {
2838     // Static call
2839     __ ld(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2840     __ addi(tmp1, tmp1, DataLayout::counter_increment);
2841     __ std(tmp1, md-&gt;byte_offset_of_slot(data, CounterData::count_offset()) - mdo_offset_bias, mdo);
2842   }
2843 }
2844 
2845 
2846 void LIR_Assembler::align_backward_branch_target() {
2847   __ align(32, 12); // Insert up to 3 nops to align with 32 byte boundary.
2848 }
2849 
2850 
2851 void LIR_Assembler::emit_delay(LIR_OpDelay* op) {
2852   Unimplemented();
2853 }
2854 
2855 
2856 void LIR_Assembler::negate(LIR_Opr left, LIR_Opr dest, LIR_Opr tmp) {
2857   // tmp must be unused
2858   assert(tmp-&gt;is_illegal(), &quot;wasting a register if tmp is allocated&quot;);
2859   assert(left-&gt;is_register(), &quot;can only handle registers&quot;);
2860 
2861   if (left-&gt;is_single_cpu()) {
2862     __ neg(dest-&gt;as_register(), left-&gt;as_register());
2863   } else if (left-&gt;is_single_fpu()) {
2864     __ fneg(dest-&gt;as_float_reg(), left-&gt;as_float_reg());
2865   } else if (left-&gt;is_double_fpu()) {
2866     __ fneg(dest-&gt;as_double_reg(), left-&gt;as_double_reg());
2867   } else {
2868     assert (left-&gt;is_double_cpu(), &quot;Must be a long&quot;);
2869     __ neg(dest-&gt;as_register_lo(), left-&gt;as_register_lo());
2870   }
2871 }
2872 
2873 
2874 void LIR_Assembler::rt_call(LIR_Opr result, address dest,
2875                             const LIR_OprList* args, LIR_Opr tmp, CodeEmitInfo* info) {
2876   // Stubs: Called via rt_call, but dest is a stub address (no function descriptor).
2877   if (dest == Runtime1::entry_for(Runtime1::register_finalizer_id) ||
2878       dest == Runtime1::entry_for(Runtime1::new_multi_array_id   )) {
2879     //__ load_const_optimized(R0, dest);
2880     __ add_const_optimized(R0, R29_TOC, MacroAssembler::offset_to_global_toc(dest));
2881     __ mtctr(R0);
2882     __ bctrl();
2883     assert(info != NULL, &quot;sanity&quot;);
2884     add_call_info_here(info);
2885     return;
2886   }
2887 
2888   __ call_c_with_frame_resize(dest, /*no resizing*/ 0);
2889   if (info != NULL) {
2890     add_call_info_here(info);
2891   }
2892 }
2893 
2894 
2895 void LIR_Assembler::volatile_move_op(LIR_Opr src, LIR_Opr dest, BasicType type, CodeEmitInfo* info) {
2896   ShouldNotReachHere(); // Not needed on _LP64.
2897 }
2898 
2899 void LIR_Assembler::membar() {
2900   __ fence();
2901 }
2902 
2903 void LIR_Assembler::membar_acquire() {
2904   __ acquire();
2905 }
2906 
2907 void LIR_Assembler::membar_release() {
2908   __ release();
2909 }
2910 
2911 void LIR_Assembler::membar_loadload() {
2912   __ membar(Assembler::LoadLoad);
2913 }
2914 
2915 void LIR_Assembler::membar_storestore() {
2916   __ membar(Assembler::StoreStore);
2917 }
2918 
2919 void LIR_Assembler::membar_loadstore() {
2920   __ membar(Assembler::LoadStore);
2921 }
2922 
2923 void LIR_Assembler::membar_storeload() {
2924   __ membar(Assembler::StoreLoad);
2925 }
2926 
2927 void LIR_Assembler::on_spin_wait() {
2928   Unimplemented();
2929 }
2930 
2931 void LIR_Assembler::leal(LIR_Opr addr_opr, LIR_Opr dest, LIR_PatchCode patch_code, CodeEmitInfo* info) {
2932   assert(patch_code == lir_patch_none, &quot;Patch code not supported&quot;);
2933   LIR_Address* addr = addr_opr-&gt;as_address_ptr();
2934   assert(addr-&gt;scale() == LIR_Address::times_1, &quot;no scaling on this platform&quot;);
2935   if (addr-&gt;index()-&gt;is_illegal()) {
2936     __ add_const_optimized(dest-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register(), addr-&gt;disp());
2937   } else {
2938     assert(addr-&gt;disp() == 0, &quot;can&#39;t have both: index and disp&quot;);
2939     __ add(dest-&gt;as_pointer_register(), addr-&gt;index()-&gt;as_pointer_register(), addr-&gt;base()-&gt;as_pointer_register());
2940   }
2941 }
2942 
2943 
2944 void LIR_Assembler::get_thread(LIR_Opr result_reg) {
2945   ShouldNotReachHere();
2946 }
2947 
2948 
2949 #ifdef ASSERT
2950 // Emit run-time assertion.
2951 void LIR_Assembler::emit_assert(LIR_OpAssert* op) {
2952   Unimplemented();
2953 }
2954 #endif
2955 
2956 
2957 void LIR_Assembler::peephole(LIR_List* lir) {
2958   // Optimize instruction pairs before emitting.
2959   LIR_OpList* inst = lir-&gt;instructions_list();
2960   for (int i = 1; i &lt; inst-&gt;length(); i++) {
2961     LIR_Op* op = inst-&gt;at(i);
2962 
2963     // 2 register-register-moves
2964     if (op-&gt;code() == lir_move) {
2965       LIR_Opr in2  = ((LIR_Op1*)op)-&gt;in_opr(),
2966               res2 = ((LIR_Op1*)op)-&gt;result_opr();
2967       if (in2-&gt;is_register() &amp;&amp; res2-&gt;is_register()) {
2968         LIR_Op* prev = inst-&gt;at(i - 1);
2969         if (prev &amp;&amp; prev-&gt;code() == lir_move) {
2970           LIR_Opr in1  = ((LIR_Op1*)prev)-&gt;in_opr(),
2971                   res1 = ((LIR_Op1*)prev)-&gt;result_opr();
2972           if (in1-&gt;is_same_register(res2) &amp;&amp; in2-&gt;is_same_register(res1)) {
2973             inst-&gt;remove_at(i);
2974           }
2975         }
2976       }
2977     }
2978 
2979   }
2980   return;
2981 }
2982 
2983 
2984 void LIR_Assembler::atomic_op(LIR_Code code, LIR_Opr src, LIR_Opr data, LIR_Opr dest, LIR_Opr tmp) {
2985   const LIR_Address *addr = src-&gt;as_address_ptr();
2986   assert(addr-&gt;disp() == 0 &amp;&amp; addr-&gt;index()-&gt;is_illegal(), &quot;use leal!&quot;);
2987   const Register Rptr = addr-&gt;base()-&gt;as_pointer_register(),
2988                  Rtmp = tmp-&gt;as_register();
2989   Register Rco = noreg;
2990   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
2991     Rco = __ encode_heap_oop(Rtmp, data-&gt;as_register());
2992   }
2993 
2994   Label Lretry;
2995   __ bind(Lretry);
2996 
2997   if (data-&gt;type() == T_INT) {
2998     const Register Rold = dest-&gt;as_register(),
2999                    Rsrc = data-&gt;as_register();
3000     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3001     __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3002     if (code == lir_xadd) {
3003       __ add(Rtmp, Rsrc, Rold);
3004       __ stwcx_(Rtmp, Rptr);
3005     } else {
3006       __ stwcx_(Rsrc, Rptr);
3007     }
3008   } else if (data-&gt;is_oop()) {
3009     assert(code == lir_xchg, &quot;xadd for oops&quot;);
3010     const Register Rold = dest-&gt;as_register();
3011     if (UseCompressedOops) {
3012       assert_different_registers(Rptr, Rold, Rco);
3013       __ lwarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3014       __ stwcx_(Rco, Rptr);
3015     } else {
3016       const Register Robj = data-&gt;as_register();
3017       assert_different_registers(Rptr, Rold, Robj);
3018       __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3019       __ stdcx_(Robj, Rptr);
3020     }
3021   } else if (data-&gt;type() == T_LONG) {
3022     const Register Rold = dest-&gt;as_register_lo(),
3023                    Rsrc = data-&gt;as_register_lo();
3024     assert_different_registers(Rptr, Rtmp, Rold, Rsrc);
3025     __ ldarx(Rold, Rptr, MacroAssembler::cmpxchgx_hint_atomic_update());
3026     if (code == lir_xadd) {
3027       __ add(Rtmp, Rsrc, Rold);
3028       __ stdcx_(Rtmp, Rptr);
3029     } else {
3030       __ stdcx_(Rsrc, Rptr);
3031     }
3032   } else {
3033     ShouldNotReachHere();
3034   }
3035 
3036   if (UseStaticBranchPredictionInCompareAndSwapPPC64) {
3037     __ bne_predict_not_taken(CCR0, Lretry);
3038   } else {
3039     __ bne(                  CCR0, Lretry);
3040   }
3041 
3042   if (UseCompressedOops &amp;&amp; data-&gt;is_oop()) {
3043     __ decode_heap_oop(dest-&gt;as_register());
3044   }
3045 }
3046 
3047 
3048 void LIR_Assembler::emit_profile_type(LIR_OpProfileType* op) {
3049   Register obj = op-&gt;obj()-&gt;as_register();
3050   Register tmp = op-&gt;tmp()-&gt;as_pointer_register();
3051   LIR_Address* mdo_addr = op-&gt;mdp()-&gt;as_address_ptr();
3052   ciKlass* exact_klass = op-&gt;exact_klass();
3053   intptr_t current_klass = op-&gt;current_klass();
3054   bool not_null = op-&gt;not_null();
3055   bool no_conflict = op-&gt;no_conflict();
3056 
3057   Label Lupdate, Ldo_update, Ldone;
3058 
3059   bool do_null = !not_null;
3060   bool exact_klass_set = exact_klass != NULL &amp;&amp; ciTypeEntries::valid_ciklass(current_klass) == exact_klass;
3061   bool do_update = !TypeEntries::is_type_unknown(current_klass) &amp;&amp; !exact_klass_set;
3062 
3063   assert(do_null || do_update, &quot;why are we here?&quot;);
3064   assert(!TypeEntries::was_null_seen(current_klass) || do_update, &quot;why are we here?&quot;);
3065 
3066   __ verify_oop(obj, FILE_AND_LINE);
3067 
3068   if (do_null) {
3069     if (!TypeEntries::was_null_seen(current_klass)) {
3070       __ cmpdi(CCR0, obj, 0);
3071       __ bne(CCR0, Lupdate);
3072       __ ld(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3073       __ ori(R0, R0, TypeEntries::null_seen);
3074       if (do_update) {
3075         __ b(Ldo_update);
3076       } else {
3077         __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3078       }
3079     } else {
3080       if (do_update) {
3081         __ cmpdi(CCR0, obj, 0);
3082         __ beq(CCR0, Ldone);
3083       }
3084     }
3085 #ifdef ASSERT
3086   } else {
3087     __ cmpdi(CCR0, obj, 0);
3088     __ bne(CCR0, Lupdate);
3089     __ stop(&quot;unexpect null obj&quot;, 0x9652);
3090 #endif
3091   }
3092 
3093   __ bind(Lupdate);
3094   if (do_update) {
3095     Label Lnext;
3096     const Register klass = R29_TOC; // kill and reload
3097     bool klass_reg_used = false;
3098 #ifdef ASSERT
3099     if (exact_klass != NULL) {
3100       Label ok;
3101       klass_reg_used = true;
3102       __ load_klass(klass, obj);
3103       metadata2reg(exact_klass-&gt;constant_encoding(), R0);
3104       __ cmpd(CCR0, klass, R0);
3105       __ beq(CCR0, ok);
3106       __ stop(&quot;exact klass and actual klass differ&quot;, 0x8564);
3107       __ bind(ok);
3108     }
3109 #endif
3110 
3111     if (!no_conflict) {
3112       if (exact_klass == NULL || TypeEntries::is_type_none(current_klass)) {
3113         klass_reg_used = true;
3114         if (exact_klass != NULL) {
3115           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3116           metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3117         } else {
3118           __ load_klass(klass, obj);
3119           __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register()); // may kill obj
3120         }
3121 
3122         // Like InterpreterMacroAssembler::profile_obj_type
3123         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3124         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3125         __ cmpd(CCR1, R0, klass);
3126         // Klass seen before, nothing to do (regardless of unknown bit).
3127         //beq(CCR1, do_nothing);
3128 
3129         __ andi_(R0, klass, TypeEntries::type_unknown);
3130         // Already unknown. Nothing to do anymore.
3131         //bne(CCR0, do_nothing);
3132         __ crorc(CCR0, Assembler::equal, CCR1, Assembler::equal); // cr0 eq = cr1 eq or cr0 ne
3133         __ beq(CCR0, Lnext);
3134 
3135         if (TypeEntries::is_type_none(current_klass)) {
3136           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3137           __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3138           __ beq(CCR0, Ldo_update); // First time here. Set profile type.
3139         }
3140 
3141       } else {
3142         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3143                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;conflict only&quot;);
3144 
3145         __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3146         __ andi_(R0, tmp, TypeEntries::type_unknown);
3147         // Already unknown. Nothing to do anymore.
3148         __ bne(CCR0, Lnext);
3149       }
3150 
3151       // Different than before. Cannot keep accurate profile.
3152       __ ori(R0, tmp, TypeEntries::type_unknown);
3153     } else {
3154       // There&#39;s a single possible klass at this profile point
3155       assert(exact_klass != NULL, &quot;should be&quot;);
3156       __ ld(tmp, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3157 
3158       if (TypeEntries::is_type_none(current_klass)) {
3159         klass_reg_used = true;
3160         metadata2reg(exact_klass-&gt;constant_encoding(), klass);
3161 
3162         __ clrrdi(R0, tmp, exact_log2(-TypeEntries::type_klass_mask));
3163         // Basically same as andi(R0, tmp, TypeEntries::type_klass_mask);
3164         __ cmpd(CCR1, R0, klass);
3165         // Klass seen before, nothing to do (regardless of unknown bit).
3166         __ beq(CCR1, Lnext);
3167 #ifdef ASSERT
3168         {
3169           Label ok;
3170           __ clrrdi_(R0, tmp, exact_log2(-TypeEntries::type_mask));
3171           __ beq(CCR0, ok); // First time here.
3172 
3173           __ stop(&quot;unexpected profiling mismatch&quot;, 0x7865);
3174           __ bind(ok);
3175         }
3176 #endif
3177         // First time here. Set profile type.
3178         __ orr(R0, klass, tmp); // Combine klass and null_seen bit (only used if (tmp &amp; type_mask)==0).
3179       } else {
3180         assert(ciTypeEntries::valid_ciklass(current_klass) != NULL &amp;&amp;
3181                ciTypeEntries::valid_ciklass(current_klass) != exact_klass, &quot;inconsistent&quot;);
3182 
3183         // Already unknown. Nothing to do anymore.
3184         __ andi_(R0, tmp, TypeEntries::type_unknown);
3185         __ bne(CCR0, Lnext);
3186 
3187         // Different than before. Cannot keep accurate profile.
3188         __ ori(R0, tmp, TypeEntries::type_unknown);
3189       }
3190     }
3191 
3192     __ bind(Ldo_update);
3193     __ std(R0, index_or_disp(mdo_addr), mdo_addr-&gt;base()-&gt;as_pointer_register());
3194 
3195     __ bind(Lnext);
3196     if (klass_reg_used) { __ load_const_optimized(R29_TOC, MacroAssembler::global_toc(), R0); } // reinit
3197   }
3198   __ bind(Ldone);
3199 }
3200 
3201 
3202 void LIR_Assembler::emit_updatecrc32(LIR_OpUpdateCRC32* op) {
3203   assert(op-&gt;crc()-&gt;is_single_cpu(), &quot;crc must be register&quot;);
3204   assert(op-&gt;val()-&gt;is_single_cpu(), &quot;byte value must be register&quot;);
3205   assert(op-&gt;result_opr()-&gt;is_single_cpu(), &quot;result must be register&quot;);
3206   Register crc = op-&gt;crc()-&gt;as_register();
3207   Register val = op-&gt;val()-&gt;as_register();
3208   Register res = op-&gt;result_opr()-&gt;as_register();
3209 
3210   assert_different_registers(val, crc, res);
3211 
3212   __ load_const_optimized(res, StubRoutines::crc_table_addr(), R0);
3213   __ kernel_crc32_singleByteReg(crc, val, res, true);
3214   __ mr(res, crc);
3215 }
3216 
3217 #undef __
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="4" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/ppc/ppc.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
<a name="1" id="anc1"></a><span class="line-modified">    2 // Copyright (c) 2011, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // Copyright (c) 2012, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
   23 //
   24 //
   25 
   26 //
   27 // PPC64 Architecture Description File
   28 //
   29 
   30 //----------REGISTER DEFINITION BLOCK------------------------------------------
   31 // This information is used by the matcher and the register allocator to
   32 // describe individual registers and classes of registers within the target
   33 // architecture.
   34 register %{
   35 //----------Architecture Description Register Definitions----------------------
   36 // General Registers
   37 // &quot;reg_def&quot;  name (register save type, C convention save type,
   38 //                  ideal register type, encoding);
   39 //
   40 // Register Save Types:
   41 //
   42 //   NS  = No-Save:     The register allocator assumes that these registers
   43 //                      can be used without saving upon entry to the method, &amp;
   44 //                      that they do not need to be saved at call sites.
   45 //
   46 //   SOC = Save-On-Call: The register allocator assumes that these registers
   47 //                      can be used without saving upon entry to the method,
   48 //                      but that they must be saved at call sites.
   49 //                      These are called &quot;volatiles&quot; on ppc.
   50 //
   51 //   SOE = Save-On-Entry: The register allocator assumes that these registers
   52 //                      must be saved before using them upon entry to the
   53 //                      method, but they do not need to be saved at call
   54 //                      sites.
   55 //                      These are called &quot;nonvolatiles&quot; on ppc.
   56 //
   57 //   AS  = Always-Save:   The register allocator assumes that these registers
   58 //                      must be saved before using them upon entry to the
   59 //                      method, &amp; that they must be saved at call sites.
   60 //
   61 // Ideal Register Type is used to determine how to save &amp; restore a
   62 // register. Op_RegI will get spilled with LoadI/StoreI, Op_RegP will get
   63 // spilled with LoadP/StoreP. If the register supports both, use Op_RegI.
   64 //
   65 // The encoding number is the actual bit-pattern placed into the opcodes.
   66 //
   67 // PPC64 register definitions, based on the 64-bit PowerPC ELF ABI
   68 // Supplement Version 1.7 as of 2003-10-29.
   69 //
   70 // For each 64-bit register we must define two registers: the register
   71 // itself, e.g. R3, and a corresponding virtual other (32-bit-)&#39;half&#39;,
   72 // e.g. R3_H, which is needed by the allocator, but is not used
   73 // for stores, loads, etc.
   74 
   75 // ----------------------------
   76 // Integer/Long Registers
   77 // ----------------------------
   78 
   79   // PPC64 has 32 64-bit integer registers.
   80 
   81   // types: v = volatile, nv = non-volatile, s = system
   82   reg_def R0   ( SOC, SOC, Op_RegI,  0, R0-&gt;as_VMReg()         );  // v   used in prologs
   83   reg_def R0_H ( SOC, SOC, Op_RegI, 99, R0-&gt;as_VMReg()-&gt;next() );
   84   reg_def R1   ( NS,  NS,  Op_RegI,  1, R1-&gt;as_VMReg()         );  // s   SP
   85   reg_def R1_H ( NS,  NS,  Op_RegI, 99, R1-&gt;as_VMReg()-&gt;next() );
   86   reg_def R2   ( SOC, SOC, Op_RegI,  2, R2-&gt;as_VMReg()         );  // v   TOC
   87   reg_def R2_H ( SOC, SOC, Op_RegI, 99, R2-&gt;as_VMReg()-&gt;next() );
   88   reg_def R3   ( SOC, SOC, Op_RegI,  3, R3-&gt;as_VMReg()         );  // v   iarg1 &amp; iret
   89   reg_def R3_H ( SOC, SOC, Op_RegI, 99, R3-&gt;as_VMReg()-&gt;next() );
   90   reg_def R4   ( SOC, SOC, Op_RegI,  4, R4-&gt;as_VMReg()         );  //     iarg2
   91   reg_def R4_H ( SOC, SOC, Op_RegI, 99, R4-&gt;as_VMReg()-&gt;next() );
   92   reg_def R5   ( SOC, SOC, Op_RegI,  5, R5-&gt;as_VMReg()         );  // v   iarg3
   93   reg_def R5_H ( SOC, SOC, Op_RegI, 99, R5-&gt;as_VMReg()-&gt;next() );
   94   reg_def R6   ( SOC, SOC, Op_RegI,  6, R6-&gt;as_VMReg()         );  // v   iarg4
   95   reg_def R6_H ( SOC, SOC, Op_RegI, 99, R6-&gt;as_VMReg()-&gt;next() );
   96   reg_def R7   ( SOC, SOC, Op_RegI,  7, R7-&gt;as_VMReg()         );  // v   iarg5
   97   reg_def R7_H ( SOC, SOC, Op_RegI, 99, R7-&gt;as_VMReg()-&gt;next() );
   98   reg_def R8   ( SOC, SOC, Op_RegI,  8, R8-&gt;as_VMReg()         );  // v   iarg6
   99   reg_def R8_H ( SOC, SOC, Op_RegI, 99, R8-&gt;as_VMReg()-&gt;next() );
  100   reg_def R9   ( SOC, SOC, Op_RegI,  9, R9-&gt;as_VMReg()         );  // v   iarg7
  101   reg_def R9_H ( SOC, SOC, Op_RegI, 99, R9-&gt;as_VMReg()-&gt;next() );
  102   reg_def R10  ( SOC, SOC, Op_RegI, 10, R10-&gt;as_VMReg()        );  // v   iarg8
  103   reg_def R10_H( SOC, SOC, Op_RegI, 99, R10-&gt;as_VMReg()-&gt;next());
  104   reg_def R11  ( SOC, SOC, Op_RegI, 11, R11-&gt;as_VMReg()        );  // v   ENV / scratch
  105   reg_def R11_H( SOC, SOC, Op_RegI, 99, R11-&gt;as_VMReg()-&gt;next());
  106   reg_def R12  ( SOC, SOC, Op_RegI, 12, R12-&gt;as_VMReg()        );  // v   scratch
  107   reg_def R12_H( SOC, SOC, Op_RegI, 99, R12-&gt;as_VMReg()-&gt;next());
  108   reg_def R13  ( NS,  NS,  Op_RegI, 13, R13-&gt;as_VMReg()        );  // s   system thread id
  109   reg_def R13_H( NS,  NS,  Op_RegI, 99, R13-&gt;as_VMReg()-&gt;next());
  110   reg_def R14  ( SOC, SOE, Op_RegI, 14, R14-&gt;as_VMReg()        );  // nv
  111   reg_def R14_H( SOC, SOE, Op_RegI, 99, R14-&gt;as_VMReg()-&gt;next());
  112   reg_def R15  ( SOC, SOE, Op_RegI, 15, R15-&gt;as_VMReg()        );  // nv
  113   reg_def R15_H( SOC, SOE, Op_RegI, 99, R15-&gt;as_VMReg()-&gt;next());
  114   reg_def R16  ( SOC, SOE, Op_RegI, 16, R16-&gt;as_VMReg()        );  // nv
  115   reg_def R16_H( SOC, SOE, Op_RegI, 99, R16-&gt;as_VMReg()-&gt;next());
  116   reg_def R17  ( SOC, SOE, Op_RegI, 17, R17-&gt;as_VMReg()        );  // nv
  117   reg_def R17_H( SOC, SOE, Op_RegI, 99, R17-&gt;as_VMReg()-&gt;next());
  118   reg_def R18  ( SOC, SOE, Op_RegI, 18, R18-&gt;as_VMReg()        );  // nv
  119   reg_def R18_H( SOC, SOE, Op_RegI, 99, R18-&gt;as_VMReg()-&gt;next());
  120   reg_def R19  ( SOC, SOE, Op_RegI, 19, R19-&gt;as_VMReg()        );  // nv
  121   reg_def R19_H( SOC, SOE, Op_RegI, 99, R19-&gt;as_VMReg()-&gt;next());
  122   reg_def R20  ( SOC, SOE, Op_RegI, 20, R20-&gt;as_VMReg()        );  // nv
  123   reg_def R20_H( SOC, SOE, Op_RegI, 99, R20-&gt;as_VMReg()-&gt;next());
  124   reg_def R21  ( SOC, SOE, Op_RegI, 21, R21-&gt;as_VMReg()        );  // nv
  125   reg_def R21_H( SOC, SOE, Op_RegI, 99, R21-&gt;as_VMReg()-&gt;next());
  126   reg_def R22  ( SOC, SOE, Op_RegI, 22, R22-&gt;as_VMReg()        );  // nv
  127   reg_def R22_H( SOC, SOE, Op_RegI, 99, R22-&gt;as_VMReg()-&gt;next());
  128   reg_def R23  ( SOC, SOE, Op_RegI, 23, R23-&gt;as_VMReg()        );  // nv
  129   reg_def R23_H( SOC, SOE, Op_RegI, 99, R23-&gt;as_VMReg()-&gt;next());
  130   reg_def R24  ( SOC, SOE, Op_RegI, 24, R24-&gt;as_VMReg()        );  // nv
  131   reg_def R24_H( SOC, SOE, Op_RegI, 99, R24-&gt;as_VMReg()-&gt;next());
  132   reg_def R25  ( SOC, SOE, Op_RegI, 25, R25-&gt;as_VMReg()        );  // nv
  133   reg_def R25_H( SOC, SOE, Op_RegI, 99, R25-&gt;as_VMReg()-&gt;next());
  134   reg_def R26  ( SOC, SOE, Op_RegI, 26, R26-&gt;as_VMReg()        );  // nv
  135   reg_def R26_H( SOC, SOE, Op_RegI, 99, R26-&gt;as_VMReg()-&gt;next());
  136   reg_def R27  ( SOC, SOE, Op_RegI, 27, R27-&gt;as_VMReg()        );  // nv
  137   reg_def R27_H( SOC, SOE, Op_RegI, 99, R27-&gt;as_VMReg()-&gt;next());
  138   reg_def R28  ( SOC, SOE, Op_RegI, 28, R28-&gt;as_VMReg()        );  // nv
  139   reg_def R28_H( SOC, SOE, Op_RegI, 99, R28-&gt;as_VMReg()-&gt;next());
  140   reg_def R29  ( SOC, SOE, Op_RegI, 29, R29-&gt;as_VMReg()        );  // nv
  141   reg_def R29_H( SOC, SOE, Op_RegI, 99, R29-&gt;as_VMReg()-&gt;next());
  142   reg_def R30  ( SOC, SOE, Op_RegI, 30, R30-&gt;as_VMReg()        );  // nv
  143   reg_def R30_H( SOC, SOE, Op_RegI, 99, R30-&gt;as_VMReg()-&gt;next());
  144   reg_def R31  ( SOC, SOE, Op_RegI, 31, R31-&gt;as_VMReg()        );  // nv
  145   reg_def R31_H( SOC, SOE, Op_RegI, 99, R31-&gt;as_VMReg()-&gt;next());
  146 
  147 
  148 // ----------------------------
  149 // Float/Double Registers
  150 // ----------------------------
  151 
  152   // Double Registers
  153   // The rules of ADL require that double registers be defined in pairs.
  154   // Each pair must be two 32-bit values, but not necessarily a pair of
  155   // single float registers. In each pair, ADLC-assigned register numbers
  156   // must be adjacent, with the lower number even. Finally, when the
  157   // CPU stores such a register pair to memory, the word associated with
  158   // the lower ADLC-assigned number must be stored to the lower address.
  159 
  160   // PPC64 has 32 64-bit floating-point registers. Each can store a single
  161   // or double precision floating-point value.
  162 
  163   // types: v = volatile, nv = non-volatile, s = system
  164   reg_def F0   ( SOC, SOC, Op_RegF,  0, F0-&gt;as_VMReg()         );  // v   scratch
  165   reg_def F0_H ( SOC, SOC, Op_RegF, 99, F0-&gt;as_VMReg()-&gt;next() );
  166   reg_def F1   ( SOC, SOC, Op_RegF,  1, F1-&gt;as_VMReg()         );  // v   farg1 &amp; fret
  167   reg_def F1_H ( SOC, SOC, Op_RegF, 99, F1-&gt;as_VMReg()-&gt;next() );
  168   reg_def F2   ( SOC, SOC, Op_RegF,  2, F2-&gt;as_VMReg()         );  // v   farg2
  169   reg_def F2_H ( SOC, SOC, Op_RegF, 99, F2-&gt;as_VMReg()-&gt;next() );
  170   reg_def F3   ( SOC, SOC, Op_RegF,  3, F3-&gt;as_VMReg()         );  // v   farg3
  171   reg_def F3_H ( SOC, SOC, Op_RegF, 99, F3-&gt;as_VMReg()-&gt;next() );
  172   reg_def F4   ( SOC, SOC, Op_RegF,  4, F4-&gt;as_VMReg()         );  // v   farg4
  173   reg_def F4_H ( SOC, SOC, Op_RegF, 99, F4-&gt;as_VMReg()-&gt;next() );
  174   reg_def F5   ( SOC, SOC, Op_RegF,  5, F5-&gt;as_VMReg()         );  // v   farg5
  175   reg_def F5_H ( SOC, SOC, Op_RegF, 99, F5-&gt;as_VMReg()-&gt;next() );
  176   reg_def F6   ( SOC, SOC, Op_RegF,  6, F6-&gt;as_VMReg()         );  // v   farg6
  177   reg_def F6_H ( SOC, SOC, Op_RegF, 99, F6-&gt;as_VMReg()-&gt;next() );
  178   reg_def F7   ( SOC, SOC, Op_RegF,  7, F7-&gt;as_VMReg()         );  // v   farg7
  179   reg_def F7_H ( SOC, SOC, Op_RegF, 99, F7-&gt;as_VMReg()-&gt;next() );
  180   reg_def F8   ( SOC, SOC, Op_RegF,  8, F8-&gt;as_VMReg()         );  // v   farg8
  181   reg_def F8_H ( SOC, SOC, Op_RegF, 99, F8-&gt;as_VMReg()-&gt;next() );
  182   reg_def F9   ( SOC, SOC, Op_RegF,  9, F9-&gt;as_VMReg()         );  // v   farg9
  183   reg_def F9_H ( SOC, SOC, Op_RegF, 99, F9-&gt;as_VMReg()-&gt;next() );
  184   reg_def F10  ( SOC, SOC, Op_RegF, 10, F10-&gt;as_VMReg()        );  // v   farg10
  185   reg_def F10_H( SOC, SOC, Op_RegF, 99, F10-&gt;as_VMReg()-&gt;next());
  186   reg_def F11  ( SOC, SOC, Op_RegF, 11, F11-&gt;as_VMReg()        );  // v   farg11
  187   reg_def F11_H( SOC, SOC, Op_RegF, 99, F11-&gt;as_VMReg()-&gt;next());
  188   reg_def F12  ( SOC, SOC, Op_RegF, 12, F12-&gt;as_VMReg()        );  // v   farg12
  189   reg_def F12_H( SOC, SOC, Op_RegF, 99, F12-&gt;as_VMReg()-&gt;next());
  190   reg_def F13  ( SOC, SOC, Op_RegF, 13, F13-&gt;as_VMReg()        );  // v   farg13
  191   reg_def F13_H( SOC, SOC, Op_RegF, 99, F13-&gt;as_VMReg()-&gt;next());
  192   reg_def F14  ( SOC, SOE, Op_RegF, 14, F14-&gt;as_VMReg()        );  // nv
  193   reg_def F14_H( SOC, SOE, Op_RegF, 99, F14-&gt;as_VMReg()-&gt;next());
  194   reg_def F15  ( SOC, SOE, Op_RegF, 15, F15-&gt;as_VMReg()        );  // nv
  195   reg_def F15_H( SOC, SOE, Op_RegF, 99, F15-&gt;as_VMReg()-&gt;next());
  196   reg_def F16  ( SOC, SOE, Op_RegF, 16, F16-&gt;as_VMReg()        );  // nv
  197   reg_def F16_H( SOC, SOE, Op_RegF, 99, F16-&gt;as_VMReg()-&gt;next());
  198   reg_def F17  ( SOC, SOE, Op_RegF, 17, F17-&gt;as_VMReg()        );  // nv
  199   reg_def F17_H( SOC, SOE, Op_RegF, 99, F17-&gt;as_VMReg()-&gt;next());
  200   reg_def F18  ( SOC, SOE, Op_RegF, 18, F18-&gt;as_VMReg()        );  // nv
  201   reg_def F18_H( SOC, SOE, Op_RegF, 99, F18-&gt;as_VMReg()-&gt;next());
  202   reg_def F19  ( SOC, SOE, Op_RegF, 19, F19-&gt;as_VMReg()        );  // nv
  203   reg_def F19_H( SOC, SOE, Op_RegF, 99, F19-&gt;as_VMReg()-&gt;next());
  204   reg_def F20  ( SOC, SOE, Op_RegF, 20, F20-&gt;as_VMReg()        );  // nv
  205   reg_def F20_H( SOC, SOE, Op_RegF, 99, F20-&gt;as_VMReg()-&gt;next());
  206   reg_def F21  ( SOC, SOE, Op_RegF, 21, F21-&gt;as_VMReg()        );  // nv
  207   reg_def F21_H( SOC, SOE, Op_RegF, 99, F21-&gt;as_VMReg()-&gt;next());
  208   reg_def F22  ( SOC, SOE, Op_RegF, 22, F22-&gt;as_VMReg()        );  // nv
  209   reg_def F22_H( SOC, SOE, Op_RegF, 99, F22-&gt;as_VMReg()-&gt;next());
  210   reg_def F23  ( SOC, SOE, Op_RegF, 23, F23-&gt;as_VMReg()        );  // nv
  211   reg_def F23_H( SOC, SOE, Op_RegF, 99, F23-&gt;as_VMReg()-&gt;next());
  212   reg_def F24  ( SOC, SOE, Op_RegF, 24, F24-&gt;as_VMReg()        );  // nv
  213   reg_def F24_H( SOC, SOE, Op_RegF, 99, F24-&gt;as_VMReg()-&gt;next());
  214   reg_def F25  ( SOC, SOE, Op_RegF, 25, F25-&gt;as_VMReg()        );  // nv
  215   reg_def F25_H( SOC, SOE, Op_RegF, 99, F25-&gt;as_VMReg()-&gt;next());
  216   reg_def F26  ( SOC, SOE, Op_RegF, 26, F26-&gt;as_VMReg()        );  // nv
  217   reg_def F26_H( SOC, SOE, Op_RegF, 99, F26-&gt;as_VMReg()-&gt;next());
  218   reg_def F27  ( SOC, SOE, Op_RegF, 27, F27-&gt;as_VMReg()        );  // nv
  219   reg_def F27_H( SOC, SOE, Op_RegF, 99, F27-&gt;as_VMReg()-&gt;next());
  220   reg_def F28  ( SOC, SOE, Op_RegF, 28, F28-&gt;as_VMReg()        );  // nv
  221   reg_def F28_H( SOC, SOE, Op_RegF, 99, F28-&gt;as_VMReg()-&gt;next());
  222   reg_def F29  ( SOC, SOE, Op_RegF, 29, F29-&gt;as_VMReg()        );  // nv
  223   reg_def F29_H( SOC, SOE, Op_RegF, 99, F29-&gt;as_VMReg()-&gt;next());
  224   reg_def F30  ( SOC, SOE, Op_RegF, 30, F30-&gt;as_VMReg()        );  // nv
  225   reg_def F30_H( SOC, SOE, Op_RegF, 99, F30-&gt;as_VMReg()-&gt;next());
  226   reg_def F31  ( SOC, SOE, Op_RegF, 31, F31-&gt;as_VMReg()        );  // nv
  227   reg_def F31_H( SOC, SOE, Op_RegF, 99, F31-&gt;as_VMReg()-&gt;next());
  228 
  229 // ----------------------------
  230 // Special Registers
  231 // ----------------------------
  232 
  233 // Condition Codes Flag Registers
  234 
  235   // PPC64 has 8 condition code &quot;registers&quot; which are all contained
  236   // in the CR register.
  237 
  238   // types: v = volatile, nv = non-volatile, s = system
  239   reg_def CCR0(SOC, SOC, Op_RegFlags, 0, CCR0-&gt;as_VMReg());  // v
  240   reg_def CCR1(SOC, SOC, Op_RegFlags, 1, CCR1-&gt;as_VMReg());  // v
  241   reg_def CCR2(SOC, SOC, Op_RegFlags, 2, CCR2-&gt;as_VMReg());  // nv
  242   reg_def CCR3(SOC, SOC, Op_RegFlags, 3, CCR3-&gt;as_VMReg());  // nv
  243   reg_def CCR4(SOC, SOC, Op_RegFlags, 4, CCR4-&gt;as_VMReg());  // nv
  244   reg_def CCR5(SOC, SOC, Op_RegFlags, 5, CCR5-&gt;as_VMReg());  // v
  245   reg_def CCR6(SOC, SOC, Op_RegFlags, 6, CCR6-&gt;as_VMReg());  // v
  246   reg_def CCR7(SOC, SOC, Op_RegFlags, 7, CCR7-&gt;as_VMReg());  // v
  247 
  248   // Special registers of PPC64
  249 
  250   reg_def SR_XER(    SOC, SOC, Op_RegP, 0, SR_XER-&gt;as_VMReg());     // v
  251   reg_def SR_LR(     SOC, SOC, Op_RegP, 1, SR_LR-&gt;as_VMReg());      // v
  252   reg_def SR_CTR(    SOC, SOC, Op_RegP, 2, SR_CTR-&gt;as_VMReg());     // v
  253   reg_def SR_VRSAVE( SOC, SOC, Op_RegP, 3, SR_VRSAVE-&gt;as_VMReg());  // v
  254   reg_def SR_SPEFSCR(SOC, SOC, Op_RegP, 4, SR_SPEFSCR-&gt;as_VMReg()); // v
  255   reg_def SR_PPR(    SOC, SOC, Op_RegP, 5, SR_PPR-&gt;as_VMReg());     // v
  256 
  257 // ----------------------------
  258 // Vector-Scalar Registers
  259 // ----------------------------
  260   reg_def VSR0 ( SOC, SOC, Op_VecX, 0, NULL);
  261   reg_def VSR1 ( SOC, SOC, Op_VecX, 1, NULL);
  262   reg_def VSR2 ( SOC, SOC, Op_VecX, 2, NULL);
  263   reg_def VSR3 ( SOC, SOC, Op_VecX, 3, NULL);
  264   reg_def VSR4 ( SOC, SOC, Op_VecX, 4, NULL);
  265   reg_def VSR5 ( SOC, SOC, Op_VecX, 5, NULL);
  266   reg_def VSR6 ( SOC, SOC, Op_VecX, 6, NULL);
  267   reg_def VSR7 ( SOC, SOC, Op_VecX, 7, NULL);
  268   reg_def VSR8 ( SOC, SOC, Op_VecX, 8, NULL);
  269   reg_def VSR9 ( SOC, SOC, Op_VecX, 9, NULL);
  270   reg_def VSR10 ( SOC, SOC, Op_VecX, 10, NULL);
  271   reg_def VSR11 ( SOC, SOC, Op_VecX, 11, NULL);
  272   reg_def VSR12 ( SOC, SOC, Op_VecX, 12, NULL);
  273   reg_def VSR13 ( SOC, SOC, Op_VecX, 13, NULL);
  274   reg_def VSR14 ( SOC, SOC, Op_VecX, 14, NULL);
  275   reg_def VSR15 ( SOC, SOC, Op_VecX, 15, NULL);
  276   reg_def VSR16 ( SOC, SOC, Op_VecX, 16, NULL);
  277   reg_def VSR17 ( SOC, SOC, Op_VecX, 17, NULL);
  278   reg_def VSR18 ( SOC, SOC, Op_VecX, 18, NULL);
  279   reg_def VSR19 ( SOC, SOC, Op_VecX, 19, NULL);
  280   reg_def VSR20 ( SOC, SOC, Op_VecX, 20, NULL);
  281   reg_def VSR21 ( SOC, SOC, Op_VecX, 21, NULL);
  282   reg_def VSR22 ( SOC, SOC, Op_VecX, 22, NULL);
  283   reg_def VSR23 ( SOC, SOC, Op_VecX, 23, NULL);
  284   reg_def VSR24 ( SOC, SOC, Op_VecX, 24, NULL);
  285   reg_def VSR25 ( SOC, SOC, Op_VecX, 25, NULL);
  286   reg_def VSR26 ( SOC, SOC, Op_VecX, 26, NULL);
  287   reg_def VSR27 ( SOC, SOC, Op_VecX, 27, NULL);
  288   reg_def VSR28 ( SOC, SOC, Op_VecX, 28, NULL);
  289   reg_def VSR29 ( SOC, SOC, Op_VecX, 29, NULL);
  290   reg_def VSR30 ( SOC, SOC, Op_VecX, 30, NULL);
  291   reg_def VSR31 ( SOC, SOC, Op_VecX, 31, NULL);
  292   reg_def VSR32 ( SOC, SOC, Op_VecX, 32, NULL);
  293   reg_def VSR33 ( SOC, SOC, Op_VecX, 33, NULL);
  294   reg_def VSR34 ( SOC, SOC, Op_VecX, 34, NULL);
  295   reg_def VSR35 ( SOC, SOC, Op_VecX, 35, NULL);
  296   reg_def VSR36 ( SOC, SOC, Op_VecX, 36, NULL);
  297   reg_def VSR37 ( SOC, SOC, Op_VecX, 37, NULL);
  298   reg_def VSR38 ( SOC, SOC, Op_VecX, 38, NULL);
  299   reg_def VSR39 ( SOC, SOC, Op_VecX, 39, NULL);
  300   reg_def VSR40 ( SOC, SOC, Op_VecX, 40, NULL);
  301   reg_def VSR41 ( SOC, SOC, Op_VecX, 41, NULL);
  302   reg_def VSR42 ( SOC, SOC, Op_VecX, 42, NULL);
  303   reg_def VSR43 ( SOC, SOC, Op_VecX, 43, NULL);
  304   reg_def VSR44 ( SOC, SOC, Op_VecX, 44, NULL);
  305   reg_def VSR45 ( SOC, SOC, Op_VecX, 45, NULL);
  306   reg_def VSR46 ( SOC, SOC, Op_VecX, 46, NULL);
  307   reg_def VSR47 ( SOC, SOC, Op_VecX, 47, NULL);
  308   reg_def VSR48 ( SOC, SOC, Op_VecX, 48, NULL);
  309   reg_def VSR49 ( SOC, SOC, Op_VecX, 49, NULL);
  310   reg_def VSR50 ( SOC, SOC, Op_VecX, 50, NULL);
  311   reg_def VSR51 ( SOC, SOC, Op_VecX, 51, NULL);
  312   reg_def VSR52 ( SOC, SOC, Op_VecX, 52, NULL);
  313   reg_def VSR53 ( SOC, SOC, Op_VecX, 53, NULL);
  314   reg_def VSR54 ( SOC, SOC, Op_VecX, 54, NULL);
  315   reg_def VSR55 ( SOC, SOC, Op_VecX, 55, NULL);
  316   reg_def VSR56 ( SOC, SOC, Op_VecX, 56, NULL);
  317   reg_def VSR57 ( SOC, SOC, Op_VecX, 57, NULL);
  318   reg_def VSR58 ( SOC, SOC, Op_VecX, 58, NULL);
  319   reg_def VSR59 ( SOC, SOC, Op_VecX, 59, NULL);
  320   reg_def VSR60 ( SOC, SOC, Op_VecX, 60, NULL);
  321   reg_def VSR61 ( SOC, SOC, Op_VecX, 61, NULL);
  322   reg_def VSR62 ( SOC, SOC, Op_VecX, 62, NULL);
  323   reg_def VSR63 ( SOC, SOC, Op_VecX, 63, NULL);
  324 
  325 // ----------------------------
  326 // Specify priority of register selection within phases of register
  327 // allocation. Highest priority is first. A useful heuristic is to
  328 // give registers a low priority when they are required by machine
  329 // instructions, like EAX and EDX on I486, and choose no-save registers
  330 // before save-on-call, &amp; save-on-call before save-on-entry. Registers
  331 // which participate in fixed calling sequences should come last.
  332 // Registers which are used as pairs must fall on an even boundary.
  333 
  334 // It&#39;s worth about 1% on SPEC geomean to get this right.
  335 
  336 // Chunk0, chunk1, and chunk2 form the MachRegisterNumbers enumeration
  337 // in adGlobals_ppc.hpp which defines the &lt;register&gt;_num values, e.g.
  338 // R3_num. Therefore, R3_num may not be (and in reality is not)
  339 // the same as R3-&gt;encoding()! Furthermore, we cannot make any
  340 // assumptions on ordering, e.g. R3_num may be less than R2_num.
  341 // Additionally, the function
  342 //   static enum RC rc_class(OptoReg::Name reg )
  343 // maps a given &lt;register&gt;_num value to its chunk type (except for flags)
  344 // and its current implementation relies on chunk0 and chunk1 having a
  345 // size of 64 each.
  346 
  347 // If you change this allocation class, please have a look at the
  348 // default values for the parameters RoundRobinIntegerRegIntervalStart
  349 // and RoundRobinFloatRegIntervalStart
  350 
  351 alloc_class chunk0 (
  352   // Chunk0 contains *all* 64 integer registers halves.
  353 
  354   // &quot;non-volatile&quot; registers
  355   R14, R14_H,
  356   R15, R15_H,
  357   R17, R17_H,
  358   R18, R18_H,
  359   R19, R19_H,
  360   R20, R20_H,
  361   R21, R21_H,
  362   R22, R22_H,
  363   R23, R23_H,
  364   R24, R24_H,
  365   R25, R25_H,
  366   R26, R26_H,
  367   R27, R27_H,
  368   R28, R28_H,
  369   R29, R29_H,
  370   R30, R30_H,
  371   R31, R31_H,
  372 
  373   // scratch/special registers
  374   R11, R11_H,
  375   R12, R12_H,
  376 
  377   // argument registers
  378   R10, R10_H,
  379   R9,  R9_H,
  380   R8,  R8_H,
  381   R7,  R7_H,
  382   R6,  R6_H,
  383   R5,  R5_H,
  384   R4,  R4_H,
  385   R3,  R3_H,
  386 
  387   // special registers, not available for allocation
  388   R16, R16_H,     // R16_thread
  389   R13, R13_H,     // system thread id
  390   R2,  R2_H,      // may be used for TOC
  391   R1,  R1_H,      // SP
  392   R0,  R0_H       // R0 (scratch)
  393 );
  394 
  395 // If you change this allocation class, please have a look at the
  396 // default values for the parameters RoundRobinIntegerRegIntervalStart
  397 // and RoundRobinFloatRegIntervalStart
  398 
  399 alloc_class chunk1 (
  400   // Chunk1 contains *all* 64 floating-point registers halves.
  401 
  402   // scratch register
  403   F0,  F0_H,
  404 
  405   // argument registers
  406   F13, F13_H,
  407   F12, F12_H,
  408   F11, F11_H,
  409   F10, F10_H,
  410   F9,  F9_H,
  411   F8,  F8_H,
  412   F7,  F7_H,
  413   F6,  F6_H,
  414   F5,  F5_H,
  415   F4,  F4_H,
  416   F3,  F3_H,
  417   F2,  F2_H,
  418   F1,  F1_H,
  419 
  420   // non-volatile registers
  421   F14, F14_H,
  422   F15, F15_H,
  423   F16, F16_H,
  424   F17, F17_H,
  425   F18, F18_H,
  426   F19, F19_H,
  427   F20, F20_H,
  428   F21, F21_H,
  429   F22, F22_H,
  430   F23, F23_H,
  431   F24, F24_H,
  432   F25, F25_H,
  433   F26, F26_H,
  434   F27, F27_H,
  435   F28, F28_H,
  436   F29, F29_H,
  437   F30, F30_H,
  438   F31, F31_H
  439 );
  440 
  441 alloc_class chunk2 (
  442   // Chunk2 contains *all* 8 condition code registers.
  443 
  444   CCR0,
  445   CCR1,
  446   CCR2,
  447   CCR3,
  448   CCR4,
  449   CCR5,
  450   CCR6,
  451   CCR7
  452 );
  453 
  454 alloc_class chunk3 (
  455   VSR0,
  456   VSR1,
  457   VSR2,
  458   VSR3,
  459   VSR4,
  460   VSR5,
  461   VSR6,
  462   VSR7,
  463   VSR8,
  464   VSR9,
  465   VSR10,
  466   VSR11,
  467   VSR12,
  468   VSR13,
  469   VSR14,
  470   VSR15,
  471   VSR16,
  472   VSR17,
  473   VSR18,
  474   VSR19,
  475   VSR20,
  476   VSR21,
  477   VSR22,
  478   VSR23,
  479   VSR24,
  480   VSR25,
  481   VSR26,
  482   VSR27,
  483   VSR28,
  484   VSR29,
  485   VSR30,
  486   VSR31,
  487   VSR32,
  488   VSR33,
  489   VSR34,
  490   VSR35,
  491   VSR36,
  492   VSR37,
  493   VSR38,
  494   VSR39,
  495   VSR40,
  496   VSR41,
  497   VSR42,
  498   VSR43,
  499   VSR44,
  500   VSR45,
  501   VSR46,
  502   VSR47,
  503   VSR48,
  504   VSR49,
  505   VSR50,
  506   VSR51,
  507   VSR52,
  508   VSR53,
  509   VSR54,
  510   VSR55,
  511   VSR56,
  512   VSR57,
  513   VSR58,
  514   VSR59,
  515   VSR60,
  516   VSR61,
  517   VSR62,
  518   VSR63
  519 );
  520 
  521 alloc_class chunk4 (
  522   // special registers
  523   // These registers are not allocated, but used for nodes generated by postalloc expand.
  524   SR_XER,
  525   SR_LR,
  526   SR_CTR,
  527   SR_VRSAVE,
  528   SR_SPEFSCR,
  529   SR_PPR
  530 );
  531 
  532 //-------Architecture Description Register Classes-----------------------
  533 
  534 // Several register classes are automatically defined based upon
  535 // information in this architecture description.
  536 
  537 // 1) reg_class inline_cache_reg           ( as defined in frame section )
  538 // 2) reg_class compiler_method_oop_reg    ( as defined in frame section )
  539 // 2) reg_class interpreter_method_oop_reg ( as defined in frame section )
  540 // 3) reg_class stack_slots( /* one chunk of stack-based &quot;registers&quot; */ )
  541 //
  542 
  543 // ----------------------------
  544 // 32 Bit Register Classes
  545 // ----------------------------
  546 
  547 // We specify registers twice, once as read/write, and once read-only.
  548 // We use the read-only registers for source operands. With this, we
  549 // can include preset read only registers in this class, as a hard-coded
  550 // &#39;0&#39;-register. (We used to simulate this on ppc.)
  551 
  552 // 32 bit registers that can be read and written i.e. these registers
  553 // can be dest (or src) of normal instructions.
  554 reg_class bits32_reg_rw(
  555 /*R0*/              // R0
  556 /*R1*/              // SP
  557   R2,               // TOC
  558   R3,
  559   R4,
  560   R5,
  561   R6,
  562   R7,
  563   R8,
  564   R9,
  565   R10,
  566   R11,
  567   R12,
  568 /*R13*/             // system thread id
  569   R14,
  570   R15,
  571 /*R16*/             // R16_thread
  572   R17,
  573   R18,
  574   R19,
  575   R20,
  576   R21,
  577   R22,
  578   R23,
  579   R24,
  580   R25,
  581   R26,
  582   R27,
  583   R28,
  584 /*R29,*/             // global TOC
  585   R30,
  586   R31
  587 );
  588 
  589 // 32 bit registers that can only be read i.e. these registers can
  590 // only be src of all instructions.
  591 reg_class bits32_reg_ro(
  592 /*R0*/              // R0
  593 /*R1*/              // SP
  594   R2                // TOC
  595   R3,
  596   R4,
  597   R5,
  598   R6,
  599   R7,
  600   R8,
  601   R9,
  602   R10,
  603   R11,
  604   R12,
  605 /*R13*/             // system thread id
  606   R14,
  607   R15,
  608 /*R16*/             // R16_thread
  609   R17,
  610   R18,
  611   R19,
  612   R20,
  613   R21,
  614   R22,
  615   R23,
  616   R24,
  617   R25,
  618   R26,
  619   R27,
  620   R28,
  621 /*R29,*/
  622   R30,
  623   R31
  624 );
  625 
  626 reg_class rscratch1_bits32_reg(R11);
  627 reg_class rscratch2_bits32_reg(R12);
  628 reg_class rarg1_bits32_reg(R3);
  629 reg_class rarg2_bits32_reg(R4);
  630 reg_class rarg3_bits32_reg(R5);
  631 reg_class rarg4_bits32_reg(R6);
  632 
  633 // ----------------------------
  634 // 64 Bit Register Classes
  635 // ----------------------------
  636 // 64-bit build means 64-bit pointers means hi/lo pairs
  637 
  638 reg_class rscratch1_bits64_reg(R11_H, R11);
  639 reg_class rscratch2_bits64_reg(R12_H, R12);
  640 reg_class rarg1_bits64_reg(R3_H, R3);
  641 reg_class rarg2_bits64_reg(R4_H, R4);
  642 reg_class rarg3_bits64_reg(R5_H, R5);
  643 reg_class rarg4_bits64_reg(R6_H, R6);
  644 // Thread register, &#39;written&#39; by tlsLoadP, see there.
  645 reg_class thread_bits64_reg(R16_H, R16);
  646 
  647 reg_class r19_bits64_reg(R19_H, R19);
  648 
  649 // 64 bit registers that can be read and written i.e. these registers
  650 // can be dest (or src) of normal instructions.
  651 reg_class bits64_reg_rw(
  652 /*R0_H,  R0*/     // R0
  653 /*R1_H,  R1*/     // SP
  654   R2_H,  R2,      // TOC
  655   R3_H,  R3,
  656   R4_H,  R4,
  657   R5_H,  R5,
  658   R6_H,  R6,
  659   R7_H,  R7,
  660   R8_H,  R8,
  661   R9_H,  R9,
  662   R10_H, R10,
  663   R11_H, R11,
  664   R12_H, R12,
  665 /*R13_H, R13*/   // system thread id
  666   R14_H, R14,
  667   R15_H, R15,
  668 /*R16_H, R16*/   // R16_thread
  669   R17_H, R17,
  670   R18_H, R18,
  671   R19_H, R19,
  672   R20_H, R20,
  673   R21_H, R21,
  674   R22_H, R22,
  675   R23_H, R23,
  676   R24_H, R24,
  677   R25_H, R25,
  678   R26_H, R26,
  679   R27_H, R27,
  680   R28_H, R28,
  681 /*R29_H, R29,*/
  682   R30_H, R30,
  683   R31_H, R31
  684 );
  685 
  686 // 64 bit registers used excluding r2, r11 and r12
  687 // Used to hold the TOC to avoid collisions with expanded LeafCall which uses
  688 // r2, r11 and r12 internally.
  689 reg_class bits64_reg_leaf_call(
  690 /*R0_H,  R0*/     // R0
  691 /*R1_H,  R1*/     // SP
  692 /*R2_H,  R2*/     // TOC
  693   R3_H,  R3,
  694   R4_H,  R4,
  695   R5_H,  R5,
  696   R6_H,  R6,
  697   R7_H,  R7,
  698   R8_H,  R8,
  699   R9_H,  R9,
  700   R10_H, R10,
  701 /*R11_H, R11*/
  702 /*R12_H, R12*/
  703 /*R13_H, R13*/   // system thread id
  704   R14_H, R14,
  705   R15_H, R15,
  706 /*R16_H, R16*/   // R16_thread
  707   R17_H, R17,
  708   R18_H, R18,
  709   R19_H, R19,
  710   R20_H, R20,
  711   R21_H, R21,
  712   R22_H, R22,
  713   R23_H, R23,
  714   R24_H, R24,
  715   R25_H, R25,
  716   R26_H, R26,
  717   R27_H, R27,
  718   R28_H, R28,
  719 /*R29_H, R29,*/
  720   R30_H, R30,
  721   R31_H, R31
  722 );
  723 
  724 // Used to hold the TOC to avoid collisions with expanded DynamicCall
  725 // which uses r19 as inline cache internally and expanded LeafCall which uses
  726 // r2, r11 and r12 internally.
  727 reg_class bits64_constant_table_base(
  728 /*R0_H,  R0*/     // R0
  729 /*R1_H,  R1*/     // SP
  730 /*R2_H,  R2*/     // TOC
  731   R3_H,  R3,
  732   R4_H,  R4,
  733   R5_H,  R5,
  734   R6_H,  R6,
  735   R7_H,  R7,
  736   R8_H,  R8,
  737   R9_H,  R9,
  738   R10_H, R10,
  739 /*R11_H, R11*/
  740 /*R12_H, R12*/
  741 /*R13_H, R13*/   // system thread id
  742   R14_H, R14,
  743   R15_H, R15,
  744 /*R16_H, R16*/   // R16_thread
  745   R17_H, R17,
  746   R18_H, R18,
  747 /*R19_H, R19*/
  748   R20_H, R20,
  749   R21_H, R21,
  750   R22_H, R22,
  751   R23_H, R23,
  752   R24_H, R24,
  753   R25_H, R25,
  754   R26_H, R26,
  755   R27_H, R27,
  756   R28_H, R28,
  757 /*R29_H, R29,*/
  758   R30_H, R30,
  759   R31_H, R31
  760 );
  761 
  762 // 64 bit registers that can only be read i.e. these registers can
  763 // only be src of all instructions.
  764 reg_class bits64_reg_ro(
  765 /*R0_H,  R0*/     // R0
  766   R1_H,  R1,
  767   R2_H,  R2,       // TOC
  768   R3_H,  R3,
  769   R4_H,  R4,
  770   R5_H,  R5,
  771   R6_H,  R6,
  772   R7_H,  R7,
  773   R8_H,  R8,
  774   R9_H,  R9,
  775   R10_H, R10,
  776   R11_H, R11,
  777   R12_H, R12,
  778 /*R13_H, R13*/   // system thread id
  779   R14_H, R14,
  780   R15_H, R15,
  781   R16_H, R16,    // R16_thread
  782   R17_H, R17,
  783   R18_H, R18,
  784   R19_H, R19,
  785   R20_H, R20,
  786   R21_H, R21,
  787   R22_H, R22,
  788   R23_H, R23,
  789   R24_H, R24,
  790   R25_H, R25,
  791   R26_H, R26,
  792   R27_H, R27,
  793   R28_H, R28,
  794 /*R29_H, R29,*/ // TODO: let allocator handle TOC!!
  795   R30_H, R30,
  796   R31_H, R31
  797 );
  798 
  799 
  800 // ----------------------------
  801 // Special Class for Condition Code Flags Register
  802 
  803 reg_class int_flags(
  804 /*CCR0*/             // scratch
  805 /*CCR1*/             // scratch
  806 /*CCR2*/             // nv!
  807 /*CCR3*/             // nv!
  808 /*CCR4*/             // nv!
  809   CCR5,
  810   CCR6,
  811   CCR7
  812 );
  813 
  814 reg_class int_flags_ro(
  815   CCR0,
  816   CCR1,
  817   CCR2,
  818   CCR3,
  819   CCR4,
  820   CCR5,
  821   CCR6,
  822   CCR7
  823 );
  824 
  825 reg_class int_flags_CR0(CCR0);
  826 reg_class int_flags_CR1(CCR1);
  827 reg_class int_flags_CR6(CCR6);
  828 reg_class ctr_reg(SR_CTR);
  829 
  830 // ----------------------------
  831 // Float Register Classes
  832 // ----------------------------
  833 
  834 reg_class flt_reg(
  835   F0,
  836   F1,
  837   F2,
  838   F3,
  839   F4,
  840   F5,
  841   F6,
  842   F7,
  843   F8,
  844   F9,
  845   F10,
  846   F11,
  847   F12,
  848   F13,
  849   F14,              // nv!
  850   F15,              // nv!
  851   F16,              // nv!
  852   F17,              // nv!
  853   F18,              // nv!
  854   F19,              // nv!
  855   F20,              // nv!
  856   F21,              // nv!
  857   F22,              // nv!
  858   F23,              // nv!
  859   F24,              // nv!
  860   F25,              // nv!
  861   F26,              // nv!
  862   F27,              // nv!
  863   F28,              // nv!
  864   F29,              // nv!
  865   F30,              // nv!
  866   F31               // nv!
  867 );
  868 
  869 // Double precision float registers have virtual `high halves&#39; that
  870 // are needed by the allocator.
  871 reg_class dbl_reg(
  872   F0,  F0_H,
  873   F1,  F1_H,
  874   F2,  F2_H,
  875   F3,  F3_H,
  876   F4,  F4_H,
  877   F5,  F5_H,
  878   F6,  F6_H,
  879   F7,  F7_H,
  880   F8,  F8_H,
  881   F9,  F9_H,
  882   F10, F10_H,
  883   F11, F11_H,
  884   F12, F12_H,
  885   F13, F13_H,
  886   F14, F14_H,    // nv!
  887   F15, F15_H,    // nv!
  888   F16, F16_H,    // nv!
  889   F17, F17_H,    // nv!
  890   F18, F18_H,    // nv!
  891   F19, F19_H,    // nv!
  892   F20, F20_H,    // nv!
  893   F21, F21_H,    // nv!
  894   F22, F22_H,    // nv!
  895   F23, F23_H,    // nv!
  896   F24, F24_H,    // nv!
  897   F25, F25_H,    // nv!
  898   F26, F26_H,    // nv!
  899   F27, F27_H,    // nv!
  900   F28, F28_H,    // nv!
  901   F29, F29_H,    // nv!
  902   F30, F30_H,    // nv!
  903   F31, F31_H     // nv!
  904 );
  905 
  906 // ----------------------------
  907 // Vector-Scalar Register Class
  908 // ----------------------------
  909 
  910 reg_class vs_reg(
  911   // Attention: Only these ones are saved &amp; restored at safepoint by RegisterSaver.
  912   VSR32,
  913   VSR33,
  914   VSR34,
  915   VSR35,
  916   VSR36,
  917   VSR37,
  918   VSR38,
  919   VSR39,
  920   VSR40,
  921   VSR41,
  922   VSR42,
  923   VSR43,
  924   VSR44,
  925   VSR45,
  926   VSR46,
  927   VSR47,
  928   VSR48,
  929   VSR49,
  930   VSR50,
  931   VSR51
  932   // VSR52-VSR63 // nv!
  933 );
  934 
  935  %}
  936 
  937 //----------DEFINITION BLOCK---------------------------------------------------
  938 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
  939 // Current support includes integer values in the range [0, 0x7FFFFFFF]
  940 // Format:
  941 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
  942 // Generated Code in ad_&lt;arch&gt;.hpp
  943 //        #define  &lt;name&gt;   (&lt;expression&gt;)
  944 //        // value == &lt;int_value&gt;
  945 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
  946 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
  947 //
  948 definitions %{
  949   // The default cost (of an ALU instruction).
  950   int_def DEFAULT_COST_LOW        (     30,      30);
  951   int_def DEFAULT_COST            (    100,     100);
  952   int_def HUGE_COST               (1000000, 1000000);
  953 
  954   // Memory refs
  955   int_def MEMORY_REF_COST_LOW     (    200, DEFAULT_COST * 2);
  956   int_def MEMORY_REF_COST         (    300, DEFAULT_COST * 3);
  957 
  958   // Branches are even more expensive.
  959   int_def BRANCH_COST             (    900, DEFAULT_COST * 9);
  960   int_def CALL_COST               (   1300, DEFAULT_COST * 13);
  961 %}
  962 
  963 
  964 //----------SOURCE BLOCK-------------------------------------------------------
  965 // This is a block of C++ code which provides values, functions, and
  966 // definitions necessary in the rest of the architecture description.
  967 source_hpp %{
  968   // Header information of the source block.
  969   // Method declarations/definitions which are used outside
  970   // the ad-scope can conveniently be defined here.
  971   //
  972   // To keep related declarations/definitions/uses close together,
  973   // we switch between source %{ }% and source_hpp %{ }% freely as needed.
  974 
  975 #include &quot;opto/convertnode.hpp&quot;
  976 
  977   // Returns true if Node n is followed by a MemBar node that
  978   // will do an acquire. If so, this node must not do the acquire
  979   // operation.
  980   bool followed_by_acquire(const Node *n);
  981 %}
  982 
  983 source %{
  984 
<a name="2" id="anc2"></a><span class="line-added">  985 void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">  986 }</span>
<span class="line-added">  987 </span>
<span class="line-added">  988 int MachNode::pd_alignment_required() const {</span>
<span class="line-added">  989   return 1;</span>
<span class="line-added">  990 }</span>
<span class="line-added">  991 </span>
<span class="line-added">  992 int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">  993   return 0;</span>
<span class="line-added">  994 }</span>
<span class="line-added">  995 </span>
<span class="line-added">  996 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added">  997 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added">  998   return false;</span>
<span class="line-added">  999 }</span>
<span class="line-added"> 1000 </span>
 1001 // Should the Matcher clone shifts on addressing modes, expecting them
 1002 // to be subsumed into complex addressing expressions or compute them
 1003 // into registers?
<a name="3" id="anc3"></a><span class="line-modified"> 1004 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1005   return clone_base_plus_offset_address(m, mstack, address_visited);
 1006 }
 1007 
 1008 void Compile::reshape_address(AddPNode* addp) {
 1009 }
 1010 
 1011 // Optimize load-acquire.
 1012 //
 1013 // Check if acquire is unnecessary due to following operation that does
 1014 // acquire anyways.
 1015 // Walk the pattern:
 1016 //
 1017 //      n: Load.acq
 1018 //           |
 1019 //      MemBarAcquire
 1020 //       |         |
 1021 //  Proj(ctrl)  Proj(mem)
 1022 //       |         |
 1023 //   MemBarRelease/Volatile
 1024 //
 1025 bool followed_by_acquire(const Node *load) {
 1026   assert(load-&gt;is_Load(), &quot;So far implemented only for loads.&quot;);
 1027 
 1028   // Find MemBarAcquire.
 1029   const Node *mba = NULL;
 1030   for (DUIterator_Fast imax, i = load-&gt;fast_outs(imax); i &lt; imax; i++) {
 1031     const Node *out = load-&gt;fast_out(i);
 1032     if (out-&gt;Opcode() == Op_MemBarAcquire) {
 1033       if (out-&gt;in(0) == load) continue; // Skip control edge, membar should be found via precedence edge.
 1034       mba = out;
 1035       break;
 1036     }
 1037   }
 1038   if (!mba) return false;
 1039 
 1040   // Find following MemBar node.
 1041   //
 1042   // The following node must be reachable by control AND memory
 1043   // edge to assure no other operations are in between the two nodes.
 1044   //
 1045   // So first get the Proj node, mem_proj, to use it to iterate forward.
 1046   Node *mem_proj = NULL;
 1047   for (DUIterator_Fast imax, i = mba-&gt;fast_outs(imax); i &lt; imax; i++) {
 1048     mem_proj = mba-&gt;fast_out(i);      // Runs out of bounds and asserts if Proj not found.
 1049     assert(mem_proj-&gt;is_Proj(), &quot;only projections here&quot;);
 1050     ProjNode *proj = mem_proj-&gt;as_Proj();
 1051     if (proj-&gt;_con == TypeFunc::Memory &amp;&amp;
 1052         !Compile::current()-&gt;node_arena()-&gt;contains(mem_proj)) // Unmatched old-space only
 1053       break;
 1054   }
 1055   assert(mem_proj-&gt;as_Proj()-&gt;_con == TypeFunc::Memory, &quot;Graph broken&quot;);
 1056 
 1057   // Search MemBar behind Proj. If there are other memory operations
 1058   // behind the Proj we lost.
 1059   for (DUIterator_Fast jmax, j = mem_proj-&gt;fast_outs(jmax); j &lt; jmax; j++) {
 1060     Node *x = mem_proj-&gt;fast_out(j);
 1061     // Proj might have an edge to a store or load node which precedes the membar.
 1062     if (x-&gt;is_Mem()) return false;
 1063 
 1064     // On PPC64 release and volatile are implemented by an instruction
 1065     // that also has acquire semantics. I.e. there is no need for an
 1066     // acquire before these.
 1067     int xop = x-&gt;Opcode();
 1068     if (xop == Op_MemBarRelease || xop == Op_MemBarVolatile) {
 1069       // Make sure we&#39;re not missing Call/Phi/MergeMem by checking
 1070       // control edges. The control edge must directly lead back
 1071       // to the MemBarAcquire
 1072       Node *ctrl_proj = x-&gt;in(0);
 1073       if (ctrl_proj-&gt;is_Proj() &amp;&amp; ctrl_proj-&gt;in(0) == mba) {
 1074         return true;
 1075       }
 1076     }
 1077   }
 1078 
 1079   return false;
 1080 }
 1081 
 1082 #define __ _masm.
 1083 
 1084 // Tertiary op of a LoadP or StoreP encoding.
 1085 #define REGP_OP true
 1086 
 1087 // ****************************************************************************
 1088 
 1089 // REQUIRED FUNCTIONALITY
 1090 
 1091 // !!!!! Special hack to get all type of calls to specify the byte offset
 1092 //       from the start of the call to the point where the return address
 1093 //       will point.
 1094 
 1095 // PPC port: Removed use of lazy constant construct.
 1096 
 1097 int MachCallStaticJavaNode::ret_addr_offset() {
 1098   // It&#39;s only a single branch-and-link instruction.
 1099   return 4;
 1100 }
 1101 
 1102 int MachCallDynamicJavaNode::ret_addr_offset() {
 1103   // Offset is 4 with postalloc expanded calls (bl is one instruction). We use
 1104   // postalloc expanded calls if we use inline caches and do not update method data.
 1105   if (UseInlineCaches)
 1106     return 4;
 1107 
 1108   int vtable_index = this-&gt;_vtable_index;
 1109   if (vtable_index &lt; 0) {
 1110     // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 1111     assert(vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 1112     return 12;
 1113   } else {
 1114     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 1115     return 24;
 1116   }
 1117 }
 1118 
 1119 int MachCallRuntimeNode::ret_addr_offset() {
 1120 #if defined(ABI_ELFv2)
 1121   return 28;
 1122 #else
 1123   return 40;
 1124 #endif
 1125 }
 1126 
 1127 //=============================================================================
 1128 
 1129 // condition code conversions
 1130 
 1131 static int cc_to_boint(int cc) {
 1132   return Assembler::bcondCRbiIs0 | (cc &amp; 8);
 1133 }
 1134 
 1135 static int cc_to_inverse_boint(int cc) {
 1136   return Assembler::bcondCRbiIs0 | (8-(cc &amp; 8));
 1137 }
 1138 
 1139 static int cc_to_biint(int cc, int flags_reg) {
 1140   return (flags_reg &lt;&lt; 2) | (cc &amp; 3);
 1141 }
 1142 
 1143 //=============================================================================
 1144 
 1145 // Compute padding required for nodes which need alignment. The padding
 1146 // is the number of bytes (not instructions) which will be inserted before
 1147 // the instruction. The padding must match the size of a NOP instruction.
 1148 
 1149 // Currently not used on this platform.
 1150 
 1151 //=============================================================================
 1152 
 1153 // Indicate if the safepoint node needs the polling page as an input.
 1154 bool SafePointNode::needs_polling_address_input() {
 1155   // The address is loaded from thread by a seperate node.
 1156   return true;
 1157 }
 1158 
 1159 //=============================================================================
 1160 
 1161 // Emit an interrupt that is caught by the debugger (for debugging compiler).
 1162 void emit_break(CodeBuffer &amp;cbuf) {
<a name="4" id="anc4"></a><span class="line-modified"> 1163   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1164   __ illtrap();
 1165 }
 1166 
 1167 #ifndef PRODUCT
 1168 void MachBreakpointNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1169   st-&gt;print(&quot;BREAKPOINT&quot;);
 1170 }
 1171 #endif
 1172 
 1173 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1174   emit_break(cbuf);
 1175 }
 1176 
 1177 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
 1178   return MachNode::size(ra_);
 1179 }
 1180 
 1181 //=============================================================================
 1182 
 1183 void emit_nop(CodeBuffer &amp;cbuf) {
<a name="5" id="anc5"></a><span class="line-modified"> 1184   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1185   __ nop();
 1186 }
 1187 
 1188 static inline void emit_long(CodeBuffer &amp;cbuf, int value) {
 1189   *((int*)(cbuf.insts_end())) = value;
 1190   cbuf.set_insts_end(cbuf.insts_end() + BytesPerInstWord);
 1191 }
 1192 
 1193 //=============================================================================
 1194 
 1195 %} // interrupt source
 1196 
 1197 source_hpp %{ // Header information of the source block.
 1198 
 1199 //--------------------------------------------------------------
 1200 //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
 1201 //--------------------------------------------------------------
 1202 
<a name="6" id="anc6"></a><span class="line-added"> 1203 class C2_MacroAssembler;</span>
<span class="line-added"> 1204 </span>
 1205 class CallStubImpl {
 1206 
 1207  public:
 1208 
 1209   // Emit call stub, compiled java to interpreter.
<a name="7" id="anc7"></a><span class="line-modified"> 1210   static void emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset);</span>
 1211 
 1212   // Size of call trampoline stub.
 1213   // This doesn&#39;t need to be accurate to the byte, but it
 1214   // must be larger than or equal to the real size of the stub.
 1215   static uint size_call_trampoline() {
 1216     return MacroAssembler::trampoline_stub_size;
 1217   }
 1218 
 1219   // number of relocations needed by a call trampoline stub
 1220   static uint reloc_call_trampoline() {
 1221     return 5;
 1222   }
 1223 
 1224 };
 1225 
 1226 %} // end source_hpp
 1227 
 1228 source %{
 1229 
 1230 // Emit a trampoline stub for a call to a target which is too far away.
 1231 //
 1232 // code sequences:
 1233 //
 1234 // call-site:
 1235 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1236 //
 1237 // Related trampoline stub for this call-site in the stub section:
 1238 //   load the call target from the constant pool
 1239 //   branch via CTR (LR/link still points to the call-site above)
 1240 
<a name="8" id="anc8"></a><span class="line-modified"> 1241 void CallStubImpl::emit_trampoline_stub(C2_MacroAssembler &amp;_masm, int destination_toc_offset, int insts_call_instruction_offset) {</span>
 1242   address stub = __ emit_trampoline_stub(destination_toc_offset, insts_call_instruction_offset);
 1243   if (stub == NULL) {
 1244     ciEnv::current()-&gt;record_out_of_memory_failure();
 1245   }
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 // Emit an inline branch-and-link call and a related trampoline stub.
 1251 //
 1252 // code sequences:
 1253 //
 1254 // call-site:
 1255 //   branch-and-link to &lt;destination&gt; or &lt;trampoline stub&gt;
 1256 //
 1257 // Related trampoline stub for this call-site in the stub section:
 1258 //   load the call target from the constant pool
 1259 //   branch via CTR (LR/link still points to the call-site above)
 1260 //
 1261 
 1262 typedef struct {
 1263   int insts_call_instruction_offset;
 1264   int ret_addr_offset;
 1265 } EmitCallOffsets;
 1266 
 1267 // Emit a branch-and-link instruction that branches to a trampoline.
 1268 // - Remember the offset of the branch-and-link instruction.
 1269 // - Add a relocation at the branch-and-link instruction.
 1270 // - Emit a branch-and-link.
 1271 // - Remember the return pc offset.
<a name="9" id="anc9"></a><span class="line-modified"> 1272 EmitCallOffsets emit_call_with_trampoline_stub(C2_MacroAssembler &amp;_masm, address entry_point, relocInfo::relocType rtype) {</span>
 1273   EmitCallOffsets offsets = { -1, -1 };
 1274   const int start_offset = __ offset();
 1275   offsets.insts_call_instruction_offset = __ offset();
 1276 
 1277   // No entry point given, use the current pc.
 1278   if (entry_point == NULL) entry_point = __ pc();
 1279 
 1280   // Put the entry point as a constant into the constant pool.
 1281   const address entry_point_toc_addr   = __ address_constant(entry_point, RelocationHolder::none);
 1282   if (entry_point_toc_addr == NULL) {
 1283     ciEnv::current()-&gt;record_out_of_memory_failure();
 1284     return offsets;
 1285   }
 1286   const int     entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 1287 
 1288   // Emit the trampoline stub which will be related to the branch-and-link below.
 1289   CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, offsets.insts_call_instruction_offset);
 1290   if (ciEnv::current()-&gt;failing()) { return offsets; } // Code cache may be full.
 1291   __ relocate(rtype);
 1292 
 1293   // Note: At this point we do not have the address of the trampoline
 1294   // stub, and the entry point might be too far away for bl, so __ pc()
 1295   // serves as dummy and the bl will be patched later.
 1296   __ bl((address) __ pc());
 1297 
 1298   offsets.ret_addr_offset = __ offset() - start_offset;
 1299 
 1300   return offsets;
 1301 }
 1302 
 1303 //=============================================================================
 1304 
 1305 // Factory for creating loadConL* nodes for large/small constant pool.
 1306 
 1307 static inline jlong replicate_immF(float con) {
 1308   // Replicate float con 2 times and pack into vector.
 1309   int val = *((int*)&amp;con);
 1310   jlong lval = val;
 1311   lval = (lval &lt;&lt; 32) | (lval &amp; 0xFFFFFFFFl);
 1312   return lval;
 1313 }
 1314 
 1315 //=============================================================================
 1316 
 1317 const RegMask&amp; MachConstantBaseNode::_out_RegMask = BITS64_CONSTANT_TABLE_BASE_mask();
<a name="10" id="anc10"></a><span class="line-modified"> 1318 int ConstantTable::calculate_table_base_offset() const {</span>
 1319   return 0;  // absolute addressing, no offset
 1320 }
 1321 
 1322 bool MachConstantBaseNode::requires_postalloc_expand() const { return true; }
 1323 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
 1324   iRegPdstOper *op_dst = new iRegPdstOper();
 1325   MachNode *m1 = new loadToc_hiNode();
 1326   MachNode *m2 = new loadToc_loNode();
 1327 
 1328   m1-&gt;add_req(NULL);
 1329   m2-&gt;add_req(NULL, m1);
 1330   m1-&gt;_opnds[0] = op_dst;
 1331   m2-&gt;_opnds[0] = op_dst;
 1332   m2-&gt;_opnds[1] = op_dst;
 1333   ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1334   ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 1335   nodes-&gt;push(m1);
 1336   nodes-&gt;push(m2);
 1337 }
 1338 
 1339 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
 1340   // Is postalloc expanded.
 1341   ShouldNotReachHere();
 1342 }
 1343 
 1344 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
 1345   return 0;
 1346 }
 1347 
 1348 #ifndef PRODUCT
 1349 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1350   st-&gt;print(&quot;-- \t// MachConstantBaseNode (empty encoding)&quot;);
 1351 }
 1352 #endif
 1353 
 1354 //=============================================================================
 1355 
 1356 #ifndef PRODUCT
 1357 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1358   Compile* C = ra_-&gt;C;
<a name="11" id="anc11"></a><span class="line-modified"> 1359   const long framesize = C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt;</span>
 1360 
 1361   st-&gt;print(&quot;PROLOG\n\t&quot;);
<a name="12" id="anc12"></a><span class="line-modified"> 1362   if (C-&gt;output()-&gt;need_stack_bang(framesize)) {</span>
 1363     st-&gt;print(&quot;stack_overflow_check\n\t&quot;);
 1364   }
 1365 
 1366   if (!false /* TODO: PPC port C-&gt;is_frameless_method()*/) {
 1367     st-&gt;print(&quot;save return pc\n\t&quot;);
 1368     st-&gt;print(&quot;push frame %ld\n\t&quot;, -framesize);
 1369   }
 1370 }
 1371 #endif
 1372 
 1373 // Macro used instead of the common __ to emulate the pipes of PPC.
 1374 // Instead of e.g. __ ld(...) one hase to write ___(ld) ld(...) This enables the
 1375 // micro scheduler to cope with &quot;hand written&quot; assembler like in the prolog. Though
 1376 // still no scheduling of this code is possible, the micro scheduler is aware of the
 1377 // code and can update its internal data. The following mechanism is used to achieve this:
 1378 // The micro scheduler calls size() of each compound node during scheduling. size() does a
 1379 // dummy emit and only during this dummy emit C-&gt;hb_scheduling() is not NULL.
 1380 #if 0 // TODO: PPC port
 1381 #define ___(op) if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1382                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(ppc64Opcode_##op); \
 1383                 _masm.
 1384 #define ___stop if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                    \
 1385                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;PdEmulatePipe(archOpcode_none)
 1386 #define ___advance if (UsePower6SchedulerPPC64 &amp;&amp; C-&gt;hb_scheduling())                 \
 1387                   C-&gt;hb_scheduling()-&gt;_pdScheduling-&gt;advance_offset
 1388 #else
 1389 #define ___(op) if (UsePower6SchedulerPPC64)                                          \
 1390                   Unimplemented();                                                    \
 1391                 _masm.
 1392 #define ___stop if (UsePower6SchedulerPPC64)                                          \
 1393                   Unimplemented()
 1394 #define ___advance if (UsePower6SchedulerPPC64)                                       \
 1395                   Unimplemented()
 1396 #endif
 1397 
 1398 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1399   Compile* C = ra_-&gt;C;
<a name="13" id="anc13"></a><span class="line-modified"> 1400   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1401 
<a name="14" id="anc14"></a><span class="line-modified"> 1402   const long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
 1403   assert(framesize % (2 * wordSize) == 0, &quot;must preserve 2*wordSize alignment&quot;);
 1404 
 1405   const bool method_is_frameless      = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1406 
 1407   const Register return_pc            = R20; // Must match return_addr() in frame section.
 1408   const Register callers_sp           = R21;
 1409   const Register push_frame_temp      = R22;
 1410   const Register toc_temp             = R23;
 1411   assert_different_registers(R11, return_pc, callers_sp, push_frame_temp, toc_temp);
 1412 
 1413   if (method_is_frameless) {
 1414     // Add nop at beginning of all frameless methods to prevent any
 1415     // oop instructions from getting overwritten by make_not_entrant
 1416     // (patching attempt would fail).
 1417     ___(nop) nop();
 1418   } else {
 1419     // Get return pc.
 1420     ___(mflr) mflr(return_pc);
 1421   }
 1422 
 1423   if (C-&gt;clinit_barrier_on_entry()) {
 1424     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
 1425 
 1426     Label L_skip_barrier;
 1427     Register klass = toc_temp;
 1428 
 1429     // Notify OOP recorder (don&#39;t need the relocation)
 1430     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
 1431     __ load_const_optimized(klass, md.value(), R0);
 1432     __ clinit_barrier(klass, R16_thread, &amp;L_skip_barrier /*L_fast_path*/);
 1433 
 1434     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub(), R0);
 1435     __ mtctr(klass);
 1436     __ bctr();
 1437 
 1438     __ bind(L_skip_barrier);
 1439   }
 1440 
 1441   // Calls to C2R adapters often do not accept exceptional returns.
 1442   // We require that their callers must bang for them. But be
 1443   // careful, because some VM calls (such as call site linkage) can
 1444   // use several kilobytes of stack. But the stack safety zone should
 1445   // account for that. See bugs 4446381, 4468289, 4497237.
 1446 
<a name="15" id="anc15"></a><span class="line-modified"> 1447   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
 1448   assert(bangsize &gt;= framesize || bangsize &lt;= 0, &quot;stack bang size incorrect&quot;);
<a name="16" id="anc16"></a><span class="line-modified"> 1449   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
 1450     // Unfortunately we cannot use the function provided in
 1451     // assembler.cpp as we have to emulate the pipes. So I had to
 1452     // insert the code of generate_stack_overflow_check(), see
 1453     // assembler.cpp for some illuminative comments.
 1454     const int page_size = os::vm_page_size();
 1455     int bang_end = JavaThread::stack_shadow_zone_size();
 1456 
 1457     // This is how far the previous frame&#39;s stack banging extended.
 1458     const int bang_end_safe = bang_end;
 1459 
 1460     if (bangsize &gt; page_size) {
 1461       bang_end += bangsize;
 1462     }
 1463 
 1464     int bang_offset = bang_end_safe;
 1465 
 1466     while (bang_offset &lt;= bang_end) {
 1467       // Need at least one stack bang at end of shadow zone.
 1468 
 1469       // Again I had to copy code, this time from assembler_ppc.cpp,
 1470       // bang_stack_with_offset - see there for comments.
 1471 
 1472       // Stack grows down, caller passes positive offset.
 1473       assert(bang_offset &gt; 0, &quot;must bang with positive offset&quot;);
 1474 
 1475       long stdoffset = -bang_offset;
 1476 
 1477       if (Assembler::is_simm(stdoffset, 16)) {
 1478         // Signed 16 bit offset, a simple std is ok.
 1479         if (UseLoadInstructionsForStackBangingPPC64) {
 1480           ___(ld) ld(R0,  (int)(signed short)stdoffset, R1_SP);
 1481         } else {
 1482           ___(std) std(R0, (int)(signed short)stdoffset, R1_SP);
 1483         }
 1484       } else if (Assembler::is_simm(stdoffset, 31)) {
 1485         // Use largeoffset calculations for addis &amp; ld/std.
 1486         const int hi = MacroAssembler::largeoffset_si16_si16_hi(stdoffset);
 1487         const int lo = MacroAssembler::largeoffset_si16_si16_lo(stdoffset);
 1488 
 1489         Register tmp = R11;
 1490         ___(addis) addis(tmp, R1_SP, hi);
 1491         if (UseLoadInstructionsForStackBangingPPC64) {
 1492           ___(ld) ld(R0, lo, tmp);
 1493         } else {
 1494           ___(std) std(R0, lo, tmp);
 1495         }
 1496       } else {
 1497         ShouldNotReachHere();
 1498       }
 1499 
 1500       bang_offset += page_size;
 1501     }
 1502     // R11 trashed
<a name="17" id="anc17"></a><span class="line-modified"> 1503   } // C-&gt;output()-&gt;need_stack_bang(framesize) &amp;&amp; UseStackBanging</span>
 1504 
 1505   unsigned int bytes = (unsigned int)framesize;
 1506   long offset = Assembler::align_addr(bytes, frame::alignment_in_bytes);
 1507   ciMethod *currMethod = C-&gt;method();
 1508 
 1509   // Optimized version for most common case.
 1510   if (UsePower6SchedulerPPC64 &amp;&amp;
 1511       !method_is_frameless &amp;&amp; Assembler::is_simm((int)(-offset), 16) &amp;&amp;
 1512       !(false /* ConstantsALot TODO: PPC port*/)) {
 1513     ___(or) mr(callers_sp, R1_SP);
 1514     ___(std) std(return_pc, _abi(lr), R1_SP);
 1515     ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1516     return;
 1517   }
 1518 
 1519   if (!method_is_frameless) {
 1520     // Get callers sp.
 1521     ___(or) mr(callers_sp, R1_SP);
 1522 
 1523     // Push method&#39;s frame, modifies SP.
 1524     assert(Assembler::is_uimm(framesize, 32U), &quot;wrong type&quot;);
 1525     // The ABI is already accounted for in &#39;framesize&#39; via the
 1526     // &#39;out_preserve&#39; area.
 1527     Register tmp = push_frame_temp;
 1528     // Had to insert code of push_frame((unsigned int)framesize, push_frame_temp).
 1529     if (Assembler::is_simm(-offset, 16)) {
 1530       ___(stdu) stdu(R1_SP, -offset, R1_SP);
 1531     } else {
 1532       long x = -offset;
 1533       // Had to insert load_const(tmp, -offset).
 1534       ___(addis)  lis( tmp, (int)((signed short)(((x &gt;&gt; 32) &amp; 0xffff0000) &gt;&gt; 16)));
 1535       ___(ori)    ori( tmp, tmp, ((x &gt;&gt; 32) &amp; 0x0000ffff));
 1536       ___(rldicr) sldi(tmp, tmp, 32);
 1537       ___(oris)   oris(tmp, tmp, (x &amp; 0xffff0000) &gt;&gt; 16);
 1538       ___(ori)    ori( tmp, tmp, (x &amp; 0x0000ffff));
 1539 
 1540       ___(stdux) stdux(R1_SP, R1_SP, tmp);
 1541     }
 1542   }
 1543 #if 0 // TODO: PPC port
 1544   // For testing large constant pools, emit a lot of constants to constant pool.
 1545   // &quot;Randomize&quot; const_size.
 1546   if (ConstantsALot) {
 1547     const int num_consts = const_size();
 1548     for (int i = 0; i &lt; num_consts; i++) {
 1549       __ long_constant(0xB0B5B00BBABE);
 1550     }
 1551   }
 1552 #endif
 1553   if (!method_is_frameless) {
 1554     // Save return pc.
 1555     ___(std) std(return_pc, _abi(lr), callers_sp);
 1556   }
 1557 
<a name="18" id="anc18"></a><span class="line-modified"> 1558   C-&gt;output()-&gt;set_frame_complete(cbuf.insts_size());</span>
 1559 }
 1560 #undef ___
 1561 #undef ___stop
 1562 #undef ___advance
 1563 
 1564 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
 1565   // Variable size. determine dynamically.
 1566   return MachNode::size(ra_);
 1567 }
 1568 
 1569 int MachPrologNode::reloc() const {
 1570   // Return number of relocatable values contained in this instruction.
 1571   return 1; // 1 reloc entry for load_const(toc).
 1572 }
 1573 
 1574 //=============================================================================
 1575 
 1576 #ifndef PRODUCT
 1577 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1578   Compile* C = ra_-&gt;C;
 1579 
 1580   st-&gt;print(&quot;EPILOG\n\t&quot;);
 1581   st-&gt;print(&quot;restore return pc\n\t&quot;);
 1582   st-&gt;print(&quot;pop frame\n\t&quot;);
 1583 
 1584   if (do_polling() &amp;&amp; C-&gt;is_method_compilation()) {
 1585     st-&gt;print(&quot;touch polling page\n\t&quot;);
 1586   }
 1587 }
 1588 #endif
 1589 
 1590 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1591   Compile* C = ra_-&gt;C;
<a name="19" id="anc19"></a><span class="line-modified"> 1592   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1593 
<a name="20" id="anc20"></a><span class="line-modified"> 1594   const long framesize = ((long)C-&gt;output()-&gt;frame_slots()) &lt;&lt; LogBytesPerInt;</span>
 1595   assert(framesize &gt;= 0, &quot;negative frame-size?&quot;);
 1596 
 1597   const bool method_needs_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
 1598   const bool method_is_frameless  = false /* TODO: PPC port C-&gt;is_frameless_method()*/;
 1599   const Register return_pc        = R31;  // Must survive C-call to enable_stack_reserved_zone().
 1600   const Register polling_page     = R12;
 1601 
 1602   if (!method_is_frameless) {
 1603     // Restore return pc relative to callers&#39; sp.
 1604     __ ld(return_pc, ((int)framesize) + _abi(lr), R1_SP);
 1605   }
 1606 
 1607   if (method_needs_polling) {
<a name="21" id="anc21"></a><span class="line-modified"> 1608     __ ld(polling_page, in_bytes(JavaThread::polling_page_offset()), R16_thread);</span>




 1609   }
 1610 
 1611   if (!method_is_frameless) {
 1612     // Move return pc to LR.
 1613     __ mtlr(return_pc);
 1614     // Pop frame (fixed frame-size).
 1615     __ addi(R1_SP, R1_SP, (int)framesize);
 1616   }
 1617 
 1618   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
 1619     __ reserved_stack_check(return_pc);
 1620   }
 1621 
 1622   if (method_needs_polling) {
 1623     // We need to mark the code position where the load from the safepoint
 1624     // polling page was emitted as relocInfo::poll_return_type here.
 1625     __ relocate(relocInfo::poll_return_type);
 1626     __ load_from_polling_page(polling_page);
 1627   }
 1628 }
 1629 
 1630 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
 1631   // Variable size. Determine dynamically.
 1632   return MachNode::size(ra_);
 1633 }
 1634 
 1635 int MachEpilogNode::reloc() const {
 1636   // Return number of relocatable values contained in this instruction.
 1637   return 1; // 1 for load_from_polling_page.
 1638 }
 1639 
 1640 const Pipeline * MachEpilogNode::pipeline() const {
 1641   return MachNode::pipeline_class();
 1642 }
 1643 
<a name="22" id="anc22"></a>







 1644 #if 0 // TODO: PPC port
 1645 void MachLoadPollAddrLateNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<a name="23" id="anc23"></a><span class="line-modified"> 1646   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1647   if (LoadPollAddressFromThread) {
 1648     _masm.ld(R11, in_bytes(JavaThread::poll_address_offset()), R16_thread);
 1649   } else {
 1650     _masm.nop();
 1651   }
 1652 }
 1653 
 1654 uint MachLoadPollAddrLateNode::size(PhaseRegAlloc* ra_) const {
 1655   if (LoadPollAddressFromThread) {
 1656     return 4;
 1657   } else {
 1658     return 4;
 1659   }
 1660 }
 1661 
 1662 #ifndef PRODUCT
 1663 void MachLoadPollAddrLateNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
 1664   st-&gt;print_cr(&quot; LD R11, PollAddressOffset, R16_thread \t// LoadPollAddressFromThread&quot;);
 1665 }
 1666 #endif
 1667 
 1668 const RegMask &amp;MachLoadPollAddrLateNode::out_RegMask() const {
 1669   return RSCRATCH1_BITS64_REG_mask();
 1670 }
 1671 #endif // PPC port
 1672 
 1673 // =============================================================================
 1674 
 1675 // Figure out which register class each belongs in: rc_int, rc_float, rc_vs or
 1676 // rc_stack.
 1677 enum RC { rc_bad, rc_int, rc_float, rc_vs, rc_stack };
 1678 
 1679 static enum RC rc_class(OptoReg::Name reg) {
 1680   // Return the register class for the given register. The given register
 1681   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
 1682   // enumeration in adGlobals_ppc.hpp.
 1683 
 1684   if (reg == OptoReg::Bad) return rc_bad;
 1685 
 1686   // We have 64 integer register halves, starting at index 0.
 1687   if (reg &lt; 64) return rc_int;
 1688 
 1689   // We have 64 floating-point register halves, starting at index 64.
 1690   if (reg &lt; 64+64) return rc_float;
 1691 
 1692   // We have 64 vector-scalar registers, starting at index 128.
 1693   if (reg &lt; 64+64+64) return rc_vs;
 1694 
 1695   // Between float regs &amp; stack are the flags regs.
 1696   assert(OptoReg::is_stack(reg) || reg &lt; 64+64+64, &quot;blow up if spilling flags&quot;);
 1697 
 1698   return rc_stack;
 1699 }
 1700 
 1701 static int ld_st_helper(CodeBuffer *cbuf, const char *op_str, uint opcode, int reg, int offset,
 1702                         bool do_print, Compile* C, outputStream *st) {
 1703 
 1704   assert(opcode == Assembler::LD_OPCODE   ||
 1705          opcode == Assembler::STD_OPCODE  ||
 1706          opcode == Assembler::LWZ_OPCODE  ||
 1707          opcode == Assembler::STW_OPCODE  ||
 1708          opcode == Assembler::LFD_OPCODE  ||
 1709          opcode == Assembler::STFD_OPCODE ||
 1710          opcode == Assembler::LFS_OPCODE  ||
 1711          opcode == Assembler::STFS_OPCODE,
 1712          &quot;opcode not supported&quot;);
 1713 
 1714   if (cbuf) {
 1715     int d =
 1716       (Assembler::LD_OPCODE == opcode || Assembler::STD_OPCODE == opcode) ?
 1717         Assembler::ds(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/)
 1718       : Assembler::d1(offset+0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/); // Makes no difference in opt build.
 1719     emit_long(*cbuf, opcode | Assembler::rt(Matcher::_regEncode[reg]) | d | Assembler::ra(R1_SP));
 1720   }
 1721 #ifndef PRODUCT
 1722   else if (do_print) {
 1723     st-&gt;print(&quot;%-7s %s, [R1_SP + #%d+%d] \t// spill copy&quot;,
 1724               op_str,
 1725               Matcher::regName[reg],
 1726               offset, 0 /* TODO: PPC port C-&gt;frame_slots_sp_bias_in_bytes()*/);
 1727   }
 1728 #endif
 1729   return 4; // size
 1730 }
 1731 
 1732 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *st) const {
 1733   Compile* C = ra_-&gt;C;
 1734 
 1735   // Get registers to move.
 1736   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1737   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1738   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1739   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1740 
 1741   enum RC src_hi_rc = rc_class(src_hi);
 1742   enum RC src_lo_rc = rc_class(src_lo);
 1743   enum RC dst_hi_rc = rc_class(dst_hi);
 1744   enum RC dst_lo_rc = rc_class(dst_lo);
 1745 
 1746   assert(src_lo != OptoReg::Bad &amp;&amp; dst_lo != OptoReg::Bad, &quot;must move at least 1 register&quot;);
 1747   if (src_hi != OptoReg::Bad)
 1748     assert((src_lo&amp;1)==0 &amp;&amp; src_lo+1==src_hi &amp;&amp;
 1749            (dst_lo&amp;1)==0 &amp;&amp; dst_lo+1==dst_hi,
 1750            &quot;expected aligned-adjacent pairs&quot;);
 1751   // Generate spill code!
 1752   int size = 0;
 1753 
 1754   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1755     return size;            // Self copy, no move.
 1756 
 1757   if (bottom_type()-&gt;isa_vect() != NULL &amp;&amp; ideal_reg() == Op_VecX) {
 1758     // Memory-&gt;Memory Spill.
 1759     if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1760       int src_offset = ra_-&gt;reg2offset(src_lo);
 1761       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1762       if (cbuf) {
<a name="24" id="anc24"></a><span class="line-modified"> 1763         C2_MacroAssembler _masm(cbuf);</span>
 1764         __ ld(R0, src_offset, R1_SP);
 1765         __ std(R0, dst_offset, R1_SP);
 1766         __ ld(R0, src_offset+8, R1_SP);
 1767         __ std(R0, dst_offset+8, R1_SP);
 1768       }
 1769       size += 16;
 1770     }
 1771     // VectorSRegister-&gt;Memory Spill.
 1772     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_stack) {
 1773       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1774       int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1775       if (cbuf) {
<a name="25" id="anc25"></a><span class="line-modified"> 1776         C2_MacroAssembler _masm(cbuf);</span>
 1777         __ addi(R0, R1_SP, dst_offset);
 1778         __ stxvd2x(Rsrc, R0);
 1779       }
 1780       size += 8;
 1781     }
 1782     // Memory-&gt;VectorSRegister Spill.
 1783     else if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_vs) {
 1784       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1785       int src_offset = ra_-&gt;reg2offset(src_lo);
 1786       if (cbuf) {
<a name="26" id="anc26"></a><span class="line-modified"> 1787         C2_MacroAssembler _masm(cbuf);</span>
 1788         __ addi(R0, R1_SP, src_offset);
 1789         __ lxvd2x(Rdst, R0);
 1790       }
 1791       size += 8;
 1792     }
 1793     // VectorSRegister-&gt;VectorSRegister.
 1794     else if (src_lo_rc == rc_vs &amp;&amp; dst_lo_rc == rc_vs) {
 1795       VectorSRegister Rsrc = as_VectorSRegister(Matcher::_regEncode[src_lo]);
 1796       VectorSRegister Rdst = as_VectorSRegister(Matcher::_regEncode[dst_lo]);
 1797       if (cbuf) {
<a name="27" id="anc27"></a><span class="line-modified"> 1798         C2_MacroAssembler _masm(cbuf);</span>
 1799         __ xxlor(Rdst, Rsrc, Rsrc);
 1800       }
 1801       size += 4;
 1802     }
 1803     else {
 1804       ShouldNotReachHere(); // No VSR spill.
 1805     }
 1806     return size;
 1807   }
 1808 
 1809   // --------------------------------------
 1810   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1811   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1812     int src_offset = ra_-&gt;reg2offset(src_lo);
 1813     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1814     if (src_hi != OptoReg::Bad) {
 1815       assert(src_hi_rc==rc_stack &amp;&amp; dst_hi_rc==rc_stack,
 1816              &quot;expected same type of move for high parts&quot;);
 1817       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE,  R0_num, src_offset, !do_size, C, st);
 1818       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1819       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1820     } else {
 1821       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, R0_num, src_offset, !do_size, C, st);
 1822       if (!cbuf &amp;&amp; !do_size) st-&gt;print(&quot;\n\t&quot;);
 1823       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, R0_num, dst_offset, !do_size, C, st);
 1824     }
 1825     return size;
 1826   }
 1827 
 1828   // --------------------------------------
 1829   // Check for float-&gt;int copy; requires a trip through memory.
 1830   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1831     Unimplemented();
 1832   }
 1833 
 1834   // --------------------------------------
 1835   // Check for integer reg-reg copy.
 1836   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1837       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1838       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1839       size = (Rsrc != Rdst) ? 4 : 0;
 1840 
 1841       if (cbuf) {
<a name="28" id="anc28"></a><span class="line-modified"> 1842         C2_MacroAssembler _masm(cbuf);</span>
 1843         if (size) {
 1844           __ mr(Rdst, Rsrc);
 1845         }
 1846       }
 1847 #ifndef PRODUCT
 1848       else if (!do_size) {
 1849         if (size) {
 1850           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1851         } else {
 1852           st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;MR-NOP&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1853         }
 1854       }
 1855 #endif
 1856       return size;
 1857   }
 1858 
 1859   // Check for integer store.
 1860   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1861     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1862     if (src_hi != OptoReg::Bad) {
 1863       assert(src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack,
 1864              &quot;expected same type of move for high parts&quot;);
 1865       size += ld_st_helper(cbuf, &quot;STD &quot;, Assembler::STD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1866     } else {
 1867       size += ld_st_helper(cbuf, &quot;STW &quot;, Assembler::STW_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1868     }
 1869     return size;
 1870   }
 1871 
 1872   // Check for integer load.
 1873   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1874     int src_offset = ra_-&gt;reg2offset(src_lo);
 1875     if (src_hi != OptoReg::Bad) {
 1876       assert(dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack,
 1877              &quot;expected same type of move for high parts&quot;);
 1878       size += ld_st_helper(cbuf, &quot;LD  &quot;, Assembler::LD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1879     } else {
 1880       size += ld_st_helper(cbuf, &quot;LWZ &quot;, Assembler::LWZ_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1881     }
 1882     return size;
 1883   }
 1884 
 1885   // Check for float reg-reg copy.
 1886   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1887     if (cbuf) {
<a name="29" id="anc29"></a><span class="line-modified"> 1888       C2_MacroAssembler _masm(cbuf);</span>
 1889       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1890       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1891       __ fmr(Rdst, Rsrc);
 1892     }
 1893 #ifndef PRODUCT
 1894     else if (!do_size) {
 1895       st-&gt;print(&quot;%-7s %s, %s \t// spill copy&quot;, &quot;FMR&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1896     }
 1897 #endif
 1898     return 4;
 1899   }
 1900 
 1901   // Check for float store.
 1902   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1903     int dst_offset = ra_-&gt;reg2offset(dst_lo);
 1904     if (src_hi != OptoReg::Bad) {
 1905       assert(src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack,
 1906              &quot;expected same type of move for high parts&quot;);
 1907       size += ld_st_helper(cbuf, &quot;STFD&quot;, Assembler::STFD_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1908     } else {
 1909       size += ld_st_helper(cbuf, &quot;STFS&quot;, Assembler::STFS_OPCODE, src_lo, dst_offset, !do_size, C, st);
 1910     }
 1911     return size;
 1912   }
 1913 
 1914   // Check for float load.
 1915   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 1916     int src_offset = ra_-&gt;reg2offset(src_lo);
 1917     if (src_hi != OptoReg::Bad) {
 1918       assert(dst_hi_rc==rc_float &amp;&amp; src_hi_rc==rc_stack,
 1919              &quot;expected same type of move for high parts&quot;);
 1920       size += ld_st_helper(cbuf, &quot;LFD &quot;, Assembler::LFD_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1921     } else {
 1922       size += ld_st_helper(cbuf, &quot;LFS &quot;, Assembler::LFS_OPCODE, dst_lo, src_offset, !do_size, C, st);
 1923     }
 1924     return size;
 1925   }
 1926 
 1927   // --------------------------------------------------------------------
 1928   // Check for hi bits still needing moving. Only happens for misaligned
 1929   // arguments to native calls.
 1930   if (src_hi == dst_hi)
 1931     return size;               // Self copy; no move.
 1932 
 1933   assert(src_hi_rc != rc_bad &amp;&amp; dst_hi_rc != rc_bad, &quot;src_hi &amp; dst_hi cannot be Bad&quot;);
 1934   ShouldNotReachHere(); // Unimplemented
 1935   return 0;
 1936 }
 1937 
 1938 #ifndef PRODUCT
 1939 void MachSpillCopyNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 1940   if (!ra_)
 1941     st-&gt;print(&quot;N%d = SpillCopy(N%d)&quot;, _idx, in(1)-&gt;_idx);
 1942   else
 1943     implementation(NULL, ra_, false, st);
 1944 }
 1945 #endif
 1946 
 1947 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1948   implementation(&amp;cbuf, ra_, false, NULL);
 1949 }
 1950 
 1951 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1952   return implementation(NULL, ra_, true, NULL);
 1953 }
 1954 
 1955 #if 0 // TODO: PPC port
 1956 ArchOpcode MachSpillCopyNode_archOpcode(MachSpillCopyNode *n, PhaseRegAlloc *ra_) {
 1957 #ifndef PRODUCT
 1958   if (ra_-&gt;node_regs_max_index() == 0) return archOpcode_undefined;
 1959 #endif
 1960   assert(ra_-&gt;node_regs_max_index() != 0, &quot;&quot;);
 1961 
 1962   // Get registers to move.
 1963   OptoReg::Name src_hi = ra_-&gt;get_reg_second(n-&gt;in(1));
 1964   OptoReg::Name src_lo = ra_-&gt;get_reg_first(n-&gt;in(1));
 1965   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(n);
 1966   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(n);
 1967 
 1968   enum RC src_lo_rc = rc_class(src_lo);
 1969   enum RC dst_lo_rc = rc_class(dst_lo);
 1970 
 1971   if (src_lo == dst_lo &amp;&amp; src_hi == dst_hi)
 1972     return ppc64Opcode_none;            // Self copy, no move.
 1973 
 1974   // --------------------------------------
 1975   // Memory-&gt;Memory Spill. Use R0 to hold the value.
 1976   if (src_lo_rc == rc_stack &amp;&amp; dst_lo_rc == rc_stack) {
 1977     return ppc64Opcode_compound;
 1978   }
 1979 
 1980   // --------------------------------------
 1981   // Check for float-&gt;int copy; requires a trip through memory.
 1982   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1983     Unimplemented();
 1984   }
 1985 
 1986   // --------------------------------------
 1987   // Check for integer reg-reg copy.
 1988   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1989     Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1990     Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1991     if (Rsrc == Rdst) {
 1992       return ppc64Opcode_none;
 1993     } else {
 1994       return ppc64Opcode_or;
 1995     }
 1996   }
 1997 
 1998   // Check for integer store.
 1999   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 2000     if (src_hi != OptoReg::Bad) {
 2001       return ppc64Opcode_std;
 2002     } else {
 2003       return ppc64Opcode_stw;
 2004     }
 2005   }
 2006 
 2007   // Check for integer load.
 2008   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 2009     if (src_hi != OptoReg::Bad) {
 2010       return ppc64Opcode_ld;
 2011     } else {
 2012       return ppc64Opcode_lwz;
 2013     }
 2014   }
 2015 
 2016   // Check for float reg-reg copy.
 2017   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 2018     return ppc64Opcode_fmr;
 2019   }
 2020 
 2021   // Check for float store.
 2022   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 2023     if (src_hi != OptoReg::Bad) {
 2024       return ppc64Opcode_stfd;
 2025     } else {
 2026       return ppc64Opcode_stfs;
 2027     }
 2028   }
 2029 
 2030   // Check for float load.
 2031   if (dst_lo_rc == rc_float &amp;&amp; src_lo_rc == rc_stack) {
 2032     if (src_hi != OptoReg::Bad) {
 2033       return ppc64Opcode_lfd;
 2034     } else {
 2035       return ppc64Opcode_lfs;
 2036     }
 2037   }
 2038 
 2039   // --------------------------------------------------------------------
 2040   // Check for hi bits still needing moving. Only happens for misaligned
 2041   // arguments to native calls.
 2042   if (src_hi == dst_hi) {
 2043     return ppc64Opcode_none;               // Self copy; no move.
 2044   }
 2045 
 2046   ShouldNotReachHere();
 2047   return ppc64Opcode_undefined;
 2048 }
 2049 #endif // PPC port
 2050 
 2051 #ifndef PRODUCT
 2052 void MachNopNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2053   st-&gt;print(&quot;NOP \t// %d nops to pad for loops.&quot;, _count);
 2054 }
 2055 #endif
 2056 
 2057 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *) const {
<a name="30" id="anc30"></a><span class="line-modified"> 2058   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2059   // _count contains the number of nops needed for padding.
 2060   for (int i = 0; i &lt; _count; i++) {
 2061     __ nop();
 2062   }
 2063 }
 2064 
 2065 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 2066   return _count * 4;
 2067 }
 2068 
 2069 #ifndef PRODUCT
 2070 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2071   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2072   char reg_str[128];
 2073   ra_-&gt;dump_register(this, reg_str);
 2074   st-&gt;print(&quot;ADDI    %s, SP, %d \t// box node&quot;, reg_str, offset);
 2075 }
 2076 #endif
 2077 
 2078 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="31" id="anc31"></a><span class="line-modified"> 2079   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2080 
 2081   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 2082   int reg    = ra_-&gt;get_encode(this);
 2083 
 2084   if (Assembler::is_simm(offset, 16)) {
 2085     __ addi(as_Register(reg), R1, offset);
 2086   } else {
 2087     ShouldNotReachHere();
 2088   }
 2089 }
 2090 
 2091 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 2092   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_).
 2093   return 4;
 2094 }
 2095 
 2096 #ifndef PRODUCT
 2097 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
 2098   st-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 2099   st-&gt;print_cr(&quot;...&quot;);
 2100 }
 2101 #endif
 2102 
 2103 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 2104   // This is the unverified entry point.
<a name="32" id="anc32"></a><span class="line-modified"> 2105   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2106 
 2107   // Inline_cache contains a klass.
 2108   Register ic_klass       = as_Register(Matcher::inline_cache_reg_encode());
 2109   Register receiver_klass = R12_scratch2;  // tmp
 2110 
 2111   assert_different_registers(ic_klass, receiver_klass, R11_scratch1, R3_ARG1);
 2112   assert(R11_scratch1 == R11, &quot;need prologue scratch register&quot;);
 2113 
 2114   // Check for NULL argument if we don&#39;t have implicit null checks.
 2115   if (!ImplicitNullChecks || !os::zero_page_read_protected()) {
 2116     if (TrapBasedNullChecks) {
 2117       __ trap_null_check(R3_ARG1);
 2118     } else {
 2119       Label valid;
 2120       __ cmpdi(CCR0, R3_ARG1, 0);
 2121       __ bne_predict_taken(CCR0, valid);
 2122       // We have a null argument, branch to ic_miss_stub.
 2123       __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2124                            relocInfo::runtime_call_type);
 2125       __ bind(valid);
 2126     }
 2127   }
 2128   // Assume argument is not NULL, load klass from receiver.
 2129   __ load_klass(receiver_klass, R3_ARG1);
 2130 
 2131   if (TrapBasedICMissChecks) {
 2132     __ trap_ic_miss_check(receiver_klass, ic_klass);
 2133   } else {
 2134     Label valid;
 2135     __ cmpd(CCR0, receiver_klass, ic_klass);
 2136     __ beq_predict_taken(CCR0, valid);
 2137     // We have an unexpected klass, branch to ic_miss_stub.
 2138     __ b64_patchable((address)SharedRuntime::get_ic_miss_stub(),
 2139                          relocInfo::runtime_call_type);
 2140     __ bind(valid);
 2141   }
 2142 
 2143   // Argument is valid and klass is as expected, continue.
 2144 }
 2145 
 2146 #if 0 // TODO: PPC port
 2147 // Optimize UEP code on z (save a load_const() call in main path).
 2148 int MachUEPNode::ep_offset() {
 2149   return 0;
 2150 }
 2151 #endif
 2152 
 2153 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
 2154   // Variable size. Determine dynamically.
 2155   return MachNode::size(ra_);
 2156 }
 2157 
 2158 //=============================================================================
 2159 
 2160 %} // interrupt source
 2161 
 2162 source_hpp %{ // Header information of the source block.
 2163 
 2164 class HandlerImpl {
 2165 
 2166  public:
 2167 
 2168   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 2169   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 2170 
 2171   static uint size_exception_handler() {
 2172     // The exception_handler is a b64_patchable.
 2173     return MacroAssembler::b64_patchable_size;
 2174   }
 2175 
 2176   static uint size_deopt_handler() {
 2177     // The deopt_handler is a bl64_patchable.
 2178     return MacroAssembler::bl64_patchable_size;
 2179   }
 2180 
 2181 };
 2182 
<a name="33" id="anc33"></a><span class="line-added"> 2183 class Node::PD {</span>
<span class="line-added"> 2184 public:</span>
<span class="line-added"> 2185   enum NodeFlags {</span>
<span class="line-added"> 2186     _last_flag = Node::_last_flag</span>
<span class="line-added"> 2187   };</span>
<span class="line-added"> 2188 };</span>
<span class="line-added"> 2189 </span>
 2190 %} // end source_hpp
 2191 
 2192 source %{
 2193 
 2194 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
<a name="34" id="anc34"></a><span class="line-modified"> 2195   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2196 
 2197   address base = __ start_a_stub(size_exception_handler());
 2198   if (base == NULL) return 0; // CodeBuffer::expand failed
 2199 
 2200   int offset = __ offset();
 2201   __ b64_patchable((address)OptoRuntime::exception_blob()-&gt;content_begin(),
 2202                        relocInfo::runtime_call_type);
 2203   assert(__ offset() - offset == (int)size_exception_handler(), &quot;must be fixed size&quot;);
 2204   __ end_a_stub();
 2205 
 2206   return offset;
 2207 }
 2208 
 2209 // The deopt_handler is like the exception handler, but it calls to
 2210 // the deoptimization blob instead of jumping to the exception blob.
 2211 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<a name="35" id="anc35"></a><span class="line-modified"> 2212   C2_MacroAssembler _masm(&amp;cbuf);</span>
 2213 
 2214   address base = __ start_a_stub(size_deopt_handler());
 2215   if (base == NULL) return 0; // CodeBuffer::expand failed
 2216 
 2217   int offset = __ offset();
 2218   __ bl64_patchable((address)SharedRuntime::deopt_blob()-&gt;unpack(),
 2219                         relocInfo::runtime_call_type);
 2220   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 2221   __ end_a_stub();
 2222 
 2223   return offset;
 2224 }
 2225 
 2226 //=============================================================================
 2227 
 2228 // Use a frame slots bias for frameless methods if accessing the stack.
 2229 static int frame_slots_bias(int reg_enc, PhaseRegAlloc* ra_) {
 2230   if (as_Register(reg_enc) == R1_SP) {
 2231     return 0; // TODO: PPC port ra_-&gt;C-&gt;frame_slots_sp_bias_in_bytes();
 2232   }
 2233   return 0;
 2234 }
 2235 
 2236 const bool Matcher::match_rule_supported(int opcode) {
 2237   if (!has_match_rule(opcode))
 2238     return false;
 2239 
 2240   bool ret_value = true;
 2241   switch (opcode) {
 2242   case Op_SqrtD:
 2243     return VM_Version::has_fsqrt();
 2244   case Op_CountLeadingZerosI:
 2245   case Op_CountLeadingZerosL:
 2246     if (!UseCountLeadingZerosInstructionsPPC64)
 2247       return false;
 2248     break;
 2249   case Op_CountTrailingZerosI:
 2250   case Op_CountTrailingZerosL:
 2251     if (!UseCountLeadingZerosInstructionsPPC64 &amp;&amp;
 2252         !UseCountTrailingZerosInstructionsPPC64)
 2253       return false;
 2254     break;
 2255 
 2256   case Op_PopCountI:
 2257   case Op_PopCountL:
 2258     return (UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
 2259 
 2260   case Op_StrComp:
 2261     return SpecialStringCompareTo;
 2262   case Op_StrEquals:
 2263     return SpecialStringEquals;
 2264   case Op_StrIndexOf:
 2265   case Op_StrIndexOfChar:
 2266     return SpecialStringIndexOf;
 2267   case Op_AddVB:
 2268   case Op_AddVS:
 2269   case Op_AddVI:
 2270   case Op_AddVF:
 2271   case Op_AddVD:
 2272   case Op_SubVB:
 2273   case Op_SubVS:
 2274   case Op_SubVI:
 2275   case Op_SubVF:
 2276   case Op_SubVD:
 2277   case Op_MulVS:
 2278   case Op_MulVF:
 2279   case Op_MulVD:
 2280   case Op_DivVF:
 2281   case Op_DivVD:
 2282   case Op_AbsVF:
 2283   case Op_AbsVD:
 2284   case Op_NegVF:
 2285   case Op_NegVD:
 2286   case Op_SqrtVF:
 2287   case Op_SqrtVD:
 2288   case Op_AddVL:
 2289   case Op_SubVL:
 2290   case Op_MulVI:
 2291   case Op_RoundDoubleModeV:
 2292     return SuperwordUseVSX;
 2293   case Op_PopCountVI:
 2294     return (SuperwordUseVSX &amp;&amp; UsePopCountInstruction);
 2295   case Op_FmaVF:
 2296   case Op_FmaVD:
 2297     return (SuperwordUseVSX &amp;&amp; UseFMA);
 2298   case Op_Digit:
 2299   case Op_LowerCase:
 2300   case Op_UpperCase:
 2301   case Op_Whitespace:
 2302     return UseCharacterCompareIntrinsics;
 2303 
 2304   case Op_CacheWB:
 2305   case Op_CacheWBPreSync:
 2306   case Op_CacheWBPostSync:
 2307     if (!VM_Version::supports_data_cache_line_flush()) {
 2308       ret_value = false;
 2309     }
 2310     break;
 2311   }
 2312 
 2313   return ret_value;  // Per default match rules are supported.
 2314 }
 2315 
 2316 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
 2317 
 2318   // TODO
 2319   // identify extra cases that we might want to provide match rules for
 2320   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
 2321   bool ret_value = match_rule_supported(opcode);
 2322   // Add rules here.
 2323 
 2324   return ret_value;  // Per default match rules are supported.
 2325 }
 2326 
 2327 const bool Matcher::has_predicated_vectors(void) {
 2328   return false;
 2329 }
 2330 
 2331 const int Matcher::float_pressure(int default_pressure_threshold) {
 2332   return default_pressure_threshold;
 2333 }
 2334 
 2335 int Matcher::regnum_to_fpu_offset(int regnum) {
 2336   // No user for this method?
 2337   Unimplemented();
 2338   return 999;
 2339 }
 2340 
 2341 const bool Matcher::convL2FSupported(void) {
 2342   // fcfids can do the conversion (&gt;= Power7).
 2343   // fcfid + frsp showed rounding problem when result should be 0x3f800001.
 2344   return VM_Version::has_fcfids(); // False means that conversion is done by runtime call.
 2345 }
 2346 
 2347 // Vector width in bytes.
 2348 const int Matcher::vector_width_in_bytes(BasicType bt) {
 2349   if (SuperwordUseVSX) {
 2350     assert(MaxVectorSize == 16, &quot;&quot;);
 2351     return 16;
 2352   } else {
 2353     assert(MaxVectorSize == 8, &quot;&quot;);
 2354     return 8;
 2355   }
 2356 }
 2357 
 2358 // Vector ideal reg.
 2359 const uint Matcher::vector_ideal_reg(int size) {
 2360   if (SuperwordUseVSX) {
 2361     assert(MaxVectorSize == 16 &amp;&amp; size == 16, &quot;&quot;);
 2362     return Op_VecX;
 2363   } else {
 2364     assert(MaxVectorSize == 8 &amp;&amp; size == 8, &quot;&quot;);
 2365     return Op_RegL;
 2366   }
 2367 }
 2368 
 2369 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 2370   fatal(&quot;vector shift is not supported&quot;);
 2371   return Node::NotAMachineReg;
 2372 }
 2373 
 2374 // Limits on vector size (number of elements) loaded into vector.
 2375 const int Matcher::max_vector_size(const BasicType bt) {
 2376   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 2377   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 2378 }
 2379 
 2380 const int Matcher::min_vector_size(const BasicType bt) {
 2381   return max_vector_size(bt); // Same as max.
 2382 }
 2383 
 2384 // PPC implementation uses VSX load/store instructions (if
 2385 // SuperwordUseVSX) which support 4 byte but not arbitrary alignment
 2386 const bool Matcher::misaligned_vectors_ok() {
 2387   return false;
 2388 }
 2389 
 2390 // PPC AES support not yet implemented
 2391 const bool Matcher::pass_original_key_for_aes() {
 2392   return false;
 2393 }
 2394 
 2395 // RETURNS: whether this branch offset is short enough that a short
 2396 // branch can be used.
 2397 //
 2398 // If the platform does not provide any short branch variants, then
 2399 // this method should return `false&#39; for offset 0.
 2400 //
 2401 // `Compile::Fill_buffer&#39; will decide on basis of this information
 2402 // whether to do the pass `Compile::Shorten_branches&#39; at all.
 2403 //
 2404 // And `Compile::Shorten_branches&#39; will decide on basis of this
 2405 // information whether to replace particular branch sites by short
 2406 // ones.
 2407 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 2408   // Is the offset within the range of a ppc64 pc relative branch?
 2409   bool b;
 2410 
 2411   const int safety_zone = 3 * BytesPerInstWord;
 2412   b = Assembler::is_simm((offset&lt;0 ? offset-safety_zone : offset+safety_zone),
 2413                          29 - 16 + 1 + 2);
 2414   return b;
 2415 }
 2416 
 2417 const bool Matcher::isSimpleConstant64(jlong value) {
 2418   // Probably always true, even if a temp register is required.
 2419   return true;
 2420 }
 2421 /* TODO: PPC port
 2422 // Make a new machine dependent decode node (with its operands).
 2423 MachTypeNode *Matcher::make_decode_node() {
 2424   assert(CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0,
 2425          &quot;This method is only implemented for unscaled cOops mode so far&quot;);
 2426   MachTypeNode *decode = new decodeN_unscaledNode();
 2427   decode-&gt;set_opnd_array(0, new iRegPdstOper());
 2428   decode-&gt;set_opnd_array(1, new iRegNsrcOper());
 2429   return decode;
 2430 }
 2431 */
 2432 
 2433 // false =&gt; size gets scaled to BytesPerLong, ok.
 2434 const bool Matcher::init_array_count_is_in_bytes = false;
 2435 
 2436 // Use conditional move (CMOVL) on Power7.
 2437 const int Matcher::long_cmove_cost() { return 0; } // this only makes long cmoves more expensive than int cmoves
 2438 
 2439 // Suppress CMOVF. Conditional move available (sort of) on PPC64 only from P7 onwards. Not exploited yet.
 2440 // fsel doesn&#39;t accept a condition register as input, so this would be slightly different.
 2441 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 2442 
 2443 // Power6 requires postalloc expand (see block.cpp for description of postalloc expand).
 2444 const bool Matcher::require_postalloc_expand = true;
 2445 
 2446 // Do we need to mask the count passed to shift instructions or does
 2447 // the cpu only look at the lower 5/6 bits anyway?
 2448 // PowerPC requires masked shift counts.
 2449 const bool Matcher::need_masked_shift_count = true;
 2450 
 2451 // No support for generic vector operands.
 2452 const bool Matcher::supports_generic_vector_operands  = false;
 2453 
 2454 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 2455   ShouldNotReachHere(); // generic vector operands not supported
 2456   return NULL;
 2457 }
 2458 
 2459 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 2460   ShouldNotReachHere();  // generic vector operands not supported
 2461   return false;
 2462 }
 2463 
 2464 bool Matcher::is_generic_vector(MachOper* opnd)  {
 2465   ShouldNotReachHere();  // generic vector operands not supported
 2466   return false;
 2467 }
 2468 
 2469 // This affects two different things:
 2470 //  - how Decode nodes are matched
 2471 //  - how ImplicitNullCheck opportunities are recognized
 2472 // If true, the matcher will try to remove all Decodes and match them
 2473 // (as operands) into nodes. NullChecks are not prepared to deal with
 2474 // Decodes by final_graph_reshaping().
 2475 // If false, final_graph_reshaping() forces the decode behind the Cmp
 2476 // for a NullCheck. The matcher matches the Decode node into a register.
 2477 // Implicit_null_check optimization moves the Decode along with the
 2478 // memory operation back up before the NullCheck.
 2479 bool Matcher::narrow_oop_use_complex_address() {
 2480   // TODO: PPC port if (MatchDecodeNodes) return true;
 2481   return false;
 2482 }
 2483 
 2484 bool Matcher::narrow_klass_use_complex_address() {
 2485   NOT_LP64(ShouldNotCallThis());
 2486   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 2487   // TODO: PPC port if (MatchDecodeNodes) return true;
 2488   return false;
 2489 }
 2490 
 2491 bool Matcher::const_oop_prefer_decode() {
 2492   // Prefer ConN+DecodeN over ConP in simple compressed oops mode.
 2493   return CompressedOops::base() == NULL;
 2494 }
 2495 
 2496 bool Matcher::const_klass_prefer_decode() {
 2497   // Prefer ConNKlass+DecodeNKlass over ConP in simple compressed klass mode.
 2498   return CompressedKlassPointers::base() == NULL;
 2499 }
 2500 
 2501 // Is it better to copy float constants, or load them directly from memory?
 2502 // Intel can load a float constant from a direct address, requiring no
 2503 // extra registers. Most RISCs will have to materialize an address into a
 2504 // register first, so they would do better to copy the constant from stack.
 2505 const bool Matcher::rematerialize_float_constants = false;
 2506 
 2507 // If CPU can load and store mis-aligned doubles directly then no fixup is
 2508 // needed. Else we split the double into 2 integer pieces and move it
 2509 // piece-by-piece. Only happens when passing doubles into C code as the
 2510 // Java calling convention forces doubles to be aligned.
 2511 const bool Matcher::misaligned_doubles_ok = true;
 2512 
 2513 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 2514  Unimplemented();
 2515 }
 2516 
 2517 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 2518 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 2519 
 2520 // Do floats take an entire double register or just half?
 2521 //
 2522 // A float occupies a ppc64 double register. For the allocator, a
 2523 // ppc64 double register appears as a pair of float registers.
 2524 bool Matcher::float_in_double() { return true; }
 2525 
 2526 // Do ints take an entire long register or just half?
 2527 // The relevant question is how the int is callee-saved:
 2528 // the whole long is written but de-opt&#39;ing will have to extract
 2529 // the relevant 32 bits.
 2530 const bool Matcher::int_in_long = true;
 2531 
 2532 // Constants for c2c and c calling conventions.
 2533 
 2534 const MachRegisterNumbers iarg_reg[8] = {
 2535   R3_num, R4_num, R5_num, R6_num,
 2536   R7_num, R8_num, R9_num, R10_num
 2537 };
 2538 
 2539 const MachRegisterNumbers farg_reg[13] = {
 2540   F1_num, F2_num, F3_num, F4_num,
 2541   F5_num, F6_num, F7_num, F8_num,
 2542   F9_num, F10_num, F11_num, F12_num,
 2543   F13_num
 2544 };
 2545 
 2546 const MachRegisterNumbers vsarg_reg[64] = {
 2547   VSR0_num, VSR1_num, VSR2_num, VSR3_num,
 2548   VSR4_num, VSR5_num, VSR6_num, VSR7_num,
 2549   VSR8_num, VSR9_num, VSR10_num, VSR11_num,
 2550   VSR12_num, VSR13_num, VSR14_num, VSR15_num,
 2551   VSR16_num, VSR17_num, VSR18_num, VSR19_num,
 2552   VSR20_num, VSR21_num, VSR22_num, VSR23_num,
 2553   VSR24_num, VSR23_num, VSR24_num, VSR25_num,
 2554   VSR28_num, VSR29_num, VSR30_num, VSR31_num,
 2555   VSR32_num, VSR33_num, VSR34_num, VSR35_num,
 2556   VSR36_num, VSR37_num, VSR38_num, VSR39_num,
 2557   VSR40_num, VSR41_num, VSR42_num, VSR43_num,
 2558   VSR44_num, VSR45_num, VSR46_num, VSR47_num,
 2559   VSR48_num, VSR49_num, VSR50_num, VSR51_num,
 2560   VSR52_num, VSR53_num, VSR54_num, VSR55_num,
 2561   VSR56_num, VSR57_num, VSR58_num, VSR59_num,
 2562   VSR60_num, VSR61_num, VSR62_num, VSR63_num
 2563 };
 2564 
 2565 const int num_iarg_registers = sizeof(iarg_reg) / sizeof(iarg_reg[0]);
 2566 
 2567 const int num_farg_registers = sizeof(farg_reg) / sizeof(farg_reg[0]);
 2568 
 2569 const int num_vsarg_registers = sizeof(vsarg_reg) / sizeof(vsarg_reg[0]);
 2570 
 2571 // Return whether or not this register is ever used as an argument. This
 2572 // function is used on startup to build the trampoline stubs in generateOptoStub.
 2573 // Registers not mentioned will be killed by the VM call in the trampoline, and
 2574 // arguments in those registers not be available to the callee.
 2575 bool Matcher::can_be_java_arg(int reg) {
 2576   // We return true for all registers contained in iarg_reg[] and
 2577   // farg_reg[] and their virtual halves.
 2578   // We must include the virtual halves in order to get STDs and LDs
 2579   // instead of STWs and LWs in the trampoline stubs.
 2580 
 2581   if (   reg == R3_num  || reg == R3_H_num
 2582       || reg == R4_num  || reg == R4_H_num
 2583       || reg == R5_num  || reg == R5_H_num
 2584       || reg == R6_num  || reg == R6_H_num
 2585       || reg == R7_num  || reg == R7_H_num
 2586       || reg == R8_num  || reg == R8_H_num
 2587       || reg == R9_num  || reg == R9_H_num
 2588       || reg == R10_num || reg == R10_H_num)
 2589     return true;
 2590 
 2591   if (   reg == F1_num  || reg == F1_H_num
 2592       || reg == F2_num  || reg == F2_H_num
 2593       || reg == F3_num  || reg == F3_H_num
 2594       || reg == F4_num  || reg == F4_H_num
 2595       || reg == F5_num  || reg == F5_H_num
 2596       || reg == F6_num  || reg == F6_H_num
 2597       || reg == F7_num  || reg == F7_H_num
 2598       || reg == F8_num  || reg == F8_H_num
 2599       || reg == F9_num  || reg == F9_H_num
 2600       || reg == F10_num || reg == F10_H_num
 2601       || reg == F11_num || reg == F11_H_num
 2602       || reg == F12_num || reg == F12_H_num
 2603       || reg == F13_num || reg == F13_H_num)
 2604     return true;
 2605 
 2606   return false;
 2607 }
 2608 
 2609 bool Matcher::is_spillable_arg(int reg) {
 2610   return can_be_java_arg(reg);
 2611 }
 2612 
 2613 bool Matcher::use_asm_for_ldiv_by_con(jlong divisor) {
 2614   return false;
 2615 }
 2616 
 2617 // Register for DIVI projection of divmodI.
 2618 RegMask Matcher::divI_proj_mask() {
 2619   ShouldNotReachHere();
 2620   return RegMask();
 2621 }
 2622 
 2623 // Register for MODI projection of divmodI.
 2624 RegMask Matcher::modI_proj_mask() {
 2625   ShouldNotReachHere();
 2626   return RegMask();
 2627 }
 2628 
 2629 // Register for DIVL projection of divmodL.
 2630 RegMask Matcher::divL_proj_mask() {
 2631   ShouldNotReachHere();
 2632   return RegMask();
 2633 }
 2634 
 2635 // Register for MODL projection of divmodL.
 2636 RegMask Matcher::modL_proj_mask() {
 2637   ShouldNotReachHere();
 2638   return RegMask();
 2639 }
 2640 
 2641 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 2642   return RegMask();
 2643 }
 2644 
 2645 const bool Matcher::convi2l_type_required = true;
 2646 
 2647 %}
 2648 
 2649 //----------ENCODING BLOCK-----------------------------------------------------
 2650 // This block specifies the encoding classes used by the compiler to output
 2651 // byte streams. Encoding classes are parameterized macros used by
 2652 // Machine Instruction Nodes in order to generate the bit encoding of the
 2653 // instruction. Operands specify their base encoding interface with the
 2654 // interface keyword. There are currently supported four interfaces,
 2655 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 2656 // operand to generate a function which returns its register number when
 2657 // queried. CONST_INTER causes an operand to generate a function which
 2658 // returns the value of the constant when queried. MEMORY_INTER causes an
 2659 // operand to generate four functions which return the Base Register, the
 2660 // Index Register, the Scale Value, and the Offset Value of the operand when
 2661 // queried. COND_INTER causes an operand to generate six functions which
 2662 // return the encoding code (ie - encoding bits for the instruction)
 2663 // associated with each basic boolean condition for a conditional instruction.
 2664 //
 2665 // Instructions specify two basic values for encoding. Again, a function
 2666 // is available to check if the constant displacement is an oop. They use the
 2667 // ins_encode keyword to specify their encoding classes (which must be
 2668 // a sequence of enc_class names, and their parameters, specified in
 2669 // the encoding block), and they use the
 2670 // opcode keyword to specify, in order, their primary, secondary, and
 2671 // tertiary opcode. Only the opcode sections which a particular instruction
 2672 // needs for encoding need to be specified.
 2673 encode %{
 2674   enc_class enc_unimplemented %{
 2675     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="36" id="anc36"></a><span class="line-modified"> 2676     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2677     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 2678   %}
 2679 
 2680   enc_class enc_untested %{
 2681 #ifdef ASSERT
 2682     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="37" id="anc37"></a><span class="line-modified"> 2683     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2684     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 2685 #else
 2686     // TODO: PPC port $archOpcode(ppc64Opcode_none);
 2687 #endif
 2688   %}
 2689 
 2690   enc_class enc_lbz(iRegIdst dst, memory mem) %{
 2691     // TODO: PPC port $archOpcode(ppc64Opcode_lbz);
<a name="38" id="anc38"></a><span class="line-modified"> 2692     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2693     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2694     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2695   %}
 2696 
 2697   // Load acquire.
 2698   enc_class enc_lbz_ac(iRegIdst dst, memory mem) %{
 2699     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="39" id="anc39"></a><span class="line-modified"> 2700     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2701     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2702     __ lbz($dst$$Register, Idisp, $mem$$base$$Register);
 2703     __ twi_0($dst$$Register);
 2704     __ isync();
 2705   %}
 2706 
 2707   enc_class enc_lhz(iRegIdst dst, memory mem) %{
 2708     // TODO: PPC port $archOpcode(ppc64Opcode_lhz);
 2709 
<a name="40" id="anc40"></a><span class="line-modified"> 2710     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2711     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2712     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2713   %}
 2714 
 2715   // Load acquire.
 2716   enc_class enc_lhz_ac(iRegIdst dst, memory mem) %{
 2717     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2718 
<a name="41" id="anc41"></a><span class="line-modified"> 2719     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2720     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2721     __ lhz($dst$$Register, Idisp, $mem$$base$$Register);
 2722     __ twi_0($dst$$Register);
 2723     __ isync();
 2724   %}
 2725 
 2726   enc_class enc_lwz(iRegIdst dst, memory mem) %{
 2727     // TODO: PPC port $archOpcode(ppc64Opcode_lwz);
 2728 
<a name="42" id="anc42"></a><span class="line-modified"> 2729     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2730     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2731     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2732   %}
 2733 
 2734   // Load acquire.
 2735   enc_class enc_lwz_ac(iRegIdst dst, memory mem) %{
 2736     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 2737 
<a name="43" id="anc43"></a><span class="line-modified"> 2738     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2739     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2740     __ lwz($dst$$Register, Idisp, $mem$$base$$Register);
 2741     __ twi_0($dst$$Register);
 2742     __ isync();
 2743   %}
 2744 
 2745   enc_class enc_ld(iRegLdst dst, memoryAlg4 mem) %{
 2746     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<a name="44" id="anc44"></a><span class="line-modified"> 2747     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2748     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2749     // Operand &#39;ds&#39; requires 4-alignment.
 2750     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2751     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2752   %}
 2753 
 2754   // Load acquire.
 2755   enc_class enc_ld_ac(iRegLdst dst, memoryAlg4 mem) %{
 2756     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="45" id="anc45"></a><span class="line-modified"> 2757     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2758     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2759     // Operand &#39;ds&#39; requires 4-alignment.
 2760     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 2761     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 2762     __ twi_0($dst$$Register);
 2763     __ isync();
 2764   %}
 2765 
 2766   enc_class enc_lfd(RegF dst, memory mem) %{
 2767     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
<a name="46" id="anc46"></a><span class="line-modified"> 2768     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2769     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 2770     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 2771   %}
 2772 
 2773   enc_class enc_load_long_constL(iRegLdst dst, immL src, iRegLdst toc) %{
 2774     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 2775 
<a name="47" id="anc47"></a><span class="line-modified"> 2776     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2777     int toc_offset = 0;
 2778 
 2779     address const_toc_addr;
 2780     // Create a non-oop constant, no relocation needed.
 2781     // If it is an IC, it has a virtual_call_Relocation.
 2782     const_toc_addr = __ long_constant((jlong)$src$$constant);
 2783     if (const_toc_addr == NULL) {
 2784       ciEnv::current()-&gt;record_out_of_memory_failure();
 2785       return;
 2786     }
 2787 
 2788     // Get the constant&#39;s TOC offset.
 2789     toc_offset = __ offset_to_method_toc(const_toc_addr);
 2790 
 2791     // Keep the current instruction offset in mind.
 2792     ((loadConLNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2793 
 2794     __ ld($dst$$Register, toc_offset, $toc$$Register);
 2795   %}
 2796 
 2797   enc_class enc_load_long_constL_hi(iRegLdst dst, iRegLdst toc, immL src) %{
 2798     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 2799 
<a name="48" id="anc48"></a><span class="line-modified"> 2800     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2801 
<a name="49" id="anc49"></a><span class="line-modified"> 2802     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 2803       address const_toc_addr;
 2804       // Create a non-oop constant, no relocation needed.
 2805       // If it is an IC, it has a virtual_call_Relocation.
 2806       const_toc_addr = __ long_constant((jlong)$src$$constant);
 2807       if (const_toc_addr == NULL) {
 2808         ciEnv::current()-&gt;record_out_of_memory_failure();
 2809         return;
 2810       }
 2811 
 2812       // Get the constant&#39;s TOC offset.
 2813       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 2814       // Store the toc offset of the constant.
 2815       ((loadConL_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 2816 
 2817       // Also keep the current instruction offset in mind.
 2818       ((loadConL_hiNode*)this)-&gt;_cbuf_insts_offset = __ offset();
 2819     }
 2820 
 2821     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 2822   %}
 2823 
 2824 %} // encode
 2825 
 2826 source %{
 2827 
 2828 typedef struct {
 2829   loadConL_hiNode *_large_hi;
 2830   loadConL_loNode *_large_lo;
 2831   loadConLNode    *_small;
 2832   MachNode        *_last;
 2833 } loadConLNodesTuple;
 2834 
 2835 loadConLNodesTuple loadConLNodesTuple_create(PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2836                                              OptoReg::Name reg_second, OptoReg::Name reg_first) {
 2837   loadConLNodesTuple nodes;
 2838 
 2839   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2840   if (large_constant_pool) {
 2841     // Create new nodes.
 2842     loadConL_hiNode *m1 = new loadConL_hiNode();
 2843     loadConL_loNode *m2 = new loadConL_loNode();
 2844 
 2845     // inputs for new nodes
 2846     m1-&gt;add_req(NULL, toc);
 2847     m2-&gt;add_req(NULL, m1);
 2848 
 2849     // operands for new nodes
 2850     m1-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2851     m1-&gt;_opnds[1] = immSrc;             // src
 2852     m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2853     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2854     m2-&gt;_opnds[1] = immSrc;             // src
 2855     m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 2856 
 2857     // Initialize ins_attrib TOC fields.
 2858     m1-&gt;_const_toc_offset = -1;
 2859     m2-&gt;_const_toc_offset_hi_node = m1;
 2860 
 2861     // Initialize ins_attrib instruction offset.
 2862     m1-&gt;_cbuf_insts_offset = -1;
 2863 
 2864     // register allocation for new nodes
 2865     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2866     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2867 
 2868     // Create result.
 2869     nodes._large_hi = m1;
 2870     nodes._large_lo = m2;
 2871     nodes._small = NULL;
 2872     nodes._last = nodes._large_lo;
 2873     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2874   } else {
 2875     loadConLNode *m2 = new loadConLNode();
 2876 
 2877     // inputs for new nodes
 2878     m2-&gt;add_req(NULL, toc);
 2879 
 2880     // operands for new nodes
 2881     m2-&gt;_opnds[0] = new iRegLdstOper(); // dst
 2882     m2-&gt;_opnds[1] = immSrc;             // src
 2883     m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 2884 
 2885     // Initialize ins_attrib instruction offset.
 2886     m2-&gt;_cbuf_insts_offset = -1;
 2887 
 2888     // register allocation for new nodes
 2889     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2890 
 2891     // Create result.
 2892     nodes._large_hi = NULL;
 2893     nodes._large_lo = NULL;
 2894     nodes._small = m2;
 2895     nodes._last = nodes._small;
 2896     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2897   }
 2898 
 2899   return nodes;
 2900 }
 2901 
 2902 typedef struct {
 2903   loadConL_hiNode *_large_hi;
 2904   loadConL_loNode *_large_lo;
 2905   mtvsrdNode      *_moved;
 2906   xxspltdNode     *_replicated;
 2907   loadConLNode    *_small;
 2908   MachNode        *_last;
 2909 } loadConLReplicatedNodesTuple;
 2910 
 2911 loadConLReplicatedNodesTuple loadConLReplicatedNodesTuple_create(Compile *C, PhaseRegAlloc *ra_, Node *toc, immLOper *immSrc,
 2912                                                  vecXOper *dst, immI_0Oper *zero,
 2913                                                  OptoReg::Name reg_second, OptoReg::Name reg_first,
 2914                                                  OptoReg::Name reg_vec_second, OptoReg::Name reg_vec_first) {
 2915   loadConLReplicatedNodesTuple nodes;
 2916 
 2917   const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 2918   if (large_constant_pool) {
 2919     // Create new nodes.
 2920     loadConL_hiNode *m1 = new  loadConL_hiNode();
 2921     loadConL_loNode *m2 = new  loadConL_loNode();
 2922     mtvsrdNode *m3 = new  mtvsrdNode();
 2923     xxspltdNode *m4 = new  xxspltdNode();
 2924 
 2925     // inputs for new nodes
 2926     m1-&gt;add_req(NULL, toc);
 2927     m2-&gt;add_req(NULL, m1);
 2928     m3-&gt;add_req(NULL, m2);
 2929     m4-&gt;add_req(NULL, m3);
 2930 
 2931     // operands for new nodes
 2932     m1-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2933     m1-&gt;_opnds[1] = immSrc;              // src
 2934     m1-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2935 
 2936     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2937     m2-&gt;_opnds[1] = immSrc;              // src
 2938     m2-&gt;_opnds[2] = new  iRegLdstOper(); // base
 2939 
 2940     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2941     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2942 
 2943     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2944     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2945     m4-&gt;_opnds[2] = zero;
 2946 
 2947     // Initialize ins_attrib TOC fields.
 2948     m1-&gt;_const_toc_offset = -1;
 2949     m2-&gt;_const_toc_offset_hi_node = m1;
 2950 
 2951     // Initialize ins_attrib instruction offset.
 2952     m1-&gt;_cbuf_insts_offset = -1;
 2953 
 2954     // register allocation for new nodes
 2955     ra_-&gt;set_pair(m1-&gt;_idx, reg_second, reg_first);
 2956     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2957     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2958     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2959     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2960 
 2961     // Create result.
 2962     nodes._large_hi = m1;
 2963     nodes._large_lo = m2;
 2964     nodes._moved = m3;
 2965     nodes._replicated = m4;
 2966     nodes._small = NULL;
 2967     nodes._last = nodes._replicated;
 2968     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 2969   } else {
 2970     loadConLNode *m2 = new  loadConLNode();
 2971     mtvsrdNode *m3 = new  mtvsrdNode();
 2972     xxspltdNode *m4 = new  xxspltdNode();
 2973 
 2974     // inputs for new nodes
 2975     m2-&gt;add_req(NULL, toc);
 2976 
 2977     // operands for new nodes
 2978     m2-&gt;_opnds[0] = new  iRegLdstOper(); // dst
 2979     m2-&gt;_opnds[1] = immSrc;              // src
 2980     m2-&gt;_opnds[2] = new  iRegPdstOper(); // toc
 2981 
 2982     m3-&gt;_opnds[0] = new  vecXOper();     // dst
 2983     m3-&gt;_opnds[1] = new  iRegLdstOper(); // src
 2984 
 2985     m4-&gt;_opnds[0] = new  vecXOper();     // dst
 2986     m4-&gt;_opnds[1] = new  vecXOper();     // src
 2987     m4-&gt;_opnds[2] = zero;
 2988 
 2989     // Initialize ins_attrib instruction offset.
 2990     m2-&gt;_cbuf_insts_offset = -1;
 2991     ra_-&gt;set1(m3-&gt;_idx, reg_second);
 2992     ra_-&gt;set2(m3-&gt;_idx, reg_vec_first);
 2993     ra_-&gt;set_pair(m4-&gt;_idx, reg_vec_second, reg_vec_first);
 2994 
 2995     // register allocation for new nodes
 2996     ra_-&gt;set_pair(m2-&gt;_idx, reg_second, reg_first);
 2997 
 2998     // Create result.
 2999     nodes._large_hi = NULL;
 3000     nodes._large_lo = NULL;
 3001     nodes._small = m2;
 3002     nodes._moved = m3;
 3003     nodes._replicated = m4;
 3004     nodes._last = nodes._replicated;
 3005     assert(m2-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3006   }
 3007 
 3008   return nodes;
 3009 }
 3010 
 3011 %} // source
 3012 
 3013 encode %{
 3014   // Postalloc expand emitter for loading a long constant from the method&#39;s TOC.
 3015   // Enc_class needed as consttanttablebase is not supported by postalloc
 3016   // expand.
 3017   enc_class postalloc_expand_load_long_constant(iRegLdst dst, immL src, iRegLdst toc) %{
 3018     // Create new nodes.
 3019     loadConLNodesTuple loadConLNodes =
 3020       loadConLNodesTuple_create(ra_, n_toc, op_src,
 3021                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3022 
 3023     // Push new nodes.
 3024     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3025     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3026 
 3027     // some asserts
 3028     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3029     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3030   %}
 3031 
 3032   enc_class enc_load_long_constP(iRegLdst dst, immP src, iRegLdst toc) %{
 3033     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3034 
<a name="50" id="anc50"></a><span class="line-modified"> 3035     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3036     int toc_offset = 0;
 3037 
 3038     intptr_t val = $src$$constant;
 3039     relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3040     address const_toc_addr;
 3041     if (constant_reloc == relocInfo::oop_type) {
 3042       // Create an oop constant and a corresponding relocation.
 3043       AddressLiteral a = __ allocate_oop_address((jobject)val);
 3044       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3045       __ relocate(a.rspec());
 3046     } else if (constant_reloc == relocInfo::metadata_type) {
 3047       AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3048       const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3049       __ relocate(a.rspec());
 3050     } else {
 3051       // Create a non-oop constant, no relocation needed.
 3052       const_toc_addr = __ long_constant((jlong)$src$$constant);
 3053     }
 3054 
 3055     if (const_toc_addr == NULL) {
 3056       ciEnv::current()-&gt;record_out_of_memory_failure();
 3057       return;
 3058     }
 3059     // Get the constant&#39;s TOC offset.
 3060     toc_offset = __ offset_to_method_toc(const_toc_addr);
 3061 
 3062     __ ld($dst$$Register, toc_offset, $toc$$Register);
 3063   %}
 3064 
 3065   enc_class enc_load_long_constP_hi(iRegLdst dst, immP src, iRegLdst toc) %{
 3066     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 3067 
<a name="51" id="anc51"></a><span class="line-modified"> 3068     C2_MacroAssembler _masm(&amp;cbuf);</span>
<span class="line-modified"> 3069     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 3070       intptr_t val = $src$$constant;
 3071       relocInfo::relocType constant_reloc = $src-&gt;constant_reloc();  // src
 3072       address const_toc_addr;
 3073       if (constant_reloc == relocInfo::oop_type) {
 3074         // Create an oop constant and a corresponding relocation.
 3075         AddressLiteral a = __ allocate_oop_address((jobject)val);
 3076         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3077         __ relocate(a.rspec());
 3078       } else if (constant_reloc == relocInfo::metadata_type) {
 3079         AddressLiteral a = __ constant_metadata_address((Metadata *)val);
 3080         const_toc_addr = __ address_constant((address)a.value(), RelocationHolder::none);
 3081         __ relocate(a.rspec());
 3082       } else {  // non-oop pointers, e.g. card mark base, heap top
 3083         // Create a non-oop constant, no relocation needed.
 3084         const_toc_addr = __ long_constant((jlong)$src$$constant);
 3085       }
 3086 
 3087       if (const_toc_addr == NULL) {
 3088         ciEnv::current()-&gt;record_out_of_memory_failure();
 3089         return;
 3090       }
 3091       // Get the constant&#39;s TOC offset.
 3092       const int toc_offset = __ offset_to_method_toc(const_toc_addr);
 3093       // Store the toc offset of the constant.
 3094       ((loadConP_hiNode*)this)-&gt;_const_toc_offset = toc_offset;
 3095     }
 3096 
 3097     __ addis($dst$$Register, $toc$$Register, MacroAssembler::largeoffset_si16_si16_hi(_const_toc_offset));
 3098   %}
 3099 
 3100   // Postalloc expand emitter for loading a ptr constant from the method&#39;s TOC.
 3101   // Enc_class needed as consttanttablebase is not supported by postalloc
 3102   // expand.
 3103   enc_class postalloc_expand_load_ptr_constant(iRegPdst dst, immP src, iRegLdst toc) %{
 3104     const bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3105     if (large_constant_pool) {
 3106       // Create new nodes.
 3107       loadConP_hiNode *m1 = new loadConP_hiNode();
 3108       loadConP_loNode *m2 = new loadConP_loNode();
 3109 
 3110       // inputs for new nodes
 3111       m1-&gt;add_req(NULL, n_toc);
 3112       m2-&gt;add_req(NULL, m1);
 3113 
 3114       // operands for new nodes
 3115       m1-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3116       m1-&gt;_opnds[1] = op_src;             // src
 3117       m1-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3118       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3119       m2-&gt;_opnds[1] = op_src;             // src
 3120       m2-&gt;_opnds[2] = new iRegLdstOper(); // base
 3121 
 3122       // Initialize ins_attrib TOC fields.
 3123       m1-&gt;_const_toc_offset = -1;
 3124       m2-&gt;_const_toc_offset_hi_node = m1;
 3125 
 3126       // Register allocation for new nodes.
 3127       ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3128       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3129 
 3130       nodes-&gt;push(m1);
 3131       nodes-&gt;push(m2);
 3132       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3133     } else {
 3134       loadConPNode *m2 = new loadConPNode();
 3135 
 3136       // inputs for new nodes
 3137       m2-&gt;add_req(NULL, n_toc);
 3138 
 3139       // operands for new nodes
 3140       m2-&gt;_opnds[0] = new iRegPdstOper(); // dst
 3141       m2-&gt;_opnds[1] = op_src;             // src
 3142       m2-&gt;_opnds[2] = new iRegPdstOper(); // toc
 3143 
 3144       // Register allocation for new nodes.
 3145       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3146 
 3147       nodes-&gt;push(m2);
 3148       assert(m2-&gt;bottom_type()-&gt;isa_ptr(), &quot;must be ptr&quot;);
 3149     }
 3150   %}
 3151 
 3152   // Enc_class needed as consttanttablebase is not supported by postalloc
 3153   // expand.
 3154   enc_class postalloc_expand_load_float_constant(regF dst, immF src, iRegLdst toc) %{
 3155     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3156 
 3157     MachNode *m2;
 3158     if (large_constant_pool) {
 3159       m2 = new loadConFCompNode();
 3160     } else {
 3161       m2 = new loadConFNode();
 3162     }
 3163     // inputs for new nodes
 3164     m2-&gt;add_req(NULL, n_toc);
 3165 
 3166     // operands for new nodes
 3167     m2-&gt;_opnds[0] = op_dst;
 3168     m2-&gt;_opnds[1] = op_src;
 3169     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3170 
 3171     // register allocation for new nodes
 3172     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3173     nodes-&gt;push(m2);
 3174   %}
 3175 
 3176   // Enc_class needed as consttanttablebase is not supported by postalloc
 3177   // expand.
 3178   enc_class postalloc_expand_load_double_constant(regD dst, immD src, iRegLdst toc) %{
 3179     bool large_constant_pool = true; // TODO: PPC port C-&gt;cfg()-&gt;_consts_size &gt; 4000;
 3180 
 3181     MachNode *m2;
 3182     if (large_constant_pool) {
 3183       m2 = new loadConDCompNode();
 3184     } else {
 3185       m2 = new loadConDNode();
 3186     }
 3187     // inputs for new nodes
 3188     m2-&gt;add_req(NULL, n_toc);
 3189 
 3190     // operands for new nodes
 3191     m2-&gt;_opnds[0] = op_dst;
 3192     m2-&gt;_opnds[1] = op_src;
 3193     m2-&gt;_opnds[2] = new iRegPdstOper(); // constanttablebase
 3194 
 3195     // register allocation for new nodes
 3196     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3197     nodes-&gt;push(m2);
 3198   %}
 3199 
 3200   enc_class enc_stw(iRegIsrc src, memory mem) %{
 3201     // TODO: PPC port $archOpcode(ppc64Opcode_stw);
<a name="52" id="anc52"></a><span class="line-modified"> 3202     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3203     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3204     __ stw($src$$Register, Idisp, $mem$$base$$Register);
 3205   %}
 3206 
 3207   enc_class enc_std(iRegIsrc src, memoryAlg4 mem) %{
 3208     // TODO: PPC port $archOpcode(ppc64Opcode_std);
<a name="53" id="anc53"></a><span class="line-modified"> 3209     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3210     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3211     // Operand &#39;ds&#39; requires 4-alignment.
 3212     assert((Idisp &amp; 0x3) == 0, &quot;unaligned offset&quot;);
 3213     __ std($src$$Register, Idisp, $mem$$base$$Register);
 3214   %}
 3215 
 3216   enc_class enc_stfs(RegF src, memory mem) %{
 3217     // TODO: PPC port $archOpcode(ppc64Opcode_stfs);
<a name="54" id="anc54"></a><span class="line-modified"> 3218     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3219     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3220     __ stfs($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3221   %}
 3222 
 3223   enc_class enc_stfd(RegF src, memory mem) %{
 3224     // TODO: PPC port $archOpcode(ppc64Opcode_stfd);
<a name="55" id="anc55"></a><span class="line-modified"> 3225     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3226     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3227     __ stfd($src$$FloatRegister, Idisp, $mem$$base$$Register);
 3228   %}
 3229 
 3230   // Use release_store for card-marking to ensure that previous
 3231   // oop-stores are visible before the card-mark change.
 3232   enc_class enc_cms_card_mark(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 3233     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3234     // FIXME: Implement this as a cmove and use a fixed condition code
 3235     // register which is written on every transition to compiled code,
 3236     // e.g. in call-stub and when returning from runtime stubs.
 3237     //
 3238     // Proposed code sequence for the cmove implementation:
 3239     //
 3240     // Label skip_release;
 3241     // __ beq(CCRfixed, skip_release);
 3242     // __ release();
 3243     // __ bind(skip_release);
 3244     // __ stb(card mark);
 3245 
<a name="56" id="anc56"></a><span class="line-modified"> 3246     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3247     Label skip_storestore;
 3248 
 3249 #if 0 // TODO: PPC port
 3250     // Check CMSCollectorCardTableBarrierSetBSExt::_requires_release and do the
 3251     // StoreStore barrier conditionally.
 3252     __ lwz(R0, 0, $releaseFieldAddr$$Register);
 3253     __ cmpwi($crx$$CondRegister, R0, 0);
 3254     __ beq_predict_taken($crx$$CondRegister, skip_storestore);
 3255 #endif
 3256     __ li(R0, 0);
 3257     __ membar(Assembler::StoreStore);
 3258 #if 0 // TODO: PPC port
 3259     __ bind(skip_storestore);
 3260 #endif
 3261 
 3262     // Do the store.
 3263     if ($mem$$index == 0) {
 3264       __ stb(R0, $mem$$disp, $mem$$base$$Register);
 3265     } else {
 3266       assert(0 == $mem$$disp, &quot;no displacement possible with indexed load/stores on ppc&quot;);
 3267       __ stbx(R0, $mem$$base$$Register, $mem$$index$$Register);
 3268     }
 3269   %}
 3270 
 3271   enc_class postalloc_expand_encode_oop(iRegNdst dst, iRegPdst src, flagsReg crx) %{
 3272 
 3273     if (VM_Version::has_isel()) {
 3274       // use isel instruction with Power 7
 3275       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3276       encodeP_subNode    *n_sub_base = new encodeP_subNode();
 3277       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3278       cond_set_0_oopNode *n_cond_set = new cond_set_0_oopNode();
 3279 
 3280       n_compare-&gt;add_req(n_region, n_src);
 3281       n_compare-&gt;_opnds[0] = op_crx;
 3282       n_compare-&gt;_opnds[1] = op_src;
 3283       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3284 
 3285       n_sub_base-&gt;add_req(n_region, n_src);
 3286       n_sub_base-&gt;_opnds[0] = op_dst;
 3287       n_sub_base-&gt;_opnds[1] = op_src;
 3288       n_sub_base-&gt;_bottom_type = _bottom_type;
 3289 
 3290       n_shift-&gt;add_req(n_region, n_sub_base);
 3291       n_shift-&gt;_opnds[0] = op_dst;
 3292       n_shift-&gt;_opnds[1] = op_dst;
 3293       n_shift-&gt;_bottom_type = _bottom_type;
 3294 
 3295       n_cond_set-&gt;add_req(n_region, n_compare, n_shift);
 3296       n_cond_set-&gt;_opnds[0] = op_dst;
 3297       n_cond_set-&gt;_opnds[1] = op_crx;
 3298       n_cond_set-&gt;_opnds[2] = op_dst;
 3299       n_cond_set-&gt;_bottom_type = _bottom_type;
 3300 
 3301       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3302       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3303       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3304       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3305 
 3306       nodes-&gt;push(n_compare);
 3307       nodes-&gt;push(n_sub_base);
 3308       nodes-&gt;push(n_shift);
 3309       nodes-&gt;push(n_cond_set);
 3310 
 3311     } else {
 3312       // before Power 7
 3313       moveRegNode        *n_move     = new moveRegNode();
 3314       cmpP_reg_imm16Node *n_compare  = new cmpP_reg_imm16Node();
 3315       encodeP_shiftNode  *n_shift    = new encodeP_shiftNode();
 3316       cond_sub_baseNode  *n_sub_base = new cond_sub_baseNode();
 3317 
 3318       n_move-&gt;add_req(n_region, n_src);
 3319       n_move-&gt;_opnds[0] = op_dst;
 3320       n_move-&gt;_opnds[1] = op_src;
 3321       ra_-&gt;set_oop(n_move, true); // Until here, &#39;n_move&#39; still produces an oop.
 3322 
 3323       n_compare-&gt;add_req(n_region, n_src);
 3324       n_compare-&gt;add_prec(n_move);
 3325 
 3326       n_compare-&gt;_opnds[0] = op_crx;
 3327       n_compare-&gt;_opnds[1] = op_src;
 3328       n_compare-&gt;_opnds[2] = new immL16Oper(0);
 3329 
 3330       n_sub_base-&gt;add_req(n_region, n_compare, n_src);
 3331       n_sub_base-&gt;_opnds[0] = op_dst;
 3332       n_sub_base-&gt;_opnds[1] = op_crx;
 3333       n_sub_base-&gt;_opnds[2] = op_src;
 3334       n_sub_base-&gt;_bottom_type = _bottom_type;
 3335 
 3336       n_shift-&gt;add_req(n_region, n_sub_base);
 3337       n_shift-&gt;_opnds[0] = op_dst;
 3338       n_shift-&gt;_opnds[1] = op_dst;
 3339       n_shift-&gt;_bottom_type = _bottom_type;
 3340 
 3341       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3342       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3343       ra_-&gt;set_pair(n_sub_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3344       ra_-&gt;set_pair(n_move-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3345 
 3346       nodes-&gt;push(n_move);
 3347       nodes-&gt;push(n_compare);
 3348       nodes-&gt;push(n_sub_base);
 3349       nodes-&gt;push(n_shift);
 3350     }
 3351 
 3352     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3353   %}
 3354 
 3355   enc_class postalloc_expand_encode_oop_not_null(iRegNdst dst, iRegPdst src) %{
 3356 
 3357     encodeP_subNode *n1 = new encodeP_subNode();
 3358     n1-&gt;add_req(n_region, n_src);
 3359     n1-&gt;_opnds[0] = op_dst;
 3360     n1-&gt;_opnds[1] = op_src;
 3361     n1-&gt;_bottom_type = _bottom_type;
 3362 
 3363     encodeP_shiftNode *n2 = new encodeP_shiftNode();
 3364     n2-&gt;add_req(n_region, n1);
 3365     n2-&gt;_opnds[0] = op_dst;
 3366     n2-&gt;_opnds[1] = op_dst;
 3367     n2-&gt;_bottom_type = _bottom_type;
 3368     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3369     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3370 
 3371     nodes-&gt;push(n1);
 3372     nodes-&gt;push(n2);
 3373     assert(!(ra_-&gt;is_oop(this)), &quot;sanity&quot;); // This is not supposed to be GC&#39;ed.
 3374   %}
 3375 
 3376   enc_class postalloc_expand_decode_oop(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 3377     decodeN_shiftNode *n_shift    = new decodeN_shiftNode();
 3378     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 3379 
 3380     n_compare-&gt;add_req(n_region, n_src);
 3381     n_compare-&gt;_opnds[0] = op_crx;
 3382     n_compare-&gt;_opnds[1] = op_src;
 3383     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 3384 
 3385     n_shift-&gt;add_req(n_region, n_src);
 3386     n_shift-&gt;_opnds[0] = op_dst;
 3387     n_shift-&gt;_opnds[1] = op_src;
 3388     n_shift-&gt;_bottom_type = _bottom_type;
 3389 
 3390     if (VM_Version::has_isel()) {
 3391       // use isel instruction with Power 7
 3392 
 3393       decodeN_addNode *n_add_base = new decodeN_addNode();
 3394       n_add_base-&gt;add_req(n_region, n_shift);
 3395       n_add_base-&gt;_opnds[0] = op_dst;
 3396       n_add_base-&gt;_opnds[1] = op_dst;
 3397       n_add_base-&gt;_bottom_type = _bottom_type;
 3398 
 3399       cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 3400       n_cond_set-&gt;add_req(n_region, n_compare, n_add_base);
 3401       n_cond_set-&gt;_opnds[0] = op_dst;
 3402       n_cond_set-&gt;_opnds[1] = op_crx;
 3403       n_cond_set-&gt;_opnds[2] = op_dst;
 3404       n_cond_set-&gt;_bottom_type = _bottom_type;
 3405 
 3406       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3407       ra_-&gt;set_oop(n_cond_set, true);
 3408 
 3409       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3410       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3411       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3412       ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3413 
 3414       nodes-&gt;push(n_compare);
 3415       nodes-&gt;push(n_shift);
 3416       nodes-&gt;push(n_add_base);
 3417       nodes-&gt;push(n_cond_set);
 3418 
 3419     } else {
 3420       // before Power 7
 3421       cond_add_baseNode *n_add_base = new cond_add_baseNode();
 3422 
 3423       n_add_base-&gt;add_req(n_region, n_compare, n_shift);
 3424       n_add_base-&gt;_opnds[0] = op_dst;
 3425       n_add_base-&gt;_opnds[1] = op_crx;
 3426       n_add_base-&gt;_opnds[2] = op_dst;
 3427       n_add_base-&gt;_bottom_type = _bottom_type;
 3428 
 3429       assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3430       ra_-&gt;set_oop(n_add_base, true);
 3431 
 3432       ra_-&gt;set_pair(n_shift-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3433       ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 3434       ra_-&gt;set_pair(n_add_base-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3435 
 3436       nodes-&gt;push(n_compare);
 3437       nodes-&gt;push(n_shift);
 3438       nodes-&gt;push(n_add_base);
 3439     }
 3440   %}
 3441 
 3442   enc_class postalloc_expand_decode_oop_not_null(iRegPdst dst, iRegNsrc src) %{
 3443     decodeN_shiftNode *n1 = new decodeN_shiftNode();
 3444     n1-&gt;add_req(n_region, n_src);
 3445     n1-&gt;_opnds[0] = op_dst;
 3446     n1-&gt;_opnds[1] = op_src;
 3447     n1-&gt;_bottom_type = _bottom_type;
 3448 
 3449     decodeN_addNode *n2 = new decodeN_addNode();
 3450     n2-&gt;add_req(n_region, n1);
 3451     n2-&gt;_opnds[0] = op_dst;
 3452     n2-&gt;_opnds[1] = op_dst;
 3453     n2-&gt;_bottom_type = _bottom_type;
 3454     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3455     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3456 
 3457     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 3458     ra_-&gt;set_oop(n2, true);
 3459 
 3460     nodes-&gt;push(n1);
 3461     nodes-&gt;push(n2);
 3462   %}
 3463 
 3464   enc_class enc_cmove_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src, cmpOp cmp) %{
 3465     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3466 
<a name="57" id="anc57"></a><span class="line-modified"> 3467     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3468     int cc        = $cmp$$cmpcode;
 3469     int flags_reg = $crx$$reg;
 3470     Label done;
 3471     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3472     // Branch if not (cmp crx).
 3473     __ bc(cc_to_inverse_boint(cc), cc_to_biint(cc, flags_reg), done);
 3474     __ mr($dst$$Register, $src$$Register);
 3475     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3476     __ bind(done);
 3477   %}
 3478 
 3479   enc_class enc_cmove_imm(iRegIdst dst, flagsRegSrc crx, immI16 src, cmpOp cmp) %{
 3480     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3481 
<a name="58" id="anc58"></a><span class="line-modified"> 3482     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3483     Label done;
 3484     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3485     // Branch if not (cmp crx).
 3486     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 3487     __ li($dst$$Register, $src$$constant);
 3488     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3489     __ bind(done);
 3490   %}
 3491 
 3492   // This enc_class is needed so that scheduler gets proper
 3493   // input mapping for latency computation.
 3494   enc_class enc_andc(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 3495     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
<a name="59" id="anc59"></a><span class="line-modified"> 3496     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3497     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
 3498   %}
 3499 
 3500   enc_class enc_convI2B_regI__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3501     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3502 
<a name="60" id="anc60"></a><span class="line-modified"> 3503     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3504 
 3505     Label done;
 3506     __ cmpwi($crx$$CondRegister, $src$$Register, 0);
 3507     __ li($dst$$Register, $zero$$constant);
 3508     __ beq($crx$$CondRegister, done);
 3509     __ li($dst$$Register, $notzero$$constant);
 3510     __ bind(done);
 3511   %}
 3512 
 3513   enc_class enc_convP2B_regP__cmove(iRegIdst dst, iRegPsrc src, flagsReg crx, immI16 zero, immI16 notzero) %{
 3514     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3515 
<a name="61" id="anc61"></a><span class="line-modified"> 3516     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3517 
 3518     Label done;
 3519     __ cmpdi($crx$$CondRegister, $src$$Register, 0);
 3520     __ li($dst$$Register, $zero$$constant);
 3521     __ beq($crx$$CondRegister, done);
 3522     __ li($dst$$Register, $notzero$$constant);
 3523     __ bind(done);
 3524   %}
 3525 
 3526   enc_class enc_cmove_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL mem ) %{
 3527     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3528 
<a name="62" id="anc62"></a><span class="line-modified"> 3529     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3530     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 3531     Label done;
 3532     __ bso($crx$$CondRegister, done);
 3533     __ ld($dst$$Register, Idisp, $mem$$base$$Register);
 3534     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3535     __ bind(done);
 3536   %}
 3537 
 3538   enc_class enc_cmove_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
 3539     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 3540 
<a name="63" id="anc63"></a><span class="line-modified"> 3541     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3542     Label done;
 3543     __ bso($crx$$CondRegister, done);
 3544     __ mffprd($dst$$Register, $src$$FloatRegister);
 3545     // TODO PPC port __ endgroup_if_needed(_size == 12);
 3546     __ bind(done);
 3547   %}
 3548 
 3549   enc_class enc_bc(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3550     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3551 
<a name="64" id="anc64"></a><span class="line-modified"> 3552     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3553     Label d;   // dummy
 3554     __ bind(d);
 3555     Label* p = ($lbl$$label);
 3556     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3557     // determine the size of the encoded instruction.
 3558     Label&amp; l = (NULL == p)? d : *(p);
 3559     int cc = $cmp$$cmpcode;
 3560     int flags_reg = $crx$$reg;
 3561     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 3562     int bhint = Assembler::bhintNoHint;
 3563 
 3564     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3565       if (_prob &lt;= PROB_NEVER) {
 3566         bhint = Assembler::bhintIsNotTaken;
 3567       } else if (_prob &gt;= PROB_ALWAYS) {
 3568         bhint = Assembler::bhintIsTaken;
 3569       }
 3570     }
 3571 
 3572     __ bc(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3573           cc_to_biint(cc, flags_reg),
 3574           l);
 3575   %}
 3576 
 3577   enc_class enc_bc_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3578     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3579     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3580     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3581 
<a name="65" id="anc65"></a><span class="line-modified"> 3582     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3583     Label d;    // dummy
 3584     __ bind(d);
 3585     Label* p = ($lbl$$label);
 3586     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3587     // determine the size of the encoded instruction.
 3588     Label&amp; l = (NULL == p)? d : *(p);
 3589     int cc = $cmp$$cmpcode;
 3590     int flags_reg = $crx$$reg;
 3591     int bhint = Assembler::bhintNoHint;
 3592 
 3593     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3594       if (_prob &lt;= PROB_NEVER) {
 3595         bhint = Assembler::bhintIsNotTaken;
 3596       } else if (_prob &gt;= PROB_ALWAYS) {
 3597         bhint = Assembler::bhintIsTaken;
 3598       }
 3599     }
 3600 
 3601     // Tell the conditional far branch to optimize itself when being relocated.
 3602     __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3603                   cc_to_biint(cc, flags_reg),
 3604                   l,
 3605                   MacroAssembler::bc_far_optimize_on_relocate);
 3606   %}
 3607 
 3608   // Branch used with Power6 scheduling (can be shortened without changing the node).
 3609   enc_class enc_bc_short_far(flagsRegSrc crx, cmpOp cmp, Label lbl) %{
 3610     // The scheduler doesn&#39;t know about branch shortening, so we set the opcode
 3611     // to ppc64Opcode_bc in order to hide this detail from the scheduler.
 3612     // TODO: PPC port $archOpcode(ppc64Opcode_bc);
 3613 
<a name="66" id="anc66"></a><span class="line-modified"> 3614     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3615     Label d;   // dummy
 3616     __ bind(d);
 3617     Label* p = ($lbl$$label);
 3618     // `p&#39; is `NULL&#39; when this encoding class is used only to
 3619     // determine the size of the encoded instruction.
 3620     Label&amp; l = (NULL == p)? d : *(p);
 3621     int cc = $cmp$$cmpcode;
 3622     int flags_reg = $crx$$reg;
 3623     int bhint = Assembler::bhintNoHint;
 3624 
 3625     if (UseStaticBranchPredictionForUncommonPathsPPC64) {
 3626       if (_prob &lt;= PROB_NEVER) {
 3627         bhint = Assembler::bhintIsNotTaken;
 3628       } else if (_prob &gt;= PROB_ALWAYS) {
 3629         bhint = Assembler::bhintIsTaken;
 3630       }
 3631     }
 3632 
 3633 #if 0 // TODO: PPC port
 3634     if (_size == 8) {
 3635       // Tell the conditional far branch to optimize itself when being relocated.
 3636       __ bc_far(Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3637                     cc_to_biint(cc, flags_reg),
 3638                     l,
 3639                     MacroAssembler::bc_far_optimize_on_relocate);
 3640     } else {
 3641       __ bc    (Assembler::add_bhint_to_boint(bhint, cc_to_boint(cc)),
 3642                     cc_to_biint(cc, flags_reg),
 3643                     l);
 3644     }
 3645 #endif
 3646     Unimplemented();
 3647   %}
 3648 
 3649   // Postalloc expand emitter for loading a replicatef float constant from
 3650   // the method&#39;s TOC.
 3651   // Enc_class needed as consttanttablebase is not supported by postalloc
 3652   // expand.
 3653   enc_class postalloc_expand_load_replF_constant(iRegLdst dst, immF src, iRegLdst toc) %{
 3654     // Create new nodes.
 3655 
 3656     // Make an operand with the bit pattern to load as float.
 3657     immLOper *op_repl = new immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3658 
 3659     loadConLNodesTuple loadConLNodes =
 3660       loadConLNodesTuple_create(ra_, n_toc, op_repl,
 3661                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3662 
 3663     // Push new nodes.
 3664     if (loadConLNodes._large_hi) nodes-&gt;push(loadConLNodes._large_hi);
 3665     if (loadConLNodes._last)     nodes-&gt;push(loadConLNodes._last);
 3666 
 3667     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3668     assert(loadConLNodes._last-&gt;bottom_type()-&gt;isa_long(), &quot;must be long&quot;);
 3669   %}
 3670 
 3671   enc_class postalloc_expand_load_replF_constant_vsx(vecX dst, immF src, iRegLdst toc, iRegLdst tmp) %{
 3672     // Create new nodes.
 3673 
 3674     // Make an operand with the bit pattern to load as float.
 3675     immLOper *op_repl = new  immLOper((jlong)replicate_immF(op_src-&gt;constantF()));
 3676     immI_0Oper *op_zero = new  immI_0Oper(0);
 3677 
 3678     loadConLReplicatedNodesTuple loadConLNodes =
 3679       loadConLReplicatedNodesTuple_create(C, ra_, n_toc, op_repl, op_dst, op_zero,
 3680                                 ra_-&gt;get_reg_second(n_tmp), ra_-&gt;get_reg_first(n_tmp),
 3681                                 ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 3682 
 3683     // Push new nodes.
 3684     if (loadConLNodes._large_hi) { nodes-&gt;push(loadConLNodes._large_hi); }
 3685     if (loadConLNodes._large_lo) { nodes-&gt;push(loadConLNodes._large_lo); }
 3686     if (loadConLNodes._moved)    { nodes-&gt;push(loadConLNodes._moved); }
 3687     if (loadConLNodes._last)     { nodes-&gt;push(loadConLNodes._last); }
 3688 
 3689     assert(nodes-&gt;length() &gt;= 1, &quot;must have created at least 1 node&quot;);
 3690   %}
 3691 
 3692   // This enc_class is needed so that scheduler gets proper
 3693   // input mapping for latency computation.
 3694   enc_class enc_poll(immI dst, iRegLdst poll) %{
 3695     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
 3696     // Fake operand dst needed for PPC scheduler.
 3697     assert($dst$$constant == 0x0, &quot;dst must be 0x0&quot;);
 3698 
<a name="67" id="anc67"></a><span class="line-modified"> 3699     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3700     // Mark the code position where the load from the safepoint
 3701     // polling page was emitted as relocInfo::poll_type.
 3702     __ relocate(relocInfo::poll_type);
 3703     __ load_from_polling_page($poll$$Register);
 3704   %}
 3705 
 3706   // A Java static call or a runtime call.
 3707   //
 3708   // Branch-and-link relative to a trampoline.
 3709   // The trampoline loads the target address and does a long branch to there.
 3710   // In case we call java, the trampoline branches to a interpreter_stub
 3711   // which loads the inline cache and the real call target from the constant pool.
 3712   //
 3713   // This basically looks like this:
 3714   //
 3715   // &gt;&gt;&gt;&gt; consts      -+  -+
 3716   //                   |   |- offset1
 3717   // [call target1]    | &lt;-+
 3718   // [IC cache]        |- offset2
 3719   // [call target2] &lt;--+
 3720   //
 3721   // &lt;&lt;&lt;&lt; consts
 3722   // &gt;&gt;&gt;&gt; insts
 3723   //
 3724   // bl offset16               -+  -+             ??? // How many bits available?
 3725   //                            |   |
 3726   // &lt;&lt;&lt;&lt; insts                 |   |
 3727   // &gt;&gt;&gt;&gt; stubs                 |   |
 3728   //                            |   |- trampoline_stub_Reloc
 3729   // trampoline stub:           | &lt;-+
 3730   //   r2 = toc                 |
 3731   //   r2 = [r2 + offset1]      |       // Load call target1 from const section
 3732   //   mtctr r2                 |
 3733   //   bctr                     |- static_stub_Reloc
 3734   // comp_to_interp_stub:   &lt;---+
 3735   //   r1 = toc
 3736   //   ICreg = [r1 + IC_offset]         // Load IC from const section
 3737   //   r1    = [r1 + offset2]           // Load call target2 from const section
 3738   //   mtctr r1
 3739   //   bctr
 3740   //
 3741   // &lt;&lt;&lt;&lt; stubs
 3742   //
 3743   // The call instruction in the code either
 3744   // - Branches directly to a compiled method if the offset is encodable in instruction.
 3745   // - Branches to the trampoline stub if the offset to the compiled method is not encodable.
 3746   // - Branches to the compiled_to_interp stub if the target is interpreted.
 3747   //
 3748   // Further there are three relocations from the loads to the constants in
 3749   // the constant section.
 3750   //
 3751   // Usage of r1 and r2 in the stubs allows to distinguish them.
 3752   enc_class enc_java_static_call(method meth) %{
 3753     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3754 
<a name="68" id="anc68"></a><span class="line-modified"> 3755     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3756     address entry_point = (address)$meth$$method;
 3757 
 3758     if (!_method) {
 3759       // A call to a runtime wrapper, e.g. new, new_typeArray_Java, uncommon_trap.
 3760       emit_call_with_trampoline_stub(_masm, entry_point, relocInfo::runtime_call_type);
 3761     } else {
 3762       // Remember the offset not the address.
 3763       const int start_offset = __ offset();
 3764 
 3765       // The trampoline stub.
 3766       // No entry point given, use the current pc.
 3767       // Make sure branch fits into
 3768       if (entry_point == 0) entry_point = __ pc();
 3769 
 3770       // Put the entry point as a constant into the constant pool.
 3771       const address entry_point_toc_addr = __ address_constant(entry_point, RelocationHolder::none);
 3772       if (entry_point_toc_addr == NULL) {
 3773         ciEnv::current()-&gt;record_out_of_memory_failure();
 3774         return;
 3775       }
 3776       const int entry_point_toc_offset = __ offset_to_method_toc(entry_point_toc_addr);
 3777 
 3778       // Emit the trampoline stub which will be related to the branch-and-link below.
 3779       CallStubImpl::emit_trampoline_stub(_masm, entry_point_toc_offset, start_offset);
 3780       if (ciEnv::current()-&gt;failing()) { return; } // Code cache may be full.
 3781       int method_index = resolved_method_index(cbuf);
 3782       __ relocate(_optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 3783                   : static_call_Relocation::spec(method_index));
 3784 
 3785       // The real call.
 3786       // Note: At this point we do not have the address of the trampoline
 3787       // stub, and the entry point might be too far away for bl, so __ pc()
 3788       // serves as dummy and the bl will be patched later.
 3789       cbuf.set_insts_mark();
 3790       __ bl(__ pc());  // Emits a relocation.
 3791 
 3792       // The stub for call to interpreter.
 3793       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 3794       if (stub == NULL) {
 3795         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 3796         return;
 3797       }
 3798     }
 3799   %}
 3800 
 3801   // Second node of expanded dynamic call - the call.
 3802   enc_class enc_java_dynamic_call_sched(method meth) %{
 3803     // TODO: PPC port $archOpcode(ppc64Opcode_bl);
 3804 
<a name="69" id="anc69"></a><span class="line-modified"> 3805     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3806 
<a name="70" id="anc70"></a><span class="line-modified"> 3807     if (!ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size()) {</span>
 3808       // Create a call trampoline stub for the given method.
 3809       const address entry_point = !($meth$$method) ? 0 : (address)$meth$$method;
 3810       const address entry_point_const = __ address_constant(entry_point, RelocationHolder::none);
 3811       if (entry_point_const == NULL) {
 3812         ciEnv::current()-&gt;record_out_of_memory_failure();
 3813         return;
 3814       }
 3815       const int entry_point_const_toc_offset = __ offset_to_method_toc(entry_point_const);
 3816       CallStubImpl::emit_trampoline_stub(_masm, entry_point_const_toc_offset, __ offset());
 3817       if (ra_-&gt;C-&gt;env()-&gt;failing()) { return; } // Code cache may be full.
 3818 
 3819       // Build relocation at call site with ic position as data.
 3820       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_node == NULL) ||
 3821              (_load_ic_hi_node == NULL &amp;&amp; _load_ic_node != NULL),
 3822              &quot;must have one, but can&#39;t have both&quot;);
 3823       assert((_load_ic_hi_node != NULL &amp;&amp; _load_ic_hi_node-&gt;_cbuf_insts_offset != -1) ||
 3824              (_load_ic_node != NULL    &amp;&amp; _load_ic_node-&gt;_cbuf_insts_offset != -1),
 3825              &quot;must contain instruction offset&quot;);
 3826       const int virtual_call_oop_addr_offset = _load_ic_hi_node != NULL
 3827         ? _load_ic_hi_node-&gt;_cbuf_insts_offset
 3828         : _load_ic_node-&gt;_cbuf_insts_offset;
 3829       const address virtual_call_oop_addr = __ addr_at(virtual_call_oop_addr_offset);
 3830       assert(MacroAssembler::is_load_const_from_method_toc_at(virtual_call_oop_addr),
 3831              &quot;should be load from TOC&quot;);
 3832       int method_index = resolved_method_index(cbuf);
 3833       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 3834     }
 3835 
 3836     // At this point I do not have the address of the trampoline stub,
 3837     // and the entry point might be too far away for bl. Pc() serves
 3838     // as dummy and bl will be patched later.
 3839     __ bl((address) __ pc());
 3840   %}
 3841 
 3842   // postalloc expand emitter for virtual calls.
 3843   enc_class postalloc_expand_java_dynamic_call_sched(method meth, iRegLdst toc) %{
 3844 
 3845     // Create the nodes for loading the IC from the TOC.
 3846     loadConLNodesTuple loadConLNodes_IC =
 3847       loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong)Universe::non_oop_word()),
 3848                                 OptoReg::Name(R19_H_num), OptoReg::Name(R19_num));
 3849 
 3850     // Create the call node.
 3851     CallDynamicJavaDirectSchedNode *call = new CallDynamicJavaDirectSchedNode();
 3852     call-&gt;_method_handle_invoke = _method_handle_invoke;
 3853     call-&gt;_vtable_index      = _vtable_index;
 3854     call-&gt;_method            = _method;
 3855     call-&gt;_bci               = _bci;
 3856     call-&gt;_optimized_virtual = _optimized_virtual;
 3857     call-&gt;_tf                = _tf;
 3858     call-&gt;_entry_point       = _entry_point;
 3859     call-&gt;_cnt               = _cnt;
 3860     call-&gt;_argsize           = _argsize;
 3861     call-&gt;_oop_map           = _oop_map;
 3862     call-&gt;_jvms              = _jvms;
 3863     call-&gt;_jvmadj            = _jvmadj;
 3864     call-&gt;_in_rms            = _in_rms;
 3865     call-&gt;_nesting           = _nesting;
 3866     call-&gt;_override_symbolic_info = _override_symbolic_info;
 3867 
 3868     // New call needs all inputs of old call.
 3869     // Req...
 3870     for (uint i = 0; i &lt; req(); ++i) {
 3871       // The expanded node does not need toc any more.
 3872       // Add the inline cache constant here instead. This expresses the
 3873       // register of the inline cache must be live at the call.
 3874       // Else we would have to adapt JVMState by -1.
 3875       if (i == mach_constant_base_node_input()) {
 3876         call-&gt;add_req(loadConLNodes_IC._last);
 3877       } else {
 3878         call-&gt;add_req(in(i));
 3879       }
 3880     }
 3881     // ...as well as prec
 3882     for (uint i = req(); i &lt; len(); ++i) {
 3883       call-&gt;add_prec(in(i));
 3884     }
 3885 
 3886     // Remember nodes loading the inline cache into r19.
 3887     call-&gt;_load_ic_hi_node = loadConLNodes_IC._large_hi;
 3888     call-&gt;_load_ic_node    = loadConLNodes_IC._small;
 3889 
 3890     // Operands for new nodes.
 3891     call-&gt;_opnds[0] = _opnds[0];
 3892     call-&gt;_opnds[1] = _opnds[1];
 3893 
 3894     // Only the inline cache is associated with a register.
 3895     assert(Matcher::inline_cache_reg() == OptoReg::Name(R19_num), &quot;ic reg should be R19&quot;);
 3896 
 3897     // Push new nodes.
 3898     if (loadConLNodes_IC._large_hi) nodes-&gt;push(loadConLNodes_IC._large_hi);
 3899     if (loadConLNodes_IC._last)     nodes-&gt;push(loadConLNodes_IC._last);
 3900     nodes-&gt;push(call);
 3901   %}
 3902 
 3903   // Compound version of call dynamic
 3904   // Toc is only passed so that it can be used in ins_encode statement.
 3905   // In the code we have to use $constanttablebase.
 3906   enc_class enc_java_dynamic_call(method meth, iRegLdst toc) %{
 3907     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
<a name="71" id="anc71"></a><span class="line-modified"> 3908     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3909     int start_offset = __ offset();
 3910 
 3911     Register Rtoc = (ra_) ? $constanttablebase : R2_TOC;
 3912 #if 0
 3913     int vtable_index = this-&gt;_vtable_index;
 3914     if (_vtable_index &lt; 0) {
 3915       // Must be invalid_vtable_index, not nonvirtual_vtable_index.
 3916       assert(_vtable_index == Method::invalid_vtable_index, &quot;correct sentinel value&quot;);
 3917       Register ic_reg = as_Register(Matcher::inline_cache_reg_encode());
 3918 
 3919       // Virtual call relocation will point to ic load.
 3920       address virtual_call_meta_addr = __ pc();
 3921       // Load a clear inline cache.
 3922       AddressLiteral empty_ic((address) Universe::non_oop_word());
 3923       bool success = __ load_const_from_method_toc(ic_reg, empty_ic, Rtoc, /*fixed_size*/ true);
 3924       if (!success) {
 3925         ciEnv::current()-&gt;record_out_of_memory_failure();
 3926         return;
 3927       }
 3928       // CALL to fixup routine.  Fixup routine uses ScopeDesc info
 3929       // to determine who we intended to call.
 3930       __ relocate(virtual_call_Relocation::spec(virtual_call_meta_addr));
 3931       emit_call_with_trampoline_stub(_masm, (address)$meth$$method, relocInfo::none);
 3932       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3933              &quot;Fix constant in ret_addr_offset()&quot;);
 3934     } else {
 3935       assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
 3936       // Go thru the vtable. Get receiver klass. Receiver already
 3937       // checked for non-null. If we&#39;ll go thru a C2I adapter, the
 3938       // interpreter expects method in R19_method.
 3939 
 3940       __ load_klass(R11_scratch1, R3);
 3941 
 3942       int entry_offset = in_bytes(Klass::vtable_start_offset()) + _vtable_index * vtableEntry::size_in_bytes();
 3943       int v_off = entry_offset + vtableEntry::method_offset_in_bytes();
 3944       __ li(R19_method, v_off);
 3945       __ ldx(R19_method/*method oop*/, R19_method/*method offset*/, R11_scratch1/*class*/);
 3946       // NOTE: for vtable dispatches, the vtable entry will never be
 3947       // null. However it may very well end up in handle_wrong_method
 3948       // if the method is abstract for the particular class.
 3949       __ ld(R11_scratch1, in_bytes(Method::from_compiled_offset()), R19_method);
 3950       // Call target. Either compiled code or C2I adapter.
 3951       __ mtctr(R11_scratch1);
 3952       __ bctrl();
 3953       if (((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() != __ offset() - start_offset) {
 3954         tty-&gt;print(&quot; %d, %d\n&quot;, ((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset(),__ offset() - start_offset);
 3955       }
 3956       assert(((MachCallDynamicJavaNode*)this)-&gt;ret_addr_offset() == __ offset() - start_offset,
 3957              &quot;Fix constant in ret_addr_offset()&quot;);
 3958     }
 3959 #endif
 3960     Unimplemented();  // ret_addr_offset not yet fixed. Depends on compressed oops (load klass!).
 3961   %}
 3962 
 3963   // a runtime call
 3964   enc_class enc_java_to_runtime_call (method meth) %{
 3965     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 3966 
<a name="72" id="anc72"></a><span class="line-modified"> 3967     C2_MacroAssembler _masm(&amp;cbuf);</span>
 3968     const address start_pc = __ pc();
 3969 
 3970 #if defined(ABI_ELFv2)
 3971     address entry= !($meth$$method) ? NULL : (address)$meth$$method;
 3972     __ call_c(entry, relocInfo::runtime_call_type);
 3973 #else
 3974     // The function we&#39;re going to call.
 3975     FunctionDescriptor fdtemp;
 3976     const FunctionDescriptor* fd = !($meth$$method) ? &amp;fdtemp : (FunctionDescriptor*)$meth$$method;
 3977 
 3978     Register Rtoc = R12_scratch2;
 3979     // Calculate the method&#39;s TOC.
 3980     __ calculate_address_from_global_toc(Rtoc, __ method_toc());
 3981     // Put entry, env, toc into the constant pool, this needs up to 3 constant
 3982     // pool entries; call_c_using_toc will optimize the call.
 3983     bool success = __ call_c_using_toc(fd, relocInfo::runtime_call_type, Rtoc);
 3984     if (!success) {
 3985       ciEnv::current()-&gt;record_out_of_memory_failure();
 3986       return;
 3987     }
 3988 #endif
 3989 
 3990     // Check the ret_addr_offset.
 3991     assert(((MachCallRuntimeNode*)this)-&gt;ret_addr_offset() ==  __ last_calls_return_pc() - start_pc,
 3992            &quot;Fix constant in ret_addr_offset()&quot;);
 3993   %}
 3994 
 3995   // Move to ctr for leaf call.
 3996   // This enc_class is needed so that scheduler gets proper
 3997   // input mapping for latency computation.
 3998   enc_class enc_leaf_call_mtctr(iRegLsrc src) %{
 3999     // TODO: PPC port $archOpcode(ppc64Opcode_mtctr);
<a name="73" id="anc73"></a><span class="line-modified"> 4000     C2_MacroAssembler _masm(&amp;cbuf);</span>
 4001     __ mtctr($src$$Register);
 4002   %}
 4003 
 4004   // Postalloc expand emitter for runtime leaf calls.
 4005   enc_class postalloc_expand_java_to_runtime_call(method meth, iRegLdst toc) %{
 4006     loadConLNodesTuple loadConLNodes_Entry;
 4007 #if defined(ABI_ELFv2)
 4008     jlong entry_address = (jlong) this-&gt;entry_point();
 4009     assert(entry_address, &quot;need address here&quot;);
 4010     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4011                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4012 #else
 4013     // Get the struct that describes the function we are about to call.
 4014     FunctionDescriptor* fd = (FunctionDescriptor*) this-&gt;entry_point();
 4015     assert(fd, &quot;need fd here&quot;);
 4016     jlong entry_address = (jlong) fd-&gt;entry();
 4017     // new nodes
 4018     loadConLNodesTuple loadConLNodes_Env;
 4019     loadConLNodesTuple loadConLNodes_Toc;
 4020 
 4021     // Create nodes and operands for loading the entry point.
 4022     loadConLNodes_Entry = loadConLNodesTuple_create(ra_, n_toc, new immLOper(entry_address),
 4023                                                     OptoReg::Name(R12_H_num), OptoReg::Name(R12_num));
 4024 
 4025 
 4026     // Create nodes and operands for loading the env pointer.
 4027     if (fd-&gt;env() != NULL) {
 4028       loadConLNodes_Env = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;env()),
 4029                                                     OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4030     } else {
 4031       loadConLNodes_Env._large_hi = NULL;
 4032       loadConLNodes_Env._large_lo = NULL;
 4033       loadConLNodes_Env._small    = NULL;
 4034       loadConLNodes_Env._last = new loadConL16Node();
 4035       loadConLNodes_Env._last-&gt;_opnds[0] = new iRegLdstOper();
 4036       loadConLNodes_Env._last-&gt;_opnds[1] = new immL16Oper(0);
 4037       ra_-&gt;set_pair(loadConLNodes_Env._last-&gt;_idx, OptoReg::Name(R11_H_num), OptoReg::Name(R11_num));
 4038     }
 4039 
 4040     // Create nodes and operands for loading the Toc point.
 4041     loadConLNodes_Toc = loadConLNodesTuple_create(ra_, n_toc, new immLOper((jlong) fd-&gt;toc()),
 4042                                                   OptoReg::Name(R2_H_num), OptoReg::Name(R2_num));
 4043 #endif // ABI_ELFv2
 4044     // mtctr node
 4045     MachNode *mtctr = new CallLeafDirect_mtctrNode();
 4046 
 4047     assert(loadConLNodes_Entry._last != NULL, &quot;entry must exist&quot;);
 4048     mtctr-&gt;add_req(0, loadConLNodes_Entry._last);
 4049 
 4050     mtctr-&gt;_opnds[0] = new iRegLdstOper();
 4051     mtctr-&gt;_opnds[1] = new iRegLdstOper();
 4052 
 4053     // call node
 4054     MachCallLeafNode *call = new CallLeafDirectNode();
 4055 
 4056     call-&gt;_opnds[0] = _opnds[0];
 4057     call-&gt;_opnds[1] = new methodOper((intptr_t) entry_address); // May get set later.
 4058 
 4059     // Make the new call node look like the old one.
 4060     call-&gt;_name        = _name;
 4061     call-&gt;_tf          = _tf;
 4062     call-&gt;_entry_point = _entry_point;
 4063     call-&gt;_cnt         = _cnt;
 4064     call-&gt;_argsize     = _argsize;
 4065     call-&gt;_oop_map     = _oop_map;
 4066     guarantee(!_jvms, &quot;You must clone the jvms and adapt the offsets by fix_jvms().&quot;);
 4067     call-&gt;_jvms        = NULL;
 4068     call-&gt;_jvmadj      = _jvmadj;
 4069     call-&gt;_in_rms      = _in_rms;
 4070     call-&gt;_nesting     = _nesting;
 4071 
 4072 
 4073     // New call needs all inputs of old call.
 4074     // Req...
 4075     for (uint i = 0; i &lt; req(); ++i) {
 4076       if (i != mach_constant_base_node_input()) {
 4077         call-&gt;add_req(in(i));
 4078       }
 4079     }
 4080 
 4081     // These must be reqired edges, as the registers are live up to
 4082     // the call. Else the constants are handled as kills.
 4083     call-&gt;add_req(mtctr);
 4084 #if !defined(ABI_ELFv2)
 4085     call-&gt;add_req(loadConLNodes_Env._last);
 4086     call-&gt;add_req(loadConLNodes_Toc._last);
 4087 #endif
 4088 
 4089     // ...as well as prec
 4090     for (uint i = req(); i &lt; len(); ++i) {
 4091       call-&gt;add_prec(in(i));
 4092     }
 4093 
 4094     // registers
 4095     ra_-&gt;set1(mtctr-&gt;_idx, OptoReg::Name(SR_CTR_num));
 4096 
 4097     // Insert the new nodes.
 4098     if (loadConLNodes_Entry._large_hi) nodes-&gt;push(loadConLNodes_Entry._large_hi);
 4099     if (loadConLNodes_Entry._last)     nodes-&gt;push(loadConLNodes_Entry._last);
 4100 #if !defined(ABI_ELFv2)
 4101     if (loadConLNodes_Env._large_hi)   nodes-&gt;push(loadConLNodes_Env._large_hi);
 4102     if (loadConLNodes_Env._last)       nodes-&gt;push(loadConLNodes_Env._last);
 4103     if (loadConLNodes_Toc._large_hi)   nodes-&gt;push(loadConLNodes_Toc._large_hi);
 4104     if (loadConLNodes_Toc._last)       nodes-&gt;push(loadConLNodes_Toc._last);
 4105 #endif
 4106     nodes-&gt;push(mtctr);
 4107     nodes-&gt;push(call);
 4108   %}
 4109 %}
 4110 
 4111 //----------FRAME--------------------------------------------------------------
 4112 // Definition of frame structure and management information.
 4113 
 4114 frame %{
 4115   // What direction does stack grow in (assumed to be same for native &amp; Java).
 4116   stack_direction(TOWARDS_LOW);
 4117 
 4118   // These two registers define part of the calling convention between
 4119   // compiled code and the interpreter.
 4120 
 4121   // Inline Cache Register or method for I2C.
 4122   inline_cache_reg(R19); // R19_method
 4123 
 4124   // Method Oop Register when calling interpreter.
 4125   interpreter_method_oop_reg(R19); // R19_method
 4126 
 4127   // Optional: name the operand used by cisc-spilling to access
 4128   // [stack_pointer + offset].
 4129   cisc_spilling_operand_name(indOffset);
 4130 
 4131   // Number of stack slots consumed by a Monitor enter.
 4132   sync_stack_slots((frame::jit_monitor_size / VMRegImpl::stack_slot_size));
 4133 
 4134   // Compiled code&#39;s Frame Pointer.
 4135   frame_pointer(R1); // R1_SP
 4136 
 4137   // Interpreter stores its frame pointer in a register which is
 4138   // stored to the stack by I2CAdaptors. I2CAdaptors convert from
 4139   // interpreted java to compiled java.
 4140   //
 4141   // R14_state holds pointer to caller&#39;s cInterpreter.
 4142   interpreter_frame_pointer(R14); // R14_state
 4143 
 4144   stack_alignment(frame::alignment_in_bytes);
 4145 
 4146   in_preserve_stack_slots((frame::jit_in_preserve_size / VMRegImpl::stack_slot_size));
 4147 
 4148   // Number of outgoing stack slots killed above the
 4149   // out_preserve_stack_slots for calls to C. Supports the var-args
 4150   // backing area for register parms.
 4151   //
 4152   varargs_C_out_slots_killed(((frame::abi_reg_args_size - frame::jit_out_preserve_size) / VMRegImpl::stack_slot_size));
 4153 
 4154   // The after-PROLOG location of the return address. Location of
 4155   // return address specifies a type (REG or STACK) and a number
 4156   // representing the register number (i.e. - use a register name) or
 4157   // stack slot.
 4158   //
 4159   // A: Link register is stored in stack slot ...
 4160   // M:  ... but it&#39;s in the caller&#39;s frame according to PPC-64 ABI.
 4161   // J: Therefore, we make sure that the link register is also in R11_scratch1
 4162   //    at the end of the prolog.
 4163   // B: We use R20, now.
 4164   //return_addr(REG R20);
 4165 
 4166   // G: After reading the comments made by all the luminaries on their
 4167   //    failure to tell the compiler where the return address really is,
 4168   //    I hardly dare to try myself.  However, I&#39;m convinced it&#39;s in slot
 4169   //    4 what apparently works and saves us some spills.
 4170   return_addr(STACK 4);
 4171 
 4172   // This is the body of the function
 4173   //
 4174   // void Matcher::calling_convention(OptoRegPair* sig, // array of ideal regs
 4175   //                                  uint length,      // length of array
 4176   //                                  bool is_outgoing)
 4177   //
 4178   // The `sig&#39; array is to be updated. sig[j] represents the location
 4179   // of the j-th argument, either a register or a stack slot.
 4180 
 4181   // Comment taken from i486.ad:
 4182   // Body of function which returns an integer array locating
 4183   // arguments either in registers or in stack slots. Passed an array
 4184   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4185   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4186   // arguments for a CALLEE. Incoming stack arguments are
 4187   // automatically biased by the preserve_stack_slots field above.
 4188   calling_convention %{
 4189     // No difference between ingoing/outgoing. Just pass false.
 4190     SharedRuntime::java_calling_convention(sig_bt, regs, length, false);
 4191   %}
 4192 
 4193   // Comment taken from i486.ad:
 4194   // Body of function which returns an integer array locating
 4195   // arguments either in registers or in stack slots. Passed an array
 4196   // of ideal registers called &quot;sig&quot; and a &quot;length&quot; count. Stack-slot
 4197   // offsets are based on outgoing arguments, i.e. a CALLER setting up
 4198   // arguments for a CALLEE. Incoming stack arguments are
 4199   // automatically biased by the preserve_stack_slots field above.
 4200   c_calling_convention %{
 4201     // This is obviously always outgoing.
 4202     // C argument in register AND stack slot.
 4203     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 4204   %}
 4205 
 4206   // Location of native (C/C++) and interpreter return values. This
 4207   // is specified to be the same as Java. In the 32-bit VM, long
 4208   // values are actually returned from native calls in O0:O1 and
 4209   // returned to the interpreter in I0:I1. The copying to and from
 4210   // the register pairs is done by the appropriate call and epilog
 4211   // opcodes. This simplifies the register allocator.
 4212   c_return_value %{
 4213     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4214             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4215             &quot;only return normal values&quot;);
 4216     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4217     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4218     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4219     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4220   %}
 4221 
 4222   // Location of compiled Java return values.  Same as C
 4223   return_value %{
 4224     assert((ideal_reg &gt;= Op_RegI &amp;&amp; ideal_reg &lt;= Op_RegL) ||
 4225             (ideal_reg == Op_RegN &amp;&amp; CompressedOops::base() == NULL &amp;&amp; CompressedOops::shift() == 0),
 4226             &quot;only return normal values&quot;);
 4227     // enum names from opcodes.hpp:    Op_Node Op_Set Op_RegN       Op_RegI       Op_RegP       Op_RegF       Op_RegD       Op_RegL
 4228     static int typeToRegLo[Op_RegL+1] = { 0,   0,     R3_num,   R3_num,   R3_num,   F1_num,   F1_num,   R3_num };
 4229     static int typeToRegHi[Op_RegL+1] = { 0,   0,     OptoReg::Bad, R3_H_num, R3_H_num, OptoReg::Bad, F1_H_num, R3_H_num };
 4230     return OptoRegPair(typeToRegHi[ideal_reg], typeToRegLo[ideal_reg]);
 4231   %}
 4232 %}
 4233 
 4234 
 4235 //----------ATTRIBUTES---------------------------------------------------------
 4236 
 4237 //----------Operand Attributes-------------------------------------------------
 4238 op_attrib op_cost(1);          // Required cost attribute.
 4239 
 4240 //----------Instruction Attributes---------------------------------------------
 4241 
 4242 // Cost attribute. required.
 4243 ins_attrib ins_cost(DEFAULT_COST);
 4244 
 4245 // Is this instruction a non-matching short branch variant of some
 4246 // long branch? Not required.
 4247 ins_attrib ins_short_branch(0);
 4248 
 4249 ins_attrib ins_is_TrapBasedCheckNode(true);
 4250 
 4251 // Number of constants.
 4252 // This instruction uses the given number of constants
 4253 // (optional attribute).
 4254 // This is needed to determine in time whether the constant pool will
 4255 // exceed 4000 entries. Before postalloc_expand the overall number of constants
 4256 // is determined. It&#39;s also used to compute the constant pool size
 4257 // in Output().
 4258 ins_attrib ins_num_consts(0);
 4259 
 4260 // Required alignment attribute (must be a power of 2) specifies the
 4261 // alignment that some part of the instruction (not necessarily the
 4262 // start) requires. If &gt; 1, a compute_padding() function must be
 4263 // provided for the instruction.
 4264 ins_attrib ins_alignment(1);
 4265 
 4266 // Enforce/prohibit rematerializations.
 4267 // - If an instruction is attributed with &#39;ins_cannot_rematerialize(true)&#39;
 4268 //   then rematerialization of that instruction is prohibited and the
 4269 //   instruction&#39;s value will be spilled if necessary.
 4270 //   Causes that MachNode::rematerialize() returns false.
 4271 // - If an instruction is attributed with &#39;ins_should_rematerialize(true)&#39;
 4272 //   then rematerialization should be enforced and a copy of the instruction
 4273 //   should be inserted if possible; rematerialization is not guaranteed.
 4274 //   Note: this may result in rematerializations in front of every use.
 4275 //   Causes that MachNode::rematerialize() can return true.
 4276 // (optional attribute)
 4277 ins_attrib ins_cannot_rematerialize(false);
 4278 ins_attrib ins_should_rematerialize(false);
 4279 
 4280 // Instruction has variable size depending on alignment.
 4281 ins_attrib ins_variable_size_depending_on_alignment(false);
 4282 
 4283 // Instruction is a nop.
 4284 ins_attrib ins_is_nop(false);
 4285 
 4286 // Instruction is mapped to a MachIfFastLock node (instead of MachFastLock).
 4287 ins_attrib ins_use_mach_if_fast_lock_node(false);
 4288 
 4289 // Field for the toc offset of a constant.
 4290 //
 4291 // This is needed if the toc offset is not encodable as an immediate in
 4292 // the PPC load instruction. If so, the upper (hi) bits of the offset are
 4293 // added to the toc, and from this a load with immediate is performed.
 4294 // With postalloc expand, we get two nodes that require the same offset
 4295 // but which don&#39;t know about each other. The offset is only known
 4296 // when the constant is added to the constant pool during emitting.
 4297 // It is generated in the &#39;hi&#39;-node adding the upper bits, and saved
 4298 // in this node.  The &#39;lo&#39;-node has a link to the &#39;hi&#39;-node and reads
 4299 // the offset from there when it gets encoded.
 4300 ins_attrib ins_field_const_toc_offset(0);
 4301 ins_attrib ins_field_const_toc_offset_hi_node(0);
 4302 
 4303 // A field that can hold the instructions offset in the code buffer.
 4304 // Set in the nodes emitter.
 4305 ins_attrib ins_field_cbuf_insts_offset(-1);
 4306 
 4307 // Fields for referencing a call&#39;s load-IC-node.
 4308 // If the toc offset can not be encoded as an immediate in a load, we
 4309 // use two nodes.
 4310 ins_attrib ins_field_load_ic_hi_node(0);
 4311 ins_attrib ins_field_load_ic_node(0);
 4312 
 4313 //----------OPERANDS-----------------------------------------------------------
 4314 // Operand definitions must precede instruction definitions for correct
 4315 // parsing in the ADLC because operands constitute user defined types
 4316 // which are used in instruction definitions.
 4317 //
 4318 // Formats are generated automatically for constants and base registers.
 4319 
 4320 operand vecX() %{
 4321   constraint(ALLOC_IN_RC(vs_reg));
 4322   match(VecX);
 4323 
 4324   format %{ %}
 4325   interface(REG_INTER);
 4326 %}
 4327 
 4328 //----------Simple Operands----------------------------------------------------
 4329 // Immediate Operands
 4330 
 4331 // Integer Immediate: 32-bit
 4332 operand immI() %{
 4333   match(ConI);
 4334   op_cost(40);
 4335   format %{ %}
 4336   interface(CONST_INTER);
 4337 %}
 4338 
 4339 operand immI8() %{
 4340   predicate(Assembler::is_simm(n-&gt;get_int(), 8));
 4341   op_cost(0);
 4342   match(ConI);
 4343   format %{ %}
 4344   interface(CONST_INTER);
 4345 %}
 4346 
 4347 // Integer Immediate: 16-bit
 4348 operand immI16() %{
 4349   predicate(Assembler::is_simm(n-&gt;get_int(), 16));
 4350   op_cost(0);
 4351   match(ConI);
 4352   format %{ %}
 4353   interface(CONST_INTER);
 4354 %}
 4355 
 4356 // Integer Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4357 operand immIhi16() %{
 4358   predicate(((n-&gt;get_int() &amp; 0xffff0000) != 0) &amp;&amp; ((n-&gt;get_int() &amp; 0xffff) == 0));
 4359   match(ConI);
 4360   op_cost(0);
 4361   format %{ %}
 4362   interface(CONST_INTER);
 4363 %}
 4364 
 4365 operand immInegpow2() %{
 4366   predicate(is_power_of_2((jlong) (julong) (juint) (-(n-&gt;get_int()))));
 4367   match(ConI);
 4368   op_cost(0);
 4369   format %{ %}
 4370   interface(CONST_INTER);
 4371 %}
 4372 
 4373 operand immIpow2minus1() %{
 4374   predicate(is_power_of_2((((jlong) (n-&gt;get_int()))+1)));
 4375   match(ConI);
 4376   op_cost(0);
 4377   format %{ %}
 4378   interface(CONST_INTER);
 4379 %}
 4380 
 4381 operand immIpowerOf2() %{
 4382   predicate(is_power_of_2((((jlong) (julong) (juint) (n-&gt;get_int())))));
 4383   match(ConI);
 4384   op_cost(0);
 4385   format %{ %}
 4386   interface(CONST_INTER);
 4387 %}
 4388 
 4389 // Unsigned Integer Immediate: the values 0-31
 4390 operand uimmI5() %{
 4391   predicate(Assembler::is_uimm(n-&gt;get_int(), 5));
 4392   match(ConI);
 4393   op_cost(0);
 4394   format %{ %}
 4395   interface(CONST_INTER);
 4396 %}
 4397 
 4398 // Unsigned Integer Immediate: 6-bit
 4399 operand uimmI6() %{
 4400   predicate(Assembler::is_uimm(n-&gt;get_int(), 6));
 4401   match(ConI);
 4402   op_cost(0);
 4403   format %{ %}
 4404   interface(CONST_INTER);
 4405 %}
 4406 
 4407 // Unsigned Integer Immediate:  6-bit int, greater than 32
 4408 operand uimmI6_ge32() %{
 4409   predicate(Assembler::is_uimm(n-&gt;get_int(), 6) &amp;&amp; n-&gt;get_int() &gt;= 32);
 4410   match(ConI);
 4411   op_cost(0);
 4412   format %{ %}
 4413   interface(CONST_INTER);
 4414 %}
 4415 
 4416 // Unsigned Integer Immediate: 15-bit
 4417 operand uimmI15() %{
 4418   predicate(Assembler::is_uimm(n-&gt;get_int(), 15));
 4419   match(ConI);
 4420   op_cost(0);
 4421   format %{ %}
 4422   interface(CONST_INTER);
 4423 %}
 4424 
 4425 // Unsigned Integer Immediate: 16-bit
 4426 operand uimmI16() %{
 4427   predicate(Assembler::is_uimm(n-&gt;get_int(), 16));
 4428   match(ConI);
 4429   op_cost(0);
 4430   format %{ %}
 4431   interface(CONST_INTER);
 4432 %}
 4433 
 4434 // constant &#39;int 0&#39;.
 4435 operand immI_0() %{
 4436   predicate(n-&gt;get_int() == 0);
 4437   match(ConI);
 4438   op_cost(0);
 4439   format %{ %}
 4440   interface(CONST_INTER);
 4441 %}
 4442 
 4443 // constant &#39;int 1&#39;.
 4444 operand immI_1() %{
 4445   predicate(n-&gt;get_int() == 1);
 4446   match(ConI);
 4447   op_cost(0);
 4448   format %{ %}
 4449   interface(CONST_INTER);
 4450 %}
 4451 
 4452 // constant &#39;int -1&#39;.
 4453 operand immI_minus1() %{
 4454   predicate(n-&gt;get_int() == -1);
 4455   match(ConI);
 4456   op_cost(0);
 4457   format %{ %}
 4458   interface(CONST_INTER);
 4459 %}
 4460 
 4461 // int value 16.
 4462 operand immI_16() %{
 4463   predicate(n-&gt;get_int() == 16);
 4464   match(ConI);
 4465   op_cost(0);
 4466   format %{ %}
 4467   interface(CONST_INTER);
 4468 %}
 4469 
 4470 // int value 24.
 4471 operand immI_24() %{
 4472   predicate(n-&gt;get_int() == 24);
 4473   match(ConI);
 4474   op_cost(0);
 4475   format %{ %}
 4476   interface(CONST_INTER);
 4477 %}
 4478 
 4479 // Compressed oops constants
 4480 // Pointer Immediate
 4481 operand immN() %{
 4482   match(ConN);
 4483 
 4484   op_cost(10);
 4485   format %{ %}
 4486   interface(CONST_INTER);
 4487 %}
 4488 
 4489 // NULL Pointer Immediate
 4490 operand immN_0() %{
 4491   predicate(n-&gt;get_narrowcon() == 0);
 4492   match(ConN);
 4493 
 4494   op_cost(0);
 4495   format %{ %}
 4496   interface(CONST_INTER);
 4497 %}
 4498 
 4499 // Compressed klass constants
 4500 operand immNKlass() %{
 4501   match(ConNKlass);
 4502 
 4503   op_cost(0);
 4504   format %{ %}
 4505   interface(CONST_INTER);
 4506 %}
 4507 
 4508 // This operand can be used to avoid matching of an instruct
 4509 // with chain rule.
 4510 operand immNKlass_NM() %{
 4511   match(ConNKlass);
 4512   predicate(false);
 4513   op_cost(0);
 4514   format %{ %}
 4515   interface(CONST_INTER);
 4516 %}
 4517 
 4518 // Pointer Immediate: 64-bit
 4519 operand immP() %{
 4520   match(ConP);
 4521   op_cost(0);
 4522   format %{ %}
 4523   interface(CONST_INTER);
 4524 %}
 4525 
 4526 // Operand to avoid match of loadConP.
 4527 // This operand can be used to avoid matching of an instruct
 4528 // with chain rule.
 4529 operand immP_NM() %{
 4530   match(ConP);
 4531   predicate(false);
 4532   op_cost(0);
 4533   format %{ %}
 4534   interface(CONST_INTER);
 4535 %}
 4536 
 4537 // costant &#39;pointer 0&#39;.
 4538 operand immP_0() %{
 4539   predicate(n-&gt;get_ptr() == 0);
 4540   match(ConP);
 4541   op_cost(0);
 4542   format %{ %}
 4543   interface(CONST_INTER);
 4544 %}
 4545 
 4546 // pointer 0x0 or 0x1
 4547 operand immP_0or1() %{
 4548   predicate((n-&gt;get_ptr() == 0) || (n-&gt;get_ptr() == 1));
 4549   match(ConP);
 4550   op_cost(0);
 4551   format %{ %}
 4552   interface(CONST_INTER);
 4553 %}
 4554 
 4555 operand immL() %{
 4556   match(ConL);
 4557   op_cost(40);
 4558   format %{ %}
 4559   interface(CONST_INTER);
 4560 %}
 4561 
 4562 operand immLmax30() %{
 4563   predicate((n-&gt;get_long() &lt;= 30));
 4564   match(ConL);
 4565   op_cost(0);
 4566   format %{ %}
 4567   interface(CONST_INTER);
 4568 %}
 4569 
 4570 // Long Immediate: 16-bit
 4571 operand immL16() %{
 4572   predicate(Assembler::is_simm(n-&gt;get_long(), 16));
 4573   match(ConL);
 4574   op_cost(0);
 4575   format %{ %}
 4576   interface(CONST_INTER);
 4577 %}
 4578 
 4579 // Long Immediate: 16-bit, 4-aligned
 4580 operand immL16Alg4() %{
 4581   predicate(Assembler::is_simm(n-&gt;get_long(), 16) &amp;&amp; ((n-&gt;get_long() &amp; 0x3) == 0));
 4582   match(ConL);
 4583   op_cost(0);
 4584   format %{ %}
 4585   interface(CONST_INTER);
 4586 %}
 4587 
 4588 // Long Immediate: 32-bit, where lowest 16 bits are 0x0000.
 4589 operand immL32hi16() %{
 4590   predicate(Assembler::is_simm(n-&gt;get_long(), 32) &amp;&amp; ((n-&gt;get_long() &amp; 0xffffL) == 0L));
 4591   match(ConL);
 4592   op_cost(0);
 4593   format %{ %}
 4594   interface(CONST_INTER);
 4595 %}
 4596 
 4597 // Long Immediate: 32-bit
 4598 operand immL32() %{
 4599   predicate(Assembler::is_simm(n-&gt;get_long(), 32));
 4600   match(ConL);
 4601   op_cost(0);
 4602   format %{ %}
 4603   interface(CONST_INTER);
 4604 %}
 4605 
 4606 // Long Immediate: 64-bit, where highest 16 bits are not 0x0000.
 4607 operand immLhighest16() %{
 4608   predicate((n-&gt;get_long() &amp; 0xffff000000000000L) != 0L &amp;&amp; (n-&gt;get_long() &amp; 0x0000ffffffffffffL) == 0L);
 4609   match(ConL);
 4610   op_cost(0);
 4611   format %{ %}
 4612   interface(CONST_INTER);
 4613 %}
 4614 
 4615 operand immLnegpow2() %{
 4616   predicate(is_power_of_2((jlong)-(n-&gt;get_long())));
 4617   match(ConL);
 4618   op_cost(0);
 4619   format %{ %}
 4620   interface(CONST_INTER);
 4621 %}
 4622 
 4623 operand immLpow2minus1() %{
 4624   predicate(is_power_of_2((((jlong) (n-&gt;get_long()))+1)) &amp;&amp;
 4625             (n-&gt;get_long() != (jlong)0xffffffffffffffffL));
 4626   match(ConL);
 4627   op_cost(0);
 4628   format %{ %}
 4629   interface(CONST_INTER);
 4630 %}
 4631 
 4632 // constant &#39;long 0&#39;.
 4633 operand immL_0() %{
 4634   predicate(n-&gt;get_long() == 0L);
 4635   match(ConL);
 4636   op_cost(0);
 4637   format %{ %}
 4638   interface(CONST_INTER);
 4639 %}
 4640 
 4641 // constat &#39; long -1&#39;.
 4642 operand immL_minus1() %{
 4643   predicate(n-&gt;get_long() == -1L);
 4644   match(ConL);
 4645   op_cost(0);
 4646   format %{ %}
 4647   interface(CONST_INTER);
 4648 %}
 4649 
 4650 // Long Immediate: low 32-bit mask
 4651 operand immL_32bits() %{
 4652   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 4653   match(ConL);
 4654   op_cost(0);
 4655   format %{ %}
 4656   interface(CONST_INTER);
 4657 %}
 4658 
 4659 // Unsigned Long Immediate: 16-bit
 4660 operand uimmL16() %{
 4661   predicate(Assembler::is_uimm(n-&gt;get_long(), 16));
 4662   match(ConL);
 4663   op_cost(0);
 4664   format %{ %}
 4665   interface(CONST_INTER);
 4666 %}
 4667 
 4668 // Float Immediate
 4669 operand immF() %{
 4670   match(ConF);
 4671   op_cost(40);
 4672   format %{ %}
 4673   interface(CONST_INTER);
 4674 %}
 4675 
 4676 // Float Immediate: +0.0f.
 4677 operand immF_0() %{
 4678   predicate(jint_cast(n-&gt;getf()) == 0);
 4679   match(ConF);
 4680 
 4681   op_cost(0);
 4682   format %{ %}
 4683   interface(CONST_INTER);
 4684 %}
 4685 
 4686 // Double Immediate
 4687 operand immD() %{
 4688   match(ConD);
 4689   op_cost(40);
 4690   format %{ %}
 4691   interface(CONST_INTER);
 4692 %}
 4693 
 4694 // Double Immediate: +0.0d.
 4695 operand immD_0() %{
 4696   predicate(jlong_cast(n-&gt;getd()) == 0);
 4697   match(ConD);
 4698 
 4699   op_cost(0);
 4700   format %{ %}
 4701   interface(CONST_INTER);
 4702 %}
 4703 
 4704 // Integer Register Operands
 4705 // Integer Destination Register
 4706 // See definition of reg_class bits32_reg_rw.
 4707 operand iRegIdst() %{
 4708   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4709   match(RegI);
 4710   match(rscratch1RegI);
 4711   match(rscratch2RegI);
 4712   match(rarg1RegI);
 4713   match(rarg2RegI);
 4714   match(rarg3RegI);
 4715   match(rarg4RegI);
 4716   format %{ %}
 4717   interface(REG_INTER);
 4718 %}
 4719 
 4720 // Integer Source Register
 4721 // See definition of reg_class bits32_reg_ro.
 4722 operand iRegIsrc() %{
 4723   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4724   match(RegI);
 4725   match(rscratch1RegI);
 4726   match(rscratch2RegI);
 4727   match(rarg1RegI);
 4728   match(rarg2RegI);
 4729   match(rarg3RegI);
 4730   match(rarg4RegI);
 4731   format %{ %}
 4732   interface(REG_INTER);
 4733 %}
 4734 
 4735 operand rscratch1RegI() %{
 4736   constraint(ALLOC_IN_RC(rscratch1_bits32_reg));
 4737   match(iRegIdst);
 4738   format %{ %}
 4739   interface(REG_INTER);
 4740 %}
 4741 
 4742 operand rscratch2RegI() %{
 4743   constraint(ALLOC_IN_RC(rscratch2_bits32_reg));
 4744   match(iRegIdst);
 4745   format %{ %}
 4746   interface(REG_INTER);
 4747 %}
 4748 
 4749 operand rarg1RegI() %{
 4750   constraint(ALLOC_IN_RC(rarg1_bits32_reg));
 4751   match(iRegIdst);
 4752   format %{ %}
 4753   interface(REG_INTER);
 4754 %}
 4755 
 4756 operand rarg2RegI() %{
 4757   constraint(ALLOC_IN_RC(rarg2_bits32_reg));
 4758   match(iRegIdst);
 4759   format %{ %}
 4760   interface(REG_INTER);
 4761 %}
 4762 
 4763 operand rarg3RegI() %{
 4764   constraint(ALLOC_IN_RC(rarg3_bits32_reg));
 4765   match(iRegIdst);
 4766   format %{ %}
 4767   interface(REG_INTER);
 4768 %}
 4769 
 4770 operand rarg4RegI() %{
 4771   constraint(ALLOC_IN_RC(rarg4_bits32_reg));
 4772   match(iRegIdst);
 4773   format %{ %}
 4774   interface(REG_INTER);
 4775 %}
 4776 
 4777 operand rarg1RegL() %{
 4778   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4779   match(iRegLdst);
 4780   format %{ %}
 4781   interface(REG_INTER);
 4782 %}
 4783 
 4784 operand rarg2RegL() %{
 4785   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4786   match(iRegLdst);
 4787   format %{ %}
 4788   interface(REG_INTER);
 4789 %}
 4790 
 4791 operand rarg3RegL() %{
 4792   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4793   match(iRegLdst);
 4794   format %{ %}
 4795   interface(REG_INTER);
 4796 %}
 4797 
 4798 operand rarg4RegL() %{
 4799   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4800   match(iRegLdst);
 4801   format %{ %}
 4802   interface(REG_INTER);
 4803 %}
 4804 
 4805 // Pointer Destination Register
 4806 // See definition of reg_class bits64_reg_rw.
 4807 operand iRegPdst() %{
 4808   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4809   match(RegP);
 4810   match(rscratch1RegP);
 4811   match(rscratch2RegP);
 4812   match(rarg1RegP);
 4813   match(rarg2RegP);
 4814   match(rarg3RegP);
 4815   match(rarg4RegP);
 4816   format %{ %}
 4817   interface(REG_INTER);
 4818 %}
 4819 
 4820 // Pointer Destination Register
 4821 // Operand not using r11 and r12 (killed in epilog).
 4822 operand iRegPdstNoScratch() %{
 4823   constraint(ALLOC_IN_RC(bits64_reg_leaf_call));
 4824   match(RegP);
 4825   match(rarg1RegP);
 4826   match(rarg2RegP);
 4827   match(rarg3RegP);
 4828   match(rarg4RegP);
 4829   format %{ %}
 4830   interface(REG_INTER);
 4831 %}
 4832 
 4833 // Pointer Source Register
 4834 // See definition of reg_class bits64_reg_ro.
 4835 operand iRegPsrc() %{
 4836   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4837   match(RegP);
 4838   match(iRegPdst);
 4839   match(rscratch1RegP);
 4840   match(rscratch2RegP);
 4841   match(rarg1RegP);
 4842   match(rarg2RegP);
 4843   match(rarg3RegP);
 4844   match(rarg4RegP);
 4845   match(threadRegP);
 4846   format %{ %}
 4847   interface(REG_INTER);
 4848 %}
 4849 
 4850 // Thread operand.
 4851 operand threadRegP() %{
 4852   constraint(ALLOC_IN_RC(thread_bits64_reg));
 4853   match(iRegPdst);
 4854   format %{ &quot;R16&quot; %}
 4855   interface(REG_INTER);
 4856 %}
 4857 
 4858 operand rscratch1RegP() %{
 4859   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4860   match(iRegPdst);
 4861   format %{ &quot;R11&quot; %}
 4862   interface(REG_INTER);
 4863 %}
 4864 
 4865 operand rscratch2RegP() %{
 4866   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4867   match(iRegPdst);
 4868   format %{ %}
 4869   interface(REG_INTER);
 4870 %}
 4871 
 4872 operand rarg1RegP() %{
 4873   constraint(ALLOC_IN_RC(rarg1_bits64_reg));
 4874   match(iRegPdst);
 4875   format %{ %}
 4876   interface(REG_INTER);
 4877 %}
 4878 
 4879 operand rarg2RegP() %{
 4880   constraint(ALLOC_IN_RC(rarg2_bits64_reg));
 4881   match(iRegPdst);
 4882   format %{ %}
 4883   interface(REG_INTER);
 4884 %}
 4885 
 4886 operand rarg3RegP() %{
 4887   constraint(ALLOC_IN_RC(rarg3_bits64_reg));
 4888   match(iRegPdst);
 4889   format %{ %}
 4890   interface(REG_INTER);
 4891 %}
 4892 
 4893 operand rarg4RegP() %{
 4894   constraint(ALLOC_IN_RC(rarg4_bits64_reg));
 4895   match(iRegPdst);
 4896   format %{ %}
 4897   interface(REG_INTER);
 4898 %}
 4899 
 4900 operand iRegNsrc() %{
 4901   constraint(ALLOC_IN_RC(bits32_reg_ro));
 4902   match(RegN);
 4903   match(iRegNdst);
 4904 
 4905   format %{ %}
 4906   interface(REG_INTER);
 4907 %}
 4908 
 4909 operand iRegNdst() %{
 4910   constraint(ALLOC_IN_RC(bits32_reg_rw));
 4911   match(RegN);
 4912 
 4913   format %{ %}
 4914   interface(REG_INTER);
 4915 %}
 4916 
 4917 // Long Destination Register
 4918 // See definition of reg_class bits64_reg_rw.
 4919 operand iRegLdst() %{
 4920   constraint(ALLOC_IN_RC(bits64_reg_rw));
 4921   match(RegL);
 4922   match(rscratch1RegL);
 4923   match(rscratch2RegL);
 4924   format %{ %}
 4925   interface(REG_INTER);
 4926 %}
 4927 
 4928 // Long Source Register
 4929 // See definition of reg_class bits64_reg_ro.
 4930 operand iRegLsrc() %{
 4931   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4932   match(RegL);
 4933   match(iRegLdst);
 4934   match(rscratch1RegL);
 4935   match(rscratch2RegL);
 4936   format %{ %}
 4937   interface(REG_INTER);
 4938 %}
 4939 
 4940 // Special operand for ConvL2I.
 4941 operand iRegL2Isrc(iRegLsrc reg) %{
 4942   constraint(ALLOC_IN_RC(bits64_reg_ro));
 4943   match(ConvL2I reg);
 4944   format %{ &quot;ConvL2I($reg)&quot; %}
 4945   interface(REG_INTER)
 4946 %}
 4947 
 4948 operand rscratch1RegL() %{
 4949   constraint(ALLOC_IN_RC(rscratch1_bits64_reg));
 4950   match(RegL);
 4951   format %{ %}
 4952   interface(REG_INTER);
 4953 %}
 4954 
 4955 operand rscratch2RegL() %{
 4956   constraint(ALLOC_IN_RC(rscratch2_bits64_reg));
 4957   match(RegL);
 4958   format %{ %}
 4959   interface(REG_INTER);
 4960 %}
 4961 
 4962 // Condition Code Flag Registers
 4963 operand flagsReg() %{
 4964   constraint(ALLOC_IN_RC(int_flags));
 4965   match(RegFlags);
 4966   format %{ %}
 4967   interface(REG_INTER);
 4968 %}
 4969 
 4970 operand flagsRegSrc() %{
 4971   constraint(ALLOC_IN_RC(int_flags_ro));
 4972   match(RegFlags);
 4973   match(flagsReg);
 4974   match(flagsRegCR0);
 4975   format %{ %}
 4976   interface(REG_INTER);
 4977 %}
 4978 
 4979 // Condition Code Flag Register CR0
 4980 operand flagsRegCR0() %{
 4981   constraint(ALLOC_IN_RC(int_flags_CR0));
 4982   match(RegFlags);
 4983   format %{ &quot;CR0&quot; %}
 4984   interface(REG_INTER);
 4985 %}
 4986 
 4987 operand flagsRegCR1() %{
 4988   constraint(ALLOC_IN_RC(int_flags_CR1));
 4989   match(RegFlags);
 4990   format %{ &quot;CR1&quot; %}
 4991   interface(REG_INTER);
 4992 %}
 4993 
 4994 operand flagsRegCR6() %{
 4995   constraint(ALLOC_IN_RC(int_flags_CR6));
 4996   match(RegFlags);
 4997   format %{ &quot;CR6&quot; %}
 4998   interface(REG_INTER);
 4999 %}
 5000 
 5001 operand regCTR() %{
 5002   constraint(ALLOC_IN_RC(ctr_reg));
 5003   // RegFlags should work. Introducing a RegSpecial type would cause a
 5004   // lot of changes.
 5005   match(RegFlags);
 5006   format %{&quot;SR_CTR&quot; %}
 5007   interface(REG_INTER);
 5008 %}
 5009 
 5010 operand regD() %{
 5011   constraint(ALLOC_IN_RC(dbl_reg));
 5012   match(RegD);
 5013   format %{ %}
 5014   interface(REG_INTER);
 5015 %}
 5016 
 5017 operand regF() %{
 5018   constraint(ALLOC_IN_RC(flt_reg));
 5019   match(RegF);
 5020   format %{ %}
 5021   interface(REG_INTER);
 5022 %}
 5023 
 5024 // Special Registers
 5025 
 5026 // Method Register
 5027 operand inline_cache_regP(iRegPdst reg) %{
 5028   constraint(ALLOC_IN_RC(r19_bits64_reg)); // inline_cache_reg
 5029   match(reg);
 5030   format %{ %}
 5031   interface(REG_INTER);
 5032 %}
 5033 
 5034 operand compiler_method_oop_regP(iRegPdst reg) %{
 5035   constraint(ALLOC_IN_RC(rscratch1_bits64_reg)); // compiler_method_oop_reg
 5036   match(reg);
 5037   format %{ %}
 5038   interface(REG_INTER);
 5039 %}
 5040 
 5041 operand interpreter_method_oop_regP(iRegPdst reg) %{
 5042   constraint(ALLOC_IN_RC(r19_bits64_reg)); // interpreter_method_oop_reg
 5043   match(reg);
 5044   format %{ %}
 5045   interface(REG_INTER);
 5046 %}
 5047 
 5048 // Operands to remove register moves in unscaled mode.
 5049 // Match read/write registers with an EncodeP node if neither shift nor add are required.
 5050 operand iRegP2N(iRegPsrc reg) %{
 5051   predicate(false /* TODO: PPC port MatchDecodeNodes*/&amp;&amp; CompressedOops::shift() == 0);
 5052   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5053   match(EncodeP reg);
 5054   format %{ &quot;$reg&quot; %}
 5055   interface(REG_INTER)
 5056 %}
 5057 
 5058 operand iRegN2P(iRegNsrc reg) %{
 5059   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5060   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5061   match(DecodeN reg);
 5062   format %{ &quot;$reg&quot; %}
 5063   interface(REG_INTER)
 5064 %}
 5065 
 5066 operand iRegN2P_klass(iRegNsrc reg) %{
 5067   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5068   constraint(ALLOC_IN_RC(bits32_reg_ro));
 5069   match(DecodeNKlass reg);
 5070   format %{ &quot;$reg&quot; %}
 5071   interface(REG_INTER)
 5072 %}
 5073 
 5074 //----------Complex Operands---------------------------------------------------
 5075 // Indirect Memory Reference
 5076 operand indirect(iRegPsrc reg) %{
 5077   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5078   match(reg);
 5079   op_cost(100);
 5080   format %{ &quot;[$reg]&quot; %}
 5081   interface(MEMORY_INTER) %{
 5082     base($reg);
 5083     index(0x0);
 5084     scale(0x0);
 5085     disp(0x0);
 5086   %}
 5087 %}
 5088 
 5089 // Indirect with Offset
 5090 operand indOffset16(iRegPsrc reg, immL16 offset) %{
 5091   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5092   match(AddP reg offset);
 5093   op_cost(100);
 5094   format %{ &quot;[$reg + $offset]&quot; %}
 5095   interface(MEMORY_INTER) %{
 5096     base($reg);
 5097     index(0x0);
 5098     scale(0x0);
 5099     disp($offset);
 5100   %}
 5101 %}
 5102 
 5103 // Indirect with 4-aligned Offset
 5104 operand indOffset16Alg4(iRegPsrc reg, immL16Alg4 offset) %{
 5105   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5106   match(AddP reg offset);
 5107   op_cost(100);
 5108   format %{ &quot;[$reg + $offset]&quot; %}
 5109   interface(MEMORY_INTER) %{
 5110     base($reg);
 5111     index(0x0);
 5112     scale(0x0);
 5113     disp($offset);
 5114   %}
 5115 %}
 5116 
 5117 //----------Complex Operands for Compressed OOPs-------------------------------
 5118 // Compressed OOPs with narrow_oop_shift == 0.
 5119 
 5120 // Indirect Memory Reference, compressed OOP
 5121 operand indirectNarrow(iRegNsrc reg) %{
 5122   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5123   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5124   match(DecodeN reg);
 5125   op_cost(100);
 5126   format %{ &quot;[$reg]&quot; %}
 5127   interface(MEMORY_INTER) %{
 5128     base($reg);
 5129     index(0x0);
 5130     scale(0x0);
 5131     disp(0x0);
 5132   %}
 5133 %}
 5134 
 5135 operand indirectNarrow_klass(iRegNsrc reg) %{
 5136   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5137   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5138   match(DecodeNKlass reg);
 5139   op_cost(100);
 5140   format %{ &quot;[$reg]&quot; %}
 5141   interface(MEMORY_INTER) %{
 5142     base($reg);
 5143     index(0x0);
 5144     scale(0x0);
 5145     disp(0x0);
 5146   %}
 5147 %}
 5148 
 5149 // Indirect with Offset, compressed OOP
 5150 operand indOffset16Narrow(iRegNsrc reg, immL16 offset) %{
 5151   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5152   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5153   match(AddP (DecodeN reg) offset);
 5154   op_cost(100);
 5155   format %{ &quot;[$reg + $offset]&quot; %}
 5156   interface(MEMORY_INTER) %{
 5157     base($reg);
 5158     index(0x0);
 5159     scale(0x0);
 5160     disp($offset);
 5161   %}
 5162 %}
 5163 
 5164 operand indOffset16Narrow_klass(iRegNsrc reg, immL16 offset) %{
 5165   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5166   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5167   match(AddP (DecodeNKlass reg) offset);
 5168   op_cost(100);
 5169   format %{ &quot;[$reg + $offset]&quot; %}
 5170   interface(MEMORY_INTER) %{
 5171     base($reg);
 5172     index(0x0);
 5173     scale(0x0);
 5174     disp($offset);
 5175   %}
 5176 %}
 5177 
 5178 // Indirect with 4-aligned Offset, compressed OOP
 5179 operand indOffset16NarrowAlg4(iRegNsrc reg, immL16Alg4 offset) %{
 5180   predicate(false /* TODO: PPC port MatchDecodeNodes*/);
 5181   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5182   match(AddP (DecodeN reg) offset);
 5183   op_cost(100);
 5184   format %{ &quot;[$reg + $offset]&quot; %}
 5185   interface(MEMORY_INTER) %{
 5186     base($reg);
 5187     index(0x0);
 5188     scale(0x0);
 5189     disp($offset);
 5190   %}
 5191 %}
 5192 
 5193 operand indOffset16NarrowAlg4_klass(iRegNsrc reg, immL16Alg4 offset) %{
 5194   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0);
 5195   constraint(ALLOC_IN_RC(bits64_reg_ro));
 5196   match(AddP (DecodeNKlass reg) offset);
 5197   op_cost(100);
 5198   format %{ &quot;[$reg + $offset]&quot; %}
 5199   interface(MEMORY_INTER) %{
 5200     base($reg);
 5201     index(0x0);
 5202     scale(0x0);
 5203     disp($offset);
 5204   %}
 5205 %}
 5206 
 5207 //----------Special Memory Operands--------------------------------------------
 5208 // Stack Slot Operand
 5209 //
 5210 // This operand is used for loading and storing temporary values on
 5211 // the stack where a match requires a value to flow through memory.
 5212 operand stackSlotI(sRegI reg) %{
 5213   constraint(ALLOC_IN_RC(stack_slots));
 5214   op_cost(100);
 5215   //match(RegI);
 5216   format %{ &quot;[sp+$reg]&quot; %}
 5217   interface(MEMORY_INTER) %{
 5218     base(0x1);   // R1_SP
 5219     index(0x0);
 5220     scale(0x0);
 5221     disp($reg);  // Stack Offset
 5222   %}
 5223 %}
 5224 
 5225 operand stackSlotL(sRegL reg) %{
 5226   constraint(ALLOC_IN_RC(stack_slots));
 5227   op_cost(100);
 5228   //match(RegL);
 5229   format %{ &quot;[sp+$reg]&quot; %}
 5230   interface(MEMORY_INTER) %{
 5231     base(0x1);   // R1_SP
 5232     index(0x0);
 5233     scale(0x0);
 5234     disp($reg);  // Stack Offset
 5235   %}
 5236 %}
 5237 
 5238 operand stackSlotP(sRegP reg) %{
 5239   constraint(ALLOC_IN_RC(stack_slots));
 5240   op_cost(100);
 5241   //match(RegP);
 5242   format %{ &quot;[sp+$reg]&quot; %}
 5243   interface(MEMORY_INTER) %{
 5244     base(0x1);   // R1_SP
 5245     index(0x0);
 5246     scale(0x0);
 5247     disp($reg);  // Stack Offset
 5248   %}
 5249 %}
 5250 
 5251 operand stackSlotF(sRegF reg) %{
 5252   constraint(ALLOC_IN_RC(stack_slots));
 5253   op_cost(100);
 5254   //match(RegF);
 5255   format %{ &quot;[sp+$reg]&quot; %}
 5256   interface(MEMORY_INTER) %{
 5257     base(0x1);   // R1_SP
 5258     index(0x0);
 5259     scale(0x0);
 5260     disp($reg);  // Stack Offset
 5261   %}
 5262 %}
 5263 
 5264 operand stackSlotD(sRegD reg) %{
 5265   constraint(ALLOC_IN_RC(stack_slots));
 5266   op_cost(100);
 5267   //match(RegD);
 5268   format %{ &quot;[sp+$reg]&quot; %}
 5269   interface(MEMORY_INTER) %{
 5270     base(0x1);   // R1_SP
 5271     index(0x0);
 5272     scale(0x0);
 5273     disp($reg);  // Stack Offset
 5274   %}
 5275 %}
 5276 
 5277 // Operands for expressing Control Flow
 5278 // NOTE: Label is a predefined operand which should not be redefined in
 5279 //       the AD file. It is generically handled within the ADLC.
 5280 
 5281 //----------Conditional Branch Operands----------------------------------------
 5282 // Comparison Op
 5283 //
 5284 // This is the operation of the comparison, and is limited to the
 5285 // following set of codes: L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE
 5286 // (!=).
 5287 //
 5288 // Other attributes of the comparison, such as unsignedness, are specified
 5289 // by the comparison instruction that sets a condition code flags register.
 5290 // That result is represented by a flags operand whose subtype is appropriate
 5291 // to the unsignedness (etc.) of the comparison.
 5292 //
 5293 // Later, the instruction which matches both the Comparison Op (a Bool) and
 5294 // the flags (produced by the Cmp) specifies the coding of the comparison op
 5295 // by matching a specific subtype of Bool operand below.
 5296 
 5297 // When used for floating point comparisons: unordered same as less.
 5298 operand cmpOp() %{
 5299   match(Bool);
 5300   format %{ &quot;&quot; %}
 5301   interface(COND_INTER) %{
 5302                            // BO only encodes bit 4 of bcondCRbiIsX, as bits 1-3 are always &#39;100&#39;.
 5303                            //           BO          &amp;  BI
 5304     equal(0xA);            // 10 10:   bcondCRbiIs1 &amp; Condition::equal
 5305     not_equal(0x2);        // 00 10:   bcondCRbiIs0 &amp; Condition::equal
 5306     less(0x8);             // 10 00:   bcondCRbiIs1 &amp; Condition::less
 5307     greater_equal(0x0);    // 00 00:   bcondCRbiIs0 &amp; Condition::less
 5308     less_equal(0x1);       // 00 01:   bcondCRbiIs0 &amp; Condition::greater
 5309     greater(0x9);          // 10 01:   bcondCRbiIs1 &amp; Condition::greater
 5310     overflow(0xB);         // 10 11:   bcondCRbiIs1 &amp; Condition::summary_overflow
 5311     no_overflow(0x3);      // 00 11:   bcondCRbiIs0 &amp; Condition::summary_overflow
 5312   %}
 5313 %}
 5314 
 5315 //----------OPERAND CLASSES----------------------------------------------------
 5316 // Operand Classes are groups of operands that are used to simplify
 5317 // instruction definitions by not requiring the AD writer to specify
 5318 // seperate instructions for every form of operand when the
 5319 // instruction accepts multiple operand types with the same basic
 5320 // encoding and format. The classic case of this is memory operands.
 5321 // Indirect is not included since its use is limited to Compare &amp; Swap.
 5322 
 5323 opclass memory(indirect, indOffset16 /*, indIndex, tlsReference*/, indirectNarrow, indirectNarrow_klass, indOffset16Narrow, indOffset16Narrow_klass);
 5324 // Memory operand where offsets are 4-aligned. Required for ld, std.
 5325 opclass memoryAlg4(indirect, indOffset16Alg4, indirectNarrow, indOffset16NarrowAlg4, indOffset16NarrowAlg4_klass);
 5326 opclass indirectMemory(indirect, indirectNarrow);
 5327 
 5328 // Special opclass for I and ConvL2I.
 5329 opclass iRegIsrc_iRegL2Isrc(iRegIsrc, iRegL2Isrc);
 5330 
 5331 // Operand classes to match encode and decode. iRegN_P2N is only used
 5332 // for storeN. I have never seen an encode node elsewhere.
 5333 opclass iRegN_P2N(iRegNsrc, iRegP2N);
 5334 opclass iRegP_N2P(iRegPsrc, iRegN2P, iRegN2P_klass);
 5335 
 5336 //----------PIPELINE-----------------------------------------------------------
 5337 
 5338 pipeline %{
 5339 
 5340 // See J.M.Tendler et al. &quot;Power4 system microarchitecture&quot;, IBM
 5341 // J. Res. &amp; Dev., No. 1, Jan. 2002.
 5342 
 5343 //----------ATTRIBUTES---------------------------------------------------------
 5344 attributes %{
 5345 
 5346   // Power4 instructions are of fixed length.
 5347   fixed_size_instructions;
 5348 
 5349   // TODO: if `bundle&#39; means number of instructions fetched
 5350   // per cycle, this is 8. If `bundle&#39; means Power4 `group&#39;, that is
 5351   // max instructions issued per cycle, this is 5.
 5352   max_instructions_per_bundle = 8;
 5353 
 5354   // A Power4 instruction is 4 bytes long.
 5355   instruction_unit_size = 4;
 5356 
 5357   // The Power4 processor fetches 64 bytes...
 5358   instruction_fetch_unit_size = 64;
 5359 
 5360   // ...in one line
 5361   instruction_fetch_units = 1
 5362 
 5363   // Unused, list one so that array generated by adlc is not empty.
 5364   // Aix compiler chokes if _nop_count = 0.
 5365   nops(fxNop);
 5366 %}
 5367 
 5368 //----------RESOURCES----------------------------------------------------------
 5369 // Resources are the functional units available to the machine
 5370 resources(
 5371    PPC_BR,         // branch unit
 5372    PPC_CR,         // condition unit
 5373    PPC_FX1,        // integer arithmetic unit 1
 5374    PPC_FX2,        // integer arithmetic unit 2
 5375    PPC_LDST1,      // load/store unit 1
 5376    PPC_LDST2,      // load/store unit 2
 5377    PPC_FP1,        // float arithmetic unit 1
 5378    PPC_FP2,        // float arithmetic unit 2
 5379    PPC_LDST = PPC_LDST1 | PPC_LDST2,
 5380    PPC_FX = PPC_FX1 | PPC_FX2,
 5381    PPC_FP = PPC_FP1 | PPC_FP2
 5382  );
 5383 
 5384 //----------PIPELINE DESCRIPTION-----------------------------------------------
 5385 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 5386 pipe_desc(
 5387    // Power4 longest pipeline path
 5388    PPC_IF,   // instruction fetch
 5389    PPC_IC,
 5390    //PPC_BP, // branch prediction
 5391    PPC_D0,   // decode
 5392    PPC_D1,   // decode
 5393    PPC_D2,   // decode
 5394    PPC_D3,   // decode
 5395    PPC_Xfer1,
 5396    PPC_GD,   // group definition
 5397    PPC_MP,   // map
 5398    PPC_ISS,  // issue
 5399    PPC_RF,   // resource fetch
 5400    PPC_EX1,  // execute (all units)
 5401    PPC_EX2,  // execute (FP, LDST)
 5402    PPC_EX3,  // execute (FP, LDST)
 5403    PPC_EX4,  // execute (FP)
 5404    PPC_EX5,  // execute (FP)
 5405    PPC_EX6,  // execute (FP)
 5406    PPC_WB,   // write back
 5407    PPC_Xfer2,
 5408    PPC_CP
 5409  );
 5410 
 5411 //----------PIPELINE CLASSES---------------------------------------------------
 5412 // Pipeline Classes describe the stages in which input and output are
 5413 // referenced by the hardware pipeline.
 5414 
 5415 // Simple pipeline classes.
 5416 
 5417 // Default pipeline class.
 5418 pipe_class pipe_class_default() %{
 5419   single_instruction;
 5420   fixed_latency(2);
 5421 %}
 5422 
 5423 // Pipeline class for empty instructions.
 5424 pipe_class pipe_class_empty() %{
 5425   single_instruction;
 5426   fixed_latency(0);
 5427 %}
 5428 
 5429 // Pipeline class for compares.
 5430 pipe_class pipe_class_compare() %{
 5431   single_instruction;
 5432   fixed_latency(16);
 5433 %}
 5434 
 5435 // Pipeline class for traps.
 5436 pipe_class pipe_class_trap() %{
 5437   single_instruction;
 5438   fixed_latency(100);
 5439 %}
 5440 
 5441 // Pipeline class for memory operations.
 5442 pipe_class pipe_class_memory() %{
 5443   single_instruction;
 5444   fixed_latency(16);
 5445 %}
 5446 
 5447 // Pipeline class for call.
 5448 pipe_class pipe_class_call() %{
 5449   single_instruction;
 5450   fixed_latency(100);
 5451 %}
 5452 
 5453 // Define the class for the Nop node.
 5454 define %{
 5455    MachNop = pipe_class_default;
 5456 %}
 5457 
 5458 %}
 5459 
 5460 //----------INSTRUCTIONS-------------------------------------------------------
 5461 
 5462 // Naming of instructions:
 5463 //   opA_operB / opA_operB_operC:
 5464 //     Operation &#39;op&#39; with one or two source operands &#39;oper&#39;. Result
 5465 //     type is A, source operand types are B and C.
 5466 //     Iff A == B == C, B and C are left out.
 5467 //
 5468 // The instructions are ordered according to the following scheme:
 5469 //  - loads
 5470 //  - load constants
 5471 //  - prefetch
 5472 //  - store
 5473 //  - encode/decode
 5474 //  - membar
 5475 //  - conditional moves
 5476 //  - compare &amp; swap
 5477 //  - arithmetic and logic operations
 5478 //    * int: Add, Sub, Mul, Div, Mod
 5479 //    * int: lShift, arShift, urShift, rot
 5480 //    * float: Add, Sub, Mul, Div
 5481 //    * and, or, xor ...
 5482 //  - register moves: float &lt;-&gt; int, reg &lt;-&gt; stack, repl
 5483 //  - cast (high level type cast, XtoP, castPP, castII, not_null etc.
 5484 //  - conv (low level type cast requiring bit changes (sign extend etc)
 5485 //  - compares, range &amp; zero checks.
 5486 //  - branches
 5487 //  - complex operations, intrinsics, min, max, replicate
 5488 //  - lock
 5489 //  - Calls
 5490 //
 5491 // If there are similar instructions with different types they are sorted:
 5492 // int before float
 5493 // small before big
 5494 // signed before unsigned
 5495 // e.g., loadS before loadUS before loadI before loadF.
 5496 
 5497 
 5498 //----------Load/Store Instructions--------------------------------------------
 5499 
 5500 //----------Load Instructions--------------------------------------------------
 5501 
 5502 // Converts byte to int.
 5503 // As convB2I_reg, but without match rule.  The match rule of convB2I_reg
 5504 // reuses the &#39;amount&#39; operand, but adlc expects that operand specification
 5505 // and operands in match rule are equivalent.
 5506 instruct convB2I_reg_2(iRegIdst dst, iRegIsrc src) %{
 5507   effect(DEF dst, USE src);
 5508   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
 5509   size(4);
 5510   ins_encode %{
 5511     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
 5512     __ extsb($dst$$Register, $src$$Register);
 5513   %}
 5514   ins_pipe(pipe_class_default);
 5515 %}
 5516 
 5517 instruct loadUB_indirect(iRegIdst dst, indirectMemory mem) %{
 5518   // match-rule, false predicate
 5519   match(Set dst (LoadB mem));
 5520   predicate(false);
 5521 
 5522   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5523   size(4);
 5524   ins_encode( enc_lbz(dst, mem) );
 5525   ins_pipe(pipe_class_memory);
 5526 %}
 5527 
 5528 instruct loadUB_indirect_ac(iRegIdst dst, indirectMemory mem) %{
 5529   // match-rule, false predicate
 5530   match(Set dst (LoadB mem));
 5531   predicate(false);
 5532 
 5533   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5534             &quot;TWI     $dst\n\t&quot;
 5535             &quot;ISYNC&quot; %}
 5536   size(12);
 5537   ins_encode( enc_lbz_ac(dst, mem) );
 5538   ins_pipe(pipe_class_memory);
 5539 %}
 5540 
 5541 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5542 instruct loadB_indirect_Ex(iRegIdst dst, indirectMemory mem) %{
 5543   match(Set dst (LoadB mem));
 5544   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5545   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5546   expand %{
 5547     iRegIdst tmp;
 5548     loadUB_indirect(tmp, mem);
 5549     convB2I_reg_2(dst, tmp);
 5550   %}
 5551 %}
 5552 
 5553 instruct loadB_indirect_ac_Ex(iRegIdst dst, indirectMemory mem) %{
 5554   match(Set dst (LoadB mem));
 5555   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5556   expand %{
 5557     iRegIdst tmp;
 5558     loadUB_indirect_ac(tmp, mem);
 5559     convB2I_reg_2(dst, tmp);
 5560   %}
 5561 %}
 5562 
 5563 instruct loadUB_indOffset16(iRegIdst dst, indOffset16 mem) %{
 5564   // match-rule, false predicate
 5565   match(Set dst (LoadB mem));
 5566   predicate(false);
 5567 
 5568   format %{ &quot;LBZ     $dst, $mem&quot; %}
 5569   size(4);
 5570   ins_encode( enc_lbz(dst, mem) );
 5571   ins_pipe(pipe_class_memory);
 5572 %}
 5573 
 5574 instruct loadUB_indOffset16_ac(iRegIdst dst, indOffset16 mem) %{
 5575   // match-rule, false predicate
 5576   match(Set dst (LoadB mem));
 5577   predicate(false);
 5578 
 5579   format %{ &quot;LBZ     $dst, $mem\n\t&quot;
 5580             &quot;TWI     $dst\n\t&quot;
 5581             &quot;ISYNC&quot; %}
 5582   size(12);
 5583   ins_encode( enc_lbz_ac(dst, mem) );
 5584   ins_pipe(pipe_class_memory);
 5585 %}
 5586 
 5587 // Load Byte (8bit signed). LoadB = LoadUB + ConvUB2B.
 5588 instruct loadB_indOffset16_Ex(iRegIdst dst, indOffset16 mem) %{
 5589   match(Set dst (LoadB mem));
 5590   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5591   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 5592 
 5593   expand %{
 5594     iRegIdst tmp;
 5595     loadUB_indOffset16(tmp, mem);
 5596     convB2I_reg_2(dst, tmp);
 5597   %}
 5598 %}
 5599 
 5600 instruct loadB_indOffset16_ac_Ex(iRegIdst dst, indOffset16 mem) %{
 5601   match(Set dst (LoadB mem));
 5602   ins_cost(3*MEMORY_REF_COST + DEFAULT_COST);
 5603 
 5604   expand %{
 5605     iRegIdst tmp;
 5606     loadUB_indOffset16_ac(tmp, mem);
 5607     convB2I_reg_2(dst, tmp);
 5608   %}
 5609 %}
 5610 
 5611 // Load Unsigned Byte (8bit UNsigned) into an int reg.
 5612 instruct loadUB(iRegIdst dst, memory mem) %{
 5613   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5614   match(Set dst (LoadUB mem));
 5615   ins_cost(MEMORY_REF_COST);
 5616 
 5617   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int&quot; %}
 5618   size(4);
 5619   ins_encode( enc_lbz(dst, mem) );
 5620   ins_pipe(pipe_class_memory);
 5621 %}
 5622 
 5623 // Load  Unsigned Byte (8bit UNsigned) acquire.
 5624 instruct loadUB_ac(iRegIdst dst, memory mem) %{
 5625   match(Set dst (LoadUB mem));
 5626   ins_cost(3*MEMORY_REF_COST);
 5627 
 5628   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to int, acquire\n\t&quot;
 5629             &quot;TWI     $dst\n\t&quot;
 5630             &quot;ISYNC&quot; %}
 5631   size(12);
 5632   ins_encode( enc_lbz_ac(dst, mem) );
 5633   ins_pipe(pipe_class_memory);
 5634 %}
 5635 
 5636 // Load Unsigned Byte (8bit UNsigned) into a Long Register.
 5637 instruct loadUB2L(iRegLdst dst, memory mem) %{
 5638   match(Set dst (ConvI2L (LoadUB mem)));
 5639   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5640   ins_cost(MEMORY_REF_COST);
 5641 
 5642   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long&quot; %}
 5643   size(4);
 5644   ins_encode( enc_lbz(dst, mem) );
 5645   ins_pipe(pipe_class_memory);
 5646 %}
 5647 
 5648 instruct loadUB2L_ac(iRegLdst dst, memory mem) %{
 5649   match(Set dst (ConvI2L (LoadUB mem)));
 5650   ins_cost(3*MEMORY_REF_COST);
 5651 
 5652   format %{ &quot;LBZ     $dst, $mem \t// byte, zero-extend to long, acquire\n\t&quot;
 5653             &quot;TWI     $dst\n\t&quot;
 5654             &quot;ISYNC&quot; %}
 5655   size(12);
 5656   ins_encode( enc_lbz_ac(dst, mem) );
 5657   ins_pipe(pipe_class_memory);
 5658 %}
 5659 
 5660 // Load Short (16bit signed)
 5661 instruct loadS(iRegIdst dst, memory mem) %{
 5662   match(Set dst (LoadS mem));
 5663   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5664   ins_cost(MEMORY_REF_COST);
 5665 
 5666   format %{ &quot;LHA     $dst, $mem&quot; %}
 5667   size(4);
 5668   ins_encode %{
 5669     // TODO: PPC port $archOpcode(ppc64Opcode_lha);
 5670     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5671     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5672   %}
 5673   ins_pipe(pipe_class_memory);
 5674 %}
 5675 
 5676 // Load Short (16bit signed) acquire.
 5677 instruct loadS_ac(iRegIdst dst, memory mem) %{
 5678   match(Set dst (LoadS mem));
 5679   ins_cost(3*MEMORY_REF_COST);
 5680 
 5681   format %{ &quot;LHA     $dst, $mem\t acquire\n\t&quot;
 5682             &quot;TWI     $dst\n\t&quot;
 5683             &quot;ISYNC&quot; %}
 5684   size(12);
 5685   ins_encode %{
 5686     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 5687     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5688     __ lha($dst$$Register, Idisp, $mem$$base$$Register);
 5689     __ twi_0($dst$$Register);
 5690     __ isync();
 5691   %}
 5692   ins_pipe(pipe_class_memory);
 5693 %}
 5694 
 5695 // Load Char (16bit unsigned)
 5696 instruct loadUS(iRegIdst dst, memory mem) %{
 5697   match(Set dst (LoadUS mem));
 5698   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5699   ins_cost(MEMORY_REF_COST);
 5700 
 5701   format %{ &quot;LHZ     $dst, $mem&quot; %}
 5702   size(4);
 5703   ins_encode( enc_lhz(dst, mem) );
 5704   ins_pipe(pipe_class_memory);
 5705 %}
 5706 
 5707 // Load Char (16bit unsigned) acquire.
 5708 instruct loadUS_ac(iRegIdst dst, memory mem) %{
 5709   match(Set dst (LoadUS mem));
 5710   ins_cost(3*MEMORY_REF_COST);
 5711 
 5712   format %{ &quot;LHZ     $dst, $mem \t// acquire\n\t&quot;
 5713             &quot;TWI     $dst\n\t&quot;
 5714             &quot;ISYNC&quot; %}
 5715   size(12);
 5716   ins_encode( enc_lhz_ac(dst, mem) );
 5717   ins_pipe(pipe_class_memory);
 5718 %}
 5719 
 5720 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register.
 5721 instruct loadUS2L(iRegLdst dst, memory mem) %{
 5722   match(Set dst (ConvI2L (LoadUS mem)));
 5723   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(_kids[0]-&gt;_leaf));
 5724   ins_cost(MEMORY_REF_COST);
 5725 
 5726   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long&quot; %}
 5727   size(4);
 5728   ins_encode( enc_lhz(dst, mem) );
 5729   ins_pipe(pipe_class_memory);
 5730 %}
 5731 
 5732 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register acquire.
 5733 instruct loadUS2L_ac(iRegLdst dst, memory mem) %{
 5734   match(Set dst (ConvI2L (LoadUS mem)));
 5735   ins_cost(3*MEMORY_REF_COST);
 5736 
 5737   format %{ &quot;LHZ     $dst, $mem \t// short, zero-extend to long, acquire\n\t&quot;
 5738             &quot;TWI     $dst\n\t&quot;
 5739             &quot;ISYNC&quot; %}
 5740   size(12);
 5741   ins_encode( enc_lhz_ac(dst, mem) );
 5742   ins_pipe(pipe_class_memory);
 5743 %}
 5744 
 5745 // Load Integer.
 5746 instruct loadI(iRegIdst dst, memory mem) %{
 5747   match(Set dst (LoadI mem));
 5748   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5749   ins_cost(MEMORY_REF_COST);
 5750 
 5751   format %{ &quot;LWZ     $dst, $mem&quot; %}
 5752   size(4);
 5753   ins_encode( enc_lwz(dst, mem) );
 5754   ins_pipe(pipe_class_memory);
 5755 %}
 5756 
 5757 // Load Integer acquire.
 5758 instruct loadI_ac(iRegIdst dst, memory mem) %{
 5759   match(Set dst (LoadI mem));
 5760   ins_cost(3*MEMORY_REF_COST);
 5761 
 5762   format %{ &quot;LWZ     $dst, $mem \t// load acquire\n\t&quot;
 5763             &quot;TWI     $dst\n\t&quot;
 5764             &quot;ISYNC&quot; %}
 5765   size(12);
 5766   ins_encode( enc_lwz_ac(dst, mem) );
 5767   ins_pipe(pipe_class_memory);
 5768 %}
 5769 
 5770 // Match loading integer and casting it to unsigned int in
 5771 // long register.
 5772 // LoadI + ConvI2L + AndL 0xffffffff.
 5773 instruct loadUI2L(iRegLdst dst, memory mem, immL_32bits mask) %{
 5774   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 5775   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5776   ins_cost(MEMORY_REF_COST);
 5777 
 5778   format %{ &quot;LWZ     $dst, $mem \t// zero-extend to long&quot; %}
 5779   size(4);
 5780   ins_encode( enc_lwz(dst, mem) );
 5781   ins_pipe(pipe_class_memory);
 5782 %}
 5783 
 5784 // Match loading integer and casting it to long.
 5785 instruct loadI2L(iRegLdst dst, memoryAlg4 mem) %{
 5786   match(Set dst (ConvI2L (LoadI mem)));
 5787   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5788   ins_cost(MEMORY_REF_COST);
 5789 
 5790   format %{ &quot;LWA     $dst, $mem \t// loadI2L&quot; %}
 5791   size(4);
 5792   ins_encode %{
 5793     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5794     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5795     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5796   %}
 5797   ins_pipe(pipe_class_memory);
 5798 %}
 5799 
 5800 // Match loading integer and casting it to long - acquire.
 5801 instruct loadI2L_ac(iRegLdst dst, memoryAlg4 mem) %{
 5802   match(Set dst (ConvI2L (LoadI mem)));
 5803   ins_cost(3*MEMORY_REF_COST);
 5804 
 5805   format %{ &quot;LWA     $dst, $mem \t// loadI2L acquire&quot;
 5806             &quot;TWI     $dst\n\t&quot;
 5807             &quot;ISYNC&quot; %}
 5808   size(12);
 5809   ins_encode %{
 5810     // TODO: PPC port $archOpcode(ppc64Opcode_lwa);
 5811     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 5812     __ lwa($dst$$Register, Idisp, $mem$$base$$Register);
 5813     __ twi_0($dst$$Register);
 5814     __ isync();
 5815   %}
 5816   ins_pipe(pipe_class_memory);
 5817 %}
 5818 
 5819 // Load Long - aligned
 5820 instruct loadL(iRegLdst dst, memoryAlg4 mem) %{
 5821   match(Set dst (LoadL mem));
 5822   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5823   ins_cost(MEMORY_REF_COST);
 5824 
 5825   format %{ &quot;LD      $dst, $mem \t// long&quot; %}
 5826   size(4);
 5827   ins_encode( enc_ld(dst, mem) );
 5828   ins_pipe(pipe_class_memory);
 5829 %}
 5830 
 5831 // Load Long - aligned acquire.
 5832 instruct loadL_ac(iRegLdst dst, memoryAlg4 mem) %{
 5833   match(Set dst (LoadL mem));
 5834   ins_cost(3*MEMORY_REF_COST);
 5835 
 5836   format %{ &quot;LD      $dst, $mem \t// long acquire\n\t&quot;
 5837             &quot;TWI     $dst\n\t&quot;
 5838             &quot;ISYNC&quot; %}
 5839   size(12);
 5840   ins_encode( enc_ld_ac(dst, mem) );
 5841   ins_pipe(pipe_class_memory);
 5842 %}
 5843 
 5844 // Load Long - UNaligned
 5845 instruct loadL_unaligned(iRegLdst dst, memoryAlg4 mem) %{
 5846   match(Set dst (LoadL_unaligned mem));
 5847   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 5848   ins_cost(MEMORY_REF_COST);
 5849 
 5850   format %{ &quot;LD      $dst, $mem \t// unaligned long&quot; %}
 5851   size(4);
 5852   ins_encode( enc_ld(dst, mem) );
 5853   ins_pipe(pipe_class_memory);
 5854 %}
 5855 
 5856 // Load nodes for superwords
 5857 
 5858 // Load Aligned Packed Byte
 5859 instruct loadV8(iRegLdst dst, memoryAlg4 mem) %{
 5860   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
 5861   match(Set dst (LoadVector mem));
 5862   ins_cost(MEMORY_REF_COST);
 5863 
 5864   format %{ &quot;LD      $dst, $mem \t// load 8-byte Vector&quot; %}
 5865   size(4);
 5866   ins_encode( enc_ld(dst, mem) );
 5867   ins_pipe(pipe_class_memory);
 5868 %}
 5869 
 5870 // Load Aligned Packed Byte
 5871 instruct loadV16(vecX dst, indirect mem) %{
 5872   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);
 5873   match(Set dst (LoadVector mem));
 5874   ins_cost(MEMORY_REF_COST);
 5875 
 5876   format %{ &quot;LXVD2X      $dst, $mem \t// load 16-byte Vector&quot; %}
 5877   size(4);
 5878   ins_encode %{
 5879     __ lxvd2x($dst$$VectorSRegister, $mem$$Register);
 5880   %}
 5881   ins_pipe(pipe_class_default);
 5882 %}
 5883 
 5884 // Load Range, range = array length (=jint)
 5885 instruct loadRange(iRegIdst dst, memory mem) %{
 5886   match(Set dst (LoadRange mem));
 5887   ins_cost(MEMORY_REF_COST);
 5888 
 5889   format %{ &quot;LWZ     $dst, $mem \t// range&quot; %}
 5890   size(4);
 5891   ins_encode( enc_lwz(dst, mem) );
 5892   ins_pipe(pipe_class_memory);
 5893 %}
 5894 
 5895 // Load Compressed Pointer
 5896 instruct loadN(iRegNdst dst, memory mem) %{
 5897   match(Set dst (LoadN mem));
 5898   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5899   ins_cost(MEMORY_REF_COST);
 5900 
 5901   format %{ &quot;LWZ     $dst, $mem \t// load compressed ptr&quot; %}
 5902   size(4);
 5903   ins_encode( enc_lwz(dst, mem) );
 5904   ins_pipe(pipe_class_memory);
 5905 %}
 5906 
 5907 // Load Compressed Pointer acquire.
 5908 instruct loadN_ac(iRegNdst dst, memory mem) %{
 5909   match(Set dst (LoadN mem));
 5910   ins_cost(3*MEMORY_REF_COST);
 5911 
 5912   format %{ &quot;LWZ     $dst, $mem \t// load acquire compressed ptr\n\t&quot;
 5913             &quot;TWI     $dst\n\t&quot;
 5914             &quot;ISYNC&quot; %}
 5915   size(12);
 5916   ins_encode( enc_lwz_ac(dst, mem) );
 5917   ins_pipe(pipe_class_memory);
 5918 %}
 5919 
 5920 // Load Compressed Pointer and decode it if narrow_oop_shift == 0.
 5921 instruct loadN2P_unscaled(iRegPdst dst, memory mem) %{
 5922   match(Set dst (DecodeN (LoadN mem)));
 5923   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered() &amp;&amp; CompressedOops::shift() == 0);
 5924   ins_cost(MEMORY_REF_COST);
 5925 
 5926   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5927   size(4);
 5928   ins_encode( enc_lwz(dst, mem) );
 5929   ins_pipe(pipe_class_memory);
 5930 %}
 5931 
 5932 instruct loadN2P_klass_unscaled(iRegPdst dst, memory mem) %{
 5933   match(Set dst (DecodeNKlass (LoadNKlass mem)));
 5934   predicate(CompressedKlassPointers::base() == NULL &amp;&amp; CompressedKlassPointers::shift() == 0 &amp;&amp;
 5935             _kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5936   ins_cost(MEMORY_REF_COST);
 5937 
 5938   format %{ &quot;LWZ     $dst, $mem \t// DecodeN (unscaled)&quot; %}
 5939   size(4);
 5940   ins_encode( enc_lwz(dst, mem) );
 5941   ins_pipe(pipe_class_memory);
 5942 %}
 5943 
 5944 // Load Pointer
 5945 instruct loadP(iRegPdst dst, memoryAlg4 mem) %{
 5946   match(Set dst (LoadP mem));
 5947   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 5948   ins_cost(MEMORY_REF_COST);
 5949 
 5950   format %{ &quot;LD      $dst, $mem \t// ptr&quot; %}
 5951   size(4);
 5952   ins_encode( enc_ld(dst, mem) );
 5953   ins_pipe(pipe_class_memory);
 5954 %}
 5955 
 5956 // Load Pointer acquire.
 5957 instruct loadP_ac(iRegPdst dst, memoryAlg4 mem) %{
 5958   match(Set dst (LoadP mem));
 5959   ins_cost(3*MEMORY_REF_COST);
 5960 
 5961   format %{ &quot;LD      $dst, $mem \t// ptr acquire\n\t&quot;
 5962             &quot;TWI     $dst\n\t&quot;
 5963             &quot;ISYNC&quot; %}
 5964   size(12);
 5965   ins_encode( enc_ld_ac(dst, mem) );
 5966   ins_pipe(pipe_class_memory);
 5967 %}
 5968 
 5969 // LoadP + CastP2L
 5970 instruct loadP2X(iRegLdst dst, memoryAlg4 mem) %{
 5971   match(Set dst (CastP2X (LoadP mem)));
 5972   predicate(_kids[0]-&gt;_leaf-&gt;as_Load()-&gt;is_unordered());
 5973   ins_cost(MEMORY_REF_COST);
 5974 
 5975   format %{ &quot;LD      $dst, $mem \t// ptr + p2x&quot; %}
 5976   size(4);
 5977   ins_encode( enc_ld(dst, mem) );
 5978   ins_pipe(pipe_class_memory);
 5979 %}
 5980 
 5981 // Load compressed klass pointer.
 5982 instruct loadNKlass(iRegNdst dst, memory mem) %{
 5983   match(Set dst (LoadNKlass mem));
 5984   ins_cost(MEMORY_REF_COST);
 5985 
 5986   format %{ &quot;LWZ     $dst, $mem \t// compressed klass ptr&quot; %}
 5987   size(4);
 5988   ins_encode( enc_lwz(dst, mem) );
 5989   ins_pipe(pipe_class_memory);
 5990 %}
 5991 
 5992 // Load Klass Pointer
 5993 instruct loadKlass(iRegPdst dst, memoryAlg4 mem) %{
 5994   match(Set dst (LoadKlass mem));
 5995   ins_cost(MEMORY_REF_COST);
 5996 
 5997   format %{ &quot;LD      $dst, $mem \t// klass ptr&quot; %}
 5998   size(4);
 5999   ins_encode( enc_ld(dst, mem) );
 6000   ins_pipe(pipe_class_memory);
 6001 %}
 6002 
 6003 // Load Float
 6004 instruct loadF(regF dst, memory mem) %{
 6005   match(Set dst (LoadF mem));
 6006   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6007   ins_cost(MEMORY_REF_COST);
 6008 
 6009   format %{ &quot;LFS     $dst, $mem&quot; %}
 6010   size(4);
 6011   ins_encode %{
 6012     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6013     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6014     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6015   %}
 6016   ins_pipe(pipe_class_memory);
 6017 %}
 6018 
 6019 // Load Float acquire.
 6020 instruct loadF_ac(regF dst, memory mem, flagsRegCR0 cr0) %{
 6021   match(Set dst (LoadF mem));
 6022   effect(TEMP cr0);
 6023   ins_cost(3*MEMORY_REF_COST);
 6024 
 6025   format %{ &quot;LFS     $dst, $mem \t// acquire\n\t&quot;
 6026             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6027             &quot;BNE     cr0, next\n&quot;
 6028             &quot;next:\n\t&quot;
 6029             &quot;ISYNC&quot; %}
 6030   size(16);
 6031   ins_encode %{
 6032     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6033     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6034     Label next;
 6035     __ lfs($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6036     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6037     __ bne(CCR0, next);
 6038     __ bind(next);
 6039     __ isync();
 6040   %}
 6041   ins_pipe(pipe_class_memory);
 6042 %}
 6043 
 6044 // Load Double - aligned
 6045 instruct loadD(regD dst, memory mem) %{
 6046   match(Set dst (LoadD mem));
 6047   predicate(n-&gt;as_Load()-&gt;is_unordered() || followed_by_acquire(n));
 6048   ins_cost(MEMORY_REF_COST);
 6049 
 6050   format %{ &quot;LFD     $dst, $mem&quot; %}
 6051   size(4);
 6052   ins_encode( enc_lfd(dst, mem) );
 6053   ins_pipe(pipe_class_memory);
 6054 %}
 6055 
 6056 // Load Double - aligned acquire.
 6057 instruct loadD_ac(regD dst, memory mem, flagsRegCR0 cr0) %{
 6058   match(Set dst (LoadD mem));
 6059   effect(TEMP cr0);
 6060   ins_cost(3*MEMORY_REF_COST);
 6061 
 6062   format %{ &quot;LFD     $dst, $mem \t// acquire\n\t&quot;
 6063             &quot;FCMPU   cr0, $dst, $dst\n\t&quot;
 6064             &quot;BNE     cr0, next\n&quot;
 6065             &quot;next:\n\t&quot;
 6066             &quot;ISYNC&quot; %}
 6067   size(16);
 6068   ins_encode %{
 6069     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6070     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6071     Label next;
 6072     __ lfd($dst$$FloatRegister, Idisp, $mem$$base$$Register);
 6073     __ fcmpu(CCR0, $dst$$FloatRegister, $dst$$FloatRegister);
 6074     __ bne(CCR0, next);
 6075     __ bind(next);
 6076     __ isync();
 6077   %}
 6078   ins_pipe(pipe_class_memory);
 6079 %}
 6080 
 6081 // Load Double - UNaligned
 6082 instruct loadD_unaligned(regD dst, memory mem) %{
 6083   match(Set dst (LoadD_unaligned mem));
 6084   // predicate(...) // Unaligned_ac is not needed (and wouldn&#39;t make sense).
 6085   ins_cost(MEMORY_REF_COST);
 6086 
 6087   format %{ &quot;LFD     $dst, $mem&quot; %}
 6088   size(4);
 6089   ins_encode( enc_lfd(dst, mem) );
 6090   ins_pipe(pipe_class_memory);
 6091 %}
 6092 
 6093 //----------Constants--------------------------------------------------------
 6094 
 6095 // Load MachConstantTableBase: add hi offset to global toc.
 6096 // TODO: Handle hidden register r29 in bundler!
 6097 instruct loadToc_hi(iRegLdst dst) %{
 6098   effect(DEF dst);
 6099   ins_cost(DEFAULT_COST);
 6100 
 6101   format %{ &quot;ADDIS   $dst, R29, DISP.hi \t// load TOC hi&quot; %}
 6102   size(4);
 6103   ins_encode %{
 6104     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6105     __ calculate_address_from_global_toc_hi16only($dst$$Register, __ method_toc());
 6106   %}
 6107   ins_pipe(pipe_class_default);
 6108 %}
 6109 
 6110 // Load MachConstantTableBase: add lo offset to global toc.
 6111 instruct loadToc_lo(iRegLdst dst, iRegLdst src) %{
 6112   effect(DEF dst, USE src);
 6113   ins_cost(DEFAULT_COST);
 6114 
 6115   format %{ &quot;ADDI    $dst, $src, DISP.lo \t// load TOC lo&quot; %}
 6116   size(4);
 6117   ins_encode %{
 6118     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6119     __ calculate_address_from_global_toc_lo16only($dst$$Register, __ method_toc());
 6120   %}
 6121   ins_pipe(pipe_class_default);
 6122 %}
 6123 
 6124 // Load 16-bit integer constant 0xssss????
 6125 instruct loadConI16(iRegIdst dst, immI16 src) %{
 6126   match(Set dst src);
 6127 
 6128   format %{ &quot;LI      $dst, $src&quot; %}
 6129   size(4);
 6130   ins_encode %{
 6131     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6132     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6133   %}
 6134   ins_pipe(pipe_class_default);
 6135 %}
 6136 
 6137 // Load integer constant 0x????0000
 6138 instruct loadConIhi16(iRegIdst dst, immIhi16 src) %{
 6139   match(Set dst src);
 6140   ins_cost(DEFAULT_COST);
 6141 
 6142   format %{ &quot;LIS     $dst, $src.hi&quot; %}
 6143   size(4);
 6144   ins_encode %{
 6145     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6146     // Lis sign extends 16-bit src then shifts it 16 bit to the left.
 6147     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6148   %}
 6149   ins_pipe(pipe_class_default);
 6150 %}
 6151 
 6152 // Part 2 of loading 32 bit constant: hi16 is is src1 (properly shifted
 6153 // and sign extended), this adds the low 16 bits.
 6154 instruct loadConI32_lo16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 6155   // no match-rule, false predicate
 6156   effect(DEF dst, USE src1, USE src2);
 6157   predicate(false);
 6158 
 6159   format %{ &quot;ORI     $dst, $src1.hi, $src2.lo&quot; %}
 6160   size(4);
 6161   ins_encode %{
 6162     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6163     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6164   %}
 6165   ins_pipe(pipe_class_default);
 6166 %}
 6167 
 6168 instruct loadConI_Ex(iRegIdst dst, immI src) %{
 6169   match(Set dst src);
 6170   ins_cost(DEFAULT_COST*2);
 6171 
 6172   expand %{
 6173     // Would like to use $src$$constant.
 6174     immI16 srcLo %{ _opnds[1]-&gt;constant() %}
 6175     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6176     immIhi16 srcHi %{ _opnds[1]-&gt;constant() %}
 6177     iRegIdst tmpI;
 6178     loadConIhi16(tmpI, srcHi);
 6179     loadConI32_lo16(dst, tmpI, srcLo);
 6180   %}
 6181 %}
 6182 
 6183 // No constant pool entries required.
 6184 instruct loadConL16(iRegLdst dst, immL16 src) %{
 6185   match(Set dst src);
 6186 
 6187   format %{ &quot;LI      $dst, $src \t// long&quot; %}
 6188   size(4);
 6189   ins_encode %{
 6190     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6191     __ li($dst$$Register, (int)((short) ($src$$constant &amp; 0xFFFF)));
 6192   %}
 6193   ins_pipe(pipe_class_default);
 6194 %}
 6195 
 6196 // Load long constant 0xssssssss????0000
 6197 instruct loadConL32hi16(iRegLdst dst, immL32hi16 src) %{
 6198   match(Set dst src);
 6199   ins_cost(DEFAULT_COST);
 6200 
 6201   format %{ &quot;LIS     $dst, $src.hi \t// long&quot; %}
 6202   size(4);
 6203   ins_encode %{
 6204     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6205     __ lis($dst$$Register, (int)((short)(($src$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
 6206   %}
 6207   ins_pipe(pipe_class_default);
 6208 %}
 6209 
 6210 // To load a 32 bit constant: merge lower 16 bits into already loaded
 6211 // high 16 bits.
 6212 instruct loadConL32_lo16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 6213   // no match-rule, false predicate
 6214   effect(DEF dst, USE src1, USE src2);
 6215   predicate(false);
 6216 
 6217   format %{ &quot;ORI     $dst, $src1, $src2.lo&quot; %}
 6218   size(4);
 6219   ins_encode %{
 6220     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6221     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
 6222   %}
 6223   ins_pipe(pipe_class_default);
 6224 %}
 6225 
 6226 // Load 32-bit long constant
 6227 instruct loadConL32_Ex(iRegLdst dst, immL32 src) %{
 6228   match(Set dst src);
 6229   ins_cost(DEFAULT_COST*2);
 6230 
 6231   expand %{
 6232     // Would like to use $src$$constant.
 6233     immL16     srcLo %{ _opnds[1]-&gt;constant() /*&amp; 0x0000FFFFL */%}
 6234     // srcHi can be 0000 if srcLo sign-extends to a negative number.
 6235     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() /*&amp; 0xFFFF0000L */%}
 6236     iRegLdst tmpL;
 6237     loadConL32hi16(tmpL, srcHi);
 6238     loadConL32_lo16(dst, tmpL, srcLo);
 6239   %}
 6240 %}
 6241 
 6242 // Load long constant 0x????000000000000.
 6243 instruct loadConLhighest16_Ex(iRegLdst dst, immLhighest16 src) %{
 6244   match(Set dst src);
 6245   ins_cost(DEFAULT_COST);
 6246 
 6247   expand %{
 6248     immL32hi16 srcHi %{ _opnds[1]-&gt;constant() &gt;&gt; 32 /*&amp; 0xFFFF0000L */%}
 6249     immI shift32 %{ 32 %}
 6250     iRegLdst tmpL;
 6251     loadConL32hi16(tmpL, srcHi);
 6252     lshiftL_regL_immI(dst, tmpL, shift32);
 6253   %}
 6254 %}
 6255 
 6256 // Expand node for constant pool load: small offset.
 6257 instruct loadConL(iRegLdst dst, immL src, iRegLdst toc) %{
 6258   effect(DEF dst, USE src, USE toc);
 6259   ins_cost(MEMORY_REF_COST);
 6260 
 6261   ins_num_consts(1);
 6262   // Needed so that CallDynamicJavaDirect can compute the address of this
 6263   // instruction for relocation.
 6264   ins_field_cbuf_insts_offset(int);
 6265 
 6266   format %{ &quot;LD      $dst, offset, $toc \t// load long $src from TOC&quot; %}
 6267   size(4);
 6268   ins_encode( enc_load_long_constL(dst, src, toc) );
 6269   ins_pipe(pipe_class_memory);
 6270 %}
 6271 
 6272 // Expand node for constant pool load: large offset.
 6273 instruct loadConL_hi(iRegLdst dst, immL src, iRegLdst toc) %{
 6274   effect(DEF dst, USE src, USE toc);
 6275   predicate(false);
 6276 
 6277   ins_num_consts(1);
 6278   ins_field_const_toc_offset(int);
 6279   // Needed so that CallDynamicJavaDirect can compute the address of this
 6280   // instruction for relocation.
 6281   ins_field_cbuf_insts_offset(int);
 6282 
 6283   format %{ &quot;ADDIS   $dst, $toc, offset \t// load long $src from TOC (hi)&quot; %}
 6284   size(4);
 6285   ins_encode( enc_load_long_constL_hi(dst, toc, src) );
 6286   ins_pipe(pipe_class_default);
 6287 %}
 6288 
 6289 // Expand node for constant pool load: large offset.
 6290 // No constant pool entries required.
 6291 instruct loadConL_lo(iRegLdst dst, immL src, iRegLdst base) %{
 6292   effect(DEF dst, USE src, USE base);
 6293   predicate(false);
 6294 
 6295   ins_field_const_toc_offset_hi_node(loadConL_hiNode*);
 6296 
 6297   format %{ &quot;LD      $dst, offset, $base \t// load long $src from TOC (lo)&quot; %}
 6298   size(4);
 6299   ins_encode %{
 6300     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<a name="74" id="anc74"></a><span class="line-modified"> 6301     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6302     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6303   %}
 6304   ins_pipe(pipe_class_memory);
 6305 %}
 6306 
 6307 // Load long constant from constant table. Expand in case of
 6308 // offset &gt; 16 bit is needed.
 6309 // Adlc adds toc node MachConstantTableBase.
 6310 instruct loadConL_Ex(iRegLdst dst, immL src) %{
 6311   match(Set dst src);
 6312   ins_cost(MEMORY_REF_COST);
 6313 
 6314   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load long $src from table, postalloc expanded&quot; %}
 6315   // We can not inline the enc_class for the expand as that does not support constanttablebase.
 6316   postalloc_expand( postalloc_expand_load_long_constant(dst, src, constanttablebase) );
 6317 %}
 6318 
 6319 // Load NULL as compressed oop.
 6320 instruct loadConN0(iRegNdst dst, immN_0 src) %{
 6321   match(Set dst src);
 6322   ins_cost(DEFAULT_COST);
 6323 
 6324   format %{ &quot;LI      $dst, $src \t// compressed ptr&quot; %}
 6325   size(4);
 6326   ins_encode %{
 6327     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6328     __ li($dst$$Register, 0);
 6329   %}
 6330   ins_pipe(pipe_class_default);
 6331 %}
 6332 
 6333 // Load hi part of compressed oop constant.
 6334 instruct loadConN_hi(iRegNdst dst, immN src) %{
 6335   effect(DEF dst, USE src);
 6336   ins_cost(DEFAULT_COST);
 6337 
 6338   format %{ &quot;LIS     $dst, $src \t// narrow oop hi&quot; %}
 6339   size(4);
 6340   ins_encode %{
 6341     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6342     __ lis($dst$$Register, (int)(short)(($src$$constant &gt;&gt; 16) &amp; 0xffff));
 6343   %}
 6344   ins_pipe(pipe_class_default);
 6345 %}
 6346 
 6347 // Add lo part of compressed oop constant to already loaded hi part.
 6348 instruct loadConN_lo(iRegNdst dst, iRegNsrc src1, immN src2) %{
 6349   effect(DEF dst, USE src1, USE src2);
 6350   ins_cost(DEFAULT_COST);
 6351 
 6352   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow oop lo&quot; %}
 6353   size(4);
 6354   ins_encode %{
 6355     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6356     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6357     int oop_index = __ oop_recorder()-&gt;find_index((jobject)$src2$$constant);
 6358     RelocationHolder rspec = oop_Relocation::spec(oop_index);
 6359     __ relocate(rspec, 1);
 6360     __ ori($dst$$Register, $src1$$Register, $src2$$constant &amp; 0xffff);
 6361   %}
 6362   ins_pipe(pipe_class_default);
 6363 %}
 6364 
 6365 instruct rldicl(iRegLdst dst, iRegLsrc src, immI16 shift, immI16 mask_begin) %{
 6366   effect(DEF dst, USE src, USE shift, USE mask_begin);
 6367 
 6368   size(4);
 6369   ins_encode %{
 6370     __ rldicl($dst$$Register, $src$$Register, $shift$$constant, $mask_begin$$constant);
 6371   %}
 6372   ins_pipe(pipe_class_default);
 6373 %}
 6374 
 6375 // Needed to postalloc expand loadConN: ConN is loaded as ConI
 6376 // leaving the upper 32 bits with sign-extension bits.
 6377 // This clears these bits: dst = src &amp; 0xFFFFFFFF.
 6378 // TODO: Eventually call this maskN_regN_FFFFFFFF.
 6379 instruct clearMs32b(iRegNdst dst, iRegNsrc src) %{
 6380   effect(DEF dst, USE src);
 6381   predicate(false);
 6382 
 6383   format %{ &quot;MASK    $dst, $src, 0xFFFFFFFF&quot; %} // mask
 6384   size(4);
 6385   ins_encode %{
 6386     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6387     __ clrldi($dst$$Register, $src$$Register, 0x20);
 6388   %}
 6389   ins_pipe(pipe_class_default);
 6390 %}
 6391 
 6392 // Optimize DecodeN for disjoint base.
 6393 // Load base of compressed oops into a register
 6394 instruct loadBase(iRegLdst dst) %{
 6395   effect(DEF dst);
 6396 
 6397   format %{ &quot;LoadConst $dst, heapbase&quot; %}
 6398   ins_encode %{
 6399     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6400     __ load_const_optimized($dst$$Register, CompressedOops::base(), R0);
 6401   %}
 6402   ins_pipe(pipe_class_default);
 6403 %}
 6404 
 6405 // Loading ConN must be postalloc expanded so that edges between
 6406 // the nodes are safe. They may not interfere with a safepoint.
 6407 // GL TODO: This needs three instructions: better put this into the constant pool.
 6408 instruct loadConN_Ex(iRegNdst dst, immN src) %{
 6409   match(Set dst src);
 6410   ins_cost(DEFAULT_COST*2);
 6411 
 6412   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6413   postalloc_expand %{
 6414     MachNode *m1 = new loadConN_hiNode();
 6415     MachNode *m2 = new loadConN_loNode();
 6416     MachNode *m3 = new clearMs32bNode();
 6417     m1-&gt;add_req(NULL);
 6418     m2-&gt;add_req(NULL, m1);
 6419     m3-&gt;add_req(NULL, m2);
 6420     m1-&gt;_opnds[0] = op_dst;
 6421     m1-&gt;_opnds[1] = op_src;
 6422     m2-&gt;_opnds[0] = op_dst;
 6423     m2-&gt;_opnds[1] = op_dst;
 6424     m2-&gt;_opnds[2] = op_src;
 6425     m3-&gt;_opnds[0] = op_dst;
 6426     m3-&gt;_opnds[1] = op_dst;
 6427     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6428     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6429     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6430     nodes-&gt;push(m1);
 6431     nodes-&gt;push(m2);
 6432     nodes-&gt;push(m3);
 6433   %}
 6434 %}
 6435 
 6436 // We have seen a safepoint between the hi and lo parts, and this node was handled
 6437 // as an oop. Therefore this needs a match rule so that build_oop_map knows this is
 6438 // not a narrow oop.
 6439 instruct loadConNKlass_hi(iRegNdst dst, immNKlass_NM src) %{
 6440   match(Set dst src);
 6441   effect(DEF dst, USE src);
 6442   ins_cost(DEFAULT_COST);
 6443 
 6444   format %{ &quot;LIS     $dst, $src \t// narrow klass hi&quot; %}
 6445   size(4);
 6446   ins_encode %{
 6447     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 6448     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src$$constant);
 6449     __ lis($dst$$Register, (int)(short)((Csrc &gt;&gt; 16) &amp; 0xffff));
 6450   %}
 6451   ins_pipe(pipe_class_default);
 6452 %}
 6453 
 6454 // As loadConNKlass_hi this must be recognized as narrow klass, not oop!
 6455 instruct loadConNKlass_mask(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6456   match(Set dst src1);
 6457   effect(TEMP src2);
 6458   ins_cost(DEFAULT_COST);
 6459 
 6460   format %{ &quot;MASK    $dst, $src2, 0xFFFFFFFF&quot; %} // mask
 6461   size(4);
 6462   ins_encode %{
 6463     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 6464     __ clrldi($dst$$Register, $src2$$Register, 0x20);
 6465   %}
 6466   ins_pipe(pipe_class_default);
 6467 %}
 6468 
 6469 // This needs a match rule so that build_oop_map knows this is
 6470 // not a narrow oop.
 6471 instruct loadConNKlass_lo(iRegNdst dst, immNKlass_NM src1, iRegNsrc src2) %{
 6472   match(Set dst src1);
 6473   effect(TEMP src2);
 6474   ins_cost(DEFAULT_COST);
 6475 
 6476   format %{ &quot;ORI     $dst, $src1, $src2 \t// narrow klass lo&quot; %}
 6477   size(4);
 6478   ins_encode %{
 6479     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
 6480     intptr_t Csrc = CompressedKlassPointers::encode((Klass *)$src1$$constant);
 6481     assert(__ oop_recorder() != NULL, &quot;this assembler needs an OopRecorder&quot;);
 6482     int klass_index = __ oop_recorder()-&gt;find_index((Klass *)$src1$$constant);
 6483     RelocationHolder rspec = metadata_Relocation::spec(klass_index);
 6484 
 6485     __ relocate(rspec, 1);
 6486     __ ori($dst$$Register, $src2$$Register, Csrc &amp; 0xffff);
 6487   %}
 6488   ins_pipe(pipe_class_default);
 6489 %}
 6490 
 6491 // Loading ConNKlass must be postalloc expanded so that edges between
 6492 // the nodes are safe. They may not interfere with a safepoint.
 6493 instruct loadConNKlass_Ex(iRegNdst dst, immNKlass src) %{
 6494   match(Set dst src);
 6495   ins_cost(DEFAULT_COST*2);
 6496 
 6497   format %{ &quot;LoadN   $dst, $src \t// postalloc expanded&quot; %} // mask
 6498   postalloc_expand %{
 6499     // Load high bits into register. Sign extended.
 6500     MachNode *m1 = new loadConNKlass_hiNode();
 6501     m1-&gt;add_req(NULL);
 6502     m1-&gt;_opnds[0] = op_dst;
 6503     m1-&gt;_opnds[1] = op_src;
 6504     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6505     nodes-&gt;push(m1);
 6506 
 6507     MachNode *m2 = m1;
 6508     if (!Assembler::is_uimm((jlong)CompressedKlassPointers::encode((Klass *)op_src-&gt;constant()), 31)) {
 6509       // Value might be 1-extended. Mask out these bits.
 6510       m2 = new loadConNKlass_maskNode();
 6511       m2-&gt;add_req(NULL, m1);
 6512       m2-&gt;_opnds[0] = op_dst;
 6513       m2-&gt;_opnds[1] = op_src;
 6514       m2-&gt;_opnds[2] = op_dst;
 6515       ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6516       nodes-&gt;push(m2);
 6517     }
 6518 
 6519     MachNode *m3 = new loadConNKlass_loNode();
 6520     m3-&gt;add_req(NULL, m2);
 6521     m3-&gt;_opnds[0] = op_dst;
 6522     m3-&gt;_opnds[1] = op_src;
 6523     m3-&gt;_opnds[2] = op_dst;
 6524     ra_-&gt;set_pair(m3-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 6525     nodes-&gt;push(m3);
 6526   %}
 6527 %}
 6528 
 6529 // 0x1 is used in object initialization (initial object header).
 6530 // No constant pool entries required.
 6531 instruct loadConP0or1(iRegPdst dst, immP_0or1 src) %{
 6532   match(Set dst src);
 6533 
 6534   format %{ &quot;LI      $dst, $src \t// ptr&quot; %}
 6535   size(4);
 6536   ins_encode %{
 6537     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 6538     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
 6539   %}
 6540   ins_pipe(pipe_class_default);
 6541 %}
 6542 
 6543 // Expand node for constant pool load: small offset.
 6544 // The match rule is needed to generate the correct bottom_type(),
 6545 // however this node should never match. The use of predicate is not
 6546 // possible since ADLC forbids predicates for chain rules. The higher
 6547 // costs do not prevent matching in this case. For that reason the
 6548 // operand immP_NM with predicate(false) is used.
 6549 instruct loadConP(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6550   match(Set dst src);
 6551   effect(TEMP toc);
 6552 
 6553   ins_num_consts(1);
 6554 
 6555   format %{ &quot;LD      $dst, offset, $toc \t// load ptr $src from TOC&quot; %}
 6556   size(4);
 6557   ins_encode( enc_load_long_constP(dst, src, toc) );
 6558   ins_pipe(pipe_class_memory);
 6559 %}
 6560 
 6561 // Expand node for constant pool load: large offset.
 6562 instruct loadConP_hi(iRegPdst dst, immP_NM src, iRegLdst toc) %{
 6563   effect(DEF dst, USE src, USE toc);
 6564   predicate(false);
 6565 
 6566   ins_num_consts(1);
 6567   ins_field_const_toc_offset(int);
 6568 
 6569   format %{ &quot;ADDIS   $dst, $toc, offset \t// load ptr $src from TOC (hi)&quot; %}
 6570   size(4);
 6571   ins_encode( enc_load_long_constP_hi(dst, src, toc) );
 6572   ins_pipe(pipe_class_default);
 6573 %}
 6574 
 6575 // Expand node for constant pool load: large offset.
 6576 instruct loadConP_lo(iRegPdst dst, immP_NM src, iRegLdst base) %{
 6577   match(Set dst src);
 6578   effect(TEMP base);
 6579 
 6580   ins_field_const_toc_offset_hi_node(loadConP_hiNode*);
 6581 
 6582   format %{ &quot;LD      $dst, offset, $base \t// load ptr $src from TOC (lo)&quot; %}
 6583   size(4);
 6584   ins_encode %{
 6585     // TODO: PPC port $archOpcode(ppc64Opcode_ld);
<a name="75" id="anc75"></a><span class="line-modified"> 6586     int offset = ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size() ? 0 : _const_toc_offset_hi_node-&gt;_const_toc_offset;</span>
 6587     __ ld($dst$$Register, MacroAssembler::largeoffset_si16_si16_lo(offset), $base$$Register);
 6588   %}
 6589   ins_pipe(pipe_class_memory);
 6590 %}
 6591 
 6592 // Load pointer constant from constant table. Expand in case an
 6593 // offset &gt; 16 bit is needed.
 6594 // Adlc adds toc node MachConstantTableBase.
 6595 instruct loadConP_Ex(iRegPdst dst, immP src) %{
 6596   match(Set dst src);
 6597   ins_cost(MEMORY_REF_COST);
 6598 
 6599   // This rule does not use &quot;expand&quot; because then
 6600   // the result type is not known to be an Oop.  An ADLC
 6601   // enhancement will be needed to make that work - not worth it!
 6602 
 6603   // If this instruction rematerializes, it prolongs the live range
 6604   // of the toc node, causing illegal graphs.
 6605   // assert(edge_from_to(_reg_node[reg_lo],def)) fails in verify_good_schedule().
 6606   ins_cannot_rematerialize(true);
 6607 
 6608   format %{ &quot;LD    $dst, offset, $constanttablebase \t//  load ptr $src from table, postalloc expanded&quot; %}
 6609   postalloc_expand( postalloc_expand_load_ptr_constant(dst, src, constanttablebase) );
 6610 %}
 6611 
 6612 // Expand node for constant pool load: small offset.
 6613 instruct loadConF(regF dst, immF src, iRegLdst toc) %{
 6614   effect(DEF dst, USE src, USE toc);
 6615   ins_cost(MEMORY_REF_COST);
 6616 
 6617   ins_num_consts(1);
 6618 
 6619   format %{ &quot;LFS     $dst, offset, $toc \t// load float $src from TOC&quot; %}
 6620   size(4);
 6621   ins_encode %{
 6622     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
 6623     address float_address = __ float_constant($src$$constant);
 6624     if (float_address == NULL) {
 6625       ciEnv::current()-&gt;record_out_of_memory_failure();
 6626       return;
 6627     }
 6628     __ lfs($dst$$FloatRegister, __ offset_to_method_toc(float_address), $toc$$Register);
 6629   %}
 6630   ins_pipe(pipe_class_memory);
 6631 %}
 6632 
 6633 // Expand node for constant pool load: large offset.
 6634 instruct loadConFComp(regF dst, immF src, iRegLdst toc) %{
 6635   effect(DEF dst, USE src, USE toc);
 6636   ins_cost(MEMORY_REF_COST);
 6637 
 6638   ins_num_consts(1);
 6639 
 6640   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6641             &quot;LFS     $dst, offset_lo, $toc \t// load float $src from TOC (hi/lo)\n\t&quot;
 6642             &quot;ADDIS   $toc, $toc, -offset_hi&quot;%}
 6643   size(12);
 6644   ins_encode %{
 6645     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6646     FloatRegister Rdst    = $dst$$FloatRegister;
 6647     Register Rtoc         = $toc$$Register;
 6648     address float_address = __ float_constant($src$$constant);
 6649     if (float_address == NULL) {
 6650       ciEnv::current()-&gt;record_out_of_memory_failure();
 6651       return;
 6652     }
 6653     int offset            = __ offset_to_method_toc(float_address);
 6654     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6655     int lo = offset - hi * (1&lt;&lt;16);
 6656 
 6657     __ addis(Rtoc, Rtoc, hi);
 6658     __ lfs(Rdst, lo, Rtoc);
 6659     __ addis(Rtoc, Rtoc, -hi);
 6660   %}
 6661   ins_pipe(pipe_class_memory);
 6662 %}
 6663 
 6664 // Adlc adds toc node MachConstantTableBase.
 6665 instruct loadConF_Ex(regF dst, immF src) %{
 6666   match(Set dst src);
 6667   ins_cost(MEMORY_REF_COST);
 6668 
 6669   // See loadConP.
 6670   ins_cannot_rematerialize(true);
 6671 
 6672   format %{ &quot;LFS     $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6673   postalloc_expand( postalloc_expand_load_float_constant(dst, src, constanttablebase) );
 6674 %}
 6675 
 6676 // Expand node for constant pool load: small offset.
 6677 instruct loadConD(regD dst, immD src, iRegLdst toc) %{
 6678   effect(DEF dst, USE src, USE toc);
 6679   ins_cost(MEMORY_REF_COST);
 6680 
 6681   ins_num_consts(1);
 6682 
 6683   format %{ &quot;LFD     $dst, offset, $toc \t// load double $src from TOC&quot; %}
 6684   size(4);
 6685   ins_encode %{
 6686     // TODO: PPC port $archOpcode(ppc64Opcode_lfd);
 6687     address float_address = __ double_constant($src$$constant);
 6688     if (float_address == NULL) {
 6689       ciEnv::current()-&gt;record_out_of_memory_failure();
 6690       return;
 6691     }
 6692     int offset =  __ offset_to_method_toc(float_address);
 6693     __ lfd($dst$$FloatRegister, offset, $toc$$Register);
 6694   %}
 6695   ins_pipe(pipe_class_memory);
 6696 %}
 6697 
 6698 // Expand node for constant pool load: large offset.
 6699 instruct loadConDComp(regD dst, immD src, iRegLdst toc) %{
 6700   effect(DEF dst, USE src, USE toc);
 6701   ins_cost(MEMORY_REF_COST);
 6702 
 6703   ins_num_consts(1);
 6704 
 6705   format %{ &quot;ADDIS   $toc, $toc, offset_hi\n\t&quot;
 6706             &quot;LFD     $dst, offset_lo, $toc \t// load double $src from TOC (hi/lo)\n\t&quot;
 6707             &quot;ADDIS   $toc, $toc, -offset_hi&quot; %}
 6708   size(12);
 6709   ins_encode %{
 6710     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6711     FloatRegister Rdst    = $dst$$FloatRegister;
 6712     Register      Rtoc    = $toc$$Register;
 6713     address float_address = __ double_constant($src$$constant);
 6714     if (float_address == NULL) {
 6715       ciEnv::current()-&gt;record_out_of_memory_failure();
 6716       return;
 6717     }
 6718     int offset = __ offset_to_method_toc(float_address);
 6719     int hi = (offset + (1&lt;&lt;15))&gt;&gt;16;
 6720     int lo = offset - hi * (1&lt;&lt;16);
 6721 
 6722     __ addis(Rtoc, Rtoc, hi);
 6723     __ lfd(Rdst, lo, Rtoc);
 6724     __ addis(Rtoc, Rtoc, -hi);
 6725   %}
 6726   ins_pipe(pipe_class_memory);
 6727 %}
 6728 
 6729 // Adlc adds toc node MachConstantTableBase.
 6730 instruct loadConD_Ex(regD dst, immD src) %{
 6731   match(Set dst src);
 6732   ins_cost(MEMORY_REF_COST);
 6733 
 6734   // See loadConP.
 6735   ins_cannot_rematerialize(true);
 6736 
 6737   format %{ &quot;ConD    $dst, offset, $constanttablebase \t// load $src from table, postalloc expanded&quot; %}
 6738   postalloc_expand( postalloc_expand_load_double_constant(dst, src, constanttablebase) );
 6739 %}
 6740 
 6741 // Prefetch instructions.
 6742 // Must be safe to execute with invalid address (cannot fault).
 6743 
 6744 // Special prefetch versions which use the dcbz instruction.
 6745 instruct prefetch_alloc_zero(indirectMemory mem, iRegLsrc src) %{
 6746   match(PrefetchAllocation (AddP mem src));
 6747   predicate(AllocatePrefetchStyle == 3);
 6748   ins_cost(MEMORY_REF_COST);
 6749 
 6750   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many with zero&quot; %}
 6751   size(4);
 6752   ins_encode %{
 6753     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6754     __ dcbz($src$$Register, $mem$$base$$Register);
 6755   %}
 6756   ins_pipe(pipe_class_memory);
 6757 %}
 6758 
 6759 instruct prefetch_alloc_zero_no_offset(indirectMemory mem) %{
 6760   match(PrefetchAllocation mem);
 6761   predicate(AllocatePrefetchStyle == 3);
 6762   ins_cost(MEMORY_REF_COST);
 6763 
 6764   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many with zero&quot; %}
 6765   size(4);
 6766   ins_encode %{
 6767     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6768     __ dcbz($mem$$base$$Register);
 6769   %}
 6770   ins_pipe(pipe_class_memory);
 6771 %}
 6772 
 6773 instruct prefetch_alloc(indirectMemory mem, iRegLsrc src) %{
 6774   match(PrefetchAllocation (AddP mem src));
 6775   predicate(AllocatePrefetchStyle != 3);
 6776   ins_cost(MEMORY_REF_COST);
 6777 
 6778   format %{ &quot;PREFETCH $mem, 2, $src \t// Prefetch write-many&quot; %}
 6779   size(4);
 6780   ins_encode %{
 6781     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6782     __ dcbtst($src$$Register, $mem$$base$$Register);
 6783   %}
 6784   ins_pipe(pipe_class_memory);
 6785 %}
 6786 
 6787 instruct prefetch_alloc_no_offset(indirectMemory mem) %{
 6788   match(PrefetchAllocation mem);
 6789   predicate(AllocatePrefetchStyle != 3);
 6790   ins_cost(MEMORY_REF_COST);
 6791 
 6792   format %{ &quot;PREFETCH $mem, 2 \t// Prefetch write-many&quot; %}
 6793   size(4);
 6794   ins_encode %{
 6795     // TODO: PPC port $archOpcode(ppc64Opcode_dcbtst);
 6796     __ dcbtst($mem$$base$$Register);
 6797   %}
 6798   ins_pipe(pipe_class_memory);
 6799 %}
 6800 
 6801 //----------Store Instructions-------------------------------------------------
 6802 
 6803 // Store Byte
 6804 instruct storeB(memory mem, iRegIsrc src) %{
 6805   match(Set mem (StoreB mem src));
 6806   ins_cost(MEMORY_REF_COST);
 6807 
 6808   format %{ &quot;STB     $src, $mem \t// byte&quot; %}
 6809   size(4);
 6810   ins_encode %{
 6811     // TODO: PPC port $archOpcode(ppc64Opcode_stb);
 6812     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6813     __ stb($src$$Register, Idisp, $mem$$base$$Register);
 6814   %}
 6815   ins_pipe(pipe_class_memory);
 6816 %}
 6817 
 6818 // Store Char/Short
 6819 instruct storeC(memory mem, iRegIsrc src) %{
 6820   match(Set mem (StoreC mem src));
 6821   ins_cost(MEMORY_REF_COST);
 6822 
 6823   format %{ &quot;STH     $src, $mem \t// short&quot; %}
 6824   size(4);
 6825   ins_encode %{
 6826     // TODO: PPC port $archOpcode(ppc64Opcode_sth);
 6827     int Idisp = $mem$$disp + frame_slots_bias($mem$$base, ra_);
 6828     __ sth($src$$Register, Idisp, $mem$$base$$Register);
 6829   %}
 6830   ins_pipe(pipe_class_memory);
 6831 %}
 6832 
 6833 // Store Integer
 6834 instruct storeI(memory mem, iRegIsrc src) %{
 6835   match(Set mem (StoreI mem src));
 6836   ins_cost(MEMORY_REF_COST);
 6837 
 6838   format %{ &quot;STW     $src, $mem&quot; %}
 6839   size(4);
 6840   ins_encode( enc_stw(src, mem) );
 6841   ins_pipe(pipe_class_memory);
 6842 %}
 6843 
 6844 // ConvL2I + StoreI.
 6845 instruct storeI_convL2I(memory mem, iRegLsrc src) %{
 6846   match(Set mem (StoreI mem (ConvL2I src)));
 6847   ins_cost(MEMORY_REF_COST);
 6848 
 6849   format %{ &quot;STW     l2i($src), $mem&quot; %}
 6850   size(4);
 6851   ins_encode( enc_stw(src, mem) );
 6852   ins_pipe(pipe_class_memory);
 6853 %}
 6854 
 6855 // Store Long
 6856 instruct storeL(memoryAlg4 mem, iRegLsrc src) %{
 6857   match(Set mem (StoreL mem src));
 6858   ins_cost(MEMORY_REF_COST);
 6859 
 6860   format %{ &quot;STD     $src, $mem \t// long&quot; %}
 6861   size(4);
 6862   ins_encode( enc_std(src, mem) );
 6863   ins_pipe(pipe_class_memory);
 6864 %}
 6865 
 6866 // Store super word nodes.
 6867 
 6868 // Store Aligned Packed Byte long register to memory
 6869 instruct storeA8B(memoryAlg4 mem, iRegLsrc src) %{
 6870   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
 6871   match(Set mem (StoreVector mem src));
 6872   ins_cost(MEMORY_REF_COST);
 6873 
 6874   format %{ &quot;STD     $mem, $src \t// packed8B&quot; %}
 6875   size(4);
 6876   ins_encode( enc_std(src, mem) );
 6877   ins_pipe(pipe_class_memory);
 6878 %}
 6879 
 6880 // Store Packed Byte long register to memory
 6881 instruct storeV16(indirect mem, vecX src) %{
 6882   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);
 6883   match(Set mem (StoreVector mem src));
 6884   ins_cost(MEMORY_REF_COST);
 6885 
 6886   format %{ &quot;STXVD2X     $mem, $src \t// store 16-byte Vector&quot; %}
 6887   size(4);
 6888   ins_encode %{
 6889     __ stxvd2x($src$$VectorSRegister, $mem$$Register);
 6890   %}
 6891   ins_pipe(pipe_class_default);
 6892 %}
 6893 
 6894 // Store Compressed Oop
 6895 instruct storeN(memory dst, iRegN_P2N src) %{
 6896   match(Set dst (StoreN dst src));
 6897   ins_cost(MEMORY_REF_COST);
 6898 
 6899   format %{ &quot;STW     $src, $dst \t// compressed oop&quot; %}
 6900   size(4);
 6901   ins_encode( enc_stw(src, dst) );
 6902   ins_pipe(pipe_class_memory);
 6903 %}
 6904 
 6905 // Store Compressed KLass
 6906 instruct storeNKlass(memory dst, iRegN_P2N src) %{
 6907   match(Set dst (StoreNKlass dst src));
 6908   ins_cost(MEMORY_REF_COST);
 6909 
 6910   format %{ &quot;STW     $src, $dst \t// compressed klass&quot; %}
 6911   size(4);
 6912   ins_encode( enc_stw(src, dst) );
 6913   ins_pipe(pipe_class_memory);
 6914 %}
 6915 
 6916 // Store Pointer
 6917 instruct storeP(memoryAlg4 dst, iRegPsrc src) %{
 6918   match(Set dst (StoreP dst src));
 6919   ins_cost(MEMORY_REF_COST);
 6920 
 6921   format %{ &quot;STD     $src, $dst \t// ptr&quot; %}
 6922   size(4);
 6923   ins_encode( enc_std(src, dst) );
 6924   ins_pipe(pipe_class_memory);
 6925 %}
 6926 
 6927 // Store Float
 6928 instruct storeF(memory mem, regF src) %{
 6929   match(Set mem (StoreF mem src));
 6930   ins_cost(MEMORY_REF_COST);
 6931 
 6932   format %{ &quot;STFS    $src, $mem&quot; %}
 6933   size(4);
 6934   ins_encode( enc_stfs(src, mem) );
 6935   ins_pipe(pipe_class_memory);
 6936 %}
 6937 
 6938 // Store Double
 6939 instruct storeD(memory mem, regD src) %{
 6940   match(Set mem (StoreD mem src));
 6941   ins_cost(MEMORY_REF_COST);
 6942 
 6943   format %{ &quot;STFD    $src, $mem&quot; %}
 6944   size(4);
 6945   ins_encode( enc_stfd(src, mem) );
 6946   ins_pipe(pipe_class_memory);
 6947 %}
 6948 
 6949 //----------Store Instructions With Zeros--------------------------------------
 6950 
 6951 // Card-mark for CMS garbage collection.
 6952 // This cardmark does an optimization so that it must not always
 6953 // do a releasing store. For this, it gets the address of
 6954 // CMSCollectorCardTableBarrierSetBSExt::_requires_release as input.
 6955 // (Using releaseFieldAddr in the match rule is a hack.)
 6956 instruct storeCM_CMS(memory mem, iRegLdst releaseFieldAddr, flagsReg crx) %{
 6957   match(Set mem (StoreCM mem releaseFieldAddr));
 6958   effect(TEMP crx);
 6959   predicate(false);
 6960   ins_cost(MEMORY_REF_COST);
 6961 
 6962   // See loadConP.
 6963   ins_cannot_rematerialize(true);
 6964 
 6965   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte (must be 0!), checking requires_release in [$releaseFieldAddr]&quot; %}
 6966   ins_encode( enc_cms_card_mark(mem, releaseFieldAddr, crx) );
 6967   ins_pipe(pipe_class_memory);
 6968 %}
 6969 
 6970 instruct storeCM_G1(memory mem, immI_0 zero) %{
 6971   match(Set mem (StoreCM mem zero));
 6972   predicate(UseG1GC);
 6973   ins_cost(MEMORY_REF_COST);
 6974 
 6975   ins_cannot_rematerialize(true);
 6976 
 6977   format %{ &quot;STB     #0, $mem \t// CMS card-mark byte store (G1)&quot; %}
 6978   size(8);
 6979   ins_encode %{
 6980     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 6981     __ li(R0, 0);
 6982     //__ release(); // G1: oops are allowed to get visible after dirty marking
 6983     guarantee($mem$$base$$Register != R1_SP, &quot;use frame_slots_bias&quot;);
 6984     __ stb(R0, $mem$$disp, $mem$$base$$Register);
 6985   %}
 6986   ins_pipe(pipe_class_memory);
 6987 %}
 6988 
 6989 // Convert oop pointer into compressed form.
 6990 
 6991 // Nodes for postalloc expand.
 6992 
 6993 // Shift node for expand.
 6994 instruct encodeP_shift(iRegNdst dst, iRegNsrc src) %{
 6995   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 6996   match(Set dst (EncodeP src));
 6997   predicate(false);
 6998 
 6999   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7000   size(4);
 7001   ins_encode %{
 7002     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7003     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7004   %}
 7005   ins_pipe(pipe_class_default);
 7006 %}
 7007 
 7008 // Add node for expand.
 7009 instruct encodeP_sub(iRegPdst dst, iRegPdst src) %{
 7010   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7011   match(Set dst (EncodeP src));
 7012   predicate(false);
 7013 
 7014   format %{ &quot;SUB     $dst, $src, oop_base \t// encode&quot; %}
 7015   ins_encode %{
 7016     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7017     __ sub_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7018   %}
 7019   ins_pipe(pipe_class_default);
 7020 %}
 7021 
 7022 // Conditional sub base.
 7023 instruct cond_sub_base(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7024   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7025   match(Set dst (EncodeP (Binary crx src1)));
 7026   predicate(false);
 7027 
 7028   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7029             &quot;SUB     $dst, $src1, heapbase \t// encode: subtract base if != NULL\n&quot;
 7030             &quot;done:&quot; %}
 7031   ins_encode %{
 7032     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7033     Label done;
 7034     __ beq($crx$$CondRegister, done);
 7035     __ sub_const_optimized($dst$$Register, $src1$$Register, CompressedOops::base(), R0);
 7036     __ bind(done);
 7037   %}
 7038   ins_pipe(pipe_class_default);
 7039 %}
 7040 
 7041 // Power 7 can use isel instruction
 7042 instruct cond_set_0_oop(iRegNdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7043   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7044   match(Set dst (EncodeP (Binary crx src1)));
 7045   predicate(false);
 7046 
 7047   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// encode: preserve 0&quot; %}
 7048   size(4);
 7049   ins_encode %{
 7050     // This is a Power7 instruction for which no machine description exists.
 7051     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7052     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7053   %}
 7054   ins_pipe(pipe_class_default);
 7055 %}
 7056 
 7057 // Disjoint narrow oop base.
 7058 instruct encodeP_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7059   match(Set dst (EncodeP src));
 7060   predicate(CompressedOops::base_disjoint());
 7061 
 7062   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7063   size(4);
 7064   ins_encode %{
 7065     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7066     __ rldicl($dst$$Register, $src$$Register, 64-CompressedOops::shift(), 32);
 7067   %}
 7068   ins_pipe(pipe_class_default);
 7069 %}
 7070 
 7071 // shift != 0, base != 0
 7072 instruct encodeP_Ex(iRegNdst dst, flagsReg crx, iRegPsrc src) %{
 7073   match(Set dst (EncodeP src));
 7074   effect(TEMP crx);
 7075   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7076             CompressedOops::shift() != 0 &amp;&amp;
 7077             CompressedOops::base_overlaps());
 7078 
 7079   format %{ &quot;EncodeP $dst, $crx, $src \t// postalloc expanded&quot; %}
 7080   postalloc_expand( postalloc_expand_encode_oop(dst, src, crx));
 7081 %}
 7082 
 7083 // shift != 0, base != 0
 7084 instruct encodeP_not_null_Ex(iRegNdst dst, iRegPsrc src) %{
 7085   match(Set dst (EncodeP src));
 7086   predicate(n-&gt;bottom_type()-&gt;make_ptr()-&gt;ptr() == TypePtr::NotNull &amp;&amp;
 7087             CompressedOops::shift() != 0 &amp;&amp;
 7088             CompressedOops::base_overlaps());
 7089 
 7090   format %{ &quot;EncodeP $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7091   postalloc_expand( postalloc_expand_encode_oop_not_null(dst, src) );
 7092 %}
 7093 
 7094 // shift != 0, base == 0
 7095 // TODO: This is the same as encodeP_shift. Merge!
 7096 instruct encodeP_not_null_base_null(iRegNdst dst, iRegPsrc src) %{
 7097   match(Set dst (EncodeP src));
 7098   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7099             CompressedOops::base() ==0);
 7100 
 7101   format %{ &quot;SRDI    $dst, $src, #3 \t// encodeP, $src != NULL&quot; %}
 7102   size(4);
 7103   ins_encode %{
 7104     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7105     __ srdi($dst$$Register, $src$$Register, CompressedOops::shift() &amp; 0x3f);
 7106   %}
 7107   ins_pipe(pipe_class_default);
 7108 %}
 7109 
 7110 // Compressed OOPs with narrow_oop_shift == 0.
 7111 // shift == 0, base == 0
 7112 instruct encodeP_narrow_oop_shift_0(iRegNdst dst, iRegPsrc src) %{
 7113   match(Set dst (EncodeP src));
 7114   predicate(CompressedOops::shift() == 0);
 7115 
 7116   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Narrow&quot; %}
 7117   // variable size, 0 or 4.
 7118   ins_encode %{
 7119     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7120     __ mr_if_needed($dst$$Register, $src$$Register);
 7121   %}
 7122   ins_pipe(pipe_class_default);
 7123 %}
 7124 
 7125 // Decode nodes.
 7126 
 7127 // Shift node for expand.
 7128 instruct decodeN_shift(iRegPdst dst, iRegPsrc src) %{
 7129   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7130   match(Set dst (DecodeN src));
 7131   predicate(false);
 7132 
 7133   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN&quot; %}
 7134   size(4);
 7135   ins_encode %{
 7136     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7137     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7138   %}
 7139   ins_pipe(pipe_class_default);
 7140 %}
 7141 
 7142 // Add node for expand.
 7143 instruct decodeN_add(iRegPdst dst, iRegPdst src) %{
 7144   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7145   match(Set dst (DecodeN src));
 7146   predicate(false);
 7147 
 7148   format %{ &quot;ADD     $dst, $src, heapbase \t// DecodeN, add oop base&quot; %}
 7149   ins_encode %{
 7150     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7151     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7152   %}
 7153   ins_pipe(pipe_class_default);
 7154 %}
 7155 
 7156 // conditianal add base for expand
 7157 instruct cond_add_base(iRegPdst dst, flagsRegSrc crx, iRegPsrc src) %{
 7158   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7159   // NOTICE that the rule is nonsense - we just have to make sure that:
 7160   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7161   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7162   match(Set dst (DecodeN (Binary crx src)));
 7163   predicate(false);
 7164 
 7165   format %{ &quot;BEQ     $crx, done\n\t&quot;
 7166             &quot;ADD     $dst, $src, heapbase \t// DecodeN: add oop base if $src != NULL\n&quot;
 7167             &quot;done:&quot; %}
 7168   ins_encode %{
 7169     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7170     Label done;
 7171     __ beq($crx$$CondRegister, done);
 7172     __ add_const_optimized($dst$$Register, $src$$Register, CompressedOops::base(), R0);
 7173     __ bind(done);
 7174   %}
 7175   ins_pipe(pipe_class_default);
 7176 %}
 7177 
 7178 instruct cond_set_0_ptr(iRegPdst dst, flagsRegSrc crx, iRegPsrc src1) %{
 7179   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7180   // NOTICE that the rule is nonsense - we just have to make sure that:
 7181   //  - _matrule-&gt;_rChild-&gt;_opType == &quot;DecodeN&quot; (see InstructForm::captures_bottom_type() in formssel.cpp)
 7182   //  - we have to match &#39;crx&#39; to avoid an &quot;illegal USE of non-input: flagsReg crx&quot; error in ADLC.
 7183   match(Set dst (DecodeN (Binary crx src1)));
 7184   predicate(false);
 7185 
 7186   format %{ &quot;CMOVE   $dst, $crx eq, 0, $src1 \t// decode: preserve 0&quot; %}
 7187   size(4);
 7188   ins_encode %{
 7189     // This is a Power7 instruction for which no machine description exists.
 7190     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7191     __ isel_0($dst$$Register, $crx$$CondRegister, Assembler::equal, $src1$$Register);
 7192   %}
 7193   ins_pipe(pipe_class_default);
 7194 %}
 7195 
 7196 //  shift != 0, base != 0
 7197 instruct decodeN_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7198   match(Set dst (DecodeN src));
 7199   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7200              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7201             CompressedOops::shift() != 0 &amp;&amp;
 7202             CompressedOops::base() != 0);
 7203   ins_cost(4 * DEFAULT_COST); // Should be more expensive than decodeN_Disjoint_isel_Ex.
 7204   effect(TEMP crx);
 7205 
 7206   format %{ &quot;DecodeN $dst, $src \t// Kills $crx, postalloc expanded&quot; %}
 7207   postalloc_expand( postalloc_expand_decode_oop(dst, src, crx) );
 7208 %}
 7209 
 7210 // shift != 0, base == 0
 7211 instruct decodeN_nullBase(iRegPdst dst, iRegNsrc src) %{
 7212   match(Set dst (DecodeN src));
 7213   predicate(CompressedOops::shift() != 0 &amp;&amp;
 7214             CompressedOops::base() == 0);
 7215 
 7216   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeN (zerobased)&quot; %}
 7217   size(4);
 7218   ins_encode %{
 7219     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7220     __ sldi($dst$$Register, $src$$Register, CompressedOops::shift());
 7221   %}
 7222   ins_pipe(pipe_class_default);
 7223 %}
 7224 
 7225 // Optimize DecodeN for disjoint base.
 7226 // Shift narrow oop and or it into register that already contains the heap base.
 7227 // Base == dst must hold, and is assured by construction in postaloc_expand.
 7228 instruct decodeN_mergeDisjoint(iRegPdst dst, iRegNsrc src, iRegLsrc base) %{
 7229   match(Set dst (DecodeN src));
 7230   effect(TEMP base);
 7231   predicate(false);
 7232 
 7233   format %{ &quot;RLDIMI  $dst, $src, shift, 32-shift \t// DecodeN (disjoint base)&quot; %}
 7234   size(4);
 7235   ins_encode %{
 7236     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
 7237     __ rldimi($dst$$Register, $src$$Register, CompressedOops::shift(), 32-CompressedOops::shift());
 7238   %}
 7239   ins_pipe(pipe_class_default);
 7240 %}
 7241 
 7242 // Optimize DecodeN for disjoint base.
 7243 // This node requires only one cycle on the critical path.
 7244 // We must postalloc_expand as we can not express use_def effects where
 7245 // the used register is L and the def&#39;ed register P.
 7246 instruct decodeN_Disjoint_notNull_Ex(iRegPdst dst, iRegNsrc src) %{
 7247   match(Set dst (DecodeN src));
 7248   effect(TEMP_DEF dst);
 7249   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7250              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7251             CompressedOops::base_disjoint());
 7252   ins_cost(DEFAULT_COST);
 7253 
 7254   format %{ &quot;MOV     $dst, heapbase \t\n&quot;
 7255             &quot;RLDIMI  $dst, $src, shift, 32-shift \t// decode with disjoint base&quot; %}
 7256   postalloc_expand %{
 7257     loadBaseNode *n1 = new loadBaseNode();
 7258     n1-&gt;add_req(NULL);
 7259     n1-&gt;_opnds[0] = op_dst;
 7260 
 7261     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7262     n2-&gt;add_req(n_region, n_src, n1);
 7263     n2-&gt;_opnds[0] = op_dst;
 7264     n2-&gt;_opnds[1] = op_src;
 7265     n2-&gt;_opnds[2] = op_dst;
 7266     n2-&gt;_bottom_type = _bottom_type;
 7267 
 7268     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7269     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7270 
 7271     nodes-&gt;push(n1);
 7272     nodes-&gt;push(n2);
 7273   %}
 7274 %}
 7275 
 7276 instruct decodeN_Disjoint_isel_Ex(iRegPdst dst, iRegNsrc src, flagsReg crx) %{
 7277   match(Set dst (DecodeN src));
 7278   effect(TEMP_DEF dst, TEMP crx);
 7279   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::NotNull &amp;&amp;
 7280              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() != TypePtr::Constant) &amp;&amp;
 7281             CompressedOops::base_disjoint() &amp;&amp; VM_Version::has_isel());
 7282   ins_cost(3 * DEFAULT_COST);
 7283 
 7284   format %{ &quot;DecodeN  $dst, $src \t// decode with disjoint base using isel&quot; %}
 7285   postalloc_expand %{
 7286     loadBaseNode *n1 = new loadBaseNode();
 7287     n1-&gt;add_req(NULL);
 7288     n1-&gt;_opnds[0] = op_dst;
 7289 
 7290     cmpN_reg_imm0Node *n_compare  = new cmpN_reg_imm0Node();
 7291     n_compare-&gt;add_req(n_region, n_src);
 7292     n_compare-&gt;_opnds[0] = op_crx;
 7293     n_compare-&gt;_opnds[1] = op_src;
 7294     n_compare-&gt;_opnds[2] = new immN_0Oper(TypeNarrowOop::NULL_PTR);
 7295 
 7296     decodeN_mergeDisjointNode *n2 = new decodeN_mergeDisjointNode();
 7297     n2-&gt;add_req(n_region, n_src, n1);
 7298     n2-&gt;_opnds[0] = op_dst;
 7299     n2-&gt;_opnds[1] = op_src;
 7300     n2-&gt;_opnds[2] = op_dst;
 7301     n2-&gt;_bottom_type = _bottom_type;
 7302 
 7303     cond_set_0_ptrNode *n_cond_set = new cond_set_0_ptrNode();
 7304     n_cond_set-&gt;add_req(n_region, n_compare, n2);
 7305     n_cond_set-&gt;_opnds[0] = op_dst;
 7306     n_cond_set-&gt;_opnds[1] = op_crx;
 7307     n_cond_set-&gt;_opnds[2] = op_dst;
 7308     n_cond_set-&gt;_bottom_type = _bottom_type;
 7309 
 7310     assert(ra_-&gt;is_oop(this) == true, &quot;A decodeN node must produce an oop!&quot;);
 7311     ra_-&gt;set_oop(n_cond_set, true);
 7312 
 7313     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7314     ra_-&gt;set_pair(n_compare-&gt;_idx, ra_-&gt;get_reg_second(n_crx), ra_-&gt;get_reg_first(n_crx));
 7315     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7316     ra_-&gt;set_pair(n_cond_set-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7317 
 7318     nodes-&gt;push(n1);
 7319     nodes-&gt;push(n_compare);
 7320     nodes-&gt;push(n2);
 7321     nodes-&gt;push(n_cond_set);
 7322   %}
 7323 %}
 7324 
 7325 // src != 0, shift != 0, base != 0
 7326 instruct decodeN_notNull_addBase_Ex(iRegPdst dst, iRegNsrc src) %{
 7327   match(Set dst (DecodeN src));
 7328   predicate((n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::NotNull ||
 7329              n-&gt;bottom_type()-&gt;is_oopptr()-&gt;ptr() == TypePtr::Constant) &amp;&amp;
 7330             CompressedOops::shift() != 0 &amp;&amp;
 7331             CompressedOops::base() != 0);
 7332   ins_cost(2 * DEFAULT_COST);
 7333 
 7334   format %{ &quot;DecodeN $dst, $src \t// $src != NULL, postalloc expanded&quot; %}
 7335   postalloc_expand( postalloc_expand_decode_oop_not_null(dst, src));
 7336 %}
 7337 
 7338 // Compressed OOPs with narrow_oop_shift == 0.
 7339 instruct decodeN_unscaled(iRegPdst dst, iRegNsrc src) %{
 7340   match(Set dst (DecodeN src));
 7341   predicate(CompressedOops::shift() == 0);
 7342   ins_cost(DEFAULT_COST);
 7343 
 7344   format %{ &quot;MR      $dst, $src \t// DecodeN (unscaled)&quot; %}
 7345   // variable size, 0 or 4.
 7346   ins_encode %{
 7347     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7348     __ mr_if_needed($dst$$Register, $src$$Register);
 7349   %}
 7350   ins_pipe(pipe_class_default);
 7351 %}
 7352 
 7353 // Convert compressed oop into int for vectors alignment masking.
 7354 instruct decodeN2I_unscaled(iRegIdst dst, iRegNsrc src) %{
 7355   match(Set dst (ConvL2I (CastP2X (DecodeN src))));
 7356   predicate(CompressedOops::shift() == 0);
 7357   ins_cost(DEFAULT_COST);
 7358 
 7359   format %{ &quot;MR      $dst, $src \t// (int)DecodeN (unscaled)&quot; %}
 7360   // variable size, 0 or 4.
 7361   ins_encode %{
 7362     // TODO: PPC port $archOpcode(ppc64Opcode_or);
 7363     __ mr_if_needed($dst$$Register, $src$$Register);
 7364   %}
 7365   ins_pipe(pipe_class_default);
 7366 %}
 7367 
 7368 // Convert klass pointer into compressed form.
 7369 
 7370 // Nodes for postalloc expand.
 7371 
 7372 // Shift node for expand.
 7373 instruct encodePKlass_shift(iRegNdst dst, iRegNsrc src) %{
 7374   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7375   match(Set dst (EncodePKlass src));
 7376   predicate(false);
 7377 
 7378   format %{ &quot;SRDI    $dst, $src, 3 \t// encode&quot; %}
 7379   size(4);
 7380   ins_encode %{
 7381     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7382     __ srdi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7383   %}
 7384   ins_pipe(pipe_class_default);
 7385 %}
 7386 
 7387 // Add node for expand.
 7388 instruct encodePKlass_sub_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7389   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7390   match(Set dst (EncodePKlass (Binary base src)));
 7391   predicate(false);
 7392 
 7393   format %{ &quot;SUB     $dst, $base, $src \t// encode&quot; %}
 7394   size(4);
 7395   ins_encode %{
 7396     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 7397     __ subf($dst$$Register, $base$$Register, $src$$Register);
 7398   %}
 7399   ins_pipe(pipe_class_default);
 7400 %}
 7401 
 7402 // Disjoint narrow oop base.
 7403 instruct encodePKlass_Disjoint(iRegNdst dst, iRegPsrc src) %{
 7404   match(Set dst (EncodePKlass src));
 7405   predicate(false /* TODO: PPC port CompressedKlassPointers::base_disjoint()*/);
 7406 
 7407   format %{ &quot;EXTRDI  $dst, $src, #32, #3 \t// encode with disjoint base&quot; %}
 7408   size(4);
 7409   ins_encode %{
 7410     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 7411     __ rldicl($dst$$Register, $src$$Register, 64-CompressedKlassPointers::shift(), 32);
 7412   %}
 7413   ins_pipe(pipe_class_default);
 7414 %}
 7415 
 7416 // shift != 0, base != 0
 7417 instruct encodePKlass_not_null_Ex(iRegNdst dst, iRegLsrc base, iRegPsrc src) %{
 7418   match(Set dst (EncodePKlass (Binary base src)));
 7419   predicate(false);
 7420 
 7421   format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7422   postalloc_expand %{
 7423     encodePKlass_sub_baseNode *n1 = new encodePKlass_sub_baseNode();
 7424     n1-&gt;add_req(n_region, n_base, n_src);
 7425     n1-&gt;_opnds[0] = op_dst;
 7426     n1-&gt;_opnds[1] = op_base;
 7427     n1-&gt;_opnds[2] = op_src;
 7428     n1-&gt;_bottom_type = _bottom_type;
 7429 
 7430     encodePKlass_shiftNode *n2 = new encodePKlass_shiftNode();
 7431     n2-&gt;add_req(n_region, n1);
 7432     n2-&gt;_opnds[0] = op_dst;
 7433     n2-&gt;_opnds[1] = op_dst;
 7434     n2-&gt;_bottom_type = _bottom_type;
 7435     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7436     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7437 
 7438     nodes-&gt;push(n1);
 7439     nodes-&gt;push(n2);
 7440   %}
 7441 %}
 7442 
 7443 // shift != 0, base != 0
 7444 instruct encodePKlass_not_null_ExEx(iRegNdst dst, iRegPsrc src) %{
 7445   match(Set dst (EncodePKlass src));
 7446   //predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7447   //          true /* TODO: PPC port CompressedKlassPointers::base_overlaps()*/);
 7448 
 7449   //format %{ &quot;EncodePKlass $dst, $src\t// $src != Null, postalloc expanded&quot; %}
 7450   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7451   expand %{
 7452     immL baseImm %{ (jlong)(intptr_t)CompressedKlassPointers::base() %}
 7453     iRegLdst base;
 7454     loadConL_Ex(base, baseImm);
 7455     encodePKlass_not_null_Ex(dst, base, src);
 7456   %}
 7457 %}
 7458 
 7459 // Decode nodes.
 7460 
 7461 // Shift node for expand.
 7462 instruct decodeNKlass_shift(iRegPdst dst, iRegPsrc src) %{
 7463   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7464   match(Set dst (DecodeNKlass src));
 7465   predicate(false);
 7466 
 7467   format %{ &quot;SLDI    $dst, $src, #3 \t// DecodeNKlass&quot; %}
 7468   size(4);
 7469   ins_encode %{
 7470     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 7471     __ sldi($dst$$Register, $src$$Register, CompressedKlassPointers::shift());
 7472   %}
 7473   ins_pipe(pipe_class_default);
 7474 %}
 7475 
 7476 // Add node for expand.
 7477 
 7478 instruct decodeNKlass_add_base(iRegPdst dst, iRegLsrc base, iRegPdst src) %{
 7479   // The match rule is needed to make it a &#39;MachTypeNode&#39;!
 7480   match(Set dst (DecodeNKlass (Binary base src)));
 7481   predicate(false);
 7482 
 7483   format %{ &quot;ADD     $dst, $base, $src \t// DecodeNKlass, add klass base&quot; %}
 7484   size(4);
 7485   ins_encode %{
 7486     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 7487     __ add($dst$$Register, $base$$Register, $src$$Register);
 7488   %}
 7489   ins_pipe(pipe_class_default);
 7490 %}
 7491 
 7492 // src != 0, shift != 0, base != 0
 7493 instruct decodeNKlass_notNull_addBase_Ex(iRegPdst dst, iRegLsrc base, iRegNsrc src) %{
 7494   match(Set dst (DecodeNKlass (Binary base src)));
 7495   //effect(kill src); // We need a register for the immediate result after shifting.
 7496   predicate(false);
 7497 
 7498   format %{ &quot;DecodeNKlass $dst =  $base + ($src &lt;&lt; 3) \t// $src != NULL, postalloc expanded&quot; %}
 7499   postalloc_expand %{
 7500     decodeNKlass_add_baseNode *n1 = new decodeNKlass_add_baseNode();
 7501     n1-&gt;add_req(n_region, n_base, n_src);
 7502     n1-&gt;_opnds[0] = op_dst;
 7503     n1-&gt;_opnds[1] = op_base;
 7504     n1-&gt;_opnds[2] = op_src;
 7505     n1-&gt;_bottom_type = _bottom_type;
 7506 
 7507     decodeNKlass_shiftNode *n2 = new decodeNKlass_shiftNode();
 7508     n2-&gt;add_req(n_region, n1);
 7509     n2-&gt;_opnds[0] = op_dst;
 7510     n2-&gt;_opnds[1] = op_dst;
 7511     n2-&gt;_bottom_type = _bottom_type;
 7512 
 7513     ra_-&gt;set_pair(n1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7514     ra_-&gt;set_pair(n2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this));
 7515 
 7516     nodes-&gt;push(n1);
 7517     nodes-&gt;push(n2);
 7518   %}
 7519 %}
 7520 
 7521 // src != 0, shift != 0, base != 0
 7522 instruct decodeNKlass_notNull_addBase_ExEx(iRegPdst dst, iRegNsrc src) %{
 7523   match(Set dst (DecodeNKlass src));
 7524   // predicate(CompressedKlassPointers::shift() != 0 &amp;&amp;
 7525   //           CompressedKlassPointers::base() != 0);
 7526 
 7527   //format %{ &quot;DecodeNKlass $dst, $src \t// $src != NULL, expanded&quot; %}
 7528 
 7529   ins_cost(DEFAULT_COST*2);  // Don&#39;t count constant.
 7530   expand %{
 7531     // We add first, then we shift. Like this, we can get along with one register less.
 7532     // But we have to load the base pre-shifted.
 7533     immL baseImm %{ (jlong)((intptr_t)CompressedKlassPointers::base() &gt;&gt; CompressedKlassPointers::shift()) %}
 7534     iRegLdst base;
 7535     loadConL_Ex(base, baseImm);
 7536     decodeNKlass_notNull_addBase_Ex(dst, base, src);
 7537   %}
 7538 %}
 7539 
 7540 //----------MemBar Instructions-----------------------------------------------
 7541 // Memory barrier flavors
 7542 
 7543 instruct membar_acquire() %{
 7544   match(LoadFence);
 7545   ins_cost(4*MEMORY_REF_COST);
 7546 
 7547   format %{ &quot;MEMBAR-acquire&quot; %}
 7548   size(4);
 7549   ins_encode %{
 7550     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7551     __ acquire();
 7552   %}
 7553   ins_pipe(pipe_class_default);
 7554 %}
 7555 
 7556 instruct unnecessary_membar_acquire() %{
 7557   match(MemBarAcquire);
 7558   ins_cost(0);
 7559 
 7560   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty&quot; %}
 7561   size(0);
 7562   ins_encode( /*empty*/ );
 7563   ins_pipe(pipe_class_default);
 7564 %}
 7565 
 7566 instruct membar_acquire_lock() %{
 7567   match(MemBarAcquireLock);
 7568   ins_cost(0);
 7569 
 7570   format %{ &quot; -- \t// redundant MEMBAR-acquire - empty (acquire as part of CAS in prior FastLock)&quot; %}
 7571   size(0);
 7572   ins_encode( /*empty*/ );
 7573   ins_pipe(pipe_class_default);
 7574 %}
 7575 
 7576 instruct membar_release() %{
 7577   match(MemBarRelease);
 7578   match(StoreFence);
 7579   ins_cost(4*MEMORY_REF_COST);
 7580 
 7581   format %{ &quot;MEMBAR-release&quot; %}
 7582   size(4);
 7583   ins_encode %{
 7584     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7585     __ release();
 7586   %}
 7587   ins_pipe(pipe_class_default);
 7588 %}
 7589 
 7590 instruct membar_storestore() %{
 7591   match(MemBarStoreStore);
 7592   ins_cost(4*MEMORY_REF_COST);
 7593 
 7594   format %{ &quot;MEMBAR-store-store&quot; %}
 7595   size(4);
 7596   ins_encode %{
 7597     // TODO: PPC port $archOpcode(ppc64Opcode_lwsync);
 7598     __ membar(Assembler::StoreStore);
 7599   %}
 7600   ins_pipe(pipe_class_default);
 7601 %}
 7602 
 7603 instruct membar_release_lock() %{
 7604   match(MemBarReleaseLock);
 7605   ins_cost(0);
 7606 
 7607   format %{ &quot; -- \t// redundant MEMBAR-release - empty (release in FastUnlock)&quot; %}
 7608   size(0);
 7609   ins_encode( /*empty*/ );
 7610   ins_pipe(pipe_class_default);
 7611 %}
 7612 
 7613 instruct membar_volatile() %{
 7614   match(MemBarVolatile);
 7615   ins_cost(4*MEMORY_REF_COST);
 7616 
 7617   format %{ &quot;MEMBAR-volatile&quot; %}
 7618   size(4);
 7619   ins_encode %{
 7620     // TODO: PPC port $archOpcode(ppc64Opcode_sync);
 7621     __ fence();
 7622   %}
 7623   ins_pipe(pipe_class_default);
 7624 %}
 7625 
 7626 // This optimization is wrong on PPC. The following pattern is not supported:
 7627 //  MemBarVolatile
 7628 //   ^        ^
 7629 //   |        |
 7630 //  CtrlProj MemProj
 7631 //   ^        ^
 7632 //   |        |
 7633 //   |       Load
 7634 //   |
 7635 //  MemBarVolatile
 7636 //
 7637 //  The first MemBarVolatile could get optimized out! According to
 7638 //  Vladimir, this pattern can not occur on Oracle platforms.
 7639 //  However, it does occur on PPC64 (because of membars in
 7640 //  inline_unsafe_load_store).
 7641 //
 7642 // Add this node again if we found a good solution for inline_unsafe_load_store().
 7643 // Don&#39;t forget to look at the implementation of post_store_load_barrier again,
 7644 // we did other fixes in that method.
 7645 //instruct unnecessary_membar_volatile() %{
 7646 //  match(MemBarVolatile);
 7647 //  predicate(Matcher::post_store_load_barrier(n));
 7648 //  ins_cost(0);
 7649 //
 7650 //  format %{ &quot; -- \t// redundant MEMBAR-volatile - empty&quot; %}
 7651 //  size(0);
 7652 //  ins_encode( /*empty*/ );
 7653 //  ins_pipe(pipe_class_default);
 7654 //%}
 7655 
 7656 instruct membar_CPUOrder() %{
 7657   match(MemBarCPUOrder);
 7658   ins_cost(0);
 7659 
 7660   format %{ &quot; -- \t// MEMBAR-CPUOrder - empty: PPC64 processors are self-consistent.&quot; %}
 7661   size(0);
 7662   ins_encode( /*empty*/ );
 7663   ins_pipe(pipe_class_default);
 7664 %}
 7665 
 7666 //----------Conditional Move---------------------------------------------------
 7667 
 7668 // Cmove using isel.
 7669 instruct cmovI_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7670   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7671   predicate(VM_Version::has_isel());
 7672   ins_cost(DEFAULT_COST);
 7673 
 7674   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7675   size(4);
 7676   ins_encode %{
 7677     // This is a Power7 instruction for which no machine description
 7678     // exists. Anyways, the scheduler should be off on Power7.
 7679     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7680     int cc        = $cmp$$cmpcode;
 7681     __ isel($dst$$Register, $crx$$CondRegister,
 7682             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7683   %}
 7684   ins_pipe(pipe_class_default);
 7685 %}
 7686 
 7687 instruct cmovI_reg(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, iRegIsrc src) %{
 7688   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7689   predicate(!VM_Version::has_isel());
 7690   ins_cost(DEFAULT_COST+BRANCH_COST);
 7691 
 7692   ins_variable_size_depending_on_alignment(true);
 7693 
 7694   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7695   // Worst case is branch + move + stop, no stop without scheduler
 7696   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7697   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7698   ins_pipe(pipe_class_default);
 7699 %}
 7700 
 7701 instruct cmovI_imm(cmpOp cmp, flagsRegSrc crx, iRegIdst dst, immI16 src) %{
 7702   match(Set dst (CMoveI (Binary cmp crx) (Binary dst src)));
 7703   ins_cost(DEFAULT_COST+BRANCH_COST);
 7704 
 7705   ins_variable_size_depending_on_alignment(true);
 7706 
 7707   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7708   // Worst case is branch + move + stop, no stop without scheduler
 7709   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7710   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7711   ins_pipe(pipe_class_default);
 7712 %}
 7713 
 7714 // Cmove using isel.
 7715 instruct cmovL_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7716   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7717   predicate(VM_Version::has_isel());
 7718   ins_cost(DEFAULT_COST);
 7719 
 7720   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7721   size(4);
 7722   ins_encode %{
 7723     // This is a Power7 instruction for which no machine description
 7724     // exists. Anyways, the scheduler should be off on Power7.
 7725     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7726     int cc        = $cmp$$cmpcode;
 7727     __ isel($dst$$Register, $crx$$CondRegister,
 7728             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7729   %}
 7730   ins_pipe(pipe_class_default);
 7731 %}
 7732 
 7733 instruct cmovL_reg(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, iRegLsrc src) %{
 7734   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7735   predicate(!VM_Version::has_isel());
 7736   ins_cost(DEFAULT_COST+BRANCH_COST);
 7737 
 7738   ins_variable_size_depending_on_alignment(true);
 7739 
 7740   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7741   // Worst case is branch + move + stop, no stop without scheduler.
 7742   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7743   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7744   ins_pipe(pipe_class_default);
 7745 %}
 7746 
 7747 instruct cmovL_imm(cmpOp cmp, flagsRegSrc crx, iRegLdst dst, immL16 src) %{
 7748   match(Set dst (CMoveL (Binary cmp crx) (Binary dst src)));
 7749   ins_cost(DEFAULT_COST+BRANCH_COST);
 7750 
 7751   ins_variable_size_depending_on_alignment(true);
 7752 
 7753   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7754   // Worst case is branch + move + stop, no stop without scheduler.
 7755   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7756   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7757   ins_pipe(pipe_class_default);
 7758 %}
 7759 
 7760 // Cmove using isel.
 7761 instruct cmovN_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7762   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7763   predicate(VM_Version::has_isel());
 7764   ins_cost(DEFAULT_COST);
 7765 
 7766   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7767   size(4);
 7768   ins_encode %{
 7769     // This is a Power7 instruction for which no machine description
 7770     // exists. Anyways, the scheduler should be off on Power7.
 7771     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7772     int cc        = $cmp$$cmpcode;
 7773     __ isel($dst$$Register, $crx$$CondRegister,
 7774             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7775   %}
 7776   ins_pipe(pipe_class_default);
 7777 %}
 7778 
 7779 // Conditional move for RegN. Only cmov(reg, reg).
 7780 instruct cmovN_reg(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, iRegNsrc src) %{
 7781   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7782   predicate(!VM_Version::has_isel());
 7783   ins_cost(DEFAULT_COST+BRANCH_COST);
 7784 
 7785   ins_variable_size_depending_on_alignment(true);
 7786 
 7787   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7788   // Worst case is branch + move + stop, no stop without scheduler.
 7789   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7790   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7791   ins_pipe(pipe_class_default);
 7792 %}
 7793 
 7794 instruct cmovN_imm(cmpOp cmp, flagsRegSrc crx, iRegNdst dst, immN_0 src) %{
 7795   match(Set dst (CMoveN (Binary cmp crx) (Binary dst src)));
 7796   ins_cost(DEFAULT_COST+BRANCH_COST);
 7797 
 7798   ins_variable_size_depending_on_alignment(true);
 7799 
 7800   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7801   // Worst case is branch + move + stop, no stop without scheduler.
 7802   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7803   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7804   ins_pipe(pipe_class_default);
 7805 %}
 7806 
 7807 // Cmove using isel.
 7808 instruct cmovP_reg_isel(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegPsrc src) %{
 7809   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7810   predicate(VM_Version::has_isel());
 7811   ins_cost(DEFAULT_COST);
 7812 
 7813   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7814   size(4);
 7815   ins_encode %{
 7816     // This is a Power7 instruction for which no machine description
 7817     // exists. Anyways, the scheduler should be off on Power7.
 7818     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7819     int cc        = $cmp$$cmpcode;
 7820     __ isel($dst$$Register, $crx$$CondRegister,
 7821             (Assembler::Condition)(cc &amp; 3), /*invert*/((~cc) &amp; 8), $src$$Register);
 7822   %}
 7823   ins_pipe(pipe_class_default);
 7824 %}
 7825 
 7826 instruct cmovP_reg(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, iRegP_N2P src) %{
 7827   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7828   predicate(!VM_Version::has_isel());
 7829   ins_cost(DEFAULT_COST+BRANCH_COST);
 7830 
 7831   ins_variable_size_depending_on_alignment(true);
 7832 
 7833   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7834   // Worst case is branch + move + stop, no stop without scheduler.
 7835   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7836   ins_encode( enc_cmove_reg(dst, crx, src, cmp) );
 7837   ins_pipe(pipe_class_default);
 7838 %}
 7839 
 7840 instruct cmovP_imm(cmpOp cmp, flagsRegSrc crx, iRegPdst dst, immP_0 src) %{
 7841   match(Set dst (CMoveP (Binary cmp crx) (Binary dst src)));
 7842   ins_cost(DEFAULT_COST+BRANCH_COST);
 7843 
 7844   ins_variable_size_depending_on_alignment(true);
 7845 
 7846   format %{ &quot;CMOVE   $cmp, $crx, $dst, $src\n\t&quot; %}
 7847   // Worst case is branch + move + stop, no stop without scheduler.
 7848   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
 7849   ins_encode( enc_cmove_imm(dst, crx, src, cmp) );
 7850   ins_pipe(pipe_class_default);
 7851 %}
 7852 
 7853 instruct cmovF_reg(cmpOp cmp, flagsRegSrc crx, regF dst, regF src) %{
 7854   match(Set dst (CMoveF (Binary cmp crx) (Binary dst src)));
 7855   ins_cost(DEFAULT_COST+BRANCH_COST);
 7856 
 7857   ins_variable_size_depending_on_alignment(true);
 7858 
 7859   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7860   // Worst case is branch + move + stop, no stop without scheduler.
 7861   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7862   ins_encode %{
 7863     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7864     Label done;
 7865     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7866     // Branch if not (cmp crx).
 7867     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7868     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7869     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7870     __ bind(done);
 7871   %}
 7872   ins_pipe(pipe_class_default);
 7873 %}
 7874 
 7875 instruct cmovD_reg(cmpOp cmp, flagsRegSrc crx, regD dst, regD src) %{
 7876   match(Set dst (CMoveD (Binary cmp crx) (Binary dst src)));
 7877   ins_cost(DEFAULT_COST+BRANCH_COST);
 7878 
 7879   ins_variable_size_depending_on_alignment(true);
 7880 
 7881   format %{ &quot;CMOVEF  $cmp, $crx, $dst, $src\n\t&quot; %}
 7882   // Worst case is branch + move + stop, no stop without scheduler.
 7883   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 7884   ins_encode %{
 7885     // TODO: PPC port $archOpcode(ppc64Opcode_cmovef);
 7886     Label done;
 7887     assert((Assembler::bcondCRbiIs1 &amp; ~Assembler::bcondCRbiIs0) == 8, &quot;check encoding&quot;);
 7888     // Branch if not (cmp crx).
 7889     __ bc(cc_to_inverse_boint($cmp$$cmpcode), cc_to_biint($cmp$$cmpcode, $crx$$reg), done);
 7890     __ fmr($dst$$FloatRegister, $src$$FloatRegister);
 7891     // TODO PPC port __ endgroup_if_needed(_size == 12);
 7892     __ bind(done);
 7893   %}
 7894   ins_pipe(pipe_class_default);
 7895 %}
 7896 
 7897 //----------Conditional_store--------------------------------------------------
 7898 // Conditional-store of the updated heap-top.
 7899 // Used during allocation of the shared heap.
 7900 // Sets flags (EQ) on success. Implemented with a CASA on Sparc.
 7901 
 7902 // As compareAndSwapL, but return flag register instead of boolean value in
 7903 // int register.
 7904 // Used by sun/misc/AtomicLongCSImpl.java.
 7905 // Mem_ptr must be a memory operand, else this node does not get
 7906 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7907 // can be rematerialized which leads to errors.
 7908 instruct storeLConditional_regP_regL_regL(flagsReg crx, indirect mem_ptr, iRegLsrc oldVal, iRegLsrc newVal, flagsRegCR0 cr0) %{
 7909   match(Set crx (StoreLConditional mem_ptr (Binary oldVal newVal)));
 7910   effect(TEMP cr0);
 7911   format %{ &quot;CMPXCHGD if ($crx = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7912   ins_encode %{
 7913     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7914     __ cmpxchgd($crx$$CondRegister, R0, $oldVal$$Register, $newVal$$Register, $mem_ptr$$Register,
 7915                 MacroAssembler::MemBarAcq, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7916                 noreg, NULL, true);
 7917   %}
 7918   ins_pipe(pipe_class_default);
 7919 %}
 7920 
 7921 // As compareAndSwapP, but return flag register instead of boolean value in
 7922 // int register.
 7923 // This instruction is matched if UseTLAB is off.
 7924 // Mem_ptr must be a memory operand, else this node does not get
 7925 // Flag_needs_anti_dependence_check set by adlc. If this is not set this node
 7926 // can be rematerialized which leads to errors.
 7927 instruct storePConditional_regP_regP_regP(flagsRegCR0 cr0, indirect mem_ptr, iRegPsrc oldVal, iRegPsrc newVal) %{
 7928   match(Set cr0 (StorePConditional mem_ptr (Binary oldVal newVal)));
 7929   ins_cost(2*MEMORY_REF_COST);
 7930 
 7931   format %{ &quot;STDCX_  if ($cr0 = ($oldVal == *$mem_ptr)) *mem_ptr = $newVal; as bool&quot; %}
 7932   ins_encode %{
 7933     // TODO: PPC port $archOpcode(ppc64Opcode_stdcx_);
 7934     __ stdcx_($newVal$$Register, $mem_ptr$$Register);
 7935   %}
 7936   ins_pipe(pipe_class_memory);
 7937 %}
 7938 
 7939 // Implement LoadPLocked. Must be ordered against changes of the memory location
 7940 // by storePConditional.
 7941 // Don&#39;t know whether this is ever used.
 7942 instruct loadPLocked(iRegPdst dst, memory mem) %{
 7943   match(Set dst (LoadPLocked mem));
 7944   ins_cost(2*MEMORY_REF_COST);
 7945 
 7946   format %{ &quot;LDARX   $dst, $mem \t// loadPLocked\n\t&quot; %}
 7947   size(4);
 7948   ins_encode %{
 7949     // TODO: PPC port $archOpcode(ppc64Opcode_ldarx);
 7950     __ ldarx($dst$$Register, $mem$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 7951   %}
 7952   ins_pipe(pipe_class_memory);
 7953 %}
 7954 
 7955 //----------Compare-And-Swap---------------------------------------------------
 7956 
 7957 // CompareAndSwap{P,I,L} have more than one output, therefore &quot;CmpI
 7958 // (CompareAndSwap ...)&quot; or &quot;If (CmpI (CompareAndSwap ..))&quot;  cannot be
 7959 // matched.
 7960 
 7961 // Strong versions:
 7962 
 7963 instruct compareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 7964   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7965   predicate(VM_Version::has_lqarx());
 7966   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 7967   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7968   ins_encode %{
 7969     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7970     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7971     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 7972                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7973                 $res$$Register, true);
 7974     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7975       __ isync();
 7976     } else {
 7977       __ sync();
 7978     }
 7979   %}
 7980   ins_pipe(pipe_class_default);
 7981 %}
 7982 
 7983 instruct compareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 7984   match(Set res (CompareAndSwapB mem_ptr (Binary src1 src2)));
 7985   predicate(!VM_Version::has_lqarx());
 7986   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 7987   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 7988   ins_encode %{
 7989     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 7990     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 7991     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 7992                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 7993                 $res$$Register, true);
 7994     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 7995       __ isync();
 7996     } else {
 7997       __ sync();
 7998     }
 7999   %}
 8000   ins_pipe(pipe_class_default);
 8001 %}
 8002 
 8003 instruct compareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8004   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8005   predicate(VM_Version::has_lqarx());
 8006   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8007   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8008   ins_encode %{
 8009     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8010     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8011     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8012                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8013                 $res$$Register, true);
 8014     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8015       __ isync();
 8016     } else {
 8017       __ sync();
 8018     }
 8019   %}
 8020   ins_pipe(pipe_class_default);
 8021 %}
 8022 
 8023 instruct compareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8024   match(Set res (CompareAndSwapS mem_ptr (Binary src1 src2)));
 8025   predicate(!VM_Version::has_lqarx());
 8026   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8027   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8028   ins_encode %{
 8029     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8030     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8031     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8032                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8033                 $res$$Register, true);
 8034     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8035       __ isync();
 8036     } else {
 8037       __ sync();
 8038     }
 8039   %}
 8040   ins_pipe(pipe_class_default);
 8041 %}
 8042 
 8043 instruct compareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8044   match(Set res (CompareAndSwapI mem_ptr (Binary src1 src2)));
 8045   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8046   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8047   ins_encode %{
 8048     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8049     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8050     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8051                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8052                 $res$$Register, true);
 8053     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8054       __ isync();
 8055     } else {
 8056       __ sync();
 8057     }
 8058   %}
 8059   ins_pipe(pipe_class_default);
 8060 %}
 8061 
 8062 instruct compareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8063   match(Set res (CompareAndSwapN mem_ptr (Binary src1 src2)));
 8064   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8065   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8066   ins_encode %{
 8067     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8068     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8069     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8070                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8071                 $res$$Register, true);
 8072     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8073       __ isync();
 8074     } else {
 8075       __ sync();
 8076     }
 8077   %}
 8078   ins_pipe(pipe_class_default);
 8079 %}
 8080 
 8081 instruct compareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8082   match(Set res (CompareAndSwapL mem_ptr (Binary src1 src2)));
 8083   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8084   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8085   ins_encode %{
 8086     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8087     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8088     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8089                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8090                 $res$$Register, NULL, true);
 8091     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8092       __ isync();
 8093     } else {
 8094       __ sync();
 8095     }
 8096   %}
 8097   ins_pipe(pipe_class_default);
 8098 %}
 8099 
 8100 instruct compareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8101   match(Set res (CompareAndSwapP mem_ptr (Binary src1 src2)));
 8102   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8103   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8104   ins_encode %{
 8105     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8106     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8107     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8108                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8109                 $res$$Register, NULL, true);
 8110     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8111       __ isync();
 8112     } else {
 8113       __ sync();
 8114     }
 8115   %}
 8116   ins_pipe(pipe_class_default);
 8117 %}
 8118 
 8119 // Weak versions:
 8120 
 8121 instruct weakCompareAndSwapB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8122   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8123   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8124   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8125   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8126   ins_encode %{
 8127     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8128     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8129     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8130                 MacroAssembler::MemBarNone,
 8131                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8132   %}
 8133   ins_pipe(pipe_class_default);
 8134 %}
 8135 
 8136 instruct weakCompareAndSwapB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8137   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8138   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8139   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8140   format %{ &quot;weak CMPXCHGB $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8141   ins_encode %{
 8142     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8143     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8144     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8145                 MacroAssembler::MemBarNone,
 8146                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8147   %}
 8148   ins_pipe(pipe_class_default);
 8149 %}
 8150 
 8151 instruct weakCompareAndSwapB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8152   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8153   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8154   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8155   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8156   ins_encode %{
 8157     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8158     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8159     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8160                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8161                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8162   %}
 8163   ins_pipe(pipe_class_default);
 8164 %}
 8165 
 8166 instruct weakCompareAndSwapB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8167   match(Set res (WeakCompareAndSwapB mem_ptr (Binary src1 src2)));
 8168   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8169   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8170   format %{ &quot;weak CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8171   ins_encode %{
 8172     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8173     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8174     __ cmpxchgb(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8175                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8176                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8177   %}
 8178   ins_pipe(pipe_class_default);
 8179 %}
 8180 
 8181 instruct weakCompareAndSwapS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8182   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8183   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8184   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8185   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8186   ins_encode %{
 8187     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8188     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8189     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8190                 MacroAssembler::MemBarNone,
 8191                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8192   %}
 8193   ins_pipe(pipe_class_default);
 8194 %}
 8195 
 8196 instruct weakCompareAndSwapS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8197   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8198   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8199   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8200   format %{ &quot;weak CMPXCHGH $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8201   ins_encode %{
 8202     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8203     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8204     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8205                 MacroAssembler::MemBarNone,
 8206                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8207   %}
 8208   ins_pipe(pipe_class_default);
 8209 %}
 8210 
 8211 instruct weakCompareAndSwapS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8212   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8213   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8214   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8215   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8216   ins_encode %{
 8217     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8218     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8219     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8220                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8221                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8222   %}
 8223   ins_pipe(pipe_class_default);
 8224 %}
 8225 
 8226 instruct weakCompareAndSwapS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, iRegIdst tmp2, flagsRegCR0 cr0) %{
 8227   match(Set res (WeakCompareAndSwapS mem_ptr (Binary src1 src2)));
 8228   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8229   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0); // TEMP_DEF to avoid jump
 8230   format %{ &quot;weak CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8231   ins_encode %{
 8232     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8233     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8234     __ cmpxchgh(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, $tmp2$$Register,
 8235                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8236                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8237   %}
 8238   ins_pipe(pipe_class_default);
 8239 %}
 8240 
 8241 instruct weakCompareAndSwapI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8242   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8243   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8244   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8245   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8246   ins_encode %{
 8247     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8248     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8249     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8250                 MacroAssembler::MemBarNone,
 8251                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8252   %}
 8253   ins_pipe(pipe_class_default);
 8254 %}
 8255 
 8256 instruct weakCompareAndSwapI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8257   match(Set res (WeakCompareAndSwapI mem_ptr (Binary src1 src2)));
 8258   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8259   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8260   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8261   ins_encode %{
 8262     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8263     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8264     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8265     // value is never passed to caller.
 8266     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8267                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8268                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8269   %}
 8270   ins_pipe(pipe_class_default);
 8271 %}
 8272 
 8273 instruct weakCompareAndSwapN_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8274   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8275   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8276   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8277   format %{ &quot;weak CMPXCHGW $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8278   ins_encode %{
 8279     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8280     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8281     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8282                 MacroAssembler::MemBarNone,
 8283                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8284   %}
 8285   ins_pipe(pipe_class_default);
 8286 %}
 8287 
 8288 instruct weakCompareAndSwapN_acq_regP_regN_regN(iRegIdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8289   match(Set res (WeakCompareAndSwapN mem_ptr (Binary src1 src2)));
 8290   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8291   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8292   format %{ &quot;weak CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8293   ins_encode %{
 8294     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8295     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8296     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8297     // value is never passed to caller.
 8298     __ cmpxchgw(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8299                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8300                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, true, /*weak*/ true);
 8301   %}
 8302   ins_pipe(pipe_class_default);
 8303 %}
 8304 
 8305 instruct weakCompareAndSwapL_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8306   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8307   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8308   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8309   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8310   ins_encode %{
 8311     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8312     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8313     // value is never passed to caller.
 8314     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8315                 MacroAssembler::MemBarNone,
 8316                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8317   %}
 8318   ins_pipe(pipe_class_default);
 8319 %}
 8320 
 8321 instruct weakCompareAndSwapL_acq_regP_regL_regL(iRegIdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8322   match(Set res (WeakCompareAndSwapL mem_ptr (Binary src1 src2)));
 8323   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8324   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8325   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool&quot; %}
 8326   ins_encode %{
 8327     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8328     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8329     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8330     // value is never passed to caller.
 8331     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8332                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8333                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8334   %}
 8335   ins_pipe(pipe_class_default);
 8336 %}
 8337 
 8338 instruct weakCompareAndSwapP_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8339   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8340   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8341   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8342   format %{ &quot;weak CMPXCHGD $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8343   ins_encode %{
 8344     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8345     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8346     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8347                 MacroAssembler::MemBarNone,
 8348                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8349   %}
 8350   ins_pipe(pipe_class_default);
 8351 %}
 8352 
 8353 instruct weakCompareAndSwapP_acq_regP_regP_regP(iRegIdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8354   match(Set res (WeakCompareAndSwapP mem_ptr (Binary src1 src2)));
 8355   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8356   effect(TEMP_DEF res, TEMP cr0); // TEMP_DEF to avoid jump
 8357   format %{ &quot;weak CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as bool; ptr&quot; %}
 8358   ins_encode %{
 8359     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8360     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8361     // Acquire only needed in successful case. Weak node is allowed to report unsuccessful in additional rare cases and
 8362     // value is never passed to caller.
 8363     __ cmpxchgd(CCR0, R0, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8364                 support_IRIW_for_not_multiple_copy_atomic_cpu ? MacroAssembler::MemBarAcq : MacroAssembler::MemBarFenceAfter,
 8365                 MacroAssembler::cmpxchgx_hint_atomic_update(), $res$$Register, NULL, true, /*weak*/ true);
 8366   %}
 8367   ins_pipe(pipe_class_default);
 8368 %}
 8369 
 8370 // CompareAndExchange
 8371 
 8372 instruct compareAndExchangeB_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8373   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8374   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8375   effect(TEMP_DEF res, TEMP cr0);
 8376   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8377   ins_encode %{
 8378     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8379     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8380     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8381                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8382                 noreg, true);
 8383   %}
 8384   ins_pipe(pipe_class_default);
 8385 %}
 8386 
 8387 instruct compareAndExchangeB4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8388   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8389   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8390   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8391   format %{ &quot;CMPXCHGB $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8392   ins_encode %{
 8393     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8394     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8395     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8396                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8397                 noreg, true);
 8398   %}
 8399   ins_pipe(pipe_class_default);
 8400 %}
 8401 
 8402 instruct compareAndExchangeB_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8403   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8404   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8405   effect(TEMP_DEF res, TEMP cr0);
 8406   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8407   ins_encode %{
 8408     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8409     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8410     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8411                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8412                 noreg, true);
 8413     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8414       __ isync();
 8415     } else {
 8416       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8417       __ sync();
 8418     }
 8419   %}
 8420   ins_pipe(pipe_class_default);
 8421 %}
 8422 
 8423 instruct compareAndExchangeB4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8424   match(Set res (CompareAndExchangeB mem_ptr (Binary src1 src2)));
 8425   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8426   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8427   format %{ &quot;CMPXCHGB acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8428   ins_encode %{
 8429     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8430     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8431     __ cmpxchgb(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8432                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8433                 noreg, true);
 8434     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8435       __ isync();
 8436     } else {
 8437       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8438       __ sync();
 8439     }
 8440   %}
 8441   ins_pipe(pipe_class_default);
 8442 %}
 8443 
 8444 instruct compareAndExchangeS_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8445   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8446   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; VM_Version::has_lqarx());
 8447   effect(TEMP_DEF res, TEMP cr0);
 8448   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8449   ins_encode %{
 8450     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8451     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8452     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8453                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8454                 noreg, true);
 8455   %}
 8456   ins_pipe(pipe_class_default);
 8457 %}
 8458 
 8459 instruct compareAndExchangeS4_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8460   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8461   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst &amp;&amp; !VM_Version::has_lqarx());
 8462   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8463   format %{ &quot;CMPXCHGH $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8464   ins_encode %{
 8465     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8466     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8467     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8468                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8469                 noreg, true);
 8470   %}
 8471   ins_pipe(pipe_class_default);
 8472 %}
 8473 
 8474 instruct compareAndExchangeS_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8475   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8476   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; VM_Version::has_lqarx());
 8477   effect(TEMP_DEF res, TEMP cr0);
 8478   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8479   ins_encode %{
 8480     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8481     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8482     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, noreg, noreg,
 8483                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8484                 noreg, true);
 8485     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8486       __ isync();
 8487     } else {
 8488       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8489       __ sync();
 8490     }
 8491   %}
 8492   ins_pipe(pipe_class_default);
 8493 %}
 8494 
 8495 instruct compareAndExchangeS4_acq_regP_regI_regI(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src1, rarg4RegI src2, iRegIdst tmp1, flagsRegCR0 cr0) %{
 8496   match(Set res (CompareAndExchangeS mem_ptr (Binary src1 src2)));
 8497   predicate((((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst) &amp;&amp; !VM_Version::has_lqarx());
 8498   effect(TEMP_DEF res, USE_KILL src2, USE_KILL mem_ptr, TEMP tmp1, TEMP cr0);
 8499   format %{ &quot;CMPXCHGH acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8500   ins_encode %{
 8501     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8502     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8503     __ cmpxchgh(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register, $tmp1$$Register, R0,
 8504                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8505                 noreg, true);
 8506     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8507       __ isync();
 8508     } else {
 8509       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8510       __ sync();
 8511     }
 8512   %}
 8513   ins_pipe(pipe_class_default);
 8514 %}
 8515 
 8516 instruct compareAndExchangeI_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8517   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8518   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8519   effect(TEMP_DEF res, TEMP cr0);
 8520   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8521   ins_encode %{
 8522     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8523     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8524     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8525                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8526                 noreg, true);
 8527   %}
 8528   ins_pipe(pipe_class_default);
 8529 %}
 8530 
 8531 instruct compareAndExchangeI_acq_regP_regI_regI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
 8532   match(Set res (CompareAndExchangeI mem_ptr (Binary src1 src2)));
 8533   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8534   effect(TEMP_DEF res, TEMP cr0);
 8535   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as int&quot; %}
 8536   ins_encode %{
 8537     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8538     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8539     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8540                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8541                 noreg, true);
 8542     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8543       __ isync();
 8544     } else {
 8545       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8546       __ sync();
 8547     }
 8548   %}
 8549   ins_pipe(pipe_class_default);
 8550 %}
 8551 
 8552 instruct compareAndExchangeN_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8553   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8554   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8555   effect(TEMP_DEF res, TEMP cr0);
 8556   format %{ &quot;CMPXCHGW $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8557   ins_encode %{
 8558     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8559     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8560     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8561                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8562                 noreg, true);
 8563   %}
 8564   ins_pipe(pipe_class_default);
 8565 %}
 8566 
 8567 instruct compareAndExchangeN_acq_regP_regN_regN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src1, iRegNsrc src2, flagsRegCR0 cr0) %{
 8568   match(Set res (CompareAndExchangeN mem_ptr (Binary src1 src2)));
 8569   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8570   effect(TEMP_DEF res, TEMP cr0);
 8571   format %{ &quot;CMPXCHGW acq $res, $mem_ptr, $src1, $src2; as narrow oop&quot; %}
 8572   ins_encode %{
 8573     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8574     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8575     __ cmpxchgw(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8576                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8577                 noreg, true);
 8578     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8579       __ isync();
 8580     } else {
 8581       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8582       __ sync();
 8583     }
 8584   %}
 8585   ins_pipe(pipe_class_default);
 8586 %}
 8587 
 8588 instruct compareAndExchangeL_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8589   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8590   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8591   effect(TEMP_DEF res, TEMP cr0);
 8592   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8593   ins_encode %{
 8594     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8595     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8596     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8597                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8598                 noreg, NULL, true);
 8599   %}
 8600   ins_pipe(pipe_class_default);
 8601 %}
 8602 
 8603 instruct compareAndExchangeL_acq_regP_regL_regL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src1, iRegLsrc src2, flagsRegCR0 cr0) %{
 8604   match(Set res (CompareAndExchangeL mem_ptr (Binary src1 src2)));
 8605   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8606   effect(TEMP_DEF res, TEMP cr0);
 8607   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as long&quot; %}
 8608   ins_encode %{
 8609     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8610     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8611     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8612                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8613                 noreg, NULL, true);
 8614     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8615       __ isync();
 8616     } else {
 8617       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8618       __ sync();
 8619     }
 8620   %}
 8621   ins_pipe(pipe_class_default);
 8622 %}
 8623 
 8624 instruct compareAndExchangeP_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8625   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8626   predicate(((CompareAndSwapNode*)n)-&gt;order() != MemNode::acquire &amp;&amp; ((CompareAndSwapNode*)n)-&gt;order() != MemNode::seqcst);
 8627   effect(TEMP_DEF res, TEMP cr0);
 8628   format %{ &quot;CMPXCHGD $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8629   ins_encode %{
 8630     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8631     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8632     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8633                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8634                 noreg, NULL, true);
 8635   %}
 8636   ins_pipe(pipe_class_default);
 8637 %}
 8638 
 8639 instruct compareAndExchangeP_acq_regP_regP_regP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src1, iRegPsrc src2, flagsRegCR0 cr0) %{
 8640   match(Set res (CompareAndExchangeP mem_ptr (Binary src1 src2)));
 8641   predicate(((CompareAndSwapNode*)n)-&gt;order() == MemNode::acquire || ((CompareAndSwapNode*)n)-&gt;order() == MemNode::seqcst);
 8642   effect(TEMP_DEF res, TEMP cr0);
 8643   format %{ &quot;CMPXCHGD acq $res, $mem_ptr, $src1, $src2; as ptr; ptr&quot; %}
 8644   ins_encode %{
 8645     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
 8646     // CmpxchgX sets CCR0 to cmpX(src1, src2) and Rres to &#39;true&#39;/&#39;false&#39;.
 8647     __ cmpxchgd(CCR0, $res$$Register, $src1$$Register, $src2$$Register, $mem_ptr$$Register,
 8648                 MacroAssembler::MemBarNone, MacroAssembler::cmpxchgx_hint_atomic_update(),
 8649                 noreg, NULL, true);
 8650     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8651       __ isync();
 8652     } else {
 8653       // isync would be sufficient in case of CompareAndExchangeAcquire, but we currently don&#39;t optimize for that.
 8654       __ sync();
 8655     }
 8656   %}
 8657   ins_pipe(pipe_class_default);
 8658 %}
 8659 
 8660 // Special RMW
 8661 
 8662 instruct getAndAddB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8663   match(Set res (GetAndAddB mem_ptr src));
 8664   predicate(VM_Version::has_lqarx());
 8665   effect(TEMP_DEF res, TEMP cr0);
 8666   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8667   ins_encode %{
 8668     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8669                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8670     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8671       __ isync();
 8672     } else {
 8673       __ sync();
 8674     }
 8675   %}
 8676   ins_pipe(pipe_class_default);
 8677 %}
 8678 
 8679 instruct getAndAddB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8680   match(Set res (GetAndAddB mem_ptr src));
 8681   predicate(!VM_Version::has_lqarx());
 8682   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8683   format %{ &quot;GetAndAddB $res, $mem_ptr, $src&quot; %}
 8684   ins_encode %{
 8685     __ getandaddb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8686                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8687     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8688       __ isync();
 8689     } else {
 8690       __ sync();
 8691     }
 8692   %}
 8693   ins_pipe(pipe_class_default);
 8694 %}
 8695 
 8696 instruct getAndAddS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8697   match(Set res (GetAndAddS mem_ptr src));
 8698   predicate(VM_Version::has_lqarx());
 8699   effect(TEMP_DEF res, TEMP cr0);
 8700   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8701   ins_encode %{
 8702     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8703                   R0, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8704     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8705       __ isync();
 8706     } else {
 8707       __ sync();
 8708     }
 8709   %}
 8710   ins_pipe(pipe_class_default);
 8711 %}
 8712 
 8713 instruct getAndAddS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8714   match(Set res (GetAndAddS mem_ptr src));
 8715   predicate(!VM_Version::has_lqarx());
 8716   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8717   format %{ &quot;GetAndAddS $res, $mem_ptr, $src&quot; %}
 8718   ins_encode %{
 8719     __ getandaddh($res$$Register, $src$$Register, $mem_ptr$$Register,
 8720                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8721     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8722       __ isync();
 8723     } else {
 8724       __ sync();
 8725     }
 8726   %}
 8727   ins_pipe(pipe_class_default);
 8728 %}
 8729 
 8730 instruct getAndAddI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8731   match(Set res (GetAndAddI mem_ptr src));
 8732   effect(TEMP_DEF res, TEMP cr0);
 8733   format %{ &quot;GetAndAddI $res, $mem_ptr, $src&quot; %}
 8734   ins_encode %{
 8735     __ getandaddw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8736                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8737     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8738       __ isync();
 8739     } else {
 8740       __ sync();
 8741     }
 8742   %}
 8743   ins_pipe(pipe_class_default);
 8744 %}
 8745 
 8746 instruct getAndAddL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8747   match(Set res (GetAndAddL mem_ptr src));
 8748   effect(TEMP_DEF res, TEMP cr0);
 8749   format %{ &quot;GetAndAddL $res, $mem_ptr, $src&quot; %}
 8750   ins_encode %{
 8751     __ getandaddd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8752                   R0, MacroAssembler::cmpxchgx_hint_atomic_update());
 8753     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8754       __ isync();
 8755     } else {
 8756       __ sync();
 8757     }
 8758   %}
 8759   ins_pipe(pipe_class_default);
 8760 %}
 8761 
 8762 instruct getAndSetB(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8763   match(Set res (GetAndSetB mem_ptr src));
 8764   predicate(VM_Version::has_lqarx());
 8765   effect(TEMP_DEF res, TEMP cr0);
 8766   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8767   ins_encode %{
 8768     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8769                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8770     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8771       __ isync();
 8772     } else {
 8773       __ sync();
 8774     }
 8775   %}
 8776   ins_pipe(pipe_class_default);
 8777 %}
 8778 
 8779 instruct getAndSetB4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8780   match(Set res (GetAndSetB mem_ptr src));
 8781   predicate(!VM_Version::has_lqarx());
 8782   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8783   format %{ &quot;GetAndSetB $res, $mem_ptr, $src&quot; %}
 8784   ins_encode %{
 8785     __ getandsetb($res$$Register, $src$$Register, $mem_ptr$$Register,
 8786                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8787     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8788       __ isync();
 8789     } else {
 8790       __ sync();
 8791     }
 8792   %}
 8793   ins_pipe(pipe_class_default);
 8794 %}
 8795 
 8796 instruct getAndSetS(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8797   match(Set res (GetAndSetS mem_ptr src));
 8798   predicate(VM_Version::has_lqarx());
 8799   effect(TEMP_DEF res, TEMP cr0);
 8800   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8801   ins_encode %{
 8802     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8803                   noreg, noreg, noreg, MacroAssembler::cmpxchgx_hint_atomic_update());
 8804     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8805       __ isync();
 8806     } else {
 8807       __ sync();
 8808     }
 8809   %}
 8810   ins_pipe(pipe_class_default);
 8811 %}
 8812 
 8813 instruct getAndSetS4(iRegIdst res, rarg3RegP mem_ptr, iRegIsrc src, iRegIsrc tmp1, iRegIsrc tmp2, flagsRegCR0 cr0) %{
 8814   match(Set res (GetAndSetS mem_ptr src));
 8815   predicate(!VM_Version::has_lqarx());
 8816   effect(TEMP_DEF res, USE_KILL mem_ptr, TEMP tmp1, TEMP tmp2, TEMP cr0);
 8817   format %{ &quot;GetAndSetS $res, $mem_ptr, $src&quot; %}
 8818   ins_encode %{
 8819     __ getandseth($res$$Register, $src$$Register, $mem_ptr$$Register,
 8820                   R0, $tmp1$$Register, $tmp2$$Register, MacroAssembler::cmpxchgx_hint_atomic_update());
 8821     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8822       __ isync();
 8823     } else {
 8824       __ sync();
 8825     }
 8826   %}
 8827   ins_pipe(pipe_class_default);
 8828 %}
 8829 
 8830 instruct getAndSetI(iRegIdst res, iRegPdst mem_ptr, iRegIsrc src, flagsRegCR0 cr0) %{
 8831   match(Set res (GetAndSetI mem_ptr src));
 8832   effect(TEMP_DEF res, TEMP cr0);
 8833   format %{ &quot;GetAndSetI $res, $mem_ptr, $src&quot; %}
 8834   ins_encode %{
 8835     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8836                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8837     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8838       __ isync();
 8839     } else {
 8840       __ sync();
 8841     }
 8842   %}
 8843   ins_pipe(pipe_class_default);
 8844 %}
 8845 
 8846 instruct getAndSetL(iRegLdst res, iRegPdst mem_ptr, iRegLsrc src, flagsRegCR0 cr0) %{
 8847   match(Set res (GetAndSetL mem_ptr src));
 8848   effect(TEMP_DEF res, TEMP cr0);
 8849   format %{ &quot;GetAndSetL $res, $mem_ptr, $src&quot; %}
 8850   ins_encode %{
 8851     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8852                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8853     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8854       __ isync();
 8855     } else {
 8856       __ sync();
 8857     }
 8858   %}
 8859   ins_pipe(pipe_class_default);
 8860 %}
 8861 
 8862 instruct getAndSetP(iRegPdst res, iRegPdst mem_ptr, iRegPsrc src, flagsRegCR0 cr0) %{
 8863   match(Set res (GetAndSetP mem_ptr src));
 8864   effect(TEMP_DEF res, TEMP cr0);
 8865   format %{ &quot;GetAndSetP $res, $mem_ptr, $src&quot; %}
 8866   ins_encode %{
 8867     __ getandsetd($res$$Register, $src$$Register, $mem_ptr$$Register,
 8868                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8869     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8870       __ isync();
 8871     } else {
 8872       __ sync();
 8873     }
 8874   %}
 8875   ins_pipe(pipe_class_default);
 8876 %}
 8877 
 8878 instruct getAndSetN(iRegNdst res, iRegPdst mem_ptr, iRegNsrc src, flagsRegCR0 cr0) %{
 8879   match(Set res (GetAndSetN mem_ptr src));
 8880   effect(TEMP_DEF res, TEMP cr0);
 8881   format %{ &quot;GetAndSetN $res, $mem_ptr, $src&quot; %}
 8882   ins_encode %{
 8883     __ getandsetw($res$$Register, $src$$Register, $mem_ptr$$Register,
 8884                   MacroAssembler::cmpxchgx_hint_atomic_update());
 8885     if (support_IRIW_for_not_multiple_copy_atomic_cpu) {
 8886       __ isync();
 8887     } else {
 8888       __ sync();
 8889     }
 8890   %}
 8891   ins_pipe(pipe_class_default);
 8892 %}
 8893 
 8894 //----------Arithmetic Instructions--------------------------------------------
 8895 // Addition Instructions
 8896 
 8897 // Register Addition
 8898 instruct addI_reg_reg(iRegIdst dst, iRegIsrc_iRegL2Isrc src1, iRegIsrc_iRegL2Isrc src2) %{
 8899   match(Set dst (AddI src1 src2));
 8900   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8901   size(4);
 8902   ins_encode %{
 8903     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8904     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8905   %}
 8906   ins_pipe(pipe_class_default);
 8907 %}
 8908 
 8909 // Expand does not work with above instruct. (??)
 8910 instruct addI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 8911   // no match-rule
 8912   effect(DEF dst, USE src1, USE src2);
 8913   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 8914   size(4);
 8915   ins_encode %{
 8916     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8917     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8918   %}
 8919   ins_pipe(pipe_class_default);
 8920 %}
 8921 
 8922 instruct tree_addI_addI_addI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
 8923   match(Set dst (AddI (AddI (AddI src1 src2) src3) src4));
 8924   ins_cost(DEFAULT_COST*3);
 8925 
 8926   expand %{
 8927     // FIXME: we should do this in the ideal world.
 8928     iRegIdst tmp1;
 8929     iRegIdst tmp2;
 8930     addI_reg_reg(tmp1, src1, src2);
 8931     addI_reg_reg_2(tmp2, src3, src4); // Adlc complains about addI_reg_reg.
 8932     addI_reg_reg(dst, tmp1, tmp2);
 8933   %}
 8934 %}
 8935 
 8936 // Immediate Addition
 8937 instruct addI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 8938   match(Set dst (AddI src1 src2));
 8939   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 8940   size(4);
 8941   ins_encode %{
 8942     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 8943     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 8944   %}
 8945   ins_pipe(pipe_class_default);
 8946 %}
 8947 
 8948 // Immediate Addition with 16-bit shifted operand
 8949 instruct addI_reg_immhi16(iRegIdst dst, iRegIsrc src1, immIhi16 src2) %{
 8950   match(Set dst (AddI src1 src2));
 8951   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 8952   size(4);
 8953   ins_encode %{
 8954     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 8955     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 8956   %}
 8957   ins_pipe(pipe_class_default);
 8958 %}
 8959 
 8960 // Long Addition
 8961 instruct addL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8962   match(Set dst (AddL src1 src2));
 8963   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8964   size(4);
 8965   ins_encode %{
 8966     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8967     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8968   %}
 8969   ins_pipe(pipe_class_default);
 8970 %}
 8971 
 8972 // Expand does not work with above instruct. (??)
 8973 instruct addL_reg_reg_2(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 8974   // no match-rule
 8975   effect(DEF dst, USE src1, USE src2);
 8976   format %{ &quot;ADD     $dst, $src1, $src2 \t// long&quot; %}
 8977   size(4);
 8978   ins_encode %{
 8979     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 8980     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 8981   %}
 8982   ins_pipe(pipe_class_default);
 8983 %}
 8984 
 8985 instruct tree_addL_addL_addL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2, iRegLsrc src3, iRegLsrc src4) %{
 8986   match(Set dst (AddL (AddL (AddL src1 src2) src3) src4));
 8987   ins_cost(DEFAULT_COST*3);
 8988 
 8989   expand %{
 8990     // FIXME: we should do this in the ideal world.
 8991     iRegLdst tmp1;
 8992     iRegLdst tmp2;
 8993     addL_reg_reg(tmp1, src1, src2);
 8994     addL_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
 8995     addL_reg_reg(dst, tmp1, tmp2);
 8996   %}
 8997 %}
 8998 
 8999 // AddL + ConvL2I.
 9000 instruct addI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9001   match(Set dst (ConvL2I (AddL src1 src2)));
 9002 
 9003   format %{ &quot;ADD     $dst, $src1, $src2 \t// long + l2i&quot; %}
 9004   size(4);
 9005   ins_encode %{
 9006     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9007     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9008   %}
 9009   ins_pipe(pipe_class_default);
 9010 %}
 9011 
 9012 // No constant pool entries required.
 9013 instruct addL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9014   match(Set dst (AddL src1 src2));
 9015 
 9016   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9017   size(4);
 9018   ins_encode %{
 9019     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9020     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9021   %}
 9022   ins_pipe(pipe_class_default);
 9023 %}
 9024 
 9025 // Long Immediate Addition with 16-bit shifted operand.
 9026 // No constant pool entries required.
 9027 instruct addL_reg_immhi16(iRegLdst dst, iRegLsrc src1, immL32hi16 src2) %{
 9028   match(Set dst (AddL src1 src2));
 9029 
 9030   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9031   size(4);
 9032   ins_encode %{
 9033     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9034     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9035   %}
 9036   ins_pipe(pipe_class_default);
 9037 %}
 9038 
 9039 // Pointer Register Addition
 9040 instruct addP_reg_reg(iRegPdst dst, iRegP_N2P src1, iRegLsrc src2) %{
 9041   match(Set dst (AddP src1 src2));
 9042   format %{ &quot;ADD     $dst, $src1, $src2&quot; %}
 9043   size(4);
 9044   ins_encode %{
 9045     // TODO: PPC port $archOpcode(ppc64Opcode_add);
 9046     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 9047   %}
 9048   ins_pipe(pipe_class_default);
 9049 %}
 9050 
 9051 // Pointer Immediate Addition
 9052 // No constant pool entries required.
 9053 instruct addP_reg_imm16(iRegPdst dst, iRegP_N2P src1, immL16 src2) %{
 9054   match(Set dst (AddP src1 src2));
 9055 
 9056   format %{ &quot;ADDI    $dst, $src1, $src2&quot; %}
 9057   size(4);
 9058   ins_encode %{
 9059     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
 9060     __ addi($dst$$Register, $src1$$Register, $src2$$constant);
 9061   %}
 9062   ins_pipe(pipe_class_default);
 9063 %}
 9064 
 9065 // Pointer Immediate Addition with 16-bit shifted operand.
 9066 // No constant pool entries required.
 9067 instruct addP_reg_immhi16(iRegPdst dst, iRegP_N2P src1, immL32hi16 src2) %{
 9068   match(Set dst (AddP src1 src2));
 9069 
 9070   format %{ &quot;ADDIS   $dst, $src1, $src2&quot; %}
 9071   size(4);
 9072   ins_encode %{
 9073     // TODO: PPC port $archOpcode(ppc64Opcode_addis);
 9074     __ addis($dst$$Register, $src1$$Register, ($src2$$constant)&gt;&gt;16);
 9075   %}
 9076   ins_pipe(pipe_class_default);
 9077 %}
 9078 
 9079 //---------------------
 9080 // Subtraction Instructions
 9081 
 9082 // Register Subtraction
 9083 instruct subI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9084   match(Set dst (SubI src1 src2));
 9085   format %{ &quot;SUBF    $dst, $src2, $src1&quot; %}
 9086   size(4);
 9087   ins_encode %{
 9088     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9089     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9090   %}
 9091   ins_pipe(pipe_class_default);
 9092 %}
 9093 
 9094 // Immediate Subtraction
 9095 // Immediate Subtraction: The compiler converts &quot;x-c0&quot; into &quot;x+ -c0&quot; (see SubLNode::Ideal),
 9096 // Don&#39;t try to use addi with - $src2$$constant since it can overflow when $src2$$constant == minI16.
 9097 
 9098 // SubI from constant (using subfic).
 9099 instruct subI_imm16_reg(iRegIdst dst, immI16 src1, iRegIsrc src2) %{
 9100   match(Set dst (SubI src1 src2));
 9101   format %{ &quot;SUBI    $dst, $src1, $src2&quot; %}
 9102 
 9103   size(4);
 9104   ins_encode %{
 9105     // TODO: PPC port $archOpcode(ppc64Opcode_subfic);
 9106     __ subfic($dst$$Register, $src2$$Register, $src1$$constant);
 9107   %}
 9108   ins_pipe(pipe_class_default);
 9109 %}
 9110 
 9111 // Turn the sign-bit of an integer into a 32-bit mask, 0x0...0 for
 9112 // positive integers and 0xF...F for negative ones.
 9113 instruct signmask32I_regI(iRegIdst dst, iRegIsrc src) %{
 9114   // no match-rule, false predicate
 9115   effect(DEF dst, USE src);
 9116   predicate(false);
 9117 
 9118   format %{ &quot;SRAWI   $dst, $src, #31&quot; %}
 9119   size(4);
 9120   ins_encode %{
 9121     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9122     __ srawi($dst$$Register, $src$$Register, 0x1f);
 9123   %}
 9124   ins_pipe(pipe_class_default);
 9125 %}
 9126 
 9127 instruct absI_reg_Ex(iRegIdst dst, iRegIsrc src) %{
 9128   match(Set dst (AbsI src));
 9129   ins_cost(DEFAULT_COST*3);
 9130 
 9131   expand %{
 9132     iRegIdst tmp1;
 9133     iRegIdst tmp2;
 9134     signmask32I_regI(tmp1, src);
 9135     xorI_reg_reg(tmp2, tmp1, src);
 9136     subI_reg_reg(dst, tmp2, tmp1);
 9137   %}
 9138 %}
 9139 
 9140 instruct negI_regI(iRegIdst dst, immI_0 zero, iRegIsrc src2) %{
 9141   match(Set dst (SubI zero src2));
 9142   format %{ &quot;NEG     $dst, $src2&quot; %}
 9143   size(4);
 9144   ins_encode %{
 9145     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9146     __ neg($dst$$Register, $src2$$Register);
 9147   %}
 9148   ins_pipe(pipe_class_default);
 9149 %}
 9150 
 9151 // Long subtraction
 9152 instruct subL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9153   match(Set dst (SubL src1 src2));
 9154   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long&quot; %}
 9155   size(4);
 9156   ins_encode %{
 9157     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9158     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9159   %}
 9160   ins_pipe(pipe_class_default);
 9161 %}
 9162 
 9163 // SubL + convL2I.
 9164 instruct subI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9165   match(Set dst (ConvL2I (SubL src1 src2)));
 9166 
 9167   format %{ &quot;SUBF    $dst, $src2, $src1 \t// long + l2i&quot; %}
 9168   size(4);
 9169   ins_encode %{
 9170     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
 9171     __ subf($dst$$Register, $src2$$Register, $src1$$Register);
 9172   %}
 9173   ins_pipe(pipe_class_default);
 9174 %}
 9175 
 9176 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9177 // positive longs and 0xF...F for negative ones.
 9178 instruct signmask64I_regL(iRegIdst dst, iRegLsrc src) %{
 9179   // no match-rule, false predicate
 9180   effect(DEF dst, USE src);
 9181   predicate(false);
 9182 
 9183   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9184   size(4);
 9185   ins_encode %{
 9186     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9187     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9188   %}
 9189   ins_pipe(pipe_class_default);
 9190 %}
 9191 
 9192 // Turn the sign-bit of a long into a 64-bit mask, 0x0...0 for
 9193 // positive longs and 0xF...F for negative ones.
 9194 instruct signmask64L_regL(iRegLdst dst, iRegLsrc src) %{
 9195   // no match-rule, false predicate
 9196   effect(DEF dst, USE src);
 9197   predicate(false);
 9198 
 9199   format %{ &quot;SRADI   $dst, $src, #63&quot; %}
 9200   size(4);
 9201   ins_encode %{
 9202     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9203     __ sradi($dst$$Register, $src$$Register, 0x3f);
 9204   %}
 9205   ins_pipe(pipe_class_default);
 9206 %}
 9207 
 9208 // Long negation
 9209 instruct negL_reg_reg(iRegLdst dst, immL_0 zero, iRegLsrc src2) %{
 9210   match(Set dst (SubL zero src2));
 9211   format %{ &quot;NEG     $dst, $src2 \t// long&quot; %}
 9212   size(4);
 9213   ins_encode %{
 9214     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9215     __ neg($dst$$Register, $src2$$Register);
 9216   %}
 9217   ins_pipe(pipe_class_default);
 9218 %}
 9219 
 9220 // NegL + ConvL2I.
 9221 instruct negI_con0_regL(iRegIdst dst, immL_0 zero, iRegLsrc src2) %{
 9222   match(Set dst (ConvL2I (SubL zero src2)));
 9223 
 9224   format %{ &quot;NEG     $dst, $src2 \t// long + l2i&quot; %}
 9225   size(4);
 9226   ins_encode %{
 9227     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9228     __ neg($dst$$Register, $src2$$Register);
 9229   %}
 9230   ins_pipe(pipe_class_default);
 9231 %}
 9232 
 9233 // Multiplication Instructions
 9234 // Integer Multiplication
 9235 
 9236 // Register Multiplication
 9237 instruct mulI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9238   match(Set dst (MulI src1 src2));
 9239   ins_cost(DEFAULT_COST);
 9240 
 9241   format %{ &quot;MULLW   $dst, $src1, $src2&quot; %}
 9242   size(4);
 9243   ins_encode %{
 9244     // TODO: PPC port $archOpcode(ppc64Opcode_mullw);
 9245     __ mullw($dst$$Register, $src1$$Register, $src2$$Register);
 9246   %}
 9247   ins_pipe(pipe_class_default);
 9248 %}
 9249 
 9250 // Immediate Multiplication
 9251 instruct mulI_reg_imm16(iRegIdst dst, iRegIsrc src1, immI16 src2) %{
 9252   match(Set dst (MulI src1 src2));
 9253   ins_cost(DEFAULT_COST);
 9254 
 9255   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9256   size(4);
 9257   ins_encode %{
 9258     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9259     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9260   %}
 9261   ins_pipe(pipe_class_default);
 9262 %}
 9263 
 9264 instruct mulL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9265   match(Set dst (MulL src1 src2));
 9266   ins_cost(DEFAULT_COST);
 9267 
 9268   format %{ &quot;MULLD   $dst $src1, $src2 \t// long&quot; %}
 9269   size(4);
 9270   ins_encode %{
 9271     // TODO: PPC port $archOpcode(ppc64Opcode_mulld);
 9272     __ mulld($dst$$Register, $src1$$Register, $src2$$Register);
 9273   %}
 9274   ins_pipe(pipe_class_default);
 9275 %}
 9276 
 9277 // Multiply high for optimized long division by constant.
 9278 instruct mulHighL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9279   match(Set dst (MulHiL src1 src2));
 9280   ins_cost(DEFAULT_COST);
 9281 
 9282   format %{ &quot;MULHD   $dst $src1, $src2 \t// long&quot; %}
 9283   size(4);
 9284   ins_encode %{
 9285     // TODO: PPC port $archOpcode(ppc64Opcode_mulhd);
 9286     __ mulhd($dst$$Register, $src1$$Register, $src2$$Register);
 9287   %}
 9288   ins_pipe(pipe_class_default);
 9289 %}
 9290 
 9291 // Immediate Multiplication
 9292 instruct mulL_reg_imm16(iRegLdst dst, iRegLsrc src1, immL16 src2) %{
 9293   match(Set dst (MulL src1 src2));
 9294   ins_cost(DEFAULT_COST);
 9295 
 9296   format %{ &quot;MULLI   $dst, $src1, $src2&quot; %}
 9297   size(4);
 9298   ins_encode %{
 9299     // TODO: PPC port $archOpcode(ppc64Opcode_mulli);
 9300     __ mulli($dst$$Register, $src1$$Register, $src2$$constant);
 9301   %}
 9302   ins_pipe(pipe_class_default);
 9303 %}
 9304 
 9305 // Integer Division with Immediate -1: Negate.
 9306 instruct divI_reg_immIvalueMinus1(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
 9307   match(Set dst (DivI src1 src2));
 9308   ins_cost(DEFAULT_COST);
 9309 
 9310   format %{ &quot;NEG     $dst, $src1 \t// /-1&quot; %}
 9311   size(4);
 9312   ins_encode %{
 9313     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9314     __ neg($dst$$Register, $src1$$Register);
 9315   %}
 9316   ins_pipe(pipe_class_default);
 9317 %}
 9318 
 9319 // Integer Division with constant, but not -1.
 9320 // We should be able to improve this by checking the type of src2.
 9321 // It might well be that src2 is known to be positive.
 9322 instruct divI_reg_regnotMinus1(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9323   match(Set dst (DivI src1 src2));
 9324   predicate(n-&gt;in(2)-&gt;find_int_con(-1) != -1); // src2 is a constant, but not -1
 9325   ins_cost(2*DEFAULT_COST);
 9326 
 9327   format %{ &quot;DIVW    $dst, $src1, $src2 \t// /not-1&quot; %}
 9328   size(4);
 9329   ins_encode %{
 9330     // TODO: PPC port $archOpcode(ppc64Opcode_divw);
 9331     __ divw($dst$$Register, $src1$$Register, $src2$$Register);
 9332   %}
 9333   ins_pipe(pipe_class_default);
 9334 %}
 9335 
 9336 instruct cmovI_bne_negI_reg(iRegIdst dst, flagsRegSrc crx, iRegIsrc src1) %{
 9337   effect(USE_DEF dst, USE src1, USE crx);
 9338   predicate(false);
 9339 
 9340   ins_variable_size_depending_on_alignment(true);
 9341 
 9342   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9343   // Worst case is branch + move + stop, no stop without scheduler.
 9344   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9345   ins_encode %{
 9346     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9347     Label done;
 9348     __ bne($crx$$CondRegister, done);
 9349     __ neg($dst$$Register, $src1$$Register);
 9350     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9351     __ bind(done);
 9352   %}
 9353   ins_pipe(pipe_class_default);
 9354 %}
 9355 
 9356 // Integer Division with Registers not containing constants.
 9357 instruct divI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9358   match(Set dst (DivI src1 src2));
 9359   ins_cost(10*DEFAULT_COST);
 9360 
 9361   expand %{
 9362     immI16 imm %{ (int)-1 %}
 9363     flagsReg tmp1;
 9364     cmpI_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9365     divI_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9366     cmovI_bne_negI_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9367   %}
 9368 %}
 9369 
 9370 // Long Division with Immediate -1: Negate.
 9371 instruct divL_reg_immLvalueMinus1(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
 9372   match(Set dst (DivL src1 src2));
 9373   ins_cost(DEFAULT_COST);
 9374 
 9375   format %{ &quot;NEG     $dst, $src1 \t// /-1, long&quot; %}
 9376   size(4);
 9377   ins_encode %{
 9378     // TODO: PPC port $archOpcode(ppc64Opcode_neg);
 9379     __ neg($dst$$Register, $src1$$Register);
 9380   %}
 9381   ins_pipe(pipe_class_default);
 9382 %}
 9383 
 9384 // Long Division with constant, but not -1.
 9385 instruct divL_reg_regnotMinus1(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9386   match(Set dst (DivL src1 src2));
 9387   predicate(n-&gt;in(2)-&gt;find_long_con(-1L) != -1L); // Src2 is a constant, but not -1.
 9388   ins_cost(2*DEFAULT_COST);
 9389 
 9390   format %{ &quot;DIVD    $dst, $src1, $src2 \t// /not-1, long&quot; %}
 9391   size(4);
 9392   ins_encode %{
 9393     // TODO: PPC port $archOpcode(ppc64Opcode_divd);
 9394     __ divd($dst$$Register, $src1$$Register, $src2$$Register);
 9395   %}
 9396   ins_pipe(pipe_class_default);
 9397 %}
 9398 
 9399 instruct cmovL_bne_negL_reg(iRegLdst dst, flagsRegSrc crx, iRegLsrc src1) %{
 9400   effect(USE_DEF dst, USE src1, USE crx);
 9401   predicate(false);
 9402 
 9403   ins_variable_size_depending_on_alignment(true);
 9404 
 9405   format %{ &quot;CMOVE   $dst, neg($src1), $crx&quot; %}
 9406   // Worst case is branch + move + stop, no stop without scheduler.
 9407   size((false /* TODO: PPC PORT (InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
 9408   ins_encode %{
 9409     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
 9410     Label done;
 9411     __ bne($crx$$CondRegister, done);
 9412     __ neg($dst$$Register, $src1$$Register);
 9413     // TODO PPC port __ endgroup_if_needed(_size == 12);
 9414     __ bind(done);
 9415   %}
 9416   ins_pipe(pipe_class_default);
 9417 %}
 9418 
 9419 // Long Division with Registers not containing constants.
 9420 instruct divL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9421   match(Set dst (DivL src1 src2));
 9422   ins_cost(10*DEFAULT_COST);
 9423 
 9424   expand %{
 9425     immL16 imm %{ (int)-1 %}
 9426     flagsReg tmp1;
 9427     cmpL_reg_imm16(tmp1, src2, imm);          // check src2 == -1
 9428     divL_reg_regnotMinus1(dst, src1, src2);   // dst = src1 / src2
 9429     cmovL_bne_negL_reg(dst, tmp1, src1);      // cmove dst = neg(src1) if src2 == -1
 9430   %}
 9431 %}
 9432 
 9433 // Integer Remainder with registers.
 9434 instruct modI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9435   match(Set dst (ModI src1 src2));
 9436   ins_cost(10*DEFAULT_COST);
 9437 
 9438   expand %{
 9439     immI16 imm %{ (int)-1 %}
 9440     flagsReg tmp1;
 9441     iRegIdst tmp2;
 9442     iRegIdst tmp3;
 9443     cmpI_reg_imm16(tmp1, src2, imm);           // check src2 == -1
 9444     divI_reg_regnotMinus1(tmp2, src1, src2);   // tmp2 = src1 / src2
 9445     cmovI_bne_negI_reg(tmp2, tmp1, src1);      // cmove tmp2 = neg(src1) if src2 == -1
 9446     mulI_reg_reg(tmp3, src2, tmp2);            // tmp3 = src2 * tmp2
 9447     subI_reg_reg(dst, src1, tmp3);             // dst = src1 - tmp3
 9448   %}
 9449 %}
 9450 
 9451 // Long Remainder with registers
 9452 instruct modL_reg_reg_Ex(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
 9453   match(Set dst (ModL src1 src2));
 9454   ins_cost(10*DEFAULT_COST);
 9455 
 9456   expand %{
 9457     immL16 imm %{ (int)-1 %}
 9458     flagsReg tmp1;
 9459     iRegLdst tmp2;
 9460     iRegLdst tmp3;
 9461     cmpL_reg_imm16(tmp1, src2, imm);             // check src2 == -1
 9462     divL_reg_regnotMinus1(tmp2, src1, src2);     // tmp2 = src1 / src2
 9463     cmovL_bne_negL_reg(tmp2, tmp1, src1);        // cmove tmp2 = neg(src1) if src2 == -1
 9464     mulL_reg_reg(tmp3, src2, tmp2);              // tmp3 = src2 * tmp2
 9465     subL_reg_reg(dst, src1, tmp3);               // dst = src1 - tmp3
 9466   %}
 9467 %}
 9468 
 9469 // Integer Shift Instructions
 9470 
 9471 // Register Shift Left
 9472 
 9473 // Clear all but the lowest #mask bits.
 9474 // Used to normalize shift amounts in registers.
 9475 instruct maskI_reg_imm(iRegIdst dst, iRegIsrc src, uimmI6 mask) %{
 9476   // no match-rule, false predicate
 9477   effect(DEF dst, USE src, USE mask);
 9478   predicate(false);
 9479 
 9480   format %{ &quot;MASK    $dst, $src, $mask \t// clear $mask upper bits&quot; %}
 9481   size(4);
 9482   ins_encode %{
 9483     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9484     __ clrldi($dst$$Register, $src$$Register, $mask$$constant);
 9485   %}
 9486   ins_pipe(pipe_class_default);
 9487 %}
 9488 
 9489 instruct lShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9490   // no match-rule, false predicate
 9491   effect(DEF dst, USE src1, USE src2);
 9492   predicate(false);
 9493 
 9494   format %{ &quot;SLW     $dst, $src1, $src2&quot; %}
 9495   size(4);
 9496   ins_encode %{
 9497     // TODO: PPC port $archOpcode(ppc64Opcode_slw);
 9498     __ slw($dst$$Register, $src1$$Register, $src2$$Register);
 9499   %}
 9500   ins_pipe(pipe_class_default);
 9501 %}
 9502 
 9503 instruct lShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9504   match(Set dst (LShiftI src1 src2));
 9505   ins_cost(DEFAULT_COST*2);
 9506   expand %{
 9507     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9508     iRegIdst tmpI;
 9509     maskI_reg_imm(tmpI, src2, mask);
 9510     lShiftI_reg_reg(dst, src1, tmpI);
 9511   %}
 9512 %}
 9513 
 9514 // Register Shift Left Immediate
 9515 instruct lShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9516   match(Set dst (LShiftI src1 src2));
 9517 
 9518   format %{ &quot;SLWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9519   size(4);
 9520   ins_encode %{
 9521     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9522     __ slwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9523   %}
 9524   ins_pipe(pipe_class_default);
 9525 %}
 9526 
 9527 // AndI with negpow2-constant + LShiftI
 9528 instruct lShiftI_andI_immInegpow2_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9529   match(Set dst (LShiftI (AndI src1 src2) src3));
 9530   predicate(UseRotateAndMaskInstructionsPPC64);
 9531 
 9532   format %{ &quot;RLWINM  $dst, lShiftI(AndI($src1, $src2), $src3)&quot; %}
 9533   size(4);
 9534   ins_encode %{
 9535     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9536     long src2      = $src2$$constant;
 9537     long src3      = $src3$$constant;
 9538     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9539     if (maskbits &gt;= 32) {
 9540       __ li($dst$$Register, 0); // addi
 9541     } else {
 9542       __ rlwinm($dst$$Register, $src1$$Register, src3 &amp; 0x1f, 0, (31-maskbits) &amp; 0x1f);
 9543     }
 9544   %}
 9545   ins_pipe(pipe_class_default);
 9546 %}
 9547 
 9548 // RShiftI + AndI with negpow2-constant + LShiftI
 9549 instruct lShiftI_andI_immInegpow2_rShiftI_imm5(iRegIdst dst, iRegIsrc src1, immInegpow2 src2, uimmI5 src3) %{
 9550   match(Set dst (LShiftI (AndI (RShiftI src1 src3) src2) src3));
 9551   predicate(UseRotateAndMaskInstructionsPPC64);
 9552 
 9553   format %{ &quot;RLWINM  $dst, lShiftI(AndI(RShiftI($src1, $src3), $src2), $src3)&quot; %}
 9554   size(4);
 9555   ins_encode %{
 9556     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm); // FIXME: assert that rlwinm is equal to addi
 9557     long src2      = $src2$$constant;
 9558     long src3      = $src3$$constant;
 9559     long maskbits  = src3 + log2_long((jlong) (julong) (juint) -src2);
 9560     if (maskbits &gt;= 32) {
 9561       __ li($dst$$Register, 0); // addi
 9562     } else {
 9563       __ rlwinm($dst$$Register, $src1$$Register, 0, 0, (31-maskbits) &amp; 0x1f);
 9564     }
 9565   %}
 9566   ins_pipe(pipe_class_default);
 9567 %}
 9568 
 9569 instruct lShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9570   // no match-rule, false predicate
 9571   effect(DEF dst, USE src1, USE src2);
 9572   predicate(false);
 9573 
 9574   format %{ &quot;SLD     $dst, $src1, $src2&quot; %}
 9575   size(4);
 9576   ins_encode %{
 9577     // TODO: PPC port $archOpcode(ppc64Opcode_sld);
 9578     __ sld($dst$$Register, $src1$$Register, $src2$$Register);
 9579   %}
 9580   ins_pipe(pipe_class_default);
 9581 %}
 9582 
 9583 // Register Shift Left
 9584 instruct lShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9585   match(Set dst (LShiftL src1 src2));
 9586   ins_cost(DEFAULT_COST*2);
 9587   expand %{
 9588     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9589     iRegIdst tmpI;
 9590     maskI_reg_imm(tmpI, src2, mask);
 9591     lShiftL_regL_regI(dst, src1, tmpI);
 9592   %}
 9593 %}
 9594 
 9595 // Register Shift Left Immediate
 9596 instruct lshiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9597   match(Set dst (LShiftL src1 src2));
 9598   format %{ &quot;SLDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9599   size(4);
 9600   ins_encode %{
 9601     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9602     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9603   %}
 9604   ins_pipe(pipe_class_default);
 9605 %}
 9606 
 9607 // If we shift more than 32 bits, we need not convert I2L.
 9608 instruct lShiftL_regI_immGE32(iRegLdst dst, iRegIsrc src1, uimmI6_ge32 src2) %{
 9609   match(Set dst (LShiftL (ConvI2L src1) src2));
 9610   ins_cost(DEFAULT_COST);
 9611 
 9612   size(4);
 9613   format %{ &quot;SLDI    $dst, i2l($src1), $src2&quot; %}
 9614   ins_encode %{
 9615     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
 9616     __ sldi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9617   %}
 9618   ins_pipe(pipe_class_default);
 9619 %}
 9620 
 9621 // Shift a postivie int to the left.
 9622 // Clrlsldi clears the upper 32 bits and shifts.
 9623 instruct scaledPositiveI2L_lShiftL_convI2L_reg_imm6(iRegLdst dst, iRegIsrc src1, uimmI6 src2) %{
 9624   match(Set dst (LShiftL (ConvI2L src1) src2));
 9625   predicate(((ConvI2LNode*)(_kids[0]-&gt;_leaf))-&gt;type()-&gt;is_long()-&gt;is_positive_int());
 9626 
 9627   format %{ &quot;SLDI    $dst, i2l(positive_int($src1)), $src2&quot; %}
 9628   size(4);
 9629   ins_encode %{
 9630     // TODO: PPC port $archOpcode(ppc64Opcode_rldic);
 9631     __ clrlsldi($dst$$Register, $src1$$Register, 0x20, $src2$$constant);
 9632   %}
 9633   ins_pipe(pipe_class_default);
 9634 %}
 9635 
 9636 instruct arShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9637   // no match-rule, false predicate
 9638   effect(DEF dst, USE src1, USE src2);
 9639   predicate(false);
 9640 
 9641   format %{ &quot;SRAW    $dst, $src1, $src2&quot; %}
 9642   size(4);
 9643   ins_encode %{
 9644     // TODO: PPC port $archOpcode(ppc64Opcode_sraw);
 9645     __ sraw($dst$$Register, $src1$$Register, $src2$$Register);
 9646   %}
 9647   ins_pipe(pipe_class_default);
 9648 %}
 9649 
 9650 // Register Arithmetic Shift Right
 9651 instruct arShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9652   match(Set dst (RShiftI src1 src2));
 9653   ins_cost(DEFAULT_COST*2);
 9654   expand %{
 9655     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9656     iRegIdst tmpI;
 9657     maskI_reg_imm(tmpI, src2, mask);
 9658     arShiftI_reg_reg(dst, src1, tmpI);
 9659   %}
 9660 %}
 9661 
 9662 // Register Arithmetic Shift Right Immediate
 9663 instruct arShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9664   match(Set dst (RShiftI src1 src2));
 9665 
 9666   format %{ &quot;SRAWI   $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9667   size(4);
 9668   ins_encode %{
 9669     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
 9670     __ srawi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9671   %}
 9672   ins_pipe(pipe_class_default);
 9673 %}
 9674 
 9675 instruct arShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9676   // no match-rule, false predicate
 9677   effect(DEF dst, USE src1, USE src2);
 9678   predicate(false);
 9679 
 9680   format %{ &quot;SRAD    $dst, $src1, $src2&quot; %}
 9681   size(4);
 9682   ins_encode %{
 9683     // TODO: PPC port $archOpcode(ppc64Opcode_srad);
 9684     __ srad($dst$$Register, $src1$$Register, $src2$$Register);
 9685   %}
 9686   ins_pipe(pipe_class_default);
 9687 %}
 9688 
 9689 // Register Shift Right Arithmetic Long
 9690 instruct arShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9691   match(Set dst (RShiftL src1 src2));
 9692   ins_cost(DEFAULT_COST*2);
 9693 
 9694   expand %{
 9695     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9696     iRegIdst tmpI;
 9697     maskI_reg_imm(tmpI, src2, mask);
 9698     arShiftL_regL_regI(dst, src1, tmpI);
 9699   %}
 9700 %}
 9701 
 9702 // Register Shift Right Immediate
 9703 instruct arShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9704   match(Set dst (RShiftL src1 src2));
 9705 
 9706   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9707   size(4);
 9708   ins_encode %{
 9709     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9710     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9711   %}
 9712   ins_pipe(pipe_class_default);
 9713 %}
 9714 
 9715 // RShiftL + ConvL2I
 9716 instruct convL2I_arShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9717   match(Set dst (ConvL2I (RShiftL src1 src2)));
 9718 
 9719   format %{ &quot;SRADI   $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9720   size(4);
 9721   ins_encode %{
 9722     // TODO: PPC port $archOpcode(ppc64Opcode_sradi);
 9723     __ sradi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9724   %}
 9725   ins_pipe(pipe_class_default);
 9726 %}
 9727 
 9728 instruct urShiftI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9729   // no match-rule, false predicate
 9730   effect(DEF dst, USE src1, USE src2);
 9731   predicate(false);
 9732 
 9733   format %{ &quot;SRW     $dst, $src1, $src2&quot; %}
 9734   size(4);
 9735   ins_encode %{
 9736     // TODO: PPC port $archOpcode(ppc64Opcode_srw);
 9737     __ srw($dst$$Register, $src1$$Register, $src2$$Register);
 9738   %}
 9739   ins_pipe(pipe_class_default);
 9740 %}
 9741 
 9742 // Register Shift Right
 9743 instruct urShiftI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
 9744   match(Set dst (URShiftI src1 src2));
 9745   ins_cost(DEFAULT_COST*2);
 9746 
 9747   expand %{
 9748     uimmI6 mask %{ 0x3b /* clear 59 bits, keep 5 */ %}
 9749     iRegIdst tmpI;
 9750     maskI_reg_imm(tmpI, src2, mask);
 9751     urShiftI_reg_reg(dst, src1, tmpI);
 9752   %}
 9753 %}
 9754 
 9755 // Register Shift Right Immediate
 9756 instruct urShiftI_reg_imm(iRegIdst dst, iRegIsrc src1, immI src2) %{
 9757   match(Set dst (URShiftI src1 src2));
 9758 
 9759   format %{ &quot;SRWI    $dst, $src1, ($src2 &amp; 0x1f)&quot; %}
 9760   size(4);
 9761   ins_encode %{
 9762     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9763     __ srwi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x1f);
 9764   %}
 9765   ins_pipe(pipe_class_default);
 9766 %}
 9767 
 9768 instruct urShiftL_regL_regI(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9769   // no match-rule, false predicate
 9770   effect(DEF dst, USE src1, USE src2);
 9771   predicate(false);
 9772 
 9773   format %{ &quot;SRD     $dst, $src1, $src2&quot; %}
 9774   size(4);
 9775   ins_encode %{
 9776     // TODO: PPC port $archOpcode(ppc64Opcode_srd);
 9777     __ srd($dst$$Register, $src1$$Register, $src2$$Register);
 9778   %}
 9779   ins_pipe(pipe_class_default);
 9780 %}
 9781 
 9782 // Register Shift Right
 9783 instruct urShiftL_regL_regI_Ex(iRegLdst dst, iRegLsrc src1, iRegIsrc src2) %{
 9784   match(Set dst (URShiftL src1 src2));
 9785   ins_cost(DEFAULT_COST*2);
 9786 
 9787   expand %{
 9788     uimmI6 mask %{ 0x3a /* clear 58 bits, keep 6 */ %}
 9789     iRegIdst tmpI;
 9790     maskI_reg_imm(tmpI, src2, mask);
 9791     urShiftL_regL_regI(dst, src1, tmpI);
 9792   %}
 9793 %}
 9794 
 9795 // Register Shift Right Immediate
 9796 instruct urShiftL_regL_immI(iRegLdst dst, iRegLsrc src1, immI src2) %{
 9797   match(Set dst (URShiftL src1 src2));
 9798 
 9799   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f)&quot; %}
 9800   size(4);
 9801   ins_encode %{
 9802     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9803     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9804   %}
 9805   ins_pipe(pipe_class_default);
 9806 %}
 9807 
 9808 // URShiftL + ConvL2I.
 9809 instruct convL2I_urShiftL_regL_immI(iRegIdst dst, iRegLsrc src1, immI src2) %{
 9810   match(Set dst (ConvL2I (URShiftL src1 src2)));
 9811 
 9812   format %{ &quot;SRDI    $dst, $src1, ($src2 &amp; 0x3f) \t// long + l2i&quot; %}
 9813   size(4);
 9814   ins_encode %{
 9815     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9816     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9817   %}
 9818   ins_pipe(pipe_class_default);
 9819 %}
 9820 
 9821 // Register Shift Right Immediate with a CastP2X
 9822 instruct shrP_convP2X_reg_imm6(iRegLdst dst, iRegP_N2P src1, uimmI6 src2) %{
 9823   match(Set dst (URShiftL (CastP2X src1) src2));
 9824 
 9825   format %{ &quot;SRDI    $dst, $src1, $src2 \t// Cast ptr $src1 to long and shift&quot; %}
 9826   size(4);
 9827   ins_encode %{
 9828     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9829     __ srdi($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0x3f);
 9830   %}
 9831   ins_pipe(pipe_class_default);
 9832 %}
 9833 
 9834 // Bitfield Extract: URShiftI + AndI
 9835 instruct andI_urShiftI_regI_immI_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immI src2, immIpow2minus1 src3) %{
 9836   match(Set dst (AndI (URShiftI src1 src2) src3));
 9837 
 9838   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// int bitfield extract&quot; %}
 9839   size(4);
 9840   ins_encode %{
 9841     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9842     int rshift = ($src2$$constant) &amp; 0x1f;
 9843     int length = log2_long(((jlong) $src3$$constant) + 1);
 9844     if (rshift + length &gt; 32) {
 9845       // if necessary, adjust mask to omit rotated bits.
 9846       length = 32 - rshift;
 9847     }
 9848     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9849   %}
 9850   ins_pipe(pipe_class_default);
 9851 %}
 9852 
 9853 // Bitfield Extract: URShiftL + AndL
 9854 instruct andL_urShiftL_regL_immI_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immI src2, immLpow2minus1 src3) %{
 9855   match(Set dst (AndL (URShiftL src1 src2) src3));
 9856 
 9857   format %{ &quot;EXTRDI  $dst, $src1, shift=$src2, mask=$src3 \t// long bitfield extract&quot; %}
 9858   size(4);
 9859   ins_encode %{
 9860     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
 9861     int rshift  = ($src2$$constant) &amp; 0x3f;
 9862     int length = log2_long(((jlong) $src3$$constant) + 1);
 9863     if (rshift + length &gt; 64) {
 9864       // if necessary, adjust mask to omit rotated bits.
 9865       length = 64 - rshift;
 9866     }
 9867     __ extrdi($dst$$Register, $src1$$Register, length, 64 - (rshift + length));
 9868   %}
 9869   ins_pipe(pipe_class_default);
 9870 %}
 9871 
 9872 instruct sxtI_reg(iRegIdst dst, iRegIsrc src) %{
 9873   match(Set dst (ConvL2I (ConvI2L src)));
 9874 
 9875   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;int&quot; %}
 9876   size(4);
 9877   ins_encode %{
 9878     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
 9879     __ extsw($dst$$Register, $src$$Register);
 9880   %}
 9881   ins_pipe(pipe_class_default);
 9882 %}
 9883 
 9884 //----------Rotate Instructions------------------------------------------------
 9885 
 9886 // Rotate Left by 8-bit immediate
 9887 instruct rotlI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 lshift, immI8 rshift) %{
 9888   match(Set dst (OrI (LShiftI src lshift) (URShiftI src rshift)));
 9889   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9890 
 9891   format %{ &quot;ROTLWI  $dst, $src, $lshift&quot; %}
 9892   size(4);
 9893   ins_encode %{
 9894     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9895     __ rotlwi($dst$$Register, $src$$Register, $lshift$$constant);
 9896   %}
 9897   ins_pipe(pipe_class_default);
 9898 %}
 9899 
 9900 // Rotate Right by 8-bit immediate
 9901 instruct rotrI_reg_immi8(iRegIdst dst, iRegIsrc src, immI8 rshift, immI8 lshift) %{
 9902   match(Set dst (OrI (URShiftI src rshift) (LShiftI src lshift)));
 9903   predicate(0 == ((n-&gt;in(1)-&gt;in(2)-&gt;get_int() + n-&gt;in(2)-&gt;in(2)-&gt;get_int()) &amp; 0x1f));
 9904 
 9905   format %{ &quot;ROTRWI  $dst, $rshift&quot; %}
 9906   size(4);
 9907   ins_encode %{
 9908     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
 9909     __ rotrwi($dst$$Register, $src$$Register, $rshift$$constant);
 9910   %}
 9911   ins_pipe(pipe_class_default);
 9912 %}
 9913 
 9914 //----------Floating Point Arithmetic Instructions-----------------------------
 9915 
 9916 // Add float single precision
 9917 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 9918   match(Set dst (AddF src1 src2));
 9919 
 9920   format %{ &quot;FADDS   $dst, $src1, $src2&quot; %}
 9921   size(4);
 9922   ins_encode %{
 9923     // TODO: PPC port $archOpcode(ppc64Opcode_fadds);
 9924     __ fadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9925   %}
 9926   ins_pipe(pipe_class_default);
 9927 %}
 9928 
 9929 // Add float double precision
 9930 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 9931   match(Set dst (AddD src1 src2));
 9932 
 9933   format %{ &quot;FADD    $dst, $src1, $src2&quot; %}
 9934   size(4);
 9935   ins_encode %{
 9936     // TODO: PPC port $archOpcode(ppc64Opcode_fadd);
 9937     __ fadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9938   %}
 9939   ins_pipe(pipe_class_default);
 9940 %}
 9941 
 9942 // Sub float single precision
 9943 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 9944   match(Set dst (SubF src1 src2));
 9945 
 9946   format %{ &quot;FSUBS   $dst, $src1, $src2&quot; %}
 9947   size(4);
 9948   ins_encode %{
 9949     // TODO: PPC port $archOpcode(ppc64Opcode_fsubs);
 9950     __ fsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9951   %}
 9952   ins_pipe(pipe_class_default);
 9953 %}
 9954 
 9955 // Sub float double precision
 9956 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 9957   match(Set dst (SubD src1 src2));
 9958   format %{ &quot;FSUB    $dst, $src1, $src2&quot; %}
 9959   size(4);
 9960   ins_encode %{
 9961     // TODO: PPC port $archOpcode(ppc64Opcode_fsub);
 9962     __ fsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9963   %}
 9964   ins_pipe(pipe_class_default);
 9965 %}
 9966 
 9967 // Mul float single precision
 9968 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 9969   match(Set dst (MulF src1 src2));
 9970   format %{ &quot;FMULS   $dst, $src1, $src2&quot; %}
 9971   size(4);
 9972   ins_encode %{
 9973     // TODO: PPC port $archOpcode(ppc64Opcode_fmuls);
 9974     __ fmuls($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9975   %}
 9976   ins_pipe(pipe_class_default);
 9977 %}
 9978 
 9979 // Mul float double precision
 9980 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 9981   match(Set dst (MulD src1 src2));
 9982   format %{ &quot;FMUL    $dst, $src1, $src2&quot; %}
 9983   size(4);
 9984   ins_encode %{
 9985     // TODO: PPC port $archOpcode(ppc64Opcode_fmul);
 9986     __ fmul($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9987   %}
 9988   ins_pipe(pipe_class_default);
 9989 %}
 9990 
 9991 // Div float single precision
 9992 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 9993   match(Set dst (DivF src1 src2));
 9994   format %{ &quot;FDIVS   $dst, $src1, $src2&quot; %}
 9995   size(4);
 9996   ins_encode %{
 9997     // TODO: PPC port $archOpcode(ppc64Opcode_fdivs);
 9998     __ fdivs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9999   %}
10000   ins_pipe(pipe_class_default);
10001 %}
10002 
10003 // Div float double precision
10004 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
10005   match(Set dst (DivD src1 src2));
10006   format %{ &quot;FDIV    $dst, $src1, $src2&quot; %}
10007   size(4);
10008   ins_encode %{
10009     // TODO: PPC port $archOpcode(ppc64Opcode_fdiv);
10010     __ fdiv($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
10011   %}
10012   ins_pipe(pipe_class_default);
10013 %}
10014 
10015 // Absolute float single precision
10016 instruct absF_reg(regF dst, regF src) %{
10017   match(Set dst (AbsF src));
10018   format %{ &quot;FABS    $dst, $src \t// float&quot; %}
10019   size(4);
10020   ins_encode %{
10021     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10022     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10023   %}
10024   ins_pipe(pipe_class_default);
10025 %}
10026 
10027 // Absolute float double precision
10028 instruct absD_reg(regD dst, regD src) %{
10029   match(Set dst (AbsD src));
10030   format %{ &quot;FABS    $dst, $src \t// double&quot; %}
10031   size(4);
10032   ins_encode %{
10033     // TODO: PPC port $archOpcode(ppc64Opcode_fabs);
10034     __ fabs($dst$$FloatRegister, $src$$FloatRegister);
10035   %}
10036   ins_pipe(pipe_class_default);
10037 %}
10038 
10039 instruct negF_reg(regF dst, regF src) %{
10040   match(Set dst (NegF src));
10041   format %{ &quot;FNEG    $dst, $src \t// float&quot; %}
10042   size(4);
10043   ins_encode %{
10044     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10045     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10046   %}
10047   ins_pipe(pipe_class_default);
10048 %}
10049 
10050 instruct negD_reg(regD dst, regD src) %{
10051   match(Set dst (NegD src));
10052   format %{ &quot;FNEG    $dst, $src \t// double&quot; %}
10053   size(4);
10054   ins_encode %{
10055     // TODO: PPC port $archOpcode(ppc64Opcode_fneg);
10056     __ fneg($dst$$FloatRegister, $src$$FloatRegister);
10057   %}
10058   ins_pipe(pipe_class_default);
10059 %}
10060 
10061 // AbsF + NegF.
10062 instruct negF_absF_reg(regF dst, regF src) %{
10063   match(Set dst (NegF (AbsF src)));
10064   format %{ &quot;FNABS   $dst, $src \t// float&quot; %}
10065   size(4);
10066   ins_encode %{
10067     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10068     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10069   %}
10070   ins_pipe(pipe_class_default);
10071 %}
10072 
10073 // AbsD + NegD.
10074 instruct negD_absD_reg(regD dst, regD src) %{
10075   match(Set dst (NegD (AbsD src)));
10076   format %{ &quot;FNABS   $dst, $src \t// double&quot; %}
10077   size(4);
10078   ins_encode %{
10079     // TODO: PPC port $archOpcode(ppc64Opcode_fnabs);
10080     __ fnabs($dst$$FloatRegister, $src$$FloatRegister);
10081   %}
10082   ins_pipe(pipe_class_default);
10083 %}
10084 
10085 // VM_Version::has_fsqrt() decides if this node will be used.
10086 // Sqrt float double precision
10087 instruct sqrtD_reg(regD dst, regD src) %{
10088   match(Set dst (SqrtD src));
10089   format %{ &quot;FSQRT   $dst, $src&quot; %}
10090   size(4);
10091   ins_encode %{
10092     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrt);
10093     __ fsqrt($dst$$FloatRegister, $src$$FloatRegister);
10094   %}
10095   ins_pipe(pipe_class_default);
10096 %}
10097 
10098 // Single-precision sqrt.
10099 instruct sqrtF_reg(regF dst, regF src) %{
10100   match(Set dst (SqrtF src));
10101   predicate(VM_Version::has_fsqrts());
10102   ins_cost(DEFAULT_COST);
10103 
10104   format %{ &quot;FSQRTS  $dst, $src&quot; %}
10105   size(4);
10106   ins_encode %{
10107     // TODO: PPC port $archOpcode(ppc64Opcode_fsqrts);
10108     __ fsqrts($dst$$FloatRegister, $src$$FloatRegister);
10109   %}
10110   ins_pipe(pipe_class_default);
10111 %}
10112 
10113 instruct roundDouble_nop(regD dst) %{
10114   match(Set dst (RoundDouble dst));
10115   ins_cost(0);
10116 
10117   format %{ &quot; -- \t// RoundDouble not needed - empty&quot; %}
10118   size(0);
10119   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10120   ins_encode( /*empty*/ );
10121   ins_pipe(pipe_class_default);
10122 %}
10123 
10124 instruct roundFloat_nop(regF dst) %{
10125   match(Set dst (RoundFloat dst));
10126   ins_cost(0);
10127 
10128   format %{ &quot; -- \t// RoundFloat not needed - empty&quot; %}
10129   size(0);
10130   // PPC results are already &quot;rounded&quot; (i.e., normal-format IEEE).
10131   ins_encode( /*empty*/ );
10132   ins_pipe(pipe_class_default);
10133 %}
10134 
10135 
10136 // Multiply-Accumulate
10137 // src1 * src2 + src3
10138 instruct maddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10139   match(Set dst (FmaF src3 (Binary src1 src2)));
10140 
10141   format %{ &quot;FMADDS  $dst, $src1, $src2, $src3&quot; %}
10142   size(4);
10143   ins_encode %{
10144     // TODO: PPC port $archOpcode(ppc64Opcode_fmadds);
10145     __ fmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10146   %}
10147   ins_pipe(pipe_class_default);
10148 %}
10149 
10150 // src1 * src2 + src3
10151 instruct maddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10152   match(Set dst (FmaD src3 (Binary src1 src2)));
10153 
10154   format %{ &quot;FMADD   $dst, $src1, $src2, $src3&quot; %}
10155   size(4);
10156   ins_encode %{
10157     // TODO: PPC port $archOpcode(ppc64Opcode_fmadd);
10158     __ fmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10159   %}
10160   ins_pipe(pipe_class_default);
10161 %}
10162 
10163 // -src1 * src2 + src3 = -(src1*src2-src3)
10164 instruct mnsubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10165   match(Set dst (FmaF src3 (Binary (NegF src1) src2)));
10166   match(Set dst (FmaF src3 (Binary src1 (NegF src2))));
10167 
10168   format %{ &quot;FNMSUBS $dst, $src1, $src2, $src3&quot; %}
10169   size(4);
10170   ins_encode %{
10171     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsubs);
10172     __ fnmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10173   %}
10174   ins_pipe(pipe_class_default);
10175 %}
10176 
10177 // -src1 * src2 + src3 = -(src1*src2-src3)
10178 instruct mnsubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10179   match(Set dst (FmaD src3 (Binary (NegD src1) src2)));
10180   match(Set dst (FmaD src3 (Binary src1 (NegD src2))));
10181 
10182   format %{ &quot;FNMSUB  $dst, $src1, $src2, $src3&quot; %}
10183   size(4);
10184   ins_encode %{
10185     // TODO: PPC port $archOpcode(ppc64Opcode_fnmsub);
10186     __ fnmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10187   %}
10188   ins_pipe(pipe_class_default);
10189 %}
10190 
10191 // -src1 * src2 - src3 = -(src1*src2+src3)
10192 instruct mnaddF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10193   match(Set dst (FmaF (NegF src3) (Binary (NegF src1) src2)));
10194   match(Set dst (FmaF (NegF src3) (Binary src1 (NegF src2))));
10195 
10196   format %{ &quot;FNMADDS $dst, $src1, $src2, $src3&quot; %}
10197   size(4);
10198   ins_encode %{
10199     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadds);
10200     __ fnmadds($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10201   %}
10202   ins_pipe(pipe_class_default);
10203 %}
10204 
10205 // -src1 * src2 - src3 = -(src1*src2+src3)
10206 instruct mnaddD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10207   match(Set dst (FmaD (NegD src3) (Binary (NegD src1) src2)));
10208   match(Set dst (FmaD (NegD src3) (Binary src1 (NegD src2))));
10209 
10210   format %{ &quot;FNMADD  $dst, $src1, $src2, $src3&quot; %}
10211   size(4);
10212   ins_encode %{
10213     // TODO: PPC port $archOpcode(ppc64Opcode_fnmadd);
10214     __ fnmadd($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10215   %}
10216   ins_pipe(pipe_class_default);
10217 %}
10218 
10219 // src1 * src2 - src3
10220 instruct msubF_reg_reg(regF dst, regF src1, regF src2, regF src3) %{
10221   match(Set dst (FmaF (NegF src3) (Binary src1 src2)));
10222 
10223   format %{ &quot;FMSUBS  $dst, $src1, $src2, $src3&quot; %}
10224   size(4);
10225   ins_encode %{
10226     // TODO: PPC port $archOpcode(ppc64Opcode_fmsubs);
10227     __ fmsubs($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10228   %}
10229   ins_pipe(pipe_class_default);
10230 %}
10231 
10232 // src1 * src2 - src3
10233 instruct msubD_reg_reg(regD dst, regD src1, regD src2, regD src3) %{
10234   match(Set dst (FmaD (NegD src3) (Binary src1 src2)));
10235 
10236   format %{ &quot;FMSUB   $dst, $src1, $src2, $src3&quot; %}
10237   size(4);
10238   ins_encode %{
10239     // TODO: PPC port $archOpcode(ppc64Opcode_fmsub);
10240     __ fmsub($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister, $src3$$FloatRegister);
10241   %}
10242   ins_pipe(pipe_class_default);
10243 %}
10244 
10245 
10246 //----------Logical Instructions-----------------------------------------------
10247 
10248 // And Instructions
10249 
10250 // Register And
10251 instruct andI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10252   match(Set dst (AndI src1 src2));
10253   format %{ &quot;AND     $dst, $src1, $src2&quot; %}
10254   size(4);
10255   ins_encode %{
10256     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10257     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10258   %}
10259   ins_pipe(pipe_class_default);
10260 %}
10261 
10262 // Left shifted Immediate And
10263 instruct andI_reg_immIhi16(iRegIdst dst, iRegIsrc src1, immIhi16  src2, flagsRegCR0 cr0) %{
10264   match(Set dst (AndI src1 src2));
10265   effect(KILL cr0);
10266   format %{ &quot;ANDIS   $dst, $src1, $src2.hi&quot; %}
10267   size(4);
10268   ins_encode %{
10269     // TODO: PPC port $archOpcode(ppc64Opcode_andis_);
10270     __ andis_($dst$$Register, $src1$$Register, (int)((unsigned short)(($src2$$constant &amp; 0xFFFF0000) &gt;&gt; 16)));
10271   %}
10272   ins_pipe(pipe_class_default);
10273 %}
10274 
10275 // Immediate And
10276 instruct andI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2, flagsRegCR0 cr0) %{
10277   match(Set dst (AndI src1 src2));
10278   effect(KILL cr0);
10279 
10280   format %{ &quot;ANDI    $dst, $src1, $src2&quot; %}
10281   size(4);
10282   ins_encode %{
10283     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10284     // FIXME: avoid andi_ ?
10285     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10286   %}
10287   ins_pipe(pipe_class_default);
10288 %}
10289 
10290 // Immediate And where the immediate is a negative power of 2.
10291 instruct andI_reg_immInegpow2(iRegIdst dst, iRegIsrc src1, immInegpow2 src2) %{
10292   match(Set dst (AndI src1 src2));
10293   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10294   size(4);
10295   ins_encode %{
10296     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10297     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)(julong)(juint)-($src2$$constant)));
10298   %}
10299   ins_pipe(pipe_class_default);
10300 %}
10301 
10302 instruct andI_reg_immIpow2minus1(iRegIdst dst, iRegIsrc src1, immIpow2minus1 src2) %{
10303   match(Set dst (AndI src1 src2));
10304   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10305   size(4);
10306   ins_encode %{
10307     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10308     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10309   %}
10310   ins_pipe(pipe_class_default);
10311 %}
10312 
10313 instruct andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src1, immIpowerOf2 src2) %{
10314   match(Set dst (AndI src1 src2));
10315   predicate(UseRotateAndMaskInstructionsPPC64);
10316   format %{ &quot;ANDWI   $dst, $src1, $src2&quot; %}
10317   size(4);
10318   ins_encode %{
10319     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10320     __ rlwinm($dst$$Register, $src1$$Register, 0,
10321               (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f, (31-log2_long((jlong) $src2$$constant)) &amp; 0x1f);
10322   %}
10323   ins_pipe(pipe_class_default);
10324 %}
10325 
10326 // Register And Long
10327 instruct andL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10328   match(Set dst (AndL src1 src2));
10329   ins_cost(DEFAULT_COST);
10330 
10331   format %{ &quot;AND     $dst, $src1, $src2 \t// long&quot; %}
10332   size(4);
10333   ins_encode %{
10334     // TODO: PPC port $archOpcode(ppc64Opcode_and);
10335     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
10336   %}
10337   ins_pipe(pipe_class_default);
10338 %}
10339 
10340 // Immediate And long
10341 instruct andL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2, flagsRegCR0 cr0) %{
10342   match(Set dst (AndL src1 src2));
10343   effect(KILL cr0);
10344 
10345   format %{ &quot;ANDI    $dst, $src1, $src2 \t// long&quot; %}
10346   size(4);
10347   ins_encode %{
10348     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
10349     // FIXME: avoid andi_ ?
10350     __ andi_($dst$$Register, $src1$$Register, $src2$$constant);
10351   %}
10352   ins_pipe(pipe_class_default);
10353 %}
10354 
10355 // Immediate And Long where the immediate is a negative power of 2.
10356 instruct andL_reg_immLnegpow2(iRegLdst dst, iRegLsrc src1, immLnegpow2 src2) %{
10357   match(Set dst (AndL src1 src2));
10358   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10359   size(4);
10360   ins_encode %{
10361     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
10362     __ clrrdi($dst$$Register, $src1$$Register, log2_long((jlong)-$src2$$constant));
10363   %}
10364   ins_pipe(pipe_class_default);
10365 %}
10366 
10367 instruct andL_reg_immLpow2minus1(iRegLdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10368   match(Set dst (AndL src1 src2));
10369   format %{ &quot;ANDDI   $dst, $src1, $src2&quot; %}
10370   size(4);
10371   ins_encode %{
10372     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10373     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10374   %}
10375   ins_pipe(pipe_class_default);
10376 %}
10377 
10378 // AndL + ConvL2I.
10379 instruct convL2I_andL_reg_immLpow2minus1(iRegIdst dst, iRegLsrc src1, immLpow2minus1 src2) %{
10380   match(Set dst (ConvL2I (AndL src1 src2)));
10381   ins_cost(DEFAULT_COST);
10382 
10383   format %{ &quot;ANDDI   $dst, $src1, $src2 \t// long + l2i&quot; %}
10384   size(4);
10385   ins_encode %{
10386     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
10387     __ clrldi($dst$$Register, $src1$$Register, 64-log2_long((((jlong) $src2$$constant)+1)));
10388   %}
10389   ins_pipe(pipe_class_default);
10390 %}
10391 
10392 // Or Instructions
10393 
10394 // Register Or
10395 instruct orI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10396   match(Set dst (OrI src1 src2));
10397   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10398   size(4);
10399   ins_encode %{
10400     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10401     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10402   %}
10403   ins_pipe(pipe_class_default);
10404 %}
10405 
10406 // Expand does not work with above instruct. (??)
10407 instruct orI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10408   // no match-rule
10409   effect(DEF dst, USE src1, USE src2);
10410   format %{ &quot;OR      $dst, $src1, $src2&quot; %}
10411   size(4);
10412   ins_encode %{
10413     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10414     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10415   %}
10416   ins_pipe(pipe_class_default);
10417 %}
10418 
10419 instruct tree_orI_orI_orI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10420   match(Set dst (OrI (OrI (OrI src1 src2) src3) src4));
10421   ins_cost(DEFAULT_COST*3);
10422 
10423   expand %{
10424     // FIXME: we should do this in the ideal world.
10425     iRegIdst tmp1;
10426     iRegIdst tmp2;
10427     orI_reg_reg(tmp1, src1, src2);
10428     orI_reg_reg_2(tmp2, src3, src4); // Adlc complains about orI_reg_reg.
10429     orI_reg_reg(dst, tmp1, tmp2);
10430   %}
10431 %}
10432 
10433 // Immediate Or
10434 instruct orI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10435   match(Set dst (OrI src1 src2));
10436   format %{ &quot;ORI     $dst, $src1, $src2&quot; %}
10437   size(4);
10438   ins_encode %{
10439     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10440     __ ori($dst$$Register, $src1$$Register, ($src2$$constant) &amp; 0xFFFF);
10441   %}
10442   ins_pipe(pipe_class_default);
10443 %}
10444 
10445 // Register Or Long
10446 instruct orL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10447   match(Set dst (OrL src1 src2));
10448   ins_cost(DEFAULT_COST);
10449 
10450   size(4);
10451   format %{ &quot;OR      $dst, $src1, $src2 \t// long&quot; %}
10452   ins_encode %{
10453     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10454     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10455   %}
10456   ins_pipe(pipe_class_default);
10457 %}
10458 
10459 // OrL + ConvL2I.
10460 instruct orI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10461   match(Set dst (ConvL2I (OrL src1 src2)));
10462   ins_cost(DEFAULT_COST);
10463 
10464   format %{ &quot;OR      $dst, $src1, $src2 \t// long + l2i&quot; %}
10465   size(4);
10466   ins_encode %{
10467     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10468     __ or_unchecked($dst$$Register, $src1$$Register, $src2$$Register);
10469   %}
10470   ins_pipe(pipe_class_default);
10471 %}
10472 
10473 // Immediate Or long
10474 instruct orL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 con) %{
10475   match(Set dst (OrL src1 con));
10476   ins_cost(DEFAULT_COST);
10477 
10478   format %{ &quot;ORI     $dst, $src1, $con \t// long&quot; %}
10479   size(4);
10480   ins_encode %{
10481     // TODO: PPC port $archOpcode(ppc64Opcode_ori);
10482     __ ori($dst$$Register, $src1$$Register, ($con$$constant) &amp; 0xFFFF);
10483   %}
10484   ins_pipe(pipe_class_default);
10485 %}
10486 
10487 // Xor Instructions
10488 
10489 // Register Xor
10490 instruct xorI_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10491   match(Set dst (XorI src1 src2));
10492   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10493   size(4);
10494   ins_encode %{
10495     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10496     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10497   %}
10498   ins_pipe(pipe_class_default);
10499 %}
10500 
10501 // Expand does not work with above instruct. (??)
10502 instruct xorI_reg_reg_2(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
10503   // no match-rule
10504   effect(DEF dst, USE src1, USE src2);
10505   format %{ &quot;XOR     $dst, $src1, $src2&quot; %}
10506   size(4);
10507   ins_encode %{
10508     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10509     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10510   %}
10511   ins_pipe(pipe_class_default);
10512 %}
10513 
10514 instruct tree_xorI_xorI_xorI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, iRegIsrc src3, iRegIsrc src4) %{
10515   match(Set dst (XorI (XorI (XorI src1 src2) src3) src4));
10516   ins_cost(DEFAULT_COST*3);
10517 
10518   expand %{
10519     // FIXME: we should do this in the ideal world.
10520     iRegIdst tmp1;
10521     iRegIdst tmp2;
10522     xorI_reg_reg(tmp1, src1, src2);
10523     xorI_reg_reg_2(tmp2, src3, src4); // Adlc complains about xorI_reg_reg.
10524     xorI_reg_reg(dst, tmp1, tmp2);
10525   %}
10526 %}
10527 
10528 // Immediate Xor
10529 instruct xorI_reg_uimm16(iRegIdst dst, iRegIsrc src1, uimmI16 src2) %{
10530   match(Set dst (XorI src1 src2));
10531   format %{ &quot;XORI    $dst, $src1, $src2&quot; %}
10532   size(4);
10533   ins_encode %{
10534     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10535     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10536   %}
10537   ins_pipe(pipe_class_default);
10538 %}
10539 
10540 // Register Xor Long
10541 instruct xorL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10542   match(Set dst (XorL src1 src2));
10543   ins_cost(DEFAULT_COST);
10544 
10545   format %{ &quot;XOR     $dst, $src1, $src2 \t// long&quot; %}
10546   size(4);
10547   ins_encode %{
10548     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10549     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10550   %}
10551   ins_pipe(pipe_class_default);
10552 %}
10553 
10554 // XorL + ConvL2I.
10555 instruct xorI_regL_regL(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
10556   match(Set dst (ConvL2I (XorL src1 src2)));
10557   ins_cost(DEFAULT_COST);
10558 
10559   format %{ &quot;XOR     $dst, $src1, $src2 \t// long + l2i&quot; %}
10560   size(4);
10561   ins_encode %{
10562     // TODO: PPC port $archOpcode(ppc64Opcode_xor);
10563     __ xorr($dst$$Register, $src1$$Register, $src2$$Register);
10564   %}
10565   ins_pipe(pipe_class_default);
10566 %}
10567 
10568 // Immediate Xor Long
10569 instruct xorL_reg_uimm16(iRegLdst dst, iRegLsrc src1, uimmL16 src2) %{
10570   match(Set dst (XorL src1 src2));
10571   ins_cost(DEFAULT_COST);
10572 
10573   format %{ &quot;XORI    $dst, $src1, $src2 \t// long&quot; %}
10574   size(4);
10575   ins_encode %{
10576     // TODO: PPC port $archOpcode(ppc64Opcode_xori);
10577     __ xori($dst$$Register, $src1$$Register, $src2$$constant);
10578   %}
10579   ins_pipe(pipe_class_default);
10580 %}
10581 
10582 instruct notI_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2) %{
10583   match(Set dst (XorI src1 src2));
10584   ins_cost(DEFAULT_COST);
10585 
10586   format %{ &quot;NOT     $dst, $src1 ($src2)&quot; %}
10587   size(4);
10588   ins_encode %{
10589     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10590     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10591   %}
10592   ins_pipe(pipe_class_default);
10593 %}
10594 
10595 instruct notL_reg(iRegLdst dst, iRegLsrc src1, immL_minus1 src2) %{
10596   match(Set dst (XorL src1 src2));
10597   ins_cost(DEFAULT_COST);
10598 
10599   format %{ &quot;NOT     $dst, $src1 ($src2) \t// long&quot; %}
10600   size(4);
10601   ins_encode %{
10602     // TODO: PPC port $archOpcode(ppc64Opcode_nor);
10603     __ nor($dst$$Register, $src1$$Register, $src1$$Register);
10604   %}
10605   ins_pipe(pipe_class_default);
10606 %}
10607 
10608 // And-complement
10609 instruct andcI_reg_reg(iRegIdst dst, iRegIsrc src1, immI_minus1 src2, iRegIsrc src3) %{
10610   match(Set dst (AndI (XorI src1 src2) src3));
10611   ins_cost(DEFAULT_COST);
10612 
10613   format %{ &quot;ANDW    $dst, xori($src1, $src2), $src3&quot; %}
10614   size(4);
10615   ins_encode( enc_andc(dst, src3, src1) );
10616   ins_pipe(pipe_class_default);
10617 %}
10618 
10619 // And-complement
10620 instruct andcL_reg_reg(iRegLdst dst, iRegLsrc src1, iRegLsrc src2) %{
10621   // no match-rule, false predicate
10622   effect(DEF dst, USE src1, USE src2);
10623   predicate(false);
10624 
10625   format %{ &quot;ANDC    $dst, $src1, $src2&quot; %}
10626   size(4);
10627   ins_encode %{
10628     // TODO: PPC port $archOpcode(ppc64Opcode_andc);
10629     __ andc($dst$$Register, $src1$$Register, $src2$$Register);
10630   %}
10631   ins_pipe(pipe_class_default);
10632 %}
10633 
10634 //----------Moves between int/long and float/double----------------------------
10635 //
10636 // The following rules move values from int/long registers/stack-locations
10637 // to float/double registers/stack-locations and vice versa, without doing any
10638 // conversions. These rules are used to implement the bit-conversion methods
10639 // of java.lang.Float etc., e.g.
10640 //   int   floatToIntBits(float value)
10641 //   float intBitsToFloat(int bits)
10642 //
10643 // Notes on the implementation on ppc64:
10644 // For Power7 and earlier, the rules are limited to those which move between a
10645 // register and a stack-location, because we always have to go through memory
10646 // when moving between a float register and an integer register.
10647 // This restriction is removed in Power8 with the introduction of the mtfprd
10648 // and mffprd instructions.
10649 
10650 instruct moveL2D_reg(regD dst, iRegLsrc src) %{
10651   match(Set dst (MoveL2D src));
10652   predicate(VM_Version::has_mtfprd());
10653 
10654   format %{ &quot;MTFPRD  $dst, $src&quot; %}
10655   size(4);
10656   ins_encode %{
10657     __ mtfprd($dst$$FloatRegister, $src$$Register);
10658   %}
10659   ins_pipe(pipe_class_default);
10660 %}
10661 
10662 instruct moveI2D_reg(regD dst, iRegIsrc src) %{
10663   // no match-rule, false predicate
10664   effect(DEF dst, USE src);
10665   predicate(false);
10666 
10667   format %{ &quot;MTFPRWA $dst, $src&quot; %}
10668   size(4);
10669   ins_encode %{
10670     __ mtfprwa($dst$$FloatRegister, $src$$Register);
10671   %}
10672   ins_pipe(pipe_class_default);
10673 %}
10674 
10675 //---------- Chain stack slots between similar types --------
10676 
10677 // These are needed so that the rules below can match.
10678 
10679 // Load integer from stack slot
10680 instruct stkI_to_regI(iRegIdst dst, stackSlotI src) %{
10681   match(Set dst src);
10682   ins_cost(MEMORY_REF_COST);
10683 
10684   format %{ &quot;LWZ     $dst, $src&quot; %}
10685   size(4);
10686   ins_encode( enc_lwz(dst, src) );
10687   ins_pipe(pipe_class_memory);
10688 %}
10689 
10690 // Store integer to stack slot
10691 instruct regI_to_stkI(stackSlotI dst, iRegIsrc src) %{
10692   match(Set dst src);
10693   ins_cost(MEMORY_REF_COST);
10694 
10695   format %{ &quot;STW     $src, $dst \t// stk&quot; %}
10696   size(4);
10697   ins_encode( enc_stw(src, dst) ); // rs=rt
10698   ins_pipe(pipe_class_memory);
10699 %}
10700 
10701 // Load long from stack slot
10702 instruct stkL_to_regL(iRegLdst dst, stackSlotL src) %{
10703   match(Set dst src);
10704   ins_cost(MEMORY_REF_COST);
10705 
10706   format %{ &quot;LD      $dst, $src \t// long&quot; %}
10707   size(4);
10708   ins_encode( enc_ld(dst, src) );
10709   ins_pipe(pipe_class_memory);
10710 %}
10711 
10712 // Store long to stack slot
10713 instruct regL_to_stkL(stackSlotL dst, iRegLsrc src) %{
10714   match(Set dst src);
10715   ins_cost(MEMORY_REF_COST);
10716 
10717   format %{ &quot;STD     $src, $dst \t// long&quot; %}
10718   size(4);
10719   ins_encode( enc_std(src, dst) ); // rs=rt
10720   ins_pipe(pipe_class_memory);
10721 %}
10722 
10723 //----------Moves between int and float
10724 
10725 // Move float value from float stack-location to integer register.
10726 instruct moveF2I_stack_reg(iRegIdst dst, stackSlotF src) %{
10727   match(Set dst (MoveF2I src));
10728   ins_cost(MEMORY_REF_COST);
10729 
10730   format %{ &quot;LWZ     $dst, $src \t// MoveF2I&quot; %}
10731   size(4);
10732   ins_encode( enc_lwz(dst, src) );
10733   ins_pipe(pipe_class_memory);
10734 %}
10735 
10736 // Move float value from float register to integer stack-location.
10737 instruct moveF2I_reg_stack(stackSlotI dst, regF src) %{
10738   match(Set dst (MoveF2I src));
10739   ins_cost(MEMORY_REF_COST);
10740 
10741   format %{ &quot;STFS    $src, $dst \t// MoveF2I&quot; %}
10742   size(4);
10743   ins_encode( enc_stfs(src, dst) );
10744   ins_pipe(pipe_class_memory);
10745 %}
10746 
10747 // Move integer value from integer stack-location to float register.
10748 instruct moveI2F_stack_reg(regF dst, stackSlotI src) %{
10749   match(Set dst (MoveI2F src));
10750   ins_cost(MEMORY_REF_COST);
10751 
10752   format %{ &quot;LFS     $dst, $src \t// MoveI2F&quot; %}
10753   size(4);
10754   ins_encode %{
10755     // TODO: PPC port $archOpcode(ppc64Opcode_lfs);
10756     int Idisp = $src$$disp + frame_slots_bias($src$$base, ra_);
10757     __ lfs($dst$$FloatRegister, Idisp, $src$$base$$Register);
10758   %}
10759   ins_pipe(pipe_class_memory);
10760 %}
10761 
10762 // Move integer value from integer register to float stack-location.
10763 instruct moveI2F_reg_stack(stackSlotF dst, iRegIsrc src) %{
10764   match(Set dst (MoveI2F src));
10765   ins_cost(MEMORY_REF_COST);
10766 
10767   format %{ &quot;STW     $src, $dst \t// MoveI2F&quot; %}
10768   size(4);
10769   ins_encode( enc_stw(src, dst) );
10770   ins_pipe(pipe_class_memory);
10771 %}
10772 
10773 //----------Moves between long and float
10774 
10775 instruct moveF2L_reg_stack(stackSlotL dst, regF src) %{
10776   // no match-rule, false predicate
10777   effect(DEF dst, USE src);
10778   predicate(false);
10779 
10780   format %{ &quot;storeD  $src, $dst \t// STACK&quot; %}
10781   size(4);
10782   ins_encode( enc_stfd(src, dst) );
10783   ins_pipe(pipe_class_default);
10784 %}
10785 
10786 //----------Moves between long and double
10787 
10788 // Move double value from double stack-location to long register.
10789 instruct moveD2L_stack_reg(iRegLdst dst, stackSlotD src) %{
10790   match(Set dst (MoveD2L src));
10791   ins_cost(MEMORY_REF_COST);
10792   size(4);
10793   format %{ &quot;LD      $dst, $src \t// MoveD2L&quot; %}
10794   ins_encode( enc_ld(dst, src) );
10795   ins_pipe(pipe_class_memory);
10796 %}
10797 
10798 // Move double value from double register to long stack-location.
10799 instruct moveD2L_reg_stack(stackSlotL dst, regD src) %{
10800   match(Set dst (MoveD2L src));
10801   effect(DEF dst, USE src);
10802   ins_cost(MEMORY_REF_COST);
10803 
10804   format %{ &quot;STFD    $src, $dst \t// MoveD2L&quot; %}
10805   size(4);
10806   ins_encode( enc_stfd(src, dst) );
10807   ins_pipe(pipe_class_memory);
10808 %}
10809 
10810 // Move long value from long stack-location to double register.
10811 instruct moveL2D_stack_reg(regD dst, stackSlotL src) %{
10812   match(Set dst (MoveL2D src));
10813   ins_cost(MEMORY_REF_COST);
10814 
10815   format %{ &quot;LFD     $dst, $src \t// MoveL2D&quot; %}
10816   size(4);
10817   ins_encode( enc_lfd(dst, src) );
10818   ins_pipe(pipe_class_memory);
10819 %}
10820 
10821 // Move long value from long register to double stack-location.
10822 instruct moveL2D_reg_stack(stackSlotD dst, iRegLsrc src) %{
10823   match(Set dst (MoveL2D src));
10824   ins_cost(MEMORY_REF_COST);
10825 
10826   format %{ &quot;STD     $src, $dst \t// MoveL2D&quot; %}
10827   size(4);
10828   ins_encode( enc_std(src, dst) );
10829   ins_pipe(pipe_class_memory);
10830 %}
10831 
10832 //----------Register Move Instructions-----------------------------------------
10833 
10834 // Replicate for Superword
10835 
10836 instruct moveReg(iRegLdst dst, iRegIsrc src) %{
10837   predicate(false);
10838   effect(DEF dst, USE src);
10839 
10840   format %{ &quot;MR      $dst, $src \t// replicate &quot; %}
10841   // variable size, 0 or 4.
10842   ins_encode %{
10843     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10844     __ mr_if_needed($dst$$Register, $src$$Register);
10845   %}
10846   ins_pipe(pipe_class_default);
10847 %}
10848 
10849 //----------Cast instructions (Java-level type cast)---------------------------
10850 
10851 // Cast Long to Pointer for unsafe natives.
10852 instruct castX2P(iRegPdst dst, iRegLsrc src) %{
10853   match(Set dst (CastX2P src));
10854 
10855   format %{ &quot;MR      $dst, $src \t// Long-&gt;Ptr&quot; %}
10856   // variable size, 0 or 4.
10857   ins_encode %{
10858     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10859     __ mr_if_needed($dst$$Register, $src$$Register);
10860   %}
10861  ins_pipe(pipe_class_default);
10862 %}
10863 
10864 // Cast Pointer to Long for unsafe natives.
10865 instruct castP2X(iRegLdst dst, iRegP_N2P src) %{
10866   match(Set dst (CastP2X src));
10867 
10868   format %{ &quot;MR      $dst, $src \t// Ptr-&gt;Long&quot; %}
10869   // variable size, 0 or 4.
10870   ins_encode %{
10871     // TODO: PPC port $archOpcode(ppc64Opcode_or);
10872     __ mr_if_needed($dst$$Register, $src$$Register);
10873   %}
10874   ins_pipe(pipe_class_default);
10875 %}
10876 
10877 instruct castPP(iRegPdst dst) %{
10878   match(Set dst (CastPP dst));
10879   format %{ &quot; -- \t// castPP of $dst&quot; %}
10880   size(0);
10881   ins_encode( /*empty*/ );
10882   ins_pipe(pipe_class_default);
10883 %}
10884 
10885 instruct castII(iRegIdst dst) %{
10886   match(Set dst (CastII dst));
10887   format %{ &quot; -- \t// castII of $dst&quot; %}
10888   size(0);
10889   ins_encode( /*empty*/ );
10890   ins_pipe(pipe_class_default);
10891 %}
10892 
10893 instruct castLL(iRegLdst dst) %{
10894   match(Set dst (CastLL dst));
10895   format %{ &quot; -- \t// castLL of $dst&quot; %}
10896   size(0);
10897   ins_encode( /*empty*/ );
10898   ins_pipe(pipe_class_default);
10899 %}
10900 
10901 instruct checkCastPP(iRegPdst dst) %{
10902   match(Set dst (CheckCastPP dst));
10903   format %{ &quot; -- \t// checkcastPP of $dst&quot; %}
10904   size(0);
10905   ins_encode( /*empty*/ );
10906   ins_pipe(pipe_class_default);
10907 %}
10908 
10909 //----------Convert instructions-----------------------------------------------
10910 
10911 // Convert to boolean.
10912 
10913 // int_to_bool(src) : { 1   if src != 0
10914 //                    { 0   else
10915 //
10916 // strategy:
10917 // 1) Count leading zeros of 32 bit-value src,
10918 //    this returns 32 (0b10.0000) iff src == 0 and &lt;32 otherwise.
10919 // 2) Shift 5 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
10920 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
10921 
10922 // convI2Bool
10923 instruct convI2Bool_reg__cntlz_Ex(iRegIdst dst, iRegIsrc src) %{
10924   match(Set dst (Conv2B src));
10925   predicate(UseCountLeadingZerosInstructionsPPC64);
10926   ins_cost(DEFAULT_COST);
10927 
10928   expand %{
10929     immI shiftAmount %{ 0x5 %}
10930     uimmI16 mask %{ 0x1 %}
10931     iRegIdst tmp1;
10932     iRegIdst tmp2;
10933     countLeadingZerosI(tmp1, src);
10934     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
10935     xorI_reg_uimm16(dst, tmp2, mask);
10936   %}
10937 %}
10938 
10939 instruct convI2Bool_reg__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx) %{
10940   match(Set dst (Conv2B src));
10941   effect(TEMP crx);
10942   predicate(!UseCountLeadingZerosInstructionsPPC64);
10943   ins_cost(DEFAULT_COST);
10944 
10945   format %{ &quot;CMPWI   $crx, $src, #0 \t// convI2B&quot;
10946             &quot;LI      $dst, #0\n\t&quot;
10947             &quot;BEQ     $crx, done\n\t&quot;
10948             &quot;LI      $dst, #1\n&quot;
10949             &quot;done:&quot; %}
10950   size(16);
10951   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x0, 0x1) );
10952   ins_pipe(pipe_class_compare);
10953 %}
10954 
10955 // ConvI2B + XorI
10956 instruct xorI_convI2Bool_reg_immIvalue1__cntlz_Ex(iRegIdst dst, iRegIsrc src, immI_1 mask) %{
10957   match(Set dst (XorI (Conv2B src) mask));
10958   predicate(UseCountLeadingZerosInstructionsPPC64);
10959   ins_cost(DEFAULT_COST);
10960 
10961   expand %{
10962     immI shiftAmount %{ 0x5 %}
10963     iRegIdst tmp1;
10964     countLeadingZerosI(tmp1, src);
10965     urShiftI_reg_imm(dst, tmp1, shiftAmount);
10966   %}
10967 %}
10968 
10969 instruct xorI_convI2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegIsrc src, flagsReg crx, immI_1 mask) %{
10970   match(Set dst (XorI (Conv2B src) mask));
10971   effect(TEMP crx);
10972   predicate(!UseCountLeadingZerosInstructionsPPC64);
10973   ins_cost(DEFAULT_COST);
10974 
10975   format %{ &quot;CMPWI   $crx, $src, #0 \t// Xor(convI2B($src), $mask)&quot;
10976             &quot;LI      $dst, #1\n\t&quot;
10977             &quot;BEQ     $crx, done\n\t&quot;
10978             &quot;LI      $dst, #0\n&quot;
10979             &quot;done:&quot; %}
10980   size(16);
10981   ins_encode( enc_convI2B_regI__cmove(dst, src, crx, 0x1, 0x0) );
10982   ins_pipe(pipe_class_compare);
10983 %}
10984 
10985 // AndI 0b0..010..0 + ConvI2B
10986 instruct convI2Bool_andI_reg_immIpowerOf2(iRegIdst dst, iRegIsrc src, immIpowerOf2 mask) %{
10987   match(Set dst (Conv2B (AndI src mask)));
10988   predicate(UseRotateAndMaskInstructionsPPC64);
10989   ins_cost(DEFAULT_COST);
10990 
10991   format %{ &quot;RLWINM  $dst, $src, $mask \t// convI2B(AndI($src, $mask))&quot; %}
10992   size(4);
10993   ins_encode %{
10994     // TODO: PPC port $archOpcode(ppc64Opcode_rlwinm);
10995     __ rlwinm($dst$$Register, $src$$Register, (32-log2_long((jlong)$mask$$constant)) &amp; 0x1f, 31, 31);
10996   %}
10997   ins_pipe(pipe_class_default);
10998 %}
10999 
11000 // Convert pointer to boolean.
11001 //
11002 // ptr_to_bool(src) : { 1   if src != 0
11003 //                    { 0   else
11004 //
11005 // strategy:
11006 // 1) Count leading zeros of 64 bit-value src,
11007 //    this returns 64 (0b100.0000) iff src == 0 and &lt;64 otherwise.
11008 // 2) Shift 6 bits to the right, result is 0b1 iff src == 0, 0b0 otherwise.
11009 // 3) Xori the result to get 0b1 if src != 0 and 0b0 if src == 0.
11010 
11011 // ConvP2B
11012 instruct convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src) %{
11013   match(Set dst (Conv2B src));
11014   predicate(UseCountLeadingZerosInstructionsPPC64);
11015   ins_cost(DEFAULT_COST);
11016 
11017   expand %{
11018     immI shiftAmount %{ 0x6 %}
11019     uimmI16 mask %{ 0x1 %}
11020     iRegIdst tmp1;
11021     iRegIdst tmp2;
11022     countLeadingZerosP(tmp1, src);
11023     urShiftI_reg_imm(tmp2, tmp1, shiftAmount);
11024     xorI_reg_uimm16(dst, tmp2, mask);
11025   %}
11026 %}
11027 
11028 instruct convP2Bool_reg__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx) %{
11029   match(Set dst (Conv2B src));
11030   effect(TEMP crx);
11031   predicate(!UseCountLeadingZerosInstructionsPPC64);
11032   ins_cost(DEFAULT_COST);
11033 
11034   format %{ &quot;CMPDI   $crx, $src, #0 \t// convP2B&quot;
11035             &quot;LI      $dst, #0\n\t&quot;
11036             &quot;BEQ     $crx, done\n\t&quot;
11037             &quot;LI      $dst, #1\n&quot;
11038             &quot;done:&quot; %}
11039   size(16);
11040   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x0, 0x1) );
11041   ins_pipe(pipe_class_compare);
11042 %}
11043 
11044 // ConvP2B + XorI
11045 instruct xorI_convP2Bool_reg__cntlz_Ex(iRegIdst dst, iRegP_N2P src, immI_1 mask) %{
11046   match(Set dst (XorI (Conv2B src) mask));
11047   predicate(UseCountLeadingZerosInstructionsPPC64);
11048   ins_cost(DEFAULT_COST);
11049 
11050   expand %{
11051     immI shiftAmount %{ 0x6 %}
11052     iRegIdst tmp1;
11053     countLeadingZerosP(tmp1, src);
11054     urShiftI_reg_imm(dst, tmp1, shiftAmount);
11055   %}
11056 %}
11057 
11058 instruct xorI_convP2Bool_reg_immIvalue1__cmove(iRegIdst dst, iRegP_N2P src, flagsReg crx, immI_1 mask) %{
11059   match(Set dst (XorI (Conv2B src) mask));
11060   effect(TEMP crx);
11061   predicate(!UseCountLeadingZerosInstructionsPPC64);
11062   ins_cost(DEFAULT_COST);
11063 
11064   format %{ &quot;CMPDI   $crx, $src, #0 \t// XorI(convP2B($src), $mask)&quot;
11065             &quot;LI      $dst, #1\n\t&quot;
11066             &quot;BEQ     $crx, done\n\t&quot;
11067             &quot;LI      $dst, #0\n&quot;
11068             &quot;done:&quot; %}
11069   size(16);
11070   ins_encode( enc_convP2B_regP__cmove(dst, src, crx, 0x1, 0x0) );
11071   ins_pipe(pipe_class_compare);
11072 %}
11073 
11074 // if src1 &lt; src2, return -1 else return 0
11075 instruct cmpLTMask_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
11076   match(Set dst (CmpLTMask src1 src2));
11077   ins_cost(DEFAULT_COST*4);
11078 
11079   expand %{
11080     iRegLdst src1s;
11081     iRegLdst src2s;
11082     iRegLdst diff;
11083     convI2L_reg(src1s, src1); // Ensure proper sign extension.
11084     convI2L_reg(src2s, src2); // Ensure proper sign extension.
11085     subL_reg_reg(diff, src1s, src2s);
11086     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
11087     signmask64I_regL(dst, diff);
11088   %}
11089 %}
11090 
11091 instruct cmpLTMask_reg_immI0(iRegIdst dst, iRegIsrc src1, immI_0 src2) %{
11092   match(Set dst (CmpLTMask src1 src2)); // if src1 &lt; src2, return -1 else return 0
11093   format %{ &quot;SRAWI   $dst, $src1, $src2 \t// CmpLTMask&quot; %}
11094   size(4);
11095   ins_encode %{
11096     // TODO: PPC port $archOpcode(ppc64Opcode_srawi);
11097     __ srawi($dst$$Register, $src1$$Register, 0x1f);
11098   %}
11099   ins_pipe(pipe_class_default);
11100 %}
11101 
11102 //----------Arithmetic Conversion Instructions---------------------------------
11103 
11104 // Convert to Byte  -- nop
11105 // Convert to Short -- nop
11106 
11107 // Convert to Int
11108 
11109 instruct convB2I_reg(iRegIdst dst, iRegIsrc src, immI_24 amount) %{
11110   match(Set dst (RShiftI (LShiftI src amount) amount));
11111   format %{ &quot;EXTSB   $dst, $src \t// byte-&gt;int&quot; %}
11112   size(4);
11113   ins_encode %{
11114     // TODO: PPC port $archOpcode(ppc64Opcode_extsb);
11115     __ extsb($dst$$Register, $src$$Register);
11116   %}
11117   ins_pipe(pipe_class_default);
11118 %}
11119 
11120 instruct extsh(iRegIdst dst, iRegIsrc src) %{
11121   effect(DEF dst, USE src);
11122 
11123   size(4);
11124   ins_encode %{
11125     __ extsh($dst$$Register, $src$$Register);
11126   %}
11127   ins_pipe(pipe_class_default);
11128 %}
11129 
11130 // LShiftI 16 + RShiftI 16 converts short to int.
11131 instruct convS2I_reg(iRegIdst dst, iRegIsrc src, immI_16 amount) %{
11132   match(Set dst (RShiftI (LShiftI src amount) amount));
11133   format %{ &quot;EXTSH   $dst, $src \t// short-&gt;int&quot; %}
11134   size(4);
11135   ins_encode %{
11136     // TODO: PPC port $archOpcode(ppc64Opcode_extsh);
11137     __ extsh($dst$$Register, $src$$Register);
11138   %}
11139   ins_pipe(pipe_class_default);
11140 %}
11141 
11142 // ConvL2I + ConvI2L: Sign extend int in long register.
11143 instruct sxtI_L2L_reg(iRegLdst dst, iRegLsrc src) %{
11144   match(Set dst (ConvI2L (ConvL2I src)));
11145 
11146   format %{ &quot;EXTSW   $dst, $src \t// long-&gt;long&quot; %}
11147   size(4);
11148   ins_encode %{
11149     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11150     __ extsw($dst$$Register, $src$$Register);
11151   %}
11152   ins_pipe(pipe_class_default);
11153 %}
11154 
11155 instruct convL2I_reg(iRegIdst dst, iRegLsrc src) %{
11156   match(Set dst (ConvL2I src));
11157   format %{ &quot;MR      $dst, $src \t// long-&gt;int&quot; %}
11158   // variable size, 0 or 4
11159   ins_encode %{
11160     // TODO: PPC port $archOpcode(ppc64Opcode_or);
11161     __ mr_if_needed($dst$$Register, $src$$Register);
11162   %}
11163   ins_pipe(pipe_class_default);
11164 %}
11165 
11166 instruct convD2IRaw_regD(regD dst, regD src) %{
11167   // no match-rule, false predicate
11168   effect(DEF dst, USE src);
11169   predicate(false);
11170 
11171   format %{ &quot;FCTIWZ $dst, $src \t// convD2I, $src != NaN&quot; %}
11172   size(4);
11173   ins_encode %{
11174     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);;
11175     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11176   %}
11177   ins_pipe(pipe_class_default);
11178 %}
11179 
11180 instruct cmovI_bso_stackSlotL(iRegIdst dst, flagsRegSrc crx, stackSlotL src) %{
11181   // no match-rule, false predicate
11182   effect(DEF dst, USE crx, USE src);
11183   predicate(false);
11184 
11185   ins_variable_size_depending_on_alignment(true);
11186 
11187   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11188   // Worst case is branch + move + stop, no stop without scheduler.
11189   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11190   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11191   ins_pipe(pipe_class_default);
11192 %}
11193 
11194 instruct cmovI_bso_reg(iRegIdst dst, flagsRegSrc crx, regD src) %{
11195   // no match-rule, false predicate
11196   effect(DEF dst, USE crx, USE src);
11197   predicate(false);
11198 
11199   ins_variable_size_depending_on_alignment(true);
11200 
11201   format %{ &quot;cmovI   $crx, $dst, $src&quot; %}
11202   // Worst case is branch + move + stop, no stop without scheduler.
11203   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 12 : 8));
11204   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11205   ins_pipe(pipe_class_default);
11206 %}
11207 
11208 instruct cmovI_bso_stackSlotL_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, stackSlotL mem) %{
11209   // no match-rule, false predicate
11210   effect(DEF dst, USE crx, USE mem);
11211   predicate(false);
11212 
11213   format %{ &quot;CmovI   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11214   postalloc_expand %{
11215     //
11216     // replaces
11217     //
11218     //   region  dst  crx  mem
11219     //    \       |    |   /
11220     //     dst=cmovI_bso_stackSlotL_conLvalue0
11221     //
11222     // with
11223     //
11224     //   region  dst
11225     //    \       /
11226     //     dst=loadConI16(0)
11227     //      |
11228     //      ^  region  dst  crx  mem
11229     //      |   \       |    |    /
11230     //      dst=cmovI_bso_stackSlotL
11231     //
11232 
11233     // Create new nodes.
11234     MachNode *m1 = new loadConI16Node();
11235     MachNode *m2 = new cmovI_bso_stackSlotLNode();
11236 
11237     // inputs for new nodes
11238     m1-&gt;add_req(n_region);
11239     m2-&gt;add_req(n_region, n_crx, n_mem);
11240 
11241     // precedences for new nodes
11242     m2-&gt;add_prec(m1);
11243 
11244     // operands for new nodes
11245     m1-&gt;_opnds[0] = op_dst;
11246     m1-&gt;_opnds[1] = new immI16Oper(0);
11247 
11248     m2-&gt;_opnds[0] = op_dst;
11249     m2-&gt;_opnds[1] = op_crx;
11250     m2-&gt;_opnds[2] = op_mem;
11251 
11252     // registers for new nodes
11253     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11254     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11255 
11256     // Insert new nodes.
11257     nodes-&gt;push(m1);
11258     nodes-&gt;push(m2);
11259   %}
11260 %}
11261 
11262 instruct cmovI_bso_reg_conLvalue0_Ex(iRegIdst dst, flagsRegSrc crx, regD src) %{
11263   // no match-rule, false predicate
11264   effect(DEF dst, USE crx, USE src);
11265   predicate(false);
11266 
11267   format %{ &quot;CmovI   $dst, $crx, $src \t// postalloc expanded&quot; %}
11268   postalloc_expand %{
11269     //
11270     // replaces
11271     //
11272     //   region  dst  crx  src
11273     //    \       |    |   /
11274     //     dst=cmovI_bso_reg_conLvalue0
11275     //
11276     // with
11277     //
11278     //   region  dst
11279     //    \       /
11280     //     dst=loadConI16(0)
11281     //      |
11282     //      ^  region  dst  crx  src
11283     //      |   \       |    |    /
11284     //      dst=cmovI_bso_reg
11285     //
11286 
11287     // Create new nodes.
11288     MachNode *m1 = new loadConI16Node();
11289     MachNode *m2 = new cmovI_bso_regNode();
11290 
11291     // inputs for new nodes
11292     m1-&gt;add_req(n_region);
11293     m2-&gt;add_req(n_region, n_crx, n_src);
11294 
11295     // precedences for new nodes
11296     m2-&gt;add_prec(m1);
11297 
11298     // operands for new nodes
11299     m1-&gt;_opnds[0] = op_dst;
11300     m1-&gt;_opnds[1] = new immI16Oper(0);
11301 
11302     m2-&gt;_opnds[0] = op_dst;
11303     m2-&gt;_opnds[1] = op_crx;
11304     m2-&gt;_opnds[2] = op_src;
11305 
11306     // registers for new nodes
11307     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11308     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11309 
11310     // Insert new nodes.
11311     nodes-&gt;push(m1);
11312     nodes-&gt;push(m2);
11313   %}
11314 %}
11315 
11316 // Double to Int conversion, NaN is mapped to 0.
11317 instruct convD2I_reg_ExEx(iRegIdst dst, regD src) %{
11318   match(Set dst (ConvD2I src));
11319   predicate(!VM_Version::has_mtfprd());
11320   ins_cost(DEFAULT_COST);
11321 
11322   expand %{
11323     regD tmpD;
11324     stackSlotL tmpS;
11325     flagsReg crx;
11326     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11327     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11328     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11329     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11330   %}
11331 %}
11332 
11333 // Double to Int conversion, NaN is mapped to 0. Special version for Power8.
11334 instruct convD2I_reg_mffprd_ExEx(iRegIdst dst, regD src) %{
11335   match(Set dst (ConvD2I src));
11336   predicate(VM_Version::has_mtfprd());
11337   ins_cost(DEFAULT_COST);
11338 
11339   expand %{
11340     regD tmpD;
11341     flagsReg crx;
11342     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11343     convD2IRaw_regD(tmpD, src);                         // Convert float to int (speculated).
11344     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11345   %}
11346 %}
11347 
11348 instruct convF2IRaw_regF(regF dst, regF src) %{
11349   // no match-rule, false predicate
11350   effect(DEF dst, USE src);
11351   predicate(false);
11352 
11353   format %{ &quot;FCTIWZ $dst, $src \t// convF2I, $src != NaN&quot; %}
11354   size(4);
11355   ins_encode %{
11356     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11357     __ fctiwz($dst$$FloatRegister, $src$$FloatRegister);
11358   %}
11359   ins_pipe(pipe_class_default);
11360 %}
11361 
11362 // Float to Int conversion, NaN is mapped to 0.
11363 instruct convF2I_regF_ExEx(iRegIdst dst, regF src) %{
11364   match(Set dst (ConvF2I src));
11365   predicate(!VM_Version::has_mtfprd());
11366   ins_cost(DEFAULT_COST);
11367 
11368   expand %{
11369     regF tmpF;
11370     stackSlotL tmpS;
11371     flagsReg crx;
11372     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11373     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11374     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11375     cmovI_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11376   %}
11377 %}
11378 
11379 // Float to Int conversion, NaN is mapped to 0. Special version for Power8.
11380 instruct convF2I_regF_mffprd_ExEx(iRegIdst dst, regF src) %{
11381   match(Set dst (ConvF2I src));
11382   predicate(VM_Version::has_mtfprd());
11383   ins_cost(DEFAULT_COST);
11384 
11385   expand %{
11386     regF tmpF;
11387     flagsReg crx;
11388     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11389     convF2IRaw_regF(tmpF, src);                         // Convert float to int (speculated).
11390     cmovI_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11391   %}
11392 %}
11393 
11394 // Convert to Long
11395 
11396 instruct convI2L_reg(iRegLdst dst, iRegIsrc src) %{
11397   match(Set dst (ConvI2L src));
11398   format %{ &quot;EXTSW   $dst, $src \t// int-&gt;long&quot; %}
11399   size(4);
11400   ins_encode %{
11401     // TODO: PPC port $archOpcode(ppc64Opcode_extsw);
11402     __ extsw($dst$$Register, $src$$Register);
11403   %}
11404   ins_pipe(pipe_class_default);
11405 %}
11406 
11407 // Zero-extend: convert unsigned int to long (convUI2L).
11408 instruct zeroExtendL_regI(iRegLdst dst, iRegIsrc src, immL_32bits mask) %{
11409   match(Set dst (AndL (ConvI2L src) mask));
11410   ins_cost(DEFAULT_COST);
11411 
11412   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11413   size(4);
11414   ins_encode %{
11415     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11416     __ clrldi($dst$$Register, $src$$Register, 32);
11417   %}
11418   ins_pipe(pipe_class_default);
11419 %}
11420 
11421 // Zero-extend: convert unsigned int to long in long register.
11422 instruct zeroExtendL_regL(iRegLdst dst, iRegLsrc src, immL_32bits mask) %{
11423   match(Set dst (AndL src mask));
11424   ins_cost(DEFAULT_COST);
11425 
11426   format %{ &quot;CLRLDI  $dst, $src, #32 \t// zero-extend int to long&quot; %}
11427   size(4);
11428   ins_encode %{
11429     // TODO: PPC port $archOpcode(ppc64Opcode_rldicl);
11430     __ clrldi($dst$$Register, $src$$Register, 32);
11431   %}
11432   ins_pipe(pipe_class_default);
11433 %}
11434 
11435 instruct convF2LRaw_regF(regF dst, regF src) %{
11436   // no match-rule, false predicate
11437   effect(DEF dst, USE src);
11438   predicate(false);
11439 
11440   format %{ &quot;FCTIDZ $dst, $src \t// convF2L, $src != NaN&quot; %}
11441   size(4);
11442   ins_encode %{
11443     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11444     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11445   %}
11446   ins_pipe(pipe_class_default);
11447 %}
11448 
11449 instruct cmovL_bso_stackSlotL(iRegLdst dst, flagsRegSrc crx, stackSlotL src) %{
11450   // no match-rule, false predicate
11451   effect(DEF dst, USE crx, USE src);
11452   predicate(false);
11453 
11454   ins_variable_size_depending_on_alignment(true);
11455 
11456   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11457   // Worst case is branch + move + stop, no stop without scheduler.
11458   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11459   ins_encode( enc_cmove_bso_stackSlotL(dst, crx, src) );
11460   ins_pipe(pipe_class_default);
11461 %}
11462 
11463 instruct cmovL_bso_reg(iRegLdst dst, flagsRegSrc crx, regD src) %{
11464   // no match-rule, false predicate
11465   effect(DEF dst, USE crx, USE src);
11466   predicate(false);
11467 
11468   ins_variable_size_depending_on_alignment(true);
11469 
11470   format %{ &quot;cmovL   $crx, $dst, $src&quot; %}
11471   // Worst case is branch + move + stop, no stop without scheduler.
11472   size((false /* TODO: PPC PORT Compile::current()-&gt;do_hb_scheduling()*/ ? 12 : 8));
11473   ins_encode( enc_cmove_bso_reg(dst, crx, src) );
11474   ins_pipe(pipe_class_default);
11475 %}
11476 
11477 instruct cmovL_bso_stackSlotL_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, stackSlotL mem) %{
11478   // no match-rule, false predicate
11479   effect(DEF dst, USE crx, USE mem);
11480   predicate(false);
11481 
11482   format %{ &quot;CmovL   $dst, $crx, $mem \t// postalloc expanded&quot; %}
11483   postalloc_expand %{
11484     //
11485     // replaces
11486     //
11487     //   region  dst  crx  mem
11488     //    \       |    |   /
11489     //     dst=cmovL_bso_stackSlotL_conLvalue0
11490     //
11491     // with
11492     //
11493     //   region  dst
11494     //    \       /
11495     //     dst=loadConL16(0)
11496     //      |
11497     //      ^  region  dst  crx  mem
11498     //      |   \       |    |    /
11499     //      dst=cmovL_bso_stackSlotL
11500     //
11501 
11502     // Create new nodes.
11503     MachNode *m1 = new loadConL16Node();
11504     MachNode *m2 = new cmovL_bso_stackSlotLNode();
11505 
11506     // inputs for new nodes
11507     m1-&gt;add_req(n_region);
11508     m2-&gt;add_req(n_region, n_crx, n_mem);
11509     m2-&gt;add_prec(m1);
11510 
11511     // operands for new nodes
11512     m1-&gt;_opnds[0] = op_dst;
11513     m1-&gt;_opnds[1] = new immL16Oper(0);
11514     m2-&gt;_opnds[0] = op_dst;
11515     m2-&gt;_opnds[1] = op_crx;
11516     m2-&gt;_opnds[2] = op_mem;
11517 
11518     // registers for new nodes
11519     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11520     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11521 
11522     // Insert new nodes.
11523     nodes-&gt;push(m1);
11524     nodes-&gt;push(m2);
11525   %}
11526 %}
11527 
11528 instruct cmovL_bso_reg_conLvalue0_Ex(iRegLdst dst, flagsRegSrc crx, regD src) %{
11529   // no match-rule, false predicate
11530   effect(DEF dst, USE crx, USE src);
11531   predicate(false);
11532 
11533   format %{ &quot;CmovL   $dst, $crx, $src \t// postalloc expanded&quot; %}
11534   postalloc_expand %{
11535     //
11536     // replaces
11537     //
11538     //   region  dst  crx  src
11539     //    \       |    |   /
11540     //     dst=cmovL_bso_reg_conLvalue0
11541     //
11542     // with
11543     //
11544     //   region  dst
11545     //    \       /
11546     //     dst=loadConL16(0)
11547     //      |
11548     //      ^  region  dst  crx  src
11549     //      |   \       |    |    /
11550     //      dst=cmovL_bso_reg
11551     //
11552 
11553     // Create new nodes.
11554     MachNode *m1 = new loadConL16Node();
11555     MachNode *m2 = new cmovL_bso_regNode();
11556 
11557     // inputs for new nodes
11558     m1-&gt;add_req(n_region);
11559     m2-&gt;add_req(n_region, n_crx, n_src);
11560     m2-&gt;add_prec(m1);
11561 
11562     // operands for new nodes
11563     m1-&gt;_opnds[0] = op_dst;
11564     m1-&gt;_opnds[1] = new immL16Oper(0);
11565     m2-&gt;_opnds[0] = op_dst;
11566     m2-&gt;_opnds[1] = op_crx;
11567     m2-&gt;_opnds[2] = op_src;
11568 
11569     // registers for new nodes
11570     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11571     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
11572 
11573     // Insert new nodes.
11574     nodes-&gt;push(m1);
11575     nodes-&gt;push(m2);
11576   %}
11577 %}
11578 
11579 // Float to Long conversion, NaN is mapped to 0.
11580 instruct convF2L_reg_ExEx(iRegLdst dst, regF src) %{
11581   match(Set dst (ConvF2L src));
11582   predicate(!VM_Version::has_mtfprd());
11583   ins_cost(DEFAULT_COST);
11584 
11585   expand %{
11586     regF tmpF;
11587     stackSlotL tmpS;
11588     flagsReg crx;
11589     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11590     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11591     moveF2L_reg_stack(tmpS, tmpF);                      // Store float to stack (speculated).
11592     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11593   %}
11594 %}
11595 
11596 // Float to Long conversion, NaN is mapped to 0. Special version for Power8.
11597 instruct convF2L_reg_mffprd_ExEx(iRegLdst dst, regF src) %{
11598   match(Set dst (ConvF2L src));
11599   predicate(VM_Version::has_mtfprd());
11600   ins_cost(DEFAULT_COST);
11601 
11602   expand %{
11603     regF tmpF;
11604     flagsReg crx;
11605     cmpFUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11606     convF2LRaw_regF(tmpF, src);                         // Convert float to long (speculated).
11607     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpF);        // Cmove based on NaN check.
11608   %}
11609 %}
11610 
11611 instruct convD2LRaw_regD(regD dst, regD src) %{
11612   // no match-rule, false predicate
11613   effect(DEF dst, USE src);
11614   predicate(false);
11615 
11616   format %{ &quot;FCTIDZ $dst, $src \t// convD2L $src != NaN&quot; %}
11617   size(4);
11618   ins_encode %{
11619     // TODO: PPC port $archOpcode(ppc64Opcode_fctiwz);
11620     __ fctidz($dst$$FloatRegister, $src$$FloatRegister);
11621   %}
11622   ins_pipe(pipe_class_default);
11623 %}
11624 
11625 // Double to Long conversion, NaN is mapped to 0.
11626 instruct convD2L_reg_ExEx(iRegLdst dst, regD src) %{
11627   match(Set dst (ConvD2L src));
11628   predicate(!VM_Version::has_mtfprd());
11629   ins_cost(DEFAULT_COST);
11630 
11631   expand %{
11632     regD tmpD;
11633     stackSlotL tmpS;
11634     flagsReg crx;
11635     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11636     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11637     moveD2L_reg_stack(tmpS, tmpD);                      // Store float to stack (speculated).
11638     cmovL_bso_stackSlotL_conLvalue0_Ex(dst, crx, tmpS); // Cmove based on NaN check.
11639   %}
11640 %}
11641 
11642 // Double to Long conversion, NaN is mapped to 0. Special version for Power8.
11643 instruct convD2L_reg_mffprd_ExEx(iRegLdst dst, regD src) %{
11644   match(Set dst (ConvD2L src));
11645   predicate(VM_Version::has_mtfprd());
11646   ins_cost(DEFAULT_COST);
11647 
11648   expand %{
11649     regD tmpD;
11650     flagsReg crx;
11651     cmpDUnordered_reg_reg(crx, src, src);               // Check whether src is NaN.
11652     convD2LRaw_regD(tmpD, src);                         // Convert float to long (speculated).
11653     cmovL_bso_reg_conLvalue0_Ex(dst, crx, tmpD);        // Cmove based on NaN check.
11654   %}
11655 %}
11656 
11657 // Convert to Float
11658 
11659 // Placed here as needed in expand.
11660 instruct convL2DRaw_regD(regD dst, regD src) %{
11661   // no match-rule, false predicate
11662   effect(DEF dst, USE src);
11663   predicate(false);
11664 
11665   format %{ &quot;FCFID $dst, $src \t// convL2D&quot; %}
11666   size(4);
11667   ins_encode %{
11668     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11669     __ fcfid($dst$$FloatRegister, $src$$FloatRegister);
11670   %}
11671   ins_pipe(pipe_class_default);
11672 %}
11673 
11674 // Placed here as needed in expand.
11675 instruct convD2F_reg(regF dst, regD src) %{
11676   match(Set dst (ConvD2F src));
11677   format %{ &quot;FRSP    $dst, $src \t// convD2F&quot; %}
11678   size(4);
11679   ins_encode %{
11680     // TODO: PPC port $archOpcode(ppc64Opcode_frsp);
11681     __ frsp($dst$$FloatRegister, $src$$FloatRegister);
11682   %}
11683   ins_pipe(pipe_class_default);
11684 %}
11685 
11686 // Integer to Float conversion.
11687 instruct convI2F_ireg_Ex(regF dst, iRegIsrc src) %{
11688   match(Set dst (ConvI2F src));
11689   predicate(!VM_Version::has_fcfids());
11690   ins_cost(DEFAULT_COST);
11691 
11692   expand %{
11693     iRegLdst tmpL;
11694     stackSlotL tmpS;
11695     regD tmpD;
11696     regD tmpD2;
11697     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11698     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11699     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11700     convL2DRaw_regD(tmpD2, tmpD);        // Convert to double.
11701     convD2F_reg(dst, tmpD2);             // Convert double to float.
11702   %}
11703 %}
11704 
11705 instruct convL2FRaw_regF(regF dst, regD src) %{
11706   // no match-rule, false predicate
11707   effect(DEF dst, USE src);
11708   predicate(false);
11709 
11710   format %{ &quot;FCFIDS $dst, $src \t// convL2F&quot; %}
11711   size(4);
11712   ins_encode %{
11713     // TODO: PPC port $archOpcode(ppc64Opcode_fcfid);
11714     __ fcfids($dst$$FloatRegister, $src$$FloatRegister);
11715   %}
11716   ins_pipe(pipe_class_default);
11717 %}
11718 
11719 // Integer to Float conversion. Special version for Power7.
11720 instruct convI2F_ireg_fcfids_Ex(regF dst, iRegIsrc src) %{
11721   match(Set dst (ConvI2F src));
11722   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11723   ins_cost(DEFAULT_COST);
11724 
11725   expand %{
11726     iRegLdst tmpL;
11727     stackSlotL tmpS;
11728     regD tmpD;
11729     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11730     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11731     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11732     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11733   %}
11734 %}
11735 
11736 // Integer to Float conversion. Special version for Power8.
11737 instruct convI2F_ireg_mtfprd_Ex(regF dst, iRegIsrc src) %{
11738   match(Set dst (ConvI2F src));
11739   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11740   ins_cost(DEFAULT_COST);
11741 
11742   expand %{
11743     regD tmpD;
11744     moveI2D_reg(tmpD, src);
11745     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11746   %}
11747 %}
11748 
11749 // L2F to avoid runtime call.
11750 instruct convL2F_ireg_fcfids_Ex(regF dst, iRegLsrc src) %{
11751   match(Set dst (ConvL2F src));
11752   predicate(VM_Version::has_fcfids() &amp;&amp; !VM_Version::has_mtfprd());
11753   ins_cost(DEFAULT_COST);
11754 
11755   expand %{
11756     stackSlotL tmpS;
11757     regD tmpD;
11758     regL_to_stkL(tmpS, src);             // Store long to stack.
11759     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11760     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11761   %}
11762 %}
11763 
11764 // L2F to avoid runtime call.  Special version for Power8.
11765 instruct convL2F_ireg_mtfprd_Ex(regF dst, iRegLsrc src) %{
11766   match(Set dst (ConvL2F src));
11767   predicate(VM_Version::has_fcfids() &amp;&amp; VM_Version::has_mtfprd());
11768   ins_cost(DEFAULT_COST);
11769 
11770   expand %{
11771     regD tmpD;
11772     moveL2D_reg(tmpD, src);
11773     convL2FRaw_regF(dst, tmpD);          // Convert to float.
11774   %}
11775 %}
11776 
11777 // Moved up as used in expand.
11778 //instruct convD2F_reg(regF dst, regD src) %{%}
11779 
11780 // Convert to Double
11781 
11782 // Integer to Double conversion.
11783 instruct convI2D_reg_Ex(regD dst, iRegIsrc src) %{
11784   match(Set dst (ConvI2D src));
11785   predicate(!VM_Version::has_mtfprd());
11786   ins_cost(DEFAULT_COST);
11787 
11788   expand %{
11789     iRegLdst tmpL;
11790     stackSlotL tmpS;
11791     regD tmpD;
11792     convI2L_reg(tmpL, src);              // Sign-extension int to long.
11793     regL_to_stkL(tmpS, tmpL);            // Store long to stack.
11794     moveL2D_stack_reg(tmpD, tmpS);       // Load long into double register.
11795     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11796   %}
11797 %}
11798 
11799 // Integer to Double conversion. Special version for Power8.
11800 instruct convI2D_reg_mtfprd_Ex(regD dst, iRegIsrc src) %{
11801   match(Set dst (ConvI2D src));
11802   predicate(VM_Version::has_mtfprd());
11803   ins_cost(DEFAULT_COST);
11804 
11805   expand %{
11806     regD tmpD;
11807     moveI2D_reg(tmpD, src);
11808     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11809   %}
11810 %}
11811 
11812 // Long to Double conversion
11813 instruct convL2D_reg_Ex(regD dst, stackSlotL src) %{
11814   match(Set dst (ConvL2D src));
11815   ins_cost(DEFAULT_COST + MEMORY_REF_COST);
11816 
11817   expand %{
11818     regD tmpD;
11819     moveL2D_stack_reg(tmpD, src);
11820     convL2DRaw_regD(dst, tmpD);
11821   %}
11822 %}
11823 
11824 // Long to Double conversion. Special version for Power8.
11825 instruct convL2D_reg_mtfprd_Ex(regD dst, iRegLsrc src) %{
11826   match(Set dst (ConvL2D src));
11827   predicate(VM_Version::has_mtfprd());
11828   ins_cost(DEFAULT_COST);
11829 
11830   expand %{
11831     regD tmpD;
11832     moveL2D_reg(tmpD, src);
11833     convL2DRaw_regD(dst, tmpD);          // Convert to double.
11834   %}
11835 %}
11836 
11837 instruct convF2D_reg(regD dst, regF src) %{
11838   match(Set dst (ConvF2D src));
11839   format %{ &quot;FMR     $dst, $src \t// float-&gt;double&quot; %}
11840   // variable size, 0 or 4
11841   ins_encode %{
11842     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
11843     __ fmr_if_needed($dst$$FloatRegister, $src$$FloatRegister);
11844   %}
11845   ins_pipe(pipe_class_default);
11846 %}
11847 
11848 //----------Control Flow Instructions------------------------------------------
11849 // Compare Instructions
11850 
11851 // Compare Integers
11852 instruct cmpI_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
11853   match(Set crx (CmpI src1 src2));
11854   size(4);
11855   format %{ &quot;CMPW    $crx, $src1, $src2&quot; %}
11856   ins_encode %{
11857     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11858     __ cmpw($crx$$CondRegister, $src1$$Register, $src2$$Register);
11859   %}
11860   ins_pipe(pipe_class_compare);
11861 %}
11862 
11863 instruct cmpI_reg_imm16(flagsReg crx, iRegIsrc src1, immI16 src2) %{
11864   match(Set crx (CmpI src1 src2));
11865   format %{ &quot;CMPWI   $crx, $src1, $src2&quot; %}
11866   size(4);
11867   ins_encode %{
11868     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11869     __ cmpwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11870   %}
11871   ins_pipe(pipe_class_compare);
11872 %}
11873 
11874 // (src1 &amp; src2) == 0?
11875 instruct testI_reg_imm(flagsRegCR0 cr0, iRegIsrc src1, uimmI16 src2, immI_0 zero) %{
11876   match(Set cr0 (CmpI (AndI src1 src2) zero));
11877   // r0 is killed
11878   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST int&quot; %}
11879   size(4);
11880   ins_encode %{
11881     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11882     __ andi_(R0, $src1$$Register, $src2$$constant);
11883   %}
11884   ins_pipe(pipe_class_compare);
11885 %}
11886 
11887 instruct cmpL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11888   match(Set crx (CmpL src1 src2));
11889   format %{ &quot;CMPD    $crx, $src1, $src2&quot; %}
11890   size(4);
11891   ins_encode %{
11892     // TODO: PPC port $archOpcode(ppc64Opcode_cmp);
11893     __ cmpd($crx$$CondRegister, $src1$$Register, $src2$$Register);
11894   %}
11895   ins_pipe(pipe_class_compare);
11896 %}
11897 
11898 instruct cmpL_reg_imm16(flagsReg crx, iRegLsrc src1, immL16 src2) %{
11899   match(Set crx (CmpL src1 src2));
11900   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
11901   size(4);
11902   ins_encode %{
11903     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
11904     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11905   %}
11906   ins_pipe(pipe_class_compare);
11907 %}
11908 
11909 // Added CmpUL for LoopPredicate.
11910 instruct cmpUL_reg_reg(flagsReg crx, iRegLsrc src1, iRegLsrc src2) %{
11911   match(Set crx (CmpUL src1 src2));
11912   format %{ &quot;CMPLD   $crx, $src1, $src2&quot; %}
11913   size(4);
11914   ins_encode %{
11915     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
11916     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
11917   %}
11918   ins_pipe(pipe_class_compare);
11919 %}
11920 
11921 instruct cmpUL_reg_imm16(flagsReg crx, iRegLsrc src1, uimmL16 src2) %{
11922   match(Set crx (CmpUL src1 src2));
11923   format %{ &quot;CMPLDI  $crx, $src1, $src2&quot; %}
11924   size(4);
11925   ins_encode %{
11926     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
11927     __ cmpldi($crx$$CondRegister, $src1$$Register, $src2$$constant);
11928   %}
11929   ins_pipe(pipe_class_compare);
11930 %}
11931 
11932 instruct testL_reg_reg(flagsRegCR0 cr0, iRegLsrc src1, iRegLsrc src2, immL_0 zero) %{
11933   match(Set cr0 (CmpL (AndL src1 src2) zero));
11934   // r0 is killed
11935   format %{ &quot;AND     R0, $src1, $src2 \t// BTST long&quot; %}
11936   size(4);
11937   ins_encode %{
11938     // TODO: PPC port $archOpcode(ppc64Opcode_and_);
11939     __ and_(R0, $src1$$Register, $src2$$Register);
11940   %}
11941   ins_pipe(pipe_class_compare);
11942 %}
11943 
11944 instruct testL_reg_imm(flagsRegCR0 cr0, iRegLsrc src1, uimmL16 src2, immL_0 zero) %{
11945   match(Set cr0 (CmpL (AndL src1 src2) zero));
11946   // r0 is killed
11947   format %{ &quot;ANDI    R0, $src1, $src2 \t// BTST long&quot; %}
11948   size(4);
11949   ins_encode %{
11950     // TODO: PPC port $archOpcode(ppc64Opcode_andi_);
11951     __ andi_(R0, $src1$$Register, $src2$$constant);
11952   %}
11953   ins_pipe(pipe_class_compare);
11954 %}
11955 
11956 instruct cmovI_conIvalueMinus1_conIvalue1(iRegIdst dst, flagsRegSrc crx) %{
11957   // no match-rule, false predicate
11958   effect(DEF dst, USE crx);
11959   predicate(false);
11960 
11961   ins_variable_size_depending_on_alignment(true);
11962 
11963   format %{ &quot;cmovI   $crx, $dst, -1, 0, +1&quot; %}
11964   // Worst case is branch + move + branch + move + stop, no stop without scheduler.
11965   size((false /* TODO: PPC PORTInsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 20 : 16));
11966   ins_encode %{
11967     // TODO: PPC port $archOpcode(ppc64Opcode_cmove);
11968     Label done;
11969     // li(Rdst, 0);              // equal -&gt; 0
11970     __ beq($crx$$CondRegister, done);
11971     __ li($dst$$Register, 1);    // greater -&gt; +1
11972     __ bgt($crx$$CondRegister, done);
11973     __ li($dst$$Register, -1);   // unordered or less -&gt; -1
11974     // TODO: PPC port__ endgroup_if_needed(_size == 20);
11975     __ bind(done);
11976   %}
11977   ins_pipe(pipe_class_compare);
11978 %}
11979 
11980 instruct cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(iRegIdst dst, flagsRegSrc crx) %{
11981   // no match-rule, false predicate
11982   effect(DEF dst, USE crx);
11983   predicate(false);
11984 
11985   format %{ &quot;CmovI    $crx, $dst, -1, 0, +1 \t// postalloc expanded&quot; %}
11986   postalloc_expand %{
11987     //
11988     // replaces
11989     //
11990     //   region  crx
11991     //    \       |
11992     //     dst=cmovI_conIvalueMinus1_conIvalue0_conIvalue1
11993     //
11994     // with
11995     //
11996     //   region
11997     //    \
11998     //     dst=loadConI16(0)
11999     //      |
12000     //      ^  region  crx
12001     //      |   \       |
12002     //      dst=cmovI_conIvalueMinus1_conIvalue1
12003     //
12004 
12005     // Create new nodes.
12006     MachNode *m1 = new loadConI16Node();
12007     MachNode *m2 = new cmovI_conIvalueMinus1_conIvalue1Node();
12008 
12009     // inputs for new nodes
12010     m1-&gt;add_req(n_region);
12011     m2-&gt;add_req(n_region, n_crx);
12012     m2-&gt;add_prec(m1);
12013 
12014     // operands for new nodes
12015     m1-&gt;_opnds[0] = op_dst;
12016     m1-&gt;_opnds[1] = new immI16Oper(0);
12017     m2-&gt;_opnds[0] = op_dst;
12018     m2-&gt;_opnds[1] = op_crx;
12019 
12020     // registers for new nodes
12021     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12022     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // dst
12023 
12024     // Insert new nodes.
12025     nodes-&gt;push(m1);
12026     nodes-&gt;push(m2);
12027   %}
12028 %}
12029 
12030 // Manifest a CmpL3 result in an integer register. Very painful.
12031 // This is the test to avoid.
12032 // (src1 &lt; src2) ? -1 : ((src1 &gt; src2) ? 1 : 0)
12033 instruct cmpL3_reg_reg_ExEx(iRegIdst dst, iRegLsrc src1, iRegLsrc src2) %{
12034   match(Set dst (CmpL3 src1 src2));
12035   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12036 
12037   expand %{
12038     flagsReg tmp1;
12039     cmpL_reg_reg(tmp1, src1, src2);
12040     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12041   %}
12042 %}
12043 
12044 // Implicit range checks.
12045 // A range check in the ideal world has one of the following shapes:
12046 //  - (If le (CmpU length index)), (IfTrue  throw exception)
12047 //  - (If lt (CmpU index length)), (IfFalse throw exception)
12048 //
12049 // Match range check &#39;If le (CmpU length index)&#39;.
12050 instruct rangeCheck_iReg_uimm15(cmpOp cmp, iRegIsrc src_length, uimmI15 index, label labl) %{
12051   match(If cmp (CmpU src_length index));
12052   effect(USE labl);
12053   predicate(TrapBasedRangeChecks &amp;&amp;
12054             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le &amp;&amp;
12055             PROB_UNLIKELY(_leaf-&gt;as_If()-&gt;_prob) &gt;= PROB_ALWAYS &amp;&amp;
12056             (Matcher::branches_to_uncommon_trap(_leaf)));
12057 
12058   ins_is_TrapBasedCheckNode(true);
12059 
12060   format %{ &quot;TWI     $index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12061   size(4);
12062   ins_encode %{
12063     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12064     if ($cmp$$cmpcode == 0x1 /* less_equal */) {
12065       __ trap_range_check_le($src_length$$Register, $index$$constant);
12066     } else {
12067       // Both successors are uncommon traps, probability is 0.
12068       // Node got flipped during fixup flow.
12069       assert($cmp$$cmpcode == 0x9, &quot;must be greater&quot;);
12070       __ trap_range_check_g($src_length$$Register, $index$$constant);
12071     }
12072   %}
12073   ins_pipe(pipe_class_trap);
12074 %}
12075 
12076 // Match range check &#39;If lt (CmpU index length)&#39;.
12077 instruct rangeCheck_iReg_iReg(cmpOp cmp, iRegIsrc src_index, iRegIsrc src_length, label labl) %{
12078   match(If cmp (CmpU src_index src_length));
12079   effect(USE labl);
12080   predicate(TrapBasedRangeChecks &amp;&amp;
12081             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12082             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12083             (Matcher::branches_to_uncommon_trap(_leaf)));
12084 
12085   ins_is_TrapBasedCheckNode(true);
12086 
12087   format %{ &quot;TW      $src_index $cmp $src_length \t// RangeCheck =&gt; trap $labl&quot; %}
12088   size(4);
12089   ins_encode %{
12090     // TODO: PPC port $archOpcode(ppc64Opcode_tw);
12091     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12092       __ trap_range_check_ge($src_index$$Register, $src_length$$Register);
12093     } else {
12094       // Both successors are uncommon traps, probability is 0.
12095       // Node got flipped during fixup flow.
12096       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12097       __ trap_range_check_l($src_index$$Register, $src_length$$Register);
12098     }
12099   %}
12100   ins_pipe(pipe_class_trap);
12101 %}
12102 
12103 // Match range check &#39;If lt (CmpU index length)&#39;.
12104 instruct rangeCheck_uimm15_iReg(cmpOp cmp, iRegIsrc src_index, uimmI15 length, label labl) %{
12105   match(If cmp (CmpU src_index length));
12106   effect(USE labl);
12107   predicate(TrapBasedRangeChecks &amp;&amp;
12108             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt &amp;&amp;
12109             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_ALWAYS &amp;&amp;
12110             (Matcher::branches_to_uncommon_trap(_leaf)));
12111 
12112   ins_is_TrapBasedCheckNode(true);
12113 
12114   format %{ &quot;TWI     $src_index $cmp $length \t// RangeCheck =&gt; trap $labl&quot; %}
12115   size(4);
12116   ins_encode %{
12117     // TODO: PPC port $archOpcode(ppc64Opcode_twi);
12118     if ($cmp$$cmpcode == 0x0 /* greater_equal */) {
12119       __ trap_range_check_ge($src_index$$Register, $length$$constant);
12120     } else {
12121       // Both successors are uncommon traps, probability is 0.
12122       // Node got flipped during fixup flow.
12123       assert($cmp$$cmpcode == 0x8, &quot;must be less&quot;);
12124       __ trap_range_check_l($src_index$$Register, $length$$constant);
12125     }
12126   %}
12127   ins_pipe(pipe_class_trap);
12128 %}
12129 
12130 instruct compU_reg_reg(flagsReg crx, iRegIsrc src1, iRegIsrc src2) %{
12131   match(Set crx (CmpU src1 src2));
12132   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// unsigned&quot; %}
12133   size(4);
12134   ins_encode %{
12135     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12136     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12137   %}
12138   ins_pipe(pipe_class_compare);
12139 %}
12140 
12141 instruct compU_reg_uimm16(flagsReg crx, iRegIsrc src1, uimmI16 src2) %{
12142   match(Set crx (CmpU src1 src2));
12143   size(4);
12144   format %{ &quot;CMPLWI  $crx, $src1, $src2&quot; %}
12145   ins_encode %{
12146     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12147     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12148   %}
12149   ins_pipe(pipe_class_compare);
12150 %}
12151 
12152 // Implicit zero checks (more implicit null checks).
12153 // No constant pool entries required.
12154 instruct zeroCheckN_iReg_imm0(cmpOp cmp, iRegNsrc value, immN_0 zero, label labl) %{
12155   match(If cmp (CmpN value zero));
12156   effect(USE labl);
12157   predicate(TrapBasedNullChecks &amp;&amp;
12158             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12159             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12160             Matcher::branches_to_uncommon_trap(_leaf));
12161   ins_cost(1);
12162 
12163   ins_is_TrapBasedCheckNode(true);
12164 
12165   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckN =&gt; trap $labl&quot; %}
12166   size(4);
12167   ins_encode %{
12168     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12169     if ($cmp$$cmpcode == 0xA) {
12170       __ trap_null_check($value$$Register);
12171     } else {
12172       // Both successors are uncommon traps, probability is 0.
12173       // Node got flipped during fixup flow.
12174       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12175       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12176     }
12177   %}
12178   ins_pipe(pipe_class_trap);
12179 %}
12180 
12181 // Compare narrow oops.
12182 instruct cmpN_reg_reg(flagsReg crx, iRegNsrc src1, iRegNsrc src2) %{
12183   match(Set crx (CmpN src1 src2));
12184 
12185   size(4);
12186   ins_cost(2);
12187   format %{ &quot;CMPLW   $crx, $src1, $src2 \t// compressed ptr&quot; %}
12188   ins_encode %{
12189     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12190     __ cmplw($crx$$CondRegister, $src1$$Register, $src2$$Register);
12191   %}
12192   ins_pipe(pipe_class_compare);
12193 %}
12194 
12195 instruct cmpN_reg_imm0(flagsReg crx, iRegNsrc src1, immN_0 src2) %{
12196   match(Set crx (CmpN src1 src2));
12197   // Make this more expensive than zeroCheckN_iReg_imm0.
12198   ins_cost(2);
12199 
12200   format %{ &quot;CMPLWI  $crx, $src1, $src2 \t// compressed ptr&quot; %}
12201   size(4);
12202   ins_encode %{
12203     // TODO: PPC port $archOpcode(ppc64Opcode_cmpli);
12204     __ cmplwi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12205   %}
12206   ins_pipe(pipe_class_compare);
12207 %}
12208 
12209 // Implicit zero checks (more implicit null checks).
12210 // No constant pool entries required.
12211 instruct zeroCheckP_reg_imm0(cmpOp cmp, iRegP_N2P value, immP_0 zero, label labl) %{
12212   match(If cmp (CmpP value zero));
12213   effect(USE labl);
12214   predicate(TrapBasedNullChecks &amp;&amp;
12215             _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne &amp;&amp;
12216             _leaf-&gt;as_If()-&gt;_prob &gt;= PROB_LIKELY_MAG(4) &amp;&amp;
12217             Matcher::branches_to_uncommon_trap(_leaf));
12218   ins_cost(1); // Should not be cheaper than zeroCheckN.
12219 
12220   ins_is_TrapBasedCheckNode(true);
12221 
12222   format %{ &quot;TDI     $value $cmp $zero \t// ZeroCheckP =&gt; trap $labl&quot; %}
12223   size(4);
12224   ins_encode %{
12225     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
12226     if ($cmp$$cmpcode == 0xA) {
12227       __ trap_null_check($value$$Register);
12228     } else {
12229       // Both successors are uncommon traps, probability is 0.
12230       // Node got flipped during fixup flow.
12231       assert($cmp$$cmpcode == 0x2 , &quot;must be equal(0xA) or notEqual(0x2)&quot;);
12232       __ trap_null_check($value$$Register, Assembler::traptoGreaterThanUnsigned);
12233     }
12234   %}
12235   ins_pipe(pipe_class_trap);
12236 %}
12237 
12238 // Compare Pointers
12239 instruct cmpP_reg_reg(flagsReg crx, iRegP_N2P src1, iRegP_N2P src2) %{
12240   match(Set crx (CmpP src1 src2));
12241   format %{ &quot;CMPLD   $crx, $src1, $src2 \t// ptr&quot; %}
12242   size(4);
12243   ins_encode %{
12244     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12245     __ cmpld($crx$$CondRegister, $src1$$Register, $src2$$Register);
12246   %}
12247   ins_pipe(pipe_class_compare);
12248 %}
12249 
12250 instruct cmpP_reg_null(flagsReg crx, iRegP_N2P src1, immP_0or1 src2) %{
12251   match(Set crx (CmpP src1 src2));
12252   format %{ &quot;CMPLDI   $crx, $src1, $src2 \t// ptr&quot; %}
12253   size(4);
12254   ins_encode %{
12255     // TODO: PPC port $archOpcode(ppc64Opcode_cmpl);
12256     __ cmpldi($crx$$CondRegister, $src1$$Register, (int)((short)($src2$$constant &amp; 0xFFFF)));
12257   %}
12258   ins_pipe(pipe_class_compare);
12259 %}
12260 
12261 // Used in postalloc expand.
12262 instruct cmpP_reg_imm16(flagsReg crx, iRegPsrc src1, immL16 src2) %{
12263   // This match rule prevents reordering of node before a safepoint.
12264   // This only makes sense if this instructions is used exclusively
12265   // for the expansion of EncodeP!
12266   match(Set crx (CmpP src1 src2));
12267   predicate(false);
12268 
12269   format %{ &quot;CMPDI   $crx, $src1, $src2&quot; %}
12270   size(4);
12271   ins_encode %{
12272     // TODO: PPC port $archOpcode(ppc64Opcode_cmpi);
12273     __ cmpdi($crx$$CondRegister, $src1$$Register, $src2$$constant);
12274   %}
12275   ins_pipe(pipe_class_compare);
12276 %}
12277 
12278 //----------Float Compares----------------------------------------------------
12279 
12280 instruct cmpFUnordered_reg_reg(flagsReg crx, regF src1, regF src2) %{
12281   // Needs matchrule, see cmpDUnordered.
12282   match(Set crx (CmpF src1 src2));
12283   // no match-rule, false predicate
12284   predicate(false);
12285 
12286   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12287   size(4);
12288   ins_encode %{
12289     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12290     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12291   %}
12292   ins_pipe(pipe_class_default);
12293 %}
12294 
12295 instruct cmov_bns_less(flagsReg crx) %{
12296   // no match-rule, false predicate
12297   effect(DEF crx);
12298   predicate(false);
12299 
12300   ins_variable_size_depending_on_alignment(true);
12301 
12302   format %{ &quot;cmov    $crx&quot; %}
12303   // Worst case is branch + move + stop, no stop without scheduler.
12304   size((false /* TODO: PPC PORT(InsertEndGroupPPC64 &amp;&amp; Compile::current()-&gt;do_hb_scheduling())*/ ? 16 : 12));
12305   ins_encode %{
12306     // TODO: PPC port $archOpcode(ppc64Opcode_cmovecr);
12307     Label done;
12308     __ bns($crx$$CondRegister, done);        // not unordered -&gt; keep crx
12309     __ li(R0, 0);
12310     __ cmpwi($crx$$CondRegister, R0, 1);     // unordered -&gt; set crx to &#39;less&#39;
12311     // TODO PPC port __ endgroup_if_needed(_size == 16);
12312     __ bind(done);
12313   %}
12314   ins_pipe(pipe_class_default);
12315 %}
12316 
12317 // Compare floating, generate condition code.
12318 instruct cmpF_reg_reg_Ex(flagsReg crx, regF src1, regF src2) %{
12319   // FIXME: should we match &#39;If cmp (CmpF src1 src2))&#39; ??
12320   //
12321   // The following code sequence occurs a lot in mpegaudio:
12322   //
12323   // block BXX:
12324   // 0: instruct cmpFUnordered_reg_reg (cmpF_reg_reg-0):
12325   //    cmpFUrd CCR6, F11, F9
12326   // 4: instruct cmov_bns_less (cmpF_reg_reg-1):
12327   //    cmov CCR6
12328   // 8: instruct branchConSched:
12329   //    B_FARle CCR6, B56  P=0.500000 C=-1.000000
12330   match(Set crx (CmpF src1 src2));
12331   ins_cost(DEFAULT_COST+BRANCH_COST);
12332 
12333   format %{ &quot;CmpF    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12334   postalloc_expand %{
12335     //
12336     // replaces
12337     //
12338     //   region  src1  src2
12339     //    \       |     |
12340     //     crx=cmpF_reg_reg
12341     //
12342     // with
12343     //
12344     //   region  src1  src2
12345     //    \       |     |
12346     //     crx=cmpFUnordered_reg_reg
12347     //      |
12348     //      ^  region
12349     //      |   \
12350     //      crx=cmov_bns_less
12351     //
12352 
12353     // Create new nodes.
12354     MachNode *m1 = new cmpFUnordered_reg_regNode();
12355     MachNode *m2 = new cmov_bns_lessNode();
12356 
12357     // inputs for new nodes
12358     m1-&gt;add_req(n_region, n_src1, n_src2);
12359     m2-&gt;add_req(n_region);
12360     m2-&gt;add_prec(m1);
12361 
12362     // operands for new nodes
12363     m1-&gt;_opnds[0] = op_crx;
12364     m1-&gt;_opnds[1] = op_src1;
12365     m1-&gt;_opnds[2] = op_src2;
12366     m2-&gt;_opnds[0] = op_crx;
12367 
12368     // registers for new nodes
12369     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12370     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12371 
12372     // Insert new nodes.
12373     nodes-&gt;push(m1);
12374     nodes-&gt;push(m2);
12375   %}
12376 %}
12377 
12378 // Compare float, generate -1,0,1
12379 instruct cmpF3_reg_reg_ExEx(iRegIdst dst, regF src1, regF src2) %{
12380   match(Set dst (CmpF3 src1 src2));
12381   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12382 
12383   expand %{
12384     flagsReg tmp1;
12385     cmpFUnordered_reg_reg(tmp1, src1, src2);
12386     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12387   %}
12388 %}
12389 
12390 instruct cmpDUnordered_reg_reg(flagsReg crx, regD src1, regD src2) %{
12391   // Needs matchrule so that ideal opcode is Cmp. This causes that gcm places the
12392   // node right before the conditional move using it.
12393   // In jck test api/java_awt/geom/QuadCurve2DFloat/index.html#SetCurveTesttestCase7,
12394   // compilation of java.awt.geom.RectangularShape::getBounds()Ljava/awt/Rectangle
12395   // crashed in register allocation where the flags Reg between cmpDUnoredered and a
12396   // conditional move was supposed to be spilled.
12397   match(Set crx (CmpD src1 src2));
12398   // False predicate, shall not be matched.
12399   predicate(false);
12400 
12401   format %{ &quot;cmpFUrd $crx, $src1, $src2&quot; %}
12402   size(4);
12403   ins_encode %{
12404     // TODO: PPC port $archOpcode(ppc64Opcode_fcmpu);
12405     __ fcmpu($crx$$CondRegister, $src1$$FloatRegister, $src2$$FloatRegister);
12406   %}
12407   ins_pipe(pipe_class_default);
12408 %}
12409 
12410 instruct cmpD_reg_reg_Ex(flagsReg crx, regD src1, regD src2) %{
12411   match(Set crx (CmpD src1 src2));
12412   ins_cost(DEFAULT_COST+BRANCH_COST);
12413 
12414   format %{ &quot;CmpD    $crx, $src1, $src2 \t// postalloc expanded&quot; %}
12415   postalloc_expand %{
12416     //
12417     // replaces
12418     //
12419     //   region  src1  src2
12420     //    \       |     |
12421     //     crx=cmpD_reg_reg
12422     //
12423     // with
12424     //
12425     //   region  src1  src2
12426     //    \       |     |
12427     //     crx=cmpDUnordered_reg_reg
12428     //      |
12429     //      ^  region
12430     //      |   \
12431     //      crx=cmov_bns_less
12432     //
12433 
12434     // create new nodes
12435     MachNode *m1 = new cmpDUnordered_reg_regNode();
12436     MachNode *m2 = new cmov_bns_lessNode();
12437 
12438     // inputs for new nodes
12439     m1-&gt;add_req(n_region, n_src1, n_src2);
12440     m2-&gt;add_req(n_region);
12441     m2-&gt;add_prec(m1);
12442 
12443     // operands for new nodes
12444     m1-&gt;_opnds[0] = op_crx;
12445     m1-&gt;_opnds[1] = op_src1;
12446     m1-&gt;_opnds[2] = op_src2;
12447     m2-&gt;_opnds[0] = op_crx;
12448 
12449     // registers for new nodes
12450     ra_-&gt;set_pair(m1-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12451     ra_-&gt;set_pair(m2-&gt;_idx, ra_-&gt;get_reg_second(this), ra_-&gt;get_reg_first(this)); // crx
12452 
12453     // Insert new nodes.
12454     nodes-&gt;push(m1);
12455     nodes-&gt;push(m2);
12456   %}
12457 %}
12458 
12459 // Compare double, generate -1,0,1
12460 instruct cmpD3_reg_reg_ExEx(iRegIdst dst, regD src1, regD src2) %{
12461   match(Set dst (CmpD3 src1 src2));
12462   ins_cost(DEFAULT_COST*5+BRANCH_COST);
12463 
12464   expand %{
12465     flagsReg tmp1;
12466     cmpDUnordered_reg_reg(tmp1, src1, src2);
12467     cmovI_conIvalueMinus1_conIvalue0_conIvalue1_Ex(dst, tmp1);
12468   %}
12469 %}
12470 
12471 // Compare char
12472 instruct cmprb_Digit_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12473   match(Set dst (Digit src1));
12474   effect(TEMP src2, TEMP crx);
12475   ins_cost(3 * DEFAULT_COST);
12476 
12477   format %{ &quot;LI      $src2, 0x3930\n\t&quot;
12478             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12479             &quot;SETB    $dst, $crx&quot; %}
12480   size(12);
12481   ins_encode %{
12482     // 0x30: 0, 0x39: 9
12483     __ li($src2$$Register, 0x3930);
12484     // compare src1 with ranges 0x30 to 0x39
12485     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12486     __ setb($dst$$Register, $crx$$CondRegister);
12487   %}
12488   ins_pipe(pipe_class_default);
12489 %}
12490 
12491 instruct cmprb_LowerCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12492   match(Set dst (LowerCase src1));
12493   effect(TEMP src2, TEMP crx);
12494   ins_cost(12 * DEFAULT_COST);
12495 
12496   format %{ &quot;LI      $src2, 0x7A61\n\t&quot;
12497             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12498             &quot;BGT     $crx, done\n\t&quot;
12499             &quot;LIS     $src2, (signed short)0xF6DF\n\t&quot;
12500             &quot;ORI     $src2, $src2, 0xFFF8\n\t&quot;
12501             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12502             &quot;BGT     $crx, done\n\t&quot;
12503             &quot;LIS     $src2, (signed short)0xAAB5\n\t&quot;
12504             &quot;ORI     $src2, $src2, 0xBABA\n\t&quot;
12505             &quot;INSRDI  $src2, $src2, 32, 0\n\t&quot;
12506             &quot;CMPEQB  $crx, 1, $src1, $src2\n&quot;
12507             &quot;done:\n\t&quot;
12508             &quot;SETB    $dst, $crx&quot; %}
12509 
12510   size(48);
12511   ins_encode %{
12512     Label done;
12513     // 0x61: a, 0x7A: z
12514     __ li($src2$$Register, 0x7A61);
12515     // compare src1 with ranges 0x61 to 0x7A
12516     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12517     __ bgt($crx$$CondRegister, done);
12518 
12519     // 0xDF: sharp s, 0xFF: y with diaeresis, 0xF7 is not the lower case
12520     __ lis($src2$$Register, (signed short)0xF6DF);
12521     __ ori($src2$$Register, $src2$$Register, 0xFFF8);
12522     // compare src1 with ranges 0xDF to 0xF6 and 0xF8 to 0xFF
12523     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12524     __ bgt($crx$$CondRegister, done);
12525 
12526     // 0xAA: feminine ordinal indicator
12527     // 0xB5: micro sign
12528     // 0xBA: masculine ordinal indicator
12529     __ lis($src2$$Register, (signed short)0xAAB5);
12530     __ ori($src2$$Register, $src2$$Register, 0xBABA);
12531     __ insrdi($src2$$Register, $src2$$Register, 32, 0);
12532     // compare src1 with 0xAA, 0xB5, and 0xBA
12533     __ cmpeqb($crx$$CondRegister, $src1$$Register, $src2$$Register);
12534 
12535     __ bind(done);
12536     __ setb($dst$$Register, $crx$$CondRegister);
12537   %}
12538   ins_pipe(pipe_class_default);
12539 %}
12540 
12541 instruct cmprb_UpperCase_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12542   match(Set dst (UpperCase src1));
12543   effect(TEMP src2, TEMP crx);
12544   ins_cost(7 * DEFAULT_COST);
12545 
12546   format %{ &quot;LI      $src2, 0x5A41\n\t&quot;
12547             &quot;CMPRB   $crx, 0, $src1, $src2\n\t&quot;
12548             &quot;BGT     $crx, done\n\t&quot;
12549             &quot;LIS     $src2, (signed short)0xD6C0\n\t&quot;
12550             &quot;ORI     $src2, $src2, 0xDED8\n\t&quot;
12551             &quot;CMPRB   $crx, 1, $src1, $src2\n&quot;
12552             &quot;done:\n\t&quot;
12553             &quot;SETB    $dst, $crx&quot; %}
12554 
12555   size(28);
12556   ins_encode %{
12557     Label done;
12558     // 0x41: A, 0x5A: Z
12559     __ li($src2$$Register, 0x5A41);
12560     // compare src1 with a range 0x41 to 0x5A
12561     __ cmprb($crx$$CondRegister, 0, $src1$$Register, $src2$$Register);
12562     __ bgt($crx$$CondRegister, done);
12563 
12564     // 0xC0: a with grave, 0xDE: thorn, 0xD7 is not the upper case
12565     __ lis($src2$$Register, (signed short)0xD6C0);
12566     __ ori($src2$$Register, $src2$$Register, 0xDED8);
12567     // compare src1 with ranges 0xC0 to 0xD6 and 0xD8 to 0xDE
12568     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12569 
12570     __ bind(done);
12571     __ setb($dst$$Register, $crx$$CondRegister);
12572   %}
12573   ins_pipe(pipe_class_default);
12574 %}
12575 
12576 instruct cmprb_Whitespace_reg_reg(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsReg crx) %{
12577   match(Set dst (Whitespace src1));
12578   effect(TEMP src2, TEMP crx);
12579   ins_cost(4 * DEFAULT_COST);
12580 
12581   format %{ &quot;LI      $src2, 0x0D09\n\t&quot;
12582             &quot;ADDIS   $src2, 0x201C\n\t&quot;
12583             &quot;CMPRB   $crx, 1, $src1, $src2\n\t&quot;
12584             &quot;SETB    $dst, $crx&quot; %}
12585   size(16);
12586   ins_encode %{
12587     // 0x09 to 0x0D, 0x1C to 0x20
12588     __ li($src2$$Register, 0x0D09);
12589     __ addis($src2$$Register, $src2$$Register, 0x0201C);
12590     // compare src with ranges 0x09 to 0x0D and 0x1C to 0x20
12591     __ cmprb($crx$$CondRegister, 1, $src1$$Register, $src2$$Register);
12592     __ setb($dst$$Register, $crx$$CondRegister);
12593   %}
12594   ins_pipe(pipe_class_default);
12595 %}
12596 
12597 //----------Branches---------------------------------------------------------
12598 // Jump
12599 
12600 // Direct Branch.
12601 instruct branch(label labl) %{
12602   match(Goto);
12603   effect(USE labl);
12604   ins_cost(BRANCH_COST);
12605 
12606   format %{ &quot;B       $labl&quot; %}
12607   size(4);
12608   ins_encode %{
12609     // TODO: PPC port $archOpcode(ppc64Opcode_b);
12610      Label d;    // dummy
12611      __ bind(d);
12612      Label* p = $labl$$label;
12613      // `p&#39; is `NULL&#39; when this encoding class is used only to
12614      // determine the size of the encoded instruction.
12615      Label&amp; l = (NULL == p)? d : *(p);
12616      __ b(l);
12617   %}
12618   ins_pipe(pipe_class_default);
12619 %}
12620 
12621 // Conditional Near Branch
12622 instruct branchCon(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12623   // Same match rule as `branchConFar&#39;.
12624   match(If cmp crx);
12625   effect(USE lbl);
12626   ins_cost(BRANCH_COST);
12627 
12628   // If set to 1 this indicates that the current instruction is a
12629   // short variant of a long branch. This avoids using this
12630   // instruction in first-pass matching. It will then only be used in
12631   // the `Shorten_branches&#39; pass.
12632   ins_short_branch(1);
12633 
12634   format %{ &quot;B$cmp     $crx, $lbl&quot; %}
12635   size(4);
12636   ins_encode( enc_bc(crx, cmp, lbl) );
12637   ins_pipe(pipe_class_default);
12638 %}
12639 
12640 // This is for cases when the ppc64 `bc&#39; instruction does not
12641 // reach far enough. So we emit a far branch here, which is more
12642 // expensive.
12643 //
12644 // Conditional Far Branch
12645 instruct branchConFar(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12646   // Same match rule as `branchCon&#39;.
12647   match(If cmp crx);
12648   effect(USE crx, USE lbl);
12649   predicate(!false /* TODO: PPC port HB_Schedule*/);
12650   // Higher cost than `branchCon&#39;.
12651   ins_cost(5*BRANCH_COST);
12652 
12653   // This is not a short variant of a branch, but the long variant.
12654   ins_short_branch(0);
12655 
12656   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12657   size(8);
12658   ins_encode( enc_bc_far(crx, cmp, lbl) );
12659   ins_pipe(pipe_class_default);
12660 %}
12661 
12662 // Conditional Branch used with Power6 scheduler (can be far or short).
12663 instruct branchConSched(cmpOp cmp, flagsRegSrc crx, label lbl) %{
12664   // Same match rule as `branchCon&#39;.
12665   match(If cmp crx);
12666   effect(USE crx, USE lbl);
12667   predicate(false /* TODO: PPC port HB_Schedule*/);
12668   // Higher cost than `branchCon&#39;.
12669   ins_cost(5*BRANCH_COST);
12670 
12671   // Actually size doesn&#39;t depend on alignment but on shortening.
12672   ins_variable_size_depending_on_alignment(true);
12673   // long variant.
12674   ins_short_branch(0);
12675 
12676   format %{ &quot;B_FAR$cmp $crx, $lbl&quot; %}
12677   size(8); // worst case
12678   ins_encode( enc_bc_short_far(crx, cmp, lbl) );
12679   ins_pipe(pipe_class_default);
12680 %}
12681 
12682 instruct branchLoopEnd(cmpOp cmp, flagsRegSrc crx, label labl) %{
12683   match(CountedLoopEnd cmp crx);
12684   effect(USE labl);
12685   ins_cost(BRANCH_COST);
12686 
12687   // short variant.
12688   ins_short_branch(1);
12689 
12690   format %{ &quot;B$cmp     $crx, $labl \t// counted loop end&quot; %}
12691   size(4);
12692   ins_encode( enc_bc(crx, cmp, labl) );
12693   ins_pipe(pipe_class_default);
12694 %}
12695 
12696 instruct branchLoopEndFar(cmpOp cmp, flagsRegSrc crx, label labl) %{
12697   match(CountedLoopEnd cmp crx);
12698   effect(USE labl);
12699   predicate(!false /* TODO: PPC port HB_Schedule */);
12700   ins_cost(BRANCH_COST);
12701 
12702   // Long variant.
12703   ins_short_branch(0);
12704 
12705   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12706   size(8);
12707   ins_encode( enc_bc_far(crx, cmp, labl) );
12708   ins_pipe(pipe_class_default);
12709 %}
12710 
12711 // Conditional Branch used with Power6 scheduler (can be far or short).
12712 instruct branchLoopEndSched(cmpOp cmp, flagsRegSrc crx, label labl) %{
12713   match(CountedLoopEnd cmp crx);
12714   effect(USE labl);
12715   predicate(false /* TODO: PPC port HB_Schedule */);
12716   // Higher cost than `branchCon&#39;.
12717   ins_cost(5*BRANCH_COST);
12718 
12719   // Actually size doesn&#39;t depend on alignment but on shortening.
12720   ins_variable_size_depending_on_alignment(true);
12721   // Long variant.
12722   ins_short_branch(0);
12723 
12724   format %{ &quot;B_FAR$cmp $crx, $labl \t// counted loop end&quot; %}
12725   size(8); // worst case
12726   ins_encode( enc_bc_short_far(crx, cmp, labl) );
12727   ins_pipe(pipe_class_default);
12728 %}
12729 
12730 // ============================================================================
12731 // Java runtime operations, intrinsics and other complex operations.
12732 
12733 // The 2nd slow-half of a subtype check. Scan the subklass&#39;s 2ndary superklass
12734 // array for an instance of the superklass. Set a hidden internal cache on a
12735 // hit (cache is checked with exposed code in gen_subtype_check()). Return
12736 // not zero for a miss or zero for a hit. The encoding ALSO sets flags.
12737 //
12738 // GL TODO: Improve this.
12739 // - result should not be a TEMP
12740 // - Add match rule as on sparc avoiding additional Cmp.
12741 instruct partialSubtypeCheck(iRegPdst result, iRegP_N2P subklass, iRegP_N2P superklass,
12742                              iRegPdst tmp_klass, iRegPdst tmp_arrayptr) %{
12743   match(Set result (PartialSubtypeCheck subklass superklass));
12744   effect(TEMP_DEF result, TEMP tmp_klass, TEMP tmp_arrayptr);
12745   ins_cost(DEFAULT_COST*10);
12746 
12747   format %{ &quot;PartialSubtypeCheck $result = ($subklass instanceOf $superklass) tmp: $tmp_klass, $tmp_arrayptr&quot; %}
12748   ins_encode %{
12749     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12750     __ check_klass_subtype_slow_path($subklass$$Register, $superklass$$Register, $tmp_arrayptr$$Register,
12751                                      $tmp_klass$$Register, NULL, $result$$Register);
12752   %}
12753   ins_pipe(pipe_class_default);
12754 %}
12755 
12756 // inlined locking and unlocking
12757 
12758 instruct cmpFastLock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2) %{
12759   match(Set crx (FastLock oop box));
12760   effect(TEMP tmp1, TEMP tmp2);
12761   predicate(!Compile::current()-&gt;use_rtm());
12762 
12763   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12764   ins_encode %{
12765     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12766     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12767                                  $tmp1$$Register, $tmp2$$Register, /*tmp3*/ R0,
12768                                  UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
12769     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12770     // The compiler generates a branch to the runtime call to
12771     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12772   %}
12773   ins_pipe(pipe_class_compare);
12774 %}
12775 
12776 // Separate version for TM. Use bound register for box to enable USE_KILL.
12777 instruct cmpFastLock_tm(flagsReg crx, iRegPdst oop, rarg2RegP box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12778   match(Set crx (FastLock oop box));
12779   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, USE_KILL box);
12780   predicate(Compile::current()-&gt;use_rtm());
12781 
12782   format %{ &quot;FASTLOCK  $oop, $box, $tmp1, $tmp2, $tmp3 (TM)&quot; %}
12783   ins_encode %{
12784     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12785     __ compiler_fast_lock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12786                                  $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12787                                  /*Biased Locking*/ false,
12788                                  _rtm_counters, _stack_rtm_counters,
12789                                  ((Method*)(ra_-&gt;C-&gt;method()-&gt;constant_encoding()))-&gt;method_data(),
12790                                  /*TM*/ true, ra_-&gt;C-&gt;profile_rtm());
12791     // If locking was successfull, crx should indicate &#39;EQ&#39;.
12792     // The compiler generates a branch to the runtime call to
12793     // _complete_monitor_locking_Java for the case where crx is &#39;NE&#39;.
12794   %}
12795   ins_pipe(pipe_class_compare);
12796 %}
12797 
12798 instruct cmpFastUnlock(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12799   match(Set crx (FastUnlock oop box));
12800   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12801   predicate(!Compile::current()-&gt;use_rtm());
12802 
12803   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2&quot; %}
12804   ins_encode %{
12805     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12806     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12807                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12808                                    UseBiasedLocking &amp;&amp; !UseOptoBiasInlining,
12809                                    false);
12810     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12811     // The compiler generates a branch to the runtime call to
12812     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12813   %}
12814   ins_pipe(pipe_class_compare);
12815 %}
12816 
12817 instruct cmpFastUnlock_tm(flagsReg crx, iRegPdst oop, iRegPdst box, iRegPdst tmp1, iRegPdst tmp2, iRegPdst tmp3) %{
12818   match(Set crx (FastUnlock oop box));
12819   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3);
12820   predicate(Compile::current()-&gt;use_rtm());
12821 
12822   format %{ &quot;FASTUNLOCK  $oop, $box, $tmp1, $tmp2 (TM)&quot; %}
12823   ins_encode %{
12824     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12825     __ compiler_fast_unlock_object($crx$$CondRegister, $oop$$Register, $box$$Register,
12826                                    $tmp1$$Register, $tmp2$$Register, $tmp3$$Register,
12827                                    /*Biased Locking*/ false, /*TM*/ true);
12828     // If unlocking was successfull, crx should indicate &#39;EQ&#39;.
12829     // The compiler generates a branch to the runtime call to
12830     // _complete_monitor_unlocking_Java for the case where crx is &#39;NE&#39;.
12831   %}
12832   ins_pipe(pipe_class_compare);
12833 %}
12834 
12835 // Align address.
12836 instruct align_addr(iRegPdst dst, iRegPsrc src, immLnegpow2 mask) %{
12837   match(Set dst (CastX2P (AndL (CastP2X src) mask)));
12838 
12839   format %{ &quot;ANDDI   $dst, $src, $mask \t// next aligned address&quot; %}
12840   size(4);
12841   ins_encode %{
12842     // TODO: PPC port $archOpcode(ppc64Opcode_rldicr);
12843     __ clrrdi($dst$$Register, $src$$Register, log2_long((jlong)-$mask$$constant));
12844   %}
12845   ins_pipe(pipe_class_default);
12846 %}
12847 
12848 // Array size computation.
12849 instruct array_size(iRegLdst dst, iRegPsrc end, iRegPsrc start) %{
12850   match(Set dst (SubL (CastP2X end) (CastP2X start)));
12851 
12852   format %{ &quot;SUB     $dst, $end, $start \t// array size in bytes&quot; %}
12853   size(4);
12854   ins_encode %{
12855     // TODO: PPC port $archOpcode(ppc64Opcode_subf);
12856     __ subf($dst$$Register, $start$$Register, $end$$Register);
12857   %}
12858   ins_pipe(pipe_class_default);
12859 %}
12860 
12861 // Clear-array with constant short array length. The versions below can use dcbz with cnt &gt; 30.
12862 instruct inlineCallClearArrayShort(immLmax30 cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12863   match(Set dummy (ClearArray cnt base));
12864   effect(USE_KILL base, KILL ctr);
12865   ins_cost(2 * MEMORY_REF_COST);
12866 
12867   format %{ &quot;ClearArray $cnt, $base&quot; %}
12868   ins_encode %{
12869     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12870     __ clear_memory_constlen($base$$Register, $cnt$$constant, R0); // kills base, R0
12871   %}
12872   ins_pipe(pipe_class_default);
12873 %}
12874 
12875 // Clear-array with constant large array length.
12876 instruct inlineCallClearArrayLarge(immL cnt, rarg2RegP base, Universe dummy, iRegLdst tmp, regCTR ctr) %{
12877   match(Set dummy (ClearArray cnt base));
12878   effect(USE_KILL base, TEMP tmp, KILL ctr);
12879   ins_cost(3 * MEMORY_REF_COST);
12880 
12881   format %{ &quot;ClearArray $cnt, $base \t// KILL $tmp&quot; %}
12882   ins_encode %{
12883     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12884     __ clear_memory_doubleword($base$$Register, $tmp$$Register, R0, $cnt$$constant); // kills base, R0
12885   %}
12886   ins_pipe(pipe_class_default);
12887 %}
12888 
12889 // Clear-array with dynamic array length.
12890 instruct inlineCallClearArray(rarg1RegL cnt, rarg2RegP base, Universe dummy, regCTR ctr) %{
12891   match(Set dummy (ClearArray cnt base));
12892   effect(USE_KILL cnt, USE_KILL base, KILL ctr);
12893   ins_cost(4 * MEMORY_REF_COST);
12894 
12895   format %{ &quot;ClearArray $cnt, $base&quot; %}
12896   ins_encode %{
12897     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12898     __ clear_memory_doubleword($base$$Register, $cnt$$Register, R0); // kills cnt, base, R0
12899   %}
12900   ins_pipe(pipe_class_default);
12901 %}
12902 
12903 instruct string_compareL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12904                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12905   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12906   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12907   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12908   ins_cost(300);
12909   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12910   ins_encode %{
12911     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12912     __ string_compare($str1$$Register, $str2$$Register,
12913                       $cnt1$$Register, $cnt2$$Register,
12914                       $tmp$$Register,
12915                       $result$$Register, StrIntrinsicNode::LL);
12916   %}
12917   ins_pipe(pipe_class_default);
12918 %}
12919 
12920 instruct string_compareU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12921                          iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12922   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12923   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12924   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12925   ins_cost(300);
12926   format %{ &quot;String Compare char[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12927   ins_encode %{
12928     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12929     __ string_compare($str1$$Register, $str2$$Register,
12930                       $cnt1$$Register, $cnt2$$Register,
12931                       $tmp$$Register,
12932                       $result$$Register, StrIntrinsicNode::UU);
12933   %}
12934   ins_pipe(pipe_class_default);
12935 %}
12936 
12937 instruct string_compareLU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12938                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12939   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::LU);
12940   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12941   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12942   ins_cost(300);
12943   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12944   ins_encode %{
12945     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12946     __ string_compare($str1$$Register, $str2$$Register,
12947                       $cnt1$$Register, $cnt2$$Register,
12948                       $tmp$$Register,
12949                       $result$$Register, StrIntrinsicNode::LU);
12950   %}
12951   ins_pipe(pipe_class_default);
12952 %}
12953 
12954 instruct string_compareUL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt1, rarg4RegI cnt2, iRegIdst result,
12955                           iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12956   predicate(((StrCompNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
12957   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
12958   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ctr, KILL cr0, TEMP tmp);
12959   ins_cost(300);
12960   format %{ &quot;String Compare byte[] $str1,$cnt1,$str2,$cnt2 -&gt; $result \t// KILL $tmp&quot; %}
12961   ins_encode %{
12962     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12963     __ string_compare($str2$$Register, $str1$$Register,
12964                       $cnt2$$Register, $cnt1$$Register,
12965                       $tmp$$Register,
12966                       $result$$Register, StrIntrinsicNode::UL);
12967   %}
12968   ins_pipe(pipe_class_default);
12969 %}
12970 
12971 instruct string_equalsL(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12972                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12973   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
12974   match(Set result (StrEquals (Binary str1 str2) cnt));
12975   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12976   ins_cost(300);
12977   format %{ &quot;String Equals byte[] $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12978   ins_encode %{
12979     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12980     __ array_equals(false, $str1$$Register, $str2$$Register,
12981                     $cnt$$Register, $tmp$$Register,
12982                     $result$$Register, true /* byte */);
12983   %}
12984   ins_pipe(pipe_class_default);
12985 %}
12986 
12987 instruct string_equalsU(rarg1RegP str1, rarg2RegP str2, rarg3RegI cnt, iRegIdst result,
12988                         iRegIdst tmp, regCTR ctr, flagsRegCR0 cr0) %{
12989   predicate(((StrEqualsNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
12990   match(Set result (StrEquals (Binary str1 str2) cnt));
12991   effect(TEMP_DEF result, USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp, KILL ctr, KILL cr0);
12992   ins_cost(300);
12993   format %{ &quot;String Equals char[]  $str1,$str2,$cnt -&gt; $result \t// KILL $tmp&quot; %}
12994   ins_encode %{
12995     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
12996     __ array_equals(false, $str1$$Register, $str2$$Register,
12997                     $cnt$$Register, $tmp$$Register,
12998                     $result$$Register, false /* byte */);
12999   %}
13000   ins_pipe(pipe_class_default);
13001 %}
13002 
13003 instruct array_equalsB(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
13004                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
13005   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13006   match(Set result (AryEq ary1 ary2));
13007   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
13008   ins_cost(300);
13009   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13010   ins_encode %{
13011     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13012     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13013                     $tmp1$$Register, $tmp2$$Register,
13014                     $result$$Register, true /* byte */);
13015   %}
13016   ins_pipe(pipe_class_default);
13017 %}
13018 
13019 instruct array_equalsC(rarg1RegP ary1, rarg2RegP ary2, iRegIdst result,
13020                        iRegIdst tmp1, iRegIdst tmp2, regCTR ctr, flagsRegCR0 cr0, flagsRegCR0 cr1) %{
13021   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13022   match(Set result (AryEq ary1 ary2));
13023   effect(TEMP_DEF result, USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0, KILL cr1);
13024   ins_cost(300);
13025   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result \t// KILL $tmp1,$tmp2&quot; %}
13026   ins_encode %{
13027     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13028     __ array_equals(true, $ary1$$Register, $ary2$$Register,
13029                     $tmp1$$Register, $tmp2$$Register,
13030                     $result$$Register, false /* byte */);
13031   %}
13032   ins_pipe(pipe_class_default);
13033 %}
13034 
13035 instruct indexOf_imm1_char_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13036                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13037                              iRegIdst tmp1, iRegIdst tmp2,
13038                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13039   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13040   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13041   // Required for EA: check if it is still a type_array.
13042   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13043   ins_cost(150);
13044 
13045   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13046             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13047 
13048   ins_encode %{
13049     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13050     immPOper *needleOper = (immPOper *)$needleImm;
13051     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13052     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13053     jchar chr;
13054 #ifdef VM_LITTLE_ENDIAN
13055     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13056            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13057 #else
13058     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13059            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13060 #endif
13061     __ string_indexof_char($result$$Register,
13062                            $haystack$$Register, $haycnt$$Register,
13063                            R0, chr,
13064                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13065   %}
13066   ins_pipe(pipe_class_compare);
13067 %}
13068 
13069 instruct indexOf_imm1_char_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13070                              immP needleImm, immL offsetImm, immI_1 needlecntImm,
13071                              iRegIdst tmp1, iRegIdst tmp2,
13072                              flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13073   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13074   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13075   // Required for EA: check if it is still a type_array.
13076   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13077   ins_cost(150);
13078 
13079   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13080             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13081 
13082   ins_encode %{
13083     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13084     immPOper *needleOper = (immPOper *)$needleImm;
13085     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13086     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13087     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13088     __ string_indexof_char($result$$Register,
13089                            $haystack$$Register, $haycnt$$Register,
13090                            R0, chr,
13091                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13092   %}
13093   ins_pipe(pipe_class_compare);
13094 %}
13095 
13096 instruct indexOf_imm1_char_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13097                               immP needleImm, immL offsetImm, immI_1 needlecntImm,
13098                               iRegIdst tmp1, iRegIdst tmp2,
13099                               flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13100   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary (AddP needleImm offsetImm) needlecntImm)));
13101   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13102   // Required for EA: check if it is still a type_array.
13103   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13104   ins_cost(150);
13105 
13106   format %{ &quot;String IndexOf CSCL1 $haystack[0..$haycnt], $needleImm+$offsetImm[0..$needlecntImm]&quot;
13107             &quot;-&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13108 
13109   ins_encode %{
13110     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13111     immPOper *needleOper = (immPOper *)$needleImm;
13112     const TypeOopPtr *t = needleOper-&gt;type()-&gt;isa_oopptr();
13113     ciTypeArray* needle_values = t-&gt;const_oop()-&gt;as_type_array();  // Pointer to live char *
13114     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13115     __ string_indexof_char($result$$Register,
13116                            $haystack$$Register, $haycnt$$Register,
13117                            R0, chr,
13118                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13119   %}
13120   ins_pipe(pipe_class_compare);
13121 %}
13122 
13123 instruct indexOf_imm1_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13124                         rscratch2RegP needle, immI_1 needlecntImm,
13125                         iRegIdst tmp1, iRegIdst tmp2,
13126                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13127   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13128   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13129   // Required for EA: check if it is still a type_array.
13130   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13131             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13132             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13133   ins_cost(180);
13134 
13135   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13136             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13137   ins_encode %{
13138     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13139     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13140     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13141     guarantee(needle_values, &quot;sanity&quot;);
13142     jchar chr;
13143 #ifdef VM_LITTLE_ENDIAN
13144     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte()) &lt;&lt; 8) |
13145            ((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte());
13146 #else
13147     chr = (((jchar)(unsigned char)needle_values-&gt;element_value(0).as_byte()) &lt;&lt; 8) |
13148            ((jchar)(unsigned char)needle_values-&gt;element_value(1).as_byte());
13149 #endif
13150     __ string_indexof_char($result$$Register,
13151                            $haystack$$Register, $haycnt$$Register,
13152                            R0, chr,
13153                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13154   %}
13155   ins_pipe(pipe_class_compare);
13156 %}
13157 
13158 instruct indexOf_imm1_L(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13159                         rscratch2RegP needle, immI_1 needlecntImm,
13160                         iRegIdst tmp1, iRegIdst tmp2,
13161                         flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13162   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13163   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13164   // Required for EA: check if it is still a type_array.
13165   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13166             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13167             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13168   ins_cost(180);
13169 
13170   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13171             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13172   ins_encode %{
13173     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13174     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13175     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13176     guarantee(needle_values, &quot;sanity&quot;);
13177     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13178     __ string_indexof_char($result$$Register,
13179                            $haystack$$Register, $haycnt$$Register,
13180                            R0, chr,
13181                            $tmp1$$Register, $tmp2$$Register, true /*is_byte*/);
13182   %}
13183   ins_pipe(pipe_class_compare);
13184 %}
13185 
13186 instruct indexOf_imm1_UL(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13187                          rscratch2RegP needle, immI_1 needlecntImm,
13188                          iRegIdst tmp1, iRegIdst tmp2,
13189                          flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13190   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13191   effect(USE_KILL needle, TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13192   // Required for EA: check if it is still a type_array.
13193   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13194             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13195             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13196   ins_cost(180);
13197 
13198   format %{ &quot;String IndexOf SCL1 $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13199             &quot; -&gt; $result \t// KILL $haycnt, $needle, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13200   ins_encode %{
13201     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13202     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13203     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13204     guarantee(needle_values, &quot;sanity&quot;);
13205     jchar chr = (jchar)needle_values-&gt;element_value(0).as_byte();
13206     __ string_indexof_char($result$$Register,
13207                            $haystack$$Register, $haycnt$$Register,
13208                            R0, chr,
13209                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13210   %}
13211   ins_pipe(pipe_class_compare);
13212 %}
13213 
13214 instruct indexOfChar_U(iRegIdst result, iRegPsrc haystack, iRegIsrc haycnt,
13215                        iRegIsrc ch, iRegIdst tmp1, iRegIdst tmp2,
13216                        flagsRegCR0 cr0, flagsRegCR1 cr1, regCTR ctr) %{
13217   match(Set result (StrIndexOfChar (Binary haystack haycnt) ch));
13218   effect(TEMP tmp1, TEMP tmp2, KILL cr0, KILL cr1, KILL ctr);
13219   ins_cost(180);
13220 
13221   format %{ &quot;String IndexOfChar $haystack[0..$haycnt], $ch&quot;
13222             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $cr0, $cr1&quot; %}
13223   ins_encode %{
13224     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13225     __ string_indexof_char($result$$Register,
13226                            $haystack$$Register, $haycnt$$Register,
13227                            $ch$$Register, 0 /* this is not used if the character is already in a register */,
13228                            $tmp1$$Register, $tmp2$$Register, false /*is_byte*/);
13229   %}
13230   ins_pipe(pipe_class_compare);
13231 %}
13232 
13233 instruct indexOf_imm_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13234                        iRegPsrc needle, uimmI15 needlecntImm,
13235                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13236                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13237   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13238   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13239          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13240   // Required for EA: check if it is still a type_array.
13241   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU &amp;&amp;
13242             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13243             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13244   ins_cost(250);
13245 
13246   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13247             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13248   ins_encode %{
13249     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13250     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13251     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13252 
13253     __ string_indexof($result$$Register,
13254                       $haystack$$Register, $haycnt$$Register,
13255                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13256                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13257   %}
13258   ins_pipe(pipe_class_compare);
13259 %}
13260 
13261 instruct indexOf_imm_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13262                        iRegPsrc needle, uimmI15 needlecntImm,
13263                        iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13264                        flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13265   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13266   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13267          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13268   // Required for EA: check if it is still a type_array.
13269   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL &amp;&amp;
13270             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13271             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13272   ins_cost(250);
13273 
13274   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13275             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13276   ins_encode %{
13277     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13278     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13279     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13280 
13281     __ string_indexof($result$$Register,
13282                       $haystack$$Register, $haycnt$$Register,
13283                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13284                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13285   %}
13286   ins_pipe(pipe_class_compare);
13287 %}
13288 
13289 instruct indexOf_imm_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt,
13290                         iRegPsrc needle, uimmI15 needlecntImm,
13291                         iRegIdst tmp1, iRegIdst tmp2, iRegIdst tmp3, iRegIdst tmp4, iRegIdst tmp5,
13292                         flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13293   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecntImm)));
13294   effect(USE_KILL haycnt, /* better: TDEF haycnt, */ TEMP_DEF result,
13295          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13296   // Required for EA: check if it is still a type_array.
13297   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL &amp;&amp;
13298             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop() &amp;&amp;
13299             n-&gt;in(3)-&gt;in(1)-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;is_type_array());
13300   ins_cost(250);
13301 
13302   format %{ &quot;String IndexOf SCL $haystack[0..$haycnt], $needle[0..$needlecntImm]&quot;
13303             &quot; -&gt; $result \t// KILL $haycnt, $tmp1, $tmp2, $tmp3, $tmp4, $tmp5, $cr0, $cr1&quot; %}
13304   ins_encode %{
13305     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13306     Node *ndl = in(operand_index($needle));  // The node that defines needle.
13307     ciTypeArray* needle_values = ndl-&gt;bottom_type()-&gt;is_aryptr()-&gt;const_oop()-&gt;as_type_array();
13308 
13309     __ string_indexof($result$$Register,
13310                       $haystack$$Register, $haycnt$$Register,
13311                       $needle$$Register, needle_values, $tmp5$$Register, $needlecntImm$$constant,
13312                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13313   %}
13314   ins_pipe(pipe_class_compare);
13315 %}
13316 
13317 instruct indexOf_U(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13318                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13319                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13320   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13321   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13322          TEMP_DEF result,
13323          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13324   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
13325   ins_cost(300);
13326 
13327   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13328              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13329   ins_encode %{
13330     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13331     __ string_indexof($result$$Register,
13332                       $haystack$$Register, $haycnt$$Register,
13333                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13334                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UU);
13335   %}
13336   ins_pipe(pipe_class_compare);
13337 %}
13338 
13339 instruct indexOf_L(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13340                    iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13341                    flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13342   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13343   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13344          TEMP_DEF result,
13345          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13346   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::LL);
13347   ins_cost(300);
13348 
13349   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13350              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13351   ins_encode %{
13352     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13353     __ string_indexof($result$$Register,
13354                       $haystack$$Register, $haycnt$$Register,
13355                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13356                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::LL);
13357   %}
13358   ins_pipe(pipe_class_compare);
13359 %}
13360 
13361 instruct indexOf_UL(iRegIdst result, iRegPsrc haystack, rscratch1RegI haycnt, iRegPsrc needle, rscratch2RegI needlecnt,
13362                     iRegLdst tmp1, iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4,
13363                     flagsRegCR0 cr0, flagsRegCR1 cr1, flagsRegCR6 cr6, regCTR ctr) %{
13364   match(Set result (StrIndexOf (Binary haystack haycnt) (Binary needle needlecnt)));
13365   effect(USE_KILL haycnt, USE_KILL needlecnt, /*better: TDEF haycnt, TDEF needlecnt,*/
13366          TEMP_DEF result,
13367          TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, KILL cr0, KILL cr1, KILL cr6, KILL ctr);
13368   predicate(((StrIndexOfNode*)n)-&gt;encoding() == StrIntrinsicNode::UL);
13369   ins_cost(300);
13370 
13371   format %{ &quot;String IndexOf $haystack[0..$haycnt], $needle[0..$needlecnt]&quot;
13372              &quot; -&gt; $result \t// KILL $haycnt, $needlecnt, $tmp1, $tmp2, $tmp3, $tmp4, $cr0, $cr1&quot; %}
13373   ins_encode %{
13374     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13375     __ string_indexof($result$$Register,
13376                       $haystack$$Register, $haycnt$$Register,
13377                       $needle$$Register, NULL, $needlecnt$$Register, 0,  // needlecnt not constant.
13378                       $tmp1$$Register, $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, StrIntrinsicNode::UL);
13379   %}
13380   ins_pipe(pipe_class_compare);
13381 %}
13382 
13383 // char[] to byte[] compression
13384 instruct string_compress(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13385                          iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13386   match(Set result (StrCompressedCopy src (Binary dst len)));
13387   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13388          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13389   ins_cost(300);
13390   format %{ &quot;String Compress $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13391   ins_encode %{
13392     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13393     Label Lskip, Ldone;
13394     __ li($result$$Register, 0);
13395     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13396                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Ldone);
13397     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13398     __ beq(CCR0, Lskip);
13399     __ string_compress($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register, Ldone);
13400     __ bind(Lskip);
13401     __ mr($result$$Register, $len$$Register);
13402     __ bind(Ldone);
13403   %}
13404   ins_pipe(pipe_class_default);
13405 %}
13406 
13407 // byte[] to char[] inflation
13408 instruct string_inflate(Universe dummy, rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegLdst tmp1,
13409                         iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13410   match(Set dummy (StrInflatedCopy src (Binary dst len)));
13411   effect(TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5, USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13412   ins_cost(300);
13413   format %{ &quot;String Inflate $src,$dst,$len \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13414   ins_encode %{
13415     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13416     Label Ldone;
13417     __ string_inflate_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13418                          $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register);
13419     __ rldicl_($tmp1$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13420     __ beq(CCR0, Ldone);
13421     __ string_inflate($src$$Register, $dst$$Register, $tmp1$$Register, $tmp2$$Register);
13422     __ bind(Ldone);
13423   %}
13424   ins_pipe(pipe_class_default);
13425 %}
13426 
13427 // StringCoding.java intrinsics
13428 instruct has_negatives(rarg1RegP ary1, iRegIsrc len, iRegIdst result, iRegLdst tmp1, iRegLdst tmp2,
13429                        regCTR ctr, flagsRegCR0 cr0)
13430 %{
13431   match(Set result (HasNegatives ary1 len));
13432   effect(TEMP_DEF result, USE_KILL ary1, TEMP tmp1, TEMP tmp2, KILL ctr, KILL cr0);
13433   ins_cost(300);
13434   format %{ &quot;has negatives byte[] $ary1,$len -&gt; $result \t// KILL $tmp1, $tmp2&quot; %}
13435   ins_encode %{
13436     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13437     __ has_negatives($ary1$$Register, $len$$Register, $result$$Register,
13438                      $tmp1$$Register, $tmp2$$Register);
13439   %}
13440   ins_pipe(pipe_class_default);
13441 %}
13442 
13443 // encode char[] to byte[] in ISO_8859_1
13444 instruct encode_iso_array(rarg1RegP src, rarg2RegP dst, iRegIsrc len, iRegIdst result, iRegLdst tmp1,
13445                           iRegLdst tmp2, iRegLdst tmp3, iRegLdst tmp4, iRegLdst tmp5, regCTR ctr, flagsRegCR0 cr0) %{
13446   match(Set result (EncodeISOArray src (Binary dst len)));
13447   effect(TEMP_DEF result, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP tmp4, TEMP tmp5,
13448          USE_KILL src, USE_KILL dst, KILL ctr, KILL cr0);
13449   ins_cost(300);
13450   format %{ &quot;Encode array $src,$dst,$len -&gt; $result \t// KILL $tmp1, $tmp2, $tmp3, $tmp4, $tmp5&quot; %}
13451   ins_encode %{
13452     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13453     Label Lslow, Lfailure1, Lfailure2, Ldone;
13454     __ string_compress_16($src$$Register, $dst$$Register, $len$$Register, $tmp1$$Register,
13455                           $tmp2$$Register, $tmp3$$Register, $tmp4$$Register, $tmp5$$Register, Lfailure1);
13456     __ rldicl_($result$$Register, $len$$Register, 0, 64-3); // Remaining characters.
13457     __ beq(CCR0, Ldone);
13458     __ bind(Lslow);
13459     __ string_compress($src$$Register, $dst$$Register, $result$$Register, $tmp2$$Register, Lfailure2);
13460     __ li($result$$Register, 0);
13461     __ b(Ldone);
13462 
13463     __ bind(Lfailure1);
13464     __ mr($result$$Register, $len$$Register);
13465     __ mfctr($tmp1$$Register);
13466     __ rldimi_($result$$Register, $tmp1$$Register, 3, 0); // Remaining characters.
13467     __ beq(CCR0, Ldone);
13468     __ b(Lslow);
13469 
13470     __ bind(Lfailure2);
13471     __ mfctr($result$$Register); // Remaining characters.
13472 
13473     __ bind(Ldone);
13474     __ subf($result$$Register, $result$$Register, $len$$Register);
13475   %}
13476   ins_pipe(pipe_class_default);
13477 %}
13478 
13479 
13480 //---------- Min/Max Instructions ---------------------------------------------
13481 
13482 instruct minI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13483   match(Set dst (MinI src1 src2));
13484   ins_cost(DEFAULT_COST*6);
13485 
13486   expand %{
13487     iRegLdst src1s;
13488     iRegLdst src2s;
13489     iRegLdst diff;
13490     iRegLdst sm;
13491     iRegLdst doz; // difference or zero
13492     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13493     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13494     subL_reg_reg(diff, src2s, src1s);
13495     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13496     signmask64L_regL(sm, diff);
13497     andL_reg_reg(doz, diff, sm); // &lt;=0
13498     addI_regL_regL(dst, doz, src1s);
13499   %}
13500 %}
13501 
13502 instruct minI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13503   match(Set dst (MinI src1 src2));
13504   effect(KILL cr0);
13505   predicate(VM_Version::has_isel());
13506   ins_cost(DEFAULT_COST*2);
13507 
13508   ins_encode %{
13509     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13510     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13511     __ isel($dst$$Register, CCR0, Assembler::less, /*invert*/false, $src1$$Register, $src2$$Register);
13512   %}
13513   ins_pipe(pipe_class_default);
13514 %}
13515 
13516 instruct maxI_reg_reg_Ex(iRegIdst dst, iRegIsrc src1, iRegIsrc src2) %{
13517   match(Set dst (MaxI src1 src2));
13518   ins_cost(DEFAULT_COST*6);
13519 
13520   expand %{
13521     iRegLdst src1s;
13522     iRegLdst src2s;
13523     iRegLdst diff;
13524     iRegLdst sm;
13525     iRegLdst doz; // difference or zero
13526     convI2L_reg(src1s, src1); // Ensure proper sign extension.
13527     convI2L_reg(src2s, src2); // Ensure proper sign extension.
13528     subL_reg_reg(diff, src2s, src1s);
13529     // Need to consider &gt;=33 bit result, therefore we need signmaskL.
13530     signmask64L_regL(sm, diff);
13531     andcL_reg_reg(doz, diff, sm); // &gt;=0
13532     addI_regL_regL(dst, doz, src1s);
13533   %}
13534 %}
13535 
13536 instruct maxI_reg_reg_isel(iRegIdst dst, iRegIsrc src1, iRegIsrc src2, flagsRegCR0 cr0) %{
13537   match(Set dst (MaxI src1 src2));
13538   effect(KILL cr0);
13539   predicate(VM_Version::has_isel());
13540   ins_cost(DEFAULT_COST*2);
13541 
13542   ins_encode %{
13543     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
13544     __ cmpw(CCR0, $src1$$Register, $src2$$Register);
13545     __ isel($dst$$Register, CCR0, Assembler::greater, /*invert*/false, $src1$$Register, $src2$$Register);
13546   %}
13547   ins_pipe(pipe_class_default);
13548 %}
13549 
13550 //---------- Population Count Instructions ------------------------------------
13551 
13552 // Popcnt for Power7.
13553 instruct popCountI(iRegIdst dst, iRegIsrc src) %{
13554   match(Set dst (PopCountI src));
13555   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13556   ins_cost(DEFAULT_COST);
13557 
13558   format %{ &quot;POPCNTW $dst, $src&quot; %}
13559   size(4);
13560   ins_encode %{
13561     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13562     __ popcntw($dst$$Register, $src$$Register);
13563   %}
13564   ins_pipe(pipe_class_default);
13565 %}
13566 
13567 // Popcnt for Power7.
13568 instruct popCountL(iRegIdst dst, iRegLsrc src) %{
13569   predicate(UsePopCountInstruction &amp;&amp; VM_Version::has_popcntw());
13570   match(Set dst (PopCountL src));
13571   ins_cost(DEFAULT_COST);
13572 
13573   format %{ &quot;POPCNTD $dst, $src&quot; %}
13574   size(4);
13575   ins_encode %{
13576     // TODO: PPC port $archOpcode(ppc64Opcode_popcntb);
13577     __ popcntd($dst$$Register, $src$$Register);
13578   %}
13579   ins_pipe(pipe_class_default);
13580 %}
13581 
13582 instruct countLeadingZerosI(iRegIdst dst, iRegIsrc src) %{
13583   match(Set dst (CountLeadingZerosI src));
13584   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13585   ins_cost(DEFAULT_COST);
13586 
13587   format %{ &quot;CNTLZW  $dst, $src&quot; %}
13588   size(4);
13589   ins_encode %{
13590     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzw);
13591     __ cntlzw($dst$$Register, $src$$Register);
13592   %}
13593   ins_pipe(pipe_class_default);
13594 %}
13595 
13596 instruct countLeadingZerosL(iRegIdst dst, iRegLsrc src) %{
13597   match(Set dst (CountLeadingZerosL src));
13598   predicate(UseCountLeadingZerosInstructionsPPC64);  // See Matcher::match_rule_supported.
13599   ins_cost(DEFAULT_COST);
13600 
13601   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13602   size(4);
13603   ins_encode %{
13604     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13605     __ cntlzd($dst$$Register, $src$$Register);
13606   %}
13607   ins_pipe(pipe_class_default);
13608 %}
13609 
13610 instruct countLeadingZerosP(iRegIdst dst, iRegPsrc src) %{
13611   // no match-rule, false predicate
13612   effect(DEF dst, USE src);
13613   predicate(false);
13614 
13615   format %{ &quot;CNTLZD  $dst, $src&quot; %}
13616   size(4);
13617   ins_encode %{
13618     // TODO: PPC port $archOpcode(ppc64Opcode_cntlzd);
13619     __ cntlzd($dst$$Register, $src$$Register);
13620   %}
13621   ins_pipe(pipe_class_default);
13622 %}
13623 
13624 instruct countTrailingZerosI_Ex(iRegIdst dst, iRegIsrc src) %{
13625   match(Set dst (CountTrailingZerosI src));
13626   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13627   ins_cost(DEFAULT_COST);
13628 
13629   expand %{
13630     immI16 imm1 %{ (int)-1 %}
13631     immI16 imm2 %{ (int)32 %}
13632     immI_minus1 m1 %{ -1 %}
13633     iRegIdst tmpI1;
13634     iRegIdst tmpI2;
13635     iRegIdst tmpI3;
13636     addI_reg_imm16(tmpI1, src, imm1);
13637     andcI_reg_reg(tmpI2, src, m1, tmpI1);
13638     countLeadingZerosI(tmpI3, tmpI2);
13639     subI_imm16_reg(dst, imm2, tmpI3);
13640   %}
13641 %}
13642 
13643 instruct countTrailingZerosI_cnttzw(iRegIdst dst, iRegIsrc src) %{
13644   match(Set dst (CountTrailingZerosI src));
13645   predicate(UseCountTrailingZerosInstructionsPPC64);
13646   ins_cost(DEFAULT_COST);
13647 
13648   format %{ &quot;CNTTZW  $dst, $src&quot; %}
13649   size(4);
13650   ins_encode %{
13651     __ cnttzw($dst$$Register, $src$$Register);
13652   %}
13653   ins_pipe(pipe_class_default);
13654 %}
13655 
13656 instruct countTrailingZerosL_Ex(iRegIdst dst, iRegLsrc src) %{
13657   match(Set dst (CountTrailingZerosL src));
13658   predicate(UseCountLeadingZerosInstructionsPPC64 &amp;&amp; !UseCountTrailingZerosInstructionsPPC64);
13659   ins_cost(DEFAULT_COST);
13660 
13661   expand %{
13662     immL16 imm1 %{ (long)-1 %}
13663     immI16 imm2 %{ (int)64 %}
13664     iRegLdst tmpL1;
13665     iRegLdst tmpL2;
13666     iRegIdst tmpL3;
13667     addL_reg_imm16(tmpL1, src, imm1);
13668     andcL_reg_reg(tmpL2, tmpL1, src);
13669     countLeadingZerosL(tmpL3, tmpL2);
13670     subI_imm16_reg(dst, imm2, tmpL3);
13671  %}
13672 %}
13673 
13674 instruct countTrailingZerosL_cnttzd(iRegIdst dst, iRegLsrc src) %{
13675   match(Set dst (CountTrailingZerosL src));
13676   predicate(UseCountTrailingZerosInstructionsPPC64);
13677   ins_cost(DEFAULT_COST);
13678 
13679   format %{ &quot;CNTTZD  $dst, $src&quot; %}
13680   size(4);
13681   ins_encode %{
13682     __ cnttzd($dst$$Register, $src$$Register);
13683   %}
13684   ins_pipe(pipe_class_default);
13685 %}
13686 
13687 // Expand nodes for byte_reverse_int.
13688 instruct insrwi_a(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13689   effect(DEF dst, USE src, USE pos, USE shift);
13690   predicate(false);
13691 
13692   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13693   size(4);
13694   ins_encode %{
13695     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13696     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13697   %}
13698   ins_pipe(pipe_class_default);
13699 %}
13700 
13701 // As insrwi_a, but with USE_DEF.
13702 instruct insrwi(iRegIdst dst, iRegIsrc src, immI16 pos, immI16 shift) %{
13703   effect(USE_DEF dst, USE src, USE pos, USE shift);
13704   predicate(false);
13705 
13706   format %{ &quot;INSRWI  $dst, $src, $pos, $shift&quot; %}
13707   size(4);
13708   ins_encode %{
13709     // TODO: PPC port $archOpcode(ppc64Opcode_rlwimi);
13710     __ insrwi($dst$$Register, $src$$Register, $shift$$constant, $pos$$constant);
13711   %}
13712   ins_pipe(pipe_class_default);
13713 %}
13714 
13715 // Just slightly faster than java implementation.
13716 instruct bytes_reverse_int_Ex(iRegIdst dst, iRegIsrc src) %{
13717   match(Set dst (ReverseBytesI src));
13718   ins_cost(7*DEFAULT_COST);
13719 
13720   expand %{
13721     immI16 imm24 %{ (int) 24 %}
13722     immI16 imm16 %{ (int) 16 %}
13723     immI16  imm8 %{ (int)  8 %}
13724     immI16  imm4 %{ (int)  4 %}
13725     immI16  imm0 %{ (int)  0 %}
13726     iRegLdst tmpI1;
13727     iRegLdst tmpI2;
13728     iRegLdst tmpI3;
13729 
13730     urShiftI_reg_imm(tmpI1, src, imm24);
13731     insrwi_a(dst, tmpI1, imm24, imm8);
13732     urShiftI_reg_imm(tmpI2, src, imm16);
13733     insrwi(dst, tmpI2, imm8, imm16);
13734     urShiftI_reg_imm(tmpI3, src, imm8);
13735     insrwi(dst, tmpI3, imm8, imm8);
13736     insrwi(dst, src, imm0, imm8);
13737   %}
13738 %}
13739 
13740 instruct bytes_reverse_long_Ex(iRegLdst dst, iRegLsrc src) %{
13741   match(Set dst (ReverseBytesL src));
13742   ins_cost(15*DEFAULT_COST);
13743 
13744   expand %{
13745     immI16 imm56 %{ (int) 56 %}
13746     immI16 imm48 %{ (int) 48 %}
13747     immI16 imm40 %{ (int) 40 %}
13748     immI16 imm32 %{ (int) 32 %}
13749     immI16 imm24 %{ (int) 24 %}
13750     immI16 imm16 %{ (int) 16 %}
13751     immI16  imm8 %{ (int)  8 %}
13752     immI16  imm0 %{ (int)  0 %}
13753     iRegLdst tmpL1;
13754     iRegLdst tmpL2;
13755     iRegLdst tmpL3;
13756     iRegLdst tmpL4;
13757     iRegLdst tmpL5;
13758     iRegLdst tmpL6;
13759 
13760                                         // src   : |a|b|c|d|e|f|g|h|
13761     rldicl(tmpL1, src, imm8, imm24);    // tmpL1 : | | | |e|f|g|h|a|
13762     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |a| | | |e|
13763     rldicl(tmpL3, tmpL2, imm32, imm0);  // tmpL3 : | | | |e| | | |a|
13764     rldicl(tmpL1, src, imm16, imm24);   // tmpL1 : | | | |f|g|h|a|b|
13765     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |b| | | |f|
13766     rldicl(tmpL4, tmpL2, imm40, imm0);  // tmpL4 : | | |f| | | |b| |
13767     orL_reg_reg(tmpL5, tmpL3, tmpL4);   // tmpL5 : | | |f|e| | |b|a|
13768     rldicl(tmpL1, src, imm24, imm24);   // tmpL1 : | | | |g|h|a|b|c|
13769     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |c| | | |g|
13770     rldicl(tmpL3, tmpL2, imm48, imm0);  // tmpL3 : | |g| | | |c| | |
13771     rldicl(tmpL1, src, imm32, imm24);   // tmpL1 : | | | |h|a|b|c|d|
13772     rldicl(tmpL2, tmpL1, imm32, imm24); // tmpL2 : | | | |d| | | |h|
13773     rldicl(tmpL4, tmpL2, imm56, imm0);  // tmpL4 : |h| | | |d| | | |
13774     orL_reg_reg(tmpL6, tmpL3, tmpL4);   // tmpL6 : |h|g| | |d|c| | |
13775     orL_reg_reg(dst, tmpL5, tmpL6);     // dst   : |h|g|f|e|d|c|b|a|
13776   %}
13777 %}
13778 
13779 instruct bytes_reverse_ushort_Ex(iRegIdst dst, iRegIsrc src) %{
13780   match(Set dst (ReverseBytesUS src));
13781   ins_cost(2*DEFAULT_COST);
13782 
13783   expand %{
13784     immI16  imm16 %{ (int) 16 %}
13785     immI16   imm8 %{ (int)  8 %}
13786 
13787     urShiftI_reg_imm(dst, src, imm8);
13788     insrwi(dst, src, imm16, imm8);
13789   %}
13790 %}
13791 
13792 instruct bytes_reverse_short_Ex(iRegIdst dst, iRegIsrc src) %{
13793   match(Set dst (ReverseBytesS src));
13794   ins_cost(3*DEFAULT_COST);
13795 
13796   expand %{
13797     immI16  imm16 %{ (int) 16 %}
13798     immI16   imm8 %{ (int)  8 %}
13799     iRegLdst tmpI1;
13800 
13801     urShiftI_reg_imm(tmpI1, src, imm8);
13802     insrwi(tmpI1, src, imm16, imm8);
13803     extsh(dst, tmpI1);
13804   %}
13805 %}
13806 
13807 // Load Integer reversed byte order
13808 instruct loadI_reversed(iRegIdst dst, indirect mem) %{
13809   match(Set dst (ReverseBytesI (LoadI mem)));
13810   ins_cost(MEMORY_REF_COST);
13811 
13812   size(4);
13813   ins_encode %{
13814     __ lwbrx($dst$$Register, $mem$$Register);
13815   %}
13816   ins_pipe(pipe_class_default);
13817 %}
13818 
13819 // Load Long - aligned and reversed
13820 instruct loadL_reversed(iRegLdst dst, indirect mem) %{
13821   match(Set dst (ReverseBytesL (LoadL mem)));
13822   predicate(VM_Version::has_ldbrx());
13823   ins_cost(MEMORY_REF_COST);
13824 
13825   size(4);
13826   ins_encode %{
13827     __ ldbrx($dst$$Register, $mem$$Register);
13828   %}
13829   ins_pipe(pipe_class_default);
13830 %}
13831 
13832 // Load unsigned short / char reversed byte order
13833 instruct loadUS_reversed(iRegIdst dst, indirect mem) %{
13834   match(Set dst (ReverseBytesUS (LoadUS mem)));
13835   ins_cost(MEMORY_REF_COST);
13836 
13837   size(4);
13838   ins_encode %{
13839     __ lhbrx($dst$$Register, $mem$$Register);
13840   %}
13841   ins_pipe(pipe_class_default);
13842 %}
13843 
13844 // Load short reversed byte order
13845 instruct loadS_reversed(iRegIdst dst, indirect mem) %{
13846   match(Set dst (ReverseBytesS (LoadS mem)));
13847   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
13848 
13849   size(8);
13850   ins_encode %{
13851     __ lhbrx($dst$$Register, $mem$$Register);
13852     __ extsh($dst$$Register, $dst$$Register);
13853   %}
13854   ins_pipe(pipe_class_default);
13855 %}
13856 
13857 // Store Integer reversed byte order
13858 instruct storeI_reversed(iRegIsrc src, indirect mem) %{
13859   match(Set mem (StoreI mem (ReverseBytesI src)));
13860   ins_cost(MEMORY_REF_COST);
13861 
13862   size(4);
13863   ins_encode %{
13864     __ stwbrx($src$$Register, $mem$$Register);
13865   %}
13866   ins_pipe(pipe_class_default);
13867 %}
13868 
13869 // Store Long reversed byte order
13870 instruct storeL_reversed(iRegLsrc src, indirect mem) %{
13871   match(Set mem (StoreL mem (ReverseBytesL src)));
13872   predicate(VM_Version::has_stdbrx());
13873   ins_cost(MEMORY_REF_COST);
13874 
13875   size(4);
13876   ins_encode %{
13877     __ stdbrx($src$$Register, $mem$$Register);
13878   %}
13879   ins_pipe(pipe_class_default);
13880 %}
13881 
13882 // Store unsigned short / char reversed byte order
13883 instruct storeUS_reversed(iRegIsrc src, indirect mem) %{
13884   match(Set mem (StoreC mem (ReverseBytesUS src)));
13885   ins_cost(MEMORY_REF_COST);
13886 
13887   size(4);
13888   ins_encode %{
13889     __ sthbrx($src$$Register, $mem$$Register);
13890   %}
13891   ins_pipe(pipe_class_default);
13892 %}
13893 
13894 // Store short reversed byte order
13895 instruct storeS_reversed(iRegIsrc src, indirect mem) %{
13896   match(Set mem (StoreC mem (ReverseBytesS src)));
13897   ins_cost(MEMORY_REF_COST);
13898 
13899   size(4);
13900   ins_encode %{
13901     __ sthbrx($src$$Register, $mem$$Register);
13902   %}
13903   ins_pipe(pipe_class_default);
13904 %}
13905 
13906 instruct mtvsrwz(vecX temp1, iRegIsrc src) %{
13907   effect(DEF temp1, USE src);
13908 
13909   format %{ &quot;MTVSRWZ $temp1, $src \t// Move to 16-byte register&quot; %}
13910   size(4);
13911   ins_encode %{
13912     __ mtvsrwz($temp1$$VectorSRegister, $src$$Register);
13913   %}
13914   ins_pipe(pipe_class_default);
13915 %}
13916 
13917 instruct xxspltw(vecX dst, vecX src, immI8 imm1) %{
13918   effect(DEF dst, USE src, USE imm1);
13919 
13920   format %{ &quot;XXSPLTW $dst, $src, $imm1 \t// Splat word&quot; %}
13921   size(4);
13922   ins_encode %{
13923     __ xxspltw($dst$$VectorSRegister, $src$$VectorSRegister, $imm1$$constant);
13924   %}
13925   ins_pipe(pipe_class_default);
13926 %}
13927 
13928 instruct xscvdpspn_regF(vecX dst, regF src) %{
13929   effect(DEF dst, USE src);
13930 
13931   format %{ &quot;XSCVDPSPN $dst, $src \t// Convert scalar single precision to vector single precision&quot; %}
13932   size(4);
13933   ins_encode %{
13934     __ xscvdpspn($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr());
13935   %}
13936   ins_pipe(pipe_class_default);
13937 %}
13938 
13939 //---------- Replicate Vector Instructions ------------------------------------
13940 
13941 // Insrdi does replicate if src == dst.
13942 instruct repl32(iRegLdst dst) %{
13943   predicate(false);
13944   effect(USE_DEF dst);
13945 
13946   format %{ &quot;INSRDI  $dst, #0, $dst, #32 \t// replicate&quot; %}
13947   size(4);
13948   ins_encode %{
13949     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13950     __ insrdi($dst$$Register, $dst$$Register, 32, 0);
13951   %}
13952   ins_pipe(pipe_class_default);
13953 %}
13954 
13955 // Insrdi does replicate if src == dst.
13956 instruct repl48(iRegLdst dst) %{
13957   predicate(false);
13958   effect(USE_DEF dst);
13959 
13960   format %{ &quot;INSRDI  $dst, #0, $dst, #48 \t// replicate&quot; %}
13961   size(4);
13962   ins_encode %{
13963     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13964     __ insrdi($dst$$Register, $dst$$Register, 48, 0);
13965   %}
13966   ins_pipe(pipe_class_default);
13967 %}
13968 
13969 // Insrdi does replicate if src == dst.
13970 instruct repl56(iRegLdst dst) %{
13971   predicate(false);
13972   effect(USE_DEF dst);
13973 
13974   format %{ &quot;INSRDI  $dst, #0, $dst, #56 \t// replicate&quot; %}
13975   size(4);
13976   ins_encode %{
13977     // TODO: PPC port $archOpcode(ppc64Opcode_rldimi);
13978     __ insrdi($dst$$Register, $dst$$Register, 56, 0);
13979   %}
13980   ins_pipe(pipe_class_default);
13981 %}
13982 
13983 instruct repl8B_reg_Ex(iRegLdst dst, iRegIsrc src) %{
13984   match(Set dst (ReplicateB src));
13985   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13986   expand %{
13987     moveReg(dst, src);
13988     repl56(dst);
13989     repl48(dst);
13990     repl32(dst);
13991   %}
13992 %}
13993 
13994 instruct repl8B_immI0(iRegLdst dst, immI_0 zero) %{
13995   match(Set dst (ReplicateB zero));
13996   predicate(n-&gt;as_Vector()-&gt;length() == 8);
13997   format %{ &quot;LI      $dst, #0 \t// replicate8B&quot; %}
13998   size(4);
13999   ins_encode %{
14000     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14001     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14002   %}
14003   ins_pipe(pipe_class_default);
14004 %}
14005 
14006 instruct repl8B_immIminus1(iRegLdst dst, immI_minus1 src) %{
14007   match(Set dst (ReplicateB src));
14008   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14009   format %{ &quot;LI      $dst, #-1 \t// replicate8B&quot; %}
14010   size(4);
14011   ins_encode %{
14012     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14013     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14014   %}
14015   ins_pipe(pipe_class_default);
14016 %}
14017 
14018 instruct repl16B_reg_Ex(vecX dst, iRegIsrc src) %{
14019   match(Set dst (ReplicateB src));
14020   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14021 
14022   expand %{
14023     iRegLdst tmpL;
14024     vecX tmpV;
14025     immI8  imm1 %{ (int)  1 %}
14026     moveReg(tmpL, src);
14027     repl56(tmpL);
14028     repl48(tmpL);
14029     mtvsrwz(tmpV, tmpL);
14030     xxspltw(dst, tmpV, imm1);
14031   %}
14032 %}
14033 
14034 instruct repl16B_immI0(vecX dst, immI_0 zero) %{
14035   match(Set dst (ReplicateB zero));
14036   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14037 
14038   format %{ &quot;XXLXOR      $dst, $zero \t// replicate16B&quot; %}
14039   size(4);
14040   ins_encode %{
14041     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14042   %}
14043   ins_pipe(pipe_class_default);
14044 %}
14045 
14046 instruct repl16B_immIminus1(vecX dst, immI_minus1 src) %{
14047   match(Set dst (ReplicateB src));
14048   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14049 
14050   format %{ &quot;XXLEQV      $dst, $src \t// replicate16B&quot; %}
14051   size(4);
14052   ins_encode %{
14053     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14054   %}
14055   ins_pipe(pipe_class_default);
14056 %}
14057 
14058 instruct repl4S_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14059   match(Set dst (ReplicateS src));
14060   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14061   expand %{
14062     moveReg(dst, src);
14063     repl48(dst);
14064     repl32(dst);
14065   %}
14066 %}
14067 
14068 instruct repl4S_immI0(iRegLdst dst, immI_0 zero) %{
14069   match(Set dst (ReplicateS zero));
14070   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14071   format %{ &quot;LI      $dst, #0 \t// replicate4S&quot; %}
14072   size(4);
14073   ins_encode %{
14074     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14075     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14076   %}
14077   ins_pipe(pipe_class_default);
14078 %}
14079 
14080 instruct repl4S_immIminus1(iRegLdst dst, immI_minus1 src) %{
14081   match(Set dst (ReplicateS src));
14082   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14083   format %{ &quot;LI      $dst, -1 \t// replicate4S&quot; %}
14084   size(4);
14085   ins_encode %{
14086     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14087     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14088   %}
14089   ins_pipe(pipe_class_default);
14090 %}
14091 
14092 instruct repl8S_reg_Ex(vecX dst, iRegIsrc src) %{
14093   match(Set dst (ReplicateS src));
14094   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14095 
14096   expand %{
14097     iRegLdst tmpL;
14098     vecX tmpV;
14099     immI8  zero %{ (int)  0 %}
14100     moveReg(tmpL, src);
14101     repl48(tmpL);
14102     repl32(tmpL);
14103     mtvsrd(tmpV, tmpL);
14104     xxpermdi(dst, tmpV, tmpV, zero);
14105   %}
14106 %}
14107 
14108 instruct repl8S_immI0(vecX dst, immI_0 zero) %{
14109   match(Set dst (ReplicateS zero));
14110   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14111 
14112   format %{ &quot;XXLXOR      $dst, $zero \t// replicate8S&quot; %}
14113   size(4);
14114   ins_encode %{
14115     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14116   %}
14117   ins_pipe(pipe_class_default);
14118 %}
14119 
14120 instruct repl8S_immIminus1(vecX dst, immI_minus1 src) %{
14121   match(Set dst (ReplicateS src));
14122   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14123 
14124   format %{ &quot;XXLEQV      $dst, $src \t// replicate8S&quot; %}
14125   size(4);
14126   ins_encode %{
14127     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14128   %}
14129   ins_pipe(pipe_class_default);
14130 %}
14131 
14132 instruct repl2I_reg_Ex(iRegLdst dst, iRegIsrc src) %{
14133   match(Set dst (ReplicateI src));
14134   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14135   ins_cost(2 * DEFAULT_COST);
14136   expand %{
14137     moveReg(dst, src);
14138     repl32(dst);
14139   %}
14140 %}
14141 
14142 instruct repl2I_immI0(iRegLdst dst, immI_0 zero) %{
14143   match(Set dst (ReplicateI zero));
14144   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14145   format %{ &quot;LI      $dst, #0 \t// replicate2I&quot; %}
14146   size(4);
14147   ins_encode %{
14148     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14149     __ li($dst$$Register, (int)((short)($zero$$constant &amp; 0xFFFF)));
14150   %}
14151   ins_pipe(pipe_class_default);
14152 %}
14153 
14154 instruct repl2I_immIminus1(iRegLdst dst, immI_minus1 src) %{
14155   match(Set dst (ReplicateI src));
14156   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14157   format %{ &quot;LI      $dst, -1 \t// replicate2I&quot; %}
14158   size(4);
14159   ins_encode %{
14160     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14161     __ li($dst$$Register, (int)((short)($src$$constant &amp; 0xFFFF)));
14162   %}
14163   ins_pipe(pipe_class_default);
14164 %}
14165 
14166 instruct repl4I_reg_Ex(vecX dst, iRegIsrc src) %{
14167   match(Set dst (ReplicateI src));
14168   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14169   ins_cost(2 * DEFAULT_COST);
14170 
14171   expand %{
14172     iRegLdst tmpL;
14173     vecX tmpV;
14174     immI8  zero %{ (int)  0 %}
14175     moveReg(tmpL, src);
14176     repl32(tmpL);
14177     mtvsrd(tmpV, tmpL);
14178     xxpermdi(dst, tmpV, tmpV, zero);
14179   %}
14180 %}
14181 
14182 instruct repl4I_immI0(vecX dst, immI_0 zero) %{
14183   match(Set dst (ReplicateI zero));
14184   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14185 
14186   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4I&quot; %}
14187   size(4);
14188   ins_encode %{
14189     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14190   %}
14191   ins_pipe(pipe_class_default);
14192 %}
14193 
14194 instruct repl4I_immIminus1(vecX dst, immI_minus1 src) %{
14195   match(Set dst (ReplicateI src));
14196   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14197 
14198   format %{ &quot;XXLEQV      $dst, $dst, $dst \t// replicate4I&quot; %}
14199   size(4);
14200   ins_encode %{
14201     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14202   %}
14203   ins_pipe(pipe_class_default);
14204 %}
14205 
14206 // Move float to int register via stack, replicate.
14207 instruct repl2F_reg_Ex(iRegLdst dst, regF src) %{
14208   match(Set dst (ReplicateF src));
14209   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14210   ins_cost(2 * MEMORY_REF_COST + DEFAULT_COST);
14211   expand %{
14212     stackSlotL tmpS;
14213     iRegIdst tmpI;
14214     moveF2I_reg_stack(tmpS, src);   // Move float to stack.
14215     moveF2I_stack_reg(tmpI, tmpS);  // Move stack to int reg.
14216     moveReg(dst, tmpI);             // Move int to long reg.
14217     repl32(dst);                    // Replicate bitpattern.
14218   %}
14219 %}
14220 
14221 // Replicate scalar constant to packed float values in Double register
14222 instruct repl2F_immF_Ex(iRegLdst dst, immF src) %{
14223   match(Set dst (ReplicateF src));
14224   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14225   ins_cost(5 * DEFAULT_COST);
14226 
14227   format %{ &quot;LD      $dst, offset, $constanttablebase\t// load replicated float $src $src from table, postalloc expanded&quot; %}
14228   postalloc_expand( postalloc_expand_load_replF_constant(dst, src, constanttablebase) );
14229 %}
14230 
14231 // Replicate scalar zero constant to packed float values in Double register
14232 instruct repl2F_immF0(iRegLdst dst, immF_0 zero) %{
14233   match(Set dst (ReplicateF zero));
14234   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14235 
14236   format %{ &quot;LI      $dst, #0 \t// replicate2F&quot; %}
14237   ins_encode %{
14238     // TODO: PPC port $archOpcode(ppc64Opcode_addi);
14239     __ li($dst$$Register, 0x0);
14240   %}
14241   ins_pipe(pipe_class_default);
14242 %}
14243 
14244 
14245 //----------Vector Arithmetic Instructions--------------------------------------
14246 
14247 // Vector Addition Instructions
14248 
14249 instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{
14250   match(Set dst (AddVB src1 src2));
14251   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14252   format %{ &quot;VADDUBM  $dst,$src1,$src2\t// add packed16B&quot; %}
14253   size(4);
14254   ins_encode %{
14255     __ vaddubm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14256   %}
14257   ins_pipe(pipe_class_default);
14258 %}
14259 
14260 instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{
14261   match(Set dst (AddVS src1 src2));
14262   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14263   format %{ &quot;VADDUHM  $dst,$src1,$src2\t// add packed8S&quot; %}
14264   size(4);
14265   ins_encode %{
14266     __ vadduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14267   %}
14268   ins_pipe(pipe_class_default);
14269 %}
14270 
14271 instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{
14272   match(Set dst (AddVI src1 src2));
14273   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14274   format %{ &quot;VADDUWM  $dst,$src1,$src2\t// add packed4I&quot; %}
14275   size(4);
14276   ins_encode %{
14277     __ vadduwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14278   %}
14279   ins_pipe(pipe_class_default);
14280 %}
14281 
14282 instruct vadd4F_reg(vecX dst, vecX src1, vecX src2) %{
14283   match(Set dst (AddVF src1 src2));
14284   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14285   format %{ &quot;VADDFP  $dst,$src1,$src2\t// add packed4F&quot; %}
14286   size(4);
14287   ins_encode %{
14288     __ vaddfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14289   %}
14290   ins_pipe(pipe_class_default);
14291 %}
14292 
14293 instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{
14294   match(Set dst (AddVL src1 src2));
14295   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14296   format %{ &quot;VADDUDM  $dst,$src1,$src2\t// add packed2L&quot; %}
14297   size(4);
14298   ins_encode %{
14299     __ vaddudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14300   %}
14301   ins_pipe(pipe_class_default);
14302 %}
14303 
14304 instruct vadd2D_reg(vecX dst, vecX src1, vecX src2) %{
14305   match(Set dst (AddVD src1 src2));
14306   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14307   format %{ &quot;XVADDDP  $dst,$src1,$src2\t// add packed2D&quot; %}
14308   size(4);
14309   ins_encode %{
14310     __ xvadddp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14311   %}
14312   ins_pipe(pipe_class_default);
14313 %}
14314 
14315 // Vector Subtraction Instructions
14316 
14317 instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{
14318   match(Set dst (SubVB src1 src2));
14319   predicate(n-&gt;as_Vector()-&gt;length() == 16);
14320   format %{ &quot;VSUBUBM  $dst,$src1,$src2\t// sub packed16B&quot; %}
14321   size(4);
14322   ins_encode %{
14323     __ vsububm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14324   %}
14325   ins_pipe(pipe_class_default);
14326 %}
14327 
14328 instruct vsub8S_reg(vecX dst, vecX src1, vecX src2) %{
14329   match(Set dst (SubVS src1 src2));
14330   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14331   format %{ &quot;VSUBUHM  $dst,$src1,$src2\t// sub packed8S&quot; %}
14332   size(4);
14333   ins_encode %{
14334     __ vsubuhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14335   %}
14336   ins_pipe(pipe_class_default);
14337 %}
14338 
14339 instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{
14340   match(Set dst (SubVI src1 src2));
14341   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14342   format %{ &quot;VSUBUWM  $dst,$src1,$src2\t// sub packed4I&quot; %}
14343   size(4);
14344   ins_encode %{
14345     __ vsubuwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14346   %}
14347   ins_pipe(pipe_class_default);
14348 %}
14349 
14350 instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{
14351   match(Set dst (SubVF src1 src2));
14352   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14353   format %{ &quot;VSUBFP  $dst,$src1,$src2\t// sub packed4F&quot; %}
14354   size(4);
14355   ins_encode %{
14356     __ vsubfp($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14357   %}
14358   ins_pipe(pipe_class_default);
14359 %}
14360 
14361 instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{
14362   match(Set dst (SubVL src1 src2));
14363   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14364   format %{ &quot;VSUBUDM  $dst,$src1,$src2\t// sub packed2L&quot; %}
14365   size(4);
14366   ins_encode %{
14367     __ vsubudm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14368   %}
14369   ins_pipe(pipe_class_default);
14370 %}
14371 
14372 instruct vsub2D_reg(vecX dst, vecX src1, vecX src2) %{
14373   match(Set dst (SubVD src1 src2));
14374   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14375   format %{ &quot;XVSUBDP  $dst,$src1,$src2\t// sub packed2D&quot; %}
14376   size(4);
14377   ins_encode %{
14378     __ xvsubdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14379   %}
14380   ins_pipe(pipe_class_default);
14381 %}
14382 
14383 // Vector Multiplication Instructions
14384 
14385 instruct vmul8S_reg(vecX dst, vecX src1, vecX src2, vecX tmp) %{
14386   match(Set dst (MulVS src1 src2));
14387   predicate(n-&gt;as_Vector()-&gt;length() == 8);
14388   effect(TEMP tmp);
14389   format %{ &quot;VSPLTISH  $tmp,0\t// mul packed8S&quot; %}
14390   format %{ &quot;VMLADDUHM  $dst,$src1,$src2\t// mul packed8S&quot; %}
14391   size(8);
14392   ins_encode %{
14393     __ vspltish($tmp$$VectorSRegister-&gt;to_vr(), 0);
14394     __ vmladduhm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr(), $tmp$$VectorSRegister-&gt;to_vr());
14395   %}
14396   ins_pipe(pipe_class_default);
14397 %}
14398 
14399 instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{
14400   match(Set dst (MulVI src1 src2));
14401   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14402   format %{ &quot;VMULUWM  $dst,$src1,$src2\t// mul packed4I&quot; %}
14403   size(4);
14404   ins_encode %{
14405     __ vmuluwm($dst$$VectorSRegister-&gt;to_vr(), $src1$$VectorSRegister-&gt;to_vr(), $src2$$VectorSRegister-&gt;to_vr());
14406   %}
14407   ins_pipe(pipe_class_default);
14408 %}
14409 
14410 instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{
14411   match(Set dst (MulVF src1 src2));
14412   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14413   format %{ &quot;XVMULSP  $dst,$src1,$src2\t// mul packed4F&quot; %}
14414   size(4);
14415   ins_encode %{
14416     __ xvmulsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14417   %}
14418   ins_pipe(pipe_class_default);
14419 %}
14420 
14421 instruct vmul2D_reg(vecX dst, vecX src1, vecX src2) %{
14422   match(Set dst (MulVD src1 src2));
14423   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14424   format %{ &quot;XVMULDP  $dst,$src1,$src2\t// mul packed2D&quot; %}
14425   size(4);
14426   ins_encode %{
14427     __ xvmuldp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14428   %}
14429   ins_pipe(pipe_class_default);
14430 %}
14431 
14432 // Vector Division Instructions
14433 
14434 instruct vdiv4F_reg(vecX dst, vecX src1, vecX src2) %{
14435   match(Set dst (DivVF src1 src2));
14436   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14437   format %{ &quot;XVDIVSP  $dst,$src1,$src2\t// div packed4F&quot; %}
14438   size(4);
14439   ins_encode %{
14440     __ xvdivsp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14441   %}
14442   ins_pipe(pipe_class_default);
14443 %}
14444 
14445 instruct vdiv2D_reg(vecX dst, vecX src1, vecX src2) %{
14446   match(Set dst (DivVD src1 src2));
14447   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14448   format %{ &quot;XVDIVDP  $dst,$src1,$src2\t// div packed2D&quot; %}
14449   size(4);
14450   ins_encode %{
14451     __ xvdivdp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14452   %}
14453   ins_pipe(pipe_class_default);
14454 %}
14455 
14456 // Vector Absolute Instructions
14457 
14458 instruct vabs4F_reg(vecX dst, vecX src) %{
14459   match(Set dst (AbsVF src));
14460   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14461   format %{ &quot;XVABSSP $dst,$src\t// absolute packed4F&quot; %}
14462   size(4);
14463   ins_encode %{
14464     __ xvabssp($dst$$VectorSRegister, $src$$VectorSRegister);
14465   %}
14466   ins_pipe(pipe_class_default);
14467 %}
14468 
14469 instruct vabs2D_reg(vecX dst, vecX src) %{
14470   match(Set dst (AbsVD src));
14471   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14472   format %{ &quot;XVABSDP $dst,$src\t// absolute packed2D&quot; %}
14473   size(4);
14474   ins_encode %{
14475     __ xvabsdp($dst$$VectorSRegister, $src$$VectorSRegister);
14476   %}
14477   ins_pipe(pipe_class_default);
14478 %}
14479 
14480 // Round Instructions
14481 instruct roundD_reg(regD dst, regD src, immI8 rmode) %{
14482   match(Set dst (RoundDoubleMode src rmode));
14483   format %{ &quot;RoundDoubleMode $src,$rmode&quot; %}
14484   size(4);
14485   ins_encode %{
14486     switch ($rmode$$constant) {
14487       case RoundDoubleModeNode::rmode_rint:
14488         __ frin($dst$$FloatRegister, $src$$FloatRegister);
14489         break;
14490       case RoundDoubleModeNode::rmode_floor:
14491         __ frim($dst$$FloatRegister, $src$$FloatRegister);
14492         break;
14493       case RoundDoubleModeNode::rmode_ceil:
14494         __ frip($dst$$FloatRegister, $src$$FloatRegister);
14495         break;
14496       default:
14497         ShouldNotReachHere();
14498     }
14499   %}
14500   ins_pipe(pipe_class_default);
14501 %}
14502 
14503 // Vector Round Instructions
14504 instruct vround2D_reg(vecX dst, vecX src, immI8 rmode) %{
14505   match(Set dst (RoundDoubleModeV src rmode));
14506   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14507   format %{ &quot;RoundDoubleModeV $src,$rmode&quot; %}
14508   size(4);
14509   ins_encode %{
14510     switch ($rmode$$constant) {
14511       case RoundDoubleModeNode::rmode_rint:
14512         __ xvrdpi($dst$$VectorSRegister, $src$$VectorSRegister);
14513         break;
14514       case RoundDoubleModeNode::rmode_floor:
14515         __ xvrdpim($dst$$VectorSRegister, $src$$VectorSRegister);
14516         break;
14517       case RoundDoubleModeNode::rmode_ceil:
14518         __ xvrdpip($dst$$VectorSRegister, $src$$VectorSRegister);
14519         break;
14520       default:
14521         ShouldNotReachHere();
14522     }
14523   %}
14524   ins_pipe(pipe_class_default);
14525 %}
14526 
14527 // Vector Negate Instructions
14528 
14529 instruct vneg4F_reg(vecX dst, vecX src) %{
14530   match(Set dst (NegVF src));
14531   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14532   format %{ &quot;XVNEGSP $dst,$src\t// negate packed4F&quot; %}
14533   size(4);
14534   ins_encode %{
14535     __ xvnegsp($dst$$VectorSRegister, $src$$VectorSRegister);
14536   %}
14537   ins_pipe(pipe_class_default);
14538 %}
14539 
14540 instruct vneg2D_reg(vecX dst, vecX src) %{
14541   match(Set dst (NegVD src));
14542   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14543   format %{ &quot;XVNEGDP $dst,$src\t// negate packed2D&quot; %}
14544   size(4);
14545   ins_encode %{
14546     __ xvnegdp($dst$$VectorSRegister, $src$$VectorSRegister);
14547   %}
14548   ins_pipe(pipe_class_default);
14549 %}
14550 
14551 // Vector Square Root Instructions
14552 
14553 instruct vsqrt4F_reg(vecX dst, vecX src) %{
14554   match(Set dst (SqrtVF src));
14555   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14556   format %{ &quot;XVSQRTSP $dst,$src\t// sqrt packed4F&quot; %}
14557   size(4);
14558   ins_encode %{
14559     __ xvsqrtsp($dst$$VectorSRegister, $src$$VectorSRegister);
14560   %}
14561   ins_pipe(pipe_class_default);
14562 %}
14563 
14564 instruct vsqrt2D_reg(vecX dst, vecX src) %{
14565   match(Set dst (SqrtVD src));
14566   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14567   format %{ &quot;XVSQRTDP  $dst,$src\t// sqrt packed2D&quot; %}
14568   size(4);
14569   ins_encode %{
14570     __ xvsqrtdp($dst$$VectorSRegister, $src$$VectorSRegister);
14571   %}
14572   ins_pipe(pipe_class_default);
14573 %}
14574 
14575 // Vector Population Count Instructions
14576 
14577 instruct vpopcnt4I_reg(vecX dst, vecX src) %{
14578   match(Set dst (PopCountVI src));
14579   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14580   format %{ &quot;VPOPCNTW $dst,$src\t// pop count packed4I&quot; %}
14581   size(4);
14582   ins_encode %{
14583     __ vpopcntw($dst$$VectorSRegister-&gt;to_vr(), $src$$VectorSRegister-&gt;to_vr());
14584   %}
14585   ins_pipe(pipe_class_default);
14586 %}
14587 
14588 // --------------------------------- FMA --------------------------------------
14589 // dst + src1 * src2
14590 instruct vfma4F(vecX dst, vecX src1, vecX src2) %{
14591   match(Set dst (FmaVF dst (Binary src1 src2)));
14592   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14593 
14594   format %{ &quot;XVMADDASP   $dst, $src1, $src2&quot; %}
14595 
14596   size(4);
14597   ins_encode %{
14598     __ xvmaddasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14599   %}
14600   ins_pipe(pipe_class_default);
14601 %}
14602 
14603 // dst - src1 * src2
14604 instruct vfma4F_neg1(vecX dst, vecX src1, vecX src2) %{
14605   match(Set dst (FmaVF dst (Binary (NegVF src1) src2)));
14606   match(Set dst (FmaVF dst (Binary src1 (NegVF src2))));
14607   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14608 
14609   format %{ &quot;XVNMSUBASP   $dst, $src1, $src2&quot; %}
14610 
14611   size(4);
14612   ins_encode %{
14613     __ xvnmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14614   %}
14615   ins_pipe(pipe_class_default);
14616 %}
14617 
14618 // - dst + src1 * src2
14619 instruct vfma4F_neg2(vecX dst, vecX src1, vecX src2) %{
14620   match(Set dst (FmaVF (NegVF dst) (Binary src1 src2)));
14621   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14622 
14623   format %{ &quot;XVMSUBASP   $dst, $src1, $src2&quot; %}
14624 
14625   size(4);
14626   ins_encode %{
14627     __ xvmsubasp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14628   %}
14629   ins_pipe(pipe_class_default);
14630 %}
14631 
14632 // dst + src1 * src2
14633 instruct vfma2D(vecX dst, vecX src1, vecX src2) %{
14634   match(Set dst (FmaVD  dst (Binary src1 src2)));
14635   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14636 
14637   format %{ &quot;XVMADDADP   $dst, $src1, $src2&quot; %}
14638 
14639   size(4);
14640   ins_encode %{
14641     __ xvmaddadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14642   %}
14643   ins_pipe(pipe_class_default);
14644 %}
14645 
14646 // dst - src1 * src2
14647 instruct vfma2D_neg1(vecX dst, vecX src1, vecX src2) %{
14648   match(Set dst (FmaVD  dst (Binary (NegVD src1) src2)));
14649   match(Set dst (FmaVD  dst (Binary src1 (NegVD src2))));
14650   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14651 
14652   format %{ &quot;XVNMSUBADP   $dst, $src1, $src2&quot; %}
14653 
14654   size(4);
14655   ins_encode %{
14656     __ xvnmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14657   %}
14658   ins_pipe(pipe_class_default);
14659 %}
14660 
14661 // - dst + src1 * src2
14662 instruct vfma2D_neg2(vecX dst, vecX src1, vecX src2) %{
14663   match(Set dst (FmaVD (NegVD dst) (Binary src1 src2)));
14664   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14665 
14666   format %{ &quot;XVMSUBADP   $dst, $src1, $src2&quot; %}
14667 
14668   size(4);
14669   ins_encode %{
14670     __ xvmsubadp($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister);
14671   %}
14672   ins_pipe(pipe_class_default);
14673 %}
14674 
14675 //----------Overflow Math Instructions-----------------------------------------
14676 
14677 // Note that we have to make sure that XER.SO is reset before using overflow instructions.
14678 // Simple Overflow operations can be matched by very few instructions (e.g. addExact: xor, and_, bc).
14679 // Seems like only Long intrinsincs have an advantage. (The only expensive one is OverflowMulL.)
14680 
14681 instruct overflowAddL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14682   match(Set cr0 (OverflowAddL op1 op2));
14683 
14684   format %{ &quot;add_    $op1, $op2\t# overflow check long&quot; %}
14685   ins_encode %{
14686     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14687     __ li(R0, 0);
14688     __ mtxer(R0); // clear XER.SO
14689     __ addo_(R0, $op1$$Register, $op2$$Register);
14690   %}
14691   ins_pipe(pipe_class_default);
14692 %}
14693 
14694 instruct overflowSubL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14695   match(Set cr0 (OverflowSubL op1 op2));
14696 
14697   format %{ &quot;subfo_  R0, $op2, $op1\t# overflow check long&quot; %}
14698   ins_encode %{
14699     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14700     __ li(R0, 0);
14701     __ mtxer(R0); // clear XER.SO
14702     __ subfo_(R0, $op2$$Register, $op1$$Register);
14703   %}
14704   ins_pipe(pipe_class_default);
14705 %}
14706 
14707 instruct overflowNegL_reg(flagsRegCR0 cr0, immL_0 zero, iRegLsrc op2) %{
14708   match(Set cr0 (OverflowSubL zero op2));
14709 
14710   format %{ &quot;nego_   R0, $op2\t# overflow check long&quot; %}
14711   ins_encode %{
14712     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14713     __ li(R0, 0);
14714     __ mtxer(R0); // clear XER.SO
14715     __ nego_(R0, $op2$$Register);
14716   %}
14717   ins_pipe(pipe_class_default);
14718 %}
14719 
14720 instruct overflowMulL_reg_reg(flagsRegCR0 cr0, iRegLsrc op1, iRegLsrc op2) %{
14721   match(Set cr0 (OverflowMulL op1 op2));
14722 
14723   format %{ &quot;mulldo_ R0, $op1, $op2\t# overflow check long&quot; %}
14724   ins_encode %{
14725     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
14726     __ li(R0, 0);
14727     __ mtxer(R0); // clear XER.SO
14728     __ mulldo_(R0, $op1$$Register, $op2$$Register);
14729   %}
14730   ins_pipe(pipe_class_default);
14731 %}
14732 
14733 instruct repl4F_reg_Ex(vecX dst, regF src) %{
14734   match(Set dst (ReplicateF src));
14735   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14736   ins_cost(DEFAULT_COST);
14737   expand %{
14738     vecX tmpV;
14739     immI8  zero %{ (int)  0 %}
14740 
14741     xscvdpspn_regF(tmpV, src);
14742     xxspltw(dst, tmpV, zero);
14743   %}
14744 %}
14745 
14746 instruct repl4F_immF_Ex(vecX dst, immF src, iRegLdst tmp) %{
14747   match(Set dst (ReplicateF src));
14748   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14749   effect(TEMP tmp);
14750   ins_cost(10 * DEFAULT_COST);
14751 
14752   postalloc_expand( postalloc_expand_load_replF_constant_vsx(dst, src, constanttablebase, tmp) );
14753 %}
14754 
14755 instruct repl4F_immF0(vecX dst, immF_0 zero) %{
14756   match(Set dst (ReplicateF zero));
14757   predicate(n-&gt;as_Vector()-&gt;length() == 4);
14758 
14759   format %{ &quot;XXLXOR      $dst, $zero \t// replicate4F&quot; %}
14760   ins_encode %{
14761     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14762   %}
14763   ins_pipe(pipe_class_default);
14764 %}
14765 
14766 instruct repl2D_reg_Ex(vecX dst, regD src) %{
14767   match(Set dst (ReplicateD src));
14768   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14769 
14770   format %{ &quot;XXPERMDI      $dst, $src, $src, 0 \t// Splat doubleword&quot; %}
14771   size(4);
14772   ins_encode %{
14773     __ xxpermdi($dst$$VectorSRegister, $src$$FloatRegister-&gt;to_vsr(), $src$$FloatRegister-&gt;to_vsr(), 0);
14774   %}
14775   ins_pipe(pipe_class_default);
14776 %}
14777 
14778 instruct repl2D_immD0(vecX dst, immD_0 zero) %{
14779   match(Set dst (ReplicateD zero));
14780   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14781 
14782   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2D&quot; %}
14783   size(4);
14784   ins_encode %{
14785     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14786   %}
14787   ins_pipe(pipe_class_default);
14788 %}
14789 
14790 instruct mtvsrd(vecX dst, iRegLsrc src) %{
14791   predicate(false);
14792   effect(DEF dst, USE src);
14793 
14794   format %{ &quot;MTVSRD      $dst, $src \t// Move to 16-byte register&quot; %}
14795   size(4);
14796   ins_encode %{
14797     __ mtvsrd($dst$$VectorSRegister, $src$$Register);
14798   %}
14799   ins_pipe(pipe_class_default);
14800 %}
14801 
14802 instruct xxspltd(vecX dst, vecX src, immI8 zero) %{
14803   effect(DEF dst, USE src, USE zero);
14804 
14805   format %{ &quot;XXSPLATD      $dst, $src, $zero \t// Splat doubleword&quot; %}
14806   size(4);
14807   ins_encode %{
14808     __ xxpermdi($dst$$VectorSRegister, $src$$VectorSRegister, $src$$VectorSRegister, $zero$$constant);
14809   %}
14810   ins_pipe(pipe_class_default);
14811 %}
14812 
14813 instruct xxpermdi(vecX dst, vecX src1, vecX src2, immI8 zero) %{
14814   effect(DEF dst, USE src1, USE src2, USE zero);
14815 
14816   format %{ &quot;XXPERMDI      $dst, $src1, $src2, $zero \t// Splat doubleword&quot; %}
14817   size(4);
14818   ins_encode %{
14819     __ xxpermdi($dst$$VectorSRegister, $src1$$VectorSRegister, $src2$$VectorSRegister, $zero$$constant);
14820   %}
14821   ins_pipe(pipe_class_default);
14822 %}
14823 
14824 instruct repl2L_reg_Ex(vecX dst, iRegLsrc src) %{
14825   match(Set dst (ReplicateL src));
14826   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14827   expand %{
14828     vecX tmpV;
14829     immI8  zero %{ (int)  0 %}
14830     mtvsrd(tmpV, src);
14831     xxpermdi(dst, tmpV, tmpV, zero);
14832   %}
14833 %}
14834 
14835 instruct repl2L_immI0(vecX dst, immI_0 zero) %{
14836   match(Set dst (ReplicateL zero));
14837   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14838 
14839   format %{ &quot;XXLXOR      $dst, $zero \t// replicate2L&quot; %}
14840   size(4);
14841   ins_encode %{
14842     __ xxlxor($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14843   %}
14844   ins_pipe(pipe_class_default);
14845 %}
14846 
14847 instruct repl2L_immIminus1(vecX dst, immI_minus1 src) %{
14848   match(Set dst (ReplicateL src));
14849   predicate(n-&gt;as_Vector()-&gt;length() == 2);
14850 
14851   format %{ &quot;XXLEQV      $dst, $src \t// replicate2L&quot; %}
14852   size(4);
14853   ins_encode %{
14854     __ xxleqv($dst$$VectorSRegister, $dst$$VectorSRegister, $dst$$VectorSRegister);
14855   %}
14856   ins_pipe(pipe_class_default);
14857 %}
14858 
14859 // ============================================================================
14860 // Safepoint Instruction
14861 
14862 instruct safePoint_poll(iRegPdst poll) %{
14863   match(SafePoint poll);
14864 
14865   // It caused problems to add the effect that r0 is killed, but this
14866   // effect no longer needs to be mentioned, since r0 is not contained
14867   // in a reg_class.
14868 
14869   format %{ &quot;LD      R0, #0, $poll \t// Safepoint poll for GC&quot; %}
14870   size(4);
14871   ins_encode( enc_poll(0x0, poll) );
14872   ins_pipe(pipe_class_default);
14873 %}
14874 
14875 // ============================================================================
14876 // Call Instructions
14877 
14878 // Call Java Static Instruction
14879 
14880 // Schedulable version of call static node.
14881 instruct CallStaticJavaDirect(method meth) %{
14882   match(CallStaticJava);
14883   effect(USE meth);
14884   ins_cost(CALL_COST);
14885 
14886   ins_num_consts(3 /* up to 3 patchable constants: inline cache, 2 call targets. */);
14887 
14888   format %{ &quot;CALL,static $meth \t// ==&gt; &quot; %}
14889   size(4);
14890   ins_encode( enc_java_static_call(meth) );
14891   ins_pipe(pipe_class_call);
14892 %}
14893 
14894 // Call Java Dynamic Instruction
14895 
14896 // Used by postalloc expand of CallDynamicJavaDirectSchedEx (actual call).
14897 // Loading of IC was postalloc expanded. The nodes loading the IC are reachable
14898 // via fields ins_field_load_ic_hi_node and ins_field_load_ic_node.
14899 // The call destination must still be placed in the constant pool.
14900 instruct CallDynamicJavaDirectSched(method meth) %{
14901   match(CallDynamicJava); // To get all the data fields we need ...
14902   effect(USE meth);
14903   predicate(false);       // ... but never match.
14904 
14905   ins_field_load_ic_hi_node(loadConL_hiNode*);
14906   ins_field_load_ic_node(loadConLNode*);
14907   ins_num_consts(1 /* 1 patchable constant: call destination */);
14908 
14909   format %{ &quot;BL        \t// dynamic $meth ==&gt; &quot; %}
14910   size(4);
14911   ins_encode( enc_java_dynamic_call_sched(meth) );
14912   ins_pipe(pipe_class_call);
14913 %}
14914 
14915 // Schedulable (i.e. postalloc expanded) version of call dynamic java.
14916 // We use postalloc expanded calls if we use inline caches
14917 // and do not update method data.
14918 //
14919 // This instruction has two constants: inline cache (IC) and call destination.
14920 // Loading the inline cache will be postalloc expanded, thus leaving a call with
14921 // one constant.
14922 instruct CallDynamicJavaDirectSched_Ex(method meth) %{
14923   match(CallDynamicJava);
14924   effect(USE meth);
14925   predicate(UseInlineCaches);
14926   ins_cost(CALL_COST);
14927 
14928   ins_num_consts(2 /* 2 patchable constants: inline cache, call destination. */);
14929 
14930   format %{ &quot;CALL,dynamic $meth \t// postalloc expanded&quot; %}
14931   postalloc_expand( postalloc_expand_java_dynamic_call_sched(meth, constanttablebase) );
14932 %}
14933 
14934 // Compound version of call dynamic java
14935 // We use postalloc expanded calls if we use inline caches
14936 // and do not update method data.
14937 instruct CallDynamicJavaDirect(method meth) %{
14938   match(CallDynamicJava);
14939   effect(USE meth);
14940   predicate(!UseInlineCaches);
14941   ins_cost(CALL_COST);
14942 
14943   // Enc_java_to_runtime_call needs up to 4 constants (method data oop).
14944   ins_num_consts(4);
14945 
14946   format %{ &quot;CALL,dynamic $meth \t// ==&gt; &quot; %}
14947   ins_encode( enc_java_dynamic_call(meth, constanttablebase) );
14948   ins_pipe(pipe_class_call);
14949 %}
14950 
14951 // Call Runtime Instruction
14952 
14953 instruct CallRuntimeDirect(method meth) %{
14954   match(CallRuntime);
14955   effect(USE meth);
14956   ins_cost(CALL_COST);
14957 
14958   // Enc_java_to_runtime_call needs up to 3 constants: call target,
14959   // env for callee, C-toc.
14960   ins_num_consts(3);
14961 
14962   format %{ &quot;CALL,runtime&quot; %}
14963   ins_encode( enc_java_to_runtime_call(meth) );
14964   ins_pipe(pipe_class_call);
14965 %}
14966 
14967 // Call Leaf
14968 
14969 // Used by postalloc expand of CallLeafDirect_Ex (mtctr).
14970 instruct CallLeafDirect_mtctr(iRegLdst dst, iRegLsrc src) %{
14971   effect(DEF dst, USE src);
14972 
14973   ins_num_consts(1);
14974 
14975   format %{ &quot;MTCTR   $src&quot; %}
14976   size(4);
14977   ins_encode( enc_leaf_call_mtctr(src) );
14978   ins_pipe(pipe_class_default);
14979 %}
14980 
14981 // Used by postalloc expand of CallLeafDirect_Ex (actual call).
14982 instruct CallLeafDirect(method meth) %{
14983   match(CallLeaf);   // To get the data all the data fields we need ...
14984   effect(USE meth);
14985   predicate(false);  // but never match.
14986 
14987   format %{ &quot;BCTRL     \t// leaf call $meth ==&gt; &quot; %}
14988   size(4);
14989   ins_encode %{
14990     // TODO: PPC port $archOpcode(ppc64Opcode_bctrl);
14991     __ bctrl();
14992   %}
14993   ins_pipe(pipe_class_call);
14994 %}
14995 
14996 // postalloc expand of CallLeafDirect.
14997 // Load adress to call from TOC, then bl to it.
14998 instruct CallLeafDirect_Ex(method meth) %{
14999   match(CallLeaf);
15000   effect(USE meth);
15001   ins_cost(CALL_COST);
15002 
15003   // Postalloc_expand_java_to_runtime_call needs up to 3 constants: call target,
15004   // env for callee, C-toc.
15005   ins_num_consts(3);
15006 
15007   format %{ &quot;CALL,runtime leaf $meth \t// postalloc expanded&quot; %}
15008   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15009 %}
15010 
15011 // Call runtime without safepoint - same as CallLeaf.
15012 // postalloc expand of CallLeafNoFPDirect.
15013 // Load adress to call from TOC, then bl to it.
15014 instruct CallLeafNoFPDirect_Ex(method meth) %{
15015   match(CallLeafNoFP);
15016   effect(USE meth);
15017   ins_cost(CALL_COST);
15018 
15019   // Enc_java_to_runtime_call needs up to 3 constants: call target,
15020   // env for callee, C-toc.
15021   ins_num_consts(3);
15022 
15023   format %{ &quot;CALL,runtime leaf nofp $meth \t// postalloc expanded&quot; %}
15024   postalloc_expand( postalloc_expand_java_to_runtime_call(meth, constanttablebase) );
15025 %}
15026 
15027 // Tail Call; Jump from runtime stub to Java code.
15028 // Also known as an &#39;interprocedural jump&#39;.
15029 // Target of jump will eventually return to caller.
15030 // TailJump below removes the return address.
15031 instruct TailCalljmpInd(iRegPdstNoScratch jump_target, inline_cache_regP method_oop) %{
15032   match(TailCall jump_target method_oop);
15033   ins_cost(CALL_COST);
15034 
15035   format %{ &quot;MTCTR   $jump_target \t// $method_oop holds method oop\n\t&quot;
15036             &quot;BCTR         \t// tail call&quot; %}
15037   size(8);
15038   ins_encode %{
15039     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15040     __ mtctr($jump_target$$Register);
15041     __ bctr();
15042   %}
15043   ins_pipe(pipe_class_call);
15044 %}
15045 
15046 // Return Instruction
15047 instruct Ret() %{
15048   match(Return);
15049   format %{ &quot;BLR      \t// branch to link register&quot; %}
15050   size(4);
15051   ins_encode %{
15052     // TODO: PPC port $archOpcode(ppc64Opcode_blr);
15053     // LR is restored in MachEpilogNode. Just do the RET here.
15054     __ blr();
15055   %}
15056   ins_pipe(pipe_class_default);
15057 %}
15058 
15059 // Tail Jump; remove the return address; jump to target.
15060 // TailCall above leaves the return address around.
15061 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
15062 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
15063 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
15064 // in %i0.
15065 instruct tailjmpInd(iRegPdstNoScratch jump_target, rarg1RegP ex_oop) %{
15066   match(TailJump jump_target ex_oop);
15067   ins_cost(CALL_COST);
15068 
15069   format %{ &quot;LD      R4_ARG2 = LR\n\t&quot;
15070             &quot;MTCTR   $jump_target\n\t&quot;
15071             &quot;BCTR     \t// TailJump, exception oop: $ex_oop&quot; %}
15072   size(12);
15073   ins_encode %{
15074     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15075     __ ld(R4_ARG2/* issuing pc */, _abi(lr), R1_SP);
15076     __ mtctr($jump_target$$Register);
15077     __ bctr();
15078   %}
15079   ins_pipe(pipe_class_call);
15080 %}
15081 
15082 // Create exception oop: created by stack-crawling runtime code.
15083 // Created exception is now available to this handler, and is setup
15084 // just prior to jumping to this handler. No code emitted.
15085 instruct CreateException(rarg1RegP ex_oop) %{
15086   match(Set ex_oop (CreateEx));
15087   ins_cost(0);
15088 
15089   format %{ &quot; -- \t// exception oop; no code emitted&quot; %}
15090   size(0);
15091   ins_encode( /*empty*/ );
15092   ins_pipe(pipe_class_default);
15093 %}
15094 
15095 // Rethrow exception: The exception oop will come in the first
15096 // argument position. Then JUMP (not call) to the rethrow stub code.
15097 instruct RethrowException() %{
15098   match(Rethrow);
15099   ins_cost(CALL_COST);
15100 
15101   format %{ &quot;Jmp     rethrow_stub&quot; %}
15102   ins_encode %{
15103     // TODO: PPC port $archOpcode(ppc64Opcode_compound);
15104     cbuf.set_insts_mark();
15105     __ b64_patchable((address)OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type);
15106   %}
15107   ins_pipe(pipe_class_call);
15108 %}
15109 
15110 // Die now.
15111 instruct ShouldNotReachHere() %{
15112   match(Halt);
15113   ins_cost(CALL_COST);
15114 
15115   format %{ &quot;ShouldNotReachHere&quot; %}
15116   size(4);
15117   ins_encode %{
15118     // TODO: PPC port $archOpcode(ppc64Opcode_tdi);
15119     __ trap_should_not_reach_here();
15120   %}
15121   ins_pipe(pipe_class_default);
15122 %}
15123 
15124 // This name is KNOWN by the ADLC and cannot be changed.  The ADLC
15125 // forces a &#39;TypeRawPtr::BOTTOM&#39; output type for this guy.
15126 // Get a DEF on threadRegP, no costs, no encoding, use
15127 // &#39;ins_should_rematerialize(true)&#39; to avoid spilling.
15128 instruct tlsLoadP(threadRegP dst) %{
15129   match(Set dst (ThreadLocal));
15130   ins_cost(0);
15131 
15132   ins_should_rematerialize(true);
15133 
15134   format %{ &quot; -- \t// $dst=Thread::current(), empty&quot; %}
15135   size(0);
15136   ins_encode( /*empty*/ );
15137   ins_pipe(pipe_class_empty);
15138 %}
15139 
15140 //---Some PPC specific nodes---------------------------------------------------
15141 
15142 // Stop a group.
15143 instruct endGroup() %{
15144   ins_cost(0);
15145 
15146   ins_is_nop(true);
15147 
15148   format %{ &quot;End Bundle (ori r1, r1, 0)&quot; %}
15149   size(4);
15150   ins_encode %{
15151     // TODO: PPC port $archOpcode(ppc64Opcode_endgroup);
15152     __ endgroup();
15153   %}
15154   ins_pipe(pipe_class_default);
15155 %}
15156 
15157 // Nop instructions
15158 
15159 instruct fxNop() %{
15160   ins_cost(0);
15161 
15162   ins_is_nop(true);
15163 
15164   format %{ &quot;fxNop&quot; %}
15165   size(4);
15166   ins_encode %{
15167     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15168     __ nop();
15169   %}
15170   ins_pipe(pipe_class_default);
15171 %}
15172 
15173 instruct fpNop0() %{
15174   ins_cost(0);
15175 
15176   ins_is_nop(true);
15177 
15178   format %{ &quot;fpNop0&quot; %}
15179   size(4);
15180   ins_encode %{
15181     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15182     __ fpnop0();
15183   %}
15184   ins_pipe(pipe_class_default);
15185 %}
15186 
15187 instruct fpNop1() %{
15188   ins_cost(0);
15189 
15190   ins_is_nop(true);
15191 
15192   format %{ &quot;fpNop1&quot; %}
15193   size(4);
15194   ins_encode %{
15195     // TODO: PPC port $archOpcode(ppc64Opcode_fmr);
15196     __ fpnop1();
15197   %}
15198   ins_pipe(pipe_class_default);
15199 %}
15200 
15201 instruct brNop0() %{
15202   ins_cost(0);
15203   size(4);
15204   format %{ &quot;brNop0&quot; %}
15205   ins_encode %{
15206     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15207     __ brnop0();
15208   %}
15209   ins_is_nop(true);
15210   ins_pipe(pipe_class_default);
15211 %}
15212 
15213 instruct brNop1() %{
15214   ins_cost(0);
15215 
15216   ins_is_nop(true);
15217 
15218   format %{ &quot;brNop1&quot; %}
15219   size(4);
15220   ins_encode %{
15221     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15222     __ brnop1();
15223   %}
15224   ins_pipe(pipe_class_default);
15225 %}
15226 
15227 instruct brNop2() %{
15228   ins_cost(0);
15229 
15230   ins_is_nop(true);
15231 
15232   format %{ &quot;brNop2&quot; %}
15233   size(4);
15234   ins_encode %{
15235     // TODO: PPC port $archOpcode(ppc64Opcode_mcrf);
15236     __ brnop2();
15237   %}
15238   ins_pipe(pipe_class_default);
15239 %}
15240 
15241 instruct cacheWB(indirect addr)
15242 %{
15243   match(CacheWB addr);
15244 
15245   ins_cost(100);
15246   format %{ &quot;cache writeback, address = $addr&quot; %}
15247   ins_encode %{
15248     assert($addr-&gt;index_position() &lt; 0, &quot;should be&quot;);
15249     assert($addr$$disp == 0, &quot;should be&quot;);
15250     __ cache_wb(Address($addr$$base$$Register));
15251   %}
15252   ins_pipe(pipe_class_default);
15253 %}
15254 
15255 instruct cacheWBPreSync()
15256 %{
15257   match(CacheWBPreSync);
15258 
15259   ins_cost(0);
15260   format %{ &quot;cache writeback presync&quot; %}
15261   ins_encode %{
15262     __ cache_wbsync(true);
15263   %}
15264   ins_pipe(pipe_class_default);
15265 %}
15266 
15267 instruct cacheWBPostSync()
15268 %{
15269   match(CacheWBPostSync);
15270 
15271   ins_cost(100);
15272   format %{ &quot;cache writeback postsync&quot; %}
15273   ins_encode %{
15274     __ cache_wbsync(false);
15275   %}
15276   ins_pipe(pipe_class_default);
15277 %}
15278 
15279 //----------PEEPHOLE RULES-----------------------------------------------------
15280 // These must follow all instruction definitions as they use the names
15281 // defined in the instructions definitions.
15282 //
15283 // peepmatch ( root_instr_name [preceeding_instruction]* );
15284 //
15285 // peepconstraint %{
15286 // (instruction_number.operand_name relational_op instruction_number.operand_name
15287 //  [, ...] );
15288 // // instruction numbers are zero-based using left to right order in peepmatch
15289 //
15290 // peepreplace ( instr_name ( [instruction_number.operand_name]* ) );
15291 // // provide an instruction_number.operand_name for each operand that appears
15292 // // in the replacement instruction&#39;s match rule
15293 //
15294 // ---------VM FLAGS---------------------------------------------------------
15295 //
15296 // All peephole optimizations can be turned off using -XX:-OptoPeephole
15297 //
15298 // Each peephole rule is given an identifying number starting with zero and
15299 // increasing by one in the order seen by the parser. An individual peephole
15300 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
15301 // on the command-line.
15302 //
15303 // ---------CURRENT LIMITATIONS----------------------------------------------
15304 //
15305 // Only match adjacent instructions in same basic block
15306 // Only equality constraints
15307 // Only constraints between operands, not (0.dest_reg == EAX_enc)
15308 // Only one replacement instruction
15309 //
15310 // ---------EXAMPLE----------------------------------------------------------
15311 //
15312 // // pertinent parts of existing instructions in architecture description
15313 // instruct movI(eRegI dst, eRegI src) %{
15314 //   match(Set dst (CopyI src));
15315 // %}
15316 //
15317 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
15318 //   match(Set dst (AddI dst src));
15319 //   effect(KILL cr);
15320 // %}
15321 //
15322 // // Change (inc mov) to lea
15323 // peephole %{
15324 //   // increment preceeded by register-register move
15325 //   peepmatch ( incI_eReg movI );
15326 //   // require that the destination register of the increment
15327 //   // match the destination register of the move
15328 //   peepconstraint ( 0.dst == 1.dst );
15329 //   // construct a replacement instruction that sets
15330 //   // the destination to ( move&#39;s source register + one )
15331 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15332 // %}
15333 //
15334 // Implementation no longer uses movX instructions since
15335 // machine-independent system no longer uses CopyX nodes.
15336 //
15337 // peephole %{
15338 //   peepmatch ( incI_eReg movI );
15339 //   peepconstraint ( 0.dst == 1.dst );
15340 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15341 // %}
15342 //
15343 // peephole %{
15344 //   peepmatch ( decI_eReg movI );
15345 //   peepconstraint ( 0.dst == 1.dst );
15346 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15347 // %}
15348 //
15349 // peephole %{
15350 //   peepmatch ( addI_eReg_imm movI );
15351 //   peepconstraint ( 0.dst == 1.dst );
15352 //   peepreplace ( leaI_eReg_immI( 0.dst 1.src 0.src ) );
15353 // %}
15354 //
15355 // peephole %{
15356 //   peepmatch ( addP_eReg_imm movP );
15357 //   peepconstraint ( 0.dst == 1.dst );
15358 //   peepreplace ( leaP_eReg_immI( 0.dst 1.src 0.src ) );
15359 // %}
15360 
15361 // // Change load of spilled value to only a spill
15362 // instruct storeI(memory mem, eRegI src) %{
15363 //   match(Set mem (StoreI mem src));
15364 // %}
15365 //
15366 // instruct loadI(eRegI dst, memory mem) %{
15367 //   match(Set dst (LoadI mem));
15368 // %}
15369 //
15370 peephole %{
15371   peepmatch ( loadI storeI );
15372   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15373   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
15374 %}
15375 
15376 peephole %{
15377   peepmatch ( loadL storeL );
15378   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
15379   peepreplace ( storeL( 1.mem 1.mem 1.src ) );
15380 %}
15381 
15382 peephole %{
15383   peepmatch ( loadP storeP );
15384   peepconstraint ( 1.src == 0.dst, 1.dst == 0.mem );
15385   peepreplace ( storeP( 1.dst 1.dst 1.src ) );
15386 %}
15387 
15388 //----------SMARTSPILL RULES---------------------------------------------------
15389 // These must follow all instruction definitions as they use the names
15390 // defined in the instructions definitions.
<a name="76" id="anc76"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="76" type="hidden" />
</body>
</html>
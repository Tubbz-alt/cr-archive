<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../../../style.css" />
  </head>
<body>
<center><a href="../../frame_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../globalDefinitions_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/gc/shenandoah/shenandoahBarrierSetAssembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #ifdef COMPILER1
  40 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  41 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  42 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  43 #endif
  44 
  45 #define __ masm-&gt;
  46 
  47 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;
  48 
  49 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
  50                                                        Register src, Register dst, Register count) {
  51 
  52   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  53 
  54   if (is_reference_type(type)) {
  55 
<span class="line-modified">  56     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahLoadRefBarrier) {</span>
  57 #ifdef _LP64
  58       Register thread = r15_thread;
  59 #else
  60       Register thread = rax;
  61       if (thread == src || thread == dst || thread == count) {
  62         thread = rbx;
  63       }
  64       if (thread == src || thread == dst || thread == count) {
  65         thread = rcx;
  66       }
  67       if (thread == src || thread == dst || thread == count) {
  68         thread = rdx;
  69       }
  70       __ push(thread);
  71       __ get_thread(thread);
  72 #endif
  73       assert_different_registers(src, dst, count, thread);
  74 
  75       Label done;
  76       // Short-circuit if count == 0.
  77       __ testptr(count, count);
  78       __ jcc(Assembler::zero, done);
  79 
<span class="line-modified">  80       // Avoid runtime call when not marking.</span>
  81       Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified">  82       int flags = ShenandoahHeap::HAS_FORWARDED;</span>
<span class="line-modified">  83       if (!dest_uninitialized) {</span>
<span class="line-modified">  84         flags |= ShenandoahHeap::MARKING;</span>


  85       }
  86       __ testb(gc_state, flags);
  87       __ jcc(Assembler::zero, done);
  88 
  89       __ pusha();                      // push registers

  90 #ifdef _LP64
  91       assert(src == rdi, &quot;expected&quot;);
  92       assert(dst == rsi, &quot;expected&quot;);
  93       assert(count == rdx, &quot;expected&quot;);
  94       if (UseCompressedOops) {
<span class="line-modified">  95         if (dest_uninitialized) {</span>
<span class="line-modified">  96           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_narrow_oop_entry), src, dst, count);</span>
<span class="line-removed">  97         } else {</span>
<span class="line-removed">  98           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_narrow_oop_entry), src, dst, count);</span>
<span class="line-removed">  99         }</span>
 100       } else
 101 #endif
 102       {
<span class="line-modified"> 103         if (dest_uninitialized) {</span>
<span class="line-modified"> 104           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_duinit_oop_entry), src, dst, count);</span>
<span class="line-removed"> 105         } else {</span>
<span class="line-removed"> 106           __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::write_ref_array_pre_oop_entry), src, dst, count);</span>
<span class="line-removed"> 107         }</span>
 108       }

 109       __ popa();
 110       __ bind(done);
 111       NOT_LP64(__ pop(thread);)
 112     }
 113   }
 114 
 115 }
 116 
 117 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 118                                                                  Register obj,
 119                                                                  Register pre_val,
 120                                                                  Register thread,
 121                                                                  Register tmp,
 122                                                                  bool tosca_live,
 123                                                                  bool expand_call) {
 124 
 125   if (ShenandoahSATBBarrier) {
 126     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 127   }
 128 }
</pre>
<hr />
<pre>
 140 
 141 #ifdef _LP64
 142   assert(thread == r15_thread, &quot;must be&quot;);
 143 #endif // _LP64
 144 
 145   Label done;
 146   Label runtime;
 147 
 148   assert(pre_val != noreg, &quot;check this code&quot;);
 149 
 150   if (obj != noreg) {
 151     assert_different_registers(obj, pre_val, tmp);
 152     assert(pre_val != rax, &quot;check this code&quot;);
 153   }
 154 
 155   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
 156   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 157   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 158 
 159   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified"> 160   __ testb(gc_state, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);</span>
 161   __ jcc(Assembler::zero, done);
 162 
 163   // Do we need to load the previous value?
 164   if (obj != noreg) {
 165     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
 166   }
 167 
 168   // Is the previous value null?
 169   __ cmpptr(pre_val, (int32_t) NULL_WORD);
 170   __ jcc(Assembler::equal, done);
 171 
 172   // Can we store original value in the thread&#39;s buffer?
 173   // Is index == 0?
 174   // (The index field is typed as size_t.)
 175 
 176   __ movptr(tmp, index);                   // tmp := *index_adr
 177   __ cmpptr(tmp, 0);                       // tmp == 0?
 178   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
 179 
 180   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
</pre>
<hr />
<pre>
 875   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
 876   // arg0 : previous value of memory
 877 
 878   __ push(rax);
 879   __ push(rdx);
 880 
 881   const Register pre_val = rax;
 882   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
 883   const Register tmp = rdx;
 884 
 885   NOT_LP64(__ get_thread(thread);)
 886 
 887   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 888   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 889 
 890   Label done;
 891   Label runtime;
 892 
 893   // Is SATB still active?
 894   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified"> 895   __ testb(gc_state, ShenandoahHeap::MARKING | ShenandoahHeap::TRAVERSAL);</span>
 896   __ jcc(Assembler::zero, done);
 897 
 898   // Can we store original value in the thread&#39;s buffer?
 899 
 900   __ movptr(tmp, queue_index);
 901   __ testptr(tmp, tmp);
 902   __ jcc(Assembler::zero, runtime);
 903   __ subptr(tmp, wordSize);
 904   __ movptr(queue_index, tmp);
 905   __ addptr(tmp, buffer);
 906 
 907   // prev_val (rax)
 908   __ load_parameter(0, pre_val);
 909   __ movptr(Address(tmp, 0), pre_val);
 910   __ jmp(done);
 911 
 912   __ bind(runtime);
 913 
 914   __ save_live_registers_no_oop_map(true);
 915 
</pre>
</td>
<td>
<hr />
<pre>
  36 #include &quot;runtime/sharedRuntime.hpp&quot;
  37 #include &quot;runtime/thread.hpp&quot;
  38 #include &quot;utilities/macros.hpp&quot;
  39 #ifdef COMPILER1
  40 #include &quot;c1/c1_LIRAssembler.hpp&quot;
  41 #include &quot;c1/c1_MacroAssembler.hpp&quot;
  42 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
  43 #endif
  44 
  45 #define __ masm-&gt;
  46 
  47 address ShenandoahBarrierSetAssembler::_shenandoah_lrb = NULL;
  48 
  49 void ShenandoahBarrierSetAssembler::arraycopy_prologue(MacroAssembler* masm, DecoratorSet decorators, BasicType type,
  50                                                        Register src, Register dst, Register count) {
  51 
  52   bool dest_uninitialized = (decorators &amp; IS_DEST_UNINITIALIZED) != 0;
  53 
  54   if (is_reference_type(type)) {
  55 
<span class="line-modified">  56     if ((ShenandoahSATBBarrier &amp;&amp; !dest_uninitialized) || ShenandoahStoreValEnqueueBarrier || ShenandoahLoadRefBarrier) {</span>
  57 #ifdef _LP64
  58       Register thread = r15_thread;
  59 #else
  60       Register thread = rax;
  61       if (thread == src || thread == dst || thread == count) {
  62         thread = rbx;
  63       }
  64       if (thread == src || thread == dst || thread == count) {
  65         thread = rcx;
  66       }
  67       if (thread == src || thread == dst || thread == count) {
  68         thread = rdx;
  69       }
  70       __ push(thread);
  71       __ get_thread(thread);
  72 #endif
  73       assert_different_registers(src, dst, count, thread);
  74 
  75       Label done;
  76       // Short-circuit if count == 0.
  77       __ testptr(count, count);
  78       __ jcc(Assembler::zero, done);
  79 
<span class="line-modified">  80       // Avoid runtime call when not active.</span>
  81       Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified">  82       int flags;</span>
<span class="line-modified">  83       if (ShenandoahSATBBarrier &amp;&amp; dest_uninitialized) {</span>
<span class="line-modified">  84         flags = ShenandoahHeap::HAS_FORWARDED;</span>
<span class="line-added">  85       } else {</span>
<span class="line-added">  86         flags = ShenandoahHeap::HAS_FORWARDED | ShenandoahHeap::MARKING;</span>
  87       }
  88       __ testb(gc_state, flags);
  89       __ jcc(Assembler::zero, done);
  90 
  91       __ pusha();                      // push registers
<span class="line-added">  92 </span>
  93 #ifdef _LP64
  94       assert(src == rdi, &quot;expected&quot;);
  95       assert(dst == rsi, &quot;expected&quot;);
  96       assert(count == rdx, &quot;expected&quot;);
  97       if (UseCompressedOops) {
<span class="line-modified">  98         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_narrow_oop_entry),</span>
<span class="line-modified">  99                         src, dst, count);</span>



 100       } else
 101 #endif
 102       {
<span class="line-modified"> 103         __ call_VM_leaf(CAST_FROM_FN_PTR(address, ShenandoahRuntime::arraycopy_barrier_oop_entry),</span>
<span class="line-modified"> 104                         src, dst, count);</span>



 105       }
<span class="line-added"> 106 </span>
 107       __ popa();
 108       __ bind(done);
 109       NOT_LP64(__ pop(thread);)
 110     }
 111   }
 112 
 113 }
 114 
 115 void ShenandoahBarrierSetAssembler::shenandoah_write_barrier_pre(MacroAssembler* masm,
 116                                                                  Register obj,
 117                                                                  Register pre_val,
 118                                                                  Register thread,
 119                                                                  Register tmp,
 120                                                                  bool tosca_live,
 121                                                                  bool expand_call) {
 122 
 123   if (ShenandoahSATBBarrier) {
 124     satb_write_barrier_pre(masm, obj, pre_val, thread, tmp, tosca_live, expand_call);
 125   }
 126 }
</pre>
<hr />
<pre>
 138 
 139 #ifdef _LP64
 140   assert(thread == r15_thread, &quot;must be&quot;);
 141 #endif // _LP64
 142 
 143   Label done;
 144   Label runtime;
 145 
 146   assert(pre_val != noreg, &quot;check this code&quot;);
 147 
 148   if (obj != noreg) {
 149     assert_different_registers(obj, pre_val, tmp);
 150     assert(pre_val != rax, &quot;check this code&quot;);
 151   }
 152 
 153   Address in_progress(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_active_offset()));
 154   Address index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 155   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 156 
 157   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified"> 158   __ testb(gc_state, ShenandoahHeap::MARKING);</span>
 159   __ jcc(Assembler::zero, done);
 160 
 161   // Do we need to load the previous value?
 162   if (obj != noreg) {
 163     __ load_heap_oop(pre_val, Address(obj, 0), noreg, noreg, AS_RAW);
 164   }
 165 
 166   // Is the previous value null?
 167   __ cmpptr(pre_val, (int32_t) NULL_WORD);
 168   __ jcc(Assembler::equal, done);
 169 
 170   // Can we store original value in the thread&#39;s buffer?
 171   // Is index == 0?
 172   // (The index field is typed as size_t.)
 173 
 174   __ movptr(tmp, index);                   // tmp := *index_adr
 175   __ cmpptr(tmp, 0);                       // tmp == 0?
 176   __ jcc(Assembler::equal, runtime);       // If yes, goto runtime
 177 
 178   __ subptr(tmp, wordSize);                // tmp := tmp - wordSize
</pre>
<hr />
<pre>
 873   __ prologue(&quot;shenandoah_pre_barrier&quot;, false);
 874   // arg0 : previous value of memory
 875 
 876   __ push(rax);
 877   __ push(rdx);
 878 
 879   const Register pre_val = rax;
 880   const Register thread = NOT_LP64(rax) LP64_ONLY(r15_thread);
 881   const Register tmp = rdx;
 882 
 883   NOT_LP64(__ get_thread(thread);)
 884 
 885   Address queue_index(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_index_offset()));
 886   Address buffer(thread, in_bytes(ShenandoahThreadLocalData::satb_mark_queue_buffer_offset()));
 887 
 888   Label done;
 889   Label runtime;
 890 
 891   // Is SATB still active?
 892   Address gc_state(thread, in_bytes(ShenandoahThreadLocalData::gc_state_offset()));
<span class="line-modified"> 893   __ testb(gc_state, ShenandoahHeap::MARKING);</span>
 894   __ jcc(Assembler::zero, done);
 895 
 896   // Can we store original value in the thread&#39;s buffer?
 897 
 898   __ movptr(tmp, queue_index);
 899   __ testptr(tmp, tmp);
 900   __ jcc(Assembler::zero, runtime);
 901   __ subptr(tmp, wordSize);
 902   __ movptr(queue_index, tmp);
 903   __ addptr(tmp, buffer);
 904 
 905   // prev_val (rax)
 906   __ load_parameter(0, pre_val);
 907   __ movptr(Address(tmp, 0), pre_val);
 908   __ jmp(done);
 909 
 910   __ bind(runtime);
 911 
 912   __ save_live_registers_no_oop_map(true);
 913 
</pre>
</td>
</tr>
</table>
<center><a href="../../frame_x86.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../index.html" target="_top">index</a> <a href="../../globalDefinitions_x86.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
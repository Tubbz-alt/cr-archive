diff a/src/hotspot/cpu/x86/x86_64.ad b/src/hotspot/cpu/x86/x86_64.ad
--- a/src/hotspot/cpu/x86/x86_64.ad
+++ b/src/hotspot/cpu/x86/x86_64.ad
@@ -1,7 +1,7 @@
 //
-// Copyright (c) 2003, 2019, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.
 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 //
 // This code is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License version 2 only, as
 // published by the Free Software Foundation.
@@ -457,17 +457,10 @@
   int offset = 13; // movq r10,#addr; callq (r10)
   offset += clear_avx_size();
   return offset;
 }
 
-// Indicate if the safepoint node needs the polling page as an input,
-// it does if the polling page is more than disp32 away.
-bool SafePointNode::needs_polling_address_input()
-{
-  return SafepointMechanism::uses_thread_local_poll() || Assembler::is_polling_page_far();
-}
-
 //
 // Compute padding required for nodes which need alignment
 //
 
 // The address of the call instruction needs to be 4-byte aligned to
@@ -783,11 +776,11 @@
 }
 
 //=============================================================================
 const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 
-int Compile::ConstantTable::calculate_table_base_offset() const {
+int ConstantTable::calculate_table_base_offset() const {
   return 0;  // absolute addressing, no offset
 }
 
 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {
@@ -812,17 +805,17 @@
 //=============================================================================
 #ifndef PRODUCT
 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
   Compile* C = ra_->C;
 
-  int framesize = C->frame_size_in_bytes();
-  int bangsize = C->bang_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
+  int bangsize = C->output()->bang_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
   // Remove wordSize for return addr which is already pushed.
   framesize -= wordSize;
 
-  if (C->need_stack_bang(bangsize)) {
+  if (C->output()->need_stack_bang(bangsize)) {
     framesize -= wordSize;
     st->print("# stack bang (%d bytes)", bangsize);
     st->print("\n\t");
     st->print("pushq   rbp\t# Save rbp");
     if (PreserveFramePointer) {
@@ -872,12 +865,12 @@
 
 void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
   Compile* C = ra_->C;
   MacroAssembler _masm(&cbuf);
 
-  int framesize = C->frame_size_in_bytes();
-  int bangsize = C->bang_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
+  int bangsize = C->output()->bang_size_in_bytes();
 
   if (C->clinit_barrier_on_entry()) {
     assert(VM_Version::supports_fast_class_init_checks(), "sanity");
     assert(!C->method()->holder()->is_not_initialized(), "initialization should have been started");
 
@@ -890,18 +883,18 @@
     __ jump(RuntimeAddress(SharedRuntime::get_handle_wrong_method_stub())); // slow path
 
     __ bind(L_skip_barrier);
   }
 
-  __ verified_entry(framesize, C->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != NULL);
+  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, false, C->stub_function() != NULL);
 
-  C->set_frame_complete(cbuf.insts_size());
+  C->output()->set_frame_complete(cbuf.insts_size());
 
   if (C->has_mach_constant_base_node()) {
     // NOTE: We set the table base offset here because users might be
     // emitted before MachConstantBaseNode.
-    Compile::ConstantTable& constant_table = C->constant_table();
+    ConstantTable& constant_table = C->output()->constant_table();
     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
   }
 }
 
 uint MachPrologNode::size(PhaseRegAlloc* ra_) const
@@ -923,11 +916,11 @@
   if (generate_vzeroupper(C)) {
     st->print("vzeroupper");
     st->cr(); st->print("\t");
   }
 
-  int framesize = C->frame_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
   // Remove word for return adr already pushed
   // and RBP
   framesize -= 2*wordSize;
 
@@ -937,22 +930,13 @@
   }
 
   st->print_cr("popq    rbp");
   if (do_polling() && C->is_method_compilation()) {
     st->print("\t");
-    if (SafepointMechanism::uses_thread_local_poll()) {
-      st->print_cr("movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t"
-                   "testl   rax, [rscratch1]\t"
-                   "# Safepoint: poll for GC");
-    } else if (Assembler::is_polling_page_far()) {
-      st->print_cr("movq    rscratch1, #polling_page_address\n\t"
-                   "testl   rax, [rscratch1]\t"
-                   "# Safepoint: poll for GC");
-    } else {
-      st->print_cr("testl   rax, [rip + #offset_to_poll_page]\t"
-                   "# Safepoint: poll for GC");
-    }
+    st->print_cr("movq    rscratch1, poll_offset[r15_thread] #polling_page_address\n\t"
+                 "testl   rax, [rscratch1]\t"
+                 "# Safepoint: poll for GC");
   }
 }
 #endif
 
 void MachEpilogNode::emit(CodeBuffer& cbuf, PhaseRegAlloc* ra_) const
@@ -964,11 +948,11 @@
     // Clear upper bits of YMM registers when current compiled code uses
     // wide vectors to avoid AVX <-> SSE transition penalty during call.
     __ vzeroupper();
   }
 
-  int framesize = C->frame_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
   // Remove word for return adr already pushed
   // and RBP
   framesize -= 2*wordSize;
 
@@ -994,24 +978,13 @@
     __ reserved_stack_check();
   }
 
   if (do_polling() && C->is_method_compilation()) {
     MacroAssembler _masm(&cbuf);
-    if (SafepointMechanism::uses_thread_local_poll()) {
-      __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
-      __ relocate(relocInfo::poll_return_type);
-      __ testl(rax, Address(rscratch1, 0));
-    } else {
-      AddressLiteral polling_page(os::get_polling_page(), relocInfo::poll_return_type);
-      if (Assembler::is_polling_page_far()) {
-        __ lea(rscratch1, polling_page);
-        __ relocate(relocInfo::poll_return_type);
-        __ testl(rax, Address(rscratch1, 0));
-      } else {
-        __ testl(rax, polling_page);
-      }
-    }
+    __ movq(rscratch1, Address(r15_thread, Thread::polling_page_offset()));
+    __ relocate(relocInfo::poll_return_type);
+    __ testl(rax, Address(rscratch1, 0));
   }
 }
 
 uint MachEpilogNode::size(PhaseRegAlloc* ra_) const
 {
@@ -1027,15 +1000,10 @@
 const Pipeline* MachEpilogNode::pipeline() const
 {
   return MachNode::pipeline_class();
 }
 
-int MachEpilogNode::safepoint_offset() const
-{
-  return 0;
-}
-
 //=============================================================================
 
 enum RC {
   rc_bad,
   rc_int,
@@ -3118,21 +3086,21 @@
   interface(CONST_INTER);
 %}
 
 operand immL_Pow2()
 %{
-  predicate(is_power_of_2(n->get_long()));
+  predicate(is_power_of_2((julong)n->get_long()));
   match(ConL);
 
   op_cost(15);
   format %{ %}
   interface(CONST_INTER);
 %}
 
 operand immL_NotPow2()
 %{
-  predicate(is_power_of_2(~n->get_long()));
+  predicate(is_power_of_2((julong)~n->get_long()));
   match(ConL);
 
   op_cost(15);
   format %{ %}
   interface(CONST_INTER);
@@ -10027,11 +9995,11 @@
   effect(KILL cr);
 
   ins_cost(125);
   format %{ "btsq    $dst, log2($con)\t# long" %}
   ins_encode %{
-    __ btsq($dst$$Address, log2_long($con$$constant));
+    __ btsq($dst$$Address, log2_long((julong)$con$$constant));
   %}
   ins_pipe(ialu_mem_imm);
 %}
 
 // Xor Instructions
@@ -12534,45 +12502,12 @@
 %}
 
 
 // ============================================================================
 // Safepoint Instructions
-instruct safePoint_poll(rFlagsReg cr)
-%{
-  predicate(!Assembler::is_polling_page_far() && SafepointMechanism::uses_global_page_poll());
-  match(SafePoint);
-  effect(KILL cr);
-
-  format %{ "testl   rax, [rip + #offset_to_poll_page]\t"
-            "# Safepoint: poll for GC" %}
-  ins_cost(125);
-  ins_encode %{
-    AddressLiteral addr(os::get_polling_page(), relocInfo::poll_type);
-    __ testl(rax, addr);
-  %}
-  ins_pipe(ialu_reg_mem);
-%}
-
-instruct safePoint_poll_far(rFlagsReg cr, rRegP poll)
-%{
-  predicate(Assembler::is_polling_page_far() && SafepointMechanism::uses_global_page_poll());
-  match(SafePoint poll);
-  effect(KILL cr, USE poll);
-
-  format %{ "testl   rax, [$poll]\t"
-            "# Safepoint: poll for GC" %}
-  ins_cost(125);
-  ins_encode %{
-    __ relocate(relocInfo::poll_type);
-    __ testl(rax, Address($poll$$Register, 0));
-  %}
-  ins_pipe(ialu_reg_mem);
-%}
-
 instruct safePoint_poll_tls(rFlagsReg cr, rRegP poll)
 %{
-  predicate(SafepointMechanism::uses_thread_local_poll());
   match(SafePoint poll);
   effect(KILL cr, USE poll);
 
   format %{ "testl   rax, [$poll]\t"
             "# Safepoint: poll for GC" %}

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/assembler_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../sparc/vm_version_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/assembler_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 246,38 ***</span>
  void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
    assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert(isByte(imm8), &quot;not a byte&quot;);
    assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
<span class="line-modified">!   emit_int8(op1);</span>
<span class="line-removed">-   emit_int8(op2 | encode(dst));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  
  void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
    assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
    if (is8bit(imm32)) {
<span class="line-modified">!     emit_int8(op1 | 0x02); // set sign bit</span>
<span class="line-modified">!     emit_int8(op2 | encode(dst));</span>
<span class="line-modified">!     emit_int8(imm32 &amp; 0xFF);</span>
    } else {
<span class="line-modified">!     emit_int8(op1);</span>
<span class="line-removed">-     emit_int8(op2 | encode(dst));</span>
      emit_int32(imm32);
    }
  }
  
  // Force generation of a 4 byte immediate value even if it fits into 8bit
  void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
    assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
<span class="line-modified">!   emit_int8(op1);</span>
<span class="line-removed">-   emit_int8(op2 | encode(dst));</span>
    emit_int32(imm32);
  }
  
  // immediate-to-memory forms
  void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
<span class="line-new-header">--- 246,34 ---</span>
  void Assembler::emit_arith_b(int op1, int op2, Register dst, int imm8) {
    assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;);
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert(isByte(imm8), &quot;not a byte&quot;);
    assert((op1 &amp; 0x01) == 0, &quot;should be 8bit operation&quot;);
<span class="line-modified">!   emit_int24(op1, (op2 | encode(dst)), imm8);</span>
  }
  
  
  void Assembler::emit_arith(int op1, int op2, Register dst, int32_t imm32) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
    assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
    if (is8bit(imm32)) {
<span class="line-modified">!     emit_int24(op1 | 0x02,        // set sign bit</span>
<span class="line-modified">!                op2 | encode(dst),</span>
<span class="line-modified">!                imm32 &amp; 0xFF);</span>
    } else {
<span class="line-modified">!     emit_int16(op1, (op2 | encode(dst)));</span>
      emit_int32(imm32);
    }
  }
  
  // Force generation of a 4 byte immediate value even if it fits into 8bit
  void Assembler::emit_arith_imm32(int op1, int op2, Register dst, int32_t imm32) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
    assert((op1 &amp; 0x01) == 1, &quot;should be 32bit operation&quot;);
    assert((op1 &amp; 0x02) == 0, &quot;sign-extension bit should not be set&quot;);
<span class="line-modified">!   emit_int16(op1, (op2 | encode(dst)));</span>
    emit_int32(imm32);
  }
  
  // immediate-to-memory forms
  void Assembler::emit_arith_operand(int op1, Register rm, Address adr, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 295,12 ***</span>
  }
  
  
  void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
<span class="line-modified">!   emit_int8(op1);</span>
<span class="line-removed">-   emit_int8(op2 | encode(dst) &lt;&lt; 3 | encode(src));</span>
  }
  
  
  bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
                                             int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
<span class="line-new-header">--- 291,11 ---</span>
  }
  
  
  void Assembler::emit_arith(int op1, int op2, Register dst, Register src) {
    assert(isByte(op1) &amp;&amp; isByte(op2), &quot;wrong opcode&quot;);
<span class="line-modified">!   emit_int16(op1, (op2 | encode(dst) &lt;&lt; 3 | encode(src)));</span>
  }
  
  
  bool Assembler::query_compressed_disp_byte(int disp, bool is_evex_inst, int vector_len,
                                             int cur_tuple_type, int in_size_in_bits, int cur_encoding) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 473,103 ***</span>
      }
    }
    return is8bit(disp);
  }
  
  
<span class="line-modified">! void Assembler::emit_operand(Register reg, Register base, Register index,</span>
<span class="line-modified">!                              Address::ScaleFactor scale, int disp,</span>
<span class="line-modified">!                              RelocationHolder const&amp; rspec,</span>
<span class="line-modified">!                              int rip_relative_correction) {</span>
<span class="line-modified">!   relocInfo::relocType rtype = rspec.type();</span>
  
<span class="line-modified">!   // Encode the registers as needed in the fields they are used in</span>
  
<span class="line-modified">!   int regenc = encode(reg) &lt;&lt; 3;</span>
<span class="line-modified">!   int indexenc = index-&gt;is_valid() ? encode(index) &lt;&lt; 3 : 0;</span>
<span class="line-modified">!   int baseenc = base-&gt;is_valid() ? encode(base) : 0;</span>
  
<span class="line-modified">!   if (base-&gt;is_valid()) {</span>
<span class="line-modified">!     if (index-&gt;is_valid()) {</span>
        assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
        // [base + index*scale + disp]
<span class="line-modified">!       if (disp == 0 &amp;&amp; rtype == relocInfo::none  &amp;&amp;</span>
<span class="line-modified">!           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {</span>
          // [base + index*scale]
          // [00 reg 100][ss index base]
<span class="line-modified">!         assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!         emit_int8(0x04 | regenc);</span>
<span class="line-modified">!         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="line-removed">-       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
          // [base + index*scale + imm8]
          // [01 reg 100][ss index base] imm8
<span class="line-modified">!         assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!         emit_int8(0x44 | regenc);</span>
<span class="line-modified">!         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
<span class="line-removed">-         emit_int8(disp &amp; 0xFF);</span>
        } else {
          // [base + index*scale + disp32]
          // [10 reg 100][ss index base] disp32
<span class="line-modified">!         assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!         emit_int8(0x84 | regenc);</span>
<span class="line-removed">-         emit_int8(scale &lt;&lt; 6 | indexenc | baseenc);</span>
          emit_data(disp, rspec, disp32_operand);
        }
<span class="line-modified">!     } else if (base == rsp LP64_ONLY(|| base == r12)) {</span>
        // [rsp + disp]
<span class="line-modified">!       if (disp == 0 &amp;&amp; rtype == relocInfo::none) {</span>
          // [rsp]
          // [00 reg 100][00 100 100]
<span class="line-modified">!         emit_int8(0x04 | regenc);</span>
<span class="line-modified">!         emit_int8(0x24);</span>
<span class="line-modified">!       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
          // [rsp + imm8]
          // [01 reg 100][00 100 100] disp8
<span class="line-modified">!         emit_int8(0x44 | regenc);</span>
<span class="line-modified">!         emit_int8(0x24);</span>
<span class="line-modified">!         emit_int8(disp &amp; 0xFF);</span>
        } else {
          // [rsp + imm32]
          // [10 reg 100][00 100 100] disp32
<span class="line-modified">!         emit_int8(0x84 | regenc);</span>
<span class="line-modified">!         emit_int8(0x24);</span>
          emit_data(disp, rspec, disp32_operand);
        }
      } else {
        // [base + disp]
<span class="line-modified">!       assert(base != rsp LP64_ONLY(&amp;&amp; base != r12), &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!       if (disp == 0 &amp;&amp; rtype == relocInfo::none &amp;&amp;</span>
<span class="line-modified">!           base != rbp LP64_ONLY(&amp;&amp; base != r13)) {</span>
          // [base]
          // [00 reg base]
<span class="line-modified">!         emit_int8(0x00 | regenc | baseenc);</span>
<span class="line-modified">!       } else if (emit_compressed_disp_byte(disp) &amp;&amp; rtype == relocInfo::none) {</span>
          // [base + disp8]
          // [01 reg base] disp8
<span class="line-modified">!         emit_int8(0x40 | regenc | baseenc);</span>
<span class="line-modified">!         emit_int8(disp &amp; 0xFF);</span>
        } else {
          // [base + disp32]
          // [10 reg base] disp32
<span class="line-modified">!         emit_int8(0x80 | regenc | baseenc);</span>
          emit_data(disp, rspec, disp32_operand);
        }
      }
    } else {
<span class="line-modified">!     if (index-&gt;is_valid()) {</span>
        assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
        // [index*scale + disp]
        // [00 reg 100][ss index 101] disp32
<span class="line-modified">!       assert(index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!       emit_int8(0x04 | regenc);</span>
<span class="line-removed">-       emit_int8(scale &lt;&lt; 6 | indexenc | 0x05);</span>
        emit_data(disp, rspec, disp32_operand);
<span class="line-modified">!     } else if (rtype != relocInfo::none ) {</span>
        // [disp] (64bit) RIP-RELATIVE (32bit) abs
<span class="line-modified">!       // [00 000 101] disp32</span>
  
<span class="line-modified">!       emit_int8(0x05 | regenc);</span>
        // Note that the RIP-rel. correction applies to the generated
        // disp field, but _not_ to the target address in the rspec.
  
        // disp was created by converting the target address minus the pc
        // at the start of the instruction. That needs more correction here.
<span class="line-new-header">--- 468,147 ---</span>
      }
    }
    return is8bit(disp);
  }
  
<span class="line-added">+ static bool is_valid_encoding(int reg_enc) {</span>
<span class="line-added">+   return reg_enc &gt;= 0;</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! static int raw_encode(Register reg) {</span>
<span class="line-modified">!   assert(reg == noreg || reg-&gt;is_valid(), &quot;sanity&quot;);</span>
<span class="line-modified">!   int reg_enc = (intptr_t)reg;</span>
<span class="line-modified">!   assert(reg_enc == -1 || is_valid_encoding(reg_enc), &quot;sanity&quot;);</span>
<span class="line-modified">!   return reg_enc;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int raw_encode(XMMRegister xmmreg) {</span>
<span class="line-added">+   assert(xmmreg == xnoreg || xmmreg-&gt;is_valid(), &quot;sanity&quot;);</span>
<span class="line-added">+   int xmmreg_enc = (intptr_t)xmmreg;</span>
<span class="line-added">+   assert(xmmreg_enc == -1 || is_valid_encoding(xmmreg_enc), &quot;sanity&quot;);</span>
<span class="line-added">+   return xmmreg_enc;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int modrm_encoding(int mod, int dst_enc, int src_enc) {</span>
<span class="line-added">+   return (mod &amp; 3) &lt;&lt; 6 | (dst_enc &amp; 7) &lt;&lt; 3 | (src_enc &amp; 7);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static int sib_encoding(Address::ScaleFactor scale, int index_enc, int base_enc) {</span>
<span class="line-added">+   return (scale &amp; 3) &lt;&lt; 6 | (index_enc &amp; 7) &lt;&lt; 3 | (base_enc &amp; 7);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void Assembler::emit_modrm(int mod, int dst_enc, int src_enc) {</span>
<span class="line-added">+   assert((mod &amp; 3) != 0b11, &quot;forbidden&quot;);</span>
<span class="line-added">+   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added">+   emit_int8(modrm);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void Assembler::emit_modrm_disp8(int mod, int dst_enc, int src_enc,</span>
<span class="line-added">+                                         int disp) {</span>
<span class="line-added">+   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added">+   emit_int16(modrm, disp &amp; 0xFF);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ inline void Assembler::emit_modrm_sib(int mod, int dst_enc, int src_enc,</span>
<span class="line-added">+                                       Address::ScaleFactor scale, int index_enc, int base_enc) {</span>
<span class="line-added">+   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added">+   int sib = sib_encoding(scale, index_enc, base_enc);</span>
<span class="line-added">+   emit_int16(modrm, sib);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! inline void Assembler::emit_modrm_sib_disp8(int mod, int dst_enc, int src_enc,</span>
<span class="line-added">+                                             Address::ScaleFactor scale, int index_enc, int base_enc,</span>
<span class="line-added">+                                             int disp) {</span>
<span class="line-added">+   int modrm = modrm_encoding(mod, dst_enc, src_enc);</span>
<span class="line-added">+   int sib = sib_encoding(scale, index_enc, base_enc);</span>
<span class="line-added">+   emit_int24(modrm, sib, disp &amp; 0xFF);</span>
<span class="line-added">+ }</span>
  
<span class="line-modified">! void Assembler::emit_operand_helper(int reg_enc, int base_enc, int index_enc,</span>
<span class="line-modified">!                                     Address::ScaleFactor scale, int disp,</span>
<span class="line-modified">!                                     RelocationHolder const&amp; rspec,</span>
<span class="line-added">+                                     int rip_relative_correction) {</span>
<span class="line-added">+   bool no_relocation = (rspec.type() == relocInfo::none);</span>
  
<span class="line-modified">!   if (is_valid_encoding(base_enc)) {</span>
<span class="line-modified">!     if (is_valid_encoding(index_enc)) {</span>
        assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
        // [base + index*scale + disp]
<span class="line-modified">!       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
<span class="line-modified">!           base_enc != rbp-&gt;encoding() LP64_ONLY(&amp;&amp; base_enc != r13-&gt;encoding())) {</span>
          // [base + index*scale]
          // [00 reg 100][ss index base]
<span class="line-modified">!         emit_modrm_sib(0b00, reg_enc, 0b100,</span>
<span class="line-modified">!                        scale, index_enc, base_enc);</span>
<span class="line-modified">!       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
          // [base + index*scale + imm8]
          // [01 reg 100][ss index base] imm8
<span class="line-modified">!         emit_modrm_sib_disp8(0b01, reg_enc, 0b100,</span>
<span class="line-modified">!                              scale, index_enc, base_enc,</span>
<span class="line-modified">!                              disp);</span>
        } else {
          // [base + index*scale + disp32]
          // [10 reg 100][ss index base] disp32
<span class="line-modified">!         emit_modrm_sib(0b10, reg_enc, 0b100,</span>
<span class="line-modified">!                        scale, index_enc, base_enc);</span>
          emit_data(disp, rspec, disp32_operand);
        }
<span class="line-modified">!     } else if (base_enc == rsp-&gt;encoding() LP64_ONLY(|| base_enc == r12-&gt;encoding())) {</span>
        // [rsp + disp]
<span class="line-modified">!       if (disp == 0 &amp;&amp; no_relocation) {</span>
          // [rsp]
          // [00 reg 100][00 100 100]
<span class="line-modified">!         emit_modrm_sib(0b00, reg_enc, 0b100,</span>
<span class="line-modified">!                        Address::times_1, 0b100, 0b100);</span>
<span class="line-modified">!       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
          // [rsp + imm8]
          // [01 reg 100][00 100 100] disp8
<span class="line-modified">!         emit_modrm_sib_disp8(0b01, reg_enc, 0b100,</span>
<span class="line-modified">!                              Address::times_1, 0b100, 0b100,</span>
<span class="line-modified">!                              disp);</span>
        } else {
          // [rsp + imm32]
          // [10 reg 100][00 100 100] disp32
<span class="line-modified">!         emit_modrm_sib(0b10, reg_enc, 0b100,</span>
<span class="line-modified">!                        Address::times_1, 0b100, 0b100);</span>
          emit_data(disp, rspec, disp32_operand);
        }
      } else {
        // [base + disp]
<span class="line-modified">!       assert(base_enc != rsp-&gt;encoding() LP64_ONLY(&amp;&amp; base_enc != r12-&gt;encoding()), &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!       if (disp == 0 &amp;&amp; no_relocation &amp;&amp;</span>
<span class="line-modified">!           base_enc != rbp-&gt;encoding() LP64_ONLY(&amp;&amp; base_enc != r13-&gt;encoding())) {</span>
          // [base]
          // [00 reg base]
<span class="line-modified">!         emit_modrm(0, reg_enc, base_enc);</span>
<span class="line-modified">!       } else if (emit_compressed_disp_byte(disp) &amp;&amp; no_relocation) {</span>
          // [base + disp8]
          // [01 reg base] disp8
<span class="line-modified">!         emit_modrm_disp8(0b01, reg_enc, base_enc,</span>
<span class="line-modified">!                          disp);</span>
        } else {
          // [base + disp32]
          // [10 reg base] disp32
<span class="line-modified">!         emit_modrm(0b10, reg_enc, base_enc);</span>
          emit_data(disp, rspec, disp32_operand);
        }
      }
    } else {
<span class="line-modified">!     if (is_valid_encoding(index_enc)) {</span>
        assert(scale != Address::no_scale, &quot;inconsistent address&quot;);
<span class="line-added">+       // base == noreg</span>
        // [index*scale + disp]
        // [00 reg 100][ss index 101] disp32
<span class="line-modified">!       emit_modrm_sib(0b00, reg_enc, 0b100,</span>
<span class="line-modified">!                      scale, index_enc, 0b101 /* no base */);</span>
        emit_data(disp, rspec, disp32_operand);
<span class="line-modified">!     } else if (!no_relocation) {</span>
<span class="line-added">+       // base == noreg, index == noreg</span>
        // [disp] (64bit) RIP-RELATIVE (32bit) abs
<span class="line-modified">!       // [00 reg 101] disp32</span>
  
<span class="line-modified">!       emit_modrm(0b00, reg_enc, 0b101 /* no base */);</span>
        // Note that the RIP-rel. correction applies to the generated
        // disp field, but _not_ to the target address in the rspec.
  
        // disp was created by converting the target address minus the pc
        // at the start of the instruction. That needs more correction here.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 582,49 ***</span>
        assert(is_simm32(adjusted),
               &quot;must be 32bit offset (RIP relative address)&quot;);
        emit_data((int32_t) adjusted, rspec, disp32_operand);
  
      } else {
        // 32bit never did this, did everything as the rip-rel/disp code above
        // [disp] ABSOLUTE
        // [00 reg 100][00 100 101] disp32
<span class="line-modified">!       emit_int8(0x04 | regenc);</span>
<span class="line-modified">!       emit_int8(0x25);</span>
        emit_data(disp, rspec, disp32_operand);
      }
    }
  }
  
<span class="line-modified">! void Assembler::emit_operand(XMMRegister reg, Register base, Register index,</span>
                               Address::ScaleFactor scale, int disp,
                               RelocationHolder const&amp; rspec) {
<span class="line-modified">!   if (UseAVX &gt; 2) {</span>
<span class="line-modified">!     int xreg_enc = reg-&gt;encoding();</span>
<span class="line-modified">!     if (xreg_enc &gt; 15) {</span>
<span class="line-modified">!       XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);</span>
<span class="line-removed">-       emit_operand((Register)new_reg, base, index, scale, disp, rspec);</span>
<span class="line-removed">-       return;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   emit_operand((Register)reg, base, index, scale, disp, rspec);</span>
  }
  
<span class="line-modified">! void Assembler::emit_operand(XMMRegister reg, Register base, XMMRegister index,</span>
                               Address::ScaleFactor scale, int disp,
                               RelocationHolder const&amp; rspec) {
<span class="line-modified">!   if (UseAVX &gt; 2) {</span>
<span class="line-modified">!     int xreg_enc = reg-&gt;encoding();</span>
<span class="line-modified">!     int xmmindex_enc = index-&gt;encoding();</span>
<span class="line-modified">!     XMMRegister new_reg = as_XMMRegister(xreg_enc &amp; 0xf);</span>
<span class="line-removed">-     XMMRegister new_index = as_XMMRegister(xmmindex_enc &amp; 0xf);</span>
<span class="line-removed">-     emit_operand((Register)new_reg, base, (Register)new_index, scale, disp, rspec);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     emit_operand((Register)reg, base, (Register)index, scale, disp, rspec);</span>
<span class="line-removed">-   }</span>
  }
  
<span class="line-removed">- </span>
  // Secret local extension to Assembler::WhichOperand:
  #define end_pc_operand (_WhichOperand_limit)
  
  address Assembler::locate_operand(address inst, WhichOperand which) {
    // Decode the given instruction, and return the address of
<span class="line-new-header">--- 621,48 ---</span>
        assert(is_simm32(adjusted),
               &quot;must be 32bit offset (RIP relative address)&quot;);
        emit_data((int32_t) adjusted, rspec, disp32_operand);
  
      } else {
<span class="line-added">+       // base == noreg, index == noreg, no_relocation == true</span>
        // 32bit never did this, did everything as the rip-rel/disp code above
        // [disp] ABSOLUTE
        // [00 reg 100][00 100 101] disp32
<span class="line-modified">!       emit_modrm_sib(0b00, reg_enc, 0b100 /* no base */,</span>
<span class="line-modified">!                      Address::times_1, 0b100, 0b101);</span>
        emit_data(disp, rspec, disp32_operand);
      }
    }
  }
  
<span class="line-modified">! void Assembler::emit_operand(Register reg, Register base, Register index,</span>
<span class="line-added">+                              Address::ScaleFactor scale, int disp,</span>
<span class="line-added">+                              RelocationHolder const&amp; rspec,</span>
<span class="line-added">+                              int rip_relative_correction) {</span>
<span class="line-added">+   assert(!index-&gt;is_valid() || index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-added">+   emit_operand_helper(raw_encode(reg), raw_encode(base), raw_encode(index),</span>
<span class="line-added">+                       scale, disp, rspec, rip_relative_correction);</span>
<span class="line-added">+ </span>
<span class="line-added">+ }</span>
<span class="line-added">+ void Assembler::emit_operand(XMMRegister xmmreg, Register base, Register index,</span>
                               Address::ScaleFactor scale, int disp,
                               RelocationHolder const&amp; rspec) {
<span class="line-modified">!   assert(!index-&gt;is_valid() || index != rsp, &quot;illegal addressing mode&quot;);</span>
<span class="line-modified">!   assert(xmmreg-&gt;encoding() &lt; 16 || UseAVX &gt; 2, &quot;not supported&quot;);</span>
<span class="line-modified">!   emit_operand_helper(raw_encode(xmmreg), raw_encode(base), raw_encode(index),</span>
<span class="line-modified">!                       scale, disp, rspec);</span>
  }
  
<span class="line-modified">! void Assembler::emit_operand(XMMRegister xmmreg, Register base, XMMRegister xmmindex,</span>
                               Address::ScaleFactor scale, int disp,
                               RelocationHolder const&amp; rspec) {
<span class="line-modified">!   assert(xmmreg-&gt;encoding() &lt; 16 || UseAVX &gt; 2, &quot;not supported&quot;);</span>
<span class="line-modified">!   assert(xmmindex-&gt;encoding() &lt; 16 || UseAVX &gt; 2, &quot;not supported&quot;);</span>
<span class="line-modified">!   emit_operand_helper(raw_encode(xmmreg), raw_encode(base), raw_encode(xmmindex),</span>
<span class="line-modified">!                       scale, disp, rspec, /* rip_relative_correction */ 0);</span>
  }
  
  // Secret local extension to Assembler::WhichOperand:
  #define end_pc_operand (_WhichOperand_limit)
  
  address Assembler::locate_operand(address inst, WhichOperand which) {
    // Decode the given instruction, and return the address of
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1107,17 ***</span>
    }
    assert(opnd == pc(), &quot;must put operand where relocs can find it&quot;);
  }
  #endif // ASSERT
  
<span class="line-removed">- void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-removed">-   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-removed">-   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">-   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-removed">-                adr._rspec);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Assembler::emit_operand(Register reg, Address adr,
                               int rip_relative_correction) {
    emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
                 adr._rspec,
                 rip_relative_correction);
<span class="line-new-header">--- 1145,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1130,31 ***</span>
         emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,
         adr._rspec);
      }
  }
  
<span class="line-removed">- // MMX operations</span>
<span class="line-removed">- void Assembler::emit_operand(MMXRegister reg, Address adr) {</span>
<span class="line-removed">-   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">-   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // work around gcc (3.2.1-7a) bug</span>
<span class="line-removed">- void Assembler::emit_operand(Address adr, MMXRegister reg) {</span>
<span class="line-removed">-   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-removed">-   emit_operand((Register)reg, adr._base, adr._index, adr._scale, adr._disp, adr._rspec);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- void Assembler::emit_farith(int b1, int b2, int i) {</span>
<span class="line-removed">-   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);</span>
<span class="line-removed">-   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);</span>
<span class="line-removed">-   emit_int8(b1);</span>
<span class="line-removed">-   emit_int8(b2 + i);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  // Now the Assembler instructions (identical for 32/64 bits)
  
  void Assembler::adcl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
<span class="line-new-header">--- 1161,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1233,54 ***</span>
  }
  
  void Assembler::addr_nop_4() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 4 bytes: NOP DWORD PTR [EAX+0]
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x1F);</span>
<span class="line-modified">!   emit_int8(0x40); // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="line-modified">!   emit_int8(0);    // 8-bits offset (1 byte)</span>
  }
  
  void Assembler::addr_nop_5() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x1F);</span>
<span class="line-modified">!   emit_int8(0x44); // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="line-modified">!   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">!   emit_int8(0);    // 8-bits offset (1 byte)</span>
  }
  
  void Assembler::addr_nop_7() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x1F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0x80);</span>
                     // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
    emit_int32(0);   // 32-bits offset (4 bytes)
  }
  
  void Assembler::addr_nop_8() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x1F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0x84);</span>
<span class="line-modified">!                    // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="line-modified">!   emit_int8(0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">!   emit_int32(0);   // 32-bits offset (4 bytes)</span>
  }
  
  void Assembler::addsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::addsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1243,53 ---</span>
  }
  
  void Assembler::addr_nop_4() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 4 bytes: NOP DWORD PTR [EAX+0]
<span class="line-modified">!   emit_int32(0x0F,</span>
<span class="line-modified">!              0x1F,</span>
<span class="line-modified">!              0x40, // emit_rm(cbuf, 0x1, EAX_enc, EAX_enc);</span>
<span class="line-modified">!              0);   // 8-bits offset (1 byte)</span>
  }
  
  void Assembler::addr_nop_5() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 5 bytes: NOP DWORD PTR [EAX+EAX*0+0] 8-bits offset
<span class="line-modified">!   emit_int32(0x0F,</span>
<span class="line-modified">!              0x1F,</span>
<span class="line-modified">!              0x44,  // emit_rm(cbuf, 0x1, EAX_enc, 0x4);</span>
<span class="line-modified">!              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">!   emit_int8(0);     // 8-bits offset (1 byte)</span>
  }
  
  void Assembler::addr_nop_7() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 7 bytes: NOP DWORD PTR [EAX+0] 32-bits offset
<span class="line-modified">!   emit_int24(0x0F,</span>
<span class="line-modified">!              0x1F,</span>
<span class="line-modified">!              (unsigned char)0x80);</span>
                     // emit_rm(cbuf, 0x2, EAX_enc, EAX_enc);
    emit_int32(0);   // 32-bits offset (4 bytes)
  }
  
  void Assembler::addr_nop_8() {
    assert(UseAddressNop, &quot;no CPU support&quot;);
    // 8 bytes: NOP DWORD PTR [EAX+EAX*0+0] 32-bits offset
<span class="line-modified">!   emit_int32(0x0F,</span>
<span class="line-modified">!              0x1F,</span>
<span class="line-modified">!              (unsigned char)0x84,</span>
<span class="line-modified">!                     // emit_rm(cbuf, 0x2, EAX_enc, 0x4);</span>
<span class="line-modified">!              0x00); // emit_rm(cbuf, 0x0, EAX_enc, EAX_enc);</span>
<span class="line-modified">!   emit_int32(0);    // 32-bits offset (4 bytes)</span>
  }
  
  void Assembler::addsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::addsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1294,12 ***</span>
  
  void Assembler::addss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::addss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1303,11 ---</span>
  
  void Assembler::addss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::addss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1321,21 ***</span>
  
  void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDE);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
  }
  
  void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDE);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::aesdeclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
<span class="line-new-header">--- 1329,19 ---</span>
  
  void Assembler::aesdec(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>
  }
  
  void Assembler::vaesdec(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDE, (0xC0 | encode));</span>
  }
  
  
  void Assembler::aesdeclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1348,21 ***</span>
  
  void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::aesenc(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1354,19 ---</span>
  
  void Assembler::aesdeclast(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  void Assembler::vaesdeclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  void Assembler::aesenc(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1374,21 ***</span>
  
  void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDC);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
  }
  
  void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::aesenclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1378,19 ---</span>
  
  void Assembler::aesenc(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDC, 0xC0 | encode);</span>
  }
  
  void Assembler::vaesenc(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDC, (0xC0 | encode));</span>
  }
  
  void Assembler::aesenclast(XMMRegister dst, Address src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1400,21 ***</span>
  
  void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::andl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
<span class="line-new-header">--- 1402,19 ---</span>
  
  void Assembler::aesenclast(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_aes(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>
  }
  
  void Assembler::vaesenclast(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vaes(), &quot;requires vaes support/enabling&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDD, (0xC0 | encode));</span>
  }
  
  void Assembler::andl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1442,12 ***</span>
  
  void Assembler::andnl(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::andnl(Register dst, Register src1, Address src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1442,11 ---</span>
  
  void Assembler::andnl(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::andnl(Register dst, Register src1, Address src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1457,34 ***</span>
    emit_operand(dst, src2);
  }
  
  void Assembler::bsfl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBC);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::bsrl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBD);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::bswapl(Register reg) { // bswap
    int encode = prefix_and_encode(reg-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC8 | encode));</span>
  }
  
  void Assembler::blsil(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::blsil(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1456,32 ---</span>
    emit_operand(dst, src2);
  }
  
  void Assembler::bsfl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBC,</span>
<span class="line-modified">!              0xC0 | encode);</span>
  }
  
  void Assembler::bsrl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBD,</span>
<span class="line-modified">!              0xC0 | encode);</span>
  }
  
  void Assembler::bswapl(Register reg) { // bswap
    int encode = prefix_and_encode(reg-&gt;encoding());
<span class="line-modified">!   emit_int16(0x0F, (0xC8 | encode));</span>
  }
  
  void Assembler::blsil(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsil(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1496,12 ***</span>
  
  void Assembler::blsmskl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::blsmskl(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1493,12 ---</span>
  
  void Assembler::blsmskl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3,</span>
<span class="line-modified">!              0xC0 | encode);</span>
  }
  
  void Assembler::blsmskl(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1513,12 ***</span>
  
  void Assembler::blsrl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::blsrl(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1510,11 ---</span>
  
  void Assembler::blsrl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsrl(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1550,12 ***</span>
    }
  }
  
  void Assembler::call(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xD0 | encode));</span>
  }
  
  
  void Assembler::call(Address adr) {
    InstructionMark im(this);
<span class="line-new-header">--- 1546,11 ---</span>
    }
  }
  
  void Assembler::call(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xFF, (0xD0 | encode));</span>
  }
  
  
  void Assembler::call(Address adr) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1586,21 ***</span>
  }
  
  void Assembler::cmovl(Condition cc, Register dst, Register src) {
    NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x40 | cc);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::cmovl(Condition cc, Register dst, Address src) {
    NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x40 | cc);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpb(Address dst, int imm8) {
    InstructionMark im(this);
<span class="line-new-header">--- 1581,20 ---</span>
  }
  
  void Assembler::cmovl(Condition cc, Register dst, Register src) {
    NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F,</span>
<span class="line-modified">!              0x40 | cc,</span>
<span class="line-modified">!              0xC0 | encode);</span>
  }
  
  
  void Assembler::cmovl(Condition cc, Register dst, Address src) {
    NOT_LP64(guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;));
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (0x40 | cc));</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpb(Address dst, int imm8) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1629,42 ***</span>
  }
  
  void Assembler::cmpl(Register dst, Address  src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8((unsigned char)0x3B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpw(Address dst, int imm16) {
    InstructionMark im(this);
    assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
<span class="line-modified">!   emit_int8(0x66);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x81);</span>
    emit_operand(rdi, dst, 2);
    emit_int16(imm16);
  }
  
  // The 32-bit cmpxchg compares the value at adr with the contents of rax,
  // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
  // The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
    InstructionMark im(this);
    prefix(adr, reg);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB1);</span>
    emit_operand(reg, adr);
  }
  
  // The 8-bit cmpxchg compares the value at adr with the contents of rax,
  // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
  // The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
    InstructionMark im(this);
    prefix(adr, reg, true);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB0);</span>
    emit_operand(reg, adr);
  }
  
  void Assembler::comisd(XMMRegister dst, Address src) {
    // NOTE: dbx seems to decode this as comiss even though the
<span class="line-new-header">--- 1623,39 ---</span>
  }
  
  void Assembler::cmpl(Register dst, Address  src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x3B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpw(Address dst, int imm16) {
    InstructionMark im(this);
    assert(!dst.base_needs_rex() &amp;&amp; !dst.index_needs_rex(), &quot;no extended registers&quot;);
<span class="line-modified">!   emit_int16(0x66, (unsigned char)0x81);</span>
    emit_operand(rdi, dst, 2);
    emit_int16(imm16);
  }
  
  // The 32-bit cmpxchg compares the value at adr with the contents of rax,
  // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
  // The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchgl(Register reg, Address adr) { // cmpxchg
    InstructionMark im(this);
    prefix(adr, reg);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xB1);</span>
    emit_operand(reg, adr);
  }
  
  // The 8-bit cmpxchg compares the value at adr with the contents of rax,
  // and stores reg into adr if so; otherwise, the value at adr is loaded into rax,.
  // The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchgb(Register reg, Address adr) { // cmpxchg
    InstructionMark im(this);
    prefix(adr, reg, true);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xB0);</span>
    emit_operand(reg, adr);
  }
  
  void Assembler::comisd(XMMRegister dst, Address src) {
    // NOTE: dbx seems to decode this as comiss even though the
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1682,12 ***</span>
  void Assembler::comisd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::comiss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1673,11 ---</span>
  void Assembler::comisd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2F, (0xC0 | encode));</span>
  }
  
  void Assembler::comiss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1700,17 ***</span>
  
  void Assembler::comiss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cpuid() {
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xA2);</span>
  }
  
  // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
  // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
  // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
<span class="line-new-header">--- 1690,15 ---</span>
  
  void Assembler::comiss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2F, (0xC0 | encode));</span>
  }
  
  void Assembler::cpuid() {
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xA2);</span>
  }
  
  // Opcode / Instruction                      Op /  En  64 - Bit Mode     Compat / Leg Mode Description                  Implemented
  // F2 0F 38 F0 / r       CRC32 r32, r / m8   RM        Valid             Valid             Accumulate CRC32 on r / m8.  v
  // F2 REX 0F 38 F0 / r   CRC32 r32, r / m8*  RM        Valid             N.E.              Accumulate CRC32 on r / m8.  -
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1724,11 ***</span>
  void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    int8_t w = 0x01;
    Prefix p = Prefix_EMPTY;
  
<span class="line-modified">!   emit_int8((int8_t)0xF2);</span>
    switch (sizeInBytes) {
    case 1:
      w = 0;
      break;
    case 2:
<span class="line-new-header">--- 1712,11 ---</span>
  void Assembler::crc32(Register crc, Register v, int8_t sizeInBytes) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    int8_t w = 0x01;
    Prefix p = Prefix_EMPTY;
  
<span class="line-modified">!   emit_int8((unsigned char)0xF2);</span>
    switch (sizeInBytes) {
    case 1:
      w = 0;
      break;
    case 2:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1753,14 ***</span>
    default:
      assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
      break;
    }
    LP64_ONLY(prefix(crc, v, p);)
<span class="line-modified">!   emit_int8((int8_t)0x0F);</span>
<span class="line-modified">!   emit_int8(0x38);</span>
<span class="line-modified">!   emit_int8((int8_t)(0xF0 | w));</span>
<span class="line-modified">!   emit_int8(0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
  }
  
  void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 1741,14 ---</span>
    default:
      assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
      break;
    }
    LP64_ONLY(prefix(crc, v, p);)
<span class="line-modified">!   emit_int32(0x0F,</span>
<span class="line-modified">!              0x38,</span>
<span class="line-modified">!              0xF0 | w,</span>
<span class="line-modified">!              0xC0 | ((crc-&gt;encoding() &amp; 0x7) &lt;&lt; 3) | (v-&gt;encoding() &amp; 7));</span>
  }
  
  void Assembler::crc32(Register crc, Address adr, int8_t sizeInBytes) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1782,39 ***</span>
    default:
      assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
      break;
    }
    LP64_ONLY(prefix(crc, adr, p);)
<span class="line-modified">!   emit_int8((int8_t)0x0F);</span>
<span class="line-removed">-   emit_int8(0x38);</span>
<span class="line-removed">-   emit_int8((int8_t)(0xF0 | w));</span>
    emit_operand(crc, adr);
  }
  
  void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE6);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1770,34 ---</span>
    default:
      assert(0, &quot;Unsupported value for a sizeInBytes argument&quot;);
      break;
    }
    LP64_ONLY(prefix(crc, adr, p);)
<span class="line-modified">!   emit_int24(0x0F, 0x38, (0xF0 | w));</span>
    emit_operand(crc, adr);
  }
  
  void Assembler::cvtdq2pd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtdq2ps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5B, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsd2ss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsd2ss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1828,12 ***</span>
  
  void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1811,11 ---</span>
  
  void Assembler::cvtsi2sdl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2sdl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1846,12 ***</span>
  
  void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1828,11 ---</span>
  
  void Assembler::cvtsi2ssl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2ssl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1864,20 ***</span>
  
  void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtss2sd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1845,18 ---</span>
  
  void Assembler::cvtsi2ssq(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtss2sd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtss2sd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1891,92 ***</span>
  
  void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvttss2sil(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE6);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x1C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x1D);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x1E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x1C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x1D);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x1E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x1F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::decl(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
    InstructionMark im(this);
<span class="line-new-header">--- 1870,82 ---</span>
  
  void Assembler::cvttsd2sil(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::cvttss2sil(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::cvttpd2dq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE6, (0xC0 | encode));</span>
  }
  
  void Assembler::pabsb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1C, (0xC0 | encode));</span>
  }
  
  void Assembler::pabsw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1D, (0xC0 | encode));</span>
  }
  
  void Assembler::pabsd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1E, (0xC0 | encode));</span>
  }
  
  void Assembler::vpabsb(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1C, (0xC0 | encode));</span>
  }
  
  void Assembler::vpabsw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1D, (0xC0 | encode));</span>
  }
  
  void Assembler::vpabsd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1E, (0xC0 | encode));</span>
  }
  
  void Assembler::evpabsq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x1F, (0xC0 | encode));</span>
  }
  
  void Assembler::decl(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrement() instead.
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1999,12 ***</span>
  void Assembler::divsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::divss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 1968,11 ---</span>
  void Assembler::divsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::divss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2017,68 ***</span>
  
  void Assembler::divss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Assembler::emms() {</span>
<span class="line-removed">-   NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x77);</span>
  }
  
  void Assembler::hlt() {
    emit_int8((unsigned char)0xF4);
  }
  
  void Assembler::idivl(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
  }
  
  void Assembler::divl(Register src) { // Unsigned
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF0 | encode));</span>
  }
  
  void Assembler::imull(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
  }
  
  void Assembler::imull(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xAF);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::imull(Register dst, Register src, int value) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    if (is8bit(value)) {
<span class="line-modified">!     emit_int8(0x6B);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-     emit_int8(value &amp; 0xFF);</span>
    } else {
<span class="line-modified">!     emit_int8(0x69);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
      emit_int32(value);
    }
  }
  
  void Assembler::imull(Register dst, Address src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char) 0xAF);</span>
    emit_operand(dst, src);
  }
  
  
  void Assembler::incl(Address dst) {
<span class="line-new-header">--- 1985,54 ---</span>
  
  void Assembler::divss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::hlt() {
    emit_int8((unsigned char)0xF4);
  }
  
  void Assembler::idivl(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>
  }
  
  void Assembler::divl(Register src) { // Unsigned
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xF0 | encode));</span>
  }
  
  void Assembler::imull(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xE8 | encode));</span>
  }
  
  void Assembler::imull(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F,</span>
<span class="line-modified">!              (unsigned char)0xAF,</span>
<span class="line-modified">!              (0xC0 | encode));</span>
  }
  
  
  void Assembler::imull(Register dst, Register src, int value) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    if (is8bit(value)) {
<span class="line-modified">!     emit_int24(0x6B, (0xC0 | encode), value &amp; 0xFF);</span>
    } else {
<span class="line-modified">!     emit_int16(0x69, (0xC0 | encode));</span>
      emit_int32(value);
    }
  }
  
  void Assembler::imull(Register dst, Address src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xAF);</span>
    emit_operand(dst, src);
  }
  
  
  void Assembler::incl(Address dst) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2099,28 ***</span>
      const int short_size = 2;
      const int long_size = 6;
      intptr_t offs = (intptr_t)dst - (intptr_t)pc();
      if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
        // 0111 tttn #8-bit disp
<span class="line-modified">!       emit_int8(0x70 | cc);</span>
<span class="line-removed">-       emit_int8((offs - short_size) &amp; 0xFF);</span>
      } else {
        // 0000 1111 1000 tttn #32-bit disp
        assert(is_simm32(offs - long_size),
               &quot;must be 32bit offset (call4)&quot;);
<span class="line-modified">!       emit_int8(0x0F);</span>
<span class="line-removed">-       emit_int8((unsigned char)(0x80 | cc));</span>
        emit_int32(offs - long_size);
      }
    } else {
      // Note: could eliminate cond. jumps to this jump if condition
      //       is the same however, seems to be rather unlikely case.
      // Note: use jccb() if label to be bound is very close to get
      //       an 8-bit displacement
      L.add_patch_at(code(), locator());
<span class="line-modified">!     emit_int8(0x0F);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0x80 | cc));</span>
      emit_int32(0);
    }
  }
  
  void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
<span class="line-new-header">--- 2053,25 ---</span>
      const int short_size = 2;
      const int long_size = 6;
      intptr_t offs = (intptr_t)dst - (intptr_t)pc();
      if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
        // 0111 tttn #8-bit disp
<span class="line-modified">!       emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>
      } else {
        // 0000 1111 1000 tttn #32-bit disp
        assert(is_simm32(offs - long_size),
               &quot;must be 32bit offset (call4)&quot;);
<span class="line-modified">!       emit_int16(0x0F, (0x80 | cc));</span>
        emit_int32(offs - long_size);
      }
    } else {
      // Note: could eliminate cond. jumps to this jump if condition
      //       is the same however, seems to be rather unlikely case.
      // Note: use jccb() if label to be bound is very close to get
      //       an 8-bit displacement
      L.add_patch_at(code(), locator());
<span class="line-modified">!     emit_int16(0x0F, (0x80 | cc));</span>
      emit_int32(0);
    }
  }
  
  void Assembler::jccb_0(Condition cc, Label&amp; L, const char* file, int line) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2135,17 ***</span>
      }
      assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
  #endif
      intptr_t offs = (intptr_t)entry - (intptr_t)pc();
      // 0111 tttn #8-bit disp
<span class="line-modified">!     emit_int8(0x70 | cc);</span>
<span class="line-removed">-     emit_int8((offs - short_size) &amp; 0xFF);</span>
    } else {
      InstructionMark im(this);
      L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">!     emit_int8(0x70 | cc);</span>
<span class="line-removed">-     emit_int8(0);</span>
    }
  }
  
  void Assembler::jmp(Address adr) {
    InstructionMark im(this);
<span class="line-new-header">--- 2086,15 ---</span>
      }
      assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
  #endif
      intptr_t offs = (intptr_t)entry - (intptr_t)pc();
      // 0111 tttn #8-bit disp
<span class="line-modified">!     emit_int16(0x70 | cc, (offs - short_size) &amp; 0xFF);</span>
    } else {
      InstructionMark im(this);
      L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">!     emit_int16(0x70 | cc, 0);</span>
    }
  }
  
  void Assembler::jmp(Address adr) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2161,12 ***</span>
      InstructionMark im(this);
      const int short_size = 2;
      const int long_size = 5;
      intptr_t offs = entry - pc();
      if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
<span class="line-modified">!       emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">-       emit_int8((offs - short_size) &amp; 0xFF);</span>
      } else {
        emit_int8((unsigned char)0xE9);
        emit_int32(offs - long_size);
      }
    } else {
<span class="line-new-header">--- 2110,11 ---</span>
      InstructionMark im(this);
      const int short_size = 2;
      const int long_size = 5;
      intptr_t offs = entry - pc();
      if (maybe_short &amp;&amp; is8bit(offs - short_size)) {
<span class="line-modified">!       emit_int16((unsigned char)0xEB, ((offs - short_size) &amp; 0xFF));</span>
      } else {
        emit_int8((unsigned char)0xE9);
        emit_int32(offs - long_size);
      }
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2181,12 ***</span>
    }
  }
  
  void Assembler::jmp(Register entry) {
    int encode = prefix_and_encode(entry-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
  }
  
  void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xE9);
<span class="line-new-header">--- 2129,11 ---</span>
    }
  }
  
  void Assembler::jmp(Register entry) {
    int encode = prefix_and_encode(entry-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xFF, (0xE0 | encode));</span>
  }
  
  void Assembler::jmp_literal(address dest, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xE9);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2208,17 ***</span>
        dist += (dist &lt; 0 ? (-delta) :delta);
      }
      assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
  #endif
      intptr_t offs = entry - pc();
<span class="line-modified">!     emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">-     emit_int8((offs - short_size) &amp; 0xFF);</span>
    } else {
      InstructionMark im(this);
      L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">!     emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">-     emit_int8(0);</span>
    }
  }
  
  void Assembler::ldmxcsr( Address src) {
    if (UseAVX &gt; 0 ) {
<span class="line-new-header">--- 2155,15 ---</span>
        dist += (dist &lt; 0 ? (-delta) :delta);
      }
      assert(is8bit(dist), &quot;Dispacement too large for a short jmp at %s:%d&quot;, file, line);
  #endif
      intptr_t offs = entry - pc();
<span class="line-modified">!     emit_int16((unsigned char)0xEB, (offs - short_size) &amp; 0xFF);</span>
    } else {
      InstructionMark im(this);
      L.add_patch_at(code(), locator(), file, line);
<span class="line-modified">!     emit_int16((unsigned char)0xEB, 0);</span>
    }
  }
  
  void Assembler::ldmxcsr( Address src) {
    if (UseAVX &gt; 0 ) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2229,12 ***</span>
      emit_operand(as_Register(2), src);
    } else {
      NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
      InstructionMark im(this);
      prefix(src);
<span class="line-modified">!     emit_int8(0x0F);</span>
<span class="line-removed">-     emit_int8((unsigned char)0xAE);</span>
      emit_operand(as_Register(2), src);
    }
  }
  
  void Assembler::leal(Register dst, Address src) {
<span class="line-new-header">--- 2174,11 ---</span>
      emit_operand(as_Register(2), src);
    } else {
      NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
      InstructionMark im(this);
      prefix(src);
<span class="line-modified">!     emit_int16(0x0F, (unsigned char)0xAE);</span>
      emit_operand(as_Register(2), src);
    }
  }
  
  void Assembler::leal(Register dst, Address src) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2246,42 ***</span>
    emit_int8((unsigned char)0x8D);
    emit_operand(dst, src);
  }
  
  void Assembler::lfence() {
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE8);</span>
  }
  
  void Assembler::lock() {
    emit_int8((unsigned char)0xF0);
  }
  
  void Assembler::lzcntl(Register dst, Register src) {
    assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // Emit mfence instruction
  void Assembler::mfence() {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF0);</span>
  }
  
  // Emit sfence instruction
  void Assembler::sfence() {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF8);</span>
  }
  
  void Assembler::mov(Register dst, Register src) {
    LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
  }
<span class="line-new-header">--- 2190,34 ---</span>
    emit_int8((unsigned char)0x8D);
    emit_operand(dst, src);
  }
  
  void Assembler::lfence() {
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xE8);</span>
  }
  
  void Assembler::lock() {
    emit_int8((unsigned char)0xF0);
  }
  
  void Assembler::lzcntl(Register dst, Register src) {
    assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>
  }
  
  // Emit mfence instruction
  void Assembler::mfence() {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF0);</span>
  }
  
  // Emit sfence instruction
  void Assembler::sfence() {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;unsupported&quot;);)
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xAE, (unsigned char)0xF8);</span>
  }
  
  void Assembler::mov(Register dst, Register src) {
    LP64_ONLY(movq(dst, src)) NOT_LP64(movl(dst, src));
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2290,29 ***</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x28);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movaps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x28);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x16);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movb(Register dst, Address src) {
    NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2226,26 ---</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x28, (0xC0 | encode));</span>
  }
  
  void Assembler::movaps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x28, (0xC0 | encode));</span>
  }
  
  void Assembler::movlhps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, src, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x16, (0xC0 | encode));</span>
  }
  
  void Assembler::movb(Register dst, Address src) {
    NOT_LP64(assert(dst-&gt;has_byte_register(), &quot;must have byte register&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2325,44 ***</span>
    NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x12);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
  }
  
  void Assembler::kmovbl(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovbl(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(KRegister dst, Register src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(Register dst, KRegister src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(KRegister dst, Address src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 2258,39 ---</span>
    NOT_LP64(assert(VM_Version::supports_sse3(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x12, 0xC0 | encode);</span>
  }
  
  void Assembler::kmovbl(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovbl(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(KRegister dst, Register src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(Register dst, KRegister src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovwl(KRegister dst, Address src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2374,28 ***</span>
  
  void Assembler::kmovdl(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovdl(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(KRegister dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x90);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(KRegister dst, Address src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 2302,25 ---</span>
  
  void Assembler::kmovdl(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovdl(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(KRegister dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x90, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(KRegister dst, Address src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2416,89 ***</span>
  
  void Assembler::kmovql(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x92);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x93);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::knotwl(KRegister dst, KRegister src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x44);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestbl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestwl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestdl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestql(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x98);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::ktestql(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x99);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::ktestq(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x99);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::ktestd(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x99);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movb(Address dst, int imm8) {
    InstructionMark im(this);
     prefix(dst);
<span class="line-new-header">--- 2341,79 ---</span>
  
  void Assembler::kmovql(KRegister dst, Register src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x92, (0xC0 | encode));</span>
  }
  
  void Assembler::kmovql(Register dst, KRegister src) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x93, (0xC0 | encode));</span>
  }
  
  void Assembler::knotwl(KRegister dst, KRegister src) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x44, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestbl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestwl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestdl(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::kortestql(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x98, (0xC0 | encode));</span>
  }
  
  // This instruction produces ZF or CF flags
  void Assembler::ktestql(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>
  }
  
  void Assembler::ktestq(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>
  }
  
  void Assembler::ktestd(KRegister src1, KRegister src2) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(src1-&gt;encoding(), 0, src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0x99, (0xC0 | encode));</span>
  }
  
  void Assembler::movb(Address dst, int imm8) {
    InstructionMark im(this);
     prefix(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2518,21 ***</span>
  
  void Assembler::movdl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movdl(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    // swap src/dst to get correct prefix
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x7E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movdl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2433,19 ---</span>
  
  void Assembler::movdl(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6E, (0xC0 | encode));</span>
  }
  
  void Assembler::movdl(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    // swap src/dst to get correct prefix
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x7E, (0xC0 | encode));</span>
  }
  
  void Assembler::movdl(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2555,12 ***</span>
  
  void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movdqa(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2468,11 ---</span>
  
  void Assembler::movdqa(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::movdqa(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2583,12 ***</span>
  
  void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movdqu(Address dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2495,11 ---</span>
  
  void Assembler::movdqu(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::movdqu(Address dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2603,12 ***</span>
  // Move Unaligned 256bit Vector
  void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
    assert(UseAVX &gt; 0, &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmovdqu(XMMRegister dst, Address src) {
    assert(UseAVX &gt; 0, &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 2514,11 ---</span>
  // Move Unaligned 256bit Vector
  void Assembler::vmovdqu(XMMRegister dst, XMMRegister src) {
    assert(UseAVX &gt; 0, &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::vmovdqu(XMMRegister dst, Address src) {
    assert(UseAVX &gt; 0, &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2637,12 ***</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 2547,11 ---</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int prefix = (_legacy_mode_bw) ? VEX_SIMD_F2 : VEX_SIMD_F3;
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), (Assembler::VexSimdPrefix)prefix, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::evmovdqub(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2734,12 ***</span>
  void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 2643,11 ---</span>
  void Assembler::evmovdqul(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::evmovdqul(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2767,12 ***</span>
  void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 2675,11 ---</span>
  void Assembler::evmovdquq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6F, (0xC0 | encode));</span>
  }
  
  void Assembler::evmovdquq(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2799,18 ***</span>
  
  // Uses zero extension on 64bit
  
  void Assembler::movl(Register dst, int32_t imm32) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)(0xB8 | encode));</span>
    emit_int32(imm32);
  }
  
  void Assembler::movl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x8B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movl(Register dst, Address src) {
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-new-header">--- 2706,17 ---</span>
  
  // Uses zero extension on 64bit
  
  void Assembler::movl(Register dst, int32_t imm32) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0xB8 | encode);</span>
    emit_int32(imm32);
  }
  
  void Assembler::movl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0x8B, (0xC0 | encode));</span>
  }
  
  void Assembler::movl(Register dst, Address src) {
    InstructionMark im(this);
    prefix(src, dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2845,30 ***</span>
    simd_prefix(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x12);
    emit_operand(dst, src);
  }
  
<span class="line-removed">- void Assembler::movq( MMXRegister dst, Address src ) {</span>
<span class="line-removed">-   assert( VM_Version::supports_mmx(), &quot;&quot; );</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x6F);</span>
<span class="line-removed">-   emit_operand(dst, src);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Assembler::movq( Address dst, MMXRegister src ) {</span>
<span class="line-removed">-   assert( VM_Version::supports_mmx(), &quot;&quot; );</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x7F);</span>
<span class="line-removed">-   // workaround gcc (3.2.1-7a) bug</span>
<span class="line-removed">-   // In that version of gcc with only an emit_operand(MMX, Address)</span>
<span class="line-removed">-   // gcc will tail jump and try and reverse the parameters completely</span>
<span class="line-removed">-   // obliterating dst in the process. By having a version available</span>
<span class="line-removed">-   // that doesn&#39;t need to swap the args at the tail jump the bug is</span>
<span class="line-removed">-   // avoided.</span>
<span class="line-removed">-   emit_operand(dst, src);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Assembler::movq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
<span class="line-new-header">--- 2751,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2890,30 ***</span>
  }
  
  void Assembler::movsbl(Register dst, Address src) { // movsxb
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBE);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movsbl(Register dst, Register src) { // movsxb
    NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBE);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x10);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2776,26 ---</span>
  }
  
  void Assembler::movsbl(Register dst, Address src) { // movsxb
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xBE);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movsbl(Register dst, Register src) { // movsxb
    NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>
  }
  
  void Assembler::movsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x10, (0xC0 | encode));</span>
  }
  
  void Assembler::movsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2939,12 ***</span>
  
  void Assembler::movss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x10);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2821,11 ---</span>
  
  void Assembler::movss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x10, (0xC0 | encode));</span>
  }
  
  void Assembler::movss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2967,20 ***</span>
  }
  
  void Assembler::movswl(Register dst, Address src) { // movsxw
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movswl(Register dst, Register src) { // movsxw
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movw(Address dst, int imm16) {
    InstructionMark im(this);
  
<span class="line-new-header">--- 2848,17 ---</span>
  }
  
  void Assembler::movswl(Register dst, Address src) { // movsxw
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xBF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movswl(Register dst, Register src) { // movsxw
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>
  }
  
  void Assembler::movw(Address dst, int imm16) {
    InstructionMark im(this);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3008,36 ***</span>
  }
  
  void Assembler::movzbl(Register dst, Address src) { // movzxb
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB6);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzbl(Register dst, Register src) { // movzxb
    NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB6);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
  }
  
  void Assembler::movzwl(Register dst, Address src) { // movzxw
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB7);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzwl(Register dst, Register src) { // movzxw
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB7);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
  }
  
  void Assembler::mull(Address src) {
    InstructionMark im(this);
    prefix(src);
<span class="line-new-header">--- 2886,30 ---</span>
  }
  
  void Assembler::movzbl(Register dst, Address src) { // movzxb
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xB6);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzbl(Register dst, Register src) { // movzxb
    NOT_LP64(assert(src-&gt;has_byte_register(), &quot;must have byte register&quot;));
    int encode = prefix_and_encode(dst-&gt;encoding(), false, src-&gt;encoding(), true);
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xB6, 0xC0 | encode);</span>
  }
  
  void Assembler::movzwl(Register dst, Address src) { // movzxw
    InstructionMark im(this);
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xB7);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzwl(Register dst, Register src) { // movzxw
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xB7, 0xC0 | encode);</span>
  }
  
  void Assembler::mull(Address src) {
    InstructionMark im(this);
    prefix(src);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3045,12 ***</span>
    emit_operand(rsp, src);
  }
  
  void Assembler::mull(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
  }
  
  void Assembler::mulsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2917,11 ---</span>
    emit_operand(rsp, src);
  }
  
  void Assembler::mull(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>
  }
  
  void Assembler::mulsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3065,12 ***</span>
  void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::mulss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 2936,11 ---</span>
  void Assembler::mulsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::mulss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3083,18 ***</span>
  
  void Assembler::mulss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::negl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xD8 | encode));</span>
  }
  
  void Assembler::nop(int i) {
  #ifdef ASSERT
    assert(i &gt; 0, &quot; &quot;);
<span class="line-new-header">--- 2953,16 ---</span>
  
  void Assembler::mulss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::negl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>
  }
  
  void Assembler::nop(int i) {
  #ifdef ASSERT
    assert(i &gt; 0, &quot; &quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3131,32 ***</span>
      // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
  
      while(i &gt;= 15) {
        // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
        i -= 15;
<span class="line-modified">!       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
        addr_nop_8();
<span class="line-modified">!       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8((unsigned char)0x90);</span>
<span class="line-removed">-                          // nop</span>
      }
      switch (i) {
        case 14:
          emit_int8(0x66); // size prefix
        case 13:
          emit_int8(0x66); // size prefix
        case 12:
          addr_nop_8();
<span class="line-modified">!         emit_int8(0x66); // size prefix</span>
<span class="line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="line-removed">-         emit_int8((unsigned char)0x90);</span>
<span class="line-removed">-                          // nop</span>
          break;
        case 11:
          emit_int8(0x66); // size prefix
        case 10:
          emit_int8(0x66); // size prefix
<span class="line-new-header">--- 2999,22 ---</span>
      // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
  
      while(i &gt;= 15) {
        // For Intel don&#39;t generate consecutive addess nops (mix with regular nops)
        i -= 15;
<span class="line-modified">!       emit_int24(0x66, 0x66, 0x66);</span>
        addr_nop_8();
<span class="line-modified">!       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
      }
      switch (i) {
        case 14:
          emit_int8(0x66); // size prefix
        case 13:
          emit_int8(0x66); // size prefix
        case 12:
          addr_nop_8();
<span class="line-modified">!         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
          break;
        case 11:
          emit_int8(0x66); // size prefix
        case 10:
          emit_int8(0x66); // size prefix
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3214,13 ***</span>
      // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
      //     Size prefixes (0x66) are added for larger sizes
  
      while(i &gt;= 22) {
        i -= 11;
<span class="line-modified">!       emit_int8(0x66); // size prefix</span>
<span class="line-removed">-       emit_int8(0x66); // size prefix</span>
<span class="line-removed">-       emit_int8(0x66); // size prefix</span>
        addr_nop_8();
      }
      // Generate first nop for size between 21-12
      switch (i) {
        case 21:
<span class="line-new-header">--- 3072,11 ---</span>
      // 16: 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00
      //     Size prefixes (0x66) are added for larger sizes
  
      while(i &gt;= 22) {
        i -= 11;
<span class="line-modified">!       emit_int24(0x66, 0x66, 0x66);</span>
        addr_nop_8();
      }
      // Generate first nop for size between 21-12
      switch (i) {
        case 21:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3313,32 ***</span>
      // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
  
      while (i &gt;= 15) {
        // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
        i -= 15;
<span class="line-modified">!       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
        addr_nop_8();
<span class="line-modified">!       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8(0x66);   // size prefix</span>
<span class="line-removed">-       emit_int8((unsigned char)0x90);</span>
<span class="line-removed">-                          // nop</span>
      }
      switch (i) {
        case 14:
          emit_int8(0x66); // size prefix
        case 13:
          emit_int8(0x66); // size prefix
        case 12:
          addr_nop_8();
<span class="line-modified">!         emit_int8(0x66); // size prefix</span>
<span class="line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="line-removed">-         emit_int8(0x66); // size prefix</span>
<span class="line-removed">-         emit_int8((unsigned char)0x90);</span>
<span class="line-removed">-                          // nop</span>
          break;
        case 11:
          emit_int8(0x66); // size prefix
        case 10:
          emit_int8(0x66); // size prefix
<span class="line-new-header">--- 3169,22 ---</span>
      // 15: 0x66 0x66 0x66 0x0F 0x1F 0x84 0x00 0x00 0x00 0x00 0x00 0x66 0x66 0x66 0x90
  
      while (i &gt;= 15) {
        // For ZX don&#39;t generate consecutive addess nops (mix with regular nops)
        i -= 15;
<span class="line-modified">!       emit_int24(0x66, 0x66, 0x66);</span>
        addr_nop_8();
<span class="line-modified">!       emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
      }
      switch (i) {
        case 14:
          emit_int8(0x66); // size prefix
        case 13:
          emit_int8(0x66); // size prefix
        case 12:
          addr_nop_8();
<span class="line-modified">!         emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
          break;
        case 11:
          emit_int8(0x66); // size prefix
        case 10:
          emit_int8(0x66); // size prefix
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3384,39 ***</span>
    //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
    //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
    //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
    // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
    //
<span class="line-modified">!   while(i &gt; 12) {</span>
      i -= 4;
<span class="line-modified">!     emit_int8(0x66); // size prefix</span>
<span class="line-removed">-     emit_int8(0x66);</span>
<span class="line-removed">-     emit_int8(0x66);</span>
<span class="line-removed">-     emit_int8((unsigned char)0x90);</span>
<span class="line-removed">-                      // nop</span>
    }
    // 1 - 12 nops
<span class="line-modified">!   if(i &gt; 8) {</span>
<span class="line-modified">!     if(i &gt; 9) {</span>
        i -= 1;
        emit_int8(0x66);
      }
      i -= 3;
<span class="line-modified">!     emit_int8(0x66);</span>
<span class="line-removed">-     emit_int8(0x66);</span>
<span class="line-removed">-     emit_int8((unsigned char)0x90);</span>
    }
    // 1 - 8 nops
<span class="line-modified">!   if(i &gt; 4) {</span>
<span class="line-modified">!     if(i &gt; 6) {</span>
        i -= 1;
        emit_int8(0x66);
      }
      i -= 3;
<span class="line-modified">!     emit_int8(0x66);</span>
<span class="line-removed">-     emit_int8(0x66);</span>
<span class="line-removed">-     emit_int8((unsigned char)0x90);</span>
    }
    switch (i) {
      case 4:
        emit_int8(0x66);
      case 3:
<span class="line-new-header">--- 3230,31 ---</span>
    //  7: 0x66 0x66 0x66 0x90 0x66 0x66 0x90
    //  8: 0x66 0x66 0x66 0x90 0x66 0x66 0x66 0x90
    //  9: 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
    // 10: 0x66 0x66 0x66 0x90 0x66 0x66 0x90 0x66 0x66 0x90
    //
<span class="line-modified">!   while (i &gt; 12) {</span>
      i -= 4;
<span class="line-modified">!     emit_int32(0x66, 0x66, 0x66, (unsigned char)0x90);</span>
    }
    // 1 - 12 nops
<span class="line-modified">!   if (i &gt; 8) {</span>
<span class="line-modified">!     if (i &gt; 9) {</span>
        i -= 1;
        emit_int8(0x66);
      }
      i -= 3;
<span class="line-modified">!     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>
    }
    // 1 - 8 nops
<span class="line-modified">!   if (i &gt; 4) {</span>
<span class="line-modified">!     if (i &gt; 6) {</span>
        i -= 1;
        emit_int8(0x66);
      }
      i -= 3;
<span class="line-modified">!     emit_int24(0x66, 0x66, (unsigned char)0x90);</span>
    }
    switch (i) {
      case 4:
        emit_int8(0x66);
      case 3:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3431,12 ***</span>
    }
  }
  
  void Assembler::notl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xD0 | encode));</span>
  }
  
  void Assembler::orl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
<span class="line-new-header">--- 3269,11 ---</span>
    }
  }
  
  void Assembler::notl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>
  }
  
  void Assembler::orl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3488,76 ***</span>
  
  void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x67);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x67);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x00);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x36);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x46);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x06);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x76);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::pause() {
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x90);</span>
  }
  
  void Assembler::ud2() {
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x0B);</span>
  }
  
  void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3325,64 ---</span>
  
  void Assembler::packuswb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x67, (0xC0 | encode));</span>
  }
  
  void Assembler::vpackuswb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;some form of AVX must be enabled&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x67, (0xC0 | encode));</span>
  }
  
  void Assembler::vpermq(XMMRegister dst, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x00, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::vpermq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512F&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x36, (0xC0 | encode));</span>
  }
  
  void Assembler::vperm2i128(XMMRegister dst,  XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x46, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::vperm2f128(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x06, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::evpermi2q(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  
  void Assembler::pause() {
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (unsigned char)0x90);</span>
  }
  
  void Assembler::ud2() {
<span class="line-modified">!   emit_int16(0x0F, 0x0B);</span>
  }
  
  void Assembler::pcmpestri(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3570,41 ***</span>
  
  void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x61);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x74);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x74);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x74);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3395,36 ---</span>
  
  void Assembler::pcmpestri(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x61, (0xC0 | encode), imm8);</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x74, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x74, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqb(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x74, (0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpgtb(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3634,25 ***</span>
  void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x3E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(vcc);</span>
  }
  
  void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
    attributes.reset_is_clear_context();
    attributes.set_embedded_opmask_register_specifier(mask);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x3E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(vcc);</span>
  }
  
  void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3454,21 ---</span>
  void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x3E, (0xC0 | encode), vcc);</span>
  }
  
  void Assembler::evpcmpuw(KRegister kdst, KRegister mask, XMMRegister nds, XMMRegister src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ false, /* uses_vl */ true);
    attributes.reset_is_clear_context();
    attributes.set_embedded_opmask_register_specifier(mask);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x3E, (0xC0 | encode), vcc);</span>
  }
  
  void Assembler::evpcmpuw(KRegister kdst, XMMRegister nds, Address src, ComparisonPredicate vcc, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3694,31 ***</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x75);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x75);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x75);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3510,28 ---</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x75, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x75, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x75, (0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpeqw(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3734,32 ***</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x76);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x76);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    attributes.reset_is_clear_context();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x76);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3547,29 ---</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    attributes.reset_is_clear_context();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x76, (0xC0 | encode));</span>
  }
  
  void Assembler::evpcmpeqd(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3776,32 ***</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x29);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x29);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.reset_is_clear_context();
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x29);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-new-header">--- 3586,29 ---</span>
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::pcmpeqq(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x29, (0xC0 | encode));</span>
  }
  
  // In this context, the dst vector contains the components that are equal, non equal components are zeroed in dst
  void Assembler::vpcmpeqq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x29, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.reset_is_clear_context();
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(kdst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x29, (0xC0 | encode));</span>
  }
  
  // In this context, kdst is written the mask used to process the equal components
  void Assembler::evpcmpeqq(KRegister kdst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3818,29 ***</span>
  
  void Assembler::pmovmskb(Register dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmovmskb(Register dst, XMMRegister src) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x16);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
<span class="line-new-header">--- 3625,25 ---</span>
  
  void Assembler::pmovmskb(Register dst, XMMRegister src) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovmskb(Register dst, XMMRegister src) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD7, (0xC0 | encode));</span>
  }
  
  void Assembler::pextrd(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x16, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pextrd(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3853,13 ***</span>
  
  void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x16);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
<span class="line-new-header">--- 3656,11 ---</span>
  
  void Assembler::pextrq(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x16, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pextrq(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3872,21 ***</span>
  
  void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xC5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
    simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x15);</span>
    emit_operand(src, dst);
    emit_int8(imm8);
  }
  
  void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
<span class="line-new-header">--- 3673,19 ---</span>
  
  void Assembler::pextrw(Register dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0xC5, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pextrw(Address dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_16bit);
    simd_prefix(src, xnoreg, dst, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x15);</span>
    emit_operand(src, dst);
    emit_int8(imm8);
  }
  
  void Assembler::pextrb(Address dst, XMMRegister src, int imm8) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3901,13 ***</span>
  
  void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x22);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
<span class="line-new-header">--- 3700,11 ---</span>
  
  void Assembler::pinsrd(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x22, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pinsrd(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3920,13 ***</span>
  
  void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x22);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
<span class="line-new-header">--- 3717,11 ---</span>
  
  void Assembler::pinsrq(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x22, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pinsrq(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3939,13 ***</span>
  
  void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xC4);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
<span class="line-new-header">--- 3734,11 ---</span>
  
  void Assembler::pinsrw(XMMRegister dst, Register src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0xC4, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pinsrw(XMMRegister dst, Address src, int imm8) {
    assert(VM_Version::supports_sse2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3978,20 ***</span>
  
  void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x30);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x20);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3771,18 ---</span>
  
  void Assembler::pmovzxbw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x30, (0xC0 | encode));</span>
  }
  
  void Assembler::pmovsxbw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x20, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovzxbw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4007,22 ***</span>
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x30);</span>
<span class="line-removed">-   emit_int8((unsigned char) (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x20);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 3798,20 ---</span>
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x30, (unsigned char) (0xC0 | encode));</span>
  }
  
  void Assembler::vpmovsxbw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x20, (0xC0 | encode));</span>
  }
  
  void Assembler::evpmovzxbw(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_avx512vlbw(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4077,40 ***</span>
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x33);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
      (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
      (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-modified">!   assert(VM_Version::supports_vnni(), &quot;must support vnni&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x52);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // generic
  void Assembler::pop(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-new-header">--- 3866,36 ---</span>
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
    vector_len == AVX_256bit? VM_Version::supports_avx2() :
    vector_len == AVX_512bit? VM_Version::supports_evex() : 0, &quot; &quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x33, (0xC0 | encode));</span>
  }
  
  void Assembler::pmaddwd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmaddwd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
      (vector_len == AVX_256bit ? VM_Version::supports_avx2() :
      (vector_len == AVX_512bit ? VM_Version::supports_evex() : 0)), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF5, (0xC0 | encode));</span>
  }
  
  void Assembler::evpdpwssd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
<span class="line-modified">!   assert(VM_Version::supports_avx512_vnni(), &quot;must support vnni&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x52, (0xC0 | encode));</span>
  }
  
  // generic
  void Assembler::pop(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4120,31 ***</span>
  void Assembler::popcntl(Register dst, Address src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    InstructionMark im(this);
    emit_int8((unsigned char)0xF3);
    prefix(src, dst);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB8);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::popcntl(Register dst, Register src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x55);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::popf() {
    emit_int8((unsigned char)0x9D);
  }
<span class="line-new-header">--- 3905,27 ---</span>
  void Assembler::popcntl(Register dst, Address src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    InstructionMark im(this);
    emit_int8((unsigned char)0xF3);
    prefix(src, dst);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xB8);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::popcntl(Register dst, Register src) {
    assert(VM_Version::supports_popcnt(), &quot;must support&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>
  }
  
  void Assembler::vpopcntd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vpopcntdq(), &quot;must support vpopcntdq feature&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x55, (0xC0 | encode));</span>
  }
  
  void Assembler::popf() {
    emit_int8((unsigned char)0x9D);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4157,60 ***</span>
    emit_int8((unsigned char)0x8F);
    emit_operand(rax, dst);
  }
  #endif
  
<span class="line-removed">- void Assembler::prefetch_prefix(Address src) {</span>
<span class="line-removed">-   prefix(src);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Assembler::prefetchnta(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefetch_prefix(src);</span>
<span class="line-modified">!   emit_int8(0x18);</span>
    emit_operand(rax, src); // 0, src
  }
  
  void Assembler::prefetchr(Address src) {
    assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefetch_prefix(src);</span>
<span class="line-modified">!   emit_int8(0x0D);</span>
    emit_operand(rax, src); // 0, src
  }
  
  void Assembler::prefetcht0(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefetch_prefix(src);</span>
<span class="line-modified">!   emit_int8(0x18);</span>
    emit_operand(rcx, src); // 1, src
  }
  
  void Assembler::prefetcht1(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefetch_prefix(src);</span>
<span class="line-modified">!   emit_int8(0x18);</span>
    emit_operand(rdx, src); // 2, src
  }
  
  void Assembler::prefetcht2(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefetch_prefix(src);</span>
<span class="line-modified">!   emit_int8(0x18);</span>
    emit_operand(rbx, src); // 3, src
  }
  
  void Assembler::prefetchw(Address src) {
    assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefetch_prefix(src);</span>
<span class="line-modified">!   emit_int8(0x0D);</span>
    emit_operand(rcx, src); // 1, src
  }
  
  void Assembler::prefix(Prefix p) {
    emit_int8(p);
<span class="line-new-header">--- 3938,55 ---</span>
    emit_int8((unsigned char)0x8F);
    emit_operand(rax, dst);
  }
  #endif
  
  void Assembler::prefetchnta(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefix(src);</span>
<span class="line-modified">!   emit_int16(0x0F, 0x18);</span>
    emit_operand(rax, src); // 0, src
  }
  
  void Assembler::prefetchr(Address src) {
    assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefix(src);</span>
<span class="line-modified">!   emit_int16(0x0F, 0x0D);</span>
    emit_operand(rax, src); // 0, src
  }
  
  void Assembler::prefetcht0(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefix(src);</span>
<span class="line-modified">!   emit_int16(0x0F, 0x18);</span>
    emit_operand(rcx, src); // 1, src
  }
  
  void Assembler::prefetcht1(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefix(src);</span>
<span class="line-modified">!   emit_int16(0x0F, 0x18);</span>
    emit_operand(rdx, src); // 2, src
  }
  
  void Assembler::prefetcht2(Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;must support&quot;));
    InstructionMark im(this);
<span class="line-modified">!   prefix(src);</span>
<span class="line-modified">!   emit_int16(0x0F, 0x18);</span>
    emit_operand(rbx, src); // 3, src
  }
  
  void Assembler::prefetchw(Address src) {
    assert(VM_Version::supports_3dnow_prefetch(), &quot;must support&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefix(src);</span>
<span class="line-modified">!   emit_int16(0x0F, 0x0D);</span>
    emit_operand(rcx, src); // 1, src
  }
  
  void Assembler::prefix(Prefix p) {
    emit_int8(p);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4218,22 ***</span>
  
  void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x00);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
           vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x00);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pshufb(XMMRegister dst, Address src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 3994,20 ---</span>
  
  void Assembler::pshufb(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x00, (0xC0 | encode));</span>
  }
  
  void Assembler::vpshufb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
           vector_len == AVX_512bit? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x00, (0xC0 | encode));</span>
  }
  
  void Assembler::pshufb(XMMRegister dst, Address src) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4248,25 ***</span>
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x70);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(mode &amp; 0xFF);</span>
  }
  
  void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           (vector_len == AVX_256bit? VM_Version::supports_avx2() :
           (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x70);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(mode &amp; 0xFF);</span>
  }
  
  void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
<span class="line-new-header">--- 4022,21 ---</span>
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    int vector_len = VM_Version::supports_avx512novl() ? AVX_512bit : AVX_128bit;
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>
  }
  
  void Assembler::vpshufd(XMMRegister dst, XMMRegister src, int mode, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           (vector_len == AVX_256bit? VM_Version::supports_avx2() :
           (vector_len == AVX_512bit? VM_Version::supports_evex() : 0)), &quot;&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>
  }
  
  void Assembler::pshufd(XMMRegister dst, Address src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4283,13 ***</span>
  void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x70);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(mode &amp; 0xFF);</span>
  }
  
  void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
<span class="line-new-header">--- 4053,11 ---</span>
  void Assembler::pshuflw(XMMRegister dst, XMMRegister src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x70, (0xC0 | encode), mode &amp; 0xFF);</span>
  }
  
  void Assembler::pshuflw(XMMRegister dst, Address src, int mode) {
    assert(isByte(mode), &quot;invalid value&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4307,56 ***</span>
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x43);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8 &amp; 0xFF);</span>
  }
  
  void Assembler::psrldq(XMMRegister dst, int shift) {
    // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift);</span>
  }
  
  void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
           vector_len == AVX_256bit ? VM_Version::supports_avx2() :
           vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::pslldq(XMMRegister dst, int shift) {
    // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM7 is for /7 encoding: 66 0F 73 /7 ib
    int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift);</span>
  }
  
  void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
           vector_len == AVX_256bit ? VM_Version::supports_avx2() :
           vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::ptest(XMMRegister dst, Address src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
<span class="line-new-header">--- 4075,46 ---</span>
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(vector_len == Assembler::AVX_256bit || vector_len == Assembler::AVX_512bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x43, (0xC0 | encode), imm8 &amp; 0xFF);</span>
  }
  
  void Assembler::psrldq(XMMRegister dst, int shift) {
    // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(xmm3, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift);</span>
  }
  
  void Assembler::vpsrldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
           vector_len == AVX_256bit ? VM_Version::supports_avx2() :
           vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(xmm3-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::pslldq(XMMRegister dst, int shift) {
    // Shift left 128 bit value in dst XMMRegister by shift number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM7 is for /7 encoding: 66 0F 73 /7 ib
    int encode = simd_prefix_and_encode(xmm7, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift);</span>
  }
  
  void Assembler::vpslldq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(vector_len == AVX_128bit ? VM_Version::supports_avx() :
           vector_len == AVX_256bit ? VM_Version::supports_avx2() :
           vector_len == AVX_512bit ? VM_Version::supports_avx512bw() : 0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /*vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(xmm7-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::ptest(XMMRegister dst, Address src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4370,11 ***</span>
  void Assembler::ptest(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x17);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vptest(XMMRegister dst, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4128,11 ---</span>
  void Assembler::ptest(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1() || VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x17);
<span class="line-modified">!   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::vptest(XMMRegister dst, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4388,12 ***</span>
  
  void Assembler::vptest(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x17);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::punpcklbw(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
<span class="line-new-header">--- 4146,11 ---</span>
  
  void Assembler::vptest(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_256bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x17, (0xC0 | encode));</span>
  }
  
  void Assembler::punpcklbw(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4407,12 ***</span>
  
  void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x60);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::punpckldq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
<span class="line-new-header">--- 4164,11 ---</span>
  
  void Assembler::punpcklbw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_vlbw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x60, (0xC0 | encode));</span>
  }
  
  void Assembler::punpckldq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    assert((UseAVX &gt; 0), &quot;SSE mode requires address alignment 16 bytes&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4426,21 ***</span>
  
  void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x62);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::push(int32_t imm32) {
    // in 64bits we push 64bits onto the stack but only
    // take a 32bit immediate
<span class="line-new-header">--- 4182,19 ---</span>
  
  void Assembler::punpckldq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x62, (0xC0 | encode));</span>
  }
  
  void Assembler::punpcklqdq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6C, (0xC0 | encode));</span>
  }
  
  void Assembler::push(int32_t imm32) {
    // in 64bits we push 64bits onto the stack but only
    // take a 32bit immediate
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4448,11 ***</span>
    emit_int32(imm32);
  }
  
  void Assembler::push(Register src) {
    int encode = prefix_and_encode(src-&gt;encoding());
<span class="line-removed">- </span>
    emit_int8(0x50 | encode);
  }
  
  void Assembler::pushf() {
    emit_int8((unsigned char)0x9C);
<span class="line-new-header">--- 4202,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4470,80 ***</span>
  
  void Assembler::rcll(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xD0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)0xD0 | encode);</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x53);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x53);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::rdtsc() {
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x31);</span>
  }
  
  // copies data from [esi] to [edi] using rcx pointer sized words
  // generic
  void Assembler::rep_mov() {
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
    // MOVSQ
<span class="line-modified">!   LP64_ONLY(prefix(REX_W));</span>
<span class="line-modified">!   emit_int8((unsigned char)0xA5);</span>
  }
  
  // sets rcx bytes with rax, value at [edi]
  void Assembler::rep_stosb() {
<span class="line-modified">!   emit_int8((unsigned char)0xF3); // REP</span>
<span class="line-modified">!   LP64_ONLY(prefix(REX_W));</span>
<span class="line-modified">!   emit_int8((unsigned char)0xAA); // STOSB</span>
  }
  
  // sets rcx pointer sized words with rax, value at [edi]
  // generic
  void Assembler::rep_stos() {
<span class="line-modified">!   emit_int8((unsigned char)0xF3); // REP</span>
<span class="line-modified">!   LP64_ONLY(prefix(REX_W));       // LP64:STOSQ, LP32:STOSD</span>
<span class="line-modified">!   emit_int8((unsigned char)0xAB);</span>
  }
  
  // scans rcx pointer sized words at [edi] for occurance of rax,
  // generic
  void Assembler::repne_scan() { // repne_scan
<span class="line-removed">-   emit_int8((unsigned char)0xF2);</span>
    // SCASQ
<span class="line-modified">!   LP64_ONLY(prefix(REX_W));</span>
<span class="line-modified">!   emit_int8((unsigned char)0xAF);</span>
  }
  
  #ifdef _LP64
  // scans rcx 4 byte words at [edi] for occurance of rax,
  // generic
  void Assembler::repne_scanl() { // repne_scan
<span class="line-removed">-   emit_int8((unsigned char)0xF2);</span>
    // SCASL
<span class="line-modified">!   emit_int8((unsigned char)0xAF);</span>
  }
  #endif
  
  void Assembler::ret(int imm16) {
    if (imm16 == 0) {
<span class="line-new-header">--- 4223,74 ---</span>
  
  void Assembler::rcll(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>
    }
  }
  
  void Assembler::rcpps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x53, (0xC0 | encode));</span>
  }
  
  void Assembler::rcpss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x53, (0xC0 | encode));</span>
  }
  
  void Assembler::rdtsc() {
<span class="line-modified">!   emit_int16(0x0F, 0x31);</span>
  }
  
  // copies data from [esi] to [edi] using rcx pointer sized words
  // generic
  void Assembler::rep_mov() {
<span class="line-modified">!   // REP</span>
    // MOVSQ
<span class="line-modified">!   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xA5);)</span>
<span class="line-modified">!   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xA5);)</span>
  }
  
  // sets rcx bytes with rax, value at [edi]
  void Assembler::rep_stosb() {
<span class="line-modified">!   // REP</span>
<span class="line-modified">!   // STOSB</span>
<span class="line-modified">!   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAA);)</span>
<span class="line-added">+   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAA);)</span>
  }
  
  // sets rcx pointer sized words with rax, value at [edi]
  // generic
  void Assembler::rep_stos() {
<span class="line-modified">!   // REP</span>
<span class="line-modified">!   // LP64:STOSQ, LP32:STOSD</span>
<span class="line-modified">!   LP64_ONLY(emit_int24((unsigned char)0xF3, REX_W, (unsigned char)0xAB);)</span>
<span class="line-added">+   NOT_LP64( emit_int16((unsigned char)0xF3,        (unsigned char)0xAB);)</span>
  }
  
  // scans rcx pointer sized words at [edi] for occurance of rax,
  // generic
  void Assembler::repne_scan() { // repne_scan
    // SCASQ
<span class="line-modified">!   LP64_ONLY(emit_int24((unsigned char)0xF2, REX_W, (unsigned char)0xAF);)</span>
<span class="line-modified">!   NOT_LP64( emit_int16((unsigned char)0xF2,        (unsigned char)0xAF);)</span>
  }
  
  #ifdef _LP64
  // scans rcx 4 byte words at [edi] for occurance of rax,
  // generic
  void Assembler::repne_scanl() { // repne_scan
    // SCASL
<span class="line-modified">!   emit_int16((unsigned char)0xF2, (unsigned char)0xAF);</span>
  }
  #endif
  
  void Assembler::ret(int imm16) {
    if (imm16 == 0) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4564,23 ***</span>
  
  void Assembler::sarl(Register dst, int imm8) {
    int encode = prefix_and_encode(dst-&gt;encoding());
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::sarl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
  }
  
  void Assembler::sbbl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
<span class="line-new-header">--- 4311,19 ---</span>
  
  void Assembler::sarl(Register dst, int imm8) {
    int encode = prefix_and_encode(dst-&gt;encoding());
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>
    }
  }
  
  void Assembler::sarl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>
  }
  
  void Assembler::sbbl(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefix(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4606,167 ***</span>
  }
  
  void Assembler::setb(Condition cc, Register dst) {
    assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x90 | cc);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
           0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x0E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xCC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)imm8);</span>
  }
  
  void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xC8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xC9);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xCA);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // xmm0 is implicit additional source to this instruction.
  void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xCB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xCC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int8((unsigned char)0xCD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::shll(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
    if (imm8 == 1 ) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::shll(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
  }
  
  void Assembler::shrl(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::shrl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
  }
  
  void Assembler::shldl(Register dst, Register src) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xA5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::shldl(Register dst, Register src, int8_t imm8) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xA4);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::shrdl(Register dst, Register src) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  // copies a single word from [esi] to [edi]
  void Assembler::smovl() {
    emit_int8((unsigned char)0xA5);
<span class="line-new-header">--- 4349,132 ---</span>
  }
  
  void Assembler::setb(Condition cc, Register dst) {
    assert(0 &lt;= cc &amp;&amp; cc &lt; 16, &quot;illegal cc&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0x90 | cc, (0xC0 | encode));</span>
  }
  
  void Assembler::palignr(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_ssse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x0F, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::vpalignr(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(vector_len == AVX_128bit? VM_Version::supports_avx() :
           vector_len == AVX_256bit? VM_Version::supports_avx2() :
           0, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x0F, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::evalignq(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x3, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::pblendw(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x0E, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::sha1rnds4(XMMRegister dst, XMMRegister src, int imm8) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_3A, /* rex_w */ false);
<span class="line-modified">!   emit_int24((unsigned char)0xCC, (0xC0 | encode), (unsigned char)imm8);</span>
  }
  
  void Assembler::sha1nexte(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int16((unsigned char)0xC8, (0xC0 | encode));</span>
  }
  
  void Assembler::sha1msg1(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int16((unsigned char)0xC9, (0xC0 | encode));</span>
  }
  
  void Assembler::sha1msg2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int16((unsigned char)0xCA, (0xC0 | encode));</span>
  }
  
  // xmm0 is implicit additional source to this instruction.
  void Assembler::sha256rnds2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int16((unsigned char)0xCB, (0xC0 | encode));</span>
  }
  
  void Assembler::sha256msg1(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int16((unsigned char)0xCC, (0xC0 | encode));</span>
  }
  
  void Assembler::sha256msg2(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sha(), &quot;&quot;);
    int encode = rex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, /* rex_w */ false);
<span class="line-modified">!   emit_int16((unsigned char)0xCD, (0xC0 | encode));</span>
  }
  
  
  void Assembler::shll(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
    if (imm8 == 1 ) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>
    }
  }
  
  void Assembler::shll(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>
  }
  
  void Assembler::shrl(Register dst, int imm8) {
    assert(isShiftCount(imm8), &quot;illegal shift count&quot;);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>
  }
  
  void Assembler::shrl(Register dst) {
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xE8 | encode));</span>
  }
  
  void Assembler::shldl(Register dst, Register src) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xA5, (0xC0 | encode));</span>
  }
  
  void Assembler::shldl(Register dst, Register src, int8_t imm8) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int32(0x0F, (unsigned char)0xA4, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::shrdl(Register dst, Register src) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xAD, (0xC0 | encode));</span>
  }
  
  void Assembler::shrdl(Register dst, Register src, int8_t imm8) {
    int encode = prefix_and_encode(src-&gt;encoding(), dst-&gt;encoding());
<span class="line-modified">!   emit_int32(0x0F, (unsigned char)0xAC, (0xC0 | encode), imm8);</span>
  }
  
  // copies a single word from [esi] to [edi]
  void Assembler::smovl() {
    emit_int8((unsigned char)0xA5);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4774,13 ***</span>
  
  void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x0B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)rmode);</span>
  }
  
  void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4482,11 ---</span>
  
  void Assembler::roundsd(XMMRegister dst, XMMRegister src, int32_t rmode) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x0B, (0xC0 | encode), (unsigned char)rmode);</span>
  }
  
  void Assembler::roundsd(XMMRegister dst, Address src, int32_t rmode) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4794,12 ***</span>
  void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x51);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::sqrtsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 4500,11 ---</span>
  void Assembler::sqrtsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::sqrtsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4813,12 ***</span>
  
  void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x51);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::std() {
    emit_int8((unsigned char)0xFD);
  }
<span class="line-new-header">--- 4518,11 ---</span>
  
  void Assembler::sqrtss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::std() {
    emit_int8((unsigned char)0xFD);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4843,12 ***</span>
      emit_operand(as_Register(3), dst);
    } else {
      NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
      InstructionMark im(this);
      prefix(dst);
<span class="line-modified">!     emit_int8(0x0F);</span>
<span class="line-removed">-     emit_int8((unsigned char)0xAE);</span>
      emit_operand(as_Register(3), dst);
    }
  }
  
  void Assembler::subl(Address dst, int32_t imm32) {
<span class="line-new-header">--- 4547,11 ---</span>
      emit_operand(as_Register(3), dst);
    } else {
      NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
      InstructionMark im(this);
      prefix(dst);
<span class="line-modified">!     emit_int16(0x0F, (unsigned char)0xAE);</span>
      emit_operand(as_Register(3), dst);
    }
  }
  
  void Assembler::subl(Address dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4890,12 ***</span>
  void Assembler::subsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::subsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 4593,11 ---</span>
  void Assembler::subsd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::subsd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4909,12 ***</span>
  
  void Assembler::subss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::subss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 4611,11 ---</span>
  
  void Assembler::subss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true , /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::subss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4946,12 ***</span>
    int encode = dst-&gt;encoding();
    if (encode == 0) {
      emit_int8((unsigned char)0xA9);
    } else {
      encode = prefix_and_encode(encode);
<span class="line-modified">!     emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
    }
    emit_int32(imm32);
  }
  
  void Assembler::testl(Register dst, Register src) {
<span class="line-new-header">--- 4647,11 ---</span>
    int encode = dst-&gt;encoding();
    if (encode == 0) {
      emit_int8((unsigned char)0xA9);
    } else {
      encode = prefix_and_encode(encode);
<span class="line-modified">!     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
    }
    emit_int32(imm32);
  }
  
  void Assembler::testl(Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4968,22 ***</span>
  
  void Assembler::tzcntl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBC);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xC0 | encode);</span>
  }
  
  void Assembler::tzcntq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::ucomisd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 4668,20 ---</span>
  
  void Assembler::tzcntl(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBC,</span>
<span class="line-modified">!              0xC0 | encode);</span>
  }
  
  void Assembler::tzcntq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;tzcnt instruction not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>
  }
  
  void Assembler::ucomisd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4998,12 ***</span>
  void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::ucomiss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 4696,11 ---</span>
  void Assembler::ucomisd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2E, (0xC0 | encode));</span>
  }
  
  void Assembler::ucomiss(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5016,59 ***</span>
  
  void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::xabort(int8_t imm8) {
<span class="line-modified">!   emit_int8((unsigned char)0xC6);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(imm8 &amp; 0xFF));</span>
  }
  
  void Assembler::xaddb(Address dst, Register src) {
    InstructionMark im(this);
    prefix(dst, src, true);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xC0);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xaddw(Address dst, Register src) {
    InstructionMark im(this);
    emit_int8(0x66);
    prefix(dst, src);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xaddl(Address dst, Register src) {
    InstructionMark im(this);
    prefix(dst, src);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
    InstructionMark im(this);
    relocate(rtype);
    if (abort.is_bound()) {
      address entry = target(abort);
      assert(entry != NULL, &quot;abort entry NULL&quot;);
      intptr_t offset = entry - pc();
<span class="line-modified">!     emit_int8((unsigned char)0xC7);</span>
<span class="line-removed">-     emit_int8((unsigned char)0xF8);</span>
      emit_int32(offset - 6); // 2 opcode + 4 address
    } else {
      abort.add_patch_at(code(), locator());
<span class="line-modified">!     emit_int8((unsigned char)0xC7);</span>
<span class="line-removed">-     emit_int8((unsigned char)0xF8);</span>
      emit_int32(0);
    }
  }
  
  void Assembler::xchgb(Register dst, Address src) { // xchg
<span class="line-new-header">--- 4713,51 ---</span>
  
  void Assembler::ucomiss(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2E, (0xC0 | encode));</span>
  }
  
  void Assembler::xabort(int8_t imm8) {
<span class="line-modified">!   emit_int24((unsigned char)0xC6, (unsigned char)0xF8, (imm8 &amp; 0xFF));</span>
  }
  
  void Assembler::xaddb(Address dst, Register src) {
    InstructionMark im(this);
    prefix(dst, src, true);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xC0);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xaddw(Address dst, Register src) {
    InstructionMark im(this);
    emit_int8(0x66);
    prefix(dst, src);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xaddl(Address dst, Register src) {
    InstructionMark im(this);
    prefix(dst, src);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xbegin(Label&amp; abort, relocInfo::relocType rtype) {
    InstructionMark im(this);
    relocate(rtype);
    if (abort.is_bound()) {
      address entry = target(abort);
      assert(entry != NULL, &quot;abort entry NULL&quot;);
      intptr_t offset = entry - pc();
<span class="line-modified">!     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>
      emit_int32(offset - 6); // 2 opcode + 4 address
    } else {
      abort.add_patch_at(code(), locator());
<span class="line-modified">!     emit_int16((unsigned char)0xC7, (unsigned char)0xF8);</span>
      emit_int32(0);
    }
  }
  
  void Assembler::xchgb(Register dst, Address src) { // xchg
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5093,24 ***</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xchgl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x87);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::xend() {
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x01);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xD5);</span>
  }
  
  void Assembler::xgetbv() {
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x01);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xD0);</span>
  }
  
  void Assembler::xorl(Register dst, int32_t imm32) {
    prefix(dst);
    emit_arith(0x81, 0xF0, dst, imm32);
<span class="line-new-header">--- 4782,19 ---</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xchgl(Register dst, Register src) {
    int encode = prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0x87, (0xC0 | encode));</span>
  }
  
  void Assembler::xend() {
<span class="line-modified">!   emit_int24(0x0F, 0x01, (unsigned char)0xD5);</span>
  }
  
  void Assembler::xgetbv() {
<span class="line-modified">!   emit_int24(0x0F, 0x01, (unsigned char)0xD0);</span>
  }
  
  void Assembler::xorl(Register dst, int32_t imm32) {
    prefix(dst);
    emit_arith(0x81, 0xF0, dst, imm32);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5151,12 ***</span>
  void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4835,11 ---</span>
  void Assembler::vaddsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5169,12 ***</span>
  
  void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4852,11 ---</span>
  
  void Assembler::vaddss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5189,12 ***</span>
  void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4871,11 ---</span>
  void Assembler::vdivsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5207,28 ***</span>
  
  void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xB9);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xB9);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4888,25 ---</span>
  
  void Assembler::vdivss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231sd(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231ss(XMMRegister dst, XMMRegister src1, XMMRegister src2) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xB9, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5243,12 ***</span>
  void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4921,11 ---</span>
  void Assembler::vmulsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5261,12 ***</span>
  
  void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4938,11 ---</span>
  
  void Assembler::vmulss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5281,12 ***</span>
  void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 4957,11 ---</span>
  void Assembler::vsubsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubss(XMMRegister dst, XMMRegister nds, Address src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5299,12 ***</span>
  
  void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  //====================VECTOR ARITHMETIC=====================================
  
  // Float-point vector arithmetic
<span class="line-new-header">--- 4974,11 ---</span>
  
  void Assembler::vsubss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  //====================VECTOR ARITHMETIC=====================================
  
  // Float-point vector arithmetic
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5312,12 ***</span>
  void Assembler::addpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::addpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 4986,11 ---</span>
  void Assembler::addpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::addpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5332,29 ***</span>
  
  void Assembler::addps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5005,26 ---</span>
  
  void Assembler::addps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vaddpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5379,37 ***</span>
  void Assembler::subpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::subps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5049,33 ---</span>
  void Assembler::subpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::subps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5C, (0xC0 | encode));</span>
  }
  
  void Assembler::vsubpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5434,12 ***</span>
  void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::mulpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 5100,11 ---</span>
  void Assembler::mulpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::mulpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5453,29 ***</span>
  
  void Assembler::mulps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5118,26 ---</span>
  
  void Assembler::mulps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vmulpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5499,20 ***</span>
  
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5161,18 ---</span>
  
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231ps(XMMRegister dst, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xB8, (0xC0 | encode));</span>
  }
  
  void Assembler::vfmadd231pd(XMMRegister dst, XMMRegister src1, Address src2, int vector_len) {
    assert(VM_Version::supports_fma(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5536,37 ***</span>
  void Assembler::divpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::divps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5196,33 ---</span>
  void Assembler::divpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::divps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5E, (0xC0 | encode));</span>
  }
  
  void Assembler::vdivpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5590,56 ***</span>
  
  void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x09);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)(rmode));</span>
  }
  
  void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x09);
    emit_operand(dst, src);
<span class="line-modified">!   emit_int8((unsigned char)(rmode));</span>
  }
  
  void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x09);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)(rmode));</span>
  }
  
  void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x09);</span>
    emit_operand(dst, src);
<span class="line-modified">!   emit_int8((unsigned char)(rmode));</span>
  }
  
  
  void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x51);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5246,51 ---</span>
  
  void Assembler::vroundpd(XMMRegister dst, XMMRegister src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x09, (0xC0 | encode), (rmode));</span>
  }
  
  void Assembler::vroundpd(XMMRegister dst, Address src, int32_t rmode,  int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    emit_int8(0x09);
    emit_operand(dst, src);
<span class="line-modified">!   emit_int8((rmode));</span>
  }
  
  void Assembler::vrndscalepd(XMMRegister dst,  XMMRegister src,  int32_t rmode, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x09, (0xC0 | encode), (rmode));</span>
  }
  
  void Assembler::vrndscalepd(XMMRegister dst, Address src, int32_t rmode, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);
    vex_prefix(src, 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x09);</span>
    emit_operand(dst, src);
<span class="line-modified">!   emit_int8((rmode));</span>
  }
  
  
  void Assembler::vsqrtpd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::vsqrtpd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5653,12 ***</span>
  
  void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x51);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5304,11 ---</span>
  
  void Assembler::vsqrtps(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x51, (0xC0 | encode));</span>
  }
  
  void Assembler::vsqrtps(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5672,20 ***</span>
  void Assembler::andpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x54);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::andps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x54);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::andps(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 5322,18 ---</span>
  void Assembler::andpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::andps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::andps(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5710,20 ***</span>
  void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x54);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x54);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5358,18 ---</span>
  void Assembler::vandpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::vandps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x54, (0xC0 | encode));</span>
  }
  
  void Assembler::vandpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5749,37 ***</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x15);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x14);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x57);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::xorps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x57);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::xorpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 5395,34 ---</span>
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x15);
<span class="line-modified">!   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::unpcklpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x14, (0xC0 | encode));</span>
  }
  
  void Assembler::xorpd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::xorps(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::xorpd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5804,20 ***</span>
  void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x57);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x57);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5447,18 ---</span>
  void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ !_legacy_mode_dq, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::vxorps(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x57, (0xC0 | encode));</span>
  }
  
  void Assembler::vxorpd(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5843,45 ***</span>
  void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
           VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x01);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
           VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x02);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::paddb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::paddw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::paddd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFE);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::paddd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 5484,40 ---</span>
  void Assembler::vphaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
           VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x01, (0xC0 | encode));</span>
  }
  
  void Assembler::vphaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx() &amp;&amp; (vector_len == 0) ||
           VM_Version::supports_avx2(), &quot;256 bit integer vectors requires AVX2&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x02, (0xC0 | encode));</span>
  }
  
  void Assembler::paddb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>
  }
  
  void Assembler::paddw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>
  }
  
  void Assembler::paddd(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>
  }
  
  void Assembler::paddd(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5894,61 ***</span>
  void Assembler::paddq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD4);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x01);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x02);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFE);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD4);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5530,54 ---</span>
  void Assembler::paddq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>
  }
  
  void Assembler::phaddw(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x01, (0xC0 | encode));</span>
  }
  
  void Assembler::phaddd(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse3(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x02, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFC, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFD, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFE, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD4, (0xC0 | encode));</span>
  }
  
  void Assembler::vpaddb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5992,69 ***</span>
  
  void Assembler::psubb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psubw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF9);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psubd(XMMRegister dst, XMMRegister src) {
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFA);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psubq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xFB);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF9);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFA);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xFB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5621,62 ---</span>
  
  void Assembler::psubb(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>
  }
  
  void Assembler::psubw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>
  }
  
  void Assembler::psubd(XMMRegister dst, XMMRegister src) {
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>
  }
  
  void Assembler::psubq(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xFB);
<span class="line-modified">!   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF8, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF9, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubd(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFA, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xFB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsubb(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6098,45 ***</span>
  
  void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x40);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD5);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x40);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x40);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5720,40 ---</span>
  
  void Assembler::pmullw(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>
  }
  
  void Assembler::pmulld(XMMRegister dst, XMMRegister src) {
    assert(VM_Version::supports_sse4_1(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x40, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD5, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmulld(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x40, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmullq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires some form of EVEX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ _legacy_mode_dq, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x40, (0xC0 | encode));</span>
  }
  
  void Assembler::vpmullw(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6172,359 ***</span>
  void Assembler::psllw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 71 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x71);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::pslld(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 72 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x72);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::psllq(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 73 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 71 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x71);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 72 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x72);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM6 is for /6 encoding: 66 0F 73 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // Shift packed integers logically right by specified number of bits.
  void Assembler::psrlw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 71 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x71);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrld(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 72 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x72);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrlq(XMMRegister dst, int shift) {
    // Do not confuse it with psrldq SSE2 instruction which
    // shifts 128 bit value in xmm register by number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM2 is for /2 encoding: 66 0F 73 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 71 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x71);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 72 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x72);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM2 is for /2 encoding: 66 0F 73 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x10);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x12);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // Shift packed integers arithmetically right by specified number of bits.
  void Assembler::psraw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x71);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrad(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 72 /4 ib
    int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x72);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
    emit_int8(shift &amp; 0xFF);
  }
  
  void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x71);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x72);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
    assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x72);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(shift &amp; 0xFF);</span>
  }
  
  void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
    assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xE2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // logical operations packed integers
  void Assembler::pand(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 5789,306 ---</span>
  void Assembler::psllw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 71 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::pslld(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 72 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psllq(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 73 /6 ib
    int encode = simd_prefix_and_encode(xmm6, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psllw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>
  }
  
  void Assembler::pslld(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::psllq(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsllw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 71 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpslld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM6 is for /6 encoding: 66 0F 72 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsllq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM6 is for /6 encoding: 66 0F 73 /6 ib
    int encode = vex_prefix_and_encode(xmm6-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsllw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF1, (0xC0 | encode));</span>
  }
  
  void Assembler::vpslld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsllq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  // Shift packed integers logically right by specified number of bits.
  void Assembler::psrlw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 71 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrld(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 72 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrlq(XMMRegister dst, int shift) {
    // Do not confuse it with psrldq SSE2 instruction which
    // shifts 128 bit value in xmm register by number of bytes.
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM2 is for /2 encoding: 66 0F 73 /2 ib
    int encode = simd_prefix_and_encode(xmm2, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrlw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>
  }
  
  void Assembler::psrld(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>
  }
  
  void Assembler::psrlq(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 71 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrld(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM2 is for /2 encoding: 66 0F 72 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    // XMM2 is for /2 encoding: 66 0F 73 /2 ib
    int encode = vex_prefix_and_encode(xmm2-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x73, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrlw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD1, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrld(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD2, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrlq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xC0 | encode));</span>
  }
  
  void Assembler::evpsrlvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x10, (0xC0 | encode));</span>
  }
  
  void Assembler::evpsllvw(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x12, (0xC0 | encode));</span>
  }
  
  // Shift packed integers arithmetically right by specified number of bits.
  void Assembler::psraw(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::psrad(XMMRegister dst, int shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 72 /4 ib
    int encode = simd_prefix_and_encode(xmm4, dst, dst, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8(0x72);
<span class="line-modified">!   emit_int8((0xC0 | encode));</span>
    emit_int8(shift &amp; 0xFF);
  }
  
  void Assembler::psraw(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>
  }
  
  void Assembler::psrad(XMMRegister dst, XMMRegister shift) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, shift, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsraw(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x71, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsrad(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    // XMM4 is for /4 encoding: 66 0F 71 /4 ib
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24(0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::vpsraw(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE1, (0xC0 | encode));</span>
  }
  
  void Assembler::vpsrad(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>
  }
  
  void Assembler::evpsraq(XMMRegister dst, XMMRegister src, int shift, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
    assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(xmm4-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0x72, (0xC0 | encode), shift &amp; 0xFF);</span>
  }
  
  void Assembler::evpsraq(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
    assert(UseAVX &gt; 2, &quot;requires AVX512&quot;);
    assert ((VM_Version::supports_avx512vl() || vector_len == 2), &quot;requires AVX512vl&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xE2, (0xC0 | encode));</span>
  }
  
  // logical operations packed integers
  void Assembler::pand(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpand(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpand(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6537,64 ***</span>
  
  void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x71);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x73);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::pandn(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::por(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 6101,58 ---</span>
  
  void Assembler::vpandq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpshldvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
    emit_int8(0x71);
<span class="line-modified">!   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::vpshrdvd(XMMRegister dst, XMMRegister src, XMMRegister shift, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx512_vbmi2(), &quot;requires vbmi2&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src-&gt;encoding(), shift-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x73, (0xC0 | encode));</span>
  }
  
  void Assembler::pandn(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  void Assembler::vpandn(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xDF, (0xC0 | encode));</span>
  }
  
  
  void Assembler::por(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>
  }
  
  void Assembler::vpor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6607,29 ***</span>
  
  void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xEB);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  
  void Assembler::pxor(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xEF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xEF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 6165,26 ---</span>
  
  void Assembler::vporq(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xEB, (0xC0 | encode));</span>
  }
  
  
  void Assembler::pxor(XMMRegister dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>
  }
  
  void Assembler::vpxor(XMMRegister dst, XMMRegister nds, XMMRegister src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xEF, (0xC0 | encode));</span>
  }
  
  void Assembler::vpxor(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(UseAVX &gt; 0, &quot;requires some form of AVX&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6644,11 ***</span>
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xEF);
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6199,11 ---</span>
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xEF);
<span class="line-modified">!   emit_int8((0xC0 | encode));</span>
  }
  
  void Assembler::evpxorq(XMMRegister dst, XMMRegister nds, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6659,23 ***</span>
    vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xEF);
    emit_operand(dst, src);
  }
  
  
  // vinserti forms
  
  void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x38);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - insert into lower 128 bits
    // 0x01 - insert into upper 128 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6214,46 ---</span>
    vex_prefix(src, nds-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
    emit_int8((unsigned char)0xEF);
    emit_operand(dst, src);
  }
  
<span class="line-added">+ void Assembler::vpternlogd(XMMRegister dst, int imm8, XMMRegister src2, XMMRegister src3, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);</span>
<span class="line-added">+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), &quot;requires VL support&quot;);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src3-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x25);</span>
<span class="line-added">+   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-added">+   emit_int8(imm8);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vpternlogd(XMMRegister dst, int imm8, XMMRegister src2, Address src3, int vector_len) {</span>
<span class="line-added">+   assert(VM_Version::supports_evex(), &quot;requires EVEX support&quot;);</span>
<span class="line-added">+   assert(vector_len == Assembler::AVX_512bit || VM_Version::supports_avx512vl(), &quot;requires VL support&quot;);</span>
<span class="line-added">+   assert(dst != xnoreg, &quot;sanity&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);</span>
<span class="line-added">+   attributes.set_is_evex_instruction();</span>
<span class="line-added">+   attributes.set_address_attributes(/* tuple_type */ EVEX_FV, /* input_size_in_bits */ EVEX_64bit);</span>
<span class="line-added">+   vex_prefix(src3, src2-&gt;encoding(), dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);</span>
<span class="line-added">+   emit_int8(0x25);</span>
<span class="line-added">+   emit_operand(dst, src3);</span>
<span class="line-added">+   emit_int8(imm8);</span>
<span class="line-added">+ }</span>
  
  // vinserti forms
  
  void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // last byte:</span>
    // 0x00 - insert into lower 128 bits
    // 0x01 - insert into upper 128 bits
<span class="line-modified">!   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinserti128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6695,17 ***</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x38);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - insert into q0 128 bits (0..127)
    // 0x01 - insert into q1 128 bits (128..255)
    // 0x02 - insert into q2 128 bits (256..383)
    // 0x03 - insert into q3 128 bits (384..511)
<span class="line-modified">!   emit_int8(imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6273,16 ---</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - insert into q0 128 bits (0..127)
    // 0x01 - insert into q1 128 bits (128..255)
    // 0x02 - insert into q2 128 bits (256..383)
    // 0x03 - insert into q3 128 bits (384..511)
<span class="line-modified">!   emit_int24(0x38, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vinserti32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6728,30 ***</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x3A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - insert into lower 256 bits
    // 0x01 - insert into upper 256 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  
  // vinsertf forms
  
  void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x18);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - insert into lower 128 bits
    // 0x01 - insert into upper 128 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6305,28 ---</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   //imm8:</span>
    // 0x00 - insert into lower 256 bits
    // 0x01 - insert into upper 256 bits
<span class="line-modified">!   emit_int24(0x3A, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  
  // vinsertf forms
  
  void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - insert into lower 128 bits
    // 0x01 - insert into upper 128 bits
<span class="line-modified">!   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinsertf128(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6770,17 ***</span>
  void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x18);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - insert into q0 128 bits (0..127)
    // 0x01 - insert into q1 128 bits (128..255)
    // 0x02 - insert into q0 128 bits (256..383)
    // 0x03 - insert into q1 128 bits (384..512)
<span class="line-modified">!   emit_int8(imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6345,16 ---</span>
  void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - insert into q0 128 bits (0..127)
    // 0x01 - insert into q1 128 bits (128..255)
    // 0x02 - insert into q0 128 bits (256..383)
    // 0x03 - insert into q1 128 bits (384..512)
<span class="line-modified">!   emit_int24(0x18, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vinsertf32x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6802,15 ***</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x1A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - insert into lower 256 bits
    // 0x01 - insert into upper 256 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6376,14 ---</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - insert into lower 256 bits
    // 0x01 - insert into upper 256 bits
<span class="line-modified">!   emit_int24(0x1A, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vinsertf64x4(XMMRegister dst, XMMRegister nds, Address src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6833,15 ***</span>
  void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x39);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from lower 128 bits
    // 0x01 - extract from upper 128 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6406,14 ---</span>
  void Assembler::vextracti128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from lower 128 bits
    // 0x01 - extract from upper 128 bits
<span class="line-modified">!   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextracti128(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6862,17 ***</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x39);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int8(imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6434,16 ---</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextracti32x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6896,30 ***</span>
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x39);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int8(imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x3B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from lower 256 bits
    // 0x01 - extract from upper 256 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6467,28 ---</span>
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int24(0x39, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextracti64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from lower 256 bits
    // 0x01 - extract from upper 256 bits
<span class="line-modified">!   emit_int24(0x3B, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextracti64x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6941,15 ***</span>
  void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x19);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from lower 128 bits
    // 0x01 - extract from upper 128 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6510,14 ---</span>
  void Assembler::vextractf128(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_256bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from lower 128 bits
    // 0x01 - extract from upper 128 bits
<span class="line-modified">!   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextractf128(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 6970,17 ***</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x19);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int8(imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6538,16 ---</span>
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextractf32x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7004,30 ***</span>
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x19);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int8(imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x1B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    // 0x00 - extract from lower 256 bits
    // 0x01 - extract from upper 256 bits
<span class="line-modified">!   emit_int8(imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6571,28 ---</span>
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    assert(imm8 &lt;= 0x03, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from bits 127:0
    // 0x01 - extract from bits 255:128
    // 0x02 - extract from bits 383:256
    // 0x03 - extract from bits 511:384
<span class="line-modified">!   emit_int24(0x19, (0xC0 | encode), imm8 &amp; 0x03);</span>
  }
  
  void Assembler::vextractf64x4(XMMRegister dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(imm8 &lt;= 0x01, &quot;imm8: %u&quot;, imm8);
    InstructionAttr attributes(AVX_512bit, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(src-&gt;encoding(), 0, dst-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   // imm8:</span>
    // 0x00 - extract from lower 256 bits
    // 0x01 - extract from upper 256 bits
<span class="line-modified">!   emit_int24(0x1B, (0xC0 | encode), imm8 &amp; 0x01);</span>
  }
  
  void Assembler::vextractf64x4(Address dst, XMMRegister src, uint8_t imm8) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(src != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7048,12 ***</span>
  // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x78);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6613,11 ---</span>
  // duplicate 1-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::vpbroadcastb(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x78, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastb(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7069,12 ***</span>
  // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x79);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6633,11 ---</span>
  // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::vpbroadcastw(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x79, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastw(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7092,12 ***</span>
  // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(UseAVX &gt;= 2, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x58);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6655,11 ---</span>
  // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vpbroadcastd(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(UseAVX &gt;= 2, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x58, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7114,12 ***</span>
  void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x59);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6676,11 ---</span>
  void Assembler::vpbroadcastq(XMMRegister dst, XMMRegister src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x59, (0xC0 | encode));</span>
  }
  
  void Assembler::vpbroadcastq(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7136,12 ***</span>
    assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
    assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
<span class="line-new-header">--- 6697,11 ---</span>
    assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5A, (0xC0 | encode));</span>
  }
  
  void Assembler::evbroadcasti64x2(XMMRegister dst, Address src, int vector_len) {
    assert(vector_len != Assembler::AVX_128bit, &quot;&quot;);
    assert(VM_Version::supports_avx512dq(), &quot;&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7158,15 ***</span>
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x18);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
<span class="line-new-header">--- 6718,14 ---</span>
  
  // scalar single/double precision replicate
  
  // duplicate single precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastss(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x18, (0xC0 | encode));</span>
  }
  
  void Assembler::vbroadcastss(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7179,20 ***</span>
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx(), &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x19);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
    attributes.set_rex_vex_w_reverted();
<span class="line-new-header">--- 6738,21 ---</span>
    emit_operand(dst, src);
  }
  
  // duplicate double precision data from src into programmed locations in dest : requires AVX512VL
  void Assembler::vbroadcastsd(XMMRegister dst, XMMRegister src, int vector_len) {
<span class="line-modified">!   assert(VM_Version::supports_avx2(), &quot;&quot;);</span>
<span class="line-added">+   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x19, (0xC0 | encode));</span>
  }
  
  void Assembler::vbroadcastsd(XMMRegister dst, Address src, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
<span class="line-added">+   assert(vector_len == AVX_256bit || vector_len == AVX_512bit, &quot;&quot;);</span>
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
    InstructionAttr attributes(vector_len, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_address_attributes(/* tuple_type */ EVEX_T1S, /* input_size_in_bits */ EVEX_64bit);
    attributes.set_rex_vex_w_reverted();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7209,42 ***</span>
  void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x7A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x7B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x7C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8(0x7C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 6769,38 ---</span>
  void Assembler::evpbroadcastb(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x7A, (0xC0 | encode));</span>
  }
  
  // duplicate 2-byte integer data from src into programmed locations in dest : requires AVX512BW and AVX512VL
  void Assembler::evpbroadcastw(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_avx512bw(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ _legacy_mode_bw, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x7B, (0xC0 | encode));</span>
  }
  
  // duplicate 4-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::evpbroadcastd(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x7C, (0xC0 | encode));</span>
  }
  
  // duplicate 8-byte integer data from src into programmed locations in dest : requires AVX512VL
  void Assembler::evpbroadcastq(XMMRegister dst, Register src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16(0x7C, (0xC0 | encode));</span>
  }
  void Assembler::evpgatherdd(XMMRegister dst, KRegister mask, Address src, int vector_len) {
    assert(VM_Version::supports_evex(), &quot;&quot;);
    assert(dst != xnoreg, &quot;sanity&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7261,51 ***</span>
  // Carry-Less Multiplication Quadword
  void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
    assert(VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x44);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)mask);</span>
  }
  
  // Carry-Less Multiplication Quadword
  void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
    assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x44);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)mask);</span>
  }
  
  void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
    assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8(0x44);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)mask);</span>
  }
  
<span class="line-modified">! void Assembler::vzeroupper() {</span>
    if (VM_Version::supports_vzeroupper()) {
      InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
      (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
      emit_int8(0x77);
    }
  }
  
  #ifndef _LP64
  // 32bit only pieces of the assembler
  
  void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT
    InstructionMark im(this);
<span class="line-modified">!   emit_int8((unsigned char)0x81);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF8 | src1-&gt;encoding()));</span>
    emit_data(imm32, rspec, 0);
  }
  
  void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
<span class="line-new-header">--- 6817,53 ---</span>
  // Carry-Less Multiplication Quadword
  void Assembler::pclmulqdq(XMMRegister dst, XMMRegister src, int mask) {
    assert(VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* rex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, dst, src, VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>
  }
  
  // Carry-Less Multiplication Quadword
  void Assembler::vpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask) {
    assert(VM_Version::supports_avx() &amp;&amp; VM_Version::supports_clmul(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>
  }
  
  void Assembler::evpclmulqdq(XMMRegister dst, XMMRegister nds, XMMRegister src, int mask, int vector_len) {
    assert(VM_Version::supports_avx512_vpclmulqdq(), &quot;Requires vector carryless multiplication support&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ true);
    attributes.set_is_evex_instruction();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x44, (0xC0 | encode), (unsigned char)mask);</span>
  }
  
<span class="line-modified">! void Assembler::vzeroupper_uncached() {</span>
    if (VM_Version::supports_vzeroupper()) {
      InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
      (void)vex_prefix_and_encode(0, 0, 0, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
      emit_int8(0x77);
    }
  }
  
  #ifndef _LP64
  // 32bit only pieces of the assembler
  
<span class="line-added">+ void Assembler::emms() {</span>
<span class="line-added">+   NOT_LP64(assert(VM_Version::supports_mmx(), &quot;&quot;));</span>
<span class="line-added">+   emit_int16(0x0F, 0x77);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::vzeroupper() {</span>
<span class="line-added">+   vzeroupper_uncached();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::cmp_literal32(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT
    InstructionMark im(this);
<span class="line-modified">!   emit_int16((unsigned char)0x81, (0xF8 | src1-&gt;encoding()));</span>
    emit_data(imm32, rspec, 0);
  }
  
  void Assembler::cmp_literal32(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    // NO PREFIX AS NEVER 64BIT (not even 32bit versions of 64bit regs
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7318,25 ***</span>
  // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
  // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
  // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchg8(Address adr) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xC7);</span>
    emit_operand(rcx, adr);
  }
  
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
   emit_int8(0x48 | dst-&gt;encoding());
  }
  
  // 64bit doesn&#39;t use the x87
  
  void Assembler::fabs() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE1);</span>
  }
  
  void Assembler::fadd(int i) {
    emit_farith(0xD8, 0xC0, i);
  }
<span class="line-new-header">--- 6876,36 ---</span>
  // The 64-bit (32bit platform) cmpxchg compares the value at adr with the contents of rdx:rax,
  // and stores rcx:rbx into adr if so; otherwise, the value at adr is loaded
  // into rdx:rax.  The ZF is set if the compared values were equal, and cleared otherwise.
  void Assembler::cmpxchg8(Address adr) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xC7);</span>
    emit_operand(rcx, adr);
  }
  
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
   emit_int8(0x48 | dst-&gt;encoding());
  }
  
  // 64bit doesn&#39;t use the x87
  
<span class="line-added">+ void Assembler::emit_operand32(Register reg, Address adr) {</span>
<span class="line-added">+   assert(reg-&gt;encoding() &lt; 8, &quot;no extended registers&quot;);</span>
<span class="line-added">+   assert(!adr.base_needs_rex() &amp;&amp; !adr.index_needs_rex(), &quot;no extended registers&quot;);</span>
<span class="line-added">+   emit_operand(reg, adr._base, adr._index, adr._scale, adr._disp,</span>
<span class="line-added">+                adr._rspec);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::emit_farith(int b1, int b2, int i) {</span>
<span class="line-added">+   assert(isByte(b1) &amp;&amp; isByte(b2), &quot;wrong opcode&quot;);</span>
<span class="line-added">+   assert(0 &lt;= i &amp;&amp;  i &lt; 8, &quot;illegal stack offset&quot;);</span>
<span class="line-added">+   emit_int16(b1, b2 + i);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::fabs() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xE1);</span>
  }
  
  void Assembler::fadd(int i) {
    emit_farith(0xD8, 0xC0, i);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7360,12 ***</span>
  void Assembler::faddp(int i) {
    emit_farith(0xDE, 0xC0, i);
  }
  
  void Assembler::fchs() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE0);</span>
  }
  
  void Assembler::fcom(int i) {
    emit_farith(0xD8, 0xD0, i);
  }
<span class="line-new-header">--- 6929,11 ---</span>
  void Assembler::faddp(int i) {
    emit_farith(0xDE, 0xC0, i);
  }
  
  void Assembler::fchs() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xE0);</span>
  }
  
  void Assembler::fcom(int i) {
    emit_farith(0xD8, 0xD0, i);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7385,22 ***</span>
    emit_int8((unsigned char)0xD8);
    emit_operand32(rbx, src);
  }
  
  void Assembler::fcompp() {
<span class="line-modified">!   emit_int8((unsigned char)0xDE);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xD9);</span>
  }
  
  void Assembler::fcos() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFF);</span>
  }
  
  void Assembler::fdecstp() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF6);</span>
  }
  
  void Assembler::fdiv(int i) {
    emit_farith(0xD8, 0xF0, i);
  }
<span class="line-new-header">--- 6953,19 ---</span>
    emit_int8((unsigned char)0xD8);
    emit_operand32(rbx, src);
  }
  
  void Assembler::fcompp() {
<span class="line-modified">!   emit_int16((unsigned char)0xDE, (unsigned char)0xD9);</span>
  }
  
  void Assembler::fcos() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xFF);</span>
  }
  
  void Assembler::fdecstp() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xF6);</span>
  }
  
  void Assembler::fdiv(int i) {
    emit_farith(0xD8, 0xF0, i);
  }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7467,18 ***</span>
    emit_int8((unsigned char)0xDB);
    emit_operand32(rax, adr);
  }
  
  void Assembler::fincstp() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF7);</span>
  }
  
  void Assembler::finit() {
<span class="line-modified">!   emit_int8((unsigned char)0x9B);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xDB);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE3);</span>
  }
  
  void Assembler::fist_s(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDB);
<span class="line-new-header">--- 7032,15 ---</span>
    emit_int8((unsigned char)0xDB);
    emit_operand32(rax, adr);
  }
  
  void Assembler::fincstp() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xF7);</span>
  }
  
  void Assembler::finit() {
<span class="line-modified">!   emit_int24((unsigned char)0x9B, (unsigned char)0xDB, (unsigned char)0xE3);</span>
  }
  
  void Assembler::fist_s(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDB);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7496,12 ***</span>
    emit_int8((unsigned char)0xDB);
    emit_operand32(rbx, adr);
  }
  
  void Assembler::fld1() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE8);</span>
  }
  
  void Assembler::fld_d(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
<span class="line-new-header">--- 7058,11 ---</span>
    emit_int8((unsigned char)0xDB);
    emit_operand32(rbx, adr);
  }
  
  void Assembler::fld1() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xE8);</span>
  }
  
  void Assembler::fld_d(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7536,22 ***</span>
    emit_int8((unsigned char)0xD9);
    emit_operand32(rsp, src);
  }
  
  void Assembler::fldlg2() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xEC);</span>
  }
  
  void Assembler::fldln2() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xED);</span>
  }
  
  void Assembler::fldz() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xEE);</span>
  }
  
  void Assembler::flog() {
    fldln2();
    fxch();
<span class="line-new-header">--- 7097,19 ---</span>
    emit_int8((unsigned char)0xD9);
    emit_operand32(rsp, src);
  }
  
  void Assembler::fldlg2() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xEC);</span>
  }
  
  void Assembler::fldln2() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xED);</span>
  }
  
  void Assembler::fldz() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xEE);</span>
  }
  
  void Assembler::flog() {
    fldln2();
    fxch();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7594,44 ***</span>
    emit_operand32(rsi, dst);
  }
  
  void Assembler::fnstcw(Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int8((unsigned char)0x9B);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xD9);</span>
    emit_operand32(rdi, src);
  }
  
  void Assembler::fnstsw_ax() {
<span class="line-modified">!   emit_int8((unsigned char)0xDF);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE0);</span>
  }
  
  void Assembler::fprem() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF8);</span>
  }
  
  void Assembler::fprem1() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF5);</span>
  }
  
  void Assembler::frstor(Address src) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
    emit_operand32(rsp, src);
  }
  
  void Assembler::fsin() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFE);</span>
  }
  
  void Assembler::fsqrt() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFA);</span>
  }
  
  void Assembler::fst_d(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
<span class="line-new-header">--- 7152,38 ---</span>
    emit_operand32(rsi, dst);
  }
  
  void Assembler::fnstcw(Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16((unsigned char)0x9B, (unsigned char)0xD9);</span>
    emit_operand32(rdi, src);
  }
  
  void Assembler::fnstsw_ax() {
<span class="line-modified">!   emit_int16((unsigned char)0xDF, (unsigned char)0xE0);</span>
  }
  
  void Assembler::fprem() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xF8);</span>
  }
  
  void Assembler::fprem1() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xF5);</span>
  }
  
  void Assembler::frstor(Address src) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
    emit_operand32(rsp, src);
  }
  
  void Assembler::fsin() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xFE);</span>
  }
  
  void Assembler::fsqrt() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xFA);</span>
  }
  
  void Assembler::fst_d(Address adr) {
    InstructionMark im(this);
    emit_int8((unsigned char)0xDD);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7713,19 ***</span>
  void Assembler::fsubrp(int i) {
    emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
  }
  
  void Assembler::ftan() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xDD);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xD8);</span>
  }
  
  void Assembler::ftst() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xE4);</span>
  }
  
  void Assembler::fucomi(int i) {
    // make sure the instruction is supported (introduced for P6, together with cmov)
    guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
<span class="line-new-header">--- 7265,15 ---</span>
  void Assembler::fsubrp(int i) {
    emit_farith(0xDE, 0xE0, i);                    // ST(0) &lt;- ST(1) - ST(0) and pop (Intel manual wrong)
  }
  
  void Assembler::ftan() {
<span class="line-modified">!   emit_int32((unsigned char)0xD9, (unsigned char)0xF2, (unsigned char)0xDD, (unsigned char)0xD8);</span>
  }
  
  void Assembler::ftst() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xE4);</span>
  }
  
  void Assembler::fucomi(int i) {
    // make sure the instruction is supported (introduced for P6, together with cmov)
    guarantee(VM_Version::supports_cmov(), &quot;illegal instruction&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7745,27 ***</span>
  void Assembler::fxch(int i) {
    emit_farith(0xD9, 0xC8, i);
  }
  
  void Assembler::fyl2x() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF1);</span>
  }
  
  void Assembler::frndint() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFC);</span>
  }
  
  void Assembler::f2xm1() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF0);</span>
  }
  
  void Assembler::fldl2e() {
<span class="line-modified">!   emit_int8((unsigned char)0xD9);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xEA);</span>
  }
  #endif // !_LP64
  
  // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
  static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
<span class="line-new-header">--- 7293,23 ---</span>
  void Assembler::fxch(int i) {
    emit_farith(0xD9, 0xC8, i);
  }
  
  void Assembler::fyl2x() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xF1);</span>
  }
  
  void Assembler::frndint() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xFC);</span>
  }
  
  void Assembler::f2xm1() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xF0);</span>
  }
  
  void Assembler::fldl2e() {
<span class="line-modified">!   emit_int16((unsigned char)0xD9, (unsigned char)0xEA);</span>
  }
  #endif // !_LP64
  
  // SSE SIMD prefix byte values corresponding to VexSimdPrefix encoding.
  static int simd_pre[4] = { 0, 0x66, 0xF3, 0xF2 };
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7809,35 ***</span>
  
  void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
    int vector_len = _attributes-&gt;get_vector_len();
    bool vex_w = _attributes-&gt;is_rex_vex_w();
    if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {
<span class="line-removed">-     prefix(VEX_3bytes);</span>
<span class="line-removed">- </span>
      int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
      byte1 = (~byte1) &amp; 0xE0;
      byte1 |= opc;
<span class="line-removed">-     emit_int8(byte1);</span>
  
      int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
      byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;
<span class="line-removed">-     emit_int8(byte2);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     prefix(VEX_2bytes);</span>
  
      int byte1 = vex_r ? VEX_R : 0;
      byte1 = (~byte1) &amp; 0x80;
      byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
      byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
<span class="line-modified">!     emit_int8(byte1);</span>
    }
  }
  
  // This is a 4 byte encoding
  void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
    // EVEX 0x62 prefix
<span class="line-modified">!   prefix(EVEX_4bytes);</span>
    bool vex_w = _attributes-&gt;is_rex_vex_w();
    int evex_encoding = (vex_w ? VEX_W : 0);
    // EVEX.b is not currently used for broadcast of single element or data rounding modes
    _attributes-&gt;set_evex_encoding(evex_encoding);
  
<span class="line-new-header">--- 7353,32 ---</span>
  
  void Assembler::vex_prefix(bool vex_r, bool vex_b, bool vex_x, int nds_enc, VexSimdPrefix pre, VexOpcode opc) {
    int vector_len = _attributes-&gt;get_vector_len();
    bool vex_w = _attributes-&gt;is_rex_vex_w();
    if (vex_b || vex_x || vex_w || (opc == VEX_OPCODE_0F_38) || (opc == VEX_OPCODE_0F_3A)) {
      int byte1 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0);
      byte1 = (~byte1) &amp; 0xE0;
      byte1 |= opc;
  
      int byte2 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
      byte2 |= (vex_w ? VEX_W : 0) | ((vector_len &gt; 0) ? 4 : 0) | pre;
  
<span class="line-added">+     emit_int24((unsigned char)VEX_3bytes, byte1, byte2);</span>
<span class="line-added">+   } else {</span>
      int byte1 = vex_r ? VEX_R : 0;
      byte1 = (~byte1) &amp; 0x80;
      byte1 |= ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
      byte1 |= ((vector_len &gt; 0 ) ? 4 : 0) | pre;
<span class="line-modified">!     emit_int16((unsigned char)VEX_2bytes, byte1);</span>
    }
  }
  
  // This is a 4 byte encoding
  void Assembler::evex_prefix(bool vex_r, bool vex_b, bool vex_x, bool evex_r, bool evex_v, int nds_enc, VexSimdPrefix pre, VexOpcode opc){
    // EVEX 0x62 prefix
<span class="line-modified">!   // byte1 = EVEX_4bytes;</span>
<span class="line-added">+ </span>
    bool vex_w = _attributes-&gt;is_rex_vex_w();
    int evex_encoding = (vex_w ? VEX_W : 0);
    // EVEX.b is not currently used for broadcast of single element or data rounding modes
    _attributes-&gt;set_evex_encoding(evex_encoding);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7846,21 ***</span>
    int byte2 = (vex_r ? VEX_R : 0) | (vex_x ? VEX_X : 0) | (vex_b ? VEX_B : 0) | (evex_r ? EVEX_Rb : 0);
    byte2 = (~byte2) &amp; 0xF0;
    // confine opc opcode extensions in mm bits to lower two bits
    // of form {0F, 0F_38, 0F_3A}
    byte2 |= opc;
<span class="line-removed">-   emit_int8(byte2);</span>
  
    // P1: byte 3 as Wvvvv1pp
    int byte3 = ((~nds_enc) &amp; 0xf) &lt;&lt; 3;
    // p[10] is always 1
    byte3 |= EVEX_F;
    byte3 |= (vex_w &amp; 1) &lt;&lt; 7;
    // confine pre opcode extensions in pp bits to lower two bits
    // of form {66, F3, F2}
    byte3 |= pre;
<span class="line-removed">-   emit_int8(byte3);</span>
  
    // P2: byte 4 as zL&#39;Lbv&#39;aaa
    // kregs are implemented in the low 3 bits as aaa
    int byte4 = (_attributes-&gt;is_no_reg_mask()) ?
                0 :
<span class="line-new-header">--- 7387,19 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7873,15 ***</span>
    byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
    // last is EVEX.z for zero/merge actions
    if (_attributes-&gt;is_no_reg_mask() == false) {
      byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
    }
<span class="line-modified">!   emit_int8(byte4);</span>
  }
  
  void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">!   bool vex_r = ((xreg_enc &amp; 8) == 8) ? 1 : 0;</span>
    bool vex_b = adr.base_needs_rex();
    bool vex_x;
    if (adr.isxmmindex()) {
      vex_x = adr.xmmindex_needs_rex();
    } else {
<span class="line-new-header">--- 7412,16 ---</span>
    byte4 |= ((_attributes-&gt;get_vector_len())&amp; 0x3) &lt;&lt; 5;
    // last is EVEX.z for zero/merge actions
    if (_attributes-&gt;is_no_reg_mask() == false) {
      byte4 |= (_attributes-&gt;is_clear_context() ? EVEX_Z : 0);
    }
<span class="line-modified">! </span>
<span class="line-added">+   emit_int32(EVEX_4bytes, byte2, byte3, byte4);</span>
  }
  
  void Assembler::vex_prefix(Address adr, int nds_enc, int xreg_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">!   bool vex_r = (xreg_enc &amp; 8) == 8;</span>
    bool vex_b = adr.base_needs_rex();
    bool vex_x;
    if (adr.isxmmindex()) {
      vex_x = adr.xmmindex_needs_rex();
    } else {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7892,11 ***</span>
  
    // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
    // is allowed in legacy mode and has resources which will fit in it.
    // Pure EVEX instructions will have is_evex_instruction set in their definition.
    if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {</span>
        if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
            attributes-&gt;set_is_legacy_mode();
        }
      }
    }
<span class="line-new-header">--- 7432,11 ---</span>
  
    // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
    // is allowed in legacy mode and has resources which will fit in it.
    // Pure EVEX instructions will have is_evex_instruction set in their definition.
    if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
        if ((attributes-&gt;get_vector_len() != AVX_512bit) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (xreg_enc &lt; 16)) {
            attributes-&gt;set_is_legacy_mode();
        }
      }
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7907,11 ***</span>
              (!_legacy_mode_vl) ||
              (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
      assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
    }
  
<span class="line-modified">!   _is_managed = false;</span>
    if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
    {
      bool evex_r = (xreg_enc &gt;= 16);
      bool evex_v;
      // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
<span class="line-new-header">--- 7447,11 ---</span>
              (!_legacy_mode_vl) ||
              (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
      assert(((nds_enc &lt; 16 &amp;&amp; xreg_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
    }
  
<span class="line-modified">!   clear_managed();</span>
    if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
    {
      bool evex_r = (xreg_enc &gt;= 16);
      bool evex_v;
      // EVEX.V&#39; is set to true when VSIB is used as we may need to use higher order XMM registers (16-31)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7929,21 ***</span>
      vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
    }
  }
  
  int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">!   bool vex_r = ((dst_enc &amp; 8) == 8) ? 1 : 0;</span>
<span class="line-modified">!   bool vex_b = ((src_enc &amp; 8) == 8) ? 1 : 0;</span>
    bool vex_x = false;
    set_attributes(attributes);
    attributes-&gt;set_current_assembler(this);
  
    // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
    // is allowed in legacy mode and has resources which will fit in it.
    // Pure EVEX instructions will have is_evex_instruction set in their definition.
    if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !_is_managed) {</span>
        if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
            (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
            attributes-&gt;set_is_legacy_mode();
        }
      }
<span class="line-new-header">--- 7469,21 ---</span>
      vex_prefix(vex_r, vex_b, vex_x, nds_enc, pre, opc);
    }
  }
  
  int Assembler::vex_prefix_and_encode(int dst_enc, int nds_enc, int src_enc, VexSimdPrefix pre, VexOpcode opc, InstructionAttr *attributes) {
<span class="line-modified">!   bool vex_r = (dst_enc &amp; 8) == 8;</span>
<span class="line-modified">!   bool vex_b = (src_enc &amp; 8) == 8;</span>
    bool vex_x = false;
    set_attributes(attributes);
    attributes-&gt;set_current_assembler(this);
  
    // For EVEX instruction (which is not marked as pure EVEX instruction) check and see if this instruction
    // is allowed in legacy mode and has resources which will fit in it.
    // Pure EVEX instructions will have is_evex_instruction set in their definition.
    if (!attributes-&gt;is_legacy_mode()) {
<span class="line-modified">!     if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_evex_instruction() &amp;&amp; !is_managed()) {</span>
        if ((!attributes-&gt;uses_vl() || (attributes-&gt;get_vector_len() != AVX_512bit)) &amp;&amp;
            (dst_enc &lt; 16) &amp;&amp; (nds_enc &lt; 16) &amp;&amp; (src_enc &lt; 16)) {
            attributes-&gt;set_is_legacy_mode();
        }
      }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 7961,11 ***</span>
              (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
      // Instruction with legacy_mode true should have dst, nds and src &lt; 15
      assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
    }
  
<span class="line-modified">!   _is_managed = false;</span>
    if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
    {
      bool evex_r = (dst_enc &gt;= 16);
      bool evex_v = (nds_enc &gt;= 16);
      // can use vex_x as bank extender on rm encoding
<span class="line-new-header">--- 7501,11 ---</span>
              (attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
      // Instruction with legacy_mode true should have dst, nds and src &lt; 15
      assert(((dst_enc &lt; 16 &amp;&amp; nds_enc &lt; 16 &amp;&amp; src_enc &lt; 16) || (!attributes-&gt;is_legacy_mode())),&quot;XMM register should be 0-15&quot;);
    }
  
<span class="line-modified">!   clear_managed();</span>
    if (UseAVX &gt; 2 &amp;&amp; !attributes-&gt;is_legacy_mode())
    {
      bool evex_r = (dst_enc &gt;= 16);
      bool evex_v = (nds_enc &gt;= 16);
      // can use vex_x as bank extender on rm encoding
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8011,105 ***</span>
  
  void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5D);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x5D);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xC2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF &amp; cop));</span>
  }
  
  void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-removed">-   emit_int8((unsigned char)0x4B);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    int src2_enc = src2-&gt;encoding();
<span class="line-modified">!   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));</span>
  }
  
  void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xC2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF &amp; cop));</span>
  }
  
  void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-removed">-   emit_int8((unsigned char)0x4A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
    int src2_enc = src2-&gt;encoding();
<span class="line-modified">!   emit_int8((unsigned char)(0xF0 &amp; src2_enc&lt;&lt;4));</span>
  }
  
  void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0x02);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8((unsigned char)imm8);</span>
  }
  
  void Assembler::shlxl(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::shlxq(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  #ifndef _LP64
  
  void Assembler::incl(Register dst) {
<span class="line-new-header">--- 7551,89 ---</span>
  
  void Assembler::vmaxss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5F, (0xC0 | encode));</span>
  }
  
  void Assembler::vmaxsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5F, (0xC0 | encode));</span>
  }
  
  void Assembler::vminss(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5D, (0xC0 | encode));</span>
  }
  
  void Assembler::vminsd(XMMRegister dst, XMMRegister nds, XMMRegister src) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ VM_Version::supports_evex(), /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    attributes.set_rex_vex_w_reverted();
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x5D, (0xC0 | encode));</span>
  }
  
  void Assembler::cmppd(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>
  }
  
  void Assembler::blendvpd(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    int src2_enc = src2-&gt;encoding();
<span class="line-modified">!   emit_int24(0x4B, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
  }
  
  void Assembler::cmpps(XMMRegister dst, XMMRegister nds, XMMRegister src, int cop, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = simd_prefix_and_encode(dst, nds, src, VEX_SIMD_NONE, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0xC2, (0xC0 | encode), (0xF &amp; cop));</span>
  }
  
  void Assembler::blendvps(XMMRegister dst, XMMRegister nds, XMMRegister src1, XMMRegister src2, int vector_len) {
    assert(VM_Version::supports_avx(), &quot;&quot;);
    assert(vector_len &lt;= AVX_256bit, &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
    int src2_enc = src2-&gt;encoding();
<span class="line-modified">!   emit_int24(0x4A, (0xC0 | encode), (0xF0 &amp; src2_enc &lt;&lt; 4));</span>
  }
  
  void Assembler::vpblendd(XMMRegister dst, XMMRegister nds, XMMRegister src, int imm8, int vector_len) {
    assert(VM_Version::supports_avx2(), &quot;&quot;);
    InstructionAttr attributes(vector_len, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), nds-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24(0x02, (0xC0 | encode), (unsigned char)imm8);</span>
  }
  
  void Assembler::shlxl(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
  }
  
  void Assembler::shlxq(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi2(), &quot;&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ true);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src2-&gt;encoding(), src1-&gt;encoding(), VEX_SIMD_66, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
  }
  
  #ifndef _LP64
  
  void Assembler::incl(Register dst) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8129,11 ***</span>
  }
  
  void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)(0xB8 | encode));</span>
    emit_data((int)imm32, rspec, 0);
  }
  
  void Assembler::popa() { // 32bit
    emit_int8(0x61);
<span class="line-new-header">--- 7653,11 ---</span>
  }
  
  void Assembler::mov_literal32(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((0xB8 | encode));</span>
    emit_data((int)imm32, rspec, 0);
  }
  
  void Assembler::popa() { // 32bit
    emit_int8(0x61);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8148,22 ***</span>
  void Assembler::pusha() { // 32bit
    emit_int8(0x60);
  }
  
  void Assembler::set_byte_if_not_zero(Register dst) {
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x95);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | dst-&gt;encoding()));</span>
  }
  
  #else // LP64
  
  void Assembler::set_byte_if_not_zero(Register dst) {
    int enc = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x95);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | enc));</span>
  }
  
  // 64bit only pieces of the assembler
  // This should only be used by 64bit instructions that can use rip-relative
  // it cannot be used by instructions that want an immediate value.
<span class="line-new-header">--- 7672,18 ---</span>
  void Assembler::pusha() { // 32bit
    emit_int8(0x60);
  }
  
  void Assembler::set_byte_if_not_zero(Register dst) {
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | dst-&gt;encoding()));</span>
  }
  
  #else // LP64
  
  void Assembler::set_byte_if_not_zero(Register dst) {
    int enc = prefix_and_encode(dst-&gt;encoding(), true);
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0x95, (0xE0 | enc));</span>
  }
  
  // 64bit only pieces of the assembler
  // This should only be used by 64bit instructions that can use rip-relative
  // it cannot be used by instructions that want an immediate value.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8234,19 ***</span>
      disp += fudge;
    }
    return is_simm32(disp);
  }
  
<span class="line-removed">- // Check if the polling page is not reachable from the code cache using rip-relative</span>
<span class="line-removed">- // addressing.</span>
<span class="line-removed">- bool Assembler::is_polling_page_far() {</span>
<span class="line-removed">-   intptr_t addr = (intptr_t)os::get_polling_page();</span>
<span class="line-removed">-   return ForceUnreachable ||</span>
<span class="line-removed">-          !is_simm32(addr - (intptr_t)CodeCache::low_bound()) ||</span>
<span class="line-removed">-          !is_simm32(addr - (intptr_t)CodeCache::high_bound());</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Assembler::emit_data64(jlong data,
                              relocInfo::relocType rtype,
                              int format) {
    if (rtype == relocInfo::none) {
      emit_int64(data);
<span class="line-new-header">--- 7754,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8268,70 ***</span>
    check_relocation(rspec, format);
  #endif
    emit_int64(data);
  }
  
<span class="line-removed">- int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="line-removed">-   if (reg_enc &gt;= 8) {</span>
<span class="line-removed">-     prefix(REX_B);</span>
<span class="line-removed">-     reg_enc -= 8;</span>
<span class="line-removed">-   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="line-removed">-     prefix(REX);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return reg_enc;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="line-removed">-   if (reg_enc &lt; 8) {</span>
<span class="line-removed">-     prefix(REX_W);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     prefix(REX_WB);</span>
<span class="line-removed">-     reg_enc -= 8;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return reg_enc;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="line-removed">-   if (dst_enc &lt; 8) {</span>
<span class="line-removed">-     if (src_enc &gt;= 8) {</span>
<span class="line-removed">-       prefix(REX_B);</span>
<span class="line-removed">-       src_enc -= 8;</span>
<span class="line-removed">-     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="line-removed">-       prefix(REX);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (src_enc &lt; 8) {</span>
<span class="line-removed">-       prefix(REX_R);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       prefix(REX_RB);</span>
<span class="line-removed">-       src_enc -= 8;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     dst_enc -= 8;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="line-removed">-   if (dst_enc &lt; 8) {</span>
<span class="line-removed">-     if (src_enc &lt; 8) {</span>
<span class="line-removed">-       prefix(REX_W);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       prefix(REX_WB);</span>
<span class="line-removed">-       src_enc -= 8;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (src_enc &lt; 8) {</span>
<span class="line-removed">-       prefix(REX_WR);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       prefix(REX_WRB);</span>
<span class="line-removed">-       src_enc -= 8;</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     dst_enc -= 8;</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
  void Assembler::prefix(Register reg) {
    if (reg-&gt;encoding() &gt;= 8) {
      prefix(REX_B);
    }
  }
<span class="line-new-header">--- 7779,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8339,11 ***</span>
  void Assembler::prefix(Register dst, Register src, Prefix p) {
    if (src-&gt;encoding() &gt;= 8) {
      p = (Prefix)(p | REX_B);
    }
    if (dst-&gt;encoding() &gt;= 8) {
<span class="line-modified">!     p = (Prefix)( p | REX_R);</span>
    }
    if (p != Prefix_EMPTY) {
      // do not generate an empty prefix
      prefix(p);
    }
<span class="line-new-header">--- 7790,11 ---</span>
  void Assembler::prefix(Register dst, Register src, Prefix p) {
    if (src-&gt;encoding() &gt;= 8) {
      p = (Prefix)(p | REX_B);
    }
    if (dst-&gt;encoding() &gt;= 8) {
<span class="line-modified">!     p = (Prefix)(p | REX_R);</span>
    }
    if (p != Prefix_EMPTY) {
      // do not generate an empty prefix
      prefix(p);
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8382,27 ***</span>
        prefix(REX_X);
      }
    }
  }
  
<span class="line-removed">- void Assembler::prefixq(Address adr) {</span>
<span class="line-removed">-   if (adr.base_needs_rex()) {</span>
<span class="line-removed">-     if (adr.index_needs_rex()) {</span>
<span class="line-removed">-       prefix(REX_WXB);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       prefix(REX_WB);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     if (adr.index_needs_rex()) {</span>
<span class="line-removed">-       prefix(REX_WX);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       prefix(REX_W);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
  void Assembler::prefix(Address adr, Register reg, bool byteinst) {
    if (reg-&gt;encoding() &lt; 8) {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
          prefix(REX_XB);
<span class="line-new-header">--- 7833,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8410,11 ***</span>
          prefix(REX_B);
        }
      } else {
        if (adr.index_needs_rex()) {
          prefix(REX_X);
<span class="line-modified">!       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4 ) {</span>
          prefix(REX);
        }
      }
    } else {
      if (adr.base_needs_rex()) {
<span class="line-new-header">--- 7844,11 ---</span>
          prefix(REX_B);
        }
      } else {
        if (adr.index_needs_rex()) {
          prefix(REX_X);
<span class="line-modified">!       } else if (byteinst &amp;&amp; reg-&gt;encoding() &gt;= 4) {</span>
          prefix(REX);
        }
      }
    } else {
      if (adr.base_needs_rex()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8431,70 ***</span>
        }
      }
    }
  }
  
<span class="line-modified">! void Assembler::prefixq(Address adr, Register src) {</span>
<span class="line-modified">!   if (src-&gt;encoding() &lt; 8) {</span>
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_WXB);</span>
        } else {
<span class="line-modified">!         prefix(REX_WB);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_WX);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         prefix(REX_W);</span>
        }
      }
    } else {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_WRXB);</span>
        } else {
<span class="line-modified">!         prefix(REX_WRB);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_WRX);</span>
        } else {
<span class="line-modified">!         prefix(REX_WR);</span>
        }
      }
    }
  }
  
<span class="line-modified">! void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="line-modified">!   if (reg-&gt;encoding() &lt; 8) {</span>
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_XB);</span>
        } else {
<span class="line-modified">!         prefix(REX_B);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_X);</span>
        }
      }
    } else {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_RXB);</span>
        } else {
<span class="line-modified">!         prefix(REX_RB);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_RX);</span>
        } else {
<span class="line-modified">!         prefix(REX_R);</span>
        }
      }
    }
  }
  
  void Assembler::prefixq(Address adr, XMMRegister src) {
    if (src-&gt;encoding() &lt; 8) {
      if (adr.base_needs_rex()) {
<span class="line-new-header">--- 7865,121 ---</span>
        }
      }
    }
  }
  
<span class="line-modified">! void Assembler::prefix(Address adr, XMMRegister reg) {</span>
<span class="line-modified">!   if (reg-&gt;encoding() &lt; 8) {</span>
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_XB);</span>
        } else {
<span class="line-modified">!         prefix(REX_B);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_X);</span>
        }
      }
    } else {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_RXB);</span>
        } else {
<span class="line-modified">!         prefix(REX_RB);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         prefix(REX_RX);</span>
        } else {
<span class="line-modified">!         prefix(REX_R);</span>
        }
      }
    }
  }
  
<span class="line-modified">! int Assembler::prefix_and_encode(int reg_enc, bool byteinst) {</span>
<span class="line-modified">!   if (reg_enc &gt;= 8) {</span>
<span class="line-added">+     prefix(REX_B);</span>
<span class="line-added">+     reg_enc -= 8;</span>
<span class="line-added">+   } else if (byteinst &amp;&amp; reg_enc &gt;= 4) {</span>
<span class="line-added">+     prefix(REX);</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return reg_enc;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int Assembler::prefix_and_encode(int dst_enc, bool dst_is_byte, int src_enc, bool src_is_byte) {</span>
<span class="line-added">+   if (dst_enc &lt; 8) {</span>
<span class="line-added">+     if (src_enc &gt;= 8) {</span>
<span class="line-added">+       prefix(REX_B);</span>
<span class="line-added">+       src_enc -= 8;</span>
<span class="line-added">+     } else if ((src_is_byte &amp;&amp; src_enc &gt;= 4) || (dst_is_byte &amp;&amp; dst_enc &gt;= 4)) {</span>
<span class="line-added">+       prefix(REX);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     if (src_enc &lt; 8) {</span>
<span class="line-added">+       prefix(REX_R);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       prefix(REX_RB);</span>
<span class="line-added">+       src_enc -= 8;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     dst_enc -= 8;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int8_t Assembler::get_prefixq(Address adr) {</span>
<span class="line-added">+   int8_t prfx = get_prefixq(adr, rax);</span>
<span class="line-added">+   assert(REX_W &lt;= prfx &amp;&amp; prfx &lt;= REX_WXB, &quot;must be&quot;);</span>
<span class="line-added">+   return prfx;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int8_t Assembler::get_prefixq(Address adr, Register src) {</span>
<span class="line-added">+   int8_t prfx = (int8_t)(REX_W +</span>
<span class="line-added">+                          ((int)adr.base_needs_rex()) +</span>
<span class="line-added">+                          ((int)adr.index_needs_rex() &lt;&lt; 1) +</span>
<span class="line-added">+                          ((int)(src-&gt;encoding() &gt;= 8) &lt;&lt; 2));</span>
<span class="line-added">+ #ifdef ASSERT</span>
<span class="line-added">+   if (src-&gt;encoding() &lt; 8) {</span>
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         assert(prfx == REX_WXB, &quot;must be&quot;);</span>
        } else {
<span class="line-modified">!         assert(prfx == REX_WB, &quot;must be&quot;);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         assert(prfx == REX_WX, &quot;must be&quot;);</span>
<span class="line-added">+       } else {</span>
<span class="line-added">+         assert(prfx == REX_W, &quot;must be&quot;);</span>
        }
      }
    } else {
      if (adr.base_needs_rex()) {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         assert(prfx == REX_WRXB, &quot;must be&quot;);</span>
        } else {
<span class="line-modified">!         assert(prfx == REX_WRB, &quot;must be&quot;);</span>
        }
      } else {
        if (adr.index_needs_rex()) {
<span class="line-modified">!         assert(prfx == REX_WRX, &quot;must be&quot;);</span>
        } else {
<span class="line-modified">!         assert(prfx == REX_WR, &quot;must be&quot;);</span>
        }
      }
    }
<span class="line-added">+ #endif</span>
<span class="line-added">+   return prfx;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::prefixq(Address adr) {</span>
<span class="line-added">+   emit_int8(get_prefixq(adr));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::prefixq(Address adr, Register src) {</span>
<span class="line-added">+   emit_int8(get_prefixq(adr, src));</span>
  }
  
  void Assembler::prefixq(Address adr, XMMRegister src) {
    if (src-&gt;encoding() &lt; 8) {
      if (adr.base_needs_rex()) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8525,19 ***</span>
        }
      }
    }
  }
  
  void Assembler::adcq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
    emit_arith(0x81, 0xD0, dst, imm32);
  }
  
  void Assembler::adcq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x13);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::adcq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-new-header">--- 8010,48 ---</span>
        }
      }
    }
  }
  
<span class="line-added">+ int Assembler::prefixq_and_encode(int reg_enc) {</span>
<span class="line-added">+   if (reg_enc &lt; 8) {</span>
<span class="line-added">+     prefix(REX_W);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     prefix(REX_WB);</span>
<span class="line-added">+     reg_enc -= 8;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return reg_enc;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int Assembler::prefixq_and_encode(int dst_enc, int src_enc) {</span>
<span class="line-added">+   if (dst_enc &lt; 8) {</span>
<span class="line-added">+     if (src_enc &lt; 8) {</span>
<span class="line-added">+       prefix(REX_W);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       prefix(REX_WB);</span>
<span class="line-added">+       src_enc -= 8;</span>
<span class="line-added">+     }</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     if (src_enc &lt; 8) {</span>
<span class="line-added">+       prefix(REX_WR);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       prefix(REX_WRB);</span>
<span class="line-added">+       src_enc -= 8;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     dst_enc -= 8;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return dst_enc &lt;&lt; 3 | src_enc;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::adcq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
    emit_arith(0x81, 0xD0, dst, imm32);
  }
  
  void Assembler::adcq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x13);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::adcq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8545,61 ***</span>
  }
  
  void Assembler::addq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
<span class="line-modified">!   emit_arith_operand(0x81, rax, dst,imm32);</span>
  }
  
  void Assembler::addq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst, src);</span>
<span class="line-removed">-   emit_int8(0x01);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::addq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
    emit_arith(0x81, 0xC0, dst, imm32);
  }
  
  void Assembler::addq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x03);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::addq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x03, 0xC0, dst, src);
  }
  
  void Assembler::adcxq(Register dst, Register src) {
    //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
<span class="line-modified">!   emit_int8((unsigned char)0x66);</span>
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x38);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xF6);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::adoxq(Register dst, Register src) {
    //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8(0x38);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xF6);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::andq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x81);</span>
    emit_operand(rsp, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::andq(Register dst, int32_t imm32) {
<span class="line-new-header">--- 8059,58 ---</span>
  }
  
  void Assembler::addq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
<span class="line-modified">!   emit_arith_operand(0x81, rax, dst, imm32);</span>
  }
  
  void Assembler::addq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst, src), 0x01);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::addq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
    emit_arith(0x81, 0xC0, dst, imm32);
  }
  
  void Assembler::addq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x03);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::addq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x03, 0xC0, dst, src);
  }
  
  void Assembler::adcxq(Register dst, Register src) {
    //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
<span class="line-modified">!   emit_int8(0x66);</span>
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int32(0x0F,</span>
<span class="line-modified">!              0x38,</span>
<span class="line-modified">!              (unsigned char)0xF6,</span>
<span class="line-modified">!              (0xC0 | encode));</span>
  }
  
  void Assembler::adoxq(Register dst, Register src) {
    //assert(VM_Version::supports_adx(), &quot;adx instructions not supported&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int32(0x0F,</span>
<span class="line-modified">!              0x38,</span>
<span class="line-modified">!              (unsigned char)0xF6,</span>
<span class="line-modified">!              (0xC0 | encode));</span>
  }
  
  void Assembler::andq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>
    emit_operand(rsp, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::andq(Register dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8607,12 ***</span>
    emit_arith(0x81, 0xE0, dst, imm32);
  }
  
  void Assembler::andq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x23);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::andq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-new-header">--- 8118,11 ---</span>
    emit_arith(0x81, 0xE0, dst, imm32);
  }
  
  void Assembler::andq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x23);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::andq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8621,12 ***</span>
  
  void Assembler::andnq(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::andnq(Register dst, Register src1, Address src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 8131,11 ---</span>
  
  void Assembler::andnq(Register dst, Register src1, Register src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), src1-&gt;encoding(), src2-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF2, (0xC0 | encode));</span>
  }
  
  void Assembler::andnq(Register dst, Register src1, Address src2) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8636,34 ***</span>
    emit_operand(dst, src2);
  }
  
  void Assembler::bsfq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBC);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::bsrq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::bswapq(Register reg) {
    int encode = prefixq_and_encode(reg-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC8 | encode));</span>
  }
  
  void Assembler::blsiq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::blsiq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 8145,28 ---</span>
    emit_operand(dst, src2);
  }
  
  void Assembler::bsfq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBC, (0xC0 | encode));</span>
  }
  
  void Assembler::bsrq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>
  }
  
  void Assembler::bswapq(Register reg) {
    int encode = prefixq_and_encode(reg-&gt;encoding());
<span class="line-modified">!   emit_int16(0x0F, (0xC8 | encode));</span>
  }
  
  void Assembler::blsiq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rbx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsiq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8675,12 ***</span>
  
  void Assembler::blsmskq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::blsmskq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 8178,11 ---</span>
  
  void Assembler::blsmskq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rdx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsmskq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8692,12 ***</span>
  
  void Assembler::blsrq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::blsrq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
<span class="line-new-header">--- 8194,11 ---</span>
  
  void Assembler::blsrq(Register dst, Register src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(rcx-&gt;encoding(), dst-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_NONE, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF3, (0xC0 | encode));</span>
  }
  
  void Assembler::blsrq(Register dst, Address src) {
    assert(VM_Version::supports_bmi1(), &quot;bit manipulation instructions not supported&quot;);
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8706,19 ***</span>
    emit_int8((unsigned char)0xF3);
    emit_operand(rcx, src);
  }
  
  void Assembler::cdqq() {
<span class="line-modified">!   prefix(REX_W);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x99);</span>
  }
  
  void Assembler::clflush(Address adr) {
    assert(VM_Version::supports_clflush(), &quot;should do&quot;);
    prefix(adr);
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    emit_operand(rdi, adr);
  }
  
  void Assembler::clflushopt(Address adr) {
    assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
<span class="line-new-header">--- 8207,17 ---</span>
    emit_int8((unsigned char)0xF3);
    emit_operand(rcx, src);
  }
  
  void Assembler::cdqq() {
<span class="line-modified">!   emit_int16(REX_W, (unsigned char)0x99);</span>
  }
  
  void Assembler::clflush(Address adr) {
    assert(VM_Version::supports_clflush(), &quot;should do&quot;);
    prefix(adr);
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xAE);</span>
    emit_operand(rdi, adr);
  }
  
  void Assembler::clflushopt(Address adr) {
    assert(VM_Version::supports_clflushopt(), &quot;should do!&quot;);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8727,13 ***</span>
    assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
    assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
    // instruction prefix is 0x66
    emit_int8(0x66);
    prefix(adr);
<span class="line-modified">!   // opcode family is 0x0f 0xAE</span>
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    // extended opcode byte is 7 == rdi
    emit_operand(rdi, adr);
  }
  
  void Assembler::clwb(Address adr) {
<span class="line-new-header">--- 8226,12 ---</span>
    assert(adr.scale() == Address::no_scale, &quot;scale should be no_scale&quot;);
    assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
    // instruction prefix is 0x66
    emit_int8(0x66);
    prefix(adr);
<span class="line-modified">!   // opcode family is 0x0F 0xAE</span>
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xAE);</span>
    // extended opcode byte is 7 == rdi
    emit_operand(rdi, adr);
  }
  
  void Assembler::clwb(Address adr) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8744,35 ***</span>
    assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
    // instruction prefix is 0x66
    emit_int8(0x66);
    prefix(adr);
    // opcode family is 0x0f 0xAE
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    // extended opcode byte is 6 == rsi
    emit_operand(rsi, adr);
  }
  
  void Assembler::cmovq(Condition cc, Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x40 | cc);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cmovq(Condition cc, Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x40 | cc);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x81);</span>
    emit_operand(rdi, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::cmpq(Register dst, int32_t imm32) {
<span class="line-new-header">--- 8242,29 ---</span>
    assert(adr.disp() == 0, &quot;displacement should be 0&quot;);
    // instruction prefix is 0x66
    emit_int8(0x66);
    prefix(adr);
    // opcode family is 0x0f 0xAE
<span class="line-modified">!   emit_int16(0x0F, (unsigned char)0xAE);</span>
    // extended opcode byte is 6 == rsi
    emit_operand(rsi, adr);
  }
  
  void Assembler::cmovq(Condition cc, Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (0x40 | cc), (0xC0 | encode));</span>
  }
  
  void Assembler::cmovq(Condition cc, Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(src, dst), 0x0F, (0x40 | cc));</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>
    emit_operand(rdi, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::cmpq(Register dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8780,41 ***</span>
    emit_arith(0x81, 0xF8, dst, imm32);
  }
  
  void Assembler::cmpq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst, src);</span>
<span class="line-removed">-   emit_int8(0x3B);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::cmpq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x3B, 0xC0, dst, src);
  }
  
<span class="line-modified">! void Assembler::cmpq(Register dst, Address  src) {</span>
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x3B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpxchgq(Register reg, Address adr) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(adr, reg);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB1);</span>
    emit_operand(reg, adr);
  }
  
  void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2A);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
<span class="line-new-header">--- 8272,36 ---</span>
    emit_arith(0x81, 0xF8, dst, imm32);
  }
  
  void Assembler::cmpq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst, src), 0x3B);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::cmpq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x3B, 0xC0, dst, src);
  }
  
<span class="line-modified">! void Assembler::cmpq(Register dst, Address src) {</span>
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x3B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cmpxchgq(Register reg, Address adr) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(adr, reg), 0x0F, (unsigned char)0xB1);</span>
    emit_operand(reg, adr);
  }
  
  void Assembler::cvtsi2sdq(XMMRegister dst, Register src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, dst, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2A, (0xC0 | encode));</span>
  }
  
  void Assembler::cvtsi2sdq(XMMRegister dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8838,158 ***</span>
  void Assembler::cvttsd2siq(Register dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    // F2 REX.W 0F 2C /r
    // CVTTSD2SI r64, xmm1/m64
    InstructionMark im(this);
<span class="line-modified">!   emit_int8((unsigned char)0xF2);</span>
<span class="line-removed">-   prefix(REX_W);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8(0x2C);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::cvttss2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x2C);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
    // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC8 | encode));</span>
  }
  
  void Assembler::decq(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">-   emit_int8(0xC8 | encode);</span>
  }
  
  void Assembler::decq(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFF);</span>
    emit_operand(rcx, dst);
  }
  
  void Assembler::fxrstor(Address src) {
<span class="line-modified">!   prefixq(src);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    emit_operand(as_Register(1), src);
  }
  
  void Assembler::xrstor(Address src) {
<span class="line-modified">!   prefixq(src);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    emit_operand(as_Register(5), src);
  }
  
  void Assembler::fxsave(Address dst) {
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    emit_operand(as_Register(0), dst);
  }
  
  void Assembler::xsave(Address dst) {
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAE);</span>
    emit_operand(as_Register(4), dst);
  }
  
  void Assembler::idivq(Register src) {
    int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
  }
  
  void Assembler::imulq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xAF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::imulq(Register dst, Register src, int value) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    if (is8bit(value)) {
<span class="line-modified">!     emit_int8(0x6B);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-     emit_int8(value &amp; 0xFF);</span>
    } else {
<span class="line-modified">!     emit_int8(0x69);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
      emit_int32(value);
    }
  }
  
  void Assembler::imulq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char) 0xAF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::incl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::incq(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xFF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::incq(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFF);</span>
    emit_operand(rax, dst);
  }
  
  void Assembler::lea(Register dst, Address src) {
    leaq(dst, src);
  }
  
  void Assembler::leaq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x8D);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::mov64(Register dst, int64_t imm64) {
    InstructionMark im(this);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)(0xB8 | encode));</span>
    emit_int64(imm64);
  }
  
  void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
<span class="line-new-header">--- 8325,130 ---</span>
  void Assembler::cvttsd2siq(Register dst, Address src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    // F2 REX.W 0F 2C /r
    // CVTTSD2SI r64, xmm1/m64
    InstructionMark im(this);
<span class="line-modified">!   emit_int32((unsigned char)0xF2, REX_W, 0x0F, 0x2C);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::cvttsd2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F2, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::cvttss2siq(Register dst, XMMRegister src) {
    NOT_LP64(assert(VM_Version::supports_sse(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(as_XMMRegister(dst-&gt;encoding()), xnoreg, src, VEX_SIMD_F3, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x2C, (0xC0 | encode));</span>
  }
  
  void Assembler::decl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementl() instead.
    // Use two-byte form (one-byte form is a REX prefix in 64-bit mode)
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xFF, (0xC8 | encode));</span>
  }
  
  void Assembler::decq(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xFF, 0xC8 | encode);</span>
  }
  
  void Assembler::decq(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::decrementq() instead.
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>
    emit_operand(rcx, dst);
  }
  
  void Assembler::fxrstor(Address src) {
<span class="line-modified">!   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(1), src);
  }
  
  void Assembler::xrstor(Address src) {
<span class="line-modified">!   emit_int24(get_prefixq(src), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(5), src);
  }
  
  void Assembler::fxsave(Address dst) {
<span class="line-modified">!   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(0), dst);
  }
  
  void Assembler::xsave(Address dst) {
<span class="line-modified">!   emit_int24(get_prefixq(dst), 0x0F, (unsigned char)0xAE);</span>
    emit_operand(as_Register(4), dst);
  }
  
  void Assembler::idivq(Register src) {
    int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xF8 | encode));</span>
  }
  
  void Assembler::imulq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xAF, (0xC0 | encode));</span>
  }
  
  void Assembler::imulq(Register dst, Register src, int value) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    if (is8bit(value)) {
<span class="line-modified">!     emit_int24(0x6B, (0xC0 | encode), (value &amp; 0xFF));</span>
    } else {
<span class="line-modified">!     emit_int16(0x69, (0xC0 | encode));</span>
      emit_int32(value);
    }
  }
  
  void Assembler::imulq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(src, dst), 0x0F, (unsigned char)0xAF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::incl(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementl() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>
  }
  
  void Assembler::incq(Register dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
    // Use two-byte form (one-byte from is a REX prefix in 64-bit mode)
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xFF, (0xC0 | encode));</span>
  }
  
  void Assembler::incq(Address dst) {
    // Don&#39;t use it directly. Use MacroAssembler::incrementq() instead.
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst), (unsigned char)0xFF);</span>
    emit_operand(rax, dst);
  }
  
  void Assembler::lea(Register dst, Address src) {
    leaq(dst, src);
  }
  
  void Assembler::leaq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), (unsigned char)0x8D);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::mov64(Register dst, int64_t imm64) {
    InstructionMark im(this);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0xB8 | encode);</span>
    emit_int64(imm64);
  }
  
  void Assembler::mov_literal64(Register dst, intptr_t imm64, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 8999,11 ***</span>
  }
  
  void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)(0xB8 | encode));</span>
    emit_data((int)imm32, rspec, narrow_oop_operand);
  }
  
  void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
<span class="line-new-header">--- 8458,11 ---</span>
  }
  
  void Assembler::mov_narrow_oop(Register dst, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0xB8 | encode);</span>
    emit_data((int)imm32, rspec, narrow_oop_operand);
  }
  
  void Assembler::mov_narrow_oop(Address dst, int32_t imm32,  RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9014,12 ***</span>
  }
  
  void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(src1-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x81);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
    emit_data((int)imm32, rspec, narrow_oop_operand);
  }
  
  void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
<span class="line-new-header">--- 8473,11 ---</span>
  }
  
  void Assembler::cmp_narrow_oop(Register src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
    int encode = prefix_and_encode(src1-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0x81, (0xF8 | encode));</span>
    emit_data((int)imm32, rspec, narrow_oop_operand);
  }
  
  void Assembler::cmp_narrow_oop(Address src1, int32_t imm32, RelocationHolder const&amp; rspec) {
    InstructionMark im(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9031,204 ***</span>
  
  void Assembler::lzcntq(Register dst, Register src) {
    assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBD);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movdq(XMMRegister dst, Register src) {
    // table D-1 says MMX/SSE2
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x6E);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movdq(Register dst, XMMRegister src) {
    // table D-1 says MMX/SSE2
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    // swap src/dst to get correct prefix
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int8(0x7E);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x8B);</span>
<span class="line-modified">!   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x8B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst, src);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x89);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::movsbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBE);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movsbq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBE);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movslq(Register dst, int32_t imm32) {
    // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
    // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
    // as a result we shouldn&#39;t use until tested at runtime...
    ShouldNotReachHere();
    InstructionMark im(this);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)(0xC7 | encode));</span>
    emit_int32(imm32);
  }
  
  void Assembler::movslq(Address dst, int32_t imm32) {
    assert(is_simm32(imm32), &quot;lost bits&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xC7);</span>
    emit_operand(rax, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::movslq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x63);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movslq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x63);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movswq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movswq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xBF);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::movzbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xB6);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzbq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB6);</span>
<span class="line-removed">-   emit_int8(0xC0 | encode);</span>
  }
  
  void Assembler::movzwq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xB7);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzwq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::mulq(Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF7);</span>
    emit_operand(rsp, src);
  }
  
  void Assembler::mulq(Register src) {
    int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
  }
  
  void Assembler::mulxq(Register dst1, Register dst2, Register src) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF6);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
  }
  
  void Assembler::negq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xD8 | encode));</span>
  }
  
  void Assembler::notq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xD0 | encode));</span>
  }
  
  void Assembler::btsq(Address dst, int imm8) {
    assert(isByte(imm8), &quot;not a byte&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBA);</span>
    emit_operand(rbp /* 5 */, dst, 1);
    emit_int8(imm8);
  }
  
  void Assembler::btrq(Address dst, int imm8) {
    assert(isByte(imm8), &quot;not a byte&quot;);
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-modified">!   emit_int8((unsigned char)0x0F);</span>
<span class="line-modified">!   emit_int8((unsigned char)0xBA);</span>
    emit_operand(rsi /* 6 */, dst, 1);
    emit_int8(imm8);
  }
  
  void Assembler::orq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x81);</span>
    emit_operand(rcx, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::orq(Register dst, int32_t imm32) {
<span class="line-new-header">--- 8489,182 ---</span>
  
  void Assembler::lzcntq(Register dst, Register src) {
    assert(VM_Version::supports_lzcnt(), &quot;encoding is treated as BSR&quot;);
    emit_int8((unsigned char)0xF3);
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBD, (0xC0 | encode));</span>
  }
  
  void Assembler::movdq(XMMRegister dst, Register src) {
    // table D-1 says MMX/SSE2
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = simd_prefix_and_encode(dst, xnoreg, as_XMMRegister(src-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x6E, (0xC0 | encode));</span>
  }
  
  void Assembler::movdq(Register dst, XMMRegister src) {
    // table D-1 says MMX/SSE2
    NOT_LP64(assert(VM_Version::supports_sse2(), &quot;&quot;));
    InstructionAttr attributes(AVX_128bit, /* rex_w */ true, /* legacy_mode */ false, /* no_mask_reg */ true, /* uses_vl */ false);
    // swap src/dst to get correct prefix
    int encode = simd_prefix_and_encode(src, xnoreg, as_XMMRegister(dst-&gt;encoding()), VEX_SIMD_66, VEX_OPCODE_0F, &amp;attributes);
<span class="line-modified">!   emit_int16(0x7E,</span>
<span class="line-modified">!              (0xC0 | encode));</span>
  }
  
  void Assembler::movq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0x8B,</span>
<span class="line-modified">!              (0xC0 | encode));</span>
  }
  
  void Assembler::movq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), (unsigned char)0x8B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst, src), (unsigned char)0x89);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::movsbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">!              0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBE);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movsbq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBE, (0xC0 | encode));</span>
  }
  
  void Assembler::movslq(Register dst, int32_t imm32) {
    // dbx shows movslq(rcx, 3) as movq     $0x0000000049000000,(%rbx)
    // and movslq(r8, 3); as movl     $0x0000000048000000,(%rbx)
    // as a result we shouldn&#39;t use until tested at runtime...
    ShouldNotReachHere();
    InstructionMark im(this);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8(0xC7 | encode);</span>
    emit_int32(imm32);
  }
  
  void Assembler::movslq(Address dst, int32_t imm32) {
    assert(is_simm32(imm32), &quot;lost bits&quot;);
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst), (unsigned char)0xC7);</span>
    emit_operand(rax, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::movslq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x63);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movslq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int16(0x63, (0xC0 | encode));</span>
  }
  
  void Assembler::movswq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">!              0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBF);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movswq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xBF, (0xC0 | encode));</span>
  }
  
  void Assembler::movzbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">!              0x0F,</span>
<span class="line-modified">!              (unsigned char)0xB6);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzbq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xB6, (0xC0 | encode));</span>
  }
  
  void Assembler::movzwq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(src, dst),</span>
<span class="line-modified">!              0x0F,</span>
<span class="line-modified">!              (unsigned char)0xB7);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::movzwq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int24(0x0F, (unsigned char)0xB7, (0xC0 | encode));</span>
  }
  
  void Assembler::mulq(Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src), (unsigned char)0xF7);</span>
    emit_operand(rsp, src);
  }
  
  void Assembler::mulq(Register src) {
    int encode = prefixq_and_encode(src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xE0 | encode));</span>
  }
  
  void Assembler::mulxq(Register dst1, Register dst2, Register src) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst1-&gt;encoding(), dst2-&gt;encoding(), src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_38, &amp;attributes);
<span class="line-modified">!   emit_int16((unsigned char)0xF6, (0xC0 | encode));</span>
  }
  
  void Assembler::negq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xD8 | encode));</span>
  }
  
  void Assembler::notq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xF7, (0xD0 | encode));</span>
  }
  
  void Assembler::btsq(Address dst, int imm8) {
    assert(isByte(imm8), &quot;not a byte&quot;);
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(dst),</span>
<span class="line-modified">!              0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBA);</span>
    emit_operand(rbp /* 5 */, dst, 1);
    emit_int8(imm8);
  }
  
  void Assembler::btrq(Address dst, int imm8) {
    assert(isByte(imm8), &quot;not a byte&quot;);
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(dst),</span>
<span class="line-modified">!              0x0F,</span>
<span class="line-modified">!              (unsigned char)0xBA);</span>
    emit_operand(rsi /* 6 */, dst, 1);
    emit_int8(imm8);
  }
  
  void Assembler::orq(Address dst, int32_t imm32) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst), (unsigned char)0x81);</span>
    emit_operand(rcx, dst, 4);
    emit_int32(imm32);
  }
  
  void Assembler::orq(Register dst, int32_t imm32) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9236,21 ***</span>
    emit_arith(0x81, 0xC8, dst, imm32);
  }
  
  void Assembler::orq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x0B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::orq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x0B, 0xC0, dst, src);
  }
  
  void Assembler::popa() { // 64bit
    movq(r15, Address(rsp, 0));
    movq(r14, Address(rsp, wordSize));
    movq(r13, Address(rsp, 2 * wordSize));
    movq(r12, Address(rsp, 3 * wordSize));
    movq(r11, Address(rsp, 4 * wordSize));
<span class="line-new-header">--- 8672,114 ---</span>
    emit_arith(0x81, 0xC8, dst, imm32);
  }
  
  void Assembler::orq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x0B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::orq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x0B, 0xC0, dst, src);
  }
  
<span class="line-added">+ void Assembler::popcntq(Register dst, Address src) {</span>
<span class="line-added">+   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   emit_int32((unsigned char)0xF3,</span>
<span class="line-added">+              get_prefixq(src, dst),</span>
<span class="line-added">+              0x0F,</span>
<span class="line-added">+              (unsigned char)0xB8);</span>
<span class="line-added">+   emit_operand(dst, src);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::popcntq(Register dst, Register src) {</span>
<span class="line-added">+   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-added">+   emit_int8((unsigned char)0xF3);</span>
<span class="line-added">+   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="line-added">+   emit_int24(0x0F, (unsigned char)0xB8, (0xC0 | encode));</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::popq(Address dst) {</span>
<span class="line-added">+   InstructionMark im(this);</span>
<span class="line-added">+   emit_int16(get_prefixq(dst), (unsigned char)0x8F);</span>
<span class="line-added">+   emit_operand(rax, dst);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Precomputable: popa, pusha, vzeroupper</span>
<span class="line-added">+ </span>
<span class="line-added">+ // The result of these routines are invariant from one invocation to another</span>
<span class="line-added">+ // invocation for the duration of a run. Caching the result on bootstrap</span>
<span class="line-added">+ // and copying it out on subsequent invocations can thus be beneficial</span>
<span class="line-added">+ static bool     precomputed = false;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u_char* popa_code  = NULL;</span>
<span class="line-added">+ static int     popa_len   = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u_char* pusha_code = NULL;</span>
<span class="line-added">+ static int     pusha_len  = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ static u_char* vzup_code  = NULL;</span>
<span class="line-added">+ static int     vzup_len   = 0;</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::precompute_instructions() {</span>
<span class="line-added">+   assert(!Universe::is_fully_initialized(), &quot;must still be single threaded&quot;);</span>
<span class="line-added">+   guarantee(!precomputed, &quot;only once&quot;);</span>
<span class="line-added">+   precomputed = true;</span>
<span class="line-added">+   ResourceMark rm;</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Make a temporary buffer big enough for the routines we&#39;re capturing</span>
<span class="line-added">+   int size = 256;</span>
<span class="line-added">+   char* tmp_code = NEW_RESOURCE_ARRAY(char, size);</span>
<span class="line-added">+   CodeBuffer buffer((address)tmp_code, size);</span>
<span class="line-added">+   MacroAssembler masm(&amp;buffer);</span>
<span class="line-added">+ </span>
<span class="line-added">+   address begin_popa  = masm.code_section()-&gt;end();</span>
<span class="line-added">+   masm.popa_uncached();</span>
<span class="line-added">+   address end_popa    = masm.code_section()-&gt;end();</span>
<span class="line-added">+   masm.pusha_uncached();</span>
<span class="line-added">+   address end_pusha   = masm.code_section()-&gt;end();</span>
<span class="line-added">+   masm.vzeroupper_uncached();</span>
<span class="line-added">+   address end_vzup    = masm.code_section()-&gt;end();</span>
<span class="line-added">+ </span>
<span class="line-added">+   // Save the instructions to permanent buffers.</span>
<span class="line-added">+   popa_len = (int)(end_popa - begin_popa);</span>
<span class="line-added">+   popa_code = NEW_C_HEAP_ARRAY(u_char, popa_len, mtInternal);</span>
<span class="line-added">+   memcpy(popa_code, begin_popa, popa_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+   pusha_len = (int)(end_pusha - end_popa);</span>
<span class="line-added">+   pusha_code = NEW_C_HEAP_ARRAY(u_char, pusha_len, mtInternal);</span>
<span class="line-added">+   memcpy(pusha_code, end_popa, pusha_len);</span>
<span class="line-added">+ </span>
<span class="line-added">+   vzup_len = (int)(end_vzup - end_pusha);</span>
<span class="line-added">+   if (vzup_len &gt; 0) {</span>
<span class="line-added">+     vzup_code = NEW_C_HEAP_ARRAY(u_char, vzup_len, mtInternal);</span>
<span class="line-added">+     memcpy(vzup_code, end_pusha, vzup_len);</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     vzup_code = pusha_code; // dummy</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+   assert(masm.code()-&gt;total_oop_size() == 0 &amp;&amp;</span>
<span class="line-added">+          masm.code()-&gt;total_metadata_size() == 0 &amp;&amp;</span>
<span class="line-added">+          masm.code()-&gt;total_relocation_size() == 0,</span>
<span class="line-added">+          &quot;pre-computed code can&#39;t reference oops, metadata or contain relocations&quot;);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ static void emit_copy(CodeSection* code_section, u_char* src, int src_len) {</span>
<span class="line-added">+   assert(src != NULL, &quot;code to copy must have been pre-computed&quot;);</span>
<span class="line-added">+   assert(code_section-&gt;limit() - code_section-&gt;end() &gt; src_len, &quot;code buffer not large enough&quot;);</span>
<span class="line-added">+   address end = code_section-&gt;end();</span>
<span class="line-added">+   memcpy(end, src, src_len);</span>
<span class="line-added">+   code_section-&gt;set_end(end + src_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::popa() { // 64bit
<span class="line-added">+   emit_copy(code_section(), popa_code, popa_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ void Assembler::popa_uncached() { // 64bit</span>
    movq(r15, Address(rsp, 0));
    movq(r14, Address(rsp, wordSize));
    movq(r13, Address(rsp, 2 * wordSize));
    movq(r12, Address(rsp, 3 * wordSize));
    movq(r11, Address(rsp, 4 * wordSize));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9267,37 ***</span>
    movq(rax, Address(rsp, 15 * wordSize));
  
    addq(rsp, 16 * wordSize);
  }
  
<span class="line-modified">! void Assembler::popcntq(Register dst, Address src) {</span>
<span class="line-modified">!   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-removed">-   InstructionMark im(this);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">-   emit_operand(dst, src);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Assembler::popcntq(Register dst, Register src) {</span>
<span class="line-removed">-   assert(VM_Version::supports_popcnt(), &quot;must support&quot;);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xF3);</span>
<span class="line-removed">-   int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());</span>
<span class="line-removed">-   emit_int8((unsigned char)0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xB8);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- void Assembler::popq(Address dst) {</span>
<span class="line-removed">-   InstructionMark im(this);</span>
<span class="line-removed">-   prefixq(dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x8F);</span>
<span class="line-removed">-   emit_operand(rax, dst);</span>
  }
  
<span class="line-modified">! void Assembler::pusha() { // 64bit</span>
    // we have to store original rsp.  ABI says that 128 bytes
    // below rsp are local scratch.
    movq(Address(rsp, -5 * wordSize), rsp);
  
    subq(rsp, 16 * wordSize);
<span class="line-new-header">--- 8796,15 ---</span>
    movq(rax, Address(rsp, 15 * wordSize));
  
    addq(rsp, 16 * wordSize);
  }
  
<span class="line-modified">! void Assembler::pusha() { // 64bit</span>
<span class="line-modified">!   emit_copy(code_section(), pusha_code, pusha_len);</span>
  }
  
<span class="line-modified">! void Assembler::pusha_uncached() { // 64bit</span>
    // we have to store original rsp.  ABI says that 128 bytes
    // below rsp are local scratch.
    movq(Address(rsp, -5 * wordSize), rsp);
  
    subq(rsp, 16 * wordSize);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9318,91 ***</span>
    movq(Address(rsp, 2 * wordSize), r13);
    movq(Address(rsp, wordSize), r14);
    movq(Address(rsp, 0), r15);
  }
  
  void Assembler::pushq(Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xFF);</span>
    emit_operand(rsi, src);
  }
  
  void Assembler::rclq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xD0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xD0 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::rcrq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xD8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xD8 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::rorq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xc8 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::rorxq(Register dst, Register src, int imm8) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF0);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::rorxd(Register dst, Register src, int imm8) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int8((unsigned char)0xF0);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xC0 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::sarq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xF8 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::sarq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xF8 | encode));</span>
  }
  
  void Assembler::sbbq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
<span class="line-new-header">--- 8825,77 ---</span>
    movq(Address(rsp, 2 * wordSize), r13);
    movq(Address(rsp, wordSize), r14);
    movq(Address(rsp, 0), r15);
  }
  
<span class="line-added">+ void Assembler::vzeroupper() {</span>
<span class="line-added">+   emit_copy(code_section(), vzup_code, vzup_len);</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  void Assembler::pushq(Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src), (unsigned char)0xFF);</span>
    emit_operand(rsi, src);
  }
  
  void Assembler::rclq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xD0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xD0 | encode), imm8);</span>
    }
  }
  
  void Assembler::rcrq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xD8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xD8 | encode), imm8);</span>
    }
  }
  
  void Assembler::rorq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xC8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xc8 | encode), imm8);</span>
    }
  }
  
  void Assembler::rorxq(Register dst, Register src, int imm8) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ true, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::rorxd(Register dst, Register src, int imm8) {
    assert(VM_Version::supports_bmi2(), &quot;bit manipulation instructions not supported&quot;);
    InstructionAttr attributes(AVX_128bit, /* vex_w */ false, /* legacy_mode */ true, /* no_mask_reg */ true, /* uses_vl */ false);
    int encode = vex_prefix_and_encode(dst-&gt;encoding(), 0, src-&gt;encoding(), VEX_SIMD_F2, VEX_OPCODE_0F_3A, &amp;attributes);
<span class="line-modified">!   emit_int24((unsigned char)0xF0, (0xC0 | encode), imm8);</span>
  }
  
  void Assembler::sarq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xF8 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xF8 | encode), imm8);</span>
    }
  }
  
  void Assembler::sarq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xF8 | encode));</span>
  }
  
  void Assembler::sbbq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9414,12 ***</span>
    emit_arith(0x81, 0xD8, dst, imm32);
  }
  
  void Assembler::sbbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x1B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::sbbq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-new-header">--- 8907,11 ---</span>
    emit_arith(0x81, 0xD8, dst, imm32);
  }
  
  void Assembler::sbbq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x1B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::sbbq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9428,49 ***</span>
  
  void Assembler::shlq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int8((unsigned char)0xD1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xE0 | encode));</span>
<span class="line-removed">-     emit_int8(imm8);</span>
    }
  }
  
  void Assembler::shlq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE0 | encode));</span>
  }
  
  void Assembler::shrq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xC1);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xE8 | encode));</span>
<span class="line-removed">-   emit_int8(imm8);</span>
  }
  
  void Assembler::shrq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0xD3);</span>
<span class="line-removed">-   emit_int8(0xE8 | encode);</span>
  }
  
  void Assembler::subq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
    emit_arith_operand(0x81, rbp, dst, imm32);
  }
  
  void Assembler::subq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst, src);</span>
<span class="line-removed">-   emit_int8(0x29);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::subq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
<span class="line-new-header">--- 8920,41 ---</span>
  
  void Assembler::shlq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
    if (imm8 == 1) {
<span class="line-modified">!     emit_int16((unsigned char)0xD1, (0xE0 | encode));</span>
    } else {
<span class="line-modified">!     emit_int24((unsigned char)0xC1, (0xE0 | encode), imm8);</span>
    }
  }
  
  void Assembler::shlq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xD3, (0xE0 | encode));</span>
  }
  
  void Assembler::shrq(Register dst, int imm8) {
    assert(isShiftCount(imm8 &gt;&gt; 1), &quot;illegal shift count&quot;);
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int24((unsigned char)0xC1, (0xE8 | encode), imm8);</span>
  }
  
  void Assembler::shrq(Register dst) {
    int encode = prefixq_and_encode(dst-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0xD3, 0xE8 | encode);</span>
  }
  
  void Assembler::subq(Address dst, int32_t imm32) {
    InstructionMark im(this);
    prefixq(dst);
    emit_arith_operand(0x81, rbp, dst, imm32);
  }
  
  void Assembler::subq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(dst, src), 0x29);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::subq(Register dst, int32_t imm32) {
    (void) prefixq_and_encode(dst-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9483,12 ***</span>
    emit_arith_imm32(0x81, 0xE8, dst, imm32);
  }
  
  void Assembler::subq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x2B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::subq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-new-header">--- 8967,11 ---</span>
    emit_arith_imm32(0x81, 0xE8, dst, imm32);
  }
  
  void Assembler::subq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x2B);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::subq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9499,16 ***</span>
    // not using emit_arith because test
    // doesn&#39;t support sign-extension of
    // 8bit operands
    int encode = dst-&gt;encoding();
    if (encode == 0) {
<span class="line-modified">!     prefix(REX_W);</span>
<span class="line-removed">-     emit_int8((unsigned char)0xA9);</span>
    } else {
      encode = prefixq_and_encode(encode);
<span class="line-modified">!     emit_int8((unsigned char)0xF7);</span>
<span class="line-removed">-     emit_int8((unsigned char)(0xC0 | encode));</span>
    }
    emit_int32(imm32);
  }
  
  void Assembler::testq(Register dst, Register src) {
<span class="line-new-header">--- 8982,14 ---</span>
    // not using emit_arith because test
    // doesn&#39;t support sign-extension of
    // 8bit operands
    int encode = dst-&gt;encoding();
    if (encode == 0) {
<span class="line-modified">!     emit_int16(REX_W, (unsigned char)0xA9);</span>
    } else {
      encode = prefixq_and_encode(encode);
<span class="line-modified">!     emit_int16((unsigned char)0xF7, (0xC0 | encode));</span>
    }
    emit_int32(imm32);
  }
  
  void Assembler::testq(Register dst, Register src) {
</pre>
<hr />
<pre>
<span class="line-old-header">*** 9516,44 ***</span>
    emit_arith(0x85, 0xC0, dst, src);
  }
  
  void Assembler::testq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x85);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xaddq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(dst, src);</span>
<span class="line-removed">-   emit_int8(0x0F);</span>
<span class="line-removed">-   emit_int8((unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xchgq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8((unsigned char)0x87);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xchgq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int8((unsigned char)0x87);</span>
<span class="line-removed">-   emit_int8((unsigned char)(0xc0 | encode));</span>
  }
  
  void Assembler::xorq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x33, 0xC0, dst, src);
  }
  
  void Assembler::xorq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   prefixq(src, dst);</span>
<span class="line-removed">-   emit_int8(0x33);</span>
    emit_operand(dst, src);
  }
  
  #endif // !LP64
<span class="line-new-header">--- 8997,38 ---</span>
    emit_arith(0x85, 0xC0, dst, src);
  }
  
  void Assembler::testq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), (unsigned char)0x85);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xaddq(Address dst, Register src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int24(get_prefixq(dst, src), 0x0F, (unsigned char)0xC1);</span>
    emit_operand(src, dst);
  }
  
  void Assembler::xchgq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), (unsigned char)0x87);</span>
    emit_operand(dst, src);
  }
  
  void Assembler::xchgq(Register dst, Register src) {
    int encode = prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
<span class="line-modified">!   emit_int16((unsigned char)0x87, (0xc0 | encode));</span>
  }
  
  void Assembler::xorq(Register dst, Register src) {
    (void) prefixq_and_encode(dst-&gt;encoding(), src-&gt;encoding());
    emit_arith(0x33, 0xC0, dst, src);
  }
  
  void Assembler::xorq(Register dst, Address src) {
    InstructionMark im(this);
<span class="line-modified">!   emit_int16(get_prefixq(src, dst), 0x33);</span>
    emit_operand(dst, src);
  }
  
  #endif // !LP64
</pre>
<center><a href="../sparc/vm_version_sparc.cpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="assembler_x86.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
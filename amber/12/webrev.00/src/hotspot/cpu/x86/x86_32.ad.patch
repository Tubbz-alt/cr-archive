diff a/src/hotspot/cpu/x86/x86_32.ad b/src/hotspot/cpu/x86/x86_32.ad
--- a/src/hotspot/cpu/x86/x86_32.ad
+++ b/src/hotspot/cpu/x86/x86_32.ad
@@ -1,7 +1,7 @@
 //
-// Copyright (c) 1997, 2018, Oracle and/or its affiliates. All rights reserved.
+// Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 //
 // This code is free software; you can redistribute it and/or modify it
 // under the terms of the GNU General Public License version 2 only, as
 // published by the Free Software Foundation.
@@ -312,16 +312,10 @@
 int MachCallRuntimeNode::ret_addr_offset() {
   assert(sizeof_FFree_Float_Stack_All != -1, "must have been emitted already");
   return sizeof_FFree_Float_Stack_All + 5 + pre_call_resets_size();
 }
 
-// Indicate if the safepoint node needs the polling page as an input.
-// Since x86 does have absolute addressing, it doesn't.
-bool SafePointNode::needs_polling_address_input() {
-  return SafepointMechanism::uses_thread_local_poll();
-}
-
 //
 // Compute padding required for nodes which need alignment
 //
 
 // The address of the call instruction needs to be 4-byte aligned to
@@ -521,11 +515,11 @@
 
 
 //=============================================================================
 const RegMask& MachConstantBaseNode::_out_RegMask = RegMask::Empty;
 
-int Compile::ConstantTable::calculate_table_base_offset() const {
+int ConstantTable::calculate_table_base_offset() const {
   return 0;  // absolute addressing, no offset
 }
 
 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
 void MachConstantBaseNode::postalloc_expand(GrowableArray <Node *> *nodes, PhaseRegAlloc *ra_) {
@@ -550,17 +544,17 @@
 //=============================================================================
 #ifndef PRODUCT
 void MachPrologNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
   Compile* C = ra_->C;
 
-  int framesize = C->frame_size_in_bytes();
-  int bangsize = C->bang_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
+  int bangsize = C->output()->bang_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
   // Remove wordSize for return addr which is already pushed.
   framesize -= wordSize;
 
-  if (C->need_stack_bang(bangsize)) {
+  if (C->output()->need_stack_bang(bangsize)) {
     framesize -= wordSize;
     st->print("# stack bang (%d bytes)", bangsize);
     st->print("\n\t");
     st->print("PUSH   EBP\t# Save EBP");
     if (PreserveFramePointer) {
@@ -614,21 +608,21 @@
 
 void MachPrologNode::emit(CodeBuffer &cbuf, PhaseRegAlloc *ra_) const {
   Compile* C = ra_->C;
   MacroAssembler _masm(&cbuf);
 
-  int framesize = C->frame_size_in_bytes();
-  int bangsize = C->bang_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
+  int bangsize = C->output()->bang_size_in_bytes();
 
-  __ verified_entry(framesize, C->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != NULL);
+  __ verified_entry(framesize, C->output()->need_stack_bang(bangsize)?bangsize:0, C->in_24_bit_fp_mode(), C->stub_function() != NULL);
 
-  C->set_frame_complete(cbuf.insts_size());
+  C->output()->set_frame_complete(cbuf.insts_size());
 
   if (C->has_mach_constant_base_node()) {
     // NOTE: We set the table base offset here because users might be
     // emitted before MachConstantBaseNode.
-    Compile::ConstantTable& constant_table = C->constant_table();
+    ConstantTable& constant_table = C->output()->constant_table();
     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
   }
 }
 
 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
@@ -641,11 +635,11 @@
 
 //=============================================================================
 #ifndef PRODUCT
 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream* st ) const {
   Compile *C = ra_->C;
-  int framesize = C->frame_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
   // Remove two words for return addr and rbp,
   framesize -= 2*wordSize;
 
   if (C->max_vector_size() > 16) {
@@ -680,11 +674,11 @@
   // If method set FPU control word, restore to standard control word
   if (C->in_24_bit_fp_mode()) {
     _masm.fldcw(ExternalAddress(StubRoutines::addr_fpu_cntrl_wrd_std()));
   }
 
-  int framesize = C->frame_size_in_bytes();
+  int framesize = C->output()->frame_size_in_bytes();
   assert((framesize & (StackAlignmentInBytes-1)) == 0, "frame size not aligned");
   // Remove two words for return addr and rbp,
   framesize -= 2*wordSize;
 
   // Note that VerifyStackAtCalls' Majik cookie does not change the frame size popped here
@@ -704,23 +698,16 @@
   if (StackReservedPages > 0 && C->has_reserved_stack_access()) {
     __ reserved_stack_check();
   }
 
   if (do_polling() && C->is_method_compilation()) {
-    if (SafepointMechanism::uses_thread_local_poll()) {
-      Register pollReg = as_Register(EBX_enc);
-      MacroAssembler masm(&cbuf);
-      masm.get_thread(pollReg);
-      masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
-      masm.relocate(relocInfo::poll_return_type);
-      masm.testl(rax, Address(pollReg, 0));
-    } else {
-      cbuf.relocate(cbuf.insts_end(), relocInfo::poll_return_type, 0);
-      emit_opcode(cbuf,0x85);
-      emit_rm(cbuf, 0x0, EAX_enc, 0x5); // EAX
-      emit_d32(cbuf, (intptr_t)os::get_polling_page());
-    }
+    Register pollReg = as_Register(EBX_enc);
+    MacroAssembler masm(&cbuf);
+    masm.get_thread(pollReg);
+    masm.movl(pollReg, Address(pollReg, in_bytes(Thread::polling_page_offset())));
+    masm.relocate(relocInfo::poll_return_type);
+    masm.testl(rax, Address(pollReg, 0));
   }
 }
 
 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
   return MachNode::size(ra_); // too many variables; just compute it
@@ -733,12 +720,10 @@
 
 const Pipeline * MachEpilogNode::pipeline() const {
   return MachNode::pipeline_class();
 }
 
-int MachEpilogNode::safepoint_offset() const { return 0; }
-
 //=============================================================================
 
 enum RC { rc_bad, rc_int, rc_float, rc_xmm, rc_stack };
 static enum RC rc_class( OptoReg::Name reg ) {
 
@@ -3146,22 +3131,10 @@
     int displace = $mem$$disp;
     relocInfo::relocType disp_reloc = $mem->disp_reloc(); // disp-as-oop when working with static globals
     encode_RegMem(cbuf, rm_byte_opcode, base, index, scale, displace, disp_reloc);
   %}
 
-  // Safepoint Poll.  This polls the safepoint page, and causes an
-  // exception if it is not readable. Unfortunately, it kills the condition code
-  // in the process
-  // We current use TESTL [spp],EDI
-  // A better choice might be TESTB [spp + pagesize() - CacheLineSize()],0
-
-  enc_class Safepoint_Poll() %{
-    cbuf.relocate(cbuf.insts_mark(), relocInfo::poll_type, 0);
-    emit_opcode(cbuf,0x85);
-    emit_rm (cbuf, 0x0, 0x7, 0x5);
-    emit_d32(cbuf, (intptr_t)os::get_polling_page());
-  %}
 %}
 
 
 //----------FRAME--------------------------------------------------------------
 // Definition of frame structure and management information.
@@ -3394,10 +3367,19 @@
   op_cost(5);
   format %{ %}
   interface(CONST_INTER);
 %}
 
+operand immU8() %{
+  predicate((0 <= n->get_int()) && (n->get_int() <= 255));
+  match(ConI);
+
+  op_cost(5);
+  format %{ %}
+  interface(CONST_INTER);
+%}
+
 operand immI16() %{
   predicate((-32768 <= n->get_int()) && (n->get_int() <= 32767));
   match(ConI);
 
   op_cost(10);
@@ -13439,32 +13421,11 @@
 
 
 
 // ============================================================================
 // Safepoint Instruction
-instruct safePoint_poll(eFlagsReg cr) %{
-  predicate(SafepointMechanism::uses_global_page_poll());
-  match(SafePoint);
-  effect(KILL cr);
-
-  // TODO-FIXME: we currently poll at offset 0 of the safepoint polling page.
-  // On SPARC that might be acceptable as we can generate the address with
-  // just a sethi, saving an or.  By polling at offset 0 we can end up
-  // putting additional pressure on the index-0 in the D$.  Because of
-  // alignment (just like the situation at hand) the lower indices tend
-  // to see more traffic.  It'd be better to change the polling address
-  // to offset 0 of the last $line in the polling page.
-
-  format %{ "TSTL   #polladdr,EAX\t! Safepoint: poll for GC" %}
-  ins_cost(125);
-  size(6) ;
-  ins_encode( Safepoint_Poll() );
-  ins_pipe( ialu_reg_mem );
-%}
-
 instruct safePoint_poll_tls(eFlagsReg cr, eRegP_no_EBP poll) %{
-  predicate(SafepointMechanism::uses_thread_local_poll());
   match(SafePoint poll);
   effect(KILL cr, USE poll);
 
   format %{ "TSTL   #EAX,[$poll]\t! Safepoint: poll for GC" %}
   ins_cost(125);

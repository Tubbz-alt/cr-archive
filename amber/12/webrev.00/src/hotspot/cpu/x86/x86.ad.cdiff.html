<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/x86/x86.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="vm_version_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_32.ad.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/x86/x86.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 1163,23 ***</span>
      return 5 + NativeJump::instruction_size; // pushl(); jmp;
    }
  #endif
  };
  
  %} // end source_hpp
  
  source %{
  
  #include &quot;opto/addnode.hpp&quot;
  
  // Emit exception handler code.
  // Stuff framesize into a register and call a VM stub routine.
  int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
  
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
<span class="line-new-header">--- 1163,63 ---</span>
      return 5 + NativeJump::instruction_size; // pushl(); jmp;
    }
  #endif
  };
  
<span class="line-added">+ class Node::PD {</span>
<span class="line-added">+ public:</span>
<span class="line-added">+   enum NodeFlags {</span>
<span class="line-added">+     Flag_intel_jcc_erratum = Node::_last_flag &lt;&lt; 1,</span>
<span class="line-added">+     _last_flag             = Flag_intel_jcc_erratum</span>
<span class="line-added">+   };</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
  %} // end source_hpp
  
  source %{
  
  #include &quot;opto/addnode.hpp&quot;
<span class="line-added">+ #include &quot;c2_intelJccErratum_x86.hpp&quot;</span>
<span class="line-added">+ </span>
<span class="line-added">+ void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">+   if (VM_Version::has_intel_jcc_erratum()) {</span>
<span class="line-added">+     int extra_padding = IntelJccErratum::tag_affected_machnodes(C, C-&gt;cfg(), C-&gt;regalloc());</span>
<span class="line-added">+     _buf_sizes._code += extra_padding;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int MachNode::pd_alignment_required() const {</span>
<span class="line-added">+   PhaseOutput* output = Compile::current()-&gt;output();</span>
<span class="line-added">+   Block* block = output-&gt;block();</span>
<span class="line-added">+   int index = output-&gt;index();</span>
<span class="line-added">+   if (VM_Version::has_intel_jcc_erratum() &amp;&amp; IntelJccErratum::is_jcc_erratum_branch(block, this, index)) {</span>
<span class="line-added">+     // Conservatively add worst case padding. We assume that relocInfo::addr_unit() is 1 on x86.</span>
<span class="line-added">+     return IntelJccErratum::largest_jcc_size() + 1;</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return 1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">+   if (flags() &amp; Node::PD::Flag_intel_jcc_erratum) {</span>
<span class="line-added">+     Compile* C = Compile::current();</span>
<span class="line-added">+     PhaseOutput* output = C-&gt;output();</span>
<span class="line-added">+     Block* block = output-&gt;block();</span>
<span class="line-added">+     int index = output-&gt;index();</span>
<span class="line-added">+     return IntelJccErratum::compute_padding(current_offset, this, block, index, C-&gt;regalloc());</span>
<span class="line-added">+   } else {</span>
<span class="line-added">+     return 0;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ }</span>
  
  // Emit exception handler code.
  // Stuff framesize into a register and call a VM stub routine.
  int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
  
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1193,11 ***</span>
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
<span class="line-new-header">--- 1233,11 ---</span>
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  
    // Note that the code buffer&#39;s insts_mark is always relative to insts.
    // That&#39;s why we must use the macroassembler to generate a handler.
<span class="line-modified">!   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address base = __ start_a_stub(size_deopt_handler());
    if (base == NULL) {
      ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1260,11 ***</span>
        if (!UsePopCountInstruction) {
          return false;
        }
        break;
      case Op_PopCountVI:
<span class="line-modified">!       if (!UsePopCountInstruction || !VM_Version::supports_vpopcntdq()) {</span>
          return false;
        }
        break;
      case Op_MulVI:
        if ((UseSSE &lt; 4) &amp;&amp; (UseAVX &lt; 1)) { // only with SSE4_1 or AVX
<span class="line-new-header">--- 1300,11 ---</span>
        if (!UsePopCountInstruction) {
          return false;
        }
        break;
      case Op_PopCountVI:
<span class="line-modified">!       if (!UsePopCountInstruction || !VM_Version::supports_avx512_vpopcntdq()) {</span>
          return false;
        }
        break;
      case Op_MulVI:
        if ((UseSSE &lt; 4) &amp;&amp; (UseAVX &lt; 1)) { // only with SSE4_1 or AVX
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1275,36 ***</span>
      case Op_MulReductionVL:
        if (VM_Version::supports_avx512dq() == false) {
          return false;
        }
        break;
<span class="line-removed">-     case Op_AddReductionVL:</span>
<span class="line-removed">-       if (UseAVX &lt; 3) { // only EVEX : vector connectivity becomes an issue here</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       break;</span>
      case Op_AbsVB:
      case Op_AbsVS:
      case Op_AbsVI:
      case Op_AddReductionVI:
<span class="line-modified">!       if (UseSSE &lt; 3 || !VM_Version::supports_ssse3()) { // requires at least SSSE3</span>
          return false;
        }
        break;
      case Op_MulReductionVI:
        if (UseSSE &lt; 4) { // requires at least SSE4
          return false;
        }
        break;
<span class="line-removed">-     case Op_AddReductionVF:</span>
<span class="line-removed">-     case Op_AddReductionVD:</span>
<span class="line-removed">-     case Op_MulReductionVF:</span>
<span class="line-removed">-     case Op_MulReductionVD:</span>
<span class="line-removed">-       if (UseSSE &lt; 1) { // requires at least SSE</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       break;</span>
      case Op_SqrtVD:
      case Op_SqrtVF:
        if (UseAVX &lt; 1) { // enabled for AVX only
          return false;
        }
<span class="line-new-header">--- 1315,26 ---</span>
      case Op_MulReductionVL:
        if (VM_Version::supports_avx512dq() == false) {
          return false;
        }
        break;
      case Op_AbsVB:
      case Op_AbsVS:
      case Op_AbsVI:
      case Op_AddReductionVI:
<span class="line-modified">!     case Op_AndReductionV:</span>
<span class="line-added">+     case Op_OrReductionV:</span>
<span class="line-added">+     case Op_XorReductionV:</span>
<span class="line-added">+       if (UseSSE &lt; 3) { // requires at least SSSE3</span>
          return false;
        }
        break;
      case Op_MulReductionVI:
        if (UseSSE &lt; 4) { // requires at least SSE4
          return false;
        }
        break;
      case Op_SqrtVD:
      case Op_SqrtVF:
        if (UseAVX &lt; 1) { // enabled for AVX only
          return false;
        }
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1336,18 ***</span>
      case Op_OnSpinWait:
        if (VM_Version::supports_on_spin_wait() == false) {
          return false;
        }
        break;
<span class="line-removed">-     case Op_MulAddVS2VI:</span>
<span class="line-removed">-     case Op_RShiftVL:</span>
<span class="line-removed">-     case Op_AbsVD:</span>
<span class="line-removed">-     case Op_NegVD:</span>
<span class="line-removed">-       if (UseSSE &lt; 2) {</span>
<span class="line-removed">-         return false;</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       break;</span>
      case Op_MulVB:
      case Op_LShiftVB:
      case Op_RShiftVB:
      case Op_URShiftVB:
        if (UseSSE &lt; 4) {
<span class="line-new-header">--- 1366,10 ---</span>
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1379,10 ***</span>
<span class="line-new-header">--- 1401,33 ---</span>
      case Op_RoundDoubleModeV:
        if (VM_Version::supports_avx() == false) {
          return false; // 128bit vroundpd is not available
        }
        break;
<span class="line-added">+     case Op_MacroLogicV:</span>
<span class="line-added">+       if (UseAVX &lt; 3 || !UseVectorMacroLogic) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ #ifndef _LP64</span>
<span class="line-added">+     case Op_AddReductionVF:</span>
<span class="line-added">+     case Op_AddReductionVD:</span>
<span class="line-added">+     case Op_MulReductionVF:</span>
<span class="line-added">+     case Op_MulReductionVD:</span>
<span class="line-added">+       if (UseSSE &lt; 1) { // requires at least SSE</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+     case Op_MulAddVS2VI:</span>
<span class="line-added">+     case Op_RShiftVL:</span>
<span class="line-added">+     case Op_AbsVD:</span>
<span class="line-added">+     case Op_NegVD:</span>
<span class="line-added">+       if (UseSSE &lt; 2) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
<span class="line-added">+ #endif // !LP64</span>
    }
    return true;  // Match rules are supported by default.
  }
  
  //------------------------------------------------------------------------
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1406,10 ***</span>
<span class="line-new-header">--- 1451,11 ---</span>
    }
    // Special cases which require vector length follow:
    //   * implementation limitations
    //   * some 512bit vector operations on FLOAT and DOUBLE types require AVX512DQ
    //   * 128bit vroundpd instruction is present only in AVX1
<span class="line-added">+   int size_in_bits = vlen * type2aelembytes(bt) * BitsPerByte;</span>
    switch (opcode) {
      case Op_AbsVF:
      case Op_NegVF:
        if ((vlen == 16) &amp;&amp; (VM_Version::supports_avx512dq() == false)) {
          return false; // 512bit vandps and vxorps are not available
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1424,10 ***</span>
<span class="line-new-header">--- 1470,16 ---</span>
      case Op_CMoveVF:
        if (vlen != 8) {
          return false; // implementation limitation (only vcmov8F_reg is present)
        }
        break;
<span class="line-added">+     case Op_MacroLogicV:</span>
<span class="line-added">+       if (!VM_Version::supports_evex() ||</span>
<span class="line-added">+           ((size_in_bits != 512) &amp;&amp; !VM_Version::supports_avx512vl())) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       break;</span>
      case Op_CMoveVD:
        if (vlen != 4) {
          return false; // implementation limitation (only vcmov4D_reg is present)
        }
        break;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1622,14 ***</span>
      return true;
    }
    return false;
  }
  
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="line-modified">! bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    Node *off = m-&gt;in(AddPNode::Offset);
    if (off-&gt;is_Con()) {
      address_visited.test_set(m-&gt;_idx); // Flag as address_visited
      Node *adr = m-&gt;in(AddPNode::Address);
  
<span class="line-new-header">--- 1674,123 ---</span>
      return true;
    }
    return false;
  }
  
<span class="line-added">+ // This function identifies sub-graphs in which a &#39;load&#39; node is</span>
<span class="line-added">+ // input to two different nodes, and such that it can be matched</span>
<span class="line-added">+ // with BMI instructions like blsi, blsr, etc.</span>
<span class="line-added">+ // Example : for b = -a[i] &amp; a[i] can be matched to blsi r32, m32.</span>
<span class="line-added">+ // The graph is (AndL (SubL Con0 LoadL*) LoadL*), where LoadL*</span>
<span class="line-added">+ // refers to the same node.</span>
<span class="line-added">+ //</span>
<span class="line-added">+ // Match the generic fused operations pattern (op1 (op2 Con{ConType} mop) mop)</span>
<span class="line-added">+ // This is a temporary solution until we make DAGs expressible in ADL.</span>
<span class="line-added">+ template&lt;typename ConType&gt;</span>
<span class="line-added">+ class FusedPatternMatcher {</span>
<span class="line-added">+   Node* _op1_node;</span>
<span class="line-added">+   Node* _mop_node;</span>
<span class="line-added">+   int _con_op;</span>
<span class="line-added">+ </span>
<span class="line-added">+   static int match_next(Node* n, int next_op, int next_op_idx) {</span>
<span class="line-added">+     if (n-&gt;in(1) == NULL || n-&gt;in(2) == NULL) {</span>
<span class="line-added">+       return -1;</span>
<span class="line-added">+     }</span>
<span class="line-added">+ </span>
<span class="line-added">+     if (next_op_idx == -1) { // n is commutative, try rotations</span>
<span class="line-added">+       if (n-&gt;in(1)-&gt;Opcode() == next_op) {</span>
<span class="line-added">+         return 1;</span>
<span class="line-added">+       } else if (n-&gt;in(2)-&gt;Opcode() == next_op) {</span>
<span class="line-added">+         return 2;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(next_op_idx &gt; 0 &amp;&amp; next_op_idx &lt;= 2, &quot;Bad argument index&quot;);</span>
<span class="line-added">+       if (n-&gt;in(next_op_idx)-&gt;Opcode() == next_op) {</span>
<span class="line-added">+         return next_op_idx;</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return -1;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ </span>
<span class="line-added">+  public:</span>
<span class="line-added">+   FusedPatternMatcher(Node* op1_node, Node* mop_node, int con_op) :</span>
<span class="line-added">+     _op1_node(op1_node), _mop_node(mop_node), _con_op(con_op) { }</span>
<span class="line-added">+ </span>
<span class="line-added">+   bool match(int op1, int op1_op2_idx,  // op1 and the index of the op1-&gt;op2 edge, -1 if op1 is commutative</span>
<span class="line-added">+              int op2, int op2_con_idx,  // op2 and the index of the op2-&gt;con edge, -1 if op2 is commutative</span>
<span class="line-added">+              typename ConType::NativeType con_value) {</span>
<span class="line-added">+     if (_op1_node-&gt;Opcode() != op1) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     if (_mop_node-&gt;outcnt() &gt; 2) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     op1_op2_idx = match_next(_op1_node, op2, op1_op2_idx);</span>
<span class="line-added">+     if (op1_op2_idx == -1) {</span>
<span class="line-added">+       return false;</span>
<span class="line-added">+     }</span>
<span class="line-added">+     // Memory operation must be the other edge</span>
<span class="line-added">+     int op1_mop_idx = (op1_op2_idx &amp; 1) + 1;</span>
<span class="line-added">+ </span>
<span class="line-added">+     // Check that the mop node is really what we want</span>
<span class="line-added">+     if (_op1_node-&gt;in(op1_mop_idx) == _mop_node) {</span>
<span class="line-added">+       Node* op2_node = _op1_node-&gt;in(op1_op2_idx);</span>
<span class="line-added">+       if (op2_node-&gt;outcnt() &gt; 1) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       assert(op2_node-&gt;Opcode() == op2, &quot;Should be&quot;);</span>
<span class="line-added">+       op2_con_idx = match_next(op2_node, _con_op, op2_con_idx);</span>
<span class="line-added">+       if (op2_con_idx == -1) {</span>
<span class="line-added">+         return false;</span>
<span class="line-added">+       }</span>
<span class="line-added">+       // Memory operation must be the other edge</span>
<span class="line-added">+       int op2_mop_idx = (op2_con_idx &amp; 1) + 1;</span>
<span class="line-added">+       // Check that the memory operation is the same node</span>
<span class="line-added">+       if (op2_node-&gt;in(op2_mop_idx) == _mop_node) {</span>
<span class="line-added">+         // Now check the constant</span>
<span class="line-added">+         const Type* con_type = op2_node-&gt;in(op2_con_idx)-&gt;bottom_type();</span>
<span class="line-added">+         if (con_type != Type::TOP &amp;&amp; ConType::as_self(con_type)-&gt;get_con() == con_value) {</span>
<span class="line-added">+           return true;</span>
<span class="line-added">+         }</span>
<span class="line-added">+       }</span>
<span class="line-added">+     }</span>
<span class="line-added">+     return false;</span>
<span class="line-added">+   }</span>
<span class="line-added">+ };</span>
<span class="line-added">+ </span>
<span class="line-added">+ static bool is_bmi_pattern(Node* n, Node* m) {</span>
<span class="line-added">+   assert(UseBMI1Instructions, &quot;sanity&quot;);</span>
<span class="line-added">+   if (n != NULL &amp;&amp; m != NULL) {</span>
<span class="line-added">+     if (m-&gt;Opcode() == Op_LoadI) {</span>
<span class="line-added">+       FusedPatternMatcher&lt;TypeInt&gt; bmii(n, m, Op_ConI);</span>
<span class="line-added">+       return bmii.match(Op_AndI, -1, Op_SubI,  1,  0)  ||</span>
<span class="line-added">+              bmii.match(Op_AndI, -1, Op_AddI, -1, -1)  ||</span>
<span class="line-added">+              bmii.match(Op_XorI, -1, Op_AddI, -1, -1);</span>
<span class="line-added">+     } else if (m-&gt;Opcode() == Op_LoadL) {</span>
<span class="line-added">+       FusedPatternMatcher&lt;TypeLong&gt; bmil(n, m, Op_ConL);</span>
<span class="line-added">+       return bmil.match(Op_AndL, -1, Op_SubL,  1,  0) ||</span>
<span class="line-added">+              bmil.match(Op_AndL, -1, Op_AddL, -1, -1) ||</span>
<span class="line-added">+              bmil.match(Op_XorL, -1, Op_AddL, -1, -1);</span>
<span class="line-added">+     }</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
<span class="line-added">+ // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added">+ bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added">+   // If &#39;n&#39; and &#39;m&#39; are part of a graph for BMI instruction, clone the input &#39;m&#39;.</span>
<span class="line-added">+   if (UseBMI1Instructions &amp;&amp; is_bmi_pattern(n, m)) {</span>
<span class="line-added">+     mstack.push(m, Visit);</span>
<span class="line-added">+     return true;</span>
<span class="line-added">+   }</span>
<span class="line-added">+   return false;</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="line-modified">! bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    Node *off = m-&gt;in(AddPNode::Offset);
    if (off-&gt;is_Con()) {
      address_visited.test_set(m-&gt;_idx); // Flag as address_visited
      Node *adr = m-&gt;in(AddPNode::Address);
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1671,10 ***</span>
<span class="line-new-header">--- 1832,16 ---</span>
  static inline uint vector_length(const MachNode* n) {
    const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();
    return vt-&gt;length();
  }
  
<span class="line-added">+ static inline uint vector_length(const MachNode* use, MachOper* opnd) {</span>
<span class="line-added">+   uint def_idx = use-&gt;operand_index(opnd);</span>
<span class="line-added">+   Node* def = use-&gt;in(def_idx);</span>
<span class="line-added">+   return def-&gt;bottom_type()-&gt;is_vect()-&gt;length();</span>
<span class="line-added">+ }</span>
<span class="line-added">+ </span>
  static inline uint vector_length_in_bytes(const MachNode* n) {
    const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();
    return vt-&gt;length_in_bytes();
  }
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1708,11 ***</span>
    assert(ireg == Op_VecS || // 32bit vector
           (src_lo &amp; 1) == 0 &amp;&amp; (src_lo + 1) == src_hi &amp;&amp;
           (dst_lo &amp; 1) == 0 &amp;&amp; (dst_lo + 1) == dst_hi,
           &quot;no non-adjacent vector moves&quot; );
    if (cbuf) {
<span class="line-modified">!     MacroAssembler _masm(cbuf);</span>
      int offset = __ offset();
      switch (ireg) {
      case Op_VecS: // copy whole register
      case Op_VecD:
      case Op_VecX:
<span class="line-new-header">--- 1875,11 ---</span>
    assert(ireg == Op_VecS || // 32bit vector
           (src_lo &amp; 1) == 0 &amp;&amp; (src_lo + 1) == src_hi &amp;&amp;
           (dst_lo &amp; 1) == 0 &amp;&amp; (dst_lo + 1) == dst_hi,
           &quot;no non-adjacent vector moves&quot; );
    if (cbuf) {
<span class="line-modified">!     C2_MacroAssembler _masm(cbuf);</span>
      int offset = __ offset();
      switch (ireg) {
      case Op_VecS: // copy whole register
      case Op_VecD:
      case Op_VecX:
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1774,11 ***</span>
                       int stack_offset, int reg, uint ireg, outputStream* st) {
    // In 64-bit VM size calculation is very complex. Emitting instructions
    // into scratch buffer is used to get size in 64-bit VM.
    LP64_ONLY( assert(!do_size, &quot;this method calculates size only for 32-bit VM&quot;); )
    if (cbuf) {
<span class="line-modified">!     MacroAssembler _masm(cbuf);</span>
      int offset = __ offset();
      if (is_load) {
        switch (ireg) {
        case Op_VecS:
          __ movdl(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));
<span class="line-new-header">--- 1941,11 ---</span>
                       int stack_offset, int reg, uint ireg, outputStream* st) {
    // In 64-bit VM size calculation is very complex. Emitting instructions
    // into scratch buffer is used to get size in 64-bit VM.
    LP64_ONLY( assert(!do_size, &quot;this method calculates size only for 32-bit VM&quot;); )
    if (cbuf) {
<span class="line-modified">!     C2_MacroAssembler _masm(cbuf);</span>
      int offset = __ offset();
      if (is_load) {
        switch (ireg) {
        case Op_VecS:
          __ movdl(as_XMMRegister(Matcher::_regEncode[reg]), Address(rsp, stack_offset));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1977,11 ***</span>
      st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
    }
  #endif
  
    void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ nop(_count);
    }
  
    uint MachNopNode::size(PhaseRegAlloc*) const {
      return _count;
<span class="line-new-header">--- 2144,11 ---</span>
      st-&gt;print(&quot;nop \t# %d bytes pad for loops and calls&quot;, _count);
    }
  #endif
  
    void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc*) const {
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ nop(_count);
    }
  
    uint MachNopNode::size(PhaseRegAlloc*) const {
      return _count;
</pre>
<hr />
<pre>
<span class="line-old-header">*** 1992,11 ***</span>
      st-&gt;print(&quot;# breakpoint&quot;);
    }
  #endif
  
    void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">!     MacroAssembler _masm(&amp;cbuf);</span>
      __ int3();
    }
  
    uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {
      return MachNode::size(ra_);
<span class="line-new-header">--- 2159,11 ---</span>
      st-&gt;print(&quot;# breakpoint&quot;);
    }
  #endif
  
    void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">!     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ int3();
    }
  
    uint MachBreakpointNode::size(PhaseRegAlloc* ra_) const {
      return MachNode::size(ra_);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 2008,11 ***</span>
  
    enc_class call_epilog %{
      if (VerifyStackAtCalls) {
        // Check that stack depth is unchanged: find majik cookie on stack
        int framesize = ra_-&gt;reg2offset_unchecked(OptoReg::add(ra_-&gt;_matcher._old_SP, -3*VMRegImpl::slots_per_word));
<span class="line-modified">!       MacroAssembler _masm(&amp;cbuf);</span>
        Label L;
        __ cmpptr(Address(rsp, framesize), (int32_t)0xbadb100d);
        __ jccb(Assembler::equal, L);
        // Die if stack mismatch
        __ int3();
<span class="line-new-header">--- 2175,11 ---</span>
  
    enc_class call_epilog %{
      if (VerifyStackAtCalls) {
        // Check that stack depth is unchanged: find majik cookie on stack
        int framesize = ra_-&gt;reg2offset_unchecked(OptoReg::add(ra_-&gt;_matcher._old_SP, -3*VMRegImpl::slots_per_word));
<span class="line-modified">!       C2_MacroAssembler _masm(&amp;cbuf);</span>
        Label L;
        __ cmpptr(Address(rsp, framesize), (int32_t)0xbadb100d);
        __ jccb(Assembler::equal, L);
        // Die if stack mismatch
        __ int3();
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3120,107 ***</span>
  
  // ====================REPLICATE=======================================
  
  // Replicate byte scalar to be vector
  instruct ReplB_reg(vec dst, rRegI src) %{
<span class="line-removed">-   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 32) ||</span>
<span class="line-removed">-             (n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit byte instructions</span>
    match(Set dst (ReplicateB src));
    format %{ &quot;replicateB $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 64 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands
<span class="line-modified">!       assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
        int vlen_enc = vector_length_encoding(this);
        __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vlen_enc);
      } else {
        __ movdl($dst$$XMMRegister, $src$$Register);
        __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);
        __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);
        if (vlen &gt;= 16) {
          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
          if (vlen &gt;= 32) {
<span class="line-modified">!           assert(vlen == 32, &quot;sanity&quot;); // vlen == 64 &amp;&amp; !AVX512BW is covered by ReplB_reg_leg</span>
            __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);
          }
        }
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-removed">- instruct ReplB_reg_leg(legVec dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512bw()); // AVX512BW for 512bit byte instructions</span>
<span class="line-removed">-   match(Set dst (ReplicateB src));</span>
<span class="line-removed">-   format %{ &quot;replicateB $dst,$src&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct ReplB_mem(vec dst, memory mem) %{
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 32 &amp;&amp; VM_Version::supports_avx512vlbw()) || // AVX512VL for &lt;512bit operands</span>
<span class="line-removed">-             (n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; VM_Version::supports_avx512bw()));    // AVX512BW for 512bit byte instructions</span>
    match(Set dst (ReplicateB (LoadB mem)));
    format %{ &quot;replicateB $dst,$mem&quot; %}
    ins_encode %{
<span class="line-removed">-     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
      int vector_len = vector_length_encoding(this);
      __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplB_imm(vec dst, immI con) %{
<span class="line-removed">-   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 32) ||</span>
<span class="line-removed">-             (n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit byte instructions</span>
    match(Set dst (ReplicateB con));
    format %{ &quot;replicateB $dst,$con&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 1));
      if (vlen == 4) {
        __ movdl($dst$$XMMRegister, const_addr);
      } else {
        __ movq($dst$$XMMRegister, const_addr);
        if (vlen &gt;= 16) {
<span class="line-modified">!         if (vlen == 64 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands</span>
            int vlen_enc = vector_length_encoding(this);
<span class="line-modified">!           __ vpbroadcastb($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
          } else {
            __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
<span class="line-removed">-           if (vlen &gt;= 32) {</span>
<span class="line-removed">-              assert(vlen == 32, &quot;sanity&quot;);// vlen == 64 &amp;&amp; !AVX512BW is covered by ReplB_imm_leg</span>
<span class="line-removed">-             __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-           }</span>
          }
        }
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-removed">- instruct ReplB_imm_leg(legVec dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 64 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateB con));</span>
<span class="line-removed">-   format %{ &quot;replicateB $dst,$con&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 1)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  // Replicate byte scalar zero to be vector
  instruct ReplB_zero(vec dst, immI0 zero) %{
    match(Set dst (ReplicateB zero));
    format %{ &quot;replicateB $dst,$zero&quot; %}
    ins_encode %{
<span class="line-new-header">--- 3287,69 ---</span>
  
  // ====================REPLICATE=======================================
  
  // Replicate byte scalar to be vector
  instruct ReplB_reg(vec dst, rRegI src) %{
    match(Set dst (ReplicateB src));
    format %{ &quot;replicateB $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 64 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands
<span class="line-modified">!       assert(VM_Version::supports_avx512bw(), &quot;required&quot;); // 512-bit byte vectors assume AVX512BW</span>
        int vlen_enc = vector_length_encoding(this);
        __ evpbroadcastb($dst$$XMMRegister, $src$$Register, vlen_enc);
      } else {
        __ movdl($dst$$XMMRegister, $src$$Register);
        __ punpcklbw($dst$$XMMRegister, $dst$$XMMRegister);
        __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);
        if (vlen &gt;= 16) {
          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
          if (vlen &gt;= 32) {
<span class="line-modified">!           assert(vlen == 32, &quot;sanity&quot;);</span>
            __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);
          }
        }
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplB_mem(vec dst, memory mem) %{
<span class="line-modified">!   predicate(VM_Version::supports_avx2());</span>
    match(Set dst (ReplicateB (LoadB mem)));
    format %{ &quot;replicateB $dst,$mem&quot; %}
    ins_encode %{
      int vector_len = vector_length_encoding(this);
      __ vpbroadcastb($dst$$XMMRegister, $mem$$Address, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplB_imm(vec dst, immI con) %{
    match(Set dst (ReplicateB con));
    format %{ &quot;replicateB $dst,$con&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 1));
      if (vlen == 4) {
        __ movdl($dst$$XMMRegister, const_addr);
      } else {
        __ movq($dst$$XMMRegister, const_addr);
        if (vlen &gt;= 16) {
<span class="line-modified">!         if (VM_Version::supports_avx2()) {</span>
            int vlen_enc = vector_length_encoding(this);
<span class="line-modified">!           __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
          } else {
<span class="line-added">+           assert(vlen == 16, &quot;sanity&quot;);</span>
            __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
          }
        }
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  // Replicate byte scalar zero to be vector
  instruct ReplB_zero(vec dst, immI0 zero) %{
    match(Set dst (ReplicateB zero));
    format %{ &quot;replicateB $dst,$zero&quot; %}
    ins_encode %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3237,130 ***</span>
  %}
  
  // ====================ReplicateS=======================================
  
  instruct ReplS_reg(vec dst, rRegI src) %{
<span class="line-removed">-   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 16) ||</span>
<span class="line-removed">-             (n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit instructions on shorts</span>
    match(Set dst (ReplicateS src));
    format %{ &quot;replicateS $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 32 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands
<span class="line-modified">!       assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
        int vlen_enc = vector_length_encoding(this);
        __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vlen_enc);
      } else {
        __ movdl($dst$$XMMRegister, $src$$Register);
        __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);
        if (vlen &gt;= 8) {
          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
          if (vlen &gt;= 16) {
<span class="line-modified">!           assert(vlen == 16, &quot;sanity&quot;); // vlen == 32 &amp;&amp; !AVX512BW is covered by ReplS_reg_leg</span>
            __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);
          }
        }
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-removed">- instruct ReplS_reg_leg(legVec dst, rRegI src) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS src));</span>
<span class="line-removed">-   format %{ &quot;replicateS $dst,$src&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movdl($dst$$XMMRegister, $src$$Register);</span>
<span class="line-removed">-     __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct ReplS_mem(vec dst, memory mem) %{
<span class="line-modified">!   predicate((n-&gt;as_Vector()-&gt;length() &gt;= 4  &amp;&amp;</span>
<span class="line-removed">-              n-&gt;as_Vector()-&gt;length() &lt;= 16 &amp;&amp; VM_Version::supports_avx()) ||</span>
<span class="line-removed">-             (n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit instructions on shorts</span>
<span class="line-removed">-   match(Set dst (ReplicateS (LoadS mem)));</span>
<span class="line-removed">-   format %{ &quot;replicateS $dst,$mem&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     uint vlen = vector_length(this);</span>
<span class="line-removed">-     if (vlen == 32 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands</span>
<span class="line-removed">-       assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
<span class="line-removed">-       int vlen_enc = vector_length_encoding(this);</span>
<span class="line-removed">-       __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-       if (vlen &gt;= 8) {</span>
<span class="line-removed">-         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-         if (vlen &gt;= 16) {</span>
<span class="line-removed">-           assert(vlen == 16, &quot;sanity&quot;); // vlen == 32 &amp;&amp; !AVX512BW is covered by ReplS_mem_leg</span>
<span class="line-removed">-           __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct ReplS_mem_leg(legVec dst, memory mem) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512bw());</span>
    match(Set dst (ReplicateS (LoadS mem)));
    format %{ &quot;replicateS $dst,$mem&quot; %}
    ins_encode %{
<span class="line-modified">!     __ pshuflw($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-modified">!     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplS_imm(vec dst, immI con) %{
<span class="line-removed">-   predicate((n-&gt;as_Vector()-&gt;length() &lt;= 16) ||</span>
<span class="line-removed">-             (n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; VM_Version::supports_avx512bw())); // AVX512BW for 512bit instructions on shorts</span>
    match(Set dst (ReplicateS con));
    format %{ &quot;replicateS $dst,$con&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
<span class="line-modified">!     InternalAddress constaddr = $constantaddress(replicate8_imm($con$$constant, 2));</span>
      if (vlen == 2) {
<span class="line-modified">!       __ movdl($dst$$XMMRegister, constaddr);</span>
      } else {
<span class="line-modified">!       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-modified">!       if (vlen == 32 || VM_Version::supports_avx512vlbw() ) { // AVX512VL for &lt;512bit operands</span>
<span class="line-modified">!         assert(VM_Version::supports_avx512bw(), &quot;required&quot;);</span>
<span class="line-modified">!         int vlen_enc = vector_length_encoding(this);</span>
<span class="line-modified">!         __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-modified">!       } else {</span>
<span class="line-modified">!         __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-modified">!         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-         if (vlen &gt;= 16) {</span>
<span class="line-removed">-           assert(vlen == 16, &quot;sanity&quot;); // vlen == 32 &amp;&amp; !AVX512BW is covered by ReplS_imm_leg</span>
<span class="line-removed">-           __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
          }
        }
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-removed">- instruct ReplS_imm_leg(legVec dst, immI con) %{</span>
<span class="line-removed">-   predicate(n-&gt;as_Vector()-&gt;length() == 32 &amp;&amp; !VM_Version::supports_avx512bw());</span>
<span class="line-removed">-   match(Set dst (ReplicateS con));</span>
<span class="line-removed">-   format %{ &quot;replicateS $dst,$con&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     __ movq($dst$$XMMRegister, $constantaddress(replicate8_imm($con$$constant, 2)));</span>
<span class="line-removed">-     __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-     __ vinserti64x4($dst$$XMMRegister, $dst$$XMMRegister, $dst$$XMMRegister, 0x1);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
  instruct ReplS_zero(vec dst, immI0 zero) %{
    match(Set dst (ReplicateS zero));
    format %{ &quot;replicateS $dst,$zero&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
<span class="line-new-header">--- 3366,68 ---</span>
  %}
  
  // ====================ReplicateS=======================================
  
  instruct ReplS_reg(vec dst, rRegI src) %{
    match(Set dst (ReplicateS src));
    format %{ &quot;replicateS $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 32 || VM_Version::supports_avx512vlbw()) { // AVX512VL for &lt;512bit operands
<span class="line-modified">!       assert(VM_Version::supports_avx512bw(), &quot;required&quot;); // 512-bit short vectors assume AVX512BW</span>
        int vlen_enc = vector_length_encoding(this);
        __ evpbroadcastw($dst$$XMMRegister, $src$$Register, vlen_enc);
      } else {
        __ movdl($dst$$XMMRegister, $src$$Register);
        __ pshuflw($dst$$XMMRegister, $dst$$XMMRegister, 0x00);
        if (vlen &gt;= 8) {
          __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
          if (vlen &gt;= 16) {
<span class="line-modified">!           assert(vlen == 16, &quot;sanity&quot;);</span>
            __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);
          }
        }
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplS_mem(vec dst, memory mem) %{
<span class="line-modified">!   predicate(VM_Version::supports_avx2());</span>
    match(Set dst (ReplicateS (LoadS mem)));
    format %{ &quot;replicateS $dst,$mem&quot; %}
    ins_encode %{
<span class="line-modified">!     int vlen_enc = vector_length_encoding(this);</span>
<span class="line-modified">!     __ vpbroadcastw($dst$$XMMRegister, $mem$$Address, vlen_enc);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplS_imm(vec dst, immI con) %{
    match(Set dst (ReplicateS con));
    format %{ &quot;replicateS $dst,$con&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
<span class="line-modified">!     InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 2));</span>
      if (vlen == 2) {
<span class="line-modified">!       __ movdl($dst$$XMMRegister, const_addr);</span>
      } else {
<span class="line-modified">!       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-modified">!       if (vlen &gt;= 8) {</span>
<span class="line-modified">!         if (VM_Version::supports_avx2()) {</span>
<span class="line-modified">!           int vlen_enc = vector_length_encoding(this);</span>
<span class="line-modified">!           __ vpbroadcastw($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);</span>
<span class="line-modified">!         } else {</span>
<span class="line-modified">!           assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-modified">!           __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
          }
        }
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
  instruct ReplS_zero(vec dst, immI0 zero) %{
    match(Set dst (ReplicateS zero));
    format %{ &quot;replicateS $dst,$zero&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3395,48 ***</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplI_mem(vec dst, memory mem) %{
<span class="line-removed">-   predicate(VM_Version::supports_avx()); // use VEX-encoded pshufd to relax 16-byte alignment restriction on the source</span>
    match(Set dst (ReplicateI (LoadI mem)));
    format %{ &quot;replicateI $dst,$mem&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen &lt;= 4) {
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-modified">!     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vector_len = vector_length_encoding(this);
        __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vector_len);
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-removed">-       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplI_imm(vec dst, immI con) %{
    match(Set dst (ReplicateI con));
    format %{ &quot;replicateI $dst,$con&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
<span class="line-modified">!     InternalAddress constaddr = $constantaddress(replicate8_imm($con$$constant, 4));</span>
<span class="line-modified">!     if (vlen == 2) {</span>
<span class="line-modified">!       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-modified">!     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vector_len = vector_length_encoding(this);
<span class="line-modified">!       __ movq($dst$$XMMRegister, constaddr);</span>
        __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       __ movq($dst$$XMMRegister, constaddr);</span>
<span class="line-removed">-       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-       if (vlen &gt;= 8) {</span>
<span class="line-removed">-         assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-removed">-         __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-       }</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-new-header">--- 3462,42 ---</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplI_mem(vec dst, memory mem) %{
    match(Set dst (ReplicateI (LoadI mem)));
    format %{ &quot;replicateI $dst,$mem&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen &lt;= 4) {
<span class="line-modified">!       __ movdl($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(VM_Version::supports_avx2(), &quot;sanity&quot;);</span>
        int vector_len = vector_length_encoding(this);
        __ vpbroadcastd($dst$$XMMRegister, $mem$$Address, vector_len);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplI_imm(vec dst, immI con) %{
    match(Set dst (ReplicateI con));
    format %{ &quot;replicateI $dst,$con&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
<span class="line-modified">!     InternalAddress const_addr = $constantaddress(replicate8_imm($con$$constant, 4));</span>
<span class="line-modified">!     if (vlen &lt;= 4) {</span>
<span class="line-modified">!       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-modified">!       if (vlen == 4) {</span>
<span class="line-added">+         __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-added">+       }</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(VM_Version::supports_avx2(), &quot;sanity&quot;);</span>
        int vector_len = vector_length_encoding(this);
<span class="line-modified">!       __ movq($dst$$XMMRegister, const_addr);</span>
        __ vpbroadcastd($dst$$XMMRegister, $dst$$XMMRegister, vector_len);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3454,10 ***</span>
<span class="line-new-header">--- 3515,24 ---</span>
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-added">+ instruct ReplI_M1(vec dst, immI_M1 con) %{</span>
<span class="line-added">+   predicate(UseAVX &gt; 0);</span>
<span class="line-added">+   match(Set dst (ReplicateB con));</span>
<span class="line-added">+   match(Set dst (ReplicateS con));</span>
<span class="line-added">+   match(Set dst (ReplicateI con));</span>
<span class="line-added">+   effect(TEMP dst);</span>
<span class="line-added">+   format %{ &quot;vallones $dst&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vallones($dst$$XMMRegister, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // ====================ReplicateL=======================================
  
  #ifdef _LP64
  // Replicate long (8 byte) scalar to be vector
  instruct ReplL_reg(vec dst, rRegL src) %{
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3542,18 ***</span>
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 2) {
        __ movq($dst$$XMMRegister, $mem$$Address);
        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
<span class="line-modified">!     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vlen_enc = vector_length_encoding(this);
        __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-removed">-       __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-removed">-       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-new-header">--- 3617,14 ---</span>
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 2) {
        __ movq($dst$$XMMRegister, $mem$$Address);
        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
<span class="line-modified">!     } else {</span>
<span class="line-added">+       assert(VM_Version::supports_avx2(), &quot;sanity&quot;);</span>
        int vlen_enc = vector_length_encoding(this);
        __ vpbroadcastq($dst$$XMMRegister, $mem$$Address, vlen_enc);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3565,19 ***</span>
      uint vlen = vector_length(this);
      InternalAddress const_addr = $constantaddress($con);
      if (vlen == 2) {
        __ movq($dst$$XMMRegister, const_addr);
        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
<span class="line-modified">!     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vlen_enc = vector_length_encoding(this);
        __ movq($dst$$XMMRegister, const_addr);
        __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-removed">-       __ movq($dst$$XMMRegister, const_addr);</span>
<span class="line-removed">-       __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);</span>
<span class="line-removed">-       __ vinserti128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-new-header">--- 3636,15 ---</span>
      uint vlen = vector_length(this);
      InternalAddress const_addr = $constantaddress($con);
      if (vlen == 2) {
        __ movq($dst$$XMMRegister, const_addr);
        __ punpcklqdq($dst$$XMMRegister, $dst$$XMMRegister);
<span class="line-modified">!     } else {</span>
<span class="line-added">+       assert(VM_Version::supports_avx2(), &quot;sanity&quot;);</span>
        int vlen_enc = vector_length_encoding(this);
        __ movq($dst$$XMMRegister, const_addr);
        __ vpbroadcastq($dst$$XMMRegister, $dst$$XMMRegister, vlen_enc);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3594,46 ***</span>
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
  // ====================ReplicateF=======================================
  
  instruct ReplF_reg(vec dst, vlRegF src) %{
    match(Set dst (ReplicateF src));
    format %{ &quot;replicateF $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen &lt;= 4) {
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);
<span class="line-modified">!     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vector_len = vector_length_encoding(this);
<span class="line-modified">!       __ vbroadcastss($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
      } else {
        assert(vlen == 8, &quot;sanity&quot;);
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);
        __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplF_mem(vec dst, memory mem) %{
<span class="line-removed">-   predicate(VM_Version::supports_avx()); // use VEX-encoded pshufd to relax 16-byte alignment restriction on the source</span>
    match(Set dst (ReplicateF (LoadF mem)));
    format %{ &quot;replicateF $dst,$mem&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen &lt;= 4) {
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-modified">!     } else if (vlen == 16 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vector_len = vector_length_encoding(this);
        __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vector_len);
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(vlen == 8, &quot;sanity&quot;);</span>
<span class="line-removed">-       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x00);</span>
<span class="line-removed">-       __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-new-header">--- 3661,55 ---</span>
      }
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
<span class="line-added">+ instruct ReplL_M1(vec dst, immL_M1 con) %{</span>
<span class="line-added">+   predicate(UseAVX &gt; 0);</span>
<span class="line-added">+   match(Set dst (ReplicateL con));</span>
<span class="line-added">+   effect(TEMP dst);</span>
<span class="line-added">+   format %{ &quot;vallones $dst&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vallones($dst$$XMMRegister, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
  // ====================ReplicateF=======================================
  
  instruct ReplF_reg(vec dst, vlRegF src) %{
    match(Set dst (ReplicateF src));
    format %{ &quot;replicateF $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen &lt;= 4) {
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);
<span class="line-modified">!    } else if (VM_Version::supports_avx2()) {</span>
        int vector_len = vector_length_encoding(this);
<span class="line-modified">!       __ vbroadcastss($dst$$XMMRegister, $src$$XMMRegister, vector_len); // reg-to-reg variant requires AVX2</span>
      } else {
        assert(vlen == 8, &quot;sanity&quot;);
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x00);
        __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplF_mem(vec dst, memory mem) %{
    match(Set dst (ReplicateF (LoadF mem)));
    format %{ &quot;replicateF $dst,$mem&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen &lt;= 4) {
<span class="line-modified">!       __ movdl($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x00);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(VM_Version::supports_avx(), &quot;sanity&quot;);</span>
        int vector_len = vector_length_encoding(this);
        __ vbroadcastss($dst$$XMMRegister, $mem$$Address, vector_len);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3660,37 ***</span>
    format %{ &quot;replicateD $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 2) {
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);
<span class="line-modified">!     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vector_len = vector_length_encoding(this);
<span class="line-modified">!       __ vbroadcastsd($dst$$XMMRegister, $src$$XMMRegister, vector_len);</span>
      } else {
        assert(vlen == 4, &quot;sanity&quot;);
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);
        __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplD_mem(vec dst, memory mem) %{
<span class="line-removed">-   predicate(VM_Version::supports_avx()); // use VEX-encoded pshufd to relax 16-byte alignment restriction on the source</span>
    match(Set dst (ReplicateD (LoadD mem)));
    format %{ &quot;replicateD $dst,$mem&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 2) {
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-modified">!     } else if (vlen == 8 || VM_Version::supports_avx512vl()) { // AVX512VL for &lt;512bit operands</span>
        int vector_len = vector_length_encoding(this);
        __ vbroadcastsd($dst$$XMMRegister, $mem$$Address, vector_len);
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(vlen == 4, &quot;sanity&quot;);</span>
<span class="line-removed">-       __ pshufd($dst$$XMMRegister, $mem$$Address, 0x44);</span>
<span class="line-removed">-       __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);</span>
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-new-header">--- 3736,34 ---</span>
    format %{ &quot;replicateD $dst,$src&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 2) {
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);
<span class="line-modified">!     } else if (VM_Version::supports_avx2()) {</span>
        int vector_len = vector_length_encoding(this);
<span class="line-modified">!       __ vbroadcastsd($dst$$XMMRegister, $src$$XMMRegister, vector_len); // reg-to-reg variant requires AVX2</span>
      } else {
        assert(vlen == 4, &quot;sanity&quot;);
        __ pshufd($dst$$XMMRegister, $src$$XMMRegister, 0x44);
        __ vinsertf128_high($dst$$XMMRegister, $dst$$XMMRegister);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
  instruct ReplD_mem(vec dst, memory mem) %{
    match(Set dst (ReplicateD (LoadD mem)));
    format %{ &quot;replicateD $dst,$mem&quot; %}
    ins_encode %{
      uint vlen = vector_length(this);
      if (vlen == 2) {
<span class="line-modified">!       __ movq($dst$$XMMRegister, $mem$$Address);</span>
<span class="line-modified">!       __ pshufd($dst$$XMMRegister, $dst$$XMMRegister, 0x44);</span>
<span class="line-added">+     } else {</span>
<span class="line-added">+       assert(VM_Version::supports_avx(), &quot;sanity&quot;);</span>
        int vector_len = vector_length_encoding(this);
        __ vbroadcastsd($dst$$XMMRegister, $mem$$Address, vector_len);
      }
    %}
    ins_pipe( pipe_slow );
  %}
  
</pre>
<hr />
<pre>
<span class="line-old-header">*** 3708,713 ***</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
  // ====================REDUCTION ARITHMETIC=======================================
  
<span class="line-modified">! // =======================AddReductionVI==========================================</span>
<span class="line-modified">! </span>
<span class="line-modified">! instruct vadd2I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_add2I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 2) {</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-       __ vpaddd($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else if (VM_Version::supports_avxonly()) {</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-       __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-       __ movdqu($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ phaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ paddd($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
    match(Set dst (AddReductionVI src1 src2));
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_add4I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     if (UseAVX &gt; 2) {</span>
<span class="line-modified">!       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-modified">!       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-modified">!       __ vpaddd($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-modified">!       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-modified">!       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-modified">!       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else if (VM_Version::supports_avxonly()) {</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-       __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-       __ movdqu($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ phaddd($tmp$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ paddd($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-removed">-   match(Set dst (AddReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_add8I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 2) {</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-       __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseAVX &gt; 0, &quot;&quot;);</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_256bit;</span>
<span class="line-removed">-       __ vphaddd($tmp$$XMMRegister, $src2$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ vphaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ vextracti128_high($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpaddd($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd16I_reduction_reg(rRegI dst, rRegI src1, legVec src2, legVec tmp, legVec tmp2, legVec tmp3) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
    match(Set dst (AddReductionVI src1 src2));
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2, TEMP tmp3);</span>
<span class="line-modified">!   format %{ &quot;vector_add16I_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     __ vextracti64x4_high($tmp3$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ vpaddd($tmp3$$XMMRegister, $tmp3$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-modified">!     __ vextracti128_high($tmp$$XMMRegister, $tmp3$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp3$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpaddd($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddd($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================AddReductionVL==========================================</span>
  
  #ifdef _LP64
<span class="line-modified">! instruct vadd2L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (AddReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_add2L_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddq($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
    match(Set dst (AddReductionVL src1 src2));
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_add4L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ vpaddq($tmp2$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vadd8L_reduction_reg(rRegL dst, rRegL src1, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
    match(Set dst (AddReductionVL src1 src2));
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_addL_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vextracti64x4_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpaddq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  #endif // _LP64
  
<span class="line-modified">! // =======================AddReductionVF==========================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;vector_add2F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-       __ addss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd4F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;vector_add4F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-       __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-       __ addss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-       __ addss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8F_reduction_reg(regF dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_add8F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd16F_reduction_reg(regF dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-removed">-   match(Set dst (AddReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_add16F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vaddss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // =======================AddReductionVD==========================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd2D_reduction_reg(regD dst, vec src2, vec tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-removed">-   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst);</span>
<span class="line-removed">-   format %{ &quot;vector_add2D_reduction  $dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-       __ addsd($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ addsd($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vadd4D_reduction_reg(regD dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_add4D_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vadd8D_reduction_reg(regD dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-removed">-   match(Set dst (AddReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_add8D_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vaddsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // =======================MulReductionVI==========================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_mul2I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-       __ vpmulld($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-       __ pmulld($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_mul4I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ vpmulld($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-       __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 3, &quot;required&quot;);</span>
<span class="line-removed">-       __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ pmulld($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x1);</span>
<span class="line-removed">-       __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-       __ pmulld($tmp2$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul8I_reduction_reg(rRegI dst, rRegI src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_mul8I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 1, &quot;required&quot;);</span>
<span class="line-removed">-     int vector_len = Assembler::AVX_128bit;</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, vector_len);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16I_reduction_reg(rRegI dst, rRegI src1, legVec src2, legVec tmp, legVec tmp2, legVec tmp3) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-removed">-   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2, TEMP tmp3);</span>
<span class="line-removed">-   format %{ &quot;vector_mul16I_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-removed">-     __ vextracti64x4_high($tmp3$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmulld($tmp3$$XMMRegister, $tmp3$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp3$$XMMRegister);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp3$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $tmp$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vpmulld($tmp$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmulld($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdl($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // =======================MulReductionVL==========================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- #ifdef _LP64</span>
<span class="line-removed">- instruct vmul2L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-removed">-   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_mul2L_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(VM_Version::supports_avx512dq(), &quot;required&quot;);</span>
<span class="line-removed">-     __ pshufd($tmp2$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmullq($tmp$$XMMRegister, $src2$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp2$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp$$XMMRegister, $tmp2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul4L_reduction_reg(rRegL dst, rRegL src1, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-removed">-   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_mul4L_reduction $dst,$src1,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     assert(VM_Version::supports_avx512dq(), &quot;required&quot;);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp$$XMMRegister, $src2$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul8L_reduction_reg(rRegL dst, rRegL src1, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_mul8L_reduction $dst,$src1,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(VM_Version::supports_avx512dq(), &quot;required&quot;);</span>
<span class="line-modified">!     __ vextracti64x4_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $src2$$XMMRegister, 1);</span>
<span class="line-removed">-     __ vextracti128_high($tmp$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($tmp$$XMMRegister, $src1$$Register);</span>
<span class="line-removed">-     __ vpmullq($tmp2$$XMMRegister, $tmp2$$XMMRegister, $tmp$$XMMRegister, 0);</span>
<span class="line-removed">-     __ movdq($dst$$Register, $tmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-removed">- #endif</span>
<span class="line-removed">- </span>
<span class="line-removed">- // =======================MulReductionVF==========================================</span>
  
<span class="line-modified">! instruct vmul2F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP tmp);</span>
<span class="line-modified">!   format %{ &quot;vector_mul2F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     if (UseAVX &gt; 0) {</span>
<span class="line-modified">!       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-       __ mulss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul4F_reduction_reg(regF dst, vec src2, vec tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 4</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;vector_mul4F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-       __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-       __ mulss($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-       __ mulss($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
  
<span class="line-modified">! instruct vmul8F_reduction_reg(regF dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 8</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_mul8F_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-removed">-     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul16F_reduction_reg(regF dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16); // vector_length(src2) == 16</span>
<span class="line-removed">-   match(Set dst (MulReductionVF dst src2));</span>
<span class="line-removed">-   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-removed">-   format %{ &quot;vector_mul16F_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 2, &quot;required&quot;);</span>
<span class="line-modified">!     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x01);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x02);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0x03);</span>
<span class="line-removed">-     __ vmulss($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-   %}</span>
<span class="line-removed">-   ins_pipe( pipe_slow );</span>
<span class="line-removed">- %}</span>
<span class="line-removed">- </span>
<span class="line-removed">- // =======================MulReductionVD==========================================</span>
<span class="line-removed">- </span>
<span class="line-removed">- instruct vmul2D_reduction_reg(regD dst, vec src2, vec tmp) %{</span>
<span class="line-removed">-   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2); // vector_length(src2) == 2</span>
<span class="line-removed">-   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-removed">-   effect(TEMP dst, TEMP tmp);</span>
<span class="line-removed">-   format %{ &quot;vector_mul2D_reduction $dst,$dst,$src2&quot; %}</span>
<span class="line-removed">-   ins_encode %{</span>
<span class="line-removed">-     if (UseAVX &gt; 0) {</span>
<span class="line-removed">-       __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       assert(UseSSE &gt; 0, &quot;required&quot;);</span>
<span class="line-removed">-       __ mulsd($dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-       __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-       __ mulsd($dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     }</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! </span>
<span class="line-modified">! instruct vmul4D_reduction_reg(regD dst, vec src2, vec tmp, vec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_mul4D_reduction  $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf128_high($tmp2$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct vmul8D_reduction_reg(regD dst, legVec src2, legVec tmp, legVec tmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8); // vector_length(src2) == 2</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src2));</span>
<span class="line-modified">!   effect(TEMP tmp, TEMP dst, TEMP tmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_mul8D_reduction $dst,$dst,$src2&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     assert(UseAVX &gt; 0, &quot;required&quot;);</span>
<span class="line-modified">!     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $src2$$XMMRegister);</span>
<span class="line-modified">!     __ pshufd($tmp$$XMMRegister, $src2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x1);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x2);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
<span class="line-removed">-     __ vextractf32x4($tmp2$$XMMRegister, $src2$$XMMRegister, 0x3);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp2$$XMMRegister);</span>
<span class="line-removed">-     __ pshufd($tmp$$XMMRegister, $tmp2$$XMMRegister, 0xE);</span>
<span class="line-removed">-     __ vmulsd($dst$$XMMRegister, $dst$$XMMRegister, $tmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // ====================VECTOR ARITHMETIC=======================================
<span class="line-new-header">--- 3781,172 ---</span>
    %}
    ins_pipe( fpu_reg_reg );
  %}
  
  // ====================REDUCTION ARITHMETIC=======================================
<span class="line-added">+ // =======================Int Reduction==========================================</span>
  
<span class="line-modified">! instruct reductionI(rRegI dst, rRegI src1, vec src2, vec vtmp1, vec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_INT &amp;&amp;</span>
<span class="line-modified">!             n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() &lt; 16);</span>
    match(Set dst (AddReductionVI src1 src2));
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-modified">!   match(Set dst (AndReductionV  src1 src2));</span>
<span class="line-modified">!   match(Set dst ( OrReductionV  src1 src2));</span>
<span class="line-modified">!   match(Set dst (XorReductionV  src1 src2));</span>
<span class="line-modified">!   effect(TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_reduction_int $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
<span class="line-modified">!   ins_encode %{</span>
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src2);</span>
<span class="line-modified">!     __ reduceI(opcode, vlen, $dst$$Register, $src1$$Register, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct reduction16I(rRegI dst, rRegI src1, legVec src2, legVec vtmp1, legVec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_INT &amp;&amp;</span>
<span class="line-added">+             n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16);</span>
    match(Set dst (AddReductionVI src1 src2));
<span class="line-modified">!   match(Set dst (MulReductionVI src1 src2));</span>
<span class="line-modified">!   match(Set dst (AndReductionV  src1 src2));</span>
<span class="line-added">+   match(Set dst ( OrReductionV  src1 src2));</span>
<span class="line-added">+   match(Set dst (XorReductionV  src1 src2));</span>
<span class="line-added">+   effect(TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_int $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src2);</span>
<span class="line-modified">!     __ reduceI(opcode, vlen, $dst$$Register, $src1$$Register, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================Long Reduction==========================================</span>
  
  #ifdef _LP64
<span class="line-modified">! instruct reductionL(rRegL dst, rRegL src1, vec src2, vec vtmp1, vec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_LONG &amp;&amp;</span>
<span class="line-modified">!             n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() &lt; 8);</span>
    match(Set dst (AddReductionVL src1 src2));
<span class="line-modified">!   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-modified">!   match(Set dst (AndReductionV  src1 src2));</span>
<span class="line-added">+   match(Set dst ( OrReductionV  src1 src2));</span>
<span class="line-added">+   match(Set dst (XorReductionV  src1 src2));</span>
<span class="line-added">+   effect(TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_long $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src2);</span>
<span class="line-modified">!     __ reduceL(opcode, vlen, $dst$$Register, $src1$$Register, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct reduction8L(rRegL dst, rRegL src1, legVec src2, legVec vtmp1, legVec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;element_basic_type() == T_LONG &amp;&amp;</span>
<span class="line-added">+             n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8);</span>
    match(Set dst (AddReductionVL src1 src2));
<span class="line-modified">!   match(Set dst (MulReductionVL src1 src2));</span>
<span class="line-modified">!   match(Set dst (AndReductionV  src1 src2));</span>
<span class="line-added">+   match(Set dst ( OrReductionV  src1 src2));</span>
<span class="line-added">+   match(Set dst (XorReductionV  src1 src2));</span>
<span class="line-added">+   effect(TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_long $dst,$src1,$src2 ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src2);</span>
<span class="line-modified">!     __ reduceL(opcode, vlen, $dst$$Register, $src1$$Register, $src2$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  #endif // _LP64
  
<span class="line-modified">! // =======================Float Reduction==========================================</span>
  
<span class="line-modified">! instruct reductionF128(regF dst, vec src, vec vtmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() &lt;= 4);</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src));</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP vtmp);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_fp  $dst,$src ; using $vtmp as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src);</span>
<span class="line-modified">!     __ reduce_fp(opcode, vlen, $dst$$XMMRegister, $src$$XMMRegister, $vtmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct reduction8F(regF dst, vec src, vec vtmp1, vec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src));</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_float $dst,$src ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src);</span>
<span class="line-modified">!     __ reduce_fp(opcode, vlen, $dst$$XMMRegister, $src$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct reduction16F(regF dst, legVec src, legVec vtmp1, legVec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 16);</span>
<span class="line-modified">!   match(Set dst (AddReductionVF dst src));</span>
<span class="line-modified">!   match(Set dst (MulReductionVF dst src));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_float $dst,$src ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src);</span>
<span class="line-modified">!     __ reduce_fp(opcode, vlen, $dst$$XMMRegister, $src$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! // =======================Double Reduction==========================================</span>
  
<span class="line-modified">! instruct reduction2D(regD dst, vec src, vec vtmp) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 2);</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src));</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP vtmp);</span>
<span class="line-modified">!   format %{ &quot;vector_reduction_double $dst,$src ; using $vtmp as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src);</span>
<span class="line-modified">!     __ reduce_fp(opcode, vlen, $dst$$XMMRegister, $src$$XMMRegister, $vtmp$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct reduction4D(regD dst, vec src, vec vtmp1, vec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 4);</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src));</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-modified">!   format %{ &quot;vector_reduction_double $dst,$src ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src);</span>
<span class="line-modified">!     __ reduce_fp(opcode, vlen, $dst$$XMMRegister, $src$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
<span class="line-modified">! instruct reduction8D(regD dst, legVec src, legVec vtmp1, legVec vtmp2) %{</span>
<span class="line-modified">!   predicate(n-&gt;in(2)-&gt;bottom_type()-&gt;is_vect()-&gt;length() == 8);</span>
<span class="line-modified">!   match(Set dst (AddReductionVD dst src));</span>
<span class="line-modified">!   match(Set dst (MulReductionVD dst src));</span>
<span class="line-modified">!   effect(TEMP dst, TEMP vtmp1, TEMP vtmp2);</span>
<span class="line-added">+   format %{ &quot;vector_reduction_double $dst,$src ; using $vtmp1, $vtmp2 as TEMP&quot; %}</span>
    ins_encode %{
<span class="line-modified">!     int opcode = this-&gt;ideal_Opcode();</span>
<span class="line-modified">!     int vlen = vector_length(this, $src);</span>
<span class="line-modified">!     __ reduce_fp(opcode, vlen, $dst$$XMMRegister, $src$$XMMRegister, $vtmp1$$XMMRegister, $vtmp2$$XMMRegister);</span>
    %}
    ins_pipe( pipe_slow );
  %}
  
  // ====================VECTOR ARITHMETIC=======================================
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5782,11 ***</span>
  %}
  
  // --------------------------------- Vector Multiply Add Add ----------------------------------
  
  instruct vmuladdaddS2I_reg(vec dst, vec src1, vec src2) %{
<span class="line-modified">!   predicate(VM_Version::supports_vnni());</span>
    match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));
    format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packedStoI&quot; %}
    ins_encode %{
      assert(UseAVX &gt; 2, &quot;required&quot;);
      int vector_len = vector_length_encoding(this);
<span class="line-new-header">--- 5314,11 ---</span>
  %}
  
  // --------------------------------- Vector Multiply Add Add ----------------------------------
  
  instruct vmuladdaddS2I_reg(vec dst, vec src1, vec src2) %{
<span class="line-modified">!   predicate(VM_Version::supports_avx512_vnni());</span>
    match(Set dst (AddVI (MulAddVS2VI src1 src2) dst));
    format %{ &quot;evpdpwssd $dst,$src1,$src2\t! muladdadd packedStoI&quot; %}
    ins_encode %{
      assert(UseAVX &gt; 2, &quot;required&quot;);
      int vector_len = vector_length_encoding(this);
</pre>
<hr />
<pre>
<span class="line-old-header">*** 5807,5 ***</span>
<span class="line-new-header">--- 5339,29 ---</span>
      int vector_len = vector_length_encoding(this);
      __ vpopcntd($dst$$XMMRegister, $src$$XMMRegister, vector_len);
    %}
    ins_pipe( pipe_slow );
  %}
<span class="line-added">+ </span>
<span class="line-added">+ // --------------------------------- Bitwise Ternary Logic ----------------------------------</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vpternlogdB(vec dst, vec src2, vec src3, immU8 func) %{</span>
<span class="line-added">+   match(Set dst (MacroLogicV (Binary dst src2) (Binary src3 func)));</span>
<span class="line-added">+   effect(TEMP dst);</span>
<span class="line-added">+   format %{ &quot;vpternlogd $dst,$src2,$src3,$func\t! vector ternary logic&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpternlogd($dst$$XMMRegister, $func$$constant, $src2$$XMMRegister, $src3$$XMMRegister, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
<span class="line-added">+ </span>
<span class="line-added">+ instruct vpternlogdB_mem(vec dst, vec src2, memory src3, immU8 func) %{</span>
<span class="line-added">+   match(Set dst (MacroLogicV (Binary dst src2) (Binary (LoadVector src3) func)));</span>
<span class="line-added">+   effect(TEMP dst);</span>
<span class="line-added">+   format %{ &quot;vpternlogd $dst,$src2,$src3,$func\t! vector ternary logic&quot; %}</span>
<span class="line-added">+   ins_encode %{</span>
<span class="line-added">+     int vector_len = vector_length_encoding(this);</span>
<span class="line-added">+     __ vpternlogd($dst$$XMMRegister, $func$$constant, $src2$$XMMRegister, $src3$$Address, vector_len);</span>
<span class="line-added">+   %}</span>
<span class="line-added">+   ins_pipe( pipe_slow );</span>
<span class="line-added">+ %}</span>
</pre>
<center><a href="vm_version_x86.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="x86_32.ad.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
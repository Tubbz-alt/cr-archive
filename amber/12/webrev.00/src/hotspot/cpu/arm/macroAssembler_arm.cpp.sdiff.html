<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/arm/macroAssembler_arm.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/arm/macroAssembler_arm.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
1609   // CF == 0 means we reached the end of itable without finding icklass
1610   b(L_no_such_interface, cc);
1611 
1612   if (method_result != noreg) {
1613     // Interface found at previous position of Rscan, now load the method
1614     ldr_s32(Rtmp, Address(Rscan, itableOffsetEntry::offset_offset_in_bytes() - entry_size));
1615     if (itable_index.is_register()) {
1616       add(Rtmp, Rtmp, Rklass); // Add offset to Klass*
1617       assert(itableMethodEntry::size() * HeapWordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
1618       assert(itableMethodEntry::method_offset_in_bytes() == 0, &quot;adjust the offset in the code below&quot;);
1619       ldr(method_result, Address::indexed_ptr(Rtmp, itable_index.as_register()));
1620     } else {
1621       int method_offset = itableMethodEntry::size() * HeapWordSize * itable_index.as_constant() +
1622                           itableMethodEntry::method_offset_in_bytes();
1623       add_slow(method_result, Rklass, method_offset);
1624       ldr(method_result, Address(method_result, Rtmp));
1625     }
1626   }
1627 }
1628 
<span class="line-removed">1629 #ifdef COMPILER2</span>
<span class="line-removed">1630 // TODO: 8 bytes at a time? pre-fetch?</span>
<span class="line-removed">1631 // Compare char[] arrays aligned to 4 bytes.</span>
<span class="line-removed">1632 void MacroAssembler::char_arrays_equals(Register ary1, Register ary2,</span>
<span class="line-removed">1633                                         Register limit, Register result,</span>
<span class="line-removed">1634                                       Register chr1, Register chr2, Label&amp; Ldone) {</span>
<span class="line-removed">1635   Label Lvector, Lloop;</span>
<span class="line-removed">1636 </span>
<span class="line-removed">1637   // if (ary1 == ary2)</span>
<span class="line-removed">1638   //     return true;</span>
<span class="line-removed">1639   cmpoop(ary1, ary2);</span>
<span class="line-removed">1640   b(Ldone, eq);</span>
<span class="line-removed">1641 </span>
<span class="line-removed">1642   // Note: limit contains number of bytes (2*char_elements) != 0.</span>
<span class="line-removed">1643   tst(limit, 0x2); // trailing character ?</span>
<span class="line-removed">1644   b(Lvector, eq);</span>
<span class="line-removed">1645 </span>
<span class="line-removed">1646   // compare the trailing char</span>
<span class="line-removed">1647   sub(limit, limit, sizeof(jchar));</span>
<span class="line-removed">1648   ldrh(chr1, Address(ary1, limit));</span>
<span class="line-removed">1649   ldrh(chr2, Address(ary2, limit));</span>
<span class="line-removed">1650   cmp(chr1, chr2);</span>
<span class="line-removed">1651   mov(result, 0, ne);     // not equal</span>
<span class="line-removed">1652   b(Ldone, ne);</span>
<span class="line-removed">1653 </span>
<span class="line-removed">1654   // only one char ?</span>
<span class="line-removed">1655   tst(limit, limit);</span>
<span class="line-removed">1656   mov(result, 1, eq);</span>
<span class="line-removed">1657   b(Ldone, eq);</span>
<span class="line-removed">1658 </span>
<span class="line-removed">1659   // word by word compare, dont&#39;t need alignment check</span>
<span class="line-removed">1660   bind(Lvector);</span>
<span class="line-removed">1661 </span>
<span class="line-removed">1662   // Shift ary1 and ary2 to the end of the arrays, negate limit</span>
<span class="line-removed">1663   add(ary1, limit, ary1);</span>
<span class="line-removed">1664   add(ary2, limit, ary2);</span>
<span class="line-removed">1665   neg(limit, limit);</span>
<span class="line-removed">1666 </span>
<span class="line-removed">1667   bind(Lloop);</span>
<span class="line-removed">1668   ldr_u32(chr1, Address(ary1, limit));</span>
<span class="line-removed">1669   ldr_u32(chr2, Address(ary2, limit));</span>
<span class="line-removed">1670   cmp_32(chr1, chr2);</span>
<span class="line-removed">1671   mov(result, 0, ne);     // not equal</span>
<span class="line-removed">1672   b(Ldone, ne);</span>
<span class="line-removed">1673   adds(limit, limit, 2*sizeof(jchar));</span>
<span class="line-removed">1674   b(Lloop, ne);</span>
<span class="line-removed">1675 </span>
<span class="line-removed">1676   // Caller should set it:</span>
<span class="line-removed">1677   // mov(result_reg, 1);  //equal</span>
<span class="line-removed">1678 }</span>
<span class="line-removed">1679 #endif</span>
1680 
1681 void MacroAssembler::inc_counter(address counter_addr, Register tmpreg1, Register tmpreg2) {
1682   mov_slow(tmpreg1, counter_addr);
1683   ldr_s32(tmpreg2, tmpreg1);
1684   add_32(tmpreg2, tmpreg2, 1);
1685   str_32(tmpreg2, tmpreg1);
1686 }
1687 
1688 void MacroAssembler::floating_cmp(Register dst) {
1689   vmrs(dst, FPSCR);
1690   orr(dst, dst, 0x08000000);
1691   eor(dst, dst, AsmOperand(dst, lsl, 3));
1692   mov(dst, AsmOperand(dst, asr, 30));
1693 }
1694 
1695 void MacroAssembler::restore_default_fp_mode() {
1696 #ifndef __SOFTFP__
1697   // Round to Near mode, IEEE compatible, masked exceptions
1698   mov(Rtemp, 0);
1699   vmsr(FPSCR, Rtemp);
</pre>
<hr />
<pre>
1953                                      Address obj, Register new_val, Register tmp1, Register tmp2, Register tmp3, bool is_null) {
1954   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1955   decorators = AccessInternal::decorator_fixup(decorators);
1956   bool as_raw = (decorators &amp; AS_RAW) != 0;
1957   if (as_raw) {
1958     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);
1959   } else {
1960     bs-&gt;store_at(this, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);
1961   }
1962 }
1963 
1964 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
1965   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
1966   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
1967     decorators |= ACCESS_READ | ACCESS_WRITE;
1968   }
1969   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1970   return bs-&gt;resolve(this, decorators, obj);
1971 }
1972 
<span class="line-removed">1973 </span>
<span class="line-removed">1974 #ifdef COMPILER2</span>
<span class="line-removed">1975 void MacroAssembler::fast_lock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2, Register scratch3)</span>
<span class="line-removed">1976 {</span>
<span class="line-removed">1977   assert(VM_Version::supports_ldrex(), &quot;unsupported, yet?&quot;);</span>
<span class="line-removed">1978 </span>
<span class="line-removed">1979   Register Rmark      = Rscratch2;</span>
<span class="line-removed">1980 </span>
<span class="line-removed">1981   assert(Roop != Rscratch, &quot;&quot;);</span>
<span class="line-removed">1982   assert(Roop != Rmark, &quot;&quot;);</span>
<span class="line-removed">1983   assert(Rbox != Rscratch, &quot;&quot;);</span>
<span class="line-removed">1984   assert(Rbox != Rmark, &quot;&quot;);</span>
<span class="line-removed">1985 </span>
<span class="line-removed">1986   Label fast_lock, done;</span>
<span class="line-removed">1987 </span>
<span class="line-removed">1988   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed">1989     assert(scratch3 != noreg, &quot;need extra temporary for -XX:-UseOptoBiasInlining&quot;);</span>
<span class="line-removed">1990     biased_locking_enter(Roop, Rmark, Rscratch, false, scratch3, done, done);</span>
<span class="line-removed">1991     // Fall through if lock not biased otherwise branch to done</span>
<span class="line-removed">1992   }</span>
<span class="line-removed">1993 </span>
<span class="line-removed">1994   // Invariant: Rmark loaded below does not contain biased lock pattern</span>
<span class="line-removed">1995 </span>
<span class="line-removed">1996   ldr(Rmark, Address(Roop, oopDesc::mark_offset_in_bytes()));</span>
<span class="line-removed">1997   tst(Rmark, markWord::unlocked_value);</span>
<span class="line-removed">1998   b(fast_lock, ne);</span>
<span class="line-removed">1999 </span>
<span class="line-removed">2000   // Check for recursive lock</span>
<span class="line-removed">2001   // See comments in InterpreterMacroAssembler::lock_object for</span>
<span class="line-removed">2002   // explanations on the fast recursive locking check.</span>
<span class="line-removed">2003   // -1- test low 2 bits</span>
<span class="line-removed">2004   movs(Rscratch, AsmOperand(Rmark, lsl, 30));</span>
<span class="line-removed">2005   // -2- test (hdr - SP) if the low two bits are 0</span>
<span class="line-removed">2006   sub(Rscratch, Rmark, SP, eq);</span>
<span class="line-removed">2007   movs(Rscratch, AsmOperand(Rscratch, lsr, exact_log2(os::vm_page_size())), eq);</span>
<span class="line-removed">2008   // If still &#39;eq&#39; then recursive locking OK</span>
<span class="line-removed">2009   // set to zero if recursive lock, set to non zero otherwise (see discussion in JDK-8153107)</span>
<span class="line-removed">2010   str(Rscratch, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));</span>
<span class="line-removed">2011   b(done);</span>
<span class="line-removed">2012 </span>
<span class="line-removed">2013   bind(fast_lock);</span>
<span class="line-removed">2014   str(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));</span>
<span class="line-removed">2015 </span>
<span class="line-removed">2016   bool allow_fallthrough_on_failure = true;</span>
<span class="line-removed">2017   bool one_shot = true;</span>
<span class="line-removed">2018   cas_for_lock_acquire(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);</span>
<span class="line-removed">2019 </span>
<span class="line-removed">2020   bind(done);</span>
<span class="line-removed">2021 </span>
<span class="line-removed">2022   // At this point flags are set as follows:</span>
<span class="line-removed">2023   //  EQ -&gt; Success</span>
<span class="line-removed">2024   //  NE -&gt; Failure, branch to slow path</span>
<span class="line-removed">2025 }</span>
<span class="line-removed">2026 </span>
<span class="line-removed">2027 void MacroAssembler::fast_unlock(Register Roop, Register Rbox, Register Rscratch, Register Rscratch2)</span>
<span class="line-removed">2028 {</span>
<span class="line-removed">2029   assert(VM_Version::supports_ldrex(), &quot;unsupported, yet?&quot;);</span>
<span class="line-removed">2030 </span>
<span class="line-removed">2031   Register Rmark      = Rscratch2;</span>
<span class="line-removed">2032 </span>
<span class="line-removed">2033   assert(Roop != Rscratch, &quot;&quot;);</span>
<span class="line-removed">2034   assert(Roop != Rmark, &quot;&quot;);</span>
<span class="line-removed">2035   assert(Rbox != Rscratch, &quot;&quot;);</span>
<span class="line-removed">2036   assert(Rbox != Rmark, &quot;&quot;);</span>
<span class="line-removed">2037 </span>
<span class="line-removed">2038   Label done;</span>
<span class="line-removed">2039 </span>
<span class="line-removed">2040   if (UseBiasedLocking &amp;&amp; !UseOptoBiasInlining) {</span>
<span class="line-removed">2041     biased_locking_exit(Roop, Rscratch, done);</span>
<span class="line-removed">2042   }</span>
<span class="line-removed">2043 </span>
<span class="line-removed">2044   ldr(Rmark, Address(Rbox, BasicLock::displaced_header_offset_in_bytes()));</span>
<span class="line-removed">2045   // If hdr is NULL, we&#39;ve got recursive locking and there&#39;s nothing more to do</span>
<span class="line-removed">2046   cmp(Rmark, 0);</span>
<span class="line-removed">2047   b(done, eq);</span>
<span class="line-removed">2048 </span>
<span class="line-removed">2049   // Restore the object header</span>
<span class="line-removed">2050   bool allow_fallthrough_on_failure = true;</span>
<span class="line-removed">2051   bool one_shot = true;</span>
<span class="line-removed">2052   cas_for_lock_release(Rmark, Rbox, Roop, Rscratch, done, allow_fallthrough_on_failure, one_shot);</span>
<span class="line-removed">2053 </span>
<span class="line-removed">2054   bind(done);</span>
<span class="line-removed">2055 </span>
<span class="line-removed">2056 }</span>
<span class="line-removed">2057 </span>
2058 void MacroAssembler::safepoint_poll(Register tmp1, Label&amp; slow_path) {
<span class="line-modified">2059   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">2060     ldr_u32(tmp1, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-modified">2061     tst(tmp1, exact_log2(SafepointMechanism::poll_bit()));</span>
<span class="line-removed">2062     b(slow_path, eq);</span>
<span class="line-removed">2063   } else {</span>
<span class="line-removed">2064     ldr_global_s32(tmp1, SafepointSynchronize::address_of_state());</span>
<span class="line-removed">2065     cmp(tmp1, SafepointSynchronize::_not_synchronized);</span>
<span class="line-removed">2066     b(slow_path, ne);</span>
<span class="line-removed">2067   }</span>
2068 }
2069 
2070 void MacroAssembler::get_polling_page(Register dest) {
<span class="line-modified">2071   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">2072     ldr(dest, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-removed">2073   } else {</span>
<span class="line-removed">2074     mov_address(dest, os::get_polling_page());</span>
<span class="line-removed">2075   }</span>
2076 }
2077 
2078 void MacroAssembler::read_polling_page(Register dest, relocInfo::relocType rtype) {
2079   get_polling_page(dest);
2080   relocate(rtype);
2081   ldr(dest, Address(dest));
2082 }
2083 
<span class="line-removed">2084 </span>
<span class="line-removed">2085 #endif // COMPILER2</span>
</pre>
</td>
<td>
<hr />
<pre>
1609   // CF == 0 means we reached the end of itable without finding icklass
1610   b(L_no_such_interface, cc);
1611 
1612   if (method_result != noreg) {
1613     // Interface found at previous position of Rscan, now load the method
1614     ldr_s32(Rtmp, Address(Rscan, itableOffsetEntry::offset_offset_in_bytes() - entry_size));
1615     if (itable_index.is_register()) {
1616       add(Rtmp, Rtmp, Rklass); // Add offset to Klass*
1617       assert(itableMethodEntry::size() * HeapWordSize == wordSize, &quot;adjust the scaling in the code below&quot;);
1618       assert(itableMethodEntry::method_offset_in_bytes() == 0, &quot;adjust the offset in the code below&quot;);
1619       ldr(method_result, Address::indexed_ptr(Rtmp, itable_index.as_register()));
1620     } else {
1621       int method_offset = itableMethodEntry::size() * HeapWordSize * itable_index.as_constant() +
1622                           itableMethodEntry::method_offset_in_bytes();
1623       add_slow(method_result, Rklass, method_offset);
1624       ldr(method_result, Address(method_result, Rtmp));
1625     }
1626   }
1627 }
1628 



















































1629 
1630 void MacroAssembler::inc_counter(address counter_addr, Register tmpreg1, Register tmpreg2) {
1631   mov_slow(tmpreg1, counter_addr);
1632   ldr_s32(tmpreg2, tmpreg1);
1633   add_32(tmpreg2, tmpreg2, 1);
1634   str_32(tmpreg2, tmpreg1);
1635 }
1636 
1637 void MacroAssembler::floating_cmp(Register dst) {
1638   vmrs(dst, FPSCR);
1639   orr(dst, dst, 0x08000000);
1640   eor(dst, dst, AsmOperand(dst, lsl, 3));
1641   mov(dst, AsmOperand(dst, asr, 30));
1642 }
1643 
1644 void MacroAssembler::restore_default_fp_mode() {
1645 #ifndef __SOFTFP__
1646   // Round to Near mode, IEEE compatible, masked exceptions
1647   mov(Rtemp, 0);
1648   vmsr(FPSCR, Rtemp);
</pre>
<hr />
<pre>
1902                                      Address obj, Register new_val, Register tmp1, Register tmp2, Register tmp3, bool is_null) {
1903   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1904   decorators = AccessInternal::decorator_fixup(decorators);
1905   bool as_raw = (decorators &amp; AS_RAW) != 0;
1906   if (as_raw) {
1907     bs-&gt;BarrierSetAssembler::store_at(this, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);
1908   } else {
1909     bs-&gt;store_at(this, decorators, type, obj, new_val, tmp1, tmp2, tmp3, is_null);
1910   }
1911 }
1912 
1913 void MacroAssembler::resolve(DecoratorSet decorators, Register obj) {
1914   // Use stronger ACCESS_WRITE|ACCESS_READ by default.
1915   if ((decorators &amp; (ACCESS_READ | ACCESS_WRITE)) == 0) {
1916     decorators |= ACCESS_READ | ACCESS_WRITE;
1917   }
1918   BarrierSetAssembler* bs = BarrierSet::barrier_set()-&gt;barrier_set_assembler();
1919   return bs-&gt;resolve(this, decorators, obj);
1920 }
1921 





















































































1922 void MacroAssembler::safepoint_poll(Register tmp1, Label&amp; slow_path) {
<span class="line-modified">1923   ldr_u32(tmp1, Address(Rthread, Thread::polling_page_offset()));</span>
<span class="line-modified">1924   tst(tmp1, exact_log2(SafepointMechanism::poll_bit()));</span>
<span class="line-modified">1925   b(slow_path, eq);</span>






1926 }
1927 
1928 void MacroAssembler::get_polling_page(Register dest) {
<span class="line-modified">1929   ldr(dest, Address(Rthread, Thread::polling_page_offset()));</span>




1930 }
1931 
1932 void MacroAssembler::read_polling_page(Register dest, relocInfo::relocType rtype) {
1933   get_polling_page(dest);
1934   relocate(rtype);
1935   ldr(dest, Address(dest));
1936 }
1937 


</pre>
</td>
</tr>
</table>
<center><a href="interp_masm_arm.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_arm.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/cpu/arm/arm.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>    1 //
    2 // Copyright (c) 2008, 2020, Oracle and/or its affiliates. All rights reserved.
    3 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    4 //
    5 // This code is free software; you can redistribute it and/or modify it
    6 // under the terms of the GNU General Public License version 2 only, as
    7 // published by the Free Software Foundation.
    8 //
    9 // This code is distributed in the hope that it will be useful, but WITHOUT
   10 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   11 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   12 // version 2 for more details (a copy is included in the LICENSE file that
   13 // accompanied this code).
   14 //
   15 // You should have received a copy of the GNU General Public License version
   16 // 2 along with this work; if not, write to the Free Software Foundation,
   17 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   18 //
   19 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   20 // or visit www.oracle.com if you need additional information or have any
   21 // questions.
   22 //
   23 
   24 // ARM Architecture Description File
   25 
   26 //----------DEFINITION BLOCK---------------------------------------------------
   27 // Define name --&gt; value mappings to inform the ADLC of an integer valued name
   28 // Current support includes integer values in the range [0, 0x7FFFFFFF]
   29 // Format:
   30 //        int_def  &lt;name&gt;         ( &lt;int_value&gt;, &lt;expression&gt;);
   31 // Generated Code in ad_&lt;arch&gt;.hpp
   32 //        #define  &lt;name&gt;   (&lt;expression&gt;)
   33 //        // value == &lt;int_value&gt;
   34 // Generated code in ad_&lt;arch&gt;.cpp adlc_verification()
   35 //        assert( &lt;name&gt; == &lt;int_value&gt;, &quot;Expect (&lt;expression&gt;) to equal &lt;int_value&gt;&quot;);
   36 //
   37 definitions %{
   38 // The default cost (of an ALU instruction).
   39   int_def DEFAULT_COST      (    100,     100);
   40   int_def HUGE_COST         (1000000, 1000000);
   41 
   42 // Memory refs are twice as expensive as run-of-the-mill.
   43   int_def MEMORY_REF_COST   (    200, DEFAULT_COST * 2);
   44 
   45 // Branches are even more expensive.
   46   int_def BRANCH_COST       (    300, DEFAULT_COST * 3);
   47   int_def CALL_COST         (    300, DEFAULT_COST * 3);
   48 %}
   49 
   50 
   51 //----------SOURCE BLOCK-------------------------------------------------------
   52 // This is a block of C++ code which provides values, functions, and
   53 // definitions necessary in the rest of the architecture description
   54 source_hpp %{
   55 // Header information of the source block.
   56 // Method declarations/definitions which are used outside
   57 // the ad-scope can conveniently be defined here.
   58 //
   59 // To keep related declarations/definitions/uses close together,
   60 // we switch between source %{ }% and source_hpp %{ }% freely as needed.
   61 
   62 // Does destination need to be loaded in a register then passed to a
   63 // branch instruction?
   64 extern bool maybe_far_call(const CallNode *n);
   65 extern bool maybe_far_call(const MachCallNode *n);
   66 static inline bool cache_reachable() {
   67   return MacroAssembler::_cache_fully_reachable();
   68 }
   69 
   70 #define ldr_32 ldr
   71 #define str_32 str
   72 #define tst_32 tst
   73 #define teq_32 teq
   74 #if 1
   75 extern bool PrintOptoAssembly;
   76 #endif
   77 
   78 class c2 {
   79 public:
   80   static OptoRegPair return_value(int ideal_reg);
   81 };
   82 
   83 class CallStubImpl {
   84 
   85   //--------------------------------------------------------------
   86   //---&lt;  Used for optimization in Compile::Shorten_branches  &gt;---
   87   //--------------------------------------------------------------
   88 
   89  public:
   90   // Size of call trampoline stub.
   91   static uint size_call_trampoline() {
   92     return 0; // no call trampolines on this platform
   93   }
   94 
   95   // number of relocations needed by a call trampoline stub
   96   static uint reloc_call_trampoline() {
   97     return 0; // no call trampolines on this platform
   98   }
   99 };
  100 
  101 class HandlerImpl {
  102 
  103  public:
  104 
  105   static int emit_exception_handler(CodeBuffer &amp;cbuf);
  106   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
  107 
  108   static uint size_exception_handler() {
  109     return ( 3 * 4 );
  110   }
  111 
  112 
  113   static uint size_deopt_handler() {
  114     return ( 9 * 4 );
  115   }
  116 
  117 };
  118 
<a name="1" id="anc1"></a><span class="line-added">  119 class Node::PD {</span>
<span class="line-added">  120 public:</span>
<span class="line-added">  121   enum NodeFlags {</span>
<span class="line-added">  122     _last_flag = Node::_last_flag</span>
<span class="line-added">  123   };</span>
<span class="line-added">  124 };</span>
<span class="line-added">  125 </span>
  126 %}
  127 
  128 source %{
  129 #define __ _masm.
  130 
  131 static FloatRegister reg_to_FloatRegister_object(int register_encoding);
  132 static Register reg_to_register_object(int register_encoding);
  133 
<a name="2" id="anc2"></a><span class="line-added">  134 void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">  135 }</span>
<span class="line-added">  136 </span>
<span class="line-added">  137 int MachNode::pd_alignment_required() const {</span>
<span class="line-added">  138   return 1;</span>
<span class="line-added">  139 }</span>
<span class="line-added">  140 </span>
<span class="line-added">  141 int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">  142   return 0;</span>
<span class="line-added">  143 }</span>
  144 
  145 // ****************************************************************************
  146 
  147 // REQUIRED FUNCTIONALITY
  148 
  149 // Indicate if the safepoint node needs the polling page as an input.
  150 // Since ARM does not have absolute addressing, it does.
  151 bool SafePointNode::needs_polling_address_input() {
  152   return true;
  153 }
  154 
  155 // emit an interrupt that is caught by the debugger (for debugging compiler)
  156 void emit_break(CodeBuffer &amp;cbuf) {
<a name="3" id="anc3"></a><span class="line-modified">  157   C2_MacroAssembler _masm(&amp;cbuf);</span>
  158   __ breakpoint();
  159 }
  160 
  161 #ifndef PRODUCT
  162 void MachBreakpointNode::format( PhaseRegAlloc *, outputStream *st ) const {
  163   st-&gt;print(&quot;TA&quot;);
  164 }
  165 #endif
  166 
  167 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  168   emit_break(cbuf);
  169 }
  170 
  171 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  172   return MachNode::size(ra_);
  173 }
  174 
  175 
  176 void emit_nop(CodeBuffer &amp;cbuf) {
<a name="4" id="anc4"></a><span class="line-modified">  177   C2_MacroAssembler _masm(&amp;cbuf);</span>
  178   __ nop();
  179 }
  180 
  181 
  182 void emit_call_reloc(CodeBuffer &amp;cbuf, const MachCallNode *n, MachOper *m, RelocationHolder const&amp; rspec) {
  183   int ret_addr_offset0 = n-&gt;as_MachCall()-&gt;ret_addr_offset();
  184   int call_site_offset = cbuf.insts()-&gt;mark_off();
<a name="5" id="anc5"></a><span class="line-modified">  185   C2_MacroAssembler _masm(&amp;cbuf);</span>
  186   __ set_inst_mark(); // needed in emit_to_interp_stub() to locate the call
  187   address target = (address)m-&gt;method();
  188   assert(n-&gt;as_MachCall()-&gt;entry_point() == target, &quot;sanity&quot;);
  189   assert(maybe_far_call(n) == !__ reachable_from_cache(target), &quot;sanity&quot;);
  190   assert(cache_reachable() == __ cache_fully_reachable(), &quot;sanity&quot;);
  191 
  192   assert(target != NULL, &quot;need real address&quot;);
  193 
  194   int ret_addr_offset = -1;
  195   if (rspec.type() == relocInfo::runtime_call_type) {
  196     __ call(target, rspec);
  197     ret_addr_offset = __ offset();
  198   } else {
  199     // scratches Rtemp
  200     ret_addr_offset = __ patchable_call(target, rspec, true);
  201   }
  202   assert(ret_addr_offset - call_site_offset == ret_addr_offset0, &quot;fix ret_addr_offset()&quot;);
  203 }
  204 
  205 //=============================================================================
  206 // REQUIRED FUNCTIONALITY for encoding
  207 void emit_lo(CodeBuffer &amp;cbuf, int val) {  }
  208 void emit_hi(CodeBuffer &amp;cbuf, int val) {  }
  209 
  210 
  211 //=============================================================================
  212 const RegMask&amp; MachConstantBaseNode::_out_RegMask = PTR_REG_mask();
  213 
<a name="6" id="anc6"></a><span class="line-modified">  214 int ConstantTable::calculate_table_base_offset() const {</span>
  215   int offset = -(size() / 2);
  216   // flds, fldd: 8-bit  offset multiplied by 4: +/- 1024
  217   // ldr, ldrb : 12-bit offset:                 +/- 4096
  218   if (!Assembler::is_simm10(offset)) {
  219     offset = Assembler::min_simm10();
  220   }
  221   return offset;
  222 }
  223 
  224 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  225 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  226   ShouldNotReachHere();
  227 }
  228 
  229 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
  230   Compile* C = ra_-&gt;C;
<a name="7" id="anc7"></a><span class="line-modified">  231   ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
<span class="line-modified">  232   C2_MacroAssembler _masm(&amp;cbuf);</span>
  233 
  234   Register r = as_Register(ra_-&gt;get_encode(this));
  235   CodeSection* consts_section = __ code()-&gt;consts();
  236   int consts_size = consts_section-&gt;align_at_start(consts_section-&gt;size());
  237   assert(constant_table.size() == consts_size, &quot;must be: %d == %d&quot;, constant_table.size(), consts_size);
  238 
  239   // Materialize the constant table base.
  240   address baseaddr = consts_section-&gt;start() + -(constant_table.table_base_offset());
  241   RelocationHolder rspec = internal_word_Relocation::spec(baseaddr);
  242   __ mov_address(r, baseaddr, rspec);
  243 }
  244 
  245 uint MachConstantBaseNode::size(PhaseRegAlloc*) const {
  246   return 8;
  247 }
  248 
  249 #ifndef PRODUCT
  250 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  251   char reg[128];
  252   ra_-&gt;dump_register(this, reg);
  253   st-&gt;print(&quot;MOV_SLOW    &amp;constanttable,%s\t! constant table base&quot;, reg);
  254 }
  255 #endif
  256 
  257 #ifndef PRODUCT
  258 void MachPrologNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  259   Compile* C = ra_-&gt;C;
  260 
  261   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  262     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  263   }
  264 
<a name="8" id="anc8"></a><span class="line-modified">  265   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  266   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<a name="9" id="anc9"></a><span class="line-modified">  267   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  268   // Remove two words for return addr and rbp,
  269   framesize -= 2*wordSize;
  270   bangsize -= 2*wordSize;
  271 
  272   // Calls to C2R adapters often do not accept exceptional returns.
  273   // We require that their callers must bang for them.  But be careful, because
  274   // some VM calls (such as call site linkage) can use several kilobytes of
  275   // stack.  But the stack safety zone should account for that.
  276   // See bugs 4446381, 4468289, 4497237.
<a name="10" id="anc10"></a><span class="line-modified">  277   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  278     st-&gt;print_cr(&quot;! stack bang (%d bytes)&quot;, bangsize); st-&gt;print(&quot;\t&quot;);
  279   }
  280   st-&gt;print_cr(&quot;PUSH   R_FP|R_LR_LR&quot;); st-&gt;print(&quot;\t&quot;);
  281   if (framesize != 0) {
  282     st-&gt;print   (&quot;SUB    R_SP, R_SP, &quot; SIZE_FORMAT,framesize);
  283   }
  284 }
  285 #endif
  286 
  287 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  288   Compile* C = ra_-&gt;C;
<a name="11" id="anc11"></a><span class="line-modified">  289   C2_MacroAssembler _masm(&amp;cbuf);</span>
  290 
  291   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  292     __ nop();
  293   }
  294 
<a name="12" id="anc12"></a><span class="line-modified">  295   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  296   assert((framesize &amp; (StackAlignmentInBytes-1)) == 0, &quot;frame size not aligned&quot;);
<a name="13" id="anc13"></a><span class="line-modified">  297   int bangsize = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  298   // Remove two words for return addr and fp,
  299   framesize -= 2*wordSize;
  300   bangsize -= 2*wordSize;
  301 
  302   // Calls to C2R adapters often do not accept exceptional returns.
  303   // We require that their callers must bang for them.  But be careful, because
  304   // some VM calls (such as call site linkage) can use several kilobytes of
  305   // stack.  But the stack safety zone should account for that.
  306   // See bugs 4446381, 4468289, 4497237.
<a name="14" id="anc14"></a><span class="line-modified">  307   if (C-&gt;output()-&gt;need_stack_bang(bangsize)) {</span>
  308     __ arm_stack_overflow_check(bangsize, Rtemp);
  309   }
  310 
  311   __ raw_push(FP, LR);
  312   if (framesize != 0) {
  313     __ sub_slow(SP, SP, framesize);
  314   }
  315 
  316   // offset from scratch buffer is not valid
  317   if (strcmp(cbuf.name(), &quot;Compile::Fill_buffer&quot;) == 0) {
<a name="15" id="anc15"></a><span class="line-modified">  318     C-&gt;output()-&gt;set_frame_complete( __ offset() );</span>
  319   }
  320 
  321   if (C-&gt;has_mach_constant_base_node()) {
  322     // NOTE: We set the table base offset here because users might be
  323     // emitted before MachConstantBaseNode.
<a name="16" id="anc16"></a><span class="line-modified">  324     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  325     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  326   }
  327 }
  328 
  329 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  330   return MachNode::size(ra_);
  331 }
  332 
  333 int MachPrologNode::reloc() const {
  334   return 10; // a large enough number
  335 }
  336 
  337 //=============================================================================
  338 #ifndef PRODUCT
  339 void MachEpilogNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  340   Compile* C = ra_-&gt;C;
  341 
<a name="17" id="anc17"></a><span class="line-modified">  342   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  343   framesize -= 2*wordSize;
  344 
  345   if (framesize != 0) {
  346     st-&gt;print(&quot;ADD    R_SP, R_SP, &quot; SIZE_FORMAT &quot;\n\t&quot;,framesize);
  347   }
  348   st-&gt;print(&quot;POP    R_FP|R_LR_LR&quot;);
  349 
  350   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  351     st-&gt;print(&quot;\n\t&quot;);
  352     st-&gt;print(&quot;MOV    Rtemp, #PollAddr\t! Load Polling address\n\t&quot;);
  353     st-&gt;print(&quot;LDR    Rtemp,[Rtemp]\t!Poll for Safepointing&quot;);
  354   }
  355 }
  356 #endif
  357 
  358 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="18" id="anc18"></a><span class="line-modified">  359   C2_MacroAssembler _masm(&amp;cbuf);</span>
  360   Compile* C = ra_-&gt;C;
  361 
<a name="19" id="anc19"></a><span class="line-modified">  362   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
  363   framesize -= 2*wordSize;
  364   if (framesize != 0) {
  365     __ add_slow(SP, SP, framesize);
  366   }
  367   __ raw_pop(FP, LR);
  368 
  369   // If this does safepoint polling, then do it here
  370   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  371     __ read_polling_page(Rtemp, relocInfo::poll_return_type);
  372   }
  373 }
  374 
  375 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  376   return MachNode::size(ra_);
  377 }
  378 
  379 int MachEpilogNode::reloc() const {
  380   return 16; // a large enough number
  381 }
  382 
  383 const Pipeline * MachEpilogNode::pipeline() const {
  384   return MachNode::pipeline_class();
  385 }
  386 
<a name="20" id="anc20"></a>






  387 //=============================================================================
  388 
  389 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack
  390 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  391 static enum RC rc_class( OptoReg::Name reg ) {
  392   if (!OptoReg::is_valid(reg)) return rc_bad;
  393   if (OptoReg::is_stack(reg)) return rc_stack;
  394   VMReg r = OptoReg::as_VMReg(reg);
  395   if (r-&gt;is_Register()) return rc_int;
  396   assert(r-&gt;is_FloatRegister(), &quot;must be&quot;);
  397   return rc_float;
  398 }
  399 
  400 static inline bool is_iRegLd_memhd(OptoReg::Name src_first, OptoReg::Name src_second, int offset) {
  401   int rlo = Matcher::_regEncode[src_first];
  402   int rhi = Matcher::_regEncode[src_second];
  403   if (!((rlo&amp;1)==0 &amp;&amp; (rlo+1 == rhi))) {
  404     tty-&gt;print_cr(&quot;CAUGHT BAD LDRD/STRD&quot;);
  405   }
  406   return (rlo&amp;1)==0 &amp;&amp; (rlo+1 == rhi) &amp;&amp; is_memoryHD(offset);
  407 }
  408 
  409 uint MachSpillCopyNode::implementation( CodeBuffer *cbuf,
  410                                         PhaseRegAlloc *ra_,
  411                                         bool do_size,
  412                                         outputStream* st ) const {
  413   // Get registers to move
  414   OptoReg::Name src_second = ra_-&gt;get_reg_second(in(1));
  415   OptoReg::Name src_first = ra_-&gt;get_reg_first(in(1));
  416   OptoReg::Name dst_second = ra_-&gt;get_reg_second(this );
  417   OptoReg::Name dst_first = ra_-&gt;get_reg_first(this );
  418 
  419   enum RC src_second_rc = rc_class(src_second);
  420   enum RC src_first_rc = rc_class(src_first);
  421   enum RC dst_second_rc = rc_class(dst_second);
  422   enum RC dst_first_rc = rc_class(dst_first);
  423 
  424   assert( OptoReg::is_valid(src_first) &amp;&amp; OptoReg::is_valid(dst_first), &quot;must move at least 1 register&quot; );
  425 
  426   // Generate spill code!
  427   int size = 0;
  428 
  429   if (src_first == dst_first &amp;&amp; src_second == dst_second)
  430     return size;            // Self copy, no move
  431 
  432 #ifdef TODO
  433   if (bottom_type()-&gt;isa_vect() != NULL) {
  434   }
  435 #endif
  436 
  437   // Shared code does not expect instruction set capability based bailouts here.
  438   // Handle offset unreachable bailout with minimal change in shared code.
  439   // Bailout only for real instruction emit.
  440   // This requires a single comment change in shared code. ( see output.cpp &quot;Normal&quot; instruction case )
  441 
<a name="21" id="anc21"></a><span class="line-modified">  442   C2_MacroAssembler _masm(cbuf);</span>
  443 
  444   // --------------------------------------
  445   // Check for mem-mem move.  Load into unused float registers and fall into
  446   // the float-store case.
  447   if (src_first_rc == rc_stack &amp;&amp; dst_first_rc == rc_stack) {
  448     int offset = ra_-&gt;reg2offset(src_first);
  449     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  450       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  451       return 0;
  452     } else {
  453       if (src_second_rc != rc_bad) {
  454         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  455         src_first     = OptoReg::Name(R_mem_copy_lo_num);
  456         src_second    = OptoReg::Name(R_mem_copy_hi_num);
  457         src_first_rc  = rc_float;
  458         src_second_rc = rc_float;
  459         if (cbuf) {
  460           __ ldr_double(Rmemcopy, Address(SP, offset));
  461         } else if (!do_size) {
  462           st-&gt;print(LDR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
  463         }
  464       } else {
  465         src_first     = OptoReg::Name(R_mem_copy_lo_num);
  466         src_first_rc  = rc_float;
  467         if (cbuf) {
  468           __ ldr_float(Rmemcopy, Address(SP, offset));
  469         } else if (!do_size) {
  470           st-&gt;print(LDR_FLOAT &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
  471         }
  472       }
  473       size += 4;
  474     }
  475   }
  476 
  477   if (src_second_rc == rc_stack &amp;&amp; dst_second_rc == rc_stack) {
  478     Unimplemented();
  479   }
  480 
  481   // --------------------------------------
  482   // Check for integer reg-reg copy
  483   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_int) {
  484     // Else normal reg-reg copy
  485     assert( src_second != dst_first, &quot;smashed second before evacuating it&quot; );
  486     if (cbuf) {
  487       __ mov(reg_to_register_object(Matcher::_regEncode[dst_first]), reg_to_register_object(Matcher::_regEncode[src_first]));
  488 #ifndef PRODUCT
  489     } else if (!do_size) {
  490       st-&gt;print(&quot;MOV    R_%s, R_%s\t# spill&quot;,
  491                 Matcher::regName[dst_first],
  492                 Matcher::regName[src_first]);
  493 #endif
  494     }
  495     size += 4;
  496   }
  497 
  498   // Check for integer store
  499   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_stack) {
  500     int offset = ra_-&gt;reg2offset(dst_first);
  501     if (cbuf &amp;&amp; !is_memoryI(offset)) {
  502       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  503       return 0;
  504     } else {
  505       if (src_second_rc != rc_bad &amp;&amp; is_iRegLd_memhd(src_first, src_second, offset)) {
  506         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  507         if (cbuf) {
  508           __ str_64(reg_to_register_object(Matcher::_regEncode[src_first]), Address(SP, offset));
  509 #ifndef PRODUCT
  510         } else if (!do_size) {
  511           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  512           st-&gt;print(STR_64 &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first), offset);
  513 #endif
  514         }
  515         return size + 4;
  516       } else {
  517         if (cbuf) {
  518           __ str_32(reg_to_register_object(Matcher::_regEncode[src_first]), Address(SP, offset));
  519 #ifndef PRODUCT
  520         } else if (!do_size) {
  521           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  522           st-&gt;print(STR_32 &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first), offset);
  523 #endif
  524         }
  525       }
  526     }
  527     size += 4;
  528   }
  529 
  530   // Check for integer load
  531   if (dst_first_rc == rc_int &amp;&amp; src_first_rc == rc_stack) {
  532     int offset = ra_-&gt;reg2offset(src_first);
  533     if (cbuf &amp;&amp; !is_memoryI(offset)) {
  534       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  535       return 0;
  536     } else {
  537       if (src_second_rc != rc_bad &amp;&amp; is_iRegLd_memhd(dst_first, dst_second, offset)) {
  538         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pair of registers must be aligned/contiguous&quot;);
  539         if (cbuf) {
  540           __ ldr_64(reg_to_register_object(Matcher::_regEncode[dst_first]), Address(SP, offset));
  541 #ifndef PRODUCT
  542         } else if (!do_size) {
  543           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  544           st-&gt;print(LDR_64 &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(dst_first), offset);
  545 #endif
  546         }
  547         return size + 4;
  548       } else {
  549         if (cbuf) {
  550           __ ldr_32(reg_to_register_object(Matcher::_regEncode[dst_first]), Address(SP, offset));
  551 #ifndef PRODUCT
  552         } else if (!do_size) {
  553           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  554           st-&gt;print(LDR_32 &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(dst_first), offset);
  555 #endif
  556         }
  557       }
  558     }
  559     size += 4;
  560   }
  561 
  562   // Check for float reg-reg copy
  563   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_float) {
  564     if (src_second_rc != rc_bad) {
  565       assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second &amp;&amp; (dst_first&amp;1)==0 &amp;&amp; dst_first+1 == dst_second, &quot;pairs of registers must be aligned/contiguous&quot;);
  566       if (cbuf) {
  567       __ mov_double(reg_to_FloatRegister_object(Matcher::_regEncode[dst_first]), reg_to_FloatRegister_object(Matcher::_regEncode[src_first]));
  568 #ifndef PRODUCT
  569       } else if (!do_size) {
  570         st-&gt;print(MOV_DOUBLE &quot;    R_%s, R_%s\t# spill&quot;,
  571                   Matcher::regName[dst_first],
  572                   Matcher::regName[src_first]);
  573 #endif
  574       }
  575       return 4;
  576     }
  577     if (cbuf) {
  578       __ mov_float(reg_to_FloatRegister_object(Matcher::_regEncode[dst_first]), reg_to_FloatRegister_object(Matcher::_regEncode[src_first]));
  579 #ifndef PRODUCT
  580     } else if (!do_size) {
  581       st-&gt;print(MOV_FLOAT &quot;    R_%s, R_%s\t# spill&quot;,
  582                 Matcher::regName[dst_first],
  583                 Matcher::regName[src_first]);
  584 #endif
  585     }
  586     size = 4;
  587   }
  588 
  589   // Check for float store
  590   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_stack) {
  591     int offset = ra_-&gt;reg2offset(dst_first);
  592     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  593       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  594       return 0;
  595     } else {
  596       // Further check for aligned-adjacent pair, so we can use a double store
  597       if (src_second_rc != rc_bad) {
  598         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second &amp;&amp; (dst_first&amp;1)==0 &amp;&amp; dst_first+1 == dst_second, &quot;pairs of registers and stack slots must be aligned/contiguous&quot;);
  599         if (cbuf) {
  600           __ str_double(reg_to_FloatRegister_object(Matcher::_regEncode[src_first]), Address(SP, offset));
  601 #ifndef PRODUCT
  602         } else if (!do_size) {
  603           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  604           st-&gt;print(STR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
  605 #endif
  606         }
  607         return size + 4;
  608       } else {
  609         if (cbuf) {
  610           __ str_float(reg_to_FloatRegister_object(Matcher::_regEncode[src_first]), Address(SP, offset));
  611 #ifndef PRODUCT
  612         } else if (!do_size) {
  613           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  614           st-&gt;print(STR_FLOAT &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_first),offset);
  615 #endif
  616         }
  617       }
  618     }
  619     size += 4;
  620   }
  621 
  622   // Check for float load
  623   if (dst_first_rc == rc_float &amp;&amp; src_first_rc == rc_stack) {
  624     int offset = ra_-&gt;reg2offset(src_first);
  625     if (cbuf &amp;&amp; !is_memoryfp(offset)) {
  626       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  627       return 0;
  628     } else {
  629       // Further check for aligned-adjacent pair, so we can use a double store
  630       if (src_second_rc != rc_bad) {
  631         assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second &amp;&amp; (dst_first&amp;1)==0 &amp;&amp; dst_first+1 == dst_second, &quot;pairs of registers and stack slots must be aligned/contiguous&quot;);
  632         if (cbuf) {
  633           __ ldr_double(reg_to_FloatRegister_object(Matcher::_regEncode[dst_first]), Address(SP, offset));
  634 #ifndef PRODUCT
  635         } else if (!do_size) {
  636           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  637           st-&gt;print(LDR_DOUBLE &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(dst_first),offset);
  638 #endif
  639         }
  640         return size + 4;
  641       } else {
  642         if (cbuf) {
  643           __ ldr_float(reg_to_FloatRegister_object(Matcher::_regEncode[dst_first]), Address(SP, offset));
  644 #ifndef PRODUCT
  645         } else if (!do_size) {
  646           if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  647           st-&gt;print(LDR_FLOAT &quot;   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(dst_first),offset);
  648 #endif
  649         }
  650       }
  651     }
  652     size += 4;
  653   }
  654 
  655   // check for int reg -&gt; float reg move
  656   if (src_first_rc == rc_int &amp;&amp; dst_first_rc == rc_float) {
  657     // Further check for aligned-adjacent pair, so we can use a single instruction
  658     if (src_second_rc != rc_bad) {
  659       assert((dst_first&amp;1)==0 &amp;&amp; dst_first+1 == dst_second, &quot;pairs of registers must be aligned/contiguous&quot;);
  660       assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pairs of registers must be aligned/contiguous&quot;);
  661       assert(src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_float, &quot;unsupported&quot;);
  662       if (cbuf) {
  663         __ fmdrr(reg_to_FloatRegister_object(Matcher::_regEncode[dst_first]), reg_to_register_object(Matcher::_regEncode[src_first]), reg_to_register_object(Matcher::_regEncode[src_second]));
  664 #ifndef PRODUCT
  665       } else if (!do_size) {
  666         if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  667         st-&gt;print(&quot;FMDRR   R_%s, R_%s, R_%s\t! spill&quot;,OptoReg::regname(dst_first), OptoReg::regname(src_first), OptoReg::regname(src_second));
  668 #endif
  669       }
  670       return size + 4;
  671     } else {
  672       if (cbuf) {
  673         __ fmsr(reg_to_FloatRegister_object(Matcher::_regEncode[dst_first]), reg_to_register_object(Matcher::_regEncode[src_first]));
  674 #ifndef PRODUCT
  675       } else if (!do_size) {
  676         if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  677         st-&gt;print(FMSR &quot;   R_%s, R_%s\t! spill&quot;,OptoReg::regname(dst_first), OptoReg::regname(src_first));
  678 #endif
  679       }
  680       size += 4;
  681     }
  682   }
  683 
  684   // check for float reg -&gt; int reg move
  685   if (src_first_rc == rc_float &amp;&amp; dst_first_rc == rc_int) {
  686     // Further check for aligned-adjacent pair, so we can use a single instruction
  687     if (src_second_rc != rc_bad) {
  688       assert((src_first&amp;1)==0 &amp;&amp; src_first+1 == src_second, &quot;pairs of registers must be aligned/contiguous&quot;);
  689       assert((dst_first&amp;1)==0 &amp;&amp; dst_first+1 == dst_second, &quot;pairs of registers must be aligned/contiguous&quot;);
  690       assert(src_second_rc == rc_float &amp;&amp; dst_second_rc == rc_int, &quot;unsupported&quot;);
  691       if (cbuf) {
  692         __ fmrrd(reg_to_register_object(Matcher::_regEncode[dst_first]), reg_to_register_object(Matcher::_regEncode[dst_second]), reg_to_FloatRegister_object(Matcher::_regEncode[src_first]));
  693 #ifndef PRODUCT
  694       } else if (!do_size) {
  695         if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  696         st-&gt;print(&quot;FMRRD   R_%s, R_%s, R_%s\t! spill&quot;,OptoReg::regname(dst_first), OptoReg::regname(dst_second), OptoReg::regname(src_first));
  697 #endif
  698       }
  699       return size + 4;
  700     } else {
  701       if (cbuf) {
  702         __ fmrs(reg_to_register_object(Matcher::_regEncode[dst_first]), reg_to_FloatRegister_object(Matcher::_regEncode[src_first]));
  703 #ifndef PRODUCT
  704       } else if (!do_size) {
  705         if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  706         st-&gt;print(FMRS &quot;   R_%s, R_%s\t! spill&quot;,OptoReg::regname(dst_first), OptoReg::regname(src_first));
  707 #endif
  708       }
  709       size += 4;
  710     }
  711   }
  712 
  713   // --------------------------------------------------------------------
  714   // Check for hi bits still needing moving.  Only happens for misaligned
  715   // arguments to native calls.
  716   if (src_second == dst_second)
  717     return size;               // Self copy; no move
  718   assert( src_second_rc != rc_bad &amp;&amp; dst_second_rc != rc_bad, &quot;src_second &amp; dst_second cannot be Bad&quot; );
  719 
  720   // Check for integer reg-reg copy.  Hi bits are stuck up in the top
  721   // 32-bits of a 64-bit register, but are needed in low bits of another
  722   // register (else it&#39;s a hi-bits-to-hi-bits copy which should have
  723   // happened already as part of a 64-bit move)
  724   if (src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_int) {
  725     if (cbuf) {
  726       __ mov(reg_to_register_object(Matcher::_regEncode[dst_second]), reg_to_register_object(Matcher::_regEncode[src_second]));
  727 #ifndef PRODUCT
  728     } else if (!do_size) {
  729       if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  730       st-&gt;print(&quot;MOV    R_%s, R_%s\t# spill high&quot;,
  731                 Matcher::regName[dst_second],
  732                 Matcher::regName[src_second]);
  733 #endif
  734     }
  735     return size+4;
  736   }
  737 
  738   // Check for high word integer store
  739   if (src_second_rc == rc_int &amp;&amp; dst_second_rc == rc_stack) {
  740     int offset = ra_-&gt;reg2offset(dst_second);
  741 
  742     if (cbuf &amp;&amp; !is_memoryP(offset)) {
  743       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  744       return 0;
  745     } else {
  746       if (cbuf) {
  747         __ str(reg_to_register_object(Matcher::_regEncode[src_second]), Address(SP, offset));
  748 #ifndef PRODUCT
  749       } else if (!do_size) {
  750         if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  751         st-&gt;print(&quot;STR   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(src_second), offset);
  752 #endif
  753       }
  754     }
  755     return size + 4;
  756   }
  757 
  758   // Check for high word integer load
  759   if (dst_second_rc == rc_int &amp;&amp; src_second_rc == rc_stack) {
  760     int offset = ra_-&gt;reg2offset(src_second);
  761     if (cbuf &amp;&amp; !is_memoryP(offset)) {
  762       ra_-&gt;C-&gt;record_method_not_compilable(&quot;unable to handle large constant offsets&quot;);
  763       return 0;
  764     } else {
  765       if (cbuf) {
  766         __ ldr(reg_to_register_object(Matcher::_regEncode[dst_second]), Address(SP, offset));
  767 #ifndef PRODUCT
  768       } else if (!do_size) {
  769         if (size != 0) st-&gt;print(&quot;\n\t&quot;);
  770         st-&gt;print(&quot;LDR   R_%s,[R_SP + #%d]\t! spill&quot;,OptoReg::regname(dst_second), offset);
  771 #endif
  772       }
  773     }
  774     return size + 4;
  775   }
  776 
  777   Unimplemented();
  778   return 0; // Mute compiler
  779 }
  780 
  781 #ifndef PRODUCT
  782 void MachSpillCopyNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  783   implementation( NULL, ra_, false, st );
  784 }
  785 #endif
  786 
  787 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  788   implementation( &amp;cbuf, ra_, false, NULL );
  789 }
  790 
  791 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
  792   return implementation( NULL, ra_, true, NULL );
  793 }
  794 
  795 //=============================================================================
  796 #ifndef PRODUCT
  797 void MachNopNode::format( PhaseRegAlloc *, outputStream *st ) const {
  798   st-&gt;print(&quot;NOP \t# %d bytes pad for loops and calls&quot;, 4 * _count);
  799 }
  800 #endif
  801 
  802 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ) const {
<a name="22" id="anc22"></a><span class="line-modified">  803   C2_MacroAssembler _masm(&amp;cbuf);</span>
  804   for(int i = 0; i &lt; _count; i += 1) {
  805     __ nop();
  806   }
  807 }
  808 
  809 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
  810   return 4 * _count;
  811 }
  812 
  813 
  814 //=============================================================================
  815 #ifndef PRODUCT
  816 void BoxLockNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  817   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  818   int reg = ra_-&gt;get_reg_first(this);
  819   st-&gt;print(&quot;ADD    %s,R_SP+#%d&quot;,Matcher::regName[reg], offset);
  820 }
  821 #endif
  822 
  823 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="23" id="anc23"></a><span class="line-modified">  824   C2_MacroAssembler _masm(&amp;cbuf);</span>
  825   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
  826   int reg = ra_-&gt;get_encode(this);
  827   Register dst = reg_to_register_object(reg);
  828 
  829   if (is_aimm(offset)) {
  830     __ add(dst, SP, offset);
  831   } else {
  832     __ mov_slow(dst, offset);
  833     __ add(dst, SP, dst);
  834   }
  835 }
  836 
  837 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
  838   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
  839   assert(ra_ == ra_-&gt;C-&gt;regalloc(), &quot;sanity&quot;);
<a name="24" id="anc24"></a><span class="line-modified">  840   return ra_-&gt;C-&gt;output()-&gt;scratch_emit_size(this);</span>
  841 }
  842 
  843 //=============================================================================
  844 #ifndef PRODUCT
  845 #define R_RTEMP &quot;R_R12&quot;
  846 void MachUEPNode::format( PhaseRegAlloc *ra_, outputStream *st ) const {
  847   st-&gt;print_cr(&quot;\nUEP:&quot;);
  848   if (UseCompressedClassPointers) {
  849     st-&gt;print_cr(&quot;\tLDR_w &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  850     st-&gt;print_cr(&quot;\tdecode_klass &quot; R_RTEMP);
  851   } else {
  852     st-&gt;print_cr(&quot;\tLDR   &quot; R_RTEMP &quot;,[R_R0 + oopDesc::klass_offset_in_bytes]\t! Inline cache check&quot;);
  853   }
  854   st-&gt;print_cr(&quot;\tCMP   &quot; R_RTEMP &quot;,R_R8&quot; );
  855   st-&gt;print   (&quot;\tB.NE  SharedRuntime::handle_ic_miss_stub&quot;);
  856 }
  857 #endif
  858 
  859 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<a name="25" id="anc25"></a><span class="line-modified">  860   C2_MacroAssembler _masm(&amp;cbuf);</span>
  861   Register iCache  = reg_to_register_object(Matcher::inline_cache_reg_encode());
  862   assert(iCache == Ricklass, &quot;should be&quot;);
  863   Register receiver = R0;
  864 
  865   __ load_klass(Rtemp, receiver);
  866   __ cmp(Rtemp, iCache);
  867   __ jump(SharedRuntime::get_ic_miss_stub(), relocInfo::runtime_call_type, noreg, ne);
  868 }
  869 
  870 uint MachUEPNode::size(PhaseRegAlloc *ra_) const {
  871   return MachNode::size(ra_);
  872 }
  873 
  874 
  875 //=============================================================================
  876 
  877 // Emit exception handler code.
  878 int HandlerImpl::emit_exception_handler(CodeBuffer&amp; cbuf) {
<a name="26" id="anc26"></a><span class="line-modified">  879   C2_MacroAssembler _masm(&amp;cbuf);</span>
  880 
  881   address base = __ start_a_stub(size_exception_handler());
  882   if (base == NULL) {
  883     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  884     return 0;  // CodeBuffer::expand failed
  885   }
  886 
  887   int offset = __ offset();
  888 
  889   // OK to trash LR, because exception blob will kill it
  890   __ jump(OptoRuntime::exception_blob()-&gt;entry_point(), relocInfo::runtime_call_type, LR_tmp);
  891 
  892   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
  893 
  894   __ end_a_stub();
  895 
  896   return offset;
  897 }
  898 
  899 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
  900   // Can&#39;t use any of the current frame&#39;s registers as we may have deopted
  901   // at a poll and everything can be live.
<a name="27" id="anc27"></a><span class="line-modified">  902   C2_MacroAssembler _masm(&amp;cbuf);</span>
  903 
  904   address base = __ start_a_stub(size_deopt_handler());
  905   if (base == NULL) {
  906     ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
  907     return 0;  // CodeBuffer::expand failed
  908   }
  909 
  910   int offset = __ offset();
  911   address deopt_pc = __ pc();
  912 
  913   __ sub(SP, SP, wordSize); // make room for saved PC
  914   __ push(LR); // save LR that may be live when we get here
  915   __ mov_relative_address(LR, deopt_pc);
  916   __ str(LR, Address(SP, wordSize)); // save deopt PC
  917   __ pop(LR); // restore LR
  918   __ jump(SharedRuntime::deopt_blob()-&gt;unpack(), relocInfo::runtime_call_type, noreg);
  919 
  920   assert(__ offset() - offset &lt;= (int) size_deopt_handler(), &quot;overflow&quot;);
  921 
  922   __ end_a_stub();
  923   return offset;
  924 }
  925 
  926 const bool Matcher::match_rule_supported(int opcode) {
  927   if (!has_match_rule(opcode))
  928     return false;
  929 
  930   switch (opcode) {
  931   case Op_PopCountI:
  932   case Op_PopCountL:
  933     if (!UsePopCountInstruction)
  934       return false;
  935     break;
  936   case Op_LShiftCntV:
  937   case Op_RShiftCntV:
  938   case Op_AddVB:
  939   case Op_AddVS:
  940   case Op_AddVI:
  941   case Op_AddVL:
  942   case Op_SubVB:
  943   case Op_SubVS:
  944   case Op_SubVI:
  945   case Op_SubVL:
  946   case Op_MulVS:
  947   case Op_MulVI:
  948   case Op_LShiftVB:
  949   case Op_LShiftVS:
  950   case Op_LShiftVI:
  951   case Op_LShiftVL:
  952   case Op_RShiftVB:
  953   case Op_RShiftVS:
  954   case Op_RShiftVI:
  955   case Op_RShiftVL:
  956   case Op_URShiftVB:
  957   case Op_URShiftVS:
  958   case Op_URShiftVI:
  959   case Op_URShiftVL:
  960   case Op_AndV:
  961   case Op_OrV:
  962   case Op_XorV:
  963     return VM_Version::has_simd();
  964   case Op_LoadVector:
  965   case Op_StoreVector:
  966   case Op_AddVF:
  967   case Op_SubVF:
  968   case Op_MulVF:
  969     return VM_Version::has_vfp() || VM_Version::has_simd();
  970   case Op_AddVD:
  971   case Op_SubVD:
  972   case Op_MulVD:
  973   case Op_DivVF:
  974   case Op_DivVD:
  975     return VM_Version::has_vfp();
  976   }
  977 
  978   return true;  // Per default match rules are supported.
  979 }
  980 
  981 const bool Matcher::match_rule_supported_vector(int opcode, int vlen, BasicType bt) {
  982 
  983   // TODO
  984   // identify extra cases that we might want to provide match rules for
  985   // e.g. Op_ vector nodes and other intrinsics while guarding with vlen
  986   bool ret_value = match_rule_supported(opcode);
  987   // Add rules here.
  988 
  989   return ret_value;  // Per default match rules are supported.
  990 }
  991 
  992 const bool Matcher::has_predicated_vectors(void) {
  993   return false;
  994 }
  995 
  996 const int Matcher::float_pressure(int default_pressure_threshold) {
  997   return default_pressure_threshold;
  998 }
  999 
 1000 int Matcher::regnum_to_fpu_offset(int regnum) {
 1001   return regnum - 32; // The FP registers are in the second chunk
 1002 }
 1003 
 1004 // Vector width in bytes
 1005 const int Matcher::vector_width_in_bytes(BasicType bt) {
 1006   return MaxVectorSize;
 1007 }
 1008 
 1009 // Vector ideal reg corresponding to specified size in bytes
 1010 const uint Matcher::vector_ideal_reg(int size) {
 1011   assert(MaxVectorSize &gt;= size, &quot;&quot;);
 1012   switch(size) {
 1013     case  8: return Op_VecD;
 1014     case 16: return Op_VecX;
 1015   }
 1016   ShouldNotReachHere();
 1017   return 0;
 1018 }
 1019 
 1020 const uint Matcher::vector_shift_count_ideal_reg(int size) {
 1021   return vector_ideal_reg(size);
 1022 }
 1023 
 1024 // Limits on vector size (number of elements) loaded into vector.
 1025 const int Matcher::max_vector_size(const BasicType bt) {
 1026   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1027   return vector_width_in_bytes(bt)/type2aelembytes(bt);
 1028 }
 1029 
 1030 const int Matcher::min_vector_size(const BasicType bt) {
 1031   assert(is_java_primitive(bt), &quot;only primitive type vectors&quot;);
 1032   return 8/type2aelembytes(bt);
 1033 }
 1034 
 1035 // ARM doesn&#39;t support misaligned vectors store/load.
 1036 const bool Matcher::misaligned_vectors_ok() {
 1037   return false;
 1038 }
 1039 
 1040 // ARM doesn&#39;t support AES intrinsics
 1041 const bool Matcher::pass_original_key_for_aes() {
 1042   return false;
 1043 }
 1044 
 1045 const bool Matcher::convL2FSupported(void) {
 1046   return false;
 1047 }
 1048 
 1049 // Is this branch offset short enough that a short branch can be used?
 1050 //
 1051 // NOTE: If the platform does not provide any short branch variants, then
 1052 //       this method should return false for offset 0.
 1053 bool Matcher::is_short_branch_offset(int rule, int br_size, int offset) {
 1054   // The passed offset is relative to address of the branch.
 1055   // On ARM a branch displacement is calculated relative to address
 1056   // of the branch + 8.
 1057   //
 1058   // offset -= 8;
 1059   // return (Assembler::is_simm24(offset));
 1060   return false;
 1061 }
 1062 
 1063 const bool Matcher::isSimpleConstant64(jlong value) {
 1064   // Will one (StoreL ConL) be cheaper than two (StoreI ConI)?.
 1065   return false;
 1066 }
 1067 
 1068 // No scaling for the parameter the ClearArray node.
 1069 const bool Matcher::init_array_count_is_in_bytes = true;
 1070 
 1071 // Needs 2 CMOV&#39;s for longs.
 1072 const int Matcher::long_cmove_cost() { return 2; }
 1073 
 1074 // CMOVF/CMOVD are expensive on ARM.
 1075 const int Matcher::float_cmove_cost() { return ConditionalMoveLimit; }
 1076 
 1077 // Does the CPU require late expand (see block.cpp for description of late expand)?
 1078 const bool Matcher::require_postalloc_expand = false;
 1079 
 1080 // Do we need to mask the count passed to shift instructions or does
 1081 // the cpu only look at the lower 5/6 bits anyway?
 1082 // FIXME: does this handle vector shifts as well?
 1083 const bool Matcher::need_masked_shift_count = true;
 1084 
 1085 const bool Matcher::convi2l_type_required = true;
 1086 
 1087 // No support for generic vector operands.
 1088 const bool Matcher::supports_generic_vector_operands  = false;
 1089 
 1090 MachOper* Matcher::specialize_generic_vector_operand(MachOper* original_opnd, uint ideal_reg, bool is_temp) {
 1091   ShouldNotReachHere(); // generic vector operands not supported
 1092   return NULL;
 1093 }
 1094 
 1095 bool Matcher::is_generic_reg2reg_move(MachNode* m) {
 1096   ShouldNotReachHere();  // generic vector operands not supported
 1097   return false;
 1098 }
 1099 
 1100 bool Matcher::is_generic_vector(MachOper* opnd)  {
 1101   ShouldNotReachHere();  // generic vector operands not supported
 1102   return false;
 1103 }
 1104 
<a name="28" id="anc28"></a><span class="line-added"> 1105 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added"> 1106 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added"> 1107   if (is_vshift_con_pattern(n, m)) { // ShiftV src (ShiftCntV con)</span>
<span class="line-added"> 1108     mstack.push(m, Visit);           // m = ShiftCntV</span>
<span class="line-added"> 1109     return true;</span>
<span class="line-added"> 1110   }</span>
<span class="line-added"> 1111   return false;</span>
<span class="line-added"> 1112 }</span>
<span class="line-added"> 1113 </span>
 1114 // Should the Matcher clone shifts on addressing modes, expecting them
 1115 // to be subsumed into complex addressing expressions or compute them
 1116 // into registers?
<a name="29" id="anc29"></a><span class="line-modified"> 1117 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1118   return clone_base_plus_offset_address(m, mstack, address_visited);
 1119 }
 1120 
 1121 void Compile::reshape_address(AddPNode* addp) {
 1122 }
 1123 
 1124 bool Matcher::narrow_oop_use_complex_address() {
 1125   NOT_LP64(ShouldNotCallThis());
 1126   assert(UseCompressedOops, &quot;only for compressed oops code&quot;);
 1127   return false;
 1128 }
 1129 
 1130 bool Matcher::narrow_klass_use_complex_address() {
 1131   NOT_LP64(ShouldNotCallThis());
 1132   assert(UseCompressedClassPointers, &quot;only for compressed klass code&quot;);
 1133   return false;
 1134 }
 1135 
 1136 bool Matcher::const_oop_prefer_decode() {
 1137   NOT_LP64(ShouldNotCallThis());
 1138   return true;
 1139 }
 1140 
 1141 bool Matcher::const_klass_prefer_decode() {
 1142   NOT_LP64(ShouldNotCallThis());
 1143   return true;
 1144 }
 1145 
 1146 // Is it better to copy float constants, or load them directly from memory?
 1147 // Intel can load a float constant from a direct address, requiring no
 1148 // extra registers.  Most RISCs will have to materialize an address into a
 1149 // register first, so they would do better to copy the constant from stack.
 1150 const bool Matcher::rematerialize_float_constants = false;
 1151 
 1152 // If CPU can load and store mis-aligned doubles directly then no fixup is
 1153 // needed.  Else we split the double into 2 integer pieces and move it
 1154 // piece-by-piece.  Only happens when passing doubles into C code as the
 1155 // Java calling convention forces doubles to be aligned.
 1156 const bool Matcher::misaligned_doubles_ok = false;
 1157 
 1158 // No-op on ARM.
 1159 void Matcher::pd_implicit_null_fixup(MachNode *node, uint idx) {
 1160 }
 1161 
 1162 // Advertise here if the CPU requires explicit rounding operations to implement strictfp mode.
 1163 const bool Matcher::strict_fp_requires_explicit_rounding = false;
 1164 
 1165 // Are floats converted to double when stored to stack during deoptimization?
 1166 // ARM does not handle callee-save floats.
 1167 bool Matcher::float_in_double() {
 1168   return false;
 1169 }
 1170 
 1171 // Do ints take an entire long register or just half?
 1172 // Note that we if-def off of _LP64.
 1173 // The relevant question is how the int is callee-saved.  In _LP64
 1174 // the whole long is written but de-opt&#39;ing will have to extract
 1175 // the relevant 32 bits, in not-_LP64 only the low 32 bits is written.
 1176 #ifdef _LP64
 1177 const bool Matcher::int_in_long = true;
 1178 #else
 1179 const bool Matcher::int_in_long = false;
 1180 #endif
 1181 
 1182 // Return whether or not this register is ever used as an argument.  This
 1183 // function is used on startup to build the trampoline stubs in generateOptoStub.
 1184 // Registers not mentioned will be killed by the VM call in the trampoline, and
 1185 // arguments in those registers not be available to the callee.
 1186 bool Matcher::can_be_java_arg( int reg ) {
 1187   if (reg == R_R0_num ||
 1188       reg == R_R1_num ||
 1189       reg == R_R2_num ||
 1190       reg == R_R3_num) return true;
 1191 
 1192   if (reg &gt;= R_S0_num &amp;&amp;
 1193       reg &lt;= R_S13_num) return true;
 1194   return false;
 1195 }
 1196 
 1197 bool Matcher::is_spillable_arg( int reg ) {
 1198   return can_be_java_arg(reg);
 1199 }
 1200 
 1201 bool Matcher::use_asm_for_ldiv_by_con( jlong divisor ) {
 1202   return false;
 1203 }
 1204 
 1205 // Register for DIVI projection of divmodI
 1206 RegMask Matcher::divI_proj_mask() {
 1207   ShouldNotReachHere();
 1208   return RegMask();
 1209 }
 1210 
 1211 // Register for MODI projection of divmodI
 1212 RegMask Matcher::modI_proj_mask() {
 1213   ShouldNotReachHere();
 1214   return RegMask();
 1215 }
 1216 
 1217 // Register for DIVL projection of divmodL
 1218 RegMask Matcher::divL_proj_mask() {
 1219   ShouldNotReachHere();
 1220   return RegMask();
 1221 }
 1222 
 1223 // Register for MODL projection of divmodL
 1224 RegMask Matcher::modL_proj_mask() {
 1225   ShouldNotReachHere();
 1226   return RegMask();
 1227 }
 1228 
 1229 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1230   return FP_REGP_mask();
 1231 }
 1232 
 1233 bool maybe_far_call(const CallNode *n) {
 1234   return !MacroAssembler::_reachable_from_cache(n-&gt;as_Call()-&gt;entry_point());
 1235 }
 1236 
 1237 bool maybe_far_call(const MachCallNode *n) {
 1238   return !MacroAssembler::_reachable_from_cache(n-&gt;as_MachCall()-&gt;entry_point());
 1239 }
 1240 
 1241 %}
 1242 
 1243 //----------ENCODING BLOCK-----------------------------------------------------
 1244 // This block specifies the encoding classes used by the compiler to output
 1245 // byte streams.  Encoding classes are parameterized macros used by
 1246 // Machine Instruction Nodes in order to generate the bit encoding of the
 1247 // instruction.  Operands specify their base encoding interface with the
 1248 // interface keyword.  There are currently supported four interfaces,
 1249 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER.  REG_INTER causes an
 1250 // operand to generate a function which returns its register number when
 1251 // queried.   CONST_INTER causes an operand to generate a function which
 1252 // returns the value of the constant when queried.  MEMORY_INTER causes an
 1253 // operand to generate four functions which return the Base Register, the
 1254 // Index Register, the Scale Value, and the Offset Value of the operand when
 1255 // queried.  COND_INTER causes an operand to generate six functions which
 1256 // return the encoding code (ie - encoding bits for the instruction)
 1257 // associated with each basic boolean condition for a conditional instruction.
 1258 //
 1259 // Instructions specify two basic values for encoding.  Again, a function
 1260 // is available to check if the constant displacement is an oop. They use the
 1261 // ins_encode keyword to specify their encoding classes (which must be
 1262 // a sequence of enc_class names, and their parameters, specified in
 1263 // the encoding block), and they use the
 1264 // opcode keyword to specify, in order, their primary, secondary, and
 1265 // tertiary opcode.  Only the opcode sections which a particular instruction
 1266 // needs for encoding need to be specified.
 1267 encode %{
 1268   enc_class call_epilog %{
 1269     // nothing
 1270   %}
 1271 
 1272   enc_class Java_To_Runtime (method meth) %{
 1273     // CALL directly to the runtime
 1274     emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());
 1275   %}
 1276 
 1277   enc_class Java_Static_Call (method meth) %{
 1278     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1279     // who we intended to call.
 1280 
 1281     if ( !_method) {
 1282       emit_call_reloc(cbuf, as_MachCall(), $meth, runtime_call_Relocation::spec());
 1283     } else {
 1284       int method_index = resolved_method_index(cbuf);
 1285       RelocationHolder rspec = _optimized_virtual ? opt_virtual_call_Relocation::spec(method_index)
 1286                                                   : static_call_Relocation::spec(method_index);
 1287       emit_call_reloc(cbuf, as_MachCall(), $meth, rspec);
 1288 
 1289       // Emit stubs for static call.
 1290       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 1291       if (stub == NULL) {
 1292         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 1293         return;
 1294       }
 1295     }
 1296   %}
 1297 
 1298   enc_class save_last_PC %{
 1299     // preserve mark
 1300     address mark = cbuf.insts()-&gt;mark();
 1301     debug_only(int off0 = cbuf.insts_size());
<a name="30" id="anc30"></a><span class="line-modified"> 1302     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1303     int ret_addr_offset = as_MachCall()-&gt;ret_addr_offset();
 1304     __ adr(LR, mark + ret_addr_offset);
 1305     __ str(LR, Address(Rthread, JavaThread::last_Java_pc_offset()));
 1306     debug_only(int off1 = cbuf.insts_size());
 1307     assert(off1 - off0 == 2 * Assembler::InstructionSize, &quot;correct size prediction&quot;);
 1308     // restore mark
 1309     cbuf.insts()-&gt;set_mark(mark);
 1310   %}
 1311 
 1312   enc_class preserve_SP %{
 1313     // preserve mark
 1314     address mark = cbuf.insts()-&gt;mark();
 1315     debug_only(int off0 = cbuf.insts_size());
<a name="31" id="anc31"></a><span class="line-modified"> 1316     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1317     // FP is preserved across all calls, even compiled calls.
 1318     // Use it to preserve SP in places where the callee might change the SP.
 1319     __ mov(Rmh_SP_save, SP);
 1320     debug_only(int off1 = cbuf.insts_size());
 1321     assert(off1 - off0 == 4, &quot;correct size prediction&quot;);
 1322     // restore mark
 1323     cbuf.insts()-&gt;set_mark(mark);
 1324   %}
 1325 
 1326   enc_class restore_SP %{
<a name="32" id="anc32"></a><span class="line-modified"> 1327     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1328     __ mov(SP, Rmh_SP_save);
 1329   %}
 1330 
 1331   enc_class Java_Dynamic_Call (method meth) %{
<a name="33" id="anc33"></a><span class="line-modified"> 1332     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1333     Register R8_ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 1334     assert(R8_ic_reg == Ricklass, &quot;should be&quot;);
 1335     __ set_inst_mark();
 1336     __ movw(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &amp; 0xffff);
 1337     __ movt(R8_ic_reg, ((unsigned int)Universe::non_oop_word()) &gt;&gt; 16);
 1338     address  virtual_call_oop_addr = __ inst_mark();
 1339     // CALL to fixup routine.  Fixup routine uses ScopeDesc info to determine
 1340     // who we intended to call.
 1341     int method_index = resolved_method_index(cbuf);
 1342     __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 1343     emit_call_reloc(cbuf, as_MachCall(), $meth, RelocationHolder::none);
 1344   %}
 1345 
 1346   enc_class LdReplImmI(immI src, regD dst, iRegI tmp, int cnt, int wth) %{
 1347     // FIXME: load from constant table?
 1348     // Load a constant replicated &quot;count&quot; times with width &quot;width&quot;
 1349     int count = $cnt$$constant;
 1350     int width = $wth$$constant;
 1351     assert(count*width == 4, &quot;sanity&quot;);
 1352     int val = $src$$constant;
 1353     if (width &lt; 4) {
 1354       int bit_width = width * 8;
 1355       val &amp;= (((int)1) &lt;&lt; bit_width) - 1; // mask off sign bits
 1356       for (int i = 0; i &lt; count - 1; i++) {
 1357         val |= (val &lt;&lt; bit_width);
 1358       }
 1359     }
<a name="34" id="anc34"></a><span class="line-modified"> 1360     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1361 
 1362     if (val == -1) {
 1363       __ mvn($tmp$$Register, 0);
 1364     } else if (val == 0) {
 1365       __ mov($tmp$$Register, 0);
 1366     } else {
 1367       __ movw($tmp$$Register, val &amp; 0xffff);
 1368       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1369     }
 1370     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1371   %}
 1372 
 1373   enc_class LdReplImmF(immF src, regD dst, iRegI tmp) %{
 1374     // Replicate float con 2 times and pack into vector (8 bytes) in regD.
 1375     float fval = $src$$constant;
 1376     int val = *((int*)&amp;fval);
<a name="35" id="anc35"></a><span class="line-modified"> 1377     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1378 
 1379     if (val == -1) {
 1380       __ mvn($tmp$$Register, 0);
 1381     } else if (val == 0) {
 1382       __ mov($tmp$$Register, 0);
 1383     } else {
 1384       __ movw($tmp$$Register, val &amp; 0xffff);
 1385       __ movt($tmp$$Register, (unsigned int)val &gt;&gt; 16);
 1386     }
 1387     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 1388   %}
 1389 
 1390   enc_class enc_String_Compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1391     Label Ldone, Lloop;
<a name="36" id="anc36"></a><span class="line-modified"> 1392     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1393 
 1394     Register   str1_reg = $str1$$Register;
 1395     Register   str2_reg = $str2$$Register;
 1396     Register   cnt1_reg = $cnt1$$Register; // int
 1397     Register   cnt2_reg = $cnt2$$Register; // int
 1398     Register   tmp1_reg = $tmp1$$Register;
 1399     Register   tmp2_reg = $tmp2$$Register;
 1400     Register result_reg = $result$$Register;
 1401 
 1402     assert_different_registers(str1_reg, str2_reg, cnt1_reg, cnt2_reg, tmp1_reg, tmp2_reg);
 1403 
 1404     // Compute the minimum of the string lengths(str1_reg) and the
 1405     // difference of the string lengths (stack)
 1406 
 1407     // See if the lengths are different, and calculate min in str1_reg.
 1408     // Stash diff in tmp2 in case we need it for a tie-breaker.
 1409     __ subs_32(tmp2_reg, cnt1_reg, cnt2_reg);
 1410     __ mov(cnt1_reg, AsmOperand(cnt1_reg, lsl, exact_log2(sizeof(jchar)))); // scale the limit
 1411     __ mov(cnt1_reg, AsmOperand(cnt2_reg, lsl, exact_log2(sizeof(jchar))), pl); // scale the limit
 1412 
 1413     // reallocate cnt1_reg, cnt2_reg, result_reg
 1414     // Note:  limit_reg holds the string length pre-scaled by 2
 1415     Register limit_reg = cnt1_reg;
 1416     Register  chr2_reg = cnt2_reg;
 1417     Register  chr1_reg = tmp1_reg;
 1418     // str{12} are the base pointers
 1419 
 1420     // Is the minimum length zero?
 1421     __ cmp_32(limit_reg, 0);
 1422     if (result_reg != tmp2_reg) {
 1423       __ mov(result_reg, tmp2_reg, eq);
 1424     }
 1425     __ b(Ldone, eq);
 1426 
 1427     // Load first characters
 1428     __ ldrh(chr1_reg, Address(str1_reg, 0));
 1429     __ ldrh(chr2_reg, Address(str2_reg, 0));
 1430 
 1431     // Compare first characters
 1432     __ subs(chr1_reg, chr1_reg, chr2_reg);
 1433     if (result_reg != chr1_reg) {
 1434       __ mov(result_reg, chr1_reg, ne);
 1435     }
 1436     __ b(Ldone, ne);
 1437 
 1438     {
 1439       // Check after comparing first character to see if strings are equivalent
 1440       // Check if the strings start at same location
 1441       __ cmp(str1_reg, str2_reg);
 1442       // Check if the length difference is zero
 1443       __ cond_cmp(tmp2_reg, 0, eq);
 1444       __ mov(result_reg, 0, eq); // result is zero
 1445       __ b(Ldone, eq);
 1446       // Strings might not be equal
 1447     }
 1448 
 1449     __ subs(chr1_reg, limit_reg, 1 * sizeof(jchar));
 1450     if (result_reg != tmp2_reg) {
 1451       __ mov(result_reg, tmp2_reg, eq);
 1452     }
 1453     __ b(Ldone, eq);
 1454 
 1455     // Shift str1_reg and str2_reg to the end of the arrays, negate limit
 1456     __ add(str1_reg, str1_reg, limit_reg);
 1457     __ add(str2_reg, str2_reg, limit_reg);
 1458     __ neg(limit_reg, chr1_reg);  // limit = -(limit-2)
 1459 
 1460     // Compare the rest of the characters
 1461     __ bind(Lloop);
 1462     __ ldrh(chr1_reg, Address(str1_reg, limit_reg));
 1463     __ ldrh(chr2_reg, Address(str2_reg, limit_reg));
 1464     __ subs(chr1_reg, chr1_reg, chr2_reg);
 1465     if (result_reg != chr1_reg) {
 1466       __ mov(result_reg, chr1_reg, ne);
 1467     }
 1468     __ b(Ldone, ne);
 1469 
 1470     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1471     __ b(Lloop, ne);
 1472 
 1473     // If strings are equal up to min length, return the length difference.
 1474     if (result_reg != tmp2_reg) {
 1475       __ mov(result_reg, tmp2_reg);
 1476     }
 1477 
 1478     // Otherwise, return the difference between the first mismatched chars.
 1479     __ bind(Ldone);
 1480   %}
 1481 
 1482   enc_class enc_String_Equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2) %{
 1483     Label Lchar, Lchar_loop, Ldone, Lequal;
<a name="37" id="anc37"></a><span class="line-modified"> 1484     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1485 
 1486     Register   str1_reg = $str1$$Register;
 1487     Register   str2_reg = $str2$$Register;
 1488     Register    cnt_reg = $cnt$$Register; // int
 1489     Register   tmp1_reg = $tmp1$$Register;
 1490     Register   tmp2_reg = $tmp2$$Register;
 1491     Register result_reg = $result$$Register;
 1492 
 1493     assert_different_registers(str1_reg, str2_reg, cnt_reg, tmp1_reg, tmp2_reg, result_reg);
 1494 
 1495     __ cmp(str1_reg, str2_reg); //same char[] ?
 1496     __ b(Lequal, eq);
 1497 
 1498     __ cbz_32(cnt_reg, Lequal); // count == 0
 1499 
 1500     //rename registers
 1501     Register limit_reg = cnt_reg;
 1502     Register  chr1_reg = tmp1_reg;
 1503     Register  chr2_reg = tmp2_reg;
 1504 
 1505     __ logical_shift_left(limit_reg, limit_reg, exact_log2(sizeof(jchar)));
 1506 
 1507     //check for alignment and position the pointers to the ends
 1508     __ orr(chr1_reg, str1_reg, str2_reg);
 1509     __ tst(chr1_reg, 0x3);
 1510 
 1511     // notZero means at least one not 4-byte aligned.
 1512     // We could optimize the case when both arrays are not aligned
 1513     // but it is not frequent case and it requires additional checks.
 1514     __ b(Lchar, ne);
 1515 
 1516     // Compare char[] arrays aligned to 4 bytes.
 1517     __ char_arrays_equals(str1_reg, str2_reg, limit_reg, result_reg,
 1518                           chr1_reg, chr2_reg, Ldone);
 1519 
 1520     __ b(Lequal); // equal
 1521 
 1522     // char by char compare
 1523     __ bind(Lchar);
 1524     __ mov(result_reg, 0);
 1525     __ add(str1_reg, limit_reg, str1_reg);
 1526     __ add(str2_reg, limit_reg, str2_reg);
 1527     __ neg(limit_reg, limit_reg); //negate count
 1528 
 1529     // Lchar_loop
 1530     __ bind(Lchar_loop);
 1531     __ ldrh(chr1_reg, Address(str1_reg, limit_reg));
 1532     __ ldrh(chr2_reg, Address(str2_reg, limit_reg));
 1533     __ cmp(chr1_reg, chr2_reg);
 1534     __ b(Ldone, ne);
 1535     __ adds(limit_reg, limit_reg, sizeof(jchar));
 1536     __ b(Lchar_loop, ne);
 1537 
 1538     __ bind(Lequal);
 1539     __ mov(result_reg, 1);  //equal
 1540 
 1541     __ bind(Ldone);
 1542   %}
 1543 
 1544   enc_class enc_Array_Equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result) %{
 1545     Label Ldone, Lloop, Lequal;
<a name="38" id="anc38"></a><span class="line-modified"> 1546     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1547 
 1548     Register   ary1_reg = $ary1$$Register;
 1549     Register   ary2_reg = $ary2$$Register;
 1550     Register   tmp1_reg = $tmp1$$Register;
 1551     Register   tmp2_reg = $tmp2$$Register;
 1552     Register   tmp3_reg = $tmp3$$Register;
 1553     Register result_reg = $result$$Register;
 1554 
 1555     assert_different_registers(ary1_reg, ary2_reg, tmp1_reg, tmp2_reg, tmp3_reg, result_reg);
 1556 
 1557     int length_offset  = arrayOopDesc::length_offset_in_bytes();
 1558     int base_offset    = arrayOopDesc::base_offset_in_bytes(T_CHAR);
 1559 
 1560     // return true if the same array
 1561     __ teq(ary1_reg, ary2_reg);
 1562     __ mov(result_reg, 1, eq);
 1563     __ b(Ldone, eq); // equal
 1564 
 1565     __ tst(ary1_reg, ary1_reg);
 1566     __ mov(result_reg, 0, eq);
 1567     __ b(Ldone, eq);    // not equal
 1568 
 1569     __ tst(ary2_reg, ary2_reg);
 1570     __ mov(result_reg, 0, eq);
 1571     __ b(Ldone, eq);    // not equal
 1572 
 1573     //load the lengths of arrays
 1574     __ ldr_s32(tmp1_reg, Address(ary1_reg, length_offset)); // int
 1575     __ ldr_s32(tmp2_reg, Address(ary2_reg, length_offset)); // int
 1576 
 1577     // return false if the two arrays are not equal length
 1578     __ teq_32(tmp1_reg, tmp2_reg);
 1579     __ mov(result_reg, 0, ne);
 1580     __ b(Ldone, ne);    // not equal
 1581 
 1582     __ tst(tmp1_reg, tmp1_reg);
 1583     __ mov(result_reg, 1, eq);
 1584     __ b(Ldone, eq);    // zero-length arrays are equal
 1585 
 1586     // load array addresses
 1587     __ add(ary1_reg, ary1_reg, base_offset);
 1588     __ add(ary2_reg, ary2_reg, base_offset);
 1589 
 1590     // renaming registers
 1591     Register chr1_reg  =  tmp3_reg;   // for characters in ary1
 1592     Register chr2_reg  =  tmp2_reg;   // for characters in ary2
 1593     Register limit_reg =  tmp1_reg;   // length
 1594 
 1595     // set byte count
 1596     __ logical_shift_left_32(limit_reg, limit_reg, exact_log2(sizeof(jchar)));
 1597 
 1598     // Compare char[] arrays aligned to 4 bytes.
 1599     __ char_arrays_equals(ary1_reg, ary2_reg, limit_reg, result_reg,
 1600                           chr1_reg, chr2_reg, Ldone);
 1601     __ bind(Lequal);
 1602     __ mov(result_reg, 1);  //equal
 1603 
 1604     __ bind(Ldone);
 1605     %}
 1606 %}
 1607 
 1608 //----------FRAME--------------------------------------------------------------
 1609 // Definition of frame structure and management information.
 1610 //
 1611 //  S T A C K   L A Y O U T    Allocators stack-slot number
 1612 //                             |   (to get allocators register number
 1613 //  G  Owned by    |        |  v    add VMRegImpl::stack0)
 1614 //  r   CALLER     |        |
 1615 //  o     |        +--------+      pad to even-align allocators stack-slot
 1616 //  w     V        |  pad0  |        numbers; owned by CALLER
 1617 //  t   -----------+--------+----&gt; Matcher::_in_arg_limit, unaligned
 1618 //  h     ^        |   in   |  5
 1619 //        |        |  args  |  4   Holes in incoming args owned by SELF
 1620 //  |     |        |        |  3
 1621 //  |     |        +--------+
 1622 //  V     |        | old out|      Empty on Intel, window on Sparc
 1623 //        |    old |preserve|      Must be even aligned.
 1624 //        |     SP-+--------+----&gt; Matcher::_old_SP, 8 (or 16 in LP64)-byte aligned
 1625 //        |        |   in   |  3   area for Intel ret address
 1626 //     Owned by    |preserve|      Empty on Sparc.
 1627 //       SELF      +--------+
 1628 //        |        |  pad2  |  2   pad to align old SP
 1629 //        |        +--------+  1
 1630 //        |        | locks  |  0
 1631 //        |        +--------+----&gt; VMRegImpl::stack0, 8 (or 16 in LP64)-byte aligned
 1632 //        |        |  pad1  | 11   pad to align new SP
 1633 //        |        +--------+
 1634 //        |        |        | 10
 1635 //        |        | spills |  9   spills
 1636 //        V        |        |  8   (pad0 slot for callee)
 1637 //      -----------+--------+----&gt; Matcher::_out_arg_limit, unaligned
 1638 //        ^        |  out   |  7
 1639 //        |        |  args  |  6   Holes in outgoing args owned by CALLEE
 1640 //     Owned by    +--------+
 1641 //      CALLEE     | new out|  6   Empty on Intel, window on Sparc
 1642 //        |    new |preserve|      Must be even-aligned.
 1643 //        |     SP-+--------+----&gt; Matcher::_new_SP, even aligned
 1644 //        |        |        |
 1645 //
 1646 // Note 1: Only region 8-11 is determined by the allocator.  Region 0-5 is
 1647 //         known from SELF&#39;s arguments and the Java calling convention.
 1648 //         Region 6-7 is determined per call site.
 1649 // Note 2: If the calling convention leaves holes in the incoming argument
 1650 //         area, those holes are owned by SELF.  Holes in the outgoing area
 1651 //         are owned by the CALLEE.  Holes should not be nessecary in the
 1652 //         incoming area, as the Java calling convention is completely under
 1653 //         the control of the AD file.  Doubles can be sorted and packed to
 1654 //         avoid holes.  Holes in the outgoing arguments may be nessecary for
 1655 //         varargs C calling conventions.
 1656 // Note 3: Region 0-3 is even aligned, with pad2 as needed.  Region 3-5 is
 1657 //         even aligned with pad0 as needed.
 1658 //         Region 6 is even aligned.  Region 6-7 is NOT even aligned;
 1659 //         region 6-11 is even aligned; it may be padded out more so that
 1660 //         the region from SP to FP meets the minimum stack alignment.
 1661 
 1662 frame %{
 1663   // What direction does stack grow in (assumed to be same for native &amp; Java)
 1664   stack_direction(TOWARDS_LOW);
 1665 
 1666   // These two registers define part of the calling convention
 1667   // between compiled code and the interpreter.
 1668   inline_cache_reg(R_Ricklass);          // Inline Cache Register or Method* for I2C
 1669   interpreter_method_oop_reg(R_Rmethod); // Method Oop Register when calling interpreter
 1670 
 1671   // Optional: name the operand used by cisc-spilling to access [stack_pointer + offset]
 1672   cisc_spilling_operand_name(indOffset);
 1673 
 1674   // Number of stack slots consumed by a Monitor enter
 1675   sync_stack_slots(1 * VMRegImpl::slots_per_word);
 1676 
 1677   // Compiled code&#39;s Frame Pointer
 1678   frame_pointer(R_R13);
 1679 
 1680   // Stack alignment requirement
 1681   stack_alignment(StackAlignmentInBytes);
 1682   //  LP64: Alignment size in bytes (128-bit -&gt; 16 bytes)
 1683   // !LP64: Alignment size in bytes (64-bit  -&gt;  8 bytes)
 1684 
 1685   // Number of stack slots between incoming argument block and the start of
 1686   // a new frame.  The PROLOG must add this many slots to the stack.  The
 1687   // EPILOG must remove this many slots.
 1688   // FP + LR
 1689   in_preserve_stack_slots(2 * VMRegImpl::slots_per_word);
 1690 
 1691   // Number of outgoing stack slots killed above the out_preserve_stack_slots
 1692   // for calls to C.  Supports the var-args backing area for register parms.
 1693   // ADLC doesn&#39;t support parsing expressions, so I folded the math by hand.
 1694   varargs_C_out_slots_killed( 0);
 1695 
 1696   // The after-PROLOG location of the return address.  Location of
 1697   // return address specifies a type (REG or STACK) and a number
 1698   // representing the register number (i.e. - use a register name) or
 1699   // stack slot.
 1700   // Ret Addr is on stack in slot 0 if no locks or verification or alignment.
 1701   // Otherwise, it is above the locks and verification slot and alignment word
 1702   return_addr(STACK - 1*VMRegImpl::slots_per_word +
 1703               align_up((Compile::current()-&gt;in_preserve_stack_slots() +
 1704                         Compile::current()-&gt;fixed_slots()),
 1705                        stack_alignment_in_slots()));
 1706 
 1707   // Body of function which returns an OptoRegs array locating
 1708   // arguments either in registers or in stack slots for calling
 1709   // java
 1710   calling_convention %{
 1711     (void) SharedRuntime::java_calling_convention(sig_bt, regs, length, is_outgoing);
 1712 
 1713   %}
 1714 
 1715   // Body of function which returns an OptoRegs array locating
 1716   // arguments either in registers or in stack slots for callin
 1717   // C.
 1718   c_calling_convention %{
 1719     // This is obviously always outgoing
 1720     (void) SharedRuntime::c_calling_convention(sig_bt, regs, /*regs2=*/NULL, length);
 1721   %}
 1722 
 1723   // Location of compiled Java return values.  Same as C
 1724   return_value %{
 1725     return c2::return_value(ideal_reg);
 1726   %}
 1727 
 1728 %}
 1729 
 1730 //----------ATTRIBUTES---------------------------------------------------------
 1731 //----------Instruction Attributes---------------------------------------------
 1732 ins_attrib ins_cost(DEFAULT_COST); // Required cost attribute
 1733 ins_attrib ins_size(32);           // Required size attribute (in bits)
 1734 ins_attrib ins_short_branch(0);    // Required flag: is this instruction a
 1735                                    // non-matching short branch variant of some
 1736                                                             // long branch?
 1737 
 1738 //----------OPERANDS-----------------------------------------------------------
 1739 // Operand definitions must precede instruction definitions for correct parsing
 1740 // in the ADLC because operands constitute user defined types which are used in
 1741 // instruction definitions.
 1742 
 1743 //----------Simple Operands----------------------------------------------------
 1744 // Immediate Operands
 1745 // Integer Immediate: 32-bit
 1746 operand immI() %{
 1747   match(ConI);
 1748 
 1749   op_cost(0);
 1750   // formats are generated automatically for constants and base registers
 1751   format %{ %}
 1752   interface(CONST_INTER);
 1753 %}
 1754 
 1755 // Integer Immediate: 8-bit unsigned - for VMOV
 1756 operand immU8() %{
 1757   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 255));
 1758   match(ConI);
 1759   op_cost(0);
 1760 
 1761   format %{ %}
 1762   interface(CONST_INTER);
 1763 %}
 1764 
 1765 // Integer Immediate: 16-bit
 1766 operand immI16() %{
 1767   predicate((n-&gt;get_int() &gt;&gt; 16) == 0 &amp;&amp; VM_Version::supports_movw());
 1768   match(ConI);
 1769   op_cost(0);
 1770 
 1771   format %{ %}
 1772   interface(CONST_INTER);
 1773 %}
 1774 
 1775 // Integer Immediate: offset for half and double word loads and stores
 1776 operand immIHD() %{
 1777   predicate(is_memoryHD(n-&gt;get_int()));
 1778   match(ConI);
 1779   op_cost(0);
 1780   format %{ %}
 1781   interface(CONST_INTER);
 1782 %}
 1783 
 1784 // Integer Immediate: offset for fp loads and stores
 1785 operand immIFP() %{
 1786   predicate(is_memoryfp(n-&gt;get_int()) &amp;&amp; ((n-&gt;get_int() &amp; 3) == 0));
 1787   match(ConI);
 1788   op_cost(0);
 1789 
 1790   format %{ %}
 1791   interface(CONST_INTER);
 1792 %}
 1793 
 1794 // Valid scale values for addressing modes and shifts
 1795 operand immU5() %{
 1796   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; (n-&gt;get_int() &lt;= 31));
 1797   match(ConI);
 1798   op_cost(0);
 1799 
 1800   format %{ %}
 1801   interface(CONST_INTER);
 1802 %}
 1803 
 1804 // Integer Immediate: 6-bit
 1805 operand immU6Big() %{
 1806   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 1807   match(ConI);
 1808   op_cost(0);
 1809   format %{ %}
 1810   interface(CONST_INTER);
 1811 %}
 1812 
 1813 // Integer Immediate: 0-bit
 1814 operand immI0() %{
 1815   predicate(n-&gt;get_int() == 0);
 1816   match(ConI);
 1817   op_cost(0);
 1818 
 1819   format %{ %}
 1820   interface(CONST_INTER);
 1821 %}
 1822 
 1823 // Integer Immediate: the value 1
 1824 operand immI_1() %{
 1825   predicate(n-&gt;get_int() == 1);
 1826   match(ConI);
 1827   op_cost(0);
 1828 
 1829   format %{ %}
 1830   interface(CONST_INTER);
 1831 %}
 1832 
 1833 // Integer Immediate: the value 2
 1834 operand immI_2() %{
 1835   predicate(n-&gt;get_int() == 2);
 1836   match(ConI);
 1837   op_cost(0);
 1838 
 1839   format %{ %}
 1840   interface(CONST_INTER);
 1841 %}
 1842 
 1843 // Integer Immediate: the value 3
 1844 operand immI_3() %{
 1845   predicate(n-&gt;get_int() == 3);
 1846   match(ConI);
 1847   op_cost(0);
 1848 
 1849   format %{ %}
 1850   interface(CONST_INTER);
 1851 %}
 1852 
 1853 // Integer Immediate: the value 4
 1854 operand immI_4() %{
 1855   predicate(n-&gt;get_int() == 4);
 1856   match(ConI);
 1857   op_cost(0);
 1858 
 1859   format %{ %}
 1860   interface(CONST_INTER);
 1861 %}
 1862 
 1863 // Integer Immediate: the value 8
 1864 operand immI_8() %{
 1865   predicate(n-&gt;get_int() == 8);
 1866   match(ConI);
 1867   op_cost(0);
 1868 
 1869   format %{ %}
 1870   interface(CONST_INTER);
 1871 %}
 1872 
 1873 // Int Immediate non-negative
 1874 operand immU31()
 1875 %{
 1876   predicate(n-&gt;get_int() &gt;= 0);
 1877   match(ConI);
 1878 
 1879   op_cost(0);
 1880   format %{ %}
 1881   interface(CONST_INTER);
 1882 %}
 1883 
 1884 // Integer Immediate: the values 32-63
 1885 operand immI_32_63() %{
 1886   predicate(n-&gt;get_int() &gt;= 32 &amp;&amp; n-&gt;get_int() &lt;= 63);
 1887   match(ConI);
 1888   op_cost(0);
 1889 
 1890   format %{ %}
 1891   interface(CONST_INTER);
 1892 %}
 1893 
 1894 // Immediates for special shifts (sign extend)
 1895 
 1896 // Integer Immediate: the value 16
 1897 operand immI_16() %{
 1898   predicate(n-&gt;get_int() == 16);
 1899   match(ConI);
 1900   op_cost(0);
 1901 
 1902   format %{ %}
 1903   interface(CONST_INTER);
 1904 %}
 1905 
 1906 // Integer Immediate: the value 24
 1907 operand immI_24() %{
 1908   predicate(n-&gt;get_int() == 24);
 1909   match(ConI);
 1910   op_cost(0);
 1911 
 1912   format %{ %}
 1913   interface(CONST_INTER);
 1914 %}
 1915 
 1916 // Integer Immediate: the value 255
 1917 operand immI_255() %{
 1918   predicate( n-&gt;get_int() == 255 );
 1919   match(ConI);
 1920   op_cost(0);
 1921 
 1922   format %{ %}
 1923   interface(CONST_INTER);
 1924 %}
 1925 
 1926 // Integer Immediate: the value 65535
 1927 operand immI_65535() %{
 1928   predicate(n-&gt;get_int() == 65535);
 1929   match(ConI);
 1930   op_cost(0);
 1931 
 1932   format %{ %}
 1933   interface(CONST_INTER);
 1934 %}
 1935 
 1936 // Integer Immediates for arithmetic instructions
 1937 
 1938 operand aimmI() %{
 1939   predicate(is_aimm(n-&gt;get_int()));
 1940   match(ConI);
 1941   op_cost(0);
 1942 
 1943   format %{ %}
 1944   interface(CONST_INTER);
 1945 %}
 1946 
 1947 operand aimmIneg() %{
 1948   predicate(is_aimm(-n-&gt;get_int()));
 1949   match(ConI);
 1950   op_cost(0);
 1951 
 1952   format %{ %}
 1953   interface(CONST_INTER);
 1954 %}
 1955 
 1956 operand aimmU31() %{
 1957   predicate((0 &lt;= n-&gt;get_int()) &amp;&amp; is_aimm(n-&gt;get_int()));
 1958   match(ConI);
 1959   op_cost(0);
 1960 
 1961   format %{ %}
 1962   interface(CONST_INTER);
 1963 %}
 1964 
 1965 // Integer Immediates for logical instructions
 1966 
 1967 operand limmI() %{
 1968   predicate(is_limmI(n-&gt;get_int()));
 1969   match(ConI);
 1970   op_cost(0);
 1971 
 1972   format %{ %}
 1973   interface(CONST_INTER);
 1974 %}
 1975 
 1976 operand limmIlow8() %{
 1977   predicate(is_limmI_low(n-&gt;get_int(), 8));
 1978   match(ConI);
 1979   op_cost(0);
 1980 
 1981   format %{ %}
 1982   interface(CONST_INTER);
 1983 %}
 1984 
 1985 operand limmU31() %{
 1986   predicate(0 &lt;= n-&gt;get_int() &amp;&amp; is_limmI(n-&gt;get_int()));
 1987   match(ConI);
 1988   op_cost(0);
 1989 
 1990   format %{ %}
 1991   interface(CONST_INTER);
 1992 %}
 1993 
 1994 operand limmIn() %{
 1995   predicate(is_limmI(~n-&gt;get_int()));
 1996   match(ConI);
 1997   op_cost(0);
 1998 
 1999   format %{ %}
 2000   interface(CONST_INTER);
 2001 %}
 2002 
 2003 
 2004 // Long Immediate: the value FF
 2005 operand immL_FF() %{
 2006   predicate( n-&gt;get_long() == 0xFFL );
 2007   match(ConL);
 2008   op_cost(0);
 2009 
 2010   format %{ %}
 2011   interface(CONST_INTER);
 2012 %}
 2013 
 2014 // Long Immediate: the value FFFF
 2015 operand immL_FFFF() %{
 2016   predicate( n-&gt;get_long() == 0xFFFFL );
 2017   match(ConL);
 2018   op_cost(0);
 2019 
 2020   format %{ %}
 2021   interface(CONST_INTER);
 2022 %}
 2023 
 2024 // Pointer Immediate: 32 or 64-bit
 2025 operand immP() %{
 2026   match(ConP);
 2027 
 2028   op_cost(5);
 2029   // formats are generated automatically for constants and base registers
 2030   format %{ %}
 2031   interface(CONST_INTER);
 2032 %}
 2033 
 2034 operand immP0() %{
 2035   predicate(n-&gt;get_ptr() == 0);
 2036   match(ConP);
 2037   op_cost(0);
 2038 
 2039   format %{ %}
 2040   interface(CONST_INTER);
 2041 %}
 2042 
<a name="39" id="anc39"></a>








 2043 // Pointer Immediate
 2044 operand immN()
 2045 %{
 2046   match(ConN);
 2047 
 2048   op_cost(10);
 2049   format %{ %}
 2050   interface(CONST_INTER);
 2051 %}
 2052 
 2053 operand immNKlass()
 2054 %{
 2055   match(ConNKlass);
 2056 
 2057   op_cost(10);
 2058   format %{ %}
 2059   interface(CONST_INTER);
 2060 %}
 2061 
 2062 // NULL Pointer Immediate
 2063 operand immN0()
 2064 %{
 2065   predicate(n-&gt;get_narrowcon() == 0);
 2066   match(ConN);
 2067 
 2068   op_cost(0);
 2069   format %{ %}
 2070   interface(CONST_INTER);
 2071 %}
 2072 
 2073 operand immL() %{
 2074   match(ConL);
 2075   op_cost(40);
 2076   // formats are generated automatically for constants and base registers
 2077   format %{ %}
 2078   interface(CONST_INTER);
 2079 %}
 2080 
 2081 operand immL0() %{
 2082   predicate(n-&gt;get_long() == 0L);
 2083   match(ConL);
 2084   op_cost(0);
 2085   // formats are generated automatically for constants and base registers
 2086   format %{ %}
 2087   interface(CONST_INTER);
 2088 %}
 2089 
 2090 // Long Immediate: 16-bit
 2091 operand immL16() %{
 2092   predicate(n-&gt;get_long() &gt;= 0 &amp;&amp; n-&gt;get_long() &lt; (1&lt;&lt;16)  &amp;&amp; VM_Version::supports_movw());
 2093   match(ConL);
 2094   op_cost(0);
 2095 
 2096   format %{ %}
 2097   interface(CONST_INTER);
 2098 %}
 2099 
 2100 // Long Immediate: low 32-bit mask
 2101 operand immL_32bits() %{
 2102   predicate(n-&gt;get_long() == 0xFFFFFFFFL);
 2103   match(ConL);
 2104   op_cost(0);
 2105 
 2106   format %{ %}
 2107   interface(CONST_INTER);
 2108 %}
 2109 
 2110 // Double Immediate
 2111 operand immD() %{
 2112   match(ConD);
 2113 
 2114   op_cost(40);
 2115   format %{ %}
 2116   interface(CONST_INTER);
 2117 %}
 2118 
 2119 // Double Immediate: +0.0d.
 2120 operand immD0() %{
 2121   predicate(jlong_cast(n-&gt;getd()) == 0);
 2122 
 2123   match(ConD);
 2124   op_cost(0);
 2125   format %{ %}
 2126   interface(CONST_INTER);
 2127 %}
 2128 
 2129 operand imm8D() %{
 2130   predicate(Assembler::double_num(n-&gt;getd()).can_be_imm8());
 2131   match(ConD);
 2132 
 2133   op_cost(0);
 2134   format %{ %}
 2135   interface(CONST_INTER);
 2136 %}
 2137 
 2138 // Float Immediate
 2139 operand immF() %{
 2140   match(ConF);
 2141 
 2142   op_cost(20);
 2143   format %{ %}
 2144   interface(CONST_INTER);
 2145 %}
 2146 
 2147 // Float Immediate: +0.0f
 2148 operand immF0() %{
 2149   predicate(jint_cast(n-&gt;getf()) == 0);
 2150   match(ConF);
 2151 
 2152   op_cost(0);
 2153   format %{ %}
 2154   interface(CONST_INTER);
 2155 %}
 2156 
 2157 // Float Immediate: encoded as 8 bits
 2158 operand imm8F() %{
 2159   predicate(Assembler::float_num(n-&gt;getf()).can_be_imm8());
 2160   match(ConF);
 2161 
 2162   op_cost(0);
 2163   format %{ %}
 2164   interface(CONST_INTER);
 2165 %}
 2166 
 2167 // Integer Register Operands
 2168 // Integer Register
 2169 operand iRegI() %{
 2170   constraint(ALLOC_IN_RC(int_reg));
 2171   match(RegI);
 2172   match(R0RegI);
 2173   match(R1RegI);
 2174   match(R2RegI);
 2175   match(R3RegI);
 2176   match(R12RegI);
 2177 
 2178   format %{ %}
 2179   interface(REG_INTER);
 2180 %}
 2181 
 2182 // Pointer Register
 2183 operand iRegP() %{
 2184   constraint(ALLOC_IN_RC(ptr_reg));
 2185   match(RegP);
 2186   match(R0RegP);
 2187   match(R1RegP);
 2188   match(R2RegP);
 2189   match(RExceptionRegP);
 2190   match(R8RegP);
 2191   match(R9RegP);
 2192   match(RthreadRegP); // FIXME: move to sp_ptr_RegP?
 2193   match(R12RegP);
 2194   match(LRRegP);
 2195 
 2196   match(sp_ptr_RegP);
 2197   match(store_ptr_RegP);
 2198 
 2199   format %{ %}
 2200   interface(REG_INTER);
 2201 %}
 2202 
 2203 // GPRs + Rthread + SP
 2204 operand sp_ptr_RegP() %{
 2205   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2206   match(RegP);
 2207   match(iRegP);
 2208   match(SPRegP); // FIXME: check cost
 2209 
 2210   format %{ %}
 2211   interface(REG_INTER);
 2212 %}
 2213 
 2214 
 2215 operand R0RegP() %{
 2216   constraint(ALLOC_IN_RC(R0_regP));
 2217   match(iRegP);
 2218 
 2219   format %{ %}
 2220   interface(REG_INTER);
 2221 %}
 2222 
 2223 operand R1RegP() %{
 2224   constraint(ALLOC_IN_RC(R1_regP));
 2225   match(iRegP);
 2226 
 2227   format %{ %}
 2228   interface(REG_INTER);
 2229 %}
 2230 
 2231 operand R8RegP() %{
 2232   constraint(ALLOC_IN_RC(R8_regP));
 2233   match(iRegP);
 2234 
 2235   format %{ %}
 2236   interface(REG_INTER);
 2237 %}
 2238 
 2239 operand R9RegP() %{
 2240   constraint(ALLOC_IN_RC(R9_regP));
 2241   match(iRegP);
 2242 
 2243   format %{ %}
 2244   interface(REG_INTER);
 2245 %}
 2246 
 2247 operand R12RegP() %{
 2248   constraint(ALLOC_IN_RC(R12_regP));
 2249   match(iRegP);
 2250 
 2251   format %{ %}
 2252   interface(REG_INTER);
 2253 %}
 2254 
 2255 operand R2RegP() %{
 2256   constraint(ALLOC_IN_RC(R2_regP));
 2257   match(iRegP);
 2258 
 2259   format %{ %}
 2260   interface(REG_INTER);
 2261 %}
 2262 
 2263 operand RExceptionRegP() %{
 2264   constraint(ALLOC_IN_RC(Rexception_regP));
 2265   match(iRegP);
 2266 
 2267   format %{ %}
 2268   interface(REG_INTER);
 2269 %}
 2270 
 2271 operand RthreadRegP() %{
 2272   constraint(ALLOC_IN_RC(Rthread_regP));
 2273   match(iRegP);
 2274 
 2275   format %{ %}
 2276   interface(REG_INTER);
 2277 %}
 2278 
 2279 operand IPRegP() %{
 2280   constraint(ALLOC_IN_RC(IP_regP));
 2281   match(iRegP);
 2282 
 2283   format %{ %}
 2284   interface(REG_INTER);
 2285 %}
 2286 
 2287 operand SPRegP() %{
 2288   constraint(ALLOC_IN_RC(SP_regP));
 2289   match(iRegP);
 2290 
 2291   format %{ %}
 2292   interface(REG_INTER);
 2293 %}
 2294 
 2295 operand LRRegP() %{
 2296   constraint(ALLOC_IN_RC(LR_regP));
 2297   match(iRegP);
 2298 
 2299   format %{ %}
 2300   interface(REG_INTER);
 2301 %}
 2302 
 2303 operand R0RegI() %{
 2304   constraint(ALLOC_IN_RC(R0_regI));
 2305   match(iRegI);
 2306 
 2307   format %{ %}
 2308   interface(REG_INTER);
 2309 %}
 2310 
 2311 operand R1RegI() %{
 2312   constraint(ALLOC_IN_RC(R1_regI));
 2313   match(iRegI);
 2314 
 2315   format %{ %}
 2316   interface(REG_INTER);
 2317 %}
 2318 
 2319 operand R2RegI() %{
 2320   constraint(ALLOC_IN_RC(R2_regI));
 2321   match(iRegI);
 2322 
 2323   format %{ %}
 2324   interface(REG_INTER);
 2325 %}
 2326 
 2327 operand R3RegI() %{
 2328   constraint(ALLOC_IN_RC(R3_regI));
 2329   match(iRegI);
 2330 
 2331   format %{ %}
 2332   interface(REG_INTER);
 2333 %}
 2334 
 2335 operand R12RegI() %{
 2336   constraint(ALLOC_IN_RC(R12_regI));
 2337   match(iRegI);
 2338 
 2339   format %{ %}
 2340   interface(REG_INTER);
 2341 %}
 2342 
 2343 // Long Register
 2344 operand iRegL() %{
 2345   constraint(ALLOC_IN_RC(long_reg));
 2346   match(RegL);
 2347   match(R0R1RegL);
 2348   match(R2R3RegL);
 2349 //match(iRegLex);
 2350 
 2351   format %{ %}
 2352   interface(REG_INTER);
 2353 %}
 2354 
 2355 operand iRegLd() %{
 2356   constraint(ALLOC_IN_RC(long_reg_align));
 2357   match(iRegL); // FIXME: allows unaligned R11/R12?
 2358 
 2359   format %{ %}
 2360   interface(REG_INTER);
 2361 %}
 2362 
 2363 // first long arg, or return value
 2364 operand R0R1RegL() %{
 2365   constraint(ALLOC_IN_RC(R0R1_regL));
 2366   match(iRegL);
 2367 
 2368   format %{ %}
 2369   interface(REG_INTER);
 2370 %}
 2371 
 2372 operand R2R3RegL() %{
 2373   constraint(ALLOC_IN_RC(R2R3_regL));
 2374   match(iRegL);
 2375 
 2376   format %{ %}
 2377   interface(REG_INTER);
 2378 %}
 2379 
 2380 // Condition Code Flag Register
 2381 operand flagsReg() %{
 2382   constraint(ALLOC_IN_RC(int_flags));
 2383   match(RegFlags);
 2384 
 2385   format %{ &quot;apsr&quot; %}
 2386   interface(REG_INTER);
 2387 %}
 2388 
 2389 // Result of compare to 0 (TST)
 2390 operand flagsReg_EQNELTGE() %{
 2391   constraint(ALLOC_IN_RC(int_flags));
 2392   match(RegFlags);
 2393 
 2394   format %{ &quot;apsr_EQNELTGE&quot; %}
 2395   interface(REG_INTER);
 2396 %}
 2397 
 2398 // Condition Code Register, unsigned comparisons.
 2399 operand flagsRegU() %{
 2400   constraint(ALLOC_IN_RC(int_flags));
 2401   match(RegFlags);
 2402 #ifdef TODO
 2403   match(RegFlagsP);
 2404 #endif
 2405 
 2406   format %{ &quot;apsr_U&quot; %}
 2407   interface(REG_INTER);
 2408 %}
 2409 
 2410 // Condition Code Register, pointer comparisons.
 2411 operand flagsRegP() %{
 2412   constraint(ALLOC_IN_RC(int_flags));
 2413   match(RegFlags);
 2414 
 2415   format %{ &quot;apsr_P&quot; %}
 2416   interface(REG_INTER);
 2417 %}
 2418 
 2419 // Condition Code Register, long comparisons.
 2420 operand flagsRegL_LTGE() %{
 2421   constraint(ALLOC_IN_RC(int_flags));
 2422   match(RegFlags);
 2423 
 2424   format %{ &quot;apsr_L_LTGE&quot; %}
 2425   interface(REG_INTER);
 2426 %}
 2427 
 2428 operand flagsRegL_EQNE() %{
 2429   constraint(ALLOC_IN_RC(int_flags));
 2430   match(RegFlags);
 2431 
 2432   format %{ &quot;apsr_L_EQNE&quot; %}
 2433   interface(REG_INTER);
 2434 %}
 2435 
 2436 operand flagsRegL_LEGT() %{
 2437   constraint(ALLOC_IN_RC(int_flags));
 2438   match(RegFlags);
 2439 
 2440   format %{ &quot;apsr_L_LEGT&quot; %}
 2441   interface(REG_INTER);
 2442 %}
 2443 
 2444 operand flagsRegUL_LTGE() %{
 2445   constraint(ALLOC_IN_RC(int_flags));
 2446   match(RegFlags);
 2447 
 2448   format %{ &quot;apsr_UL_LTGE&quot; %}
 2449   interface(REG_INTER);
 2450 %}
 2451 
 2452 operand flagsRegUL_EQNE() %{
 2453   constraint(ALLOC_IN_RC(int_flags));
 2454   match(RegFlags);
 2455 
 2456   format %{ &quot;apsr_UL_EQNE&quot; %}
 2457   interface(REG_INTER);
 2458 %}
 2459 
 2460 operand flagsRegUL_LEGT() %{
 2461   constraint(ALLOC_IN_RC(int_flags));
 2462   match(RegFlags);
 2463 
 2464   format %{ &quot;apsr_UL_LEGT&quot; %}
 2465   interface(REG_INTER);
 2466 %}
 2467 
 2468 // Condition Code Register, floating comparisons, unordered same as &quot;less&quot;.
 2469 operand flagsRegF() %{
 2470   constraint(ALLOC_IN_RC(float_flags));
 2471   match(RegFlags);
 2472 
 2473   format %{ &quot;fpscr_F&quot; %}
 2474   interface(REG_INTER);
 2475 %}
 2476 
 2477 // Vectors
 2478 operand vecD() %{
 2479   constraint(ALLOC_IN_RC(actual_dflt_reg));
 2480   match(VecD);
 2481 
 2482   format %{ %}
 2483   interface(REG_INTER);
 2484 %}
 2485 
 2486 operand vecX() %{
 2487   constraint(ALLOC_IN_RC(vectorx_reg));
 2488   match(VecX);
 2489 
 2490   format %{ %}
 2491   interface(REG_INTER);
 2492 %}
 2493 
 2494 operand regD() %{
 2495   constraint(ALLOC_IN_RC(actual_dflt_reg));
 2496   match(RegD);
 2497   match(regD_low);
 2498 
 2499   format %{ %}
 2500   interface(REG_INTER);
 2501 %}
 2502 
 2503 operand regF() %{
 2504   constraint(ALLOC_IN_RC(sflt_reg));
 2505   match(RegF);
 2506 
 2507   format %{ %}
 2508   interface(REG_INTER);
 2509 %}
 2510 
 2511 operand regD_low() %{
 2512   constraint(ALLOC_IN_RC(dflt_low_reg));
 2513   match(RegD);
 2514 
 2515   format %{ %}
 2516   interface(REG_INTER);
 2517 %}
 2518 
 2519 // Special Registers
 2520 
 2521 // Method Register
 2522 operand inline_cache_regP(iRegP reg) %{
 2523   constraint(ALLOC_IN_RC(Ricklass_regP));
 2524   match(reg);
 2525   format %{ %}
 2526   interface(REG_INTER);
 2527 %}
 2528 
 2529 operand interpreter_method_oop_regP(iRegP reg) %{
 2530   constraint(ALLOC_IN_RC(Rmethod_regP));
 2531   match(reg);
 2532   format %{ %}
 2533   interface(REG_INTER);
 2534 %}
 2535 
 2536 
 2537 //----------Complex Operands---------------------------------------------------
 2538 // Indirect Memory Reference
 2539 operand indirect(sp_ptr_RegP reg) %{
 2540   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2541   match(reg);
 2542 
 2543   op_cost(100);
 2544   format %{ &quot;[$reg]&quot; %}
 2545   interface(MEMORY_INTER) %{
 2546     base($reg);
 2547     index(0xf); // PC =&gt; no index
 2548     scale(0x0);
 2549     disp(0x0);
 2550   %}
 2551 %}
 2552 
 2553 
 2554 // Indirect with Offset in ]-4096, 4096[
 2555 operand indOffset12(sp_ptr_RegP reg, immI12 offset) %{
 2556   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2557   match(AddP reg offset);
 2558 
 2559   op_cost(100);
 2560   format %{ &quot;[$reg + $offset]&quot; %}
 2561   interface(MEMORY_INTER) %{
 2562     base($reg);
 2563     index(0xf); // PC =&gt; no index
 2564     scale(0x0);
 2565     disp($offset);
 2566   %}
 2567 %}
 2568 
 2569 // Indirect with offset for float load/store
 2570 operand indOffsetFP(sp_ptr_RegP reg, immIFP offset) %{
 2571   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2572   match(AddP reg offset);
 2573 
 2574   op_cost(100);
 2575   format %{ &quot;[$reg + $offset]&quot; %}
 2576   interface(MEMORY_INTER) %{
 2577     base($reg);
 2578     index(0xf); // PC =&gt; no index
 2579     scale(0x0);
 2580     disp($offset);
 2581   %}
 2582 %}
 2583 
 2584 // Indirect with Offset for half and double words
 2585 operand indOffsetHD(sp_ptr_RegP reg, immIHD offset) %{
 2586   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2587   match(AddP reg offset);
 2588 
 2589   op_cost(100);
 2590   format %{ &quot;[$reg + $offset]&quot; %}
 2591   interface(MEMORY_INTER) %{
 2592     base($reg);
 2593     index(0xf); // PC =&gt; no index
 2594     scale(0x0);
 2595     disp($offset);
 2596   %}
 2597 %}
 2598 
 2599 // Indirect with Offset and Offset+4 in ]-1024, 1024[
 2600 operand indOffsetFPx2(sp_ptr_RegP reg, immX10x2 offset) %{
 2601   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2602   match(AddP reg offset);
 2603 
 2604   op_cost(100);
 2605   format %{ &quot;[$reg + $offset]&quot; %}
 2606   interface(MEMORY_INTER) %{
 2607     base($reg);
 2608     index(0xf); // PC =&gt; no index
 2609     scale(0x0);
 2610     disp($offset);
 2611   %}
 2612 %}
 2613 
 2614 // Indirect with Offset and Offset+4 in ]-4096, 4096[
 2615 operand indOffset12x2(sp_ptr_RegP reg, immI12x2 offset) %{
 2616   constraint(ALLOC_IN_RC(sp_ptr_reg));
 2617   match(AddP reg offset);
 2618 
 2619   op_cost(100);
 2620   format %{ &quot;[$reg + $offset]&quot; %}
 2621   interface(MEMORY_INTER) %{
 2622     base($reg);
 2623     index(0xf); // PC =&gt; no index
 2624     scale(0x0);
 2625     disp($offset);
 2626   %}
 2627 %}
 2628 
 2629 // Indirect with Register Index
 2630 operand indIndex(iRegP addr, iRegX index) %{
 2631   constraint(ALLOC_IN_RC(ptr_reg));
 2632   match(AddP addr index);
 2633 
 2634   op_cost(100);
 2635   format %{ &quot;[$addr + $index]&quot; %}
 2636   interface(MEMORY_INTER) %{
 2637     base($addr);
 2638     index($index);
 2639     scale(0x0);
 2640     disp(0x0);
 2641   %}
 2642 %}
 2643 
 2644 // Indirect Memory Times Scale Plus Index Register
 2645 operand indIndexScale(iRegP addr, iRegX index, immU5 scale) %{
 2646   constraint(ALLOC_IN_RC(ptr_reg));
 2647   match(AddP addr (LShiftX index scale));
 2648 
 2649   op_cost(100);
 2650   format %{&quot;[$addr + $index &lt;&lt; $scale]&quot; %}
 2651   interface(MEMORY_INTER) %{
 2652     base($addr);
 2653     index($index);
 2654     scale($scale);
 2655     disp(0x0);
 2656   %}
 2657 %}
 2658 
 2659 // Operands for expressing Control Flow
 2660 // NOTE:  Label is a predefined operand which should not be redefined in
 2661 //        the AD file.  It is generically handled within the ADLC.
 2662 
 2663 //----------Conditional Branch Operands----------------------------------------
 2664 // Comparison Op  - This is the operation of the comparison, and is limited to
 2665 //                  the following set of codes:
 2666 //                  L (&lt;), LE (&lt;=), G (&gt;), GE (&gt;=), E (==), NE (!=)
 2667 //
 2668 // Other attributes of the comparison, such as unsignedness, are specified
 2669 // by the comparison instruction that sets a condition code flags register.
 2670 // That result is represented by a flags operand whose subtype is appropriate
 2671 // to the unsignedness (etc.) of the comparison.
 2672 //
 2673 // Later, the instruction which matches both the Comparison Op (a Bool) and
 2674 // the flags (produced by the Cmp) specifies the coding of the comparison op
 2675 // by matching a specific subtype of Bool operand below, such as cmpOpU.
 2676 
 2677 operand cmpOp() %{
 2678   match(Bool);
 2679 
 2680   format %{ &quot;&quot; %}
 2681   interface(COND_INTER) %{
 2682     equal(0x0);
 2683     not_equal(0x1);
 2684     less(0xb);
 2685     greater_equal(0xa);
 2686     less_equal(0xd);
 2687     greater(0xc);
 2688     overflow(0x0); // unsupported/unimplemented
 2689     no_overflow(0x0); // unsupported/unimplemented
 2690   %}
 2691 %}
 2692 
 2693 // integer comparison with 0, signed
 2694 operand cmpOp0() %{
 2695   match(Bool);
 2696 
 2697   format %{ &quot;&quot; %}
 2698   interface(COND_INTER) %{
 2699     equal(0x0);
 2700     not_equal(0x1);
 2701     less(0x4);
 2702     greater_equal(0x5);
 2703     less_equal(0xd); // unsupported
 2704     greater(0xc); // unsupported
 2705     overflow(0x0); // unsupported/unimplemented
 2706     no_overflow(0x0); // unsupported/unimplemented
 2707   %}
 2708 %}
 2709 
 2710 // Comparison Op, unsigned
 2711 operand cmpOpU() %{
 2712   match(Bool);
 2713 
 2714   format %{ &quot;u&quot; %}
 2715   interface(COND_INTER) %{
 2716     equal(0x0);
 2717     not_equal(0x1);
 2718     less(0x3);
 2719     greater_equal(0x2);
 2720     less_equal(0x9);
 2721     greater(0x8);
 2722     overflow(0x0); // unsupported/unimplemented
 2723     no_overflow(0x0); // unsupported/unimplemented
 2724   %}
 2725 %}
 2726 
 2727 // Comparison Op, pointer (same as unsigned)
 2728 operand cmpOpP() %{
 2729   match(Bool);
 2730 
 2731   format %{ &quot;p&quot; %}
 2732   interface(COND_INTER) %{
 2733     equal(0x0);
 2734     not_equal(0x1);
 2735     less(0x3);
 2736     greater_equal(0x2);
 2737     less_equal(0x9);
 2738     greater(0x8);
 2739     overflow(0x0); // unsupported/unimplemented
 2740     no_overflow(0x0); // unsupported/unimplemented
 2741   %}
 2742 %}
 2743 
 2744 operand cmpOpL() %{
 2745   match(Bool);
 2746 
 2747   format %{ &quot;L&quot; %}
 2748   interface(COND_INTER) %{
 2749     equal(0x0);
 2750     not_equal(0x1);
 2751     less(0xb);
 2752     greater_equal(0xa);
 2753     less_equal(0xd);
 2754     greater(0xc);
 2755     overflow(0x0); // unsupported/unimplemented
 2756     no_overflow(0x0); // unsupported/unimplemented
 2757   %}
 2758 %}
 2759 
 2760 operand cmpOpL_commute() %{
 2761   match(Bool);
 2762 
 2763   format %{ &quot;L&quot; %}
 2764   interface(COND_INTER) %{
 2765     equal(0x0);
 2766     not_equal(0x1);
 2767     less(0xc);
 2768     greater_equal(0xd);
 2769     less_equal(0xa);
 2770     greater(0xb);
 2771     overflow(0x0); // unsupported/unimplemented
 2772     no_overflow(0x0); // unsupported/unimplemented
 2773   %}
 2774 %}
 2775 
 2776 operand cmpOpUL() %{
 2777   match(Bool);
 2778 
 2779   format %{ &quot;UL&quot; %}
 2780   interface(COND_INTER) %{
 2781     equal(0x0);
 2782     not_equal(0x1);
 2783     less(0x3);
 2784     greater_equal(0x2);
 2785     less_equal(0x9);
 2786     greater(0x8);
 2787     overflow(0x0); // unsupported/unimplemented
 2788     no_overflow(0x0); // unsupported/unimplemented
 2789   %}
 2790 %}
 2791 
 2792 operand cmpOpUL_commute() %{
 2793   match(Bool);
 2794 
 2795   format %{ &quot;UL&quot; %}
 2796   interface(COND_INTER) %{
 2797     equal(0x0);
 2798     not_equal(0x1);
 2799     less(0x8);
 2800     greater_equal(0x9);
 2801     less_equal(0x2);
 2802     greater(0x3);
 2803     overflow(0x0); // unsupported/unimplemented
 2804     no_overflow(0x0); // unsupported/unimplemented
 2805   %}
 2806 %}
 2807 
 2808 
 2809 //----------OPERAND CLASSES----------------------------------------------------
 2810 // Operand Classes are groups of operands that are used to simplify
 2811 // instruction definitions by not requiring the AD writer to specify separate
 2812 // instructions for every form of operand when the instruction accepts
 2813 // multiple operand types with the same basic encoding and format.  The classic
 2814 // case of this is memory operands.
 2815 
 2816 opclass memoryI ( indirect, indOffset12, indIndex, indIndexScale );
 2817 opclass memoryP ( indirect, indOffset12, indIndex, indIndexScale );
 2818 opclass memoryF ( indirect, indOffsetFP );
 2819 opclass memoryF2 ( indirect, indOffsetFPx2 );
 2820 opclass memoryD ( indirect, indOffsetFP );
 2821 opclass memoryfp( indirect, indOffsetFP );
 2822 opclass memoryB ( indirect, indIndex, indOffsetHD );
 2823 opclass memoryS ( indirect, indIndex, indOffsetHD );
 2824 opclass memoryL ( indirect, indIndex, indOffsetHD );
 2825 
 2826 opclass memoryScaledI(indIndexScale);
 2827 opclass memoryScaledP(indIndexScale);
 2828 
 2829 // when ldrex/strex is used:
 2830 opclass memoryex ( indirect );
 2831 opclass indIndexMemory( indIndex );
 2832 opclass memorylong ( indirect, indOffset12x2 );
 2833 opclass memoryvld ( indirect /* , write back mode not implemented */ );
 2834 
 2835 //----------PIPELINE-----------------------------------------------------------
 2836 pipeline %{
 2837 
 2838 //----------ATTRIBUTES---------------------------------------------------------
 2839 attributes %{
 2840   fixed_size_instructions;           // Fixed size instructions
 2841   max_instructions_per_bundle = 4;   // Up to 4 instructions per bundle
 2842   instruction_unit_size = 4;         // An instruction is 4 bytes long
 2843   instruction_fetch_unit_size = 16;  // The processor fetches one line
 2844   instruction_fetch_units = 1;       // of 16 bytes
 2845 
 2846   // List of nop instructions
 2847   nops( Nop_A0, Nop_A1, Nop_MS, Nop_FA, Nop_BR );
 2848 %}
 2849 
 2850 //----------RESOURCES----------------------------------------------------------
 2851 // Resources are the functional units available to the machine
 2852 resources(A0, A1, MS, BR, FA, FM, IDIV, FDIV, IALU = A0 | A1);
 2853 
 2854 //----------PIPELINE DESCRIPTION-----------------------------------------------
 2855 // Pipeline Description specifies the stages in the machine&#39;s pipeline
 2856 
 2857 pipe_desc(A, P, F, B, I, J, S, R, E, C, M, W, X, T, D);
 2858 
 2859 //----------PIPELINE CLASSES---------------------------------------------------
 2860 // Pipeline Classes describe the stages in which input and output are
 2861 // referenced by the hardware pipeline.
 2862 
 2863 // Integer ALU reg-reg operation
 2864 pipe_class ialu_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 2865     single_instruction;
 2866     dst   : E(write);
 2867     src1  : R(read);
 2868     src2  : R(read);
 2869     IALU  : R;
 2870 %}
 2871 
 2872 // Integer ALU reg-reg long operation
 2873 pipe_class ialu_reg_reg_2(iRegL dst, iRegL src1, iRegL src2) %{
 2874     instruction_count(2);
 2875     dst   : E(write);
 2876     src1  : R(read);
 2877     src2  : R(read);
 2878     IALU  : R;
 2879     IALU  : R;
 2880 %}
 2881 
 2882 // Integer ALU reg-reg long dependent operation
 2883 pipe_class ialu_reg_reg_2_dep(iRegL dst, iRegL src1, iRegL src2, flagsReg cr) %{
 2884     instruction_count(1); multiple_bundles;
 2885     dst   : E(write);
 2886     src1  : R(read);
 2887     src2  : R(read);
 2888     cr    : E(write);
 2889     IALU  : R(2);
 2890 %}
 2891 
 2892 // Integer ALU reg-imm operaion
 2893 pipe_class ialu_reg_imm(iRegI dst, iRegI src1) %{
 2894     single_instruction;
 2895     dst   : E(write);
 2896     src1  : R(read);
 2897     IALU  : R;
 2898 %}
 2899 
 2900 // Integer ALU reg-reg operation with condition code
 2901 pipe_class ialu_cc_reg_reg(iRegI dst, iRegI src1, iRegI src2, flagsReg cr) %{
 2902     single_instruction;
 2903     dst   : E(write);
 2904     cr    : E(write);
 2905     src1  : R(read);
 2906     src2  : R(read);
 2907     IALU  : R;
 2908 %}
 2909 
 2910 // Integer ALU zero-reg operation
 2911 pipe_class ialu_zero_reg(iRegI dst, immI0 zero, iRegI src2) %{
 2912     single_instruction;
 2913     dst   : E(write);
 2914     src2  : R(read);
 2915     IALU  : R;
 2916 %}
 2917 
 2918 // Integer ALU zero-reg operation with condition code only
 2919 pipe_class ialu_cconly_zero_reg(flagsReg cr, iRegI src) %{
 2920     single_instruction;
 2921     cr    : E(write);
 2922     src   : R(read);
 2923     IALU  : R;
 2924 %}
 2925 
 2926 // Integer ALU reg-reg operation with condition code only
 2927 pipe_class ialu_cconly_reg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 2928     single_instruction;
 2929     cr    : E(write);
 2930     src1  : R(read);
 2931     src2  : R(read);
 2932     IALU  : R;
 2933 %}
 2934 
 2935 // Integer ALU reg-imm operation with condition code only
 2936 pipe_class ialu_cconly_reg_imm(flagsReg cr, iRegI src1) %{
 2937     single_instruction;
 2938     cr    : E(write);
 2939     src1  : R(read);
 2940     IALU  : R;
 2941 %}
 2942 
 2943 // Integer ALU reg-reg-zero operation with condition code only
 2944 pipe_class ialu_cconly_reg_reg_zero(flagsReg cr, iRegI src1, iRegI src2, immI0 zero) %{
 2945     single_instruction;
 2946     cr    : E(write);
 2947     src1  : R(read);
 2948     src2  : R(read);
 2949     IALU  : R;
 2950 %}
 2951 
 2952 // Integer ALU reg-imm-zero operation with condition code only
 2953 pipe_class ialu_cconly_reg_imm_zero(flagsReg cr, iRegI src1, immI0 zero) %{
 2954     single_instruction;
 2955     cr    : E(write);
 2956     src1  : R(read);
 2957     IALU  : R;
 2958 %}
 2959 
 2960 // Integer ALU reg-reg operation with condition code, src1 modified
 2961 pipe_class ialu_cc_rwreg_reg(flagsReg cr, iRegI src1, iRegI src2) %{
 2962     single_instruction;
 2963     cr    : E(write);
 2964     src1  : E(write);
 2965     src1  : R(read);
 2966     src2  : R(read);
 2967     IALU  : R;
 2968 %}
 2969 
 2970 pipe_class cmpL_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg cr ) %{
 2971     multiple_bundles;
 2972     dst   : E(write)+4;
 2973     cr    : E(write);
 2974     src1  : R(read);
 2975     src2  : R(read);
 2976     IALU  : R(3);
 2977     BR    : R(2);
 2978 %}
 2979 
 2980 // Integer ALU operation
 2981 pipe_class ialu_none(iRegI dst) %{
 2982     single_instruction;
 2983     dst   : E(write);
 2984     IALU  : R;
 2985 %}
 2986 
 2987 // Integer ALU reg operation
 2988 pipe_class ialu_reg(iRegI dst, iRegI src) %{
 2989     single_instruction; may_have_no_code;
 2990     dst   : E(write);
 2991     src   : R(read);
 2992     IALU  : R;
 2993 %}
 2994 
 2995 // Integer ALU reg conditional operation
 2996 // This instruction has a 1 cycle stall, and cannot execute
 2997 // in the same cycle as the instruction setting the condition
 2998 // code. We kludge this by pretending to read the condition code
 2999 // 1 cycle earlier, and by marking the functional units as busy
 3000 // for 2 cycles with the result available 1 cycle later than
 3001 // is really the case.
 3002 pipe_class ialu_reg_flags( iRegI op2_out, iRegI op2_in, iRegI op1, flagsReg cr ) %{
 3003     single_instruction;
 3004     op2_out : C(write);
 3005     op1     : R(read);
 3006     cr      : R(read);       // This is really E, with a 1 cycle stall
 3007     BR      : R(2);
 3008     MS      : R(2);
 3009 %}
 3010 
 3011 // Integer ALU reg operation
 3012 pipe_class ialu_move_reg_L_to_I(iRegI dst, iRegL src) %{
 3013     single_instruction; may_have_no_code;
 3014     dst   : E(write);
 3015     src   : R(read);
 3016     IALU  : R;
 3017 %}
 3018 pipe_class ialu_move_reg_I_to_L(iRegL dst, iRegI src) %{
 3019     single_instruction; may_have_no_code;
 3020     dst   : E(write);
 3021     src   : R(read);
 3022     IALU  : R;
 3023 %}
 3024 
 3025 // Two integer ALU reg operations
 3026 pipe_class ialu_reg_2(iRegL dst, iRegL src) %{
 3027     instruction_count(2);
 3028     dst   : E(write);
 3029     src   : R(read);
 3030     A0    : R;
 3031     A1    : R;
 3032 %}
 3033 
 3034 // Two integer ALU reg operations
 3035 pipe_class ialu_move_reg_L_to_L(iRegL dst, iRegL src) %{
 3036     instruction_count(2); may_have_no_code;
 3037     dst   : E(write);
 3038     src   : R(read);
 3039     A0    : R;
 3040     A1    : R;
 3041 %}
 3042 
 3043 // Integer ALU imm operation
 3044 pipe_class ialu_imm(iRegI dst) %{
 3045     single_instruction;
 3046     dst   : E(write);
 3047     IALU  : R;
 3048 %}
 3049 
 3050 pipe_class ialu_imm_n(iRegI dst) %{
 3051     single_instruction;
 3052     dst   : E(write);
 3053     IALU  : R;
 3054 %}
 3055 
 3056 // Integer ALU reg-reg with carry operation
 3057 pipe_class ialu_reg_reg_cy(iRegI dst, iRegI src1, iRegI src2, iRegI cy) %{
 3058     single_instruction;
 3059     dst   : E(write);
 3060     src1  : R(read);
 3061     src2  : R(read);
 3062     IALU  : R;
 3063 %}
 3064 
 3065 // Integer ALU cc operation
 3066 pipe_class ialu_cc(iRegI dst, flagsReg cc) %{
 3067     single_instruction;
 3068     dst   : E(write);
 3069     cc    : R(read);
 3070     IALU  : R;
 3071 %}
 3072 
 3073 // Integer ALU cc / second IALU operation
 3074 pipe_class ialu_reg_ialu( iRegI dst, iRegI src ) %{
 3075     instruction_count(1); multiple_bundles;
 3076     dst   : E(write)+1;
 3077     src   : R(read);
 3078     IALU  : R;
 3079 %}
 3080 
 3081 // Integer ALU cc / second IALU operation
 3082 pipe_class ialu_reg_reg_ialu( iRegI dst, iRegI p, iRegI q ) %{
 3083     instruction_count(1); multiple_bundles;
 3084     dst   : E(write)+1;
 3085     p     : R(read);
 3086     q     : R(read);
 3087     IALU  : R;
 3088 %}
 3089 
 3090 // Integer ALU hi-lo-reg operation
 3091 pipe_class ialu_hi_lo_reg(iRegI dst, immI src) %{
 3092     instruction_count(1); multiple_bundles;
 3093     dst   : E(write)+1;
 3094     IALU  : R(2);
 3095 %}
 3096 
 3097 // Long Constant
 3098 pipe_class loadConL( iRegL dst, immL src ) %{
 3099     instruction_count(2); multiple_bundles;
 3100     dst   : E(write)+1;
 3101     IALU  : R(2);
 3102     IALU  : R(2);
 3103 %}
 3104 
 3105 // Pointer Constant
 3106 pipe_class loadConP( iRegP dst, immP src ) %{
 3107     instruction_count(0); multiple_bundles;
 3108     fixed_latency(6);
 3109 %}
 3110 
<a name="40" id="anc40"></a>





 3111 // Long Constant small
 3112 pipe_class loadConLlo( iRegL dst, immL src ) %{
 3113     instruction_count(2);
 3114     dst   : E(write);
 3115     IALU  : R;
 3116     IALU  : R;
 3117 %}
 3118 
 3119 // [PHH] This is wrong for 64-bit.  See LdImmF/D.
 3120 pipe_class loadConFD(regF dst, immF src, iRegP tmp) %{
 3121     instruction_count(1); multiple_bundles;
 3122     src   : R(read);
 3123     dst   : M(write)+1;
 3124     IALU  : R;
 3125     MS    : E;
 3126 %}
 3127 
 3128 // Integer ALU nop operation
 3129 pipe_class ialu_nop() %{
 3130     single_instruction;
 3131     IALU  : R;
 3132 %}
 3133 
 3134 // Integer ALU nop operation
 3135 pipe_class ialu_nop_A0() %{
 3136     single_instruction;
 3137     A0    : R;
 3138 %}
 3139 
 3140 // Integer ALU nop operation
 3141 pipe_class ialu_nop_A1() %{
 3142     single_instruction;
 3143     A1    : R;
 3144 %}
 3145 
 3146 // Integer Multiply reg-reg operation
 3147 pipe_class imul_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 3148     single_instruction;
 3149     dst   : E(write);
 3150     src1  : R(read);
 3151     src2  : R(read);
 3152     MS    : R(5);
 3153 %}
 3154 
 3155 pipe_class mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 3156     single_instruction;
 3157     dst   : E(write)+4;
 3158     src1  : R(read);
 3159     src2  : R(read);
 3160     MS    : R(6);
 3161 %}
 3162 
 3163 // Integer Divide reg-reg
 3164 pipe_class sdiv_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI temp, flagsReg cr) %{
 3165     instruction_count(1); multiple_bundles;
 3166     dst   : E(write);
 3167     temp  : E(write);
 3168     src1  : R(read);
 3169     src2  : R(read);
 3170     temp  : R(read);
 3171     MS    : R(38);
 3172 %}
 3173 
 3174 // Long Divide
 3175 pipe_class divL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 3176     dst  : E(write)+71;
 3177     src1 : R(read);
 3178     src2 : R(read)+1;
 3179     MS   : R(70);
 3180 %}
 3181 
 3182 // Floating Point Add Float
 3183 pipe_class faddF_reg_reg(regF dst, regF src1, regF src2) %{
 3184     single_instruction;
 3185     dst   : X(write);
 3186     src1  : E(read);
 3187     src2  : E(read);
 3188     FA    : R;
 3189 %}
 3190 
 3191 // Floating Point Add Double
 3192 pipe_class faddD_reg_reg(regD dst, regD src1, regD src2) %{
 3193     single_instruction;
 3194     dst   : X(write);
 3195     src1  : E(read);
 3196     src2  : E(read);
 3197     FA    : R;
 3198 %}
 3199 
 3200 // Floating Point Conditional Move based on integer flags
 3201 pipe_class int_conditional_float_move (cmpOp cmp, flagsReg cr, regF dst, regF src) %{
 3202     single_instruction;
 3203     dst   : X(write);
 3204     src   : E(read);
 3205     cr    : R(read);
 3206     FA    : R(2);
 3207     BR    : R(2);
 3208 %}
 3209 
 3210 // Floating Point Conditional Move based on integer flags
 3211 pipe_class int_conditional_double_move (cmpOp cmp, flagsReg cr, regD dst, regD src) %{
 3212     single_instruction;
 3213     dst   : X(write);
 3214     src   : E(read);
 3215     cr    : R(read);
 3216     FA    : R(2);
 3217     BR    : R(2);
 3218 %}
 3219 
 3220 // Floating Point Multiply Float
 3221 pipe_class fmulF_reg_reg(regF dst, regF src1, regF src2) %{
 3222     single_instruction;
 3223     dst   : X(write);
 3224     src1  : E(read);
 3225     src2  : E(read);
 3226     FM    : R;
 3227 %}
 3228 
 3229 // Floating Point Multiply Double
 3230 pipe_class fmulD_reg_reg(regD dst, regD src1, regD src2) %{
 3231     single_instruction;
 3232     dst   : X(write);
 3233     src1  : E(read);
 3234     src2  : E(read);
 3235     FM    : R;
 3236 %}
 3237 
 3238 // Floating Point Divide Float
 3239 pipe_class fdivF_reg_reg(regF dst, regF src1, regF src2) %{
 3240     single_instruction;
 3241     dst   : X(write);
 3242     src1  : E(read);
 3243     src2  : E(read);
 3244     FM    : R;
 3245     FDIV  : C(14);
 3246 %}
 3247 
 3248 // Floating Point Divide Double
 3249 pipe_class fdivD_reg_reg(regD dst, regD src1, regD src2) %{
 3250     single_instruction;
 3251     dst   : X(write);
 3252     src1  : E(read);
 3253     src2  : E(read);
 3254     FM    : R;
 3255     FDIV  : C(17);
 3256 %}
 3257 
 3258 // Floating Point Move/Negate/Abs Float
 3259 pipe_class faddF_reg(regF dst, regF src) %{
 3260     single_instruction;
 3261     dst   : W(write);
 3262     src   : E(read);
 3263     FA    : R(1);
 3264 %}
 3265 
 3266 // Floating Point Move/Negate/Abs Double
 3267 pipe_class faddD_reg(regD dst, regD src) %{
 3268     single_instruction;
 3269     dst   : W(write);
 3270     src   : E(read);
 3271     FA    : R;
 3272 %}
 3273 
 3274 // Floating Point Convert F-&gt;D
 3275 pipe_class fcvtF2D(regD dst, regF src) %{
 3276     single_instruction;
 3277     dst   : X(write);
 3278     src   : E(read);
 3279     FA    : R;
 3280 %}
 3281 
 3282 // Floating Point Convert I-&gt;D
 3283 pipe_class fcvtI2D(regD dst, regF src) %{
 3284     single_instruction;
 3285     dst   : X(write);
 3286     src   : E(read);
 3287     FA    : R;
 3288 %}
 3289 
 3290 // Floating Point Convert LHi-&gt;D
 3291 pipe_class fcvtLHi2D(regD dst, regD src) %{
 3292     single_instruction;
 3293     dst   : X(write);
 3294     src   : E(read);
 3295     FA    : R;
 3296 %}
 3297 
 3298 // Floating Point Convert L-&gt;D
 3299 pipe_class fcvtL2D(regD dst, iRegL src) %{
 3300     single_instruction;
 3301     dst   : X(write);
 3302     src   : E(read);
 3303     FA    : R;
 3304 %}
 3305 
 3306 // Floating Point Convert L-&gt;F
 3307 pipe_class fcvtL2F(regF dst, iRegL src) %{
 3308     single_instruction;
 3309     dst   : X(write);
 3310     src   : E(read);
 3311     FA    : R;
 3312 %}
 3313 
 3314 // Floating Point Convert D-&gt;F
 3315 pipe_class fcvtD2F(regD dst, regF src) %{
 3316     single_instruction;
 3317     dst   : X(write);
 3318     src   : E(read);
 3319     FA    : R;
 3320 %}
 3321 
 3322 // Floating Point Convert I-&gt;L
 3323 pipe_class fcvtI2L(regD dst, regF src) %{
 3324     single_instruction;
 3325     dst   : X(write);
 3326     src   : E(read);
 3327     FA    : R;
 3328 %}
 3329 
 3330 // Floating Point Convert D-&gt;F
 3331 pipe_class fcvtD2I(iRegI dst, regD src, flagsReg cr) %{
 3332     instruction_count(1); multiple_bundles;
 3333     dst   : X(write)+6;
 3334     src   : E(read);
 3335     FA    : R;
 3336 %}
 3337 
 3338 // Floating Point Convert D-&gt;L
 3339 pipe_class fcvtD2L(regD dst, regD src, flagsReg cr) %{
 3340     instruction_count(1); multiple_bundles;
 3341     dst   : X(write)+6;
 3342     src   : E(read);
 3343     FA    : R;
 3344 %}
 3345 
 3346 // Floating Point Convert F-&gt;I
 3347 pipe_class fcvtF2I(regF dst, regF src, flagsReg cr) %{
 3348     instruction_count(1); multiple_bundles;
 3349     dst   : X(write)+6;
 3350     src   : E(read);
 3351     FA    : R;
 3352 %}
 3353 
 3354 // Floating Point Convert F-&gt;L
 3355 pipe_class fcvtF2L(regD dst, regF src, flagsReg cr) %{
 3356     instruction_count(1); multiple_bundles;
 3357     dst   : X(write)+6;
 3358     src   : E(read);
 3359     FA    : R;
 3360 %}
 3361 
 3362 // Floating Point Convert I-&gt;F
 3363 pipe_class fcvtI2F(regF dst, regF src) %{
 3364     single_instruction;
 3365     dst   : X(write);
 3366     src   : E(read);
 3367     FA    : R;
 3368 %}
 3369 
 3370 // Floating Point Compare
 3371 pipe_class faddF_fcc_reg_reg_zero(flagsRegF cr, regF src1, regF src2, immI0 zero) %{
 3372     single_instruction;
 3373     cr    : X(write);
 3374     src1  : E(read);
 3375     src2  : E(read);
 3376     FA    : R;
 3377 %}
 3378 
 3379 // Floating Point Compare
 3380 pipe_class faddD_fcc_reg_reg_zero(flagsRegF cr, regD src1, regD src2, immI0 zero) %{
 3381     single_instruction;
 3382     cr    : X(write);
 3383     src1  : E(read);
 3384     src2  : E(read);
 3385     FA    : R;
 3386 %}
 3387 
 3388 // Floating Add Nop
 3389 pipe_class fadd_nop() %{
 3390     single_instruction;
 3391     FA  : R;
 3392 %}
 3393 
 3394 // Integer Store to Memory
 3395 pipe_class istore_mem_reg(memoryI mem, iRegI src) %{
 3396     single_instruction;
 3397     mem   : R(read);
 3398     src   : C(read);
 3399     MS    : R;
 3400 %}
 3401 
 3402 // Integer Store to Memory
 3403 pipe_class istore_mem_spORreg(memoryI mem, sp_ptr_RegP src) %{
 3404     single_instruction;
 3405     mem   : R(read);
 3406     src   : C(read);
 3407     MS    : R;
 3408 %}
 3409 
 3410 // Float Store
 3411 pipe_class fstoreF_mem_reg(memoryF mem, RegF src) %{
 3412     single_instruction;
 3413     mem : R(read);
 3414     src : C(read);
 3415     MS  : R;
 3416 %}
 3417 
 3418 // Float Store
 3419 pipe_class fstoreF_mem_zero(memoryF mem, immF0 src) %{
 3420     single_instruction;
 3421     mem : R(read);
 3422     MS  : R;
 3423 %}
 3424 
 3425 // Double Store
 3426 pipe_class fstoreD_mem_reg(memoryD mem, RegD src) %{
 3427     instruction_count(1);
 3428     mem : R(read);
 3429     src : C(read);
 3430     MS  : R;
 3431 %}
 3432 
 3433 // Double Store
 3434 pipe_class fstoreD_mem_zero(memoryD mem, immD0 src) %{
 3435     single_instruction;
 3436     mem : R(read);
 3437     MS  : R;
 3438 %}
 3439 
 3440 // Integer Load (when sign bit propagation not needed)
 3441 pipe_class iload_mem(iRegI dst, memoryI mem) %{
 3442     single_instruction;
 3443     mem : R(read);
 3444     dst : C(write);
 3445     MS  : R;
 3446 %}
 3447 
 3448 // Integer Load (when sign bit propagation or masking is needed)
 3449 pipe_class iload_mask_mem(iRegI dst, memoryI mem) %{
 3450     single_instruction;
 3451     mem : R(read);
 3452     dst : M(write);
 3453     MS  : R;
 3454 %}
 3455 
 3456 // Float Load
 3457 pipe_class floadF_mem(regF dst, memoryF mem) %{
 3458     single_instruction;
 3459     mem : R(read);
 3460     dst : M(write);
 3461     MS  : R;
 3462 %}
 3463 
 3464 // Float Load
 3465 pipe_class floadD_mem(regD dst, memoryD mem) %{
 3466     instruction_count(1); multiple_bundles; // Again, unaligned argument is only multiple case
 3467     mem : R(read);
 3468     dst : M(write);
 3469     MS  : R;
 3470 %}
 3471 
 3472 // Memory Nop
 3473 pipe_class mem_nop() %{
 3474     single_instruction;
 3475     MS  : R;
 3476 %}
 3477 
 3478 pipe_class sethi(iRegP dst, immI src) %{
 3479     single_instruction;
 3480     dst  : E(write);
 3481     IALU : R;
 3482 %}
 3483 
 3484 pipe_class loadPollP(iRegP poll) %{
 3485     single_instruction;
 3486     poll : R(read);
 3487     MS   : R;
 3488 %}
 3489 
 3490 pipe_class br(Universe br, label labl) %{
 3491     single_instruction_with_delay_slot;
 3492     BR  : R;
 3493 %}
 3494 
 3495 pipe_class br_cc(Universe br, cmpOp cmp, flagsReg cr, label labl) %{
 3496     single_instruction_with_delay_slot;
 3497     cr    : E(read);
 3498     BR    : R;
 3499 %}
 3500 
 3501 pipe_class br_reg(Universe br, cmpOp cmp, iRegI op1, label labl) %{
 3502     single_instruction_with_delay_slot;
 3503     op1 : E(read);
 3504     BR  : R;
 3505     MS  : R;
 3506 %}
 3507 
 3508 pipe_class br_nop() %{
 3509     single_instruction;
 3510     BR  : R;
 3511 %}
 3512 
 3513 pipe_class simple_call(method meth) %{
 3514     instruction_count(2); multiple_bundles; force_serialization;
 3515     fixed_latency(100);
 3516     BR  : R(1);
 3517     MS  : R(1);
 3518     A0  : R(1);
 3519 %}
 3520 
 3521 pipe_class compiled_call(method meth) %{
 3522     instruction_count(1); multiple_bundles; force_serialization;
 3523     fixed_latency(100);
 3524     MS  : R(1);
 3525 %}
 3526 
 3527 pipe_class call(method meth) %{
 3528     instruction_count(0); multiple_bundles; force_serialization;
 3529     fixed_latency(100);
 3530 %}
 3531 
 3532 pipe_class tail_call(Universe ignore, label labl) %{
 3533     single_instruction; has_delay_slot;
 3534     fixed_latency(100);
 3535     BR  : R(1);
 3536     MS  : R(1);
 3537 %}
 3538 
 3539 pipe_class ret(Universe ignore) %{
 3540     single_instruction; has_delay_slot;
 3541     BR  : R(1);
 3542     MS  : R(1);
 3543 %}
 3544 
 3545 // The real do-nothing guy
 3546 pipe_class empty( ) %{
 3547     instruction_count(0);
 3548 %}
 3549 
 3550 pipe_class long_memory_op() %{
 3551     instruction_count(0); multiple_bundles; force_serialization;
 3552     fixed_latency(25);
 3553     MS  : R(1);
 3554 %}
 3555 
 3556 // Check-cast
 3557 pipe_class partial_subtype_check_pipe(Universe ignore, iRegP array, iRegP match ) %{
 3558     array : R(read);
 3559     match  : R(read);
 3560     IALU   : R(2);
 3561     BR     : R(2);
 3562     MS     : R;
 3563 %}
 3564 
 3565 // Convert FPU flags into +1,0,-1
 3566 pipe_class floating_cmp( iRegI dst, regF src1, regF src2 ) %{
 3567     src1  : E(read);
 3568     src2  : E(read);
 3569     dst   : E(write);
 3570     FA    : R;
 3571     MS    : R(2);
 3572     BR    : R(2);
 3573 %}
 3574 
 3575 // Compare for p &lt; q, and conditionally add y
 3576 pipe_class cadd_cmpltmask( iRegI p, iRegI q, iRegI y ) %{
 3577     p     : E(read);
 3578     q     : E(read);
 3579     y     : E(read);
 3580     IALU  : R(3)
 3581 %}
 3582 
 3583 // Perform a compare, then move conditionally in a branch delay slot.
 3584 pipe_class min_max( iRegI src2, iRegI srcdst ) %{
 3585     src2   : E(read);
 3586     srcdst : E(read);
 3587     IALU   : R;
 3588     BR     : R;
 3589 %}
 3590 
 3591 // Define the class for the Nop node
 3592 define %{
 3593    MachNop = ialu_nop;
 3594 %}
 3595 
 3596 %}
 3597 
 3598 //----------INSTRUCTIONS-------------------------------------------------------
 3599 
 3600 //------------Special Nop instructions for bundling - no match rules-----------
 3601 // Nop using the A0 functional unit
 3602 instruct Nop_A0() %{
 3603   ins_pipe(ialu_nop_A0);
 3604 %}
 3605 
 3606 // Nop using the A1 functional unit
 3607 instruct Nop_A1( ) %{
 3608   ins_pipe(ialu_nop_A1);
 3609 %}
 3610 
 3611 // Nop using the memory functional unit
 3612 instruct Nop_MS( ) %{
 3613   ins_pipe(mem_nop);
 3614 %}
 3615 
 3616 // Nop using the floating add functional unit
 3617 instruct Nop_FA( ) %{
 3618   ins_pipe(fadd_nop);
 3619 %}
 3620 
 3621 // Nop using the branch functional unit
 3622 instruct Nop_BR( ) %{
 3623   ins_pipe(br_nop);
 3624 %}
 3625 
 3626 //----------Load/Store/Move Instructions---------------------------------------
 3627 //----------Load Instructions--------------------------------------------------
 3628 // Load Byte (8bit signed)
 3629 instruct loadB(iRegI dst, memoryB mem) %{
 3630   match(Set dst (LoadB mem));
 3631   ins_cost(MEMORY_REF_COST);
 3632 
 3633   size(4);
 3634   format %{ &quot;LDRSB   $dst,$mem\t! byte -&gt; int&quot; %}
 3635   ins_encode %{
 3636     __ ldrsb($dst$$Register, $mem$$Address);
 3637   %}
 3638   ins_pipe(iload_mask_mem);
 3639 %}
 3640 
 3641 // Load Byte (8bit signed) into a Long Register
 3642 instruct loadB2L(iRegL dst, memoryB mem) %{
 3643   match(Set dst (ConvI2L (LoadB mem)));
 3644   ins_cost(MEMORY_REF_COST);
 3645 
 3646   size(8);
 3647   format %{ &quot;LDRSB $dst.lo,$mem\t! byte -&gt; long\n\t&quot;
 3648             &quot;ASR   $dst.hi,$dst.lo,31&quot; %}
 3649   ins_encode %{
 3650     __ ldrsb($dst$$Register, $mem$$Address);
 3651     __ mov($dst$$Register-&gt;successor(), AsmOperand($dst$$Register, asr, 31));
 3652   %}
 3653   ins_pipe(iload_mask_mem);
 3654 %}
 3655 
 3656 // Load Unsigned Byte (8bit UNsigned) into an int reg
 3657 instruct loadUB(iRegI dst, memoryB mem) %{
 3658   match(Set dst (LoadUB mem));
 3659   ins_cost(MEMORY_REF_COST);
 3660 
 3661   size(4);
 3662   format %{ &quot;LDRB   $dst,$mem\t! ubyte -&gt; int&quot; %}
 3663   ins_encode %{
 3664     __ ldrb($dst$$Register, $mem$$Address);
 3665   %}
 3666   ins_pipe(iload_mem);
 3667 %}
 3668 
 3669 // Load Unsigned Byte (8bit UNsigned) into a Long Register
 3670 instruct loadUB2L(iRegL dst, memoryB mem) %{
 3671   match(Set dst (ConvI2L (LoadUB mem)));
 3672   ins_cost(MEMORY_REF_COST);
 3673 
 3674   size(8);
 3675   format %{ &quot;LDRB  $dst.lo,$mem\t! ubyte -&gt; long\n\t&quot;
 3676             &quot;MOV   $dst.hi,0&quot; %}
 3677   ins_encode %{
 3678     __ ldrb($dst$$Register, $mem$$Address);
 3679     __ mov($dst$$Register-&gt;successor(), 0);
 3680   %}
 3681   ins_pipe(iload_mem);
 3682 %}
 3683 
 3684 // Load Unsigned Byte (8 bit UNsigned) with immediate mask into Long Register
 3685 instruct loadUB2L_limmI(iRegL dst, memoryB mem, limmIlow8 mask) %{
 3686   match(Set dst (ConvI2L (AndI (LoadUB mem) mask)));
 3687 
 3688   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 3689   size(12);
 3690   format %{ &quot;LDRB  $dst.lo,$mem\t! ubyte -&gt; long\n\t&quot;
 3691             &quot;MOV   $dst.hi,0\n\t&quot;
 3692             &quot;AND  $dst.lo,$dst.lo,$mask&quot; %}
 3693   ins_encode %{
 3694     __ ldrb($dst$$Register, $mem$$Address);
 3695     __ mov($dst$$Register-&gt;successor(), 0);
 3696     __ andr($dst$$Register, $dst$$Register, limmI_low($mask$$constant, 8));
 3697   %}
 3698   ins_pipe(iload_mem);
 3699 %}
 3700 
 3701 // Load Short (16bit signed)
 3702 
 3703 instruct loadS(iRegI dst, memoryS mem) %{
 3704   match(Set dst (LoadS mem));
 3705   ins_cost(MEMORY_REF_COST);
 3706 
 3707   size(4);
 3708   format %{ &quot;LDRSH   $dst,$mem\t! short&quot; %}
 3709   ins_encode %{
 3710     __ ldrsh($dst$$Register, $mem$$Address);
 3711   %}
 3712   ins_pipe(iload_mask_mem);
 3713 %}
 3714 
 3715 // Load Short (16 bit signed) to Byte (8 bit signed)
 3716 instruct loadS2B(iRegI dst, memoryS mem, immI_24 twentyfour) %{
 3717   match(Set dst (RShiftI (LShiftI (LoadS mem) twentyfour) twentyfour));
 3718   ins_cost(MEMORY_REF_COST);
 3719 
 3720   size(4);
 3721 
 3722   format %{ &quot;LDRSB   $dst,$mem\t! short -&gt; byte&quot; %}
 3723   ins_encode %{
 3724     __ ldrsb($dst$$Register, $mem$$Address);
 3725   %}
 3726   ins_pipe(iload_mask_mem);
 3727 %}
 3728 
 3729 // Load Short (16bit signed) into a Long Register
 3730 instruct loadS2L(iRegL dst, memoryS mem) %{
 3731   match(Set dst (ConvI2L (LoadS mem)));
 3732   ins_cost(MEMORY_REF_COST);
 3733 
 3734   size(8);
 3735   format %{ &quot;LDRSH $dst.lo,$mem\t! short -&gt; long\n\t&quot;
 3736             &quot;ASR   $dst.hi,$dst.lo,31&quot; %}
 3737   ins_encode %{
 3738     __ ldrsh($dst$$Register, $mem$$Address);
 3739     __ mov($dst$$Register-&gt;successor(), AsmOperand($dst$$Register, asr, 31));
 3740   %}
 3741   ins_pipe(iload_mask_mem);
 3742 %}
 3743 
 3744 // Load Unsigned Short/Char (16bit UNsigned)
 3745 
 3746 
 3747 instruct loadUS(iRegI dst, memoryS mem) %{
 3748   match(Set dst (LoadUS mem));
 3749   ins_cost(MEMORY_REF_COST);
 3750 
 3751   size(4);
 3752   format %{ &quot;LDRH   $dst,$mem\t! ushort/char&quot; %}
 3753   ins_encode %{
 3754     __ ldrh($dst$$Register, $mem$$Address);
 3755   %}
 3756   ins_pipe(iload_mem);
 3757 %}
 3758 
 3759 // Load Unsigned Short/Char (16 bit UNsigned) to Byte (8 bit signed)
 3760 instruct loadUS2B(iRegI dst, memoryB mem, immI_24 twentyfour) %{
 3761   match(Set dst (RShiftI (LShiftI (LoadUS mem) twentyfour) twentyfour));
 3762   ins_cost(MEMORY_REF_COST);
 3763 
 3764   size(4);
 3765   format %{ &quot;LDRSB   $dst,$mem\t! ushort -&gt; byte&quot; %}
 3766   ins_encode %{
 3767     __ ldrsb($dst$$Register, $mem$$Address);
 3768   %}
 3769   ins_pipe(iload_mask_mem);
 3770 %}
 3771 
 3772 // Load Unsigned Short/Char (16bit UNsigned) into a Long Register
 3773 instruct loadUS2L(iRegL dst, memoryS mem) %{
 3774   match(Set dst (ConvI2L (LoadUS mem)));
 3775   ins_cost(MEMORY_REF_COST);
 3776 
 3777   size(8);
 3778   format %{ &quot;LDRH  $dst.lo,$mem\t! short -&gt; long\n\t&quot;
 3779             &quot;MOV   $dst.hi, 0&quot; %}
 3780   ins_encode %{
 3781     __ ldrh($dst$$Register, $mem$$Address);
 3782     __ mov($dst$$Register-&gt;successor(), 0);
 3783   %}
 3784   ins_pipe(iload_mem);
 3785 %}
 3786 
 3787 // Load Unsigned Short/Char (16bit UNsigned) with mask 0xFF into a Long Register
 3788 instruct loadUS2L_immI_255(iRegL dst, memoryB mem, immI_255 mask) %{
 3789   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 3790   ins_cost(MEMORY_REF_COST);
 3791 
 3792   size(8);
 3793   format %{ &quot;LDRB  $dst.lo,$mem\t! \n\t&quot;
 3794             &quot;MOV   $dst.hi, 0&quot; %}
 3795   ins_encode %{
 3796     __ ldrb($dst$$Register, $mem$$Address);
 3797     __ mov($dst$$Register-&gt;successor(), 0);
 3798   %}
 3799   ins_pipe(iload_mem);
 3800 %}
 3801 
 3802 // Load Unsigned Short/Char (16bit UNsigned) with a immediate mask into a Long Register
 3803 instruct loadUS2L_limmI(iRegL dst, memoryS mem, limmI mask) %{
 3804   match(Set dst (ConvI2L (AndI (LoadUS mem) mask)));
 3805   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 3806 
 3807   size(12);
 3808   format %{ &quot;LDRH   $dst,$mem\t! ushort/char &amp; mask -&gt; long\n\t&quot;
 3809             &quot;MOV    $dst.hi, 0\n\t&quot;
 3810             &quot;AND    $dst,$dst,$mask&quot; %}
 3811   ins_encode %{
 3812     __ ldrh($dst$$Register, $mem$$Address);
 3813     __ mov($dst$$Register-&gt;successor(), 0);
 3814     __ andr($dst$$Register, $dst$$Register, $mask$$constant);
 3815   %}
 3816   ins_pipe(iload_mem);
 3817 %}
 3818 
 3819 // Load Integer
 3820 
 3821 
 3822 instruct loadI(iRegI dst, memoryI mem) %{
 3823   match(Set dst (LoadI mem));
 3824   ins_cost(MEMORY_REF_COST);
 3825 
 3826   size(4);
 3827   format %{ &quot;ldr_s32 $dst,$mem\t! int&quot; %}
 3828   ins_encode %{
 3829     __ ldr_s32($dst$$Register, $mem$$Address);
 3830   %}
 3831   ins_pipe(iload_mem);
 3832 %}
 3833 
 3834 // Load Integer to Byte (8 bit signed)
 3835 instruct loadI2B(iRegI dst, memoryS mem, immI_24 twentyfour) %{
 3836   match(Set dst (RShiftI (LShiftI (LoadI mem) twentyfour) twentyfour));
 3837   ins_cost(MEMORY_REF_COST);
 3838 
 3839   size(4);
 3840 
 3841   format %{ &quot;LDRSB   $dst,$mem\t! int -&gt; byte&quot; %}
 3842   ins_encode %{
 3843     __ ldrsb($dst$$Register, $mem$$Address);
 3844   %}
 3845   ins_pipe(iload_mask_mem);
 3846 %}
 3847 
 3848 // Load Integer to Unsigned Byte (8 bit UNsigned)
 3849 instruct loadI2UB(iRegI dst, memoryB mem, immI_255 mask) %{
 3850   match(Set dst (AndI (LoadI mem) mask));
 3851   ins_cost(MEMORY_REF_COST);
 3852 
 3853   size(4);
 3854 
 3855   format %{ &quot;LDRB   $dst,$mem\t! int -&gt; ubyte&quot; %}
 3856   ins_encode %{
 3857     __ ldrb($dst$$Register, $mem$$Address);
 3858   %}
 3859   ins_pipe(iload_mask_mem);
 3860 %}
 3861 
 3862 // Load Integer to Short (16 bit signed)
 3863 instruct loadI2S(iRegI dst, memoryS mem, immI_16 sixteen) %{
 3864   match(Set dst (RShiftI (LShiftI (LoadI mem) sixteen) sixteen));
 3865   ins_cost(MEMORY_REF_COST);
 3866 
 3867   size(4);
 3868   format %{ &quot;LDRSH   $dst,$mem\t! int -&gt; short&quot; %}
 3869   ins_encode %{
 3870     __ ldrsh($dst$$Register, $mem$$Address);
 3871   %}
 3872   ins_pipe(iload_mask_mem);
 3873 %}
 3874 
 3875 // Load Integer to Unsigned Short (16 bit UNsigned)
 3876 instruct loadI2US(iRegI dst, memoryS mem, immI_65535 mask) %{
 3877   match(Set dst (AndI (LoadI mem) mask));
 3878   ins_cost(MEMORY_REF_COST);
 3879 
 3880   size(4);
 3881   format %{ &quot;LDRH   $dst,$mem\t! int -&gt; ushort/char&quot; %}
 3882   ins_encode %{
 3883     __ ldrh($dst$$Register, $mem$$Address);
 3884   %}
 3885   ins_pipe(iload_mask_mem);
 3886 %}
 3887 
 3888 // Load Integer into a Long Register
 3889 instruct loadI2L(iRegL dst, memoryI mem) %{
 3890   match(Set dst (ConvI2L (LoadI mem)));
 3891   ins_cost(MEMORY_REF_COST);
 3892 
 3893   size(8);
 3894   format %{ &quot;LDR   $dst.lo,$mem\t! int -&gt; long\n\t&quot;
 3895             &quot;ASR   $dst.hi,$dst.lo,31\t! int-&gt;long&quot; %}
 3896   ins_encode %{
 3897     __ ldr($dst$$Register, $mem$$Address);
 3898     __ mov($dst$$Register-&gt;successor(), AsmOperand($dst$$Register, asr, 31));
 3899   %}
 3900   ins_pipe(iload_mask_mem);
 3901 %}
 3902 
 3903 // Load Integer with mask 0xFF into a Long Register
 3904 instruct loadI2L_immI_255(iRegL dst, memoryB mem, immI_255 mask) %{
 3905   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 3906   ins_cost(MEMORY_REF_COST);
 3907 
 3908   size(8);
 3909   format %{ &quot;LDRB   $dst.lo,$mem\t! int &amp; 0xFF -&gt; long\n\t&quot;
 3910             &quot;MOV    $dst.hi, 0&quot; %}
 3911   ins_encode %{
 3912     __ ldrb($dst$$Register, $mem$$Address);
 3913     __ mov($dst$$Register-&gt;successor(), 0);
 3914   %}
 3915   ins_pipe(iload_mem);
 3916 %}
 3917 
 3918 // Load Integer with mask 0xFFFF into a Long Register
 3919 instruct loadI2L_immI_65535(iRegL dst, memoryS mem, immI_65535 mask) %{
 3920   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 3921   ins_cost(MEMORY_REF_COST);
 3922 
 3923   size(8);
 3924   format %{ &quot;LDRH   $dst,$mem\t! int &amp; 0xFFFF -&gt; long\n\t&quot;
 3925             &quot;MOV    $dst.hi, 0&quot; %}
 3926   ins_encode %{
 3927     __ ldrh($dst$$Register, $mem$$Address);
 3928     __ mov($dst$$Register-&gt;successor(), 0);
 3929   %}
 3930   ins_pipe(iload_mask_mem);
 3931 %}
 3932 
 3933 // Load Integer with a 31-bit immediate mask into a Long Register
 3934 instruct loadI2L_limmU31(iRegL dst, memoryI mem, limmU31 mask) %{
 3935   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 3936   ins_cost(MEMORY_REF_COST + 2*DEFAULT_COST);
 3937 
 3938   size(12);
 3939   format %{ &quot;LDR   $dst.lo,$mem\t! int -&gt; long\n\t&quot;
 3940             &quot;MOV    $dst.hi, 0\n\t&quot;
 3941             &quot;AND   $dst,$dst,$mask&quot; %}
 3942 
 3943   ins_encode %{
 3944     __ ldr($dst$$Register, $mem$$Address);
 3945     __ mov($dst$$Register-&gt;successor(), 0);
 3946     __ andr($dst$$Register, $dst$$Register, $mask$$constant);
 3947   %}
 3948   ins_pipe(iload_mem);
 3949 %}
 3950 
 3951 // Load Integer with a 31-bit mask into a Long Register
 3952 // FIXME: use iRegI mask, remove tmp?
 3953 instruct loadI2L_immU31(iRegL dst, memoryI mem, immU31 mask, iRegI tmp) %{
 3954   match(Set dst (ConvI2L (AndI (LoadI mem) mask)));
 3955   effect(TEMP dst, TEMP tmp);
 3956 
 3957   ins_cost(MEMORY_REF_COST + 4*DEFAULT_COST);
 3958   size(20);
 3959   format %{ &quot;LDR      $mem,$dst\t! int &amp; 31-bit mask -&gt; long\n\t&quot;
 3960             &quot;MOV      $dst.hi, 0\n\t&quot;
 3961             &quot;MOV_SLOW $tmp,$mask\n\t&quot;
 3962             &quot;AND      $dst,$tmp,$dst&quot; %}
 3963   ins_encode %{
 3964     __ ldr($dst$$Register, $mem$$Address);
 3965     __ mov($dst$$Register-&gt;successor(), 0);
 3966     __ mov_slow($tmp$$Register, $mask$$constant);
 3967     __ andr($dst$$Register, $dst$$Register, $tmp$$Register);
 3968   %}
 3969   ins_pipe(iload_mem);
 3970 %}
 3971 
 3972 // Load Unsigned Integer into a Long Register
 3973 instruct loadUI2L(iRegL dst, memoryI mem, immL_32bits mask) %{
 3974   match(Set dst (AndL (ConvI2L (LoadI mem)) mask));
 3975   ins_cost(MEMORY_REF_COST);
 3976 
 3977   size(8);
 3978   format %{ &quot;LDR   $dst.lo,$mem\t! uint -&gt; long\n\t&quot;
 3979             &quot;MOV   $dst.hi,0&quot; %}
 3980   ins_encode %{
 3981     __ ldr($dst$$Register, $mem$$Address);
 3982     __ mov($dst$$Register-&gt;successor(), 0);
 3983   %}
 3984   ins_pipe(iload_mem);
 3985 %}
 3986 
 3987 // Load Long
 3988 
 3989 
 3990 instruct loadL(iRegLd dst, memoryL mem ) %{
 3991   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 3992   match(Set dst (LoadL mem));
 3993   effect(TEMP dst);
 3994   ins_cost(MEMORY_REF_COST);
 3995 
 3996   size(4);
 3997   format %{ &quot;ldr_64  $dst,$mem\t! long&quot; %}
 3998   ins_encode %{
 3999     __ ldr_64($dst$$Register, $mem$$Address);
 4000   %}
 4001   ins_pipe(iload_mem);
 4002 %}
 4003 
 4004 instruct loadL_2instr(iRegL dst, memorylong mem ) %{
 4005   predicate(!((LoadLNode*)n)-&gt;require_atomic_access());
 4006   match(Set dst (LoadL mem));
 4007   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 4008 
 4009   size(8);
 4010   format %{ &quot;LDR    $dst.lo,$mem \t! long order of instrs reversed if $dst.lo == base($mem)\n\t&quot;
 4011             &quot;LDR    $dst.hi,$mem+4 or $mem&quot; %}
 4012   ins_encode %{
 4013     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 4014     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 4015 
 4016     if ($dst$$Register == reg_to_register_object($mem$$base)) {
 4017       __ ldr($dst$$Register-&gt;successor(), Amemhi);
 4018       __ ldr($dst$$Register, Amemlo);
 4019     } else {
 4020       __ ldr($dst$$Register, Amemlo);
 4021       __ ldr($dst$$Register-&gt;successor(), Amemhi);
 4022     }
 4023   %}
 4024   ins_pipe(iload_mem);
 4025 %}
 4026 
 4027 instruct loadL_volatile(iRegL dst, indirect mem ) %{
 4028   predicate(((LoadLNode*)n)-&gt;require_atomic_access());
 4029   match(Set dst (LoadL mem));
 4030   ins_cost(MEMORY_REF_COST);
 4031 
 4032   size(4);
 4033   format %{ &quot;LDMIA    $dst,$mem\t! long&quot; %}
 4034   ins_encode %{
 4035     // FIXME: why is ldmia considered atomic?  Should be ldrexd
 4036     RegisterSet set($dst$$Register);
 4037     set = set | reg_to_register_object($dst$$reg + 1);
 4038     __ ldmia(reg_to_register_object($mem$$base), set);
 4039   %}
 4040   ins_pipe(iload_mem);
 4041 %}
 4042 
 4043 instruct loadL_volatile_fp(iRegL dst, memoryD mem ) %{
 4044   predicate(((LoadLNode*)n)-&gt;require_atomic_access());
 4045   match(Set dst (LoadL mem));
 4046   ins_cost(MEMORY_REF_COST);
 4047 
 4048   size(8);
 4049   format %{ &quot;FLDD      S14, $mem&quot;
 4050             &quot;FMRRD    $dst, S14\t! long \n&#39;t&quot; %}
 4051   ins_encode %{
 4052     __ fldd(S14, $mem$$Address);
 4053     __ fmrrd($dst$$Register, $dst$$Register-&gt;successor(), S14);
 4054   %}
 4055   ins_pipe(iload_mem);
 4056 %}
 4057 
 4058 instruct loadL_unaligned(iRegL dst, memorylong mem ) %{
 4059   match(Set dst (LoadL_unaligned mem));
 4060   ins_cost(MEMORY_REF_COST);
 4061 
 4062   size(8);
 4063   format %{ &quot;LDR    $dst.lo,$mem\t! long order of instrs reversed if $dst.lo == base($mem)\n\t&quot;
 4064             &quot;LDR    $dst.hi,$mem+4&quot; %}
 4065   ins_encode %{
 4066     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 4067     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 4068 
 4069     if ($dst$$Register == reg_to_register_object($mem$$base)) {
 4070       __ ldr($dst$$Register-&gt;successor(), Amemhi);
 4071       __ ldr($dst$$Register, Amemlo);
 4072     } else {
 4073       __ ldr($dst$$Register, Amemlo);
 4074       __ ldr($dst$$Register-&gt;successor(), Amemhi);
 4075     }
 4076   %}
 4077   ins_pipe(iload_mem);
 4078 %}
 4079 
 4080 // Load Range
 4081 instruct loadRange(iRegI dst, memoryI mem) %{
 4082   match(Set dst (LoadRange mem));
 4083   ins_cost(MEMORY_REF_COST);
 4084 
 4085   size(4);
 4086   format %{ &quot;LDR_u32 $dst,$mem\t! range&quot; %}
 4087   ins_encode %{
 4088     __ ldr_u32($dst$$Register, $mem$$Address);
 4089   %}
 4090   ins_pipe(iload_mem);
 4091 %}
 4092 
 4093 // Load Pointer
 4094 
 4095 
 4096 instruct loadP(iRegP dst, memoryP mem) %{
 4097   match(Set dst (LoadP mem));
 4098   ins_cost(MEMORY_REF_COST);
 4099   size(4);
 4100 
 4101   format %{ &quot;LDR   $dst,$mem\t! ptr&quot; %}
 4102   ins_encode %{
 4103     __ ldr($dst$$Register, $mem$$Address);
 4104   %}
 4105   ins_pipe(iload_mem);
 4106 %}
 4107 
 4108 #ifdef XXX
 4109 // FIXME XXXX
 4110 //instruct loadSP(iRegP dst, memoryP mem) %{
 4111 instruct loadSP(SPRegP dst, memoryP mem, iRegP tmp) %{
 4112   match(Set dst (LoadP mem));
 4113   effect(TEMP tmp);
 4114   ins_cost(MEMORY_REF_COST+1);
 4115   size(8);
 4116 
 4117   format %{ &quot;LDR   $tmp,$mem\t! ptr\n\t&quot;
 4118             &quot;MOV   $dst,$tmp\t! ptr&quot; %}
 4119   ins_encode %{
 4120     __ ldr($tmp$$Register, $mem$$Address);
 4121     __ mov($dst$$Register, $tmp$$Register);
 4122   %}
 4123   ins_pipe(iload_mem);
 4124 %}
 4125 #endif
 4126 
 4127 #ifdef _LP64
 4128 // Load Compressed Pointer
 4129 
 4130 // XXX This variant shouldn&#39;t be necessary if 6217251 is implemented
 4131 instruct loadNoff(iRegN dst, memoryScaledI mem, aimmX off, iRegP tmp) %{
 4132   match(Set dst (LoadN (AddP mem off)));
 4133   ins_cost(MEMORY_REF_COST + DEFAULT_COST); // assume shift/sign-extend is free
 4134   effect(TEMP tmp);
 4135   size(4 * 2);
 4136 
 4137   format %{ &quot;ldr_u32 $dst,$mem+$off\t! compressed ptr temp=$tmp&quot; %}
 4138   ins_encode %{
 4139     Register base = reg_to_register_object($mem$$base);
 4140     __ add($tmp$$Register, base, $off$$constant);
 4141     Address nmem = Address::make_raw($tmp$$reg, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 4142     __ ldr_u32($dst$$Register, nmem);
 4143   %}
 4144   ins_pipe(iload_mem);
 4145 %}
 4146 
 4147 instruct loadN(iRegN dst, memoryI mem) %{
 4148   match(Set dst (LoadN mem));
 4149   ins_cost(MEMORY_REF_COST);
 4150   size(4);
 4151 
 4152   format %{ &quot;ldr_u32 $dst,$mem\t! compressed ptr&quot; %}
 4153   ins_encode %{
 4154     __ ldr_u32($dst$$Register, $mem$$Address);
 4155   %}
 4156   ins_pipe(iload_mem);
 4157 %}
 4158 #endif
 4159 
 4160 // Load Klass Pointer
 4161 instruct loadKlass(iRegP dst, memoryI mem) %{
 4162   match(Set dst (LoadKlass mem));
 4163   ins_cost(MEMORY_REF_COST);
 4164   size(4);
 4165 
 4166   format %{ &quot;LDR   $dst,$mem\t! klass ptr&quot; %}
 4167   ins_encode %{
 4168     __ ldr($dst$$Register, $mem$$Address);
 4169   %}
 4170   ins_pipe(iload_mem);
 4171 %}
 4172 
 4173 #ifdef _LP64
 4174 // Load narrow Klass Pointer
 4175 instruct loadNKlass(iRegN dst, memoryI mem) %{
 4176   match(Set dst (LoadNKlass mem));
 4177   ins_cost(MEMORY_REF_COST);
 4178   size(4);
 4179 
 4180   format %{ &quot;ldr_u32 $dst,$mem\t! compressed klass ptr&quot; %}
 4181   ins_encode %{
 4182     __ ldr_u32($dst$$Register, $mem$$Address);
 4183   %}
 4184   ins_pipe(iload_mem);
 4185 %}
 4186 #endif
 4187 
 4188 
 4189 instruct loadD(regD dst, memoryD mem) %{
 4190   match(Set dst (LoadD mem));
 4191   ins_cost(MEMORY_REF_COST);
 4192 
 4193   size(4);
 4194   // FIXME: needs to be atomic, but  ARMv7 A.R.M. guarantees
 4195   // only LDREXD and STREXD are 64-bit single-copy atomic
 4196   format %{ &quot;FLDD   $dst,$mem&quot; %}
 4197   ins_encode %{
 4198     __ ldr_double($dst$$FloatRegister, $mem$$Address);
 4199   %}
 4200   ins_pipe(floadD_mem);
 4201 %}
 4202 
 4203 // Load Double - UNaligned
 4204 instruct loadD_unaligned(regD_low dst, memoryF2 mem ) %{
 4205   match(Set dst (LoadD_unaligned mem));
 4206   ins_cost(MEMORY_REF_COST*2+DEFAULT_COST);
 4207   size(8);
 4208   format %{ &quot;FLDS    $dst.lo,$mem\t! misaligned double\n&quot;
 4209           &quot;\tFLDS    $dst.hi,$mem+4\t!&quot; %}
 4210   ins_encode %{
 4211     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 4212     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 4213       __ flds($dst$$FloatRegister, Amemlo);
 4214       __ flds($dst$$FloatRegister-&gt;successor(), Amemhi);
 4215   %}
 4216   ins_pipe(iload_mem);
 4217 %}
 4218 
 4219 
 4220 instruct loadF(regF dst, memoryF mem) %{
 4221   match(Set dst (LoadF mem));
 4222 
 4223   ins_cost(MEMORY_REF_COST);
 4224   size(4);
 4225   format %{ &quot;FLDS    $dst,$mem&quot; %}
 4226   ins_encode %{
 4227     __ ldr_float($dst$$FloatRegister, $mem$$Address);
 4228   %}
 4229   ins_pipe(floadF_mem);
 4230 %}
 4231 
 4232 
 4233 // // Load Constant
 4234 instruct loadConI( iRegI dst, immI src ) %{
 4235   match(Set dst src);
 4236   ins_cost(DEFAULT_COST * 3/2);
 4237   format %{ &quot;MOV_SLOW    $dst, $src&quot; %}
 4238   ins_encode %{
 4239     __ mov_slow($dst$$Register, $src$$constant);
 4240   %}
 4241   ins_pipe(ialu_hi_lo_reg);
 4242 %}
 4243 
 4244 instruct loadConIMov( iRegI dst, immIMov src ) %{
 4245   match(Set dst src);
 4246   size(4);
 4247   format %{ &quot;MOV    $dst, $src&quot; %}
 4248   ins_encode %{
 4249     __ mov($dst$$Register, $src$$constant);
 4250   %}
 4251   ins_pipe(ialu_imm);
 4252 %}
 4253 
 4254 instruct loadConIMovn( iRegI dst, immIRotn src ) %{
 4255   match(Set dst src);
 4256   size(4);
 4257   format %{ &quot;MVN    $dst, ~$src&quot; %}
 4258   ins_encode %{
 4259     __ mvn($dst$$Register, ~$src$$constant);
 4260   %}
 4261   ins_pipe(ialu_imm_n);
 4262 %}
 4263 
 4264 instruct loadConI16( iRegI dst, immI16 src ) %{
 4265   match(Set dst src);
 4266   size(4);
 4267   format %{ &quot;MOVW    $dst, $src&quot; %}
 4268   ins_encode %{
 4269     __ movw($dst$$Register, $src$$constant);
 4270   %}
 4271   ins_pipe(ialu_imm_n);
 4272 %}
 4273 
 4274 instruct loadConP(iRegP dst, immP src) %{
 4275   match(Set dst src);
 4276   ins_cost(DEFAULT_COST * 3/2);
 4277   format %{ &quot;MOV_SLOW    $dst,$src\t!ptr&quot; %}
 4278   ins_encode %{
 4279     relocInfo::relocType constant_reloc = _opnds[1]-&gt;constant_reloc();
 4280     intptr_t val = $src$$constant;
 4281     if (constant_reloc == relocInfo::oop_type) {
 4282       __ mov_oop($dst$$Register, (jobject)val);
 4283     } else if (constant_reloc == relocInfo::metadata_type) {
 4284       __ mov_metadata($dst$$Register, (Metadata*)val);
 4285     } else {
 4286       __ mov_slow($dst$$Register, val);
 4287     }
 4288   %}
 4289   ins_pipe(loadConP);
 4290 %}
 4291 
 4292 
<a name="41" id="anc41"></a>









 4293 instruct loadConL(iRegL dst, immL src) %{
 4294   match(Set dst src);
 4295   ins_cost(DEFAULT_COST * 4);
 4296   format %{ &quot;MOV_SLOW   $dst.lo, $src &amp; 0x0FFFFFFFFL \t! long\n\t&quot;
 4297             &quot;MOV_SLOW   $dst.hi, $src &gt;&gt; 32&quot; %}
 4298   ins_encode %{
 4299     __ mov_slow(reg_to_register_object($dst$$reg), $src$$constant &amp; 0x0FFFFFFFFL);
 4300     __ mov_slow(reg_to_register_object($dst$$reg + 1), ((julong)($src$$constant)) &gt;&gt; 32);
 4301   %}
 4302   ins_pipe(loadConL);
 4303 %}
 4304 
 4305 instruct loadConL16( iRegL dst, immL16 src ) %{
 4306   match(Set dst src);
 4307   ins_cost(DEFAULT_COST * 2);
 4308 
 4309   size(8);
 4310   format %{ &quot;MOVW    $dst.lo, $src \n\t&quot;
 4311             &quot;MOVW    $dst.hi, 0 \n\t&quot; %}
 4312   ins_encode %{
 4313     __ movw($dst$$Register, $src$$constant);
 4314     __ movw($dst$$Register-&gt;successor(), 0);
 4315   %}
 4316   ins_pipe(ialu_imm);
 4317 %}
 4318 
 4319 instruct loadConF_imm8(regF dst, imm8F src) %{
 4320   match(Set dst src);
 4321   ins_cost(DEFAULT_COST);
 4322   size(4);
 4323 
 4324   format %{ &quot;FCONSTS      $dst, $src&quot;%}
 4325 
 4326   ins_encode %{
 4327     __ fconsts($dst$$FloatRegister, Assembler::float_num($src$$constant).imm8());
 4328   %}
 4329   ins_pipe(loadConFD); // FIXME
 4330 %}
 4331 
 4332 
 4333 instruct loadConF(regF dst, immF src, iRegI tmp) %{
 4334   match(Set dst src);
 4335   ins_cost(DEFAULT_COST * 2);
 4336   effect(TEMP tmp);
 4337   size(3*4);
 4338 
 4339   format %{ &quot;MOV_SLOW  $tmp, $src\n\t&quot;
 4340             &quot;FMSR      $dst, $tmp&quot;%}
 4341 
 4342   ins_encode %{
 4343     // FIXME revisit once 6961697 is in
 4344     union {
 4345       jfloat f;
 4346       int i;
 4347     } v;
 4348     v.f = $src$$constant;
 4349     __ mov_slow($tmp$$Register, v.i);
 4350     __ fmsr($dst$$FloatRegister, $tmp$$Register);
 4351   %}
 4352   ins_pipe(loadConFD); // FIXME
 4353 %}
 4354 
 4355 instruct loadConD_imm8(regD dst, imm8D src) %{
 4356   match(Set dst src);
 4357   ins_cost(DEFAULT_COST);
 4358   size(4);
 4359 
 4360   format %{ &quot;FCONSTD      $dst, $src&quot;%}
 4361 
 4362   ins_encode %{
 4363     __ fconstd($dst$$FloatRegister, Assembler::double_num($src$$constant).imm8());
 4364   %}
 4365   ins_pipe(loadConFD); // FIXME
 4366 %}
 4367 
 4368 instruct loadConD(regD dst, immD src, iRegP tmp) %{
 4369   match(Set dst src);
 4370   effect(TEMP tmp);
 4371   ins_cost(MEMORY_REF_COST);
 4372   format %{ &quot;FLDD  $dst, [$constanttablebase + $constantoffset]\t! load from constant table: double=$src&quot; %}
 4373 
 4374   ins_encode %{
 4375     Register r = $constanttablebase;
 4376     int offset  = $constantoffset($src);
 4377     if (!is_memoryD(offset)) {                // can&#39;t use a predicate
 4378                                               // in load constant instructs
 4379       __ add_slow($tmp$$Register, r, offset);
 4380       r = $tmp$$Register;
 4381       offset = 0;
 4382     }
 4383     __ ldr_double($dst$$FloatRegister, Address(r, offset));
 4384   %}
 4385   ins_pipe(loadConFD);
 4386 %}
 4387 
 4388 // Prefetch instructions.
 4389 // Must be safe to execute with invalid address (cannot fault).
 4390 
 4391 instruct prefetchAlloc_mp( memoryP mem ) %{
 4392   predicate(VM_Version::has_multiprocessing_extensions());
 4393   match( PrefetchAllocation mem );
 4394   ins_cost(MEMORY_REF_COST);
 4395   size(4);
 4396 
 4397   format %{ &quot;PLDW $mem\t! Prefetch allocation&quot; %}
 4398   ins_encode %{
 4399     __ pldw($mem$$Address);
 4400   %}
 4401   ins_pipe(iload_mem);
 4402 %}
 4403 
 4404 instruct prefetchAlloc_sp( memoryP mem ) %{
 4405   predicate(!VM_Version::has_multiprocessing_extensions());
 4406   match( PrefetchAllocation mem );
 4407   ins_cost(MEMORY_REF_COST);
 4408   size(4);
 4409 
 4410   format %{ &quot;PLD $mem\t! Prefetch allocation&quot; %}
 4411   ins_encode %{
 4412     __ pld($mem$$Address);
 4413   %}
 4414   ins_pipe(iload_mem);
 4415 %}
 4416 
 4417 
 4418 //----------Store Instructions-------------------------------------------------
 4419 // Store Byte
 4420 instruct storeB(memoryB mem, store_RegI src) %{
 4421   match(Set mem (StoreB mem src));
 4422   ins_cost(MEMORY_REF_COST);
 4423 
 4424   size(4);
 4425   format %{ &quot;STRB    $src,$mem\t! byte&quot; %}
 4426   ins_encode %{
 4427     __ strb($src$$Register, $mem$$Address);
 4428   %}
 4429   ins_pipe(istore_mem_reg);
 4430 %}
 4431 
 4432 instruct storeCM(memoryB mem, store_RegI src) %{
 4433   match(Set mem (StoreCM mem src));
 4434   ins_cost(MEMORY_REF_COST);
 4435 
 4436   size(4);
 4437   format %{ &quot;STRB    $src,$mem\t! CMS card-mark byte&quot; %}
 4438   ins_encode %{
 4439     __ strb($src$$Register, $mem$$Address);
 4440   %}
 4441   ins_pipe(istore_mem_reg);
 4442 %}
 4443 
 4444 // Store Char/Short
 4445 
 4446 
 4447 instruct storeC(memoryS mem, store_RegI src) %{
 4448   match(Set mem (StoreC mem src));
 4449   ins_cost(MEMORY_REF_COST);
 4450 
 4451   size(4);
 4452   format %{ &quot;STRH    $src,$mem\t! short&quot; %}
 4453   ins_encode %{
 4454     __ strh($src$$Register, $mem$$Address);
 4455   %}
 4456   ins_pipe(istore_mem_reg);
 4457 %}
 4458 
 4459 // Store Integer
 4460 
 4461 
 4462 instruct storeI(memoryI mem, store_RegI src) %{
 4463   match(Set mem (StoreI mem src));
 4464   ins_cost(MEMORY_REF_COST);
 4465 
 4466   size(4);
 4467   format %{ &quot;str_32 $src,$mem&quot; %}
 4468   ins_encode %{
 4469     __ str_32($src$$Register, $mem$$Address);
 4470   %}
 4471   ins_pipe(istore_mem_reg);
 4472 %}
 4473 
 4474 // Store Long
 4475 
 4476 
 4477 instruct storeL(memoryL mem, store_RegLd src) %{
 4478   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 4479   match(Set mem (StoreL mem src));
 4480   ins_cost(MEMORY_REF_COST);
 4481 
 4482   size(4);
 4483   format %{ &quot;str_64  $src,$mem\t! long\n\t&quot; %}
 4484 
 4485   ins_encode %{
 4486     __ str_64($src$$Register, $mem$$Address);
 4487   %}
 4488   ins_pipe(istore_mem_reg);
 4489 %}
 4490 
 4491 instruct storeL_2instr(memorylong mem, iRegL src) %{
 4492   predicate(!((StoreLNode*)n)-&gt;require_atomic_access());
 4493   match(Set mem (StoreL mem src));
 4494   ins_cost(MEMORY_REF_COST + DEFAULT_COST);
 4495 
 4496   size(8);
 4497   format %{ &quot;STR    $src.lo,$mem\t! long\n\t&quot;
 4498             &quot;STR    $src.hi,$mem+4&quot; %}
 4499 
 4500   ins_encode %{
 4501     Address Amemlo = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp, relocInfo::none);
 4502     Address Amemhi = Address::make_raw($mem$$base, $mem$$index, $mem$$scale, $mem$$disp + 4, relocInfo::none);
 4503     __ str($src$$Register, Amemlo);
 4504     __ str($src$$Register-&gt;successor(), Amemhi);
 4505   %}
 4506   ins_pipe(istore_mem_reg);
 4507 %}
 4508 
 4509 instruct storeL_volatile(indirect mem, iRegL src) %{
 4510   predicate(((StoreLNode*)n)-&gt;require_atomic_access());
 4511   match(Set mem (StoreL mem src));
 4512   ins_cost(MEMORY_REF_COST);
 4513   size(4);
 4514   format %{ &quot;STMIA    $src,$mem\t! long&quot; %}
 4515   ins_encode %{
 4516     // FIXME: why is stmia considered atomic?  Should be strexd
 4517     RegisterSet set($src$$Register);
 4518     set = set | reg_to_register_object($src$$reg + 1);
 4519     __ stmia(reg_to_register_object($mem$$base), set);
 4520   %}
 4521   ins_pipe(istore_mem_reg);
 4522 %}
 4523 
 4524 instruct storeL_volatile_fp(memoryD mem, iRegL src) %{
 4525   predicate(((StoreLNode*)n)-&gt;require_atomic_access());
 4526   match(Set mem (StoreL mem src));
 4527   ins_cost(MEMORY_REF_COST);
 4528   size(8);
 4529   format %{ &quot;FMDRR    S14, $src\t! long \n\t&quot;
 4530             &quot;FSTD     S14, $mem&quot; %}
 4531   ins_encode %{
 4532     __ fmdrr(S14, $src$$Register, $src$$Register-&gt;successor());
 4533     __ fstd(S14, $mem$$Address);
 4534   %}
 4535   ins_pipe(istore_mem_reg);
 4536 %}
 4537 
 4538 #ifdef XXX
 4539 // Move SP Pointer
 4540 //instruct movSP(sp_ptr_RegP dst, SPRegP src) %{
 4541 //instruct movSP(iRegP dst, SPRegP src) %{
 4542 instruct movSP(store_ptr_RegP dst, SPRegP src) %{
 4543   match(Set dst src);
 4544 //predicate(!_kids[1]-&gt;_leaf-&gt;is_Proj() || _kids[1]-&gt;_leaf-&gt;as_Proj()-&gt;_con == TypeFunc::FramePtr);
 4545   ins_cost(MEMORY_REF_COST);
 4546   size(4);
 4547 
 4548   format %{ &quot;MOV    $dst,$src\t! SP ptr\n\t&quot; %}
 4549   ins_encode %{
 4550     assert(false, &quot;XXX1 got here&quot;);
 4551     __ mov($dst$$Register, SP);
 4552     __ mov($dst$$Register, $src$$Register);
 4553   %}
 4554   ins_pipe(ialu_reg);
 4555 %}
 4556 #endif
 4557 
 4558 
 4559 // Store Pointer
 4560 
 4561 
 4562 instruct storeP(memoryP mem, store_ptr_RegP src) %{
 4563   match(Set mem (StoreP mem src));
 4564   ins_cost(MEMORY_REF_COST);
 4565   size(4);
 4566 
 4567   format %{ &quot;STR    $src,$mem\t! ptr&quot; %}
 4568   ins_encode %{
 4569     __ str($src$$Register, $mem$$Address);
 4570   %}
 4571   ins_pipe(istore_mem_spORreg);
 4572 %}
 4573 
 4574 
 4575 #ifdef _LP64
 4576 // Store Compressed Pointer
 4577 
 4578 
 4579 instruct storeN(memoryI mem, store_RegN src) %{
 4580   match(Set mem (StoreN mem src));
 4581   ins_cost(MEMORY_REF_COST);
 4582   size(4);
 4583 
 4584   format %{ &quot;str_32 $src,$mem\t! compressed ptr&quot; %}
 4585   ins_encode %{
 4586     __ str_32($src$$Register, $mem$$Address);
 4587   %}
 4588   ins_pipe(istore_mem_reg);
 4589 %}
 4590 
 4591 
 4592 // Store Compressed Klass Pointer
 4593 instruct storeNKlass(memoryI mem, store_RegN src) %{
 4594   match(Set mem (StoreNKlass mem src));
 4595   ins_cost(MEMORY_REF_COST);
 4596   size(4);
 4597 
 4598   format %{ &quot;str_32 $src,$mem\t! compressed klass ptr&quot; %}
 4599   ins_encode %{
 4600     __ str_32($src$$Register, $mem$$Address);
 4601   %}
 4602   ins_pipe(istore_mem_reg);
 4603 %}
 4604 #endif
 4605 
 4606 // Store Double
 4607 
 4608 
 4609 instruct storeD(memoryD mem, regD src) %{
 4610   match(Set mem (StoreD mem src));
 4611   ins_cost(MEMORY_REF_COST);
 4612 
 4613   size(4);
 4614   // FIXME: needs to be atomic, but  ARMv7 A.R.M. guarantees
 4615   // only LDREXD and STREXD are 64-bit single-copy atomic
 4616   format %{ &quot;FSTD   $src,$mem&quot; %}
 4617   ins_encode %{
 4618     __ str_double($src$$FloatRegister, $mem$$Address);
 4619   %}
 4620   ins_pipe(fstoreD_mem_reg);
 4621 %}
 4622 
 4623 
 4624 // Store Float
 4625 
 4626 
 4627 instruct storeF( memoryF mem, regF src) %{
 4628   match(Set mem (StoreF mem src));
 4629   ins_cost(MEMORY_REF_COST);
 4630 
 4631   size(4);
 4632   format %{ &quot;FSTS    $src,$mem&quot; %}
 4633   ins_encode %{
 4634     __ str_float($src$$FloatRegister, $mem$$Address);
 4635   %}
 4636   ins_pipe(fstoreF_mem_reg);
 4637 %}
 4638 
 4639 
 4640 //----------MemBar Instructions-----------------------------------------------
 4641 // Memory barrier flavors
 4642 
 4643 // pattern-match out unnecessary membars
 4644 instruct membar_storestore() %{
 4645   match(MemBarStoreStore);
 4646   ins_cost(4*MEMORY_REF_COST);
 4647 
 4648   size(4);
 4649   format %{ &quot;MEMBAR-storestore&quot; %}
 4650   ins_encode %{
 4651     __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore), noreg);
 4652   %}
 4653   ins_pipe(long_memory_op);
 4654 %}
 4655 
 4656 instruct membar_acquire() %{
 4657   match(MemBarAcquire);
 4658   match(LoadFence);
 4659   ins_cost(4*MEMORY_REF_COST);
 4660 
 4661   size(4);
 4662   format %{ &quot;MEMBAR-acquire&quot; %}
 4663   ins_encode %{
 4664     __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadLoad | MacroAssembler::LoadStore), noreg);
 4665   %}
 4666   ins_pipe(long_memory_op);
 4667 %}
 4668 
 4669 instruct membar_acquire_lock() %{
 4670   match(MemBarAcquireLock);
 4671   ins_cost(0);
 4672 
 4673   size(0);
 4674   format %{ &quot;!MEMBAR-acquire (CAS in prior FastLock so empty encoding)&quot; %}
 4675   ins_encode( );
 4676   ins_pipe(empty);
 4677 %}
 4678 
 4679 instruct membar_release() %{
 4680   match(MemBarRelease);
 4681   match(StoreFence);
 4682   ins_cost(4*MEMORY_REF_COST);
 4683 
 4684   size(4);
 4685   format %{ &quot;MEMBAR-release&quot; %}
 4686   ins_encode %{
 4687     __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::StoreStore | MacroAssembler::LoadStore), noreg);
 4688   %}
 4689   ins_pipe(long_memory_op);
 4690 %}
 4691 
 4692 instruct membar_release_lock() %{
 4693   match(MemBarReleaseLock);
 4694   ins_cost(0);
 4695 
 4696   size(0);
 4697   format %{ &quot;!MEMBAR-release (CAS in succeeding FastUnlock so empty encoding)&quot; %}
 4698   ins_encode( );
 4699   ins_pipe(empty);
 4700 %}
 4701 
 4702 instruct membar_volatile() %{
 4703   match(MemBarVolatile);
 4704   ins_cost(4*MEMORY_REF_COST);
 4705 
 4706   size(4);
 4707   format %{ &quot;MEMBAR-volatile&quot; %}
 4708   ins_encode %{
 4709     __ membar(MacroAssembler::StoreLoad, noreg);
 4710   %}
 4711   ins_pipe(long_memory_op);
 4712 %}
 4713 
 4714 instruct unnecessary_membar_volatile() %{
 4715   match(MemBarVolatile);
 4716   predicate(Matcher::post_store_load_barrier(n));
 4717   ins_cost(0);
 4718 
 4719   size(0);
 4720   format %{ &quot;!MEMBAR-volatile (unnecessary so empty encoding)&quot; %}
 4721   ins_encode( );
 4722   ins_pipe(empty);
 4723 %}
 4724 
 4725 //----------Register Move Instructions-----------------------------------------
 4726 // instruct roundDouble_nop(regD dst) %{
 4727 //   match(Set dst (RoundDouble dst));
 4728 //   ins_pipe(empty);
 4729 // %}
 4730 
 4731 
 4732 // instruct roundFloat_nop(regF dst) %{
 4733 //   match(Set dst (RoundFloat dst));
 4734 //   ins_pipe(empty);
 4735 // %}
 4736 
 4737 
 4738 
 4739 // Cast Index to Pointer for unsafe natives
 4740 instruct castX2P(iRegX src, iRegP dst) %{
 4741   match(Set dst (CastX2P src));
 4742 
 4743   format %{ &quot;MOV    $dst,$src\t! IntX-&gt;Ptr if $dst != $src&quot; %}
 4744   ins_encode %{
 4745     if ($dst$$Register !=  $src$$Register) {
 4746       __ mov($dst$$Register, $src$$Register);
 4747     }
 4748   %}
 4749   ins_pipe(ialu_reg);
 4750 %}
 4751 
 4752 // Cast Pointer to Index for unsafe natives
 4753 instruct castP2X(iRegP src, iRegX dst) %{
 4754   match(Set dst (CastP2X src));
 4755 
 4756   format %{ &quot;MOV    $dst,$src\t! Ptr-&gt;IntX if $dst != $src&quot; %}
 4757   ins_encode %{
 4758     if ($dst$$Register !=  $src$$Register) {
 4759       __ mov($dst$$Register, $src$$Register);
 4760     }
 4761   %}
 4762   ins_pipe(ialu_reg);
 4763 %}
 4764 
 4765 //----------Conditional Move---------------------------------------------------
 4766 // Conditional move
 4767 instruct cmovIP_reg(cmpOpP cmp, flagsRegP pcc, iRegI dst, iRegI src) %{
 4768   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 4769   ins_cost(150);
 4770   size(4);
 4771   format %{ &quot;MOV$cmp  $dst,$src\t! int&quot; %}
 4772   ins_encode %{
 4773     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4774   %}
 4775   ins_pipe(ialu_reg);
 4776 %}
 4777 
 4778 
 4779 instruct cmovIP_immMov(cmpOpP cmp, flagsRegP pcc, iRegI dst, immIMov src) %{
 4780   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 4781   ins_cost(140);
 4782   size(4);
 4783   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4784   ins_encode %{
 4785     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4786   %}
 4787   ins_pipe(ialu_imm);
 4788 %}
 4789 
 4790 instruct cmovIP_imm16(cmpOpP cmp, flagsRegP pcc, iRegI dst, immI16 src) %{
 4791   match(Set dst (CMoveI (Binary cmp pcc) (Binary dst src)));
 4792   ins_cost(140);
 4793   size(4);
 4794   format %{ &quot;MOVw$cmp  $dst,$src&quot; %}
 4795   ins_encode %{
 4796     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4797   %}
 4798   ins_pipe(ialu_imm);
 4799 %}
 4800 
 4801 instruct cmovI_reg(cmpOp cmp, flagsReg icc, iRegI dst, iRegI src) %{
 4802   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4803   ins_cost(150);
 4804   size(4);
 4805   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4806   ins_encode %{
 4807     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4808   %}
 4809   ins_pipe(ialu_reg);
 4810 %}
 4811 
 4812 
 4813 instruct cmovI_immMov(cmpOp cmp, flagsReg icc, iRegI dst, immIMov src) %{
 4814   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4815   ins_cost(140);
 4816   size(4);
 4817   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4818   ins_encode %{
 4819     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4820   %}
 4821   ins_pipe(ialu_imm);
 4822 %}
 4823 
 4824 instruct cmovII_imm16(cmpOp cmp, flagsReg icc, iRegI dst, immI16 src) %{
 4825   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4826   ins_cost(140);
 4827   size(4);
 4828   format %{ &quot;MOVw$cmp  $dst,$src&quot; %}
 4829   ins_encode %{
 4830     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4831   %}
 4832   ins_pipe(ialu_imm);
 4833 %}
 4834 
 4835 instruct cmovII_reg_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegI dst, iRegI src) %{
 4836   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4837   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 4838             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4839             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4840             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 4841   ins_cost(150);
 4842   size(4);
 4843   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4844   ins_encode %{
 4845     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4846   %}
 4847   ins_pipe(ialu_reg);
 4848 %}
 4849 
 4850 instruct cmovII_immMov_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegI dst, immIMov src) %{
 4851   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4852   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 4853             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4854             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4855             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 4856   ins_cost(140);
 4857   size(4);
 4858   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4859   ins_encode %{
 4860     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4861   %}
 4862   ins_pipe(ialu_imm);
 4863 %}
 4864 
 4865 instruct cmovII_imm16_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegI dst, immI16 src) %{
 4866   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4867   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 4868             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4869             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4870             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 4871   ins_cost(140);
 4872   size(4);
 4873   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 4874   ins_encode %{
 4875     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4876   %}
 4877   ins_pipe(ialu_imm);
 4878 %}
 4879 
 4880 instruct cmovIIu_reg(cmpOpU cmp, flagsRegU icc, iRegI dst, iRegI src) %{
 4881   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4882   ins_cost(150);
 4883   size(4);
 4884   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4885   ins_encode %{
 4886     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4887   %}
 4888   ins_pipe(ialu_reg);
 4889 %}
 4890 
 4891 instruct cmovIIu_immMov(cmpOpU cmp, flagsRegU icc, iRegI dst, immIMov src) %{
 4892   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4893   ins_cost(140);
 4894   size(4);
 4895   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4896   ins_encode %{
 4897     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4898   %}
 4899   ins_pipe(ialu_imm);
 4900 %}
 4901 
 4902 instruct cmovIIu_imm16(cmpOpU cmp, flagsRegU icc, iRegI dst, immI16 src) %{
 4903   match(Set dst (CMoveI (Binary cmp icc) (Binary dst src)));
 4904   ins_cost(140);
 4905   size(4);
 4906   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 4907   ins_encode %{
 4908     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4909   %}
 4910   ins_pipe(ialu_imm);
 4911 %}
 4912 
 4913 // Conditional move
 4914 instruct cmovPP_reg(cmpOpP cmp, flagsRegP pcc, iRegP dst, iRegP src) %{
 4915   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 4916   ins_cost(150);
 4917   size(4);
 4918   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4919   ins_encode %{
 4920     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4921   %}
 4922   ins_pipe(ialu_reg);
 4923 %}
 4924 
 4925 instruct cmovPP_imm(cmpOpP cmp, flagsRegP pcc, iRegP dst, immP0 src) %{
 4926   match(Set dst (CMoveP (Binary cmp pcc) (Binary dst src)));
 4927   ins_cost(140);
 4928   size(4);
 4929   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 4930   ins_encode %{
 4931     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4932   %}
 4933   ins_pipe(ialu_imm);
 4934 %}
 4935 
 4936 // This instruction also works with CmpN so we don&#39;t need cmovPN_reg.
 4937 instruct cmovPI_reg(cmpOp cmp, flagsReg icc, iRegP dst, iRegP src) %{
 4938   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 4939   ins_cost(150);
 4940 
 4941   size(4);
 4942   format %{ &quot;MOV$cmp  $dst,$src\t! ptr&quot; %}
 4943   ins_encode %{
 4944     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4945   %}
 4946   ins_pipe(ialu_reg);
 4947 %}
 4948 
 4949 instruct cmovPI_reg_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegP dst, iRegP src) %{
 4950   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 4951   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 4952             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4953             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4954             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 4955   ins_cost(150);
 4956 
 4957   size(4);
 4958   format %{ &quot;MOV$cmp  $dst,$src\t! ptr&quot; %}
 4959   ins_encode %{
 4960     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4961   %}
 4962   ins_pipe(ialu_reg);
 4963 %}
 4964 
 4965 instruct cmovPIu_reg(cmpOpU cmp, flagsRegU icc, iRegP dst, iRegP src) %{
 4966   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 4967   ins_cost(150);
 4968 
 4969   size(4);
 4970   format %{ &quot;MOV$cmp  $dst,$src\t! ptr&quot; %}
 4971   ins_encode %{
 4972     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 4973   %}
 4974   ins_pipe(ialu_reg);
 4975 %}
 4976 
 4977 instruct cmovPI_imm(cmpOp cmp, flagsReg icc, iRegP dst, immP0 src) %{
 4978   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 4979   ins_cost(140);
 4980 
 4981   size(4);
 4982   format %{ &quot;MOV$cmp  $dst,$src\t! ptr&quot; %}
 4983   ins_encode %{
 4984     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 4985   %}
 4986   ins_pipe(ialu_imm);
 4987 %}
 4988 
 4989 instruct cmovPI_imm_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegP dst, immP0 src) %{
 4990   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 4991   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 4992             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 4993             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 4994             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 4995   ins_cost(140);
 4996 
 4997   size(4);
 4998   format %{ &quot;MOV$cmp  $dst,$src\t! ptr&quot; %}
 4999   ins_encode %{
 5000     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5001   %}
 5002   ins_pipe(ialu_imm);
 5003 %}
 5004 
 5005 instruct cmovPIu_imm(cmpOpU cmp, flagsRegU icc, iRegP dst, immP0 src) %{
 5006   match(Set dst (CMoveP (Binary cmp icc) (Binary dst src)));
 5007   ins_cost(140);
 5008 
 5009   size(4);
 5010   format %{ &quot;MOV$cmp  $dst,$src\t! ptr&quot; %}
 5011   ins_encode %{
 5012     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5013   %}
 5014   ins_pipe(ialu_imm);
 5015 %}
 5016 
 5017 
 5018 // Conditional move
 5019 instruct cmovFP_reg(cmpOpP cmp, flagsRegP pcc, regF dst, regF src) %{
 5020   match(Set dst (CMoveF (Binary cmp pcc) (Binary dst src)));
 5021   ins_cost(150);
 5022   size(4);
 5023   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 5024   ins_encode %{
 5025     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5026   %}
 5027   ins_pipe(int_conditional_float_move);
 5028 %}
 5029 
 5030 instruct cmovFI_reg(cmpOp cmp, flagsReg icc, regF dst, regF src) %{
 5031   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 5032   ins_cost(150);
 5033 
 5034   size(4);
 5035   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 5036   ins_encode %{
 5037     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5038   %}
 5039   ins_pipe(int_conditional_float_move);
 5040 %}
 5041 
 5042 instruct cmovFI_reg_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, regF dst, regF src) %{
 5043   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 5044   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 5045             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 5046             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 5047             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5048   ins_cost(150);
 5049 
 5050   size(4);
 5051   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 5052   ins_encode %{
 5053     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5054   %}
 5055   ins_pipe(int_conditional_float_move);
 5056 %}
 5057 
 5058 instruct cmovFIu_reg(cmpOpU cmp, flagsRegU icc, regF dst, regF src) %{
 5059   match(Set dst (CMoveF (Binary cmp icc) (Binary dst src)));
 5060   ins_cost(150);
 5061 
 5062   size(4);
 5063   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 5064   ins_encode %{
 5065     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5066   %}
 5067   ins_pipe(int_conditional_float_move);
 5068 %}
 5069 
 5070 // Conditional move
 5071 instruct cmovDP_reg(cmpOpP cmp, flagsRegP pcc, regD dst, regD src) %{
 5072   match(Set dst (CMoveD (Binary cmp pcc) (Binary dst src)));
 5073   ins_cost(150);
 5074   size(4);
 5075   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 5076   ins_encode %{
 5077     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5078   %}
 5079   ins_pipe(int_conditional_double_move);
 5080 %}
 5081 
 5082 instruct cmovDI_reg(cmpOp cmp, flagsReg icc, regD dst, regD src) %{
 5083   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 5084   ins_cost(150);
 5085 
 5086   size(4);
 5087   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 5088   ins_encode %{
 5089     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5090   %}
 5091   ins_pipe(int_conditional_double_move);
 5092 %}
 5093 
 5094 instruct cmovDI_reg_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, regD dst, regD src) %{
 5095   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 5096   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5097   ins_cost(150);
 5098 
 5099   size(4);
 5100   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 5101   ins_encode %{
 5102     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5103   %}
 5104   ins_pipe(int_conditional_double_move);
 5105 %}
 5106 
 5107 instruct cmovDIu_reg(cmpOpU cmp, flagsRegU icc, regD dst, regD src) %{
 5108   match(Set dst (CMoveD (Binary cmp icc) (Binary dst src)));
 5109   ins_cost(150);
 5110 
 5111   size(4);
 5112   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 5113   ins_encode %{
 5114     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 5115   %}
 5116   ins_pipe(int_conditional_double_move);
 5117 %}
 5118 
 5119 // Conditional move
 5120 instruct cmovLP_reg(cmpOpP cmp, flagsRegP pcc, iRegL dst, iRegL src) %{
 5121   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 5122   ins_cost(150);
 5123 
 5124   size(8);
 5125   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 5126             &quot;MOV$cmp  $dst.hi,$src.hi&quot; %}
 5127   ins_encode %{
 5128     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 5129     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 5130   %}
 5131   ins_pipe(ialu_reg);
 5132 %}
 5133 
 5134 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 5135 // (hi($con$$constant), lo($con$$constant)) becomes
 5136 instruct cmovLP_immRot(cmpOpP cmp, flagsRegP pcc, iRegL dst, immLlowRot src) %{
 5137   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 5138   ins_cost(140);
 5139 
 5140   size(8);
 5141   format %{ &quot;MOV$cmp  $dst.lo,$src\t! long\n\t&quot;
 5142             &quot;MOV$cmp  $dst.hi,0&quot; %}
 5143   ins_encode %{
 5144     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5145     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 5146   %}
 5147   ins_pipe(ialu_imm);
 5148 %}
 5149 
 5150 instruct cmovLP_imm16(cmpOpP cmp, flagsRegP pcc, iRegL dst, immL16 src) %{
 5151   match(Set dst (CMoveL (Binary cmp pcc) (Binary dst src)));
 5152   ins_cost(140);
 5153 
 5154   size(8);
 5155   format %{ &quot;MOV$cmp  $dst.lo,$src\t! long\n\t&quot;
 5156             &quot;MOV$cmp  $dst.hi,0&quot; %}
 5157   ins_encode %{
 5158     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5159     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 5160   %}
 5161   ins_pipe(ialu_imm);
 5162 %}
 5163 
 5164 instruct cmovLI_reg(cmpOp cmp, flagsReg icc, iRegL dst, iRegL src) %{
 5165   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5166   ins_cost(150);
 5167 
 5168   size(8);
 5169   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 5170             &quot;MOV$cmp  $dst.hi,$src.hi&quot; %}
 5171   ins_encode %{
 5172     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 5173     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 5174   %}
 5175   ins_pipe(ialu_reg);
 5176 %}
 5177 
 5178 instruct cmovLI_reg_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegL dst, iRegL src) %{
 5179   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5180   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 5181             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 5182             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 5183             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5184   ins_cost(150);
 5185 
 5186   size(8);
 5187   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 5188             &quot;MOV$cmp  $dst.hi,$src.hi&quot; %}
 5189   ins_encode %{
 5190     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 5191     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 5192   %}
 5193   ins_pipe(ialu_reg);
 5194 %}
 5195 
 5196 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 5197 // (hi($con$$constant), lo($con$$constant)) becomes
 5198 instruct cmovLI_immRot(cmpOp cmp, flagsReg icc, iRegL dst, immLlowRot src) %{
 5199   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5200   ins_cost(140);
 5201 
 5202   size(8);
 5203   format %{ &quot;MOV$cmp  $dst.lo,$src\t! long\n\t&quot;
 5204             &quot;MOV$cmp  $dst.hi,0&quot; %}
 5205   ins_encode %{
 5206     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5207     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 5208   %}
 5209   ins_pipe(ialu_imm);
 5210 %}
 5211 
 5212 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 5213 // (hi($con$$constant), lo($con$$constant)) becomes
 5214 instruct cmovLI_immRot_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegL dst, immLlowRot src) %{
 5215   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5216   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 5217             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 5218             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 5219             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5220   ins_cost(140);
 5221 
 5222   size(8);
 5223   format %{ &quot;MOV$cmp  $dst.lo,$src\t! long\n\t&quot;
 5224             &quot;MOV$cmp  $dst.hi,0&quot; %}
 5225   ins_encode %{
 5226     __ mov($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5227     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 5228   %}
 5229   ins_pipe(ialu_imm);
 5230 %}
 5231 
 5232 instruct cmovLI_imm16(cmpOp cmp, flagsReg icc, iRegL dst, immL16 src) %{
 5233   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5234   ins_cost(140);
 5235 
 5236   size(8);
 5237   format %{ &quot;MOV$cmp  $dst.lo,$src\t! long\n\t&quot;
 5238             &quot;MOV$cmp  $dst.hi,0&quot; %}
 5239   ins_encode %{
 5240     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5241     __ movw($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 5242   %}
 5243   ins_pipe(ialu_imm);
 5244 %}
 5245 
 5246 instruct cmovLI_imm16_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, iRegL dst, immL16 src) %{
 5247   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5248   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq ||
 5249             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne ||
 5250             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt ||
 5251             _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 5252   ins_cost(140);
 5253 
 5254   size(8);
 5255   format %{ &quot;MOV$cmp  $dst.lo,$src\t! long\n\t&quot;
 5256             &quot;MOV$cmp  $dst.hi,0&quot; %}
 5257   ins_encode %{
 5258     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 5259     __ movw($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 5260   %}
 5261   ins_pipe(ialu_imm);
 5262 %}
 5263 
 5264 instruct cmovLIu_reg(cmpOpU cmp, flagsRegU icc, iRegL dst, iRegL src) %{
 5265   match(Set dst (CMoveL (Binary cmp icc) (Binary dst src)));
 5266   ins_cost(150);
 5267 
 5268   size(8);
 5269   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 5270             &quot;MOV$cmp  $dst.hi,$src.hi&quot; %}
 5271   ins_encode %{
 5272     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 5273     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 5274   %}
 5275   ins_pipe(ialu_reg);
 5276 %}
 5277 
 5278 
 5279 //----------OS and Locking Instructions----------------------------------------
 5280 
 5281 // This name is KNOWN by the ADLC and cannot be changed.
 5282 // The ADLC forces a &#39;TypeRawPtr::BOTTOM&#39; output type
 5283 // for this guy.
 5284 instruct tlsLoadP(RthreadRegP dst) %{
 5285   match(Set dst (ThreadLocal));
 5286 
 5287   size(0);
 5288   ins_cost(0);
 5289   format %{ &quot;! TLS is in $dst&quot; %}
 5290   ins_encode( /*empty encoding*/ );
 5291   ins_pipe(ialu_none);
 5292 %}
 5293 
 5294 instruct checkCastPP( iRegP dst ) %{
 5295   match(Set dst (CheckCastPP dst));
 5296 
 5297   size(0);
 5298   format %{ &quot;! checkcastPP of $dst&quot; %}
 5299   ins_encode( /*empty encoding*/ );
 5300   ins_pipe(empty);
 5301 %}
 5302 
 5303 
 5304 instruct castPP( iRegP dst ) %{
 5305   match(Set dst (CastPP dst));
 5306   format %{ &quot;! castPP of $dst&quot; %}
 5307   ins_encode( /*empty encoding*/ );
 5308   ins_pipe(empty);
 5309 %}
 5310 
 5311 instruct castII( iRegI dst ) %{
 5312   match(Set dst (CastII dst));
 5313   format %{ &quot;! castII of $dst&quot; %}
 5314   ins_encode( /*empty encoding*/ );
 5315   ins_cost(0);
 5316   ins_pipe(empty);
 5317 %}
 5318 
 5319 instruct castLL( iRegL dst ) %{
 5320   match(Set dst (CastLL dst));
 5321   format %{ &quot;! castLL of $dst&quot; %}
 5322   ins_encode( /*empty encoding*/ );
 5323   ins_cost(0);
 5324   ins_pipe(empty);
 5325 %}
 5326 
 5327 //----------Arithmetic Instructions--------------------------------------------
 5328 // Addition Instructions
 5329 // Register Addition
 5330 instruct addI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 5331   match(Set dst (AddI src1 src2));
 5332 
 5333   size(4);
 5334   format %{ &quot;add_32 $dst,$src1,$src2\t! int&quot; %}
 5335   ins_encode %{
 5336     __ add_32($dst$$Register, $src1$$Register, $src2$$Register);
 5337   %}
 5338   ins_pipe(ialu_reg_reg);
 5339 %}
 5340 
 5341 instruct addshlI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5342   match(Set dst (AddI (LShiftI src1 src2) src3));
 5343 
 5344   size(4);
 5345   format %{ &quot;add_32 $dst,$src3,$src1&lt;&lt;$src2\t! int&quot; %}
 5346   ins_encode %{
 5347     __ add_32($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsl, $src2$$Register));
 5348   %}
 5349   ins_pipe(ialu_reg_reg);
 5350 %}
 5351 
 5352 
 5353 instruct addshlI_reg_imm_reg(iRegI dst, iRegI src1, immU5 src2, iRegI src3) %{
 5354   match(Set dst (AddI (LShiftI src1 src2) src3));
 5355 
 5356   size(4);
 5357   format %{ &quot;add_32 $dst,$src3,$src1&lt;&lt;$src2\t! int&quot; %}
 5358   ins_encode %{
 5359     __ add_32($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsl, $src2$$constant));
 5360   %}
 5361   ins_pipe(ialu_reg_reg);
 5362 %}
 5363 
 5364 instruct addsarI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5365   match(Set dst (AddI (RShiftI src1 src2) src3));
 5366 
 5367   size(4);
 5368   format %{ &quot;add_32 $dst,$src3,$src1&gt;&gt;$src2\t! int&quot; %}
 5369   ins_encode %{
 5370     __ add_32($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, asr, $src2$$Register));
 5371   %}
 5372   ins_pipe(ialu_reg_reg);
 5373 %}
 5374 
 5375 instruct addsarI_reg_imm_reg(iRegI dst, iRegI src1, immU5 src2, iRegI src3) %{
 5376   match(Set dst (AddI (RShiftI src1 src2) src3));
 5377 
 5378   size(4);
 5379   format %{ &quot;add_32 $dst,$src3,$src1&gt;&gt;$src2\t! int&quot; %}
 5380   ins_encode %{
 5381     __ add_32($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, asr, $src2$$constant));
 5382   %}
 5383   ins_pipe(ialu_reg_reg);
 5384 %}
 5385 
 5386 instruct addshrI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5387   match(Set dst (AddI (URShiftI src1 src2) src3));
 5388 
 5389   size(4);
 5390   format %{ &quot;add_32 $dst,$src3,$src1&gt;&gt;&gt;$src2\t! int&quot; %}
 5391   ins_encode %{
 5392     __ add_32($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsr, $src2$$Register));
 5393   %}
 5394   ins_pipe(ialu_reg_reg);
 5395 %}
 5396 
 5397 instruct addshrI_reg_imm_reg(iRegI dst, iRegI src1, immU5 src2, iRegI src3) %{
 5398   match(Set dst (AddI (URShiftI src1 src2) src3));
 5399 
 5400   size(4);
 5401   format %{ &quot;add_32 $dst,$src3,$src1&gt;&gt;&gt;$src2\t! int&quot; %}
 5402   ins_encode %{
 5403     __ add_32($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsr, $src2$$constant));
 5404   %}
 5405   ins_pipe(ialu_reg_reg);
 5406 %}
 5407 
 5408 // Immediate Addition
 5409 instruct addI_reg_aimmI(iRegI dst, iRegI src1, aimmI src2) %{
 5410   match(Set dst (AddI src1 src2));
 5411 
 5412   size(4);
 5413   format %{ &quot;add_32 $dst,$src1,$src2\t! int&quot; %}
 5414   ins_encode %{
 5415     __ add_32($dst$$Register, $src1$$Register, $src2$$constant);
 5416   %}
 5417   ins_pipe(ialu_reg_imm);
 5418 %}
 5419 
 5420 // Pointer Register Addition
 5421 instruct addP_reg_reg(iRegP dst, iRegP src1, iRegX src2) %{
 5422   match(Set dst (AddP src1 src2));
 5423 
 5424   size(4);
 5425   format %{ &quot;ADD    $dst,$src1,$src2\t! ptr&quot; %}
 5426   ins_encode %{
 5427     __ add($dst$$Register, $src1$$Register, $src2$$Register);
 5428   %}
 5429   ins_pipe(ialu_reg_reg);
 5430 %}
 5431 
 5432 
 5433 // shifted iRegX operand
 5434 operand shiftedX(iRegX src2, shimmX src3) %{
 5435 //constraint(ALLOC_IN_RC(sp_ptr_reg));
 5436   match(LShiftX src2 src3);
 5437 
 5438   op_cost(1);
 5439   format %{ &quot;$src2 &lt;&lt; $src3&quot; %}
 5440   interface(MEMORY_INTER) %{
 5441     base($src2);
 5442     index(0xff);
 5443     scale($src3);
 5444     disp(0x0);
 5445   %}
 5446 %}
 5447 
 5448 instruct addshlP_reg_reg_imm(iRegP dst, iRegP src1, shiftedX src2) %{
 5449   match(Set dst (AddP src1 src2));
 5450 
 5451   ins_cost(DEFAULT_COST * 3/2);
 5452   size(4);
 5453   format %{ &quot;ADD    $dst,$src1,$src2\t! ptr&quot; %}
 5454   ins_encode %{
 5455     Register base = reg_to_register_object($src2$$base);
 5456     __ add($dst$$Register, $src1$$Register, AsmOperand(base, lsl, $src2$$scale));
 5457   %}
 5458   ins_pipe(ialu_reg_reg);
 5459 %}
 5460 
 5461 // Pointer Immediate Addition
 5462 instruct addP_reg_aimmX(iRegP dst, iRegP src1, aimmX src2) %{
 5463   match(Set dst (AddP src1 src2));
 5464 
 5465   size(4);
 5466   format %{ &quot;ADD    $dst,$src1,$src2\t! ptr&quot; %}
 5467   ins_encode %{
 5468     __ add($dst$$Register, $src1$$Register, $src2$$constant);
 5469   %}
 5470   ins_pipe(ialu_reg_imm);
 5471 %}
 5472 
 5473 // Long Addition
 5474 instruct addL_reg_reg(iRegL dst, iRegL src1, iRegL src2, flagsReg ccr) %{
 5475   match(Set dst (AddL src1 src2));
 5476   effect(KILL ccr);
 5477   size(8);
 5478   format %{ &quot;ADDS    $dst.lo,$src1.lo,$src2.lo\t! long\n\t&quot;
 5479             &quot;ADC     $dst.hi,$src1.hi,$src2.hi&quot; %}
 5480   ins_encode %{
 5481     __ adds($dst$$Register, $src1$$Register, $src2$$Register);
 5482     __ adc($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), $src2$$Register-&gt;successor());
 5483   %}
 5484   ins_pipe(ialu_reg_reg);
 5485 %}
 5486 
 5487 // TODO
 5488 
 5489 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 5490 // (hi($con$$constant), lo($con$$constant)) becomes
 5491 instruct addL_reg_immRot(iRegL dst, iRegL src1, immLlowRot con, flagsReg ccr) %{
 5492   match(Set dst (AddL src1 con));
 5493   effect(KILL ccr);
 5494   size(8);
 5495   format %{ &quot;ADDS    $dst.lo,$src1.lo,$con\t! long\n\t&quot;
 5496             &quot;ADC     $dst.hi,$src1.hi,0&quot; %}
 5497   ins_encode %{
 5498     __ adds($dst$$Register, $src1$$Register, $con$$constant);
 5499     __ adc($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), 0);
 5500   %}
 5501   ins_pipe(ialu_reg_imm);
 5502 %}
 5503 
 5504 //----------Conditional_store--------------------------------------------------
 5505 // Conditional-store of the updated heap-top.
 5506 // Used during allocation of the shared heap.
 5507 // Sets flags (EQ) on success.
 5508 
 5509 // LoadP-locked.
 5510 instruct loadPLocked(iRegP dst, memoryex mem) %{
 5511   match(Set dst (LoadPLocked mem));
 5512   size(4);
 5513   format %{ &quot;LDREX  $dst,$mem&quot; %}
 5514   ins_encode %{
 5515     __ ldrex($dst$$Register,$mem$$Address);
 5516   %}
 5517   ins_pipe(iload_mem);
 5518 %}
 5519 
 5520 instruct storePConditional( memoryex heap_top_ptr, iRegP oldval, iRegP newval, iRegI tmp, flagsRegP pcc ) %{
 5521   predicate(_kids[1]-&gt;_kids[0]-&gt;_leaf-&gt;Opcode() == Op_LoadPLocked); // only works in conjunction with a LoadPLocked node
 5522   match(Set pcc (StorePConditional heap_top_ptr (Binary oldval newval)));
 5523   effect( TEMP tmp );
 5524   size(8);
 5525   format %{ &quot;STREX  $tmp,$newval,$heap_top_ptr\n\t&quot;
 5526             &quot;CMP    $tmp, 0&quot; %}
 5527   ins_encode %{
 5528     __ strex($tmp$$Register, $newval$$Register, $heap_top_ptr$$Address);
 5529     __ cmp($tmp$$Register, 0);
 5530   %}
 5531   ins_pipe( long_memory_op );
 5532 %}
 5533 
 5534 // Conditional-store of an intx value.
 5535 instruct storeXConditional( memoryex mem, iRegX oldval, iRegX newval, iRegX tmp, flagsReg icc ) %{
 5536   match(Set icc (StoreIConditional mem (Binary oldval newval)));
 5537   effect( TEMP tmp );
 5538   size(28);
 5539   format %{ &quot;loop: \n\t&quot;
 5540             &quot;LDREX    $tmp, $mem\t! If $oldval==[$mem] Then store $newval into [$mem], DOESN&#39;T set $newval=[$mem] in any case\n\t&quot;
 5541             &quot;XORS     $tmp,$tmp, $oldval\n\t&quot;
 5542             &quot;STREX.eq $tmp, $newval, $mem\n\t&quot;
 5543             &quot;CMP.eq   $tmp, 1 \n\t&quot;
 5544             &quot;B.eq     loop \n\t&quot;
 5545             &quot;TEQ      $tmp, 0\n\t&quot;
 5546             &quot;membar   LoadStore|LoadLoad&quot; %}
 5547   ins_encode %{
 5548     Label loop;
 5549     __ bind(loop);
 5550     __ ldrex($tmp$$Register, $mem$$Address);
 5551     __ eors($tmp$$Register, $tmp$$Register, $oldval$$Register);
 5552     __ strex($tmp$$Register, $newval$$Register, $mem$$Address, eq);
 5553     __ cmp($tmp$$Register, 1, eq);
 5554     __ b(loop, eq);
 5555     __ teq($tmp$$Register, 0);
 5556     // used by biased locking only. Requires a membar.
 5557     __ membar(MacroAssembler::Membar_mask_bits(MacroAssembler::LoadStore | MacroAssembler::LoadLoad), noreg);
 5558   %}
 5559   ins_pipe( long_memory_op );
 5560 %}
 5561 
 5562 // No flag versions for CompareAndSwap{P,I,L} because matcher can&#39;t match them
 5563 
 5564 instruct compareAndSwapL_bool(memoryex mem, iRegL oldval, iRegLd newval, iRegI res, iRegLd tmp, flagsReg ccr ) %{
 5565   match(Set res (CompareAndSwapL mem (Binary oldval newval)));
 5566   effect( KILL ccr, TEMP tmp);
 5567   size(32);
 5568   format %{ &quot;loop: \n\t&quot;
 5569             &quot;LDREXD   $tmp, $mem\t! If $oldval==[$mem] Then store $newval into [$mem]\n\t&quot;
 5570             &quot;CMP      $tmp.lo, $oldval.lo\n\t&quot;
 5571             &quot;CMP.eq   $tmp.hi, $oldval.hi\n\t&quot;
 5572             &quot;STREXD.eq $tmp, $newval, $mem\n\t&quot;
 5573             &quot;MOV.ne   $tmp, 0 \n\t&quot;
 5574             &quot;XORS.eq  $tmp,$tmp, 1 \n\t&quot;
 5575             &quot;B.eq     loop \n\t&quot;
 5576             &quot;MOV      $res, $tmp&quot; %}
 5577   ins_encode %{
 5578     Label loop;
 5579     __ bind(loop);
 5580     __ ldrexd($tmp$$Register, $mem$$Address);
 5581     __ cmp($tmp$$Register, $oldval$$Register);
 5582     __ cmp($tmp$$Register-&gt;successor(), $oldval$$Register-&gt;successor(), eq);
 5583     __ strexd($tmp$$Register, $newval$$Register, $mem$$Address, eq);
 5584     __ mov($tmp$$Register, 0, ne);
 5585     __ eors($tmp$$Register, $tmp$$Register, 1, eq);
 5586     __ b(loop, eq);
 5587     __ mov($res$$Register, $tmp$$Register);
 5588   %}
 5589   ins_pipe( long_memory_op );
 5590 %}
 5591 
 5592 
 5593 instruct compareAndSwapI_bool(memoryex mem, iRegI oldval, iRegI newval, iRegI res, iRegI tmp, flagsReg ccr ) %{
 5594   match(Set res (CompareAndSwapI mem (Binary oldval newval)));
 5595   effect( KILL ccr, TEMP tmp);
 5596   size(28);
 5597   format %{ &quot;loop: \n\t&quot;
 5598             &quot;LDREX    $tmp, $mem\t! If $oldval==[$mem] Then store $newval into [$mem]\n\t&quot;
 5599             &quot;CMP      $tmp, $oldval\n\t&quot;
 5600             &quot;STREX.eq $tmp, $newval, $mem\n\t&quot;
 5601             &quot;MOV.ne   $tmp, 0 \n\t&quot;
 5602             &quot;XORS.eq  $tmp,$tmp, 1 \n\t&quot;
 5603             &quot;B.eq     loop \n\t&quot;
 5604             &quot;MOV      $res, $tmp&quot; %}
 5605 
 5606   ins_encode %{
 5607     Label loop;
 5608     __ bind(loop);
 5609     __ ldrex($tmp$$Register,$mem$$Address);
 5610     __ cmp($tmp$$Register, $oldval$$Register);
 5611     __ strex($tmp$$Register, $newval$$Register, $mem$$Address, eq);
 5612     __ mov($tmp$$Register, 0, ne);
 5613     __ eors($tmp$$Register, $tmp$$Register, 1, eq);
 5614     __ b(loop, eq);
 5615     __ mov($res$$Register, $tmp$$Register);
 5616   %}
 5617   ins_pipe( long_memory_op );
 5618 %}
 5619 
 5620 instruct compareAndSwapP_bool(memoryex mem, iRegP oldval, iRegP newval, iRegI res, iRegI tmp, flagsReg ccr ) %{
 5621   match(Set res (CompareAndSwapP mem (Binary oldval newval)));
 5622   effect( KILL ccr, TEMP tmp);
 5623   size(28);
 5624   format %{ &quot;loop: \n\t&quot;
 5625             &quot;LDREX    $tmp, $mem\t! If $oldval==[$mem] Then store $newval into [$mem]\n\t&quot;
 5626             &quot;CMP      $tmp, $oldval\n\t&quot;
 5627             &quot;STREX.eq $tmp, $newval, $mem\n\t&quot;
 5628             &quot;MOV.ne   $tmp, 0 \n\t&quot;
 5629             &quot;EORS.eq  $tmp,$tmp, 1 \n\t&quot;
 5630             &quot;B.eq     loop \n\t&quot;
 5631             &quot;MOV      $res, $tmp&quot; %}
 5632 
 5633   ins_encode %{
 5634     Label loop;
 5635     __ bind(loop);
 5636     __ ldrex($tmp$$Register,$mem$$Address);
 5637     __ cmp($tmp$$Register, $oldval$$Register);
 5638     __ strex($tmp$$Register, $newval$$Register, $mem$$Address, eq);
 5639     __ mov($tmp$$Register, 0, ne);
 5640     __ eors($tmp$$Register, $tmp$$Register, 1, eq);
 5641     __ b(loop, eq);
 5642     __ mov($res$$Register, $tmp$$Register);
 5643   %}
 5644   ins_pipe( long_memory_op );
 5645 %}
 5646 
 5647 instruct xaddI_aimmI_no_res(memoryex mem, aimmI add, Universe dummy, iRegI tmp1, iRegI tmp2, flagsReg ccr) %{
 5648   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 5649   match(Set dummy (GetAndAddI mem add));
 5650   effect(KILL ccr, TEMP tmp1, TEMP tmp2);
 5651   size(20);
 5652   format %{ &quot;loop: \n\t&quot;
 5653             &quot;LDREX    $tmp1, $mem\n\t&quot;
 5654             &quot;ADD      $tmp1, $tmp1, $add\n\t&quot;
 5655             &quot;STREX    $tmp2, $tmp1, $mem\n\t&quot;
 5656             &quot;CMP      $tmp2, 0 \n\t&quot;
 5657             &quot;B.ne     loop \n\t&quot; %}
 5658 
 5659   ins_encode %{
 5660     Label loop;
 5661     __ bind(loop);
 5662     __ ldrex($tmp1$$Register,$mem$$Address);
 5663     __ add($tmp1$$Register, $tmp1$$Register, $add$$constant);
 5664     __ strex($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5665     __ cmp($tmp2$$Register, 0);
 5666     __ b(loop, ne);
 5667   %}
 5668   ins_pipe( long_memory_op );
 5669 %}
 5670 
 5671 instruct xaddI_reg_no_res(memoryex mem, iRegI add, Universe dummy, iRegI tmp1, iRegI tmp2, flagsReg ccr) %{
 5672   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 5673   match(Set dummy (GetAndAddI mem add));
 5674   effect(KILL ccr, TEMP tmp1, TEMP tmp2);
 5675   size(20);
 5676   format %{ &quot;loop: \n\t&quot;
 5677             &quot;LDREX    $tmp1, $mem\n\t&quot;
 5678             &quot;ADD      $tmp1, $tmp1, $add\n\t&quot;
 5679             &quot;STREX    $tmp2, $tmp1, $mem\n\t&quot;
 5680             &quot;CMP      $tmp2, 0 \n\t&quot;
 5681             &quot;B.ne     loop \n\t&quot; %}
 5682 
 5683   ins_encode %{
 5684     Label loop;
 5685     __ bind(loop);
 5686     __ ldrex($tmp1$$Register,$mem$$Address);
 5687     __ add($tmp1$$Register, $tmp1$$Register, $add$$Register);
 5688     __ strex($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5689     __ cmp($tmp2$$Register, 0);
 5690     __ b(loop, ne);
 5691   %}
 5692   ins_pipe( long_memory_op );
 5693 %}
 5694 
 5695 instruct xaddI_aimmI(memoryex mem, aimmI add, iRegI res, iRegI tmp1, iRegI tmp2, flagsReg ccr) %{
 5696   match(Set res (GetAndAddI mem add));
 5697   effect(KILL ccr, TEMP tmp1, TEMP tmp2, TEMP res);
 5698   size(20);
 5699   format %{ &quot;loop: \n\t&quot;
 5700             &quot;LDREX    $res, $mem\n\t&quot;
 5701             &quot;ADD      $tmp1, $res, $add\n\t&quot;
 5702             &quot;STREX    $tmp2, $tmp1, $mem\n\t&quot;
 5703             &quot;CMP      $tmp2, 0 \n\t&quot;
 5704             &quot;B.ne     loop \n\t&quot; %}
 5705 
 5706   ins_encode %{
 5707     Label loop;
 5708     __ bind(loop);
 5709     __ ldrex($res$$Register,$mem$$Address);
 5710     __ add($tmp1$$Register, $res$$Register, $add$$constant);
 5711     __ strex($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5712     __ cmp($tmp2$$Register, 0);
 5713     __ b(loop, ne);
 5714   %}
 5715   ins_pipe( long_memory_op );
 5716 %}
 5717 
 5718 instruct xaddI_reg(memoryex mem, iRegI add, iRegI res, iRegI tmp1, iRegI tmp2, flagsReg ccr) %{
 5719   match(Set res (GetAndAddI mem add));
 5720   effect(KILL ccr, TEMP tmp1, TEMP tmp2, TEMP res);
 5721   size(20);
 5722   format %{ &quot;loop: \n\t&quot;
 5723             &quot;LDREX    $res, $mem\n\t&quot;
 5724             &quot;ADD      $tmp1, $res, $add\n\t&quot;
 5725             &quot;STREX    $tmp2, $tmp1, $mem\n\t&quot;
 5726             &quot;CMP      $tmp2, 0 \n\t&quot;
 5727             &quot;B.ne     loop \n\t&quot; %}
 5728 
 5729   ins_encode %{
 5730     Label loop;
 5731     __ bind(loop);
 5732     __ ldrex($res$$Register,$mem$$Address);
 5733     __ add($tmp1$$Register, $res$$Register, $add$$Register);
 5734     __ strex($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5735     __ cmp($tmp2$$Register, 0);
 5736     __ b(loop, ne);
 5737   %}
 5738   ins_pipe( long_memory_op );
 5739 %}
 5740 
 5741 instruct xaddL_reg_no_res(memoryex mem, iRegL add, Universe dummy, iRegLd tmp1, iRegI tmp2, flagsReg ccr) %{
 5742   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 5743   match(Set dummy (GetAndAddL mem add));
 5744   effect( KILL ccr, TEMP tmp1, TEMP tmp2);
 5745   size(24);
 5746   format %{ &quot;loop: \n\t&quot;
 5747             &quot;LDREXD   $tmp1, $mem\n\t&quot;
 5748             &quot;ADDS     $tmp1.lo, $tmp1.lo, $add.lo\n\t&quot;
 5749             &quot;ADC      $tmp1.hi, $tmp1.hi, $add.hi\n\t&quot;
 5750             &quot;STREXD   $tmp2, $tmp1, $mem\n\t&quot;
 5751             &quot;CMP      $tmp2, 0 \n\t&quot;
 5752             &quot;B.ne     loop \n\t&quot; %}
 5753 
 5754   ins_encode %{
 5755     Label loop;
 5756     __ bind(loop);
 5757     __ ldrexd($tmp1$$Register, $mem$$Address);
 5758     __ adds($tmp1$$Register, $tmp1$$Register, $add$$Register);
 5759     __ adc($tmp1$$Register-&gt;successor(), $tmp1$$Register-&gt;successor(), $add$$Register-&gt;successor());
 5760     __ strexd($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5761     __ cmp($tmp2$$Register, 0);
 5762     __ b(loop, ne);
 5763   %}
 5764   ins_pipe( long_memory_op );
 5765 %}
 5766 
 5767 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 5768 // (hi($con$$constant), lo($con$$constant)) becomes
 5769 instruct xaddL_immRot_no_res(memoryex mem, immLlowRot add, Universe dummy, iRegLd tmp1, iRegI tmp2, flagsReg ccr) %{
 5770   predicate(n-&gt;as_LoadStore()-&gt;result_not_used());
 5771   match(Set dummy (GetAndAddL mem add));
 5772   effect( KILL ccr, TEMP tmp1, TEMP tmp2);
 5773   size(24);
 5774   format %{ &quot;loop: \n\t&quot;
 5775             &quot;LDREXD   $tmp1, $mem\n\t&quot;
 5776             &quot;ADDS     $tmp1.lo, $tmp1.lo, $add\n\t&quot;
 5777             &quot;ADC      $tmp1.hi, $tmp1.hi, 0\n\t&quot;
 5778             &quot;STREXD   $tmp2, $tmp1, $mem\n\t&quot;
 5779             &quot;CMP      $tmp2, 0 \n\t&quot;
 5780             &quot;B.ne     loop \n\t&quot; %}
 5781 
 5782   ins_encode %{
 5783     Label loop;
 5784     __ bind(loop);
 5785     __ ldrexd($tmp1$$Register, $mem$$Address);
 5786     __ adds($tmp1$$Register, $tmp1$$Register, $add$$constant);
 5787     __ adc($tmp1$$Register-&gt;successor(), $tmp1$$Register-&gt;successor(), 0);
 5788     __ strexd($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5789     __ cmp($tmp2$$Register, 0);
 5790     __ b(loop, ne);
 5791   %}
 5792   ins_pipe( long_memory_op );
 5793 %}
 5794 
 5795 instruct xaddL_reg(memoryex mem, iRegL add, iRegLd res, iRegLd tmp1, iRegI tmp2, flagsReg ccr) %{
 5796   match(Set res (GetAndAddL mem add));
 5797   effect( KILL ccr, TEMP tmp1, TEMP tmp2, TEMP res);
 5798   size(24);
 5799   format %{ &quot;loop: \n\t&quot;
 5800             &quot;LDREXD   $res, $mem\n\t&quot;
 5801             &quot;ADDS     $tmp1.lo, $res.lo, $add.lo\n\t&quot;
 5802             &quot;ADC      $tmp1.hi, $res.hi, $add.hi\n\t&quot;
 5803             &quot;STREXD   $tmp2, $tmp1, $mem\n\t&quot;
 5804             &quot;CMP      $tmp2, 0 \n\t&quot;
 5805             &quot;B.ne     loop \n\t&quot; %}
 5806 
 5807   ins_encode %{
 5808     Label loop;
 5809     __ bind(loop);
 5810     __ ldrexd($res$$Register, $mem$$Address);
 5811     __ adds($tmp1$$Register, $res$$Register, $add$$Register);
 5812     __ adc($tmp1$$Register-&gt;successor(), $res$$Register-&gt;successor(), $add$$Register-&gt;successor());
 5813     __ strexd($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5814     __ cmp($tmp2$$Register, 0);
 5815     __ b(loop, ne);
 5816   %}
 5817   ins_pipe( long_memory_op );
 5818 %}
 5819 
 5820 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 5821 // (hi($con$$constant), lo($con$$constant)) becomes
 5822 instruct xaddL_immRot(memoryex mem, immLlowRot add, iRegLd res, iRegLd tmp1, iRegI tmp2, flagsReg ccr) %{
 5823   match(Set res (GetAndAddL mem add));
 5824   effect( KILL ccr, TEMP tmp1, TEMP tmp2, TEMP res);
 5825   size(24);
 5826   format %{ &quot;loop: \n\t&quot;
 5827             &quot;LDREXD   $res, $mem\n\t&quot;
 5828             &quot;ADDS     $tmp1.lo, $res.lo, $add\n\t&quot;
 5829             &quot;ADC      $tmp1.hi, $res.hi, 0\n\t&quot;
 5830             &quot;STREXD   $tmp2, $tmp1, $mem\n\t&quot;
 5831             &quot;CMP      $tmp2, 0 \n\t&quot;
 5832             &quot;B.ne     loop \n\t&quot; %}
 5833 
 5834   ins_encode %{
 5835     Label loop;
 5836     __ bind(loop);
 5837     __ ldrexd($res$$Register, $mem$$Address);
 5838     __ adds($tmp1$$Register, $res$$Register, $add$$constant);
 5839     __ adc($tmp1$$Register-&gt;successor(), $res$$Register-&gt;successor(), 0);
 5840     __ strexd($tmp2$$Register, $tmp1$$Register, $mem$$Address);
 5841     __ cmp($tmp2$$Register, 0);
 5842     __ b(loop, ne);
 5843   %}
 5844   ins_pipe( long_memory_op );
 5845 %}
 5846 
 5847 instruct xchgI(memoryex mem, iRegI newval, iRegI res, iRegI tmp, flagsReg ccr) %{
 5848   match(Set res (GetAndSetI mem newval));
 5849   effect(KILL ccr, TEMP tmp, TEMP res);
 5850   size(16);
 5851   format %{ &quot;loop: \n\t&quot;
 5852             &quot;LDREX    $res, $mem\n\t&quot;
 5853             &quot;STREX    $tmp, $newval, $mem\n\t&quot;
 5854             &quot;CMP      $tmp, 0 \n\t&quot;
 5855             &quot;B.ne     loop \n\t&quot; %}
 5856 
 5857   ins_encode %{
 5858     Label loop;
 5859     __ bind(loop);
 5860     __ ldrex($res$$Register,$mem$$Address);
 5861     __ strex($tmp$$Register, $newval$$Register, $mem$$Address);
 5862     __ cmp($tmp$$Register, 0);
 5863     __ b(loop, ne);
 5864   %}
 5865   ins_pipe( long_memory_op );
 5866 %}
 5867 
 5868 instruct xchgL(memoryex mem, iRegLd newval, iRegLd res, iRegI tmp, flagsReg ccr) %{
 5869   match(Set res (GetAndSetL mem newval));
 5870   effect( KILL ccr, TEMP tmp, TEMP res);
 5871   size(16);
 5872   format %{ &quot;loop: \n\t&quot;
 5873             &quot;LDREXD   $res, $mem\n\t&quot;
 5874             &quot;STREXD   $tmp, $newval, $mem\n\t&quot;
 5875             &quot;CMP      $tmp, 0 \n\t&quot;
 5876             &quot;B.ne     loop \n\t&quot; %}
 5877 
 5878   ins_encode %{
 5879     Label loop;
 5880     __ bind(loop);
 5881     __ ldrexd($res$$Register, $mem$$Address);
 5882     __ strexd($tmp$$Register, $newval$$Register, $mem$$Address);
 5883     __ cmp($tmp$$Register, 0);
 5884     __ b(loop, ne);
 5885   %}
 5886   ins_pipe( long_memory_op );
 5887 %}
 5888 
 5889 instruct xchgP(memoryex mem, iRegP newval, iRegP res, iRegI tmp, flagsReg ccr) %{
 5890   match(Set res (GetAndSetP mem newval));
 5891   effect(KILL ccr, TEMP tmp, TEMP res);
 5892   size(16);
 5893   format %{ &quot;loop: \n\t&quot;
 5894             &quot;LDREX    $res, $mem\n\t&quot;
 5895             &quot;STREX    $tmp, $newval, $mem\n\t&quot;
 5896             &quot;CMP      $tmp, 0 \n\t&quot;
 5897             &quot;B.ne     loop \n\t&quot; %}
 5898 
 5899   ins_encode %{
 5900     Label loop;
 5901     __ bind(loop);
 5902     __ ldrex($res$$Register,$mem$$Address);
 5903     __ strex($tmp$$Register, $newval$$Register, $mem$$Address);
 5904     __ cmp($tmp$$Register, 0);
 5905     __ b(loop, ne);
 5906   %}
 5907   ins_pipe( long_memory_op );
 5908 %}
 5909 
 5910 //---------------------
 5911 // Subtraction Instructions
 5912 // Register Subtraction
 5913 instruct subI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 5914   match(Set dst (SubI src1 src2));
 5915 
 5916   size(4);
 5917   format %{ &quot;sub_32 $dst,$src1,$src2\t! int&quot; %}
 5918   ins_encode %{
 5919     __ sub_32($dst$$Register, $src1$$Register, $src2$$Register);
 5920   %}
 5921   ins_pipe(ialu_reg_reg);
 5922 %}
 5923 
 5924 instruct subshlI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5925   match(Set dst (SubI src1 (LShiftI src2 src3)));
 5926 
 5927   size(4);
 5928   format %{ &quot;SUB    $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 5929   ins_encode %{
 5930     __ sub($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$Register));
 5931   %}
 5932   ins_pipe(ialu_reg_reg);
 5933 %}
 5934 
 5935 instruct subshlI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 5936   match(Set dst (SubI src1 (LShiftI src2 src3)));
 5937 
 5938   size(4);
 5939   format %{ &quot;sub_32 $dst,$src1,$src2&lt;&lt;$src3\t! int&quot; %}
 5940   ins_encode %{
 5941     __ sub_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$constant));
 5942   %}
 5943   ins_pipe(ialu_reg_reg);
 5944 %}
 5945 
 5946 instruct subsarI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5947   match(Set dst (SubI src1 (RShiftI src2 src3)));
 5948 
 5949   size(4);
 5950   format %{ &quot;SUB    $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 5951   ins_encode %{
 5952     __ sub($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$Register));
 5953   %}
 5954   ins_pipe(ialu_reg_reg);
 5955 %}
 5956 
 5957 instruct subsarI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 5958   match(Set dst (SubI src1 (RShiftI src2 src3)));
 5959 
 5960   size(4);
 5961   format %{ &quot;sub_32 $dst,$src1,$src2&gt;&gt;$src3\t! int&quot; %}
 5962   ins_encode %{
 5963     __ sub_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$constant));
 5964   %}
 5965   ins_pipe(ialu_reg_reg);
 5966 %}
 5967 
 5968 instruct subshrI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5969   match(Set dst (SubI src1 (URShiftI src2 src3)));
 5970 
 5971   size(4);
 5972   format %{ &quot;SUB    $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 5973   ins_encode %{
 5974     __ sub($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$Register));
 5975   %}
 5976   ins_pipe(ialu_reg_reg);
 5977 %}
 5978 
 5979 instruct subshrI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 5980   match(Set dst (SubI src1 (URShiftI src2 src3)));
 5981 
 5982   size(4);
 5983   format %{ &quot;sub_32 $dst,$src1,$src2&gt;&gt;&gt;$src3\t! int&quot; %}
 5984   ins_encode %{
 5985     __ sub_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$constant));
 5986   %}
 5987   ins_pipe(ialu_reg_reg);
 5988 %}
 5989 
 5990 instruct rsbshlI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 5991   match(Set dst (SubI (LShiftI src1 src2) src3));
 5992 
 5993   size(4);
 5994   format %{ &quot;RSB    $dst,$src3,$src1&lt;&lt;$src2&quot; %}
 5995   ins_encode %{
 5996     __ rsb($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsl, $src2$$Register));
 5997   %}
 5998   ins_pipe(ialu_reg_reg);
 5999 %}
 6000 
 6001 instruct rsbshlI_reg_imm_reg(iRegI dst, iRegI src1, immU5 src2, iRegI src3) %{
 6002   match(Set dst (SubI (LShiftI src1 src2) src3));
 6003 
 6004   size(4);
 6005   format %{ &quot;RSB    $dst,$src3,$src1&lt;&lt;$src2&quot; %}
 6006   ins_encode %{
 6007     __ rsb($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsl, $src2$$constant));
 6008   %}
 6009   ins_pipe(ialu_reg_reg);
 6010 %}
 6011 
 6012 instruct rsbsarI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6013   match(Set dst (SubI (RShiftI src1 src2) src3));
 6014 
 6015   size(4);
 6016   format %{ &quot;RSB    $dst,$src3,$src1&gt;&gt;$src2&quot; %}
 6017   ins_encode %{
 6018     __ rsb($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, asr, $src2$$Register));
 6019   %}
 6020   ins_pipe(ialu_reg_reg);
 6021 %}
 6022 
 6023 instruct rsbsarI_reg_imm_reg(iRegI dst, iRegI src1, immU5 src2, iRegI src3) %{
 6024   match(Set dst (SubI (RShiftI src1 src2) src3));
 6025 
 6026   size(4);
 6027   format %{ &quot;RSB    $dst,$src3,$src1&gt;&gt;$src2&quot; %}
 6028   ins_encode %{
 6029     __ rsb($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, asr, $src2$$constant));
 6030   %}
 6031   ins_pipe(ialu_reg_reg);
 6032 %}
 6033 
 6034 instruct rsbshrI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6035   match(Set dst (SubI (URShiftI src1 src2) src3));
 6036 
 6037   size(4);
 6038   format %{ &quot;RSB    $dst,$src3,$src1&gt;&gt;&gt;$src2&quot; %}
 6039   ins_encode %{
 6040     __ rsb($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsr, $src2$$Register));
 6041   %}
 6042   ins_pipe(ialu_reg_reg);
 6043 %}
 6044 
 6045 instruct rsbshrI_reg_imm_reg(iRegI dst, iRegI src1, immU5 src2, iRegI src3) %{
 6046   match(Set dst (SubI (URShiftI src1 src2) src3));
 6047 
 6048   size(4);
 6049   format %{ &quot;RSB    $dst,$src3,$src1&gt;&gt;&gt;$src2&quot; %}
 6050   ins_encode %{
 6051     __ rsb($dst$$Register, $src3$$Register, AsmOperand($src1$$Register, lsr, $src2$$constant));
 6052   %}
 6053   ins_pipe(ialu_reg_reg);
 6054 %}
 6055 
 6056 // Immediate Subtraction
 6057 instruct subI_reg_aimmI(iRegI dst, iRegI src1, aimmI src2) %{
 6058   match(Set dst (SubI src1 src2));
 6059 
 6060   size(4);
 6061   format %{ &quot;sub_32 $dst,$src1,$src2\t! int&quot; %}
 6062   ins_encode %{
 6063     __ sub_32($dst$$Register, $src1$$Register, $src2$$constant);
 6064   %}
 6065   ins_pipe(ialu_reg_imm);
 6066 %}
 6067 
 6068 instruct subI_reg_immRotneg(iRegI dst, iRegI src1, aimmIneg src2) %{
 6069   match(Set dst (AddI src1 src2));
 6070 
 6071   size(4);
 6072   format %{ &quot;sub_32 $dst,$src1,-($src2)\t! int&quot; %}
 6073   ins_encode %{
 6074     __ sub_32($dst$$Register, $src1$$Register, -$src2$$constant);
 6075   %}
 6076   ins_pipe(ialu_reg_imm);
 6077 %}
 6078 
 6079 instruct subI_immRot_reg(iRegI dst, immIRot src1, iRegI src2) %{
 6080   match(Set dst (SubI src1 src2));
 6081 
 6082   size(4);
 6083   format %{ &quot;RSB    $dst,$src2,src1&quot; %}
 6084   ins_encode %{
 6085     __ rsb($dst$$Register, $src2$$Register, $src1$$constant);
 6086   %}
 6087   ins_pipe(ialu_zero_reg);
 6088 %}
 6089 
 6090 // Register Subtraction
 6091 instruct subL_reg_reg(iRegL dst, iRegL src1, iRegL src2, flagsReg icc ) %{
 6092   match(Set dst (SubL src1 src2));
 6093   effect (KILL icc);
 6094 
 6095   size(8);
 6096   format %{ &quot;SUBS   $dst.lo,$src1.lo,$src2.lo\t! long\n\t&quot;
 6097             &quot;SBC    $dst.hi,$src1.hi,$src2.hi&quot; %}
 6098   ins_encode %{
 6099     __ subs($dst$$Register, $src1$$Register, $src2$$Register);
 6100     __ sbc($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), $src2$$Register-&gt;successor());
 6101   %}
 6102   ins_pipe(ialu_reg_reg);
 6103 %}
 6104 
 6105 // TODO
 6106 
 6107 // Immediate Subtraction
 6108 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 6109 // (hi($con$$constant), lo($con$$constant)) becomes
 6110 instruct subL_reg_immRot(iRegL dst, iRegL src1, immLlowRot con, flagsReg icc) %{
 6111   match(Set dst (SubL src1 con));
 6112   effect (KILL icc);
 6113 
 6114   size(8);
 6115   format %{ &quot;SUB    $dst.lo,$src1.lo,$con\t! long\n\t&quot;
 6116             &quot;SBC    $dst.hi,$src1.hi,0&quot; %}
 6117   ins_encode %{
 6118     __ subs($dst$$Register, $src1$$Register, $con$$constant);
 6119     __ sbc($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), 0);
 6120   %}
 6121   ins_pipe(ialu_reg_imm);
 6122 %}
 6123 
 6124 // Long negation
 6125 instruct negL_reg_reg(iRegL dst, immL0 zero, iRegL src2, flagsReg icc) %{
 6126   match(Set dst (SubL zero src2));
 6127   effect (KILL icc);
 6128 
 6129   size(8);
 6130   format %{ &quot;RSBS   $dst.lo,$src2.lo,0\t! long\n\t&quot;
 6131             &quot;RSC    $dst.hi,$src2.hi,0&quot; %}
 6132   ins_encode %{
 6133     __ rsbs($dst$$Register, $src2$$Register, 0);
 6134     __ rsc($dst$$Register-&gt;successor(), $src2$$Register-&gt;successor(), 0);
 6135   %}
 6136   ins_pipe(ialu_zero_reg);
 6137 %}
 6138 
 6139 // Multiplication Instructions
 6140 // Integer Multiplication
 6141 // Register Multiplication
 6142 instruct mulI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6143   match(Set dst (MulI src1 src2));
 6144 
 6145   size(4);
 6146   format %{ &quot;mul_32 $dst,$src1,$src2&quot; %}
 6147   ins_encode %{
 6148     __ mul_32($dst$$Register, $src1$$Register, $src2$$Register);
 6149   %}
 6150   ins_pipe(imul_reg_reg);
 6151 %}
 6152 
 6153 instruct mulL_lo1_hi2(iRegL dst, iRegL src1, iRegL src2) %{
 6154   effect(DEF dst, USE src1, USE src2);
 6155   size(4);
 6156   format %{ &quot;MUL  $dst.hi,$src1.lo,$src2.hi\t! long&quot; %}
 6157   ins_encode %{
 6158     __ mul($dst$$Register-&gt;successor(), $src1$$Register, $src2$$Register-&gt;successor());
 6159   %}
 6160   ins_pipe(imul_reg_reg);
 6161 %}
 6162 
 6163 instruct mulL_hi1_lo2(iRegL dst, iRegL src1, iRegL src2) %{
 6164   effect(USE_DEF dst, USE src1, USE src2);
 6165   size(8);
 6166   format %{ &quot;MLA  $dst.hi,$src1.hi,$src2.lo,$dst.hi\t! long\n\t&quot;
 6167             &quot;MOV  $dst.lo, 0&quot;%}
 6168   ins_encode %{
 6169     __ mla($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), $src2$$Register, $dst$$Register-&gt;successor());
 6170     __ mov($dst$$Register, 0);
 6171   %}
 6172   ins_pipe(imul_reg_reg);
 6173 %}
 6174 
 6175 instruct mulL_lo1_lo2(iRegL dst, iRegL src1, iRegL src2) %{
 6176   effect(USE_DEF dst, USE src1, USE src2);
 6177   size(4);
 6178   format %{ &quot;UMLAL  $dst.lo,$dst.hi,$src1,$src2\t! long&quot; %}
 6179   ins_encode %{
 6180     __ umlal($dst$$Register, $dst$$Register-&gt;successor(), $src1$$Register, $src2$$Register);
 6181   %}
 6182   ins_pipe(imul_reg_reg);
 6183 %}
 6184 
 6185 instruct mulL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6186   match(Set dst (MulL src1 src2));
 6187 
 6188   expand %{
 6189     mulL_lo1_hi2(dst, src1, src2);
 6190     mulL_hi1_lo2(dst, src1, src2);
 6191     mulL_lo1_lo2(dst, src1, src2);
 6192   %}
 6193 %}
 6194 
 6195 // Integer Division
 6196 // Register Division
 6197 instruct divI_reg_reg(R1RegI dst, R0RegI src1, R2RegI src2, LRRegP lr, flagsReg ccr) %{
 6198   match(Set dst (DivI src1 src2));
 6199   effect( KILL ccr, KILL src1, KILL src2, KILL lr);
 6200   ins_cost((2+71)*DEFAULT_COST);
 6201 
 6202   format %{ &quot;DIV   $dst,$src1,$src2 ! call to StubRoutines::Arm::idiv_irem_entry()&quot; %}
 6203   ins_encode %{
 6204     __ call(StubRoutines::Arm::idiv_irem_entry(), relocInfo::runtime_call_type);
 6205   %}
 6206   ins_pipe(sdiv_reg_reg);
 6207 %}
 6208 
 6209 // Register Long Division
 6210 instruct divL_reg_reg(R0R1RegL dst, R2R3RegL src1, R0R1RegL src2) %{
 6211   match(Set dst (DivL src1 src2));
 6212   effect(CALL);
 6213   ins_cost(DEFAULT_COST*71);
 6214   format %{ &quot;DIVL  $src1,$src2,$dst\t! long ! call to SharedRuntime::ldiv&quot; %}
 6215   ins_encode %{
 6216     address target = CAST_FROM_FN_PTR(address, SharedRuntime::ldiv);
 6217     __ call(target, relocInfo::runtime_call_type);
 6218   %}
 6219   ins_pipe(divL_reg_reg);
 6220 %}
 6221 
 6222 // Integer Remainder
 6223 // Register Remainder
 6224 instruct modI_reg_reg(R0RegI dst, R0RegI src1, R2RegI src2, R1RegI temp, LRRegP lr, flagsReg ccr ) %{
 6225   match(Set dst (ModI src1 src2));
 6226   effect( KILL ccr, KILL temp, KILL src2, KILL lr);
 6227 
 6228   format %{ &quot;MODI   $dst,$src1,$src2\t ! call to StubRoutines::Arm::idiv_irem_entry&quot; %}
 6229   ins_encode %{
 6230     __ call(StubRoutines::Arm::idiv_irem_entry(), relocInfo::runtime_call_type);
 6231   %}
 6232   ins_pipe(sdiv_reg_reg);
 6233 %}
 6234 
 6235 // Register Long Remainder
 6236 instruct modL_reg_reg(R0R1RegL dst, R2R3RegL src1, R0R1RegL src2) %{
 6237   match(Set dst (ModL src1 src2));
 6238   effect(CALL);
 6239   ins_cost(MEMORY_REF_COST); // FIXME
 6240   format %{ &quot;modL    $dst,$src1,$src2\t ! call to SharedRuntime::lrem&quot; %}
 6241   ins_encode %{
 6242     address target = CAST_FROM_FN_PTR(address, SharedRuntime::lrem);
 6243     __ call(target, relocInfo::runtime_call_type);
 6244   %}
 6245   ins_pipe(divL_reg_reg);
 6246 %}
 6247 
 6248 // Integer Shift Instructions
 6249 
 6250 // Register Shift Left
 6251 instruct shlI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6252   match(Set dst (LShiftI src1 src2));
 6253 
 6254   size(4);
 6255   format %{ &quot;LSL  $dst,$src1,$src2 \n\t&quot; %}
 6256   ins_encode %{
 6257     __ mov($dst$$Register, AsmOperand($src1$$Register, lsl, $src2$$Register));
 6258   %}
 6259   ins_pipe(ialu_reg_reg);
 6260 %}
 6261 
 6262 // Register Shift Left Immediate
 6263 instruct shlI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 6264   match(Set dst (LShiftI src1 src2));
 6265 
 6266   size(4);
 6267   format %{ &quot;LSL    $dst,$src1,$src2\t! int&quot; %}
 6268   ins_encode %{
 6269     __ logical_shift_left($dst$$Register, $src1$$Register, $src2$$constant);
 6270   %}
 6271   ins_pipe(ialu_reg_imm);
 6272 %}
 6273 
 6274 instruct shlL_reg_reg_merge_hi(iRegL dst, iRegL src1, iRegI src2) %{
 6275   effect(USE_DEF dst, USE src1, USE src2);
 6276   size(4);
 6277   format %{&quot;OR  $dst.hi,$dst.hi,($src1.hi &lt;&lt; $src2)&quot;  %}
 6278   ins_encode %{
 6279     __ orr($dst$$Register-&gt;successor(), $dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), lsl, $src2$$Register));
 6280   %}
 6281   ins_pipe(ialu_reg_reg);
 6282 %}
 6283 
 6284 instruct shlL_reg_reg_merge_lo(iRegL dst, iRegL src1, iRegI src2) %{
 6285   effect(USE_DEF dst, USE src1, USE src2);
 6286   size(4);
 6287   format %{ &quot;LSL  $dst.lo,$src1.lo,$src2 \n\t&quot; %}
 6288   ins_encode %{
 6289     __ mov($dst$$Register, AsmOperand($src1$$Register, lsl, $src2$$Register));
 6290   %}
 6291   ins_pipe(ialu_reg_reg);
 6292 %}
 6293 
 6294 instruct shlL_reg_reg_overlap(iRegL dst, iRegL src1, iRegI src2, flagsReg ccr) %{
 6295   effect(DEF dst, USE src1, USE src2, KILL ccr);
 6296   size(16);
 6297   format %{ &quot;SUBS  $dst.hi,$src2,32 \n\t&quot;
 6298             &quot;LSLpl $dst.hi,$src1.lo,$dst.hi \n\t&quot;
 6299             &quot;RSBmi $dst.hi,$dst.hi,0 \n\t&quot;
 6300             &quot;LSRmi $dst.hi,$src1.lo,$dst.hi&quot; %}
 6301 
 6302   ins_encode %{
 6303     // $src1$$Register and $dst$$Register-&gt;successor() can&#39;t be the same
 6304     __ subs($dst$$Register-&gt;successor(), $src2$$Register, 32);
 6305     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register, lsl, $dst$$Register-&gt;successor()), pl);
 6306     __ rsb($dst$$Register-&gt;successor(), $dst$$Register-&gt;successor(), 0, mi);
 6307     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register, lsr, $dst$$Register-&gt;successor()), mi);
 6308   %}
 6309   ins_pipe(ialu_reg_reg);
 6310 %}
 6311 
 6312 instruct shlL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6313   match(Set dst (LShiftL src1 src2));
 6314 
 6315   expand %{
 6316     flagsReg ccr;
 6317     shlL_reg_reg_overlap(dst, src1, src2, ccr);
 6318     shlL_reg_reg_merge_hi(dst, src1, src2);
 6319     shlL_reg_reg_merge_lo(dst, src1, src2);
 6320   %}
 6321 %}
 6322 
 6323 // Register Shift Left Immediate
 6324 instruct shlL_reg_imm6(iRegL dst, iRegL src1, immU6Big src2) %{
 6325   match(Set dst (LShiftL src1 src2));
 6326 
 6327   size(8);
 6328   format %{ &quot;LSL   $dst.hi,$src1.lo,$src2-32\t! or mov if $src2==32\n\t&quot;
 6329             &quot;MOV   $dst.lo, 0&quot; %}
 6330   ins_encode %{
 6331     if ($src2$$constant == 32) {
 6332       __ mov($dst$$Register-&gt;successor(), $src1$$Register);
 6333     } else {
 6334       __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register, lsl, $src2$$constant-32));
 6335     }
 6336     __ mov($dst$$Register, 0);
 6337   %}
 6338   ins_pipe(ialu_reg_imm);
 6339 %}
 6340 
 6341 instruct shlL_reg_imm5(iRegL dst, iRegL src1, immU5 src2) %{
 6342   match(Set dst (LShiftL src1 src2));
 6343 
 6344   size(12);
 6345   format %{ &quot;LSL   $dst.hi,$src1.lo,$src2\n\t&quot;
 6346             &quot;OR    $dst.hi, $dst.hi, $src1.lo &gt;&gt; 32-$src2\n\t&quot;
 6347             &quot;LSL   $dst.lo,$src1.lo,$src2&quot; %}
 6348   ins_encode %{
 6349     // The order of the following 3 instructions matters: src1.lo and
 6350     // dst.hi can&#39;t overlap but src.hi and dst.hi can.
 6351     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), lsl, $src2$$constant));
 6352     __ orr($dst$$Register-&gt;successor(), $dst$$Register-&gt;successor(), AsmOperand($src1$$Register, lsr, 32-$src2$$constant));
 6353     __ mov($dst$$Register, AsmOperand($src1$$Register, lsl, $src2$$constant));
 6354   %}
 6355   ins_pipe(ialu_reg_imm);
 6356 %}
 6357 
 6358 // Register Arithmetic Shift Right
 6359 instruct sarI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6360   match(Set dst (RShiftI src1 src2));
 6361   size(4);
 6362   format %{ &quot;ASR    $dst,$src1,$src2\t! int&quot; %}
 6363   ins_encode %{
 6364     __ mov($dst$$Register, AsmOperand($src1$$Register, asr, $src2$$Register));
 6365   %}
 6366   ins_pipe(ialu_reg_reg);
 6367 %}
 6368 
 6369 // Register Arithmetic Shift Right Immediate
 6370 instruct sarI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 6371   match(Set dst (RShiftI src1 src2));
 6372 
 6373   size(4);
 6374   format %{ &quot;ASR    $dst,$src1,$src2&quot; %}
 6375   ins_encode %{
 6376     __ mov($dst$$Register, AsmOperand($src1$$Register, asr, $src2$$constant));
 6377   %}
 6378   ins_pipe(ialu_reg_imm);
 6379 %}
 6380 
 6381 // Register Shift Right Arithmetic Long
 6382 instruct sarL_reg_reg_merge_lo(iRegL dst, iRegL src1, iRegI src2) %{
 6383   effect(USE_DEF dst, USE src1, USE src2);
 6384   size(4);
 6385   format %{ &quot;OR  $dst.lo,$dst.lo,($src1.lo &gt;&gt; $src2)&quot;  %}
 6386   ins_encode %{
 6387     __ orr($dst$$Register, $dst$$Register, AsmOperand($src1$$Register, lsr, $src2$$Register));
 6388   %}
 6389   ins_pipe(ialu_reg_reg);
 6390 %}
 6391 
 6392 instruct sarL_reg_reg_merge_hi(iRegL dst, iRegL src1, iRegI src2) %{
 6393   effect(USE_DEF dst, USE src1, USE src2);
 6394   size(4);
 6395   format %{ &quot;ASR  $dst.hi,$src1.hi,$src2 \n\t&quot; %}
 6396   ins_encode %{
 6397     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), asr, $src2$$Register));
 6398   %}
 6399   ins_pipe(ialu_reg_reg);
 6400 %}
 6401 
 6402 instruct sarL_reg_reg_overlap(iRegL dst, iRegL src1, iRegI src2, flagsReg ccr) %{
 6403   effect(DEF dst, USE src1, USE src2, KILL ccr);
 6404   size(16);
 6405   format %{ &quot;SUBS  $dst.lo,$src2,32 \n\t&quot;
 6406             &quot;ASRpl $dst.lo,$src1.hi,$dst.lo \n\t&quot;
 6407             &quot;RSBmi $dst.lo,$dst.lo,0 \n\t&quot;
 6408             &quot;LSLmi $dst.lo,$src1.hi,$dst.lo&quot; %}
 6409 
 6410   ins_encode %{
 6411     // $src1$$Register-&gt;successor() and $dst$$Register can&#39;t be the same
 6412     __ subs($dst$$Register, $src2$$Register, 32);
 6413     __ mov($dst$$Register, AsmOperand($src1$$Register-&gt;successor(), asr, $dst$$Register), pl);
 6414     __ rsb($dst$$Register, $dst$$Register, 0, mi);
 6415     __ mov($dst$$Register, AsmOperand($src1$$Register-&gt;successor(), lsl, $dst$$Register), mi);
 6416   %}
 6417   ins_pipe(ialu_reg_reg);
 6418 %}
 6419 
 6420 instruct sarL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6421   match(Set dst (RShiftL src1 src2));
 6422 
 6423   expand %{
 6424     flagsReg ccr;
 6425     sarL_reg_reg_overlap(dst, src1, src2, ccr);
 6426     sarL_reg_reg_merge_lo(dst, src1, src2);
 6427     sarL_reg_reg_merge_hi(dst, src1, src2);
 6428   %}
 6429 %}
 6430 
 6431 // Register Shift Left Immediate
 6432 instruct sarL_reg_imm6(iRegL dst, iRegL src1, immU6Big src2) %{
 6433   match(Set dst (RShiftL src1 src2));
 6434 
 6435   size(8);
 6436   format %{ &quot;ASR   $dst.lo,$src1.hi,$src2-32\t! or mov if $src2==32\n\t&quot;
 6437             &quot;ASR   $dst.hi,$src1.hi, $src2&quot; %}
 6438   ins_encode %{
 6439     if ($src2$$constant == 32) {
 6440       __ mov($dst$$Register, $src1$$Register-&gt;successor());
 6441     } else{
 6442       __ mov($dst$$Register, AsmOperand($src1$$Register-&gt;successor(), asr, $src2$$constant-32));
 6443     }
 6444     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), asr, 0));
 6445   %}
 6446 
 6447   ins_pipe(ialu_reg_imm);
 6448 %}
 6449 
 6450 instruct sarL_reg_imm5(iRegL dst, iRegL src1, immU5 src2) %{
 6451   match(Set dst (RShiftL src1 src2));
 6452   size(12);
 6453   format %{ &quot;LSR   $dst.lo,$src1.lo,$src2\n\t&quot;
 6454             &quot;OR    $dst.lo, $dst.lo, $src1.hi &lt;&lt; 32-$src2\n\t&quot;
 6455             &quot;ASR   $dst.hi,$src1.hi,$src2&quot; %}
 6456   ins_encode %{
 6457     // The order of the following 3 instructions matters: src1.lo and
 6458     // dst.hi can&#39;t overlap but src.hi and dst.hi can.
 6459     __ mov($dst$$Register, AsmOperand($src1$$Register, lsr, $src2$$constant));
 6460     __ orr($dst$$Register, $dst$$Register, AsmOperand($src1$$Register-&gt;successor(), lsl, 32-$src2$$constant));
 6461     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), asr, $src2$$constant));
 6462   %}
 6463   ins_pipe(ialu_reg_imm);
 6464 %}
 6465 
 6466 // Register Shift Right
 6467 instruct shrI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6468   match(Set dst (URShiftI src1 src2));
 6469   size(4);
 6470   format %{ &quot;LSR    $dst,$src1,$src2\t! int&quot; %}
 6471   ins_encode %{
 6472     __ mov($dst$$Register, AsmOperand($src1$$Register, lsr, $src2$$Register));
 6473   %}
 6474   ins_pipe(ialu_reg_reg);
 6475 %}
 6476 
 6477 // Register Shift Right Immediate
 6478 instruct shrI_reg_imm5(iRegI dst, iRegI src1, immU5 src2) %{
 6479   match(Set dst (URShiftI src1 src2));
 6480 
 6481   size(4);
 6482   format %{ &quot;LSR    $dst,$src1,$src2&quot; %}
 6483   ins_encode %{
 6484     __ mov($dst$$Register, AsmOperand($src1$$Register, lsr, $src2$$constant));
 6485   %}
 6486   ins_pipe(ialu_reg_imm);
 6487 %}
 6488 
 6489 // Register Shift Right
 6490 instruct shrL_reg_reg_merge_lo(iRegL dst, iRegL src1, iRegI src2) %{
 6491   effect(USE_DEF dst, USE src1, USE src2);
 6492   size(4);
 6493   format %{ &quot;OR   $dst.lo,$dst,($src1.lo &gt;&gt;&gt; $src2)&quot;  %}
 6494   ins_encode %{
 6495     __ orr($dst$$Register, $dst$$Register, AsmOperand($src1$$Register, lsr, $src2$$Register));
 6496   %}
 6497   ins_pipe(ialu_reg_reg);
 6498 %}
 6499 
 6500 instruct shrL_reg_reg_merge_hi(iRegL dst, iRegL src1, iRegI src2) %{
 6501   effect(USE_DEF dst, USE src1, USE src2);
 6502   size(4);
 6503   format %{ &quot;LSR  $dst.hi,$src1.hi,$src2 \n\t&quot; %}
 6504   ins_encode %{
 6505     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), lsr, $src2$$Register));
 6506   %}
 6507   ins_pipe(ialu_reg_reg);
 6508 %}
 6509 
 6510 instruct shrL_reg_reg_overlap(iRegL dst, iRegL src1, iRegI src2, flagsReg ccr) %{
 6511   effect(DEF dst, USE src1, USE src2, KILL ccr);
 6512   size(16);
 6513   format %{ &quot;SUBS  $dst,$src2,32 \n\t&quot;
 6514             &quot;LSRpl $dst,$src1.hi,$dst \n\t&quot;
 6515             &quot;RSBmi $dst,$dst,0 \n\t&quot;
 6516             &quot;LSLmi $dst,$src1.hi,$dst&quot; %}
 6517 
 6518   ins_encode %{
 6519     // $src1$$Register-&gt;successor() and $dst$$Register can&#39;t be the same
 6520     __ subs($dst$$Register, $src2$$Register, 32);
 6521     __ mov($dst$$Register, AsmOperand($src1$$Register-&gt;successor(), lsr, $dst$$Register), pl);
 6522     __ rsb($dst$$Register, $dst$$Register, 0, mi);
 6523     __ mov($dst$$Register, AsmOperand($src1$$Register-&gt;successor(), lsl, $dst$$Register), mi);
 6524   %}
 6525   ins_pipe(ialu_reg_reg);
 6526 %}
 6527 
 6528 instruct shrL_reg_reg(iRegL dst, iRegL src1, iRegI src2) %{
 6529   match(Set dst (URShiftL src1 src2));
 6530 
 6531   expand %{
 6532     flagsReg ccr;
 6533     shrL_reg_reg_overlap(dst, src1, src2, ccr);
 6534     shrL_reg_reg_merge_lo(dst, src1, src2);
 6535     shrL_reg_reg_merge_hi(dst, src1, src2);
 6536   %}
 6537 %}
 6538 
 6539 // Register Shift Right Immediate
 6540 instruct shrL_reg_imm6(iRegL dst, iRegL src1, immU6Big src2) %{
 6541   match(Set dst (URShiftL src1 src2));
 6542 
 6543   size(8);
 6544   format %{ &quot;LSR   $dst.lo,$src1.hi,$src2-32\t! or mov if $src2==32\n\t&quot;
 6545             &quot;MOV   $dst.hi, 0&quot; %}
 6546   ins_encode %{
 6547     if ($src2$$constant == 32) {
 6548       __ mov($dst$$Register, $src1$$Register-&gt;successor());
 6549     } else {
 6550       __ mov($dst$$Register, AsmOperand($src1$$Register-&gt;successor(), lsr, $src2$$constant-32));
 6551     }
 6552     __ mov($dst$$Register-&gt;successor(), 0);
 6553   %}
 6554 
 6555   ins_pipe(ialu_reg_imm);
 6556 %}
 6557 
 6558 instruct shrL_reg_imm5(iRegL dst, iRegL src1, immU5 src2) %{
 6559   match(Set dst (URShiftL src1 src2));
 6560 
 6561   size(12);
 6562   format %{ &quot;LSR   $dst.lo,$src1.lo,$src2\n\t&quot;
 6563             &quot;OR    $dst.lo, $dst.lo, $src1.hi &lt;&lt; 32-$src2\n\t&quot;
 6564             &quot;LSR   $dst.hi,$src1.hi,$src2&quot; %}
 6565   ins_encode %{
 6566     // The order of the following 3 instructions matters: src1.lo and
 6567     // dst.hi can&#39;t overlap but src.hi and dst.hi can.
 6568     __ mov($dst$$Register, AsmOperand($src1$$Register, lsr, $src2$$constant));
 6569     __ orr($dst$$Register, $dst$$Register, AsmOperand($src1$$Register-&gt;successor(), lsl, 32-$src2$$constant));
 6570     __ mov($dst$$Register-&gt;successor(), AsmOperand($src1$$Register-&gt;successor(), lsr, $src2$$constant));
 6571   %}
 6572   ins_pipe(ialu_reg_imm);
 6573 %}
 6574 
 6575 
 6576 instruct shrP_reg_imm5(iRegX dst, iRegP src1, immU5 src2) %{
 6577   match(Set dst (URShiftI (CastP2X src1) src2));
 6578   size(4);
 6579   format %{ &quot;LSR    $dst,$src1,$src2\t! Cast ptr $src1 to int and shift&quot; %}
 6580   ins_encode %{
 6581     __ logical_shift_right($dst$$Register, $src1$$Register, $src2$$constant);
 6582   %}
 6583   ins_pipe(ialu_reg_imm);
 6584 %}
 6585 
 6586 //----------Floating Point Arithmetic Instructions-----------------------------
 6587 
 6588 //  Add float single precision
 6589 instruct addF_reg_reg(regF dst, regF src1, regF src2) %{
 6590   match(Set dst (AddF src1 src2));
 6591 
 6592   size(4);
 6593   format %{ &quot;FADDS  $dst,$src1,$src2&quot; %}
 6594   ins_encode %{
 6595     __ add_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6596   %}
 6597 
 6598   ins_pipe(faddF_reg_reg);
 6599 %}
 6600 
 6601 //  Add float double precision
 6602 instruct addD_reg_reg(regD dst, regD src1, regD src2) %{
 6603   match(Set dst (AddD src1 src2));
 6604 
 6605   size(4);
 6606   format %{ &quot;FADDD  $dst,$src1,$src2&quot; %}
 6607   ins_encode %{
 6608     __ add_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6609   %}
 6610 
 6611   ins_pipe(faddD_reg_reg);
 6612 %}
 6613 
 6614 //  Sub float single precision
 6615 instruct subF_reg_reg(regF dst, regF src1, regF src2) %{
 6616   match(Set dst (SubF src1 src2));
 6617 
 6618   size(4);
 6619   format %{ &quot;FSUBS  $dst,$src1,$src2&quot; %}
 6620   ins_encode %{
 6621     __ sub_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6622   %}
 6623   ins_pipe(faddF_reg_reg);
 6624 %}
 6625 
 6626 //  Sub float double precision
 6627 instruct subD_reg_reg(regD dst, regD src1, regD src2) %{
 6628   match(Set dst (SubD src1 src2));
 6629 
 6630   size(4);
 6631   format %{ &quot;FSUBD  $dst,$src1,$src2&quot; %}
 6632   ins_encode %{
 6633     __ sub_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6634   %}
 6635   ins_pipe(faddD_reg_reg);
 6636 %}
 6637 
 6638 //  Mul float single precision
 6639 instruct mulF_reg_reg(regF dst, regF src1, regF src2) %{
 6640   match(Set dst (MulF src1 src2));
 6641 
 6642   size(4);
 6643   format %{ &quot;FMULS  $dst,$src1,$src2&quot; %}
 6644   ins_encode %{
 6645     __ mul_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6646   %}
 6647 
 6648   ins_pipe(fmulF_reg_reg);
 6649 %}
 6650 
 6651 //  Mul float double precision
 6652 instruct mulD_reg_reg(regD dst, regD src1, regD src2) %{
 6653   match(Set dst (MulD src1 src2));
 6654 
 6655   size(4);
 6656   format %{ &quot;FMULD  $dst,$src1,$src2&quot; %}
 6657   ins_encode %{
 6658     __ mul_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6659   %}
 6660 
 6661   ins_pipe(fmulD_reg_reg);
 6662 %}
 6663 
 6664 //  Div float single precision
 6665 instruct divF_reg_reg(regF dst, regF src1, regF src2) %{
 6666   match(Set dst (DivF src1 src2));
 6667 
 6668   size(4);
 6669   format %{ &quot;FDIVS  $dst,$src1,$src2&quot; %}
 6670   ins_encode %{
 6671     __ div_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6672   %}
 6673 
 6674   ins_pipe(fdivF_reg_reg);
 6675 %}
 6676 
 6677 //  Div float double precision
 6678 instruct divD_reg_reg(regD dst, regD src1, regD src2) %{
 6679   match(Set dst (DivD src1 src2));
 6680 
 6681   size(4);
 6682   format %{ &quot;FDIVD  $dst,$src1,$src2&quot; %}
 6683   ins_encode %{
 6684     __ div_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 6685   %}
 6686 
 6687   ins_pipe(fdivD_reg_reg);
 6688 %}
 6689 
 6690 //  Absolute float double precision
 6691 instruct absD_reg(regD dst, regD src) %{
 6692   match(Set dst (AbsD src));
 6693 
 6694   size(4);
 6695   format %{ &quot;FABSd  $dst,$src&quot; %}
 6696   ins_encode %{
 6697     __ abs_double($dst$$FloatRegister, $src$$FloatRegister);
 6698   %}
 6699   ins_pipe(faddD_reg);
 6700 %}
 6701 
 6702 //  Absolute float single precision
 6703 instruct absF_reg(regF dst, regF src) %{
 6704   match(Set dst (AbsF src));
 6705   format %{ &quot;FABSs  $dst,$src&quot; %}
 6706   ins_encode %{
 6707     __ abs_float($dst$$FloatRegister, $src$$FloatRegister);
 6708   %}
 6709   ins_pipe(faddF_reg);
 6710 %}
 6711 
 6712 instruct negF_reg(regF dst, regF src) %{
 6713   match(Set dst (NegF src));
 6714 
 6715   size(4);
 6716   format %{ &quot;FNEGs  $dst,$src&quot; %}
 6717   ins_encode %{
 6718     __ neg_float($dst$$FloatRegister, $src$$FloatRegister);
 6719   %}
 6720   ins_pipe(faddF_reg);
 6721 %}
 6722 
 6723 instruct negD_reg(regD dst, regD src) %{
 6724   match(Set dst (NegD src));
 6725 
 6726   format %{ &quot;FNEGd  $dst,$src&quot; %}
 6727   ins_encode %{
 6728     __ neg_double($dst$$FloatRegister, $src$$FloatRegister);
 6729   %}
 6730   ins_pipe(faddD_reg);
 6731 %}
 6732 
 6733 //  Sqrt float double precision
 6734 instruct sqrtF_reg_reg(regF dst, regF src) %{
 6735   match(Set dst (ConvD2F (SqrtD (ConvF2D src))));
 6736 
 6737   size(4);
 6738   format %{ &quot;FSQRTS $dst,$src&quot; %}
 6739   ins_encode %{
 6740     __ sqrt_float($dst$$FloatRegister, $src$$FloatRegister);
 6741   %}
 6742   ins_pipe(fdivF_reg_reg);
 6743 %}
 6744 
 6745 //  Sqrt float double precision
 6746 instruct sqrtD_reg_reg(regD dst, regD src) %{
 6747   match(Set dst (SqrtD src));
 6748 
 6749   size(4);
 6750   format %{ &quot;FSQRTD $dst,$src&quot; %}
 6751   ins_encode %{
 6752     __ sqrt_double($dst$$FloatRegister, $src$$FloatRegister);
 6753   %}
 6754   ins_pipe(fdivD_reg_reg);
 6755 %}
 6756 
 6757 //----------Logical Instructions-----------------------------------------------
 6758 // And Instructions
 6759 // Register And
 6760 instruct andI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6761   match(Set dst (AndI src1 src2));
 6762 
 6763   size(4);
 6764   format %{ &quot;and_32 $dst,$src1,$src2&quot; %}
 6765   ins_encode %{
 6766     __ and_32($dst$$Register, $src1$$Register, $src2$$Register);
 6767   %}
 6768   ins_pipe(ialu_reg_reg);
 6769 %}
 6770 
 6771 instruct andshlI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6772   match(Set dst (AndI src1 (LShiftI src2 src3)));
 6773 
 6774   size(4);
 6775   format %{ &quot;AND    $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 6776   ins_encode %{
 6777     __ andr($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$Register));
 6778   %}
 6779   ins_pipe(ialu_reg_reg);
 6780 %}
 6781 
 6782 instruct andshlI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 6783   match(Set dst (AndI src1 (LShiftI src2 src3)));
 6784 
 6785   size(4);
 6786   format %{ &quot;and_32 $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 6787   ins_encode %{
 6788     __ and_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$constant));
 6789   %}
 6790   ins_pipe(ialu_reg_reg);
 6791 %}
 6792 
 6793 instruct andsarI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6794   match(Set dst (AndI src1 (RShiftI src2 src3)));
 6795 
 6796   size(4);
 6797   format %{ &quot;AND    $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 6798   ins_encode %{
 6799     __ andr($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$Register));
 6800   %}
 6801   ins_pipe(ialu_reg_reg);
 6802 %}
 6803 
 6804 instruct andsarI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 6805   match(Set dst (AndI src1 (RShiftI src2 src3)));
 6806 
 6807   size(4);
 6808   format %{ &quot;and_32 $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 6809   ins_encode %{
 6810     __ and_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$constant));
 6811   %}
 6812   ins_pipe(ialu_reg_reg);
 6813 %}
 6814 
 6815 instruct andshrI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6816   match(Set dst (AndI src1 (URShiftI src2 src3)));
 6817 
 6818   size(4);
 6819   format %{ &quot;AND    $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 6820   ins_encode %{
 6821     __ andr($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$Register));
 6822   %}
 6823   ins_pipe(ialu_reg_reg);
 6824 %}
 6825 
 6826 instruct andshrI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 6827   match(Set dst (AndI src1 (URShiftI src2 src3)));
 6828 
 6829   size(4);
 6830   format %{ &quot;and_32 $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 6831   ins_encode %{
 6832     __ and_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$constant));
 6833   %}
 6834   ins_pipe(ialu_reg_reg);
 6835 %}
 6836 
 6837 // Immediate And
 6838 instruct andI_reg_limm(iRegI dst, iRegI src1, limmI src2) %{
 6839   match(Set dst (AndI src1 src2));
 6840 
 6841   size(4);
 6842   format %{ &quot;and_32 $dst,$src1,$src2\t! int&quot; %}
 6843   ins_encode %{
 6844     __ and_32($dst$$Register, $src1$$Register, $src2$$constant);
 6845   %}
 6846   ins_pipe(ialu_reg_imm);
 6847 %}
 6848 
 6849 instruct andI_reg_limmn(iRegI dst, iRegI src1, limmIn src2) %{
 6850   match(Set dst (AndI src1 src2));
 6851 
 6852   size(4);
 6853   format %{ &quot;bic    $dst,$src1,~$src2\t! int&quot; %}
 6854   ins_encode %{
 6855     __ bic($dst$$Register, $src1$$Register, ~$src2$$constant);
 6856   %}
 6857   ins_pipe(ialu_reg_imm);
 6858 %}
 6859 
 6860 // Register And Long
 6861 instruct andL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6862   match(Set dst (AndL src1 src2));
 6863 
 6864   ins_cost(DEFAULT_COST);
 6865   size(8);
 6866   format %{ &quot;AND    $dst,$src1,$src2\t! long&quot; %}
 6867   ins_encode %{
 6868     __ andr($dst$$Register, $src1$$Register, $src2$$Register);
 6869     __ andr($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), $src2$$Register-&gt;successor());
 6870   %}
 6871   ins_pipe(ialu_reg_reg);
 6872 %}
 6873 
 6874 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 6875 // (hi($con$$constant), lo($con$$constant)) becomes
 6876 instruct andL_reg_immRot(iRegL dst, iRegL src1, immLlowRot con) %{
 6877   match(Set dst (AndL src1 con));
 6878   ins_cost(DEFAULT_COST);
 6879   size(8);
 6880   format %{ &quot;AND    $dst,$src1,$con\t! long&quot; %}
 6881   ins_encode %{
 6882     __ andr($dst$$Register, $src1$$Register, $con$$constant);
 6883     __ andr($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), 0);
 6884   %}
 6885   ins_pipe(ialu_reg_imm);
 6886 %}
 6887 
 6888 // Or Instructions
 6889 // Register Or
 6890 instruct orI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 6891   match(Set dst (OrI src1 src2));
 6892 
 6893   size(4);
 6894   format %{ &quot;orr_32 $dst,$src1,$src2\t! int&quot; %}
 6895   ins_encode %{
 6896     __ orr_32($dst$$Register, $src1$$Register, $src2$$Register);
 6897   %}
 6898   ins_pipe(ialu_reg_reg);
 6899 %}
 6900 
 6901 instruct orshlI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6902   match(Set dst (OrI src1 (LShiftI src2 src3)));
 6903 
 6904   size(4);
 6905   format %{ &quot;OR    $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 6906   ins_encode %{
 6907     __ orr($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$Register));
 6908   %}
 6909   ins_pipe(ialu_reg_reg);
 6910 %}
 6911 
 6912 instruct orshlI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 6913   match(Set dst (OrI src1 (LShiftI src2 src3)));
 6914 
 6915   size(4);
 6916   format %{ &quot;orr_32 $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 6917   ins_encode %{
 6918     __ orr_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$constant));
 6919   %}
 6920   ins_pipe(ialu_reg_reg);
 6921 %}
 6922 
 6923 instruct orsarI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6924   match(Set dst (OrI src1 (RShiftI src2 src3)));
 6925 
 6926   size(4);
 6927   format %{ &quot;OR    $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 6928   ins_encode %{
 6929     __ orr($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$Register));
 6930   %}
 6931   ins_pipe(ialu_reg_reg);
 6932 %}
 6933 
 6934 instruct orsarI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 6935   match(Set dst (OrI src1 (RShiftI src2 src3)));
 6936 
 6937   size(4);
 6938   format %{ &quot;orr_32 $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 6939   ins_encode %{
 6940     __ orr_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$constant));
 6941   %}
 6942   ins_pipe(ialu_reg_reg);
 6943 %}
 6944 
 6945 instruct orshrI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 6946   match(Set dst (OrI src1 (URShiftI src2 src3)));
 6947 
 6948   size(4);
 6949   format %{ &quot;OR    $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 6950   ins_encode %{
 6951     __ orr($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$Register));
 6952   %}
 6953   ins_pipe(ialu_reg_reg);
 6954 %}
 6955 
 6956 instruct orshrI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 6957   match(Set dst (OrI src1 (URShiftI src2 src3)));
 6958 
 6959   size(4);
 6960   format %{ &quot;orr_32 $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 6961   ins_encode %{
 6962     __ orr_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$constant));
 6963   %}
 6964   ins_pipe(ialu_reg_reg);
 6965 %}
 6966 
 6967 // Immediate Or
 6968 instruct orI_reg_limm(iRegI dst, iRegI src1, limmI src2) %{
 6969   match(Set dst (OrI src1 src2));
 6970 
 6971   size(4);
 6972   format %{ &quot;orr_32  $dst,$src1,$src2&quot; %}
 6973   ins_encode %{
 6974     __ orr_32($dst$$Register, $src1$$Register, $src2$$constant);
 6975   %}
 6976   ins_pipe(ialu_reg_imm);
 6977 %}
 6978 // TODO: orn_32 with limmIn
 6979 
 6980 // Register Or Long
 6981 instruct orL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 6982   match(Set dst (OrL src1 src2));
 6983 
 6984   ins_cost(DEFAULT_COST);
 6985   size(8);
 6986   format %{ &quot;OR     $dst.lo,$src1.lo,$src2.lo\t! long\n\t&quot;
 6987             &quot;OR     $dst.hi,$src1.hi,$src2.hi&quot; %}
 6988   ins_encode %{
 6989     __ orr($dst$$Register, $src1$$Register, $src2$$Register);
 6990     __ orr($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), $src2$$Register-&gt;successor());
 6991   %}
 6992   ins_pipe(ialu_reg_reg);
 6993 %}
 6994 
 6995 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 6996 // (hi($con$$constant), lo($con$$constant)) becomes
 6997 instruct orL_reg_immRot(iRegL dst, iRegL src1, immLlowRot con) %{
 6998   match(Set dst (OrL src1 con));
 6999   ins_cost(DEFAULT_COST);
 7000   size(8);
 7001   format %{ &quot;OR     $dst.lo,$src1.lo,$con\t! long\n\t&quot;
 7002             &quot;OR     $dst.hi,$src1.hi,$con&quot; %}
 7003   ins_encode %{
 7004     __ orr($dst$$Register, $src1$$Register, $con$$constant);
 7005     __ orr($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), 0);
 7006   %}
 7007   ins_pipe(ialu_reg_imm);
 7008 %}
 7009 
 7010 #ifdef TODO
 7011 // Use SPRegP to match Rthread (TLS register) without spilling.
 7012 // Use store_ptr_RegP to match Rthread (TLS register) without spilling.
 7013 // Use sp_ptr_RegP to match Rthread (TLS register) without spilling.
 7014 instruct orI_reg_castP2X(iRegI dst, iRegI src1, sp_ptr_RegP src2) %{
 7015   match(Set dst (OrI src1 (CastP2X src2)));
 7016   size(4);
 7017   format %{ &quot;OR     $dst,$src1,$src2&quot; %}
 7018   ins_encode %{
 7019     __ orr($dst$$Register, $src1$$Register, $src2$$Register);
 7020   %}
 7021   ins_pipe(ialu_reg_reg);
 7022 %}
 7023 #endif
 7024 
 7025 // Xor Instructions
 7026 // Register Xor
 7027 instruct xorI_reg_reg(iRegI dst, iRegI src1, iRegI src2) %{
 7028   match(Set dst (XorI src1 src2));
 7029 
 7030   size(4);
 7031   format %{ &quot;eor_32 $dst,$src1,$src2&quot; %}
 7032   ins_encode %{
 7033     __ eor_32($dst$$Register, $src1$$Register, $src2$$Register);
 7034   %}
 7035   ins_pipe(ialu_reg_reg);
 7036 %}
 7037 
 7038 instruct xorshlI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 7039   match(Set dst (XorI src1 (LShiftI src2 src3)));
 7040 
 7041   size(4);
 7042   format %{ &quot;XOR    $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 7043   ins_encode %{
 7044     __ eor($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$Register));
 7045   %}
 7046   ins_pipe(ialu_reg_reg);
 7047 %}
 7048 
 7049 instruct xorshlI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 7050   match(Set dst (XorI src1 (LShiftI src2 src3)));
 7051 
 7052   size(4);
 7053   format %{ &quot;eor_32 $dst,$src1,$src2&lt;&lt;$src3&quot; %}
 7054   ins_encode %{
 7055     __ eor_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsl, $src3$$constant));
 7056   %}
 7057   ins_pipe(ialu_reg_reg);
 7058 %}
 7059 
 7060 instruct xorsarI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 7061   match(Set dst (XorI src1 (RShiftI src2 src3)));
 7062 
 7063   size(4);
 7064   format %{ &quot;XOR    $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 7065   ins_encode %{
 7066     __ eor($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$Register));
 7067   %}
 7068   ins_pipe(ialu_reg_reg);
 7069 %}
 7070 
 7071 instruct xorsarI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 7072   match(Set dst (XorI src1 (RShiftI src2 src3)));
 7073 
 7074   size(4);
 7075   format %{ &quot;eor_32 $dst,$src1,$src2&gt;&gt;$src3&quot; %}
 7076   ins_encode %{
 7077     __ eor_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, asr, $src3$$constant));
 7078   %}
 7079   ins_pipe(ialu_reg_reg);
 7080 %}
 7081 
 7082 instruct xorshrI_reg_reg_reg(iRegI dst, iRegI src1, iRegI src2, iRegI src3) %{
 7083   match(Set dst (XorI src1 (URShiftI src2 src3)));
 7084 
 7085   size(4);
 7086   format %{ &quot;XOR    $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 7087   ins_encode %{
 7088     __ eor($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$Register));
 7089   %}
 7090   ins_pipe(ialu_reg_reg);
 7091 %}
 7092 
 7093 instruct xorshrI_reg_reg_imm(iRegI dst, iRegI src1, iRegI src2, immU5 src3) %{
 7094   match(Set dst (XorI src1 (URShiftI src2 src3)));
 7095 
 7096   size(4);
 7097   format %{ &quot;eor_32 $dst,$src1,$src2&gt;&gt;&gt;$src3&quot; %}
 7098   ins_encode %{
 7099     __ eor_32($dst$$Register, $src1$$Register, AsmOperand($src2$$Register, lsr, $src3$$constant));
 7100   %}
 7101   ins_pipe(ialu_reg_reg);
 7102 %}
 7103 
 7104 // Immediate Xor
 7105 instruct xorI_reg_imm(iRegI dst, iRegI src1, limmI src2) %{
 7106   match(Set dst (XorI src1 src2));
 7107 
 7108   size(4);
 7109   format %{ &quot;eor_32 $dst,$src1,$src2&quot; %}
 7110   ins_encode %{
 7111     __ eor_32($dst$$Register, $src1$$Register, $src2$$constant);
 7112   %}
 7113   ins_pipe(ialu_reg_imm);
 7114 %}
 7115 
 7116 // Register Xor Long
 7117 instruct xorL_reg_reg(iRegL dst, iRegL src1, iRegL src2) %{
 7118   match(Set dst (XorL src1 src2));
 7119   ins_cost(DEFAULT_COST);
 7120   size(8);
 7121   format %{ &quot;XOR     $dst.hi,$src1.hi,$src2.hi\t! long\n\t&quot;
 7122             &quot;XOR     $dst.lo,$src1.lo,$src2.lo\t! long&quot; %}
 7123   ins_encode %{
 7124     __ eor($dst$$Register, $src1$$Register, $src2$$Register);
 7125     __ eor($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), $src2$$Register-&gt;successor());
 7126   %}
 7127   ins_pipe(ialu_reg_reg);
 7128 %}
 7129 
 7130 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7131 // (hi($con$$constant), lo($con$$constant)) becomes
 7132 instruct xorL_reg_immRot(iRegL dst, iRegL src1, immLlowRot con) %{
 7133   match(Set dst (XorL src1 con));
 7134   ins_cost(DEFAULT_COST);
 7135   size(8);
 7136   format %{ &quot;XOR     $dst.hi,$src1.hi,$con\t! long\n\t&quot;
 7137             &quot;XOR     $dst.lo,$src1.lo,0\t! long&quot; %}
 7138   ins_encode %{
 7139     __ eor($dst$$Register, $src1$$Register, $con$$constant);
 7140     __ eor($dst$$Register-&gt;successor(), $src1$$Register-&gt;successor(), 0);
 7141   %}
 7142   ins_pipe(ialu_reg_imm);
 7143 %}
 7144 
 7145 //----------Convert to Boolean-------------------------------------------------
 7146 instruct convI2B( iRegI dst, iRegI src, flagsReg ccr ) %{
 7147   match(Set dst (Conv2B src));
 7148   effect(KILL ccr);
 7149   size(12);
 7150   ins_cost(DEFAULT_COST*2);
 7151   format %{ &quot;TST    $src,$src \n\t&quot;
 7152             &quot;MOV    $dst, 0   \n\t&quot;
 7153             &quot;MOV.ne $dst, 1&quot; %}
 7154   ins_encode %{ // FIXME: can do better?
 7155     __ tst($src$$Register, $src$$Register);
 7156     __ mov($dst$$Register, 0);
 7157     __ mov($dst$$Register, 1, ne);
 7158   %}
 7159   ins_pipe(ialu_reg_ialu);
 7160 %}
 7161 
 7162 instruct convP2B( iRegI dst, iRegP src, flagsReg ccr ) %{
 7163   match(Set dst (Conv2B src));
 7164   effect(KILL ccr);
 7165   size(12);
 7166   ins_cost(DEFAULT_COST*2);
 7167   format %{ &quot;TST    $src,$src \n\t&quot;
 7168             &quot;MOV    $dst, 0   \n\t&quot;
 7169             &quot;MOV.ne $dst, 1&quot; %}
 7170   ins_encode %{
 7171     __ tst($src$$Register, $src$$Register);
 7172     __ mov($dst$$Register, 0);
 7173     __ mov($dst$$Register, 1, ne);
 7174   %}
 7175   ins_pipe(ialu_reg_ialu);
 7176 %}
 7177 
 7178 instruct cmpLTMask_reg_reg( iRegI dst, iRegI p, iRegI q, flagsReg ccr ) %{
 7179   match(Set dst (CmpLTMask p q));
 7180   effect( KILL ccr );
 7181   ins_cost(DEFAULT_COST*3);
 7182   format %{ &quot;CMP    $p,$q\n\t&quot;
 7183             &quot;MOV    $dst, #0\n\t&quot;
 7184             &quot;MOV.lt $dst, #-1&quot; %}
 7185   ins_encode %{
 7186     __ cmp($p$$Register, $q$$Register);
 7187     __ mov($dst$$Register, 0);
 7188     __ mvn($dst$$Register, 0, lt);
 7189   %}
 7190   ins_pipe(ialu_reg_reg_ialu);
 7191 %}
 7192 
 7193 instruct cmpLTMask_reg_imm( iRegI dst, iRegI p, aimmI q, flagsReg ccr ) %{
 7194   match(Set dst (CmpLTMask p q));
 7195   effect( KILL ccr );
 7196   ins_cost(DEFAULT_COST*3);
 7197   format %{ &quot;CMP    $p,$q\n\t&quot;
 7198             &quot;MOV    $dst, #0\n\t&quot;
 7199             &quot;MOV.lt $dst, #-1&quot; %}
 7200   ins_encode %{
 7201     __ cmp($p$$Register, $q$$constant);
 7202     __ mov($dst$$Register, 0);
 7203     __ mvn($dst$$Register, 0, lt);
 7204   %}
 7205   ins_pipe(ialu_reg_reg_ialu);
 7206 %}
 7207 
 7208 instruct cadd_cmpLTMask3( iRegI p, iRegI q, iRegI y, iRegI z, flagsReg ccr ) %{
 7209   match(Set z (AddI (AndI (CmpLTMask p q) y) z));
 7210   effect( KILL ccr );
 7211   ins_cost(DEFAULT_COST*2);
 7212   format %{ &quot;CMP    $p,$q\n\t&quot;
 7213             &quot;ADD.lt $z,$y,$z&quot; %}
 7214   ins_encode %{
 7215     __ cmp($p$$Register, $q$$Register);
 7216     __ add($z$$Register, $y$$Register, $z$$Register, lt);
 7217   %}
 7218   ins_pipe( cadd_cmpltmask );
 7219 %}
 7220 
 7221 // FIXME: remove unused &quot;dst&quot;
 7222 instruct cadd_cmpLTMask4( iRegI dst, iRegI p, aimmI q, iRegI y, iRegI z, flagsReg ccr ) %{
 7223   match(Set z (AddI (AndI (CmpLTMask p q) y) z));
 7224   effect( KILL ccr );
 7225   ins_cost(DEFAULT_COST*2);
 7226   format %{ &quot;CMP    $p,$q\n\t&quot;
 7227             &quot;ADD.lt $z,$y,$z&quot; %}
 7228   ins_encode %{
 7229     __ cmp($p$$Register, $q$$constant);
 7230     __ add($z$$Register, $y$$Register, $z$$Register, lt);
 7231   %}
 7232   ins_pipe( cadd_cmpltmask );
 7233 %}
 7234 
 7235 instruct cadd_cmpLTMask( iRegI p, iRegI q, iRegI y, flagsReg ccr ) %{
 7236   match(Set p (AddI (AndI (CmpLTMask p q) y) (SubI p q)));
 7237   effect( KILL ccr );
 7238   ins_cost(DEFAULT_COST*2);
 7239   format %{ &quot;SUBS   $p,$p,$q\n\t&quot;
 7240             &quot;ADD.lt $p,$y,$p&quot; %}
 7241   ins_encode %{
 7242     __ subs($p$$Register, $p$$Register, $q$$Register);
 7243     __ add($p$$Register, $y$$Register, $p$$Register, lt);
 7244   %}
 7245   ins_pipe( cadd_cmpltmask );
 7246 %}
 7247 
 7248 //----------Arithmetic Conversion Instructions---------------------------------
 7249 // The conversions operations are all Alpha sorted.  Please keep it that way!
 7250 
 7251 instruct convD2F_reg(regF dst, regD src) %{
 7252   match(Set dst (ConvD2F src));
 7253   size(4);
 7254   format %{ &quot;FCVTSD  $dst,$src&quot; %}
 7255   ins_encode %{
 7256     __ convert_d2f($dst$$FloatRegister, $src$$FloatRegister);
 7257   %}
 7258   ins_pipe(fcvtD2F);
 7259 %}
 7260 
 7261 // Convert a double to an int in a float register.
 7262 // If the double is a NAN, stuff a zero in instead.
 7263 
 7264 instruct convD2I_reg_reg(iRegI dst, regD src, regF tmp) %{
 7265   match(Set dst (ConvD2I src));
 7266   effect( TEMP tmp );
 7267   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST); // FIXME
 7268   format %{ &quot;FTOSIZD  $tmp,$src\n\t&quot;
 7269             &quot;FMRS     $dst, $tmp&quot; %}
 7270   ins_encode %{
 7271     __ ftosizd($tmp$$FloatRegister, $src$$FloatRegister);
 7272     __ fmrs($dst$$Register, $tmp$$FloatRegister);
 7273   %}
 7274   ins_pipe(fcvtD2I);
 7275 %}
 7276 
 7277 // Convert a double to a long in a double register.
 7278 // If the double is a NAN, stuff a zero in instead.
 7279 
 7280 // Double to Long conversion
 7281 instruct convD2L_reg(R0R1RegL dst, regD src) %{
 7282   match(Set dst (ConvD2L src));
 7283   effect(CALL);
 7284   ins_cost(MEMORY_REF_COST); // FIXME
 7285   format %{ &quot;convD2L    $dst,$src\t ! call to SharedRuntime::d2l&quot; %}
 7286   ins_encode %{
 7287 #ifndef __ABI_HARD__
 7288     __ fmrrd($dst$$Register, $dst$$Register-&gt;successor(), $src$$FloatRegister);
 7289 #else
 7290     if ($src$$FloatRegister != D0) {
 7291       __ mov_double(D0, $src$$FloatRegister);
 7292     }
 7293 #endif
 7294     address target = CAST_FROM_FN_PTR(address, SharedRuntime::d2l);
 7295     __ call(target, relocInfo::runtime_call_type);
 7296   %}
 7297   ins_pipe(fcvtD2L);
 7298 %}
 7299 
 7300 instruct convF2D_reg(regD dst, regF src) %{
 7301   match(Set dst (ConvF2D src));
 7302   size(4);
 7303   format %{ &quot;FCVTDS  $dst,$src&quot; %}
 7304   ins_encode %{
 7305     __ convert_f2d($dst$$FloatRegister, $src$$FloatRegister);
 7306   %}
 7307   ins_pipe(fcvtF2D);
 7308 %}
 7309 
 7310 instruct convF2I_reg_reg(iRegI dst, regF src, regF tmp) %{
 7311   match(Set dst (ConvF2I src));
 7312   effect( TEMP tmp );
 7313   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST); // FIXME
 7314   size(8);
 7315   format %{ &quot;FTOSIZS  $tmp,$src\n\t&quot;
 7316             &quot;FMRS     $dst, $tmp&quot; %}
 7317   ins_encode %{
 7318     __ ftosizs($tmp$$FloatRegister, $src$$FloatRegister);
 7319     __ fmrs($dst$$Register, $tmp$$FloatRegister);
 7320   %}
 7321   ins_pipe(fcvtF2I);
 7322 %}
 7323 
 7324 // Float to Long conversion
 7325 instruct convF2L_reg(R0R1RegL dst, regF src, R0RegI arg1) %{
 7326   match(Set dst (ConvF2L src));
 7327   ins_cost(DEFAULT_COST*2 + MEMORY_REF_COST*2 + BRANCH_COST); // FIXME
 7328   effect(CALL);
 7329   format %{ &quot;convF2L  $dst,$src\t! call to SharedRuntime::f2l&quot; %}
 7330   ins_encode %{
 7331 #ifndef __ABI_HARD__
 7332     __ fmrs($arg1$$Register, $src$$FloatRegister);
 7333 #else
 7334     if($src$$FloatRegister != S0) {
 7335       __ mov_float(S0, $src$$FloatRegister);
 7336     }
 7337 #endif
 7338     address target = CAST_FROM_FN_PTR(address, SharedRuntime::f2l);
 7339     __ call(target, relocInfo::runtime_call_type);
 7340   %}
 7341   ins_pipe(fcvtF2L);
 7342 %}
 7343 
 7344 instruct convI2D_reg_reg(iRegI src, regD_low dst) %{
 7345   match(Set dst (ConvI2D src));
 7346   ins_cost(DEFAULT_COST + MEMORY_REF_COST); // FIXME
 7347   size(8);
 7348   format %{ &quot;FMSR     $dst,$src \n\t&quot;
 7349             &quot;FSITOD   $dst $dst&quot;%}
 7350   ins_encode %{
 7351       __ fmsr($dst$$FloatRegister, $src$$Register);
 7352       __ fsitod($dst$$FloatRegister, $dst$$FloatRegister);
 7353   %}
 7354   ins_pipe(fcvtI2D);
 7355 %}
 7356 
 7357 instruct convI2F_reg_reg( regF dst, iRegI src ) %{
 7358   match(Set dst (ConvI2F src));
 7359   ins_cost(DEFAULT_COST + MEMORY_REF_COST); // FIXME
 7360   size(8);
 7361   format %{ &quot;FMSR     $dst,$src \n\t&quot;
 7362             &quot;FSITOS   $dst, $dst&quot;%}
 7363   ins_encode %{
 7364       __ fmsr($dst$$FloatRegister, $src$$Register);
 7365       __ fsitos($dst$$FloatRegister, $dst$$FloatRegister);
 7366   %}
 7367   ins_pipe(fcvtI2F);
 7368 %}
 7369 
 7370 instruct convI2L_reg(iRegL dst, iRegI src) %{
 7371   match(Set dst (ConvI2L src));
 7372   size(8);
 7373   format %{ &quot;MOV    $dst.lo, $src \n\t&quot;
 7374             &quot;ASR    $dst.hi,$src,31\t! int-&gt;long&quot; %}
 7375   ins_encode %{
 7376     __ mov($dst$$Register, $src$$Register);
 7377     __ mov($dst$$Register-&gt;successor(), AsmOperand($src$$Register, asr, 31));
 7378   %}
 7379   ins_pipe(ialu_reg_reg);
 7380 %}
 7381 
 7382 // Zero-extend convert int to long
 7383 instruct convI2L_reg_zex(iRegL dst, iRegI src, immL_32bits mask ) %{
 7384   match(Set dst (AndL (ConvI2L src) mask) );
 7385   size(8);
 7386   format %{ &quot;MOV    $dst.lo,$src.lo\t! zero-extend int to long\n\t&quot;
 7387             &quot;MOV    $dst.hi, 0&quot;%}
 7388   ins_encode %{
 7389     __ mov($dst$$Register, $src$$Register);
 7390     __ mov($dst$$Register-&gt;successor(), 0);
 7391   %}
 7392   ins_pipe(ialu_reg_reg);
 7393 %}
 7394 
 7395 // Zero-extend long
 7396 instruct zerox_long(iRegL dst, iRegL src, immL_32bits mask ) %{
 7397   match(Set dst (AndL src mask) );
 7398   size(8);
 7399   format %{ &quot;MOV    $dst.lo,$src.lo\t! zero-extend long\n\t&quot;
 7400             &quot;MOV    $dst.hi, 0&quot;%}
 7401   ins_encode %{
 7402     __ mov($dst$$Register, $src$$Register);
 7403     __ mov($dst$$Register-&gt;successor(), 0);
 7404   %}
 7405   ins_pipe(ialu_reg_reg);
 7406 %}
 7407 
 7408 instruct MoveF2I_reg_reg(iRegI dst, regF src) %{
 7409   match(Set dst (MoveF2I src));
 7410   effect(DEF dst, USE src);
 7411   ins_cost(MEMORY_REF_COST); // FIXME
 7412 
 7413   size(4);
 7414   format %{ &quot;FMRS   $dst,$src\t! MoveF2I&quot; %}
 7415   ins_encode %{
 7416     __ fmrs($dst$$Register, $src$$FloatRegister);
 7417   %}
 7418   ins_pipe(iload_mem); // FIXME
 7419 %}
 7420 
 7421 instruct MoveI2F_reg_reg(regF dst, iRegI src) %{
 7422   match(Set dst (MoveI2F src));
 7423   ins_cost(MEMORY_REF_COST); // FIXME
 7424 
 7425   size(4);
 7426   format %{ &quot;FMSR   $dst,$src\t! MoveI2F&quot; %}
 7427   ins_encode %{
 7428     __ fmsr($dst$$FloatRegister, $src$$Register);
 7429   %}
 7430   ins_pipe(iload_mem); // FIXME
 7431 %}
 7432 
 7433 instruct MoveD2L_reg_reg(iRegL dst, regD src) %{
 7434   match(Set dst (MoveD2L src));
 7435   effect(DEF dst, USE src);
 7436   ins_cost(MEMORY_REF_COST); // FIXME
 7437 
 7438   size(4);
 7439   format %{ &quot;FMRRD    $dst,$src\t! MoveD2L&quot; %}
 7440   ins_encode %{
 7441     __ fmrrd($dst$$Register, $dst$$Register-&gt;successor(), $src$$FloatRegister);
 7442   %}
 7443   ins_pipe(iload_mem); // FIXME
 7444 %}
 7445 
 7446 instruct MoveL2D_reg_reg(regD dst, iRegL src) %{
 7447   match(Set dst (MoveL2D src));
 7448   effect(DEF dst, USE src);
 7449   ins_cost(MEMORY_REF_COST); // FIXME
 7450 
 7451   size(4);
 7452   format %{ &quot;FMDRR   $dst,$src\t! MoveL2D&quot; %}
 7453   ins_encode %{
 7454     __ fmdrr($dst$$FloatRegister, $src$$Register, $src$$Register-&gt;successor());
 7455   %}
 7456   ins_pipe(ialu_reg_reg); // FIXME
 7457 %}
 7458 
 7459 //-----------
 7460 // Long to Double conversion
 7461 
 7462 // Magic constant, 0x43300000
 7463 instruct loadConI_x43300000(iRegI dst) %{
 7464   effect(DEF dst);
 7465   size(8);
 7466   format %{ &quot;MOV_SLOW  $dst,0x43300000\t! 2^52&quot; %}
 7467   ins_encode %{
 7468     __ mov_slow($dst$$Register, 0x43300000);
 7469   %}
 7470   ins_pipe(ialu_none);
 7471 %}
 7472 
 7473 // Magic constant, 0x41f00000
 7474 instruct loadConI_x41f00000(iRegI dst) %{
 7475   effect(DEF dst);
 7476   size(8);
 7477   format %{ &quot;MOV_SLOW  $dst, 0x41f00000\t! 2^32&quot; %}
 7478   ins_encode %{
 7479     __ mov_slow($dst$$Register, 0x41f00000);
 7480   %}
 7481   ins_pipe(ialu_none);
 7482 %}
 7483 
 7484 instruct loadConI_x0(iRegI dst) %{
 7485   effect(DEF dst);
 7486   size(4);
 7487   format %{ &quot;MOV  $dst, 0x0\t! 0&quot; %}
 7488   ins_encode %{
 7489     __ mov($dst$$Register, 0);
 7490   %}
 7491   ins_pipe(ialu_none);
 7492 %}
 7493 
 7494 // Construct a double from two float halves
 7495 instruct regDHi_regDLo_to_regD(regD_low dst, regD_low src1, regD_low src2) %{
 7496   effect(DEF dst, USE src1, USE src2);
 7497   size(8);
 7498   format %{ &quot;FCPYS  $dst.hi,$src1.hi\n\t&quot;
 7499             &quot;FCPYS  $dst.lo,$src2.lo&quot; %}
 7500   ins_encode %{
 7501     __ fcpys($dst$$FloatRegister-&gt;successor(), $src1$$FloatRegister-&gt;successor());
 7502     __ fcpys($dst$$FloatRegister, $src2$$FloatRegister);
 7503   %}
 7504   ins_pipe(faddD_reg_reg);
 7505 %}
 7506 
 7507 // Convert integer in high half of a double register (in the lower half of
 7508 // the double register file) to double
 7509 instruct convI2D_regDHi_regD(regD dst, regD_low src) %{
 7510   effect(DEF dst, USE src);
 7511   size(4);
 7512   format %{ &quot;FSITOD  $dst,$src&quot; %}
 7513   ins_encode %{
 7514     __ fsitod($dst$$FloatRegister, $src$$FloatRegister-&gt;successor());
 7515   %}
 7516   ins_pipe(fcvtLHi2D);
 7517 %}
 7518 
 7519 // Add float double precision
 7520 instruct addD_regD_regD(regD dst, regD src1, regD src2) %{
 7521   effect(DEF dst, USE src1, USE src2);
 7522   size(4);
 7523   format %{ &quot;FADDD  $dst,$src1,$src2&quot; %}
 7524   ins_encode %{
 7525     __ add_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7526   %}
 7527   ins_pipe(faddD_reg_reg);
 7528 %}
 7529 
 7530 // Sub float double precision
 7531 instruct subD_regD_regD(regD dst, regD src1, regD src2) %{
 7532   effect(DEF dst, USE src1, USE src2);
 7533   size(4);
 7534   format %{ &quot;FSUBD  $dst,$src1,$src2&quot; %}
 7535   ins_encode %{
 7536     __ sub_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7537   %}
 7538   ins_pipe(faddD_reg_reg);
 7539 %}
 7540 
 7541 // Mul float double precision
 7542 instruct mulD_regD_regD(regD dst, regD src1, regD src2) %{
 7543   effect(DEF dst, USE src1, USE src2);
 7544   size(4);
 7545   format %{ &quot;FMULD  $dst,$src1,$src2&quot; %}
 7546   ins_encode %{
 7547     __ mul_double($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 7548   %}
 7549   ins_pipe(fmulD_reg_reg);
 7550 %}
 7551 
 7552 instruct regL_to_regD(regD dst, iRegL src) %{
 7553   // No match rule to avoid chain rule match.
 7554   effect(DEF dst, USE src);
 7555   ins_cost(MEMORY_REF_COST);
 7556   size(4);
 7557   format %{ &quot;FMDRR   $dst,$src\t! regL to regD&quot; %}
 7558   ins_encode %{
 7559     __ fmdrr($dst$$FloatRegister, $src$$Register, $src$$Register-&gt;successor());
 7560   %}
 7561   ins_pipe(ialu_reg_reg); // FIXME
 7562 %}
 7563 
 7564 instruct regI_regI_to_regD(regD dst, iRegI src1, iRegI src2) %{
 7565   // No match rule to avoid chain rule match.
 7566   effect(DEF dst, USE src1, USE src2);
 7567   ins_cost(MEMORY_REF_COST);
 7568   size(4);
 7569   format %{ &quot;FMDRR   $dst,$src1,$src2\t! regI,regI to regD&quot; %}
 7570   ins_encode %{
 7571     __ fmdrr($dst$$FloatRegister, $src1$$Register, $src2$$Register);
 7572   %}
 7573   ins_pipe(ialu_reg_reg); // FIXME
 7574 %}
 7575 
 7576 instruct convL2D_reg_slow_fxtof(regD dst, iRegL src) %{
 7577   match(Set dst (ConvL2D src));
 7578   ins_cost(DEFAULT_COST*8 + MEMORY_REF_COST*6); // FIXME
 7579 
 7580   expand %{
 7581     regD_low   tmpsrc;
 7582     iRegI      ix43300000;
 7583     iRegI      ix41f00000;
 7584     iRegI      ix0;
 7585     regD_low   dx43300000;
 7586     regD       dx41f00000;
 7587     regD       tmp1;
 7588     regD_low   tmp2;
 7589     regD       tmp3;
 7590     regD       tmp4;
 7591 
 7592     regL_to_regD(tmpsrc, src);
 7593 
 7594     loadConI_x43300000(ix43300000);
 7595     loadConI_x41f00000(ix41f00000);
 7596     loadConI_x0(ix0);
 7597 
 7598     regI_regI_to_regD(dx43300000, ix0, ix43300000);
 7599     regI_regI_to_regD(dx41f00000, ix0, ix41f00000);
 7600 
 7601     convI2D_regDHi_regD(tmp1, tmpsrc);
 7602     regDHi_regDLo_to_regD(tmp2, dx43300000, tmpsrc);
 7603     subD_regD_regD(tmp3, tmp2, dx43300000);
 7604     mulD_regD_regD(tmp4, tmp1, dx41f00000);
 7605     addD_regD_regD(dst, tmp3, tmp4);
 7606   %}
 7607 %}
 7608 
 7609 instruct convL2I_reg(iRegI dst, iRegL src) %{
 7610   match(Set dst (ConvL2I src));
 7611   size(4);
 7612   format %{ &quot;MOV    $dst,$src.lo\t! long-&gt;int&quot; %}
 7613   ins_encode %{
 7614     __ mov($dst$$Register, $src$$Register);
 7615   %}
 7616   ins_pipe(ialu_move_reg_I_to_L);
 7617 %}
 7618 
 7619 // Register Shift Right Immediate
 7620 instruct shrL_reg_imm6_L2I(iRegI dst, iRegL src, immI_32_63 cnt) %{
 7621   match(Set dst (ConvL2I (RShiftL src cnt)));
 7622   size(4);
 7623   format %{ &quot;ASR    $dst,$src.hi,($cnt - 32)\t! long-&gt;int or mov if $cnt==32&quot; %}
 7624   ins_encode %{
 7625     if ($cnt$$constant == 32) {
 7626       __ mov($dst$$Register, $src$$Register-&gt;successor());
 7627     } else {
 7628       __ mov($dst$$Register, AsmOperand($src$$Register-&gt;successor(), asr, $cnt$$constant - 32));
 7629     }
 7630   %}
 7631   ins_pipe(ialu_reg_imm);
 7632 %}
 7633 
 7634 
 7635 //----------Control Flow Instructions------------------------------------------
 7636 // Compare Instructions
 7637 // Compare Integers
 7638 instruct compI_iReg(flagsReg icc, iRegI op1, iRegI op2) %{
 7639   match(Set icc (CmpI op1 op2));
 7640   effect( DEF icc, USE op1, USE op2 );
 7641 
 7642   size(4);
 7643   format %{ &quot;cmp_32 $op1,$op2\t! int&quot; %}
 7644   ins_encode %{
 7645     __ cmp_32($op1$$Register, $op2$$Register);
 7646   %}
 7647   ins_pipe(ialu_cconly_reg_reg);
 7648 %}
 7649 
 7650 #ifdef _LP64
 7651 // Compare compressed pointers
 7652 instruct compN_reg2(flagsRegU icc, iRegN op1, iRegN op2) %{
 7653   match(Set icc (CmpN op1 op2));
 7654   effect( DEF icc, USE op1, USE op2 );
 7655 
 7656   size(4);
 7657   format %{ &quot;cmp_32 $op1,$op2\t! int&quot; %}
 7658   ins_encode %{
 7659     __ cmp_32($op1$$Register, $op2$$Register);
 7660   %}
 7661   ins_pipe(ialu_cconly_reg_reg);
 7662 %}
 7663 #endif
 7664 
 7665 instruct compU_iReg(flagsRegU icc, iRegI op1, iRegI op2) %{
 7666   match(Set icc (CmpU op1 op2));
 7667 
 7668   size(4);
 7669   format %{ &quot;cmp_32 $op1,$op2\t! unsigned int&quot; %}
 7670   ins_encode %{
 7671     __ cmp_32($op1$$Register, $op2$$Register);
 7672   %}
 7673   ins_pipe(ialu_cconly_reg_reg);
 7674 %}
 7675 
 7676 instruct compI_iReg_immneg(flagsReg icc, iRegI op1, aimmIneg op2) %{
 7677   match(Set icc (CmpI op1 op2));
 7678   effect( DEF icc, USE op1 );
 7679 
 7680   size(4);
 7681   format %{ &quot;cmn_32 $op1,-$op2\t! int&quot; %}
 7682   ins_encode %{
 7683     __ cmn_32($op1$$Register, -$op2$$constant);
 7684   %}
 7685   ins_pipe(ialu_cconly_reg_imm);
 7686 %}
 7687 
 7688 instruct compI_iReg_imm(flagsReg icc, iRegI op1, aimmI op2) %{
 7689   match(Set icc (CmpI op1 op2));
 7690   effect( DEF icc, USE op1 );
 7691 
 7692   size(4);
 7693   format %{ &quot;cmp_32 $op1,$op2\t! int&quot; %}
 7694   ins_encode %{
 7695     __ cmp_32($op1$$Register, $op2$$constant);
 7696   %}
 7697   ins_pipe(ialu_cconly_reg_imm);
 7698 %}
 7699 
 7700 instruct testI_reg_reg( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, immI0 zero ) %{
 7701   match(Set icc (CmpI (AndI op1 op2) zero));
 7702   size(4);
 7703   format %{ &quot;tst_32 $op2,$op1&quot; %}
 7704 
 7705   ins_encode %{
 7706     __ tst_32($op1$$Register, $op2$$Register);
 7707   %}
 7708   ins_pipe(ialu_cconly_reg_reg_zero);
 7709 %}
 7710 
 7711 instruct testshlI_reg_reg_reg( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, iRegI op3, immI0 zero ) %{
 7712   match(Set icc (CmpI (AndI op1 (LShiftI op2 op3)) zero));
 7713   size(4);
 7714   format %{ &quot;TST   $op2,$op1&lt;&lt;$op3&quot; %}
 7715 
 7716   ins_encode %{
 7717     __ tst($op1$$Register, AsmOperand($op2$$Register, lsl, $op3$$Register));
 7718   %}
 7719   ins_pipe(ialu_cconly_reg_reg_zero);
 7720 %}
 7721 
 7722 instruct testshlI_reg_reg_imm( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, immU5 op3, immI0 zero ) %{
 7723   match(Set icc (CmpI (AndI op1 (LShiftI op2 op3)) zero));
 7724   size(4);
 7725   format %{ &quot;tst_32 $op2,$op1&lt;&lt;$op3&quot; %}
 7726 
 7727   ins_encode %{
 7728     __ tst_32($op1$$Register, AsmOperand($op2$$Register, lsl, $op3$$constant));
 7729   %}
 7730   ins_pipe(ialu_cconly_reg_reg_zero);
 7731 %}
 7732 
 7733 instruct testsarI_reg_reg_reg( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, iRegI op3, immI0 zero ) %{
 7734   match(Set icc (CmpI (AndI op1 (RShiftI op2 op3)) zero));
 7735   size(4);
 7736   format %{ &quot;TST   $op2,$op1&lt;&lt;$op3&quot; %}
 7737 
 7738   ins_encode %{
 7739     __ tst($op1$$Register, AsmOperand($op2$$Register, asr, $op3$$Register));
 7740   %}
 7741   ins_pipe(ialu_cconly_reg_reg_zero);
 7742 %}
 7743 
 7744 instruct testsarI_reg_reg_imm( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, immU5 op3, immI0 zero ) %{
 7745   match(Set icc (CmpI (AndI op1 (RShiftI op2 op3)) zero));
 7746   size(4);
 7747   format %{ &quot;tst_32 $op2,$op1&lt;&lt;$op3&quot; %}
 7748 
 7749   ins_encode %{
 7750     __ tst_32($op1$$Register, AsmOperand($op2$$Register, asr, $op3$$constant));
 7751   %}
 7752   ins_pipe(ialu_cconly_reg_reg_zero);
 7753 %}
 7754 
 7755 instruct testshrI_reg_reg_reg( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, iRegI op3, immI0 zero ) %{
 7756   match(Set icc (CmpI (AndI op1 (URShiftI op2 op3)) zero));
 7757   size(4);
 7758   format %{ &quot;TST   $op2,$op1&lt;&lt;$op3&quot; %}
 7759 
 7760   ins_encode %{
 7761     __ tst($op1$$Register, AsmOperand($op2$$Register, lsr, $op3$$Register));
 7762   %}
 7763   ins_pipe(ialu_cconly_reg_reg_zero);
 7764 %}
 7765 
 7766 instruct testshrI_reg_reg_imm( flagsReg_EQNELTGE icc, iRegI op1, iRegI op2, immU5 op3, immI0 zero ) %{
 7767   match(Set icc (CmpI (AndI op1 (URShiftI op2 op3)) zero));
 7768   size(4);
 7769   format %{ &quot;tst_32 $op2,$op1&lt;&lt;$op3&quot; %}
 7770 
 7771   ins_encode %{
 7772     __ tst_32($op1$$Register, AsmOperand($op2$$Register, lsr, $op3$$constant));
 7773   %}
 7774   ins_pipe(ialu_cconly_reg_reg_zero);
 7775 %}
 7776 
 7777 instruct testI_reg_imm( flagsReg_EQNELTGE icc, iRegI op1, limmI op2, immI0 zero ) %{
 7778   match(Set icc (CmpI (AndI op1 op2) zero));
 7779   size(4);
 7780   format %{ &quot;tst_32 $op2,$op1&quot; %}
 7781 
 7782   ins_encode %{
 7783     __ tst_32($op1$$Register, $op2$$constant);
 7784   %}
 7785   ins_pipe(ialu_cconly_reg_imm_zero);
 7786 %}
 7787 
 7788 instruct compL_reg_reg_LTGE(flagsRegL_LTGE xcc, iRegL op1, iRegL op2, iRegL tmp) %{
 7789   match(Set xcc (CmpL op1 op2));
 7790   effect( DEF xcc, USE op1, USE op2, TEMP tmp );
 7791 
 7792   size(8);
 7793   format %{ &quot;SUBS    $tmp,$op1.low,$op2.low\t\t! long\n\t&quot;
 7794             &quot;SBCS    $tmp,$op1.hi,$op2.hi&quot; %}
 7795   ins_encode %{
 7796     __ subs($tmp$$Register, $op1$$Register, $op2$$Register);
 7797     __ sbcs($tmp$$Register-&gt;successor(), $op1$$Register-&gt;successor(), $op2$$Register-&gt;successor());
 7798   %}
 7799   ins_pipe(ialu_cconly_reg_reg);
 7800 %}
 7801 
 7802 instruct compUL_reg_reg_LTGE(flagsRegUL_LTGE xcc, iRegL op1, iRegL op2, iRegL tmp) %{
 7803   match(Set xcc (CmpUL op1 op2));
 7804   effect(DEF xcc, USE op1, USE op2, TEMP tmp);
 7805 
 7806   size(8);
 7807   format %{ &quot;SUBS    $tmp,$op1.low,$op2.low\t\t! unsigned long\n\t&quot;
 7808             &quot;SBCS    $tmp,$op1.hi,$op2.hi&quot; %}
 7809   ins_encode %{
 7810     __ subs($tmp$$Register, $op1$$Register, $op2$$Register);
 7811     __ sbcs($tmp$$Register-&gt;successor(), $op1$$Register-&gt;successor(), $op2$$Register-&gt;successor());
 7812   %}
 7813   ins_pipe(ialu_cconly_reg_reg);
 7814 %}
 7815 
 7816 instruct compL_reg_reg_EQNE(flagsRegL_EQNE xcc, iRegL op1, iRegL op2) %{
 7817   match(Set xcc (CmpL op1 op2));
 7818   effect( DEF xcc, USE op1, USE op2 );
 7819 
 7820   size(8);
 7821   format %{ &quot;TEQ    $op1.hi,$op2.hi\t\t! long\n\t&quot;
 7822             &quot;TEQ.eq $op1.lo,$op2.lo&quot; %}
 7823   ins_encode %{
 7824     __ teq($op1$$Register-&gt;successor(), $op2$$Register-&gt;successor());
 7825     __ teq($op1$$Register, $op2$$Register, eq);
 7826   %}
 7827   ins_pipe(ialu_cconly_reg_reg);
 7828 %}
 7829 
 7830 instruct compL_reg_reg_LEGT(flagsRegL_LEGT xcc, iRegL op1, iRegL op2, iRegL tmp) %{
 7831   match(Set xcc (CmpL op1 op2));
 7832   effect( DEF xcc, USE op1, USE op2, TEMP tmp );
 7833 
 7834   size(8);
 7835   format %{ &quot;SUBS    $tmp,$op2.low,$op1.low\t\t! long\n\t&quot;
 7836             &quot;SBCS    $tmp,$op2.hi,$op1.hi&quot; %}
 7837   ins_encode %{
 7838     __ subs($tmp$$Register, $op2$$Register, $op1$$Register);
 7839     __ sbcs($tmp$$Register-&gt;successor(), $op2$$Register-&gt;successor(), $op1$$Register-&gt;successor());
 7840   %}
 7841   ins_pipe(ialu_cconly_reg_reg);
 7842 %}
 7843 
 7844 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7845 // (hi($con$$constant), lo($con$$constant)) becomes
 7846 instruct compL_reg_con_LTGE(flagsRegL_LTGE xcc, iRegL op1, immLlowRot con, iRegL tmp) %{
 7847   match(Set xcc (CmpL op1 con));
 7848   effect( DEF xcc, USE op1, USE con, TEMP tmp );
 7849 
 7850   size(8);
 7851   format %{ &quot;SUBS    $tmp,$op1.low,$con\t\t! long\n\t&quot;
 7852             &quot;SBCS    $tmp,$op1.hi,0&quot; %}
 7853   ins_encode %{
 7854     __ subs($tmp$$Register, $op1$$Register, $con$$constant);
 7855     __ sbcs($tmp$$Register-&gt;successor(), $op1$$Register-&gt;successor(), 0);
 7856   %}
 7857 
 7858   ins_pipe(ialu_cconly_reg_reg);
 7859 %}
 7860 
 7861 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7862 // (hi($con$$constant), lo($con$$constant)) becomes
 7863 instruct compL_reg_con_EQNE(flagsRegL_EQNE xcc, iRegL op1, immLlowRot con) %{
 7864   match(Set xcc (CmpL op1 con));
 7865   effect( DEF xcc, USE op1, USE con );
 7866 
 7867   size(8);
 7868   format %{ &quot;TEQ    $op1.hi,0\t\t! long\n\t&quot;
 7869             &quot;TEQ.eq $op1.lo,$con&quot; %}
 7870   ins_encode %{
 7871     __ teq($op1$$Register-&gt;successor(), 0);
 7872     __ teq($op1$$Register, $con$$constant, eq);
 7873   %}
 7874 
 7875   ins_pipe(ialu_cconly_reg_reg);
 7876 %}
 7877 
 7878 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7879 // (hi($con$$constant), lo($con$$constant)) becomes
 7880 instruct compL_reg_con_LEGT(flagsRegL_LEGT xcc, iRegL op1, immLlowRot con, iRegL tmp) %{
 7881   match(Set xcc (CmpL op1 con));
 7882   effect( DEF xcc, USE op1, USE con, TEMP tmp );
 7883 
 7884   size(8);
 7885   format %{ &quot;RSBS    $tmp,$op1.low,$con\t\t! long\n\t&quot;
 7886             &quot;RSCS    $tmp,$op1.hi,0&quot; %}
 7887   ins_encode %{
 7888     __ rsbs($tmp$$Register, $op1$$Register, $con$$constant);
 7889     __ rscs($tmp$$Register-&gt;successor(), $op1$$Register-&gt;successor(), 0);
 7890   %}
 7891 
 7892   ins_pipe(ialu_cconly_reg_reg);
 7893 %}
 7894 
 7895 instruct compUL_reg_reg_EQNE(flagsRegUL_EQNE xcc, iRegL op1, iRegL op2) %{
 7896   match(Set xcc (CmpUL op1 op2));
 7897   effect(DEF xcc, USE op1, USE op2);
 7898 
 7899   size(8);
 7900   format %{ &quot;TEQ    $op1.hi,$op2.hi\t\t! unsigned long\n\t&quot;
 7901             &quot;TEQ.eq $op1.lo,$op2.lo&quot; %}
 7902   ins_encode %{
 7903     __ teq($op1$$Register-&gt;successor(), $op2$$Register-&gt;successor());
 7904     __ teq($op1$$Register, $op2$$Register, eq);
 7905   %}
 7906   ins_pipe(ialu_cconly_reg_reg);
 7907 %}
 7908 
 7909 instruct compUL_reg_reg_LEGT(flagsRegUL_LEGT xcc, iRegL op1, iRegL op2, iRegL tmp) %{
 7910   match(Set xcc (CmpUL op1 op2));
 7911   effect(DEF xcc, USE op1, USE op2, TEMP tmp);
 7912 
 7913   size(8);
 7914   format %{ &quot;SUBS    $tmp,$op2.low,$op1.low\t\t! unsigned long\n\t&quot;
 7915             &quot;SBCS    $tmp,$op2.hi,$op1.hi&quot; %}
 7916   ins_encode %{
 7917     __ subs($tmp$$Register, $op2$$Register, $op1$$Register);
 7918     __ sbcs($tmp$$Register-&gt;successor(), $op2$$Register-&gt;successor(), $op1$$Register-&gt;successor());
 7919   %}
 7920   ins_pipe(ialu_cconly_reg_reg);
 7921 %}
 7922 
 7923 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7924 // (hi($con$$constant), lo($con$$constant)) becomes
 7925 instruct compUL_reg_con_LTGE(flagsRegUL_LTGE xcc, iRegL op1, immLlowRot con, iRegL tmp) %{
 7926   match(Set xcc (CmpUL op1 con));
 7927   effect(DEF xcc, USE op1, USE con, TEMP tmp);
 7928 
 7929   size(8);
 7930   format %{ &quot;SUBS    $tmp,$op1.low,$con\t\t! unsigned long\n\t&quot;
 7931             &quot;SBCS    $tmp,$op1.hi,0&quot; %}
 7932   ins_encode %{
 7933     __ subs($tmp$$Register, $op1$$Register, $con$$constant);
 7934     __ sbcs($tmp$$Register-&gt;successor(), $op1$$Register-&gt;successor(), 0);
 7935   %}
 7936 
 7937   ins_pipe(ialu_cconly_reg_reg);
 7938 %}
 7939 
 7940 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7941 // (hi($con$$constant), lo($con$$constant)) becomes
 7942 instruct compUL_reg_con_EQNE(flagsRegUL_EQNE xcc, iRegL op1, immLlowRot con) %{
 7943   match(Set xcc (CmpUL op1 con));
 7944   effect(DEF xcc, USE op1, USE con);
 7945 
 7946   size(8);
 7947   format %{ &quot;TEQ    $op1.hi,0\t\t! unsigned long\n\t&quot;
 7948             &quot;TEQ.eq $op1.lo,$con&quot; %}
 7949   ins_encode %{
 7950     __ teq($op1$$Register-&gt;successor(), 0);
 7951     __ teq($op1$$Register, $con$$constant, eq);
 7952   %}
 7953 
 7954   ins_pipe(ialu_cconly_reg_reg);
 7955 %}
 7956 
 7957 // TODO: try immLRot2 instead, (0, $con$$constant) becomes
 7958 // (hi($con$$constant), lo($con$$constant)) becomes
 7959 instruct compUL_reg_con_LEGT(flagsRegUL_LEGT xcc, iRegL op1, immLlowRot con, iRegL tmp) %{
 7960   match(Set xcc (CmpUL op1 con));
 7961   effect(DEF xcc, USE op1, USE con, TEMP tmp);
 7962 
 7963   size(8);
 7964   format %{ &quot;RSBS    $tmp,$op1.low,$con\t\t! unsigned long\n\t&quot;
 7965             &quot;RSCS    $tmp,$op1.hi,0&quot; %}
 7966   ins_encode %{
 7967     __ rsbs($tmp$$Register, $op1$$Register, $con$$constant);
 7968     __ rscs($tmp$$Register-&gt;successor(), $op1$$Register-&gt;successor(), 0);
 7969   %}
 7970 
 7971   ins_pipe(ialu_cconly_reg_reg);
 7972 %}
 7973 
 7974 /* instruct testL_reg_reg(flagsRegL xcc, iRegL op1, iRegL op2, immL0 zero) %{ */
 7975 /*   match(Set xcc (CmpL (AndL op1 op2) zero)); */
 7976 /*   ins_encode %{ */
 7977 /*     __ stop(&quot;testL_reg_reg unimplemented&quot;); */
 7978 /*   %} */
 7979 /*   ins_pipe(ialu_cconly_reg_reg); */
 7980 /* %} */
 7981 
 7982 /* // useful for checking the alignment of a pointer: */
 7983 /* instruct testL_reg_con(flagsRegL xcc, iRegL op1, immLlowRot con, immL0 zero) %{ */
 7984 /*   match(Set xcc (CmpL (AndL op1 con) zero)); */
 7985 /*   ins_encode %{ */
 7986 /*     __ stop(&quot;testL_reg_con unimplemented&quot;); */
 7987 /*   %} */
 7988 /*   ins_pipe(ialu_cconly_reg_reg); */
 7989 /* %} */
 7990 
 7991 instruct compU_iReg_imm(flagsRegU icc, iRegI op1, aimmU31 op2 ) %{
 7992   match(Set icc (CmpU op1 op2));
 7993 
 7994   size(4);
 7995   format %{ &quot;cmp_32 $op1,$op2\t! unsigned&quot; %}
 7996   ins_encode %{
 7997     __ cmp_32($op1$$Register, $op2$$constant);
 7998   %}
 7999   ins_pipe(ialu_cconly_reg_imm);
 8000 %}
 8001 
 8002 // Compare Pointers
 8003 instruct compP_iRegP(flagsRegP pcc, iRegP op1, iRegP op2 ) %{
 8004   match(Set pcc (CmpP op1 op2));
 8005 
 8006   size(4);
 8007   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8008   ins_encode %{
 8009     __ cmp($op1$$Register, $op2$$Register);
 8010   %}
 8011   ins_pipe(ialu_cconly_reg_reg);
 8012 %}
 8013 
 8014 instruct compP_iRegP_imm(flagsRegP pcc, iRegP op1, aimmP op2 ) %{
 8015   match(Set pcc (CmpP op1 op2));
 8016 
 8017   size(4);
 8018   format %{ &quot;CMP    $op1,$op2\t! ptr&quot; %}
 8019   ins_encode %{
 8020     assert($op2$$constant == 0 || _opnds[2]-&gt;constant_reloc() == relocInfo::none, &quot;reloc in cmp?&quot;);
 8021     __ cmp($op1$$Register, $op2$$constant);
 8022   %}
 8023   ins_pipe(ialu_cconly_reg_imm);
 8024 %}
 8025 
 8026 //----------Max and Min--------------------------------------------------------
 8027 // Min Instructions
 8028 // Conditional move for min
 8029 instruct cmovI_reg_lt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8030   effect( USE_DEF op2, USE op1, USE icc );
 8031 
 8032   size(4);
 8033   format %{ &quot;MOV.lt  $op2,$op1\t! min&quot; %}
 8034   ins_encode %{
 8035     __ mov($op2$$Register, $op1$$Register, lt);
 8036   %}
 8037   ins_pipe(ialu_reg_flags);
 8038 %}
 8039 
 8040 // Min Register with Register.
 8041 instruct minI_eReg(iRegI op1, iRegI op2) %{
 8042   match(Set op2 (MinI op1 op2));
 8043   ins_cost(DEFAULT_COST*2);
 8044   expand %{
 8045     flagsReg icc;
 8046     compI_iReg(icc,op1,op2);
 8047     cmovI_reg_lt(op2,op1,icc);
 8048   %}
 8049 %}
 8050 
 8051 // Max Instructions
 8052 // Conditional move for max
 8053 instruct cmovI_reg_gt( iRegI op2, iRegI op1, flagsReg icc ) %{
 8054   effect( USE_DEF op2, USE op1, USE icc );
 8055   format %{ &quot;MOV.gt  $op2,$op1\t! max&quot; %}
 8056   ins_encode %{
 8057     __ mov($op2$$Register, $op1$$Register, gt);
 8058   %}
 8059   ins_pipe(ialu_reg_flags);
 8060 %}
 8061 
 8062 // Max Register with Register
 8063 instruct maxI_eReg(iRegI op1, iRegI op2) %{
 8064   match(Set op2 (MaxI op1 op2));
 8065   ins_cost(DEFAULT_COST*2);
 8066   expand %{
 8067     flagsReg icc;
 8068     compI_iReg(icc,op1,op2);
 8069     cmovI_reg_gt(op2,op1,icc);
 8070   %}
 8071 %}
 8072 
 8073 
 8074 //----------Float Compares----------------------------------------------------
 8075 // Compare floating, generate condition code
 8076 instruct cmpF_cc(flagsRegF fcc, flagsReg icc, regF src1, regF src2) %{
 8077   match(Set icc (CmpF src1 src2));
 8078   effect(KILL fcc);
 8079 
 8080   size(8);
 8081   format %{ &quot;FCMPs  $src1,$src2\n\t&quot;
 8082             &quot;FMSTAT&quot; %}
 8083   ins_encode %{
 8084     __ fcmps($src1$$FloatRegister, $src2$$FloatRegister);
 8085     __ fmstat();
 8086   %}
 8087   ins_pipe(faddF_fcc_reg_reg_zero);
 8088 %}
 8089 
 8090 instruct cmpF0_cc(flagsRegF fcc, flagsReg icc, regF src1, immF0 src2) %{
 8091   match(Set icc (CmpF src1 src2));
 8092   effect(KILL fcc);
 8093 
 8094   size(8);
 8095   format %{ &quot;FCMPs  $src1,$src2\n\t&quot;
 8096             &quot;FMSTAT&quot; %}
 8097   ins_encode %{
 8098     __ fcmpzs($src1$$FloatRegister);
 8099     __ fmstat();
 8100   %}
 8101   ins_pipe(faddF_fcc_reg_reg_zero);
 8102 %}
 8103 
 8104 instruct cmpD_cc(flagsRegF fcc, flagsReg icc, regD src1, regD src2) %{
 8105   match(Set icc (CmpD src1 src2));
 8106   effect(KILL fcc);
 8107 
 8108   size(8);
 8109   format %{ &quot;FCMPd  $src1,$src2 \n\t&quot;
 8110             &quot;FMSTAT&quot; %}
 8111   ins_encode %{
 8112     __ fcmpd($src1$$FloatRegister, $src2$$FloatRegister);
 8113     __ fmstat();
 8114   %}
 8115   ins_pipe(faddD_fcc_reg_reg_zero);
 8116 %}
 8117 
 8118 instruct cmpD0_cc(flagsRegF fcc, flagsReg icc, regD src1, immD0 src2) %{
 8119   match(Set icc (CmpD src1 src2));
 8120   effect(KILL fcc);
 8121 
 8122   size(8);
 8123   format %{ &quot;FCMPZd  $src1,$src2 \n\t&quot;
 8124             &quot;FMSTAT&quot; %}
 8125   ins_encode %{
 8126     __ fcmpzd($src1$$FloatRegister);
 8127     __ fmstat();
 8128   %}
 8129   ins_pipe(faddD_fcc_reg_reg_zero);
 8130 %}
 8131 
 8132 // Compare floating, generate -1,0,1
 8133 instruct cmpF_reg(iRegI dst, regF src1, regF src2, flagsRegF fcc) %{
 8134   match(Set dst (CmpF3 src1 src2));
 8135   effect(KILL fcc);
 8136   ins_cost(DEFAULT_COST*3+BRANCH_COST*3); // FIXME
 8137   size(20);
 8138   // same number of instructions as code using conditional moves but
 8139   // doesn&#39;t kill integer condition register
 8140   format %{ &quot;FCMPs  $dst,$src1,$src2 \n\t&quot;
 8141             &quot;VMRS   $dst, FPSCR \n\t&quot;
 8142             &quot;OR     $dst, $dst, 0x08000000 \n\t&quot;
 8143             &quot;EOR    $dst, $dst, $dst &lt;&lt; 3 \n\t&quot;
 8144             &quot;MOV    $dst, $dst &gt;&gt; 30&quot; %}
 8145   ins_encode %{
 8146     __ fcmps($src1$$FloatRegister, $src2$$FloatRegister);
 8147     __ floating_cmp($dst$$Register);
 8148   %}
 8149   ins_pipe( floating_cmp );
 8150 %}
 8151 
 8152 instruct cmpF0_reg(iRegI dst, regF src1, immF0 src2, flagsRegF fcc) %{
 8153   match(Set dst (CmpF3 src1 src2));
 8154   effect(KILL fcc);
 8155   ins_cost(DEFAULT_COST*3+BRANCH_COST*3); // FIXME
 8156   size(20);
 8157   // same number of instructions as code using conditional moves but
 8158   // doesn&#39;t kill integer condition register
 8159   format %{ &quot;FCMPZs $dst,$src1,$src2 \n\t&quot;
 8160             &quot;VMRS   $dst, FPSCR \n\t&quot;
 8161             &quot;OR     $dst, $dst, 0x08000000 \n\t&quot;
 8162             &quot;EOR    $dst, $dst, $dst &lt;&lt; 3 \n\t&quot;
 8163             &quot;MOV    $dst, $dst &gt;&gt; 30&quot; %}
 8164   ins_encode %{
 8165     __ fcmpzs($src1$$FloatRegister);
 8166     __ floating_cmp($dst$$Register);
 8167   %}
 8168   ins_pipe( floating_cmp );
 8169 %}
 8170 
 8171 instruct cmpD_reg(iRegI dst, regD src1, regD src2, flagsRegF fcc) %{
 8172   match(Set dst (CmpD3 src1 src2));
 8173   effect(KILL fcc);
 8174   ins_cost(DEFAULT_COST*3+BRANCH_COST*3); // FIXME
 8175   size(20);
 8176   // same number of instructions as code using conditional moves but
 8177   // doesn&#39;t kill integer condition register
 8178   format %{ &quot;FCMPd  $dst,$src1,$src2 \n\t&quot;
 8179             &quot;VMRS   $dst, FPSCR \n\t&quot;
 8180             &quot;OR     $dst, $dst, 0x08000000 \n\t&quot;
 8181             &quot;EOR    $dst, $dst, $dst &lt;&lt; 3 \n\t&quot;
 8182             &quot;MOV    $dst, $dst &gt;&gt; 30&quot; %}
 8183   ins_encode %{
 8184     __ fcmpd($src1$$FloatRegister, $src2$$FloatRegister);
 8185     __ floating_cmp($dst$$Register);
 8186   %}
 8187   ins_pipe( floating_cmp );
 8188 %}
 8189 
 8190 instruct cmpD0_reg(iRegI dst, regD src1, immD0 src2, flagsRegF fcc) %{
 8191   match(Set dst (CmpD3 src1 src2));
 8192   effect(KILL fcc);
 8193   ins_cost(DEFAULT_COST*3+BRANCH_COST*3); // FIXME
 8194   size(20);
 8195   // same number of instructions as code using conditional moves but
 8196   // doesn&#39;t kill integer condition register
 8197   format %{ &quot;FCMPZd $dst,$src1,$src2 \n\t&quot;
 8198             &quot;VMRS   $dst, FPSCR \n\t&quot;
 8199             &quot;OR     $dst, $dst, 0x08000000 \n\t&quot;
 8200             &quot;EOR    $dst, $dst, $dst &lt;&lt; 3 \n\t&quot;
 8201             &quot;MOV    $dst, $dst &gt;&gt; 30&quot; %}
 8202   ins_encode %{
 8203     __ fcmpzd($src1$$FloatRegister);
 8204     __ floating_cmp($dst$$Register);
 8205   %}
 8206   ins_pipe( floating_cmp );
 8207 %}
 8208 
 8209 //----------Branches---------------------------------------------------------
 8210 // Jump
 8211 // (compare &#39;operand indIndex&#39; and &#39;instruct addP_reg_reg&#39; above)
 8212 // FIXME
 8213 instruct jumpXtnd(iRegX switch_val, iRegP tmp) %{
 8214   match(Jump switch_val);
 8215   effect(TEMP tmp);
 8216   ins_cost(350);
 8217   format %{  &quot;ADD    $tmp, $constanttablebase, $switch_val\n\t&quot;
 8218              &quot;LDR    $tmp,[$tmp + $constantoffset]\n\t&quot;
 8219              &quot;BX     $tmp&quot; %}
 8220   size(20);
 8221   ins_encode %{
 8222     Register table_reg;
 8223     Register label_reg = $tmp$$Register;
 8224     if (constant_offset() == 0) {
 8225       table_reg = $constanttablebase;
 8226       __ ldr(label_reg, Address(table_reg, $switch_val$$Register));
 8227     } else {
 8228       table_reg = $tmp$$Register;
 8229       int offset = $constantoffset;
 8230       if (is_memoryP(offset)) {
 8231         __ add(table_reg, $constanttablebase, $switch_val$$Register);
 8232         __ ldr(label_reg, Address(table_reg, offset));
 8233       } else {
 8234         __ mov_slow(table_reg, $constantoffset);
 8235         __ add(table_reg, $constanttablebase, table_reg);
 8236         __ ldr(label_reg, Address(table_reg, $switch_val$$Register));
 8237       }
 8238     }
 8239     __ jump(label_reg); // ldr + b better than ldr to PC for branch predictor?
 8240     //    __ ldr(PC, Address($table$$Register, $switch_val$$Register));
 8241   %}
 8242   ins_pipe(ialu_reg_reg);
 8243 %}
 8244 
 8245 // // Direct Branch.
 8246 instruct branch(label labl) %{
 8247   match(Goto);
 8248   effect(USE labl);
 8249 
 8250   size(4);
 8251   ins_cost(BRANCH_COST);
 8252   format %{ &quot;B     $labl&quot; %}
 8253   ins_encode %{
 8254     __ b(*($labl$$label));
 8255   %}
 8256   ins_pipe(br);
 8257 %}
 8258 
 8259 // Conditional Direct Branch
 8260 instruct branchCon(cmpOp cmp, flagsReg icc, label labl) %{
 8261   match(If cmp icc);
 8262   effect(USE labl);
 8263 
 8264   size(4);
 8265   ins_cost(BRANCH_COST);
 8266   format %{ &quot;B$cmp   $icc,$labl&quot; %}
 8267   ins_encode %{
 8268     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8269   %}
 8270   ins_pipe(br_cc);
 8271 %}
 8272 
 8273 #ifdef ARM
 8274 instruct branchCon_EQNELTGE(cmpOp0 cmp, flagsReg_EQNELTGE icc, label labl) %{
 8275   match(If cmp icc);
 8276   effect(USE labl);
 8277   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 8278 
 8279   size(4);
 8280   ins_cost(BRANCH_COST);
 8281   format %{ &quot;B$cmp   $icc,$labl&quot; %}
 8282   ins_encode %{
 8283     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8284   %}
 8285   ins_pipe(br_cc);
 8286 %}
 8287 #endif
 8288 
 8289 
 8290 instruct branchConU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8291   match(If cmp icc);
 8292   effect(USE labl);
 8293 
 8294   size(4);
 8295   ins_cost(BRANCH_COST);
 8296   format %{ &quot;B$cmp  $icc,$labl&quot; %}
 8297   ins_encode %{
 8298     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8299   %}
 8300   ins_pipe(br_cc);
 8301 %}
 8302 
 8303 instruct branchConP(cmpOpP cmp, flagsRegP pcc, label labl) %{
 8304   match(If cmp pcc);
 8305   effect(USE labl);
 8306 
 8307   size(4);
 8308   ins_cost(BRANCH_COST);
 8309   format %{ &quot;B$cmp  $pcc,$labl&quot; %}
 8310   ins_encode %{
 8311     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8312   %}
 8313   ins_pipe(br_cc);
 8314 %}
 8315 
 8316 instruct branchConL_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, label labl) %{
 8317   match(If cmp xcc);
 8318   effect(USE labl);
 8319   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8320 
 8321   size(4);
 8322   ins_cost(BRANCH_COST);
 8323   format %{ &quot;B$cmp  $xcc,$labl&quot; %}
 8324   ins_encode %{
 8325     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8326   %}
 8327   ins_pipe(br_cc);
 8328 %}
 8329 
 8330 instruct branchConL_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, label labl) %{
 8331   match(If cmp xcc);
 8332   effect(USE labl);
 8333   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8334 
 8335   size(4);
 8336   ins_cost(BRANCH_COST);
 8337   format %{ &quot;B$cmp  $xcc,$labl&quot; %}
 8338   ins_encode %{
 8339     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8340   %}
 8341   ins_pipe(br_cc);
 8342 %}
 8343 
 8344 instruct branchConL_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, label labl) %{
 8345   match(If cmp xcc);
 8346   effect(USE labl);
 8347   predicate( _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le );
 8348 
 8349   size(4);
 8350   ins_cost(BRANCH_COST);
 8351   format %{ &quot;B$cmp  $xcc,$labl&quot; %}
 8352   ins_encode %{
 8353     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8354   %}
 8355   ins_pipe(br_cc);
 8356 %}
 8357 
 8358 instruct branchConUL_LTGE(cmpOpUL cmp, flagsRegUL_LTGE xcc, label labl) %{
 8359   match(If cmp xcc);
 8360   effect(USE labl);
 8361   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge);
 8362 
 8363   size(4);
 8364   ins_cost(BRANCH_COST);
 8365   format %{ &quot;B$cmp  $xcc,$labl&quot; %}
 8366   ins_encode %{
 8367     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8368   %}
 8369   ins_pipe(br_cc);
 8370 %}
 8371 
 8372 instruct branchConUL_EQNE(cmpOpUL cmp, flagsRegUL_EQNE xcc, label labl) %{
 8373   match(If cmp xcc);
 8374   effect(USE labl);
 8375   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne);
 8376 
 8377   size(4);
 8378   ins_cost(BRANCH_COST);
 8379   format %{ &quot;B$cmp  $xcc,$labl&quot; %}
 8380   ins_encode %{
 8381     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8382   %}
 8383   ins_pipe(br_cc);
 8384 %}
 8385 
 8386 instruct branchConUL_LEGT(cmpOpUL_commute cmp, flagsRegUL_LEGT xcc, label labl) %{
 8387   match(If cmp xcc);
 8388   effect(USE labl);
 8389   predicate(_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt || _kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le);
 8390 
 8391   size(4);
 8392   ins_cost(BRANCH_COST);
 8393   format %{ &quot;B$cmp  $xcc,$labl&quot; %}
 8394   ins_encode %{
 8395     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8396   %}
 8397   ins_pipe(br_cc);
 8398 %}
 8399 
 8400 instruct branchLoopEnd(cmpOp cmp, flagsReg icc, label labl) %{
 8401   match(CountedLoopEnd cmp icc);
 8402   effect(USE labl);
 8403 
 8404   size(4);
 8405   ins_cost(BRANCH_COST);
 8406   format %{ &quot;B$cmp   $icc,$labl\t! Loop end&quot; %}
 8407   ins_encode %{
 8408     __ b(*($labl$$label), (AsmCondition)($cmp$$cmpcode));
 8409   %}
 8410   ins_pipe(br_cc);
 8411 %}
 8412 
 8413 // instruct branchLoopEndU(cmpOpU cmp, flagsRegU icc, label labl) %{
 8414 //   match(CountedLoopEnd cmp icc);
 8415 //   ins_pipe(br_cc);
 8416 // %}
 8417 
 8418 // ============================================================================
 8419 // Long Compare
 8420 //
 8421 // Currently we hold longs in 2 registers.  Comparing such values efficiently
 8422 // is tricky.  The flavor of compare used depends on whether we are testing
 8423 // for LT, LE, or EQ.  For a simple LT test we can check just the sign bit.
 8424 // The GE test is the negated LT test.  The LE test can be had by commuting
 8425 // the operands (yielding a GE test) and then negating; negate again for the
 8426 // GT test.  The EQ test is done by ORcc&#39;ing the high and low halves, and the
 8427 // NE test is negated from that.
 8428 
 8429 // Due to a shortcoming in the ADLC, it mixes up expressions like:
 8430 // (foo (CmpI (CmpL X Y) 0)) and (bar (CmpI (CmpL X 0L) 0)).  Note the
 8431 // difference between &#39;Y&#39; and &#39;0L&#39;.  The tree-matches for the CmpI sections
 8432 // are collapsed internally in the ADLC&#39;s dfa-gen code.  The match for
 8433 // (CmpI (CmpL X Y) 0) is silently replaced with (CmpI (CmpL X 0L) 0) and the
 8434 // foo match ends up with the wrong leaf.  One fix is to not match both
 8435 // reg-reg and reg-zero forms of long-compare.  This is unfortunate because
 8436 // both forms beat the trinary form of long-compare and both are very useful
 8437 // on Intel which has so few registers.
 8438 
 8439 // instruct branchCon_long(cmpOp cmp, flagsRegL xcc, label labl) %{
 8440 //   match(If cmp xcc);
 8441 //   ins_pipe(br_cc);
 8442 // %}
 8443 
 8444 // Manifest a CmpL3 result in an integer register.  Very painful.
 8445 // This is the test to avoid.
 8446 instruct cmpL3_reg_reg(iRegI dst, iRegL src1, iRegL src2, flagsReg ccr ) %{
 8447   match(Set dst (CmpL3 src1 src2) );
 8448   effect( KILL ccr );
 8449   ins_cost(6*DEFAULT_COST); // FIXME
 8450   size(32);
 8451   format %{
 8452       &quot;CMP    $src1.hi, $src2.hi\t\t! long\n&quot;
 8453     &quot;\tMOV.gt $dst, 1\n&quot;
 8454     &quot;\tmvn.lt $dst, 0\n&quot;
 8455     &quot;\tB.ne   done\n&quot;
 8456     &quot;\tSUBS   $dst, $src1.lo, $src2.lo\n&quot;
 8457     &quot;\tMOV.hi $dst, 1\n&quot;
 8458     &quot;\tmvn.lo $dst, 0\n&quot;
 8459     &quot;done:&quot;     %}
 8460   ins_encode %{
 8461     Label done;
 8462     __ cmp($src1$$Register-&gt;successor(), $src2$$Register-&gt;successor());
 8463     __ mov($dst$$Register, 1, gt);
 8464     __ mvn($dst$$Register, 0, lt);
 8465     __ b(done, ne);
 8466     __ subs($dst$$Register, $src1$$Register, $src2$$Register);
 8467     __ mov($dst$$Register, 1, hi);
 8468     __ mvn($dst$$Register, 0, lo);
 8469     __ bind(done);
 8470   %}
 8471   ins_pipe(cmpL_reg);
 8472 %}
 8473 
 8474 // Conditional move
 8475 instruct cmovLL_reg_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, iRegL dst, iRegL src) %{
 8476   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 8477   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8478 
 8479   ins_cost(150);
 8480   size(8);
 8481   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 8482             &quot;MOV$cmp  $dst,$src.hi&quot; %}
 8483   ins_encode %{
 8484     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8485     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 8486   %}
 8487   ins_pipe(ialu_reg);
 8488 %}
 8489 
 8490 instruct cmovLL_reg_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, iRegL dst, iRegL src) %{
 8491   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 8492   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8493 
 8494   ins_cost(150);
 8495   size(8);
 8496   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 8497             &quot;MOV$cmp  $dst,$src.hi&quot; %}
 8498   ins_encode %{
 8499     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8500     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 8501   %}
 8502   ins_pipe(ialu_reg);
 8503 %}
 8504 
 8505 instruct cmovLL_reg_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, iRegL dst, iRegL src) %{
 8506   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 8507   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8508 
 8509   ins_cost(150);
 8510   size(8);
 8511   format %{ &quot;MOV$cmp  $dst.lo,$src.lo\t! long\n\t&quot;
 8512             &quot;MOV$cmp  $dst,$src.hi&quot; %}
 8513   ins_encode %{
 8514     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8515     __ mov($dst$$Register-&gt;successor(), $src$$Register-&gt;successor(), (AsmCondition)($cmp$$cmpcode));
 8516   %}
 8517   ins_pipe(ialu_reg);
 8518 %}
 8519 
 8520 instruct cmovLL_imm_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, iRegL dst, immL0 src) %{
 8521   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 8522   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8523   ins_cost(140);
 8524   size(8);
 8525   format %{ &quot;MOV$cmp  $dst.lo,0\t! long\n\t&quot;
 8526             &quot;MOV$cmp  $dst,0&quot; %}
 8527   ins_encode %{
 8528     __ mov($dst$$Register, 0, (AsmCondition)($cmp$$cmpcode));
 8529     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 8530   %}
 8531   ins_pipe(ialu_imm);
 8532 %}
 8533 
 8534 instruct cmovLL_imm_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, iRegL dst, immL0 src) %{
 8535   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 8536   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8537   ins_cost(140);
 8538   size(8);
 8539   format %{ &quot;MOV$cmp  $dst.lo,0\t! long\n\t&quot;
 8540             &quot;MOV$cmp  $dst,0&quot; %}
 8541   ins_encode %{
 8542     __ mov($dst$$Register, 0, (AsmCondition)($cmp$$cmpcode));
 8543     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 8544   %}
 8545   ins_pipe(ialu_imm);
 8546 %}
 8547 
 8548 instruct cmovLL_imm_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, iRegL dst, immL0 src) %{
 8549   match(Set dst (CMoveL (Binary cmp xcc) (Binary dst src)));
 8550   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8551   ins_cost(140);
 8552   size(8);
 8553   format %{ &quot;MOV$cmp  $dst.lo,0\t! long\n\t&quot;
 8554             &quot;MOV$cmp  $dst,0&quot; %}
 8555   ins_encode %{
 8556     __ mov($dst$$Register, 0, (AsmCondition)($cmp$$cmpcode));
 8557     __ mov($dst$$Register-&gt;successor(), 0, (AsmCondition)($cmp$$cmpcode));
 8558   %}
 8559   ins_pipe(ialu_imm);
 8560 %}
 8561 
 8562 instruct cmovIL_reg_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, iRegI dst, iRegI src) %{
 8563   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 8564   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8565 
 8566   ins_cost(150);
 8567   size(4);
 8568   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 8569   ins_encode %{
 8570     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8571   %}
 8572   ins_pipe(ialu_reg);
 8573 %}
 8574 
 8575 instruct cmovIL_reg_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, iRegI dst, iRegI src) %{
 8576   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 8577   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8578 
 8579   ins_cost(150);
 8580   size(4);
 8581   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 8582   ins_encode %{
 8583     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8584   %}
 8585   ins_pipe(ialu_reg);
 8586 %}
 8587 
 8588 instruct cmovIL_reg_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, iRegI dst, iRegI src) %{
 8589   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 8590   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8591 
 8592   ins_cost(150);
 8593   size(4);
 8594   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 8595   ins_encode %{
 8596     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8597   %}
 8598   ins_pipe(ialu_reg);
 8599 %}
 8600 
 8601 instruct cmovIL_imm_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, iRegI dst, immI16 src) %{
 8602   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 8603   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8604 
 8605   ins_cost(140);
 8606   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 8607   ins_encode %{
 8608     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 8609   %}
 8610   ins_pipe(ialu_imm);
 8611 %}
 8612 
 8613 instruct cmovIL_imm_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, iRegI dst, immI16 src) %{
 8614   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 8615   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8616 
 8617   ins_cost(140);
 8618   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 8619   ins_encode %{
 8620     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 8621   %}
 8622   ins_pipe(ialu_imm);
 8623 %}
 8624 
 8625 instruct cmovIL_imm_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, iRegI dst, immI16 src) %{
 8626   match(Set dst (CMoveI (Binary cmp xcc) (Binary dst src)));
 8627   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8628 
 8629   ins_cost(140);
 8630   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 8631   ins_encode %{
 8632     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 8633   %}
 8634   ins_pipe(ialu_imm);
 8635 %}
 8636 
 8637 instruct cmovPL_reg_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, iRegP dst, iRegP src) %{
 8638   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 8639   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8640 
 8641   ins_cost(150);
 8642   size(4);
 8643   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 8644   ins_encode %{
 8645     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8646   %}
 8647   ins_pipe(ialu_reg);
 8648 %}
 8649 
 8650 instruct cmovPL_reg_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, iRegP dst, iRegP src) %{
 8651   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 8652   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8653 
 8654   ins_cost(150);
 8655   size(4);
 8656   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 8657   ins_encode %{
 8658     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8659   %}
 8660   ins_pipe(ialu_reg);
 8661 %}
 8662 
 8663 instruct cmovPL_reg_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, iRegP dst, iRegP src) %{
 8664   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 8665   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8666 
 8667   ins_cost(150);
 8668   size(4);
 8669   format %{ &quot;MOV$cmp  $dst,$src&quot; %}
 8670   ins_encode %{
 8671     __ mov($dst$$Register, $src$$Register, (AsmCondition)($cmp$$cmpcode));
 8672   %}
 8673   ins_pipe(ialu_reg);
 8674 %}
 8675 
 8676 instruct cmovPL_imm_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, iRegP dst, immP0 src) %{
 8677   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 8678   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8679 
 8680   ins_cost(140);
 8681   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 8682   ins_encode %{
 8683     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 8684   %}
 8685   ins_pipe(ialu_imm);
 8686 %}
 8687 
 8688 instruct cmovPL_imm_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, iRegP dst, immP0 src) %{
 8689   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 8690   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8691 
 8692   ins_cost(140);
 8693   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 8694   ins_encode %{
 8695     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 8696   %}
 8697   ins_pipe(ialu_imm);
 8698 %}
 8699 
 8700 instruct cmovPL_imm_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, iRegP dst, immP0 src) %{
 8701   match(Set dst (CMoveP (Binary cmp xcc) (Binary dst src)));
 8702   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8703 
 8704   ins_cost(140);
 8705   format %{ &quot;MOVW$cmp  $dst,$src&quot; %}
 8706   ins_encode %{
 8707     __ movw($dst$$Register, $src$$constant, (AsmCondition)($cmp$$cmpcode));
 8708   %}
 8709   ins_pipe(ialu_imm);
 8710 %}
 8711 
 8712 instruct cmovFL_reg_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, regF dst, regF src) %{
 8713   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 8714   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8715   ins_cost(150);
 8716   size(4);
 8717   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 8718   ins_encode %{
 8719     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 8720   %}
 8721   ins_pipe(int_conditional_float_move);
 8722 %}
 8723 
 8724 instruct cmovFL_reg_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, regF dst, regF src) %{
 8725   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 8726   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8727   ins_cost(150);
 8728   size(4);
 8729   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 8730   ins_encode %{
 8731     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 8732   %}
 8733   ins_pipe(int_conditional_float_move);
 8734 %}
 8735 
 8736 instruct cmovFL_reg_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, regF dst, regF src) %{
 8737   match(Set dst (CMoveF (Binary cmp xcc) (Binary dst src)));
 8738   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8739   ins_cost(150);
 8740   size(4);
 8741   format %{ &quot;FCPYS$cmp $dst,$src&quot; %}
 8742   ins_encode %{
 8743     __ fcpys($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 8744   %}
 8745   ins_pipe(int_conditional_float_move);
 8746 %}
 8747 
 8748 instruct cmovDL_reg_LTGE(cmpOpL cmp, flagsRegL_LTGE xcc, regD dst, regD src) %{
 8749   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 8750   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::lt || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ge );
 8751 
 8752   ins_cost(150);
 8753   size(4);
 8754   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 8755   ins_encode %{
 8756     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 8757   %}
 8758   ins_pipe(int_conditional_float_move);
 8759 %}
 8760 
 8761 instruct cmovDL_reg_EQNE(cmpOpL cmp, flagsRegL_EQNE xcc, regD dst, regD src) %{
 8762   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 8763   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::eq || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::ne );
 8764 
 8765   ins_cost(150);
 8766   size(4);
 8767   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 8768   ins_encode %{
 8769     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 8770   %}
 8771   ins_pipe(int_conditional_float_move);
 8772 %}
 8773 
 8774 instruct cmovDL_reg_LEGT(cmpOpL_commute cmp, flagsRegL_LEGT xcc, regD dst, regD src) %{
 8775   match(Set dst (CMoveD (Binary cmp xcc) (Binary dst src)));
 8776   predicate(_kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::le || _kids[0]-&gt;_kids[0]-&gt;_leaf-&gt;as_Bool()-&gt;_test._test == BoolTest::gt );
 8777 
 8778   ins_cost(150);
 8779   size(4);
 8780   format %{ &quot;FCPYD$cmp $dst,$src&quot; %}
 8781   ins_encode %{
 8782     __ fcpyd($dst$$FloatRegister, $src$$FloatRegister, (AsmCondition)($cmp$$cmpcode));
 8783   %}
 8784   ins_pipe(int_conditional_float_move);
 8785 %}
 8786 
 8787 // ============================================================================
 8788 // Safepoint Instruction
 8789 // rather than KILL R12, it would be better to use any reg as
 8790 // TEMP. Can&#39;t do that at this point because it crashes the compiler
 8791 instruct safePoint_poll(iRegP poll, R12RegI tmp, flagsReg icc) %{
 8792   match(SafePoint poll);
 8793   effect(USE poll, KILL tmp, KILL icc);
 8794 
 8795   size(4);
 8796   format %{ &quot;LDR   $tmp,[$poll]\t! Safepoint: poll for GC&quot; %}
 8797   ins_encode %{
 8798     __ relocate(relocInfo::poll_type);
 8799     __ ldr($tmp$$Register, Address($poll$$Register));
 8800   %}
 8801   ins_pipe(loadPollP);
 8802 %}
 8803 
 8804 
 8805 // ============================================================================
 8806 // Call Instructions
 8807 // Call Java Static Instruction
 8808 instruct CallStaticJavaDirect( method meth ) %{
 8809   match(CallStaticJava);
 8810   predicate(! ((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 8811   effect(USE meth);
 8812 
 8813   ins_cost(CALL_COST);
 8814   format %{ &quot;CALL,static ==&gt; &quot; %}
 8815   ins_encode( Java_Static_Call( meth ), call_epilog );
 8816   ins_pipe(simple_call);
 8817 %}
 8818 
 8819 // Call Java Static Instruction (method handle version)
 8820 instruct CallStaticJavaHandle( method meth ) %{
 8821   match(CallStaticJava);
 8822   predicate(((CallStaticJavaNode*)n)-&gt;is_method_handle_invoke());
 8823   effect(USE meth);
 8824   // FP is saved by all callees (for interpreter stack correction).
 8825   // We use it here for a similar purpose, in {preserve,restore}_FP.
 8826 
 8827   ins_cost(CALL_COST);
 8828   format %{ &quot;CALL,static/MethodHandle ==&gt; &quot; %}
 8829   ins_encode( preserve_SP, Java_Static_Call( meth ), restore_SP, call_epilog );
 8830   ins_pipe(simple_call);
 8831 %}
 8832 
 8833 // Call Java Dynamic Instruction
 8834 instruct CallDynamicJavaDirect( method meth ) %{
 8835   match(CallDynamicJava);
 8836   effect(USE meth);
 8837 
 8838   ins_cost(CALL_COST);
 8839   format %{ &quot;MOV_OOP    (empty),R_R8\n\t&quot;
 8840             &quot;CALL,dynamic  ; NOP ==&gt; &quot; %}
 8841   ins_encode( Java_Dynamic_Call( meth ), call_epilog );
 8842   ins_pipe(call);
 8843 %}
 8844 
 8845 // Call Runtime Instruction
 8846 instruct CallRuntimeDirect(method meth) %{
 8847   match(CallRuntime);
 8848   effect(USE meth);
 8849   ins_cost(CALL_COST);
 8850   format %{ &quot;CALL,runtime&quot; %}
 8851   ins_encode( Java_To_Runtime( meth ),
 8852               call_epilog );
 8853   ins_pipe(simple_call);
 8854 %}
 8855 
 8856 // Call runtime without safepoint - same as CallRuntime
 8857 instruct CallLeafDirect(method meth) %{
 8858   match(CallLeaf);
 8859   effect(USE meth);
 8860   ins_cost(CALL_COST);
 8861   format %{ &quot;CALL,runtime leaf&quot; %}
 8862   // TODO: ned save_last_PC here?
 8863   ins_encode( Java_To_Runtime( meth ),
 8864               call_epilog );
 8865   ins_pipe(simple_call);
 8866 %}
 8867 
 8868 // Call runtime without safepoint - same as CallLeaf
 8869 instruct CallLeafNoFPDirect(method meth) %{
 8870   match(CallLeafNoFP);
 8871   effect(USE meth);
 8872   ins_cost(CALL_COST);
 8873   format %{ &quot;CALL,runtime leaf nofp&quot; %}
 8874   // TODO: ned save_last_PC here?
 8875   ins_encode( Java_To_Runtime( meth ),
 8876               call_epilog );
 8877   ins_pipe(simple_call);
 8878 %}
 8879 
 8880 // Tail Call; Jump from runtime stub to Java code.
 8881 // Also known as an &#39;interprocedural jump&#39;.
 8882 // Target of jump will eventually return to caller.
 8883 // TailJump below removes the return address.
 8884 instruct TailCalljmpInd(IPRegP jump_target, inline_cache_regP method_oop) %{
 8885   match(TailCall jump_target method_oop );
 8886 
 8887   ins_cost(CALL_COST);
 8888   format %{ &quot;MOV    Rexception_pc, LR\n\t&quot;
 8889             &quot;jump   $jump_target  \t! $method_oop holds method oop&quot; %}
 8890   ins_encode %{
 8891     __ mov(Rexception_pc, LR);   // this is used only to call
 8892                                  // StubRoutines::forward_exception_entry()
 8893                                  // which expects PC of exception in
 8894                                  // R5. FIXME?
 8895     __ jump($jump_target$$Register);
 8896   %}
 8897   ins_pipe(tail_call);
 8898 %}
 8899 
 8900 
 8901 // Return Instruction
 8902 instruct Ret() %{
 8903   match(Return);
 8904 
 8905   format %{ &quot;ret LR&quot; %}
 8906 
 8907   ins_encode %{
 8908     __ ret(LR);
 8909   %}
 8910 
 8911   ins_pipe(br);
 8912 %}
 8913 
 8914 
 8915 // Tail Jump; remove the return address; jump to target.
 8916 // TailCall above leaves the return address around.
 8917 // TailJump is used in only one place, the rethrow_Java stub (fancy_jump=2).
 8918 // ex_oop (Exception Oop) is needed in %o0 at the jump. As there would be a
 8919 // &quot;restore&quot; before this instruction (in Epilogue), we need to materialize it
 8920 // in %i0.
 8921 instruct tailjmpInd(IPRegP jump_target, RExceptionRegP ex_oop) %{
 8922   match( TailJump jump_target ex_oop );
 8923   ins_cost(CALL_COST);
 8924   format %{ &quot;MOV    Rexception_pc, LR\n\t&quot;
 8925             &quot;jump   $jump_target \t! $ex_oop holds exc. oop&quot; %}
 8926   ins_encode %{
 8927     __ mov(Rexception_pc, LR);
 8928     __ jump($jump_target$$Register);
 8929   %}
 8930   ins_pipe(tail_call);
 8931 %}
 8932 
 8933 // Create exception oop: created by stack-crawling runtime code.
 8934 // Created exception is now available to this handler, and is setup
 8935 // just prior to jumping to this handler.  No code emitted.
 8936 instruct CreateException( RExceptionRegP ex_oop )
 8937 %{
 8938   match(Set ex_oop (CreateEx));
 8939   ins_cost(0);
 8940 
 8941   size(0);
 8942   // use the following format syntax
 8943   format %{ &quot;! exception oop is in Rexception_obj; no code emitted&quot; %}
 8944   ins_encode();
 8945   ins_pipe(empty);
 8946 %}
 8947 
 8948 
 8949 // Rethrow exception:
 8950 // The exception oop will come in the first argument position.
 8951 // Then JUMP (not call) to the rethrow stub code.
 8952 instruct RethrowException()
 8953 %{
 8954   match(Rethrow);
 8955   ins_cost(CALL_COST);
 8956 
 8957   // use the following format syntax
 8958   format %{ &quot;b    rethrow_stub&quot; %}
 8959   ins_encode %{
 8960     Register scratch = R1_tmp;
 8961     assert_different_registers(scratch, c_rarg0, LR);
 8962     __ jump(OptoRuntime::rethrow_stub(), relocInfo::runtime_call_type, scratch);
 8963   %}
 8964   ins_pipe(tail_call);
 8965 %}
 8966 
 8967 
 8968 // Die now
 8969 instruct ShouldNotReachHere( )
 8970 %{
 8971   match(Halt);
 8972   ins_cost(CALL_COST);
 8973 
 8974   size(4);
 8975   // Use the following format syntax
 8976   format %{ &quot;ShouldNotReachHere&quot; %}
 8977   ins_encode %{
 8978     __ udf(0xdead);
 8979   %}
 8980   ins_pipe(tail_call);
 8981 %}
 8982 
 8983 // ============================================================================
 8984 // The 2nd slow-half of a subtype check.  Scan the subklass&#39;s 2ndary superklass
 8985 // array for an instance of the superklass.  Set a hidden internal cache on a
 8986 // hit (cache is checked with exposed code in gen_subtype_check()).  Return
 8987 // not zero for a miss or zero for a hit.  The encoding ALSO sets flags.
 8988 instruct partialSubtypeCheck( R0RegP index, R1RegP sub, R2RegP super, flagsRegP pcc, LRRegP lr ) %{
 8989   match(Set index (PartialSubtypeCheck sub super));
 8990   effect( KILL pcc, KILL lr );
 8991   ins_cost(DEFAULT_COST*10);
 8992   format %{ &quot;CALL   PartialSubtypeCheck&quot; %}
 8993   ins_encode %{
 8994     __ call(StubRoutines::Arm::partial_subtype_check(), relocInfo::runtime_call_type);
 8995   %}
 8996   ins_pipe(partial_subtype_check_pipe);
 8997 %}
 8998 
 8999 /* instruct partialSubtypeCheck_vs_zero( flagsRegP pcc, o1RegP sub, o2RegP super, immP0 zero, o0RegP idx, o7RegP o7 ) %{ */
 9000 /*   match(Set pcc (CmpP (PartialSubtypeCheck sub super) zero)); */
 9001 /*   ins_pipe(partial_subtype_check_pipe); */
 9002 /* %} */
 9003 
 9004 
 9005 // ============================================================================
 9006 // inlined locking and unlocking
 9007 
 9008 instruct cmpFastLock(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2, iRegP scratch )
 9009 %{
 9010   match(Set pcc (FastLock object box));
 9011   predicate(!(UseBiasedLocking &amp;&amp; !UseOptoBiasInlining));
 9012 
 9013   effect(TEMP scratch, TEMP scratch2);
 9014   ins_cost(DEFAULT_COST*3);
 9015 
 9016   format %{ &quot;FASTLOCK  $object, $box; KILL $scratch, $scratch2&quot; %}
 9017   ins_encode %{
 9018     __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register);
 9019   %}
 9020   ins_pipe(long_memory_op);
 9021 %}
 9022 
 9023 instruct cmpFastLock_noBiasInline(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2,
 9024                                   iRegP scratch, iRegP scratch3) %{
 9025   match(Set pcc (FastLock object box));
 9026   predicate(UseBiasedLocking &amp;&amp; !UseOptoBiasInlining);
 9027 
 9028   effect(TEMP scratch, TEMP scratch2, TEMP scratch3);
 9029   ins_cost(DEFAULT_COST*5);
 9030 
 9031   format %{ &quot;FASTLOCK  $object, $box; KILL $scratch, $scratch2, $scratch3&quot; %}
 9032   ins_encode %{
 9033     __ fast_lock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register, $scratch3$$Register);
 9034   %}
 9035   ins_pipe(long_memory_op);
 9036 %}
 9037 
 9038 
 9039 instruct cmpFastUnlock(flagsRegP pcc, iRegP object, iRegP box, iRegP scratch2, iRegP scratch ) %{
 9040   match(Set pcc (FastUnlock object box));
 9041   effect(TEMP scratch, TEMP scratch2);
 9042   ins_cost(100);
 9043 
 9044   format %{ &quot;FASTUNLOCK  $object, $box; KILL $scratch, $scratch2&quot; %}
 9045   ins_encode %{
 9046     __ fast_unlock($object$$Register, $box$$Register, $scratch$$Register, $scratch2$$Register);
 9047   %}
 9048   ins_pipe(long_memory_op);
 9049 %}
 9050 
 9051 // Count and Base registers are fixed because the allocator cannot
 9052 // kill unknown registers.  The encodings are generic.
 9053 instruct clear_array(iRegX cnt, iRegP base, iRegI temp, iRegX zero, Universe dummy, flagsReg cpsr) %{
 9054   match(Set dummy (ClearArray cnt base));
 9055   effect(TEMP temp, TEMP zero, KILL cpsr);
 9056   ins_cost(300);
 9057   format %{ &quot;MOV    $zero,0\n&quot;
 9058       &quot;        MOV    $temp,$cnt\n&quot;
 9059       &quot;loop:   SUBS   $temp,$temp,4\t! Count down a dword of bytes\n&quot;
 9060       &quot;        STR.ge $zero,[$base+$temp]\t! delay slot&quot;
 9061       &quot;        B.gt   loop\t\t! Clearing loop\n&quot; %}
 9062   ins_encode %{
 9063     __ mov($zero$$Register, 0);
 9064     __ mov($temp$$Register, $cnt$$Register);
 9065     Label(loop);
 9066     __ bind(loop);
 9067     __ subs($temp$$Register, $temp$$Register, 4);
 9068     __ str($zero$$Register, Address($base$$Register, $temp$$Register), ge);
 9069     __ b(loop, gt);
 9070   %}
 9071   ins_pipe(long_memory_op);
 9072 %}
 9073 
 9074 #ifdef XXX
 9075 // FIXME: Why R0/R1/R2/R3?
 9076 instruct string_compare(R0RegP str1, R1RegP str2, R2RegI cnt1, R3RegI cnt2, iRegI result,
 9077                         iRegI tmp1, iRegI tmp2, flagsReg ccr) %{
 9078   predicate(!CompactStrings);
 9079   match(Set result (StrComp (Binary str1 cnt1) (Binary str2 cnt2)));
 9080   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt1, USE_KILL cnt2, KILL ccr, TEMP tmp1, TEMP tmp2);
 9081   ins_cost(300);
 9082   format %{ &quot;String Compare $str1,$cnt1,$str2,$cnt2 -&gt; $result   // TEMP $tmp1, $tmp2&quot; %}
 9083   ins_encode( enc_String_Compare(str1, str2, cnt1, cnt2, result, tmp1, tmp2) );
 9084 
 9085   ins_pipe(long_memory_op);
 9086 %}
 9087 
 9088 // FIXME: Why R0/R1/R2?
 9089 instruct string_equals(R0RegP str1, R1RegP str2, R2RegI cnt, iRegI result, iRegI tmp1, iRegI tmp2,
 9090                        flagsReg ccr) %{
 9091   predicate(!CompactStrings);
 9092   match(Set result (StrEquals (Binary str1 str2) cnt));
 9093   effect(USE_KILL str1, USE_KILL str2, USE_KILL cnt, TEMP tmp1, TEMP tmp2, TEMP result, KILL ccr);
 9094 
 9095   ins_cost(300);
 9096   format %{ &quot;String Equals $str1,$str2,$cnt -&gt; $result   // TEMP $tmp1, $tmp2&quot; %}
 9097   ins_encode( enc_String_Equals(str1, str2, cnt, result, tmp1, tmp2) );
 9098   ins_pipe(long_memory_op);
 9099 %}
 9100 
 9101 // FIXME: Why R0/R1?
 9102 instruct array_equals(R0RegP ary1, R1RegP ary2, iRegI tmp1, iRegI tmp2, iRegI tmp3, iRegI result,
 9103                       flagsReg ccr) %{
 9104   predicate(((AryEqNode*)n)-&gt;encoding() == StrIntrinsicNode::UU);
 9105   match(Set result (AryEq ary1 ary2));
 9106   effect(USE_KILL ary1, USE_KILL ary2, TEMP tmp1, TEMP tmp2, TEMP tmp3, TEMP result, KILL ccr);
 9107 
 9108   ins_cost(300);
 9109   format %{ &quot;Array Equals $ary1,$ary2 -&gt; $result   // TEMP $tmp1,$tmp2,$tmp3&quot; %}
 9110   ins_encode( enc_Array_Equals(ary1, ary2, tmp1, tmp2, tmp3, result));
 9111   ins_pipe(long_memory_op);
 9112 %}
 9113 #endif
 9114 
 9115 //---------- Zeros Count Instructions ------------------------------------------
 9116 
 9117 instruct countLeadingZerosI(iRegI dst, iRegI src) %{
 9118   match(Set dst (CountLeadingZerosI src));
 9119   size(4);
 9120   format %{ &quot;CLZ_32 $dst,$src&quot; %}
 9121   ins_encode %{
 9122     __ clz_32($dst$$Register, $src$$Register);
 9123   %}
 9124   ins_pipe(ialu_reg);
 9125 %}
 9126 
 9127 instruct countLeadingZerosL(iRegI dst, iRegL src, iRegI tmp, flagsReg ccr) %{
 9128   match(Set dst (CountLeadingZerosL src));
 9129   effect(TEMP tmp, TEMP dst, KILL ccr);
 9130   size(16);
 9131   format %{ &quot;CLZ    $dst,$src.hi\n\t&quot;
 9132             &quot;TEQ    $dst,32\n\t&quot;
 9133             &quot;CLZ.eq $tmp,$src.lo\n\t&quot;
 9134             &quot;ADD.eq $dst, $dst, $tmp\n\t&quot; %}
 9135   ins_encode %{
 9136     __ clz($dst$$Register, $src$$Register-&gt;successor());
 9137     __ teq($dst$$Register, 32);
 9138     __ clz($tmp$$Register, $src$$Register, eq);
 9139     __ add($dst$$Register, $dst$$Register, $tmp$$Register, eq);
 9140   %}
 9141   ins_pipe(ialu_reg);
 9142 %}
 9143 
 9144 instruct countTrailingZerosI(iRegI dst, iRegI src, iRegI tmp) %{
 9145   match(Set dst (CountTrailingZerosI src));
 9146   effect(TEMP tmp);
 9147   size(8);
 9148   format %{ &quot;RBIT_32 $tmp, $src\n\t&quot;
 9149             &quot;CLZ_32  $dst,$tmp&quot; %}
 9150   ins_encode %{
 9151     __ rbit_32($tmp$$Register, $src$$Register);
 9152     __ clz_32($dst$$Register, $tmp$$Register);
 9153   %}
 9154   ins_pipe(ialu_reg);
 9155 %}
 9156 
 9157 instruct countTrailingZerosL(iRegI dst, iRegL src, iRegI tmp, flagsReg ccr) %{
 9158   match(Set dst (CountTrailingZerosL src));
 9159   effect(TEMP tmp, TEMP dst, KILL ccr);
 9160   size(24);
 9161   format %{ &quot;RBIT   $tmp,$src.lo\n\t&quot;
 9162             &quot;CLZ    $dst,$tmp\n\t&quot;
 9163             &quot;TEQ    $dst,32\n\t&quot;
 9164             &quot;RBIT   $tmp,$src.hi\n\t&quot;
 9165             &quot;CLZ.eq $tmp,$tmp\n\t&quot;
 9166             &quot;ADD.eq $dst,$dst,$tmp\n\t&quot; %}
 9167   ins_encode %{
 9168     __ rbit($tmp$$Register, $src$$Register);
 9169     __ clz($dst$$Register, $tmp$$Register);
 9170     __ teq($dst$$Register, 32);
 9171     __ rbit($tmp$$Register, $src$$Register-&gt;successor());
 9172     __ clz($tmp$$Register, $tmp$$Register, eq);
 9173     __ add($dst$$Register, $dst$$Register, $tmp$$Register, eq);
 9174   %}
 9175   ins_pipe(ialu_reg);
 9176 %}
 9177 
 9178 
 9179 //---------- Population Count Instructions -------------------------------------
 9180 
 9181 instruct popCountI(iRegI dst, iRegI src, regD_low tmp) %{
 9182   predicate(UsePopCountInstruction);
 9183   match(Set dst (PopCountI src));
 9184   effect(TEMP tmp);
 9185 
 9186   format %{ &quot;FMSR       $tmp,$src\n\t&quot;
 9187             &quot;VCNT.8     $tmp,$tmp\n\t&quot;
 9188             &quot;VPADDL.U8  $tmp,$tmp\n\t&quot;
 9189             &quot;VPADDL.U16 $tmp,$tmp\n\t&quot;
 9190             &quot;FMRS       $dst,$tmp&quot; %}
 9191   size(20);
 9192 
 9193   ins_encode %{
 9194     __ fmsr($tmp$$FloatRegister, $src$$Register);
 9195     __ vcnt($tmp$$FloatRegister, $tmp$$FloatRegister);
 9196     __ vpaddl($tmp$$FloatRegister, $tmp$$FloatRegister, 8, 0);
 9197     __ vpaddl($tmp$$FloatRegister, $tmp$$FloatRegister, 16, 0);
 9198     __ fmrs($dst$$Register, $tmp$$FloatRegister);
 9199   %}
 9200   ins_pipe(ialu_reg); // FIXME
 9201 %}
 9202 
 9203 // Note: Long.bitCount(long) returns an int.
 9204 instruct popCountL(iRegI dst, iRegL src, regD_low tmp) %{
 9205   predicate(UsePopCountInstruction);
 9206   match(Set dst (PopCountL src));
 9207   effect(TEMP tmp);
 9208 
 9209   format %{ &quot;FMDRR       $tmp,$src.lo,$src.hi\n\t&quot;
 9210             &quot;VCNT.8      $tmp,$tmp\n\t&quot;
 9211             &quot;VPADDL.U8   $tmp,$tmp\n\t&quot;
 9212             &quot;VPADDL.U16  $tmp,$tmp\n\t&quot;
 9213             &quot;VPADDL.U32  $tmp,$tmp\n\t&quot;
 9214             &quot;FMRS        $dst,$tmp&quot; %}
 9215 
 9216   size(32);
 9217 
 9218   ins_encode %{
 9219     __ fmdrr($tmp$$FloatRegister, $src$$Register, $src$$Register-&gt;successor());
 9220     __ vcnt($tmp$$FloatRegister, $tmp$$FloatRegister);
 9221     __ vpaddl($tmp$$FloatRegister, $tmp$$FloatRegister, 8, 0);
 9222     __ vpaddl($tmp$$FloatRegister, $tmp$$FloatRegister, 16, 0);
 9223     __ vpaddl($tmp$$FloatRegister, $tmp$$FloatRegister, 32, 0);
 9224     __ fmrs($dst$$Register, $tmp$$FloatRegister);
 9225   %}
 9226   ins_pipe(ialu_reg);
 9227 %}
 9228 
 9229 
 9230 // ============================================================================
 9231 //------------Bytes reverse--------------------------------------------------
 9232 
 9233 instruct bytes_reverse_int(iRegI dst, iRegI src) %{
 9234   match(Set dst (ReverseBytesI src));
 9235 
 9236   size(4);
 9237   format %{ &quot;REV32 $dst,$src&quot; %}
 9238   ins_encode %{
 9239     __ rev($dst$$Register, $src$$Register);
 9240   %}
 9241   ins_pipe( iload_mem ); // FIXME
 9242 %}
 9243 
 9244 instruct bytes_reverse_long(iRegL dst, iRegL src) %{
 9245   match(Set dst (ReverseBytesL src));
 9246   effect(TEMP dst);
 9247   size(8);
 9248   format %{ &quot;REV $dst.lo,$src.lo\n\t&quot;
 9249             &quot;REV $dst.hi,$src.hi&quot; %}
 9250   ins_encode %{
 9251     __ rev($dst$$Register, $src$$Register-&gt;successor());
 9252     __ rev($dst$$Register-&gt;successor(), $src$$Register);
 9253   %}
 9254   ins_pipe( iload_mem ); // FIXME
 9255 %}
 9256 
 9257 instruct bytes_reverse_unsigned_short(iRegI dst, iRegI src) %{
 9258   match(Set dst (ReverseBytesUS src));
 9259   size(4);
 9260   format %{ &quot;REV16 $dst,$src&quot; %}
 9261   ins_encode %{
 9262     __ rev16($dst$$Register, $src$$Register);
 9263   %}
 9264   ins_pipe( iload_mem ); // FIXME
 9265 %}
 9266 
 9267 instruct bytes_reverse_short(iRegI dst, iRegI src) %{
 9268   match(Set dst (ReverseBytesS src));
 9269   size(4);
 9270   format %{ &quot;REVSH $dst,$src&quot; %}
 9271   ins_encode %{
 9272     __ revsh($dst$$Register, $src$$Register);
 9273   %}
 9274   ins_pipe( iload_mem ); // FIXME
 9275 %}
 9276 
 9277 
 9278 // ====================VECTOR INSTRUCTIONS=====================================
 9279 
 9280 // Load Aligned Packed values into a Double Register
 9281 instruct loadV8(vecD dst, memoryD mem) %{
 9282   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 8);
 9283   match(Set dst (LoadVector mem));
 9284   ins_cost(MEMORY_REF_COST);
 9285   size(4);
 9286   format %{ &quot;FLDD   $mem,$dst\t! load vector (8 bytes)&quot; %}
 9287   ins_encode %{
 9288     __ ldr_double($dst$$FloatRegister, $mem$$Address);
 9289   %}
 9290   ins_pipe(floadD_mem);
 9291 %}
 9292 
 9293 // Load Aligned Packed values into a Double Register Pair
 9294 instruct loadV16(vecX dst, memoryvld mem) %{
 9295   predicate(n-&gt;as_LoadVector()-&gt;memory_size() == 16);
 9296   match(Set dst (LoadVector mem));
 9297   ins_cost(MEMORY_REF_COST);
 9298   size(4);
 9299   format %{ &quot;VLD1   $mem,$dst.Q\t! load vector (16 bytes)&quot; %}
 9300   ins_encode %{
 9301     __ vld1($dst$$FloatRegister, $mem$$Address, MacroAssembler::VELEM_SIZE_16, 128);
 9302   %}
 9303   ins_pipe(floadD_mem); // FIXME
 9304 %}
 9305 
 9306 // Store Vector in Double register to memory
 9307 instruct storeV8(memoryD mem, vecD src) %{
 9308   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 8);
 9309   match(Set mem (StoreVector mem src));
 9310   ins_cost(MEMORY_REF_COST);
 9311   size(4);
 9312   format %{ &quot;FSTD   $src,$mem\t! store vector (8 bytes)&quot; %}
 9313   ins_encode %{
 9314     __ str_double($src$$FloatRegister, $mem$$Address);
 9315   %}
 9316   ins_pipe(fstoreD_mem_reg);
 9317 %}
 9318 
 9319 // Store Vector in Double Register Pair to memory
 9320 instruct storeV16(memoryvld mem, vecX src) %{
 9321   predicate(n-&gt;as_StoreVector()-&gt;memory_size() == 16);
 9322   match(Set mem (StoreVector mem src));
 9323   ins_cost(MEMORY_REF_COST);
 9324   size(4);
 9325   format %{ &quot;VST1   $src,$mem\t! store vector (16 bytes)&quot; %}
 9326   ins_encode %{
 9327     __ vst1($src$$FloatRegister, $mem$$Address, MacroAssembler::VELEM_SIZE_16, 128);
 9328   %}
 9329   ins_pipe(fstoreD_mem_reg); // FIXME
 9330 %}
 9331 
 9332 // Replicate scalar to packed byte values in Double register
 9333 instruct Repl8B_reg(vecD dst, iRegI src, iRegI tmp) %{
 9334   predicate(n-&gt;as_Vector()-&gt;length() == 8);
 9335   match(Set dst (ReplicateB src));
 9336   ins_cost(DEFAULT_COST*4);
 9337   effect(TEMP tmp);
 9338   size(16);
 9339 
 9340   // FIXME: could use PKH instruction instead?
 9341   format %{ &quot;LSL      $tmp, $src, 24 \n\t&quot;
 9342             &quot;OR       $tmp, $tmp, ($tmp &gt;&gt; 8) \n\t&quot;
 9343             &quot;OR       $tmp, $tmp, ($tmp &gt;&gt; 16) \n\t&quot;
 9344             &quot;FMDRR    $dst,$tmp,$tmp\t&quot; %}
 9345   ins_encode %{
 9346     __ mov($tmp$$Register, AsmOperand($src$$Register, lsl, 24));
 9347     __ orr($tmp$$Register, $tmp$$Register, AsmOperand($tmp$$Register, lsr, 8));
 9348     __ orr($tmp$$Register, $tmp$$Register, AsmOperand($tmp$$Register, lsr, 16));
 9349     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 9350   %}
 9351   ins_pipe(ialu_reg); // FIXME
 9352 %}
 9353 
 9354 // Replicate scalar to packed byte values in Double register
 9355 instruct Repl8B_reg_simd(vecD dst, iRegI src) %{
 9356   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9357   match(Set dst (ReplicateB src));
 9358   size(4);
 9359 
 9360   format %{ &quot;VDUP.8 $dst,$src\t&quot; %}
 9361   ins_encode %{
 9362     bool quad = false;
 9363     __ vdupI($dst$$FloatRegister, $src$$Register,
 9364              MacroAssembler::VELEM_SIZE_8, quad);
 9365   %}
 9366   ins_pipe(ialu_reg); // FIXME
 9367 %}
 9368 
 9369 // Replicate scalar to packed byte values in Double register pair
 9370 instruct Repl16B_reg(vecX dst, iRegI src) %{
 9371   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16);
 9372   match(Set dst (ReplicateB src));
 9373   size(4);
 9374 
 9375   format %{ &quot;VDUP.8 $dst.Q,$src\t&quot; %}
 9376   ins_encode %{
 9377     bool quad = true;
 9378     __ vdupI($dst$$FloatRegister, $src$$Register,
 9379              MacroAssembler::VELEM_SIZE_8, quad);
 9380   %}
 9381   ins_pipe(ialu_reg); // FIXME
 9382 %}
 9383 
 9384 // Replicate scalar constant to packed byte values in Double register
 9385 instruct Repl8B_immI(vecD dst, immI src, iRegI tmp) %{
 9386   predicate(n-&gt;as_Vector()-&gt;length() == 8);
 9387   match(Set dst (ReplicateB src));
 9388   ins_cost(DEFAULT_COST*2);
 9389   effect(TEMP tmp);
 9390   size(12);
 9391 
 9392   format %{ &quot;MOV      $tmp, Repl4($src))\n\t&quot;
 9393             &quot;FMDRR    $dst,$tmp,$tmp\t&quot; %}
 9394   ins_encode( LdReplImmI(src, dst, tmp, (4), (1)) );
 9395   ins_pipe(loadConFD); // FIXME
 9396 %}
 9397 
 9398 // Replicate scalar constant to packed byte values in Double register
 9399 // TODO: support negative constants with MVNI?
 9400 instruct Repl8B_immU8(vecD dst, immU8 src) %{
 9401   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9402   match(Set dst (ReplicateB src));
 9403   size(4);
 9404 
 9405   format %{ &quot;VMOV.U8  $dst,$src&quot; %}
 9406   ins_encode %{
 9407     bool quad = false;
 9408     __ vmovI($dst$$FloatRegister, $src$$constant,
 9409              MacroAssembler::VELEM_SIZE_8, quad);
 9410   %}
 9411   ins_pipe(loadConFD); // FIXME
 9412 %}
 9413 
 9414 // Replicate scalar constant to packed byte values in Double register pair
 9415 instruct Repl16B_immU8(vecX dst, immU8 src) %{
 9416   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
 9417   match(Set dst (ReplicateB src));
 9418   size(4);
 9419 
 9420   format %{ &quot;VMOV.U8  $dst.Q,$src&quot; %}
 9421   ins_encode %{
 9422     bool quad = true;
 9423     __ vmovI($dst$$FloatRegister, $src$$constant,
 9424              MacroAssembler::VELEM_SIZE_8, quad);
 9425   %}
 9426   ins_pipe(loadConFD); // FIXME
 9427 %}
 9428 
 9429 // Replicate scalar to packed short/char values into Double register
 9430 instruct Repl4S_reg(vecD dst, iRegI src, iRegI tmp) %{
 9431   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9432   match(Set dst (ReplicateS src));
 9433   ins_cost(DEFAULT_COST*3);
 9434   effect(TEMP tmp);
 9435   size(12);
 9436 
 9437   // FIXME: could use PKH instruction instead?
 9438   format %{ &quot;LSL      $tmp, $src, 16 \n\t&quot;
 9439             &quot;OR       $tmp, $tmp, ($tmp &gt;&gt; 16) \n\t&quot;
 9440             &quot;FMDRR    $dst,$tmp,$tmp\t&quot; %}
 9441   ins_encode %{
 9442     __ mov($tmp$$Register, AsmOperand($src$$Register, lsl, 16));
 9443     __ orr($tmp$$Register, $tmp$$Register, AsmOperand($tmp$$Register, lsr, 16));
 9444     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 9445   %}
 9446   ins_pipe(ialu_reg); // FIXME
 9447 %}
 9448 
 9449 // Replicate scalar to packed byte values in Double register
 9450 instruct Repl4S_reg_simd(vecD dst, iRegI src) %{
 9451   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9452   match(Set dst (ReplicateS src));
 9453   size(4);
 9454 
 9455   format %{ &quot;VDUP.16 $dst,$src\t&quot; %}
 9456   ins_encode %{
 9457     bool quad = false;
 9458     __ vdupI($dst$$FloatRegister, $src$$Register,
 9459              MacroAssembler::VELEM_SIZE_16, quad);
 9460   %}
 9461   ins_pipe(ialu_reg); // FIXME
 9462 %}
 9463 
 9464 // Replicate scalar to packed byte values in Double register pair
 9465 instruct Repl8S_reg(vecX dst, iRegI src) %{
 9466   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
 9467   match(Set dst (ReplicateS src));
 9468   size(4);
 9469 
 9470   format %{ &quot;VDUP.16 $dst.Q,$src\t&quot; %}
 9471   ins_encode %{
 9472     bool quad = true;
 9473     __ vdupI($dst$$FloatRegister, $src$$Register,
 9474              MacroAssembler::VELEM_SIZE_16, quad);
 9475   %}
 9476   ins_pipe(ialu_reg); // FIXME
 9477 %}
 9478 
 9479 
 9480 // Replicate scalar constant to packed short/char values in Double register
 9481 instruct Repl4S_immI(vecD dst, immI src, iRegP tmp) %{
 9482   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9483   match(Set dst (ReplicateS src));
 9484   effect(TEMP tmp);
 9485   size(12);
 9486   ins_cost(DEFAULT_COST*4); // FIXME
 9487 
 9488   format %{ &quot;MOV      $tmp, Repl2($src))\n\t&quot;
 9489             &quot;FMDRR    $dst,$tmp,$tmp\t&quot; %}
 9490   ins_encode( LdReplImmI(src, dst, tmp, (2), (2)) );
 9491   ins_pipe(loadConFD); // FIXME
 9492 %}
 9493 
 9494 // Replicate scalar constant to packed byte values in Double register
 9495 instruct Repl4S_immU8(vecD dst, immU8 src) %{
 9496   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9497   match(Set dst (ReplicateS src));
 9498   size(4);
 9499 
 9500   format %{ &quot;VMOV.U16  $dst,$src&quot; %}
 9501   ins_encode %{
 9502     bool quad = false;
 9503     __ vmovI($dst$$FloatRegister, $src$$constant,
 9504              MacroAssembler::VELEM_SIZE_16, quad);
 9505   %}
 9506   ins_pipe(loadConFD); // FIXME
 9507 %}
 9508 
 9509 // Replicate scalar constant to packed byte values in Double register pair
 9510 instruct Repl8S_immU8(vecX dst, immU8 src) %{
 9511   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
 9512   match(Set dst (ReplicateS src));
 9513   size(4);
 9514 
 9515   format %{ &quot;VMOV.U16  $dst.Q,$src&quot; %}
 9516   ins_encode %{
 9517     bool quad = true;
 9518     __ vmovI($dst$$FloatRegister, $src$$constant,
 9519              MacroAssembler::VELEM_SIZE_16, quad);
 9520   %}
 9521   ins_pipe(loadConFD); // FIXME
 9522 %}
 9523 
 9524 // Replicate scalar to packed int values in Double register
 9525 instruct Repl2I_reg(vecD dst, iRegI src) %{
 9526   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9527   match(Set dst (ReplicateI src));
 9528   size(4);
 9529 
 9530   format %{ &quot;FMDRR    $dst,$src,$src\t&quot; %}
 9531   ins_encode %{
 9532     __ fmdrr($dst$$FloatRegister, $src$$Register, $src$$Register);
 9533   %}
 9534   ins_pipe(ialu_reg); // FIXME
 9535 %}
 9536 
 9537 // Replicate scalar to packed int values in Double register pair
 9538 instruct Repl4I_reg(vecX dst, iRegI src) %{
 9539   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9540   match(Set dst (ReplicateI src));
 9541   ins_cost(DEFAULT_COST*2);
 9542   size(8);
 9543 
 9544   format %{ &quot;FMDRR    $dst.lo,$src,$src\n\t&quot;
 9545             &quot;FMDRR    $dst.hi,$src,$src&quot; %}
 9546 
 9547   ins_encode %{
 9548     __ fmdrr($dst$$FloatRegister, $src$$Register, $src$$Register);
 9549     __ fmdrr($dst$$FloatRegister-&gt;successor()-&gt;successor(),
 9550              $src$$Register, $src$$Register);
 9551   %}
 9552   ins_pipe(ialu_reg); // FIXME
 9553 %}
 9554 
 9555 // Replicate scalar to packed int values in Double register
 9556 instruct Repl2I_reg_simd(vecD dst, iRegI src) %{
 9557   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9558   match(Set dst (ReplicateI src));
 9559   size(4);
 9560 
 9561   format %{ &quot;VDUP.32 $dst.D,$src\t&quot; %}
 9562   ins_encode %{
 9563     bool quad = false;
 9564     __ vdupI($dst$$FloatRegister, $src$$Register,
 9565              MacroAssembler::VELEM_SIZE_32, quad);
 9566   %}
 9567   ins_pipe(ialu_reg); // FIXME
 9568 %}
 9569 
 9570 // Replicate scalar to packed int values in Double register pair
 9571 instruct Repl4I_reg_simd(vecX dst, iRegI src) %{
 9572   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
 9573   match(Set dst (ReplicateI src));
 9574   size(4);
 9575 
 9576   format %{ &quot;VDUP.32 $dst.Q,$src\t&quot; %}
 9577   ins_encode %{
 9578     bool quad = true;
 9579     __ vdupI($dst$$FloatRegister, $src$$Register,
 9580              MacroAssembler::VELEM_SIZE_32, quad);
 9581   %}
 9582   ins_pipe(ialu_reg); // FIXME
 9583 %}
 9584 
 9585 
 9586 // Replicate scalar zero constant to packed int values in Double register
 9587 instruct Repl2I_immI(vecD dst, immI src, iRegI tmp) %{
 9588   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9589   match(Set dst (ReplicateI src));
 9590   effect(TEMP tmp);
 9591   size(12);
 9592   ins_cost(DEFAULT_COST*4); // FIXME
 9593 
 9594   format %{ &quot;MOV      $tmp, Repl1($src))\n\t&quot;
 9595             &quot;FMDRR    $dst,$tmp,$tmp\t&quot; %}
 9596   ins_encode( LdReplImmI(src, dst, tmp, (1), (4)) );
 9597   ins_pipe(loadConFD); // FIXME
 9598 %}
 9599 
 9600 // Replicate scalar constant to packed byte values in Double register
 9601 instruct Repl2I_immU8(vecD dst, immU8 src) %{
 9602   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9603   match(Set dst (ReplicateI src));
 9604   size(4);
 9605 
 9606   format %{ &quot;VMOV.I32  $dst.D,$src&quot; %}
 9607   ins_encode %{
 9608     bool quad = false;
 9609     __ vmovI($dst$$FloatRegister, $src$$constant,
 9610              MacroAssembler::VELEM_SIZE_32, quad);
 9611   %}
 9612   ins_pipe(loadConFD); // FIXME
 9613 %}
 9614 
 9615 // Replicate scalar constant to packed byte values in Double register pair
 9616 instruct Repl4I_immU8(vecX dst, immU8 src) %{
 9617   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
 9618   match(Set dst (ReplicateI src));
 9619   size(4);
 9620 
 9621   format %{ &quot;VMOV.I32  $dst.Q,$src&quot; %}
 9622   ins_encode %{
 9623     bool quad = true;
 9624     __ vmovI($dst$$FloatRegister, $src$$constant,
 9625              MacroAssembler::VELEM_SIZE_32, quad);
 9626   %}
 9627   ins_pipe(loadConFD); // FIXME
 9628 %}
 9629 
 9630 // Replicate scalar to packed byte values in Double register pair
 9631 instruct Repl2L_reg(vecX dst, iRegL src) %{
 9632   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9633   match(Set dst (ReplicateL src));
 9634   size(8);
 9635   ins_cost(DEFAULT_COST*2); // FIXME
 9636 
 9637   format %{ &quot;FMDRR $dst.D,$src.lo,$src.hi\t\n&quot;
 9638             &quot;FMDRR $dst.D.next,$src.lo,$src.hi&quot; %}
 9639   ins_encode %{
 9640     __ fmdrr($dst$$FloatRegister, $src$$Register, $src$$Register-&gt;successor());
 9641     __ fmdrr($dst$$FloatRegister-&gt;successor()-&gt;successor(),
 9642              $src$$Register, $src$$Register-&gt;successor());
 9643   %}
 9644   ins_pipe(ialu_reg); // FIXME
 9645 %}
 9646 
 9647 
 9648 // Replicate scalar to packed float values in Double register
 9649 instruct Repl2F_regI(vecD dst, iRegI src) %{
 9650   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9651   match(Set dst (ReplicateF src));
 9652   size(4);
 9653 
 9654   format %{ &quot;FMDRR    $dst.D,$src,$src\t&quot; %}
 9655   ins_encode %{
 9656     __ fmdrr($dst$$FloatRegister, $src$$Register, $src$$Register);
 9657   %}
 9658   ins_pipe(ialu_reg); // FIXME
 9659 %}
 9660 
 9661 // Replicate scalar to packed float values in Double register
 9662 instruct Repl2F_reg_vfp(vecD dst, regF src) %{
 9663   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9664   match(Set dst (ReplicateF src));
 9665   size(4*2);
 9666   ins_cost(DEFAULT_COST*2); // FIXME
 9667 
 9668   expand %{
 9669     iRegI tmp;
 9670     MoveF2I_reg_reg(tmp, src);
 9671     Repl2F_regI(dst,tmp);
 9672   %}
 9673 %}
 9674 
 9675 // Replicate scalar to packed float values in Double register
 9676 instruct Repl2F_reg_simd(vecD dst, regF src) %{
 9677   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
 9678   match(Set dst (ReplicateF src));
 9679   size(4);
 9680   ins_cost(DEFAULT_COST); // FIXME
 9681 
 9682   format %{ &quot;VDUP.32  $dst.D,$src.D\t&quot; %}
 9683   ins_encode %{
 9684     bool quad = false;
 9685     __ vdupF($dst$$FloatRegister, $src$$FloatRegister, quad);
 9686   %}
 9687   ins_pipe(ialu_reg); // FIXME
 9688 %}
 9689 
 9690 // Replicate scalar to packed float values in Double register pair
 9691 instruct Repl4F_reg(vecX dst, regF src, iRegI tmp) %{
 9692   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9693   match(Set dst (ReplicateF src));
 9694   effect(TEMP tmp);
 9695   size(4*3);
 9696   ins_cost(DEFAULT_COST*3); // FIXME
 9697 
 9698   format %{ &quot;FMRS     $tmp,$src\n\t&quot;
 9699             &quot;FMDRR    $dst.D,$tmp,$tmp\n\t&quot;
 9700             &quot;FMDRR    $dst.D.next,$tmp,$tmp\t&quot; %}
 9701   ins_encode %{
 9702     __ fmrs($tmp$$Register, $src$$FloatRegister);
 9703     __ fmdrr($dst$$FloatRegister, $tmp$$Register, $tmp$$Register);
 9704     __ fmdrr($dst$$FloatRegister-&gt;successor()-&gt;successor(),
 9705              $tmp$$Register, $tmp$$Register);
 9706   %}
 9707   ins_pipe(ialu_reg); // FIXME
 9708 %}
 9709 
 9710 // Replicate scalar to packed float values in Double register pair
 9711 instruct Repl4F_reg_simd(vecX dst, regF src) %{
 9712   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
 9713   match(Set dst (ReplicateF src));
 9714   size(4);
 9715   ins_cost(DEFAULT_COST); // FIXME
 9716 
 9717   format %{ &quot;VDUP.32  $dst.Q,$src.D\t&quot; %}
 9718   ins_encode %{
 9719     bool quad = true;
 9720     __ vdupF($dst$$FloatRegister, $src$$FloatRegister, quad);
 9721   %}
 9722   ins_pipe(ialu_reg); // FIXME
 9723 %}
 9724 
 9725 // Replicate scalar zero constant to packed float values in Double register
 9726 instruct Repl2F_immI(vecD dst, immF src, iRegI tmp) %{
 9727   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9728   match(Set dst (ReplicateF src));
 9729   effect(TEMP tmp);
 9730   size(12);
 9731   ins_cost(DEFAULT_COST*4); // FIXME
 9732 
 9733   format %{ &quot;MOV      $tmp, Repl1($src))\n\t&quot;
 9734             &quot;FMDRR    $dst,$tmp,$tmp\t&quot; %}
 9735   ins_encode( LdReplImmF(src, dst, tmp) );
 9736   ins_pipe(loadConFD); // FIXME
 9737 %}
 9738 
 9739 // Replicate scalar to packed double float values in Double register pair
 9740 instruct Repl2D_reg(vecX dst, regD src) %{
 9741   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9742   match(Set dst (ReplicateD src));
 9743   size(4*2);
 9744   ins_cost(DEFAULT_COST*2); // FIXME
 9745 
 9746   format %{ &quot;FCPYD    $dst.D.a,$src\n\t&quot;
 9747             &quot;FCPYD    $dst.D.b,$src\t&quot; %}
 9748   ins_encode %{
 9749     FloatRegister dsta = $dst$$FloatRegister;
 9750     FloatRegister src = $src$$FloatRegister;
 9751     __ fcpyd(dsta, src);
 9752     FloatRegister dstb = dsta-&gt;successor()-&gt;successor();
 9753     __ fcpyd(dstb, src);
 9754   %}
 9755   ins_pipe(ialu_reg); // FIXME
 9756 %}
 9757 
 9758 // ====================VECTOR ARITHMETIC=======================================
 9759 
 9760 // --------------------------------- ADD --------------------------------------
 9761 
 9762 // Bytes vector add
 9763 instruct vadd8B_reg(vecD dst, vecD src1, vecD src2) %{
 9764   predicate(n-&gt;as_Vector()-&gt;length() == 8);
 9765   match(Set dst (AddVB src1 src2));
 9766   format %{ &quot;VADD.I8 $dst,$src1,$src2\t! add packed8B&quot; %}
 9767   size(4);
 9768   ins_encode %{
 9769     bool quad = false;
 9770     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9771              MacroAssembler::VELEM_SIZE_8, quad);
 9772   %}
 9773   ins_pipe( ialu_reg_reg ); // FIXME
 9774 %}
 9775 
 9776 instruct vadd16B_reg(vecX dst, vecX src1, vecX src2) %{
 9777   predicate(n-&gt;as_Vector()-&gt;length() == 16);
 9778   match(Set dst (AddVB src1 src2));
 9779   size(4);
 9780   format %{ &quot;VADD.I8 $dst.Q,$src1.Q,$src2.Q\t! add packed16B&quot; %}
 9781   ins_encode %{
 9782     bool quad = true;
 9783     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9784              MacroAssembler::VELEM_SIZE_8, quad);
 9785   %}
 9786   ins_pipe( ialu_reg_reg ); // FIXME
 9787 %}
 9788 
 9789 // Shorts/Chars vector add
 9790 instruct vadd4S_reg(vecD dst, vecD src1, vecD src2) %{
 9791   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9792   match(Set dst (AddVS src1 src2));
 9793   size(4);
 9794   format %{ &quot;VADD.I16 $dst,$src1,$src2\t! add packed4S&quot; %}
 9795   ins_encode %{
 9796     bool quad = false;
 9797     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9798              MacroAssembler::VELEM_SIZE_16, quad);
 9799   %}
 9800   ins_pipe( ialu_reg_reg ); // FIXME
 9801 %}
 9802 
 9803 instruct vadd8S_reg(vecX dst, vecX src1, vecX src2) %{
 9804   predicate(n-&gt;as_Vector()-&gt;length() == 8);
 9805   match(Set dst (AddVS src1 src2));
 9806   size(4);
 9807   format %{ &quot;VADD.I16 $dst.Q,$src1.Q,$src2.Q\t! add packed8S&quot; %}
 9808   ins_encode %{
 9809     bool quad = true;
 9810     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9811              MacroAssembler::VELEM_SIZE_16, quad);
 9812   %}
 9813   ins_pipe( ialu_reg_reg ); // FIXME
 9814 %}
 9815 
 9816 // Integers vector add
 9817 instruct vadd2I_reg(vecD dst, vecD src1, vecD src2) %{
 9818   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9819   match(Set dst (AddVI src1 src2));
 9820   size(4);
 9821   format %{ &quot;VADD.I32 $dst.D,$src1.D,$src2.D\t! add packed2I&quot; %}
 9822   ins_encode %{
 9823     bool quad = false;
 9824     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9825              MacroAssembler::VELEM_SIZE_32, quad);
 9826   %}
 9827   ins_pipe( ialu_reg_reg ); // FIXME
 9828 %}
 9829 
 9830 instruct vadd4I_reg(vecX dst, vecX src1, vecX src2) %{
 9831   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9832   match(Set dst (AddVI src1 src2));
 9833   size(4);
 9834   format %{ &quot;VADD.I32 $dst.Q,$src1.Q,$src2.Q\t! add packed4I&quot; %}
 9835   ins_encode %{
 9836     bool quad = true;
 9837     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9838              MacroAssembler::VELEM_SIZE_32, quad);
 9839   %}
 9840   ins_pipe( ialu_reg_reg ); // FIXME
 9841 %}
 9842 
 9843 // Longs vector add
 9844 instruct vadd2L_reg(vecX dst, vecX src1, vecX src2) %{
 9845   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9846   match(Set dst (AddVL src1 src2));
 9847   size(4);
 9848   format %{ &quot;VADD.I64 $dst.Q,$src1.Q,$src2.Q\t! add packed2L&quot; %}
 9849   ins_encode %{
 9850     bool quad = true;
 9851     __ vaddI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9852              MacroAssembler::VELEM_SIZE_64, quad);
 9853   %}
 9854   ins_pipe( ialu_reg_reg ); // FIXME
 9855 %}
 9856 
 9857 // Floats vector add
 9858 instruct vadd2F_reg(vecD dst, vecD src1, vecD src2) %{
 9859   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::simd_math_is_compliant());
 9860   match(Set dst (AddVF src1 src2));
 9861   size(4);
 9862   format %{ &quot;VADD.F32 $dst,$src1,$src2\t! add packed2F&quot; %}
 9863   ins_encode %{
 9864     bool quad = false;
 9865     __ vaddF($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9866              MacroAssembler::VFA_SIZE_F32, quad);
 9867   %}
 9868   ins_pipe( faddD_reg_reg ); // FIXME
 9869 %}
 9870 
 9871 instruct vadd2F_reg_vfp(vecD dst, vecD src1, vecD src2) %{
 9872   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; !VM_Version::simd_math_is_compliant());
 9873   match(Set dst (AddVF src1 src2));
 9874   ins_cost(DEFAULT_COST*2); // FIXME
 9875 
 9876   size(4*2);
 9877   format %{ &quot;FADDS  $dst.a,$src1.a,$src2.a\n\t&quot;
 9878             &quot;FADDS  $dst.b,$src1.b,$src2.b&quot; %}
 9879   ins_encode %{
 9880     __ add_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
 9881     __ add_float($dst$$FloatRegister-&gt;successor(),
 9882              $src1$$FloatRegister-&gt;successor(),
 9883              $src2$$FloatRegister-&gt;successor());
 9884   %}
 9885 
 9886   ins_pipe(faddF_reg_reg); // FIXME
 9887 %}
 9888 
 9889 instruct vadd4F_reg_simd(vecX dst, vecX src1, vecX src2) %{
 9890   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::simd_math_is_compliant());
 9891   match(Set dst (AddVF src1 src2));
 9892   size(4);
 9893   format %{ &quot;VADD.F32 $dst.Q,$src1.Q,$src2.Q\t! add packed4F&quot; %}
 9894   ins_encode %{
 9895     bool quad = true;
 9896     __ vaddF($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9897              MacroAssembler::VFA_SIZE_F32, quad);
 9898   %}
 9899   ins_pipe( faddD_reg_reg ); // FIXME
 9900 %}
 9901 
 9902 instruct vadd4F_reg_vfp(vecX dst, vecX src1, vecX src2) %{
 9903   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::simd_math_is_compliant());
 9904   match(Set dst (AddVF src1 src2));
 9905   size(4*4);
 9906   ins_cost(DEFAULT_COST*4); // FIXME
 9907 
 9908   format %{ &quot;FADDS  $dst.a,$src1.a,$src2.a\n\t&quot;
 9909             &quot;FADDS  $dst.b,$src1.b,$src2.b\n\t&quot;
 9910             &quot;FADDS  $dst.c,$src1.c,$src2.c\n\t&quot;
 9911             &quot;FADDS  $dst.d,$src1.d,$src2.d&quot; %}
 9912 
 9913   ins_encode %{
 9914     FloatRegister dsta = $dst$$FloatRegister;
 9915     FloatRegister src1a = $src1$$FloatRegister;
 9916     FloatRegister src2a = $src2$$FloatRegister;
 9917     __ add_float(dsta, src1a, src2a);
 9918     FloatRegister dstb = dsta-&gt;successor();
 9919     FloatRegister src1b = src1a-&gt;successor();
 9920     FloatRegister src2b = src2a-&gt;successor();
 9921     __ add_float(dstb, src1b, src2b);
 9922     FloatRegister dstc = dstb-&gt;successor();
 9923     FloatRegister src1c = src1b-&gt;successor();
 9924     FloatRegister src2c = src2b-&gt;successor();
 9925     __ add_float(dstc, src1c, src2c);
 9926     FloatRegister dstd = dstc-&gt;successor();
 9927     FloatRegister src1d = src1c-&gt;successor();
 9928     FloatRegister src2d = src2c-&gt;successor();
 9929     __ add_float(dstd, src1d, src2d);
 9930   %}
 9931 
 9932   ins_pipe(faddF_reg_reg); // FIXME
 9933 %}
 9934 
 9935 instruct vadd2D_reg_vfp(vecX dst, vecX src1, vecX src2) %{
 9936   predicate(n-&gt;as_Vector()-&gt;length() == 2);
 9937   match(Set dst (AddVD src1 src2));
 9938   size(4*2);
 9939   ins_cost(DEFAULT_COST*2); // FIXME
 9940 
 9941   format %{ &quot;FADDD  $dst.a,$src1.a,$src2.a\n\t&quot;
 9942             &quot;FADDD  $dst.b,$src1.b,$src2.b&quot; %}
 9943 
 9944   ins_encode %{
 9945     FloatRegister dsta = $dst$$FloatRegister;
 9946     FloatRegister src1a = $src1$$FloatRegister;
 9947     FloatRegister src2a = $src2$$FloatRegister;
 9948     __ add_double(dsta, src1a, src2a);
 9949     FloatRegister dstb = dsta-&gt;successor()-&gt;successor();
 9950     FloatRegister src1b = src1a-&gt;successor()-&gt;successor();
 9951     FloatRegister src2b = src2a-&gt;successor()-&gt;successor();
 9952     __ add_double(dstb, src1b, src2b);
 9953   %}
 9954 
 9955   ins_pipe(faddF_reg_reg); // FIXME
 9956 %}
 9957 
 9958 
 9959 // Bytes vector sub
 9960 instruct vsub8B_reg(vecD dst, vecD src1, vecD src2) %{
 9961   predicate(n-&gt;as_Vector()-&gt;length() == 8);
 9962   match(Set dst (SubVB src1 src2));
 9963   size(4);
 9964   format %{ &quot;VSUB.I8 $dst,$src1,$src2\t! sub packed8B&quot; %}
 9965   ins_encode %{
 9966     bool quad = false;
 9967     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9968              MacroAssembler::VELEM_SIZE_8, quad);
 9969   %}
 9970   ins_pipe( ialu_reg_reg ); // FIXME
 9971 %}
 9972 
 9973 instruct vsub16B_reg(vecX dst, vecX src1, vecX src2) %{
 9974   predicate(n-&gt;as_Vector()-&gt;length() == 16);
 9975   match(Set dst (SubVB src1 src2));
 9976   size(4);
 9977   format %{ &quot;VSUB.I8 $dst.Q,$src1.Q,$src2.Q\t! sub packed16B&quot; %}
 9978   ins_encode %{
 9979     bool quad = true;
 9980     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9981              MacroAssembler::VELEM_SIZE_8, quad);
 9982   %}
 9983   ins_pipe( ialu_reg_reg ); // FIXME
 9984 %}
 9985 
 9986 // Shorts/Chars vector sub
 9987 instruct vsub4S_reg(vecD dst, vecD src1, vecD src2) %{
 9988   predicate(n-&gt;as_Vector()-&gt;length() == 4);
 9989   match(Set dst (SubVS src1 src2));
 9990   size(4);
 9991   format %{ &quot;VSUB.I16 $dst,$src1,$src2\t! sub packed4S&quot; %}
 9992   ins_encode %{
 9993     bool quad = false;
 9994     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
 9995              MacroAssembler::VELEM_SIZE_16, quad);
 9996   %}
 9997   ins_pipe( ialu_reg_reg ); // FIXME
 9998 %}
 9999 
10000 instruct vsub16S_reg(vecX dst, vecX src1, vecX src2) %{
10001   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10002   match(Set dst (SubVS src1 src2));
10003   size(4);
10004   format %{ &quot;VSUB.I16 $dst.Q,$src1.Q,$src2.Q\t! sub packed8S&quot; %}
10005   ins_encode %{
10006     bool quad = true;
10007     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10008              MacroAssembler::VELEM_SIZE_16, quad);
10009   %}
10010   ins_pipe( ialu_reg_reg ); // FIXME
10011 %}
10012 
10013 // Integers vector sub
10014 instruct vsub2I_reg(vecD dst, vecD src1, vecD src2) %{
10015   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10016   match(Set dst (SubVI src1 src2));
10017   size(4);
10018   format %{ &quot;VSUB.I32 $dst,$src1,$src2\t! sub packed2I&quot; %}
10019   ins_encode %{
10020     bool quad = false;
10021     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10022              MacroAssembler::VELEM_SIZE_32, quad);
10023   %}
10024   ins_pipe( ialu_reg_reg ); // FIXME
10025 %}
10026 
10027 instruct vsub4I_reg(vecX dst, vecX src1, vecX src2) %{
10028   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10029   match(Set dst (SubVI src1 src2));
10030   size(4);
10031   format %{ &quot;VSUB.I32 $dst.Q,$src1.Q,$src2.Q\t! sub packed4I&quot; %}
10032   ins_encode %{
10033     bool quad = true;
10034     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10035              MacroAssembler::VELEM_SIZE_32, quad);
10036   %}
10037   ins_pipe( ialu_reg_reg ); // FIXME
10038 %}
10039 
10040 // Longs vector sub
10041 instruct vsub2L_reg(vecX dst, vecX src1, vecX src2) %{
10042   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10043   match(Set dst (SubVL src1 src2));
10044   size(4);
10045   format %{ &quot;VSUB.I64 $dst.Q,$src1.Q,$src2.Q\t! sub packed2L&quot; %}
10046   ins_encode %{
10047     bool quad = true;
10048     __ vsubI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10049              MacroAssembler::VELEM_SIZE_64, quad);
10050   %}
10051   ins_pipe( ialu_reg_reg ); // FIXME
10052 %}
10053 
10054 // Floats vector sub
10055 instruct vsub2F_reg(vecD dst, vecD src1, vecD src2) %{
10056   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::simd_math_is_compliant());
10057   match(Set dst (SubVF src1 src2));
10058   size(4);
10059   format %{ &quot;VSUB.F32 $dst,$src1,$src2\t! sub packed2F&quot; %}
10060   ins_encode %{
10061     bool quad = false;
10062     __ vsubF($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10063              MacroAssembler::VFA_SIZE_F32, quad);
10064   %}
10065   ins_pipe( faddF_reg_reg ); // FIXME
10066 %}
10067 
10068 instruct vsub2F_reg_vfp(vecD dst, vecD src1, vecD src2) %{
10069   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; !VM_Version::simd_math_is_compliant());
10070   match(Set dst (SubVF src1 src2));
10071   size(4*2);
10072   ins_cost(DEFAULT_COST*2); // FIXME
10073 
10074   format %{ &quot;FSUBS  $dst.a,$src1.a,$src2.a\n\t&quot;
10075             &quot;FSUBS  $dst.b,$src1.b,$src2.b&quot; %}
10076 
10077   ins_encode %{
10078     FloatRegister dsta = $dst$$FloatRegister;
10079     FloatRegister src1a = $src1$$FloatRegister;
10080     FloatRegister src2a = $src2$$FloatRegister;
10081     __ sub_float(dsta, src1a, src2a);
10082     FloatRegister dstb = dsta-&gt;successor();
10083     FloatRegister src1b = src1a-&gt;successor();
10084     FloatRegister src2b = src2a-&gt;successor();
10085     __ sub_float(dstb, src1b, src2b);
10086   %}
10087 
10088   ins_pipe(faddF_reg_reg); // FIXME
10089 %}
10090 
10091 
10092 instruct vsub4F_reg(vecX dst, vecX src1, vecX src2) %{
10093   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::simd_math_is_compliant());
10094   match(Set dst (SubVF src1 src2));
10095   size(4);
10096   format %{ &quot;VSUB.F32 $dst.Q,$src1.Q,$src2.Q\t! sub packed4F&quot; %}
10097   ins_encode %{
10098     bool quad = true;
10099     __ vsubF($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10100              MacroAssembler::VFA_SIZE_F32, quad);
10101   %}
10102   ins_pipe( faddF_reg_reg ); // FIXME
10103 %}
10104 
10105 instruct vsub4F_reg_vfp(vecX dst, vecX src1, vecX src2) %{
10106   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::simd_math_is_compliant());
10107   match(Set dst (SubVF src1 src2));
10108   size(4*4);
10109   ins_cost(DEFAULT_COST*4); // FIXME
10110 
10111   format %{ &quot;FSUBS  $dst.a,$src1.a,$src2.a\n\t&quot;
10112             &quot;FSUBS  $dst.b,$src1.b,$src2.b\n\t&quot;
10113             &quot;FSUBS  $dst.c,$src1.c,$src2.c\n\t&quot;
10114             &quot;FSUBS  $dst.d,$src1.d,$src2.d&quot; %}
10115 
10116   ins_encode %{
10117     FloatRegister dsta = $dst$$FloatRegister;
10118     FloatRegister src1a = $src1$$FloatRegister;
10119     FloatRegister src2a = $src2$$FloatRegister;
10120     __ sub_float(dsta, src1a, src2a);
10121     FloatRegister dstb = dsta-&gt;successor();
10122     FloatRegister src1b = src1a-&gt;successor();
10123     FloatRegister src2b = src2a-&gt;successor();
10124     __ sub_float(dstb, src1b, src2b);
10125     FloatRegister dstc = dstb-&gt;successor();
10126     FloatRegister src1c = src1b-&gt;successor();
10127     FloatRegister src2c = src2b-&gt;successor();
10128     __ sub_float(dstc, src1c, src2c);
10129     FloatRegister dstd = dstc-&gt;successor();
10130     FloatRegister src1d = src1c-&gt;successor();
10131     FloatRegister src2d = src2c-&gt;successor();
10132     __ sub_float(dstd, src1d, src2d);
10133   %}
10134 
10135   ins_pipe(faddF_reg_reg); // FIXME
10136 %}
10137 
10138 instruct vsub2D_reg_vfp(vecX dst, vecX src1, vecX src2) %{
10139   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10140   match(Set dst (SubVD src1 src2));
10141   size(4*2);
10142   ins_cost(DEFAULT_COST*2); // FIXME
10143 
10144   format %{ &quot;FSUBD  $dst.a,$src1.a,$src2.a\n\t&quot;
10145             &quot;FSUBD  $dst.b,$src1.b,$src2.b&quot; %}
10146 
10147   ins_encode %{
10148     FloatRegister dsta = $dst$$FloatRegister;
10149     FloatRegister src1a = $src1$$FloatRegister;
10150     FloatRegister src2a = $src2$$FloatRegister;
10151     __ sub_double(dsta, src1a, src2a);
10152     FloatRegister dstb = dsta-&gt;successor()-&gt;successor();
10153     FloatRegister src1b = src1a-&gt;successor()-&gt;successor();
10154     FloatRegister src2b = src2a-&gt;successor()-&gt;successor();
10155     __ sub_double(dstb, src1b, src2b);
10156   %}
10157 
10158   ins_pipe(faddF_reg_reg); // FIXME
10159 %}
10160 
10161 // Shorts/Chars vector mul
10162 instruct vmul4S_reg(vecD dst, vecD src1, vecD src2) %{
10163   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10164   match(Set dst (MulVS src1 src2));
10165   size(4);
10166   format %{ &quot;VMUL.I16 $dst,$src1,$src2\t! mul packed4S&quot; %}
10167   ins_encode %{
10168     __ vmulI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10169              MacroAssembler::VELEM_SIZE_16, 0);
10170   %}
10171   ins_pipe( ialu_reg_reg ); // FIXME
10172 %}
10173 
10174 instruct vmul8S_reg(vecX dst, vecX src1, vecX src2) %{
10175   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10176   match(Set dst (MulVS src1 src2));
10177   size(4);
10178   format %{ &quot;VMUL.I16 $dst.Q,$src1.Q,$src2.Q\t! mul packed8S&quot; %}
10179   ins_encode %{
10180     __ vmulI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10181              MacroAssembler::VELEM_SIZE_16, 1);
10182   %}
10183   ins_pipe( ialu_reg_reg ); // FIXME
10184 %}
10185 
10186 // Integers vector mul
10187 instruct vmul2I_reg(vecD dst, vecD src1, vecD src2) %{
10188   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10189   match(Set dst (MulVI src1 src2));
10190   size(4);
10191   format %{ &quot;VMUL.I32 $dst,$src1,$src2\t! mul packed2I&quot; %}
10192   ins_encode %{
10193     __ vmulI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10194              MacroAssembler::VELEM_SIZE_32, 0);
10195   %}
10196   ins_pipe( ialu_reg_reg ); // FIXME
10197 %}
10198 
10199 instruct vmul4I_reg(vecX dst, vecX src1, vecX src2) %{
10200   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10201   match(Set dst (MulVI src1 src2));
10202   size(4);
10203   format %{ &quot;VMUL.I32 $dst.Q,$src1.Q,$src2.Q\t! mul packed4I&quot; %}
10204   ins_encode %{
10205     __ vmulI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10206              MacroAssembler::VELEM_SIZE_32, 1);
10207   %}
10208   ins_pipe( ialu_reg_reg ); // FIXME
10209 %}
10210 
10211 // Floats vector mul
10212 instruct vmul2F_reg(vecD dst, vecD src1, vecD src2) %{
10213   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::simd_math_is_compliant());
10214   match(Set dst (MulVF src1 src2));
10215   size(4);
10216   format %{ &quot;VMUL.F32 $dst,$src1,$src2\t! mul packed2F&quot; %}
10217   ins_encode %{
10218     __ vmulF($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10219              MacroAssembler::VFA_SIZE_F32, 0);
10220   %}
10221   ins_pipe( fmulF_reg_reg ); // FIXME
10222 %}
10223 
10224 instruct vmul2F_reg_vfp(vecD dst, vecD src1, vecD src2) %{
10225   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; !VM_Version::simd_math_is_compliant());
10226   match(Set dst (MulVF src1 src2));
10227   size(4*2);
10228   ins_cost(DEFAULT_COST*2); // FIXME
10229 
10230   format %{ &quot;FMULS  $dst.a,$src1.a,$src2.a\n\t&quot;
10231             &quot;FMULS  $dst.b,$src1.b,$src2.b&quot; %}
10232   ins_encode %{
10233     __ mul_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
10234     __ mul_float($dst$$FloatRegister-&gt;successor(),
10235              $src1$$FloatRegister-&gt;successor(),
10236              $src2$$FloatRegister-&gt;successor());
10237   %}
10238 
10239   ins_pipe(fmulF_reg_reg); // FIXME
10240 %}
10241 
10242 instruct vmul4F_reg(vecX dst, vecX src1, vecX src2) %{
10243   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::simd_math_is_compliant());
10244   match(Set dst (MulVF src1 src2));
10245   size(4);
10246   format %{ &quot;VMUL.F32 $dst.Q,$src1.Q,$src2.Q\t! mul packed4F&quot; %}
10247   ins_encode %{
10248     __ vmulF($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
10249              MacroAssembler::VFA_SIZE_F32, 1);
10250   %}
10251   ins_pipe( fmulF_reg_reg ); // FIXME
10252 %}
10253 
10254 instruct vmul4F_reg_vfp(vecX dst, vecX src1, vecX src2) %{
10255   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; !VM_Version::simd_math_is_compliant());
10256   match(Set dst (MulVF src1 src2));
10257   size(4*4);
10258   ins_cost(DEFAULT_COST*4); // FIXME
10259 
10260   format %{ &quot;FMULS  $dst.a,$src1.a,$src2.a\n\t&quot;
10261             &quot;FMULS  $dst.b,$src1.b,$src2.b\n\t&quot;
10262             &quot;FMULS  $dst.c,$src1.c,$src2.c\n\t&quot;
10263             &quot;FMULS  $dst.d,$src1.d,$src2.d&quot; %}
10264 
10265   ins_encode %{
10266     FloatRegister dsta = $dst$$FloatRegister;
10267     FloatRegister src1a = $src1$$FloatRegister;
10268     FloatRegister src2a = $src2$$FloatRegister;
10269     __ mul_float(dsta, src1a, src2a);
10270     FloatRegister dstb = dsta-&gt;successor();
10271     FloatRegister src1b = src1a-&gt;successor();
10272     FloatRegister src2b = src2a-&gt;successor();
10273     __ mul_float(dstb, src1b, src2b);
10274     FloatRegister dstc = dstb-&gt;successor();
10275     FloatRegister src1c = src1b-&gt;successor();
10276     FloatRegister src2c = src2b-&gt;successor();
10277     __ mul_float(dstc, src1c, src2c);
10278     FloatRegister dstd = dstc-&gt;successor();
10279     FloatRegister src1d = src1c-&gt;successor();
10280     FloatRegister src2d = src2c-&gt;successor();
10281     __ mul_float(dstd, src1d, src2d);
10282   %}
10283 
10284   ins_pipe(fmulF_reg_reg); // FIXME
10285 %}
10286 
10287 instruct vmul2D_reg_vfp(vecX dst, vecX src1, vecX src2) %{
10288   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10289   match(Set dst (MulVD src1 src2));
10290   size(4*2);
10291   ins_cost(DEFAULT_COST*2); // FIXME
10292 
10293   format %{ &quot;FMULD  $dst.D.a,$src1.D.a,$src2.D.a\n\t&quot;
10294             &quot;FMULD  $dst.D.b,$src1.D.b,$src2.D.b&quot; %}
10295   ins_encode %{
10296     FloatRegister dsta = $dst$$FloatRegister;
10297     FloatRegister src1a = $src1$$FloatRegister;
10298     FloatRegister src2a = $src2$$FloatRegister;
10299     __ mul_double(dsta, src1a, src2a);
10300     FloatRegister dstb = dsta-&gt;successor()-&gt;successor();
10301     FloatRegister src1b = src1a-&gt;successor()-&gt;successor();
10302     FloatRegister src2b = src2a-&gt;successor()-&gt;successor();
10303     __ mul_double(dstb, src1b, src2b);
10304   %}
10305 
10306   ins_pipe(fmulD_reg_reg); // FIXME
10307 %}
10308 
10309 
10310 // Floats vector div
10311 instruct vdiv2F_reg_vfp(vecD dst, vecD src1, vecD src2) %{
10312   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10313   match(Set dst (DivVF src1 src2));
10314   size(4*2);
10315   ins_cost(DEFAULT_COST*2); // FIXME
10316 
10317   format %{ &quot;FDIVS  $dst.a,$src1.a,$src2.a\n\t&quot;
10318             &quot;FDIVS  $dst.b,$src1.b,$src2.b&quot; %}
10319   ins_encode %{
10320     __ div_float($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister);
10321     __ div_float($dst$$FloatRegister-&gt;successor(),
10322              $src1$$FloatRegister-&gt;successor(),
10323              $src2$$FloatRegister-&gt;successor());
10324   %}
10325 
10326   ins_pipe(fdivF_reg_reg); // FIXME
10327 %}
10328 
10329 instruct vdiv4F_reg_vfp(vecX dst, vecX src1, vecX src2) %{
10330   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10331   match(Set dst (DivVF src1 src2));
10332   size(4*4);
10333   ins_cost(DEFAULT_COST*4); // FIXME
10334 
10335   format %{ &quot;FDIVS  $dst.a,$src1.a,$src2.a\n\t&quot;
10336             &quot;FDIVS  $dst.b,$src1.b,$src2.b\n\t&quot;
10337             &quot;FDIVS  $dst.c,$src1.c,$src2.c\n\t&quot;
10338             &quot;FDIVS  $dst.d,$src1.d,$src2.d&quot; %}
10339 
10340   ins_encode %{
10341     FloatRegister dsta = $dst$$FloatRegister;
10342     FloatRegister src1a = $src1$$FloatRegister;
10343     FloatRegister src2a = $src2$$FloatRegister;
10344     __ div_float(dsta, src1a, src2a);
10345     FloatRegister dstb = dsta-&gt;successor();
10346     FloatRegister src1b = src1a-&gt;successor();
10347     FloatRegister src2b = src2a-&gt;successor();
10348     __ div_float(dstb, src1b, src2b);
10349     FloatRegister dstc = dstb-&gt;successor();
10350     FloatRegister src1c = src1b-&gt;successor();
10351     FloatRegister src2c = src2b-&gt;successor();
10352     __ div_float(dstc, src1c, src2c);
10353     FloatRegister dstd = dstc-&gt;successor();
10354     FloatRegister src1d = src1c-&gt;successor();
10355     FloatRegister src2d = src2c-&gt;successor();
10356     __ div_float(dstd, src1d, src2d);
10357   %}
10358 
10359   ins_pipe(fdivF_reg_reg); // FIXME
10360 %}
10361 
10362 instruct vdiv2D_reg_vfp(vecX dst, vecX src1, vecX src2) %{
10363   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10364   match(Set dst (DivVD src1 src2));
10365   size(4*2);
10366   ins_cost(DEFAULT_COST*2); // FIXME
10367 
10368   format %{ &quot;FDIVD  $dst.D.a,$src1.D.a,$src2.D.a\n\t&quot;
10369             &quot;FDIVD  $dst.D.b,$src1.D.b,$src2.D.b&quot; %}
10370   ins_encode %{
10371     FloatRegister dsta = $dst$$FloatRegister;
10372     FloatRegister src1a = $src1$$FloatRegister;
10373     FloatRegister src2a = $src2$$FloatRegister;
10374     __ div_double(dsta, src1a, src2a);
10375     FloatRegister dstb = dsta-&gt;successor()-&gt;successor();
10376     FloatRegister src1b = src1a-&gt;successor()-&gt;successor();
10377     FloatRegister src2b = src2a-&gt;successor()-&gt;successor();
10378     __ div_double(dstb, src1b, src2b);
10379   %}
10380 
10381   ins_pipe(fdivD_reg_reg); // FIXME
10382 %}
10383 
10384 // --------------------------------- NEG --------------------------------------
10385 
10386 instruct vneg8B_reg(vecD dst, vecD src) %{
10387   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8);
10388   effect(DEF dst, USE src);
10389   size(4);
10390   ins_cost(DEFAULT_COST); // FIXME
10391   format %{ &quot;VNEG.S8 $dst.D,$src.D\t! neg packed8B&quot; %}
10392   ins_encode %{
10393     bool quad = false;
10394     __ vnegI($dst$$FloatRegister, $src$$FloatRegister,
10395               MacroAssembler::VELEM_SIZE_8, quad);
10396   %}
10397   ins_pipe( ialu_reg_reg ); // FIXME
10398 %}
10399 
10400 instruct vneg16B_reg(vecX dst, vecX src) %{
10401   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16);
10402   effect(DEF dst, USE src);
10403   size(4);
10404   ins_cost(DEFAULT_COST); // FIXME
10405   format %{ &quot;VNEG.S8 $dst.Q,$src.Q\t! neg0 packed16B&quot; %}
10406   ins_encode %{
10407     bool _float = false;
10408     bool quad = true;
10409     __ vnegI($dst$$FloatRegister, $src$$FloatRegister,
10410               MacroAssembler::VELEM_SIZE_8, quad);
10411   %}
10412   ins_pipe( ialu_reg_reg ); // FIXME
10413 %}
10414 
10415 // ------------------------------ Shift ---------------------------------------
10416 
10417 instruct vslcntD(vecD dst, iRegI cnt) %{
10418   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
10419   match(Set dst (LShiftCntV cnt));
10420   size(4);
10421   ins_cost(DEFAULT_COST); // FIXME
10422   expand %{
10423     Repl8B_reg_simd(dst, cnt);
10424   %}
10425 %}
10426 
10427 instruct vslcntX(vecX dst, iRegI cnt) %{
10428   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
10429   match(Set dst (LShiftCntV cnt));
10430   size(4);
10431   ins_cost(DEFAULT_COST); // FIXME
10432   expand %{
10433     Repl16B_reg(dst, cnt);
10434   %}
10435 %}
10436 
10437 // Low bits of vector &quot;shift&quot; elements are used, so it
10438 // doesn&#39;t matter if we treat it as ints or bytes here.
10439 instruct vsrcntD(vecD dst, iRegI cnt) %{
10440   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8 &amp;&amp; VM_Version::has_simd());
10441   match(Set dst (RShiftCntV cnt));
10442   size(4*2);
10443   ins_cost(DEFAULT_COST*2); // FIXME
10444 
10445   format %{ &quot;VDUP.8 $dst.D,$cnt\n\t&quot;
10446             &quot;VNEG.S8 $dst.D,$dst.D\t! neg packed8B&quot; %}
10447   ins_encode %{
10448     bool quad = false;
10449     __ vdupI($dst$$FloatRegister, $cnt$$Register,
10450              MacroAssembler::VELEM_SIZE_8, quad);
10451     __ vnegI($dst$$FloatRegister, $dst$$FloatRegister,
10452               MacroAssembler::VELEM_SIZE_8, quad);
10453   %}
10454   ins_pipe( ialu_reg_reg ); // FIXME
10455 %}
10456 
10457 instruct vsrcntX(vecX dst, iRegI cnt) %{
10458   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16 &amp;&amp; VM_Version::has_simd());
10459   match(Set dst (RShiftCntV cnt));
10460   size(4*2);
10461   ins_cost(DEFAULT_COST*2); // FIXME
10462   format %{ &quot;VDUP.8 $dst.Q,$cnt\n\t&quot;
10463             &quot;VNEG.S8 $dst.Q,$dst.Q\t! neg packed16B&quot; %}
10464   ins_encode %{
10465     bool quad = true;
10466     __ vdupI($dst$$FloatRegister, $cnt$$Register,
10467              MacroAssembler::VELEM_SIZE_8, quad);
10468     __ vnegI($dst$$FloatRegister, $dst$$FloatRegister,
10469               MacroAssembler::VELEM_SIZE_8, quad);
10470   %}
10471   ins_pipe( ialu_reg_reg ); // FIXME
10472 %}
10473 
10474 // Byte vector logical left/right shift based on sign
10475 instruct vsh8B_reg(vecD dst, vecD src, vecD shift) %{
10476   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10477   effect(DEF dst, USE src, USE shift);
10478   size(4);
10479   ins_cost(DEFAULT_COST); // FIXME
10480   format %{
10481     &quot;VSHL.U8 $dst.D,$src.D,$shift.D\t! logical left/right shift packed8B&quot;
10482   %}
10483   ins_encode %{
10484     bool quad = false;
10485     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10486               MacroAssembler::VELEM_SIZE_8, quad);
10487   %}
10488   ins_pipe( ialu_reg_reg ); // FIXME
10489 %}
10490 
10491 instruct vsh16B_reg(vecX dst, vecX src, vecX shift) %{
10492   predicate(n-&gt;as_Vector()-&gt;length() == 16);
10493   effect(DEF dst, USE src, USE shift);
10494   size(4);
10495   ins_cost(DEFAULT_COST); // FIXME
10496   format %{
10497     &quot;VSHL.U8 $dst.Q,$src.Q,$shift.Q\t! logical left/right shift packed16B&quot;
10498   %}
10499   ins_encode %{
10500     bool quad = true;
10501     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10502               MacroAssembler::VELEM_SIZE_8, quad);
10503   %}
10504   ins_pipe( ialu_reg_reg ); // FIXME
10505 %}
10506 
10507 // Shorts/Char vector logical left/right shift based on sign
10508 instruct vsh4S_reg(vecD dst, vecD src, vecD shift) %{
10509   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10510   effect(DEF dst, USE src, USE shift);
10511   size(4);
10512   ins_cost(DEFAULT_COST); // FIXME
10513   format %{
10514     &quot;VSHL.U16 $dst.D,$src.D,$shift.D\t! logical left/right shift packed4S&quot;
10515   %}
10516   ins_encode %{
10517     bool quad = false;
10518     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10519               MacroAssembler::VELEM_SIZE_16, quad);
10520   %}
10521   ins_pipe( ialu_reg_reg ); // FIXME
10522 %}
10523 
10524 instruct vsh8S_reg(vecX dst, vecX src, vecX shift) %{
10525   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10526   effect(DEF dst, USE src, USE shift);
10527   size(4);
10528   ins_cost(DEFAULT_COST); // FIXME
10529   format %{
10530     &quot;VSHL.U16 $dst.Q,$src.Q,$shift.Q\t! logical left/right shift packed8S&quot;
10531   %}
10532   ins_encode %{
10533     bool quad = true;
10534     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10535               MacroAssembler::VELEM_SIZE_16, quad);
10536   %}
10537   ins_pipe( ialu_reg_reg ); // FIXME
10538 %}
10539 
10540 // Integers vector logical left/right shift based on sign
10541 instruct vsh2I_reg(vecD dst, vecD src, vecD shift) %{
10542   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10543   effect(DEF dst, USE src, USE shift);
10544   size(4);
10545   ins_cost(DEFAULT_COST); // FIXME
10546   format %{
10547     &quot;VSHL.U32 $dst.D,$src.D,$shift.D\t! logical left/right shift packed2I&quot;
10548   %}
10549   ins_encode %{
10550     bool quad = false;
10551     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10552               MacroAssembler::VELEM_SIZE_32, quad);
10553   %}
10554   ins_pipe( ialu_reg_reg ); // FIXME
10555 %}
10556 
10557 instruct vsh4I_reg(vecX dst, vecX src, vecX shift) %{
10558   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10559   effect(DEF dst, USE src, USE shift);
10560   size(4);
10561   ins_cost(DEFAULT_COST); // FIXME
10562   format %{
10563     &quot;VSHL.U32 $dst.Q,$src.Q,$shift.Q\t! logical left/right shift packed4I&quot;
10564   %}
10565   ins_encode %{
10566     bool quad = true;
10567     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10568               MacroAssembler::VELEM_SIZE_32, quad);
10569   %}
10570   ins_pipe( ialu_reg_reg ); // FIXME
10571 %}
10572 
10573 // Longs vector logical left/right shift based on sign
10574 instruct vsh2L_reg(vecX dst, vecX src, vecX shift) %{
10575   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10576   effect(DEF dst, USE src, USE shift);
10577   size(4);
10578   ins_cost(DEFAULT_COST); // FIXME
10579   format %{
10580     &quot;VSHL.U64 $dst.Q,$src.Q,$shift.Q\t! logical left/right shift packed2L&quot;
10581   %}
10582   ins_encode %{
10583     bool quad = true;
10584     __ vshlUI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10585               MacroAssembler::VELEM_SIZE_64, quad);
10586   %}
10587   ins_pipe( ialu_reg_reg ); // FIXME
10588 %}
10589 
10590 // ------------------------------ LeftShift -----------------------------------
10591 
10592 // Byte vector left shift
10593 instruct vsl8B_reg(vecD dst, vecD src, vecD shift) %{
10594   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10595   match(Set dst (LShiftVB src shift));
10596   size(4*1);
10597   ins_cost(DEFAULT_COST*1); // FIXME
10598   expand %{
10599     vsh8B_reg(dst, src, shift);
10600   %}
10601 %}
10602 
10603 instruct vsl16B_reg(vecX dst, vecX src, vecX shift) %{
10604   predicate(n-&gt;as_Vector()-&gt;length() == 16);
10605   match(Set dst (LShiftVB src shift));
10606   size(4*1);
10607   ins_cost(DEFAULT_COST*1); // FIXME
10608   expand %{
10609     vsh16B_reg(dst, src, shift);
10610   %}
10611 %}
10612 
10613 instruct vsl8B_immI(vecD dst, vecD src, immI shift) %{
10614   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10615   match(Set dst (LShiftVB src (LShiftCntV shift)));
10616   size(4);
10617   ins_cost(DEFAULT_COST); // FIXME
10618   format %{
10619     &quot;VSHL.I8 $dst.D,$src.D,$shift\t! logical left shift packed8B&quot;
10620   %}
10621   ins_encode %{
10622     bool quad = false;
10623     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 8, $shift$$constant,
10624              quad);
10625   %}
10626   ins_pipe( ialu_reg_reg ); // FIXME
10627 %}
10628 
10629 instruct vsl16B_immI(vecX dst, vecX src, immI shift) %{
10630   predicate(n-&gt;as_Vector()-&gt;length() == 16);
10631   match(Set dst (LShiftVB src (LShiftCntV shift)));
10632   size(4);
10633   ins_cost(DEFAULT_COST); // FIXME
10634   format %{
10635     &quot;VSHL.I8 $dst.Q,$src.Q,$shift\t! logical left shift packed16B&quot;
10636   %}
10637   ins_encode %{
10638     bool quad = true;
10639     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 8, $shift$$constant,
10640              quad);
10641   %}
10642   ins_pipe( ialu_reg_reg ); // FIXME
10643 %}
10644 
10645 // Shorts/Chars vector logical left/right shift
10646 instruct vsl4S_reg(vecD dst, vecD src, vecD shift) %{
10647   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10648   match(Set dst (LShiftVS src shift));
10649   match(Set dst (URShiftVS src shift));
10650   size(4*1);
10651   ins_cost(DEFAULT_COST*1); // FIXME
10652   expand %{
10653     vsh4S_reg(dst, src, shift);
10654   %}
10655 %}
10656 
10657 instruct vsl8S_reg(vecX dst, vecX src, vecX shift) %{
10658   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10659   match(Set dst (LShiftVS src shift));
10660   match(Set dst (URShiftVS src shift));
10661   size(4*1);
10662   ins_cost(DEFAULT_COST*1); // FIXME
10663   expand %{
10664     vsh8S_reg(dst, src, shift);
10665   %}
10666 %}
10667 
10668 instruct vsl4S_immI(vecD dst, vecD src, immI shift) %{
10669   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10670   match(Set dst (LShiftVS src (LShiftCntV shift)));
10671   size(4);
10672   ins_cost(DEFAULT_COST); // FIXME
10673   format %{
10674     &quot;VSHL.I16 $dst.D,$src.D,$shift\t! logical left shift packed4S&quot;
10675   %}
10676   ins_encode %{
10677     bool quad = false;
10678     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 16, $shift$$constant,
10679              quad);
10680   %}
10681   ins_pipe( ialu_reg_reg ); // FIXME
10682 %}
10683 
10684 instruct vsl8S_immI(vecX dst, vecX src, immI shift) %{
10685   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10686   match(Set dst (LShiftVS src shift));
10687   size(4);
10688   ins_cost(DEFAULT_COST); // FIXME
10689   format %{
10690     &quot;VSHL.I16 $dst.Q,$src.Q,$shift\t! logical left shift packed8S&quot;
10691   %}
10692   ins_encode %{
10693     bool quad = true;
10694     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 16, $shift$$constant,
10695              quad);
10696   %}
10697   ins_pipe( ialu_reg_reg ); // FIXME
10698 %}
10699 
10700 // Integers vector logical left/right shift
10701 instruct vsl2I_reg(vecD dst, vecD src, vecD shift) %{
10702   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
10703   match(Set dst (LShiftVI src shift));
10704   match(Set dst (URShiftVI src shift));
10705   size(4*1);
10706   ins_cost(DEFAULT_COST*1); // FIXME
10707   expand %{
10708     vsh2I_reg(dst, src, shift);
10709   %}
10710 %}
10711 
10712 instruct vsl4I_reg(vecX dst, vecX src, vecX shift) %{
10713   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
10714   match(Set dst (LShiftVI src shift));
10715   match(Set dst (URShiftVI src shift));
10716   size(4*1);
10717   ins_cost(DEFAULT_COST*1); // FIXME
10718   expand %{
10719     vsh4I_reg(dst, src, shift);
10720   %}
10721 %}
10722 
10723 instruct vsl2I_immI(vecD dst, vecD src, immI shift) %{
10724   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
10725   match(Set dst (LShiftVI src (LShiftCntV shift)));
10726   size(4);
10727   ins_cost(DEFAULT_COST); // FIXME
10728   format %{
10729     &quot;VSHL.I32 $dst.D,$src.D,$shift\t! logical left shift packed2I&quot;
10730   %}
10731   ins_encode %{
10732     bool quad = false;
10733     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 32, $shift$$constant,
10734              quad);
10735   %}
10736   ins_pipe( ialu_reg_reg ); // FIXME
10737 %}
10738 
10739 instruct vsl4I_immI(vecX dst, vecX src, immI shift) %{
10740   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
10741   match(Set dst (LShiftVI src (LShiftCntV shift)));
10742   size(4);
10743   ins_cost(DEFAULT_COST); // FIXME
10744   format %{
10745     &quot;VSHL.I32 $dst.Q,$src.Q,$shift\t! logical left shift packed4I&quot;
10746   %}
10747   ins_encode %{
10748     bool quad = true;
10749     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 32, $shift$$constant,
10750              quad);
10751   %}
10752   ins_pipe( ialu_reg_reg ); // FIXME
10753 %}
10754 
10755 // Longs vector logical left/right shift
10756 instruct vsl2L_reg(vecX dst, vecX src, vecX shift) %{
10757   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10758   match(Set dst (LShiftVL src shift));
10759   match(Set dst (URShiftVL src shift));
10760   size(4*1);
10761   ins_cost(DEFAULT_COST*1); // FIXME
10762   expand %{
10763     vsh2L_reg(dst, src, shift);
10764   %}
10765 %}
10766 
10767 instruct vsl2L_immI(vecX dst, vecX src, immI shift) %{
10768   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10769   match(Set dst (LShiftVL src (LShiftCntV shift)));
10770   size(4);
10771   ins_cost(DEFAULT_COST); // FIXME
10772   format %{
10773     &quot;VSHL.I64 $dst.Q,$src.Q,$shift\t! logical left shift packed2L&quot;
10774   %}
10775   ins_encode %{
10776     bool quad = true;
10777     __ vshli($dst$$FloatRegister, $src$$FloatRegister, 64, $shift$$constant,
10778              quad);
10779   %}
10780   ins_pipe( ialu_reg_reg ); // FIXME
10781 %}
10782 
10783 // ----------------------- LogicalRightShift -----------------------------------
10784 
10785 // Bytes/Shorts vector logical right shift produces incorrect Java result
10786 // for negative data because java code convert short value into int with
10787 // sign extension before a shift.
10788 
10789 // Chars vector logical right shift
10790 instruct vsrl4S_immI(vecD dst, vecD src, immI shift) %{
10791   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10792   match(Set dst (URShiftVS src (RShiftCntV shift)));
10793   size(4);
10794   ins_cost(DEFAULT_COST); // FIXME
10795   format %{
10796     &quot;VSHR.U16 $dst.D,$src.D,$shift\t! logical right shift packed4S&quot;
10797   %}
10798   ins_encode %{
10799     bool quad = false;
10800     __ vshrUI($dst$$FloatRegister, $src$$FloatRegister, 16, $shift$$constant,
10801              quad);
10802   %}
10803   ins_pipe( ialu_reg_reg ); // FIXME
10804 %}
10805 
10806 instruct vsrl8S_immI(vecX dst, vecX src, immI shift) %{
10807   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10808   match(Set dst (URShiftVS src (RShiftCntV shift)));
10809   size(4);
10810   ins_cost(DEFAULT_COST); // FIXME
10811   format %{
10812     &quot;VSHR.U16 $dst.Q,$src.Q,$shift\t! logical right shift packed8S&quot;
10813   %}
10814   ins_encode %{
10815     bool quad = true;
10816     __ vshrUI($dst$$FloatRegister, $src$$FloatRegister, 16, $shift$$constant,
10817              quad);
10818   %}
10819   ins_pipe( ialu_reg_reg ); // FIXME
10820 %}
10821 
10822 // Integers vector logical right shift
10823 instruct vsrl2I_immI(vecD dst, vecD src, immI shift) %{
10824   predicate(n-&gt;as_Vector()-&gt;length() == 2 &amp;&amp; VM_Version::has_simd());
10825   match(Set dst (URShiftVI src (RShiftCntV shift)));
10826   size(4);
10827   ins_cost(DEFAULT_COST); // FIXME
10828   format %{
10829     &quot;VSHR.U32 $dst.D,$src.D,$shift\t! logical right shift packed2I&quot;
10830   %}
10831   ins_encode %{
10832     bool quad = false;
10833     __ vshrUI($dst$$FloatRegister, $src$$FloatRegister, 32, $shift$$constant,
10834              quad);
10835   %}
10836   ins_pipe( ialu_reg_reg ); // FIXME
10837 %}
10838 
10839 instruct vsrl4I_immI(vecX dst, vecX src, immI shift) %{
10840   predicate(n-&gt;as_Vector()-&gt;length() == 4 &amp;&amp; VM_Version::has_simd());
10841   match(Set dst (URShiftVI src (RShiftCntV shift)));
10842   size(4);
10843   ins_cost(DEFAULT_COST); // FIXME
10844   format %{
10845     &quot;VSHR.U32 $dst.Q,$src.Q,$shift\t! logical right shift packed4I&quot;
10846   %}
10847   ins_encode %{
10848     bool quad = true;
10849     __ vshrUI($dst$$FloatRegister, $src$$FloatRegister, 32, $shift$$constant,
10850              quad);
10851   %}
10852   ins_pipe( ialu_reg_reg ); // FIXME
10853 %}
10854 
10855 // Longs vector logical right shift
10856 instruct vsrl2L_immI(vecX dst, vecX src, immI shift) %{
10857   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10858   match(Set dst (URShiftVL src (RShiftCntV shift)));
10859   size(4);
10860   ins_cost(DEFAULT_COST); // FIXME
10861   format %{
10862     &quot;VSHR.U64 $dst.Q,$src.Q,$shift\t! logical right shift packed2L&quot;
10863   %}
10864   ins_encode %{
10865     bool quad = true;
10866     __ vshrUI($dst$$FloatRegister, $src$$FloatRegister, 64, $shift$$constant,
10867              quad);
10868   %}
10869   ins_pipe( ialu_reg_reg ); // FIXME
10870 %}
10871 
10872 // ------------------- ArithmeticRightShift -----------------------------------
10873 
10874 // Bytes vector arithmetic left/right shift based on sign
10875 instruct vsha8B_reg(vecD dst, vecD src, vecD shift) %{
10876   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10877   effect(DEF dst, USE src, USE shift);
10878   size(4);
10879   ins_cost(DEFAULT_COST); // FIXME
10880   format %{
10881     &quot;VSHL.S8 $dst.D,$src.D,$shift.D\t! arithmetic right shift packed8B&quot;
10882   %}
10883   ins_encode %{
10884     bool quad = false;
10885     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10886               MacroAssembler::VELEM_SIZE_8, quad);
10887   %}
10888   ins_pipe( ialu_reg_reg ); // FIXME
10889 %}
10890 
10891 instruct vsha16B_reg(vecX dst, vecX src, vecX shift) %{
10892   predicate(n-&gt;as_Vector()-&gt;length() == 16);
10893   effect(DEF dst, USE src, USE shift);
10894   size(4);
10895   ins_cost(DEFAULT_COST); // FIXME
10896   format %{
10897     &quot;VSHL.S8 $dst.Q,$src.Q,$shift.Q\t! arithmetic right shift packed16B&quot;
10898   %}
10899   ins_encode %{
10900     bool quad = true;
10901     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10902               MacroAssembler::VELEM_SIZE_8, quad);
10903   %}
10904   ins_pipe( ialu_reg_reg ); // FIXME
10905 %}
10906 
10907 // Shorts vector arithmetic left/right shift based on sign
10908 instruct vsha4S_reg(vecD dst, vecD src, vecD shift) %{
10909   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10910   effect(DEF dst, USE src, USE shift);
10911   size(4);
10912   ins_cost(DEFAULT_COST); // FIXME
10913   format %{
10914     &quot;VSHL.S16 $dst.D,$src.D,$shift.D\t! arithmetic right shift packed4S&quot;
10915   %}
10916   ins_encode %{
10917     bool quad = false;
10918     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10919               MacroAssembler::VELEM_SIZE_16, quad);
10920   %}
10921   ins_pipe( ialu_reg_reg ); // FIXME
10922 %}
10923 
10924 instruct vsha8S_reg(vecX dst, vecX src, vecX shift) %{
10925   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10926   effect(DEF dst, USE src, USE shift);
10927   size(4);
10928   ins_cost(DEFAULT_COST); // FIXME
10929   format %{
10930     &quot;VSHL.S16 $dst.Q,$src.Q,$shift.Q\t! arithmetic right shift packed8S&quot;
10931   %}
10932   ins_encode %{
10933     bool quad = true;
10934     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10935               MacroAssembler::VELEM_SIZE_16, quad);
10936   %}
10937   ins_pipe( ialu_reg_reg ); // FIXME
10938 %}
10939 
10940 // Integers vector arithmetic left/right shift based on sign
10941 instruct vsha2I_reg(vecD dst, vecD src, vecD shift) %{
10942   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10943   effect(DEF dst, USE src, USE shift);
10944   size(4);
10945   ins_cost(DEFAULT_COST); // FIXME
10946   format %{
10947     &quot;VSHL.S32 $dst.D,$src.D,$shift.D\t! arithmetic right shift packed2I&quot;
10948   %}
10949   ins_encode %{
10950     bool quad = false;
10951     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10952               MacroAssembler::VELEM_SIZE_32, quad);
10953   %}
10954   ins_pipe( ialu_reg_reg ); // FIXME
10955 %}
10956 
10957 instruct vsha4I_reg(vecX dst, vecX src, vecX shift) %{
10958   predicate(n-&gt;as_Vector()-&gt;length() == 4);
10959   effect(DEF dst, USE src, USE shift);
10960   size(4);
10961   ins_cost(DEFAULT_COST); // FIXME
10962   format %{
10963     &quot;VSHL.S32 $dst.Q,$src.Q,$shift.Q\t! arithmetic right shift packed4I&quot;
10964   %}
10965   ins_encode %{
10966     bool quad = true;
10967     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10968               MacroAssembler::VELEM_SIZE_32, quad);
10969   %}
10970   ins_pipe( ialu_reg_reg ); // FIXME
10971 %}
10972 
10973 // Longs vector arithmetic left/right shift based on sign
10974 instruct vsha2L_reg(vecX dst, vecX src, vecX shift) %{
10975   predicate(n-&gt;as_Vector()-&gt;length() == 2);
10976   effect(DEF dst, USE src, USE shift);
10977   size(4);
10978   ins_cost(DEFAULT_COST); // FIXME
10979   format %{
10980     &quot;VSHL.S64 $dst.Q,$src.Q,$shift.Q\t! arithmetic right shift packed2L&quot;
10981   %}
10982   ins_encode %{
10983     bool quad = true;
10984     __ vshlSI($dst$$FloatRegister, $shift$$FloatRegister, $src$$FloatRegister,
10985               MacroAssembler::VELEM_SIZE_64, quad);
10986   %}
10987   ins_pipe( ialu_reg_reg ); // FIXME
10988 %}
10989 
10990 // Byte vector arithmetic right shift
10991 
10992 instruct vsra8B_reg(vecD dst, vecD src, vecD shift) %{
10993   predicate(n-&gt;as_Vector()-&gt;length() == 8);
10994   match(Set dst (RShiftVB src shift));
10995   size(4);
10996   ins_cost(DEFAULT_COST); // FIXME
10997   expand %{
10998     vsha8B_reg(dst, src, shift);
10999   %}
11000 %}
11001 
11002 instruct vsrl16B_reg(vecX dst, vecX src, vecX shift) %{
11003   predicate(n-&gt;as_Vector()-&gt;length() == 16);
11004   match(Set dst (RShiftVB src shift));
11005   size(4);
11006   ins_cost(DEFAULT_COST); // FIXME
11007   expand %{
11008     vsha16B_reg(dst, src, shift);
11009   %}
11010 %}
11011 
11012 instruct vsrl8B_immI(vecD dst, vecD src, immI shift) %{
11013   predicate(n-&gt;as_Vector()-&gt;length() == 8);
11014   match(Set dst (RShiftVB src shift));
11015   size(4);
11016   ins_cost(DEFAULT_COST); // FIXME
11017   format %{
11018     &quot;VSHR.S8 $dst.D,$src.D,$shift\t! logical right shift packed8B&quot;
11019   %}
11020   ins_encode %{
11021     bool quad = false;
11022     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 8, $shift$$constant,
11023              quad);
11024   %}
11025   ins_pipe( ialu_reg_reg ); // FIXME
11026 %}
11027 
11028 instruct vsrl16B_immI(vecX dst, vecX src, immI shift) %{
11029   predicate(n-&gt;as_Vector()-&gt;length() == 16);
11030   match(Set dst (RShiftVB src shift));
11031   size(4);
11032   ins_cost(DEFAULT_COST); // FIXME
11033   format %{
11034     &quot;VSHR.S8 $dst.Q,$src.Q,$shift\t! logical right shift packed16B&quot;
11035   %}
11036   ins_encode %{
11037     bool quad = true;
11038     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 8, $shift$$constant,
11039              quad);
11040   %}
11041   ins_pipe( ialu_reg_reg ); // FIXME
11042 %}
11043 
11044 // Shorts vector arithmetic right shift
11045 instruct vsra4S_reg(vecD dst, vecD src, vecD shift) %{
11046   predicate(n-&gt;as_Vector()-&gt;length() == 4);
11047   match(Set dst (RShiftVS src shift));
11048   size(4);
11049   ins_cost(DEFAULT_COST); // FIXME
11050   expand %{
11051     vsha4S_reg(dst, src, shift);
11052   %}
11053 %}
11054 
11055 instruct vsra8S_reg(vecX dst, vecX src, vecX shift) %{
11056   predicate(n-&gt;as_Vector()-&gt;length() == 8);
11057   match(Set dst (RShiftVS src shift));
11058   size(4);
11059   ins_cost(DEFAULT_COST); // FIXME
11060   expand %{
11061     vsha8S_reg(dst, src, shift);
11062   %}
11063 %}
11064 
11065 instruct vsra4S_immI(vecD dst, vecD src, immI shift) %{
11066   predicate(n-&gt;as_Vector()-&gt;length() == 4);
11067   match(Set dst (RShiftVS src shift));
11068   size(4);
11069   ins_cost(DEFAULT_COST); // FIXME
11070   format %{
11071     &quot;VSHR.S16 $dst.D,$src.D,$shift\t! logical right shift packed4S&quot;
11072   %}
11073   ins_encode %{
11074     bool quad = false;
11075     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 16, $shift$$constant,
11076              quad);
11077   %}
11078   ins_pipe( ialu_reg_reg ); // FIXME
11079 %}
11080 
11081 instruct vsra8S_immI(vecX dst, vecX src, immI shift) %{
11082   predicate(n-&gt;as_Vector()-&gt;length() == 8);
11083   match(Set dst (RShiftVS src shift));
11084   size(4);
11085   ins_cost(DEFAULT_COST); // FIXME
11086   format %{
11087     &quot;VSHR.S16 $dst.Q,$src.Q,$shift\t! logical right shift packed8S&quot;
11088   %}
11089   ins_encode %{
11090     bool quad = true;
11091     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 16, $shift$$constant,
11092              quad);
11093   %}
11094   ins_pipe( ialu_reg_reg ); // FIXME
11095 %}
11096 
11097 // Integers vector arithmetic right shift
11098 instruct vsra2I_reg(vecD dst, vecD src, vecD shift) %{
11099   predicate(n-&gt;as_Vector()-&gt;length() == 2);
11100   match(Set dst (RShiftVI src shift));
11101   size(4);
11102   ins_cost(DEFAULT_COST); // FIXME
11103   expand %{
11104     vsha2I_reg(dst, src, shift);
11105   %}
11106 %}
11107 
11108 instruct vsra4I_reg(vecX dst, vecX src, vecX shift) %{
11109   predicate(n-&gt;as_Vector()-&gt;length() == 4);
11110   match(Set dst (RShiftVI src shift));
11111   size(4);
11112   ins_cost(DEFAULT_COST); // FIXME
11113   expand %{
11114     vsha4I_reg(dst, src, shift);
11115   %}
11116 %}
11117 
11118 instruct vsra2I_immI(vecD dst, vecD src, immI shift) %{
11119   predicate(n-&gt;as_Vector()-&gt;length() == 2);
11120   match(Set dst (RShiftVI src shift));
11121   size(4);
11122   ins_cost(DEFAULT_COST); // FIXME
11123   format %{
11124     &quot;VSHR.S32 $dst.D,$src.D,$shift\t! logical right shift packed2I&quot;
11125   %}
11126   ins_encode %{
11127     bool quad = false;
11128     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 32, $shift$$constant,
11129              quad);
11130   %}
11131   ins_pipe( ialu_reg_reg ); // FIXME
11132 %}
11133 
11134 instruct vsra4I_immI(vecX dst, vecX src, immI shift) %{
11135   predicate(n-&gt;as_Vector()-&gt;length() == 4);
11136   match(Set dst (RShiftVI src shift));
11137   size(4);
11138   ins_cost(DEFAULT_COST); // FIXME
11139   format %{
11140     &quot;VSHR.S32 $dst.Q,$src.Q,$shift\t! logical right shift packed4I&quot;
11141   %}
11142   ins_encode %{
11143     bool quad = true;
11144     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 32, $shift$$constant,
11145              quad);
11146   %}
11147   ins_pipe( ialu_reg_reg ); // FIXME
11148 %}
11149 
11150 // Longs vector arithmetic right shift
11151 instruct vsra2L_reg(vecX dst, vecX src, vecX shift) %{
11152   predicate(n-&gt;as_Vector()-&gt;length() == 2);
11153   match(Set dst (RShiftVL src shift));
11154   size(4);
11155   ins_cost(DEFAULT_COST); // FIXME
11156   expand %{
11157     vsha2L_reg(dst, src, shift);
11158   %}
11159 %}
11160 
11161 instruct vsra2L_immI(vecX dst, vecX src, immI shift) %{
11162   predicate(n-&gt;as_Vector()-&gt;length() == 2);
11163   match(Set dst (RShiftVL src shift));
11164   size(4);
11165   ins_cost(DEFAULT_COST); // FIXME
11166   format %{
11167     &quot;VSHR.S64 $dst.Q,$src.Q,$shift\t! logical right shift packed2L&quot;
11168   %}
11169   ins_encode %{
11170     bool quad = true;
11171     __ vshrSI($dst$$FloatRegister, $src$$FloatRegister, 64, $shift$$constant,
11172              quad);
11173   %}
11174   ins_pipe( ialu_reg_reg ); // FIXME
11175 %}
11176 
11177 // --------------------------------- AND --------------------------------------
11178 
11179 instruct vandD(vecD dst, vecD src1, vecD src2) %{
11180   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8);
11181   match(Set dst (AndV src1 src2));
11182   format %{ &quot;VAND    $dst.D,$src1.D,$src2.D\t! and vectors (8 bytes)&quot; %}
11183   ins_encode %{
11184     bool quad = false;
11185     __ vandI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
11186              quad);
11187   %}
11188   ins_pipe( ialu_reg_reg ); // FIXME
11189 %}
11190 
11191 instruct vandX(vecX dst, vecX src1, vecX src2) %{
11192   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16);
11193   match(Set dst (AndV src1 src2));
11194   format %{ &quot;VAND    $dst.Q,$src1.Q,$src2.Q\t! and vectors (16 bytes)&quot; %}
11195   ins_encode %{
11196     bool quad = true;
11197     __ vandI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
11198              quad);
11199   %}
11200   ins_pipe( ialu_reg_reg ); // FIXME
11201 %}
11202 
11203 // --------------------------------- OR ---------------------------------------
11204 
11205 instruct vorD(vecD dst, vecD src1, vecD src2) %{
11206   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8);
11207   match(Set dst (OrV src1 src2));
11208   format %{ &quot;VOR     $dst.D,$src1.D,$src2.D\t! and vectors (8 bytes)&quot; %}
11209   ins_encode %{
11210     bool quad = false;
11211     __ vorI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
11212             quad);
11213   %}
11214   ins_pipe( ialu_reg_reg ); // FIXME
11215 %}
11216 
11217 instruct vorX(vecX dst, vecX src1, vecX src2) %{
11218   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16);
11219   match(Set dst (OrV src1 src2));
11220   format %{ &quot;VOR     $dst.Q,$src1.Q,$src2.Q\t! and vectors (16 bytes)&quot; %}
11221   ins_encode %{
11222     bool quad = true;
11223     __ vorI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
11224             quad);
11225   %}
11226   ins_pipe( ialu_reg_reg ); // FIXME
11227 %}
11228 
11229 // --------------------------------- XOR --------------------------------------
11230 
11231 instruct vxorD(vecD dst, vecD src1, vecD src2) %{
11232   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 8);
11233   match(Set dst (XorV src1 src2));
11234   format %{ &quot;VXOR    $dst.D,$src1.D,$src2.D\t! and vectors (8 bytes)&quot; %}
11235   ins_encode %{
11236     bool quad = false;
11237     __ vxorI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
11238              quad);
11239   %}
11240   ins_pipe( ialu_reg_reg ); // FIXME
11241 %}
11242 
11243 instruct vxorX(vecX dst, vecX src1, vecX src2) %{
11244   predicate(n-&gt;as_Vector()-&gt;length_in_bytes() == 16);
11245   match(Set dst (XorV src1 src2));
11246   format %{ &quot;VXOR    $dst.Q,$src1.Q,$src2.Q\t! and vectors (16 bytes)&quot; %}
11247   ins_encode %{
11248     bool quad = true;
11249     __ vxorI($dst$$FloatRegister, $src1$$FloatRegister, $src2$$FloatRegister,
11250              quad);
11251   %}
11252   ins_pipe( ialu_reg_reg ); // FIXME
11253 %}
11254 
11255 
11256 //----------PEEPHOLE RULES-----------------------------------------------------
11257 // These must follow all instruction definitions as they use the names
11258 // defined in the instructions definitions.
11259 //
11260 // peepmatch ( root_instr_name [preceding_instruction]* );
11261 //
11262 // peepconstraint %{
11263 // (instruction_number.operand_name relational_op instruction_number.operand_name
11264 //  [, ...] );
11265 // // instruction numbers are zero-based using left to right order in peepmatch
11266 //
11267 // peepreplace ( instr_name  ( [instruction_number.operand_name]* ) );
11268 // // provide an instruction_number.operand_name for each operand that appears
11269 // // in the replacement instruction&#39;s match rule
11270 //
11271 // ---------VM FLAGS---------------------------------------------------------
11272 //
11273 // All peephole optimizations can be turned off using -XX:-OptoPeephole
11274 //
11275 // Each peephole rule is given an identifying number starting with zero and
11276 // increasing by one in the order seen by the parser.  An individual peephole
11277 // can be enabled, and all others disabled, by using -XX:OptoPeepholeAt=#
11278 // on the command-line.
11279 //
11280 // ---------CURRENT LIMITATIONS----------------------------------------------
11281 //
11282 // Only match adjacent instructions in same basic block
11283 // Only equality constraints
11284 // Only constraints between operands, not (0.dest_reg == EAX_enc)
11285 // Only one replacement instruction
11286 //
11287 // ---------EXAMPLE----------------------------------------------------------
11288 //
11289 // // pertinent parts of existing instructions in architecture description
11290 // instruct movI(eRegI dst, eRegI src) %{
11291 //   match(Set dst (CopyI src));
11292 // %}
11293 //
11294 // instruct incI_eReg(eRegI dst, immI1 src, eFlagsReg cr) %{
11295 //   match(Set dst (AddI dst src));
11296 //   effect(KILL cr);
11297 // %}
11298 //
11299 // // Change (inc mov) to lea
11300 // peephole %{
11301 //   // increment preceeded by register-register move
11302 //   peepmatch ( incI_eReg movI );
11303 //   // require that the destination register of the increment
11304 //   // match the destination register of the move
11305 //   peepconstraint ( 0.dst == 1.dst );
11306 //   // construct a replacement instruction that sets
11307 //   // the destination to ( move&#39;s source register + one )
11308 //   peepreplace ( incI_eReg_immI1( 0.dst 1.src 0.src ) );
11309 // %}
11310 //
11311 
11312 // // Change load of spilled value to only a spill
11313 // instruct storeI(memory mem, eRegI src) %{
11314 //   match(Set mem (StoreI mem src));
11315 // %}
11316 //
11317 // instruct loadI(eRegI dst, memory mem) %{
11318 //   match(Set dst (LoadI mem));
11319 // %}
11320 //
11321 // peephole %{
11322 //   peepmatch ( loadI storeI );
11323 //   peepconstraint ( 1.src == 0.dst, 1.mem == 0.mem );
11324 //   peepreplace ( storeI( 1.mem 1.mem 1.src ) );
11325 // %}
11326 
11327 //----------SMARTSPILL RULES---------------------------------------------------
11328 // These must follow all instruction definitions as they use the names
11329 // defined in the instructions definitions.
11330 //
11331 // ARM will probably not have any of these rules due to RISC instruction set.
11332 
11333 //----------PIPELINE-----------------------------------------------------------
11334 // Rules which define the behavior of the target architectures pipeline.
<a name="42" id="anc42"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="42" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/s390.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
    3 // Copyright (c) 2017, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
</pre>
<hr />
<pre>
  588 
  589 #define __ _masm.
  590 
  591 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  592 #define Z_DISP3_SIZE 6
  593 
  594 // Tertiary op of a LoadP or StoreP encoding.
  595 #define REGP_OP true
  596 
  597 // Given a register encoding, produce an Integer Register object.
  598 static Register reg_to_register_object(int register_encoding);
  599 
  600 // ****************************************************************************
  601 
  602 // REQUIRED FUNCTIONALITY
  603 
  604 // !!!!! Special hack to get all type of calls to specify the byte offset
  605 //       from the start of the call to the point where the return address
  606 //       will point.
  607 











  608 int MachCallStaticJavaNode::ret_addr_offset() {
  609   if (_method) {
  610     return 8;
  611   } else {
  612     return MacroAssembler::call_far_patchable_ret_addr_offset();
  613   }
  614 }
  615 
  616 int MachCallDynamicJavaNode::ret_addr_offset() {
  617   // Consider size of receiver type profiling (C2 tiers).
  618   int profile_receiver_type_size = 0;
  619 
  620   int vtable_index = this-&gt;_vtable_index;
  621   if (vtable_index == -4) {
  622     return 14 + profile_receiver_type_size;
  623   } else {
  624     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  625     return 36 + profile_receiver_type_size;
  626   }
  627 }
</pre>
<hr />
<pre>
  647 
  648 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  649   return (12 - current_offset) &amp; 2;
  650 }
  651 
  652 int CallLeafDirectNode::compute_padding(int current_offset) const {
  653   return (12 - current_offset) &amp; 2;
  654 }
  655 
  656 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  657   return (12 - current_offset) &amp; 2;
  658 }
  659 
  660 // Indicate if the safepoint node needs the polling page as an input.
  661 // Since z/Architecture does not have absolute addressing, it does.
  662 bool SafePointNode::needs_polling_address_input() {
  663   return true;
  664 }
  665 
  666 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  667   MacroAssembler _masm(&amp;cbuf);</span>
  668   __ z_nop();
  669 }
  670 
  671 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  672 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  673   MacroAssembler _masm(&amp;cbuf);</span>
  674   __ z_illtrap();
  675 }
  676 
  677 #if !defined(PRODUCT)
  678 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  679   os-&gt;print(&quot;TA&quot;);
  680 }
  681 #endif
  682 
  683 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  684   emit_break(cbuf);
  685 }
  686 
  687 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  688   return MachNode::size(ra_);
  689 }
  690 
  691 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  692   // 32bit instructions may become sign extended.
  693   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
</pre>
<hr />
<pre>
  718     value = (long)((unsigned long)((unsigned int)value));
  719   }
  720 
  721   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  722     z_emit16(cbuf, value);
  723     return 2;
  724   }
  725 
  726   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  727     z_emit32(cbuf, value);
  728     return 4;
  729   }
  730 
  731   // 6-byte instruction, probably unaligned store.
  732   z_emit48(cbuf, value);
  733   return 6;
  734 }
  735 
  736 // Check effective address (at runtime) for required alignment.
  737 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="line-modified">  738   MacroAssembler _masm(&amp;cbuf);</span>
  739 
  740   __ z_lay(Z_R0, disp, index, base);
  741   __ z_nill(Z_R0, alignment-1);
  742   __ z_brc(Assembler::bcondEqual, +3);
  743   __ z_illtrap();
  744 }
  745 
<span class="line-modified">  746 int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
  747                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  748   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  749   address old_mark = __ inst_mark();
  750   unsigned int start_off = __ offset();
  751 
  752   if (is_native_call) {
  753     ShouldNotReachHere();
  754   }
  755 
  756   if (rtype == relocInfo::runtime_call_w_cp_type) {
  757     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  758     address call_addr = __ call_c_opt((address)entry_point);
  759     if (call_addr == NULL) {
  760       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  761       return -1;
  762     }
  763   } else {
  764     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  765            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  766     __ relocate(rtype);
  767     // BRASL must be prepended with a nop to identify it in the instruction stream.
  768     __ z_nop();
  769     __ z_brasl(Z_R14, (address)entry_point);
  770   }
  771 
  772   unsigned int ret_off = __ offset();
  773 
  774   return (ret_off - start_off);
  775 }
  776 
<span class="line-modified">  777 static int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
  778   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  779   address old_mark = __ inst_mark();
  780   unsigned int start_off = __ offset();
  781 
  782   relocInfo::relocType rtype = rspec.type();
  783   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  784          &quot;unexpected rtype&quot;);
  785 
  786   __ relocate(rspec);
  787   __ z_nop();
  788   __ z_brasl(Z_R14, (address)entry_point);
  789 
  790   unsigned int ret_off = __ offset();
  791 
  792   return (ret_off - start_off);
  793 }
  794 
  795 //=============================================================================
  796 
  797 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="line-modified">  798 int Compile::ConstantTable::calculate_table_base_offset() const {</span>
  799   return 0;  // absolute addressing, no offset
  800 }
  801 
  802 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  803 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  804   ShouldNotReachHere();
  805 }
  806 
  807 // Even with PC-relative TOC addressing, we still need this node.
  808 // Float loads/stores do not support PC-relative addresses.
  809 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">  810   MacroAssembler _masm(&amp;cbuf);</span>
  811   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  812   __ load_toc(Rtoc);
  813 }
  814 
  815 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  816   // PCrelative TOC access.
  817   return 6;   // sizeof(LARL)
  818 }
  819 
  820 #if !defined(PRODUCT)
  821 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  822   Register r = as_Register(ra_-&gt;get_encode(this));
  823   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  824 }
  825 #endif
  826 
  827 //=============================================================================
  828 
  829 #if !defined(PRODUCT)
  830 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  831   Compile* C = ra_-&gt;C;
  832   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  833   st-&gt;print(&quot;\t&quot;);
  834   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  835     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  836   }
  837 
  838   if (VerifyThread) {
  839     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  840     st-&gt;print(&quot;\t&quot;);
  841   }
  842 
<span class="line-modified">  843   long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  844   int bangsize   = C-&gt;bang_size_in_bytes();</span>
  845 
  846   // Calls to C2R adapters often do not accept exceptional returns.
  847   // We require that their callers must bang for them. But be
  848   // careful, because some VM calls (such as call site linkage) can
  849   // use several kilobytes of stack. But the stack safety zone should
  850   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  851   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  852     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  853   }
  854   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  855   st-&gt;print(&quot;\t&quot;);
  856 }
  857 #endif
  858 
  859 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  860   Compile* C = ra_-&gt;C;
<span class="line-modified">  861   MacroAssembler _masm(&amp;cbuf);</span>
  862 
  863   __ verify_thread();
  864 
<span class="line-modified">  865   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  866   size_t bangsize  = C-&gt;bang_size_in_bytes();</span>
  867 
  868   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  869 
  870   if (C-&gt;clinit_barrier_on_entry()) {
  871     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  872 
  873     Label L_skip_barrier;
  874     Register klass = Z_R1_scratch;
  875 
  876     // Notify OOP recorder (don&#39;t need the relocation)
  877     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  878     __ load_const_optimized(klass, md.value());
  879     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  880 
  881     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  882     __ z_br(klass);
  883 
  884     __ bind(L_skip_barrier);
  885   }
  886 
  887   // Calls to C2R adapters often do not accept exceptional returns.
  888   // We require that their callers must bang for them. But be
  889   // careful, because some VM calls (such as call site linkage) can
  890   // use several kilobytes of stack. But the stack safety zone should
  891   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  892   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  893     __ generate_stack_overflow_check(bangsize);
  894   }
  895 
  896   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  897   __ save_return_pc();
  898 
  899   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  900   // &#39;out_preserve_stack_slots&#39; declaration.
  901   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  902 
  903   if (C-&gt;has_mach_constant_base_node()) {
  904     // NOTE: We set the table base offset here because users might be
  905     // emitted before MachConstantBaseNode.
<span class="line-modified">  906     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
  907     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  908   }
  909 }
  910 
  911 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  912   // Variable size. Determine dynamically.
  913   return MachNode::size(ra_);
  914 }
  915 
  916 int MachPrologNode::reloc() const {
  917   // Return number of relocatable values contained in this instruction.
  918   return 1; // One reloc entry for load_const(toc).
  919 }
  920 
  921 //=============================================================================
  922 
  923 #if !defined(PRODUCT)
  924 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  925   os-&gt;print_cr(&quot;epilog&quot;);
  926   os-&gt;print(&quot;\t&quot;);
  927   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  928     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  929     os-&gt;print(&quot;\t&quot;);
  930   }
  931 }
  932 #endif
  933 
  934 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  935   MacroAssembler _masm(&amp;cbuf);</span>
  936   Compile* C = ra_-&gt;C;
  937   __ verify_thread();
  938 
  939   // If this does safepoint polling, then do it here.
  940   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  941 
  942   // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="line-modified">  943   int frame_size_in_bytes = Assembler::align((C-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
  944   __ pop_frame_restore_retPC(frame_size_in_bytes);
  945 
  946   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  947     __ reserved_stack_check(Z_R14);
  948   }
  949 
  950   // Touch the polling page.
  951   if (need_polling) {
<span class="line-modified">  952     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">  953       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));</span>
<span class="line-removed">  954     } else {</span>
<span class="line-removed">  955       AddressLiteral pp(os::get_polling_page());</span>
<span class="line-removed">  956       __ load_const_optimized(Z_R1_scratch, pp);</span>
<span class="line-removed">  957     }</span>
  958     // We need to mark the code position where the load from the safepoint
  959     // polling page was emitted as relocInfo::poll_return_type here.
  960     __ relocate(relocInfo::poll_return_type);
  961     __ load_from_polling_page(Z_R1_scratch);
  962   }
  963 }
  964 
  965 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  966   // Variable size. determine dynamically.
  967   return MachNode::size(ra_);
  968 }
  969 
  970 int MachEpilogNode::reloc() const {
  971   // Return number of relocatable values contained in this instruction.
  972   return 1; // One for load_from_polling_page.
  973 }
  974 
  975 const Pipeline * MachEpilogNode::pipeline() const {
  976   return MachNode::pipeline_class();
  977 }
  978 
<span class="line-removed">  979 int MachEpilogNode::safepoint_offset() const {</span>
<span class="line-removed">  980   assert(do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="line-removed">  981   return 0;</span>
<span class="line-removed">  982 }</span>
<span class="line-removed">  983 </span>
  984 //=============================================================================
  985 
  986 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  987 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  988 
  989 static enum RC rc_class(OptoReg::Name reg) {
  990   // Return the register class for the given register. The given register
  991   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  992   // enumeration in adGlobals_s390.hpp.
  993 
  994   if (reg == OptoReg::Bad) {
  995     return rc_bad;
  996   }
  997 
  998   // We have 32 integer register halves, starting at index 0.
  999   if (reg &lt; 32) {
 1000     return rc_int;
 1001   }
 1002 
 1003   // We have 32 floating-point register halves, starting at index 32.
</pre>
<hr />
<pre>
 1017   if (cbuf) {
 1018     if (opcode &gt; (1L&lt;&lt;32)) {
 1019       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1020                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1021     } else {
 1022       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1023                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1024     }
 1025   }
 1026 
 1027 #if !defined(PRODUCT)
 1028   if (do_print) {
 1029     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1030   }
 1031 #endif
 1032   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1033 }
 1034 
 1035 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1036   if (cbuf) {
<span class="line-modified"> 1037     MacroAssembler _masm(cbuf);</span>
 1038     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1039   }
 1040 
 1041 #if !defined(PRODUCT)
 1042   else if (do_print) {
 1043     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1044   }
 1045 #endif
 1046 
 1047   return 6;
 1048 }
 1049 
 1050 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1051   // Get registers to move.
 1052   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1053   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1054   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1055   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1056 
 1057   enum RC src_hi_rc = rc_class(src_hi);
</pre>
<hr />
<pre>
 1091     }
 1092 
 1093     int r0 = Z_R0_num;
 1094     if (is64) {
 1095       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1096              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1097     }
 1098 
 1099     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1100            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1101   }
 1102 
 1103   // Check for float-&gt;int copy. Requires a trip through memory.
 1104   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1105     Unimplemented();  // Unsafe, do not remove!
 1106   }
 1107 
 1108   // Check for integer reg-reg copy.
 1109   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1110     if (cbuf) {
<span class="line-modified"> 1111       MacroAssembler _masm(cbuf);</span>
 1112       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1113       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1114       __ z_lgr(Rdst, Rsrc);
 1115       return 4;
 1116     }
 1117 #if !defined(PRODUCT)
 1118     // else
 1119     if (print) {
 1120       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1121     }
 1122 #endif
 1123     return 4;
 1124   }
 1125 
 1126   // Check for integer store.
 1127   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1128     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1129            &quot;expected same type of move for high parts&quot;);
 1130 
 1131     if (is64) {
</pre>
<hr />
<pre>
 1138 
 1139     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1140   }
 1141 
 1142   // Check for integer load
 1143   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1144   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1145 
 1146     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1147            &quot;expected same type of move for high parts&quot;);
 1148 
 1149     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1150     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1151 
 1152     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1153   }
 1154 
 1155   // Check for float reg-reg copy.
 1156   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1157     if (cbuf) {
<span class="line-modified"> 1158       MacroAssembler _masm(cbuf);</span>
 1159       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1160       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1161       __ z_ldr(Rdst, Rsrc);
 1162       return 2;
 1163     }
 1164 #if !defined(PRODUCT)
 1165     // else
 1166     if (print) {
 1167       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1168     }
 1169 #endif
 1170     return 2;
 1171   }
 1172 
 1173   // Check for float store.
 1174   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1175     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1176            &quot;expected same type of move for high parts&quot;);
 1177 
 1178     if (is64) {
</pre>
<hr />
<pre>
 1237 }
 1238 #endif
 1239 
 1240 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1241   implementation(&amp;cbuf, ra_, false, NULL);
 1242 }
 1243 
 1244 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1245   return implementation(NULL, ra_, true, NULL);
 1246 }
 1247 
 1248 //=============================================================================
 1249 
 1250 #if !defined(PRODUCT)
 1251 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1252   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1253 }
 1254 #endif
 1255 
 1256 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="line-modified"> 1257   MacroAssembler _masm(&amp;cbuf);</span>
 1258 
 1259   int rem_space = 0;
<span class="line-modified"> 1260   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
 1261     rem_space = cbuf.insts()-&gt;remaining();
 1262     if (rem_space &lt;= _count*2 + 8) {
 1263       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1264     }
 1265   }
 1266 
 1267   for (int i = 0; i &lt; _count; i++) {
 1268     __ z_nop();
 1269   }
 1270 
<span class="line-modified"> 1271   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
 1272     if (rem_space &lt;= _count*2 + 8) {
 1273       int rem_space2 = cbuf.insts()-&gt;remaining();
 1274       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1275     }
 1276   }
 1277 }
 1278 
 1279 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1280    return 2 * _count;
 1281 }
 1282 
 1283 #if !defined(PRODUCT)
 1284 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1285   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1286   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1287     int reg = ra_-&gt;get_reg_first(this);
 1288     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1289   } else {
 1290     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1291   }
 1292 }
 1293 #endif
 1294 
 1295 // Take care of the size function, if you make changes here!
 1296 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1297   MacroAssembler _masm(&amp;cbuf);</span>
 1298 
 1299   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1300   int reg = ra_-&gt;get_encode(this);
 1301   __ z_lay(as_Register(reg), offset, Z_SP);
 1302 }
 1303 
 1304 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1305   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1306   return 6;
 1307 }
 1308 
 1309  %} // end source section
 1310 
 1311 //----------SOURCE BLOCK-------------------------------------------------------
 1312 // This is a block of C++ code which provides values, functions, and
 1313 // definitions necessary in the rest of the architecture description
 1314 
 1315 source_hpp %{
 1316 
 1317 // Header information of the source block.
</pre>
<hr />
<pre>
 1343 
 1344 %} // end source_hpp section
 1345 
 1346 source %{
 1347 
 1348 #if !defined(PRODUCT)
 1349 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1350   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1351   os-&gt;print_cr(&quot;\tTA&quot;);
 1352   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1353   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1354   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1355   os-&gt;print_cr(&quot;\t...&quot;);
 1356   os-&gt;print_cr(&quot;\tTA&quot;);
 1357   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1358   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1359 }
 1360 #endif
 1361 
 1362 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1363   MacroAssembler _masm(&amp;cbuf);</span>
 1364   const int ic_miss_offset = 2;
 1365 
 1366   // Inline_cache contains a klass.
 1367   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1368   // ARG1 is the receiver oop.
 1369   Register R2_receiver = Z_ARG1;
 1370   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1371   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1372   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1373 
 1374   // Null check of receiver.
 1375   // This is the null check of the receiver that actually should be
 1376   // done in the caller. It&#39;s here because in case of implicit null
 1377   // checks we get it for free.
 1378   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1379          &quot;second word in oop should not require explicit null check.&quot;);
 1380   if (!ImplicitNullChecks) {
 1381     Label valid;
 1382     if (VM_Version::has_CompareBranch()) {
 1383       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
</pre>
<hr />
<pre>
 1416 
 1417 %} // interrupt source section
 1418 
 1419 source_hpp %{ // Header information of the source block.
 1420 
 1421 class HandlerImpl {
 1422  public:
 1423 
 1424   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1425   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1426 
 1427   static uint size_exception_handler() {
 1428     return NativeJump::max_instruction_size();
 1429   }
 1430 
 1431   static uint size_deopt_handler() {
 1432     return NativeCall::max_instruction_size();
 1433   }
 1434 };
 1435 







 1436 %} // end source_hpp section
 1437 
 1438 source %{
 1439 
 1440 // This exception handler code snippet is placed after the method&#39;s
 1441 // code. It is the return point if an exception occurred. it jumps to
 1442 // the exception blob.
 1443 //
 1444 // If the method gets deoptimized, the method and this code snippet
 1445 // get patched.
 1446 //
 1447 // 1) Trampoline code gets patched into the end of this exception
 1448 //   handler. the trampoline code jumps to the deoptimization blob.
 1449 //
 1450 // 2) The return address in the method&#39;s code will get patched such
 1451 //   that it jumps to the trampoline.
 1452 //
 1453 // 3) The handler will get patched such that it does not jump to the
 1454 //   exception blob, but to an entry in the deoptimization blob being
 1455 //   aware of the exception.
 1456 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1457   Register temp_reg = Z_R1;
<span class="line-modified"> 1458   MacroAssembler _masm(&amp;cbuf);</span>
 1459 
 1460   address base = __ start_a_stub(size_exception_handler());
 1461   if (base == NULL) {
 1462     return 0;          // CodeBuffer::expand failed
 1463   }
 1464 
 1465   int offset = __ offset();
 1466   // Use unconditional pc-relative jump with 32-bit range here.
 1467   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1468   __ z_br(temp_reg);
 1469 
 1470   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1471 
 1472   __ end_a_stub();
 1473 
 1474   return offset;
 1475 }
 1476 
 1477 // Emit deopt handler code.
 1478 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified"> 1479   MacroAssembler _masm(&amp;cbuf);</span>
 1480   address        base = __ start_a_stub(size_deopt_handler());
 1481 
 1482   if (base == NULL) {
 1483     return 0;  // CodeBuffer::expand failed
 1484   }
 1485 
 1486   int offset = __ offset();
 1487 
 1488   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1489   // we do not use load_const_opt here.
 1490   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1491   __ call(Z_R1);
 1492   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1493 
 1494   __ end_a_stub();
 1495   return offset;
 1496 }
 1497 
 1498 //=============================================================================
 1499 
</pre>
<hr />
<pre>
 1786   return _Z_RARG3_INT_REG_mask;
 1787 }
 1788 
 1789 // Register for DIVL projection of divmodL
 1790 RegMask Matcher::divL_proj_mask() {
 1791   return _Z_RARG4_LONG_REG_mask;
 1792 }
 1793 
 1794 // Register for MODL projection of divmodL
 1795 RegMask Matcher::modL_proj_mask() {
 1796   return _Z_RARG3_LONG_REG_mask;
 1797 }
 1798 
 1799 // Copied from sparc.
 1800 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1801   return RegMask();
 1802 }
 1803 
 1804 const bool Matcher::convi2l_type_required = true;
 1805 





 1806 // Should the Matcher clone shifts on addressing modes, expecting them
 1807 // to be subsumed into complex addressing expressions or compute them
 1808 // into registers?
<span class="line-modified"> 1809 bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1810   return clone_base_plus_offset_address(m, mstack, address_visited);
 1811 }
 1812 
 1813 void Compile::reshape_address(AddPNode* addp) {
 1814 }
 1815 
 1816 %} // source
 1817 
 1818 //----------ENCODING BLOCK-----------------------------------------------------
 1819 // This block specifies the encoding classes used by the compiler to output
 1820 // byte streams. Encoding classes are parameterized macros used by
 1821 // Machine Instruction Nodes in order to generate the bit encoding of the
 1822 // instruction. Operands specify their base encoding interface with the
 1823 // interface keyword. There are currently supported four interfaces,
 1824 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1825 // operand to generate a function which returns its register number when
 1826 // queried. CONST_INTER causes an operand to generate a function which
 1827 // returns the value of the constant when queried. MEMORY_INTER causes an
 1828 // operand to generate four functions which return the Base Register, the
 1829 // Index Register, the Scale Value, and the Offset Value of the operand when
 1830 // queried. COND_INTER causes an operand to generate six functions which
 1831 // return the encoding code (ie - encoding bits for the instruction)
 1832 // associated with each basic boolean condition for a conditional instruction.
 1833 //
 1834 // Instructions specify two basic values for encoding. Again, a function
 1835 // is available to check if the constant displacement is an oop. They use the
 1836 // ins_encode keyword to specify their encoding classes (which must be
 1837 // a sequence of enc_class names, and their parameters, specified in
 1838 // the encoding block), and they use the
 1839 // opcode keyword to specify, in order, their primary, secondary, and
 1840 // tertiary opcode. Only the opcode sections which a particular instruction
 1841 // needs for encoding need to be specified.
 1842 encode %{
 1843   enc_class enc_unimplemented %{
<span class="line-modified"> 1844     MacroAssembler _masm(&amp;cbuf);</span>
 1845     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1846   %}
 1847 
 1848   enc_class enc_untested %{
 1849 #ifdef ASSERT
<span class="line-modified"> 1850     MacroAssembler _masm(&amp;cbuf);</span>
 1851     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1852 #endif
 1853   %}
 1854 
 1855   enc_class z_rrform(iRegI dst, iRegI src) %{
 1856     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1857     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1858     z_emit16(cbuf, $primary |
 1859              Assembler::reg($dst$$reg,8,16) |
 1860              Assembler::reg($src$$reg,12,16));
 1861   %}
 1862 
 1863   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1864     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1865     z_emit32(cbuf, $primary |
 1866              Assembler::reg($dst1$$reg,24,32) |
 1867              Assembler::reg($src2$$reg,28,32));
 1868   %}
 1869 
 1870   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
</pre>
<hr />
<pre>
 2016   %}
 2017 
 2018   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2019     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2020     Register Ridx = $mem$$index$$Register;
 2021     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2022 
 2023     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2024       z_emit_inst(cbuf, $secondary |
 2025                   Assembler::reg($dst$$reg, 8, isize) |
 2026                   Assembler::uimm12($mem$$disp, 20, isize) |
 2027                   Assembler::reg(Ridx, 12, isize) |
 2028                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2029     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2030       z_emit_inst(cbuf, $primary |
 2031                   Assembler::reg($dst$$reg, 8, 48) |
 2032                   Assembler::simm20($mem$$disp) |
 2033                   Assembler::reg(Ridx, 12, 48) |
 2034                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2035     } else {
<span class="line-modified"> 2036         MacroAssembler _masm(&amp;cbuf);</span>
 2037         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2038         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2039         z_emit_inst(cbuf, $secondary |
 2040                     Assembler::reg($dst$$reg, 8, isize) |
 2041                     Assembler::uimm12(0, 20, isize) |
 2042                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2043                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2044     }
 2045   %}
 2046 
 2047   enc_class z_enc_brul(Label lbl) %{
<span class="line-modified"> 2048     MacroAssembler _masm(&amp;cbuf);</span>
 2049     Label* p = $lbl$$label;
 2050 
 2051     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2052     // determine the size of the encoded instruction.
 2053     // Use a bound dummy label in that case.
 2054     Label d;
 2055     __ bind(d);
 2056     Label&amp; l = (NULL == p) ? d : *(p);
 2057     __ z_brul(l);
 2058   %}
 2059 
 2060   enc_class z_enc_bru(Label lbl) %{
<span class="line-modified"> 2061     MacroAssembler _masm(&amp;cbuf);</span>
 2062     Label* p = $lbl$$label;
 2063 
 2064     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2065     // determine the size of the encoded instruction.
 2066     // Use a bound dummy label in that case.
 2067     Label d;
 2068     __ bind(d);
 2069     Label&amp; l = (NULL == p) ? d : *(p);
 2070     __ z_bru(l);
 2071   %}
 2072 
 2073   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2074     MacroAssembler _masm(&amp;cbuf);</span>
 2075     Label* p = $lbl$$label;
 2076 
 2077     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2078     // determine the size of the encoded instruction.
 2079     // Use a bound dummy label in that case.
 2080     Label d;
 2081     __ bind(d);
 2082     Label&amp; l = (NULL == p) ? d : *(p);
 2083     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2084   %}
 2085 
 2086   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2087     MacroAssembler _masm(&amp;cbuf);</span>
 2088     Label* p = $lbl$$label;
 2089 
 2090     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2091     // determine the size of the encoded instruction.
 2092     // Use a bound dummy label in that case.
 2093     Label d;
 2094     __ bind(d);
 2095     Label&amp; l = (NULL == p) ? d : *(p);
 2096     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2097   %}
 2098 
 2099   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2100     MacroAssembler _masm(&amp;cbuf);</span>
 2101     Label* p = $lbl$$label;
 2102 
 2103     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2104     // determine the size of the encoded instruction.
 2105     // Use a bound dummy label in that case.
 2106     Label d;
 2107     __ bind(d);
 2108     Label&amp; l = (NULL == p) ? d : *(p);
 2109     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2110     unsigned long instr = $primary;
 2111     if (instr == CRJ_ZOPC) {
 2112       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2113     } else if (instr == CLRJ_ZOPC) {
 2114       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2115     } else if (instr == CGRJ_ZOPC) {
 2116       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2117     } else {
 2118       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2119       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2120     }
 2121   %}
 2122 
 2123   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2124     MacroAssembler _masm(&amp;cbuf);</span>
 2125     Label* p = $lbl$$label;
 2126 
 2127     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2128     // determine the size of the encoded instruction.
 2129     // Use a bound dummy label in that case.
 2130     Label d;
 2131     __ bind(d);
 2132     Label&amp; l = (NULL == p) ? d : *(p);
 2133 
 2134     unsigned long instr = $primary;
 2135     if (instr == CR_ZOPC) {
 2136       __ z_cr($src1$$Register, $src2$$Register);
 2137     } else if (instr == CLR_ZOPC) {
 2138       __ z_clr($src1$$Register, $src2$$Register);
 2139     } else if (instr == CGR_ZOPC) {
 2140       __ z_cgr($src1$$Register, $src2$$Register);
 2141     } else {
 2142       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2143       __ z_clgr($src1$$Register, $src2$$Register);
 2144     }
 2145 
 2146     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2147   %}
 2148 
 2149   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2150     MacroAssembler _masm(&amp;cbuf);</span>
 2151     Label* p = $lbl$$label;
 2152 
 2153     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2154     // determine the size of the encoded instruction.
 2155     // Use a bound dummy label in that case.
 2156     Label d;
 2157     __ bind(d);
 2158     Label&amp; l = (NULL == p) ? d : *(p);
 2159 
 2160     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2161     unsigned long instr = $primary;
 2162     if (instr == CIJ_ZOPC) {
 2163       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2164     } else if (instr == CLIJ_ZOPC) {
 2165       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2166     } else if (instr == CGIJ_ZOPC) {
 2167       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2168     } else {
 2169       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2170       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2171     }
 2172   %}
 2173 
 2174   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2175     MacroAssembler _masm(&amp;cbuf);</span>
 2176     Label* p = $lbl$$label;
 2177 
 2178     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2179     // determine the size of the encoded instruction.
 2180     // Use a bound dummy label in that case.
 2181     Label d;
 2182     __ bind(d);
 2183     Label&amp; l = (NULL == p) ? d : *(p);
 2184 
 2185     unsigned long instr = $primary;
 2186     if (instr == CHI_ZOPC) {
 2187       __ z_chi($src1$$Register, $src2$$constant);
 2188     } else if (instr == CLFI_ZOPC) {
 2189       __ z_clfi($src1$$Register, $src2$$constant);
 2190     } else if (instr == CGHI_ZOPC) {
 2191       __ z_cghi($src1$$Register, $src2$$constant);
 2192     } else {
 2193       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2194       __ z_clgfi($src1$$Register, $src2$$constant);
 2195     }
 2196 
 2197     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2198   %}
 2199 
 2200   // Call from Java to runtime.
 2201   enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="line-modified"> 2202     MacroAssembler _masm(&amp;cbuf);</span>
 2203 
 2204     // Save return pc before call to the place where we need it, since
 2205     // callee doesn&#39;t.
 2206     unsigned int start_off = __ offset();
 2207     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2208     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2209     __ get_PC(Z_R14, size_of_code);
 2210     __ save_return_pc();
 2211     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2212 
 2213     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2214     address call_addr = __ call_c_opt((address)$meth$$method);
 2215     if (call_addr == NULL) {
 2216       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2217       return;
 2218     }
 2219 
 2220 #ifdef ASSERT
 2221     // Plausibility check for size_of_code assumptions.
 2222     unsigned int actual_ret_off = __ offset();
 2223     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2224 #endif
 2225   %}
 2226 
 2227   enc_class z_enc_java_static_call(method meth) %{
 2228     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2229     // whom we intended to call.
<span class="line-modified"> 2230     MacroAssembler _masm(&amp;cbuf);</span>
 2231     int ret_offset = 0;
 2232 
 2233     if (!_method) {
 2234       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2235                                    relocInfo::runtime_call_w_cp_type, ra_);
 2236     } else {
 2237       int method_index = resolved_method_index(cbuf);
 2238       if (_optimized_virtual) {
 2239         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2240                                      opt_virtual_call_Relocation::spec(method_index));
 2241       } else {
 2242         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2243                                      static_call_Relocation::spec(method_index));
 2244       }
 2245     }
 2246     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2247 
 2248     if (_method) { // Emit stub for static call.
 2249       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2250       if (stub == NULL) {
 2251         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2252         return;
 2253       }
 2254     }
 2255   %}
 2256 
 2257   // Java dynamic call
 2258   enc_class z_enc_java_dynamic_call(method meth) %{
<span class="line-modified"> 2259     MacroAssembler _masm(&amp;cbuf);</span>
 2260     unsigned int start_off = __ offset();
 2261 
 2262     int vtable_index = this-&gt;_vtable_index;
 2263     if (vtable_index == -4) {
 2264       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2265       address virtual_call_oop_addr = NULL;
 2266 
 2267       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2268       virtual_call_oop_addr = __ pc();
 2269       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2270       if (!success) {
 2271         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2272         return;
 2273       }
 2274 
 2275       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2276       // to determine who we intended to call.
 2277       int method_index = resolved_method_index(cbuf);
 2278       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2279       unsigned int ret_off = __ offset();
</pre>
<hr />
<pre>
 2294 
 2295       if (Displacement::is_validDisp(v_off) ) {
 2296         // Can use load instruction with large offset.
 2297         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2298       } else {
 2299         // Worse case, must load offset into register.
 2300         __ load_const(Z_R1_scratch, v_off);
 2301         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2302       }
 2303       // NOTE: for vtable dispatches, the vtable entry will never be
 2304       // null. However it may very well end up in handle_wrong_method
 2305       // if the method is abstract for the particular class.
 2306       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2307       // Call target. Either compiled code or C2I adapter.
 2308       __ z_basr(Z_R14, Z_R1_scratch);
 2309       unsigned int ret_off = __ offset();
 2310     }
 2311   %}
 2312 
 2313   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="line-modified"> 2314     MacroAssembler _masm(&amp;cbuf);</span>
 2315     Register Rdst = reg_to_register_object($dst$$reg);
 2316     Register Rsrc = reg_to_register_object($src$$reg);
 2317 
 2318     // Don&#39;t emit code if operands are identical (same register).
 2319     if (Rsrc != Rdst) {
 2320       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2321 
 2322       if (VM_Version::has_LoadStoreConditional()) {
 2323         __ z_locgr(Rdst, Rsrc, cc);
 2324       } else {
 2325         // Branch if not (cmp cr).
 2326         Label done;
 2327         __ z_brc(Assembler::inverse_condition(cc), done);
 2328         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2329         __ bind(done);
 2330       }
 2331     }
 2332   %}
 2333 
 2334   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="line-modified"> 2335     MacroAssembler _masm(&amp;cbuf);</span>
 2336     Register Rdst = reg_to_register_object($dst$$reg);
 2337     int      Csrc = $src$$constant;
 2338     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2339     Label done;
 2340     // Branch if not (cmp cr).
 2341     __ z_brc(Assembler::inverse_condition(cc), done);
 2342     if (Csrc == 0) {
 2343       // Don&#39;t set CC.
 2344       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2345     } else {
 2346       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2347     }
 2348     __ bind(done);
 2349   %}
 2350 
 2351   enc_class z_enc_cctobool(iRegI res) %{
<span class="line-modified"> 2352     MacroAssembler _masm(&amp;cbuf);</span>
 2353     Register Rres = reg_to_register_object($res$$reg);
 2354 
 2355     if (VM_Version::has_LoadStoreConditional()) {
 2356       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2357       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2358       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2359     } else {
 2360       Label done;
 2361       __ load_const_optimized(Rres, 0L); // false (failed)
 2362       __ z_brne(done);                   // Assume true to be the common case.
 2363       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2364       __ bind(done);
 2365     }
 2366   %}
 2367 
 2368   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2369     MacroAssembler _masm(&amp;cbuf);</span>
 2370     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2371     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2372     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2373 
 2374     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2375   %}
 2376 
 2377   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2378     MacroAssembler _masm(&amp;cbuf);</span>
 2379     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2380     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2381     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2382 
 2383     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2384   %}
 2385 
 2386   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="line-modified"> 2387     MacroAssembler _masm(&amp;cbuf);</span>
 2388     Register Rdst = reg_to_register_object($dst$$reg);
 2389     Register Rtmp = reg_to_register_object($tmp$$reg);
 2390     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2391     Label    retry;
 2392 
 2393     // Iterate until swap succeeds.
 2394     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2395     __ bind(retry);
 2396       // Calculate incremented value.
 2397       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2398       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2399     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2400   %}
 2401 
 2402   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="line-modified"> 2403     MacroAssembler _masm(&amp;cbuf);</span>
 2404     Register Rdst = reg_to_register_object($dst$$reg);
 2405     Register Rtmp = reg_to_register_object($tmp$$reg);
 2406     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2407     Label    retry;
 2408 
 2409     // Iterate until swap succeeds.
 2410     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2411     __ bind(retry);
 2412       // Calculate incremented value.
 2413       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2414       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2415     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2416   %}
 2417 
 2418 %} // encode
 2419 
 2420 source %{
 2421 
 2422   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2423   // 32 bits after encoding.
</pre>
</td>
<td>
<hr />
<pre>
    1 //
<span class="line-modified">    2 // Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
    3 // Copyright (c) 2017, 2019 SAP SE. All rights reserved.
    4 // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
    5 //
    6 // This code is free software; you can redistribute it and/or modify it
    7 // under the terms of the GNU General Public License version 2 only, as
    8 // published by the Free Software Foundation.
    9 //
   10 // This code is distributed in the hope that it will be useful, but WITHOUT
   11 // ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
   12 // FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
   13 // version 2 for more details (a copy is included in the LICENSE file that
   14 // accompanied this code).
   15 //
   16 // You should have received a copy of the GNU General Public License version
   17 // 2 along with this work; if not, write to the Free Software Foundation,
   18 // Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
   19 //
   20 // Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
   21 // or visit www.oracle.com if you need additional information or have any
   22 // questions.
</pre>
<hr />
<pre>
  588 
  589 #define __ _masm.
  590 
  591 #define Z_DISP_SIZE Immediate::is_uimm12((long)opnd_array(1)-&gt;disp(ra_,this,2)) ?  4 : 6
  592 #define Z_DISP3_SIZE 6
  593 
  594 // Tertiary op of a LoadP or StoreP encoding.
  595 #define REGP_OP true
  596 
  597 // Given a register encoding, produce an Integer Register object.
  598 static Register reg_to_register_object(int register_encoding);
  599 
  600 // ****************************************************************************
  601 
  602 // REQUIRED FUNCTIONALITY
  603 
  604 // !!!!! Special hack to get all type of calls to specify the byte offset
  605 //       from the start of the call to the point where the return address
  606 //       will point.
  607 
<span class="line-added">  608 void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="line-added">  609 }</span>
<span class="line-added">  610 </span>
<span class="line-added">  611 int MachNode::pd_alignment_required() const {</span>
<span class="line-added">  612   return 1;</span>
<span class="line-added">  613 }</span>
<span class="line-added">  614 </span>
<span class="line-added">  615 int MachNode::compute_padding(int current_offset) const {</span>
<span class="line-added">  616   return 0;</span>
<span class="line-added">  617 }</span>
<span class="line-added">  618 </span>
  619 int MachCallStaticJavaNode::ret_addr_offset() {
  620   if (_method) {
  621     return 8;
  622   } else {
  623     return MacroAssembler::call_far_patchable_ret_addr_offset();
  624   }
  625 }
  626 
  627 int MachCallDynamicJavaNode::ret_addr_offset() {
  628   // Consider size of receiver type profiling (C2 tiers).
  629   int profile_receiver_type_size = 0;
  630 
  631   int vtable_index = this-&gt;_vtable_index;
  632   if (vtable_index == -4) {
  633     return 14 + profile_receiver_type_size;
  634   } else {
  635     assert(!UseInlineCaches, &quot;expect vtable calls only if not using ICs&quot;);
  636     return 36 + profile_receiver_type_size;
  637   }
  638 }
</pre>
<hr />
<pre>
  658 
  659 int CallRuntimeDirectNode::compute_padding(int current_offset) const {
  660   return (12 - current_offset) &amp; 2;
  661 }
  662 
  663 int CallLeafDirectNode::compute_padding(int current_offset) const {
  664   return (12 - current_offset) &amp; 2;
  665 }
  666 
  667 int CallLeafNoFPDirectNode::compute_padding(int current_offset) const {
  668   return (12 - current_offset) &amp; 2;
  669 }
  670 
  671 // Indicate if the safepoint node needs the polling page as an input.
  672 // Since z/Architecture does not have absolute addressing, it does.
  673 bool SafePointNode::needs_polling_address_input() {
  674   return true;
  675 }
  676 
  677 void emit_nop(CodeBuffer &amp;cbuf) {
<span class="line-modified">  678   C2_MacroAssembler _masm(&amp;cbuf);</span>
  679   __ z_nop();
  680 }
  681 
  682 // Emit an interrupt that is caught by the debugger (for debugging compiler).
  683 void emit_break(CodeBuffer &amp;cbuf) {
<span class="line-modified">  684   C2_MacroAssembler _masm(&amp;cbuf);</span>
  685   __ z_illtrap();
  686 }
  687 
  688 #if !defined(PRODUCT)
  689 void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
  690   os-&gt;print(&quot;TA&quot;);
  691 }
  692 #endif
  693 
  694 void MachBreakpointNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  695   emit_break(cbuf);
  696 }
  697 
  698 uint MachBreakpointNode::size(PhaseRegAlloc *ra_) const {
  699   return MachNode::size(ra_);
  700 }
  701 
  702 static inline void z_emit16(CodeBuffer &amp;cbuf, long value) {
  703   // 32bit instructions may become sign extended.
  704   assert(value &gt;= 0, &quot;unintended sign extension (int-&gt;long)&quot;);
</pre>
<hr />
<pre>
  729     value = (long)((unsigned long)((unsigned int)value));
  730   }
  731 
  732   if (value &lt; (1L &lt;&lt; 16)) { // 2-byte instruction
  733     z_emit16(cbuf, value);
  734     return 2;
  735   }
  736 
  737   if (value &lt; (1L &lt;&lt; 32)) { // 4-byte instruction, might be unaligned store
  738     z_emit32(cbuf, value);
  739     return 4;
  740   }
  741 
  742   // 6-byte instruction, probably unaligned store.
  743   z_emit48(cbuf, value);
  744   return 6;
  745 }
  746 
  747 // Check effective address (at runtime) for required alignment.
  748 static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="line-modified">  749   C2_MacroAssembler _masm(&amp;cbuf);</span>
  750 
  751   __ z_lay(Z_R0, disp, index, base);
  752   __ z_nill(Z_R0, alignment-1);
  753   __ z_brc(Assembler::bcondEqual, +3);
  754   __ z_illtrap();
  755 }
  756 
<span class="line-modified">  757 int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
  758                     PhaseRegAlloc* ra_, bool is_native_call = false) {
  759   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  760   address old_mark = __ inst_mark();
  761   unsigned int start_off = __ offset();
  762 
  763   if (is_native_call) {
  764     ShouldNotReachHere();
  765   }
  766 
  767   if (rtype == relocInfo::runtime_call_w_cp_type) {
  768     assert((__ offset() &amp; 2) == 0, &quot;misaligned emit_call_reloc&quot;);
  769     address call_addr = __ call_c_opt((address)entry_point);
  770     if (call_addr == NULL) {
  771       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
  772       return -1;
  773     }
  774   } else {
  775     assert(rtype == relocInfo::none || rtype == relocInfo::opt_virtual_call_type ||
  776            rtype == relocInfo::static_call_type, &quot;unexpected rtype&quot;);
  777     __ relocate(rtype);
  778     // BRASL must be prepended with a nop to identify it in the instruction stream.
  779     __ z_nop();
  780     __ z_brasl(Z_R14, (address)entry_point);
  781   }
  782 
  783   unsigned int ret_off = __ offset();
  784 
  785   return (ret_off - start_off);
  786 }
  787 
<span class="line-modified">  788 static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
  789   __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
  790   address old_mark = __ inst_mark();
  791   unsigned int start_off = __ offset();
  792 
  793   relocInfo::relocType rtype = rspec.type();
  794   assert(rtype == relocInfo::opt_virtual_call_type || rtype == relocInfo::static_call_type,
  795          &quot;unexpected rtype&quot;);
  796 
  797   __ relocate(rspec);
  798   __ z_nop();
  799   __ z_brasl(Z_R14, (address)entry_point);
  800 
  801   unsigned int ret_off = __ offset();
  802 
  803   return (ret_off - start_off);
  804 }
  805 
  806 //=============================================================================
  807 
  808 const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="line-modified">  809 int ConstantTable::calculate_table_base_offset() const {</span>
  810   return 0;  // absolute addressing, no offset
  811 }
  812 
  813 bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  814 void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
  815   ShouldNotReachHere();
  816 }
  817 
  818 // Even with PC-relative TOC addressing, we still need this node.
  819 // Float loads/stores do not support PC-relative addresses.
  820 void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="line-modified">  821   C2_MacroAssembler _masm(&amp;cbuf);</span>
  822   Register Rtoc = as_Register(ra_-&gt;get_encode(this));
  823   __ load_toc(Rtoc);
  824 }
  825 
  826 uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
  827   // PCrelative TOC access.
  828   return 6;   // sizeof(LARL)
  829 }
  830 
  831 #if !defined(PRODUCT)
  832 void MachConstantBaseNode::format(PhaseRegAlloc* ra_, outputStream* st) const {
  833   Register r = as_Register(ra_-&gt;get_encode(this));
  834   st-&gt;print(&quot;LARL    %s,&amp;constant_pool # MachConstantBaseNode&quot;, r-&gt;name());
  835 }
  836 #endif
  837 
  838 //=============================================================================
  839 
  840 #if !defined(PRODUCT)
  841 void MachPrologNode::format(PhaseRegAlloc *ra_, outputStream *st) const {
  842   Compile* C = ra_-&gt;C;
  843   st-&gt;print_cr(&quot;--- MachPrologNode ---&quot;);
  844   st-&gt;print(&quot;\t&quot;);
  845   for (int i = 0; i &lt; OptoPrologueNops; i++) {
  846     st-&gt;print_cr(&quot;NOP&quot;); st-&gt;print(&quot;\t&quot;);
  847   }
  848 
  849   if (VerifyThread) {
  850     st-&gt;print_cr(&quot;Verify_Thread&quot;);
  851     st-&gt;print(&quot;\t&quot;);
  852   }
  853 
<span class="line-modified">  854   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  855   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  856 
  857   // Calls to C2R adapters often do not accept exceptional returns.
  858   // We require that their callers must bang for them. But be
  859   // careful, because some VM calls (such as call site linkage) can
  860   // use several kilobytes of stack. But the stack safety zone should
  861   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  862   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  863     st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
  864   }
  865   st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
  866   st-&gt;print(&quot;\t&quot;);
  867 }
  868 #endif
  869 
  870 void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
  871   Compile* C = ra_-&gt;C;
<span class="line-modified">  872   C2_MacroAssembler _masm(&amp;cbuf);</span>
  873 
  874   __ verify_thread();
  875 
<span class="line-modified">  876   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="line-modified">  877   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  878 
  879   assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  880 
  881   if (C-&gt;clinit_barrier_on_entry()) {
  882     assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
  883 
  884     Label L_skip_barrier;
  885     Register klass = Z_R1_scratch;
  886 
  887     // Notify OOP recorder (don&#39;t need the relocation)
  888     AddressLiteral md = __ constant_metadata_address(C-&gt;method()-&gt;holder()-&gt;constant_encoding());
  889     __ load_const_optimized(klass, md.value());
  890     __ clinit_barrier(klass, Z_thread, &amp;L_skip_barrier /*L_fast_path*/);
  891 
  892     __ load_const_optimized(klass, SharedRuntime::get_handle_wrong_method_stub());
  893     __ z_br(klass);
  894 
  895     __ bind(L_skip_barrier);
  896   }
  897 
  898   // Calls to C2R adapters often do not accept exceptional returns.
  899   // We require that their callers must bang for them. But be
  900   // careful, because some VM calls (such as call site linkage) can
  901   // use several kilobytes of stack. But the stack safety zone should
  902   // account for that. See bugs 4446381, 4468289, 4497237.
<span class="line-modified">  903   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
  904     __ generate_stack_overflow_check(bangsize);
  905   }
  906 
  907   assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
  908   __ save_return_pc();
  909 
  910   // The z/Architecture abi is already accounted for in `framesize&#39; via the
  911   // &#39;out_preserve_stack_slots&#39; declaration.
  912   __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  913 
  914   if (C-&gt;has_mach_constant_base_node()) {
  915     // NOTE: We set the table base offset here because users might be
  916     // emitted before MachConstantBaseNode.
<span class="line-modified">  917     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
  918     constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
  919   }
  920 }
  921 
  922 uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
  923   // Variable size. Determine dynamically.
  924   return MachNode::size(ra_);
  925 }
  926 
  927 int MachPrologNode::reloc() const {
  928   // Return number of relocatable values contained in this instruction.
  929   return 1; // One reloc entry for load_const(toc).
  930 }
  931 
  932 //=============================================================================
  933 
  934 #if !defined(PRODUCT)
  935 void MachEpilogNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
  936   os-&gt;print_cr(&quot;epilog&quot;);
  937   os-&gt;print(&quot;\t&quot;);
  938   if (do_polling() &amp;&amp; ra_-&gt;C-&gt;is_method_compilation()) {
  939     os-&gt;print_cr(&quot;load_from_polling_page Z_R1_scratch&quot;);
  940     os-&gt;print(&quot;\t&quot;);
  941   }
  942 }
  943 #endif
  944 
  945 void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified">  946   C2_MacroAssembler _masm(&amp;cbuf);</span>
  947   Compile* C = ra_-&gt;C;
  948   __ verify_thread();
  949 
  950   // If this does safepoint polling, then do it here.
  951   bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  952 
  953   // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="line-modified">  954   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
  955   __ pop_frame_restore_retPC(frame_size_in_bytes);
  956 
  957   if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
  958     __ reserved_stack_check(Z_R14);
  959   }
  960 
  961   // Touch the polling page.
  962   if (need_polling) {
<span class="line-modified">  963     __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));</span>





  964     // We need to mark the code position where the load from the safepoint
  965     // polling page was emitted as relocInfo::poll_return_type here.
  966     __ relocate(relocInfo::poll_return_type);
  967     __ load_from_polling_page(Z_R1_scratch);
  968   }
  969 }
  970 
  971 uint MachEpilogNode::size(PhaseRegAlloc *ra_) const {
  972   // Variable size. determine dynamically.
  973   return MachNode::size(ra_);
  974 }
  975 
  976 int MachEpilogNode::reloc() const {
  977   // Return number of relocatable values contained in this instruction.
  978   return 1; // One for load_from_polling_page.
  979 }
  980 
  981 const Pipeline * MachEpilogNode::pipeline() const {
  982   return MachNode::pipeline_class();
  983 }
  984 





  985 //=============================================================================
  986 
  987 // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  988 enum RC { rc_bad, rc_int, rc_float, rc_stack };
  989 
  990 static enum RC rc_class(OptoReg::Name reg) {
  991   // Return the register class for the given register. The given register
  992   // reg is a &lt;register&gt;_num value, which is an index into the MachRegisterNumbers
  993   // enumeration in adGlobals_s390.hpp.
  994 
  995   if (reg == OptoReg::Bad) {
  996     return rc_bad;
  997   }
  998 
  999   // We have 32 integer register halves, starting at index 0.
 1000   if (reg &lt; 32) {
 1001     return rc_int;
 1002   }
 1003 
 1004   // We have 32 floating-point register halves, starting at index 32.
</pre>
<hr />
<pre>
 1018   if (cbuf) {
 1019     if (opcode &gt; (1L&lt;&lt;32)) {
 1020       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 48) |
 1021                          Assembler::simm20(offset) | Assembler::reg(Z_R0, 12, 48) | Assembler::regz(Z_SP, 16, 48));
 1022     } else {
 1023       return z_emit_inst(*cbuf, opcode | Assembler::reg(Matcher::_regEncode[reg], 8, 32) |
 1024                          Assembler::uimm12(offset, 20, 32) | Assembler::reg(Z_R0, 12, 32) | Assembler::regz(Z_SP, 16, 32));
 1025     }
 1026   }
 1027 
 1028 #if !defined(PRODUCT)
 1029   if (do_print) {
 1030     os-&gt;print(&quot;%s    %s,#%d[,SP]\t # MachCopy spill code&quot;,op_str, Matcher::regName[reg], offset);
 1031   }
 1032 #endif
 1033   return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
 1034 }
 1035 
 1036 static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
 1037   if (cbuf) {
<span class="line-modified"> 1038     C2_MacroAssembler _masm(cbuf);</span>
 1039     __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
 1040   }
 1041 
 1042 #if !defined(PRODUCT)
 1043   else if (do_print) {
 1044     os-&gt;print(&quot;MVC     %d(%d,SP),%d(SP)\t # MachCopy spill code&quot;,dst_off, len, src_off);
 1045   }
 1046 #endif
 1047 
 1048   return 6;
 1049 }
 1050 
 1051 uint MachSpillCopyNode::implementation(CodeBuffer *cbuf, PhaseRegAlloc *ra_, bool do_size, outputStream *os) const {
 1052   // Get registers to move.
 1053   OptoReg::Name src_hi = ra_-&gt;get_reg_second(in(1));
 1054   OptoReg::Name src_lo = ra_-&gt;get_reg_first(in(1));
 1055   OptoReg::Name dst_hi = ra_-&gt;get_reg_second(this);
 1056   OptoReg::Name dst_lo = ra_-&gt;get_reg_first(this);
 1057 
 1058   enum RC src_hi_rc = rc_class(src_hi);
</pre>
<hr />
<pre>
 1092     }
 1093 
 1094     int r0 = Z_R0_num;
 1095     if (is64) {
 1096       return z_ld_st_helper(cbuf, &quot;LG  &quot;, LG_ZOPC, r0, src_offset, print, os) +
 1097              z_ld_st_helper(cbuf, &quot;STG &quot;, STG_ZOPC, r0, dst_offset, print, os);
 1098     }
 1099 
 1100     return z_ld_st_helper(cbuf, &quot;LY   &quot;, LY_ZOPC, r0, src_offset, print, os) +
 1101            z_ld_st_helper(cbuf, &quot;STY  &quot;, STY_ZOPC, r0, dst_offset, print, os);
 1102   }
 1103 
 1104   // Check for float-&gt;int copy. Requires a trip through memory.
 1105   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_int) {
 1106     Unimplemented();  // Unsafe, do not remove!
 1107   }
 1108 
 1109   // Check for integer reg-reg copy.
 1110   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
 1111     if (cbuf) {
<span class="line-modified"> 1112       C2_MacroAssembler _masm(cbuf);</span>
 1113       Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
 1114       Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
 1115       __ z_lgr(Rdst, Rsrc);
 1116       return 4;
 1117     }
 1118 #if !defined(PRODUCT)
 1119     // else
 1120     if (print) {
 1121       os-&gt;print(&quot;LGR     %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1122     }
 1123 #endif
 1124     return 4;
 1125   }
 1126 
 1127   // Check for integer store.
 1128   if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_stack) {
 1129     assert(!is64 || (src_hi_rc==rc_int &amp;&amp; dst_hi_rc==rc_stack),
 1130            &quot;expected same type of move for high parts&quot;);
 1131 
 1132     if (is64) {
</pre>
<hr />
<pre>
 1139 
 1140     return z_ld_st_helper(cbuf, mnemo, opc, src_lo, dst_offset, print, os);
 1141   }
 1142 
 1143   // Check for integer load
 1144   // Always load cOops zero-extended. That doesn&#39;t hurt int loads.
 1145   if (dst_lo_rc == rc_int &amp;&amp; src_lo_rc == rc_stack) {
 1146 
 1147     assert(!is64 || (dst_hi_rc==rc_int &amp;&amp; src_hi_rc==rc_stack),
 1148            &quot;expected same type of move for high parts&quot;);
 1149 
 1150     mnemo = is64 ? &quot;LG  &quot; : &quot;LLGF&quot;;
 1151     opc = is64 ? LG_ZOPC : LLGF_ZOPC;
 1152 
 1153     return z_ld_st_helper(cbuf, mnemo, opc, dst_lo, src_offset, print, os);
 1154   }
 1155 
 1156   // Check for float reg-reg copy.
 1157   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
 1158     if (cbuf) {
<span class="line-modified"> 1159       C2_MacroAssembler _masm(cbuf);</span>
 1160       FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
 1161       FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
 1162       __ z_ldr(Rdst, Rsrc);
 1163       return 2;
 1164     }
 1165 #if !defined(PRODUCT)
 1166     // else
 1167     if (print) {
 1168       os-&gt;print(&quot;LDR      %s,%s\t # MachCopy spill code&quot;, Matcher::regName[dst_lo], Matcher::regName[src_lo]);
 1169     }
 1170 #endif
 1171     return 2;
 1172   }
 1173 
 1174   // Check for float store.
 1175   if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_stack) {
 1176     assert(!is64 || (src_hi_rc==rc_float &amp;&amp; dst_hi_rc==rc_stack),
 1177            &quot;expected same type of move for high parts&quot;);
 1178 
 1179     if (is64) {
</pre>
<hr />
<pre>
 1238 }
 1239 #endif
 1240 
 1241 void MachSpillCopyNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
 1242   implementation(&amp;cbuf, ra_, false, NULL);
 1243 }
 1244 
 1245 uint MachSpillCopyNode::size(PhaseRegAlloc *ra_) const {
 1246   return implementation(NULL, ra_, true, NULL);
 1247 }
 1248 
 1249 //=============================================================================
 1250 
 1251 #if !defined(PRODUCT)
 1252 void MachNopNode::format(PhaseRegAlloc *, outputStream *os) const {
 1253   os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
 1254 }
 1255 #endif
 1256 
 1257 void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="line-modified"> 1258   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1259 
 1260   int rem_space = 0;
<span class="line-modified"> 1261   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
 1262     rem_space = cbuf.insts()-&gt;remaining();
 1263     if (rem_space &lt;= _count*2 + 8) {
 1264       tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
 1265     }
 1266   }
 1267 
 1268   for (int i = 0; i &lt; _count; i++) {
 1269     __ z_nop();
 1270   }
 1271 
<span class="line-modified"> 1272   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
 1273     if (rem_space &lt;= _count*2 + 8) {
 1274       int rem_space2 = cbuf.insts()-&gt;remaining();
 1275       tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
 1276     }
 1277   }
 1278 }
 1279 
 1280 uint MachNopNode::size(PhaseRegAlloc *ra_) const {
 1281    return 2 * _count;
 1282 }
 1283 
 1284 #if !defined(PRODUCT)
 1285 void BoxLockNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1286   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1287   if (ra_ &amp;&amp; ra_-&gt;node_regs_max_index() &gt; 0) {
 1288     int reg = ra_-&gt;get_reg_first(this);
 1289     os-&gt;print(&quot;ADDHI  %s, SP, %d\t//box node&quot;, Matcher::regName[reg], offset);
 1290   } else {
 1291     os-&gt;print(&quot;ADDHI  N%d = SP + %d\t// box node&quot;, _idx, offset);
 1292   }
 1293 }
 1294 #endif
 1295 
 1296 // Take care of the size function, if you make changes here!
 1297 void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1298   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1299 
 1300   int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
 1301   int reg = ra_-&gt;get_encode(this);
 1302   __ z_lay(as_Register(reg), offset, Z_SP);
 1303 }
 1304 
 1305 uint BoxLockNode::size(PhaseRegAlloc *ra_) const {
 1306   // BoxLockNode is not a MachNode, so we can&#39;t just call MachNode::size(ra_)
 1307   return 6;
 1308 }
 1309 
 1310  %} // end source section
 1311 
 1312 //----------SOURCE BLOCK-------------------------------------------------------
 1313 // This is a block of C++ code which provides values, functions, and
 1314 // definitions necessary in the rest of the architecture description
 1315 
 1316 source_hpp %{
 1317 
 1318 // Header information of the source block.
</pre>
<hr />
<pre>
 1344 
 1345 %} // end source_hpp section
 1346 
 1347 source %{
 1348 
 1349 #if !defined(PRODUCT)
 1350 void MachUEPNode::format(PhaseRegAlloc *ra_, outputStream *os) const {
 1351   os-&gt;print_cr(&quot;---- MachUEPNode ----&quot;);
 1352   os-&gt;print_cr(&quot;\tTA&quot;);
 1353   os-&gt;print_cr(&quot;\tload_const Z_R1, SharedRuntime::get_ic_miss_stub()&quot;);
 1354   os-&gt;print_cr(&quot;\tBR(Z_R1)&quot;);
 1355   os-&gt;print_cr(&quot;\tTA  # pad with illtraps&quot;);
 1356   os-&gt;print_cr(&quot;\t...&quot;);
 1357   os-&gt;print_cr(&quot;\tTA&quot;);
 1358   os-&gt;print_cr(&quot;\tLTGR    Z_R2, Z_R2&quot;);
 1359   os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
 1360 }
 1361 #endif
 1362 
 1363 void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="line-modified"> 1364   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1365   const int ic_miss_offset = 2;
 1366 
 1367   // Inline_cache contains a klass.
 1368   Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
 1369   // ARG1 is the receiver oop.
 1370   Register R2_receiver = Z_ARG1;
 1371   int      klass_offset = oopDesc::klass_offset_in_bytes();
 1372   AddressLiteral icmiss(SharedRuntime::get_ic_miss_stub());
 1373   Register R1_ic_miss_stub_addr = Z_R1_scratch;
 1374 
 1375   // Null check of receiver.
 1376   // This is the null check of the receiver that actually should be
 1377   // done in the caller. It&#39;s here because in case of implicit null
 1378   // checks we get it for free.
 1379   assert(!MacroAssembler::needs_explicit_null_check(oopDesc::klass_offset_in_bytes()),
 1380          &quot;second word in oop should not require explicit null check.&quot;);
 1381   if (!ImplicitNullChecks) {
 1382     Label valid;
 1383     if (VM_Version::has_CompareBranch()) {
 1384       __ z_cgij(R2_receiver, 0, Assembler::bcondNotEqual, valid);
</pre>
<hr />
<pre>
 1417 
 1418 %} // interrupt source section
 1419 
 1420 source_hpp %{ // Header information of the source block.
 1421 
 1422 class HandlerImpl {
 1423  public:
 1424 
 1425   static int emit_exception_handler(CodeBuffer &amp;cbuf);
 1426   static int emit_deopt_handler(CodeBuffer&amp; cbuf);
 1427 
 1428   static uint size_exception_handler() {
 1429     return NativeJump::max_instruction_size();
 1430   }
 1431 
 1432   static uint size_deopt_handler() {
 1433     return NativeCall::max_instruction_size();
 1434   }
 1435 };
 1436 
<span class="line-added"> 1437 class Node::PD {</span>
<span class="line-added"> 1438 public:</span>
<span class="line-added"> 1439   enum NodeFlags {</span>
<span class="line-added"> 1440     _last_flag = Node::_last_flag</span>
<span class="line-added"> 1441   };</span>
<span class="line-added"> 1442 };</span>
<span class="line-added"> 1443 </span>
 1444 %} // end source_hpp section
 1445 
 1446 source %{
 1447 
 1448 // This exception handler code snippet is placed after the method&#39;s
 1449 // code. It is the return point if an exception occurred. it jumps to
 1450 // the exception blob.
 1451 //
 1452 // If the method gets deoptimized, the method and this code snippet
 1453 // get patched.
 1454 //
 1455 // 1) Trampoline code gets patched into the end of this exception
 1456 //   handler. the trampoline code jumps to the deoptimization blob.
 1457 //
 1458 // 2) The return address in the method&#39;s code will get patched such
 1459 //   that it jumps to the trampoline.
 1460 //
 1461 // 3) The handler will get patched such that it does not jump to the
 1462 //   exception blob, but to an entry in the deoptimization blob being
 1463 //   aware of the exception.
 1464 int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
 1465   Register temp_reg = Z_R1;
<span class="line-modified"> 1466   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1467 
 1468   address base = __ start_a_stub(size_exception_handler());
 1469   if (base == NULL) {
 1470     return 0;          // CodeBuffer::expand failed
 1471   }
 1472 
 1473   int offset = __ offset();
 1474   // Use unconditional pc-relative jump with 32-bit range here.
 1475   __ load_const_optimized(temp_reg, (address)OptoRuntime::exception_blob()-&gt;content_begin());
 1476   __ z_br(temp_reg);
 1477 
 1478   assert(__ offset() - offset &lt;= (int) size_exception_handler(), &quot;overflow&quot;);
 1479 
 1480   __ end_a_stub();
 1481 
 1482   return offset;
 1483 }
 1484 
 1485 // Emit deopt handler code.
 1486 int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="line-modified"> 1487   C2_MacroAssembler _masm(&amp;cbuf);</span>
 1488   address        base = __ start_a_stub(size_deopt_handler());
 1489 
 1490   if (base == NULL) {
 1491     return 0;  // CodeBuffer::expand failed
 1492   }
 1493 
 1494   int offset = __ offset();
 1495 
 1496   // Size_deopt_handler() must be exact on zarch, so for simplicity
 1497   // we do not use load_const_opt here.
 1498   __ load_const(Z_R1, SharedRuntime::deopt_blob()-&gt;unpack());
 1499   __ call(Z_R1);
 1500   assert(__ offset() - offset == (int) size_deopt_handler(), &quot;must be fixed size&quot;);
 1501 
 1502   __ end_a_stub();
 1503   return offset;
 1504 }
 1505 
 1506 //=============================================================================
 1507 
</pre>
<hr />
<pre>
 1794   return _Z_RARG3_INT_REG_mask;
 1795 }
 1796 
 1797 // Register for DIVL projection of divmodL
 1798 RegMask Matcher::divL_proj_mask() {
 1799   return _Z_RARG4_LONG_REG_mask;
 1800 }
 1801 
 1802 // Register for MODL projection of divmodL
 1803 RegMask Matcher::modL_proj_mask() {
 1804   return _Z_RARG3_LONG_REG_mask;
 1805 }
 1806 
 1807 // Copied from sparc.
 1808 const RegMask Matcher::method_handle_invoke_SP_save_mask() {
 1809   return RegMask();
 1810 }
 1811 
 1812 const bool Matcher::convi2l_type_required = true;
 1813 
<span class="line-added"> 1814 // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="line-added"> 1815 bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="line-added"> 1816   return false;</span>
<span class="line-added"> 1817 }</span>
<span class="line-added"> 1818 </span>
 1819 // Should the Matcher clone shifts on addressing modes, expecting them
 1820 // to be subsumed into complex addressing expressions or compute them
 1821 // into registers?
<span class="line-modified"> 1822 bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
 1823   return clone_base_plus_offset_address(m, mstack, address_visited);
 1824 }
 1825 
 1826 void Compile::reshape_address(AddPNode* addp) {
 1827 }
 1828 
 1829 %} // source
 1830 
 1831 //----------ENCODING BLOCK-----------------------------------------------------
 1832 // This block specifies the encoding classes used by the compiler to output
 1833 // byte streams. Encoding classes are parameterized macros used by
 1834 // Machine Instruction Nodes in order to generate the bit encoding of the
 1835 // instruction. Operands specify their base encoding interface with the
 1836 // interface keyword. There are currently supported four interfaces,
 1837 // REG_INTER, CONST_INTER, MEMORY_INTER, &amp; COND_INTER. REG_INTER causes an
 1838 // operand to generate a function which returns its register number when
 1839 // queried. CONST_INTER causes an operand to generate a function which
 1840 // returns the value of the constant when queried. MEMORY_INTER causes an
 1841 // operand to generate four functions which return the Base Register, the
 1842 // Index Register, the Scale Value, and the Offset Value of the operand when
 1843 // queried. COND_INTER causes an operand to generate six functions which
 1844 // return the encoding code (ie - encoding bits for the instruction)
 1845 // associated with each basic boolean condition for a conditional instruction.
 1846 //
 1847 // Instructions specify two basic values for encoding. Again, a function
 1848 // is available to check if the constant displacement is an oop. They use the
 1849 // ins_encode keyword to specify their encoding classes (which must be
 1850 // a sequence of enc_class names, and their parameters, specified in
 1851 // the encoding block), and they use the
 1852 // opcode keyword to specify, in order, their primary, secondary, and
 1853 // tertiary opcode. Only the opcode sections which a particular instruction
 1854 // needs for encoding need to be specified.
 1855 encode %{
 1856   enc_class enc_unimplemented %{
<span class="line-modified"> 1857     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1858     __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
 1859   %}
 1860 
 1861   enc_class enc_untested %{
 1862 #ifdef ASSERT
<span class="line-modified"> 1863     C2_MacroAssembler _masm(&amp;cbuf);</span>
 1864     __ untested(&quot;Untested mach node encoding in AD file.&quot;);
 1865 #endif
 1866   %}
 1867 
 1868   enc_class z_rrform(iRegI dst, iRegI src) %{
 1869     assert((($primary &gt;&gt; 14) &amp; 0x03) == 0, &quot;Instruction format error&quot;);
 1870     assert( ($primary &gt;&gt; 16)         == 0, &quot;Instruction format error&quot;);
 1871     z_emit16(cbuf, $primary |
 1872              Assembler::reg($dst$$reg,8,16) |
 1873              Assembler::reg($src$$reg,12,16));
 1874   %}
 1875 
 1876   enc_class z_rreform(iRegI dst1, iRegI src2) %{
 1877     assert((($primary &gt;&gt; 30) &amp; 0x03) == 2, &quot;Instruction format error&quot;);
 1878     z_emit32(cbuf, $primary |
 1879              Assembler::reg($dst1$$reg,24,32) |
 1880              Assembler::reg($src2$$reg,28,32));
 1881   %}
 1882 
 1883   enc_class z_rrfform(iRegI dst1, iRegI src2, iRegI src3) %{
</pre>
<hr />
<pre>
 2029   %}
 2030 
 2031   enc_class z_form_rt_mem_opt(iRegI dst, memory mem) %{
 2032     int isize = $secondary &gt; 1L &lt;&lt; 32 ? 48 : 32;
 2033     Register Ridx = $mem$$index$$Register;
 2034     if (Ridx == noreg) { Ridx = Z_R0; } // Index is 0.
 2035 
 2036     if (Displacement::is_shortDisp((long)$mem$$disp)) {
 2037       z_emit_inst(cbuf, $secondary |
 2038                   Assembler::reg($dst$$reg, 8, isize) |
 2039                   Assembler::uimm12($mem$$disp, 20, isize) |
 2040                   Assembler::reg(Ridx, 12, isize) |
 2041                   Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2042     } else if (Displacement::is_validDisp((long)$mem$$disp)) {
 2043       z_emit_inst(cbuf, $primary |
 2044                   Assembler::reg($dst$$reg, 8, 48) |
 2045                   Assembler::simm20($mem$$disp) |
 2046                   Assembler::reg(Ridx, 12, 48) |
 2047                   Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
 2048     } else {
<span class="line-modified"> 2049         C2_MacroAssembler _masm(&amp;cbuf);</span>
 2050         __ load_const_optimized(Z_R1_scratch, $mem$$disp);
 2051         if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
 2052         z_emit_inst(cbuf, $secondary |
 2053                     Assembler::reg($dst$$reg, 8, isize) |
 2054                     Assembler::uimm12(0, 20, isize) |
 2055                     Assembler::reg(Z_R1_scratch, 12, isize) |
 2056                     Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
 2057     }
 2058   %}
 2059 
 2060   enc_class z_enc_brul(Label lbl) %{
<span class="line-modified"> 2061     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2062     Label* p = $lbl$$label;
 2063 
 2064     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2065     // determine the size of the encoded instruction.
 2066     // Use a bound dummy label in that case.
 2067     Label d;
 2068     __ bind(d);
 2069     Label&amp; l = (NULL == p) ? d : *(p);
 2070     __ z_brul(l);
 2071   %}
 2072 
 2073   enc_class z_enc_bru(Label lbl) %{
<span class="line-modified"> 2074     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2075     Label* p = $lbl$$label;
 2076 
 2077     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2078     // determine the size of the encoded instruction.
 2079     // Use a bound dummy label in that case.
 2080     Label d;
 2081     __ bind(d);
 2082     Label&amp; l = (NULL == p) ? d : *(p);
 2083     __ z_bru(l);
 2084   %}
 2085 
 2086   enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2087     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2088     Label* p = $lbl$$label;
 2089 
 2090     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2091     // determine the size of the encoded instruction.
 2092     // Use a bound dummy label in that case.
 2093     Label d;
 2094     __ bind(d);
 2095     Label&amp; l = (NULL == p) ? d : *(p);
 2096     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2097   %}
 2098 
 2099   enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="line-modified"> 2100     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2101     Label* p = $lbl$$label;
 2102 
 2103     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2104     // determine the size of the encoded instruction.
 2105     // Use a bound dummy label in that case.
 2106     Label d;
 2107     __ bind(d);
 2108     Label&amp; l = (NULL == p) ? d : *(p);
 2109     __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
 2110   %}
 2111 
 2112   enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2113     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2114     Label* p = $lbl$$label;
 2115 
 2116     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2117     // determine the size of the encoded instruction.
 2118     // Use a bound dummy label in that case.
 2119     Label d;
 2120     __ bind(d);
 2121     Label&amp; l = (NULL == p) ? d : *(p);
 2122     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2123     unsigned long instr = $primary;
 2124     if (instr == CRJ_ZOPC) {
 2125       __ z_crj($src1$$Register, $src2$$Register, cc, l);
 2126     } else if (instr == CLRJ_ZOPC) {
 2127       __ z_clrj($src1$$Register, $src2$$Register, cc, l);
 2128     } else if (instr == CGRJ_ZOPC) {
 2129       __ z_cgrj($src1$$Register, $src2$$Register, cc, l);
 2130     } else {
 2131       guarantee(instr == CLGRJ_ZOPC, &quot;opcode not implemented&quot;);
 2132       __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
 2133     }
 2134   %}
 2135 
 2136   enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2137     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2138     Label* p = $lbl$$label;
 2139 
 2140     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2141     // determine the size of the encoded instruction.
 2142     // Use a bound dummy label in that case.
 2143     Label d;
 2144     __ bind(d);
 2145     Label&amp; l = (NULL == p) ? d : *(p);
 2146 
 2147     unsigned long instr = $primary;
 2148     if (instr == CR_ZOPC) {
 2149       __ z_cr($src1$$Register, $src2$$Register);
 2150     } else if (instr == CLR_ZOPC) {
 2151       __ z_clr($src1$$Register, $src2$$Register);
 2152     } else if (instr == CGR_ZOPC) {
 2153       __ z_cgr($src1$$Register, $src2$$Register);
 2154     } else {
 2155       guarantee(instr == CLGR_ZOPC, &quot;opcode not implemented&quot;);
 2156       __ z_clgr($src1$$Register, $src2$$Register);
 2157     }
 2158 
 2159     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2160   %}
 2161 
 2162   enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2163     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2164     Label* p = $lbl$$label;
 2165 
 2166     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2167     // determine the size of the encoded instruction.
 2168     // Use a bound dummy label in that case.
 2169     Label d;
 2170     __ bind(d);
 2171     Label&amp; l = (NULL == p) ? d : *(p);
 2172 
 2173     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2174     unsigned long instr = $primary;
 2175     if (instr == CIJ_ZOPC) {
 2176       __ z_cij($src1$$Register, $src2$$constant, cc, l);
 2177     } else if (instr == CLIJ_ZOPC) {
 2178       __ z_clij($src1$$Register, $src2$$constant, cc, l);
 2179     } else if (instr == CGIJ_ZOPC) {
 2180       __ z_cgij($src1$$Register, $src2$$constant, cc, l);
 2181     } else {
 2182       guarantee(instr == CLGIJ_ZOPC, &quot;opcode not implemented&quot;);
 2183       __ z_clgij($src1$$Register, $src2$$constant, cc, l);
 2184     }
 2185   %}
 2186 
 2187   enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="line-modified"> 2188     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2189     Label* p = $lbl$$label;
 2190 
 2191     // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
 2192     // determine the size of the encoded instruction.
 2193     // Use a bound dummy label in that case.
 2194     Label d;
 2195     __ bind(d);
 2196     Label&amp; l = (NULL == p) ? d : *(p);
 2197 
 2198     unsigned long instr = $primary;
 2199     if (instr == CHI_ZOPC) {
 2200       __ z_chi($src1$$Register, $src2$$constant);
 2201     } else if (instr == CLFI_ZOPC) {
 2202       __ z_clfi($src1$$Register, $src2$$constant);
 2203     } else if (instr == CGHI_ZOPC) {
 2204       __ z_cghi($src1$$Register, $src2$$constant);
 2205     } else {
 2206       guarantee(instr == CLGFI_ZOPC, &quot;opcode not implemented&quot;);
 2207       __ z_clgfi($src1$$Register, $src2$$constant);
 2208     }
 2209 
 2210     __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
 2211   %}
 2212 
 2213   // Call from Java to runtime.
 2214   enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="line-modified"> 2215     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2216 
 2217     // Save return pc before call to the place where we need it, since
 2218     // callee doesn&#39;t.
 2219     unsigned int start_off = __ offset();
 2220     // Compute size of &quot;larl + stg + call_c_opt&quot;.
 2221     const int size_of_code = 6 + 6 + MacroAssembler::call_far_patchable_size();
 2222     __ get_PC(Z_R14, size_of_code);
 2223     __ save_return_pc();
 2224     assert(__ offset() - start_off == 12, &quot;bad prelude len: %d&quot;, __ offset() - start_off);
 2225 
 2226     assert((__ offset() &amp; 2) == 0, &quot;misaligned z_enc_java_to_runtime_call&quot;);
 2227     address call_addr = __ call_c_opt((address)$meth$$method);
 2228     if (call_addr == NULL) {
 2229       Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2230       return;
 2231     }
 2232 
 2233 #ifdef ASSERT
 2234     // Plausibility check for size_of_code assumptions.
 2235     unsigned int actual_ret_off = __ offset();
 2236     assert(start_off + size_of_code == actual_ret_off, &quot;wrong return_pc&quot;);
 2237 #endif
 2238   %}
 2239 
 2240   enc_class z_enc_java_static_call(method meth) %{
 2241     // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
 2242     // whom we intended to call.
<span class="line-modified"> 2243     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2244     int ret_offset = 0;
 2245 
 2246     if (!_method) {
 2247       ret_offset = emit_call_reloc(_masm, $meth$$method,
 2248                                    relocInfo::runtime_call_w_cp_type, ra_);
 2249     } else {
 2250       int method_index = resolved_method_index(cbuf);
 2251       if (_optimized_virtual) {
 2252         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2253                                      opt_virtual_call_Relocation::spec(method_index));
 2254       } else {
 2255         ret_offset = emit_call_reloc(_masm, $meth$$method,
 2256                                      static_call_Relocation::spec(method_index));
 2257       }
 2258     }
 2259     assert(__ inst_mark() != NULL, &quot;emit_call_reloc must set_inst_mark()&quot;);
 2260 
 2261     if (_method) { // Emit stub for static call.
 2262       address stub = CompiledStaticCall::emit_to_interp_stub(cbuf);
 2263       if (stub == NULL) {
 2264         ciEnv::current()-&gt;record_failure(&quot;CodeCache is full&quot;);
 2265         return;
 2266       }
 2267     }
 2268   %}
 2269 
 2270   // Java dynamic call
 2271   enc_class z_enc_java_dynamic_call(method meth) %{
<span class="line-modified"> 2272     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2273     unsigned int start_off = __ offset();
 2274 
 2275     int vtable_index = this-&gt;_vtable_index;
 2276     if (vtable_index == -4) {
 2277       Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
 2278       address virtual_call_oop_addr = NULL;
 2279 
 2280       AddressLiteral empty_ic((address) Universe::non_oop_word());
 2281       virtual_call_oop_addr = __ pc();
 2282       bool success = __ load_const_from_toc(ic_reg, empty_ic);
 2283       if (!success) {
 2284         Compile::current()-&gt;env()-&gt;record_out_of_memory_failure();
 2285         return;
 2286       }
 2287 
 2288       // Call to fixup routine. Fixup routine uses ScopeDesc info
 2289       // to determine who we intended to call.
 2290       int method_index = resolved_method_index(cbuf);
 2291       __ relocate(virtual_call_Relocation::spec(virtual_call_oop_addr, method_index));
 2292       unsigned int ret_off = __ offset();
</pre>
<hr />
<pre>
 2307 
 2308       if (Displacement::is_validDisp(v_off) ) {
 2309         // Can use load instruction with large offset.
 2310         __ z_lg(Z_method, Address(Z_method /*class oop*/, v_off /*method offset*/));
 2311       } else {
 2312         // Worse case, must load offset into register.
 2313         __ load_const(Z_R1_scratch, v_off);
 2314         __ z_lg(Z_method, Address(Z_method /*class oop*/, Z_R1_scratch /*method offset*/));
 2315       }
 2316       // NOTE: for vtable dispatches, the vtable entry will never be
 2317       // null. However it may very well end up in handle_wrong_method
 2318       // if the method is abstract for the particular class.
 2319       __ z_lg(Z_R1_scratch, Address(Z_method, Method::from_compiled_offset()));
 2320       // Call target. Either compiled code or C2I adapter.
 2321       __ z_basr(Z_R14, Z_R1_scratch);
 2322       unsigned int ret_off = __ offset();
 2323     }
 2324   %}
 2325 
 2326   enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="line-modified"> 2327     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2328     Register Rdst = reg_to_register_object($dst$$reg);
 2329     Register Rsrc = reg_to_register_object($src$$reg);
 2330 
 2331     // Don&#39;t emit code if operands are identical (same register).
 2332     if (Rsrc != Rdst) {
 2333       Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2334 
 2335       if (VM_Version::has_LoadStoreConditional()) {
 2336         __ z_locgr(Rdst, Rsrc, cc);
 2337       } else {
 2338         // Branch if not (cmp cr).
 2339         Label done;
 2340         __ z_brc(Assembler::inverse_condition(cc), done);
 2341         __ z_lgr(Rdst, Rsrc); // Used for int and long+ptr.
 2342         __ bind(done);
 2343       }
 2344     }
 2345   %}
 2346 
 2347   enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="line-modified"> 2348     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2349     Register Rdst = reg_to_register_object($dst$$reg);
 2350     int      Csrc = $src$$constant;
 2351     Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
 2352     Label done;
 2353     // Branch if not (cmp cr).
 2354     __ z_brc(Assembler::inverse_condition(cc), done);
 2355     if (Csrc == 0) {
 2356       // Don&#39;t set CC.
 2357       __ clear_reg(Rdst, true, false);  // Use for int, long &amp; ptr.
 2358     } else {
 2359       __ z_lghi(Rdst, Csrc); // Use for int, long &amp; ptr.
 2360     }
 2361     __ bind(done);
 2362   %}
 2363 
 2364   enc_class z_enc_cctobool(iRegI res) %{
<span class="line-modified"> 2365     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2366     Register Rres = reg_to_register_object($res$$reg);
 2367 
 2368     if (VM_Version::has_LoadStoreConditional()) {
 2369       __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
 2370       __ load_const_optimized(Rres, 1L);         // true  (succeed)
 2371       __ z_locgr(Rres, Z_R0_scratch, Assembler::bcondNotEqual);
 2372     } else {
 2373       Label done;
 2374       __ load_const_optimized(Rres, 0L); // false (failed)
 2375       __ z_brne(done);                   // Assume true to be the common case.
 2376       __ load_const_optimized(Rres, 1L); // true  (succeed)
 2377       __ bind(done);
 2378     }
 2379   %}
 2380 
 2381   enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2382     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2383     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2384     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2385     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2386 
 2387     __ z_cs(Rcomp, Rnew, 0, Raddr);
 2388   %}
 2389 
 2390   enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="line-modified"> 2391     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2392     Register Rcomp = reg_to_register_object($compare_value$$reg);
 2393     Register Rnew  = reg_to_register_object($exchange_value$$reg);
 2394     Register Raddr = reg_to_register_object($addr_ptr$$reg);
 2395 
 2396     __ z_csg(Rcomp, Rnew, 0, Raddr);
 2397   %}
 2398 
 2399   enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="line-modified"> 2400     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2401     Register Rdst = reg_to_register_object($dst$$reg);
 2402     Register Rtmp = reg_to_register_object($tmp$$reg);
 2403     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2404     Label    retry;
 2405 
 2406     // Iterate until swap succeeds.
 2407     __ z_llgf(Rtmp, $mem$$Address);  // current contents
 2408     __ bind(retry);
 2409       // Calculate incremented value.
 2410       __ z_csy(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2411       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2412     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2413   %}
 2414 
 2415   enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="line-modified"> 2416     C2_MacroAssembler _masm(&amp;cbuf);</span>
 2417     Register Rdst = reg_to_register_object($dst$$reg);
 2418     Register Rtmp = reg_to_register_object($tmp$$reg);
 2419     guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
 2420     Label    retry;
 2421 
 2422     // Iterate until swap succeeds.
 2423     __ z_lg(Rtmp, $mem$$Address);  // current contents
 2424     __ bind(retry);
 2425       // Calculate incremented value.
 2426       __ z_csg(Rtmp, Rdst, $mem$$Address); // Try to store new value.
 2427       __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
 2428     __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
 2429   %}
 2430 
 2431 %} // encode
 2432 
 2433 source %{
 2434 
 2435   // Check whether outs are all Stores. If so, we can omit clearing the upper
 2436   // 32 bits after encoding.
</pre>
</td>
</tr>
</table>
<center><a href="macroAssembler_s390.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Udiff src/hotspot/cpu/s390/s390.ad</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macroAssembler_s390.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.udiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/s390/s390.ad</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-new-header">@@ -1,7 +1,7 @@</span>
  //
<span class="udiff-line-modified-removed">- // Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
<span class="udiff-line-modified-added">+ // Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  // Copyright (c) 2017, 2019 SAP SE. All rights reserved.
  // DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  //
  // This code is free software; you can redistribute it and/or modify it
  // under the terms of the GNU General Public License version 2 only, as
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -603,10 +603,21 @@</span>
  
  // !!!!! Special hack to get all type of calls to specify the byte offset
  //       from the start of the call to the point where the return address
  //       will point.
  
<span class="udiff-line-added">+ void PhaseOutput::pd_perform_mach_node_analysis() {</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int MachNode::pd_alignment_required() const {</span>
<span class="udiff-line-added">+   return 1;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
<span class="udiff-line-added">+ int MachNode::compute_padding(int current_offset) const {</span>
<span class="udiff-line-added">+   return 0;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  int MachCallStaticJavaNode::ret_addr_offset() {
    if (_method) {
      return 8;
    } else {
      return MacroAssembler::call_far_patchable_ret_addr_offset();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -662,17 +673,17 @@</span>
  bool SafePointNode::needs_polling_address_input() {
    return true;
  }
  
  void emit_nop(CodeBuffer &amp;cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ z_nop();
  }
  
  // Emit an interrupt that is caught by the debugger (for debugging compiler).
  void emit_break(CodeBuffer &amp;cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    __ z_illtrap();
  }
  
  #if !defined(PRODUCT)
  void MachBreakpointNode::format(PhaseRegAlloc *, outputStream *os) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -733,19 +744,19 @@</span>
    return 6;
  }
  
  // Check effective address (at runtime) for required alignment.
  static inline void z_assert_aligned(CodeBuffer &amp;cbuf, int disp, Register index, Register base, int alignment) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    __ z_lay(Z_R0, disp, index, base);
    __ z_nill(Z_R0, alignment-1);
    __ z_brc(Assembler::bcondEqual, +3);
    __ z_illtrap();
  }
  
<span class="udiff-line-modified-removed">- int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
<span class="udiff-line-modified-added">+ int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, relocInfo::relocType rtype,</span>
                      PhaseRegAlloc* ra_, bool is_native_call = false) {
    __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
    address old_mark = __ inst_mark();
    unsigned int start_off = __ offset();
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -772,11 +783,11 @@</span>
    unsigned int ret_off = __ offset();
  
    return (ret_off - start_off);
  }
  
<span class="udiff-line-modified-removed">- static int emit_call_reloc(MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
<span class="udiff-line-modified-added">+ static int emit_call_reloc(C2_MacroAssembler &amp;_masm, intptr_t entry_point, RelocationHolder const&amp; rspec) {</span>
    __ set_inst_mark(); // Used in z_enc_java_static_call() and emit_java_to_interp().
    address old_mark = __ inst_mark();
    unsigned int start_off = __ offset();
  
    relocInfo::relocType rtype = rspec.type();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -793,11 +804,11 @@</span>
  }
  
  //=============================================================================
  
  const RegMask&amp; MachConstantBaseNode::_out_RegMask = _Z_PTR_REG_mask;
<span class="udiff-line-modified-removed">- int Compile::ConstantTable::calculate_table_base_offset() const {</span>
<span class="udiff-line-modified-added">+ int ConstantTable::calculate_table_base_offset() const {</span>
    return 0;  // absolute addressing, no offset
  }
  
  bool MachConstantBaseNode::requires_postalloc_expand() const { return false; }
  void MachConstantBaseNode::postalloc_expand(GrowableArray &lt;Node *&gt; *nodes, PhaseRegAlloc *ra_) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -805,11 +816,11 @@</span>
  }
  
  // Even with PC-relative TOC addressing, we still need this node.
  // Float loads/stores do not support PC-relative addresses.
  void MachConstantBaseNode::emit(CodeBuffer&amp; cbuf, PhaseRegAlloc* ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Register Rtoc = as_Register(ra_-&gt;get_encode(this));
    __ load_toc(Rtoc);
  }
  
  uint MachConstantBaseNode::size(PhaseRegAlloc* ra_) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -838,34 +849,34 @@</span>
    if (VerifyThread) {
      st-&gt;print_cr(&quot;Verify_Thread&quot;);
      st-&gt;print(&quot;\t&quot;);
    }
  
<span class="udiff-line-modified-removed">-   long framesize = C-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-modified-removed">-   int bangsize   = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   long framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   int bangsize   = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      st-&gt;print_cr(&quot;# stack bang&quot;); st-&gt;print(&quot;\t&quot;);
    }
    st-&gt;print_cr(&quot;push_frame %d&quot;, (int)-framesize);
    st-&gt;print(&quot;\t&quot;);
  }
  #endif
  
  void MachPrologNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
    Compile* C = ra_-&gt;C;
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    __ verify_thread();
  
<span class="udiff-line-modified-removed">-   size_t framesize = C-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-modified-removed">-   size_t bangsize  = C-&gt;bang_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   size_t framesize = C-&gt;output()-&gt;frame_size_in_bytes();</span>
<span class="udiff-line-modified-added">+   size_t bangsize  = C-&gt;output()-&gt;bang_size_in_bytes();</span>
  
    assert(framesize % wordSize == 0, &quot;must preserve wordSize alignment&quot;);
  
    if (C-&gt;clinit_barrier_on_entry()) {
      assert(!C-&gt;method()-&gt;holder()-&gt;is_not_initialized(), &quot;initialization should have been started&quot;);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -887,11 +898,11 @@</span>
    // Calls to C2R adapters often do not accept exceptional returns.
    // We require that their callers must bang for them. But be
    // careful, because some VM calls (such as call site linkage) can
    // use several kilobytes of stack. But the stack safety zone should
    // account for that. See bugs 4446381, 4468289, 4497237.
<span class="udiff-line-modified-removed">-   if (C-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
<span class="udiff-line-modified-added">+   if (C-&gt;output()-&gt;need_stack_bang(bangsize) &amp;&amp; UseStackBanging) {</span>
      __ generate_stack_overflow_check(bangsize);
    }
  
    assert(Immediate::is_uimm32((long)framesize), &quot;to do: choose suitable types!&quot;);
    __ save_return_pc();
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -901,11 +912,11 @@</span>
    __ push_frame((unsigned int)framesize/*includes JIT ABI*/);
  
    if (C-&gt;has_mach_constant_base_node()) {
      // NOTE: We set the table base offset here because users might be
      // emitted before MachConstantBaseNode.
<span class="udiff-line-modified-removed">-     Compile::ConstantTable&amp; constant_table = C-&gt;constant_table();</span>
<span class="udiff-line-modified-added">+     ConstantTable&amp; constant_table = C-&gt;output()-&gt;constant_table();</span>
      constant_table.set_table_base_offset(constant_table.calculate_table_base_offset());
    }
  }
  
  uint MachPrologNode::size(PhaseRegAlloc *ra_) const {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -930,33 +941,28 @@</span>
    }
  }
  #endif
  
  void MachEpilogNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    Compile* C = ra_-&gt;C;
    __ verify_thread();
  
    // If this does safepoint polling, then do it here.
    bool need_polling = do_polling() &amp;&amp; C-&gt;is_method_compilation();
  
    // Pop frame, restore return_pc, and all stuff needed by interpreter.
<span class="udiff-line-modified-removed">-   int frame_size_in_bytes = Assembler::align((C-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
<span class="udiff-line-modified-added">+   int frame_size_in_bytes = Assembler::align((C-&gt;output()-&gt;frame_slots() &lt;&lt; LogBytesPerInt), frame::alignment_in_bytes);</span>
    __ pop_frame_restore_retPC(frame_size_in_bytes);
  
    if (StackReservedPages &gt; 0 &amp;&amp; C-&gt;has_reserved_stack_access()) {
      __ reserved_stack_check(Z_R14);
    }
  
    // Touch the polling page.
    if (need_polling) {
<span class="udiff-line-modified-removed">-     if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="udiff-line-removed">-       __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));</span>
<span class="udiff-line-removed">-     } else {</span>
<span class="udiff-line-removed">-       AddressLiteral pp(os::get_polling_page());</span>
<span class="udiff-line-removed">-       __ load_const_optimized(Z_R1_scratch, pp);</span>
<span class="udiff-line-removed">-     }</span>
<span class="udiff-line-modified-added">+     __ z_lg(Z_R1_scratch, Address(Z_thread, Thread::polling_page_offset()));</span>
      // We need to mark the code position where the load from the safepoint
      // polling page was emitted as relocInfo::poll_return_type here.
      __ relocate(relocInfo::poll_return_type);
      __ load_from_polling_page(Z_R1_scratch);
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -974,15 +980,10 @@</span>
  
  const Pipeline * MachEpilogNode::pipeline() const {
    return MachNode::pipeline_class();
  }
  
<span class="udiff-line-removed">- int MachEpilogNode::safepoint_offset() const {</span>
<span class="udiff-line-removed">-   assert(do_polling(), &quot;no return for this epilog node&quot;);</span>
<span class="udiff-line-removed">-   return 0;</span>
<span class="udiff-line-removed">- }</span>
<span class="udiff-line-removed">- </span>
  //=============================================================================
  
  // Figure out which register class each belongs in: rc_int, rc_float, rc_stack.
  enum RC { rc_bad, rc_int, rc_float, rc_stack };
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1032,11 +1033,11 @@</span>
    return (opcode &gt; (1L &lt;&lt; 32)) ? 6 : 4;
  }
  
  static unsigned int z_mvc_helper(CodeBuffer *cbuf, int len, int dst_off, int src_off, bool do_print, outputStream *os) {
    if (cbuf) {
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(cbuf);</span>
      __ z_mvc(dst_off, len-1, Z_SP, src_off, Z_SP);
    }
  
  #if !defined(PRODUCT)
    else if (do_print) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1106,11 +1107,11 @@</span>
    }
  
    // Check for integer reg-reg copy.
    if (src_lo_rc == rc_int &amp;&amp; dst_lo_rc == rc_int) {
      if (cbuf) {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(cbuf);</span>
        Register Rsrc = as_Register(Matcher::_regEncode[src_lo]);
        Register Rdst = as_Register(Matcher::_regEncode[dst_lo]);
        __ z_lgr(Rdst, Rsrc);
        return 4;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1153,11 +1154,11 @@</span>
    }
  
    // Check for float reg-reg copy.
    if (src_lo_rc == rc_float &amp;&amp; dst_lo_rc == rc_float) {
      if (cbuf) {
<span class="udiff-line-modified-removed">-       MacroAssembler _masm(cbuf);</span>
<span class="udiff-line-modified-added">+       C2_MacroAssembler _masm(cbuf);</span>
        FloatRegister Rsrc = as_FloatRegister(Matcher::_regEncode[src_lo]);
        FloatRegister Rdst = as_FloatRegister(Matcher::_regEncode[dst_lo]);
        __ z_ldr(Rdst, Rsrc);
        return 2;
      }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1252,25 +1253,25 @@</span>
    os-&gt;print(&quot;NOP     # pad for alignment (%d nops, %d bytes)&quot;, _count, _count*MacroAssembler::nop_size());
  }
  #endif
  
  void MachNopNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc * ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int rem_space = 0;
<span class="udiff-line-modified-removed">-   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
<span class="udiff-line-modified-added">+   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
      rem_space = cbuf.insts()-&gt;remaining();
      if (rem_space &lt;= _count*2 + 8) {
        tty-&gt;print(&quot;NopNode: _count = %3.3d, remaining space before = %d&quot;, _count, rem_space);
      }
    }
  
    for (int i = 0; i &lt; _count; i++) {
      __ z_nop();
    }
  
<span class="udiff-line-modified-removed">-   if (!(ra_-&gt;C-&gt;in_scratch_emit_size())) {</span>
<span class="udiff-line-modified-added">+   if (!(ra_-&gt;C-&gt;output()-&gt;in_scratch_emit_size())) {</span>
      if (rem_space &lt;= _count*2 + 8) {
        int rem_space2 = cbuf.insts()-&gt;remaining();
        tty-&gt;print_cr(&quot;, after = %d&quot;, rem_space2);
      }
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1292,11 +1293,11 @@</span>
  }
  #endif
  
  // Take care of the size function, if you make changes here!
  void BoxLockNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    int offset = ra_-&gt;reg2offset(in_RegMask(0).find_first_elem());
    int reg = ra_-&gt;get_encode(this);
    __ z_lay(as_Register(reg), offset, Z_SP);
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1358,11 +1359,11 @@</span>
    os-&gt;print_cr(&quot;\tBRU     ic_miss&quot;);
  }
  #endif
  
  void MachUEPNode::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    const int ic_miss_offset = 2;
  
    // Inline_cache contains a klass.
    Register ic_klass = as_Register(Matcher::inline_cache_reg_encode());
    // ARG1 is the receiver oop.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1431,10 +1432,17 @@</span>
    static uint size_deopt_handler() {
      return NativeCall::max_instruction_size();
    }
  };
  
<span class="udiff-line-added">+ class Node::PD {</span>
<span class="udiff-line-added">+ public:</span>
<span class="udiff-line-added">+   enum NodeFlags {</span>
<span class="udiff-line-added">+     _last_flag = Node::_last_flag</span>
<span class="udiff-line-added">+   };</span>
<span class="udiff-line-added">+ };</span>
<span class="udiff-line-added">+ </span>
  %} // end source_hpp section
  
  source %{
  
  // This exception handler code snippet is placed after the method&#39;s
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1453,11 +1461,11 @@</span>
  // 3) The handler will get patched such that it does not jump to the
  //   exception blob, but to an entry in the deoptimization blob being
  //   aware of the exception.
  int HandlerImpl::emit_exception_handler(CodeBuffer &amp;cbuf) {
    Register temp_reg = Z_R1;
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
  
    address base = __ start_a_stub(size_exception_handler());
    if (base == NULL) {
      return 0;          // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1474,11 +1482,11 @@</span>
    return offset;
  }
  
  // Emit deopt handler code.
  int HandlerImpl::emit_deopt_handler(CodeBuffer&amp; cbuf) {
<span class="udiff-line-modified-removed">-   MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+   C2_MacroAssembler _masm(&amp;cbuf);</span>
    address        base = __ start_a_stub(size_deopt_handler());
  
    if (base == NULL) {
      return 0;  // CodeBuffer::expand failed
    }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1801,14 +1809,19 @@</span>
    return RegMask();
  }
  
  const bool Matcher::convi2l_type_required = true;
  
<span class="udiff-line-added">+ // Should the matcher clone input &#39;m&#39; of node &#39;n&#39;?</span>
<span class="udiff-line-added">+ bool Matcher::pd_clone_node(Node* n, Node* m, Matcher::MStack&amp; mstack) {</span>
<span class="udiff-line-added">+   return false;</span>
<span class="udiff-line-added">+ }</span>
<span class="udiff-line-added">+ </span>
  // Should the Matcher clone shifts on addressing modes, expecting them
  // to be subsumed into complex addressing expressions or compute them
  // into registers?
<span class="udiff-line-modified-removed">- bool Matcher::clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
<span class="udiff-line-modified-added">+ bool Matcher::pd_clone_address_expressions(AddPNode* m, Matcher::MStack&amp; mstack, VectorSet&amp; address_visited) {</span>
    return clone_base_plus_offset_address(m, mstack, address_visited);
  }
  
  void Compile::reshape_address(AddPNode* addp) {
  }
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -1839,17 +1852,17 @@</span>
  // opcode keyword to specify, in order, their primary, secondary, and
  // tertiary opcode. Only the opcode sections which a particular instruction
  // needs for encoding need to be specified.
  encode %{
    enc_class enc_unimplemented %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ unimplemented(&quot;Unimplemented mach node encoding in AD file.&quot;, 13);
    %}
  
    enc_class enc_untested %{
  #ifdef ASSERT
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      __ untested(&quot;Untested mach node encoding in AD file.&quot;);
  #endif
    %}
  
    enc_class z_rrform(iRegI dst, iRegI src) %{
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2031,11 +2044,11 @@</span>
                    Assembler::reg($dst$$reg, 8, 48) |
                    Assembler::simm20($mem$$disp) |
                    Assembler::reg(Ridx, 12, 48) |
                    Assembler::regz(reg_to_register_object($mem$$base), 16, 48));
      } else {
<span class="udiff-line-modified-removed">-         MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+         C2_MacroAssembler _masm(&amp;cbuf);</span>
          __ load_const_optimized(Z_R1_scratch, $mem$$disp);
          if (Ridx != Z_R0) { __ z_agr(Z_R1_scratch, Ridx); }
          z_emit_inst(cbuf, $secondary |
                      Assembler::reg($dst$$reg, 8, isize) |
                      Assembler::uimm12(0, 20, isize) |
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2043,11 +2056,11 @@</span>
                      Assembler::regz(reg_to_register_object($mem$$base), 16, isize));
      }
    %}
  
    enc_class z_enc_brul(Label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2056,11 +2069,11 @@</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brul(l);
    %}
  
    enc_class z_enc_bru(Label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2069,11 +2082,11 @@</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_bru(l);
    %}
  
    enc_class z_enc_branch_con_far(cmpOp cmp, Label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2082,11 +2095,11 @@</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_branch_con_short(cmpOp cmp, Label lbl) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2095,11 +2108,11 @@</span>
      Label&amp; l = (NULL == p) ? d : *(p);
      __ z_brc((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_cmpb_regreg(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2119,11 +2132,11 @@</span>
        __ z_clgrj($src1$$Register, $src2$$Register, cc, l);
      }
    %}
  
    enc_class z_enc_cmpb_regregFar(iRegI src1, iRegI src2, Label lbl, cmpOpT cmp) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2145,11 +2158,11 @@</span>
  
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    enc_class z_enc_cmpb_regimm(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2170,11 +2183,11 @@</span>
        __ z_clgij($src1$$Register, $src2$$constant, cc, l);
      }
    %}
  
    enc_class z_enc_cmpb_regimmFar(iRegI src1, immI8 src2, Label lbl, cmpOpT cmp) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Label* p = $lbl$$label;
  
      // &#39;p&#39; is `NULL&#39; when this encoding class is used only to
      // determine the size of the encoded instruction.
      // Use a bound dummy label in that case.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2197,11 +2210,11 @@</span>
      __ z_brcl((Assembler::branch_condition)$cmp$$cmpcode, l);
    %}
  
    // Call from Java to runtime.
    enc_class z_enc_java_to_runtime_call(method meth) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
  
      // Save return pc before call to the place where we need it, since
      // callee doesn&#39;t.
      unsigned int start_off = __ offset();
      // Compute size of &quot;larl + stg + call_c_opt&quot;.
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2225,11 +2238,11 @@</span>
    %}
  
    enc_class z_enc_java_static_call(method meth) %{
      // Call to fixup routine. Fixup routine uses ScopeDesc info to determine
      // whom we intended to call.
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      int ret_offset = 0;
  
      if (!_method) {
        ret_offset = emit_call_reloc(_masm, $meth$$method,
                                     relocInfo::runtime_call_w_cp_type, ra_);
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2254,11 +2267,11 @@</span>
      }
    %}
  
    // Java dynamic call
    enc_class z_enc_java_dynamic_call(method meth) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      unsigned int start_off = __ offset();
  
      int vtable_index = this-&gt;_vtable_index;
      if (vtable_index == -4) {
        Register ic_reg = reg_to_register_object(Matcher::inline_cache_reg_encode());
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2309,11 +2322,11 @@</span>
        unsigned int ret_off = __ offset();
      }
    %}
  
    enc_class z_enc_cmov_reg(cmpOp cmp, iRegI dst, iRegI src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rsrc = reg_to_register_object($src$$reg);
  
      // Don&#39;t emit code if operands are identical (same register).
      if (Rsrc != Rdst) {
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2330,11 +2343,11 @@</span>
        }
      }
    %}
  
    enc_class z_enc_cmov_imm(cmpOp cmp, iRegI dst, immI16 src) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      int      Csrc = $src$$constant;
      Assembler::branch_condition cc = (Assembler::branch_condition)$cmp$$cmpcode;
      Label done;
      // Branch if not (cmp cr).
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2347,11 +2360,11 @@</span>
      }
      __ bind(done);
    %}
  
    enc_class z_enc_cctobool(iRegI res) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rres = reg_to_register_object($res$$reg);
  
      if (VM_Version::has_LoadStoreConditional()) {
        __ load_const_optimized(Z_R0_scratch, 0L); // false (failed)
        __ load_const_optimized(Rres, 1L);         // true  (succeed)
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2364,29 +2377,29 @@</span>
        __ bind(done);
      }
    %}
  
    enc_class z_enc_casI(iRegI compare_value, iRegI exchange_value, iRegP addr_ptr) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rcomp = reg_to_register_object($compare_value$$reg);
      Register Rnew  = reg_to_register_object($exchange_value$$reg);
      Register Raddr = reg_to_register_object($addr_ptr$$reg);
  
      __ z_cs(Rcomp, Rnew, 0, Raddr);
    %}
  
    enc_class z_enc_casL(iRegL compare_value, iRegL exchange_value, iRegP addr_ptr) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rcomp = reg_to_register_object($compare_value$$reg);
      Register Rnew  = reg_to_register_object($exchange_value$$reg);
      Register Raddr = reg_to_register_object($addr_ptr$$reg);
  
      __ z_csg(Rcomp, Rnew, 0, Raddr);
    %}
  
    enc_class z_enc_SwapI(memoryRSY mem, iRegI dst, iRegI tmp) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rtmp = reg_to_register_object($tmp$$reg);
      guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
      Label    retry;
  
</pre>
<hr />
<pre>
<span class="line-new-header">@@ -2398,11 +2411,11 @@</span>
        __ z_brne(retry);                    // Yikes, concurrent update, need to retry.
      __ z_lgr(Rdst, Rtmp);                  // Exchanged value from memory is return value.
    %}
  
    enc_class z_enc_SwapL(memoryRSY mem, iRegL dst, iRegL tmp) %{
<span class="udiff-line-modified-removed">-     MacroAssembler _masm(&amp;cbuf);</span>
<span class="udiff-line-modified-added">+     C2_MacroAssembler _masm(&amp;cbuf);</span>
      Register Rdst = reg_to_register_object($dst$$reg);
      Register Rtmp = reg_to_register_object($tmp$$reg);
      guarantee(Rdst != Rtmp, &quot;Fix match rule to use TEMP_DEF&quot;);
      Label    retry;
  
</pre>
<center><a href="macroAssembler_s390.hpp.udiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="sharedRuntime_s390.cpp.udiff.html" target="_top">next &gt;</a></center>  </body>
</html>
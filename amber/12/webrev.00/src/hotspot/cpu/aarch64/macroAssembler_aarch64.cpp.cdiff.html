<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Cdiff src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="interp_masm_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/cpu/aarch64/macroAssembler_aarch64.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<hr />
<pre>
<span class="line-old-header">*** 52,12 ***</span>
  #include &quot;c1/c1_LIRAssembler.hpp&quot;
  #endif
  #ifdef COMPILER2
  #include &quot;oops/oop.hpp&quot;
  #include &quot;opto/compile.hpp&quot;
<span class="line-removed">- #include &quot;opto/intrinsicnode.hpp&quot;</span>
  #include &quot;opto/node.hpp&quot;
  #endif
  
  #ifdef PRODUCT
  #define BLOCK_COMMENT(str) /* nothing */
  #define STOP(error) stop(error)
<span class="line-new-header">--- 52,12 ---</span>
  #include &quot;c1/c1_LIRAssembler.hpp&quot;
  #endif
  #ifdef COMPILER2
  #include &quot;oops/oop.hpp&quot;
  #include &quot;opto/compile.hpp&quot;
  #include &quot;opto/node.hpp&quot;
<span class="line-added">+ #include &quot;opto/output.hpp&quot;</span>
  #endif
  
  #ifdef PRODUCT
  #define BLOCK_COMMENT(str) /* nothing */
  #define STOP(error) stop(error)
</pre>
<hr />
<pre>
<span class="line-old-header">*** 289,20 ***</span>
    }
    return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
  }
  
  void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
<span class="line-modified">!   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">!     ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-removed">-     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     unsigned long offset;</span>
<span class="line-removed">-     adrp(rscratch1, ExternalAddress(SafepointSynchronize::address_of_state()), offset);</span>
<span class="line-removed">-     ldrw(rscratch1, Address(rscratch1, offset));</span>
<span class="line-removed">-     assert(SafepointSynchronize::_not_synchronized == 0, &quot;rewrite this code&quot;);</span>
<span class="line-removed">-     cbnz(rscratch1, slow_path);</span>
<span class="line-removed">-   }</span>
  }
  
  // Just like safepoint_poll, but use an acquiring load for thread-
  // local polling.
  //
<span class="line-new-header">--- 289,12 ---</span>
    }
    return address(((uint64_t)insn_addr + (offset &lt;&lt; 2)));
  }
  
  void MacroAssembler::safepoint_poll(Label&amp; slow_path) {
<span class="line-modified">!   ldr(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified">!   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
  }
  
  // Just like safepoint_poll, but use an acquiring load for thread-
  // local polling.
  //
</pre>
<hr />
<pre>
<span class="line-old-header">*** 314,17 ***</span>
  //
  // This is to avoid a race when we&#39;re in a native-&gt;Java transition
  // racing the code which wakes up from a safepoint.
  //
  void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
<span class="line-modified">!   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">!     lea(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified">!     ldar(rscratch1, rscratch1);</span>
<span class="line-removed">-     tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     safepoint_poll(slow_path);</span>
<span class="line-removed">-   }</span>
  }
  
  void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
    // we must set sp to zero to clear frame
    str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
<span class="line-new-header">--- 306,13 ---</span>
  //
  // This is to avoid a race when we&#39;re in a native-&gt;Java transition
  // racing the code which wakes up from a safepoint.
  //
  void MacroAssembler::safepoint_poll_acquire(Label&amp; slow_path) {
<span class="line-modified">!   lea(rscratch1, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-modified">!   ldar(rscratch1, rscratch1);</span>
<span class="line-modified">!   tbnz(rscratch1, exact_log2(SafepointMechanism::poll_bit()), slow_path);</span>
  }
  
  void MacroAssembler::reset_last_Java_frame(bool clear_fp) {
    // we must set sp to zero to clear frame
    str(zr, Address(rthread, JavaThread::last_Java_sp_offset()));
</pre>
<hr />
<pre>
<span class="line-old-header">*** 743,11 ***</span>
      // We don&#39;t want to emit a trampoline if C2 is generating dummy
      // code during its branch shortening phase.
      CompileTask* task = ciEnv::current()-&gt;task();
      in_scratch_emit_size =
        (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
<span class="line-modified">!        Compile::current()-&gt;in_scratch_emit_size());</span>
  #endif
      if (!in_scratch_emit_size) {
        address stub = emit_trampoline_stub(offset(), entry.target());
        if (stub == NULL) {
          return NULL; // CodeCache is full
<span class="line-new-header">--- 731,11 ---</span>
      // We don&#39;t want to emit a trampoline if C2 is generating dummy
      // code during its branch shortening phase.
      CompileTask* task = ciEnv::current()-&gt;task();
      in_scratch_emit_size =
        (task != NULL &amp;&amp; is_c2_compile(task-&gt;comp_level()) &amp;&amp;
<span class="line-modified">!        Compile::current()-&gt;output()-&gt;in_scratch_emit_size());</span>
  #endif
      if (!in_scratch_emit_size) {
        address stub = emit_trampoline_stub(offset(), entry.target());
        if (stub == NULL) {
          return NULL; // CodeCache is full
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4303,26 ***</span>
      lea(tmp, Address(tmp, -os::vm_page_size()));
      str(size, Address(tmp));
    }
  }
  
<span class="line-removed">- </span>
  // Move the address of the polling page into dest.
<span class="line-modified">! void MacroAssembler::get_polling_page(Register dest, address page, relocInfo::relocType rtype) {</span>
<span class="line-modified">!   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-removed">-     ldr(dest, Address(rthread, Thread::polling_page_offset()));</span>
<span class="line-removed">-   } else {</span>
<span class="line-removed">-     unsigned long off;</span>
<span class="line-removed">-     adrp(dest, Address(page, rtype), off);</span>
<span class="line-removed">-     assert(off == 0, &quot;polling page must be page aligned&quot;);</span>
<span class="line-removed">-   }</span>
  }
  
  // Move the address of the polling page into r, then read the polling
  // page.
<span class="line-modified">! address MacroAssembler::read_polling_page(Register r, address page, relocInfo::relocType rtype) {</span>
<span class="line-modified">!   get_polling_page(r, page, rtype);</span>
    return read_polling_page(r, rtype);
  }
  
  // Read the polling page.  The address of the polling page must
  // already be in r.
<span class="line-new-header">--- 4291,19 ---</span>
      lea(tmp, Address(tmp, -os::vm_page_size()));
      str(size, Address(tmp));
    }
  }
  
  // Move the address of the polling page into dest.
<span class="line-modified">! void MacroAssembler::get_polling_page(Register dest, relocInfo::relocType rtype) {</span>
<span class="line-modified">!   ldr(dest, Address(rthread, Thread::polling_page_offset()));</span>
  }
  
  // Move the address of the polling page into r, then read the polling
  // page.
<span class="line-modified">! address MacroAssembler::fetch_and_read_polling_page(Register r, relocInfo::relocType rtype) {</span>
<span class="line-modified">!   get_polling_page(r, rtype);</span>
    return read_polling_page(r, rtype);
  }
  
  // Read the polling page.  The address of the polling page must
  // already be in r.
</pre>
<hr />
<pre>
<span class="line-old-header">*** 4411,741 ***</span>
      }
      ldp(rfp, lr, Address(post(sp, 2 * wordSize)));
    }
  }
  
<span class="line-removed">- #ifdef COMPILER2</span>
<span class="line-removed">- typedef void (MacroAssembler::* chr_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Search for str1 in str2 and return index or -1</span>
<span class="line-removed">- void MacroAssembler::string_indexof(Register str2, Register str1,</span>
<span class="line-removed">-                                     Register cnt2, Register cnt1,</span>
<span class="line-removed">-                                     Register tmp1, Register tmp2,</span>
<span class="line-removed">-                                     Register tmp3, Register tmp4,</span>
<span class="line-removed">-                                     Register tmp5, Register tmp6,</span>
<span class="line-removed">-                                     int icnt1, Register result, int ae) {</span>
<span class="line-removed">-   // NOTE: tmp5, tmp6 can be zr depending on specific method version</span>
<span class="line-removed">-   Label LINEARSEARCH, LINEARSTUB, LINEAR_MEDIUM, DONE, NOMATCH, MATCH;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   Register ch1 = rscratch1;</span>
<span class="line-removed">-   Register ch2 = rscratch2;</span>
<span class="line-removed">-   Register cnt1tmp = tmp1;</span>
<span class="line-removed">-   Register cnt2tmp = tmp2;</span>
<span class="line-removed">-   Register cnt1_neg = cnt1;</span>
<span class="line-removed">-   Register cnt2_neg = cnt2;</span>
<span class="line-removed">-   Register result_tmp = tmp4;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool isL = ae == StrIntrinsicNode::LL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool str1_isL = ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::UL;</span>
<span class="line-removed">-   bool str2_isL = ae == StrIntrinsicNode::LL || ae == StrIntrinsicNode::LU;</span>
<span class="line-removed">-   int str1_chr_shift = str1_isL ? 0:1;</span>
<span class="line-removed">-   int str2_chr_shift = str2_isL ? 0:1;</span>
<span class="line-removed">-   int str1_chr_size = str1_isL ? 1:2;</span>
<span class="line-removed">-   int str2_chr_size = str2_isL ? 1:2;</span>
<span class="line-removed">-   chr_insn str1_load_1chr = str1_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">-                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">-   chr_insn str2_load_1chr = str2_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">-                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">-   chr_insn load_2chr = isL ? (chr_insn)&amp;MacroAssembler::ldrh : (chr_insn)&amp;MacroAssembler::ldrw;</span>
<span class="line-removed">-   chr_insn load_4chr = isL ? (chr_insn)&amp;MacroAssembler::ldrw : (chr_insn)&amp;MacroAssembler::ldr;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Note, inline_string_indexOf() generates checks:</span>
<span class="line-removed">-   // if (substr.count &gt; string.count) return -1;</span>
<span class="line-removed">-   // if (substr.count == 0) return 0;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // We have two strings, a source string in str2, cnt2 and a pattern string</span>
<span class="line-removed">-   // in str1, cnt1. Find the 1st occurence of pattern in source or return -1.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // For larger pattern and source we use a simplified Boyer Moore algorithm.</span>
<span class="line-removed">-   // With a small pattern and source we use linear scan.</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (icnt1 == -1) {</span>
<span class="line-removed">-     sub(result_tmp, cnt2, cnt1);</span>
<span class="line-removed">-     cmp(cnt1, (u1)8);             // Use Linear Scan if cnt1 &lt; 8 || cnt1 &gt;= 256</span>
<span class="line-removed">-     br(LT, LINEARSEARCH);</span>
<span class="line-removed">-     dup(v0, T16B, cnt1); // done in separate FPU pipeline. Almost no penalty</span>
<span class="line-removed">-     subs(zr, cnt1, 256);</span>
<span class="line-removed">-     lsr(tmp1, cnt2, 2);</span>
<span class="line-removed">-     ccmp(cnt1, tmp1, 0b0000, LT); // Source must be 4 * pattern for BM</span>
<span class="line-removed">-     br(GE, LINEARSTUB);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // The Boyer Moore alogorithm is based on the description here:-</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // http://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string_search_algorithm</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // This describes and algorithm with 2 shift rules. The &#39;Bad Character&#39; rule</span>
<span class="line-removed">- // and the &#39;Good Suffix&#39; rule.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // These rules are essentially heuristics for how far we can shift the</span>
<span class="line-removed">- // pattern along the search string.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // The implementation here uses the &#39;Bad Character&#39; rule only because of the</span>
<span class="line-removed">- // complexity of initialisation for the &#39;Good Suffix&#39; rule.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // This is also known as the Boyer-Moore-Horspool algorithm:-</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // http://en.wikipedia.org/wiki/Boyer-Moore-Horspool_algorithm</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // This particular implementation has few java-specific optimizations.</span>
<span class="line-removed">- //</span>
<span class="line-removed">- // #define ASIZE 256</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //    int bm(unsigned char *x, int m, unsigned char *y, int n) {</span>
<span class="line-removed">- //       int i, j;</span>
<span class="line-removed">- //       unsigned c;</span>
<span class="line-removed">- //       unsigned char bc[ASIZE];</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //       /* Preprocessing */</span>
<span class="line-removed">- //       for (i = 0; i &lt; ASIZE; ++i)</span>
<span class="line-removed">- //          bc[i] = m;</span>
<span class="line-removed">- //       for (i = 0; i &lt; m - 1; ) {</span>
<span class="line-removed">- //          c = x[i];</span>
<span class="line-removed">- //          ++i;</span>
<span class="line-removed">- //          // c &lt; 256 for Latin1 string, so, no need for branch</span>
<span class="line-removed">- //          #ifdef PATTERN_STRING_IS_LATIN1</span>
<span class="line-removed">- //          bc[c] = m - i;</span>
<span class="line-removed">- //          #else</span>
<span class="line-removed">- //          if (c &lt; ASIZE) bc[c] = m - i;</span>
<span class="line-removed">- //          #endif</span>
<span class="line-removed">- //       }</span>
<span class="line-removed">- //</span>
<span class="line-removed">- //       /* Searching */</span>
<span class="line-removed">- //       j = 0;</span>
<span class="line-removed">- //       while (j &lt;= n - m) {</span>
<span class="line-removed">- //          c = y[i+j];</span>
<span class="line-removed">- //          if (x[m-1] == c)</span>
<span class="line-removed">- //            for (i = m - 2; i &gt;= 0 &amp;&amp; x[i] == y[i + j]; --i);</span>
<span class="line-removed">- //          if (i &lt; 0) return j;</span>
<span class="line-removed">- //          // c &lt; 256 for Latin1 string, so, no need for branch</span>
<span class="line-removed">- //          #ifdef SOURCE_STRING_IS_LATIN1</span>
<span class="line-removed">- //          // LL case: (c&lt; 256) always true. Remove branch</span>
<span class="line-removed">- //          j += bc[y[j+m-1]];</span>
<span class="line-removed">- //          #endif</span>
<span class="line-removed">- //          #ifndef PATTERN_STRING_IS_UTF</span>
<span class="line-removed">- //          // UU case: need if (c&lt;ASIZE) check. Skip 1 character if not.</span>
<span class="line-removed">- //          if (c &lt; ASIZE)</span>
<span class="line-removed">- //            j += bc[y[j+m-1]];</span>
<span class="line-removed">- //          else</span>
<span class="line-removed">- //            j += 1</span>
<span class="line-removed">- //          #endif</span>
<span class="line-removed">- //          #ifdef PATTERN_IS_LATIN1_AND_SOURCE_IS_UTF</span>
<span class="line-removed">- //          // UL case: need if (c&lt;ASIZE) check. Skip &lt;pattern length&gt; if not.</span>
<span class="line-removed">- //          if (c &lt; ASIZE)</span>
<span class="line-removed">- //            j += bc[y[j+m-1]];</span>
<span class="line-removed">- //          else</span>
<span class="line-removed">- //            j += m</span>
<span class="line-removed">- //          #endif</span>
<span class="line-removed">- //       }</span>
<span class="line-removed">- //    }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   if (icnt1 == -1) {</span>
<span class="line-removed">-     Label BCLOOP, BCSKIP, BMLOOPSTR2, BMLOOPSTR1, BMSKIP, BMADV, BMMATCH,</span>
<span class="line-removed">-         BMLOOPSTR1_LASTCMP, BMLOOPSTR1_CMP, BMLOOPSTR1_AFTER_LOAD, BM_INIT_LOOP;</span>
<span class="line-removed">-     Register cnt1end = tmp2;</span>
<span class="line-removed">-     Register str2end = cnt2;</span>
<span class="line-removed">-     Register skipch = tmp2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // str1 length is &gt;=8, so, we can read at least 1 register for cases when</span>
<span class="line-removed">-     // UTF-&gt;Latin1 conversion is not needed(8 LL or 4UU) and half register for</span>
<span class="line-removed">-     // UL case. We&#39;ll re-read last character in inner pre-loop code to have</span>
<span class="line-removed">-     // single outer pre-loop load</span>
<span class="line-removed">-     const int firstStep = isL ? 7 : 3;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     const int ASIZE = 256;</span>
<span class="line-removed">-     const int STORED_BYTES = 32; // amount of bytes stored per instruction</span>
<span class="line-removed">-     sub(sp, sp, ASIZE);</span>
<span class="line-removed">-     mov(tmp5, ASIZE/STORED_BYTES); // loop iterations</span>
<span class="line-removed">-     mov(ch1, sp);</span>
<span class="line-removed">-     BIND(BM_INIT_LOOP);</span>
<span class="line-removed">-       stpq(v0, v0, Address(post(ch1, STORED_BYTES)));</span>
<span class="line-removed">-       subs(tmp5, tmp5, 1);</span>
<span class="line-removed">-       br(GT, BM_INIT_LOOP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       sub(cnt1tmp, cnt1, 1);</span>
<span class="line-removed">-       mov(tmp5, str2);</span>
<span class="line-removed">-       add(str2end, str2, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">-       sub(ch2, cnt1, 1);</span>
<span class="line-removed">-       mov(tmp3, str1);</span>
<span class="line-removed">-     BIND(BCLOOP);</span>
<span class="line-removed">-       (this-&gt;*str1_load_1chr)(ch1, Address(post(tmp3, str1_chr_size)));</span>
<span class="line-removed">-       if (!str1_isL) {</span>
<span class="line-removed">-         subs(zr, ch1, ASIZE);</span>
<span class="line-removed">-         br(HS, BCSKIP);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       strb(ch2, Address(sp, ch1));</span>
<span class="line-removed">-     BIND(BCSKIP);</span>
<span class="line-removed">-       subs(ch2, ch2, 1);</span>
<span class="line-removed">-       br(GT, BCLOOP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       add(tmp6, str1, cnt1, LSL, str1_chr_shift); // address after str1</span>
<span class="line-removed">-       if (str1_isL == str2_isL) {</span>
<span class="line-removed">-         // load last 8 bytes (8LL/4UU symbols)</span>
<span class="line-removed">-         ldr(tmp6, Address(tmp6, -wordSize));</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         ldrw(tmp6, Address(tmp6, -wordSize/2)); // load last 4 bytes(4 symbols)</span>
<span class="line-removed">-         // convert Latin1 to UTF. We&#39;ll have to wait until load completed, but</span>
<span class="line-removed">-         // it&#39;s still faster than per-character loads+checks</span>
<span class="line-removed">-         lsr(tmp3, tmp6, BitsPerByte * (wordSize/2 - str1_chr_size)); // str1[N-1]</span>
<span class="line-removed">-         ubfx(ch1, tmp6, 8, 8); // str1[N-2]</span>
<span class="line-removed">-         ubfx(ch2, tmp6, 16, 8); // str1[N-3]</span>
<span class="line-removed">-         andr(tmp6, tmp6, 0xFF); // str1[N-4]</span>
<span class="line-removed">-         orr(ch2, ch1, ch2, LSL, 16);</span>
<span class="line-removed">-         orr(tmp6, tmp6, tmp3, LSL, 48);</span>
<span class="line-removed">-         orr(tmp6, tmp6, ch2, LSL, 16);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     BIND(BMLOOPSTR2);</span>
<span class="line-removed">-       (this-&gt;*str2_load_1chr)(skipch, Address(str2, cnt1tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-       sub(cnt1tmp, cnt1tmp, firstStep); // cnt1tmp is positive here, because cnt1 &gt;= 8</span>
<span class="line-removed">-       if (str1_isL == str2_isL) {</span>
<span class="line-removed">-         // re-init tmp3. It&#39;s for free because it&#39;s executed in parallel with</span>
<span class="line-removed">-         // load above. Alternative is to initialize it before loop, but it&#39;ll</span>
<span class="line-removed">-         // affect performance on in-order systems with 2 or more ld/st pipelines</span>
<span class="line-removed">-         lsr(tmp3, tmp6, BitsPerByte * (wordSize - str1_chr_size));</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       if (!isL) { // UU/UL case</span>
<span class="line-removed">-         lsl(ch2, cnt1tmp, 1); // offset in bytes</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       cmp(tmp3, skipch);</span>
<span class="line-removed">-       br(NE, BMSKIP);</span>
<span class="line-removed">-       ldr(ch2, Address(str2, isL ? cnt1tmp : ch2));</span>
<span class="line-removed">-       mov(ch1, tmp6);</span>
<span class="line-removed">-       if (isL) {</span>
<span class="line-removed">-         b(BMLOOPSTR1_AFTER_LOAD);</span>
<span class="line-removed">-       } else {</span>
<span class="line-removed">-         sub(cnt1tmp, cnt1tmp, 1); // no need to branch for UU/UL case. cnt1 &gt;= 8</span>
<span class="line-removed">-         b(BMLOOPSTR1_CMP);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     BIND(BMLOOPSTR1);</span>
<span class="line-removed">-       (this-&gt;*str1_load_1chr)(ch1, Address(str1, cnt1tmp, Address::lsl(str1_chr_shift)));</span>
<span class="line-removed">-       (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt1tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-     BIND(BMLOOPSTR1_AFTER_LOAD);</span>
<span class="line-removed">-       subs(cnt1tmp, cnt1tmp, 1);</span>
<span class="line-removed">-       br(LT, BMLOOPSTR1_LASTCMP);</span>
<span class="line-removed">-     BIND(BMLOOPSTR1_CMP);</span>
<span class="line-removed">-       cmp(ch1, ch2);</span>
<span class="line-removed">-       br(EQ, BMLOOPSTR1);</span>
<span class="line-removed">-     BIND(BMSKIP);</span>
<span class="line-removed">-       if (!isL) {</span>
<span class="line-removed">-         // if we&#39;ve met UTF symbol while searching Latin1 pattern, then we can</span>
<span class="line-removed">-         // skip cnt1 symbols</span>
<span class="line-removed">-         if (str1_isL != str2_isL) {</span>
<span class="line-removed">-           mov(result_tmp, cnt1);</span>
<span class="line-removed">-         } else {</span>
<span class="line-removed">-           mov(result_tmp, 1);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         subs(zr, skipch, ASIZE);</span>
<span class="line-removed">-         br(HS, BMADV);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-       ldrb(result_tmp, Address(sp, skipch)); // load skip distance</span>
<span class="line-removed">-     BIND(BMADV);</span>
<span class="line-removed">-       sub(cnt1tmp, cnt1, 1);</span>
<span class="line-removed">-       add(str2, str2, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">-       cmp(str2, str2end);</span>
<span class="line-removed">-       br(LE, BMLOOPSTR2);</span>
<span class="line-removed">-       add(sp, sp, ASIZE);</span>
<span class="line-removed">-       b(NOMATCH);</span>
<span class="line-removed">-     BIND(BMLOOPSTR1_LASTCMP);</span>
<span class="line-removed">-       cmp(ch1, ch2);</span>
<span class="line-removed">-       br(NE, BMSKIP);</span>
<span class="line-removed">-     BIND(BMMATCH);</span>
<span class="line-removed">-       sub(result, str2, tmp5);</span>
<span class="line-removed">-       if (!str2_isL) lsr(result, result, 1);</span>
<span class="line-removed">-       add(sp, sp, ASIZE);</span>
<span class="line-removed">-       b(DONE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     BIND(LINEARSTUB);</span>
<span class="line-removed">-     cmp(cnt1, (u1)16); // small patterns still should be handled by simple algorithm</span>
<span class="line-removed">-     br(LT, LINEAR_MEDIUM);</span>
<span class="line-removed">-     mov(result, zr);</span>
<span class="line-removed">-     RuntimeAddress stub = NULL;</span>
<span class="line-removed">-     if (isL) {</span>
<span class="line-removed">-       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_ll());</span>
<span class="line-removed">-       assert(stub.target() != NULL, &quot;string_indexof_linear_ll stub has not been generated&quot;);</span>
<span class="line-removed">-     } else if (str1_isL) {</span>
<span class="line-removed">-       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_ul());</span>
<span class="line-removed">-        assert(stub.target() != NULL, &quot;string_indexof_linear_ul stub has not been generated&quot;);</span>
<span class="line-removed">-     } else {</span>
<span class="line-removed">-       stub = RuntimeAddress(StubRoutines::aarch64::string_indexof_linear_uu());</span>
<span class="line-removed">-       assert(stub.target() != NULL, &quot;string_indexof_linear_uu stub has not been generated&quot;);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     trampoline_call(stub);</span>
<span class="line-removed">-     b(DONE);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BIND(LINEARSEARCH);</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     Label DO1, DO2, DO3;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     Register str2tmp = tmp2;</span>
<span class="line-removed">-     Register first = tmp3;</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (icnt1 == -1)</span>
<span class="line-removed">-     {</span>
<span class="line-removed">-         Label DOSHORT, FIRST_LOOP, STR2_NEXT, STR1_LOOP, STR1_NEXT;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         cmp(cnt1, u1(str1_isL == str2_isL ? 4 : 2));</span>
<span class="line-removed">-         br(LT, DOSHORT);</span>
<span class="line-removed">-       BIND(LINEAR_MEDIUM);</span>
<span class="line-removed">-         (this-&gt;*str1_load_1chr)(first, Address(str1));</span>
<span class="line-removed">-         lea(str1, Address(str1, cnt1, Address::lsl(str1_chr_shift)));</span>
<span class="line-removed">-         sub(cnt1_neg, zr, cnt1, LSL, str1_chr_shift);</span>
<span class="line-removed">-         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(FIRST_LOOP);</span>
<span class="line-removed">-         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">-         cmp(first, ch2);</span>
<span class="line-removed">-         br(EQ, STR1_LOOP);</span>
<span class="line-removed">-       BIND(STR2_NEXT);</span>
<span class="line-removed">-         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">-         br(LE, FIRST_LOOP);</span>
<span class="line-removed">-         b(NOMATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(STR1_LOOP);</span>
<span class="line-removed">-         adds(cnt1tmp, cnt1_neg, str1_chr_size);</span>
<span class="line-removed">-         add(cnt2tmp, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">-         br(GE, MATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(STR1_NEXT);</span>
<span class="line-removed">-         (this-&gt;*str1_load_1chr)(ch1, Address(str1, cnt1tmp));</span>
<span class="line-removed">-         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2tmp));</span>
<span class="line-removed">-         cmp(ch1, ch2);</span>
<span class="line-removed">-         br(NE, STR2_NEXT);</span>
<span class="line-removed">-         adds(cnt1tmp, cnt1tmp, str1_chr_size);</span>
<span class="line-removed">-         add(cnt2tmp, cnt2tmp, str2_chr_size);</span>
<span class="line-removed">-         br(LT, STR1_NEXT);</span>
<span class="line-removed">-         b(MATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(DOSHORT);</span>
<span class="line-removed">-       if (str1_isL == str2_isL) {</span>
<span class="line-removed">-         cmp(cnt1, (u1)2);</span>
<span class="line-removed">-         br(LT, DO1);</span>
<span class="line-removed">-         br(GT, DO3);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (icnt1 == 4) {</span>
<span class="line-removed">-       Label CH1_LOOP;</span>
<span class="line-removed">- </span>
<span class="line-removed">-         (this-&gt;*load_4chr)(ch1, str1);</span>
<span class="line-removed">-         sub(result_tmp, cnt2, 4);</span>
<span class="line-removed">-         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(CH1_LOOP);</span>
<span class="line-removed">-         (this-&gt;*load_4chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">-         cmp(ch1, ch2);</span>
<span class="line-removed">-         br(EQ, MATCH);</span>
<span class="line-removed">-         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">-         br(LE, CH1_LOOP);</span>
<span class="line-removed">-         b(NOMATCH);</span>
<span class="line-removed">-       }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if ((icnt1 == -1 &amp;&amp; str1_isL == str2_isL) || icnt1 == 2) {</span>
<span class="line-removed">-       Label CH1_LOOP;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(DO2);</span>
<span class="line-removed">-         (this-&gt;*load_2chr)(ch1, str1);</span>
<span class="line-removed">-         if (icnt1 == 2) {</span>
<span class="line-removed">-           sub(result_tmp, cnt2, 2);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">-       BIND(CH1_LOOP);</span>
<span class="line-removed">-         (this-&gt;*load_2chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">-         cmp(ch1, ch2);</span>
<span class="line-removed">-         br(EQ, MATCH);</span>
<span class="line-removed">-         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">-         br(LE, CH1_LOOP);</span>
<span class="line-removed">-         b(NOMATCH);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if ((icnt1 == -1 &amp;&amp; str1_isL == str2_isL) || icnt1 == 3) {</span>
<span class="line-removed">-       Label FIRST_LOOP, STR2_NEXT, STR1_LOOP;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(DO3);</span>
<span class="line-removed">-         (this-&gt;*load_2chr)(first, str1);</span>
<span class="line-removed">-         (this-&gt;*str1_load_1chr)(ch1, Address(str1, 2*str1_chr_size));</span>
<span class="line-removed">-         if (icnt1 == 3) {</span>
<span class="line-removed">-           sub(result_tmp, cnt2, 3);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">-       BIND(FIRST_LOOP);</span>
<span class="line-removed">-         (this-&gt;*load_2chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">-         cmpw(first, ch2);</span>
<span class="line-removed">-         br(EQ, STR1_LOOP);</span>
<span class="line-removed">-       BIND(STR2_NEXT);</span>
<span class="line-removed">-         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">-         br(LE, FIRST_LOOP);</span>
<span class="line-removed">-         b(NOMATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(STR1_LOOP);</span>
<span class="line-removed">-         add(cnt2tmp, cnt2_neg, 2*str2_chr_size);</span>
<span class="line-removed">-         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2tmp));</span>
<span class="line-removed">-         cmp(ch1, ch2);</span>
<span class="line-removed">-         br(NE, STR2_NEXT);</span>
<span class="line-removed">-         b(MATCH);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">- </span>
<span class="line-removed">-     if (icnt1 == -1 || icnt1 == 1) {</span>
<span class="line-removed">-       Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP;</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(DO1);</span>
<span class="line-removed">-         (this-&gt;*str1_load_1chr)(ch1, str1);</span>
<span class="line-removed">-         cmp(cnt2, (u1)8);</span>
<span class="line-removed">-         br(LT, DO1_SHORT);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         sub(result_tmp, cnt2, 8/str2_chr_size);</span>
<span class="line-removed">-         sub(cnt2_neg, zr, result_tmp, LSL, str2_chr_shift);</span>
<span class="line-removed">-         mov(tmp3, str2_isL ? 0x0101010101010101 : 0x0001000100010001);</span>
<span class="line-removed">-         lea(str2, Address(str2, result_tmp, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">- </span>
<span class="line-removed">-         if (str2_isL) {</span>
<span class="line-removed">-           orr(ch1, ch1, ch1, LSL, 8);</span>
<span class="line-removed">-         }</span>
<span class="line-removed">-         orr(ch1, ch1, ch1, LSL, 16);</span>
<span class="line-removed">-         orr(ch1, ch1, ch1, LSL, 32);</span>
<span class="line-removed">-       BIND(CH1_LOOP);</span>
<span class="line-removed">-         ldr(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">-         eor(ch2, ch1, ch2);</span>
<span class="line-removed">-         sub(tmp1, ch2, tmp3);</span>
<span class="line-removed">-         orr(tmp2, ch2, str2_isL ? 0x7f7f7f7f7f7f7f7f : 0x7fff7fff7fff7fff);</span>
<span class="line-removed">-         bics(tmp1, tmp1, tmp2);</span>
<span class="line-removed">-         br(NE, HAS_ZERO);</span>
<span class="line-removed">-         adds(cnt2_neg, cnt2_neg, 8);</span>
<span class="line-removed">-         br(LT, CH1_LOOP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-         cmp(cnt2_neg, (u1)8);</span>
<span class="line-removed">-         mov(cnt2_neg, 0);</span>
<span class="line-removed">-         br(LT, CH1_LOOP);</span>
<span class="line-removed">-         b(NOMATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(HAS_ZERO);</span>
<span class="line-removed">-         rev(tmp1, tmp1);</span>
<span class="line-removed">-         clz(tmp1, tmp1);</span>
<span class="line-removed">-         add(cnt2_neg, cnt2_neg, tmp1, LSR, 3);</span>
<span class="line-removed">-         b(MATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-       BIND(DO1_SHORT);</span>
<span class="line-removed">-         mov(result_tmp, cnt2);</span>
<span class="line-removed">-         lea(str2, Address(str2, cnt2, Address::lsl(str2_chr_shift)));</span>
<span class="line-removed">-         sub(cnt2_neg, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">-       BIND(DO1_LOOP);</span>
<span class="line-removed">-         (this-&gt;*str2_load_1chr)(ch2, Address(str2, cnt2_neg));</span>
<span class="line-removed">-         cmpw(ch1, ch2);</span>
<span class="line-removed">-         br(EQ, MATCH);</span>
<span class="line-removed">-         adds(cnt2_neg, cnt2_neg, str2_chr_size);</span>
<span class="line-removed">-         br(LT, DO1_LOOP);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-   }</span>
<span class="line-removed">-   BIND(NOMATCH);</span>
<span class="line-removed">-     mov(result, -1);</span>
<span class="line-removed">-     b(DONE);</span>
<span class="line-removed">-   BIND(MATCH);</span>
<span class="line-removed">-     add(result, result_tmp, cnt2_neg, ASR, str2_chr_shift);</span>
<span class="line-removed">-   BIND(DONE);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- typedef void (MacroAssembler::* chr_insn)(Register Rt, const Address &amp;adr);</span>
<span class="line-removed">- typedef void (MacroAssembler::* uxt_insn)(Register Rd, Register Rn);</span>
<span class="line-removed">- </span>
<span class="line-removed">- void MacroAssembler::string_indexof_char(Register str1, Register cnt1,</span>
<span class="line-removed">-                                          Register ch, Register result,</span>
<span class="line-removed">-                                          Register tmp1, Register tmp2, Register tmp3)</span>
<span class="line-removed">- {</span>
<span class="line-removed">-   Label CH1_LOOP, HAS_ZERO, DO1_SHORT, DO1_LOOP, MATCH, NOMATCH, DONE;</span>
<span class="line-removed">-   Register cnt1_neg = cnt1;</span>
<span class="line-removed">-   Register ch1 = rscratch1;</span>
<span class="line-removed">-   Register result_tmp = rscratch2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   cbz(cnt1, NOMATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   cmp(cnt1, (u1)4);</span>
<span class="line-removed">-   br(LT, DO1_SHORT);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   orr(ch, ch, ch, LSL, 16);</span>
<span class="line-removed">-   orr(ch, ch, ch, LSL, 32);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   sub(cnt1, cnt1, 4);</span>
<span class="line-removed">-   mov(result_tmp, cnt1);</span>
<span class="line-removed">-   lea(str1, Address(str1, cnt1, Address::uxtw(1)));</span>
<span class="line-removed">-   sub(cnt1_neg, zr, cnt1, LSL, 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   mov(tmp3, 0x0001000100010001);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BIND(CH1_LOOP);</span>
<span class="line-removed">-     ldr(ch1, Address(str1, cnt1_neg));</span>
<span class="line-removed">-     eor(ch1, ch, ch1);</span>
<span class="line-removed">-     sub(tmp1, ch1, tmp3);</span>
<span class="line-removed">-     orr(tmp2, ch1, 0x7fff7fff7fff7fff);</span>
<span class="line-removed">-     bics(tmp1, tmp1, tmp2);</span>
<span class="line-removed">-     br(NE, HAS_ZERO);</span>
<span class="line-removed">-     adds(cnt1_neg, cnt1_neg, 8);</span>
<span class="line-removed">-     br(LT, CH1_LOOP);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     cmp(cnt1_neg, (u1)8);</span>
<span class="line-removed">-     mov(cnt1_neg, 0);</span>
<span class="line-removed">-     br(LT, CH1_LOOP);</span>
<span class="line-removed">-     b(NOMATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BIND(HAS_ZERO);</span>
<span class="line-removed">-     rev(tmp1, tmp1);</span>
<span class="line-removed">-     clz(tmp1, tmp1);</span>
<span class="line-removed">-     add(cnt1_neg, cnt1_neg, tmp1, LSR, 3);</span>
<span class="line-removed">-     b(MATCH);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BIND(DO1_SHORT);</span>
<span class="line-removed">-     mov(result_tmp, cnt1);</span>
<span class="line-removed">-     lea(str1, Address(str1, cnt1, Address::uxtw(1)));</span>
<span class="line-removed">-     sub(cnt1_neg, zr, cnt1, LSL, 1);</span>
<span class="line-removed">-   BIND(DO1_LOOP);</span>
<span class="line-removed">-     ldrh(ch1, Address(str1, cnt1_neg));</span>
<span class="line-removed">-     cmpw(ch, ch1);</span>
<span class="line-removed">-     br(EQ, MATCH);</span>
<span class="line-removed">-     adds(cnt1_neg, cnt1_neg, 2);</span>
<span class="line-removed">-     br(LT, DO1_LOOP);</span>
<span class="line-removed">-   BIND(NOMATCH);</span>
<span class="line-removed">-     mov(result, -1);</span>
<span class="line-removed">-     b(DONE);</span>
<span class="line-removed">-   BIND(MATCH);</span>
<span class="line-removed">-     add(result, result_tmp, cnt1_neg, ASR, 1);</span>
<span class="line-removed">-   BIND(DONE);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- </span>
<span class="line-removed">- // Compare strings.</span>
<span class="line-removed">- void MacroAssembler::string_compare(Register str1, Register str2,</span>
<span class="line-removed">-     Register cnt1, Register cnt2, Register result, Register tmp1, Register tmp2,</span>
<span class="line-removed">-     FloatRegister vtmp1, FloatRegister vtmp2, FloatRegister vtmp3, int ae) {</span>
<span class="line-removed">-   Label DONE, SHORT_LOOP, SHORT_STRING, SHORT_LAST, TAIL, STUB,</span>
<span class="line-removed">-       DIFFERENCE, NEXT_WORD, SHORT_LOOP_TAIL, SHORT_LAST2, SHORT_LAST_INIT,</span>
<span class="line-removed">-       SHORT_LOOP_START, TAIL_CHECK;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool isLL = ae == StrIntrinsicNode::LL;</span>
<span class="line-removed">-   bool isLU = ae == StrIntrinsicNode::LU;</span>
<span class="line-removed">-   bool isUL = ae == StrIntrinsicNode::UL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // The stub threshold for LL strings is: 72 (64 + 8) chars</span>
<span class="line-removed">-   // UU: 36 chars, or 72 bytes (valid for the 64-byte large loop with prefetch)</span>
<span class="line-removed">-   // LU/UL: 24 chars, or 48 bytes (valid for the 16-character loop at least)</span>
<span class="line-removed">-   const u1 stub_threshold = isLL ? 72 : ((isLU || isUL) ? 24 : 36);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bool str1_isL = isLL || isLU;</span>
<span class="line-removed">-   bool str2_isL = isLL || isUL;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   int str1_chr_shift = str1_isL ? 0 : 1;</span>
<span class="line-removed">-   int str2_chr_shift = str2_isL ? 0 : 1;</span>
<span class="line-removed">-   int str1_chr_size = str1_isL ? 1 : 2;</span>
<span class="line-removed">-   int str2_chr_size = str2_isL ? 1 : 2;</span>
<span class="line-removed">-   int minCharsInWord = isLL ? wordSize : wordSize/2;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   FloatRegister vtmpZ = vtmp1, vtmp = vtmp2;</span>
<span class="line-removed">-   chr_insn str1_load_chr = str1_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">-                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">-   chr_insn str2_load_chr = str2_isL ? (chr_insn)&amp;MacroAssembler::ldrb :</span>
<span class="line-removed">-                                       (chr_insn)&amp;MacroAssembler::ldrh;</span>
<span class="line-removed">-   uxt_insn ext_chr = isLL ? (uxt_insn)&amp;MacroAssembler::uxtbw :</span>
<span class="line-removed">-                             (uxt_insn)&amp;MacroAssembler::uxthw;</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BLOCK_COMMENT(&quot;string_compare {&quot;);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Bizzarely, the counts are passed in bytes, regardless of whether they</span>
<span class="line-removed">-   // are L or U strings, however the result is always in characters.</span>
<span class="line-removed">-   if (!str1_isL) asrw(cnt1, cnt1, 1);</span>
<span class="line-removed">-   if (!str2_isL) asrw(cnt2, cnt2, 1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Compute the minimum of the string lengths and save the difference.</span>
<span class="line-removed">-   subsw(result, cnt1, cnt2);</span>
<span class="line-removed">-   cselw(cnt2, cnt1, cnt2, Assembler::LE); // min</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // A very short string</span>
<span class="line-removed">-   cmpw(cnt2, minCharsInWord);</span>
<span class="line-removed">-   br(Assembler::LE, SHORT_STRING);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   // Compare longwords</span>
<span class="line-removed">-   // load first parts of strings and finish initialization while loading</span>
<span class="line-removed">-   {</span>
<span class="line-removed">-     if (str1_isL == str2_isL) { // LL or UU</span>
<span class="line-removed">-       ldr(tmp1, Address(str1));</span>
<span class="line-removed">-       cmp(str1, str2);</span>
<span class="line-removed">-       br(Assembler::EQ, DONE);</span>
<span class="line-removed">-       ldr(tmp2, Address(str2));</span>
<span class="line-removed">-       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">-       br(GE, STUB);</span>
<span class="line-removed">-       subsw(cnt2, cnt2, minCharsInWord);</span>
<span class="line-removed">-       br(EQ, TAIL_CHECK);</span>
<span class="line-removed">-       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">-       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">-       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">-     } else if (isLU) {</span>
<span class="line-removed">-       ldrs(vtmp, Address(str1));</span>
<span class="line-removed">-       ldr(tmp2, Address(str2));</span>
<span class="line-removed">-       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">-       br(GE, STUB);</span>
<span class="line-removed">-       subw(cnt2, cnt2, 4);</span>
<span class="line-removed">-       eor(vtmpZ, T16B, vtmpZ, vtmpZ);</span>
<span class="line-removed">-       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">-       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">-       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">-       sub(cnt1, zr, cnt2, LSL, str1_chr_shift);</span>
<span class="line-removed">-       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">-       add(cnt1, cnt1, 4);</span>
<span class="line-removed">-       fmovd(tmp1, vtmp);</span>
<span class="line-removed">-     } else { // UL case</span>
<span class="line-removed">-       ldr(tmp1, Address(str1));</span>
<span class="line-removed">-       ldrs(vtmp, Address(str2));</span>
<span class="line-removed">-       cmp(cnt2, stub_threshold);</span>
<span class="line-removed">-       br(GE, STUB);</span>
<span class="line-removed">-       subw(cnt2, cnt2, 4);</span>
<span class="line-removed">-       lea(str1, Address(str1, cnt2, Address::uxtw(str1_chr_shift)));</span>
<span class="line-removed">-       eor(vtmpZ, T16B, vtmpZ, vtmpZ);</span>
<span class="line-removed">-       lea(str2, Address(str2, cnt2, Address::uxtw(str2_chr_shift)));</span>
<span class="line-removed">-       sub(cnt1, zr, cnt2, LSL, str1_chr_shift);</span>
<span class="line-removed">-       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">-       sub(cnt2, zr, cnt2, LSL, str2_chr_shift);</span>
<span class="line-removed">-       add(cnt1, cnt1, 8);</span>
<span class="line-removed">-       fmovd(tmp2, vtmp);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     adds(cnt2, cnt2, isUL ? 4 : 8);</span>
<span class="line-removed">-     br(GE, TAIL);</span>
<span class="line-removed">-     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">-     cbnz(rscratch2, DIFFERENCE);</span>
<span class="line-removed">-     // main loop</span>
<span class="line-removed">-     bind(NEXT_WORD);</span>
<span class="line-removed">-     if (str1_isL == str2_isL) {</span>
<span class="line-removed">-       ldr(tmp1, Address(str1, cnt2));</span>
<span class="line-removed">-       ldr(tmp2, Address(str2, cnt2));</span>
<span class="line-removed">-       adds(cnt2, cnt2, 8);</span>
<span class="line-removed">-     } else if (isLU) {</span>
<span class="line-removed">-       ldrs(vtmp, Address(str1, cnt1));</span>
<span class="line-removed">-       ldr(tmp2, Address(str2, cnt2));</span>
<span class="line-removed">-       add(cnt1, cnt1, 4);</span>
<span class="line-removed">-       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">-       fmovd(tmp1, vtmp);</span>
<span class="line-removed">-       adds(cnt2, cnt2, 8);</span>
<span class="line-removed">-     } else { // UL</span>
<span class="line-removed">-       ldrs(vtmp, Address(str2, cnt2));</span>
<span class="line-removed">-       ldr(tmp1, Address(str1, cnt1));</span>
<span class="line-removed">-       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">-       add(cnt1, cnt1, 8);</span>
<span class="line-removed">-       fmovd(tmp2, vtmp);</span>
<span class="line-removed">-       adds(cnt2, cnt2, 4);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     br(GE, TAIL);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">-     cbz(rscratch2, NEXT_WORD);</span>
<span class="line-removed">-     b(DIFFERENCE);</span>
<span class="line-removed">-     bind(TAIL);</span>
<span class="line-removed">-     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">-     cbnz(rscratch2, DIFFERENCE);</span>
<span class="line-removed">-     // Last longword.  In the case where length == 4 we compare the</span>
<span class="line-removed">-     // same longword twice, but that&#39;s still faster than another</span>
<span class="line-removed">-     // conditional branch.</span>
<span class="line-removed">-     if (str1_isL == str2_isL) {</span>
<span class="line-removed">-       ldr(tmp1, Address(str1));</span>
<span class="line-removed">-       ldr(tmp2, Address(str2));</span>
<span class="line-removed">-     } else if (isLU) {</span>
<span class="line-removed">-       ldrs(vtmp, Address(str1));</span>
<span class="line-removed">-       ldr(tmp2, Address(str2));</span>
<span class="line-removed">-       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">-       fmovd(tmp1, vtmp);</span>
<span class="line-removed">-     } else { // UL</span>
<span class="line-removed">-       ldrs(vtmp, Address(str2));</span>
<span class="line-removed">-       ldr(tmp1, Address(str1));</span>
<span class="line-removed">-       zip1(vtmp, T8B, vtmp, vtmpZ);</span>
<span class="line-removed">-       fmovd(tmp2, vtmp);</span>
<span class="line-removed">-     }</span>
<span class="line-removed">-     bind(TAIL_CHECK);</span>
<span class="line-removed">-     eor(rscratch2, tmp1, tmp2);</span>
<span class="line-removed">-     cbz(rscratch2, DONE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-     // Find the first different characters in the longwords and</span>
<span class="line-removed">-     // compute their difference.</span>
<span class="line-removed">-     bind(DIFFERENCE);</span>
<span class="line-removed">-     rev(rscratch2, rscratch2);</span>
<span class="line-removed">-     clz(rscratch2, rscratch2);</span>
<span class="line-removed">-     andr(rscratch2, rscratch2, isLL ? -8 : -16);</span>
<span class="line-removed">-     lsrv(tmp1, tmp1, rscratch2);</span>
<span class="line-removed">-     (this-&gt;*ext_chr)(tmp1, tmp1);</span>
<span class="line-removed">-     lsrv(tmp2, tmp2, rscratch2);</span>
<span class="line-removed">-     (this-&gt;*ext_chr)(tmp2, tmp2);</span>
<span class="line-removed">-     subw(result, tmp1, tmp2);</span>
<span class="line-removed">-     b(DONE);</span>
<span class="line-removed">-   }</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(STUB);</span>
<span class="line-removed">-     RuntimeAddress stub = NULL;</span>
<span class="line-removed">-     switch(ae) {</span>
<span class="line-removed">-       case StrIntrinsicNode::LL:</span>
<span class="line-removed">-         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_LL());</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       case StrIntrinsicNode::UU:</span>
<span class="line-removed">-         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_UU());</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       case StrIntrinsicNode::LU:</span>
<span class="line-removed">-         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_LU());</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       case StrIntrinsicNode::UL:</span>
<span class="line-removed">-         stub = RuntimeAddress(StubRoutines::aarch64::compare_long_string_UL());</span>
<span class="line-removed">-         break;</span>
<span class="line-removed">-       default:</span>
<span class="line-removed">-         ShouldNotReachHere();</span>
<span class="line-removed">-      }</span>
<span class="line-removed">-     assert(stub.target() != NULL, &quot;compare_long_string stub has not been generated&quot;);</span>
<span class="line-removed">-     trampoline_call(stub);</span>
<span class="line-removed">-     b(DONE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(SHORT_STRING);</span>
<span class="line-removed">-   // Is the minimum length zero?</span>
<span class="line-removed">-   cbz(cnt2, DONE);</span>
<span class="line-removed">-   // arrange code to do most branches while loading and loading next characters</span>
<span class="line-removed">-   // while comparing previous</span>
<span class="line-removed">-   (this-&gt;*str1_load_chr)(tmp1, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">-   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">-   br(EQ, SHORT_LAST_INIT);</span>
<span class="line-removed">-   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">-   b(SHORT_LOOP_START);</span>
<span class="line-removed">-   bind(SHORT_LOOP);</span>
<span class="line-removed">-   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">-   br(EQ, SHORT_LAST);</span>
<span class="line-removed">-   bind(SHORT_LOOP_START);</span>
<span class="line-removed">-   (this-&gt;*str1_load_chr)(tmp2, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">-   (this-&gt;*str2_load_chr)(rscratch1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">-   cmp(tmp1, cnt1);</span>
<span class="line-removed">-   br(NE, SHORT_LOOP_TAIL);</span>
<span class="line-removed">-   subs(cnt2, cnt2, 1);</span>
<span class="line-removed">-   br(EQ, SHORT_LAST2);</span>
<span class="line-removed">-   (this-&gt;*str1_load_chr)(tmp1, Address(post(str1, str1_chr_size)));</span>
<span class="line-removed">-   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">-   cmp(tmp2, rscratch1);</span>
<span class="line-removed">-   br(EQ, SHORT_LOOP);</span>
<span class="line-removed">-   sub(result, tmp2, rscratch1);</span>
<span class="line-removed">-   b(DONE);</span>
<span class="line-removed">-   bind(SHORT_LOOP_TAIL);</span>
<span class="line-removed">-   sub(result, tmp1, cnt1);</span>
<span class="line-removed">-   b(DONE);</span>
<span class="line-removed">-   bind(SHORT_LAST2);</span>
<span class="line-removed">-   cmp(tmp2, rscratch1);</span>
<span class="line-removed">-   br(EQ, DONE);</span>
<span class="line-removed">-   sub(result, tmp2, rscratch1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   b(DONE);</span>
<span class="line-removed">-   bind(SHORT_LAST_INIT);</span>
<span class="line-removed">-   (this-&gt;*str2_load_chr)(cnt1, Address(post(str2, str2_chr_size)));</span>
<span class="line-removed">-   bind(SHORT_LAST);</span>
<span class="line-removed">-   cmp(tmp1, cnt1);</span>
<span class="line-removed">-   br(EQ, DONE);</span>
<span class="line-removed">-   sub(result, tmp1, cnt1);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   bind(DONE);</span>
<span class="line-removed">- </span>
<span class="line-removed">-   BLOCK_COMMENT(&quot;} string_compare&quot;);</span>
<span class="line-removed">- }</span>
<span class="line-removed">- #endif // COMPILER2</span>
  
  // This method checks if provided byte array contains byte with highest bit set.
  void MacroAssembler::has_negatives(Register ary1, Register len, Register result) {
      // Simple and most common case of aligned small array which is not at the
      // end of memory page is placed here. All other cases are in stub.
<span class="line-new-header">--- 4392,10 ---</span>
</pre>
<center><a href="interp_masm_aarch64.hpp.cdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroAssembler_aarch64.hpp.cdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
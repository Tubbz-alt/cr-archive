diff a/src/hotspot/share/gc/shared/gcTimer.hpp b/src/hotspot/share/gc/shared/gcTimer.hpp
--- a/src/hotspot/share/gc/shared/gcTimer.hpp
+++ b/src/hotspot/share/gc/shared/gcTimer.hpp
@@ -89,28 +89,36 @@
   void clear();
 
   void push(int phase_index);
   int pop();
   int count() const;
+  int phase_index(int level) const;
 };
 
 class TimePartitions {
+  friend class TimePartitionsTest;
+
   static const int INITIAL_CAPACITY = 10;
 
   GrowableArray<GCPhase>* _phases;
   PhasesStack _active_phases;
 
   Tickspan _sum_of_pauses;
   Tickspan _longest_pause;
 
+  GCPhase::PhaseType current_phase_type() const;
+
+  void report_gc_phase_start(const char* name, const Ticks& time, GCPhase::PhaseType type);
+
  public:
   TimePartitions();
   ~TimePartitions();
   void clear();
 
-  void report_gc_phase_start(const char* name, const Ticks& time, GCPhase::PhaseType type=GCPhase::PausePhaseType);
-  void report_gc_phase_end(const Ticks& time, GCPhase::PhaseType type=GCPhase::PausePhaseType);
+  void report_gc_phase_start_top_level(const char* name, const Ticks& time, GCPhase::PhaseType type);
+  void report_gc_phase_start_sub_phase(const char* name, const Ticks& time);
+  void report_gc_phase_end(const Ticks& time);
 
   int num_phases() const;
   GCPhase* phase_at(int index) const;
 
   const Tickspan sum_of_pauses() const { return _sum_of_pauses; }
@@ -127,49 +135,40 @@
   virtual bool has_next() = 0;
   virtual GCPhase* next() = 0;
 };
 
 class GCTimer : public ResourceObj {
+  friend class GCTimerTest;
  protected:
   Ticks _gc_start;
   Ticks _gc_end;
   TimePartitions _time_partitions;
 
  public:
   virtual void register_gc_start(const Ticks& time = Ticks::now());
   virtual void register_gc_end(const Ticks& time = Ticks::now());
 
+  void register_gc_pause_start(const char* name, const Ticks& time = Ticks::now());
+  void register_gc_pause_end(const Ticks& time = Ticks::now());
+
   void register_gc_phase_start(const char* name, const Ticks& time);
   void register_gc_phase_end(const Ticks& time);
 
   const Ticks gc_start() const { return _gc_start; }
   const Ticks gc_end() const { return _gc_end; }
 
   TimePartitions* time_partitions() { return &_time_partitions; }
-
- protected:
-  void register_gc_pause_start(const char* name, const Ticks& time = Ticks::now());
-  void register_gc_pause_end(const Ticks& time = Ticks::now());
 };
 
 class STWGCTimer : public GCTimer {
  public:
   virtual void register_gc_start(const Ticks& time = Ticks::now());
   virtual void register_gc_end(const Ticks& time = Ticks::now());
 };
 
 class ConcurrentGCTimer : public GCTimer {
-  // ConcurrentGCTimer can't be used if there is an overlap between a pause phase and a concurrent phase.
-  // _is_concurrent_phase_active is used to find above case.
-  bool _is_concurrent_phase_active;
-
  public:
-  ConcurrentGCTimer(): GCTimer(), _is_concurrent_phase_active(false) {};
-
-  void register_gc_pause_start(const char* name, const Ticks& time = Ticks::now());
-  void register_gc_pause_end(const Ticks& time = Ticks::now());
-
   void register_gc_concurrent_start(const char* name, const Ticks& time = Ticks::now());
   void register_gc_concurrent_end(const Ticks& time = Ticks::now());
 };
 
 class TimePartitionPhasesIterator {

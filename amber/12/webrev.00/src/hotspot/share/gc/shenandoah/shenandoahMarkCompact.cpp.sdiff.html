<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahLock.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahMarkCompact.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  29 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  36 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;

  39 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  40 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;
<span class="line-removed">  42 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;</span>
  43 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/compressedOops.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;runtime/biasedLocking.hpp&quot;
  53 #include &quot;runtime/orderAccess.hpp&quot;
  54 #include &quot;runtime/thread.hpp&quot;
  55 #include &quot;utilities/copy.hpp&quot;
  56 #include &quot;utilities/growableArray.hpp&quot;
  57 #include &quot;gc/shared/workgroup.hpp&quot;
  58 
  59 ShenandoahMarkCompact::ShenandoahMarkCompact() :
  60   _gc_timer(NULL),
  61   _preserved_marks(new PreservedMarksSet(true)) {}
  62 
</pre>
<hr />
<pre>
  93 
  94   {
  95     ShenandoahGCPhase prepare_phase(ShenandoahPhaseTimings::full_gc_prepare);
  96     // Full GC is supposed to recover from any GC state:
  97 
  98     // a0. Remember if we have forwarded objects
  99     bool has_forwarded_objects = heap-&gt;has_forwarded_objects();
 100 
 101     // a1. Cancel evacuation, if in progress
 102     if (heap-&gt;is_evacuation_in_progress()) {
 103       heap-&gt;set_evacuation_in_progress(false);
 104     }
 105     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
 106 
 107     // a2. Cancel update-refs, if in progress
 108     if (heap-&gt;is_update_refs_in_progress()) {
 109       heap-&gt;set_update_refs_in_progress(false);
 110     }
 111     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
 112 
<span class="line-removed"> 113     // a3. Cancel concurrent traversal GC, if in progress</span>
<span class="line-removed"> 114     if (heap-&gt;is_concurrent_traversal_in_progress()) {</span>
<span class="line-removed"> 115       heap-&gt;traversal_gc()-&gt;reset();</span>
<span class="line-removed"> 116       heap-&gt;set_concurrent_traversal_in_progress(false);</span>
<span class="line-removed"> 117     }</span>
<span class="line-removed"> 118 </span>
 119     // b. Cancel concurrent mark, if in progress
 120     if (heap-&gt;is_concurrent_mark_in_progress()) {
 121       heap-&gt;concurrent_mark()-&gt;cancel();
 122       heap-&gt;set_concurrent_mark_in_progress(false);
 123     }
 124     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
 125 
 126     // c. Reset the bitmaps for new marking
 127     heap-&gt;reset_mark_bitmap();
 128     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
 129     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
 130 
 131     // d. Abandon reference discovery and clear all discovered references.
 132     ReferenceProcessor* rp = heap-&gt;ref_processor();
 133     rp-&gt;disable_discovery();
 134     rp-&gt;abandon_partial_discovery();
 135     rp-&gt;verify_no_references_recorded();
 136 
 137     // e. Set back forwarded objects bit back, in case some steps above dropped it.
 138     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
</pre>
<hr />
<pre>
 207   if (VerifyAfterGC) {
 208     Universe::verify();
 209   }
 210 
 211   {
 212     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
 213     heap-&gt;post_full_gc_dump(_gc_timer);
 214   }
 215 }
 216 
 217 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
 218 private:
 219   ShenandoahMarkingContext* const _ctx;
 220 
 221 public:
 222   ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
 223 
 224   void heap_region_do(ShenandoahHeapRegion *r) {
 225     _ctx-&gt;capture_top_at_mark_start(r);
 226     r-&gt;clear_live_data();
<span class="line-removed"> 227     r-&gt;set_concurrent_iteration_safe_limit(r-&gt;top());</span>
 228   }
 229 };
 230 
 231 void ShenandoahMarkCompact::phase1_mark_heap() {
 232   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 233   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 234 
 235   ShenandoahHeap* heap = ShenandoahHeap::heap();
 236 
 237   ShenandoahPrepareForMarkClosure cl;
 238   heap-&gt;heap_region_iterate(&amp;cl);
 239 
 240   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 241 
 242   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 243   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 244 
 245   ReferenceProcessor* rp = heap-&gt;ref_processor();
 246   // enable (&quot;weak&quot;) refs discovery
 247   rp-&gt;enable_discovery(true /*verify_no_refs*/);
</pre>
<hr />
<pre>
 316       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
 317       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
 318       _to_region = new_to_region;
 319       _compact_point = _to_region-&gt;bottom();
 320     }
 321 
 322     // Object fits into current region, record new location:
 323     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
 324     shenandoah_assert_not_forwarded(NULL, p);
 325     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());
 326     p-&gt;forward_to(oop(_compact_point));
 327     _compact_point += obj_size;
 328   }
 329 };
 330 
 331 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
 332 private:
 333   PreservedMarksSet*        const _preserved_marks;
 334   ShenandoahHeap*           const _heap;
 335   ShenandoahHeapRegionSet** const _worker_slices;
<span class="line-removed"> 336   ShenandoahRegionIterator        _heap_regions;</span>
<span class="line-removed"> 337 </span>
<span class="line-removed"> 338   ShenandoahHeapRegion* next_from_region(ShenandoahHeapRegionSet* slice) {</span>
<span class="line-removed"> 339     ShenandoahHeapRegion* from_region = _heap_regions.next();</span>
<span class="line-removed"> 340 </span>
<span class="line-removed"> 341     // Look for next candidate for this slice:</span>
<span class="line-removed"> 342     while (from_region != NULL) {</span>
<span class="line-removed"> 343       // Empty region: get it into the slice to defragment the slice itself.</span>
<span class="line-removed"> 344       // We could have skipped this without violating correctness, but we really</span>
<span class="line-removed"> 345       // want to compact all live regions to the start of the heap, which sometimes</span>
<span class="line-removed"> 346       // means moving them into the fully empty regions.</span>
<span class="line-removed"> 347       if (from_region-&gt;is_empty()) break;</span>
<span class="line-removed"> 348 </span>
<span class="line-removed"> 349       // Can move the region, and this is not the humongous region. Humongous</span>
<span class="line-removed"> 350       // moves are special cased here, because their moves are handled separately.</span>
<span class="line-removed"> 351       if (from_region-&gt;is_stw_move_allowed() &amp;&amp; !from_region-&gt;is_humongous()) break;</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353       from_region = _heap_regions.next();</span>
<span class="line-removed"> 354     }</span>
<span class="line-removed"> 355 </span>
<span class="line-removed"> 356     if (from_region != NULL) {</span>
<span class="line-removed"> 357       assert(slice != NULL, &quot;sanity&quot;);</span>
<span class="line-removed"> 358       assert(!from_region-&gt;is_humongous(), &quot;this path cannot handle humongous regions&quot;);</span>
<span class="line-removed"> 359       assert(from_region-&gt;is_empty() || from_region-&gt;is_stw_move_allowed(), &quot;only regions that can be moved in mark-compact&quot;);</span>
<span class="line-removed"> 360       slice-&gt;add_region(from_region);</span>
<span class="line-removed"> 361     }</span>
<span class="line-removed"> 362 </span>
<span class="line-removed"> 363     return from_region;</span>
<span class="line-removed"> 364   }</span>
 365 
 366 public:
<span class="line-modified"> 367   ShenandoahPrepareForCompactionTask(PreservedMarksSet* preserved_marks, ShenandoahHeapRegionSet** worker_slices) :</span>
 368     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
 369     _preserved_marks(preserved_marks),
 370     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
 371   }
 372 












 373   void work(uint worker_id) {
 374     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
<span class="line-modified"> 375     ShenandoahHeapRegion* from_region = next_from_region(slice);</span>

 376     // No work?
 377     if (from_region == NULL) {
<span class="line-modified"> 378       return;</span>
 379     }
 380 
 381     // Sliding compaction. Walk all regions in the slice, and compact them.
 382     // Remember empty regions and reuse them as needed.
 383     ResourceMark rm;

 384     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());

 385     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);

 386     while (from_region != NULL) {


 387       cl.set_from_region(from_region);
 388       if (from_region-&gt;has_live()) {
 389         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
 390       }
 391 
 392       // Compacted the region to somewhere else? From-region is empty then.
 393       if (!cl.is_compact_same_region()) {
 394         empty_regions.append(from_region);
 395       }
<span class="line-modified"> 396       from_region = next_from_region(slice);</span>
 397     }
 398     cl.finish_region();
 399 
 400     // Mark all remaining regions as empty
 401     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
 402       ShenandoahHeapRegion* r = empty_regions.at(pos);
 403       r-&gt;set_new_top(r-&gt;bottom());
 404     }
 405   }
 406 };
 407 
 408 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
 409   ShenandoahHeap* heap = ShenandoahHeap::heap();
 410 
 411   // Compute the new addresses for humongous objects. We need to do this after addresses
 412   // for regular objects are calculated, and we know what regions in heap suffix are
 413   // available for humongous moves.
 414   //
 415   // Scan the heap backwards, because we are compacting humongous regions towards the end.
 416   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
 417   // humongous start there.
 418   //
 419   // The complication is potential non-movable regions during the scan. If such region is
 420   // detected, then sliding restarts towards that non-movable region.
 421 
 422   size_t to_begin = heap-&gt;num_regions();
 423   size_t to_end = heap-&gt;num_regions();
 424 
 425   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {
 426     ShenandoahHeapRegion *r = heap-&gt;get_region(c - 1);
 427     if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
 428       // To-region candidate: record this, and continue scan
<span class="line-modified"> 429       to_begin = r-&gt;region_number();</span>
 430       continue;
 431     }
 432 
 433     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_stw_move_allowed()) {
 434       // From-region candidate: movable humongous region
 435       oop old_obj = oop(r-&gt;bottom());
 436       size_t words_size = old_obj-&gt;size();
 437       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
 438 
 439       size_t start = to_end - num_regions;
 440 
<span class="line-modified"> 441       if (start &gt;= to_begin &amp;&amp; start != r-&gt;region_number()) {</span>
 442         // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
 443         _preserved_marks-&gt;get(0)-&gt;push_if_necessary(old_obj, old_obj-&gt;mark_raw());
 444         old_obj-&gt;forward_to(oop(heap-&gt;get_region(start)-&gt;bottom()));
 445         to_end = start;
 446         continue;
 447       }
 448     }
 449 
 450     // Failed to fit. Scan starting from current region.
<span class="line-modified"> 451     to_begin = r-&gt;region_number();</span>
<span class="line-modified"> 452     to_end = r-&gt;region_number();</span>
 453   }
 454 }
 455 
 456 class ShenandoahEnsureHeapActiveClosure: public ShenandoahHeapRegionClosure {
 457 private:
 458   ShenandoahHeap* const _heap;
 459 
 460 public:
 461   ShenandoahEnsureHeapActiveClosure() : _heap(ShenandoahHeap::heap()) {}
 462   void heap_region_do(ShenandoahHeapRegion* r) {
 463     if (r-&gt;is_trash()) {
 464       r-&gt;recycle();
 465     }
 466     if (r-&gt;is_cset()) {
 467       r-&gt;make_regular_bypass();
 468     }
 469     if (r-&gt;is_empty_uncommitted()) {
 470       r-&gt;make_committed_bypass();
 471     }
<span class="line-modified"> 472     assert (r-&gt;is_committed(), &quot;only committed regions in heap now, see region &quot; SIZE_FORMAT, r-&gt;region_number());</span>
 473 
 474     // Record current region occupancy: this communicates empty regions are free
 475     // to the rest of Full GC code.
 476     r-&gt;set_new_top(r-&gt;top());
 477   }
 478 };
 479 
 480 class ShenandoahTrashImmediateGarbageClosure: public ShenandoahHeapRegionClosure {
 481 private:
 482   ShenandoahHeap* const _heap;
 483   ShenandoahMarkingContext* const _ctx;
 484 
 485 public:
 486   ShenandoahTrashImmediateGarbageClosure() :
 487     _heap(ShenandoahHeap::heap()),
 488     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
 489 
 490   void heap_region_do(ShenandoahHeapRegion* r) {
 491     if (r-&gt;is_humongous_start()) {
 492       oop humongous_obj = oop(r-&gt;bottom());
 493       if (!_ctx-&gt;is_marked(humongous_obj)) {
 494         assert(!r-&gt;has_live(),
<span class="line-modified"> 495                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;region_number());</span>
 496         _heap-&gt;trash_humongous_region_at(r);
 497       } else {
 498         assert(r-&gt;has_live(),
<span class="line-modified"> 499                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());</span>
 500       }
 501     } else if (r-&gt;is_humongous_continuation()) {
 502       // If we hit continuation, the non-live humongous starts should have been trashed already
 503       assert(r-&gt;humongous_start_region()-&gt;has_live(),
<span class="line-modified"> 504              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;region_number());</span>
 505     } else if (r-&gt;is_regular()) {
 506       if (!r-&gt;has_live()) {
 507         r-&gt;make_trash_immediate();
 508       }
 509     }
 510   }
 511 };
 512 














































































































































 513 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
 514   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
 515   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
 516 
 517   ShenandoahHeap* heap = ShenandoahHeap::heap();
 518 
 519   // About to figure out which regions can be compacted, make sure pinning status
 520   // had been updated in GC prologue.
 521   heap-&gt;assert_pinned_region_status();
 522 
 523   {
 524     // Trash the immediately collectible regions before computing addresses
 525     ShenandoahTrashImmediateGarbageClosure tigcl;
 526     heap-&gt;heap_region_iterate(&amp;tigcl);
 527 
 528     // Make sure regions are in good state: committed, active, clean.
 529     // This is needed because we are potentially sliding the data through them.
 530     ShenandoahEnsureHeapActiveClosure ecl;
 531     heap-&gt;heap_region_iterate(&amp;ecl);
 532   }
 533 
 534   // Compute the new addresses for regular objects
 535   {
 536     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified"> 537     ShenandoahPrepareForCompactionTask prepare_task(_preserved_marks, worker_slices);</span>
<span class="line-modified"> 538     heap-&gt;workers()-&gt;run_task(&amp;prepare_task);</span>



 539   }
 540 
 541   // Compute the new addresses for humongous objects
 542   {
 543     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
 544     calculate_target_humongous_objects();
 545   }
 546 }
 547 
 548 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
 549 private:
 550   ShenandoahHeap* const _heap;
 551   ShenandoahMarkingContext* const _ctx;
 552 
 553   template &lt;class T&gt;
 554   inline void do_oop_work(T* p) {
 555     T o = RawAccess&lt;&gt;::oop_load(p);
 556     if (!CompressedOops::is_null(o)) {
 557       oop obj = CompressedOops::decode_not_null(o);
 558       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
</pre>
<hr />
<pre>
 725 
 726     size_t live = r-&gt;used();
 727 
 728     // Make empty regions that have been allocated into regular
 729     if (r-&gt;is_empty() &amp;&amp; live &gt; 0) {
 730       r-&gt;make_regular_bypass();
 731     }
 732 
 733     // Reclaim regular regions that became empty
 734     if (r-&gt;is_regular() &amp;&amp; live == 0) {
 735       r-&gt;make_trash();
 736     }
 737 
 738     // Recycle all trash regions
 739     if (r-&gt;is_trash()) {
 740       live = 0;
 741       r-&gt;recycle();
 742     }
 743 
 744     r-&gt;set_live_data(live);
<span class="line-modified"> 745     r-&gt;reset_alloc_metadata_to_shared();</span>
 746     _live += live;
 747   }
 748 
 749   size_t get_live() {
 750     return _live;
 751   }
 752 };
 753 
 754 void ShenandoahMarkCompact::compact_humongous_objects() {
 755   // Compact humongous regions, based on their fwdptr objects.
 756   //
 757   // This code is serial, because doing the in-slice parallel sliding is tricky. In most cases,
 758   // humongous regions are already compacted, and do not require further moves, which alleviates
 759   // sliding costs. We may consider doing this in parallel in future.
 760 
 761   ShenandoahHeap* heap = ShenandoahHeap::heap();
 762 
 763   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {
 764     ShenandoahHeapRegion* r = heap-&gt;get_region(c - 1);
 765     if (r-&gt;is_humongous_start()) {
 766       oop old_obj = oop(r-&gt;bottom());
 767       if (!old_obj-&gt;is_forwarded()) {
 768         // No need to move the object, it stays at the same slot
 769         continue;
 770       }
 771       size_t words_size = old_obj-&gt;size();
 772       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
 773 
<span class="line-modified"> 774       size_t old_start = r-&gt;region_number();</span>
 775       size_t old_end   = old_start + num_regions - 1;
 776       size_t new_start = heap-&gt;heap_region_index_containing(old_obj-&gt;forwardee());
 777       size_t new_end   = new_start + num_regions - 1;
 778       assert(old_start != new_start, &quot;must be real move&quot;);
<span class="line-modified"> 779       assert(r-&gt;is_stw_move_allowed(), &quot;Region &quot; SIZE_FORMAT &quot; should be movable&quot;, r-&gt;region_number());</span>
 780 
 781       Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
 782                                    heap-&gt;get_region(new_start)-&gt;bottom(),
 783                                    ShenandoahHeapRegion::region_size_words()*num_regions);
 784 
 785       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom());
 786       new_obj-&gt;init_mark_raw();
 787 
 788       {
 789         for (size_t c = old_start; c &lt;= old_end; c++) {
 790           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 791           r-&gt;make_regular_bypass();
 792           r-&gt;set_top(r-&gt;bottom());
 793         }
 794 
 795         for (size_t c = new_start; c &lt;= new_end; c++) {
 796           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 797           if (c == new_start) {
 798             r-&gt;make_humongous_start_bypass();
 799           } else {
 800             r-&gt;make_humongous_cont_bypass();
 801           }
 802 
 803           // Trailing region may be non-full, record the remainder there
 804           size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
 805           if ((c == new_end) &amp;&amp; (remainder != 0)) {
 806             r-&gt;set_top(r-&gt;bottom() + remainder);
 807           } else {
 808             r-&gt;set_top(r-&gt;end());
 809           }
 810 
<span class="line-modified"> 811           r-&gt;reset_alloc_metadata_to_shared();</span>
 812         }
 813       }
 814     }
 815   }
 816 }
 817 
 818 // This is slightly different to ShHeap::reset_next_mark_bitmap:
 819 // we need to remain able to walk pinned regions.
 820 // Since pinned region do not move and don&#39;t get compacted, we will get holes with
 821 // unreachable objects in them (which may have pointers to unloaded Klasses and thus
 822 // cannot be iterated over using oop-&gt;size(). The only way to safely iterate over those is using
 823 // a valid marking bitmap and valid TAMS pointer. This class only resets marking
 824 // bitmaps for un-pinned regions, and later we only reset TAMS for unpinned regions.
 825 class ShenandoahMCResetCompleteBitmapTask : public AbstractGangTask {
 826 private:
 827   ShenandoahRegionIterator _regions;
 828 
 829 public:
 830   ShenandoahMCResetCompleteBitmapTask() :
 831     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {
</pre>
</td>
<td>
<hr />
<pre>
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &quot;code/codeCache.hpp&quot;
  28 #include &quot;gc/shared/gcTraceTime.inline.hpp&quot;
  29 #include &quot;gc/shared/preservedMarks.inline.hpp&quot;
  30 #include &quot;gc/shenandoah/shenandoahForwarding.inline.hpp&quot;
  31 #include &quot;gc/shenandoah/shenandoahConcurrentMark.inline.hpp&quot;
  32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
  33 #include &quot;gc/shenandoah/shenandoahCollectionSet.hpp&quot;
  34 #include &quot;gc/shenandoah/shenandoahFreeSet.hpp&quot;
  35 #include &quot;gc/shenandoah/shenandoahPhaseTimings.hpp&quot;
  36 #include &quot;gc/shenandoah/shenandoahMarkCompact.hpp&quot;
  37 #include &quot;gc/shenandoah/shenandoahHeapRegionSet.hpp&quot;
  38 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
<span class="line-added">  39 #include &quot;gc/shenandoah/shenandoahHeapRegion.inline.hpp&quot;</span>
  40 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
  41 #include &quot;gc/shenandoah/shenandoahMarkingContext.inline.hpp&quot;
  42 #include &quot;gc/shenandoah/shenandoahRootProcessor.inline.hpp&quot;

  43 #include &quot;gc/shenandoah/shenandoahTaskqueue.inline.hpp&quot;
  44 #include &quot;gc/shenandoah/shenandoahUtils.hpp&quot;
  45 #include &quot;gc/shenandoah/shenandoahVerifier.hpp&quot;
  46 #include &quot;gc/shenandoah/shenandoahVMOperations.hpp&quot;
  47 #include &quot;gc/shenandoah/shenandoahWorkerPolicy.hpp&quot;
  48 #include &quot;memory/metaspace.hpp&quot;
  49 #include &quot;memory/universe.hpp&quot;
  50 #include &quot;oops/compressedOops.inline.hpp&quot;
  51 #include &quot;oops/oop.inline.hpp&quot;
  52 #include &quot;runtime/biasedLocking.hpp&quot;
  53 #include &quot;runtime/orderAccess.hpp&quot;
  54 #include &quot;runtime/thread.hpp&quot;
  55 #include &quot;utilities/copy.hpp&quot;
  56 #include &quot;utilities/growableArray.hpp&quot;
  57 #include &quot;gc/shared/workgroup.hpp&quot;
  58 
  59 ShenandoahMarkCompact::ShenandoahMarkCompact() :
  60   _gc_timer(NULL),
  61   _preserved_marks(new PreservedMarksSet(true)) {}
  62 
</pre>
<hr />
<pre>
  93 
  94   {
  95     ShenandoahGCPhase prepare_phase(ShenandoahPhaseTimings::full_gc_prepare);
  96     // Full GC is supposed to recover from any GC state:
  97 
  98     // a0. Remember if we have forwarded objects
  99     bool has_forwarded_objects = heap-&gt;has_forwarded_objects();
 100 
 101     // a1. Cancel evacuation, if in progress
 102     if (heap-&gt;is_evacuation_in_progress()) {
 103       heap-&gt;set_evacuation_in_progress(false);
 104     }
 105     assert(!heap-&gt;is_evacuation_in_progress(), &quot;sanity&quot;);
 106 
 107     // a2. Cancel update-refs, if in progress
 108     if (heap-&gt;is_update_refs_in_progress()) {
 109       heap-&gt;set_update_refs_in_progress(false);
 110     }
 111     assert(!heap-&gt;is_update_refs_in_progress(), &quot;sanity&quot;);
 112 






 113     // b. Cancel concurrent mark, if in progress
 114     if (heap-&gt;is_concurrent_mark_in_progress()) {
 115       heap-&gt;concurrent_mark()-&gt;cancel();
 116       heap-&gt;set_concurrent_mark_in_progress(false);
 117     }
 118     assert(!heap-&gt;is_concurrent_mark_in_progress(), &quot;sanity&quot;);
 119 
 120     // c. Reset the bitmaps for new marking
 121     heap-&gt;reset_mark_bitmap();
 122     assert(heap-&gt;marking_context()-&gt;is_bitmap_clear(), &quot;sanity&quot;);
 123     assert(!heap-&gt;marking_context()-&gt;is_complete(), &quot;sanity&quot;);
 124 
 125     // d. Abandon reference discovery and clear all discovered references.
 126     ReferenceProcessor* rp = heap-&gt;ref_processor();
 127     rp-&gt;disable_discovery();
 128     rp-&gt;abandon_partial_discovery();
 129     rp-&gt;verify_no_references_recorded();
 130 
 131     // e. Set back forwarded objects bit back, in case some steps above dropped it.
 132     heap-&gt;set_has_forwarded_objects(has_forwarded_objects);
</pre>
<hr />
<pre>
 201   if (VerifyAfterGC) {
 202     Universe::verify();
 203   }
 204 
 205   {
 206     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_heapdumps);
 207     heap-&gt;post_full_gc_dump(_gc_timer);
 208   }
 209 }
 210 
 211 class ShenandoahPrepareForMarkClosure: public ShenandoahHeapRegionClosure {
 212 private:
 213   ShenandoahMarkingContext* const _ctx;
 214 
 215 public:
 216   ShenandoahPrepareForMarkClosure() : _ctx(ShenandoahHeap::heap()-&gt;marking_context()) {}
 217 
 218   void heap_region_do(ShenandoahHeapRegion *r) {
 219     _ctx-&gt;capture_top_at_mark_start(r);
 220     r-&gt;clear_live_data();

 221   }
 222 };
 223 
 224 void ShenandoahMarkCompact::phase1_mark_heap() {
 225   GCTraceTime(Info, gc, phases) time(&quot;Phase 1: Mark live objects&quot;, _gc_timer);
 226   ShenandoahGCPhase mark_phase(ShenandoahPhaseTimings::full_gc_mark);
 227 
 228   ShenandoahHeap* heap = ShenandoahHeap::heap();
 229 
 230   ShenandoahPrepareForMarkClosure cl;
 231   heap-&gt;heap_region_iterate(&amp;cl);
 232 
 233   ShenandoahConcurrentMark* cm = heap-&gt;concurrent_mark();
 234 
 235   heap-&gt;set_process_references(heap-&gt;heuristics()-&gt;can_process_references());
 236   heap-&gt;set_unload_classes(heap-&gt;heuristics()-&gt;can_unload_classes());
 237 
 238   ReferenceProcessor* rp = heap-&gt;ref_processor();
 239   // enable (&quot;weak&quot;) refs discovery
 240   rp-&gt;enable_discovery(true /*verify_no_refs*/);
</pre>
<hr />
<pre>
 309       assert(new_to_region != _to_region, &quot;must not reuse same to-region&quot;);
 310       assert(new_to_region != NULL, &quot;must not be NULL&quot;);
 311       _to_region = new_to_region;
 312       _compact_point = _to_region-&gt;bottom();
 313     }
 314 
 315     // Object fits into current region, record new location:
 316     assert(_compact_point + obj_size &lt;= _to_region-&gt;end(), &quot;must fit&quot;);
 317     shenandoah_assert_not_forwarded(NULL, p);
 318     _preserved_marks-&gt;push_if_necessary(p, p-&gt;mark_raw());
 319     p-&gt;forward_to(oop(_compact_point));
 320     _compact_point += obj_size;
 321   }
 322 };
 323 
 324 class ShenandoahPrepareForCompactionTask : public AbstractGangTask {
 325 private:
 326   PreservedMarksSet*        const _preserved_marks;
 327   ShenandoahHeap*           const _heap;
 328   ShenandoahHeapRegionSet** const _worker_slices;





























 329 
 330 public:
<span class="line-modified"> 331   ShenandoahPrepareForCompactionTask(PreservedMarksSet *preserved_marks, ShenandoahHeapRegionSet **worker_slices) :</span>
 332     AbstractGangTask(&quot;Shenandoah Prepare For Compaction Task&quot;),
 333     _preserved_marks(preserved_marks),
 334     _heap(ShenandoahHeap::heap()), _worker_slices(worker_slices) {
 335   }
 336 
<span class="line-added"> 337   static bool is_candidate_region(ShenandoahHeapRegion* r) {</span>
<span class="line-added"> 338     // Empty region: get it into the slice to defragment the slice itself.</span>
<span class="line-added"> 339     // We could have skipped this without violating correctness, but we really</span>
<span class="line-added"> 340     // want to compact all live regions to the start of the heap, which sometimes</span>
<span class="line-added"> 341     // means moving them into the fully empty regions.</span>
<span class="line-added"> 342     if (r-&gt;is_empty()) return true;</span>
<span class="line-added"> 343 </span>
<span class="line-added"> 344     // Can move the region, and this is not the humongous region. Humongous</span>
<span class="line-added"> 345     // moves are special cased here, because their moves are handled separately.</span>
<span class="line-added"> 346     return r-&gt;is_stw_move_allowed() &amp;&amp; !r-&gt;is_humongous();</span>
<span class="line-added"> 347   }</span>
<span class="line-added"> 348 </span>
 349   void work(uint worker_id) {
 350     ShenandoahHeapRegionSet* slice = _worker_slices[worker_id];
<span class="line-modified"> 351     ShenandoahHeapRegionSetIterator it(slice);</span>
<span class="line-added"> 352     ShenandoahHeapRegion* from_region = it.next();</span>
 353     // No work?
 354     if (from_region == NULL) {
<span class="line-modified"> 355        return;</span>
 356     }
 357 
 358     // Sliding compaction. Walk all regions in the slice, and compact them.
 359     // Remember empty regions and reuse them as needed.
 360     ResourceMark rm;
<span class="line-added"> 361 </span>
 362     GrowableArray&lt;ShenandoahHeapRegion*&gt; empty_regions((int)_heap-&gt;num_regions());
<span class="line-added"> 363 </span>
 364     ShenandoahPrepareForCompactionObjectClosure cl(_preserved_marks-&gt;get(worker_id), empty_regions, from_region);
<span class="line-added"> 365 </span>
 366     while (from_region != NULL) {
<span class="line-added"> 367       assert(is_candidate_region(from_region), &quot;Sanity&quot;);</span>
<span class="line-added"> 368 </span>
 369       cl.set_from_region(from_region);
 370       if (from_region-&gt;has_live()) {
 371         _heap-&gt;marked_object_iterate(from_region, &amp;cl);
 372       }
 373 
 374       // Compacted the region to somewhere else? From-region is empty then.
 375       if (!cl.is_compact_same_region()) {
 376         empty_regions.append(from_region);
 377       }
<span class="line-modified"> 378       from_region = it.next();</span>
 379     }
 380     cl.finish_region();
 381 
 382     // Mark all remaining regions as empty
 383     for (int pos = cl.empty_regions_pos(); pos &lt; empty_regions.length(); ++pos) {
 384       ShenandoahHeapRegion* r = empty_regions.at(pos);
 385       r-&gt;set_new_top(r-&gt;bottom());
 386     }
 387   }
 388 };
 389 
 390 void ShenandoahMarkCompact::calculate_target_humongous_objects() {
 391   ShenandoahHeap* heap = ShenandoahHeap::heap();
 392 
 393   // Compute the new addresses for humongous objects. We need to do this after addresses
 394   // for regular objects are calculated, and we know what regions in heap suffix are
 395   // available for humongous moves.
 396   //
 397   // Scan the heap backwards, because we are compacting humongous regions towards the end.
 398   // Maintain the contiguous compaction window in [to_begin; to_end), so that we can slide
 399   // humongous start there.
 400   //
 401   // The complication is potential non-movable regions during the scan. If such region is
 402   // detected, then sliding restarts towards that non-movable region.
 403 
 404   size_t to_begin = heap-&gt;num_regions();
 405   size_t to_end = heap-&gt;num_regions();
 406 
 407   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {
 408     ShenandoahHeapRegion *r = heap-&gt;get_region(c - 1);
 409     if (r-&gt;is_humongous_continuation() || (r-&gt;new_top() == r-&gt;bottom())) {
 410       // To-region candidate: record this, and continue scan
<span class="line-modified"> 411       to_begin = r-&gt;index();</span>
 412       continue;
 413     }
 414 
 415     if (r-&gt;is_humongous_start() &amp;&amp; r-&gt;is_stw_move_allowed()) {
 416       // From-region candidate: movable humongous region
 417       oop old_obj = oop(r-&gt;bottom());
 418       size_t words_size = old_obj-&gt;size();
 419       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
 420 
 421       size_t start = to_end - num_regions;
 422 
<span class="line-modified"> 423       if (start &gt;= to_begin &amp;&amp; start != r-&gt;index()) {</span>
 424         // Fits into current window, and the move is non-trivial. Record the move then, and continue scan.
 425         _preserved_marks-&gt;get(0)-&gt;push_if_necessary(old_obj, old_obj-&gt;mark_raw());
 426         old_obj-&gt;forward_to(oop(heap-&gt;get_region(start)-&gt;bottom()));
 427         to_end = start;
 428         continue;
 429       }
 430     }
 431 
 432     // Failed to fit. Scan starting from current region.
<span class="line-modified"> 433     to_begin = r-&gt;index();</span>
<span class="line-modified"> 434     to_end = r-&gt;index();</span>
 435   }
 436 }
 437 
 438 class ShenandoahEnsureHeapActiveClosure: public ShenandoahHeapRegionClosure {
 439 private:
 440   ShenandoahHeap* const _heap;
 441 
 442 public:
 443   ShenandoahEnsureHeapActiveClosure() : _heap(ShenandoahHeap::heap()) {}
 444   void heap_region_do(ShenandoahHeapRegion* r) {
 445     if (r-&gt;is_trash()) {
 446       r-&gt;recycle();
 447     }
 448     if (r-&gt;is_cset()) {
 449       r-&gt;make_regular_bypass();
 450     }
 451     if (r-&gt;is_empty_uncommitted()) {
 452       r-&gt;make_committed_bypass();
 453     }
<span class="line-modified"> 454     assert (r-&gt;is_committed(), &quot;only committed regions in heap now, see region &quot; SIZE_FORMAT, r-&gt;index());</span>
 455 
 456     // Record current region occupancy: this communicates empty regions are free
 457     // to the rest of Full GC code.
 458     r-&gt;set_new_top(r-&gt;top());
 459   }
 460 };
 461 
 462 class ShenandoahTrashImmediateGarbageClosure: public ShenandoahHeapRegionClosure {
 463 private:
 464   ShenandoahHeap* const _heap;
 465   ShenandoahMarkingContext* const _ctx;
 466 
 467 public:
 468   ShenandoahTrashImmediateGarbageClosure() :
 469     _heap(ShenandoahHeap::heap()),
 470     _ctx(ShenandoahHeap::heap()-&gt;complete_marking_context()) {}
 471 
 472   void heap_region_do(ShenandoahHeapRegion* r) {
 473     if (r-&gt;is_humongous_start()) {
 474       oop humongous_obj = oop(r-&gt;bottom());
 475       if (!_ctx-&gt;is_marked(humongous_obj)) {
 476         assert(!r-&gt;has_live(),
<span class="line-modified"> 477                &quot;Region &quot; SIZE_FORMAT &quot; is not marked, should not have live&quot;, r-&gt;index());</span>
 478         _heap-&gt;trash_humongous_region_at(r);
 479       } else {
 480         assert(r-&gt;has_live(),
<span class="line-modified"> 481                &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;index());</span>
 482       }
 483     } else if (r-&gt;is_humongous_continuation()) {
 484       // If we hit continuation, the non-live humongous starts should have been trashed already
 485       assert(r-&gt;humongous_start_region()-&gt;has_live(),
<span class="line-modified"> 486              &quot;Region &quot; SIZE_FORMAT &quot; should have live&quot;, r-&gt;index());</span>
 487     } else if (r-&gt;is_regular()) {
 488       if (!r-&gt;has_live()) {
 489         r-&gt;make_trash_immediate();
 490       }
 491     }
 492   }
 493 };
 494 
<span class="line-added"> 495 void ShenandoahMarkCompact::distribute_slices(ShenandoahHeapRegionSet** worker_slices) {</span>
<span class="line-added"> 496   ShenandoahHeap* heap = ShenandoahHeap::heap();</span>
<span class="line-added"> 497 </span>
<span class="line-added"> 498   uint n_workers = heap-&gt;workers()-&gt;active_workers();</span>
<span class="line-added"> 499   size_t n_regions = heap-&gt;num_regions();</span>
<span class="line-added"> 500 </span>
<span class="line-added"> 501   // What we want to accomplish: have the dense prefix of data, while still balancing</span>
<span class="line-added"> 502   // out the parallel work.</span>
<span class="line-added"> 503   //</span>
<span class="line-added"> 504   // Assuming the amount of work is driven by the live data that needs moving, we can slice</span>
<span class="line-added"> 505   // the entire heap into equal-live-sized prefix slices, and compact into them. So, each</span>
<span class="line-added"> 506   // thread takes all regions in its prefix subset, and then it takes some regions from</span>
<span class="line-added"> 507   // the tail.</span>
<span class="line-added"> 508   //</span>
<span class="line-added"> 509   // Tail region selection becomes interesting.</span>
<span class="line-added"> 510   //</span>
<span class="line-added"> 511   // First, we want to distribute the regions fairly between the workers, and those regions</span>
<span class="line-added"> 512   // might have different amount of live data. So, until we sure no workers need live data,</span>
<span class="line-added"> 513   // we need to only take what the worker needs.</span>
<span class="line-added"> 514   //</span>
<span class="line-added"> 515   // Second, since we slide everything to the left in each slice, the most busy regions</span>
<span class="line-added"> 516   // would be the ones on the left. Which means we want to have all workers have their after-tail</span>
<span class="line-added"> 517   // regions as close to the left as possible.</span>
<span class="line-added"> 518   //</span>
<span class="line-added"> 519   // The easiest way to do this is to distribute after-tail regions in round-robin between</span>
<span class="line-added"> 520   // workers that still need live data.</span>
<span class="line-added"> 521   //</span>
<span class="line-added"> 522   // Consider parallel workers A, B, C, then the target slice layout would be:</span>
<span class="line-added"> 523   //</span>
<span class="line-added"> 524   //  AAAAAAAABBBBBBBBCCCCCCCC|ABCABCABCABCABCABCABCABABABABABABABABABABAAAAA</span>
<span class="line-added"> 525   //</span>
<span class="line-added"> 526   //  (.....dense-prefix.....) (.....................tail...................)</span>
<span class="line-added"> 527   //  [all regions fully live] [left-most regions are fuller that right-most]</span>
<span class="line-added"> 528   //</span>
<span class="line-added"> 529 </span>
<span class="line-added"> 530   // Compute how much live data is there. This would approximate the size of dense prefix</span>
<span class="line-added"> 531   // we target to create.</span>
<span class="line-added"> 532   size_t total_live = 0;</span>
<span class="line-added"> 533   for (size_t idx = 0; idx &lt; n_regions; idx++) {</span>
<span class="line-added"> 534     ShenandoahHeapRegion *r = heap-&gt;get_region(idx);</span>
<span class="line-added"> 535     if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 536       total_live += r-&gt;get_live_data_words();</span>
<span class="line-added"> 537     }</span>
<span class="line-added"> 538   }</span>
<span class="line-added"> 539 </span>
<span class="line-added"> 540   // Estimate the size for the dense prefix. Note that we specifically count only the</span>
<span class="line-added"> 541   // &quot;full&quot; regions, so there would be some non-full regions in the slice tail.</span>
<span class="line-added"> 542   size_t live_per_worker = total_live / n_workers;</span>
<span class="line-added"> 543   size_t prefix_regions_per_worker = live_per_worker / ShenandoahHeapRegion::region_size_words();</span>
<span class="line-added"> 544   size_t prefix_regions_total = prefix_regions_per_worker * n_workers;</span>
<span class="line-added"> 545   prefix_regions_total = MIN2(prefix_regions_total, n_regions);</span>
<span class="line-added"> 546   assert(prefix_regions_total &lt;= n_regions, &quot;Sanity&quot;);</span>
<span class="line-added"> 547 </span>
<span class="line-added"> 548   // There might be non-candidate regions in the prefix. To compute where the tail actually</span>
<span class="line-added"> 549   // ends up being, we need to account those as well.</span>
<span class="line-added"> 550   size_t prefix_end = prefix_regions_total;</span>
<span class="line-added"> 551   for (size_t idx = 0; idx &lt; prefix_regions_total; idx++) {</span>
<span class="line-added"> 552     ShenandoahHeapRegion *r = heap-&gt;get_region(idx);</span>
<span class="line-added"> 553     if (!ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 554       prefix_end++;</span>
<span class="line-added"> 555     }</span>
<span class="line-added"> 556   }</span>
<span class="line-added"> 557   prefix_end = MIN2(prefix_end, n_regions);</span>
<span class="line-added"> 558   assert(prefix_end &lt;= n_regions, &quot;Sanity&quot;);</span>
<span class="line-added"> 559 </span>
<span class="line-added"> 560   // Distribute prefix regions per worker: each thread definitely gets its own same-sized</span>
<span class="line-added"> 561   // subset of dense prefix.</span>
<span class="line-added"> 562   size_t prefix_idx = 0;</span>
<span class="line-added"> 563 </span>
<span class="line-added"> 564   size_t* live = NEW_C_HEAP_ARRAY(size_t, n_workers, mtGC);</span>
<span class="line-added"> 565 </span>
<span class="line-added"> 566   for (size_t wid = 0; wid &lt; n_workers; wid++) {</span>
<span class="line-added"> 567     ShenandoahHeapRegionSet* slice = worker_slices[wid];</span>
<span class="line-added"> 568 </span>
<span class="line-added"> 569     live[wid] = 0;</span>
<span class="line-added"> 570     size_t regs = 0;</span>
<span class="line-added"> 571 </span>
<span class="line-added"> 572     // Add all prefix regions for this worker</span>
<span class="line-added"> 573     while (prefix_idx &lt; prefix_end &amp;&amp; regs &lt; prefix_regions_per_worker) {</span>
<span class="line-added"> 574       ShenandoahHeapRegion *r = heap-&gt;get_region(prefix_idx);</span>
<span class="line-added"> 575       if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 576         slice-&gt;add_region(r);</span>
<span class="line-added"> 577         live[wid] += r-&gt;get_live_data_words();</span>
<span class="line-added"> 578         regs++;</span>
<span class="line-added"> 579       }</span>
<span class="line-added"> 580       prefix_idx++;</span>
<span class="line-added"> 581     }</span>
<span class="line-added"> 582   }</span>
<span class="line-added"> 583 </span>
<span class="line-added"> 584   // Distribute the tail among workers in round-robin fashion.</span>
<span class="line-added"> 585   size_t wid = n_workers - 1;</span>
<span class="line-added"> 586 </span>
<span class="line-added"> 587   for (size_t tail_idx = prefix_end; tail_idx &lt; n_regions; tail_idx++) {</span>
<span class="line-added"> 588     ShenandoahHeapRegion *r = heap-&gt;get_region(tail_idx);</span>
<span class="line-added"> 589     if (ShenandoahPrepareForCompactionTask::is_candidate_region(r)) {</span>
<span class="line-added"> 590       assert(wid &lt; n_workers, &quot;Sanity&quot;);</span>
<span class="line-added"> 591 </span>
<span class="line-added"> 592       size_t live_region = r-&gt;get_live_data_words();</span>
<span class="line-added"> 593 </span>
<span class="line-added"> 594       // Select next worker that still needs live data.</span>
<span class="line-added"> 595       size_t old_wid = wid;</span>
<span class="line-added"> 596       do {</span>
<span class="line-added"> 597         wid++;</span>
<span class="line-added"> 598         if (wid == n_workers) wid = 0;</span>
<span class="line-added"> 599       } while (live[wid] + live_region &gt;= live_per_worker &amp;&amp; old_wid != wid);</span>
<span class="line-added"> 600 </span>
<span class="line-added"> 601       if (old_wid == wid) {</span>
<span class="line-added"> 602         // Circled back to the same worker? This means liveness data was</span>
<span class="line-added"> 603         // miscalculated. Bump the live_per_worker limit so that</span>
<span class="line-added"> 604         // everyone gets a piece of the leftover work.</span>
<span class="line-added"> 605         live_per_worker += ShenandoahHeapRegion::region_size_words();</span>
<span class="line-added"> 606       }</span>
<span class="line-added"> 607 </span>
<span class="line-added"> 608       worker_slices[wid]-&gt;add_region(r);</span>
<span class="line-added"> 609       live[wid] += live_region;</span>
<span class="line-added"> 610     }</span>
<span class="line-added"> 611   }</span>
<span class="line-added"> 612 </span>
<span class="line-added"> 613   FREE_C_HEAP_ARRAY(size_t, live);</span>
<span class="line-added"> 614 </span>
<span class="line-added"> 615 #ifdef ASSERT</span>
<span class="line-added"> 616   ResourceBitMap map(n_regions);</span>
<span class="line-added"> 617   for (size_t wid = 0; wid &lt; n_workers; wid++) {</span>
<span class="line-added"> 618     ShenandoahHeapRegionSetIterator it(worker_slices[wid]);</span>
<span class="line-added"> 619     ShenandoahHeapRegion* r = it.next();</span>
<span class="line-added"> 620     while (r != NULL) {</span>
<span class="line-added"> 621       size_t idx = r-&gt;index();</span>
<span class="line-added"> 622       assert(ShenandoahPrepareForCompactionTask::is_candidate_region(r), &quot;Sanity: &quot; SIZE_FORMAT, idx);</span>
<span class="line-added"> 623       assert(!map.at(idx), &quot;No region distributed twice: &quot; SIZE_FORMAT, idx);</span>
<span class="line-added"> 624       map.at_put(idx, true);</span>
<span class="line-added"> 625       r = it.next();</span>
<span class="line-added"> 626     }</span>
<span class="line-added"> 627   }</span>
<span class="line-added"> 628 </span>
<span class="line-added"> 629   for (size_t rid = 0; rid &lt; n_regions; rid++) {</span>
<span class="line-added"> 630     bool is_candidate = ShenandoahPrepareForCompactionTask::is_candidate_region(heap-&gt;get_region(rid));</span>
<span class="line-added"> 631     bool is_distributed = map.at(rid);</span>
<span class="line-added"> 632     assert(is_distributed || !is_candidate, &quot;All candidates are distributed: &quot; SIZE_FORMAT, rid);</span>
<span class="line-added"> 633   }</span>
<span class="line-added"> 634 #endif</span>
<span class="line-added"> 635 }</span>
<span class="line-added"> 636 </span>
 637 void ShenandoahMarkCompact::phase2_calculate_target_addresses(ShenandoahHeapRegionSet** worker_slices) {
 638   GCTraceTime(Info, gc, phases) time(&quot;Phase 2: Compute new object addresses&quot;, _gc_timer);
 639   ShenandoahGCPhase calculate_address_phase(ShenandoahPhaseTimings::full_gc_calculate_addresses);
 640 
 641   ShenandoahHeap* heap = ShenandoahHeap::heap();
 642 
 643   // About to figure out which regions can be compacted, make sure pinning status
 644   // had been updated in GC prologue.
 645   heap-&gt;assert_pinned_region_status();
 646 
 647   {
 648     // Trash the immediately collectible regions before computing addresses
 649     ShenandoahTrashImmediateGarbageClosure tigcl;
 650     heap-&gt;heap_region_iterate(&amp;tigcl);
 651 
 652     // Make sure regions are in good state: committed, active, clean.
 653     // This is needed because we are potentially sliding the data through them.
 654     ShenandoahEnsureHeapActiveClosure ecl;
 655     heap-&gt;heap_region_iterate(&amp;ecl);
 656   }
 657 
 658   // Compute the new addresses for regular objects
 659   {
 660     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_regular);
<span class="line-modified"> 661 </span>
<span class="line-modified"> 662     distribute_slices(worker_slices);</span>
<span class="line-added"> 663 </span>
<span class="line-added"> 664     ShenandoahPrepareForCompactionTask task(_preserved_marks, worker_slices);</span>
<span class="line-added"> 665     heap-&gt;workers()-&gt;run_task(&amp;task);</span>
 666   }
 667 
 668   // Compute the new addresses for humongous objects
 669   {
 670     ShenandoahGCPhase phase(ShenandoahPhaseTimings::full_gc_calculate_addresses_humong);
 671     calculate_target_humongous_objects();
 672   }
 673 }
 674 
 675 class ShenandoahAdjustPointersClosure : public MetadataVisitingOopIterateClosure {
 676 private:
 677   ShenandoahHeap* const _heap;
 678   ShenandoahMarkingContext* const _ctx;
 679 
 680   template &lt;class T&gt;
 681   inline void do_oop_work(T* p) {
 682     T o = RawAccess&lt;&gt;::oop_load(p);
 683     if (!CompressedOops::is_null(o)) {
 684       oop obj = CompressedOops::decode_not_null(o);
 685       assert(_ctx-&gt;is_marked(obj), &quot;must be marked&quot;);
</pre>
<hr />
<pre>
 852 
 853     size_t live = r-&gt;used();
 854 
 855     // Make empty regions that have been allocated into regular
 856     if (r-&gt;is_empty() &amp;&amp; live &gt; 0) {
 857       r-&gt;make_regular_bypass();
 858     }
 859 
 860     // Reclaim regular regions that became empty
 861     if (r-&gt;is_regular() &amp;&amp; live == 0) {
 862       r-&gt;make_trash();
 863     }
 864 
 865     // Recycle all trash regions
 866     if (r-&gt;is_trash()) {
 867       live = 0;
 868       r-&gt;recycle();
 869     }
 870 
 871     r-&gt;set_live_data(live);
<span class="line-modified"> 872     r-&gt;reset_alloc_metadata();</span>
 873     _live += live;
 874   }
 875 
 876   size_t get_live() {
 877     return _live;
 878   }
 879 };
 880 
 881 void ShenandoahMarkCompact::compact_humongous_objects() {
 882   // Compact humongous regions, based on their fwdptr objects.
 883   //
 884   // This code is serial, because doing the in-slice parallel sliding is tricky. In most cases,
 885   // humongous regions are already compacted, and do not require further moves, which alleviates
 886   // sliding costs. We may consider doing this in parallel in future.
 887 
 888   ShenandoahHeap* heap = ShenandoahHeap::heap();
 889 
 890   for (size_t c = heap-&gt;num_regions(); c &gt; 0; c--) {
 891     ShenandoahHeapRegion* r = heap-&gt;get_region(c - 1);
 892     if (r-&gt;is_humongous_start()) {
 893       oop old_obj = oop(r-&gt;bottom());
 894       if (!old_obj-&gt;is_forwarded()) {
 895         // No need to move the object, it stays at the same slot
 896         continue;
 897       }
 898       size_t words_size = old_obj-&gt;size();
 899       size_t num_regions = ShenandoahHeapRegion::required_regions(words_size * HeapWordSize);
 900 
<span class="line-modified"> 901       size_t old_start = r-&gt;index();</span>
 902       size_t old_end   = old_start + num_regions - 1;
 903       size_t new_start = heap-&gt;heap_region_index_containing(old_obj-&gt;forwardee());
 904       size_t new_end   = new_start + num_regions - 1;
 905       assert(old_start != new_start, &quot;must be real move&quot;);
<span class="line-modified"> 906       assert(r-&gt;is_stw_move_allowed(), &quot;Region &quot; SIZE_FORMAT &quot; should be movable&quot;, r-&gt;index());</span>
 907 
 908       Copy::aligned_conjoint_words(heap-&gt;get_region(old_start)-&gt;bottom(),
 909                                    heap-&gt;get_region(new_start)-&gt;bottom(),
 910                                    ShenandoahHeapRegion::region_size_words()*num_regions);
 911 
 912       oop new_obj = oop(heap-&gt;get_region(new_start)-&gt;bottom());
 913       new_obj-&gt;init_mark_raw();
 914 
 915       {
 916         for (size_t c = old_start; c &lt;= old_end; c++) {
 917           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 918           r-&gt;make_regular_bypass();
 919           r-&gt;set_top(r-&gt;bottom());
 920         }
 921 
 922         for (size_t c = new_start; c &lt;= new_end; c++) {
 923           ShenandoahHeapRegion* r = heap-&gt;get_region(c);
 924           if (c == new_start) {
 925             r-&gt;make_humongous_start_bypass();
 926           } else {
 927             r-&gt;make_humongous_cont_bypass();
 928           }
 929 
 930           // Trailing region may be non-full, record the remainder there
 931           size_t remainder = words_size &amp; ShenandoahHeapRegion::region_size_words_mask();
 932           if ((c == new_end) &amp;&amp; (remainder != 0)) {
 933             r-&gt;set_top(r-&gt;bottom() + remainder);
 934           } else {
 935             r-&gt;set_top(r-&gt;end());
 936           }
 937 
<span class="line-modified"> 938           r-&gt;reset_alloc_metadata();</span>
 939         }
 940       }
 941     }
 942   }
 943 }
 944 
 945 // This is slightly different to ShHeap::reset_next_mark_bitmap:
 946 // we need to remain able to walk pinned regions.
 947 // Since pinned region do not move and don&#39;t get compacted, we will get holes with
 948 // unreachable objects in them (which may have pointers to unloaded Klasses and thus
 949 // cannot be iterated over using oop-&gt;size(). The only way to safely iterate over those is using
 950 // a valid marking bitmap and valid TAMS pointer. This class only resets marking
 951 // bitmaps for un-pinned regions, and later we only reset TAMS for unpinned regions.
 952 class ShenandoahMCResetCompleteBitmapTask : public AbstractGangTask {
 953 private:
 954   ShenandoahRegionIterator _regions;
 955 
 956 public:
 957   ShenandoahMCResetCompleteBitmapTask() :
 958     AbstractGangTask(&quot;Parallel Reset Bitmap Task&quot;) {
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahLock.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
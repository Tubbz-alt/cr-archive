<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahAsserts.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSet.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahBarrierSet.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahBarrierSetClone.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahBarrierSetNMethod.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;
<span class="line-removed"> 35 #include &quot;gc/shenandoah/shenandoahTraversalGC.hpp&quot;</span>
 36 #include &quot;memory/iterator.inline.hpp&quot;
 37 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 38 #ifdef COMPILER1
 39 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 40 #endif
 41 #ifdef COMPILER2
 42 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
 43 #endif
 44 
 45 class ShenandoahBarrierSetC1;
 46 class ShenandoahBarrierSetC2;
 47 
 48 static BarrierSetNMethod* make_barrier_set_nmethod(ShenandoahHeap* heap) {
 49   // NMethod barriers are only used when concurrent nmethod unloading is enabled
 50   if (!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {
 51     return NULL;
 52   }
 53   return new ShenandoahBarrierSetNMethod(heap);
 54 }
 55 
</pre>
<hr />
<pre>
 83 }
 84 
 85 bool ShenandoahBarrierSet::need_load_reference_barrier(DecoratorSet decorators, BasicType type) {
 86   if (!ShenandoahLoadRefBarrier) return false;
 87   // Only needed for references
 88   return is_reference_type(type);
 89 }
 90 
 91 bool ShenandoahBarrierSet::use_load_reference_barrier_native(DecoratorSet decorators, BasicType type) {
 92   assert(need_load_reference_barrier(decorators, type), &quot;Should be subset of LRB&quot;);
 93   assert(is_reference_type(type), &quot;Why we here?&quot;);
 94   // Native load reference barrier is only needed for concurrent root processing
 95   if (!ShenandoahConcurrentRoots::can_do_concurrent_roots()) {
 96     return false;
 97   }
 98 
 99   return (decorators &amp; IN_NATIVE) != 0;
100 }
101 
102 bool ShenandoahBarrierSet::need_keep_alive_barrier(DecoratorSet decorators,BasicType type) {
<span class="line-modified">103   if (!ShenandoahKeepAliveBarrier) return false;</span>
104   // Only needed for references
105   if (!is_reference_type(type)) return false;
106 
107   bool keep_alive = (decorators &amp; AS_NO_KEEPALIVE) == 0;
108   bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;
<span class="line-removed">109   bool is_traversal_mode = ShenandoahHeap::heap()-&gt;is_traversal_mode();</span>
110   bool on_weak_ref = (decorators &amp; (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;
<span class="line-modified">111   return (on_weak_ref || unknown) &amp;&amp; (keep_alive || is_traversal_mode);</span>
112 }
113 
114 oop ShenandoahBarrierSet::load_reference_barrier_not_null(oop obj) {
115   if (ShenandoahLoadRefBarrier &amp;&amp; _heap-&gt;has_forwarded_objects()) {
116     return load_reference_barrier_impl(obj);
117   } else {
118     return obj;
119   }
120 }
121 
122 oop ShenandoahBarrierSet::load_reference_barrier(oop obj) {
123   if (obj != NULL) {
124     return load_reference_barrier_not_null(obj);
125   } else {
126     return obj;
127   }
128 }
129 
<span class="line-removed">130 oop ShenandoahBarrierSet::load_reference_barrier_mutator(oop obj, oop* load_addr) {</span>
<span class="line-removed">131   return load_reference_barrier_mutator_work(obj, load_addr);</span>
<span class="line-removed">132 }</span>
<span class="line-removed">133 </span>
<span class="line-removed">134 oop ShenandoahBarrierSet::load_reference_barrier_mutator(oop obj, narrowOop* load_addr) {</span>
<span class="line-removed">135   return load_reference_barrier_mutator_work(obj, load_addr);</span>
<span class="line-removed">136 }</span>
<span class="line-removed">137 </span>
<span class="line-removed">138 template &lt;class T&gt;</span>
<span class="line-removed">139 oop ShenandoahBarrierSet::load_reference_barrier_mutator_work(oop obj, T* load_addr) {</span>
<span class="line-removed">140   assert(ShenandoahLoadRefBarrier, &quot;should be enabled&quot;);</span>
<span class="line-removed">141   shenandoah_assert_in_cset(load_addr, obj);</span>
<span class="line-removed">142 </span>
<span class="line-removed">143   oop fwd = resolve_forwarded_not_null_mutator(obj);</span>
<span class="line-removed">144   if (obj == fwd) {</span>
<span class="line-removed">145     assert(_heap-&gt;is_gc_in_progress_mask(ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL),</span>
<span class="line-removed">146            &quot;evac should be in progress&quot;);</span>
<span class="line-removed">147     ShenandoahEvacOOMScope scope;</span>
<span class="line-removed">148     fwd = _heap-&gt;evacuate_object(obj, Thread::current());</span>
<span class="line-removed">149   }</span>
<span class="line-removed">150 </span>
<span class="line-removed">151   if (load_addr != NULL &amp;&amp; fwd != obj) {</span>
<span class="line-removed">152     // Since we are here and we know the load address, update the reference.</span>
<span class="line-removed">153     ShenandoahHeap::cas_oop(fwd, load_addr, obj);</span>
<span class="line-removed">154   }</span>
<span class="line-removed">155 </span>
<span class="line-removed">156   return fwd;</span>
<span class="line-removed">157 }</span>
<span class="line-removed">158 </span>
159 oop ShenandoahBarrierSet::load_reference_barrier_impl(oop obj) {
160   assert(ShenandoahLoadRefBarrier, &quot;should be enabled&quot;);
161   if (!CompressedOops::is_null(obj)) {
<span class="line-modified">162     bool evac_in_progress = _heap-&gt;is_gc_in_progress_mask(ShenandoahHeap::EVACUATION | ShenandoahHeap::TRAVERSAL);</span>
163     oop fwd = resolve_forwarded_not_null(obj);
164     if (evac_in_progress &amp;&amp;
165         _heap-&gt;in_collection_set(obj) &amp;&amp;
166         obj == fwd) {
167       Thread *t = Thread::current();
168       ShenandoahEvacOOMScope oom_evac_scope;
169       return _heap-&gt;evacuate_object(obj, t);
170     } else {
171       return fwd;
172     }
173   } else {
174     return obj;
175   }
176 }
177 
178 void ShenandoahBarrierSet::on_thread_create(Thread* thread) {
179   // Create thread local data
180   ShenandoahThreadLocalData::create(thread);
181 }
182 
</pre>
<hr />
<pre>
226   ShenandoahMarkingContext* const marking_context = _heap-&gt;marking_context();
227   if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp; !marking_context-&gt;is_marked(obj)) {
228     Thread* thr = Thread::current();
229     if (thr-&gt;is_Java_thread()) {
230       return NULL;
231     } else {
232       return obj;
233     }
234   }
235 
236   oop fwd = load_reference_barrier_not_null(obj);
237   if (load_addr != NULL &amp;&amp; fwd != obj) {
238     // Since we are here and we know the load address, update the reference.
239     ShenandoahHeap::cas_oop(fwd, load_addr, obj);
240   }
241 
242   return fwd;
243 }
244 
245 void ShenandoahBarrierSet::clone_barrier_runtime(oop src) {
<span class="line-modified">246   if (_heap-&gt;has_forwarded_objects()) {</span>
247     clone_barrier(src);
248   }
249 }
250 
</pre>
</td>
<td>
<hr />
<pre>
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;gc/shenandoah/shenandoahAsserts.hpp&quot;
 27 #include &quot;gc/shenandoah/shenandoahBarrierSet.hpp&quot;
 28 #include &quot;gc/shenandoah/shenandoahBarrierSetClone.inline.hpp&quot;
 29 #include &quot;gc/shenandoah/shenandoahBarrierSetAssembler.hpp&quot;
 30 #include &quot;gc/shenandoah/shenandoahBarrierSetNMethod.hpp&quot;
 31 #include &quot;gc/shenandoah/shenandoahCollectorPolicy.hpp&quot;
 32 #include &quot;gc/shenandoah/shenandoahConcurrentRoots.hpp&quot;
 33 #include &quot;gc/shenandoah/shenandoahHeap.inline.hpp&quot;
 34 #include &quot;gc/shenandoah/shenandoahHeuristics.hpp&quot;

 35 #include &quot;memory/iterator.inline.hpp&quot;
 36 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 37 #ifdef COMPILER1
 38 #include &quot;gc/shenandoah/c1/shenandoahBarrierSetC1.hpp&quot;
 39 #endif
 40 #ifdef COMPILER2
 41 #include &quot;gc/shenandoah/c2/shenandoahBarrierSetC2.hpp&quot;
 42 #endif
 43 
 44 class ShenandoahBarrierSetC1;
 45 class ShenandoahBarrierSetC2;
 46 
 47 static BarrierSetNMethod* make_barrier_set_nmethod(ShenandoahHeap* heap) {
 48   // NMethod barriers are only used when concurrent nmethod unloading is enabled
 49   if (!ShenandoahConcurrentRoots::can_do_concurrent_class_unloading()) {
 50     return NULL;
 51   }
 52   return new ShenandoahBarrierSetNMethod(heap);
 53 }
 54 
</pre>
<hr />
<pre>
 82 }
 83 
 84 bool ShenandoahBarrierSet::need_load_reference_barrier(DecoratorSet decorators, BasicType type) {
 85   if (!ShenandoahLoadRefBarrier) return false;
 86   // Only needed for references
 87   return is_reference_type(type);
 88 }
 89 
 90 bool ShenandoahBarrierSet::use_load_reference_barrier_native(DecoratorSet decorators, BasicType type) {
 91   assert(need_load_reference_barrier(decorators, type), &quot;Should be subset of LRB&quot;);
 92   assert(is_reference_type(type), &quot;Why we here?&quot;);
 93   // Native load reference barrier is only needed for concurrent root processing
 94   if (!ShenandoahConcurrentRoots::can_do_concurrent_roots()) {
 95     return false;
 96   }
 97 
 98   return (decorators &amp; IN_NATIVE) != 0;
 99 }
100 
101 bool ShenandoahBarrierSet::need_keep_alive_barrier(DecoratorSet decorators,BasicType type) {
<span class="line-modified">102   if (!ShenandoahSATBBarrier) return false;</span>
103   // Only needed for references
104   if (!is_reference_type(type)) return false;
105 
106   bool keep_alive = (decorators &amp; AS_NO_KEEPALIVE) == 0;
107   bool unknown = (decorators &amp; ON_UNKNOWN_OOP_REF) != 0;

108   bool on_weak_ref = (decorators &amp; (ON_WEAK_OOP_REF | ON_PHANTOM_OOP_REF)) != 0;
<span class="line-modified">109   return (on_weak_ref || unknown) &amp;&amp; keep_alive;</span>
110 }
111 
112 oop ShenandoahBarrierSet::load_reference_barrier_not_null(oop obj) {
113   if (ShenandoahLoadRefBarrier &amp;&amp; _heap-&gt;has_forwarded_objects()) {
114     return load_reference_barrier_impl(obj);
115   } else {
116     return obj;
117   }
118 }
119 
120 oop ShenandoahBarrierSet::load_reference_barrier(oop obj) {
121   if (obj != NULL) {
122     return load_reference_barrier_not_null(obj);
123   } else {
124     return obj;
125   }
126 }
127 





























128 oop ShenandoahBarrierSet::load_reference_barrier_impl(oop obj) {
129   assert(ShenandoahLoadRefBarrier, &quot;should be enabled&quot;);
130   if (!CompressedOops::is_null(obj)) {
<span class="line-modified">131     bool evac_in_progress = _heap-&gt;is_evacuation_in_progress();</span>
132     oop fwd = resolve_forwarded_not_null(obj);
133     if (evac_in_progress &amp;&amp;
134         _heap-&gt;in_collection_set(obj) &amp;&amp;
135         obj == fwd) {
136       Thread *t = Thread::current();
137       ShenandoahEvacOOMScope oom_evac_scope;
138       return _heap-&gt;evacuate_object(obj, t);
139     } else {
140       return fwd;
141     }
142   } else {
143     return obj;
144   }
145 }
146 
147 void ShenandoahBarrierSet::on_thread_create(Thread* thread) {
148   // Create thread local data
149   ShenandoahThreadLocalData::create(thread);
150 }
151 
</pre>
<hr />
<pre>
195   ShenandoahMarkingContext* const marking_context = _heap-&gt;marking_context();
196   if (_heap-&gt;is_concurrent_root_in_progress() &amp;&amp; !marking_context-&gt;is_marked(obj)) {
197     Thread* thr = Thread::current();
198     if (thr-&gt;is_Java_thread()) {
199       return NULL;
200     } else {
201       return obj;
202     }
203   }
204 
205   oop fwd = load_reference_barrier_not_null(obj);
206   if (load_addr != NULL &amp;&amp; fwd != obj) {
207     // Since we are here and we know the load address, update the reference.
208     ShenandoahHeap::cas_oop(fwd, load_addr, obj);
209   }
210 
211   return fwd;
212 }
213 
214 void ShenandoahBarrierSet::clone_barrier_runtime(oop src) {
<span class="line-modified">215   if (_heap-&gt;has_forwarded_objects() || (ShenandoahStoreValEnqueueBarrier &amp;&amp; _heap-&gt;is_concurrent_mark_in_progress())) {</span>
216     clone_barrier(src);
217   }
218 }
219 
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahAsserts.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahBarrierSet.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
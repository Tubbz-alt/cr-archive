<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/gc/shenandoah/shenandoahMarkingContext.cpp</title>
    <link rel="stylesheet" href="../../../../../style.css" />
  </head>
<body>
<center><a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkingContext.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/gc/shenandoah/shenandoahMarkingContext.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 36   _mark_bit_map.initialize(heap_region, bitmap_region);
 37 }
 38 
 39 bool ShenandoahMarkingContext::is_bitmap_clear() const {
 40   ShenandoahHeap* heap = ShenandoahHeap::heap();
 41   size_t num_regions = heap-&gt;num_regions();
 42   for (size_t idx = 0; idx &lt; num_regions; idx++) {
 43     ShenandoahHeapRegion* r = heap-&gt;get_region(idx);
 44     if (heap-&gt;is_bitmap_slice_committed(r) &amp;&amp; !is_bitmap_clear_range(r-&gt;bottom(), r-&gt;end())) {
 45       return false;
 46     }
 47   }
 48   return true;
 49 }
 50 
 51 bool ShenandoahMarkingContext::is_bitmap_clear_range(HeapWord* start, HeapWord* end) const {
 52   return _mark_bit_map.get_next_marked_addr(start, end) == end;
 53 }
 54 
 55 void ShenandoahMarkingContext::initialize_top_at_mark_start(ShenandoahHeapRegion* r) {
<span class="line-modified"> 56   size_t idx = r-&gt;region_number();</span>
 57   HeapWord *bottom = r-&gt;bottom();
 58   _top_at_mark_starts_base[idx] = bottom;
 59   _top_bitmaps[idx] = bottom;
 60 }
 61 
<span class="line-removed"> 62 void ShenandoahMarkingContext::capture_top_at_mark_start(ShenandoahHeapRegion *r) {</span>
<span class="line-removed"> 63   size_t region_number = r-&gt;region_number();</span>
<span class="line-removed"> 64   HeapWord* old_tams = _top_at_mark_starts_base[region_number];</span>
<span class="line-removed"> 65   HeapWord* new_tams = r-&gt;top();</span>
<span class="line-removed"> 66 </span>
<span class="line-removed"> 67   assert(new_tams &gt;= old_tams,</span>
<span class="line-removed"> 68          &quot;Region &quot; SIZE_FORMAT&quot;, TAMS updates should be monotonic: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,</span>
<span class="line-removed"> 69          region_number, p2i(old_tams), p2i(new_tams));</span>
<span class="line-removed"> 70   assert(is_bitmap_clear_range(old_tams, new_tams),</span>
<span class="line-removed"> 71          &quot;Region &quot; SIZE_FORMAT &quot;, bitmap should be clear while adjusting TAMS: &quot; PTR_FORMAT &quot; -&gt; &quot; PTR_FORMAT,</span>
<span class="line-removed"> 72          region_number, p2i(old_tams), p2i(new_tams));</span>
<span class="line-removed"> 73 </span>
<span class="line-removed"> 74   _top_at_mark_starts_base[region_number] = new_tams;</span>
<span class="line-removed"> 75   _top_bitmaps[region_number] = new_tams;</span>
<span class="line-removed"> 76 }</span>
<span class="line-removed"> 77 </span>
<span class="line-removed"> 78 void ShenandoahMarkingContext::reset_top_at_mark_start(ShenandoahHeapRegion* r) {</span>
<span class="line-removed"> 79   _top_at_mark_starts_base[r-&gt;region_number()] = r-&gt;bottom();</span>
<span class="line-removed"> 80 }</span>
<span class="line-removed"> 81 </span>
<span class="line-removed"> 82 HeapWord* ShenandoahMarkingContext::top_at_mark_start(ShenandoahHeapRegion* r) const {</span>
<span class="line-removed"> 83   return _top_at_mark_starts_base[r-&gt;region_number()];</span>
<span class="line-removed"> 84 }</span>
<span class="line-removed"> 85 </span>
<span class="line-removed"> 86 void ShenandoahMarkingContext::reset_top_bitmap(ShenandoahHeapRegion* r) {</span>
<span class="line-removed"> 87   assert(is_bitmap_clear_range(r-&gt;bottom(), r-&gt;end()),</span>
<span class="line-removed"> 88          &quot;Region &quot; SIZE_FORMAT &quot; should have no marks in bitmap&quot;, r-&gt;region_number());</span>
<span class="line-removed"> 89   _top_bitmaps[r-&gt;region_number()] = r-&gt;bottom();</span>
<span class="line-removed"> 90 }</span>
<span class="line-removed"> 91 </span>
 92 void ShenandoahMarkingContext::clear_bitmap(ShenandoahHeapRegion* r) {
 93   HeapWord* bottom = r-&gt;bottom();
<span class="line-modified"> 94   HeapWord* top_bitmap = _top_bitmaps[r-&gt;region_number()];</span>
 95   if (top_bitmap &gt; bottom) {
 96     _mark_bit_map.clear_range_large(MemRegion(bottom, top_bitmap));
<span class="line-modified"> 97     _top_bitmaps[r-&gt;region_number()] = bottom;</span>
 98   }
 99   assert(is_bitmap_clear_range(bottom, r-&gt;end()),
<span class="line-modified">100          &quot;Region &quot; SIZE_FORMAT &quot; should have no marks in bitmap&quot;, r-&gt;region_number());</span>
101 }
102 
103 bool ShenandoahMarkingContext::is_complete() {
104   return _is_complete.is_set();
105 }
106 
107 void ShenandoahMarkingContext::mark_complete() {
108   _is_complete.set();
109 }
110 
111 void ShenandoahMarkingContext::mark_incomplete() {
112   _is_complete.unset();
113 }
</pre>
</td>
<td>
<hr />
<pre>
 36   _mark_bit_map.initialize(heap_region, bitmap_region);
 37 }
 38 
 39 bool ShenandoahMarkingContext::is_bitmap_clear() const {
 40   ShenandoahHeap* heap = ShenandoahHeap::heap();
 41   size_t num_regions = heap-&gt;num_regions();
 42   for (size_t idx = 0; idx &lt; num_regions; idx++) {
 43     ShenandoahHeapRegion* r = heap-&gt;get_region(idx);
 44     if (heap-&gt;is_bitmap_slice_committed(r) &amp;&amp; !is_bitmap_clear_range(r-&gt;bottom(), r-&gt;end())) {
 45       return false;
 46     }
 47   }
 48   return true;
 49 }
 50 
 51 bool ShenandoahMarkingContext::is_bitmap_clear_range(HeapWord* start, HeapWord* end) const {
 52   return _mark_bit_map.get_next_marked_addr(start, end) == end;
 53 }
 54 
 55 void ShenandoahMarkingContext::initialize_top_at_mark_start(ShenandoahHeapRegion* r) {
<span class="line-modified"> 56   size_t idx = r-&gt;index();</span>
 57   HeapWord *bottom = r-&gt;bottom();
 58   _top_at_mark_starts_base[idx] = bottom;
 59   _top_bitmaps[idx] = bottom;
 60 }
 61 






























 62 void ShenandoahMarkingContext::clear_bitmap(ShenandoahHeapRegion* r) {
 63   HeapWord* bottom = r-&gt;bottom();
<span class="line-modified"> 64   HeapWord* top_bitmap = _top_bitmaps[r-&gt;index()];</span>
 65   if (top_bitmap &gt; bottom) {
 66     _mark_bit_map.clear_range_large(MemRegion(bottom, top_bitmap));
<span class="line-modified"> 67     _top_bitmaps[r-&gt;index()] = bottom;</span>
 68   }
 69   assert(is_bitmap_clear_range(bottom, r-&gt;end()),
<span class="line-modified"> 70          &quot;Region &quot; SIZE_FORMAT &quot; should have no marks in bitmap&quot;, r-&gt;index());</span>
 71 }
 72 
 73 bool ShenandoahMarkingContext::is_complete() {
 74   return _is_complete.is_set();
 75 }
 76 
 77 void ShenandoahMarkingContext::mark_complete() {
 78   _is_complete.set();
 79 }
 80 
 81 void ShenandoahMarkingContext::mark_incomplete() {
 82   _is_complete.unset();
 83 }
</pre>
</td>
</tr>
</table>
<center><a href="shenandoahMarkCompact.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../index.html" target="_top">index</a> <a href="shenandoahMarkingContext.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
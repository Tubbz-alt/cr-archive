diff a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
--- a/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
+++ b/src/hotspot/share/gc/shenandoah/shenandoahHeapRegion.cpp
@@ -26,11 +26,10 @@
 #include "memory/allocation.hpp"
 #include "gc/shenandoah/shenandoahHeapRegionSet.inline.hpp"
 #include "gc/shenandoah/shenandoahHeap.inline.hpp"
 #include "gc/shenandoah/shenandoahHeapRegion.hpp"
 #include "gc/shenandoah/shenandoahMarkingContext.inline.hpp"
-#include "gc/shenandoah/shenandoahTraversalGC.hpp"
 #include "gc/shared/space.inline.hpp"
 #include "jfr/jfrEvents.hpp"
 #include "memory/iterator.inline.hpp"
 #include "memory/resourceArea.hpp"
 #include "memory/universe.hpp"
@@ -51,35 +50,29 @@
 size_t ShenandoahHeapRegion::HumongousThresholdBytes = 0;
 size_t ShenandoahHeapRegion::HumongousThresholdWords = 0;
 size_t ShenandoahHeapRegion::MaxTLABSizeBytes = 0;
 size_t ShenandoahHeapRegion::MaxTLABSizeWords = 0;
 
-ShenandoahHeapRegion::PaddedAllocSeqNum ShenandoahHeapRegion::_alloc_seq_num;
-
-ShenandoahHeapRegion::ShenandoahHeapRegion(ShenandoahHeap* heap, HeapWord* start,
-                                           size_t size_words, size_t index, bool committed) :
-  _heap(heap),
-  _reserved(MemRegion(start, size_words)),
-  _region_number(index),
+ShenandoahHeapRegion::ShenandoahHeapRegion(HeapWord* start, size_t index, bool committed) :
+  _index(index),
+  _bottom(start),
+  _end(start + RegionSizeWords),
   _new_top(NULL),
   _empty_time(os::elapsedTime()),
   _state(committed ? _empty_committed : _empty_uncommitted),
+  _top(start),
   _tlab_allocs(0),
   _gclab_allocs(0),
-  _shared_allocs(0),
-  _seqnum_first_alloc_mutator(0),
-  _seqnum_first_alloc_gc(0),
-  _seqnum_last_alloc_mutator(0),
-  _seqnum_last_alloc_gc(0),
   _live_data(0),
-  _critical_pins(0) {
-
-  ContiguousSpace::initialize(_reserved, true, committed);
-}
+  _critical_pins(0),
+  _update_watermark(start) {
 
-size_t ShenandoahHeapRegion::region_number() const {
-  return _region_number;
+  assert(Universe::on_page_boundary(_bottom) && Universe::on_page_boundary(_end),
+         "invalid space boundaries");
+  if (ZapUnusedHeapArea && committed) {
+    SpaceMangler::mangle_region(MemRegion(_bottom, _end));
+  }
 }
 
 void ShenandoahHeapRegion::report_illegal_transition(const char *method) {
   ResourceMark rm;
   stringStream ss;
@@ -87,11 +80,11 @@
   print_on(&ss);
   fatal("%s", ss.as_string());
 }
 
 void ShenandoahHeapRegion::make_regular_allocation() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
 
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
     case _empty_committed:
@@ -103,12 +96,12 @@
       report_illegal_transition("regular allocation");
   }
 }
 
 void ShenandoahHeapRegion::make_regular_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress() || _heap->is_degenerated_gc_in_progress(),
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress() || ShenandoahHeap::heap()->is_degenerated_gc_in_progress(),
           "only for full or degen GC");
 
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
@@ -128,11 +121,11 @@
       report_illegal_transition("regular bypass");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_start() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
     case _empty_committed:
       set_state(_humongous_start);
@@ -141,12 +134,12 @@
       report_illegal_transition("humongous start allocation");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_start_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress(), "only for full GC");
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress(), "only for full GC");
 
   switch (_state) {
     case _empty_committed:
     case _regular:
     case _humongous_start:
@@ -157,11 +150,11 @@
       report_illegal_transition("humongous start bypass");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_cont() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
     case _empty_committed:
      set_state(_humongous_cont);
@@ -170,12 +163,12 @@
       report_illegal_transition("humongous continuation allocation");
   }
 }
 
 void ShenandoahHeapRegion::make_humongous_cont_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress(), "only for full GC");
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress(), "only for full GC");
 
   switch (_state) {
     case _empty_committed:
     case _regular:
     case _humongous_start:
@@ -186,11 +179,11 @@
       report_illegal_transition("humongous continuation bypass");
   }
 }
 
 void ShenandoahHeapRegion::make_pinned() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   assert(pin_count() > 0, "Should have pins: " SIZE_FORMAT, pin_count());
 
   switch (_state) {
     case _regular:
       set_state(_pinned);
@@ -208,11 +201,11 @@
       report_illegal_transition("pinning");
   }
 }
 
 void ShenandoahHeapRegion::make_unpinned() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   assert(pin_count() == 0, "Should not have pins: " SIZE_FORMAT, pin_count());
 
   switch (_state) {
     case _pinned:
       set_state(_regular);
@@ -230,11 +223,11 @@
       report_illegal_transition("unpinning");
   }
 }
 
 void ShenandoahHeapRegion::make_cset() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _regular:
       set_state(_cset);
     case _cset:
       return;
@@ -242,11 +235,11 @@
       report_illegal_transition("cset");
   }
 }
 
 void ShenandoahHeapRegion::make_trash() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _cset:
       // Reclaiming cset regions
     case _humongous_start:
     case _humongous_cont:
@@ -263,15 +256,15 @@
 void ShenandoahHeapRegion::make_trash_immediate() {
   make_trash();
 
   // On this path, we know there are no marked objects in the region,
   // tell marking context about it to bypass bitmap resets.
-  _heap->complete_marking_context()->reset_top_bitmap(this);
+  ShenandoahHeap::heap()->complete_marking_context()->reset_top_bitmap(this);
 }
 
 void ShenandoahHeapRegion::make_empty() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _trash:
       set_state(_empty_committed);
       _empty_time = os::elapsedTime();
       return;
@@ -279,11 +272,11 @@
       report_illegal_transition("emptying");
   }
 }
 
 void ShenandoahHeapRegion::make_uncommitted() {
-  _heap->assert_heaplock_owned_by_current_thread();
+  shenandoah_assert_heaplocked();
   switch (_state) {
     case _empty_committed:
       do_uncommit();
       set_state(_empty_uncommitted);
       return;
@@ -291,12 +284,12 @@
       report_illegal_transition("uncommiting");
   }
 }
 
 void ShenandoahHeapRegion::make_committed_bypass() {
-  _heap->assert_heaplock_owned_by_current_thread();
-  assert (_heap->is_full_gc_in_progress(), "only for full GC");
+  shenandoah_assert_heaplocked();
+  assert (ShenandoahHeap::heap()->is_full_gc_in_progress(), "only for full GC");
 
   switch (_state) {
     case _empty_uncommitted:
       do_commit();
       set_state(_empty_committed);
@@ -304,41 +297,17 @@
     default:
       report_illegal_transition("commit bypass");
   }
 }
 
-void ShenandoahHeapRegion::clear_live_data() {
-  Atomic::release_store_fence(&_live_data, (size_t)0);
-}
-
 void ShenandoahHeapRegion::reset_alloc_metadata() {
   _tlab_allocs = 0;
   _gclab_allocs = 0;
-  _shared_allocs = 0;
-  _seqnum_first_alloc_mutator = 0;
-  _seqnum_last_alloc_mutator = 0;
-  _seqnum_first_alloc_gc = 0;
-  _seqnum_last_alloc_gc = 0;
-}
-
-void ShenandoahHeapRegion::reset_alloc_metadata_to_shared() {
-  if (used() > 0) {
-    _tlab_allocs = 0;
-    _gclab_allocs = 0;
-    _shared_allocs = used() >> LogHeapWordSize;
-    uint64_t next = _alloc_seq_num.value++;
-    _seqnum_first_alloc_mutator = next;
-    _seqnum_last_alloc_mutator = next;
-    _seqnum_first_alloc_gc = 0;
-    _seqnum_last_alloc_gc = 0;
-  } else {
-    reset_alloc_metadata();
-  }
 }
 
 size_t ShenandoahHeapRegion::get_shared_allocs() const {
-  return _shared_allocs * HeapWordSize;
+  return used() - (_tlab_allocs + _gclab_allocs) * HeapWordSize;
 }
 
 size_t ShenandoahHeapRegion::get_tlab_allocs() const {
   return _tlab_allocs * HeapWordSize;
 }
@@ -350,33 +319,13 @@
 void ShenandoahHeapRegion::set_live_data(size_t s) {
   assert(Thread::current()->is_VM_thread(), "by VM thread");
   _live_data = (s >> LogHeapWordSize);
 }
 
-size_t ShenandoahHeapRegion::get_live_data_words() const {
-  return Atomic::load_acquire(&_live_data);
-}
-
-size_t ShenandoahHeapRegion::get_live_data_bytes() const {
-  return get_live_data_words() * HeapWordSize;
-}
-
-bool ShenandoahHeapRegion::has_live() const {
-  return get_live_data_words() != 0;
-}
-
-size_t ShenandoahHeapRegion::garbage() const {
-  assert(used() >= get_live_data_bytes(), "Live Data must be a subset of used() live: " SIZE_FORMAT " used: " SIZE_FORMAT,
-         get_live_data_bytes(), used());
-
-  size_t result = used() - get_live_data_bytes();
-  return result;
-}
-
 void ShenandoahHeapRegion::print_on(outputStream* st) const {
   st->print("|");
-  st->print(SIZE_FORMAT_W(5), this->_region_number);
+  st->print(SIZE_FORMAT_W(5), this->_index);
 
   switch (_state) {
     case _empty_uncommitted:
       st->print("|EU ");
       break;
@@ -411,20 +360,19 @@
       ShouldNotReachHere();
   }
   st->print("|BTE " INTPTR_FORMAT_W(12) ", " INTPTR_FORMAT_W(12) ", " INTPTR_FORMAT_W(12),
             p2i(bottom()), p2i(top()), p2i(end()));
   st->print("|TAMS " INTPTR_FORMAT_W(12),
-            p2i(_heap->marking_context()->top_at_mark_start(const_cast<ShenandoahHeapRegion*>(this))));
+            p2i(ShenandoahHeap::heap()->marking_context()->top_at_mark_start(const_cast<ShenandoahHeapRegion*>(this))));
+  st->print("|UWM " INTPTR_FORMAT_W(12),
+            p2i(_update_watermark));
   st->print("|U " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(used()),                proper_unit_for_byte_size(used()));
   st->print("|T " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_tlab_allocs()),     proper_unit_for_byte_size(get_tlab_allocs()));
   st->print("|G " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_gclab_allocs()),    proper_unit_for_byte_size(get_gclab_allocs()));
   st->print("|S " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_shared_allocs()),   proper_unit_for_byte_size(get_shared_allocs()));
   st->print("|L " SIZE_FORMAT_W(5) "%1s", byte_size_in_proper_unit(get_live_data_bytes()), proper_unit_for_byte_size(get_live_data_bytes()));
   st->print("|CP " SIZE_FORMAT_W(3), pin_count());
-  st->print("|SN " UINT64_FORMAT_X_W(12) ", " UINT64_FORMAT_X_W(8) ", " UINT64_FORMAT_X_W(8) ", " UINT64_FORMAT_X_W(8),
-            seqnum_first_alloc_mutator(), seqnum_last_alloc_mutator(),
-            seqnum_first_alloc_gc(), seqnum_last_alloc_gc());
   st->cr();
 }
 
 void ShenandoahHeapRegion::oop_iterate(OopIterateClosure* blk) {
   if (!is_active()) return;
@@ -454,38 +402,41 @@
   oop obj = oop(r->bottom());
   obj->oop_iterate(blk, MemRegion(bottom(), top()));
 }
 
 ShenandoahHeapRegion* ShenandoahHeapRegion::humongous_start_region() const {
+  ShenandoahHeap* heap = ShenandoahHeap::heap();
   assert(is_humongous(), "Must be a part of the humongous region");
-  size_t reg_num = region_number();
+  size_t i = index();
   ShenandoahHeapRegion* r = const_cast<ShenandoahHeapRegion*>(this);
   while (!r->is_humongous_start()) {
-    assert(reg_num > 0, "Sanity");
-    reg_num --;
-    r = _heap->get_region(reg_num);
+    assert(i > 0, "Sanity");
+    i--;
+    r = heap->get_region(i);
     assert(r->is_humongous(), "Must be a part of the humongous region");
   }
   assert(r->is_humongous_start(), "Must be");
   return r;
 }
 
 void ShenandoahHeapRegion::recycle() {
-  ContiguousSpace::clear(false);
-  if (ZapUnusedHeapArea) {
-    ContiguousSpace::mangle_unused_area_complete();
-  }
+  set_top(bottom());
   clear_live_data();
 
   reset_alloc_metadata();
 
-  _heap->marking_context()->reset_top_at_mark_start(this);
+  ShenandoahHeap::heap()->marking_context()->reset_top_at_mark_start(this);
+  set_update_watermark(bottom());
 
   make_empty();
+
+  if (ZapUnusedHeapArea) {
+    SpaceMangler::mangle_region(MemRegion(bottom(), end()));
+  }
 }
 
-HeapWord* ShenandoahHeapRegion::block_start_const(const void* p) const {
+HeapWord* ShenandoahHeapRegion::block_start(const void* p) const {
   assert(MemRegion(bottom(), end()).contains(p),
          "p (" PTR_FORMAT ") not in space [" PTR_FORMAT ", " PTR_FORMAT ")",
          p2i(p), p2i(bottom()), p2i(end()));
   if (p >= top()) {
     return top();
@@ -499,20 +450,32 @@
     shenandoah_assert_correct(NULL, oop(last));
     return last;
   }
 }
 
+size_t ShenandoahHeapRegion::block_size(const HeapWord* p) const {
+  assert(MemRegion(bottom(), end()).contains(p),
+         "p (" PTR_FORMAT ") not in space [" PTR_FORMAT ", " PTR_FORMAT ")",
+         p2i(p), p2i(bottom()), p2i(end()));
+  if (p < top()) {
+    return oop(p)->size();
+  } else {
+    assert(p == top(), "just checking");
+    return pointer_delta(end(), (HeapWord*) p);
+  }
+}
+
 void ShenandoahHeapRegion::setup_sizes(size_t max_heap_size) {
   // Absolute minimums we should not ever break.
   static const size_t MIN_REGION_SIZE = 256*K;
 
   if (FLAG_IS_DEFAULT(ShenandoahMinRegionSize)) {
     FLAG_SET_DEFAULT(ShenandoahMinRegionSize, MIN_REGION_SIZE);
   }
 
   size_t region_size;
-  if (FLAG_IS_DEFAULT(ShenandoahHeapRegionSize)) {
+  if (FLAG_IS_DEFAULT(ShenandoahRegionSize)) {
     if (ShenandoahMinRegionSize > max_heap_size / MIN_NUM_REGIONS) {
       err_msg message("Max heap size (" SIZE_FORMAT "%s) is too low to afford the minimum number "
                       "of regions (" SIZE_FORMAT ") of minimum region size (" SIZE_FORMAT "%s).",
                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
                       MIN_NUM_REGIONS,
@@ -551,31 +514,31 @@
     // Now make sure that we don't go over or under our limits.
     region_size = MAX2(ShenandoahMinRegionSize, region_size);
     region_size = MIN2(ShenandoahMaxRegionSize, region_size);
 
   } else {
-    if (ShenandoahHeapRegionSize > max_heap_size / MIN_NUM_REGIONS) {
+    if (ShenandoahRegionSize > max_heap_size / MIN_NUM_REGIONS) {
       err_msg message("Max heap size (" SIZE_FORMAT "%s) is too low to afford the minimum number "
                               "of regions (" SIZE_FORMAT ") of requested size (" SIZE_FORMAT "%s).",
                       byte_size_in_proper_unit(max_heap_size), proper_unit_for_byte_size(max_heap_size),
                       MIN_NUM_REGIONS,
-                      byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize));
-      vm_exit_during_initialization("Invalid -XX:ShenandoahHeapRegionSize option", message);
+                      byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize));
+      vm_exit_during_initialization("Invalid -XX:ShenandoahRegionSize option", message);
     }
-    if (ShenandoahHeapRegionSize < ShenandoahMinRegionSize) {
+    if (ShenandoahRegionSize < ShenandoahMinRegionSize) {
       err_msg message("Heap region size (" SIZE_FORMAT "%s) should be larger than min region size (" SIZE_FORMAT "%s).",
-                      byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),
+                      byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize),
                       byte_size_in_proper_unit(ShenandoahMinRegionSize),  proper_unit_for_byte_size(ShenandoahMinRegionSize));
-      vm_exit_during_initialization("Invalid -XX:ShenandoahHeapRegionSize option", message);
+      vm_exit_during_initialization("Invalid -XX:ShenandoahRegionSize option", message);
     }
-    if (ShenandoahHeapRegionSize > ShenandoahMaxRegionSize) {
+    if (ShenandoahRegionSize > ShenandoahMaxRegionSize) {
       err_msg message("Heap region size (" SIZE_FORMAT "%s) should be lower than max region size (" SIZE_FORMAT "%s).",
-                      byte_size_in_proper_unit(ShenandoahHeapRegionSize), proper_unit_for_byte_size(ShenandoahHeapRegionSize),
+                      byte_size_in_proper_unit(ShenandoahRegionSize), proper_unit_for_byte_size(ShenandoahRegionSize),
                       byte_size_in_proper_unit(ShenandoahMaxRegionSize),  proper_unit_for_byte_size(ShenandoahMaxRegionSize));
-      vm_exit_during_initialization("Invalid -XX:ShenandoahHeapRegionSize option", message);
+      vm_exit_during_initialization("Invalid -XX:ShenandoahRegionSize option", message);
     }
-    region_size = ShenandoahHeapRegionSize;
+    region_size = ShenandoahRegionSize;
   }
 
   // Make sure region size is at least one large page, if enabled.
   // Otherwise, uncommitting one region may falsely uncommit the adjacent
   // regions too.
@@ -654,33 +617,35 @@
   log_info(gc, init)("Max TLAB size: " SIZE_FORMAT "%s",
                      byte_size_in_proper_unit(MaxTLABSizeBytes), proper_unit_for_byte_size(MaxTLABSizeBytes));
 }
 
 void ShenandoahHeapRegion::do_commit() {
-  if (!_heap->is_heap_region_special() && !os::commit_memory((char *) _reserved.start(), _reserved.byte_size(), false)) {
+  ShenandoahHeap* heap = ShenandoahHeap::heap();
+  if (!heap->is_heap_region_special() && !os::commit_memory((char *) bottom(), RegionSizeBytes, false)) {
     report_java_out_of_memory("Unable to commit region");
   }
-  if (!_heap->commit_bitmap_slice(this)) {
+  if (!heap->commit_bitmap_slice(this)) {
     report_java_out_of_memory("Unable to commit bitmaps for region");
   }
-  _heap->increase_committed(ShenandoahHeapRegion::region_size_bytes());
+  heap->increase_committed(ShenandoahHeapRegion::region_size_bytes());
 }
 
 void ShenandoahHeapRegion::do_uncommit() {
-  if (!_heap->is_heap_region_special() && !os::uncommit_memory((char *) _reserved.start(), _reserved.byte_size())) {
+  ShenandoahHeap* heap = ShenandoahHeap::heap();
+  if (!heap->is_heap_region_special() && !os::uncommit_memory((char *) bottom(), RegionSizeBytes)) {
     report_java_out_of_memory("Unable to uncommit region");
   }
-  if (!_heap->uncommit_bitmap_slice(this)) {
+  if (!heap->uncommit_bitmap_slice(this)) {
     report_java_out_of_memory("Unable to uncommit bitmaps for region");
   }
-  _heap->decrease_committed(ShenandoahHeapRegion::region_size_bytes());
+  heap->decrease_committed(ShenandoahHeapRegion::region_size_bytes());
 }
 
 void ShenandoahHeapRegion::set_state(RegionState to) {
   EventShenandoahHeapRegionStateChange evt;
   if (evt.should_commit()){
-    evt.set_index((unsigned)region_number());
+    evt.set_index((unsigned) index());
     evt.set_start((uintptr_t)bottom());
     evt.set_used(used());
     evt.set_from(_state);
     evt.set_to(to);
     evt.commit();
@@ -691,11 +656,11 @@
 void ShenandoahHeapRegion::record_pin() {
   Atomic::add(&_critical_pins, (size_t)1);
 }
 
 void ShenandoahHeapRegion::record_unpin() {
-  assert(pin_count() > 0, "Region " SIZE_FORMAT " should have non-zero pins", region_number());
+  assert(pin_count() > 0, "Region " SIZE_FORMAT " should have non-zero pins", index());
   Atomic::sub(&_critical_pins, (size_t)1);
 }
 
 size_t ShenandoahHeapRegion::pin_count() const {
   return Atomic::load(&_critical_pins);

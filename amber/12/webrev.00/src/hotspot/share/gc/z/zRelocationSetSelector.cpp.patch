diff a/src/hotspot/share/gc/z/zRelocationSetSelector.cpp b/src/hotspot/share/gc/z/zRelocationSetSelector.cpp
--- a/src/hotspot/share/gc/z/zRelocationSetSelector.cpp
+++ b/src/hotspot/share/gc/z/zRelocationSetSelector.cpp
@@ -24,10 +24,11 @@
 #include "precompiled.hpp"
 #include "gc/z/zArray.inline.hpp"
 #include "gc/z/zPage.inline.hpp"
 #include "gc/z/zRelocationSet.hpp"
 #include "gc/z/zRelocationSetSelector.inline.hpp"
+#include "jfr/jfrEvents.hpp"
 #include "logging/log.hpp"
 #include "runtime/globals.hpp"
 #include "utilities/debug.hpp"
 #include "utilities/powerOfTwo.hpp"
 
@@ -39,13 +40,15 @@
     _empty(0),
     _compacting_from(0),
     _compacting_to(0) {}
 
 ZRelocationSetSelectorGroup::ZRelocationSetSelectorGroup(const char* name,
+                                                         uint8_t page_type,
                                                          size_t page_size,
                                                          size_t object_size_limit) :
     _name(name),
+    _page_type(page_type),
     _page_size(page_size),
     _object_size_limit(object_size_limit),
     _fragmentation_limit(page_size * (ZFragmentationLimit / 100)),
     _registered_pages(),
     _sorted_pages(NULL),
@@ -79,10 +82,20 @@
   _stats._total += size;
   _stats._garbage += size;
   _stats._empty += size;
 }
 
+bool ZRelocationSetSelectorGroup::is_disabled() {
+  // Medium pages are disabled when their page size is zero
+  return _page_type == ZPageTypeMedium && _page_size == 0;
+}
+
+bool ZRelocationSetSelectorGroup::is_selectable() {
+  // Large pages are not selectable
+  return _page_type != ZPageTypeLarge;
+}
+
 void ZRelocationSetSelectorGroup::semi_sort() {
   // Semi-sort registered pages by live bytes in ascending order
   const size_t npartitions_shift = 11;
   const size_t npartitions = (size_t)1 << npartitions_shift;
   const size_t partition_size = _page_size >> npartitions_shift;
@@ -121,16 +134,11 @@
     assert(_sorted_pages[finger] == NULL, "Invalid finger");
     _sorted_pages[finger] = page;
   }
 }
 
-void ZRelocationSetSelectorGroup::select() {
-  if (_page_size == 0) {
-    // Page type disabled
-    return;
-  }
-
+void ZRelocationSetSelectorGroup::select_inner() {
   // Calculate the number of pages to relocate by successively including pages in
   // a candidate relocation set and calculate the maximum space requirement for
   // their live objects.
   const size_t npages = _registered_pages.size();
   size_t selected_from = 0;
@@ -175,14 +183,30 @@
 
   log_trace(gc, reloc)("Relocation Set (%s Pages): " SIZE_FORMAT "->" SIZE_FORMAT ", " SIZE_FORMAT " skipped",
                        _name, selected_from, selected_to, npages - _nselected);
 }
 
+void ZRelocationSetSelectorGroup::select() {
+  if (is_disabled()) {
+    return;
+  }
+
+  EventZRelocationSetGroup event;
+
+  if (is_selectable()) {
+    select_inner();
+  }
+
+  // Send event
+  event.commit(_page_type, _stats.npages(), _stats.total(), _stats.empty(),
+               _stats.compacting_from(), _stats.compacting_to());
+}
+
 ZRelocationSetSelector::ZRelocationSetSelector() :
-    _small("Small", ZPageSizeSmall, ZObjectSizeLimitSmall),
-    _medium("Medium", ZPageSizeMedium, ZObjectSizeLimitMedium),
-    _large("Large", 0 /* page_size */, 0 /* object_size_limit */) {}
+    _small("Small", ZPageTypeSmall, ZPageSizeSmall, ZObjectSizeLimitSmall),
+    _medium("Medium", ZPageTypeMedium, ZPageSizeMedium, ZObjectSizeLimitMedium),
+    _large("Large", ZPageTypeLarge, 0 /* page_size */, 0 /* object_size_limit */) {}
 
 void ZRelocationSetSelector::register_live_page(ZPage* page) {
   const uint8_t type = page->type();
 
   if (type == ZPageTypeSmall) {
@@ -211,17 +235,23 @@
   // sorted such that medium pages comes first, followed by small
   // pages. Pages within each page group will be semi-sorted by live
   // bytes in ascending order. Relocating pages in this order allows
   // us to start reclaiming memory more quickly.
 
-  // Select pages from each group, except large
+  EventZRelocationSet event;
+
+  // Select pages from each group
+  _large.select();
   _medium.select();
   _small.select();
 
   // Populate relocation set
   relocation_set->populate(_medium.selected(), _medium.nselected(),
                            _small.selected(), _small.nselected());
+
+  // Send event
+  event.commit(total(), empty(), compacting_from(), compacting_to());
 }
 
 ZRelocationSetSelectorStats ZRelocationSetSelector::stats() const {
   ZRelocationSetSelectorStats stats;
   stats._small = _small.stats();

<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/classfile/classLoader.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;jvm.h&quot;
  27 #include &quot;jimage.hpp&quot;
  28 #include &quot;classfile/classFileStream.hpp&quot;
  29 #include &quot;classfile/classLoader.inline.hpp&quot;
  30 #include &quot;classfile/classLoaderData.inline.hpp&quot;
  31 #include &quot;classfile/classLoaderExt.hpp&quot;
  32 #include &quot;classfile/javaClasses.hpp&quot;
  33 #include &quot;classfile/moduleEntry.hpp&quot;
  34 #include &quot;classfile/modules.hpp&quot;
  35 #include &quot;classfile/packageEntry.hpp&quot;
  36 #include &quot;classfile/klassFactory.hpp&quot;
  37 #include &quot;classfile/symbolTable.hpp&quot;
  38 #include &quot;classfile/systemDictionary.hpp&quot;
  39 #include &quot;classfile/systemDictionaryShared.hpp&quot;
  40 #include &quot;classfile/vmSymbols.hpp&quot;
  41 #include &quot;compiler/compileBroker.hpp&quot;
  42 #include &quot;interpreter/bytecodeStream.hpp&quot;
  43 #include &quot;interpreter/oopMapCache.hpp&quot;
  44 #include &quot;logging/log.hpp&quot;
  45 #include &quot;logging/logStream.hpp&quot;
  46 #include &quot;logging/logTag.hpp&quot;
  47 #include &quot;memory/allocation.inline.hpp&quot;
  48 #include &quot;memory/filemap.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;memory/resourceArea.hpp&quot;
  51 #include &quot;memory/universe.hpp&quot;
  52 #include &quot;oops/instanceKlass.hpp&quot;
  53 #include &quot;oops/instanceRefKlass.hpp&quot;
  54 #include &quot;oops/method.inline.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/symbol.hpp&quot;
  58 #include &quot;prims/jvm_misc.hpp&quot;
  59 #include &quot;runtime/arguments.hpp&quot;
  60 #include &quot;runtime/handles.inline.hpp&quot;
  61 #include &quot;runtime/init.hpp&quot;
  62 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  63 #include &quot;runtime/java.hpp&quot;
  64 #include &quot;runtime/javaCalls.hpp&quot;
  65 #include &quot;runtime/os.inline.hpp&quot;
  66 #include &quot;runtime/threadCritical.hpp&quot;
  67 #include &quot;runtime/timer.hpp&quot;
  68 #include &quot;runtime/vm_version.hpp&quot;
  69 #include &quot;services/management.hpp&quot;
  70 #include &quot;services/threadService.hpp&quot;
  71 #include &quot;utilities/classpathStream.hpp&quot;
  72 #include &quot;utilities/events.hpp&quot;
  73 #include &quot;utilities/hashtable.inline.hpp&quot;
  74 #include &quot;utilities/macros.hpp&quot;
<a name="1" id="anc1"></a>
  75 
  76 // Entry point in java.dll for path canonicalization
  77 
  78 typedef int (*canonicalize_fn_t)(const char *orig, char *out, int len);
  79 
  80 static canonicalize_fn_t CanonicalizeEntry  = NULL;
  81 
  82 // Entry points in zip.dll for loading zip/jar file entries
  83 
  84 typedef void * * (*ZipOpen_t)(const char *name, char **pmsg);
  85 typedef void     (*ZipClose_t)(jzfile *zip);
  86 typedef jzentry* (*FindEntry_t)(jzfile *zip, const char *name, jint *sizeP, jint *nameLen);
  87 typedef jboolean (*ReadEntry_t)(jzfile *zip, jzentry *entry, unsigned char *buf, char *namebuf);
  88 typedef jzentry* (*GetNextEntry_t)(jzfile *zip, jint n);
  89 typedef jint     (*Crc32_t)(jint crc, const jbyte *buf, jint len);
  90 
  91 static ZipOpen_t         ZipOpen            = NULL;
  92 static ZipClose_t        ZipClose           = NULL;
  93 static FindEntry_t       FindEntry          = NULL;
  94 static ReadEntry_t       ReadEntry          = NULL;
  95 static GetNextEntry_t    GetNextEntry       = NULL;
  96 static Crc32_t           Crc32              = NULL;
  97 
  98 // Entry points for jimage.dll for loading jimage file entries
  99 
 100 static JImageOpen_t                    JImageOpen             = NULL;
 101 static JImageClose_t                   JImageClose            = NULL;
 102 static JImagePackageToModule_t         JImagePackageToModule  = NULL;
 103 static JImageFindResource_t            JImageFindResource     = NULL;
 104 static JImageGetResource_t             JImageGetResource      = NULL;
 105 static JImageResourceIterator_t        JImageResourceIterator = NULL;
 106 
 107 // Globals
 108 
 109 PerfCounter*    ClassLoader::_perf_accumulated_time = NULL;
 110 PerfCounter*    ClassLoader::_perf_classes_inited = NULL;
 111 PerfCounter*    ClassLoader::_perf_class_init_time = NULL;
 112 PerfCounter*    ClassLoader::_perf_class_init_selftime = NULL;
 113 PerfCounter*    ClassLoader::_perf_classes_verified = NULL;
 114 PerfCounter*    ClassLoader::_perf_class_verify_time = NULL;
 115 PerfCounter*    ClassLoader::_perf_class_verify_selftime = NULL;
 116 PerfCounter*    ClassLoader::_perf_classes_linked = NULL;
 117 PerfCounter*    ClassLoader::_perf_class_link_time = NULL;
 118 PerfCounter*    ClassLoader::_perf_class_link_selftime = NULL;
<a name="2" id="anc2"></a><span class="line-removed"> 119 PerfCounter*    ClassLoader::_perf_class_parse_time = NULL;</span>
<span class="line-removed"> 120 PerfCounter*    ClassLoader::_perf_class_parse_selftime = NULL;</span>
 121 PerfCounter*    ClassLoader::_perf_sys_class_lookup_time = NULL;
 122 PerfCounter*    ClassLoader::_perf_shared_classload_time = NULL;
 123 PerfCounter*    ClassLoader::_perf_sys_classload_time = NULL;
 124 PerfCounter*    ClassLoader::_perf_app_classload_time = NULL;
 125 PerfCounter*    ClassLoader::_perf_app_classload_selftime = NULL;
 126 PerfCounter*    ClassLoader::_perf_app_classload_count = NULL;
 127 PerfCounter*    ClassLoader::_perf_define_appclasses = NULL;
 128 PerfCounter*    ClassLoader::_perf_define_appclass_time = NULL;
 129 PerfCounter*    ClassLoader::_perf_define_appclass_selftime = NULL;
 130 PerfCounter*    ClassLoader::_perf_app_classfile_bytes_read = NULL;
 131 PerfCounter*    ClassLoader::_perf_sys_classfile_bytes_read = NULL;
 132 PerfCounter*    ClassLoader::_sync_systemLoaderLockContentionRate = NULL;
 133 PerfCounter*    ClassLoader::_sync_nonSystemLoaderLockContentionRate = NULL;
 134 PerfCounter*    ClassLoader::_sync_JVMFindLoadedClassLockFreeCounter = NULL;
 135 PerfCounter*    ClassLoader::_sync_JVMDefineClassLockFreeCounter = NULL;
 136 PerfCounter*    ClassLoader::_sync_JNIDefineClassLockFreeCounter = NULL;
 137 PerfCounter*    ClassLoader::_unsafe_defineClassCallCounter = NULL;
 138 
 139 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_patch_mod_entries = NULL;
 140 GrowableArray&lt;ModuleClassPathList*&gt;* ClassLoader::_exploded_entries = NULL;
 141 ClassPathEntry* ClassLoader::_jrt_entry = NULL;
 142 ClassPathEntry* ClassLoader::_first_append_entry = NULL;
 143 ClassPathEntry* ClassLoader::_last_append_entry  = NULL;
 144 #if INCLUDE_CDS
 145 ClassPathEntry* ClassLoader::_app_classpath_entries = NULL;
 146 ClassPathEntry* ClassLoader::_last_app_classpath_entry = NULL;
 147 ClassPathEntry* ClassLoader::_module_path_entries = NULL;
 148 ClassPathEntry* ClassLoader::_last_module_path_entry = NULL;
 149 #endif
 150 
 151 // helper routines
 152 bool string_starts_with(const char* str, const char* str_to_find) {
 153   size_t str_len = strlen(str);
 154   size_t str_to_find_len = strlen(str_to_find);
 155   if (str_to_find_len &gt; str_len) {
 156     return false;
 157   }
 158   return (strncmp(str, str_to_find, str_to_find_len) == 0);
 159 }
 160 
 161 static const char* get_jimage_version_string() {
 162   static char version_string[10] = &quot;&quot;;
 163   if (version_string[0] == &#39;\0&#39;) {
 164     jio_snprintf(version_string, sizeof(version_string), &quot;%d.%d&quot;,
 165                  VM_Version::vm_major_version(), VM_Version::vm_minor_version());
 166   }
 167   return (const char*)version_string;
 168 }
 169 
 170 bool ClassLoader::string_ends_with(const char* str, const char* str_to_find) {
 171   size_t str_len = strlen(str);
 172   size_t str_to_find_len = strlen(str_to_find);
 173   if (str_to_find_len &gt; str_len) {
 174     return false;
 175   }
 176   return (strncmp(str + (str_len - str_to_find_len), str_to_find, str_to_find_len) == 0);
 177 }
 178 
 179 // Used to obtain the package name from a fully qualified class name.
<a name="3" id="anc3"></a><span class="line-modified"> 180 // It is the responsibility of the caller to establish a ResourceMark.</span>
<span class="line-modified"> 181 const char* ClassLoader::package_from_name(const char* const class_name, bool* bad_class_name) {</span>
<span class="line-removed"> 182   if (class_name == NULL) {</span>
 183     if (bad_class_name != NULL) {
 184       *bad_class_name = true;
 185     }
 186     return NULL;
 187   }
 188 
<a name="4" id="anc4"></a><span class="line-modified"> 189   if (bad_class_name != NULL) {</span>
<span class="line-modified"> 190     *bad_class_name = false;</span>
<span class="line-modified"> 191   }</span>
<span class="line-modified"> 192 </span>
<span class="line-modified"> 193   const char* const last_slash = strrchr(class_name, JVM_SIGNATURE_SLASH);</span>
<span class="line-removed"> 194   if (last_slash == NULL) {</span>
<span class="line-removed"> 195     // No package name</span>
 196     return NULL;
 197   }
<a name="5" id="anc5"></a><span class="line-removed"> 198 </span>
<span class="line-removed"> 199   char* class_name_ptr = (char*) class_name;</span>
 200   // Skip over &#39;[&#39;s
<a name="6" id="anc6"></a><span class="line-modified"> 201   if (*class_name_ptr == JVM_SIGNATURE_ARRAY) {</span>
 202     do {
<a name="7" id="anc7"></a><span class="line-modified"> 203       class_name_ptr++;</span>
<span class="line-modified"> 204     } while (*class_name_ptr == JVM_SIGNATURE_ARRAY);</span>
 205 
 206     // Fully qualified class names should not contain a &#39;L&#39;.
 207     // Set bad_class_name to true to indicate that the package name
 208     // could not be obtained due to an error condition.
 209     // In this situation, is_same_class_package returns false.
<a name="8" id="anc8"></a><span class="line-modified"> 210     if (*class_name_ptr == JVM_SIGNATURE_CLASS) {</span>
 211       if (bad_class_name != NULL) {
 212         *bad_class_name = true;
 213       }
 214       return NULL;
 215     }
 216   }
<a name="9" id="anc9"></a><span class="line-modified"> 217 </span>
<span class="line-modified"> 218   int length = last_slash - class_name_ptr;</span>
<span class="line-modified"> 219 </span>
<span class="line-removed"> 220   // A class name could have just the slash character in the name.</span>
<span class="line-removed"> 221   if (length &lt;= 0) {</span>
 222     // No package name
 223     if (bad_class_name != NULL) {
 224       *bad_class_name = true;
 225     }
 226     return NULL;
 227   }
<a name="10" id="anc10"></a><span class="line-modified"> 228 </span>
<span class="line-removed"> 229   // drop name after last slash (including slash)</span>
<span class="line-removed"> 230   // Ex., &quot;java/lang/String.class&quot; =&gt; &quot;java/lang&quot;</span>
<span class="line-removed"> 231   char* pkg_name = NEW_RESOURCE_ARRAY(char, length + 1);</span>
<span class="line-removed"> 232   strncpy(pkg_name, class_name_ptr, length);</span>
<span class="line-removed"> 233   *(pkg_name+length) = &#39;\0&#39;;</span>
<span class="line-removed"> 234 </span>
<span class="line-removed"> 235   return (const char *)pkg_name;</span>
 236 }
 237 
<a name="11" id="anc11"></a><span class="line-modified"> 238 // Given a fully qualified class name, find its defining package in the class loader&#39;s</span>
 239 // package entry table.
<a name="12" id="anc12"></a><span class="line-modified"> 240 PackageEntry* ClassLoader::get_package_entry(const char* class_name, ClassLoaderData* loader_data, TRAPS) {</span>
<span class="line-removed"> 241   ResourceMark rm(THREAD);</span>
<span class="line-removed"> 242   const char *pkg_name = ClassLoader::package_from_name(class_name);</span>
 243   if (pkg_name == NULL) {
 244     return NULL;
 245   }
 246   PackageEntryTable* pkgEntryTable = loader_data-&gt;packages();
<a name="13" id="anc13"></a><span class="line-modified"> 247   TempNewSymbol pkg_symbol = SymbolTable::new_symbol(pkg_name);</span>
<span class="line-removed"> 248   return pkgEntryTable-&gt;lookup_only(pkg_symbol);</span>
 249 }
 250 
 251 const char* ClassPathEntry::copy_path(const char* path) {
 252   char* copy = NEW_C_HEAP_ARRAY(char, strlen(path)+1, mtClass);
 253   strcpy(copy, path);
 254   return copy;
 255 }
 256 
 257 ClassFileStream* ClassPathDirEntry::open_stream(const char* name, TRAPS) {
 258   // construct full path name
 259   assert((_dir != NULL) &amp;&amp; (name != NULL), &quot;sanity&quot;);
 260   size_t path_len = strlen(_dir) + strlen(name) + strlen(os::file_separator()) + 1;
 261   char* path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, path_len);
 262   int len = jio_snprintf(path, path_len, &quot;%s%s%s&quot;, _dir, os::file_separator(), name);
 263   assert(len == (int)(path_len - 1), &quot;sanity&quot;);
 264   // check if file exists
 265   struct stat st;
 266   if (os::stat(path, &amp;st) == 0) {
 267     // found file, open it
 268     int file_handle = os::open(path, 0, 0);
 269     if (file_handle != -1) {
 270       // read contents into resource array
 271       u1* buffer = NEW_RESOURCE_ARRAY(u1, st.st_size);
 272       size_t num_read = os::read(file_handle, (char*) buffer, st.st_size);
 273       // close file
 274       os::close(file_handle);
 275       // construct ClassFileStream
 276       if (num_read == (size_t)st.st_size) {
 277         if (UsePerfData) {
 278           ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(num_read);
 279         }
 280         FREE_RESOURCE_ARRAY(char, path, path_len);
 281         // Resource allocated
 282         return new ClassFileStream(buffer,
 283                                    st.st_size,
 284                                    _dir,
 285                                    ClassFileStream::verify);
 286       }
 287     }
 288   }
 289   FREE_RESOURCE_ARRAY(char, path, path_len);
 290   return NULL;
 291 }
 292 
 293 ClassPathZipEntry::ClassPathZipEntry(jzfile* zip, const char* zip_name,
 294                                      bool is_boot_append, bool from_class_path_attr) : ClassPathEntry() {
 295   _zip = zip;
 296   _zip_name = copy_path(zip_name);
 297   _from_class_path_attr = from_class_path_attr;
 298 }
 299 
 300 ClassPathZipEntry::~ClassPathZipEntry() {
 301   (*ZipClose)(_zip);
 302   FREE_C_HEAP_ARRAY(char, _zip_name);
 303 }
 304 
 305 u1* ClassPathZipEntry::open_entry(const char* name, jint* filesize, bool nul_terminate, TRAPS) {
 306     // enable call to C land
 307   JavaThread* thread = JavaThread::current();
 308   ThreadToNativeFromVM ttn(thread);
 309   // check whether zip archive contains name
 310   jint name_len;
 311   jzentry* entry = (*FindEntry)(_zip, name, filesize, &amp;name_len);
 312   if (entry == NULL) return NULL;
 313   u1* buffer;
 314   char name_buf[128];
 315   char* filename;
 316   if (name_len &lt; 128) {
 317     filename = name_buf;
 318   } else {
 319     filename = NEW_RESOURCE_ARRAY(char, name_len + 1);
 320   }
 321 
 322   // read contents into resource array
 323   int size = (*filesize) + ((nul_terminate) ? 1 : 0);
 324   buffer = NEW_RESOURCE_ARRAY(u1, size);
 325   if (!(*ReadEntry)(_zip, entry, buffer, filename)) return NULL;
 326 
 327   // return result
 328   if (nul_terminate) {
 329     buffer[*filesize] = 0;
 330   }
 331   return buffer;
 332 }
 333 
 334 ClassFileStream* ClassPathZipEntry::open_stream(const char* name, TRAPS) {
 335   jint filesize;
 336   u1* buffer = open_entry(name, &amp;filesize, false, CHECK_NULL);
 337   if (buffer == NULL) {
 338     return NULL;
 339   }
 340   if (UsePerfData) {
 341     ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(filesize);
 342   }
 343   // Resource allocated
 344   return new ClassFileStream(buffer,
 345                              filesize,
 346                              _zip_name,
 347                              ClassFileStream::verify);
 348 }
 349 
 350 // invoke function for each entry in the zip file
 351 void ClassPathZipEntry::contents_do(void f(const char* name, void* context), void* context) {
 352   JavaThread* thread = JavaThread::current();
 353   HandleMark  handle_mark(thread);
 354   ThreadToNativeFromVM ttn(thread);
 355   for (int n = 0; ; n++) {
 356     jzentry * ze = ((*GetNextEntry)(_zip, n));
 357     if (ze == NULL) break;
 358     (*f)(ze-&gt;name, context);
 359   }
 360 }
 361 
 362 DEBUG_ONLY(ClassPathImageEntry* ClassPathImageEntry::_singleton = NULL;)
 363 
 364 void ClassPathImageEntry::close_jimage() {
 365   if (_jimage != NULL) {
 366     (*JImageClose)(_jimage);
 367     _jimage = NULL;
 368   }
 369 }
 370 
 371 ClassPathImageEntry::ClassPathImageEntry(JImageFile* jimage, const char* name) :
 372   ClassPathEntry(),
 373   _jimage(jimage) {
 374   guarantee(jimage != NULL, &quot;jimage file is null&quot;);
 375   guarantee(name != NULL, &quot;jimage file name is null&quot;);
 376   assert(_singleton == NULL, &quot;VM supports only one jimage&quot;);
 377   DEBUG_ONLY(_singleton = this);
 378   size_t len = strlen(name) + 1;
 379   _name = copy_path(name);
 380 }
 381 
 382 ClassPathImageEntry::~ClassPathImageEntry() {
 383   assert(_singleton == this, &quot;must be&quot;);
 384   DEBUG_ONLY(_singleton = NULL);
 385 
 386   FREE_C_HEAP_ARRAY(const char, _name);
 387 
 388   if (_jimage != NULL) {
 389     (*JImageClose)(_jimage);
 390     _jimage = NULL;
 391   }
 392 }
 393 
 394 ClassFileStream* ClassPathImageEntry::open_stream(const char* name, TRAPS) {
 395   return open_stream_for_loader(name, ClassLoaderData::the_null_class_loader_data(), THREAD);
 396 }
 397 
 398 // For a class in a named module, look it up in the jimage file using this syntax:
 399 //    /&lt;module-name&gt;/&lt;package-name&gt;/&lt;base-class&gt;
 400 //
 401 // Assumptions:
 402 //     1. There are no unnamed modules in the jimage file.
 403 //     2. A package is in at most one module in the jimage file.
 404 //
 405 ClassFileStream* ClassPathImageEntry::open_stream_for_loader(const char* name, ClassLoaderData* loader_data, TRAPS) {
 406   jlong size;
 407   JImageLocationRef location = (*JImageFindResource)(_jimage, &quot;&quot;, get_jimage_version_string(), name, &amp;size);
 408 
 409   if (location == 0) {
<a name="14" id="anc14"></a><span class="line-modified"> 410     ResourceMark rm;</span>
<span class="line-modified"> 411     const char* pkg_name = ClassLoader::package_from_name(name);</span>
 412 
 413     if (pkg_name != NULL) {
 414       if (!Universe::is_module_initialized()) {
 415         location = (*JImageFindResource)(_jimage, JAVA_BASE_NAME, get_jimage_version_string(), name, &amp;size);
 416       } else {
<a name="15" id="anc15"></a><span class="line-modified"> 417         PackageEntry* package_entry = ClassLoader::get_package_entry(name, loader_data, CHECK_NULL);</span>
 418         if (package_entry != NULL) {
<a name="16" id="anc16"></a><span class="line-modified"> 419           ResourceMark rm;</span>
 420           // Get the module name
 421           ModuleEntry* module = package_entry-&gt;module();
 422           assert(module != NULL, &quot;Boot classLoader package missing module&quot;);
 423           assert(module-&gt;is_named(), &quot;Boot classLoader package is in unnamed module&quot;);
 424           const char* module_name = module-&gt;name()-&gt;as_C_string();
 425           if (module_name != NULL) {
 426             location = (*JImageFindResource)(_jimage, module_name, get_jimage_version_string(), name, &amp;size);
 427           }
 428         }
 429       }
 430     }
 431   }
 432   if (location != 0) {
 433     if (UsePerfData) {
 434       ClassLoader::perf_sys_classfile_bytes_read()-&gt;inc(size);
 435     }
 436     char* data = NEW_RESOURCE_ARRAY(char, size);
 437     (*JImageGetResource)(_jimage, location, data, size);
 438     // Resource allocated
 439     assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be&quot;);
 440     return new ClassFileStream((u1*)data,
 441                                (int)size,
 442                                _name,
 443                                ClassFileStream::verify,
 444                                true); // from_boot_loader_modules_image
 445   }
 446 
 447   return NULL;
 448 }
 449 
 450 JImageLocationRef ClassLoader::jimage_find_resource(JImageFile* jf,
 451                                                     const char* module_name,
 452                                                     const char* file_name,
 453                                                     jlong &amp;size) {
 454   return ((*JImageFindResource)(jf, module_name, get_jimage_version_string(), file_name, &amp;size));
 455 }
 456 
 457 bool ClassPathImageEntry::is_modules_image() const {
 458   assert(this == _singleton, &quot;VM supports a single jimage&quot;);
 459   assert(this == (ClassPathImageEntry*)ClassLoader::get_jrt_entry(), &quot;must be used for jrt entry&quot;);
 460   return true;
 461 }
 462 
 463 #if INCLUDE_CDS
 464 void ClassLoader::exit_with_path_failure(const char* error, const char* message) {
 465   Arguments::assert_is_dumping_archive();
 466   tty-&gt;print_cr(&quot;Hint: enable -Xlog:class+path=info to diagnose the failure&quot;);
 467   vm_exit_during_initialization(error, message);
 468 }
 469 #endif
 470 
 471 ModuleClassPathList::ModuleClassPathList(Symbol* module_name) {
 472   _module_name = module_name;
 473   _module_first_entry = NULL;
 474   _module_last_entry = NULL;
 475 }
 476 
 477 ModuleClassPathList::~ModuleClassPathList() {
 478   // Clean out each ClassPathEntry on list
 479   ClassPathEntry* e = _module_first_entry;
 480   while (e != NULL) {
 481     ClassPathEntry* next_entry = e-&gt;next();
 482     delete e;
 483     e = next_entry;
 484   }
 485 }
 486 
 487 void ModuleClassPathList::add_to_list(ClassPathEntry* new_entry) {
 488   if (new_entry != NULL) {
 489     if (_module_last_entry == NULL) {
 490       _module_first_entry = _module_last_entry = new_entry;
 491     } else {
 492       _module_last_entry-&gt;set_next(new_entry);
 493       _module_last_entry = new_entry;
 494     }
 495   }
 496 }
 497 
 498 void ClassLoader::trace_class_path(const char* msg, const char* name) {
 499   LogTarget(Info, class, path) lt;
 500   if (lt.is_enabled()) {
 501     LogStream ls(lt);
 502     if (msg) {
 503       ls.print(&quot;%s&quot;, msg);
 504     }
 505     if (name) {
 506       if (strlen(name) &lt; 256) {
 507         ls.print(&quot;%s&quot;, name);
 508       } else {
 509         // For very long paths, we need to print each character separately,
 510         // as print_cr() has a length limit
 511         while (name[0] != &#39;\0&#39;) {
 512           ls.print(&quot;%c&quot;, name[0]);
 513           name++;
 514         }
 515       }
 516     }
 517     ls.cr();
 518   }
 519 }
 520 
 521 void ClassLoader::setup_bootstrap_search_path() {
 522   const char* sys_class_path = Arguments::get_sysclasspath();
 523   assert(sys_class_path != NULL, &quot;System boot class path must not be NULL&quot;);
 524   if (PrintSharedArchiveAndExit) {
 525     // Don&#39;t print sys_class_path - this is the bootcp of this current VM process, not necessarily
 526     // the same as the bootcp of the shared archive.
 527   } else {
 528     trace_class_path(&quot;bootstrap loader class path=&quot;, sys_class_path);
 529   }
 530   setup_boot_search_path(sys_class_path);
 531 }
 532 
 533 #if INCLUDE_CDS
 534 void ClassLoader::setup_app_search_path(const char *class_path) {
 535   Arguments::assert_is_dumping_archive();
 536 
 537   ResourceMark rm;
 538   ClasspathStream cp_stream(class_path);
 539 
 540   while (cp_stream.has_next()) {
 541     const char* path = cp_stream.get_next();
 542     update_class_path_entry_list(path, false, false, false);
 543   }
 544 }
 545 
 546 void ClassLoader::add_to_module_path_entries(const char* path,
 547                                              ClassPathEntry* entry) {
 548   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
 549   Arguments::assert_is_dumping_archive();
 550 
 551   // The entry does not exist, add to the list
 552   if (_module_path_entries == NULL) {
 553     assert(_last_module_path_entry == NULL, &quot;Sanity&quot;);
 554     _module_path_entries = _last_module_path_entry = entry;
 555   } else {
 556     _last_module_path_entry-&gt;set_next(entry);
 557     _last_module_path_entry = entry;
 558   }
 559 }
 560 
 561 // Add a module path to the _module_path_entries list.
 562 void ClassLoader::update_module_path_entry_list(const char *path, TRAPS) {
 563   Arguments::assert_is_dumping_archive();
 564   struct stat st;
 565   if (os::stat(path, &amp;st) != 0) {
 566     tty-&gt;print_cr(&quot;os::stat error %d (%s). CDS dump aborted (path was \&quot;%s\&quot;).&quot;,
 567       errno, os::errno_name(errno), path);
 568     vm_exit_during_initialization();
 569   }
 570   // File or directory found
 571   ClassPathEntry* new_entry = NULL;
 572   new_entry = create_class_path_entry(path, &amp;st, true /* throw_exception */,
 573                                       false /*is_boot_append */, false /* from_class_path_attr */, CHECK);
 574   if (new_entry == NULL) {
 575     return;
 576   }
 577 
 578   add_to_module_path_entries(path, new_entry);
 579   return;
 580 }
 581 
 582 void ClassLoader::setup_module_search_path(const char* path, TRAPS) {
 583   update_module_path_entry_list(path, THREAD);
 584 }
 585 
 586 #endif // INCLUDE_CDS
 587 
 588 void ClassLoader::close_jrt_image() {
 589   // Not applicable for exploded builds
 590   if (!ClassLoader::has_jrt_entry()) return;
 591   _jrt_entry-&gt;close_jimage();
 592 }
 593 
 594 // Construct the array of module/path pairs as specified to --patch-module
 595 // for the boot loader to search ahead of the jimage, if the class being
 596 // loaded is defined to a module that has been specified to --patch-module.
 597 void ClassLoader::setup_patch_mod_entries() {
 598   Thread* THREAD = Thread::current();
 599   GrowableArray&lt;ModulePatchPath*&gt;* patch_mod_args = Arguments::get_patch_mod_prefix();
 600   int num_of_entries = patch_mod_args-&gt;length();
 601 
 602   // Set up the boot loader&#39;s _patch_mod_entries list
 603   _patch_mod_entries = new (ResourceObj::C_HEAP, mtModule) GrowableArray&lt;ModuleClassPathList*&gt;(num_of_entries, true);
 604 
 605   for (int i = 0; i &lt; num_of_entries; i++) {
 606     const char* module_name = (patch_mod_args-&gt;at(i))-&gt;module_name();
 607     Symbol* const module_sym = SymbolTable::new_symbol(module_name);
 608     assert(module_sym != NULL, &quot;Failed to obtain Symbol for module name&quot;);
 609     ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 610 
 611     char* class_path = (patch_mod_args-&gt;at(i))-&gt;path_string();
 612     ResourceMark rm(THREAD);
 613     ClasspathStream cp_stream(class_path);
 614 
 615     while (cp_stream.has_next()) {
 616       const char* path = cp_stream.get_next();
 617       struct stat st;
 618       if (os::stat(path, &amp;st) == 0) {
 619         // File or directory found
 620         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 621         // If the path specification is valid, enter it into this module&#39;s list
 622         if (new_entry != NULL) {
 623           module_cpl-&gt;add_to_list(new_entry);
 624         }
 625       }
 626     }
 627 
 628     // Record the module into the list of --patch-module entries only if
 629     // valid ClassPathEntrys have been created
 630     if (module_cpl-&gt;module_first_entry() != NULL) {
 631       _patch_mod_entries-&gt;push(module_cpl);
 632     }
 633   }
 634 }
 635 
 636 // Determine whether the module has been patched via the command-line
 637 // option --patch-module
 638 bool ClassLoader::is_in_patch_mod_entries(Symbol* module_name) {
 639   if (_patch_mod_entries != NULL &amp;&amp; _patch_mod_entries-&gt;is_nonempty()) {
 640     int table_len = _patch_mod_entries-&gt;length();
 641     for (int i = 0; i &lt; table_len; i++) {
 642       ModuleClassPathList* patch_mod = _patch_mod_entries-&gt;at(i);
 643       if (module_name-&gt;fast_compare(patch_mod-&gt;module_name()) == 0) {
 644         return true;
 645       }
 646     }
 647   }
 648   return false;
 649 }
 650 
 651 // Set up the _jrt_entry if present and boot append path
 652 void ClassLoader::setup_boot_search_path(const char *class_path) {
 653   EXCEPTION_MARK;
 654   ResourceMark rm(THREAD);
 655   ClasspathStream cp_stream(class_path);
 656   bool set_base_piece = true;
 657 
 658 #if INCLUDE_CDS
 659   if (Arguments::is_dumping_archive()) {
 660     if (!Arguments::has_jimage()) {
 661       vm_exit_during_initialization(&quot;CDS is not supported in exploded JDK build&quot;, NULL);
 662     }
 663   }
 664 #endif
 665 
 666   while (cp_stream.has_next()) {
 667     const char* path = cp_stream.get_next();
 668 
 669     if (set_base_piece) {
 670       // The first time through the bootstrap_search setup, it must be determined
 671       // what the base or core piece of the boot loader search is.  Either a java runtime
 672       // image is present or this is an exploded module build situation.
 673       assert(string_ends_with(path, MODULES_IMAGE_NAME) || string_ends_with(path, JAVA_BASE_NAME),
 674              &quot;Incorrect boot loader search path, no java runtime image or &quot; JAVA_BASE_NAME &quot; exploded build&quot;);
 675       struct stat st;
 676       if (os::stat(path, &amp;st) == 0) {
 677         // Directory found
 678         ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 679 
 680         // Check for a jimage
 681         if (Arguments::has_jimage()) {
 682           assert(_jrt_entry == NULL, &quot;should not setup bootstrap class search path twice&quot;);
 683           _jrt_entry = new_entry;
 684           assert(new_entry != NULL &amp;&amp; new_entry-&gt;is_modules_image(), &quot;No java runtime image present&quot;);
 685           assert(_jrt_entry-&gt;jimage() != NULL, &quot;No java runtime image&quot;);
 686         }
 687       } else {
 688         // If path does not exist, exit
 689         vm_exit_during_initialization(&quot;Unable to establish the boot loader search path&quot;, path);
 690       }
 691       set_base_piece = false;
 692     } else {
 693       // Every entry on the system boot class path after the initial base piece,
 694       // which is set by os::set_boot_path(), is considered an appended entry.
 695       update_class_path_entry_list(path, false, true, false);
 696     }
 697   }
 698 }
 699 
 700 // During an exploded modules build, each module defined to the boot loader
 701 // will be added to the ClassLoader::_exploded_entries array.
 702 void ClassLoader::add_to_exploded_build_list(Symbol* module_sym, TRAPS) {
 703   assert(!ClassLoader::has_jrt_entry(), &quot;Exploded build not applicable&quot;);
 704   assert(_exploded_entries != NULL, &quot;_exploded_entries was not initialized&quot;);
 705 
 706   // Find the module&#39;s symbol
 707   ResourceMark rm(THREAD);
 708   const char *module_name = module_sym-&gt;as_C_string();
 709   const char *home = Arguments::get_java_home();
 710   const char file_sep = os::file_separator()[0];
 711   // 10 represents the length of &quot;modules&quot; + 2 file separators + \0
 712   size_t len = strlen(home) + strlen(module_name) + 10;
 713   char *path = NEW_RESOURCE_ARRAY(char, len);
 714   jio_snprintf(path, len, &quot;%s%cmodules%c%s&quot;, home, file_sep, file_sep, module_name);
 715 
 716   struct stat st;
 717   if (os::stat(path, &amp;st) == 0) {
 718     // Directory found
 719     ClassPathEntry* new_entry = create_class_path_entry(path, &amp;st, false, false, false, CHECK);
 720 
 721     // If the path specification is valid, enter it into this module&#39;s list.
 722     // There is no need to check for duplicate modules in the exploded entry list,
 723     // since no two modules with the same name can be defined to the boot loader.
 724     // This is checked at module definition time in Modules::define_module.
 725     if (new_entry != NULL) {
 726       ModuleClassPathList* module_cpl = new ModuleClassPathList(module_sym);
 727       module_cpl-&gt;add_to_list(new_entry);
 728       {
 729         MutexLocker ml(THREAD, Module_lock);
 730         _exploded_entries-&gt;push(module_cpl);
 731       }
 732       log_info(class, load)(&quot;path: %s&quot;, path);
 733     }
 734   }
 735 }
 736 
 737 ClassPathEntry* ClassLoader::create_class_path_entry(const char *path, const struct stat* st,
 738                                                      bool throw_exception,
 739                                                      bool is_boot_append,
 740                                                      bool from_class_path_attr,
 741                                                      TRAPS) {
 742   JavaThread* thread = JavaThread::current();
 743   ClassPathEntry* new_entry = NULL;
 744   if ((st-&gt;st_mode &amp; S_IFMT) == S_IFREG) {
 745     ResourceMark rm(thread);
 746     // Regular file, should be a zip or jimage file
 747     // Canonicalized filename
 748     char* canonical_path = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, JVM_MAXPATHLEN);
 749     if (!get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 750       // This matches the classic VM
 751       if (throw_exception) {
 752         THROW_MSG_(vmSymbols::java_io_IOException(), &quot;Bad pathname&quot;, NULL);
 753       } else {
 754         return NULL;
 755       }
 756     }
 757     jint error;
 758     JImageFile* jimage =(*JImageOpen)(canonical_path, &amp;error);
 759     if (jimage != NULL) {
 760       new_entry = new ClassPathImageEntry(jimage, canonical_path);
 761     } else {
 762       char* error_msg = NULL;
 763       jzfile* zip;
 764       {
 765         // enable call to C land
 766         ThreadToNativeFromVM ttn(thread);
 767         HandleMark hm(thread);
 768         zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 769       }
 770       if (zip != NULL &amp;&amp; error_msg == NULL) {
 771         new_entry = new ClassPathZipEntry(zip, path, is_boot_append, from_class_path_attr);
 772       } else {
 773         char *msg;
 774         if (error_msg == NULL) {
 775           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, strlen(path) + 128); ;
 776           jio_snprintf(msg, strlen(path) + 127, &quot;error in opening JAR file %s&quot;, path);
 777         } else {
 778           int len = (int)(strlen(path) + strlen(error_msg) + 128);
 779           msg = NEW_RESOURCE_ARRAY_IN_THREAD(thread, char, len); ;
 780           jio_snprintf(msg, len - 1, &quot;error in opening JAR file &lt;%s&gt; %s&quot;, error_msg, path);
 781         }
 782         // Don&#39;t complain about bad jar files added via -Xbootclasspath/a:.
 783         if (throw_exception &amp;&amp; is_init_completed()) {
 784           THROW_MSG_(vmSymbols::java_lang_ClassNotFoundException(), msg, NULL);
 785         } else {
 786           return NULL;
 787         }
 788       }
 789     }
 790     log_info(class, path)(&quot;opened: %s&quot;, path);
 791     log_info(class, load)(&quot;opened: %s&quot;, path);
 792   } else {
 793     // Directory
 794     new_entry = new ClassPathDirEntry(path);
 795     log_info(class, load)(&quot;path: %s&quot;, path);
 796   }
 797   return new_entry;
 798 }
 799 
 800 
 801 // Create a class path zip entry for a given path (return NULL if not found
 802 // or zip/JAR file cannot be opened)
 803 ClassPathZipEntry* ClassLoader::create_class_path_zip_entry(const char *path, bool is_boot_append) {
 804   // check for a regular file
 805   struct stat st;
 806   if (os::stat(path, &amp;st) == 0) {
 807     if ((st.st_mode &amp; S_IFMT) == S_IFREG) {
 808       char canonical_path[JVM_MAXPATHLEN];
 809       if (get_canonical_path(path, canonical_path, JVM_MAXPATHLEN)) {
 810         char* error_msg = NULL;
 811         jzfile* zip;
 812         {
 813           // enable call to C land
 814           JavaThread* thread = JavaThread::current();
 815           ThreadToNativeFromVM ttn(thread);
 816           HandleMark hm(thread);
 817           zip = (*ZipOpen)(canonical_path, &amp;error_msg);
 818         }
 819         if (zip != NULL &amp;&amp; error_msg == NULL) {
 820           // create using canonical path
 821           return new ClassPathZipEntry(zip, canonical_path, is_boot_append, false);
 822         }
 823       }
 824     }
 825   }
 826   return NULL;
 827 }
 828 
 829 // returns true if entry already on class path
 830 bool ClassLoader::contains_append_entry(const char* name) {
 831   ClassPathEntry* e = _first_append_entry;
 832   while (e != NULL) {
 833     // assume zip entries have been canonicalized
 834     if (strcmp(name, e-&gt;name()) == 0) {
 835       return true;
 836     }
 837     e = e-&gt;next();
 838   }
 839   return false;
 840 }
 841 
 842 void ClassLoader::add_to_boot_append_entries(ClassPathEntry *new_entry) {
 843   if (new_entry != NULL) {
 844     if (_last_append_entry == NULL) {
 845       assert(_first_append_entry == NULL, &quot;boot loader&#39;s append class path entry list not empty&quot;);
 846       _first_append_entry = _last_append_entry = new_entry;
 847     } else {
 848       _last_append_entry-&gt;set_next(new_entry);
 849       _last_append_entry = new_entry;
 850     }
 851   }
 852 }
 853 
 854 // Record the path entries specified in -cp during dump time. The recorded
 855 // information will be used at runtime for loading the archived app classes.
 856 //
 857 // Note that at dump time, ClassLoader::_app_classpath_entries are NOT used for
 858 // loading app classes. Instead, the app class are loaded by the
 859 // jdk/internal/loader/ClassLoaders$AppClassLoader instance.
 860 void ClassLoader::add_to_app_classpath_entries(const char* path,
 861                                                ClassPathEntry* entry,
 862                                                bool check_for_duplicates) {
 863 #if INCLUDE_CDS
 864   assert(entry != NULL, &quot;ClassPathEntry should not be NULL&quot;);
 865   ClassPathEntry* e = _app_classpath_entries;
 866   if (check_for_duplicates) {
 867     while (e != NULL) {
 868       if (strcmp(e-&gt;name(), entry-&gt;name()) == 0) {
 869         // entry already exists
 870         return;
 871       }
 872       e = e-&gt;next();
 873     }
 874   }
 875 
 876   // The entry does not exist, add to the list
 877   if (_app_classpath_entries == NULL) {
 878     assert(_last_app_classpath_entry == NULL, &quot;Sanity&quot;);
 879     _app_classpath_entries = _last_app_classpath_entry = entry;
 880   } else {
 881     _last_app_classpath_entry-&gt;set_next(entry);
 882     _last_app_classpath_entry = entry;
 883   }
 884 
 885   if (entry-&gt;is_jar_file()) {
 886     ClassLoaderExt::process_jar_manifest(entry, check_for_duplicates);
 887   }
 888 #endif
 889 }
 890 
 891 // Returns true IFF the file/dir exists and the entry was successfully created.
 892 bool ClassLoader::update_class_path_entry_list(const char *path,
 893                                                bool check_for_duplicates,
 894                                                bool is_boot_append,
 895                                                bool from_class_path_attr,
 896                                                bool throw_exception) {
 897   struct stat st;
 898   if (os::stat(path, &amp;st) == 0) {
 899     // File or directory found
 900     ClassPathEntry* new_entry = NULL;
 901     Thread* THREAD = Thread::current();
 902     new_entry = create_class_path_entry(path, &amp;st, throw_exception, is_boot_append, from_class_path_attr, CHECK_(false));
 903     if (new_entry == NULL) {
 904       return false;
 905     }
 906 
 907     // Do not reorder the bootclasspath which would break get_system_package().
 908     // Add new entry to linked list
 909     if (is_boot_append) {
 910       add_to_boot_append_entries(new_entry);
 911     } else {
 912       add_to_app_classpath_entries(path, new_entry, check_for_duplicates);
 913     }
 914     return true;
 915   } else {
 916     return false;
 917   }
 918 }
 919 
 920 static void print_module_entry_table(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
 921   ResourceMark rm;
 922   int num_of_entries = module_list-&gt;length();
 923   for (int i = 0; i &lt; num_of_entries; i++) {
 924     ClassPathEntry* e;
 925     ModuleClassPathList* mpl = module_list-&gt;at(i);
 926     tty-&gt;print(&quot;%s=&quot;, mpl-&gt;module_name()-&gt;as_C_string());
 927     e = mpl-&gt;module_first_entry();
 928     while (e != NULL) {
 929       tty-&gt;print(&quot;%s&quot;, e-&gt;name());
 930       e = e-&gt;next();
 931       if (e != NULL) {
 932         tty-&gt;print(&quot;%s&quot;, os::path_separator());
 933       }
 934     }
 935     tty-&gt;print(&quot; ;&quot;);
 936   }
 937 }
 938 
 939 void ClassLoader::print_bootclasspath() {
 940   ClassPathEntry* e;
 941   tty-&gt;print(&quot;[bootclasspath= &quot;);
 942 
 943   // Print --patch-module module/path specifications first
 944   if (_patch_mod_entries != NULL) {
 945     print_module_entry_table(_patch_mod_entries);
 946   }
 947 
 948   // [jimage | exploded modules build]
 949   if (has_jrt_entry()) {
 950     // Print the location of the java runtime image
 951     tty-&gt;print(&quot;%s ;&quot;, _jrt_entry-&gt;name());
 952   } else {
 953     // Print exploded module build path specifications
 954     if (_exploded_entries != NULL) {
 955       print_module_entry_table(_exploded_entries);
 956     }
 957   }
 958 
 959   // appended entries
 960   e = _first_append_entry;
 961   while (e != NULL) {
 962     tty-&gt;print(&quot;%s ;&quot;, e-&gt;name());
 963     e = e-&gt;next();
 964   }
 965   tty-&gt;print_cr(&quot;]&quot;);
 966 }
 967 
 968 void* ClassLoader::dll_lookup(void* lib, const char* name, const char* path) {
 969   void* func = os::dll_lookup(lib, name);
 970   if (func == NULL) {
 971     char msg[256] = &quot;&quot;;
 972     jio_snprintf(msg, sizeof(msg), &quot;Could not resolve \&quot;%s\&quot;&quot;, name);
 973     vm_exit_during_initialization(msg, path);
 974   }
 975   return func;
 976 }
 977 
 978 void ClassLoader::load_java_library() {
 979   assert(CanonicalizeEntry == NULL, &quot;should not load java library twice&quot;);
 980   void *javalib_handle = os::native_java_library();
 981   if (javalib_handle == NULL) {
 982     vm_exit_during_initialization(&quot;Unable to load java library&quot;, NULL);
 983   }
 984 
 985   CanonicalizeEntry = CAST_TO_FN_PTR(canonicalize_fn_t, dll_lookup(javalib_handle, &quot;JDK_Canonicalize&quot;, NULL));
 986 }
 987 
 988 void ClassLoader::load_zip_library() {
 989   assert(ZipOpen == NULL, &quot;should not load zip library twice&quot;);
 990   char path[JVM_MAXPATHLEN];
 991   char ebuf[1024];
 992   void* handle = NULL;
 993   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;zip&quot;)) {
 994     handle = os::dll_load(path, ebuf, sizeof ebuf);
 995   }
 996   if (handle == NULL) {
 997     vm_exit_during_initialization(&quot;Unable to load zip library&quot;, path);
 998   }
 999 
1000   ZipOpen = CAST_TO_FN_PTR(ZipOpen_t, dll_lookup(handle, &quot;ZIP_Open&quot;, path));
1001   ZipClose = CAST_TO_FN_PTR(ZipClose_t, dll_lookup(handle, &quot;ZIP_Close&quot;, path));
1002   FindEntry = CAST_TO_FN_PTR(FindEntry_t, dll_lookup(handle, &quot;ZIP_FindEntry&quot;, path));
1003   ReadEntry = CAST_TO_FN_PTR(ReadEntry_t, dll_lookup(handle, &quot;ZIP_ReadEntry&quot;, path));
1004   GetNextEntry = CAST_TO_FN_PTR(GetNextEntry_t, dll_lookup(handle, &quot;ZIP_GetNextEntry&quot;, path));
1005   Crc32 = CAST_TO_FN_PTR(Crc32_t, dll_lookup(handle, &quot;ZIP_CRC32&quot;, path));
1006 }
1007 
1008 void ClassLoader::load_jimage_library() {
1009   assert(JImageOpen == NULL, &quot;should not load jimage library twice&quot;);
1010   char path[JVM_MAXPATHLEN];
1011   char ebuf[1024];
1012   void* handle = NULL;
1013   if (os::dll_locate_lib(path, sizeof(path), Arguments::get_dll_dir(), &quot;jimage&quot;)) {
1014     handle = os::dll_load(path, ebuf, sizeof ebuf);
1015   }
1016   if (handle == NULL) {
1017     vm_exit_during_initialization(&quot;Unable to load jimage library&quot;, path);
1018   }
1019 
1020   JImageOpen = CAST_TO_FN_PTR(JImageOpen_t, dll_lookup(handle, &quot;JIMAGE_Open&quot;, path));
1021   JImageClose = CAST_TO_FN_PTR(JImageClose_t, dll_lookup(handle, &quot;JIMAGE_Close&quot;, path));
1022   JImagePackageToModule = CAST_TO_FN_PTR(JImagePackageToModule_t, dll_lookup(handle, &quot;JIMAGE_PackageToModule&quot;, path));
1023   JImageFindResource = CAST_TO_FN_PTR(JImageFindResource_t, dll_lookup(handle, &quot;JIMAGE_FindResource&quot;, path));
1024   JImageGetResource = CAST_TO_FN_PTR(JImageGetResource_t, dll_lookup(handle, &quot;JIMAGE_GetResource&quot;, path));
1025   JImageResourceIterator = CAST_TO_FN_PTR(JImageResourceIterator_t, dll_lookup(handle, &quot;JIMAGE_ResourceIterator&quot;, path));
1026 }
1027 
1028 int ClassLoader::crc32(int crc, const char* buf, int len) {
1029   return (*Crc32)(crc, (const jbyte*)buf, len);
1030 }
1031 
<a name="17" id="anc17"></a><span class="line-modified">1032 // Function add_package extracts the package from the fully qualified class name</span>
<span class="line-modified">1033 // and checks if the package is in the boot loader&#39;s package entry table.  If so,</span>
<span class="line-modified">1034 // then it sets the classpath_index in the package entry record.</span>
1035 //
1036 // The classpath_index field is used to find the entry on the boot loader class
1037 // path for packages with classes loaded by the boot loader from -Xbootclasspath/a
1038 // in an unnamed module.  It is also used to indicate (for all packages whose
1039 // classes are loaded by the boot loader) that at least one of the package&#39;s
1040 // classes has been loaded.
<a name="18" id="anc18"></a><span class="line-modified">1041 bool ClassLoader::add_package(const char *fullq_class_name, s2 classpath_index, TRAPS) {</span>
<span class="line-modified">1042   assert(fullq_class_name != NULL, &quot;just checking&quot;);</span>
1043 
<a name="19" id="anc19"></a><span class="line-modified">1044   // Get package name from fully qualified class name.</span>
<span class="line-modified">1045   ResourceMark rm(THREAD);</span>
<span class="line-removed">1046   const char *cp = package_from_name(fullq_class_name);</span>
<span class="line-removed">1047   if (cp != NULL) {</span>
1048     PackageEntryTable* pkg_entry_tbl = ClassLoaderData::the_null_class_loader_data()-&gt;packages();
<a name="20" id="anc20"></a><span class="line-modified">1049     TempNewSymbol pkg_symbol = SymbolTable::new_symbol(cp);</span>
<span class="line-removed">1050     PackageEntry* pkg_entry = pkg_entry_tbl-&gt;lookup_only(pkg_symbol);</span>
1051     if (pkg_entry != NULL) {
1052       assert(classpath_index != -1, &quot;Unexpected classpath_index&quot;);
1053       pkg_entry-&gt;set_classpath_index(classpath_index);
1054     } else {
1055       return false;
1056     }
1057   }
1058   return true;
1059 }
1060 
1061 oop ClassLoader::get_system_package(const char* name, TRAPS) {
1062   // Look up the name in the boot loader&#39;s package entry table.
1063   if (name != NULL) {
1064     TempNewSymbol package_sym = SymbolTable::new_symbol(name);
1065     // Look for the package entry in the boot loader&#39;s package entry table.
1066     PackageEntry* package =
1067       ClassLoaderData::the_null_class_loader_data()-&gt;packages()-&gt;lookup_only(package_sym);
1068 
1069     // Return NULL if package does not exist or if no classes in that package
1070     // have been loaded.
1071     if (package != NULL &amp;&amp; package-&gt;has_loaded_class()) {
1072       ModuleEntry* module = package-&gt;module();
1073       if (module-&gt;location() != NULL) {
1074         ResourceMark rm(THREAD);
1075         Handle ml = java_lang_String::create_from_str(
1076           module-&gt;location()-&gt;as_C_string(), THREAD);
1077         return ml();
1078       }
1079       // Return entry on boot loader class path.
1080       Handle cph = java_lang_String::create_from_str(
1081         ClassLoader::classpath_entry(package-&gt;classpath_index())-&gt;name(), THREAD);
1082       return cph();
1083     }
1084   }
1085   return NULL;
1086 }
1087 
1088 objArrayOop ClassLoader::get_system_packages(TRAPS) {
1089   ResourceMark rm(THREAD);
1090   // List of pointers to PackageEntrys that have loaded classes.
1091   GrowableArray&lt;PackageEntry*&gt;* loaded_class_pkgs = new GrowableArray&lt;PackageEntry*&gt;(50);
1092   {
1093     MutexLocker ml(THREAD, Module_lock);
1094 
1095     PackageEntryTable* pe_table =
1096       ClassLoaderData::the_null_class_loader_data()-&gt;packages();
1097 
1098     // Collect the packages that have at least one loaded class.
1099     for (int x = 0; x &lt; pe_table-&gt;table_size(); x++) {
1100       for (PackageEntry* package_entry = pe_table-&gt;bucket(x);
1101            package_entry != NULL;
1102            package_entry = package_entry-&gt;next()) {
1103         if (package_entry-&gt;has_loaded_class()) {
1104           loaded_class_pkgs-&gt;append(package_entry);
1105         }
1106       }
1107     }
1108   }
1109 
1110 
1111   // Allocate objArray and fill with java.lang.String
1112   objArrayOop r = oopFactory::new_objArray(SystemDictionary::String_klass(),
1113                                            loaded_class_pkgs-&gt;length(), CHECK_NULL);
1114   objArrayHandle result(THREAD, r);
1115   for (int x = 0; x &lt; loaded_class_pkgs-&gt;length(); x++) {
1116     PackageEntry* package_entry = loaded_class_pkgs-&gt;at(x);
1117     Handle str = java_lang_String::create_from_symbol(package_entry-&gt;name(), CHECK_NULL);
1118     result-&gt;obj_at_put(x, str());
1119   }
1120   return result();
1121 }
1122 
1123 // caller needs ResourceMark
1124 const char* ClassLoader::file_name_for_class_name(const char* class_name,
1125                                                   int class_name_len) {
1126   assert(class_name != NULL, &quot;invariant&quot;);
1127   assert((int)strlen(class_name) == class_name_len, &quot;invariant&quot;);
1128 
1129   static const char class_suffix[] = &quot;.class&quot;;
1130   size_t class_suffix_len = sizeof(class_suffix);
1131 
1132   char* const file_name = NEW_RESOURCE_ARRAY(char,
1133                                              class_name_len +
1134                                              class_suffix_len); // includes term NULL
1135 
1136   strncpy(file_name, class_name, class_name_len);
1137   strncpy(&amp;file_name[class_name_len], class_suffix, class_suffix_len);
1138 
1139   return file_name;
1140 }
1141 
1142 ClassPathEntry* find_first_module_cpe(ModuleEntry* mod_entry,
1143                                       const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list) {
1144   int num_of_entries = module_list-&gt;length();
1145   const Symbol* class_module_name = mod_entry-&gt;name();
1146 
1147   // Loop through all the modules in either the patch-module or exploded entries looking for module
1148   for (int i = 0; i &lt; num_of_entries; i++) {
1149     ModuleClassPathList* module_cpl = module_list-&gt;at(i);
1150     Symbol* module_cpl_name = module_cpl-&gt;module_name();
1151 
1152     if (module_cpl_name-&gt;fast_compare(class_module_name) == 0) {
1153       // Class&#39; module has been located.
1154       return module_cpl-&gt;module_first_entry();
1155     }
1156   }
1157   return NULL;
1158 }
1159 
1160 
1161 // Search either the patch-module or exploded build entries for class.
1162 ClassFileStream* ClassLoader::search_module_entries(const GrowableArray&lt;ModuleClassPathList*&gt;* const module_list,
1163                                                     const char* const class_name,
1164                                                     const char* const file_name,
1165                                                     TRAPS) {
1166   ClassFileStream* stream = NULL;
1167 
1168   // Find the class&#39; defining module in the boot loader&#39;s module entry table
<a name="21" id="anc21"></a><span class="line-modified">1169   PackageEntry* pkg_entry = get_package_entry(class_name, ClassLoaderData::the_null_class_loader_data(), CHECK_NULL);</span>


1170   ModuleEntry* mod_entry = (pkg_entry != NULL) ? pkg_entry-&gt;module() : NULL;
1171 
1172   // If the module system has not defined java.base yet, then
1173   // classes loaded are assumed to be defined to java.base.
1174   // When java.base is eventually defined by the module system,
1175   // all packages of classes that have been previously loaded
1176   // are verified in ModuleEntryTable::verify_javabase_packages().
1177   if (!Universe::is_module_initialized() &amp;&amp;
1178       !ModuleEntryTable::javabase_defined() &amp;&amp;
1179       mod_entry == NULL) {
1180     mod_entry = ModuleEntryTable::javabase_moduleEntry();
1181   }
1182 
1183   // The module must be a named module
1184   ClassPathEntry* e = NULL;
1185   if (mod_entry != NULL &amp;&amp; mod_entry-&gt;is_named()) {
1186     if (module_list == _exploded_entries) {
1187       // The exploded build entries can be added to at any time so a lock is
1188       // needed when searching them.
1189       assert(!ClassLoader::has_jrt_entry(), &quot;Must be exploded build&quot;);
1190       MutexLocker ml(THREAD, Module_lock);
1191       e = find_first_module_cpe(mod_entry, module_list);
1192     } else {
1193       e = find_first_module_cpe(mod_entry, module_list);
1194     }
1195   }
1196 
1197   // Try to load the class from the module&#39;s ClassPathEntry list.
1198   while (e != NULL) {
1199     stream = e-&gt;open_stream(file_name, CHECK_NULL);
1200     // No context.check is required since CDS is not supported
1201     // for an exploded modules build or if --patch-module is specified.
1202     if (NULL != stream) {
1203       return stream;
1204     }
1205     e = e-&gt;next();
1206   }
1207   // If the module was located, break out even if the class was not
1208   // located successfully from that module&#39;s ClassPathEntry list.
1209   // There will not be another valid entry for that module.
1210   return NULL;
1211 }
1212 
1213 // Called by the boot classloader to load classes
1214 InstanceKlass* ClassLoader::load_class(Symbol* name, bool search_append_only, TRAPS) {
1215   assert(name != NULL, &quot;invariant&quot;);
1216   assert(THREAD-&gt;is_Java_thread(), &quot;must be a JavaThread&quot;);
1217 
1218   ResourceMark rm(THREAD);
1219   HandleMark hm(THREAD);
1220 
1221   const char* const class_name = name-&gt;as_C_string();
1222 
1223   EventMark m(&quot;loading class %s&quot;, class_name);
1224 
1225   const char* const file_name = file_name_for_class_name(class_name,
1226                                                          name-&gt;utf8_length());
1227   assert(file_name != NULL, &quot;invariant&quot;);
1228 
1229   // Lookup stream for parsing .class file
1230   ClassFileStream* stream = NULL;
1231   s2 classpath_index = 0;
1232   ClassPathEntry* e = NULL;
1233 
1234   // If search_append_only is true, boot loader visibility boundaries are
1235   // set to be _first_append_entry to the end. This includes:
1236   //   [-Xbootclasspath/a]; [jvmti appended entries]
1237   //
1238   // If search_append_only is false, boot loader visibility boundaries are
1239   // set to be the --patch-module entries plus the base piece. This includes:
1240   //   [--patch-module=&lt;module&gt;=&lt;file&gt;(&lt;pathsep&gt;&lt;file&gt;)*]; [jimage | exploded module build]
1241   //
1242 
1243   // Load Attempt #1: --patch-module
1244   // Determine the class&#39; defining module.  If it appears in the _patch_mod_entries,
1245   // attempt to load the class from those locations specific to the module.
1246   // Specifications to --patch-module can contain a partial number of classes
1247   // that are part of the overall module definition.  So if a particular class is not
1248   // found within its module specification, the search should continue to Load Attempt #2.
1249   // Note: The --patch-module entries are never searched if the boot loader&#39;s
1250   //       visibility boundary is limited to only searching the append entries.
1251   if (_patch_mod_entries != NULL &amp;&amp; !search_append_only) {
1252     // At CDS dump time, the --patch-module entries are ignored. That means a
1253     // class is still loaded from the runtime image even if it might
1254     // appear in the _patch_mod_entries. The runtime shared class visibility
1255     // check will determine if a shared class is visible based on the runtime
1256     // environemnt, including the runtime --patch-module setting.
1257     //
1258     // DynamicDumpSharedSpaces requires UseSharedSpaces to be enabled. Since --patch-module
1259     // is not supported with UseSharedSpaces, it is not supported with DynamicDumpSharedSpaces.
1260     assert(!DynamicDumpSharedSpaces, &quot;sanity&quot;);
1261     if (!DumpSharedSpaces) {
1262       stream = search_module_entries(_patch_mod_entries, class_name, file_name, CHECK_NULL);
1263     }
1264   }
1265 
1266   // Load Attempt #2: [jimage | exploded build]
1267   if (!search_append_only &amp;&amp; (NULL == stream)) {
1268     if (has_jrt_entry()) {
1269       e = _jrt_entry;
1270       stream = _jrt_entry-&gt;open_stream(file_name, CHECK_NULL);
1271     } else {
1272       // Exploded build - attempt to locate class in its defining module&#39;s location.
1273       assert(_exploded_entries != NULL, &quot;No exploded build entries present&quot;);
1274       stream = search_module_entries(_exploded_entries, class_name, file_name, CHECK_NULL);
1275     }
1276   }
1277 
1278   // Load Attempt #3: [-Xbootclasspath/a]; [jvmti appended entries]
1279   if (search_append_only &amp;&amp; (NULL == stream)) {
1280     // For the boot loader append path search, the starting classpath_index
1281     // for the appended piece is always 1 to account for either the
1282     // _jrt_entry or the _exploded_entries.
1283     assert(classpath_index == 0, &quot;The classpath_index has been incremented incorrectly&quot;);
1284     classpath_index = 1;
1285 
1286     e = _first_append_entry;
1287     while (e != NULL) {
1288       stream = e-&gt;open_stream(file_name, CHECK_NULL);
1289       if (NULL != stream) {
1290         break;
1291       }
1292       e = e-&gt;next();
1293       ++classpath_index;
1294     }
1295   }
1296 
1297   if (NULL == stream) {
1298     return NULL;
1299   }
1300 
1301   stream-&gt;set_verify(ClassLoaderExt::should_verify(classpath_index));
1302 
1303   ClassLoaderData* loader_data = ClassLoaderData::the_null_class_loader_data();
1304   Handle protection_domain;
1305 
1306   InstanceKlass* result = KlassFactory::create_from_stream(stream,
1307                                                            name,
1308                                                            loader_data,
1309                                                            protection_domain,
1310                                                            NULL, // unsafe_anonymous_host
1311                                                            NULL, // cp_patches
1312                                                            THREAD);
1313   if (HAS_PENDING_EXCEPTION) {
1314     if (DumpSharedSpaces) {
1315       log_error(cds)(&quot;Preload Error: Failed to load %s&quot;, class_name);
1316     }
1317     return NULL;
1318   }
1319 
<a name="22" id="anc22"></a><span class="line-modified">1320   if (!add_package(file_name, classpath_index, THREAD)) {</span>
1321     return NULL;
1322   }
1323 
1324   return result;
1325 }
1326 
1327 #if INCLUDE_CDS
1328 char* ClassLoader::skip_uri_protocol(char* source) {
1329   if (strncmp(source, &quot;file:&quot;, 5) == 0) {
1330     // file: protocol path could start with file:/ or file:///
1331     // locate the char after all the forward slashes
1332     int offset = 5;
1333     while (*(source + offset) == &#39;/&#39;) {
1334         offset++;
1335     }
1336     source += offset;
1337   // for non-windows platforms, move back one char as the path begins with a &#39;/&#39;
1338 #ifndef _WINDOWS
1339     source -= 1;
1340 #endif
1341   } else if (strncmp(source, &quot;jrt:/&quot;, 5) == 0) {
1342     source += 5;
1343   }
1344   return source;
1345 }
1346 
1347 // Record the shared classpath index and loader type for classes loaded
1348 // by the builtin loaders at dump time.
1349 void ClassLoader::record_result(InstanceKlass* ik, const ClassFileStream* stream, TRAPS) {
1350   Arguments::assert_is_dumping_archive();
1351   assert(stream != NULL, &quot;sanity&quot;);
1352 
1353   if (ik-&gt;is_unsafe_anonymous()) {
1354     // We do not archive unsafe anonymous classes.
1355     return;
1356   }
1357 
1358   oop loader = ik-&gt;class_loader();
1359   char* src = (char*)stream-&gt;source();
1360   if (src == NULL) {
1361     if (loader == NULL) {
1362       // JFR classes
1363       ik-&gt;set_shared_classpath_index(0);
1364       ik-&gt;set_shared_class_loader_type(ClassLoader::BOOT_LOADER);
1365     }
1366     return;
1367   }
1368 
1369   assert(has_jrt_entry(), &quot;CDS dumping does not support exploded JDK build&quot;);
1370 
1371   ResourceMark rm(THREAD);
1372   int classpath_index = -1;
1373   PackageEntry* pkg_entry = ik-&gt;package();
1374 
1375   if (FileMapInfo::get_number_of_shared_paths() &gt; 0) {
1376     char* canonical_path_table_entry = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);
1377 
1378     // save the path from the file: protocol or the module name from the jrt: protocol
1379     // if no protocol prefix is found, path is the same as stream-&gt;source()
1380     char* path = skip_uri_protocol(src);
1381     char* canonical_class_src_path = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, JVM_MAXPATHLEN);
1382     bool success = get_canonical_path(path, canonical_class_src_path, JVM_MAXPATHLEN);
1383     // The path is from the ClassFileStream. Since a ClassFileStream has been created successfully in functions
1384     // such as ClassLoader::load_class(), its source path must be valid.
1385     assert(success, &quot;must be valid path&quot;);
1386     for (int i = 0; i &lt; FileMapInfo::get_number_of_shared_paths(); i++) {
1387       SharedClassPathEntry* ent = FileMapInfo::shared_path(i);
1388       success = get_canonical_path(ent-&gt;name(), canonical_path_table_entry, JVM_MAXPATHLEN);
1389       // A shared path has been validated during its creation in ClassLoader::create_class_path_entry(),
1390       // it must be valid here.
1391       assert(success, &quot;must be valid path&quot;);
1392       // If the path (from the class stream source) is the same as the shared
1393       // class or module path, then we have a match.
1394       if (strcmp(canonical_path_table_entry, canonical_class_src_path) == 0) {
1395         // NULL pkg_entry and pkg_entry in an unnamed module implies the class
1396         // is from the -cp or boot loader append path which consists of -Xbootclasspath/a
1397         // and jvmti appended entries.
1398         if ((pkg_entry == NULL) || (pkg_entry-&gt;in_unnamed_module())) {
1399           // Ensure the index is within the -cp range before assigning
1400           // to the classpath_index.
1401           if (SystemDictionary::is_system_class_loader(loader) &amp;&amp;
1402               (i &gt;= ClassLoaderExt::app_class_paths_start_index()) &amp;&amp;
1403               (i &lt; ClassLoaderExt::app_module_paths_start_index())) {
1404             classpath_index = i;
1405             break;
1406           } else {
1407             if ((i &gt;= 1) &amp;&amp;
1408                 (i &lt; ClassLoaderExt::app_class_paths_start_index())) {
1409               // The class must be from boot loader append path which consists of
1410               // -Xbootclasspath/a and jvmti appended entries.
1411               assert(loader == NULL, &quot;sanity&quot;);
1412               classpath_index = i;
1413               break;
1414             }
1415           }
1416         } else {
1417           // A class from a named module from the --module-path. Ensure the index is
1418           // within the --module-path range before assigning to the classpath_index.
1419           if ((pkg_entry != NULL) &amp;&amp; !(pkg_entry-&gt;in_unnamed_module()) &amp;&amp; (i &gt; 0)) {
1420             if (i &gt;= ClassLoaderExt::app_module_paths_start_index() &amp;&amp;
1421                 i &lt; FileMapInfo::get_number_of_shared_paths()) {
1422               classpath_index = i;
1423               break;
1424             }
1425           }
1426         }
1427       }
1428       // for index 0 and the stream-&gt;source() is the modules image or has the jrt: protocol.
1429       // The class must be from the runtime modules image.
1430       if (i == 0 &amp;&amp; (stream-&gt;from_boot_loader_modules_image() || string_starts_with(src, &quot;jrt:&quot;))) {
1431         classpath_index = i;
1432         break;
1433       }
1434     }
1435 
1436     // No path entry found for this class. Must be a shared class loaded by the
1437     // user defined classloader.
1438     if (classpath_index &lt; 0) {
1439       assert(ik-&gt;shared_classpath_index() &lt; 0, &quot;Sanity&quot;);
1440       ik-&gt;set_shared_classpath_index(UNREGISTERED_INDEX);
1441       SystemDictionaryShared::set_shared_class_misc_info(ik, (ClassFileStream*)stream);
1442       return;
1443     }
1444   } else {
1445     // The shared path table is set up after module system initialization.
1446     // The path table contains no entry before that. Any classes loaded prior
1447     // to the setup of the shared path table must be from the modules image.
1448     assert(stream-&gt;from_boot_loader_modules_image(), &quot;stream must be loaded by boot loader from modules image&quot;);
1449     assert(FileMapInfo::get_number_of_shared_paths() == 0, &quot;shared path table must not have been setup&quot;);
1450     classpath_index = 0;
1451   }
1452 
1453   const char* const class_name = ik-&gt;name()-&gt;as_C_string();
1454   const char* const file_name = file_name_for_class_name(class_name,
1455                                                          ik-&gt;name()-&gt;utf8_length());
1456   assert(file_name != NULL, &quot;invariant&quot;);
1457 
1458   ClassLoaderExt::record_result(classpath_index, ik, THREAD);
1459 }
1460 #endif // INCLUDE_CDS
1461 
1462 // Initialize the class loader&#39;s access to methods in libzip.  Parse and
1463 // process the boot classpath into a list ClassPathEntry objects.  Once
1464 // this list has been created, it must not change order (see class PackageInfo)
1465 // it can be appended to and is by jvmti and the kernel vm.
1466 
1467 void ClassLoader::initialize() {
1468   EXCEPTION_MARK;
1469 
1470   if (UsePerfData) {
1471     // jvmstat performance counters
1472     NEWPERFTICKCOUNTER(_perf_accumulated_time, SUN_CLS, &quot;time&quot;);
1473     NEWPERFTICKCOUNTER(_perf_class_init_time, SUN_CLS, &quot;classInitTime&quot;);
1474     NEWPERFTICKCOUNTER(_perf_class_init_selftime, SUN_CLS, &quot;classInitTime.self&quot;);
1475     NEWPERFTICKCOUNTER(_perf_class_verify_time, SUN_CLS, &quot;classVerifyTime&quot;);
1476     NEWPERFTICKCOUNTER(_perf_class_verify_selftime, SUN_CLS, &quot;classVerifyTime.self&quot;);
1477     NEWPERFTICKCOUNTER(_perf_class_link_time, SUN_CLS, &quot;classLinkedTime&quot;);
1478     NEWPERFTICKCOUNTER(_perf_class_link_selftime, SUN_CLS, &quot;classLinkedTime.self&quot;);
1479     NEWPERFEVENTCOUNTER(_perf_classes_inited, SUN_CLS, &quot;initializedClasses&quot;);
1480     NEWPERFEVENTCOUNTER(_perf_classes_linked, SUN_CLS, &quot;linkedClasses&quot;);
1481     NEWPERFEVENTCOUNTER(_perf_classes_verified, SUN_CLS, &quot;verifiedClasses&quot;);
1482 
<a name="23" id="anc23"></a><span class="line-removed">1483     NEWPERFTICKCOUNTER(_perf_class_parse_time, SUN_CLS, &quot;parseClassTime&quot;);</span>
<span class="line-removed">1484     NEWPERFTICKCOUNTER(_perf_class_parse_selftime, SUN_CLS, &quot;parseClassTime.self&quot;);</span>
1485     NEWPERFTICKCOUNTER(_perf_sys_class_lookup_time, SUN_CLS, &quot;lookupSysClassTime&quot;);
1486     NEWPERFTICKCOUNTER(_perf_shared_classload_time, SUN_CLS, &quot;sharedClassLoadTime&quot;);
1487     NEWPERFTICKCOUNTER(_perf_sys_classload_time, SUN_CLS, &quot;sysClassLoadTime&quot;);
1488     NEWPERFTICKCOUNTER(_perf_app_classload_time, SUN_CLS, &quot;appClassLoadTime&quot;);
1489     NEWPERFTICKCOUNTER(_perf_app_classload_selftime, SUN_CLS, &quot;appClassLoadTime.self&quot;);
1490     NEWPERFEVENTCOUNTER(_perf_app_classload_count, SUN_CLS, &quot;appClassLoadCount&quot;);
1491     NEWPERFTICKCOUNTER(_perf_define_appclasses, SUN_CLS, &quot;defineAppClasses&quot;);
1492     NEWPERFTICKCOUNTER(_perf_define_appclass_time, SUN_CLS, &quot;defineAppClassTime&quot;);
1493     NEWPERFTICKCOUNTER(_perf_define_appclass_selftime, SUN_CLS, &quot;defineAppClassTime.self&quot;);
1494     NEWPERFBYTECOUNTER(_perf_app_classfile_bytes_read, SUN_CLS, &quot;appClassBytes&quot;);
1495     NEWPERFBYTECOUNTER(_perf_sys_classfile_bytes_read, SUN_CLS, &quot;sysClassBytes&quot;);
1496 
1497 
1498     // The following performance counters are added for measuring the impact
1499     // of the bug fix of 6365597. They are mainly focused on finding out
1500     // the behavior of system &amp; user-defined classloader lock, whether
1501     // ClassLoader.loadClass/findClass is being called synchronized or not.
1502     NEWPERFEVENTCOUNTER(_sync_systemLoaderLockContentionRate, SUN_CLS,
1503                         &quot;systemLoaderLockContentionRate&quot;);
1504     NEWPERFEVENTCOUNTER(_sync_nonSystemLoaderLockContentionRate, SUN_CLS,
1505                         &quot;nonSystemLoaderLockContentionRate&quot;);
1506     NEWPERFEVENTCOUNTER(_sync_JVMFindLoadedClassLockFreeCounter, SUN_CLS,
1507                         &quot;jvmFindLoadedClassNoLockCalls&quot;);
1508     NEWPERFEVENTCOUNTER(_sync_JVMDefineClassLockFreeCounter, SUN_CLS,
1509                         &quot;jvmDefineClassNoLockCalls&quot;);
1510 
1511     NEWPERFEVENTCOUNTER(_sync_JNIDefineClassLockFreeCounter, SUN_CLS,
1512                         &quot;jniDefineClassNoLockCalls&quot;);
1513 
1514     NEWPERFEVENTCOUNTER(_unsafe_defineClassCallCounter, SUN_CLS,
1515                         &quot;unsafeDefineClassCalls&quot;);
1516   }
1517 
1518   // lookup java library entry points
1519   load_java_library();
1520   // lookup zip library entry points
1521   load_zip_library();
1522   // jimage library entry points are loaded below, in lookup_vm_options
1523   setup_bootstrap_search_path();
1524 }
1525 
1526 char* lookup_vm_resource(JImageFile *jimage, const char *jimage_version, const char *path) {
1527   jlong size;
1528   JImageLocationRef location = (*JImageFindResource)(jimage, &quot;java.base&quot;, jimage_version, path, &amp;size);
1529   if (location == 0)
1530     return NULL;
1531   char *val = NEW_C_HEAP_ARRAY(char, size+1, mtClass);
1532   (*JImageGetResource)(jimage, location, val, size);
1533   val[size] = &#39;\0&#39;;
1534   return val;
1535 }
1536 
1537 // Lookup VM options embedded in the modules jimage file
1538 char* ClassLoader::lookup_vm_options() {
1539   jint error;
1540   char modules_path[JVM_MAXPATHLEN];
1541   const char* fileSep = os::file_separator();
1542 
1543   // Initialize jimage library entry points
1544   load_jimage_library();
1545 
1546   jio_snprintf(modules_path, JVM_MAXPATHLEN, &quot;%s%slib%smodules&quot;, Arguments::get_java_home(), fileSep, fileSep);
1547   JImageFile* jimage =(*JImageOpen)(modules_path, &amp;error);
1548   if (jimage == NULL) {
1549     return NULL;
1550   }
1551 
1552   const char *jimage_version = get_jimage_version_string();
1553   char *options = lookup_vm_resource(jimage, jimage_version, &quot;jdk/internal/vm/options&quot;);
1554 
1555   (*JImageClose)(jimage);
1556   return options;
1557 }
1558 
1559 #if INCLUDE_CDS
1560 void ClassLoader::initialize_shared_path() {
1561   if (Arguments::is_dumping_archive()) {
1562     ClassLoaderExt::setup_search_paths();
1563   }
1564 }
1565 
1566 void ClassLoader::initialize_module_path(TRAPS) {
1567   if (Arguments::is_dumping_archive()) {
1568     ClassLoaderExt::setup_module_paths(THREAD);
1569     FileMapInfo::allocate_shared_path_table();
1570   }
1571 }
1572 #endif
1573 
1574 jlong ClassLoader::classloader_time_ms() {
1575   return UsePerfData ?
1576     Management::ticks_to_ms(_perf_accumulated_time-&gt;get_value()) : -1;
1577 }
1578 
1579 jlong ClassLoader::class_init_count() {
1580   return UsePerfData ? _perf_classes_inited-&gt;get_value() : -1;
1581 }
1582 
1583 jlong ClassLoader::class_init_time_ms() {
1584   return UsePerfData ?
1585     Management::ticks_to_ms(_perf_class_init_time-&gt;get_value()) : -1;
1586 }
1587 
1588 jlong ClassLoader::class_verify_time_ms() {
1589   return UsePerfData ?
1590     Management::ticks_to_ms(_perf_class_verify_time-&gt;get_value()) : -1;
1591 }
1592 
1593 jlong ClassLoader::class_link_count() {
1594   return UsePerfData ? _perf_classes_linked-&gt;get_value() : -1;
1595 }
1596 
1597 jlong ClassLoader::class_link_time_ms() {
1598   return UsePerfData ?
1599     Management::ticks_to_ms(_perf_class_link_time-&gt;get_value()) : -1;
1600 }
1601 
1602 int ClassLoader::compute_Object_vtable() {
1603   // hardwired for JDK1.2 -- would need to duplicate class file parsing
1604   // code to determine actual value from file
1605   // Would be value &#39;11&#39; if finals were in vtable
1606   int JDK_1_2_Object_vtable_size = 5;
1607   return JDK_1_2_Object_vtable_size * vtableEntry::size();
1608 }
1609 
1610 
1611 void classLoader_init1() {
1612   ClassLoader::initialize();
1613 }
1614 
1615 // Complete the ClassPathEntry setup for the boot loader
1616 void ClassLoader::classLoader_init2(TRAPS) {
1617   // Setup the list of module/path pairs for --patch-module processing
1618   // This must be done after the SymbolTable is created in order
1619   // to use fast_compare on module names instead of a string compare.
1620   if (Arguments::get_patch_mod_prefix() != NULL) {
1621     setup_patch_mod_entries();
1622   }
1623 
1624   // Create the ModuleEntry for java.base (must occur after setup_patch_mod_entries
1625   // to successfully determine if java.base has been patched)
1626   create_javabase();
1627 
1628   // Setup the initial java.base/path pair for the exploded build entries.
1629   // As more modules are defined during module system initialization, more
1630   // entries will be added to the exploded build array.
1631   if (!has_jrt_entry()) {
1632     assert(!DumpSharedSpaces, &quot;DumpSharedSpaces not supported with exploded module builds&quot;);
1633     assert(!DynamicDumpSharedSpaces, &quot;DynamicDumpSharedSpaces not supported with exploded module builds&quot;);
1634     assert(!UseSharedSpaces, &quot;UsedSharedSpaces not supported with exploded module builds&quot;);
1635     // Set up the boot loader&#39;s _exploded_entries list.  Note that this gets
1636     // done before loading any classes, by the same thread that will
1637     // subsequently do the first class load. So, no lock is needed for this.
1638     assert(_exploded_entries == NULL, &quot;Should only get initialized once&quot;);
1639     _exploded_entries = new (ResourceObj::C_HEAP, mtModule)
1640       GrowableArray&lt;ModuleClassPathList*&gt;(EXPLODED_ENTRY_SIZE, true);
1641     add_to_exploded_build_list(vmSymbols::java_base(), CHECK);
1642   }
1643 }
1644 
1645 bool ClassLoader::get_canonical_path(const char* orig, char* out, int len) {
1646   assert(orig != NULL &amp;&amp; out != NULL &amp;&amp; len &gt; 0, &quot;bad arguments&quot;);
1647   JavaThread* THREAD = JavaThread::current();
1648   ResourceMark rm(THREAD);
1649 
1650   // os::native_path writes into orig_copy
1651   char* orig_copy = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char, strlen(orig)+1);
1652   strcpy(orig_copy, orig);
1653   if ((CanonicalizeEntry)(os::native_path(orig_copy), out, len) &lt; 0) {
1654     return false;
1655   }
1656   return true;
1657 }
1658 
1659 void ClassLoader::create_javabase() {
1660   Thread* THREAD = Thread::current();
1661 
1662   // Create java.base&#39;s module entry for the boot
1663   // class loader prior to loading j.l.Ojbect.
1664   ClassLoaderData* null_cld = ClassLoaderData::the_null_class_loader_data();
1665 
1666   // Get module entry table
1667   ModuleEntryTable* null_cld_modules = null_cld-&gt;modules();
1668   if (null_cld_modules == NULL) {
1669     vm_exit_during_initialization(&quot;No ModuleEntryTable for the boot class loader&quot;);
1670   }
1671 
1672   {
1673     MutexLocker ml(THREAD, Module_lock);
1674     ModuleEntry* jb_module = null_cld_modules-&gt;locked_create_entry(Handle(),
1675                                false, vmSymbols::java_base(), NULL, NULL, null_cld);
1676     if (jb_module == NULL) {
1677       vm_exit_during_initialization(&quot;Unable to create ModuleEntry for &quot; JAVA_BASE_NAME);
1678     }
1679     ModuleEntryTable::set_javabase_moduleEntry(jb_module);
1680   }
1681 }
1682 
1683 // Please keep following two functions at end of this file. With them placed at top or in middle of the file,
1684 // they could get inlined by agressive compiler, an unknown trick, see bug 6966589.
1685 void PerfClassTraceTime::initialize() {
1686   if (!UsePerfData) return;
1687 
1688   if (_eventp != NULL) {
1689     // increment the event counter
1690     _eventp-&gt;inc();
1691   }
1692 
1693   // stop the current active thread-local timer to measure inclusive time
1694   _prev_active_event = -1;
1695   for (int i=0; i &lt; EVENT_TYPE_COUNT; i++) {
1696      if (_timers[i].is_active()) {
1697        assert(_prev_active_event == -1, &quot;should have only one active timer&quot;);
1698        _prev_active_event = i;
1699        _timers[i].stop();
1700      }
1701   }
1702 
1703   if (_recursion_counters == NULL || (_recursion_counters[_event_type])++ == 0) {
1704     // start the inclusive timer if not recursively called
1705     _t.start();
1706   }
1707 
1708   // start thread-local timer of the given event type
1709    if (!_timers[_event_type].is_active()) {
1710     _timers[_event_type].start();
1711   }
1712 }
1713 
1714 PerfClassTraceTime::~PerfClassTraceTime() {
1715   if (!UsePerfData) return;
1716 
1717   // stop the thread-local timer as the event completes
1718   // and resume the thread-local timer of the event next on the stack
1719   _timers[_event_type].stop();
1720   jlong selftime = _timers[_event_type].ticks();
1721 
1722   if (_prev_active_event &gt;= 0) {
1723     _timers[_prev_active_event].start();
1724   }
1725 
1726   if (_recursion_counters != NULL &amp;&amp; --(_recursion_counters[_event_type]) &gt; 0) return;
1727 
1728   // increment the counters only on the leaf call
1729   _t.stop();
1730   _timep-&gt;inc(_t.ticks());
1731   if (_selftimep != NULL) {
1732     _selftimep-&gt;inc(selftime);
1733   }
1734   // add all class loading related event selftime to the accumulated time counter
1735   ClassLoader::perf_accumulated_time()-&gt;inc(selftime);
1736 
1737   // reset the timer
1738   _timers[_event_type].reset();
1739 }
<a name="24" id="anc24"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="24" type="hidden" />
</body>
</html>
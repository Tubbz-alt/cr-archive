<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/prims/whitebox.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 2012, 2020, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 
  27 #include &lt;new&gt;
  28 
  29 #include &quot;classfile/classLoaderDataGraph.hpp&quot;
  30 #include &quot;classfile/modules.hpp&quot;
  31 #include &quot;classfile/protectionDomainCache.hpp&quot;
  32 #include &quot;classfile/stringTable.hpp&quot;
  33 #include &quot;classfile/symbolTable.hpp&quot;
  34 #include &quot;code/codeCache.hpp&quot;
  35 #include &quot;compiler/compilationPolicy.hpp&quot;
  36 #include &quot;compiler/methodMatcher.hpp&quot;
  37 #include &quot;compiler/directivesParser.hpp&quot;
<a name="1" id="anc1"></a>
  38 #include &quot;gc/shared/gcConfig.hpp&quot;
  39 #include &quot;gc/shared/genArguments.hpp&quot;
  40 #include &quot;gc/shared/genCollectedHeap.hpp&quot;
  41 #include &quot;jvmtifiles/jvmtiEnv.hpp&quot;
  42 #include &quot;memory/filemap.hpp&quot;
  43 #include &quot;memory/heapShared.inline.hpp&quot;
  44 #include &quot;memory/metaspaceShared.hpp&quot;
  45 #include &quot;memory/metadataFactory.hpp&quot;
  46 #include &quot;memory/iterator.hpp&quot;
  47 #include &quot;memory/resourceArea.hpp&quot;
  48 #include &quot;memory/universe.hpp&quot;
  49 #include &quot;memory/oopFactory.hpp&quot;
  50 #include &quot;oops/array.hpp&quot;
  51 #include &quot;oops/compressedOops.hpp&quot;
  52 #include &quot;oops/constantPool.inline.hpp&quot;
  53 #include &quot;oops/method.inline.hpp&quot;
  54 #include &quot;oops/objArrayKlass.hpp&quot;
  55 #include &quot;oops/objArrayOop.inline.hpp&quot;
  56 #include &quot;oops/oop.inline.hpp&quot;
  57 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  58 #include &quot;prims/resolvedMethodTable.hpp&quot;
  59 #include &quot;prims/wbtestmethods/parserTests.hpp&quot;
  60 #include &quot;prims/whitebox.inline.hpp&quot;
  61 #include &quot;runtime/arguments.hpp&quot;
  62 #include &quot;runtime/atomic.hpp&quot;
  63 #include &quot;runtime/deoptimization.hpp&quot;
  64 #include &quot;runtime/fieldDescriptor.inline.hpp&quot;
  65 #include &quot;runtime/flags/jvmFlag.hpp&quot;
  66 #include &quot;runtime/frame.inline.hpp&quot;
  67 #include &quot;runtime/handles.inline.hpp&quot;
  68 #include &quot;runtime/handshake.hpp&quot;
  69 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  70 #include &quot;runtime/javaCalls.hpp&quot;
  71 #include &quot;runtime/jniHandles.inline.hpp&quot;
  72 #include &quot;runtime/os.hpp&quot;
  73 #include &quot;runtime/sweeper.hpp&quot;
  74 #include &quot;runtime/thread.hpp&quot;
  75 #include &quot;runtime/threadSMR.hpp&quot;
  76 #include &quot;runtime/vm_version.hpp&quot;
  77 #include &quot;services/memoryService.hpp&quot;
  78 #include &quot;utilities/align.hpp&quot;
  79 #include &quot;utilities/debug.hpp&quot;
  80 #include &quot;utilities/elfFile.hpp&quot;
  81 #include &quot;utilities/exceptions.hpp&quot;
  82 #include &quot;utilities/macros.hpp&quot;
  83 #if INCLUDE_CDS
  84 #include &quot;prims/cdsoffsets.hpp&quot;
  85 #endif // INCLUDE_CDS
  86 #if INCLUDE_G1GC
  87 #include &quot;gc/g1/g1Arguments.hpp&quot;
  88 #include &quot;gc/g1/g1CollectedHeap.inline.hpp&quot;
  89 #include &quot;gc/g1/g1ConcurrentMark.hpp&quot;
  90 #include &quot;gc/g1/g1ConcurrentMarkThread.hpp&quot;
  91 #include &quot;gc/g1/heapRegionRemSet.hpp&quot;
  92 #include &quot;gc/g1/heterogeneousHeapRegionManager.hpp&quot;
  93 #endif // INCLUDE_G1GC
  94 #if INCLUDE_PARALLELGC
  95 #include &quot;gc/parallel/parallelScavengeHeap.inline.hpp&quot;
  96 #include &quot;gc/parallel/adjoiningGenerations.hpp&quot;
  97 #endif // INCLUDE_PARALLELGC
  98 #if INCLUDE_NMT
  99 #include &quot;services/mallocSiteTable.hpp&quot;
 100 #include &quot;services/memTracker.hpp&quot;
 101 #include &quot;utilities/nativeCallStack.hpp&quot;
 102 #endif // INCLUDE_NMT
 103 #if INCLUDE_AOT
 104 #include &quot;aot/aotLoader.hpp&quot;
 105 #endif // INCLUDE_AOT
 106 
 107 #ifdef LINUX
 108 #include &quot;osContainer_linux.hpp&quot;
<a name="2" id="anc2"></a>
 109 #endif
 110 
 111 #define SIZE_T_MAX_VALUE ((size_t) -1)
 112 
 113 #define CHECK_JNI_EXCEPTION_(env, value)                               \
 114   do {                                                                 \
 115     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 116     THREAD-&gt;clear_pending_jni_exception_check();                       \
 117     if (HAS_PENDING_EXCEPTION) {                                       \
 118       return(value);                                                   \
 119     }                                                                  \
 120   } while (0)
 121 
 122 #define CHECK_JNI_EXCEPTION(env)                                       \
 123   do {                                                                 \
 124     JavaThread* THREAD = JavaThread::thread_from_jni_environment(env); \
 125     THREAD-&gt;clear_pending_jni_exception_check();                       \
 126     if (HAS_PENDING_EXCEPTION) {                                       \
 127       return;                                                          \
 128     }                                                                  \
 129   } while (0)
 130 
 131 bool WhiteBox::_used = false;
 132 volatile bool WhiteBox::compilation_locked = false;
 133 
 134 class VM_WhiteBoxOperation : public VM_Operation {
 135  public:
 136   VM_WhiteBoxOperation()                         { }
 137   VMOp_Type type()                  const        { return VMOp_WhiteBoxOperation; }
 138   bool allow_nested_vm_operations() const        { return true; }
 139 };
 140 
 141 
 142 WB_ENTRY(jlong, WB_GetObjectAddress(JNIEnv* env, jobject o, jobject obj))
 143   return (jlong)(void*)JNIHandles::resolve(obj);
 144 WB_END
 145 
 146 WB_ENTRY(jint, WB_GetHeapOopSize(JNIEnv* env, jobject o))
 147   return heapOopSize;
 148 WB_END
 149 
 150 WB_ENTRY(jint, WB_GetVMPageSize(JNIEnv* env, jobject o))
 151   return os::vm_page_size();
 152 WB_END
 153 
 154 WB_ENTRY(jlong, WB_GetVMAllocationGranularity(JNIEnv* env, jobject o))
 155   return os::vm_allocation_granularity();
 156 WB_END
 157 
 158 WB_ENTRY(jlong, WB_GetVMLargePageSize(JNIEnv* env, jobject o))
 159   return os::large_page_size();
 160 WB_END
 161 
 162 class WBIsKlassAliveClosure : public LockedClassesDo {
 163     Symbol* _name;
 164     int _count;
 165 public:
 166     WBIsKlassAliveClosure(Symbol* name) : _name(name), _count(0) {}
 167 
 168     void do_klass(Klass* k) {
 169       Symbol* ksym = k-&gt;name();
 170       if (ksym-&gt;fast_compare(_name) == 0) {
 171         _count++;
 172       }
 173     }
 174 
 175     int count() const {
 176         return _count;
 177     }
 178 };
 179 
 180 WB_ENTRY(jint, WB_CountAliveClasses(JNIEnv* env, jobject target, jstring name))
 181   oop h_name = JNIHandles::resolve(name);
 182   if (h_name == NULL) return false;
 183   Symbol* sym = java_lang_String::as_symbol(h_name);
 184   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 185 
 186   WBIsKlassAliveClosure closure(sym);
 187   ClassLoaderDataGraph::classes_do(&amp;closure);
 188 
 189   // Return the count of alive classes with this name.
 190   return closure.count();
 191 WB_END
 192 
 193 WB_ENTRY(jint, WB_GetSymbolRefcount(JNIEnv* env, jobject unused, jstring name))
 194   oop h_name = JNIHandles::resolve(name);
 195   if (h_name == NULL) return false;
 196   Symbol* sym = java_lang_String::as_symbol(h_name);
 197   TempNewSymbol tsym(sym); // Make sure to decrement reference count on sym on return
 198   return (jint)sym-&gt;refcount();
 199 WB_END
 200 
 201 
 202 WB_ENTRY(void, WB_AddToBootstrapClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 203 #if INCLUDE_JVMTI
 204   ResourceMark rm;
 205   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 206   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 207   jvmtiError err = jvmti_env-&gt;AddToBootstrapClassLoaderSearch(seg);
 208   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 209 #endif
 210 }
 211 WB_END
 212 
 213 WB_ENTRY(void, WB_AddToSystemClassLoaderSearch(JNIEnv* env, jobject o, jstring segment)) {
 214 #if INCLUDE_JVMTI
 215   ResourceMark rm;
 216   const char* seg = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(segment));
 217   JvmtiEnv* jvmti_env = JvmtiEnv::create_a_jvmti(JVMTI_VERSION);
 218   jvmtiError err = jvmti_env-&gt;AddToSystemClassLoaderSearch(seg);
 219   assert(err == JVMTI_ERROR_NONE, &quot;must not fail&quot;);
 220 #endif
 221 }
 222 WB_END
 223 
 224 
 225 WB_ENTRY(jlong, WB_GetCompressedOopsMaxHeapSize(JNIEnv* env, jobject o)) {
 226   return (jlong)Arguments::max_heap_for_compressed_oops();
 227 }
 228 WB_END
 229 
 230 WB_ENTRY(void, WB_PrintHeapSizes(JNIEnv* env, jobject o)) {
 231   tty-&gt;print_cr(&quot;Minimum heap &quot; SIZE_FORMAT &quot; Initial heap &quot; SIZE_FORMAT &quot; &quot;
 232                 &quot;Maximum heap &quot; SIZE_FORMAT &quot; Space alignment &quot; SIZE_FORMAT &quot; Heap alignment &quot; SIZE_FORMAT,
 233                 MinHeapSize,
 234                 InitialHeapSize,
 235                 MaxHeapSize,
 236                 SpaceAlignment,
 237                 HeapAlignment);
 238 }
 239 WB_END
 240 
 241 #ifndef PRODUCT
 242 // Forward declaration
 243 void TestReservedSpace_test();
 244 void TestReserveMemorySpecial_test();
 245 void TestVirtualSpace_test();
 246 #endif
 247 
 248 WB_ENTRY(void, WB_RunMemoryUnitTests(JNIEnv* env, jobject o))
 249 #ifndef PRODUCT
 250   TestReservedSpace_test();
 251   TestReserveMemorySpecial_test();
 252   TestVirtualSpace_test();
 253 #endif
 254 WB_END
 255 
 256 WB_ENTRY(void, WB_ReadFromNoaccessArea(JNIEnv* env, jobject o))
 257   size_t granularity = os::vm_allocation_granularity();
 258   ReservedHeapSpace rhs(100 * granularity, granularity, false);
 259   VirtualSpace vs;
 260   vs.initialize(rhs, 50 * granularity);
 261 
 262   // Check if constraints are complied
 263   if (!( UseCompressedOops &amp;&amp; rhs.base() != NULL &amp;&amp;
 264          CompressedOops::base() != NULL &amp;&amp;
 265          CompressedOops::use_implicit_null_checks() )) {
 266     tty-&gt;print_cr(&quot;WB_ReadFromNoaccessArea method is useless:\n &quot;
 267                   &quot;\tUseCompressedOops is %d\n&quot;
 268                   &quot;\trhs.base() is &quot; PTR_FORMAT &quot;\n&quot;
 269                   &quot;\tCompressedOops::base() is &quot; PTR_FORMAT &quot;\n&quot;
 270                   &quot;\tCompressedOops::use_implicit_null_checks() is %d&quot;,
 271                   UseCompressedOops,
 272                   p2i(rhs.base()),
 273                   p2i(CompressedOops::base()),
 274                   CompressedOops::use_implicit_null_checks());
 275     return;
 276   }
 277   tty-&gt;print_cr(&quot;Reading from no access area... &quot;);
 278   tty-&gt;print_cr(&quot;*(vs.low_boundary() - rhs.noaccess_prefix() / 2 ) = %c&quot;,
 279                 *(vs.low_boundary() - rhs.noaccess_prefix() / 2 ));
 280 WB_END
 281 
 282 static jint wb_stress_virtual_space_resize(size_t reserved_space_size,
 283                                            size_t magnitude, size_t iterations) {
 284   size_t granularity = os::vm_allocation_granularity();
 285   ReservedHeapSpace rhs(reserved_space_size * granularity, granularity, false);
 286   VirtualSpace vs;
 287   if (!vs.initialize(rhs, 0)) {
 288     tty-&gt;print_cr(&quot;Failed to initialize VirtualSpace. Can&#39;t proceed.&quot;);
 289     return 3;
 290   }
 291 
 292   int seed = os::random();
 293   tty-&gt;print_cr(&quot;Random seed is %d&quot;, seed);
 294   os::init_random(seed);
 295 
 296   for (size_t i = 0; i &lt; iterations; i++) {
 297 
 298     // Whether we will shrink or grow
 299     bool shrink = os::random() % 2L == 0;
 300 
 301     // Get random delta to resize virtual space
 302     size_t delta = (size_t)os::random() % magnitude;
 303 
 304     // If we are about to shrink virtual space below zero, then expand instead
 305     if (shrink &amp;&amp; vs.committed_size() &lt; delta) {
 306       shrink = false;
 307     }
 308 
 309     // Resizing by delta
 310     if (shrink) {
 311       vs.shrink_by(delta);
 312     } else {
 313       // If expanding fails expand_by will silently return false
 314       vs.expand_by(delta, true);
 315     }
 316   }
 317   return 0;
 318 }
 319 
 320 WB_ENTRY(jint, WB_StressVirtualSpaceResize(JNIEnv* env, jobject o,
 321         jlong reserved_space_size, jlong magnitude, jlong iterations))
 322   tty-&gt;print_cr(&quot;reservedSpaceSize=&quot; JLONG_FORMAT &quot;, magnitude=&quot; JLONG_FORMAT &quot;, &quot;
 323                 &quot;iterations=&quot; JLONG_FORMAT &quot;\n&quot;, reserved_space_size, magnitude,
 324                 iterations);
 325   if (reserved_space_size &lt; 0 || magnitude &lt; 0 || iterations &lt; 0) {
 326     tty-&gt;print_cr(&quot;One of variables printed above is negative. Can&#39;t proceed.\n&quot;);
 327     return 1;
 328   }
 329 
 330   // sizeof(size_t) depends on whether OS is 32bit or 64bit. sizeof(jlong) is
 331   // always 8 byte. That&#39;s why we should avoid overflow in case of 32bit platform.
 332   if (sizeof(size_t) &lt; sizeof(jlong)) {
 333     jlong size_t_max_value = (jlong) SIZE_T_MAX_VALUE;
 334     if (reserved_space_size &gt; size_t_max_value || magnitude &gt; size_t_max_value
 335         || iterations &gt; size_t_max_value) {
 336       tty-&gt;print_cr(&quot;One of variables printed above overflows size_t. Can&#39;t proceed.\n&quot;);
 337       return 2;
 338     }
 339   }
 340 
 341   return wb_stress_virtual_space_resize((size_t) reserved_space_size,
 342                                         (size_t) magnitude, (size_t) iterations);
 343 WB_END
 344 
 345 WB_ENTRY(jboolean, WB_IsGCSupported(JNIEnv* env, jobject o, jint name))
 346   return GCConfig::is_gc_supported((CollectedHeap::Name)name);
 347 WB_END
 348 
 349 WB_ENTRY(jboolean, WB_IsGCSelected(JNIEnv* env, jobject o, jint name))
 350   return GCConfig::is_gc_selected((CollectedHeap::Name)name);
 351 WB_END
 352 
 353 WB_ENTRY(jboolean, WB_IsGCSelectedErgonomically(JNIEnv* env, jobject o))
 354   return GCConfig::is_gc_selected_ergonomically();
 355 WB_END
 356 
 357 WB_ENTRY(jboolean, WB_isObjectInOldGen(JNIEnv* env, jobject o, jobject obj))
 358   oop p = JNIHandles::resolve(obj);
 359 #if INCLUDE_G1GC
 360   if (UseG1GC) {
 361     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 362     const HeapRegion* hr = g1h-&gt;heap_region_containing(p);
 363     if (hr == NULL) {
 364       return false;
 365     }
 366     return !(hr-&gt;is_young());
 367   }
 368 #endif
 369 #if INCLUDE_PARALLELGC
 370   if (UseParallelGC) {
 371     ParallelScavengeHeap* psh = ParallelScavengeHeap::heap();
 372     return !psh-&gt;is_in_young(p);
 373   }
 374 #endif
 375 #if INCLUDE_ZGC
 376   if (UseZGC) {
 377     return Universe::heap()-&gt;is_in(p);
 378   }
 379 #endif
 380   GenCollectedHeap* gch = GenCollectedHeap::heap();
 381   return !gch-&gt;is_in_young(p);
 382 WB_END
 383 
 384 WB_ENTRY(jlong, WB_GetObjectSize(JNIEnv* env, jobject o, jobject obj))
 385   oop p = JNIHandles::resolve(obj);
 386   return Universe::heap()-&gt;obj_size(p) * HeapWordSize;
 387 WB_END
 388 
 389 WB_ENTRY(jlong, WB_GetHeapSpaceAlignment(JNIEnv* env, jobject o))
 390   return (jlong)SpaceAlignment;
 391 WB_END
 392 
 393 WB_ENTRY(jlong, WB_GetHeapAlignment(JNIEnv* env, jobject o))
 394   return (jlong)HeapAlignment;
 395 WB_END
 396 
<a name="3" id="anc3"></a><span class="line-modified"> 397 WB_ENTRY(jboolean, WB_SupportsConcurrentGCPhaseControl(JNIEnv* env, jobject o))</span>
<span class="line-modified"> 398   return Universe::heap()-&gt;supports_concurrent_phase_control();</span>
 399 WB_END
 400 
<a name="4" id="anc4"></a><span class="line-modified"> 401 WB_ENTRY(jboolean, WB_RequestConcurrentGCPhase(JNIEnv* env, jobject o, jstring name))</span>
<span class="line-modified"> 402   Handle h_name(THREAD, JNIHandles::resolve(name));</span>












 403   ResourceMark rm;
 404   const char* c_name = java_lang_String::as_utf8_string(h_name());
<a name="5" id="anc5"></a><span class="line-modified"> 405   return Universe::heap()-&gt;request_concurrent_phase(c_name);</span>
 406 WB_END
 407 
 408 #if INCLUDE_G1GC
 409 
 410 WB_ENTRY(jboolean, WB_G1IsHumongous(JNIEnv* env, jobject o, jobject obj))
 411   if (UseG1GC) {
 412     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 413     oop result = JNIHandles::resolve(obj);
 414     const HeapRegion* hr = g1h-&gt;heap_region_containing(result);
 415     return hr-&gt;is_humongous();
 416   }
 417   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1IsHumongous: G1 GC is not enabled&quot;);
 418 WB_END
 419 
 420 WB_ENTRY(jboolean, WB_G1BelongsToHumongousRegion(JNIEnv* env, jobject o, jlong addr))
 421   if (UseG1GC) {
 422     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 423     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 424     return hr-&gt;is_humongous();
 425   }
 426   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToHumongousRegion: G1 GC is not enabled&quot;);
 427 WB_END
 428 
 429 WB_ENTRY(jboolean, WB_G1BelongsToFreeRegion(JNIEnv* env, jobject o, jlong addr))
 430   if (UseG1GC) {
 431     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 432     const HeapRegion* hr = g1h-&gt;heap_region_containing((void*) addr);
 433     return hr-&gt;is_free();
 434   }
 435   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1BelongsToFreeRegion: G1 GC is not enabled&quot;);
 436 WB_END
 437 
 438 WB_ENTRY(jlong, WB_G1NumMaxRegions(JNIEnv* env, jobject o))
 439   if (UseG1GC) {
 440     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 441     size_t nr = g1h-&gt;max_regions();
 442     return (jlong)nr;
 443   }
 444   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumMaxRegions: G1 GC is not enabled&quot;);
 445 WB_END
 446 
 447 WB_ENTRY(jlong, WB_G1NumFreeRegions(JNIEnv* env, jobject o))
 448   if (UseG1GC) {
 449     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 450     size_t nr = g1h-&gt;num_free_regions();
 451     return (jlong)nr;
 452   }
 453   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1NumFreeRegions: G1 GC is not enabled&quot;);
 454 WB_END
 455 
 456 WB_ENTRY(jboolean, WB_G1InConcurrentMark(JNIEnv* env, jobject o))
 457   if (UseG1GC) {
 458     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 459     return g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle();
 460   }
 461   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1InConcurrentMark: G1 GC is not enabled&quot;);
 462 WB_END
 463 
 464 WB_ENTRY(jboolean, WB_G1StartMarkCycle(JNIEnv* env, jobject o))
 465   if (UseG1GC) {
 466     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 467     if (!g1h-&gt;concurrent_mark()-&gt;cm_thread()-&gt;during_cycle()) {
 468       g1h-&gt;collect(GCCause::_wb_conc_mark);
 469       return true;
 470     }
 471     return false;
 472   }
 473   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1StartMarkCycle: G1 GC is not enabled&quot;);
 474 WB_END
 475 
 476 WB_ENTRY(jint, WB_G1RegionSize(JNIEnv* env, jobject o))
 477   if (UseG1GC) {
 478     return (jint)HeapRegion::GrainBytes;
 479   }
 480   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1RegionSize: G1 GC is not enabled&quot;);
 481 WB_END
 482 
 483 #endif // INCLUDE_G1GC
 484 
 485 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
 486 WB_ENTRY(jlong, WB_DramReservedStart(JNIEnv* env, jobject o))
 487 #if INCLUDE_G1GC
 488   if (UseG1GC) {
 489     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 490     if (g1h-&gt;is_heterogeneous_heap()) {
 491       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_dram();
 492       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 493     } else {
 494       return (jlong)g1h-&gt;base();
 495     }
 496   }
 497 #endif // INCLUDE_G1GC
 498 #if INCLUDE_PARALLELGC
 499   if (UseParallelGC) {
 500     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 501     if (AllocateOldGenAt != NULL) {
 502       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 503       return (jlong)reserved.start();
 504     } else {
 505       return (jlong)ps_heap-&gt;base();
 506     }
 507   }
 508 #endif // INCLUDE_PARALLELGC
 509   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedStart: enabled only for G1 and Parallel GC&quot;);
 510 WB_END
 511 
 512 WB_ENTRY(jlong, WB_DramReservedEnd(JNIEnv* env, jobject o))
 513 #if INCLUDE_G1GC
 514   if (UseG1GC) {
 515     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 516     if (g1h-&gt;is_heterogeneous_heap()) {
 517       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;end_index_of_dram();
 518       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 519     } else {
 520       return (jlong)g1h-&gt;base() + G1Arguments::heap_max_size_bytes();
 521     }
 522   }
 523 #endif // INCLUDE_G1GC
 524 #if INCLUDE_PARALLELGC
 525   if (UseParallelGC) {
 526     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 527     if (AllocateOldGenAt != NULL) {
 528       MemRegion reserved = ps_heap-&gt;young_gen()-&gt;reserved();
 529       return (jlong)reserved.end();
 530     } else {
 531       return (jlong)ps_heap-&gt;reserved_region().end();
 532     }
 533   }
 534 #endif // INCLUDE_PARALLELGC
 535   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_DramReservedEnd: enabled only for G1 and Parallel GC&quot;);
 536 WB_END
 537 
 538 WB_ENTRY(jlong, WB_NvdimmReservedStart(JNIEnv* env, jobject o))
 539 #if INCLUDE_G1GC
 540   if (UseG1GC) {
 541     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 542     if (g1h-&gt;is_heterogeneous_heap()) {
 543       uint start_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 544       return (jlong)(g1h-&gt;base() + start_region * HeapRegion::GrainBytes);
 545     } else {
 546       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 547     }
 548   }
 549 #endif // INCLUDE_G1GC
 550 #if INCLUDE_PARALLELGC
 551   if (UseParallelGC) {
 552     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 553     if (AllocateOldGenAt != NULL) {
 554       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 555       return (jlong)reserved.start();
 556     } else {
 557       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 558     }
 559   }
 560 #endif // INCLUDE_PARALLELGC
 561   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedStart: enabled only for G1 and Parallel GC&quot;);
 562 WB_END
 563 
 564 WB_ENTRY(jlong, WB_NvdimmReservedEnd(JNIEnv* env, jobject o))
 565 #if INCLUDE_G1GC
 566   if (UseG1GC) {
 567     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 568     if (g1h-&gt;is_heterogeneous_heap()) {
 569       uint end_region = HeterogeneousHeapRegionManager::manager()-&gt;start_index_of_nvdimm();
 570       return (jlong)(g1h-&gt;base() + (end_region + 1) * HeapRegion::GrainBytes - 1);
 571     } else {
 572       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 573     }
 574   }
 575 #endif // INCLUDE_G1GC
 576 #if INCLUDE_PARALLELGC
 577   if (UseParallelGC) {
 578     ParallelScavengeHeap* ps_heap = ParallelScavengeHeap::heap();
 579     if (AllocateOldGenAt != NULL) {
 580       MemRegion reserved = ps_heap-&gt;old_gen()-&gt;reserved();
 581       return (jlong)reserved.end();
 582       } else {
 583       THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: Old gen is not allocated on NV-DIMM using AllocateOldGenAt flag&quot;);
 584     }
 585   }
 586 #endif // INCLUDE_PARALLELGC
 587   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_NvdimmReservedEnd: enabled only for G1 and Parallel GC&quot;);
 588 WB_END
 589 
 590 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
 591 
 592 #if INCLUDE_PARALLELGC
 593 
 594 WB_ENTRY(jlong, WB_PSVirtualSpaceAlignment(JNIEnv* env, jobject o))
 595   if (UseParallelGC) {
 596     return ParallelScavengeHeap::heap()-&gt;gens()-&gt;virtual_spaces()-&gt;alignment();
 597   }
 598   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSVirtualSpaceAlignment: Parallel GC is not enabled&quot;);
 599 WB_END
 600 
 601 WB_ENTRY(jlong, WB_PSHeapGenerationAlignment(JNIEnv* env, jobject o))
 602   if (UseParallelGC) {
 603     return GenAlignment;
 604   }
 605   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_PSHeapGenerationAlignment: Parallel GC is not enabled&quot;);
 606 WB_END
 607 
 608 #endif // INCLUDE_PARALLELGC
 609 
 610 #if INCLUDE_G1GC
 611 
 612 WB_ENTRY(jobject, WB_G1AuxiliaryMemoryUsage(JNIEnv* env))
 613   if (UseG1GC) {
 614     ResourceMark rm(THREAD);
 615     G1CollectedHeap* g1h = G1CollectedHeap::heap();
 616     MemoryUsage usage = g1h-&gt;get_auxiliary_data_memory_usage();
 617     Handle h = MemoryService::create_MemoryUsage_obj(usage, CHECK_NULL);
 618     return JNIHandles::make_local(env, h());
 619   }
 620   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1AuxiliaryMemoryUsage: G1 GC is not enabled&quot;);
 621 WB_END
 622 
 623 WB_ENTRY(jint, WB_G1ActiveMemoryNodeCount(JNIEnv* env, jobject o))
 624   if (UseG1GC) {
 625     G1NUMA* numa = G1NUMA::numa();
 626     return (jint)numa-&gt;num_active_nodes();
 627   }
 628   THROW_MSG_0(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1ActiveMemoryNodeCount: G1 GC is not enabled&quot;);
 629 WB_END
 630 
 631 WB_ENTRY(jintArray, WB_G1MemoryNodeIds(JNIEnv* env, jobject o))
 632   if (UseG1GC) {
 633     G1NUMA* numa = G1NUMA::numa();
 634     int num_node_ids = (int)numa-&gt;num_active_nodes();
 635     const int* node_ids = numa-&gt;node_ids();
 636 
 637     typeArrayOop result = oopFactory::new_intArray(num_node_ids, CHECK_NULL);
 638     for (int i = 0; i &lt; num_node_ids; i++) {
 639       result-&gt;int_at_put(i, (jint)node_ids[i]);
 640     }
 641     return (jintArray) JNIHandles::make_local(env, result);
 642   }
 643   THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1MemoryNodeIds: G1 GC is not enabled&quot;);
 644 WB_END
 645 
 646 class OldRegionsLivenessClosure: public HeapRegionClosure {
 647 
 648  private:
 649   const int _liveness;
 650   size_t _total_count;
 651   size_t _total_memory;
 652   size_t _total_memory_to_free;
 653 
 654  public:
 655   OldRegionsLivenessClosure(int liveness) :
 656     _liveness(liveness),
 657     _total_count(0),
 658     _total_memory(0),
 659     _total_memory_to_free(0) { }
 660 
 661     size_t total_count() { return _total_count; }
 662     size_t total_memory() { return _total_memory; }
 663     size_t total_memory_to_free() { return _total_memory_to_free; }
 664 
 665   bool do_heap_region(HeapRegion* r) {
 666     if (r-&gt;is_old()) {
 667       size_t prev_live = r-&gt;marked_bytes();
 668       size_t live = r-&gt;live_bytes();
 669       size_t size = r-&gt;used();
 670       size_t reg_size = HeapRegion::GrainBytes;
 671       if (size &gt; 0 &amp;&amp; ((int)(live * 100 / size) &lt; _liveness)) {
 672         _total_memory += size;
 673         ++_total_count;
 674         if (size == reg_size) {
 675         // we don&#39;t include non-full regions since they are unlikely included in mixed gc
 676         // for testing purposes it&#39;s enough to have lowest estimation of total memory that is expected to be freed
 677           _total_memory_to_free += size - prev_live;
 678         }
 679       }
 680     }
 681     return false;
 682   }
 683 };
 684 
 685 
 686 WB_ENTRY(jlongArray, WB_G1GetMixedGCInfo(JNIEnv* env, jobject o, jint liveness))
 687   if (!UseG1GC) {
 688     THROW_MSG_NULL(vmSymbols::java_lang_UnsupportedOperationException(), &quot;WB_G1GetMixedGCInfo: G1 GC is not enabled&quot;);
 689   }
 690   if (liveness &lt; 0) {
 691     THROW_MSG_NULL(vmSymbols::java_lang_IllegalArgumentException(), &quot;liveness value should be non-negative&quot;);
 692   }
 693 
 694   G1CollectedHeap* g1h = G1CollectedHeap::heap();
 695   OldRegionsLivenessClosure rli(liveness);
 696   g1h-&gt;heap_region_iterate(&amp;rli);
 697 
 698   typeArrayOop result = oopFactory::new_longArray(3, CHECK_NULL);
 699   result-&gt;long_at_put(0, rli.total_count());
 700   result-&gt;long_at_put(1, rli.total_memory());
 701   result-&gt;long_at_put(2, rli.total_memory_to_free());
 702   return (jlongArray) JNIHandles::make_local(env, result);
 703 WB_END
 704 
 705 #endif // INCLUDE_G1GC
 706 
 707 #if INCLUDE_NMT
 708 // Alloc memory using the test memory type so that we can use that to see if
 709 // NMT picks it up correctly
 710 WB_ENTRY(jlong, WB_NMTMalloc(JNIEnv* env, jobject o, jlong size))
 711   jlong addr = 0;
 712   addr = (jlong)(uintptr_t)os::malloc(size, mtTest);
 713   return addr;
 714 WB_END
 715 
 716 // Alloc memory with pseudo call stack. The test can create psudo malloc
 717 // allocation site to stress the malloc tracking.
 718 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStack(JNIEnv* env, jobject o, jlong size, jint pseudo_stack))
 719   address pc = (address)(size_t)pseudo_stack;
 720   NativeCallStack stack(&amp;pc, 1);
 721   return (jlong)(uintptr_t)os::malloc(size, mtTest, stack);
 722 WB_END
 723 
 724 // Alloc memory with pseudo call stack and specific memory type.
 725 WB_ENTRY(jlong, WB_NMTMallocWithPseudoStackAndType(JNIEnv* env, jobject o, jlong size, jint pseudo_stack, jint type))
 726   address pc = (address)(size_t)pseudo_stack;
 727   NativeCallStack stack(&amp;pc, 1);
 728   return (jlong)(uintptr_t)os::malloc(size, (MEMFLAGS)type, stack);
 729 WB_END
 730 
 731 // Free the memory allocated by NMTAllocTest
 732 WB_ENTRY(void, WB_NMTFree(JNIEnv* env, jobject o, jlong mem))
 733   os::free((void*)(uintptr_t)mem);
 734 WB_END
 735 
 736 WB_ENTRY(jlong, WB_NMTReserveMemory(JNIEnv* env, jobject o, jlong size))
 737   jlong addr = 0;
 738 
 739   addr = (jlong)(uintptr_t)os::reserve_memory(size);
 740   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 741 
 742   return addr;
 743 WB_END
 744 
 745 WB_ENTRY(jlong, WB_NMTAttemptReserveMemoryAt(JNIEnv* env, jobject o, jlong addr, jlong size))
 746   addr = (jlong)(uintptr_t)os::attempt_reserve_memory_at((size_t)size, (char*)(uintptr_t)addr);
 747   MemTracker::record_virtual_memory_type((address)addr, mtTest);
 748 
 749   return addr;
 750 WB_END
 751 
 752 WB_ENTRY(void, WB_NMTCommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 753   os::commit_memory((char *)(uintptr_t)addr, size, !ExecMem);
 754   MemTracker::record_virtual_memory_type((address)(uintptr_t)addr, mtTest);
 755 WB_END
 756 
 757 WB_ENTRY(void, WB_NMTUncommitMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 758   os::uncommit_memory((char *)(uintptr_t)addr, size);
 759 WB_END
 760 
 761 WB_ENTRY(void, WB_NMTReleaseMemory(JNIEnv* env, jobject o, jlong addr, jlong size))
 762   os::release_memory((char *)(uintptr_t)addr, size);
 763 WB_END
 764 
 765 WB_ENTRY(jboolean, WB_NMTChangeTrackingLevel(JNIEnv* env))
 766   // Test that we can downgrade NMT levels but not upgrade them.
 767   if (MemTracker::tracking_level() == NMT_off) {
 768     MemTracker::transition_to(NMT_off);
 769     return MemTracker::tracking_level() == NMT_off;
 770   } else {
 771     assert(MemTracker::tracking_level() == NMT_detail, &quot;Should start out as detail tracking&quot;);
 772     MemTracker::transition_to(NMT_summary);
 773     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should be summary now&quot;);
 774 
 775     // Can&#39;t go to detail once NMT is set to summary.
 776     MemTracker::transition_to(NMT_detail);
 777     assert(MemTracker::tracking_level() == NMT_summary, &quot;Should still be summary now&quot;);
 778 
 779     // Shutdown sets tracking level to minimal.
 780     MemTracker::shutdown();
 781     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should be minimal now&quot;);
 782 
 783     // Once the tracking level is minimal, we cannot increase to summary.
 784     // The code ignores this request instead of asserting because if the malloc site
 785     // table overflows in another thread, it tries to change the code to summary.
 786     MemTracker::transition_to(NMT_summary);
 787     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 788 
 789     // Really can never go up to detail, verify that the code would never do this.
 790     MemTracker::transition_to(NMT_detail);
 791     assert(MemTracker::tracking_level() == NMT_minimal, &quot;Should still be minimal now&quot;);
 792     return MemTracker::tracking_level() == NMT_minimal;
 793   }
 794 WB_END
 795 
 796 WB_ENTRY(jint, WB_NMTGetHashSize(JNIEnv* env, jobject o))
 797   int hash_size = MallocSiteTable::hash_buckets();
 798   assert(hash_size &gt; 0, &quot;NMT hash_size should be &gt; 0&quot;);
 799   return (jint)hash_size;
 800 WB_END
 801 
 802 WB_ENTRY(jlong, WB_NMTNewArena(JNIEnv* env, jobject o, jlong init_size))
 803   Arena* arena =  new (mtTest) Arena(mtTest, size_t(init_size));
 804   return (jlong)arena;
 805 WB_END
 806 
 807 WB_ENTRY(void, WB_NMTFreeArena(JNIEnv* env, jobject o, jlong arena))
 808   Arena* a = (Arena*)arena;
 809   delete a;
 810 WB_END
 811 
 812 WB_ENTRY(void, WB_NMTArenaMalloc(JNIEnv* env, jobject o, jlong arena, jlong size))
 813   Arena* a = (Arena*)arena;
 814   a-&gt;Amalloc(size_t(size));
 815 WB_END
 816 #endif // INCLUDE_NMT
 817 
 818 static jmethodID reflected_method_to_jmid(JavaThread* thread, JNIEnv* env, jobject method) {
 819   assert(method != NULL, &quot;method should not be null&quot;);
 820   ThreadToNativeFromVM ttn(thread);
 821   return env-&gt;FromReflectedMethod(method);
 822 }
 823 
 824 static CompLevel highestCompLevel() {
 825   return TieredCompilation ? MIN2((CompLevel) TieredStopAtLevel, CompLevel_highest_tier) : CompLevel_highest_tier;
 826 }
 827 
 828 // Deoptimizes all compiled frames and makes nmethods not entrant if it&#39;s requested
 829 class VM_WhiteBoxDeoptimizeFrames : public VM_WhiteBoxOperation {
 830  private:
 831   int _result;
 832   const bool _make_not_entrant;
 833  public:
 834   VM_WhiteBoxDeoptimizeFrames(bool make_not_entrant) :
 835         _result(0), _make_not_entrant(make_not_entrant) { }
 836   int  result() const { return _result; }
 837 
 838   void doit() {
 839     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {
 840       if (t-&gt;has_last_Java_frame()) {
 841         for (StackFrameStream fst(t, false); !fst.is_done(); fst.next()) {
 842           frame* f = fst.current();
 843           if (f-&gt;can_be_deoptimized() &amp;&amp; !f-&gt;is_deoptimized_frame()) {
 844             Deoptimization::deoptimize(t, *f);
 845             if (_make_not_entrant) {
 846                 CompiledMethod* cm = CodeCache::find_compiled(f-&gt;pc());
 847                 assert(cm != NULL, &quot;sanity check&quot;);
 848                 cm-&gt;make_not_entrant();
 849             }
 850             ++_result;
 851           }
 852         }
 853       }
 854     }
 855   }
 856 };
 857 
 858 WB_ENTRY(jint, WB_DeoptimizeFrames(JNIEnv* env, jobject o, jboolean make_not_entrant))
 859   VM_WhiteBoxDeoptimizeFrames op(make_not_entrant == JNI_TRUE);
 860   VMThread::execute(&amp;op);
 861   return op.result();
 862 WB_END
 863 
 864 WB_ENTRY(void, WB_DeoptimizeAll(JNIEnv* env, jobject o))
 865   CodeCache::mark_all_nmethods_for_deoptimization();
 866   Deoptimization::deoptimize_all_marked();
 867 WB_END
 868 
 869 WB_ENTRY(jint, WB_DeoptimizeMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 870   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 871   int result = 0;
 872   CHECK_JNI_EXCEPTION_(env, result);
 873   MutexLocker mu(Compile_lock);
 874   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 875   if (is_osr) {
 876     result += mh-&gt;mark_osr_nmethods();
 877   } else if (mh-&gt;code() != NULL) {
 878     mh-&gt;code()-&gt;mark_for_deoptimization();
 879     ++result;
 880   }
 881   result += CodeCache::mark_for_deoptimization(mh());
 882   if (result &gt; 0) {
 883     Deoptimization::deoptimize_all_marked();
 884   }
 885   return result;
 886 WB_END
 887 
 888 WB_ENTRY(jboolean, WB_IsMethodCompiled(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 889   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 890   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 891   MutexLocker mu(Compile_lock);
 892   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 893   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 894   if (code == NULL) {
 895     return JNI_FALSE;
 896   }
 897   return (code-&gt;is_alive() &amp;&amp; !code-&gt;is_marked_for_deoptimization());
 898 WB_END
 899 
 900 WB_ENTRY(jboolean, WB_IsMethodCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 901   if (method == NULL || comp_level &gt; highestCompLevel()) {
 902     return false;
 903   }
 904   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 905   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 906   MutexLocker mu(Compile_lock);
 907   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 908   if (is_osr) {
 909     return CompilationPolicy::can_be_osr_compiled(mh, comp_level);
 910   } else {
 911     return CompilationPolicy::can_be_compiled(mh, comp_level);
 912   }
 913 WB_END
 914 
 915 WB_ENTRY(jboolean, WB_IsMethodQueuedForCompilation(JNIEnv* env, jobject o, jobject method))
 916   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 917   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 918   MutexLocker mu(Compile_lock);
 919   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 920   return mh-&gt;queued_for_compilation();
 921 WB_END
 922 
 923 WB_ENTRY(jboolean, WB_IsIntrinsicAvailable(JNIEnv* env, jobject o, jobject method, jobject compilation_context, jint compLevel))
 924   if (compLevel &lt; CompLevel_none || compLevel &gt; highestCompLevel()) {
 925     return false; // Intrinsic is not available on a non-existent compilation level.
 926   }
 927   jmethodID method_id, compilation_context_id;
 928   method_id = reflected_method_to_jmid(thread, env, method);
 929   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 930   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(method_id));
 931 
 932   DirectiveSet* directive;
 933   AbstractCompiler* comp = CompileBroker::compiler((int)compLevel);
 934   assert(comp != NULL, &quot;compiler not available&quot;);
 935   if (compilation_context != NULL) {
 936     compilation_context_id = reflected_method_to_jmid(thread, env, compilation_context);
 937     CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 938     methodHandle cch(THREAD, Method::checked_resolve_jmethod_id(compilation_context_id));
 939     directive = DirectivesStack::getMatchingDirective(cch, comp);
 940   } else {
 941     // Calling with NULL matches default directive
 942     directive = DirectivesStack::getDefaultDirective(comp);
 943   }
 944   bool result = comp-&gt;is_intrinsic_available(mh, directive);
 945   DirectivesStack::release(directive);
 946   return result;
 947 WB_END
 948 
 949 WB_ENTRY(jint, WB_GetMethodCompilationLevel(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
 950   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 951   CHECK_JNI_EXCEPTION_(env, CompLevel_none);
 952   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 953   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
 954   return (code != NULL ? code-&gt;comp_level() : CompLevel_none);
 955 WB_END
 956 
 957 WB_ENTRY(void, WB_MakeMethodNotCompilable(JNIEnv* env, jobject o, jobject method, jint comp_level, jboolean is_osr))
 958   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 959   CHECK_JNI_EXCEPTION(env);
 960   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 961   if (is_osr) {
 962     mh-&gt;set_not_osr_compilable(&quot;WhiteBox&quot;, comp_level);
 963   } else {
 964     mh-&gt;set_not_compilable(&quot;WhiteBox&quot;, comp_level);
 965   }
 966 WB_END
 967 
 968 WB_ENTRY(jint, WB_GetMethodEntryBci(JNIEnv* env, jobject o, jobject method))
 969   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 970   CHECK_JNI_EXCEPTION_(env, InvocationEntryBci);
 971   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 972   CompiledMethod* code = mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false);
 973   return (code != NULL &amp;&amp; code-&gt;is_osr_method() ? code-&gt;osr_entry_bci() : InvocationEntryBci);
 974 WB_END
 975 
 976 WB_ENTRY(jboolean, WB_TestSetDontInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 977   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 978   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 979   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 980   bool result = mh-&gt;dont_inline();
 981   mh-&gt;set_dont_inline(value == JNI_TRUE);
 982   return result;
 983 WB_END
 984 
 985 WB_ENTRY(jint, WB_GetCompileQueueSize(JNIEnv* env, jobject o, jint comp_level))
 986   if (comp_level == CompLevel_any) {
 987     return CompileBroker::queue_size(CompLevel_full_optimization) /* C2 */ +
 988         CompileBroker::queue_size(CompLevel_full_profile) /* C1 */;
 989   } else {
 990     return CompileBroker::queue_size(comp_level);
 991   }
 992 WB_END
 993 
 994 WB_ENTRY(jboolean, WB_TestSetForceInlineMethod(JNIEnv* env, jobject o, jobject method, jboolean value))
 995   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
 996   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
 997   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
 998   bool result = mh-&gt;force_inline();
 999   mh-&gt;set_force_inline(value == JNI_TRUE);
1000   return result;
1001 WB_END
1002 
<a name="6" id="anc6"></a>











1003 bool WhiteBox::compile_method(Method* method, int comp_level, int bci, Thread* THREAD) {
1004   // Screen for unavailable/bad comp level or null method
1005   AbstractCompiler* comp = CompileBroker::compiler(comp_level);
1006   if (method == NULL) {
1007     tty-&gt;print_cr(&quot;WB error: request to compile NULL method&quot;);
1008     return false;
1009   }
1010   if (comp_level &gt; highestCompLevel()) {
1011     tty-&gt;print_cr(&quot;WB error: invalid compilation level %d&quot;, comp_level);
1012     return false;
1013   }
1014   if (comp == NULL) {
1015     tty-&gt;print_cr(&quot;WB error: no compiler for requested compilation level %d&quot;, comp_level);
1016     return false;
1017   }
1018 
1019   // Check if compilation is blocking
1020   methodHandle mh(THREAD, method);
1021   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, comp);
1022   bool is_blocking = !directive-&gt;BackgroundCompilationOption;
1023   DirectivesStack::release(directive);
1024 
1025   // Compile method and check result
1026   nmethod* nm = CompileBroker::compile_method(mh, bci, comp_level, mh, mh-&gt;invocation_count(), CompileTask::Reason_Whitebox, THREAD);
1027   MutexLocker mu(THREAD, Compile_lock);
1028   bool is_queued = mh-&gt;queued_for_compilation();
1029   if ((!is_blocking &amp;&amp; is_queued) || nm != NULL) {
1030     return true;
1031   }
1032   tty-&gt;print(&quot;WB error: failed to %s compile at level %d method &quot;, is_blocking ? &quot;blocking&quot; : &quot;&quot;, comp_level);
1033   mh-&gt;print_short_name(tty);
1034   tty-&gt;cr();
1035   if (is_blocking &amp;&amp; is_queued) {
1036     tty-&gt;print_cr(&quot;WB error: blocking compilation is still in queue!&quot;);
1037   }
1038   return false;
1039 }
1040 
1041 WB_ENTRY(jboolean, WB_EnqueueMethodForCompilation(JNIEnv* env, jobject o, jobject method, jint comp_level, jint bci))
1042   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1043   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1044   return WhiteBox::compile_method(Method::checked_resolve_jmethod_id(jmid), comp_level, bci, THREAD);
1045 WB_END
1046 
1047 WB_ENTRY(jboolean, WB_EnqueueInitializerForCompilation(JNIEnv* env, jobject o, jclass klass, jint comp_level))
1048   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1049   Method* clinit = ik-&gt;class_initializer();
1050   if (clinit == NULL) {
1051     return false;
1052   }
1053   return WhiteBox::compile_method(clinit, comp_level, InvocationEntryBci, THREAD);
1054 WB_END
1055 
1056 WB_ENTRY(jboolean, WB_ShouldPrintAssembly(JNIEnv* env, jobject o, jobject method, jint comp_level))
1057   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1058   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1059 
1060   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1061   DirectiveSet* directive = DirectivesStack::getMatchingDirective(mh, CompileBroker::compiler(comp_level));
1062   bool result = directive-&gt;PrintAssemblyOption;
1063   DirectivesStack::release(directive);
1064 
1065   return result;
1066 WB_END
1067 
1068 WB_ENTRY(jint, WB_MatchesInline(JNIEnv* env, jobject o, jobject method, jstring pattern))
1069   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1070   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1071 
1072   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1073 
1074   ResourceMark rm(THREAD);
1075   const char* error_msg = NULL;
1076   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1077   InlineMatcher* m = InlineMatcher::parse_inline_pattern(method_str, error_msg);
1078 
1079   if (m == NULL) {
1080     assert(error_msg != NULL, &quot;Always have an error message&quot;);
1081     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1082     return -1; // Pattern failed
1083   }
1084 
1085   // Pattern works - now check if it matches
1086   int result;
1087   if (m-&gt;match(mh, InlineMatcher::force_inline)) {
1088     result = 2; // Force inline match
1089   } else if (m-&gt;match(mh, InlineMatcher::dont_inline)) {
1090     result = 1; // Dont inline match
1091   } else {
1092     result = 0; // No match
1093   }
1094   delete m;
1095   return result;
1096 WB_END
1097 
1098 WB_ENTRY(jint, WB_MatchesMethod(JNIEnv* env, jobject o, jobject method, jstring pattern))
1099   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1100   CHECK_JNI_EXCEPTION_(env, JNI_FALSE);
1101 
1102   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1103 
1104   ResourceMark rm;
1105   char* method_str = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(pattern));
1106 
1107   const char* error_msg = NULL;
1108 
1109   BasicMatcher* m = BasicMatcher::parse_method_pattern(method_str, error_msg);
1110   if (m == NULL) {
1111     assert(error_msg != NULL, &quot;Must have error_msg&quot;);
1112     tty-&gt;print_cr(&quot;Got error: %s&quot;, error_msg);
1113     return -1;
1114   }
1115 
1116   // Pattern works - now check if it matches
1117   int result = m-&gt;matches(mh);
1118   delete m;
1119   assert(result == 0 || result == 1, &quot;Result out of range&quot;);
1120   return result;
1121 WB_END
1122 
1123 WB_ENTRY(void, WB_MarkMethodProfiled(JNIEnv* env, jobject o, jobject method))
1124   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1125   CHECK_JNI_EXCEPTION(env);
1126   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1127 
1128   MethodData* mdo = mh-&gt;method_data();
1129   if (mdo == NULL) {
1130     Method::build_interpreter_method_data(mh, CHECK_AND_CLEAR);
1131     mdo = mh-&gt;method_data();
1132   }
1133   mdo-&gt;init();
1134   InvocationCounter* icnt = mdo-&gt;invocation_counter();
1135   InvocationCounter* bcnt = mdo-&gt;backedge_counter();
1136   // set i-counter according to TieredThresholdPolicy::is_method_profiled
1137   icnt-&gt;set(Tier4MinInvocationThreshold);
1138   bcnt-&gt;set(Tier4CompileThreshold);
1139 WB_END
1140 
1141 WB_ENTRY(void, WB_ClearMethodState(JNIEnv* env, jobject o, jobject method))
1142   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1143   CHECK_JNI_EXCEPTION(env);
1144   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1145   MutexLocker mu(THREAD, Compile_lock);
1146   MethodData* mdo = mh-&gt;method_data();
1147   MethodCounters* mcs = mh-&gt;method_counters();
1148 
1149   if (mdo != NULL) {
1150     mdo-&gt;init();
1151     ResourceMark rm(THREAD);
1152     int arg_count = mdo-&gt;method()-&gt;size_of_parameters();
1153     for (int i = 0; i &lt; arg_count; i++) {
1154       mdo-&gt;set_arg_modified(i, 0);
1155     }
1156     MutexLocker mu(THREAD, mdo-&gt;extra_data_lock());
1157     mdo-&gt;clean_method_data(/*always_clean*/true);
1158   }
1159 
1160   mh-&gt;clear_not_c1_compilable();
1161   mh-&gt;clear_not_c2_compilable();
1162   mh-&gt;clear_not_c2_osr_compilable();
1163   NOT_PRODUCT(mh-&gt;set_compiled_invocation_count(0));
1164   if (mcs != NULL) {
1165     mcs-&gt;backedge_counter()-&gt;init();
1166     mcs-&gt;invocation_counter()-&gt;init();
1167     mcs-&gt;set_interpreter_invocation_count(0);
1168     mcs-&gt;set_interpreter_throwout_count(0);
1169 
1170 #ifdef TIERED
1171     mcs-&gt;set_rate(0.0F);
1172     mh-&gt;set_prev_event_count(0);
1173     mh-&gt;set_prev_time(0);
1174 #endif
1175   }
1176 WB_END
1177 
1178 template &lt;typename T&gt;
1179 static bool GetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAt)(const JVMFlag*, T*)) {
1180   if (name == NULL) {
1181     return false;
1182   }
1183   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1184   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1185   CHECK_JNI_EXCEPTION_(env, false);
1186   const JVMFlag* flag = JVMFlag::find_declared_flag(flag_name);
1187   JVMFlag::Error result = (*TAt)(flag, value);
1188   env-&gt;ReleaseStringUTFChars(name, flag_name);
1189   return (result == JVMFlag::SUCCESS);
1190 }
1191 
1192 template &lt;typename T&gt;
1193 static bool SetVMFlag(JavaThread* thread, JNIEnv* env, jstring name, T* value, JVMFlag::Error (*TAtPut)(JVMFlag* flag, T*, JVMFlag::Flags)) {
1194   if (name == NULL) {
1195     return false;
1196   }
1197   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1198   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1199   CHECK_JNI_EXCEPTION_(env, false);
1200   JVMFlag* flag = JVMFlag::find_flag(flag_name);
1201   JVMFlag::Error result = (*TAtPut)(flag, value, JVMFlag::INTERNAL);
1202   env-&gt;ReleaseStringUTFChars(name, flag_name);
1203   return (result == JVMFlag::SUCCESS);
1204 }
1205 
1206 template &lt;typename T&gt;
1207 static jobject box(JavaThread* thread, JNIEnv* env, Symbol* name, Symbol* sig, T value) {
1208   ResourceMark rm(thread);
1209   jclass clazz = env-&gt;FindClass(name-&gt;as_C_string());
1210   CHECK_JNI_EXCEPTION_(env, NULL);
1211   jmethodID methodID = env-&gt;GetStaticMethodID(clazz,
1212         vmSymbols::valueOf_name()-&gt;as_C_string(),
1213         sig-&gt;as_C_string());
1214   CHECK_JNI_EXCEPTION_(env, NULL);
1215   jobject result = env-&gt;CallStaticObjectMethod(clazz, methodID, value);
1216   CHECK_JNI_EXCEPTION_(env, NULL);
1217   return result;
1218 }
1219 
1220 static jobject booleanBox(JavaThread* thread, JNIEnv* env, jboolean value) {
1221   return box(thread, env, vmSymbols::java_lang_Boolean(), vmSymbols::Boolean_valueOf_signature(), value);
1222 }
1223 static jobject integerBox(JavaThread* thread, JNIEnv* env, jint value) {
1224   return box(thread, env, vmSymbols::java_lang_Integer(), vmSymbols::Integer_valueOf_signature(), value);
1225 }
1226 static jobject longBox(JavaThread* thread, JNIEnv* env, jlong value) {
1227   return box(thread, env, vmSymbols::java_lang_Long(), vmSymbols::Long_valueOf_signature(), value);
1228 }
1229 /* static jobject floatBox(JavaThread* thread, JNIEnv* env, jfloat value) {
1230   return box(thread, env, vmSymbols::java_lang_Float(), vmSymbols::Float_valueOf_signature(), value);
1231 }*/
1232 static jobject doubleBox(JavaThread* thread, JNIEnv* env, jdouble value) {
1233   return box(thread, env, vmSymbols::java_lang_Double(), vmSymbols::Double_valueOf_signature(), value);
1234 }
1235 
1236 static const JVMFlag* getVMFlag(JavaThread* thread, JNIEnv* env, jstring name) {
1237   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1238   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1239   CHECK_JNI_EXCEPTION_(env, NULL);
1240   const JVMFlag* result = JVMFlag::find_declared_flag(flag_name);
1241   env-&gt;ReleaseStringUTFChars(name, flag_name);
1242   return result;
1243 }
1244 
1245 WB_ENTRY(jboolean, WB_IsConstantVMFlag(JNIEnv* env, jobject o, jstring name))
1246   const JVMFlag* flag = getVMFlag(thread, env, name);
1247   return (flag != NULL) &amp;&amp; flag-&gt;is_constant_in_binary();
1248 WB_END
1249 
1250 WB_ENTRY(jboolean, WB_IsLockedVMFlag(JNIEnv* env, jobject o, jstring name))
1251   const JVMFlag* flag = getVMFlag(thread, env, name);
1252   return (flag != NULL) &amp;&amp; !(flag-&gt;is_unlocked() || flag-&gt;is_unlocker());
1253 WB_END
1254 
1255 WB_ENTRY(jobject, WB_GetBooleanVMFlag(JNIEnv* env, jobject o, jstring name))
1256   bool result;
1257   if (GetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAt)) {
1258     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1259     return booleanBox(thread, env, result);
1260   }
1261   return NULL;
1262 WB_END
1263 
1264 WB_ENTRY(jobject, WB_GetIntVMFlag(JNIEnv* env, jobject o, jstring name))
1265   int result;
1266   if (GetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAt)) {
1267     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1268     return longBox(thread, env, result);
1269   }
1270   return NULL;
1271 WB_END
1272 
1273 WB_ENTRY(jobject, WB_GetUintVMFlag(JNIEnv* env, jobject o, jstring name))
1274   uint result;
1275   if (GetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAt)) {
1276     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1277     return longBox(thread, env, result);
1278   }
1279   return NULL;
1280 WB_END
1281 
1282 WB_ENTRY(jobject, WB_GetIntxVMFlag(JNIEnv* env, jobject o, jstring name))
1283   intx result;
1284   if (GetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAt)) {
1285     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1286     return longBox(thread, env, result);
1287   }
1288   return NULL;
1289 WB_END
1290 
1291 WB_ENTRY(jobject, WB_GetUintxVMFlag(JNIEnv* env, jobject o, jstring name))
1292   uintx result;
1293   if (GetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAt)) {
1294     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1295     return longBox(thread, env, result);
1296   }
1297   return NULL;
1298 WB_END
1299 
1300 WB_ENTRY(jobject, WB_GetUint64VMFlag(JNIEnv* env, jobject o, jstring name))
1301   uint64_t result;
1302   if (GetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAt)) {
1303     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1304     return longBox(thread, env, result);
1305   }
1306   return NULL;
1307 WB_END
1308 
1309 WB_ENTRY(jobject, WB_GetSizeTVMFlag(JNIEnv* env, jobject o, jstring name))
1310   size_t result;
1311   if (GetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAt)) {
1312     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1313     return longBox(thread, env, result);
1314   }
1315   return NULL;
1316 WB_END
1317 
1318 WB_ENTRY(jobject, WB_GetDoubleVMFlag(JNIEnv* env, jobject o, jstring name))
1319   double result;
1320   if (GetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAt)) {
1321     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1322     return doubleBox(thread, env, result);
1323   }
1324   return NULL;
1325 WB_END
1326 
1327 WB_ENTRY(jstring, WB_GetStringVMFlag(JNIEnv* env, jobject o, jstring name))
1328   ccstr ccstrResult;
1329   if (GetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAt)) {
1330     ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1331     jstring result = env-&gt;NewStringUTF(ccstrResult);
1332     CHECK_JNI_EXCEPTION_(env, NULL);
1333     return result;
1334   }
1335   return NULL;
1336 WB_END
1337 
1338 WB_ENTRY(void, WB_SetBooleanVMFlag(JNIEnv* env, jobject o, jstring name, jboolean value))
1339   bool result = value == JNI_TRUE ? true : false;
1340   SetVMFlag &lt;bool&gt; (thread, env, name, &amp;result, &amp;JVMFlag::boolAtPut);
1341 WB_END
1342 
1343 WB_ENTRY(void, WB_SetIntVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1344   int result = value;
1345   SetVMFlag &lt;int&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intAtPut);
1346 WB_END
1347 
1348 WB_ENTRY(void, WB_SetUintVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1349   uint result = value;
1350   SetVMFlag &lt;uint&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintAtPut);
1351 WB_END
1352 
1353 WB_ENTRY(void, WB_SetIntxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1354   intx result = value;
1355   SetVMFlag &lt;intx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::intxAtPut);
1356 WB_END
1357 
1358 WB_ENTRY(void, WB_SetUintxVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1359   uintx result = value;
1360   SetVMFlag &lt;uintx&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uintxAtPut);
1361 WB_END
1362 
1363 WB_ENTRY(void, WB_SetUint64VMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1364   uint64_t result = value;
1365   SetVMFlag &lt;uint64_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::uint64_tAtPut);
1366 WB_END
1367 
1368 WB_ENTRY(void, WB_SetSizeTVMFlag(JNIEnv* env, jobject o, jstring name, jlong value))
1369   size_t result = value;
1370   SetVMFlag &lt;size_t&gt; (thread, env, name, &amp;result, &amp;JVMFlag::size_tAtPut);
1371 WB_END
1372 
1373 WB_ENTRY(void, WB_SetDoubleVMFlag(JNIEnv* env, jobject o, jstring name, jdouble value))
1374   double result = value;
1375   SetVMFlag &lt;double&gt; (thread, env, name, &amp;result, &amp;JVMFlag::doubleAtPut);
1376 WB_END
1377 
1378 WB_ENTRY(void, WB_SetStringVMFlag(JNIEnv* env, jobject o, jstring name, jstring value))
1379   ThreadToNativeFromVM ttnfv(thread);   // can&#39;t be in VM when we call JNI
1380   const char* ccstrValue;
1381   if (value == NULL) {
1382     ccstrValue = NULL;
1383   }
1384   else {
1385     ccstrValue = env-&gt;GetStringUTFChars(value, NULL);
1386     CHECK_JNI_EXCEPTION(env);
1387   }
1388   ccstr ccstrResult = ccstrValue;
1389   bool needFree;
1390   {
1391     ThreadInVMfromNative ttvfn(thread); // back to VM
1392     needFree = SetVMFlag &lt;ccstr&gt; (thread, env, name, &amp;ccstrResult, &amp;JVMFlag::ccstrAtPut);
1393   }
1394   if (value != NULL) {
1395     env-&gt;ReleaseStringUTFChars(value, ccstrValue);
1396   }
1397   if (needFree) {
1398     FREE_C_HEAP_ARRAY(char, ccstrResult);
1399   }
1400 WB_END
1401 
1402 WB_ENTRY(void, WB_LockCompilation(JNIEnv* env, jobject o, jlong timeout))
1403   WhiteBox::compilation_locked = true;
1404 WB_END
1405 
1406 WB_ENTRY(void, WB_UnlockCompilation(JNIEnv* env, jobject o))
1407   MonitorLocker mo(Compilation_lock, Mutex::_no_safepoint_check_flag);
1408   WhiteBox::compilation_locked = false;
1409   mo.notify_all();
1410 WB_END
1411 
1412 WB_ENTRY(void, WB_ForceNMethodSweep(JNIEnv* env, jobject o))
1413   // Force a code cache sweep and block until it finished
1414   NMethodSweeper::force_sweep();
1415 WB_END
1416 
1417 WB_ENTRY(jboolean, WB_IsInStringTable(JNIEnv* env, jobject o, jstring javaString))
1418   ResourceMark rm(THREAD);
1419   int len;
1420   jchar* name = java_lang_String::as_unicode_string(JNIHandles::resolve(javaString), len, CHECK_false);
1421   return (StringTable::lookup(name, len) != NULL);
1422 WB_END
1423 
1424 WB_ENTRY(void, WB_FullGC(JNIEnv* env, jobject o))
1425   Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(true);
1426   Universe::heap()-&gt;collect(GCCause::_wb_full_gc);
1427 #if INCLUDE_G1GC
1428   if (UseG1GC) {
1429     // Needs to be cleared explicitly for G1
1430     Universe::heap()-&gt;soft_ref_policy()-&gt;set_should_clear_all_soft_refs(false);
1431   }
1432 #endif // INCLUDE_G1GC
1433 WB_END
1434 
1435 WB_ENTRY(void, WB_YoungGC(JNIEnv* env, jobject o))
1436   Universe::heap()-&gt;collect(GCCause::_wb_young_gc);
1437 WB_END
1438 
1439 WB_ENTRY(void, WB_ReadReservedMemory(JNIEnv* env, jobject o))
1440   // static+volatile in order to force the read to happen
1441   // (not be eliminated by the compiler)
1442   static char c;
1443   static volatile char* p;
1444 
1445   p = os::reserve_memory(os::vm_allocation_granularity(), NULL, 0);
1446   if (p == NULL) {
1447     THROW_MSG(vmSymbols::java_lang_OutOfMemoryError(), &quot;Failed to reserve memory&quot;);
1448   }
1449 
1450   c = *p;
1451 WB_END
1452 
1453 WB_ENTRY(jstring, WB_GetCPUFeatures(JNIEnv* env, jobject o))
1454   const char* features = VM_Version::features_string();
1455   ThreadToNativeFromVM ttn(thread);
1456   jstring features_string = env-&gt;NewStringUTF(features);
1457 
1458   CHECK_JNI_EXCEPTION_(env, NULL);
1459 
1460   return features_string;
1461 WB_END
1462 
1463 int WhiteBox::get_blob_type(const CodeBlob* code) {
1464   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1465   if (code-&gt;is_aot()) {
1466     return -1;
1467   }
1468   return CodeCache::get_code_heap(code)-&gt;code_blob_type();
1469 }
1470 
1471 CodeHeap* WhiteBox::get_code_heap(int blob_type) {
1472   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1473   return CodeCache::get_code_heap(blob_type);
1474 }
1475 
1476 struct CodeBlobStub {
1477   CodeBlobStub(const CodeBlob* blob) :
1478       name(os::strdup(blob-&gt;name())),
1479       size(blob-&gt;size()),
1480       blob_type(WhiteBox::get_blob_type(blob)),
1481       address((jlong) blob) { }
1482   ~CodeBlobStub() { os::free((void*) name); }
1483   const char* const name;
1484   const jint        size;
1485   const jint        blob_type;
1486   const jlong       address;
1487 };
1488 
1489 static jobjectArray codeBlob2objectArray(JavaThread* thread, JNIEnv* env, CodeBlobStub* cb) {
<a name="7" id="anc7"></a>
1490   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1491   CHECK_JNI_EXCEPTION_(env, NULL);
1492   jobjectArray result = env-&gt;NewObjectArray(4, clazz, NULL);
1493 
1494   jstring name = env-&gt;NewStringUTF(cb-&gt;name);
1495   CHECK_JNI_EXCEPTION_(env, NULL);
1496   env-&gt;SetObjectArrayElement(result, 0, name);
1497 
1498   jobject obj = integerBox(thread, env, cb-&gt;size);
1499   CHECK_JNI_EXCEPTION_(env, NULL);
1500   env-&gt;SetObjectArrayElement(result, 1, obj);
1501 
1502   obj = integerBox(thread, env, cb-&gt;blob_type);
1503   CHECK_JNI_EXCEPTION_(env, NULL);
1504   env-&gt;SetObjectArrayElement(result, 2, obj);
1505 
1506   obj = longBox(thread, env, cb-&gt;address);
1507   CHECK_JNI_EXCEPTION_(env, NULL);
1508   env-&gt;SetObjectArrayElement(result, 3, obj);
1509 
1510   return result;
1511 }
1512 
1513 WB_ENTRY(jobjectArray, WB_GetNMethod(JNIEnv* env, jobject o, jobject method, jboolean is_osr))
1514   ResourceMark rm(THREAD);
1515   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1516   CHECK_JNI_EXCEPTION_(env, NULL);
1517   methodHandle mh(THREAD, Method::checked_resolve_jmethod_id(jmid));
1518   CompiledMethod* code = is_osr ? mh-&gt;lookup_osr_nmethod_for(InvocationEntryBci, CompLevel_none, false) : mh-&gt;code();
1519   jobjectArray result = NULL;
1520   if (code == NULL) {
1521     return result;
1522   }
1523   int comp_level = code-&gt;comp_level();
1524   int insts_size = comp_level == CompLevel_aot ? code-&gt;code_end() - code-&gt;code_begin() : code-&gt;insts_size();
1525 
1526   ThreadToNativeFromVM ttn(thread);
1527   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1528   CHECK_JNI_EXCEPTION_(env, NULL);
1529   result = env-&gt;NewObjectArray(5, clazz, NULL);
1530   if (result == NULL) {
1531     return result;
1532   }
1533 
1534   CodeBlobStub stub(code);
1535   jobjectArray codeBlob = codeBlob2objectArray(thread, env, &amp;stub);
1536   CHECK_JNI_EXCEPTION_(env, NULL);
1537   env-&gt;SetObjectArrayElement(result, 0, codeBlob);
1538 
1539   jobject level = integerBox(thread, env, comp_level);
1540   CHECK_JNI_EXCEPTION_(env, NULL);
1541   env-&gt;SetObjectArrayElement(result, 1, level);
1542 
1543   jbyteArray insts = env-&gt;NewByteArray(insts_size);
1544   CHECK_JNI_EXCEPTION_(env, NULL);
1545   env-&gt;SetByteArrayRegion(insts, 0, insts_size, (jbyte*) code-&gt;insts_begin());
1546   env-&gt;SetObjectArrayElement(result, 2, insts);
1547 
1548   jobject id = integerBox(thread, env, code-&gt;compile_id());
1549   CHECK_JNI_EXCEPTION_(env, NULL);
1550   env-&gt;SetObjectArrayElement(result, 3, id);
1551 
1552   jobject entry_point = longBox(thread, env, (jlong) code-&gt;entry_point());
1553   CHECK_JNI_EXCEPTION_(env, NULL);
1554   env-&gt;SetObjectArrayElement(result, 4, entry_point);
1555 
1556   return result;
1557 WB_END
1558 
1559 CodeBlob* WhiteBox::allocate_code_blob(int size, int blob_type) {
1560   guarantee(WhiteBoxAPI, &quot;internal testing API :: WhiteBox has to be enabled&quot;);
1561   BufferBlob* blob;
1562   int full_size = CodeBlob::align_code_offset(sizeof(BufferBlob));
1563   if (full_size &lt; size) {
1564     full_size += align_up(size - full_size, oopSize);
1565   }
1566   {
1567     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1568     blob = (BufferBlob*) CodeCache::allocate(full_size, blob_type);
1569     if (blob != NULL) {
1570       ::new (blob) BufferBlob(&quot;WB::DummyBlob&quot;, full_size);
1571     }
1572   }
1573   // Track memory usage statistic after releasing CodeCache_lock
1574   MemoryService::track_code_cache_memory_usage();
1575   return blob;
1576 }
1577 
1578 WB_ENTRY(jlong, WB_AllocateCodeBlob(JNIEnv* env, jobject o, jint size, jint blob_type))
1579   if (size &lt; 0) {
1580     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1581       err_msg(&quot;WB_AllocateCodeBlob: size is negative: &quot; INT32_FORMAT, size));
1582   }
1583   return (jlong) WhiteBox::allocate_code_blob(size, blob_type);
1584 WB_END
1585 
1586 WB_ENTRY(void, WB_FreeCodeBlob(JNIEnv* env, jobject o, jlong addr))
1587   if (addr == 0) {
1588     return;
1589   }
1590   BufferBlob::free((BufferBlob*) addr);
1591 WB_END
1592 
1593 WB_ENTRY(jobjectArray, WB_GetCodeHeapEntries(JNIEnv* env, jobject o, jint blob_type))
1594   ResourceMark rm;
1595   GrowableArray&lt;CodeBlobStub*&gt; blobs;
1596   {
1597     MutexLocker mu(CodeCache_lock, Mutex::_no_safepoint_check_flag);
1598     CodeHeap* heap = WhiteBox::get_code_heap(blob_type);
1599     if (heap == NULL) {
1600       return NULL;
1601     }
1602     for (CodeBlob* cb = (CodeBlob*) heap-&gt;first();
1603          cb != NULL; cb = (CodeBlob*) heap-&gt;next(cb)) {
1604       CodeBlobStub* stub = NEW_RESOURCE_OBJ(CodeBlobStub);
1605       new (stub) CodeBlobStub(cb);
1606       blobs.append(stub);
1607     }
1608   }
1609   ThreadToNativeFromVM ttn(thread);
1610   jobjectArray result = NULL;
1611   jclass clazz = env-&gt;FindClass(vmSymbols::java_lang_Object()-&gt;as_C_string());
1612   CHECK_JNI_EXCEPTION_(env, NULL);
1613   result = env-&gt;NewObjectArray(blobs.length(), clazz, NULL);
1614   CHECK_JNI_EXCEPTION_(env, NULL);
1615   if (result == NULL) {
1616     return result;
1617   }
1618   int i = 0;
1619   for (GrowableArrayIterator&lt;CodeBlobStub*&gt; it = blobs.begin();
1620        it != blobs.end(); ++it) {
1621     jobjectArray obj = codeBlob2objectArray(thread, env, *it);
1622     CHECK_JNI_EXCEPTION_(env, NULL);
1623     env-&gt;SetObjectArrayElement(result, i, obj);
1624     CHECK_JNI_EXCEPTION_(env, NULL);
1625     ++i;
1626   }
1627   return result;
1628 WB_END
1629 
1630 WB_ENTRY(jint, WB_GetCompilationActivityMode(JNIEnv* env, jobject o))
1631   return CompileBroker::get_compilation_activity_mode();
1632 WB_END
1633 
1634 WB_ENTRY(jobjectArray, WB_GetCodeBlob(JNIEnv* env, jobject o, jlong addr))
1635   if (addr == 0) {
1636     THROW_MSG_NULL(vmSymbols::java_lang_NullPointerException(),
1637       &quot;WB_GetCodeBlob: addr is null&quot;);
1638   }
1639   ThreadToNativeFromVM ttn(thread);
1640   CodeBlobStub stub((CodeBlob*) addr);
1641   return codeBlob2objectArray(thread, env, &amp;stub);
1642 WB_END
1643 
1644 WB_ENTRY(jlong, WB_GetMethodData(JNIEnv* env, jobject wv, jobject method))
1645   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1646   CHECK_JNI_EXCEPTION_(env, 0);
1647   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1648   return (jlong) mh-&gt;method_data();
1649 WB_END
1650 
1651 WB_ENTRY(jlong, WB_GetThreadStackSize(JNIEnv* env, jobject o))
1652   return (jlong) Thread::current()-&gt;stack_size();
1653 WB_END
1654 
1655 WB_ENTRY(jlong, WB_GetThreadRemainingStackSize(JNIEnv* env, jobject o))
1656   JavaThread* t = JavaThread::current();
1657   return (jlong) t-&gt;stack_available(os::current_stack_pointer()) - (jlong)JavaThread::stack_shadow_zone_size();
1658 WB_END
1659 
1660 
1661 int WhiteBox::array_bytes_to_length(size_t bytes) {
1662   return Array&lt;u1&gt;::bytes_to_length(bytes);
1663 }
1664 
1665 WB_ENTRY(jlong, WB_AllocateMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong size))
1666   if (size &lt; 0) {
1667     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1668         err_msg(&quot;WB_AllocateMetaspace: size is negative: &quot; JLONG_FORMAT, size));
1669   }
1670 
1671   oop class_loader_oop = JNIHandles::resolve(class_loader);
1672   ClassLoaderData* cld = class_loader_oop != NULL
1673       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1674       : ClassLoaderData::the_null_class_loader_data();
1675 
1676   void* metadata = MetadataFactory::new_array&lt;u1&gt;(cld, WhiteBox::array_bytes_to_length((size_t)size), thread);
1677 
1678   return (jlong)(uintptr_t)metadata;
1679 WB_END
1680 
1681 WB_ENTRY(void, WB_FreeMetaspace(JNIEnv* env, jobject wb, jobject class_loader, jlong addr, jlong size))
1682   oop class_loader_oop = JNIHandles::resolve(class_loader);
1683   ClassLoaderData* cld = class_loader_oop != NULL
1684       ? java_lang_ClassLoader::loader_data_acquire(class_loader_oop)
1685       : ClassLoaderData::the_null_class_loader_data();
1686 
1687   MetadataFactory::free_array(cld, (Array&lt;u1&gt;*)(uintptr_t)addr);
1688 WB_END
1689 
1690 WB_ENTRY(void, WB_DefineModule(JNIEnv* env, jobject o, jobject module, jboolean is_open,
1691                                 jstring version, jstring location, jobjectArray packages))
1692   ResourceMark rm(THREAD);
1693 
1694   objArrayOop packages_oop = objArrayOop(JNIHandles::resolve(packages));
1695   objArrayHandle packages_h(THREAD, packages_oop);
1696   int num_packages = (packages_h == NULL ? 0 : packages_h-&gt;length());
1697 
1698   char** pkgs = NULL;
1699   if (num_packages &gt; 0) {
1700     pkgs = NEW_RESOURCE_ARRAY_IN_THREAD(THREAD, char*, num_packages);
1701     for (int x = 0; x &lt; num_packages; x++) {
1702       oop pkg_str = packages_h-&gt;obj_at(x);
1703       if (pkg_str == NULL || !pkg_str-&gt;is_a(SystemDictionary::String_klass())) {
1704         THROW_MSG(vmSymbols::java_lang_IllegalArgumentException(),
1705                   err_msg(&quot;Bad package name&quot;));
1706       }
1707       pkgs[x] = java_lang_String::as_utf8_string(pkg_str);
1708     }
1709   }
1710   Modules::define_module(module, is_open, version, location, (const char* const*)pkgs, num_packages, CHECK);
1711 WB_END
1712 
1713 WB_ENTRY(void, WB_AddModuleExports(JNIEnv* env, jobject o, jobject from_module, jstring package, jobject to_module))
1714   ResourceMark rm(THREAD);
1715   char* package_name = NULL;
1716   if (package != NULL) {
1717       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1718   }
1719   Modules::add_module_exports_qualified(from_module, package_name, to_module, CHECK);
1720 WB_END
1721 
1722 WB_ENTRY(void, WB_AddModuleExportsToAllUnnamed(JNIEnv* env, jobject o, jclass module, jstring package))
1723   ResourceMark rm(THREAD);
1724   char* package_name = NULL;
1725   if (package != NULL) {
1726       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1727   }
1728   Modules::add_module_exports_to_all_unnamed(module, package_name, CHECK);
1729 WB_END
1730 
1731 WB_ENTRY(void, WB_AddModuleExportsToAll(JNIEnv* env, jobject o, jclass module, jstring package))
1732   ResourceMark rm(THREAD);
1733   char* package_name = NULL;
1734   if (package != NULL) {
1735       package_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(package));
1736   }
1737   Modules::add_module_exports(module, package_name, NULL, CHECK);
1738 WB_END
1739 
1740 WB_ENTRY(void, WB_AddReadsModule(JNIEnv* env, jobject o, jobject from_module, jobject source_module))
1741   Modules::add_reads_module(from_module, source_module, CHECK);
1742 WB_END
1743 
1744 WB_ENTRY(jlong, WB_IncMetaspaceCapacityUntilGC(JNIEnv* env, jobject wb, jlong inc))
1745   if (inc &lt; 0) {
1746     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1747         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc is negative: &quot; JLONG_FORMAT, inc));
1748   }
1749 
1750   jlong max_size_t = (jlong) ((size_t) -1);
1751   if (inc &gt; max_size_t) {
1752     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(),
1753         err_msg(&quot;WB_IncMetaspaceCapacityUntilGC: inc does not fit in size_t: &quot; JLONG_FORMAT, inc));
1754   }
1755 
1756   size_t new_cap_until_GC = 0;
1757   size_t aligned_inc = align_down((size_t) inc, Metaspace::commit_alignment());
1758   bool success = MetaspaceGC::inc_capacity_until_GC(aligned_inc, &amp;new_cap_until_GC);
1759   if (!success) {
1760     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(),
1761                 &quot;WB_IncMetaspaceCapacityUntilGC: could not increase capacity until GC &quot;
1762                 &quot;due to contention with another thread&quot;);
1763   }
1764   return (jlong) new_cap_until_GC;
1765 WB_END
1766 
1767 WB_ENTRY(jlong, WB_MetaspaceCapacityUntilGC(JNIEnv* env, jobject wb))
1768   return (jlong) MetaspaceGC::capacity_until_GC();
1769 WB_END
1770 
1771 WB_ENTRY(jlong, WB_MetaspaceReserveAlignment(JNIEnv* env, jobject wb))
1772   return (jlong)Metaspace::reserve_alignment();
1773 WB_END
1774 
1775 WB_ENTRY(void, WB_AssertMatchingSafepointCalls(JNIEnv* env, jobject o, jboolean mutexSafepointValue, jboolean attemptedNoSafepointValue))
1776   Mutex::SafepointCheckRequired sfpt_check_required = mutexSafepointValue ?
1777                                            Mutex::_safepoint_check_always :
1778                                            Mutex::_safepoint_check_never;
1779   Mutex::SafepointCheckFlag sfpt_check_attempted = attemptedNoSafepointValue ?
1780                                            Mutex::_no_safepoint_check_flag :
1781                                            Mutex::_safepoint_check_flag;
1782   MutexLocker ml(new Mutex(Mutex::leaf, &quot;SFPT_Test_lock&quot;, true, sfpt_check_required),
1783                  sfpt_check_attempted);
1784 WB_END
1785 
1786 WB_ENTRY(void, WB_AssertSpecialLock(JNIEnv* env, jobject o, jboolean allowVMBlock, jboolean safepointCheck))
1787   // Create a special lock violating condition in value
1788   Mutex::SafepointCheckRequired sfpt_check_required = safepointCheck ?
1789                                            Mutex::_safepoint_check_always :
1790                                            Mutex::_safepoint_check_never;
1791   Mutex::SafepointCheckFlag safepoint_check = safepointCheck ?
1792                                            Monitor::_safepoint_check_flag :
1793                                            Monitor::_no_safepoint_check_flag;
1794 
1795   MutexLocker ml(new Mutex(Mutex::special, &quot;SpecialTest_lock&quot;, allowVMBlock, sfpt_check_required), safepoint_check);
1796   // If the lock above succeeds, try to safepoint to test the NSV implied with this special lock.
1797   ThreadBlockInVM tbivm(JavaThread::current());
1798 WB_END
1799 
1800 WB_ENTRY(jboolean, WB_IsMonitorInflated(JNIEnv* env, jobject wb, jobject obj))
1801   oop obj_oop = JNIHandles::resolve(obj);
1802   return (jboolean) obj_oop-&gt;mark().has_monitor();
1803 WB_END
1804 
1805 WB_ENTRY(void, WB_ForceSafepoint(JNIEnv* env, jobject wb))
1806   VM_ForceSafepoint force_safepoint_op;
1807   VMThread::execute(&amp;force_safepoint_op);
1808 WB_END
1809 
1810 WB_ENTRY(jlong, WB_GetConstantPool(JNIEnv* env, jobject wb, jclass klass))
1811   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1812   return (jlong) ik-&gt;constants();
1813 WB_END
1814 
1815 WB_ENTRY(jint, WB_GetConstantPoolCacheIndexTag(JNIEnv* env, jobject wb))
1816   return ConstantPool::CPCACHE_INDEX_TAG;
1817 WB_END
1818 
1819 WB_ENTRY(jint, WB_GetConstantPoolCacheLength(JNIEnv* env, jobject wb, jclass klass))
1820   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1821   ConstantPool* cp = ik-&gt;constants();
1822   if (cp-&gt;cache() == NULL) {
1823       return -1;
1824   }
1825   return cp-&gt;cache()-&gt;length();
1826 WB_END
1827 
1828 WB_ENTRY(jint, WB_ConstantPoolRemapInstructionOperandFromCache(JNIEnv* env, jobject wb, jclass klass, jint index))
1829   InstanceKlass* ik = InstanceKlass::cast(java_lang_Class::as_Klass(JNIHandles::resolve(klass)));
1830   ConstantPool* cp = ik-&gt;constants();
1831   if (cp-&gt;cache() == NULL) {
1832     THROW_MSG_0(vmSymbols::java_lang_IllegalStateException(), &quot;Constant pool does not have a cache&quot;);
1833   }
1834   jint cpci = index;
1835   jint cpciTag = ConstantPool::CPCACHE_INDEX_TAG;
1836   if (cpciTag &gt; cpci || cpci &gt;= cp-&gt;cache()-&gt;length() + cpciTag) {
1837     THROW_MSG_0(vmSymbols::java_lang_IllegalArgumentException(), &quot;Constant pool cache index is out of range&quot;);
1838   }
1839   jint cpi = cp-&gt;remap_instruction_operand_from_cache(cpci);
1840   return cpi;
1841 WB_END
1842 
1843 WB_ENTRY(jint, WB_ConstantPoolEncodeIndyIndex(JNIEnv* env, jobject wb, jint index))
1844   return ConstantPool::encode_invokedynamic_index(index);
1845 WB_END
1846 
1847 WB_ENTRY(void, WB_ClearInlineCaches(JNIEnv* env, jobject wb, jboolean preserve_static_stubs))
1848   VM_ClearICs clear_ics(preserve_static_stubs == JNI_TRUE);
1849   VMThread::execute(&amp;clear_ics);
1850 WB_END
1851 
1852 template &lt;typename T&gt;
1853 static bool GetMethodOption(JavaThread* thread, JNIEnv* env, jobject method, jstring name, T* value) {
1854   assert(value != NULL, &quot;sanity&quot;);
1855   if (method == NULL || name == NULL) {
1856     return false;
1857   }
1858   jmethodID jmid = reflected_method_to_jmid(thread, env, method);
1859   CHECK_JNI_EXCEPTION_(env, false);
1860   methodHandle mh(thread, Method::checked_resolve_jmethod_id(jmid));
1861   // can&#39;t be in VM when we call JNI
1862   ThreadToNativeFromVM ttnfv(thread);
1863   const char* flag_name = env-&gt;GetStringUTFChars(name, NULL);
1864   CHECK_JNI_EXCEPTION_(env, false);
1865   bool result =  CompilerOracle::has_option_value(mh, flag_name, *value);
1866   env-&gt;ReleaseStringUTFChars(name, flag_name);
1867   return result;
1868 }
1869 
1870 WB_ENTRY(jobject, WB_GetMethodBooleaneOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1871   bool result;
1872   if (GetMethodOption&lt;bool&gt; (thread, env, method, name, &amp;result)) {
1873     // can&#39;t be in VM when we call JNI
1874     ThreadToNativeFromVM ttnfv(thread);
1875     return booleanBox(thread, env, result);
1876   }
1877   return NULL;
1878 WB_END
1879 
1880 WB_ENTRY(jobject, WB_GetMethodIntxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1881   intx result;
1882   if (GetMethodOption &lt;intx&gt; (thread, env, method, name, &amp;result)) {
1883     // can&#39;t be in VM when we call JNI
1884     ThreadToNativeFromVM ttnfv(thread);
1885     return longBox(thread, env, result);
1886   }
1887   return NULL;
1888 WB_END
1889 
1890 WB_ENTRY(jobject, WB_GetMethodUintxOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1891   uintx result;
1892   if (GetMethodOption &lt;uintx&gt; (thread, env, method, name, &amp;result)) {
1893     // can&#39;t be in VM when we call JNI
1894     ThreadToNativeFromVM ttnfv(thread);
1895     return longBox(thread, env, result);
1896   }
1897   return NULL;
1898 WB_END
1899 
1900 WB_ENTRY(jobject, WB_GetMethodDoubleOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1901   double result;
1902   if (GetMethodOption &lt;double&gt; (thread, env, method, name, &amp;result)) {
1903     // can&#39;t be in VM when we call JNI
1904     ThreadToNativeFromVM ttnfv(thread);
1905     return doubleBox(thread, env, result);
1906   }
1907   return NULL;
1908 WB_END
1909 
1910 WB_ENTRY(jobject, WB_GetMethodStringOption(JNIEnv* env, jobject wb, jobject method, jstring name))
1911   ccstr ccstrResult;
1912   if (GetMethodOption &lt;ccstr&gt; (thread, env, method, name, &amp;ccstrResult)) {
1913     // can&#39;t be in VM when we call JNI
1914     ThreadToNativeFromVM ttnfv(thread);
1915     jstring result = env-&gt;NewStringUTF(ccstrResult);
1916     CHECK_JNI_EXCEPTION_(env, NULL);
1917     return result;
1918   }
1919   return NULL;
1920 WB_END
1921 
1922 WB_ENTRY(jobject, WB_GetDefaultArchivePath(JNIEnv* env, jobject wb))
1923   const char* p = Arguments::get_default_shared_archive_path();
1924   ThreadToNativeFromVM ttn(thread);
1925   jstring path_string = env-&gt;NewStringUTF(p);
1926 
1927   CHECK_JNI_EXCEPTION_(env, NULL);
1928 
1929   return path_string;
1930 WB_END
1931 
1932 WB_ENTRY(jboolean, WB_IsSharingEnabled(JNIEnv* env, jobject wb))
1933   return UseSharedSpaces;
1934 WB_END
1935 
1936 WB_ENTRY(jboolean, WB_CDSMemoryMappingFailed(JNIEnv* env, jobject wb))
1937   return FileMapInfo::memory_mapping_failed();
1938 WB_END
1939 
1940 WB_ENTRY(jboolean, WB_IsShared(JNIEnv* env, jobject wb, jobject obj))
1941   oop obj_oop = JNIHandles::resolve(obj);
1942   return HeapShared::is_archived_object(obj_oop);
1943 WB_END
1944 
1945 WB_ENTRY(jboolean, WB_IsSharedClass(JNIEnv* env, jobject wb, jclass clazz))
1946   return (jboolean)MetaspaceShared::is_in_shared_metaspace(java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz)));
1947 WB_END
1948 
1949 WB_ENTRY(jboolean, WB_AreSharedStringsIgnored(JNIEnv* env))
1950   return !HeapShared::closed_archive_heap_region_mapped();
1951 WB_END
1952 
1953 WB_ENTRY(jobject, WB_GetResolvedReferences(JNIEnv* env, jobject wb, jclass clazz))
1954   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1955   if (k-&gt;is_instance_klass()) {
1956     InstanceKlass *ik = InstanceKlass::cast(k);
1957     ConstantPool *cp = ik-&gt;constants();
1958     objArrayOop refs =  cp-&gt;resolved_references();
1959     return (jobject)JNIHandles::make_local(env, refs);
1960   } else {
1961     return NULL;
1962   }
1963 WB_END
1964 
1965 WB_ENTRY(void, WB_LinkClass(JNIEnv* env, jobject wb, jclass clazz))
1966   Klass *k = java_lang_Class::as_Klass(JNIHandles::resolve_non_null(clazz));
1967   if (!k-&gt;is_instance_klass()) {
1968     return;
1969   }
1970   InstanceKlass *ik = InstanceKlass::cast(k);
1971   ik-&gt;link_class(THREAD); // may throw verification error
1972 WB_END
1973 
1974 WB_ENTRY(jboolean, WB_AreOpenArchiveHeapObjectsMapped(JNIEnv* env))
1975   return HeapShared::open_archive_heap_region_mapped();
1976 WB_END
1977 
1978 WB_ENTRY(jboolean, WB_IsCDSIncludedInVmBuild(JNIEnv* env))
1979 #if INCLUDE_CDS
<a name="8" id="anc8"></a><span class="line-removed">1980 # ifdef _LP64</span>
<span class="line-removed">1981     if (!UseCompressedOops || !UseCompressedClassPointers) {</span>
<span class="line-removed">1982       // On 64-bit VMs, CDS is supported only with compressed oops/pointers</span>
<span class="line-removed">1983       return false;</span>
<span class="line-removed">1984     }</span>
<span class="line-removed">1985 # endif // _LP64</span>
1986   return true;
1987 #else
1988   return false;
1989 #endif // INCLUDE_CDS
1990 WB_END
1991 
1992 WB_ENTRY(jboolean, WB_isC2OrJVMCIIncludedInVmBuild(JNIEnv* env))
1993 #if COMPILER2_OR_JVMCI
1994   return true;
1995 #else
1996   return false;
1997 #endif
1998 WB_END
1999 
2000 WB_ENTRY(jboolean, WB_IsJavaHeapArchiveSupported(JNIEnv* env))
2001   return HeapShared::is_heap_object_archiving_allowed();
2002 WB_END
2003 
2004 
2005 WB_ENTRY(jboolean, WB_IsJFRIncludedInVmBuild(JNIEnv* env))
2006 #if INCLUDE_JFR
2007   return true;
2008 #else
2009   return false;
2010 #endif // INCLUDE_JFR
2011 WB_END
2012 
2013 #if INCLUDE_CDS
2014 
2015 WB_ENTRY(jint, WB_GetOffsetForName(JNIEnv* env, jobject o, jstring name))
2016   ResourceMark rm;
2017   char* c_name = java_lang_String::as_utf8_string(JNIHandles::resolve_non_null(name));
2018   int result = CDSOffsets::find_offset(c_name);
2019   return (jint)result;
2020 WB_END
2021 
2022 #endif // INCLUDE_CDS
2023 
2024 WB_ENTRY(jint, WB_HandshakeWalkStack(JNIEnv* env, jobject wb, jobject thread_handle, jboolean all_threads))
2025   class TraceSelfClosure : public HandshakeClosure {
2026     jint _num_threads_completed;
2027 
2028     void do_thread(Thread* th) {
2029       assert(th-&gt;is_Java_thread(), &quot;sanity&quot;);
2030       JavaThread* jt = (JavaThread*)th;
2031       ResourceMark rm;
2032 
2033       jt-&gt;print_on(tty);
2034       jt-&gt;print_stack_on(tty);
2035       tty-&gt;cr();
2036       Atomic::inc(&amp;_num_threads_completed);
2037     }
2038 
2039   public:
2040     TraceSelfClosure() : HandshakeClosure(&quot;WB_TraceSelf&quot;), _num_threads_completed(0) {}
2041 
2042     jint num_threads_completed() const { return _num_threads_completed; }
2043   };
2044   TraceSelfClosure tsc;
2045 
2046   if (all_threads) {
2047     Handshake::execute(&amp;tsc);
2048   } else {
2049     oop thread_oop = JNIHandles::resolve(thread_handle);
2050     if (thread_oop != NULL) {
2051       JavaThread* target = java_lang_Thread::thread(thread_oop);
2052       Handshake::execute(&amp;tsc, target);
2053     }
2054   }
2055   return tsc.num_threads_completed();
2056 WB_END
2057 
2058 //Some convenience methods to deal with objects from java
2059 int WhiteBox::offset_for_field(const char* field_name, oop object,
2060     Symbol* signature_symbol) {
2061   assert(field_name != NULL &amp;&amp; strlen(field_name) &gt; 0, &quot;Field name not valid&quot;);
2062   Thread* THREAD = Thread::current();
2063 
2064   //Get the class of our object
2065   Klass* arg_klass = object-&gt;klass();
2066   //Turn it into an instance-klass
2067   InstanceKlass* ik = InstanceKlass::cast(arg_klass);
2068 
2069   //Create symbols to look for in the class
2070   TempNewSymbol name_symbol = SymbolTable::new_symbol(field_name);
2071 
2072   //To be filled in with an offset of the field we&#39;re looking for
2073   fieldDescriptor fd;
2074 
2075   Klass* res = ik-&gt;find_field(name_symbol, signature_symbol, &amp;fd);
2076   if (res == NULL) {
2077     tty-&gt;print_cr(&quot;Invalid layout of %s at %s&quot;, ik-&gt;external_name(),
2078         name_symbol-&gt;as_C_string());
2079     vm_exit_during_initialization(&quot;Invalid layout of preloaded class: use -Xlog:class+load=info to see the origin of the problem class&quot;);
2080   }
2081 
2082   //fetch the field at the offset we&#39;ve found
2083   int dest_offset = fd.offset();
2084 
2085   return dest_offset;
2086 }
2087 
2088 
2089 const char* WhiteBox::lookup_jstring(const char* field_name, oop object) {
2090   int offset = offset_for_field(field_name, object,
2091       vmSymbols::string_signature());
2092   oop string = object-&gt;obj_field(offset);
2093   if (string == NULL) {
2094     return NULL;
2095   }
2096   const char* ret = java_lang_String::as_utf8_string(string);
2097   return ret;
2098 }
2099 
2100 bool WhiteBox::lookup_bool(const char* field_name, oop object) {
2101   int offset =
2102       offset_for_field(field_name, object, vmSymbols::bool_signature());
2103   bool ret = (object-&gt;bool_field(offset) == JNI_TRUE);
2104   return ret;
2105 }
2106 
2107 void WhiteBox::register_methods(JNIEnv* env, jclass wbclass, JavaThread* thread, JNINativeMethod* method_array, int method_count) {
2108   ResourceMark rm;
2109   ThreadToNativeFromVM ttnfv(thread); // can&#39;t be in VM when we call JNI
2110 
2111   //  one by one registration natives for exception catching
2112   jclass no_such_method_error_klass = env-&gt;FindClass(vmSymbols::java_lang_NoSuchMethodError()-&gt;as_C_string());
2113   CHECK_JNI_EXCEPTION(env);
2114   for (int i = 0, n = method_count; i &lt; n; ++i) {
2115     // Skip dummy entries
2116     if (method_array[i].fnPtr == NULL) continue;
2117     if (env-&gt;RegisterNatives(wbclass, &amp;method_array[i], 1) != 0) {
2118       jthrowable throwable_obj = env-&gt;ExceptionOccurred();
2119       if (throwable_obj != NULL) {
2120         env-&gt;ExceptionClear();
2121         if (env-&gt;IsInstanceOf(throwable_obj, no_such_method_error_klass)) {
2122           // NoSuchMethodError is thrown when a method can&#39;t be found or a method is not native.
2123           // Ignoring the exception since it is not preventing use of other WhiteBox methods.
2124           tty-&gt;print_cr(&quot;Warning: &#39;NoSuchMethodError&#39; on register of sun.hotspot.WhiteBox::%s%s&quot;,
2125               method_array[i].name, method_array[i].signature);
2126         }
2127       } else {
2128         // Registration failed unexpectedly.
2129         tty-&gt;print_cr(&quot;Warning: unexpected error on register of sun.hotspot.WhiteBox::%s%s. All methods will be unregistered&quot;,
2130             method_array[i].name, method_array[i].signature);
2131         env-&gt;UnregisterNatives(wbclass);
2132         break;
2133       }
2134     }
2135   }
2136 }
2137 
2138 WB_ENTRY(jint, WB_AddCompilerDirective(JNIEnv* env, jobject o, jstring compDirect))
2139   // can&#39;t be in VM when we call JNI
2140   ThreadToNativeFromVM ttnfv(thread);
2141   const char* dir = env-&gt;GetStringUTFChars(compDirect, NULL);
2142   CHECK_JNI_EXCEPTION_(env, 0);
2143   int ret;
2144   {
2145     ThreadInVMfromNative ttvfn(thread); // back to VM
2146     ret = DirectivesParser::parse_string(dir, tty);
2147   }
2148   env-&gt;ReleaseStringUTFChars(compDirect, dir);
2149   // -1 for error parsing directive. Return 0 as number of directives added.
2150   if (ret == -1) {
2151     ret = 0;
2152   }
2153   return (jint) ret;
2154 WB_END
2155 
2156 WB_ENTRY(void, WB_RemoveCompilerDirective(JNIEnv* env, jobject o, jint count))
2157   DirectivesStack::pop(count);
2158 WB_END
2159 
2160 // Checks that the library libfile has the noexecstack bit set.
2161 WB_ENTRY(jboolean, WB_CheckLibSpecifiesNoexecstack(JNIEnv* env, jobject o, jstring libfile))
2162   jboolean ret = false;
2163 #ifdef LINUX
2164   // Can&#39;t be in VM when we call JNI.
2165   ThreadToNativeFromVM ttnfv(thread);
2166   const char* lf = env-&gt;GetStringUTFChars(libfile, NULL);
2167   CHECK_JNI_EXCEPTION_(env, 0);
2168   ret = (jboolean) ElfFile::specifies_noexecstack(lf);
2169   env-&gt;ReleaseStringUTFChars(libfile, lf);
2170 #endif
2171   return ret;
2172 WB_END
2173 
2174 WB_ENTRY(jboolean, WB_IsContainerized(JNIEnv* env, jobject o))
2175   LINUX_ONLY(return OSContainer::is_containerized();)
2176   return false;
2177 WB_END
2178 
<a name="9" id="anc9"></a>
























2179 WB_ENTRY(void, WB_PrintOsInfo(JNIEnv* env, jobject o))
2180   os::print_os_info(tty);
2181 WB_END
2182 
2183 // Elf decoder
2184 WB_ENTRY(void, WB_DisableElfSectionCache(JNIEnv* env))
2185 #if !defined(_WINDOWS) &amp;&amp; !defined(__APPLE__) &amp;&amp; !defined(_AIX)
2186   ElfFile::_do_not_cache_elf_section = true;
2187 #endif
2188 WB_END
2189 
2190 WB_ENTRY(jlong, WB_ResolvedMethodItemsCount(JNIEnv* env, jobject o))
2191   return (jlong) ResolvedMethodTable::items_count();
2192 WB_END
2193 
2194 WB_ENTRY(jint, WB_ProtectionDomainRemovedCount(JNIEnv* env, jobject o))
2195   return (jint) SystemDictionary::pd_cache_table()-&gt;removed_entries_count();
2196 WB_END
2197 
2198 WB_ENTRY(jint, WB_AotLibrariesCount(JNIEnv* env, jobject o))
2199   jint result = 0;
2200 #if INCLUDE_AOT
2201   result = (jint) AOTLoader::heaps_count();
2202 #endif
2203   return result;
2204 WB_END
2205 
2206 WB_ENTRY(jint, WB_GetKlassMetadataSize(JNIEnv* env, jobject wb, jclass mirror))
2207   Klass* k = java_lang_Class::as_Klass(JNIHandles::resolve(mirror));
2208   // Return size in bytes.
2209   return k-&gt;size() * wordSize;
2210 WB_END
2211 
2212 #define CC (char*)
2213 
2214 static JNINativeMethod methods[] = {
2215   {CC&quot;getObjectAddress0&quot;,                CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectAddress  },
2216   {CC&quot;getObjectSize0&quot;,                   CC&quot;(Ljava/lang/Object;)J&quot;, (void*)&amp;WB_GetObjectSize     },
2217   {CC&quot;isObjectInOldGen0&quot;,                CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_isObjectInOldGen  },
2218   {CC&quot;getHeapOopSize&quot;,                   CC&quot;()I&quot;,                   (void*)&amp;WB_GetHeapOopSize    },
2219   {CC&quot;getVMPageSize&quot;,                    CC&quot;()I&quot;,                   (void*)&amp;WB_GetVMPageSize     },
2220   {CC&quot;getVMAllocationGranularity&quot;,       CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMAllocationGranularity },
2221   {CC&quot;getVMLargePageSize&quot;,               CC&quot;()J&quot;,                   (void*)&amp;WB_GetVMLargePageSize},
2222   {CC&quot;getHeapSpaceAlignment&quot;,            CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapSpaceAlignment},
2223   {CC&quot;getHeapAlignment&quot;,                 CC&quot;()J&quot;,                   (void*)&amp;WB_GetHeapAlignment},
2224   {CC&quot;countAliveClasses0&quot;,               CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_CountAliveClasses },
2225   {CC&quot;getSymbolRefcount&quot;,                CC&quot;(Ljava/lang/String;)I&quot;, (void*)&amp;WB_GetSymbolRefcount },
2226   {CC&quot;parseCommandLine0&quot;,
2227       CC&quot;(Ljava/lang/String;C[Lsun/hotspot/parser/DiagnosticCommand;)[Ljava/lang/Object;&quot;,
2228       (void*) &amp;WB_ParseCommandLine
2229   },
2230   {CC&quot;addToBootstrapClassLoaderSearch0&quot;, CC&quot;(Ljava/lang/String;)V&quot;,
2231                                                       (void*)&amp;WB_AddToBootstrapClassLoaderSearch},
2232   {CC&quot;addToSystemClassLoaderSearch0&quot;,    CC&quot;(Ljava/lang/String;)V&quot;,
2233                                                       (void*)&amp;WB_AddToSystemClassLoaderSearch},
2234   {CC&quot;getCompressedOopsMaxHeapSize&quot;, CC&quot;()J&quot;,
2235       (void*)&amp;WB_GetCompressedOopsMaxHeapSize},
2236   {CC&quot;printHeapSizes&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_PrintHeapSizes    },
2237   {CC&quot;runMemoryUnitTests&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_RunMemoryUnitTests},
2238   {CC&quot;readFromNoaccessArea&quot;,CC&quot;()V&quot;,                  (void*)&amp;WB_ReadFromNoaccessArea},
2239   {CC&quot;stressVirtualSpaceResize&quot;,CC&quot;(JJJ)I&quot;,           (void*)&amp;WB_StressVirtualSpaceResize},
2240 #if INCLUDE_CDS
2241   {CC&quot;getOffsetForName0&quot;, CC&quot;(Ljava/lang/String;)I&quot;,  (void*)&amp;WB_GetOffsetForName},
2242 #endif
2243 #if INCLUDE_G1GC
2244   {CC&quot;g1InConcurrentMark&quot;, CC&quot;()Z&quot;,                   (void*)&amp;WB_G1InConcurrentMark},
2245   {CC&quot;g1IsHumongous0&quot;,      CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_G1IsHumongous     },
2246   {CC&quot;g1BelongsToHumongousRegion0&quot;, CC&quot;(J)Z&quot;,         (void*)&amp;WB_G1BelongsToHumongousRegion},
2247   {CC&quot;g1BelongsToFreeRegion0&quot;, CC&quot;(J)Z&quot;,              (void*)&amp;WB_G1BelongsToFreeRegion},
2248   {CC&quot;g1NumMaxRegions&quot;,    CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumMaxRegions  },
2249   {CC&quot;g1NumFreeRegions&quot;,   CC&quot;()J&quot;,                   (void*)&amp;WB_G1NumFreeRegions  },
2250   {CC&quot;g1RegionSize&quot;,       CC&quot;()I&quot;,                   (void*)&amp;WB_G1RegionSize      },
2251   {CC&quot;g1StartConcMarkCycle&quot;,       CC&quot;()Z&quot;,           (void*)&amp;WB_G1StartMarkCycle  },
2252   {CC&quot;g1AuxiliaryMemoryUsage&quot;, CC&quot;()Ljava/lang/management/MemoryUsage;&quot;,
2253                                                       (void*)&amp;WB_G1AuxiliaryMemoryUsage  },
2254   {CC&quot;g1ActiveMemoryNodeCount&quot;, CC&quot;()I&quot;,              (void*)&amp;WB_G1ActiveMemoryNodeCount },
2255   {CC&quot;g1MemoryNodeIds&quot;,    CC&quot;()[I&quot;,                  (void*)&amp;WB_G1MemoryNodeIds },
2256   {CC&quot;g1GetMixedGCInfo&quot;,   CC&quot;(I)[J&quot;,                 (void*)&amp;WB_G1GetMixedGCInfo },
2257 #endif // INCLUDE_G1GC
2258 #if INCLUDE_G1GC || INCLUDE_PARALLELGC
2259   {CC&quot;dramReservedStart&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedStart },
2260   {CC&quot;dramReservedEnd&quot;,     CC&quot;()J&quot;,                  (void*)&amp;WB_DramReservedEnd },
2261   {CC&quot;nvdimmReservedStart&quot;, CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedStart },
2262   {CC&quot;nvdimmReservedEnd&quot;,   CC&quot;()J&quot;,                  (void*)&amp;WB_NvdimmReservedEnd },
2263 #endif // INCLUDE_G1GC || INCLUDE_PARALLELGC
2264 #if INCLUDE_PARALLELGC
2265   {CC&quot;psVirtualSpaceAlignment&quot;,CC&quot;()J&quot;,               (void*)&amp;WB_PSVirtualSpaceAlignment},
2266   {CC&quot;psHeapGenerationAlignment&quot;,CC&quot;()J&quot;,             (void*)&amp;WB_PSHeapGenerationAlignment},
2267 #endif
2268 #if INCLUDE_NMT
2269   {CC&quot;NMTMalloc&quot;,           CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTMalloc          },
2270   {CC&quot;NMTMallocWithPseudoStack&quot;, CC&quot;(JI)J&quot;,           (void*)&amp;WB_NMTMallocWithPseudoStack},
2271   {CC&quot;NMTMallocWithPseudoStackAndType&quot;, CC&quot;(JII)J&quot;,   (void*)&amp;WB_NMTMallocWithPseudoStackAndType},
2272   {CC&quot;NMTFree&quot;,             CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFree            },
2273   {CC&quot;NMTReserveMemory&quot;,    CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTReserveMemory   },
2274   {CC&quot;NMTAttemptReserveMemoryAt&quot;,    CC&quot;(JJ)J&quot;,       (void*)&amp;WB_NMTAttemptReserveMemoryAt },
2275   {CC&quot;NMTCommitMemory&quot;,     CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTCommitMemory    },
2276   {CC&quot;NMTUncommitMemory&quot;,   CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTUncommitMemory  },
2277   {CC&quot;NMTReleaseMemory&quot;,    CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTReleaseMemory   },
2278   {CC&quot;NMTChangeTrackingLevel&quot;, CC&quot;()Z&quot;,               (void*)&amp;WB_NMTChangeTrackingLevel},
2279   {CC&quot;NMTGetHashSize&quot;,      CC&quot;()I&quot;,                  (void*)&amp;WB_NMTGetHashSize     },
2280   {CC&quot;NMTNewArena&quot;,         CC&quot;(J)J&quot;,                 (void*)&amp;WB_NMTNewArena        },
2281   {CC&quot;NMTFreeArena&quot;,        CC&quot;(J)V&quot;,                 (void*)&amp;WB_NMTFreeArena       },
2282   {CC&quot;NMTArenaMalloc&quot;,      CC&quot;(JJ)V&quot;,                (void*)&amp;WB_NMTArenaMalloc     },
2283 #endif // INCLUDE_NMT
2284   {CC&quot;deoptimizeFrames&quot;,   CC&quot;(Z)I&quot;,                  (void*)&amp;WB_DeoptimizeFrames  },
2285   {CC&quot;deoptimizeAll&quot;,      CC&quot;()V&quot;,                   (void*)&amp;WB_DeoptimizeAll     },
2286   {CC&quot;deoptimizeMethod0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,
2287                                                       (void*)&amp;WB_DeoptimizeMethod  },
2288   {CC&quot;isMethodCompiled0&quot;,   CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,
2289                                                       (void*)&amp;WB_IsMethodCompiled  },
2290   {CC&quot;isMethodCompilable0&quot;, CC&quot;(Ljava/lang/reflect/Executable;IZ)Z&quot;,
2291                                                       (void*)&amp;WB_IsMethodCompilable},
2292   {CC&quot;isMethodQueuedForCompilation0&quot;,
2293       CC&quot;(Ljava/lang/reflect/Executable;)Z&quot;,          (void*)&amp;WB_IsMethodQueuedForCompilation},
2294   {CC&quot;isIntrinsicAvailable0&quot;,
2295       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/reflect/Executable;I)Z&quot;,
2296                                                       (void*)&amp;WB_IsIntrinsicAvailable},
2297   {CC&quot;makeMethodNotCompilable0&quot;,
2298       CC&quot;(Ljava/lang/reflect/Executable;IZ)V&quot;,        (void*)&amp;WB_MakeMethodNotCompilable},
2299   {CC&quot;testSetDontInlineMethod0&quot;,
2300       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetDontInlineMethod},
2301   {CC&quot;getMethodCompilationLevel0&quot;,
2302       CC&quot;(Ljava/lang/reflect/Executable;Z)I&quot;,         (void*)&amp;WB_GetMethodCompilationLevel},
2303   {CC&quot;getMethodEntryBci0&quot;,
2304       CC&quot;(Ljava/lang/reflect/Executable;)I&quot;,          (void*)&amp;WB_GetMethodEntryBci},
2305   {CC&quot;getCompileQueueSize&quot;,
2306       CC&quot;(I)I&quot;,                                       (void*)&amp;WB_GetCompileQueueSize},
2307   {CC&quot;testSetForceInlineMethod0&quot;,
2308       CC&quot;(Ljava/lang/reflect/Executable;Z)Z&quot;,         (void*)&amp;WB_TestSetForceInlineMethod},
2309   {CC&quot;enqueueMethodForCompilation0&quot;,
2310       CC&quot;(Ljava/lang/reflect/Executable;II)Z&quot;,        (void*)&amp;WB_EnqueueMethodForCompilation},
2311   {CC&quot;enqueueInitializerForCompilation0&quot;,
2312       CC&quot;(Ljava/lang/Class;I)Z&quot;,                      (void*)&amp;WB_EnqueueInitializerForCompilation},
2313   {CC&quot;markMethodProfiled&quot;,
2314       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_MarkMethodProfiled},
2315   {CC&quot;clearMethodState0&quot;,
2316       CC&quot;(Ljava/lang/reflect/Executable;)V&quot;,          (void*)&amp;WB_ClearMethodState},
2317   {CC&quot;lockCompilation&quot;,    CC&quot;()V&quot;,                   (void*)&amp;WB_LockCompilation},
2318   {CC&quot;unlockCompilation&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_UnlockCompilation},
2319   {CC&quot;matchesMethod&quot;,
2320       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2321                                                       (void*)&amp;WB_MatchesMethod},
2322   {CC&quot;matchesInline&quot;,
2323       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)I&quot;,
2324                                                       (void*)&amp;WB_MatchesInline},
2325   {CC&quot;shouldPrintAssembly&quot;,
2326         CC&quot;(Ljava/lang/reflect/Executable;I)Z&quot;,
2327                                                         (void*)&amp;WB_ShouldPrintAssembly},
2328 
2329   {CC&quot;isConstantVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsConstantVMFlag},
2330   {CC&quot;isLockedVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsLockedVMFlag},
2331   {CC&quot;setBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;Z)V&quot;,(void*)&amp;WB_SetBooleanVMFlag},
2332   {CC&quot;setIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntVMFlag},
2333   {CC&quot;setUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintVMFlag},
2334   {CC&quot;setIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetIntxVMFlag},
2335   {CC&quot;setUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUintxVMFlag},
2336   {CC&quot;setUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetUint64VMFlag},
2337   {CC&quot;setSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;J)V&quot;,(void*)&amp;WB_SetSizeTVMFlag},
2338   {CC&quot;setDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;D)V&quot;,(void*)&amp;WB_SetDoubleVMFlag},
2339   {CC&quot;setStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;Ljava/lang/String;)V&quot;,
2340                                                       (void*)&amp;WB_SetStringVMFlag},
2341   {CC&quot;getBooleanVMFlag&quot;,   CC&quot;(Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2342                                                       (void*)&amp;WB_GetBooleanVMFlag},
2343   {CC&quot;getIntVMFlag&quot;,       CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2344                                                       (void*)&amp;WB_GetIntVMFlag},
2345   {CC&quot;getUintVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2346                                                       (void*)&amp;WB_GetUintVMFlag},
2347   {CC&quot;getIntxVMFlag&quot;,      CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2348                                                       (void*)&amp;WB_GetIntxVMFlag},
2349   {CC&quot;getUintxVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2350                                                       (void*)&amp;WB_GetUintxVMFlag},
2351   {CC&quot;getUint64VMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2352                                                       (void*)&amp;WB_GetUint64VMFlag},
2353   {CC&quot;getSizeTVMFlag&quot;,     CC&quot;(Ljava/lang/String;)Ljava/lang/Long;&quot;,
2354                                                       (void*)&amp;WB_GetSizeTVMFlag},
2355   {CC&quot;getDoubleVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/Double;&quot;,
2356                                                       (void*)&amp;WB_GetDoubleVMFlag},
2357   {CC&quot;getStringVMFlag&quot;,    CC&quot;(Ljava/lang/String;)Ljava/lang/String;&quot;,
2358                                                       (void*)&amp;WB_GetStringVMFlag},
2359   {CC&quot;isInStringTable&quot;,    CC&quot;(Ljava/lang/String;)Z&quot;, (void*)&amp;WB_IsInStringTable  },
2360   {CC&quot;fullGC&quot;,   CC&quot;()V&quot;,                             (void*)&amp;WB_FullGC },
2361   {CC&quot;youngGC&quot;,  CC&quot;()V&quot;,                             (void*)&amp;WB_YoungGC },
2362   {CC&quot;readReservedMemory&quot;, CC&quot;()V&quot;,                   (void*)&amp;WB_ReadReservedMemory },
2363   {CC&quot;allocateMetaspace&quot;,
2364      CC&quot;(Ljava/lang/ClassLoader;J)J&quot;,                 (void*)&amp;WB_AllocateMetaspace },
2365   {CC&quot;freeMetaspace&quot;,
2366      CC&quot;(Ljava/lang/ClassLoader;JJ)V&quot;,                (void*)&amp;WB_FreeMetaspace },
2367   {CC&quot;incMetaspaceCapacityUntilGC&quot;, CC&quot;(J)J&quot;,         (void*)&amp;WB_IncMetaspaceCapacityUntilGC },
2368   {CC&quot;metaspaceCapacityUntilGC&quot;, CC&quot;()J&quot;,             (void*)&amp;WB_MetaspaceCapacityUntilGC },
2369   {CC&quot;metaspaceReserveAlignment&quot;, CC&quot;()J&quot;,            (void*)&amp;WB_MetaspaceReserveAlignment },
2370   {CC&quot;getCPUFeatures&quot;,     CC&quot;()Ljava/lang/String;&quot;,  (void*)&amp;WB_GetCPUFeatures     },
2371   {CC&quot;getNMethod0&quot;,         CC&quot;(Ljava/lang/reflect/Executable;Z)[Ljava/lang/Object;&quot;,
2372                                                       (void*)&amp;WB_GetNMethod         },
2373   {CC&quot;forceNMethodSweep&quot;,  CC&quot;()V&quot;,                   (void*)&amp;WB_ForceNMethodSweep  },
2374   {CC&quot;allocateCodeBlob&quot;,   CC&quot;(II)J&quot;,                 (void*)&amp;WB_AllocateCodeBlob   },
2375   {CC&quot;freeCodeBlob&quot;,       CC&quot;(J)V&quot;,                  (void*)&amp;WB_FreeCodeBlob       },
2376   {CC&quot;getCodeHeapEntries&quot;, CC&quot;(I)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeHeapEntries },
2377   {CC&quot;getCompilationActivityMode&quot;,
2378                            CC&quot;()I&quot;,                   (void*)&amp;WB_GetCompilationActivityMode},
2379   {CC&quot;getMethodData0&quot;,     CC&quot;(Ljava/lang/reflect/Executable;)J&quot;,
2380                                                       (void*)&amp;WB_GetMethodData      },
2381   {CC&quot;getCodeBlob&quot;,        CC&quot;(J)[Ljava/lang/Object;&quot;,(void*)&amp;WB_GetCodeBlob        },
2382   {CC&quot;getThreadStackSize&quot;, CC&quot;()J&quot;,                   (void*)&amp;WB_GetThreadStackSize },
2383   {CC&quot;getThreadRemainingStackSize&quot;, CC&quot;()J&quot;,          (void*)&amp;WB_GetThreadRemainingStackSize },
2384   {CC&quot;DefineModule&quot;,       CC&quot;(Ljava/lang/Object;ZLjava/lang/String;Ljava/lang/String;[Ljava/lang/Object;)V&quot;,
2385                                                       (void*)&amp;WB_DefineModule },
2386   {CC&quot;AddModuleExports&quot;,   CC&quot;(Ljava/lang/Object;Ljava/lang/String;Ljava/lang/Object;)V&quot;,
2387                                                       (void*)&amp;WB_AddModuleExports },
2388   {CC&quot;AddReadsModule&quot;,     CC&quot;(Ljava/lang/Object;Ljava/lang/Object;)V&quot;,
2389                                                       (void*)&amp;WB_AddReadsModule },
2390   {CC&quot;AddModuleExportsToAllUnnamed&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2391                                                       (void*)&amp;WB_AddModuleExportsToAllUnnamed },
2392   {CC&quot;AddModuleExportsToAll&quot;, CC&quot;(Ljava/lang/Object;Ljava/lang/String;)V&quot;,
2393                                                       (void*)&amp;WB_AddModuleExportsToAll },
2394   {CC&quot;assertMatchingSafepointCalls&quot;, CC&quot;(ZZ)V&quot;,       (void*)&amp;WB_AssertMatchingSafepointCalls },
2395   {CC&quot;assertSpecialLock&quot;,  CC&quot;(ZZ)V&quot;,                 (void*)&amp;WB_AssertSpecialLock },
2396   {CC&quot;isMonitorInflated0&quot;, CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsMonitorInflated  },
2397   {CC&quot;forceSafepoint&quot;,     CC&quot;()V&quot;,                   (void*)&amp;WB_ForceSafepoint     },
2398   {CC&quot;getConstantPool0&quot;,   CC&quot;(Ljava/lang/Class;)J&quot;,  (void*)&amp;WB_GetConstantPool    },
2399   {CC&quot;getConstantPoolCacheIndexTag0&quot;, CC&quot;()I&quot;,  (void*)&amp;WB_GetConstantPoolCacheIndexTag},
2400   {CC&quot;getConstantPoolCacheLength0&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,  (void*)&amp;WB_GetConstantPoolCacheLength},
2401   {CC&quot;remapInstructionOperandFromCPCache0&quot;,
2402       CC&quot;(Ljava/lang/Class;I)I&quot;,                      (void*)&amp;WB_ConstantPoolRemapInstructionOperandFromCache},
2403   {CC&quot;encodeConstantPoolIndyIndex0&quot;,
2404       CC&quot;(I)I&quot;,                      (void*)&amp;WB_ConstantPoolEncodeIndyIndex},
2405   {CC&quot;getMethodBooleanOption&quot;,
2406       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Boolean;&quot;,
2407                                                       (void*)&amp;WB_GetMethodBooleaneOption},
2408   {CC&quot;getMethodIntxOption&quot;,
2409       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2410                                                       (void*)&amp;WB_GetMethodIntxOption},
2411   {CC&quot;getMethodUintxOption&quot;,
2412       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Long;&quot;,
2413                                                       (void*)&amp;WB_GetMethodUintxOption},
2414   {CC&quot;getMethodDoubleOption&quot;,
2415       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/Double;&quot;,
2416                                                       (void*)&amp;WB_GetMethodDoubleOption},
2417   {CC&quot;getMethodStringOption&quot;,
2418       CC&quot;(Ljava/lang/reflect/Executable;Ljava/lang/String;)Ljava/lang/String;&quot;,
2419                                                       (void*)&amp;WB_GetMethodStringOption},
2420   {CC&quot;getDefaultArchivePath&quot;,             CC&quot;()Ljava/lang/String;&quot;,
2421                                                       (void*)&amp;WB_GetDefaultArchivePath},
2422   {CC&quot;isSharingEnabled&quot;,   CC&quot;()Z&quot;,                   (void*)&amp;WB_IsSharingEnabled},
2423   {CC&quot;isShared&quot;,           CC&quot;(Ljava/lang/Object;)Z&quot;, (void*)&amp;WB_IsShared },
2424   {CC&quot;isSharedClass&quot;,      CC&quot;(Ljava/lang/Class;)Z&quot;,  (void*)&amp;WB_IsSharedClass },
2425   {CC&quot;areSharedStringsIgnored&quot;,           CC&quot;()Z&quot;,    (void*)&amp;WB_AreSharedStringsIgnored },
2426   {CC&quot;getResolvedReferences&quot;, CC&quot;(Ljava/lang/Class;)Ljava/lang/Object;&quot;, (void*)&amp;WB_GetResolvedReferences},
2427   {CC&quot;linkClass&quot;,          CC&quot;(Ljava/lang/Class;)V&quot;,  (void*)&amp;WB_LinkClass},
2428   {CC&quot;areOpenArchiveHeapObjectsMapped&quot;,   CC&quot;()Z&quot;,    (void*)&amp;WB_AreOpenArchiveHeapObjectsMapped},
2429   {CC&quot;isCDSIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsCDSIncludedInVmBuild },
2430   {CC&quot;isJFRIncludedInVmBuild&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_IsJFRIncludedInVmBuild },
2431   {CC&quot;isC2OrJVMCIIncludedInVmBuild&quot;,      CC&quot;()Z&quot;,    (void*)&amp;WB_isC2OrJVMCIIncludedInVmBuild },
2432   {CC&quot;isJavaHeapArchiveSupported&quot;,        CC&quot;()Z&quot;,    (void*)&amp;WB_IsJavaHeapArchiveSupported },
2433   {CC&quot;cdsMemoryMappingFailed&quot;,            CC&quot;()Z&quot;,    (void*)&amp;WB_CDSMemoryMappingFailed },
2434 
2435   {CC&quot;clearInlineCaches0&quot;,  CC&quot;(Z)V&quot;,                 (void*)&amp;WB_ClearInlineCaches },
2436   {CC&quot;handshakeWalkStack&quot;, CC&quot;(Ljava/lang/Thread;Z)I&quot;, (void*)&amp;WB_HandshakeWalkStack },
2437   {CC&quot;addCompilerDirective&quot;,    CC&quot;(Ljava/lang/String;)I&quot;,
2438                                                       (void*)&amp;WB_AddCompilerDirective },
2439   {CC&quot;removeCompilerDirective&quot;,   CC&quot;(I)V&quot;,           (void*)&amp;WB_RemoveCompilerDirective },
2440   {CC&quot;isGCSupported&quot;,             CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSupported},
2441   {CC&quot;isGCSelected&quot;,              CC&quot;(I)Z&quot;,           (void*)&amp;WB_IsGCSelected},
2442   {CC&quot;isGCSelectedErgonomically&quot;, CC&quot;()Z&quot;,            (void*)&amp;WB_IsGCSelectedErgonomically},
<a name="10" id="anc10"></a><span class="line-modified">2443   {CC&quot;supportsConcurrentGCPhaseControl&quot;, CC&quot;()Z&quot;,     (void*)&amp;WB_SupportsConcurrentGCPhaseControl},</span>
<span class="line-modified">2444   {CC&quot;requestConcurrentGCPhase0&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,</span>
<span class="line-modified">2445                                                       (void*)&amp;WB_RequestConcurrentGCPhase},</span>



2446   {CC&quot;checkLibSpecifiesNoexecstack&quot;, CC&quot;(Ljava/lang/String;)Z&quot;,
2447                                                       (void*)&amp;WB_CheckLibSpecifiesNoexecstack},
2448   {CC&quot;isContainerized&quot;,           CC&quot;()Z&quot;,            (void*)&amp;WB_IsContainerized },
<a name="11" id="anc11"></a>


2449   {CC&quot;printOsInfo&quot;,               CC&quot;()V&quot;,            (void*)&amp;WB_PrintOsInfo },
2450   {CC&quot;disableElfSectionCache&quot;,    CC&quot;()V&quot;,            (void*)&amp;WB_DisableElfSectionCache },
2451   {CC&quot;resolvedMethodItemsCount&quot;,  CC&quot;()J&quot;,            (void*)&amp;WB_ResolvedMethodItemsCount },
2452   {CC&quot;protectionDomainRemovedCount&quot;,   CC&quot;()I&quot;,       (void*)&amp;WB_ProtectionDomainRemovedCount },
2453   {CC&quot;aotLibrariesCount&quot;, CC&quot;()I&quot;,                    (void*)&amp;WB_AotLibrariesCount },
2454   {CC&quot;getKlassMetadataSize&quot;, CC&quot;(Ljava/lang/Class;)I&quot;,(void*)&amp;WB_GetKlassMetadataSize},
2455 };
2456 
2457 
2458 #undef CC
2459 
2460 JVM_ENTRY(void, JVM_RegisterWhiteBoxMethods(JNIEnv* env, jclass wbclass))
2461   {
2462     if (WhiteBoxAPI) {
2463       // Make sure that wbclass is loaded by the null classloader
2464       InstanceKlass* ik = InstanceKlass::cast(JNIHandles::resolve(wbclass)-&gt;klass());
2465       Handle loader(THREAD, ik-&gt;class_loader());
2466       if (loader.is_null()) {
2467         WhiteBox::register_methods(env, wbclass, thread, methods, sizeof(methods) / sizeof(methods[0]));
2468         WhiteBox::set_used();
2469       }
2470     }
2471   }
2472 JVM_END
<a name="12" id="anc12"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="12" type="hidden" />
</body>
</html>
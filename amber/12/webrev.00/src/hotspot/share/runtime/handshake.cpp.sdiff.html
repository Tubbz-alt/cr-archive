<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/runtime/handshake.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="globals_extension.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handshake.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/runtime/handshake.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2019, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;logging/logStream.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;runtime/atomic.hpp&quot;
 30 #include &quot;runtime/handshake.hpp&quot;
 31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 32 #include &quot;runtime/osThread.hpp&quot;
 33 #include &quot;runtime/semaphore.inline.hpp&quot;
 34 #include &quot;runtime/task.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;runtime/vmThread.hpp&quot;
 37 #include &quot;utilities/formatBuffer.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 
<span class="line-removed"> 40 class HandshakeOperation: public StackObj {</span>
<span class="line-removed"> 41 public:</span>
<span class="line-removed"> 42   virtual void do_handshake(JavaThread* thread) = 0;</span>
<span class="line-removed"> 43 };</span>
 44 
<span class="line-modified"> 45 class HandshakeThreadsOperation: public HandshakeOperation {</span>
<span class="line-removed"> 46   static Semaphore _done;</span>
 47   HandshakeClosure* _handshake_cl;

 48   bool _executed;

 49 public:
<span class="line-modified"> 50   HandshakeThreadsOperation(HandshakeClosure* cl) : _handshake_cl(cl), _executed(false) {}</span>





 51   void do_handshake(JavaThread* thread);
<span class="line-modified"> 52   bool thread_has_completed() { return _done.trywait(); }</span>





 53   bool executed() const { return _executed; }
 54   const char* name() { return _handshake_cl-&gt;name(); }
 55 
<span class="line-modified"> 56 #ifdef ASSERT</span>
<span class="line-removed"> 57   void check_state() {</span>
<span class="line-removed"> 58     assert(!_done.trywait(), &quot;Must be zero&quot;);</span>
<span class="line-removed"> 59   }</span>
<span class="line-removed"> 60 #endif</span>
 61 };
 62 
<span class="line-removed"> 63 Semaphore HandshakeThreadsOperation::_done(0);</span>
<span class="line-removed"> 64 </span>
 65 class VM_Handshake: public VM_Operation {
 66   const jlong _handshake_timeout;
 67  public:
 68   bool evaluate_at_safepoint() const { return false; }
 69 
 70  protected:
<span class="line-modified"> 71   HandshakeThreadsOperation* const _op;</span>
 72 
<span class="line-modified"> 73   VM_Handshake(HandshakeThreadsOperation* op) :</span>
 74       _handshake_timeout(TimeHelper::millis_to_counter(HandshakeTimeout)), _op(op) {}
 75 
<span class="line-removed"> 76   void set_handshake(JavaThread* target) {</span>
<span class="line-removed"> 77     target-&gt;set_handshake_operation(_op);</span>
<span class="line-removed"> 78   }</span>
<span class="line-removed"> 79 </span>
<span class="line-removed"> 80   // This method returns true for threads completed their operation</span>
<span class="line-removed"> 81   // and true for threads canceled their operation.</span>
<span class="line-removed"> 82   // A cancellation can happen if the thread is exiting.</span>
<span class="line-removed"> 83   bool poll_for_completed_thread() { return _op-&gt;thread_has_completed(); }</span>
<span class="line-removed"> 84 </span>
 85   bool handshake_has_timed_out(jlong start_time);
 86   static void handle_timeout();
 87 };
 88 
 89 bool VM_Handshake::handshake_has_timed_out(jlong start_time) {
 90   // Check if handshake operation has timed out
 91   if (_handshake_timeout &gt; 0) {
 92     return os::elapsed_counter() &gt;= (start_time + _handshake_timeout);
 93   }
 94   return false;
 95 }
 96 
 97 void VM_Handshake::handle_timeout() {
 98   LogStreamHandle(Warning, handshake) log_stream;
 99   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {
100     if (thr-&gt;has_handshake()) {
101       log_stream.print(&quot;Thread &quot; PTR_FORMAT &quot; has not cleared its handshake op&quot;, p2i(thr));
102       thr-&gt;print_thread_state_on(&amp;log_stream);
103     }
104   }
105   log_stream.flush();
106   fatal(&quot;Handshake operation timed out&quot;);
107 }
108 
109 static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int vmt_executed, const char* extra = NULL) {
110   if (start_time_ns != 0) {
111     jlong completion_time = os::javaTimeNanos() - start_time_ns;
112     log_info(handshake)(&quot;Handshake \&quot;%s\&quot;, Targeted threads: %d, Executed by targeted threads: %d, Total completion time: &quot; JLONG_FORMAT &quot; ns%s%s&quot;,
113                         name, targets,
114                         targets - vmt_executed,
115                         completion_time,
116                         extra != NULL ? &quot;, &quot; : &quot;&quot;,
117                         extra != NULL ? extra : &quot;&quot;);
118   }
119 }
120 
121 class VM_HandshakeOneThread: public VM_Handshake {
122   JavaThread* _target;
123  public:
<span class="line-modified">124   VM_HandshakeOneThread(HandshakeThreadsOperation* op, JavaThread* target) :</span>
125     VM_Handshake(op), _target(target) {}
126 
127   void doit() {
<span class="line-removed">128     DEBUG_ONLY(_op-&gt;check_state();)</span>
<span class="line-removed">129 </span>
130     jlong start_time_ns = 0;
131     if (log_is_enabled(Info, handshake)) {
132       start_time_ns = os::javaTimeNanos();
133     }
134 
135     ThreadsListHandle tlh;
136     if (tlh.includes(_target)) {
<span class="line-modified">137       set_handshake(_target);</span>
138     } else {
139       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0, &quot;(thread dead)&quot;);
140       return;
141     }
142 
143     log_trace(handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; signaled, begin attempt to process by VMThtread&quot;, p2i(_target));
144     jlong timeout_start_time = os::elapsed_counter();
145     bool by_vm_thread = false;
146     do {
147       if (handshake_has_timed_out(timeout_start_time)) {
148         handle_timeout();
149       }
<span class="line-modified">150       by_vm_thread = _target-&gt;handshake_try_process_by_vmThread();</span>
<span class="line-modified">151     } while (!poll_for_completed_thread());</span>
<span class="line-modified">152     DEBUG_ONLY(_op-&gt;check_state();)</span>






153     log_handshake_info(start_time_ns, _op-&gt;name(), 1, by_vm_thread ? 1 : 0);
154   }
155 
156   VMOp_Type type() const { return VMOp_HandshakeOneThread; }
157 
158   bool executed() const { return _op-&gt;executed(); }
159 };
160 
161 class VM_HandshakeAllThreads: public VM_Handshake {
162  public:
<span class="line-modified">163   VM_HandshakeAllThreads(HandshakeThreadsOperation* op) : VM_Handshake(op) {}</span>
164 
165   void doit() {
<span class="line-removed">166     DEBUG_ONLY(_op-&gt;check_state();)</span>
<span class="line-removed">167 </span>
168     jlong start_time_ns = 0;
169     if (log_is_enabled(Info, handshake)) {
170       start_time_ns = os::javaTimeNanos();
171     }
172     int handshake_executed_by_vm_thread = 0;
173 
174     JavaThreadIteratorWithHandle jtiwh;
175     int number_of_threads_issued = 0;
176     for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
<span class="line-modified">177       set_handshake(thr);</span>
178       number_of_threads_issued++;
179     }
180 
181     if (number_of_threads_issued &lt; 1) {
182       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0);
183       return;
184     }


185 
186     log_trace(handshake)(&quot;Threads signaled, begin processing blocked threads by VMThread&quot;);
187     const jlong start_time = os::elapsed_counter();
<span class="line-removed">188     int number_of_threads_completed = 0;</span>
189     do {
190       // Check if handshake operation has timed out
191       if (handshake_has_timed_out(start_time)) {
192         handle_timeout();
193       }
194 
195       // Have VM thread perform the handshake operation for blocked threads.
196       // Observing a blocked state may of course be transient but the processing is guarded
197       // by semaphores and we optimistically begin by working on the blocked threads
198       jtiwh.rewind();
199       for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
200         // A new thread on the ThreadsList will not have an operation,
<span class="line-modified">201         // hence it is skipped in handshake_process_by_vmthread.</span>
<span class="line-modified">202         if (thr-&gt;handshake_try_process_by_vmThread()) {</span>
203           handshake_executed_by_vm_thread++;
204         }
205       }
<span class="line-modified">206       while (poll_for_completed_thread()) {</span>
<span class="line-removed">207         // Includes canceled operations by exiting threads.</span>
<span class="line-removed">208         number_of_threads_completed++;</span>
<span class="line-removed">209       }</span>
210 
<span class="line-modified">211     } while (number_of_threads_issued &gt; number_of_threads_completed);</span>
<span class="line-modified">212     assert(number_of_threads_issued == number_of_threads_completed, &quot;Must be the same&quot;);</span>
<span class="line-modified">213     DEBUG_ONLY(_op-&gt;check_state();)</span>


214 
215     log_handshake_info(start_time_ns, _op-&gt;name(), number_of_threads_issued, handshake_executed_by_vm_thread);
216   }
217 
218   VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
219 };
220 
<span class="line-modified">221 class VM_HandshakeFallbackOperation : public VM_Operation {</span>
<span class="line-removed">222   HandshakeClosure* _handshake_cl;</span>
<span class="line-removed">223   Thread* _target_thread;</span>
<span class="line-removed">224   bool _all_threads;</span>
<span class="line-removed">225   bool _executed;</span>
<span class="line-removed">226 public:</span>
<span class="line-removed">227   VM_HandshakeFallbackOperation(HandshakeClosure* cl) :</span>
<span class="line-removed">228       _handshake_cl(cl), _target_thread(NULL), _all_threads(true), _executed(false) {}</span>
<span class="line-removed">229   VM_HandshakeFallbackOperation(HandshakeClosure* cl, Thread* target) :</span>
<span class="line-removed">230       _handshake_cl(cl), _target_thread(target), _all_threads(false), _executed(false) {}</span>
<span class="line-removed">231 </span>
<span class="line-removed">232   void doit() {</span>
<span class="line-removed">233     log_trace(handshake)(&quot;VMThread executing VM_HandshakeFallbackOperation, operation: %s&quot;, name());</span>
<span class="line-removed">234     for (JavaThreadIteratorWithHandle jtiwh; JavaThread *t = jtiwh.next(); ) {</span>
<span class="line-removed">235       if (_all_threads || t == _target_thread) {</span>
<span class="line-removed">236         if (t == _target_thread) {</span>
<span class="line-removed">237           _executed = true;</span>
<span class="line-removed">238         }</span>
<span class="line-removed">239         _handshake_cl-&gt;do_thread(t);</span>
<span class="line-removed">240       }</span>
<span class="line-removed">241     }</span>
<span class="line-removed">242   }</span>
<span class="line-removed">243 </span>
<span class="line-removed">244   VMOp_Type type() const { return VMOp_HandshakeFallback; }</span>
<span class="line-removed">245   bool executed() const { return _executed; }</span>
<span class="line-removed">246 };</span>
<span class="line-removed">247 </span>
<span class="line-removed">248 void HandshakeThreadsOperation::do_handshake(JavaThread* thread) {</span>
249   jlong start_time_ns = 0;
250   if (log_is_enabled(Debug, handshake, task)) {
251     start_time_ns = os::javaTimeNanos();
252   }
253 
254   // Only actually execute the operation for non terminated threads.
255   if (!thread-&gt;is_terminated()) {
256     _handshake_cl-&gt;do_thread(thread);
257     _executed = true;
258   }
259 
260   if (start_time_ns != 0) {
261     jlong completion_time = os::javaTimeNanos() - start_time_ns;
262     log_debug(handshake, task)(&quot;Operation: %s for thread &quot; PTR_FORMAT &quot;, is_vm_thread: %s, completed in &quot; JLONG_FORMAT &quot; ns&quot;,
263                                name(), p2i(thread), BOOL_TO_STR(Thread::current()-&gt;is_VM_thread()), completion_time);
264   }
265 
<span class="line-modified">266   // Use the semaphore to inform the VM thread that we have completed the operation</span>
<span class="line-modified">267   _done.signal();</span>




268 
<span class="line-modified">269   // It is no longer safe to refer to &#39;this&#39; as the VMThread may have destroyed this operation</span>
270 }
271 
272 void Handshake::execute(HandshakeClosure* thread_cl) {
<span class="line-modified">273   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">274     HandshakeThreadsOperation cto(thread_cl);</span>
<span class="line-modified">275     VM_HandshakeAllThreads handshake(&amp;cto);</span>
<span class="line-removed">276     VMThread::execute(&amp;handshake);</span>
<span class="line-removed">277   } else {</span>
<span class="line-removed">278     VM_HandshakeFallbackOperation op(thread_cl);</span>
<span class="line-removed">279     VMThread::execute(&amp;op);</span>
<span class="line-removed">280   }</span>
281 }
282 
283 bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {
<span class="line-modified">284   if (SafepointMechanism::uses_thread_local_poll()) {</span>
<span class="line-modified">285     HandshakeThreadsOperation cto(thread_cl);</span>
<span class="line-modified">286     VM_HandshakeOneThread handshake(&amp;cto, target);</span>
<span class="line-modified">287     VMThread::execute(&amp;handshake);</span>
<span class="line-modified">288     return handshake.executed();</span>













289   } else {
<span class="line-modified">290     VM_HandshakeFallbackOperation op(thread_cl, target);</span>
<span class="line-modified">291     VMThread::execute(&amp;op);</span>
<span class="line-removed">292     return op.executed();</span>
293   }




















294 }
295 
<span class="line-modified">296 HandshakeState::HandshakeState() : _operation(NULL), _semaphore(1), _thread_in_process_handshake(false) {</span>
<span class="line-modified">297   DEBUG_ONLY(_vmthread_processing_handshake = false;)</span>






298 }
299 
<span class="line-modified">300 void HandshakeState::set_operation(JavaThread* target, HandshakeOperation* op) {</span>
<span class="line-modified">301   _operation = op;</span>
<span class="line-modified">302   SafepointMechanism::arm_local_poll_release(target);</span>








303 }
304 
<span class="line-modified">305 void HandshakeState::clear_handshake(JavaThread* target) {</span>
<span class="line-modified">306   _operation = NULL;</span>
<span class="line-modified">307   SafepointMechanism::disarm_if_needed(target, true /* release */);</span>




308 }
309 
<span class="line-modified">310 void HandshakeState::process_self_inner(JavaThread* thread) {</span>
<span class="line-modified">311   assert(Thread::current() == thread, &quot;should call from thread&quot;);</span>
<span class="line-modified">312   assert(!thread-&gt;is_terminated(), &quot;should not be a terminated thread&quot;);</span>
<span class="line-modified">313   assert(thread-&gt;thread_state() != _thread_blocked, &quot;should not be in a blocked state&quot;);</span>
<span class="line-modified">314   assert(thread-&gt;thread_state() != _thread_in_native, &quot;should not be in native&quot;);</span>

315 
316   do {
<span class="line-modified">317     ThreadInVMForHandshake tivm(thread);</span>
<span class="line-modified">318     if (!_semaphore.trywait()) {</span>
<span class="line-modified">319       _semaphore.wait_with_safepoint_check(thread);</span>
320     }
<span class="line-modified">321     HandshakeOperation* op = Atomic::load_acquire(&amp;_operation);</span>
<span class="line-modified">322     if (op != NULL) {</span>
<span class="line-modified">323       HandleMark hm(thread);</span>
<span class="line-modified">324       CautiouslyPreserveExceptionMark pem(thread);</span>
<span class="line-modified">325       // Disarm before execute the operation</span>
<span class="line-modified">326       clear_handshake(thread);</span>
<span class="line-modified">327       op-&gt;do_handshake(thread);</span>








328     }
<span class="line-modified">329     _semaphore.signal();</span>
330   } while (has_operation());
331 }
332 
<span class="line-modified">333 bool HandshakeState::vmthread_can_process_handshake(JavaThread* target) {</span>
334   // handshake_safe may only be called with polls armed.
<span class="line-modified">335   // VM thread controls this by first claiming the handshake via claim_handshake_for_vmthread.</span>
<span class="line-modified">336   return SafepointSynchronize::handshake_safe(target);</span>
337 }
338 
<span class="line-modified">339 static bool possibly_vmthread_can_process_handshake(JavaThread* target) {</span>
340   // Note that this method is allowed to produce false positives.
<span class="line-modified">341   if (target-&gt;is_ext_suspended()) {</span>
342     return true;
343   }
<span class="line-modified">344   if (target-&gt;is_terminated()) {</span>
345     return true;
346   }
<span class="line-modified">347   switch (target-&gt;thread_state()) {</span>
348   case _thread_in_native:
349     // native threads are safe if they have no java stack or have walkable stack
<span class="line-modified">350     return !target-&gt;has_last_Java_frame() || target-&gt;frame_anchor()-&gt;walkable();</span>
351 
352   case _thread_blocked:
353     return true;
354 
355   default:
356     return false;
357   }
358 }
359 
<span class="line-modified">360 bool HandshakeState::claim_handshake_for_vmthread() {</span>
<span class="line-modified">361   if (!_semaphore.trywait()) {</span>
362     return false;
363   }
<span class="line-modified">364   if (has_operation()) {</span>
365     return true;
366   }
<span class="line-modified">367   _semaphore.signal();</span>
368   return false;
369 }
370 
<span class="line-modified">371 bool HandshakeState::try_process_by_vmThread(JavaThread* target) {</span>
<span class="line-modified">372   assert(Thread::current()-&gt;is_VM_thread(), &quot;should call from vm thread&quot;);</span>
373 
<span class="line-modified">374   if (!has_operation()) {</span>
375     // JT has already cleared its handshake
376     return false;
377   }
378 
<span class="line-modified">379   if (!possibly_vmthread_can_process_handshake(target)) {</span>
380     // JT is observed in an unsafe state, it must notice the handshake itself
381     return false;
382   }
383 
384   // Claim the semaphore if there still an operation to be executed.
<span class="line-modified">385   if (!claim_handshake_for_vmthread()) {</span>








386     return false;
387   }
388 
389   // If we own the semaphore at this point and while owning the semaphore
390   // can observe a safe state the thread cannot possibly continue without
391   // getting caught by the semaphore.
392   bool executed = false;
<span class="line-modified">393   if (vmthread_can_process_handshake(target)) {</span>
<span class="line-modified">394     guarantee(!_semaphore.trywait(), &quot;we should already own the semaphore&quot;);</span>
<span class="line-modified">395     log_trace(handshake)(&quot;Processing handshake by VMThtread&quot;);</span>
<span class="line-modified">396     DEBUG_ONLY(_vmthread_processing_handshake = true;)</span>
<span class="line-modified">397     _operation-&gt;do_handshake(target);</span>
<span class="line-modified">398     DEBUG_ONLY(_vmthread_processing_handshake = false;)</span>
<span class="line-modified">399     // Disarm after VM thread have executed the operation.</span>
<span class="line-modified">400     clear_handshake(target);</span>
401     executed = true;
402   }
403 
404   // Release the thread
<span class="line-modified">405   _semaphore.signal();</span>
406 
407   return executed;
408 }
</pre>
</td>
<td>
<hr />
<pre>
  1 /*
<span class="line-modified">  2  * Copyright (c) 2017, 2020, Oracle and/or its affiliates. All rights reserved.</span>
  3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
  4  *
  5  * This code is free software; you can redistribute it and/or modify it
  6  * under the terms of the GNU General Public License version 2 only, as
  7  * published by the Free Software Foundation.
  8  *
  9  * This code is distributed in the hope that it will be useful, but WITHOUT
 10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 12  * version 2 for more details (a copy is included in the LICENSE file that
 13  * accompanied this code).
 14  *
 15  * You should have received a copy of the GNU General Public License version
 16  * 2 along with this work; if not, write to the Free Software Foundation,
 17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 18  *
 19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 20  * or visit www.oracle.com if you need additional information or have any
 21  * questions.
 22  *
 23  */
 24 
 25 #include &quot;precompiled.hpp&quot;
 26 #include &quot;logging/log.hpp&quot;
 27 #include &quot;logging/logStream.hpp&quot;
 28 #include &quot;memory/resourceArea.hpp&quot;
 29 #include &quot;runtime/atomic.hpp&quot;
 30 #include &quot;runtime/handshake.hpp&quot;
 31 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 32 #include &quot;runtime/osThread.hpp&quot;
 33 #include &quot;runtime/semaphore.inline.hpp&quot;
 34 #include &quot;runtime/task.hpp&quot;
 35 #include &quot;runtime/thread.hpp&quot;
 36 #include &quot;runtime/vmThread.hpp&quot;
 37 #include &quot;utilities/formatBuffer.hpp&quot;
 38 #include &quot;utilities/preserveException.hpp&quot;
 39 




 40 
<span class="line-modified"> 41 class HandshakeOperation: public StackObj {</span>

 42   HandshakeClosure* _handshake_cl;
<span class="line-added"> 43   int32_t _pending_threads;</span>
 44   bool _executed;
<span class="line-added"> 45   bool _is_direct;</span>
 46 public:
<span class="line-modified"> 47   HandshakeOperation(HandshakeClosure* cl, bool is_direct = false) :</span>
<span class="line-added"> 48     _handshake_cl(cl),</span>
<span class="line-added"> 49     _pending_threads(1),</span>
<span class="line-added"> 50     _executed(false),</span>
<span class="line-added"> 51     _is_direct(is_direct) {}</span>
<span class="line-added"> 52 </span>
 53   void do_handshake(JavaThread* thread);
<span class="line-modified"> 54   bool is_completed() {</span>
<span class="line-added"> 55     int32_t val = Atomic::load(&amp;_pending_threads);</span>
<span class="line-added"> 56     assert(val &gt;= 0, &quot;_pending_threads=%d cannot be negative&quot;, val);</span>
<span class="line-added"> 57     return val == 0;</span>
<span class="line-added"> 58   }</span>
<span class="line-added"> 59   void add_target_count(int count) { Atomic::add(&amp;_pending_threads, count, memory_order_relaxed); }</span>
 60   bool executed() const { return _executed; }
 61   const char* name() { return _handshake_cl-&gt;name(); }
 62 
<span class="line-modified"> 63   bool is_direct() { return _is_direct; }</span>




 64 };
 65 


 66 class VM_Handshake: public VM_Operation {
 67   const jlong _handshake_timeout;
 68  public:
 69   bool evaluate_at_safepoint() const { return false; }
 70 
 71  protected:
<span class="line-modified"> 72   HandshakeOperation* const _op;</span>
 73 
<span class="line-modified"> 74   VM_Handshake(HandshakeOperation* op) :</span>
 75       _handshake_timeout(TimeHelper::millis_to_counter(HandshakeTimeout)), _op(op) {}
 76 









 77   bool handshake_has_timed_out(jlong start_time);
 78   static void handle_timeout();
 79 };
 80 
 81 bool VM_Handshake::handshake_has_timed_out(jlong start_time) {
 82   // Check if handshake operation has timed out
 83   if (_handshake_timeout &gt; 0) {
 84     return os::elapsed_counter() &gt;= (start_time + _handshake_timeout);
 85   }
 86   return false;
 87 }
 88 
 89 void VM_Handshake::handle_timeout() {
 90   LogStreamHandle(Warning, handshake) log_stream;
 91   for (JavaThreadIteratorWithHandle jtiwh; JavaThread *thr = jtiwh.next(); ) {
 92     if (thr-&gt;has_handshake()) {
 93       log_stream.print(&quot;Thread &quot; PTR_FORMAT &quot; has not cleared its handshake op&quot;, p2i(thr));
 94       thr-&gt;print_thread_state_on(&amp;log_stream);
 95     }
 96   }
 97   log_stream.flush();
 98   fatal(&quot;Handshake operation timed out&quot;);
 99 }
100 
101 static void log_handshake_info(jlong start_time_ns, const char* name, int targets, int vmt_executed, const char* extra = NULL) {
102   if (start_time_ns != 0) {
103     jlong completion_time = os::javaTimeNanos() - start_time_ns;
104     log_info(handshake)(&quot;Handshake \&quot;%s\&quot;, Targeted threads: %d, Executed by targeted threads: %d, Total completion time: &quot; JLONG_FORMAT &quot; ns%s%s&quot;,
105                         name, targets,
106                         targets - vmt_executed,
107                         completion_time,
108                         extra != NULL ? &quot;, &quot; : &quot;&quot;,
109                         extra != NULL ? extra : &quot;&quot;);
110   }
111 }
112 
113 class VM_HandshakeOneThread: public VM_Handshake {
114   JavaThread* _target;
115  public:
<span class="line-modified">116   VM_HandshakeOneThread(HandshakeOperation* op, JavaThread* target) :</span>
117     VM_Handshake(op), _target(target) {}
118 
119   void doit() {


120     jlong start_time_ns = 0;
121     if (log_is_enabled(Info, handshake)) {
122       start_time_ns = os::javaTimeNanos();
123     }
124 
125     ThreadsListHandle tlh;
126     if (tlh.includes(_target)) {
<span class="line-modified">127       _target-&gt;set_handshake_operation(_op);</span>
128     } else {
129       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0, &quot;(thread dead)&quot;);
130       return;
131     }
132 
133     log_trace(handshake)(&quot;JavaThread &quot; INTPTR_FORMAT &quot; signaled, begin attempt to process by VMThtread&quot;, p2i(_target));
134     jlong timeout_start_time = os::elapsed_counter();
135     bool by_vm_thread = false;
136     do {
137       if (handshake_has_timed_out(timeout_start_time)) {
138         handle_timeout();
139       }
<span class="line-modified">140       by_vm_thread = _target-&gt;handshake_try_process(_op);</span>
<span class="line-modified">141     } while (!_op-&gt;is_completed());</span>
<span class="line-modified">142 </span>
<span class="line-added">143     // This pairs up with the release store in do_handshake(). It prevents future</span>
<span class="line-added">144     // loads from floating above the load of _pending_threads in is_completed()</span>
<span class="line-added">145     // and thus prevents reading stale data modified in the handshake closure</span>
<span class="line-added">146     // by the Handshakee.</span>
<span class="line-added">147     OrderAccess::acquire();</span>
<span class="line-added">148 </span>
149     log_handshake_info(start_time_ns, _op-&gt;name(), 1, by_vm_thread ? 1 : 0);
150   }
151 
152   VMOp_Type type() const { return VMOp_HandshakeOneThread; }
153 
154   bool executed() const { return _op-&gt;executed(); }
155 };
156 
157 class VM_HandshakeAllThreads: public VM_Handshake {
158  public:
<span class="line-modified">159   VM_HandshakeAllThreads(HandshakeOperation* op) : VM_Handshake(op) {}</span>
160 
161   void doit() {


162     jlong start_time_ns = 0;
163     if (log_is_enabled(Info, handshake)) {
164       start_time_ns = os::javaTimeNanos();
165     }
166     int handshake_executed_by_vm_thread = 0;
167 
168     JavaThreadIteratorWithHandle jtiwh;
169     int number_of_threads_issued = 0;
170     for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
<span class="line-modified">171       thr-&gt;set_handshake_operation(_op);</span>
172       number_of_threads_issued++;
173     }
174 
175     if (number_of_threads_issued &lt; 1) {
176       log_handshake_info(start_time_ns, _op-&gt;name(), 0, 0);
177       return;
178     }
<span class="line-added">179     // _op was created with a count == 1 so don&#39;t double count.</span>
<span class="line-added">180     _op-&gt;add_target_count(number_of_threads_issued - 1);</span>
181 
182     log_trace(handshake)(&quot;Threads signaled, begin processing blocked threads by VMThread&quot;);
183     const jlong start_time = os::elapsed_counter();

184     do {
185       // Check if handshake operation has timed out
186       if (handshake_has_timed_out(start_time)) {
187         handle_timeout();
188       }
189 
190       // Have VM thread perform the handshake operation for blocked threads.
191       // Observing a blocked state may of course be transient but the processing is guarded
192       // by semaphores and we optimistically begin by working on the blocked threads
193       jtiwh.rewind();
194       for (JavaThread *thr = jtiwh.next(); thr != NULL; thr = jtiwh.next()) {
195         // A new thread on the ThreadsList will not have an operation,
<span class="line-modified">196         // hence it is skipped in handshake_try_process.</span>
<span class="line-modified">197         if (thr-&gt;handshake_try_process(_op)) {</span>
198           handshake_executed_by_vm_thread++;
199         }
200       }
<span class="line-modified">201     } while (!_op-&gt;is_completed());</span>



202 
<span class="line-modified">203     // This pairs up with the release store in do_handshake(). It prevents future</span>
<span class="line-modified">204     // loads from floating above the load of _pending_threads in is_completed()</span>
<span class="line-modified">205     // and thus prevents reading stale data modified in the handshake closure</span>
<span class="line-added">206     // by the Handshakee.</span>
<span class="line-added">207     OrderAccess::acquire();</span>
208 
209     log_handshake_info(start_time_ns, _op-&gt;name(), number_of_threads_issued, handshake_executed_by_vm_thread);
210   }
211 
212   VMOp_Type type() const { return VMOp_HandshakeAllThreads; }
213 };
214 
<span class="line-modified">215 void HandshakeOperation::do_handshake(JavaThread* thread) {</span>



























216   jlong start_time_ns = 0;
217   if (log_is_enabled(Debug, handshake, task)) {
218     start_time_ns = os::javaTimeNanos();
219   }
220 
221   // Only actually execute the operation for non terminated threads.
222   if (!thread-&gt;is_terminated()) {
223     _handshake_cl-&gt;do_thread(thread);
224     _executed = true;
225   }
226 
227   if (start_time_ns != 0) {
228     jlong completion_time = os::javaTimeNanos() - start_time_ns;
229     log_debug(handshake, task)(&quot;Operation: %s for thread &quot; PTR_FORMAT &quot;, is_vm_thread: %s, completed in &quot; JLONG_FORMAT &quot; ns&quot;,
230                                name(), p2i(thread), BOOL_TO_STR(Thread::current()-&gt;is_VM_thread()), completion_time);
231   }
232 
<span class="line-modified">233   // Inform VMThread/Handshaker that we have completed the operation.</span>
<span class="line-modified">234   // When this is executed by the Handshakee we need a release store</span>
<span class="line-added">235   // here to make sure memory operations executed in the handshake</span>
<span class="line-added">236   // closure are visible to the VMThread/Handshaker after it reads</span>
<span class="line-added">237   // that the operation has completed.</span>
<span class="line-added">238   Atomic::dec(&amp;_pending_threads, memory_order_release);</span>
239 
<span class="line-modified">240   // It is no longer safe to refer to &#39;this&#39; as the VMThread/Handshaker may have destroyed this operation</span>
241 }
242 
243 void Handshake::execute(HandshakeClosure* thread_cl) {
<span class="line-modified">244   HandshakeOperation cto(thread_cl);</span>
<span class="line-modified">245   VM_HandshakeAllThreads handshake(&amp;cto);</span>
<span class="line-modified">246   VMThread::execute(&amp;handshake);</span>





247 }
248 
249 bool Handshake::execute(HandshakeClosure* thread_cl, JavaThread* target) {
<span class="line-modified">250   HandshakeOperation cto(thread_cl);</span>
<span class="line-modified">251   VM_HandshakeOneThread handshake(&amp;cto, target);</span>
<span class="line-modified">252   VMThread::execute(&amp;handshake);</span>
<span class="line-modified">253   return handshake.executed();</span>
<span class="line-modified">254 }</span>
<span class="line-added">255 </span>
<span class="line-added">256 bool Handshake::execute_direct(HandshakeClosure* thread_cl, JavaThread* target) {</span>
<span class="line-added">257   JavaThread* self = JavaThread::current();</span>
<span class="line-added">258   HandshakeOperation op(thread_cl, /*is_direct*/ true);</span>
<span class="line-added">259 </span>
<span class="line-added">260   jlong start_time_ns = 0;</span>
<span class="line-added">261   if (log_is_enabled(Info, handshake)) {</span>
<span class="line-added">262     start_time_ns = os::javaTimeNanos();</span>
<span class="line-added">263   }</span>
<span class="line-added">264 </span>
<span class="line-added">265   ThreadsListHandle tlh;</span>
<span class="line-added">266   if (tlh.includes(target)) {</span>
<span class="line-added">267     target-&gt;set_handshake_operation(&amp;op);</span>
268   } else {
<span class="line-modified">269     log_handshake_info(start_time_ns, op.name(), 0, 0, &quot;(thread dead)&quot;);</span>
<span class="line-modified">270     return false;</span>

271   }
<span class="line-added">272 </span>
<span class="line-added">273   bool by_handshaker = false;</span>
<span class="line-added">274   while (!op.is_completed()) {</span>
<span class="line-added">275     by_handshaker = target-&gt;handshake_try_process(&amp;op);</span>
<span class="line-added">276     // Check for pending handshakes to avoid possible deadlocks where our</span>
<span class="line-added">277     // target is trying to handshake us.</span>
<span class="line-added">278     if (SafepointMechanism::should_block(self)) {</span>
<span class="line-added">279       ThreadBlockInVM tbivm(self);</span>
<span class="line-added">280     }</span>
<span class="line-added">281   }</span>
<span class="line-added">282 </span>
<span class="line-added">283   // This pairs up with the release store in do_handshake(). It prevents future</span>
<span class="line-added">284   // loads from floating above the load of _pending_threads in is_completed()</span>
<span class="line-added">285   // and thus prevents reading stale data modified in the handshake closure</span>
<span class="line-added">286   // by the Handshakee.</span>
<span class="line-added">287   OrderAccess::acquire();</span>
<span class="line-added">288 </span>
<span class="line-added">289   log_handshake_info(start_time_ns, op.name(), 1, by_handshaker ? 1 : 0);</span>
<span class="line-added">290 </span>
<span class="line-added">291   return op.executed();</span>
292 }
293 
<span class="line-modified">294 HandshakeState::HandshakeState() :</span>
<span class="line-modified">295   _operation(NULL),</span>
<span class="line-added">296   _operation_direct(NULL),</span>
<span class="line-added">297   _handshake_turn_sem(1),</span>
<span class="line-added">298   _processing_sem(1),</span>
<span class="line-added">299   _thread_in_process_handshake(false)</span>
<span class="line-added">300 {</span>
<span class="line-added">301   DEBUG_ONLY(_active_handshaker = NULL;)</span>
302 }
303 
<span class="line-modified">304 void HandshakeState::set_operation(HandshakeOperation* op) {</span>
<span class="line-modified">305   if (!op-&gt;is_direct()) {</span>
<span class="line-modified">306     assert(Thread::current()-&gt;is_VM_thread(), &quot;should be the VMThread&quot;);</span>
<span class="line-added">307     _operation = op;</span>
<span class="line-added">308   } else {</span>
<span class="line-added">309     assert(Thread::current()-&gt;is_Java_thread(), &quot;should be a JavaThread&quot;);</span>
<span class="line-added">310     // Serialize direct handshakes so that only one proceeds at a time for a given target</span>
<span class="line-added">311     _handshake_turn_sem.wait_with_safepoint_check(JavaThread::current());</span>
<span class="line-added">312     _operation_direct = op;</span>
<span class="line-added">313   }</span>
<span class="line-added">314   SafepointMechanism::arm_local_poll_release(_handshakee);</span>
315 }
316 
<span class="line-modified">317 void HandshakeState::clear_handshake(bool is_direct) {</span>
<span class="line-modified">318   if (!is_direct) {</span>
<span class="line-modified">319     _operation = NULL;</span>
<span class="line-added">320   } else {</span>
<span class="line-added">321     _operation_direct = NULL;</span>
<span class="line-added">322     _handshake_turn_sem.signal();</span>
<span class="line-added">323   }</span>
324 }
325 
<span class="line-modified">326 void HandshakeState::process_self_inner() {</span>
<span class="line-modified">327   assert(Thread::current() == _handshakee, &quot;should call from _handshakee&quot;);</span>
<span class="line-modified">328   assert(!_handshakee-&gt;is_terminated(), &quot;should not be a terminated thread&quot;);</span>
<span class="line-modified">329   assert(_handshakee-&gt;thread_state() != _thread_blocked, &quot;should not be in a blocked state&quot;);</span>
<span class="line-modified">330   assert(_handshakee-&gt;thread_state() != _thread_in_native, &quot;should not be in native&quot;);</span>
<span class="line-added">331   JavaThread* self = _handshakee;</span>
332 
333   do {
<span class="line-modified">334     ThreadInVMForHandshake tivm(self);</span>
<span class="line-modified">335     if (!_processing_sem.trywait()) {</span>
<span class="line-modified">336       _processing_sem.wait_with_safepoint_check(self);</span>
337     }
<span class="line-modified">338     if (has_operation()) {</span>
<span class="line-modified">339       HandleMark hm(self);</span>
<span class="line-modified">340       CautiouslyPreserveExceptionMark pem(self);</span>
<span class="line-modified">341       HandshakeOperation * op = _operation;</span>
<span class="line-modified">342       if (op != NULL) {</span>
<span class="line-modified">343         // Disarm before executing the operation</span>
<span class="line-modified">344         clear_handshake(/*is_direct*/ false);</span>
<span class="line-added">345         op-&gt;do_handshake(self);</span>
<span class="line-added">346       }</span>
<span class="line-added">347       op = _operation_direct;</span>
<span class="line-added">348       if (op != NULL) {</span>
<span class="line-added">349         // Disarm before executing the operation</span>
<span class="line-added">350         clear_handshake(/*is_direct*/ true);</span>
<span class="line-added">351         op-&gt;do_handshake(self);</span>
<span class="line-added">352       }</span>
353     }
<span class="line-modified">354     _processing_sem.signal();</span>
355   } while (has_operation());
356 }
357 
<span class="line-modified">358 bool HandshakeState::can_process_handshake() {</span>
359   // handshake_safe may only be called with polls armed.
<span class="line-modified">360   // Handshaker controls this by first claiming the handshake via claim_handshake().</span>
<span class="line-modified">361   return SafepointSynchronize::handshake_safe(_handshakee);</span>
362 }
363 
<span class="line-modified">364 bool HandshakeState::possibly_can_process_handshake() {</span>
365   // Note that this method is allowed to produce false positives.
<span class="line-modified">366   if (_handshakee-&gt;is_ext_suspended()) {</span>
367     return true;
368   }
<span class="line-modified">369   if (_handshakee-&gt;is_terminated()) {</span>
370     return true;
371   }
<span class="line-modified">372   switch (_handshakee-&gt;thread_state()) {</span>
373   case _thread_in_native:
374     // native threads are safe if they have no java stack or have walkable stack
<span class="line-modified">375     return !_handshakee-&gt;has_last_Java_frame() || _handshakee-&gt;frame_anchor()-&gt;walkable();</span>
376 
377   case _thread_blocked:
378     return true;
379 
380   default:
381     return false;
382   }
383 }
384 
<span class="line-modified">385 bool HandshakeState::claim_handshake(bool is_direct) {</span>
<span class="line-modified">386   if (!_processing_sem.trywait()) {</span>
387     return false;
388   }
<span class="line-modified">389   if (has_specific_operation(is_direct)){</span>
390     return true;
391   }
<span class="line-modified">392   _processing_sem.signal();</span>
393   return false;
394 }
395 
<span class="line-modified">396 bool HandshakeState::try_process(HandshakeOperation* op) {</span>
<span class="line-modified">397   bool is_direct = op-&gt;is_direct();</span>
398 
<span class="line-modified">399   if (!has_specific_operation(is_direct)){</span>
400     // JT has already cleared its handshake
401     return false;
402   }
403 
<span class="line-modified">404   if (!possibly_can_process_handshake()) {</span>
405     // JT is observed in an unsafe state, it must notice the handshake itself
406     return false;
407   }
408 
409   // Claim the semaphore if there still an operation to be executed.
<span class="line-modified">410   if (!claim_handshake(is_direct)) {</span>
<span class="line-added">411     return false;</span>
<span class="line-added">412   }</span>
<span class="line-added">413 </span>
<span class="line-added">414   // Check if the handshake operation is the same as the one we meant to execute. The</span>
<span class="line-added">415   // handshake could have been already processed by the handshakee and a new handshake</span>
<span class="line-added">416   // by another JavaThread might be in progress.</span>
<span class="line-added">417   if (is_direct &amp;&amp; op != _operation_direct) {</span>
<span class="line-added">418     _processing_sem.signal();</span>
419     return false;
420   }
421 
422   // If we own the semaphore at this point and while owning the semaphore
423   // can observe a safe state the thread cannot possibly continue without
424   // getting caught by the semaphore.
425   bool executed = false;
<span class="line-modified">426   if (can_process_handshake()) {</span>
<span class="line-modified">427     guarantee(!_processing_sem.trywait(), &quot;we should already own the semaphore&quot;);</span>
<span class="line-modified">428     log_trace(handshake)(&quot;Processing handshake by %s&quot;, Thread::current()-&gt;is_VM_thread() ? &quot;VMThread&quot; : &quot;Handshaker&quot;);</span>
<span class="line-modified">429     DEBUG_ONLY(_active_handshaker = Thread::current();)</span>
<span class="line-modified">430     op-&gt;do_handshake(_handshakee);</span>
<span class="line-modified">431     DEBUG_ONLY(_active_handshaker = NULL;)</span>
<span class="line-modified">432     // Disarm after we have executed the operation.</span>
<span class="line-modified">433     clear_handshake(is_direct);</span>
434     executed = true;
435   }
436 
437   // Release the thread
<span class="line-modified">438   _processing_sem.signal();</span>
439 
440   return executed;
441 }
</pre>
</td>
</tr>
</table>
<center><a href="globals_extension.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="handshake.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
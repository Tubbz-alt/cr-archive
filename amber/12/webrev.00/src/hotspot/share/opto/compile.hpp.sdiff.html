<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_COMPILE_HPP
  26 #define SHARE_OPTO_COMPILE_HPP
  27 
  28 #include &quot;asm/codeBuffer.hpp&quot;
  29 #include &quot;ci/compilerInterface.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
<span class="line-removed">  31 #include &quot;code/exceptionHandlerTable.hpp&quot;</span>
  32 #include &quot;compiler/compilerOracle.hpp&quot;
  33 #include &quot;compiler/compileBroker.hpp&quot;

  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;libadt/vectset.hpp&quot;
<span class="line-removed">  36 #include &quot;jfr/jfrEvents.hpp&quot;</span>
  37 #include &quot;memory/resourceArea.hpp&quot;
  38 #include &quot;oops/methodData.hpp&quot;
  39 #include &quot;opto/idealGraphPrinter.hpp&quot;
  40 #include &quot;opto/phasetype.hpp&quot;
  41 #include &quot;opto/phase.hpp&quot;
  42 #include &quot;opto/regmask.hpp&quot;
  43 #include &quot;runtime/deoptimization.hpp&quot;
  44 #include &quot;runtime/timerTrace.hpp&quot;
  45 #include &quot;runtime/vmThread.hpp&quot;
  46 #include &quot;utilities/ticks.hpp&quot;
  47 
  48 class AddPNode;
  49 class Block;
  50 class Bundle;
<span class="line-removed">  51 class C2Compiler;</span>
  52 class CallGenerator;
  53 class CloneMap;
  54 class ConnectionGraph;
  55 class IdealGraphPrinter;
  56 class InlineTree;
  57 class Int_Array;
  58 class Matcher;
  59 class MachConstantNode;
  60 class MachConstantBaseNode;
  61 class MachNode;
  62 class MachOper;
  63 class MachSafePointNode;
  64 class Node;
  65 class Node_Array;
  66 class Node_Notes;
  67 class NodeCloneInfo;
  68 class OptoReg;
  69 class PhaseCFG;
  70 class PhaseGVN;
  71 class PhaseIterGVN;
  72 class PhaseRegAlloc;
  73 class PhaseCCP;
  74 class PhaseCCP_DCE;

  75 class RootNode;
  76 class relocInfo;
  77 class Scope;
  78 class StartNode;
  79 class SafePointNode;
  80 class JVMState;
  81 class Type;
  82 class TypeData;
  83 class TypeInt;
  84 class TypePtr;
  85 class TypeOopPtr;
  86 class TypeFunc;

  87 class Unique_Node_List;
  88 class nmethod;
  89 class WarmCallInfo;
  90 class Node_Stack;
  91 struct Final_Reshape_Counts;
  92 
  93 enum LoopOptsMode {
  94   LoopOptsDefault,
  95   LoopOptsNone,
  96   LoopOptsMaxUnroll,
  97   LoopOptsShenandoahExpand,
  98   LoopOptsShenandoahPostExpand,
  99   LoopOptsSkipSplitIf,
 100   LoopOptsVerify
 101 };
 102 
 103 typedef unsigned int node_idx_t;
 104 class NodeCloneInfo {
 105  private:
 106   uint64_t _idx_clone_orig;
</pre>
<hr />
<pre>
 223     }
 224     void set_element(const Type* e) {
 225       assert(_element == NULL, &quot;&quot;);
 226       _element = e;
 227     }
 228 
 229     BasicType basic_type() const;
 230 
 231     void print_on(outputStream* st) PRODUCT_RETURN;
 232   };
 233 
 234   enum {
 235     logAliasCacheSize = 6,
 236     AliasCacheSize = (1&lt;&lt;logAliasCacheSize)
 237   };
 238   struct AliasCacheEntry { const TypePtr* _adr_type; int _index; };  // simple duple type
 239   enum {
 240     trapHistLength = MethodData::_trap_hist_limit
 241   };
 242 
<span class="line-removed"> 243   // Constant entry of the constant table.</span>
<span class="line-removed"> 244   class Constant {</span>
<span class="line-removed"> 245   private:</span>
<span class="line-removed"> 246     BasicType _type;</span>
<span class="line-removed"> 247     union {</span>
<span class="line-removed"> 248       jvalue    _value;</span>
<span class="line-removed"> 249       Metadata* _metadata;</span>
<span class="line-removed"> 250     } _v;</span>
<span class="line-removed"> 251     int       _offset;         // offset of this constant (in bytes) relative to the constant table base.</span>
<span class="line-removed"> 252     float     _freq;</span>
<span class="line-removed"> 253     bool      _can_be_reused;  // true (default) if the value can be shared with other users.</span>
<span class="line-removed"> 254 </span>
<span class="line-removed"> 255   public:</span>
<span class="line-removed"> 256     Constant() : _type(T_ILLEGAL), _offset(-1), _freq(0.0f), _can_be_reused(true) { _v._value.l = 0; }</span>
<span class="line-removed"> 257     Constant(BasicType type, jvalue value, float freq = 0.0f, bool can_be_reused = true) :</span>
<span class="line-removed"> 258       _type(type),</span>
<span class="line-removed"> 259       _offset(-1),</span>
<span class="line-removed"> 260       _freq(freq),</span>
<span class="line-removed"> 261       _can_be_reused(can_be_reused)</span>
<span class="line-removed"> 262     {</span>
<span class="line-removed"> 263       assert(type != T_METADATA, &quot;wrong constructor&quot;);</span>
<span class="line-removed"> 264       _v._value = value;</span>
<span class="line-removed"> 265     }</span>
<span class="line-removed"> 266     Constant(Metadata* metadata, bool can_be_reused = true) :</span>
<span class="line-removed"> 267       _type(T_METADATA),</span>
<span class="line-removed"> 268       _offset(-1),</span>
<span class="line-removed"> 269       _freq(0.0f),</span>
<span class="line-removed"> 270       _can_be_reused(can_be_reused)</span>
<span class="line-removed"> 271     {</span>
<span class="line-removed"> 272       _v._metadata = metadata;</span>
<span class="line-removed"> 273     }</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275     bool operator==(const Constant&amp; other);</span>
<span class="line-removed"> 276 </span>
<span class="line-removed"> 277     BasicType type()      const    { return _type; }</span>
<span class="line-removed"> 278 </span>
<span class="line-removed"> 279     jint    get_jint()    const    { return _v._value.i; }</span>
<span class="line-removed"> 280     jlong   get_jlong()   const    { return _v._value.j; }</span>
<span class="line-removed"> 281     jfloat  get_jfloat()  const    { return _v._value.f; }</span>
<span class="line-removed"> 282     jdouble get_jdouble() const    { return _v._value.d; }</span>
<span class="line-removed"> 283     jobject get_jobject() const    { return _v._value.l; }</span>
<span class="line-removed"> 284 </span>
<span class="line-removed"> 285     Metadata* get_metadata() const { return _v._metadata; }</span>
<span class="line-removed"> 286 </span>
<span class="line-removed"> 287     int         offset()  const    { return _offset; }</span>
<span class="line-removed"> 288     void    set_offset(int offset) {        _offset = offset; }</span>
<span class="line-removed"> 289 </span>
<span class="line-removed"> 290     float       freq()    const    { return _freq;         }</span>
<span class="line-removed"> 291     void    inc_freq(float freq)   {        _freq += freq; }</span>
<span class="line-removed"> 292 </span>
<span class="line-removed"> 293     bool    can_be_reused() const  { return _can_be_reused; }</span>
<span class="line-removed"> 294   };</span>
<span class="line-removed"> 295 </span>
<span class="line-removed"> 296   // Constant table.</span>
<span class="line-removed"> 297   class ConstantTable {</span>
<span class="line-removed"> 298   private:</span>
<span class="line-removed"> 299     GrowableArray&lt;Constant&gt; _constants;          // Constants of this table.</span>
<span class="line-removed"> 300     int                     _size;               // Size in bytes the emitted constant table takes (including padding).</span>
<span class="line-removed"> 301     int                     _table_base_offset;  // Offset of the table base that gets added to the constant offsets.</span>
<span class="line-removed"> 302     int                     _nof_jump_tables;    // Number of jump-tables in this constant table.</span>
<span class="line-removed"> 303 </span>
<span class="line-removed"> 304     static int qsort_comparator(Constant* a, Constant* b);</span>
<span class="line-removed"> 305 </span>
<span class="line-removed"> 306     // We use negative frequencies to keep the order of the</span>
<span class="line-removed"> 307     // jump-tables in which they were added.  Otherwise we get into</span>
<span class="line-removed"> 308     // trouble with relocation.</span>
<span class="line-removed"> 309     float next_jump_table_freq() { return -1.0f * (++_nof_jump_tables); }</span>
<span class="line-removed"> 310 </span>
<span class="line-removed"> 311   public:</span>
<span class="line-removed"> 312     ConstantTable() :</span>
<span class="line-removed"> 313       _size(-1),</span>
<span class="line-removed"> 314       _table_base_offset(-1),  // We can use -1 here since the constant table is always bigger than 2 bytes (-(size / 2), see MachConstantBaseNode::emit).</span>
<span class="line-removed"> 315       _nof_jump_tables(0)</span>
<span class="line-removed"> 316     {}</span>
<span class="line-removed"> 317 </span>
<span class="line-removed"> 318     int size() const { assert(_size != -1, &quot;not calculated yet&quot;); return _size; }</span>
<span class="line-removed"> 319 </span>
<span class="line-removed"> 320     int calculate_table_base_offset() const;  // AD specific</span>
<span class="line-removed"> 321     void set_table_base_offset(int x)  { assert(_table_base_offset == -1 || x == _table_base_offset, &quot;can&#39;t change&quot;); _table_base_offset = x; }</span>
<span class="line-removed"> 322     int      table_base_offset() const { assert(_table_base_offset != -1, &quot;not set yet&quot;);                      return _table_base_offset; }</span>
<span class="line-removed"> 323 </span>
<span class="line-removed"> 324     void emit(CodeBuffer&amp; cb);</span>
<span class="line-removed"> 325 </span>
<span class="line-removed"> 326     // Returns the offset of the last entry (the top) of the constant table.</span>
<span class="line-removed"> 327     int  top_offset() const { assert(_constants.top().offset() != -1, &quot;not bound yet&quot;); return _constants.top().offset(); }</span>
<span class="line-removed"> 328 </span>
<span class="line-removed"> 329     void calculate_offsets_and_size();</span>
<span class="line-removed"> 330     int  find_offset(Constant&amp; con) const;</span>
<span class="line-removed"> 331 </span>
<span class="line-removed"> 332     void     add(Constant&amp; con);</span>
<span class="line-removed"> 333     Constant add(MachConstantNode* n, BasicType type, jvalue value);</span>
<span class="line-removed"> 334     Constant add(Metadata* metadata);</span>
<span class="line-removed"> 335     Constant add(MachConstantNode* n, MachOper* oper);</span>
<span class="line-removed"> 336     Constant add(MachConstantNode* n, jint i) {</span>
<span class="line-removed"> 337       jvalue value; value.i = i;</span>
<span class="line-removed"> 338       return add(n, T_INT, value);</span>
<span class="line-removed"> 339     }</span>
<span class="line-removed"> 340     Constant add(MachConstantNode* n, jlong j) {</span>
<span class="line-removed"> 341       jvalue value; value.j = j;</span>
<span class="line-removed"> 342       return add(n, T_LONG, value);</span>
<span class="line-removed"> 343     }</span>
<span class="line-removed"> 344     Constant add(MachConstantNode* n, jfloat f) {</span>
<span class="line-removed"> 345       jvalue value; value.f = f;</span>
<span class="line-removed"> 346       return add(n, T_FLOAT, value);</span>
<span class="line-removed"> 347     }</span>
<span class="line-removed"> 348     Constant add(MachConstantNode* n, jdouble d) {</span>
<span class="line-removed"> 349       jvalue value; value.d = d;</span>
<span class="line-removed"> 350       return add(n, T_DOUBLE, value);</span>
<span class="line-removed"> 351     }</span>
<span class="line-removed"> 352 </span>
<span class="line-removed"> 353     // Jump-table</span>
<span class="line-removed"> 354     Constant  add_jump_table(MachConstantNode* n);</span>
<span class="line-removed"> 355     void     fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const;</span>
<span class="line-removed"> 356   };</span>
<span class="line-removed"> 357 </span>
 358  private:
 359   // Fixed parameters to this compilation.
 360   const int             _compile_id;
 361   const bool            _save_argument_registers; // save/restore arg regs for trampolines
 362   const bool            _subsume_loads;         // Load can be matched as part of a larger op.
 363   const bool            _do_escape_analysis;    // Do escape analysis.
 364   const bool            _eliminate_boxing;      // Do boxing elimination.
 365   ciMethod*             _method;                // The method being compiled.
 366   int                   _entry_bci;             // entry bci for osr methods.
 367   const TypeFunc*       _tf;                    // My kind of signature
 368   InlineTree*           _ilt;                   // Ditto (temporary).
 369   address               _stub_function;         // VM entry for stub being compiled, or NULL
 370   const char*           _stub_name;             // Name of stub or adapter being compiled, or NULL
 371   address               _stub_entry_point;      // Compile code entry for generated stub, or NULL
 372 
 373   // Control of this compilation.
 374   int                   _max_inline_size;       // Max inline size for this compilation
 375   int                   _freq_inline_size;      // Max hot method inline size for this compilation
 376   int                   _fixed_slots;           // count of frame slots not allocated by the register
 377                                                 // allocator i.e. locks, original deopt pc, etc.
 378   uintx                 _max_node_limit;        // Max unique node count during a single compilation.
<span class="line-removed"> 379   // For deopt</span>
<span class="line-removed"> 380   int                   _orig_pc_slot;</span>
<span class="line-removed"> 381   int                   _orig_pc_slot_offset_in_bytes;</span>
 382 
 383   int                   _major_progress;        // Count of something big happening
 384   bool                  _inlining_progress;     // progress doing incremental inlining?
 385   bool                  _inlining_incrementally;// Are we doing incremental inlining (post parse)
 386   bool                  _do_cleanup;            // Cleanup is needed before proceeding with incremental inlining
 387   bool                  _has_loops;             // True if the method _may_ have some loops
 388   bool                  _has_split_ifs;         // True if the method _may_ have some split-if
 389   bool                  _has_unsafe_access;     // True if the method _may_ produce faults in unsafe loads or stores.
 390   bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
 391   bool                  _has_boxed_value;       // True if a boxed object is allocated
 392   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 393   uint                  _max_vector_size;       // Maximum size of generated vectors
 394   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 395   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 396   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 397   uint                  _decompile_count;       // Cumulative decompilation counts.
 398   bool                  _do_inlining;           // True if we intend to do inlining
 399   bool                  _do_scheduling;         // True if we intend to do scheduling
 400   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 401   bool                  _do_count_invocations;  // True if we generate code to count invocations
</pre>
<hr />
<pre>
 440 
 441   // Node management
 442   uint                  _unique;                // Counter for unique Node indices
 443   VectorSet             _dead_node_list;        // Set of dead nodes
 444   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 445                                                 // So use this to keep count and make the call O(1).
 446   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 447 
 448   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 449   Arena                 _node_arena;            // Arena for new-space Nodes
 450   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 451   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 452   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 453 
 454   Node*                 _immutable_memory;      // Initial memory state
 455 
 456   Node*                 _recent_alloc_obj;
 457   Node*                 _recent_alloc_ctl;
 458 
 459   // Constant table
<span class="line-removed"> 460   ConstantTable         _constant_table;        // The constant table for this compile.</span>
 461   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 462 
 463 
 464   // Blocked array of debugging and profiling information,
 465   // tracked per node.
 466   enum { _log2_node_notes_block_size = 8,
 467          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 468   };
 469   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 470   Node_Notes*           _default_node_notes;  // default notes for new nodes
 471 
 472   // After parsing and every bulk phase we hang onto the Root instruction.
 473   // The RootNode instruction is where the whole program begins.  It produces
 474   // the initial Control and BOTTOM for everybody else.
 475 
 476   // Type management
 477   Arena                 _Compile_types;         // Arena for all types
 478   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 479   Dict*                 _type_dict;             // Intern table
 480   CloneMap              _clone_map;             // used for recording history of cloned nodes
</pre>
<hr />
<pre>
 569 #ifndef PRODUCT
 570   IdealGraphPrinter* printer() { return _printer; }
 571 #endif
 572 
 573   void log_late_inline(CallGenerator* cg);
 574   void log_inline_id(CallGenerator* cg);
 575   void log_inline_failure(const char* msg);
 576 
 577   void* replay_inline_data() const { return _replay_inline_data; }
 578 
 579   // Dump inlining replay data to the stream.
 580   void dump_inline_data(outputStream* out);
 581 
 582  private:
 583   // Matching, CFG layout, allocation, code generation
 584   PhaseCFG*             _cfg;                   // Results of CFG finding
 585   int                   _java_calls;            // Number of java calls in the method
 586   int                   _inner_loops;           // Number of inner loops in the method
 587   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 588   PhaseRegAlloc*        _regalloc;              // Results of register allocation.
<span class="line-removed"> 589   int                   _frame_slots;           // Size of total frame in stack slots</span>
<span class="line-removed"> 590   CodeOffsets           _code_offsets;          // Offsets into the code for various interesting entries</span>
 591   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 592   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 593   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 594   int                   _interpreter_frame_size;
 595 
<span class="line-modified"> 596   uint                  _node_bundling_limit;</span>
<span class="line-removed"> 597   Bundle*               _node_bundling_base;    // Information for instruction bundling</span>
<span class="line-removed"> 598 </span>
<span class="line-removed"> 599   // Instruction bits passed off to the VM</span>
<span class="line-removed"> 600   int                   _method_size;           // Size of nmethod code segment in bytes</span>
<span class="line-removed"> 601   CodeBuffer            _code_buffer;           // Where the code is assembled</span>
<span class="line-removed"> 602   int                   _first_block_size;      // Size of unvalidated entry point code / OSR poison code</span>
<span class="line-removed"> 603   ExceptionHandlerTable _handler_table;         // Table of native-code exception handlers</span>
<span class="line-removed"> 604   ImplicitExceptionTable _inc_table;            // Table of implicit null checks in native code</span>
<span class="line-removed"> 605   OopMapSet*            _oop_map_set;           // Table of oop maps (one for each safepoint location)</span>
<span class="line-removed"> 606   BufferBlob*           _scratch_buffer_blob;   // For temporary code buffers.</span>
<span class="line-removed"> 607   relocInfo*            _scratch_locs_memory;   // For temporary code buffers.</span>
<span class="line-removed"> 608   int                   _scratch_const_size;    // For temporary code buffers.</span>
<span class="line-removed"> 609   bool                  _in_scratch_emit_size;  // true when in scratch_emit_size.</span>
 610 
 611   void reshape_address(AddPNode* n);
 612 
 613  public:
 614   // Accessors
 615 
 616   // The Compile instance currently active in this (compiler) thread.
 617   static Compile* current() {
 618     return (Compile*) ciEnv::current()-&gt;compiler_data();
 619   }
 620 





 621   // ID for this compilation.  Useful for setting breakpoints in the debugger.
 622   int               compile_id() const          { return _compile_id; }
 623   DirectiveSet*     directive() const           { return _directive; }
 624 
 625   // Does this compilation allow instructions to subsume loads?  User
 626   // instructions that subsume a load may result in an unschedulable
 627   // instruction sequence.
 628   bool              subsume_loads() const       { return _subsume_loads; }
 629   /** Do escape analysis. */
 630   bool              do_escape_analysis() const  { return _do_escape_analysis; }
 631   /** Do boxing elimination. */
 632   bool              eliminate_boxing() const    { return _eliminate_boxing; }
 633   /** Do aggressive boxing elimination. */
 634   bool              aggressive_unboxing() const { return _eliminate_boxing &amp;&amp; AggressiveUnboxing; }
 635   bool              save_argument_registers() const { return _save_argument_registers; }
 636 
 637 
 638   // Other fixed compilation parameters.
 639   ciMethod*         method() const              { return _method; }
 640   int               entry_bci() const           { return _entry_bci; }
 641   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 642   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 643   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 644   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 645   InlineTree*       ilt() const                 { return _ilt; }
 646   address           stub_function() const       { return _stub_function; }
 647   const char*       stub_name() const           { return _stub_name; }
 648   address           stub_entry_point() const    { return _stub_entry_point; }

 649 
 650   // Control of this compilation.
 651   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 652   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 653   int               major_progress() const      { return _major_progress; }
 654   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 655   int               inlining_progress() const   { return _inlining_progress; }
 656   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 657   int               inlining_incrementally() const { return _inlining_incrementally; }
 658   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 659   int               do_cleanup() const          { return _do_cleanup; }
 660   void          set_major_progress()            { _major_progress++; }
 661   void          restore_major_progress(int progress) { _major_progress += progress; }
 662   void        clear_major_progress()            { _major_progress = 0; }
 663   int               max_inline_size() const     { return _max_inline_size; }
 664   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 665   int               freq_inline_size() const    { return _freq_inline_size; }
 666   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 667   bool              has_loops() const           { return _has_loops; }
 668   void          set_has_loops(bool z)           { _has_loops = z; }
</pre>
<hr />
<pre>
 743   void begin_method() {
 744 #ifndef PRODUCT
 745     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 746       _printer-&gt;begin_method();
 747     }
 748 #endif
 749     C-&gt;_latest_stage_start_counter.stamp();
 750   }
 751 
 752   bool should_print(int level = 1) {
 753 #ifndef PRODUCT
 754     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 755 #else
 756     return false;
 757 #endif
 758   }
 759 
 760   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 761     EventCompilerPhase event;
 762     if (event.should_commit()) {
<span class="line-modified"> 763       event.set_starttime(C-&gt;_latest_stage_start_counter);</span>
<span class="line-removed"> 764       event.set_phase((u1) cpt);</span>
<span class="line-removed"> 765       event.set_compileId(C-&gt;_compile_id);</span>
<span class="line-removed"> 766       event.set_phaseLevel(level);</span>
<span class="line-removed"> 767       event.commit();</span>
 768     }
 769 
 770 #ifndef PRODUCT
 771     if (should_print(level)) {
 772       char output[1024];
 773       if (idx != 0) {
 774         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);
 775       } else {
 776         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));
 777       }
 778       _printer-&gt;print_method(output, level);
 779     }
 780 #endif
 781     C-&gt;_latest_stage_start_counter.stamp();
 782   }
 783 
 784   void end_method(int level = 1) {
 785     EventCompilerPhase event;
 786     if (event.should_commit()) {
<span class="line-modified"> 787       event.set_starttime(C-&gt;_latest_stage_start_counter);</span>
<span class="line-removed"> 788       event.set_phase((u1) PHASE_END);</span>
<span class="line-removed"> 789       event.set_compileId(C-&gt;_compile_id);</span>
<span class="line-removed"> 790       event.set_phaseLevel(level);</span>
<span class="line-removed"> 791       event.commit();</span>
 792     }

 793 #ifndef PRODUCT
 794     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 795       _printer-&gt;end_method();
 796     }
 797 #endif
 798   }
 799 
 800   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 801   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 802   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 803   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 804   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 805   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 806   ConnectionGraph* congraph()                   { return _congraph;}
 807   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 808   void add_macro_node(Node * n) {
 809     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 810     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 811     _macro_nodes-&gt;append(n);
 812   }
</pre>
<hr />
<pre>
 837   void remove_range_check_cast(Node* n) {
 838     if (_range_check_casts-&gt;contains(n)) {
 839       _range_check_casts-&gt;remove(n);
 840     }
 841   }
 842   Node* range_check_cast_node(int idx) const { return _range_check_casts-&gt;at(idx);  }
 843   int   range_check_cast_count()       const { return _range_check_casts-&gt;length(); }
 844   // Remove all range check dependent CastIINodes.
 845   void  remove_range_check_casts(PhaseIterGVN &amp;igvn);
 846 
 847   void add_opaque4_node(Node* n);
 848   void remove_opaque4_node(Node* n) {
 849     if (_opaque4_nodes-&gt;contains(n)) {
 850       _opaque4_nodes-&gt;remove(n);
 851     }
 852   }
 853   Node* opaque4_node(int idx) const { return _opaque4_nodes-&gt;at(idx);  }
 854   int   opaque4_count()       const { return _opaque4_nodes-&gt;length(); }
 855   void  remove_opaque4_nodes(PhaseIterGVN &amp;igvn);
 856 


 857   // remove the opaque nodes that protect the predicates so that the unused checks and
 858   // uncommon traps will be eliminated from the graph.
 859   void cleanup_loop_predicates(PhaseIterGVN &amp;igvn);
 860   bool is_predicate_opaq(Node * n) {
 861     return _predicate_opaqs-&gt;contains(n);
 862   }
 863 
 864   // Are there candidate expensive nodes for optimization?
 865   bool should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn);
 866   // Check whether n1 and n2 are similar
 867   static int cmp_expensive_nodes(Node* n1, Node* n2);
 868   // Sort expensive nodes to locate similar expensive nodes
 869   void sort_expensive_nodes();
 870 
 871   // Compilation environment.
 872   Arena*      comp_arena()           { return &amp;_comp_arena; }
 873   ciEnv*      env() const            { return _env; }
 874   CompileLog* log() const            { return _log; }
 875   bool        failing() const        { return _env-&gt;failing() || _failure_reason != NULL; }
 876   const char* failure_reason() const { return (_env-&gt;failing()) ? _env-&gt;failure_reason() : _failure_reason; }
</pre>
<hr />
<pre>
 919                                              _dead_node_count++;
 920                                            }
 921   void         reset_dead_node_list()      { _dead_node_list.reset();
 922                                              _dead_node_count = 0;
 923                                            }
 924   uint          live_nodes() const         {
 925     int  val = _unique - _dead_node_count;
 926     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 927             return (uint) val;
 928                                            }
 929 #ifdef ASSERT
 930   uint         count_live_nodes_by_graph_walk();
 931   void         print_missing_nodes();
 932 #endif
 933 
 934   // Record modified nodes to check that they are put on IGVN worklist
 935   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 936   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 937   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 938 
<span class="line-removed"> 939   // Constant table</span>
<span class="line-removed"> 940   ConstantTable&amp;   constant_table() { return _constant_table; }</span>
<span class="line-removed"> 941 </span>
 942   MachConstantBaseNode*     mach_constant_base_node();
 943   bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }
 944   // Generated by adlc, true if CallNode requires MachConstantBase.
 945   bool                      needs_clone_jvms();
 946 
 947   // Handy undefined Node
 948   Node*             top() const                 { return _top; }
 949 
 950   // these are used by guys who need to know about creation and transformation of top:
 951   Node*             cached_top_node()           { return _top; }
 952   void          set_cached_top_node(Node* tn);
 953 
 954   GrowableArray&lt;Node_Notes*&gt;* node_note_array() const { return _node_note_array; }
 955   void set_node_note_array(GrowableArray&lt;Node_Notes*&gt;* arr) { _node_note_array = arr; }
 956   Node_Notes* default_node_notes() const        { return _default_node_notes; }
 957   void    set_default_node_notes(Node_Notes* n) { _default_node_notes = n; }
 958 
 959   Node_Notes*       node_notes_at(int idx) {
 960     return locate_node_notes(_node_note_array, idx, false);
 961   }
</pre>
<hr />
<pre>
1107 
1108   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
1109   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
1110   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
1111 
1112   bool inline_incrementally_one();
1113   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
1114   void inline_incrementally(PhaseIterGVN&amp; igvn);
1115   void inline_string_calls(bool parse_time);
1116   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
1117   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
1118   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
1119 
1120   // Matching, CFG layout, allocation, code generation
1121   PhaseCFG*         cfg()                       { return _cfg; }
1122   bool              has_java_calls() const      { return _java_calls &gt; 0; }
1123   int               java_calls() const          { return _java_calls; }
1124   int               inner_loops() const         { return _inner_loops; }
1125   Matcher*          matcher()                   { return _matcher; }
1126   PhaseRegAlloc*    regalloc()                  { return _regalloc; }
<span class="line-removed">1127   int               frame_slots() const         { return _frame_slots; }</span>
<span class="line-removed">1128   int               frame_size_in_words() const; // frame_slots in units of the polymorphic &#39;words&#39;</span>
<span class="line-removed">1129   int               frame_size_in_bytes() const { return _frame_slots &lt;&lt; LogBytesPerInt; }</span>
1130   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
1131   Arena*            indexSet_arena()            { return _indexSet_arena; }
1132   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
<span class="line-modified">1133   uint              node_bundling_limit()       { return _node_bundling_limit; }</span>
<span class="line-removed">1134   Bundle*           node_bundling_base()        { return _node_bundling_base; }</span>
<span class="line-removed">1135   void          set_node_bundling_limit(uint n) { _node_bundling_limit = n; }</span>
<span class="line-removed">1136   void          set_node_bundling_base(Bundle* b) { _node_bundling_base = b; }</span>
<span class="line-removed">1137   bool          starts_bundle(const Node *n) const;</span>
<span class="line-removed">1138   bool          need_stack_bang(int frame_size_in_bytes) const;</span>
<span class="line-removed">1139   bool          need_register_stack_bang() const;</span>
1140 
1141   void  update_interpreter_frame_size(int size) {
1142     if (_interpreter_frame_size &lt; size) {
1143       _interpreter_frame_size = size;
1144     }
1145   }
<span class="line-removed">1146   int           bang_size_in_bytes() const;</span>
1147 
1148   void          set_matcher(Matcher* m)                 { _matcher = m; }
1149 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1150   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1151   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1152 
1153   void  set_java_calls(int z) { _java_calls  = z; }
1154   void set_inner_loops(int z) { _inner_loops = z; }
1155 
<span class="line-modified">1156   // Instruction bits passed off to the VM</span>
<span class="line-removed">1157   int               code_size()                 { return _method_size; }</span>
<span class="line-removed">1158   CodeBuffer*       code_buffer()               { return &amp;_code_buffer; }</span>
<span class="line-removed">1159   int               first_block_size()          { return _first_block_size; }</span>
<span class="line-removed">1160   void              set_frame_complete(int off) { if (!in_scratch_emit_size()) { _code_offsets.set_value(CodeOffsets::Frame_Complete, off); } }</span>
<span class="line-removed">1161   ExceptionHandlerTable*  handler_table()       { return &amp;_handler_table; }</span>
<span class="line-removed">1162   ImplicitExceptionTable* inc_table()           { return &amp;_inc_table; }</span>
<span class="line-removed">1163   OopMapSet*        oop_map_set()               { return _oop_map_set; }</span>
<span class="line-removed">1164   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }</span>
<span class="line-removed">1165   Dependencies*     dependencies()              { return env()-&gt;dependencies(); }</span>
<span class="line-removed">1166   BufferBlob*       scratch_buffer_blob()       { return _scratch_buffer_blob; }</span>
<span class="line-removed">1167   void         init_scratch_buffer_blob(int const_size);</span>
<span class="line-removed">1168   void        clear_scratch_buffer_blob();</span>
<span class="line-removed">1169   void          set_scratch_buffer_blob(BufferBlob* b) { _scratch_buffer_blob = b; }</span>
<span class="line-removed">1170   relocInfo*        scratch_locs_memory()       { return _scratch_locs_memory; }</span>
<span class="line-removed">1171   void          set_scratch_locs_memory(relocInfo* b)  { _scratch_locs_memory = b; }</span>
<span class="line-removed">1172 </span>
<span class="line-removed">1173   // emit to scratch blob, report resulting size</span>
<span class="line-removed">1174   uint              scratch_emit_size(const Node* n);</span>
<span class="line-removed">1175   void       set_in_scratch_emit_size(bool x)   {        _in_scratch_emit_size = x; }</span>
<span class="line-removed">1176   bool           in_scratch_emit_size() const   { return _in_scratch_emit_size;     }</span>
<span class="line-removed">1177 </span>
<span class="line-removed">1178   enum ScratchBufferBlob {</span>
<span class="line-removed">1179     MAX_inst_size       = 2048,</span>
<span class="line-removed">1180     MAX_locs_size       = 128, // number of relocInfo elements</span>
<span class="line-removed">1181     MAX_const_size      = 128,</span>
<span class="line-removed">1182     MAX_stubs_size      = 128</span>
<span class="line-removed">1183   };</span>
1184 
1185   // Major entry point.  Given a Scope, compile the associated method.
1186   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1187   // replacement, entry_bci indicates the bytecode for which to compile a
1188   // continuation.
<span class="line-modified">1189   Compile(ciEnv* ci_env, C2Compiler* compiler, ciMethod* target,</span>
1190           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1191           bool eliminate_boxing, DirectiveSet* directive);
1192 
1193   // Second major entry point.  From the TypeFunc signature, generate code
1194   // to pass arguments from the Java calling convention to the C calling
1195   // convention.
1196   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1197           address stub_function, const char *stub_name,
1198           int is_fancy_jump, bool pass_tls,
1199           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1200 
1201   // From the TypeFunc signature, generate code to pass arguments
1202   // from Compiled calling convention to Interpreter&#39;s calling convention
1203   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
1204 
1205   // From the TypeFunc signature, generate code to pass arguments
1206   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention
1207   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
1208 
1209   // Are we compiling a method?
1210   bool has_method() { return method() != NULL; }
1211 
1212   // Maybe print some information about this compile.
1213   void print_compile_messages();
1214 
1215   // Final graph reshaping, a post-pass after the regular optimizer is done.
1216   bool final_graph_reshaping();
1217 
1218   // returns true if adr is completely contained in the given alias category
1219   bool must_alias(const TypePtr* adr, int alias_idx);
1220 
1221   // returns true if adr overlaps with the given alias category
1222   bool can_alias(const TypePtr* adr, int alias_idx);
1223 
<span class="line-removed">1224   // Driver for converting compiler&#39;s IR into machine code bits</span>
<span class="line-removed">1225   void Output();</span>
<span class="line-removed">1226 </span>
<span class="line-removed">1227   // Accessors for node bundling info.</span>
<span class="line-removed">1228   Bundle* node_bundling(const Node *n);</span>
<span class="line-removed">1229   bool valid_bundle_info(const Node *n);</span>
<span class="line-removed">1230 </span>
<span class="line-removed">1231   // Schedule and Bundle the instructions</span>
<span class="line-removed">1232   void ScheduleAndBundle();</span>
<span class="line-removed">1233 </span>
<span class="line-removed">1234   // Build OopMaps for each GC point</span>
<span class="line-removed">1235   void BuildOopMaps();</span>
<span class="line-removed">1236 </span>
<span class="line-removed">1237   // Append debug info for the node &quot;local&quot; at safepoint node &quot;sfpt&quot; to the</span>
<span class="line-removed">1238   // &quot;array&quot;,   May also consult and add to &quot;objs&quot;, which describes the</span>
<span class="line-removed">1239   // scalar-replaced objects.</span>
<span class="line-removed">1240   void FillLocArray( int idx, MachSafePointNode* sfpt,</span>
<span class="line-removed">1241                      Node *local, GrowableArray&lt;ScopeValue*&gt; *array,</span>
<span class="line-removed">1242                      GrowableArray&lt;ScopeValue*&gt; *objs );</span>
<span class="line-removed">1243 </span>
1244   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1245   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);
<span class="line-removed">1246   // Requres that &quot;objs&quot; does not contains an ObjectValue whose id matches</span>
<span class="line-removed">1247   // that of &quot;sv.  Appends &quot;sv&quot;.</span>
<span class="line-removed">1248   static void set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
<span class="line-removed">1249                                      ObjectValue* sv );</span>
<span class="line-removed">1250 </span>
<span class="line-removed">1251   // Process an OopMap Element while emitting nodes</span>
<span class="line-removed">1252   void Process_OopMap_Node(MachNode *mach, int code_offset);</span>
<span class="line-removed">1253 </span>
<span class="line-removed">1254   class BufferSizingData {</span>
<span class="line-removed">1255   public:</span>
<span class="line-removed">1256     int _stub;</span>
<span class="line-removed">1257     int _code;</span>
<span class="line-removed">1258     int _const;</span>
<span class="line-removed">1259     int _reloc;</span>
<span class="line-removed">1260 </span>
<span class="line-removed">1261       BufferSizingData() :</span>
<span class="line-removed">1262       _stub(0),</span>
<span class="line-removed">1263       _code(0),</span>
<span class="line-removed">1264       _const(0),</span>
<span class="line-removed">1265       _reloc(0)</span>
<span class="line-removed">1266       { };</span>
<span class="line-removed">1267   };</span>
<span class="line-removed">1268 </span>
<span class="line-removed">1269   // Initialize code buffer</span>
<span class="line-removed">1270   void        estimate_buffer_size(int&amp; const_req);</span>
<span class="line-removed">1271   CodeBuffer* init_buffer(BufferSizingData&amp; buf_sizes);</span>
<span class="line-removed">1272 </span>
<span class="line-removed">1273   // Write out basic block data to code buffer</span>
<span class="line-removed">1274   void fill_buffer(CodeBuffer* cb, uint* blk_starts);</span>
<span class="line-removed">1275 </span>
<span class="line-removed">1276   // Determine which variable sized branches can be shortened</span>
<span class="line-removed">1277   void shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes);</span>
<span class="line-removed">1278 </span>
<span class="line-removed">1279   // Compute the size of first NumberOfLoopInstrToAlign instructions</span>
<span class="line-removed">1280   // at the head of a loop.</span>
<span class="line-removed">1281   void compute_loop_first_inst_sizes();</span>
<span class="line-removed">1282 </span>
<span class="line-removed">1283   // Compute the information for the exception tables</span>
<span class="line-removed">1284   void FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels);</span>
1285 
1286   // Stack slots that may be unused by the calling convention but must
1287   // otherwise be preserved.  On Intel this includes the return address.
1288   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1289   uint in_preserve_stack_slots();
1290 
1291   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1292   // otherwise be preserved.
1293   // On Intel these are not necessary and the value can be zero.
1294   // On Sparc this describes the words reserved for storing a register window
1295   // when an interrupt occurs.
1296   static uint out_preserve_stack_slots();
1297 
1298   // Number of outgoing stack slots killed above the out_preserve_stack_slots
1299   // for calls to C.  Supports the var-args backing area for register parms.
1300   uint varargs_C_out_slots_killed() const;
1301 
1302   // Number of Stack Slots consumed by a synchronization entry
1303   int sync_stack_slots() const;
1304 
</pre>
<hr />
<pre>
1322   void verify_top(Node*) const PRODUCT_RETURN;
1323 
1324   // Intrinsic setup.
1325   void           register_library_intrinsics();                            // initializer
1326   CallGenerator* make_vm_intrinsic(ciMethod* m, bool is_virtual);          // constructor
1327   int            intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found);  // helper
1328   CallGenerator* find_intrinsic(ciMethod* m, bool is_virtual);             // query fn
1329   void           register_intrinsic(CallGenerator* cg);                    // update fn
1330 
1331 #ifndef PRODUCT
1332   static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];
1333   static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];
1334 #endif
1335   // Function calls made by the public function final_graph_reshaping.
1336   // No need to be made public as they are not called elsewhere.
1337   void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc);
1338   void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop);
1339   void final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc );
1340   void eliminate_redundant_card_marks(Node* n);
1341 









1342  public:
1343 
1344   // Note:  Histogram array size is about 1 Kb.
1345   enum {                        // flag bits:
1346     _intrinsic_worked = 1,      // succeeded at least once
1347     _intrinsic_failed = 2,      // tried it but it failed
1348     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1349     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1350     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1351   };
1352   // Update histogram.  Return boolean if this is a first-time occurrence.
1353   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1354                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1355   static void print_intrinsic_statistics() PRODUCT_RETURN;
1356 
1357   // Graph verification code
1358   // Walk the node list, verifying that there is a one-to-one
1359   // correspondence between Use-Def edges and Def-Use edges
1360   // The option no_dead_code enables stronger checks that the
1361   // graph is strongly connected from root in both directions.
1362   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1363 
1364   // End-of-run dumps.
1365   static void print_statistics() PRODUCT_RETURN;
1366 
<span class="line-removed">1367   // Dump formatted assembly</span>
<span class="line-removed">1368 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">1369   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit);</span>
<span class="line-removed">1370   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { dump_asm_on(tty, pcs, pc_limit); }</span>
<span class="line-removed">1371 #else</span>
<span class="line-removed">1372   void dump_asm_on(outputStream* ost, int* pcs, uint pc_limit) { return; }</span>
<span class="line-removed">1373   void dump_asm(int* pcs = NULL, uint pc_limit = 0) { return; }</span>
<span class="line-removed">1374 #endif</span>
<span class="line-removed">1375   void dump_pc(int *pcs, int pc_limit, Node *n);</span>
<span class="line-removed">1376 </span>
1377   // Verify ADLC assumptions during startup
1378   static void adlc_verification() PRODUCT_RETURN;
1379 
1380   // Definitions of pd methods
1381   static void pd_compiler2_init();
1382 
1383   // Static parse-time type checking logic for gen_subtype_check:
1384   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1385   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1386 
1387   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1388                               // Optional control dependency (for example, on range check)
1389                               Node* ctrl = NULL);
1390 
1391   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1392   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1393 
1394   // Auxiliary method for randomized fuzzing/stressing
1395   static bool randomized_select(int count);
1396 
</pre>
<hr />
<pre>
1400 
1401   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);
1402   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);
1403   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);
1404 
1405 #ifdef IA32
1406  private:
1407   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result
1408   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results
1409 
1410   // Remember if this compilation changes hardware mode to 24-bit precision.
1411   void set_24_bit_selection_and_mode(bool selection, bool mode) {
1412     _select_24_bit_instr = selection;
1413     _in_24_bit_fp_mode   = mode;
1414   }
1415 
1416  public:
1417   bool select_24_bit_instr() const { return _select_24_bit_instr; }
1418   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }
1419 #endif // IA32



1420 };
1421 
1422 #endif // SHARE_OPTO_COMPILE_HPP
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 1997, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #ifndef SHARE_OPTO_COMPILE_HPP
  26 #define SHARE_OPTO_COMPILE_HPP
  27 
  28 #include &quot;asm/codeBuffer.hpp&quot;
  29 #include &quot;ci/compilerInterface.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;

  31 #include &quot;compiler/compilerOracle.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
<span class="line-added">  33 #include &quot;compiler/compilerEvent.hpp&quot;</span>
  34 #include &quot;libadt/dict.hpp&quot;
  35 #include &quot;libadt/vectset.hpp&quot;

  36 #include &quot;memory/resourceArea.hpp&quot;
  37 #include &quot;oops/methodData.hpp&quot;
  38 #include &quot;opto/idealGraphPrinter.hpp&quot;
  39 #include &quot;opto/phasetype.hpp&quot;
  40 #include &quot;opto/phase.hpp&quot;
  41 #include &quot;opto/regmask.hpp&quot;
  42 #include &quot;runtime/deoptimization.hpp&quot;
  43 #include &quot;runtime/timerTrace.hpp&quot;
  44 #include &quot;runtime/vmThread.hpp&quot;
  45 #include &quot;utilities/ticks.hpp&quot;
  46 
  47 class AddPNode;
  48 class Block;
  49 class Bundle;

  50 class CallGenerator;
  51 class CloneMap;
  52 class ConnectionGraph;
  53 class IdealGraphPrinter;
  54 class InlineTree;
  55 class Int_Array;
  56 class Matcher;
  57 class MachConstantNode;
  58 class MachConstantBaseNode;
  59 class MachNode;
  60 class MachOper;
  61 class MachSafePointNode;
  62 class Node;
  63 class Node_Array;
  64 class Node_Notes;
  65 class NodeCloneInfo;
  66 class OptoReg;
  67 class PhaseCFG;
  68 class PhaseGVN;
  69 class PhaseIterGVN;
  70 class PhaseRegAlloc;
  71 class PhaseCCP;
  72 class PhaseCCP_DCE;
<span class="line-added">  73 class PhaseOutput;</span>
  74 class RootNode;
  75 class relocInfo;
  76 class Scope;
  77 class StartNode;
  78 class SafePointNode;
  79 class JVMState;
  80 class Type;
  81 class TypeData;
  82 class TypeInt;
  83 class TypePtr;
  84 class TypeOopPtr;
  85 class TypeFunc;
<span class="line-added">  86 class TypeVect;</span>
  87 class Unique_Node_List;
  88 class nmethod;
  89 class WarmCallInfo;
  90 class Node_Stack;
  91 struct Final_Reshape_Counts;
  92 
  93 enum LoopOptsMode {
  94   LoopOptsDefault,
  95   LoopOptsNone,
  96   LoopOptsMaxUnroll,
  97   LoopOptsShenandoahExpand,
  98   LoopOptsShenandoahPostExpand,
  99   LoopOptsSkipSplitIf,
 100   LoopOptsVerify
 101 };
 102 
 103 typedef unsigned int node_idx_t;
 104 class NodeCloneInfo {
 105  private:
 106   uint64_t _idx_clone_orig;
</pre>
<hr />
<pre>
 223     }
 224     void set_element(const Type* e) {
 225       assert(_element == NULL, &quot;&quot;);
 226       _element = e;
 227     }
 228 
 229     BasicType basic_type() const;
 230 
 231     void print_on(outputStream* st) PRODUCT_RETURN;
 232   };
 233 
 234   enum {
 235     logAliasCacheSize = 6,
 236     AliasCacheSize = (1&lt;&lt;logAliasCacheSize)
 237   };
 238   struct AliasCacheEntry { const TypePtr* _adr_type; int _index; };  // simple duple type
 239   enum {
 240     trapHistLength = MethodData::_trap_hist_limit
 241   };
 242 



















































































































 243  private:
 244   // Fixed parameters to this compilation.
 245   const int             _compile_id;
 246   const bool            _save_argument_registers; // save/restore arg regs for trampolines
 247   const bool            _subsume_loads;         // Load can be matched as part of a larger op.
 248   const bool            _do_escape_analysis;    // Do escape analysis.
 249   const bool            _eliminate_boxing;      // Do boxing elimination.
 250   ciMethod*             _method;                // The method being compiled.
 251   int                   _entry_bci;             // entry bci for osr methods.
 252   const TypeFunc*       _tf;                    // My kind of signature
 253   InlineTree*           _ilt;                   // Ditto (temporary).
 254   address               _stub_function;         // VM entry for stub being compiled, or NULL
 255   const char*           _stub_name;             // Name of stub or adapter being compiled, or NULL
 256   address               _stub_entry_point;      // Compile code entry for generated stub, or NULL
 257 
 258   // Control of this compilation.
 259   int                   _max_inline_size;       // Max inline size for this compilation
 260   int                   _freq_inline_size;      // Max hot method inline size for this compilation
 261   int                   _fixed_slots;           // count of frame slots not allocated by the register
 262                                                 // allocator i.e. locks, original deopt pc, etc.
 263   uintx                 _max_node_limit;        // Max unique node count during a single compilation.



 264 
 265   int                   _major_progress;        // Count of something big happening
 266   bool                  _inlining_progress;     // progress doing incremental inlining?
 267   bool                  _inlining_incrementally;// Are we doing incremental inlining (post parse)
 268   bool                  _do_cleanup;            // Cleanup is needed before proceeding with incremental inlining
 269   bool                  _has_loops;             // True if the method _may_ have some loops
 270   bool                  _has_split_ifs;         // True if the method _may_ have some split-if
 271   bool                  _has_unsafe_access;     // True if the method _may_ produce faults in unsafe loads or stores.
 272   bool                  _has_stringbuilder;     // True StringBuffers or StringBuilders are allocated
 273   bool                  _has_boxed_value;       // True if a boxed object is allocated
 274   bool                  _has_reserved_stack_access; // True if the method or an inlined method is annotated with ReservedStackAccess
 275   uint                  _max_vector_size;       // Maximum size of generated vectors
 276   bool                  _clear_upper_avx;       // Clear upper bits of ymm registers using vzeroupper
 277   uint                  _trap_hist[trapHistLength];  // Cumulative traps
 278   bool                  _trap_can_recompile;    // Have we emitted a recompiling trap?
 279   uint                  _decompile_count;       // Cumulative decompilation counts.
 280   bool                  _do_inlining;           // True if we intend to do inlining
 281   bool                  _do_scheduling;         // True if we intend to do scheduling
 282   bool                  _do_freq_based_layout;  // True if we intend to do frequency based block layout
 283   bool                  _do_count_invocations;  // True if we generate code to count invocations
</pre>
<hr />
<pre>
 322 
 323   // Node management
 324   uint                  _unique;                // Counter for unique Node indices
 325   VectorSet             _dead_node_list;        // Set of dead nodes
 326   uint                  _dead_node_count;       // Number of dead nodes; VectorSet::Size() is O(N).
 327                                                 // So use this to keep count and make the call O(1).
 328   DEBUG_ONLY( Unique_Node_List* _modified_nodes; )  // List of nodes which inputs were modified
 329 
 330   debug_only(static int _debug_idx;)            // Monotonic counter (not reset), use -XX:BreakAtNode=&lt;idx&gt;
 331   Arena                 _node_arena;            // Arena for new-space Nodes
 332   Arena                 _old_arena;             // Arena for old-space Nodes, lifetime during xform
 333   RootNode*             _root;                  // Unique root of compilation, or NULL after bail-out.
 334   Node*                 _top;                   // Unique top node.  (Reset by various phases.)
 335 
 336   Node*                 _immutable_memory;      // Initial memory state
 337 
 338   Node*                 _recent_alloc_obj;
 339   Node*                 _recent_alloc_ctl;
 340 
 341   // Constant table

 342   MachConstantBaseNode* _mach_constant_base_node;  // Constant table base node singleton.
 343 
 344 
 345   // Blocked array of debugging and profiling information,
 346   // tracked per node.
 347   enum { _log2_node_notes_block_size = 8,
 348          _node_notes_block_size = (1&lt;&lt;_log2_node_notes_block_size)
 349   };
 350   GrowableArray&lt;Node_Notes*&gt;* _node_note_array;
 351   Node_Notes*           _default_node_notes;  // default notes for new nodes
 352 
 353   // After parsing and every bulk phase we hang onto the Root instruction.
 354   // The RootNode instruction is where the whole program begins.  It produces
 355   // the initial Control and BOTTOM for everybody else.
 356 
 357   // Type management
 358   Arena                 _Compile_types;         // Arena for all types
 359   Arena*                _type_arena;            // Alias for _Compile_types except in Initialize_shared()
 360   Dict*                 _type_dict;             // Intern table
 361   CloneMap              _clone_map;             // used for recording history of cloned nodes
</pre>
<hr />
<pre>
 450 #ifndef PRODUCT
 451   IdealGraphPrinter* printer() { return _printer; }
 452 #endif
 453 
 454   void log_late_inline(CallGenerator* cg);
 455   void log_inline_id(CallGenerator* cg);
 456   void log_inline_failure(const char* msg);
 457 
 458   void* replay_inline_data() const { return _replay_inline_data; }
 459 
 460   // Dump inlining replay data to the stream.
 461   void dump_inline_data(outputStream* out);
 462 
 463  private:
 464   // Matching, CFG layout, allocation, code generation
 465   PhaseCFG*             _cfg;                   // Results of CFG finding
 466   int                   _java_calls;            // Number of java calls in the method
 467   int                   _inner_loops;           // Number of inner loops in the method
 468   Matcher*              _matcher;               // Engine to map ideal to machine instructions
 469   PhaseRegAlloc*        _regalloc;              // Results of register allocation.


 470   RegMask               _FIRST_STACK_mask;      // All stack slots usable for spills (depends on frame layout)
 471   Arena*                _indexSet_arena;        // control IndexSet allocation within PhaseChaitin
 472   void*                 _indexSet_free_block_list; // free list of IndexSet bit blocks
 473   int                   _interpreter_frame_size;
 474 
<span class="line-modified"> 475   PhaseOutput*          _output;</span>













 476 
 477   void reshape_address(AddPNode* n);
 478 
 479  public:
 480   // Accessors
 481 
 482   // The Compile instance currently active in this (compiler) thread.
 483   static Compile* current() {
 484     return (Compile*) ciEnv::current()-&gt;compiler_data();
 485   }
 486 
<span class="line-added"> 487   int interpreter_frame_size() const            { return _interpreter_frame_size; }</span>
<span class="line-added"> 488 </span>
<span class="line-added"> 489   PhaseOutput*      output() const              { return _output; }</span>
<span class="line-added"> 490   void              set_output(PhaseOutput* o)  { _output = o; }</span>
<span class="line-added"> 491 </span>
 492   // ID for this compilation.  Useful for setting breakpoints in the debugger.
 493   int               compile_id() const          { return _compile_id; }
 494   DirectiveSet*     directive() const           { return _directive; }
 495 
 496   // Does this compilation allow instructions to subsume loads?  User
 497   // instructions that subsume a load may result in an unschedulable
 498   // instruction sequence.
 499   bool              subsume_loads() const       { return _subsume_loads; }
 500   /** Do escape analysis. */
 501   bool              do_escape_analysis() const  { return _do_escape_analysis; }
 502   /** Do boxing elimination. */
 503   bool              eliminate_boxing() const    { return _eliminate_boxing; }
 504   /** Do aggressive boxing elimination. */
 505   bool              aggressive_unboxing() const { return _eliminate_boxing &amp;&amp; AggressiveUnboxing; }
 506   bool              save_argument_registers() const { return _save_argument_registers; }
 507 
 508 
 509   // Other fixed compilation parameters.
 510   ciMethod*         method() const              { return _method; }
 511   int               entry_bci() const           { return _entry_bci; }
 512   bool              is_osr_compilation() const  { return _entry_bci != InvocationEntryBci; }
 513   bool              is_method_compilation() const { return (_method != NULL &amp;&amp; !_method-&gt;flags().is_native()); }
 514   const TypeFunc*   tf() const                  { assert(_tf!=NULL, &quot;&quot;); return _tf; }
 515   void         init_tf(const TypeFunc* tf)      { assert(_tf==NULL, &quot;&quot;); _tf = tf; }
 516   InlineTree*       ilt() const                 { return _ilt; }
 517   address           stub_function() const       { return _stub_function; }
 518   const char*       stub_name() const           { return _stub_name; }
 519   address           stub_entry_point() const    { return _stub_entry_point; }
<span class="line-added"> 520   void          set_stub_entry_point(address z) { _stub_entry_point = z; }</span>
 521 
 522   // Control of this compilation.
 523   int               fixed_slots() const         { assert(_fixed_slots &gt;= 0, &quot;&quot;);         return _fixed_slots; }
 524   void          set_fixed_slots(int n)          { _fixed_slots = n; }
 525   int               major_progress() const      { return _major_progress; }
 526   void          set_inlining_progress(bool z)   { _inlining_progress = z; }
 527   int               inlining_progress() const   { return _inlining_progress; }
 528   void          set_inlining_incrementally(bool z) { _inlining_incrementally = z; }
 529   int               inlining_incrementally() const { return _inlining_incrementally; }
 530   void          set_do_cleanup(bool z)          { _do_cleanup = z; }
 531   int               do_cleanup() const          { return _do_cleanup; }
 532   void          set_major_progress()            { _major_progress++; }
 533   void          restore_major_progress(int progress) { _major_progress += progress; }
 534   void        clear_major_progress()            { _major_progress = 0; }
 535   int               max_inline_size() const     { return _max_inline_size; }
 536   void          set_freq_inline_size(int n)     { _freq_inline_size = n; }
 537   int               freq_inline_size() const    { return _freq_inline_size; }
 538   void          set_max_inline_size(int n)      { _max_inline_size = n; }
 539   bool              has_loops() const           { return _has_loops; }
 540   void          set_has_loops(bool z)           { _has_loops = z; }
</pre>
<hr />
<pre>
 615   void begin_method() {
 616 #ifndef PRODUCT
 617     if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 618       _printer-&gt;begin_method();
 619     }
 620 #endif
 621     C-&gt;_latest_stage_start_counter.stamp();
 622   }
 623 
 624   bool should_print(int level = 1) {
 625 #ifndef PRODUCT
 626     return (_printer &amp;&amp; _printer-&gt;should_print(level));
 627 #else
 628     return false;
 629 #endif
 630   }
 631 
 632   void print_method(CompilerPhaseType cpt, int level = 1, int idx = 0) {
 633     EventCompilerPhase event;
 634     if (event.should_commit()) {
<span class="line-modified"> 635       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, cpt, C-&gt;_compile_id, level);</span>




 636     }
 637 
 638 #ifndef PRODUCT
 639     if (should_print(level)) {
 640       char output[1024];
 641       if (idx != 0) {
 642         sprintf(output, &quot;%s:%d&quot;, CompilerPhaseTypeHelper::to_string(cpt), idx);
 643       } else {
 644         sprintf(output, &quot;%s&quot;, CompilerPhaseTypeHelper::to_string(cpt));
 645       }
 646       _printer-&gt;print_method(output, level);
 647     }
 648 #endif
 649     C-&gt;_latest_stage_start_counter.stamp();
 650   }
 651 
 652   void end_method(int level = 1) {
 653     EventCompilerPhase event;
 654     if (event.should_commit()) {
<span class="line-modified"> 655       CompilerEvent::PhaseEvent::post(event, C-&gt;_latest_stage_start_counter, PHASE_END, C-&gt;_compile_id, level);</span>




 656     }
<span class="line-added"> 657 </span>
 658 #ifndef PRODUCT
 659     if (_printer &amp;&amp; _printer-&gt;should_print(level)) {
 660       _printer-&gt;end_method();
 661     }
 662 #endif
 663   }
 664 
 665   int           macro_count()             const { return _macro_nodes-&gt;length(); }
 666   int           predicate_count()         const { return _predicate_opaqs-&gt;length();}
 667   int           expensive_count()         const { return _expensive_nodes-&gt;length(); }
 668   Node*         macro_node(int idx)       const { return _macro_nodes-&gt;at(idx); }
 669   Node*         predicate_opaque1_node(int idx) const { return _predicate_opaqs-&gt;at(idx);}
 670   Node*         expensive_node(int idx)   const { return _expensive_nodes-&gt;at(idx); }
 671   ConnectionGraph* congraph()                   { return _congraph;}
 672   void set_congraph(ConnectionGraph* congraph)  { _congraph = congraph;}
 673   void add_macro_node(Node * n) {
 674     //assert(n-&gt;is_macro(), &quot;must be a macro node&quot;);
 675     assert(!_macro_nodes-&gt;contains(n), &quot;duplicate entry in expand list&quot;);
 676     _macro_nodes-&gt;append(n);
 677   }
</pre>
<hr />
<pre>
 702   void remove_range_check_cast(Node* n) {
 703     if (_range_check_casts-&gt;contains(n)) {
 704       _range_check_casts-&gt;remove(n);
 705     }
 706   }
 707   Node* range_check_cast_node(int idx) const { return _range_check_casts-&gt;at(idx);  }
 708   int   range_check_cast_count()       const { return _range_check_casts-&gt;length(); }
 709   // Remove all range check dependent CastIINodes.
 710   void  remove_range_check_casts(PhaseIterGVN &amp;igvn);
 711 
 712   void add_opaque4_node(Node* n);
 713   void remove_opaque4_node(Node* n) {
 714     if (_opaque4_nodes-&gt;contains(n)) {
 715       _opaque4_nodes-&gt;remove(n);
 716     }
 717   }
 718   Node* opaque4_node(int idx) const { return _opaque4_nodes-&gt;at(idx);  }
 719   int   opaque4_count()       const { return _opaque4_nodes-&gt;length(); }
 720   void  remove_opaque4_nodes(PhaseIterGVN &amp;igvn);
 721 
<span class="line-added"> 722   void sort_macro_nodes();</span>
<span class="line-added"> 723 </span>
 724   // remove the opaque nodes that protect the predicates so that the unused checks and
 725   // uncommon traps will be eliminated from the graph.
 726   void cleanup_loop_predicates(PhaseIterGVN &amp;igvn);
 727   bool is_predicate_opaq(Node * n) {
 728     return _predicate_opaqs-&gt;contains(n);
 729   }
 730 
 731   // Are there candidate expensive nodes for optimization?
 732   bool should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn);
 733   // Check whether n1 and n2 are similar
 734   static int cmp_expensive_nodes(Node* n1, Node* n2);
 735   // Sort expensive nodes to locate similar expensive nodes
 736   void sort_expensive_nodes();
 737 
 738   // Compilation environment.
 739   Arena*      comp_arena()           { return &amp;_comp_arena; }
 740   ciEnv*      env() const            { return _env; }
 741   CompileLog* log() const            { return _log; }
 742   bool        failing() const        { return _env-&gt;failing() || _failure_reason != NULL; }
 743   const char* failure_reason() const { return (_env-&gt;failing()) ? _env-&gt;failure_reason() : _failure_reason; }
</pre>
<hr />
<pre>
 786                                              _dead_node_count++;
 787                                            }
 788   void         reset_dead_node_list()      { _dead_node_list.reset();
 789                                              _dead_node_count = 0;
 790                                            }
 791   uint          live_nodes() const         {
 792     int  val = _unique - _dead_node_count;
 793     assert (val &gt;= 0, &quot;number of tracked dead nodes %d more than created nodes %d&quot;, _unique, _dead_node_count);
 794             return (uint) val;
 795                                            }
 796 #ifdef ASSERT
 797   uint         count_live_nodes_by_graph_walk();
 798   void         print_missing_nodes();
 799 #endif
 800 
 801   // Record modified nodes to check that they are put on IGVN worklist
 802   void         record_modified_node(Node* n) NOT_DEBUG_RETURN;
 803   void         remove_modified_node(Node* n) NOT_DEBUG_RETURN;
 804   DEBUG_ONLY( Unique_Node_List*   modified_nodes() const { return _modified_nodes; } )
 805 



 806   MachConstantBaseNode*     mach_constant_base_node();
 807   bool                  has_mach_constant_base_node() const { return _mach_constant_base_node != NULL; }
 808   // Generated by adlc, true if CallNode requires MachConstantBase.
 809   bool                      needs_clone_jvms();
 810 
 811   // Handy undefined Node
 812   Node*             top() const                 { return _top; }
 813 
 814   // these are used by guys who need to know about creation and transformation of top:
 815   Node*             cached_top_node()           { return _top; }
 816   void          set_cached_top_node(Node* tn);
 817 
 818   GrowableArray&lt;Node_Notes*&gt;* node_note_array() const { return _node_note_array; }
 819   void set_node_note_array(GrowableArray&lt;Node_Notes*&gt;* arr) { _node_note_array = arr; }
 820   Node_Notes* default_node_notes() const        { return _default_node_notes; }
 821   void    set_default_node_notes(Node_Notes* n) { _default_node_notes = n; }
 822 
 823   Node_Notes*       node_notes_at(int idx) {
 824     return locate_node_notes(_node_note_array, idx, false);
 825   }
</pre>
<hr />
<pre>
 971 
 972   void inc_number_of_mh_late_inlines() { _number_of_mh_late_inlines++; }
 973   void dec_number_of_mh_late_inlines() { assert(_number_of_mh_late_inlines &gt; 0, &quot;_number_of_mh_late_inlines &lt; 0 !&quot;); _number_of_mh_late_inlines--; }
 974   bool has_mh_late_inlines() const     { return _number_of_mh_late_inlines &gt; 0; }
 975 
 976   bool inline_incrementally_one();
 977   void inline_incrementally_cleanup(PhaseIterGVN&amp; igvn);
 978   void inline_incrementally(PhaseIterGVN&amp; igvn);
 979   void inline_string_calls(bool parse_time);
 980   void inline_boxing_calls(PhaseIterGVN&amp; igvn);
 981   bool optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode);
 982   void remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn);
 983 
 984   // Matching, CFG layout, allocation, code generation
 985   PhaseCFG*         cfg()                       { return _cfg; }
 986   bool              has_java_calls() const      { return _java_calls &gt; 0; }
 987   int               java_calls() const          { return _java_calls; }
 988   int               inner_loops() const         { return _inner_loops; }
 989   Matcher*          matcher()                   { return _matcher; }
 990   PhaseRegAlloc*    regalloc()                  { return _regalloc; }



 991   RegMask&amp;          FIRST_STACK_mask()          { return _FIRST_STACK_mask; }
 992   Arena*            indexSet_arena()            { return _indexSet_arena; }
 993   void*             indexSet_free_block_list()  { return _indexSet_free_block_list; }
<span class="line-modified"> 994   DebugInformationRecorder* debug_info()        { return env()-&gt;debug_info(); }</span>






 995 
 996   void  update_interpreter_frame_size(int size) {
 997     if (_interpreter_frame_size &lt; size) {
 998       _interpreter_frame_size = size;
 999     }
1000   }

1001 
1002   void          set_matcher(Matcher* m)                 { _matcher = m; }
1003 //void          set_regalloc(PhaseRegAlloc* ra)           { _regalloc = ra; }
1004   void          set_indexSet_arena(Arena* a)            { _indexSet_arena = a; }
1005   void          set_indexSet_free_block_list(void* p)   { _indexSet_free_block_list = p; }
1006 
1007   void  set_java_calls(int z) { _java_calls  = z; }
1008   void set_inner_loops(int z) { _inner_loops = z; }
1009 
<span class="line-modified">1010   Dependencies* dependencies() { return env()-&gt;dependencies(); }</span>



























1011 
1012   // Major entry point.  Given a Scope, compile the associated method.
1013   // For normal compilations, entry_bci is InvocationEntryBci.  For on stack
1014   // replacement, entry_bci indicates the bytecode for which to compile a
1015   // continuation.
<span class="line-modified">1016   Compile(ciEnv* ci_env, ciMethod* target,</span>
1017           int entry_bci, bool subsume_loads, bool do_escape_analysis,
1018           bool eliminate_boxing, DirectiveSet* directive);
1019 
1020   // Second major entry point.  From the TypeFunc signature, generate code
1021   // to pass arguments from the Java calling convention to the C calling
1022   // convention.
1023   Compile(ciEnv* ci_env, const TypeFunc *(*gen)(),
1024           address stub_function, const char *stub_name,
1025           int is_fancy_jump, bool pass_tls,
1026           bool save_arg_registers, bool return_pc, DirectiveSet* directive);
1027 
1028   // From the TypeFunc signature, generate code to pass arguments
1029   // from Compiled calling convention to Interpreter&#39;s calling convention
1030   void Generate_Compiled_To_Interpreter_Graph(const TypeFunc *tf, address interpreter_entry);
1031 
1032   // From the TypeFunc signature, generate code to pass arguments
1033   // from Interpreter&#39;s calling convention to Compiler&#39;s calling convention
1034   void Generate_Interpreter_To_Compiled_Graph(const TypeFunc *tf);
1035 
1036   // Are we compiling a method?
1037   bool has_method() { return method() != NULL; }
1038 
1039   // Maybe print some information about this compile.
1040   void print_compile_messages();
1041 
1042   // Final graph reshaping, a post-pass after the regular optimizer is done.
1043   bool final_graph_reshaping();
1044 
1045   // returns true if adr is completely contained in the given alias category
1046   bool must_alias(const TypePtr* adr, int alias_idx);
1047 
1048   // returns true if adr overlaps with the given alias category
1049   bool can_alias(const TypePtr* adr, int alias_idx);
1050 




















1051   // If &quot;objs&quot; contains an ObjectValue whose id is &quot;id&quot;, returns it, else NULL.
1052   static ObjectValue* sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id);







































1053 
1054   // Stack slots that may be unused by the calling convention but must
1055   // otherwise be preserved.  On Intel this includes the return address.
1056   // On PowerPC it includes the 4 words holding the old TOC &amp; LR glue.
1057   uint in_preserve_stack_slots();
1058 
1059   // &quot;Top of Stack&quot; slots that may be unused by the calling convention but must
1060   // otherwise be preserved.
1061   // On Intel these are not necessary and the value can be zero.
1062   // On Sparc this describes the words reserved for storing a register window
1063   // when an interrupt occurs.
1064   static uint out_preserve_stack_slots();
1065 
1066   // Number of outgoing stack slots killed above the out_preserve_stack_slots
1067   // for calls to C.  Supports the var-args backing area for register parms.
1068   uint varargs_C_out_slots_killed() const;
1069 
1070   // Number of Stack Slots consumed by a synchronization entry
1071   int sync_stack_slots() const;
1072 
</pre>
<hr />
<pre>
1090   void verify_top(Node*) const PRODUCT_RETURN;
1091 
1092   // Intrinsic setup.
1093   void           register_library_intrinsics();                            // initializer
1094   CallGenerator* make_vm_intrinsic(ciMethod* m, bool is_virtual);          // constructor
1095   int            intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found);  // helper
1096   CallGenerator* find_intrinsic(ciMethod* m, bool is_virtual);             // query fn
1097   void           register_intrinsic(CallGenerator* cg);                    // update fn
1098 
1099 #ifndef PRODUCT
1100   static juint  _intrinsic_hist_count[vmIntrinsics::ID_LIMIT];
1101   static jubyte _intrinsic_hist_flags[vmIntrinsics::ID_LIMIT];
1102 #endif
1103   // Function calls made by the public function final_graph_reshaping.
1104   // No need to be made public as they are not called elsewhere.
1105   void final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc);
1106   void final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop);
1107   void final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc );
1108   void eliminate_redundant_card_marks(Node* n);
1109 
<span class="line-added">1110   // Logic cone optimization.</span>
<span class="line-added">1111   void optimize_logic_cones(PhaseIterGVN &amp;igvn);</span>
<span class="line-added">1112   void collect_logic_cone_roots(Unique_Node_List&amp; list);</span>
<span class="line-added">1113   void process_logic_cone_root(PhaseIterGVN &amp;igvn, Node* n, VectorSet&amp; visited);</span>
<span class="line-added">1114   bool compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs);</span>
<span class="line-added">1115   uint compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs);</span>
<span class="line-added">1116   uint eval_macro_logic_op(uint func, uint op1, uint op2, uint op3);</span>
<span class="line-added">1117   Node* xform_to_MacroLogicV(PhaseIterGVN &amp;igvn, const TypeVect* vt, Unique_Node_List&amp; partitions, Unique_Node_List&amp; inputs);</span>
<span class="line-added">1118 </span>
1119  public:
1120 
1121   // Note:  Histogram array size is about 1 Kb.
1122   enum {                        // flag bits:
1123     _intrinsic_worked = 1,      // succeeded at least once
1124     _intrinsic_failed = 2,      // tried it but it failed
1125     _intrinsic_disabled = 4,    // was requested but disabled (e.g., -XX:-InlineUnsafeOps)
1126     _intrinsic_virtual = 8,     // was seen in the virtual form (rare)
1127     _intrinsic_both = 16        // was seen in the non-virtual form (usual)
1128   };
1129   // Update histogram.  Return boolean if this is a first-time occurrence.
1130   static bool gather_intrinsic_statistics(vmIntrinsics::ID id,
1131                                           bool is_virtual, int flags) PRODUCT_RETURN0;
1132   static void print_intrinsic_statistics() PRODUCT_RETURN;
1133 
1134   // Graph verification code
1135   // Walk the node list, verifying that there is a one-to-one
1136   // correspondence between Use-Def edges and Def-Use edges
1137   // The option no_dead_code enables stronger checks that the
1138   // graph is strongly connected from root in both directions.
1139   void verify_graph_edges(bool no_dead_code = false) PRODUCT_RETURN;
1140 
1141   // End-of-run dumps.
1142   static void print_statistics() PRODUCT_RETURN;
1143 










1144   // Verify ADLC assumptions during startup
1145   static void adlc_verification() PRODUCT_RETURN;
1146 
1147   // Definitions of pd methods
1148   static void pd_compiler2_init();
1149 
1150   // Static parse-time type checking logic for gen_subtype_check:
1151   enum { SSC_always_false, SSC_always_true, SSC_easy_test, SSC_full_test };
1152   int static_subtype_check(ciKlass* superk, ciKlass* subk);
1153 
1154   static Node* conv_I2X_index(PhaseGVN* phase, Node* offset, const TypeInt* sizetype,
1155                               // Optional control dependency (for example, on range check)
1156                               Node* ctrl = NULL);
1157 
1158   // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
1159   static Node* constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl);
1160 
1161   // Auxiliary method for randomized fuzzing/stressing
1162   static bool randomized_select(int count);
1163 
</pre>
<hr />
<pre>
1167 
1168   bool needs_clinit_barrier(ciField* ik,         ciMethod* accessing_method);
1169   bool needs_clinit_barrier(ciMethod* ik,        ciMethod* accessing_method);
1170   bool needs_clinit_barrier(ciInstanceKlass* ik, ciMethod* accessing_method);
1171 
1172 #ifdef IA32
1173  private:
1174   bool _select_24_bit_instr;   // We selected an instruction with a 24-bit result
1175   bool _in_24_bit_fp_mode;     // We are emitting instructions with 24-bit results
1176 
1177   // Remember if this compilation changes hardware mode to 24-bit precision.
1178   void set_24_bit_selection_and_mode(bool selection, bool mode) {
1179     _select_24_bit_instr = selection;
1180     _in_24_bit_fp_mode   = mode;
1181   }
1182 
1183  public:
1184   bool select_24_bit_instr() const { return _select_24_bit_instr; }
1185   bool in_24_bit_fp_mode() const   { return _in_24_bit_fp_mode; }
1186 #endif // IA32
<span class="line-added">1187 #ifdef ASSERT</span>
<span class="line-added">1188   bool _type_verify_symmetry;</span>
<span class="line-added">1189 #endif</span>
1190 };
1191 
1192 #endif // SHARE_OPTO_COMPILE_HPP
</pre>
</td>
</tr>
</table>
<center><a href="compile.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="graphKit.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
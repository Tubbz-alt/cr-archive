<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>New src/hotspot/share/opto/runtime.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
  <body>
    <pre>
   1 /*
   2  * Copyright (c) 1998, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;classfile/systemDictionary.hpp&quot;
  27 #include &quot;classfile/vmSymbols.hpp&quot;
  28 #include &quot;code/codeCache.hpp&quot;
  29 #include &quot;code/compiledMethod.inline.hpp&quot;
  30 #include &quot;code/compiledIC.hpp&quot;
  31 #include &quot;code/icBuffer.hpp&quot;
  32 #include &quot;code/nmethod.hpp&quot;
  33 #include &quot;code/pcDesc.hpp&quot;
  34 #include &quot;code/scopeDesc.hpp&quot;
  35 #include &quot;code/vtableStubs.hpp&quot;
  36 #include &quot;compiler/compileBroker.hpp&quot;
  37 #include &quot;compiler/oopMap.hpp&quot;
  38 #include &quot;gc/g1/heapRegion.hpp&quot;
  39 #include &quot;gc/shared/barrierSet.hpp&quot;
  40 #include &quot;gc/shared/collectedHeap.hpp&quot;
  41 #include &quot;gc/shared/gcLocker.hpp&quot;
  42 #include &quot;interpreter/bytecode.hpp&quot;
  43 #include &quot;interpreter/interpreter.hpp&quot;
  44 #include &quot;interpreter/linkResolver.hpp&quot;
  45 #include &quot;logging/log.hpp&quot;
  46 #include &quot;logging/logStream.hpp&quot;
  47 #include &quot;memory/oopFactory.hpp&quot;
  48 #include &quot;memory/resourceArea.hpp&quot;
  49 #include &quot;oops/objArrayKlass.hpp&quot;
  50 #include &quot;oops/oop.inline.hpp&quot;
  51 #include &quot;oops/typeArrayOop.inline.hpp&quot;
  52 #include &quot;opto/ad.hpp&quot;
  53 #include &quot;opto/addnode.hpp&quot;
  54 #include &quot;opto/callnode.hpp&quot;
  55 #include &quot;opto/cfgnode.hpp&quot;
  56 #include &quot;opto/graphKit.hpp&quot;
  57 #include &quot;opto/machnode.hpp&quot;
  58 #include &quot;opto/matcher.hpp&quot;
  59 #include &quot;opto/memnode.hpp&quot;
  60 #include &quot;opto/mulnode.hpp&quot;
  61 #include &quot;opto/output.hpp&quot;
  62 #include &quot;opto/runtime.hpp&quot;
  63 #include &quot;opto/subnode.hpp&quot;
  64 #include &quot;runtime/atomic.hpp&quot;
  65 #include &quot;runtime/frame.inline.hpp&quot;
  66 #include &quot;runtime/handles.inline.hpp&quot;
  67 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
  68 #include &quot;runtime/javaCalls.hpp&quot;
  69 #include &quot;runtime/sharedRuntime.hpp&quot;
  70 #include &quot;runtime/signature.hpp&quot;
  71 #include &quot;runtime/threadCritical.hpp&quot;
  72 #include &quot;runtime/vframe.hpp&quot;
  73 #include &quot;runtime/vframeArray.hpp&quot;
  74 #include &quot;runtime/vframe_hp.hpp&quot;
  75 #include &quot;utilities/copy.hpp&quot;
  76 #include &quot;utilities/preserveException.hpp&quot;
  77 
  78 
  79 // For debugging purposes:
  80 //  To force FullGCALot inside a runtime function, add the following two lines
  81 //
  82 //  Universe::release_fullgc_alot_dummy();
  83 //  MarkSweep::invoke(0, &quot;Debugging&quot;);
  84 //
  85 // At command line specify the parameters: -XX:+FullGCALot -XX:FullGCALotStart=100000000
  86 
  87 
  88 
  89 
  90 // Compiled code entry points
  91 address OptoRuntime::_new_instance_Java                           = NULL;
  92 address OptoRuntime::_new_array_Java                              = NULL;
  93 address OptoRuntime::_new_array_nozero_Java                       = NULL;
  94 address OptoRuntime::_multianewarray2_Java                        = NULL;
  95 address OptoRuntime::_multianewarray3_Java                        = NULL;
  96 address OptoRuntime::_multianewarray4_Java                        = NULL;
  97 address OptoRuntime::_multianewarray5_Java                        = NULL;
  98 address OptoRuntime::_multianewarrayN_Java                        = NULL;
  99 address OptoRuntime::_vtable_must_compile_Java                    = NULL;
 100 address OptoRuntime::_complete_monitor_locking_Java               = NULL;
 101 address OptoRuntime::_monitor_notify_Java                         = NULL;
 102 address OptoRuntime::_monitor_notifyAll_Java                      = NULL;
 103 address OptoRuntime::_rethrow_Java                                = NULL;
 104 
 105 address OptoRuntime::_slow_arraycopy_Java                         = NULL;
 106 address OptoRuntime::_register_finalizer_Java                     = NULL;
 107 
 108 ExceptionBlob* OptoRuntime::_exception_blob;
 109 
 110 // This should be called in an assertion at the start of OptoRuntime routines
 111 // which are entered from compiled code (all of them)
 112 #ifdef ASSERT
 113 static bool check_compiled_frame(JavaThread* thread) {
 114   assert(thread-&gt;last_frame().is_runtime_frame(), &quot;cannot call runtime directly from compiled code&quot;);
 115   RegisterMap map(thread, false);
 116   frame caller = thread-&gt;last_frame().sender(&amp;map);
 117   assert(caller.is_compiled_frame(), &quot;not being called from compiled like code&quot;);
 118   return true;
 119 }
 120 #endif // ASSERT
 121 
 122 
 123 #define gen(env, var, type_func_gen, c_func, fancy_jump, pass_tls, save_arg_regs, return_pc) \
 124   var = generate_stub(env, type_func_gen, CAST_FROM_FN_PTR(address, c_func), #var, fancy_jump, pass_tls, save_arg_regs, return_pc); \
 125   if (var == NULL) { return false; }
 126 
 127 bool OptoRuntime::generate(ciEnv* env) {
 128 
 129   generate_exception_blob();
 130 
 131   // Note: tls: Means fetching the return oop out of the thread-local storage
 132   //
 133   //   variable/name                       type-function-gen              , runtime method                  ,fncy_jp, tls,save_args,retpc
 134   // -------------------------------------------------------------------------------------------------------------------------------
 135   gen(env, _new_instance_Java              , new_instance_Type            , new_instance_C                  ,    0 , true , false, false);
 136   gen(env, _new_array_Java                 , new_array_Type               , new_array_C                     ,    0 , true , false, false);
 137   gen(env, _new_array_nozero_Java          , new_array_Type               , new_array_nozero_C              ,    0 , true , false, false);
 138   gen(env, _multianewarray2_Java           , multianewarray2_Type         , multianewarray2_C               ,    0 , true , false, false);
 139   gen(env, _multianewarray3_Java           , multianewarray3_Type         , multianewarray3_C               ,    0 , true , false, false);
 140   gen(env, _multianewarray4_Java           , multianewarray4_Type         , multianewarray4_C               ,    0 , true , false, false);
 141   gen(env, _multianewarray5_Java           , multianewarray5_Type         , multianewarray5_C               ,    0 , true , false, false);
 142   gen(env, _multianewarrayN_Java           , multianewarrayN_Type         , multianewarrayN_C               ,    0 , true , false, false);
 143   gen(env, _complete_monitor_locking_Java  , complete_monitor_enter_Type  , SharedRuntime::complete_monitor_locking_C, 0, false, false, false);
 144   gen(env, _monitor_notify_Java            , monitor_notify_Type          , monitor_notify_C                ,    0 , false, false, false);
 145   gen(env, _monitor_notifyAll_Java         , monitor_notify_Type          , monitor_notifyAll_C             ,    0 , false, false, false);
 146   gen(env, _rethrow_Java                   , rethrow_Type                 , rethrow_C                       ,    2 , true , false, true );
 147 
 148   gen(env, _slow_arraycopy_Java            , slow_arraycopy_Type          , SharedRuntime::slow_arraycopy_C ,    0 , false, false, false);
 149   gen(env, _register_finalizer_Java        , register_finalizer_Type      , register_finalizer              ,    0 , false, false, false);
 150 
 151   return true;
 152 }
 153 
 154 #undef gen
 155 
 156 
 157 // Helper method to do generation of RunTimeStub&#39;s
 158 address OptoRuntime::generate_stub( ciEnv* env,
 159                                     TypeFunc_generator gen, address C_function,
 160                                     const char *name, int is_fancy_jump,
 161                                     bool pass_tls,
 162                                     bool save_argument_registers,
 163                                     bool return_pc) {
 164 
 165   // Matching the default directive, we currently have no method to match.
 166   DirectiveSet* directive = DirectivesStack::getDefaultDirective(CompileBroker::compiler(CompLevel_full_optimization));
 167   ResourceMark rm;
 168   Compile C( env, gen, C_function, name, is_fancy_jump, pass_tls, save_argument_registers, return_pc, directive);
 169   DirectivesStack::release(directive);
 170   return  C.stub_entry_point();
 171 }
 172 
 173 const char* OptoRuntime::stub_name(address entry) {
 174 #ifndef PRODUCT
 175   CodeBlob* cb = CodeCache::find_blob(entry);
 176   RuntimeStub* rs =(RuntimeStub *)cb;
 177   assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;not a runtime stub&quot;);
 178   return rs-&gt;name();
 179 #else
 180   // Fast implementation for product mode (maybe it should be inlined too)
 181   return &quot;runtime stub&quot;;
 182 #endif
 183 }
 184 
 185 
 186 //=============================================================================
 187 // Opto compiler runtime routines
 188 //=============================================================================
 189 
 190 
 191 //=============================allocation======================================
 192 // We failed the fast-path allocation.  Now we need to do a scavenge or GC
 193 // and try allocation again.
 194 
 195 // object allocation
 196 JRT_BLOCK_ENTRY(void, OptoRuntime::new_instance_C(Klass* klass, JavaThread* thread))
 197   JRT_BLOCK;
 198 #ifndef PRODUCT
 199   SharedRuntime::_new_instance_ctr++;         // new instance requires GC
 200 #endif
 201   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 202 
 203   // These checks are cheap to make and support reflective allocation.
 204   int lh = klass-&gt;layout_helper();
 205   if (Klass::layout_helper_needs_slow_path(lh) || !InstanceKlass::cast(klass)-&gt;is_initialized()) {
 206     Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 207     klass-&gt;check_valid_for_instantiation(false, THREAD);
 208     if (!HAS_PENDING_EXCEPTION) {
 209       InstanceKlass::cast(klass)-&gt;initialize(THREAD);
 210     }
 211   }
 212 
 213   if (!HAS_PENDING_EXCEPTION) {
 214     // Scavenge and allocate an instance.
 215     Handle holder(THREAD, klass-&gt;klass_holder()); // keep the klass alive
 216     oop result = InstanceKlass::cast(klass)-&gt;allocate_instance(THREAD);
 217     thread-&gt;set_vm_result(result);
 218 
 219     // Pass oops back through thread local storage.  Our apparent type to Java
 220     // is that we return an oop, but we can block on exit from this routine and
 221     // a GC can trash the oop in C&#39;s return register.  The generated stub will
 222     // fetch the oop from TLS after any possible GC.
 223   }
 224 
 225   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 226   JRT_BLOCK_END;
 227 
 228   // inform GC that we won&#39;t do card marks for initializing writes.
 229   SharedRuntime::on_slowpath_allocation_exit(thread);
 230 JRT_END
 231 
 232 
 233 // array allocation
 234 JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_C(Klass* array_type, int len, JavaThread *thread))
 235   JRT_BLOCK;
 236 #ifndef PRODUCT
 237   SharedRuntime::_new_array_ctr++;            // new array requires GC
 238 #endif
 239   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 240 
 241   // Scavenge and allocate an instance.
 242   oop result;
 243 
 244   if (array_type-&gt;is_typeArray_klass()) {
 245     // The oopFactory likes to work with the element type.
 246     // (We could bypass the oopFactory, since it doesn&#39;t add much value.)
 247     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 248     result = oopFactory::new_typeArray(elem_type, len, THREAD);
 249   } else {
 250     // Although the oopFactory likes to work with the elem_type,
 251     // the compiler prefers the array_type, since it must already have
 252     // that latter value in hand for the fast path.
 253     Handle holder(THREAD, array_type-&gt;klass_holder()); // keep the array klass alive
 254     Klass* elem_type = ObjArrayKlass::cast(array_type)-&gt;element_klass();
 255     result = oopFactory::new_objArray(elem_type, len, THREAD);
 256   }
 257 
 258   // Pass oops back through thread local storage.  Our apparent type to Java
 259   // is that we return an oop, but we can block on exit from this routine and
 260   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 261   // fetch the oop from TLS after any possible GC.
 262   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 263   thread-&gt;set_vm_result(result);
 264   JRT_BLOCK_END;
 265 
 266   // inform GC that we won&#39;t do card marks for initializing writes.
 267   SharedRuntime::on_slowpath_allocation_exit(thread);
 268 JRT_END
 269 
 270 // array allocation without zeroing
 271 JRT_BLOCK_ENTRY(void, OptoRuntime::new_array_nozero_C(Klass* array_type, int len, JavaThread *thread))
 272   JRT_BLOCK;
 273 #ifndef PRODUCT
 274   SharedRuntime::_new_array_ctr++;            // new array requires GC
 275 #endif
 276   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 277 
 278   // Scavenge and allocate an instance.
 279   oop result;
 280 
 281   assert(array_type-&gt;is_typeArray_klass(), &quot;should be called only for type array&quot;);
 282   // The oopFactory likes to work with the element type.
 283   BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 284   result = oopFactory::new_typeArray_nozero(elem_type, len, THREAD);
 285 
 286   // Pass oops back through thread local storage.  Our apparent type to Java
 287   // is that we return an oop, but we can block on exit from this routine and
 288   // a GC can trash the oop in C&#39;s return register.  The generated stub will
 289   // fetch the oop from TLS after any possible GC.
 290   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 291   thread-&gt;set_vm_result(result);
 292   JRT_BLOCK_END;
 293 
 294 
 295   // inform GC that we won&#39;t do card marks for initializing writes.
 296   SharedRuntime::on_slowpath_allocation_exit(thread);
 297 
 298   oop result = thread-&gt;vm_result();
 299   if ((len &gt; 0) &amp;&amp; (result != NULL) &amp;&amp;
 300       is_deoptimized_caller_frame(thread)) {
 301     // Zero array here if the caller is deoptimized.
 302     int size = ((typeArrayOop)result)-&gt;object_size();
 303     BasicType elem_type = TypeArrayKlass::cast(array_type)-&gt;element_type();
 304     const size_t hs = arrayOopDesc::header_size(elem_type);
 305     // Align to next 8 bytes to avoid trashing arrays&#39;s length.
 306     const size_t aligned_hs = align_object_offset(hs);
 307     HeapWord* obj = cast_from_oop&lt;HeapWord*&gt;(result);
 308     if (aligned_hs &gt; hs) {
 309       Copy::zero_to_words(obj+hs, aligned_hs-hs);
 310     }
 311     // Optimized zeroing.
 312     Copy::fill_to_aligned_words(obj+aligned_hs, size-aligned_hs);
 313   }
 314 
 315 JRT_END
 316 
 317 // Note: multianewarray for one dimension is handled inline by GraphKit::new_array.
 318 
 319 // multianewarray for 2 dimensions
 320 JRT_ENTRY(void, OptoRuntime::multianewarray2_C(Klass* elem_type, int len1, int len2, JavaThread *thread))
 321 #ifndef PRODUCT
 322   SharedRuntime::_multi2_ctr++;                // multianewarray for 1 dimension
 323 #endif
 324   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 325   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 326   jint dims[2];
 327   dims[0] = len1;
 328   dims[1] = len2;
 329   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 330   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(2, dims, THREAD);
 331   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 332   thread-&gt;set_vm_result(obj);
 333 JRT_END
 334 
 335 // multianewarray for 3 dimensions
 336 JRT_ENTRY(void, OptoRuntime::multianewarray3_C(Klass* elem_type, int len1, int len2, int len3, JavaThread *thread))
 337 #ifndef PRODUCT
 338   SharedRuntime::_multi3_ctr++;                // multianewarray for 1 dimension
 339 #endif
 340   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 341   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 342   jint dims[3];
 343   dims[0] = len1;
 344   dims[1] = len2;
 345   dims[2] = len3;
 346   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 347   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(3, dims, THREAD);
 348   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 349   thread-&gt;set_vm_result(obj);
 350 JRT_END
 351 
 352 // multianewarray for 4 dimensions
 353 JRT_ENTRY(void, OptoRuntime::multianewarray4_C(Klass* elem_type, int len1, int len2, int len3, int len4, JavaThread *thread))
 354 #ifndef PRODUCT
 355   SharedRuntime::_multi4_ctr++;                // multianewarray for 1 dimension
 356 #endif
 357   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 358   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 359   jint dims[4];
 360   dims[0] = len1;
 361   dims[1] = len2;
 362   dims[2] = len3;
 363   dims[3] = len4;
 364   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 365   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(4, dims, THREAD);
 366   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 367   thread-&gt;set_vm_result(obj);
 368 JRT_END
 369 
 370 // multianewarray for 5 dimensions
 371 JRT_ENTRY(void, OptoRuntime::multianewarray5_C(Klass* elem_type, int len1, int len2, int len3, int len4, int len5, JavaThread *thread))
 372 #ifndef PRODUCT
 373   SharedRuntime::_multi5_ctr++;                // multianewarray for 1 dimension
 374 #endif
 375   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 376   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 377   jint dims[5];
 378   dims[0] = len1;
 379   dims[1] = len2;
 380   dims[2] = len3;
 381   dims[3] = len4;
 382   dims[4] = len5;
 383   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 384   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(5, dims, THREAD);
 385   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 386   thread-&gt;set_vm_result(obj);
 387 JRT_END
 388 
 389 JRT_ENTRY(void, OptoRuntime::multianewarrayN_C(Klass* elem_type, arrayOopDesc* dims, JavaThread *thread))
 390   assert(check_compiled_frame(thread), &quot;incorrect caller&quot;);
 391   assert(elem_type-&gt;is_klass(), &quot;not a class&quot;);
 392   assert(oop(dims)-&gt;is_typeArray(), &quot;not an array&quot;);
 393 
 394   ResourceMark rm;
 395   jint len = dims-&gt;length();
 396   assert(len &gt; 0, &quot;Dimensions array should contain data&quot;);
 397   jint *c_dims = NEW_RESOURCE_ARRAY(jint, len);
 398   ArrayAccess&lt;&gt;::arraycopy_to_native&lt;&gt;(dims, typeArrayOopDesc::element_offset&lt;jint&gt;(0),
 399                                        c_dims, len);
 400 
 401   Handle holder(THREAD, elem_type-&gt;klass_holder()); // keep the klass alive
 402   oop obj = ArrayKlass::cast(elem_type)-&gt;multi_allocate(len, c_dims, THREAD);
 403   deoptimize_caller_frame(thread, HAS_PENDING_EXCEPTION);
 404   thread-&gt;set_vm_result(obj);
 405 JRT_END
 406 
 407 JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notify_C(oopDesc* obj, JavaThread *thread))
 408 
 409   // Very few notify/notifyAll operations find any threads on the waitset, so
 410   // the dominant fast-path is to simply return.
 411   // Relatedly, it&#39;s critical that notify/notifyAll be fast in order to
 412   // reduce lock hold times.
 413   if (!SafepointSynchronize::is_synchronizing()) {
 414     if (ObjectSynchronizer::quick_notify(obj, thread, false)) {
 415       return;
 416     }
 417   }
 418 
 419   // This is the case the fast-path above isn&#39;t provisioned to handle.
 420   // The fast-path is designed to handle frequently arising cases in an efficient manner.
 421   // (The fast-path is just a degenerate variant of the slow-path).
 422   // Perform the dreaded state transition and pass control into the slow-path.
 423   JRT_BLOCK;
 424   Handle h_obj(THREAD, obj);
 425   ObjectSynchronizer::notify(h_obj, CHECK);
 426   JRT_BLOCK_END;
 427 JRT_END
 428 
 429 JRT_BLOCK_ENTRY(void, OptoRuntime::monitor_notifyAll_C(oopDesc* obj, JavaThread *thread))
 430 
 431   if (!SafepointSynchronize::is_synchronizing() ) {
 432     if (ObjectSynchronizer::quick_notify(obj, thread, true)) {
 433       return;
 434     }
 435   }
 436 
 437   // This is the case the fast-path above isn&#39;t provisioned to handle.
 438   // The fast-path is designed to handle frequently arising cases in an efficient manner.
 439   // (The fast-path is just a degenerate variant of the slow-path).
 440   // Perform the dreaded state transition and pass control into the slow-path.
 441   JRT_BLOCK;
 442   Handle h_obj(THREAD, obj);
 443   ObjectSynchronizer::notifyall(h_obj, CHECK);
 444   JRT_BLOCK_END;
 445 JRT_END
 446 
 447 const TypeFunc *OptoRuntime::new_instance_Type() {
 448   // create input type (domain)
 449   const Type **fields = TypeTuple::fields(1);
 450   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Klass to be allocated
 451   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 452 
 453   // create result type (range)
 454   fields = TypeTuple::fields(1);
 455   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 456 
 457   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 458 
 459   return TypeFunc::make(domain, range);
 460 }
 461 
 462 
 463 const TypeFunc *OptoRuntime::athrow_Type() {
 464   // create input type (domain)
 465   const Type **fields = TypeTuple::fields(1);
 466   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Klass to be allocated
 467   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 468 
 469   // create result type (range)
 470   fields = TypeTuple::fields(0);
 471 
 472   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 473 
 474   return TypeFunc::make(domain, range);
 475 }
 476 
 477 
 478 const TypeFunc *OptoRuntime::new_array_Type() {
 479   // create input type (domain)
 480   const Type **fields = TypeTuple::fields(2);
 481   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 482   fields[TypeFunc::Parms+1] = TypeInt::INT;       // array size
 483   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 484 
 485   // create result type (range)
 486   fields = TypeTuple::fields(1);
 487   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 488 
 489   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 490 
 491   return TypeFunc::make(domain, range);
 492 }
 493 
 494 const TypeFunc *OptoRuntime::multianewarray_Type(int ndim) {
 495   // create input type (domain)
 496   const int nargs = ndim + 1;
 497   const Type **fields = TypeTuple::fields(nargs);
 498   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 499   for( int i = 1; i &lt; nargs; i++ )
 500     fields[TypeFunc::Parms + i] = TypeInt::INT;       // array size
 501   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+nargs, fields);
 502 
 503   // create result type (range)
 504   fields = TypeTuple::fields(1);
 505   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 506   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 507 
 508   return TypeFunc::make(domain, range);
 509 }
 510 
 511 const TypeFunc *OptoRuntime::multianewarray2_Type() {
 512   return multianewarray_Type(2);
 513 }
 514 
 515 const TypeFunc *OptoRuntime::multianewarray3_Type() {
 516   return multianewarray_Type(3);
 517 }
 518 
 519 const TypeFunc *OptoRuntime::multianewarray4_Type() {
 520   return multianewarray_Type(4);
 521 }
 522 
 523 const TypeFunc *OptoRuntime::multianewarray5_Type() {
 524   return multianewarray_Type(5);
 525 }
 526 
 527 const TypeFunc *OptoRuntime::multianewarrayN_Type() {
 528   // create input type (domain)
 529   const Type **fields = TypeTuple::fields(2);
 530   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;   // element klass
 531   fields[TypeFunc::Parms+1] = TypeInstPtr::NOTNULL;   // array of dim sizes
 532   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 533 
 534   // create result type (range)
 535   fields = TypeTuple::fields(1);
 536   fields[TypeFunc::Parms+0] = TypeRawPtr::NOTNULL; // Returned oop
 537   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 538 
 539   return TypeFunc::make(domain, range);
 540 }
 541 
 542 const TypeFunc *OptoRuntime::uncommon_trap_Type() {
 543   // create input type (domain)
 544   const Type **fields = TypeTuple::fields(1);
 545   fields[TypeFunc::Parms+0] = TypeInt::INT; // trap_reason (deopt reason and action)
 546   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 547 
 548   // create result type (range)
 549   fields = TypeTuple::fields(0);
 550   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 551 
 552   return TypeFunc::make(domain, range);
 553 }
 554 
 555 //-----------------------------------------------------------------------------
 556 // Monitor Handling
 557 const TypeFunc *OptoRuntime::complete_monitor_enter_Type() {
 558   // create input type (domain)
 559   const Type **fields = TypeTuple::fields(2);
 560   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 561   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;   // Address of stack location for lock
 562   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
 563 
 564   // create result type (range)
 565   fields = TypeTuple::fields(0);
 566 
 567   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
 568 
 569   return TypeFunc::make(domain,range);
 570 }
 571 
 572 
 573 //-----------------------------------------------------------------------------
 574 const TypeFunc *OptoRuntime::complete_monitor_exit_Type() {
 575   // create input type (domain)
 576   const Type **fields = TypeTuple::fields(3);
 577   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 578   fields[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM;    // Address of stack location for lock - BasicLock
 579   fields[TypeFunc::Parms+2] = TypeRawPtr::BOTTOM;    // Thread pointer (Self)
 580   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+3, fields);
 581 
 582   // create result type (range)
 583   fields = TypeTuple::fields(0);
 584 
 585   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 586 
 587   return TypeFunc::make(domain, range);
 588 }
 589 
 590 const TypeFunc *OptoRuntime::monitor_notify_Type() {
 591   // create input type (domain)
 592   const Type **fields = TypeTuple::fields(1);
 593   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // Object to be Locked
 594   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
 595 
 596   // create result type (range)
 597   fields = TypeTuple::fields(0);
 598   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0, fields);
 599   return TypeFunc::make(domain, range);
 600 }
 601 
 602 const TypeFunc* OptoRuntime::flush_windows_Type() {
 603   // create input type (domain)
 604   const Type** fields = TypeTuple::fields(1);
 605   fields[TypeFunc::Parms+0] = NULL; // void
 606   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms, fields);
 607 
 608   // create result type
 609   fields = TypeTuple::fields(1);
 610   fields[TypeFunc::Parms+0] = NULL; // void
 611   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
 612 
 613   return TypeFunc::make(domain, range);
 614 }
 615 
 616 const TypeFunc* OptoRuntime::l2f_Type() {
 617   // create input type (domain)
 618   const Type **fields = TypeTuple::fields(2);
 619   fields[TypeFunc::Parms+0] = TypeLong::LONG;
 620   fields[TypeFunc::Parms+1] = Type::HALF;
 621   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 622 
 623   // create result type (range)
 624   fields = TypeTuple::fields(1);
 625   fields[TypeFunc::Parms+0] = Type::FLOAT;
 626   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 627 
 628   return TypeFunc::make(domain, range);
 629 }
 630 
 631 const TypeFunc* OptoRuntime::modf_Type() {
 632   const Type **fields = TypeTuple::fields(2);
 633   fields[TypeFunc::Parms+0] = Type::FLOAT;
 634   fields[TypeFunc::Parms+1] = Type::FLOAT;
 635   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 636 
 637   // create result type (range)
 638   fields = TypeTuple::fields(1);
 639   fields[TypeFunc::Parms+0] = Type::FLOAT;
 640 
 641   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
 642 
 643   return TypeFunc::make(domain, range);
 644 }
 645 
 646 const TypeFunc *OptoRuntime::Math_D_D_Type() {
 647   // create input type (domain)
 648   const Type **fields = TypeTuple::fields(2);
 649   // Symbol* name of class to be loaded
 650   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 651   fields[TypeFunc::Parms+1] = Type::HALF;
 652   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
 653 
 654   // create result type (range)
 655   fields = TypeTuple::fields(2);
 656   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 657   fields[TypeFunc::Parms+1] = Type::HALF;
 658   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 659 
 660   return TypeFunc::make(domain, range);
 661 }
 662 
 663 const TypeFunc* OptoRuntime::Math_DD_D_Type() {
 664   const Type **fields = TypeTuple::fields(4);
 665   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 666   fields[TypeFunc::Parms+1] = Type::HALF;
 667   fields[TypeFunc::Parms+2] = Type::DOUBLE;
 668   fields[TypeFunc::Parms+3] = Type::HALF;
 669   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+4, fields);
 670 
 671   // create result type (range)
 672   fields = TypeTuple::fields(2);
 673   fields[TypeFunc::Parms+0] = Type::DOUBLE;
 674   fields[TypeFunc::Parms+1] = Type::HALF;
 675   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 676 
 677   return TypeFunc::make(domain, range);
 678 }
 679 
 680 //-------------- currentTimeMillis, currentTimeNanos, etc
 681 
 682 const TypeFunc* OptoRuntime::void_long_Type() {
 683   // create input type (domain)
 684   const Type **fields = TypeTuple::fields(0);
 685   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+0, fields);
 686 
 687   // create result type (range)
 688   fields = TypeTuple::fields(2);
 689   fields[TypeFunc::Parms+0] = TypeLong::LONG;
 690   fields[TypeFunc::Parms+1] = Type::HALF;
 691   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+2, fields);
 692 
 693   return TypeFunc::make(domain, range);
 694 }
 695 
 696 // arraycopy stub variations:
 697 enum ArrayCopyType {
 698   ac_fast,                      // void(ptr, ptr, size_t)
 699   ac_checkcast,                 //  int(ptr, ptr, size_t, size_t, ptr)
 700   ac_slow,                      // void(ptr, int, ptr, int, int)
 701   ac_generic                    //  int(ptr, int, ptr, int, int)
 702 };
 703 
 704 static const TypeFunc* make_arraycopy_Type(ArrayCopyType act) {
 705   // create input type (domain)
 706   int num_args      = (act == ac_fast ? 3 : 5);
 707   int num_size_args = (act == ac_fast ? 1 : act == ac_checkcast ? 2 : 0);
 708   int argcnt = num_args;
 709   LP64_ONLY(argcnt += num_size_args); // halfwords for lengths
 710   const Type** fields = TypeTuple::fields(argcnt);
 711   int argp = TypeFunc::Parms;
 712   fields[argp++] = TypePtr::NOTNULL;    // src
 713   if (num_size_args == 0) {
 714     fields[argp++] = TypeInt::INT;      // src_pos
 715   }
 716   fields[argp++] = TypePtr::NOTNULL;    // dest
 717   if (num_size_args == 0) {
 718     fields[argp++] = TypeInt::INT;      // dest_pos
 719     fields[argp++] = TypeInt::INT;      // length
 720   }
 721   while (num_size_args-- &gt; 0) {
 722     fields[argp++] = TypeX_X;               // size in whatevers (size_t)
 723     LP64_ONLY(fields[argp++] = Type::HALF); // other half of long length
 724   }
 725   if (act == ac_checkcast) {
 726     fields[argp++] = TypePtr::NOTNULL;  // super_klass
 727   }
 728   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding of act&quot;);
 729   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 730 
 731   // create result type if needed
 732   int retcnt = (act == ac_checkcast || act == ac_generic ? 1 : 0);
 733   fields = TypeTuple::fields(1);
 734   if (retcnt == 0)
 735     fields[TypeFunc::Parms+0] = NULL; // void
 736   else
 737     fields[TypeFunc::Parms+0] = TypeInt::INT; // status result, if needed
 738   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+retcnt, fields);
 739   return TypeFunc::make(domain, range);
 740 }
 741 
 742 const TypeFunc* OptoRuntime::fast_arraycopy_Type() {
 743   // This signature is simple:  Two base pointers and a size_t.
 744   return make_arraycopy_Type(ac_fast);
 745 }
 746 
 747 const TypeFunc* OptoRuntime::checkcast_arraycopy_Type() {
 748   // An extension of fast_arraycopy_Type which adds type checking.
 749   return make_arraycopy_Type(ac_checkcast);
 750 }
 751 
 752 const TypeFunc* OptoRuntime::slow_arraycopy_Type() {
 753   // This signature is exactly the same as System.arraycopy.
 754   // There are no intptr_t (int/long) arguments.
 755   return make_arraycopy_Type(ac_slow);
 756 }
 757 
 758 const TypeFunc* OptoRuntime::generic_arraycopy_Type() {
 759   // This signature is like System.arraycopy, except that it returns status.
 760   return make_arraycopy_Type(ac_generic);
 761 }
 762 
 763 
 764 const TypeFunc* OptoRuntime::array_fill_Type() {
 765   const Type** fields;
 766   int argp = TypeFunc::Parms;
 767   // create input type (domain): pointer, int, size_t
 768   fields = TypeTuple::fields(3 LP64_ONLY( + 1));
 769   fields[argp++] = TypePtr::NOTNULL;
 770   fields[argp++] = TypeInt::INT;
 771   fields[argp++] = TypeX_X;               // size in whatevers (size_t)
 772   LP64_ONLY(fields[argp++] = Type::HALF); // other half of long length
 773   const TypeTuple *domain = TypeTuple::make(argp, fields);
 774 
 775   // create result type
 776   fields = TypeTuple::fields(1);
 777   fields[TypeFunc::Parms+0] = NULL; // void
 778   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
 779 
 780   return TypeFunc::make(domain, range);
 781 }
 782 
 783 // for aescrypt encrypt/decrypt operations, just three pointers returning void (length is constant)
 784 const TypeFunc* OptoRuntime::aescrypt_block_Type() {
 785   // create input type (domain)
 786   int num_args      = 3;
 787   if (Matcher::pass_original_key_for_aes()) {
 788     num_args = 4;
 789   }
 790   int argcnt = num_args;
 791   const Type** fields = TypeTuple::fields(argcnt);
 792   int argp = TypeFunc::Parms;
 793   fields[argp++] = TypePtr::NOTNULL;    // src
 794   fields[argp++] = TypePtr::NOTNULL;    // dest
 795   fields[argp++] = TypePtr::NOTNULL;    // k array
 796   if (Matcher::pass_original_key_for_aes()) {
 797     fields[argp++] = TypePtr::NOTNULL;    // original k array
 798   }
 799   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 800   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 801 
 802   // no result type needed
 803   fields = TypeTuple::fields(1);
 804   fields[TypeFunc::Parms+0] = NULL; // void
 805   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
 806   return TypeFunc::make(domain, range);
 807 }
 808 
 809 /**
 810  * int updateBytesCRC32(int crc, byte* b, int len)
 811  */
 812 const TypeFunc* OptoRuntime::updateBytesCRC32_Type() {
 813   // create input type (domain)
 814   int num_args      = 3;
 815   int argcnt = num_args;
 816   const Type** fields = TypeTuple::fields(argcnt);
 817   int argp = TypeFunc::Parms;
 818   fields[argp++] = TypeInt::INT;        // crc
 819   fields[argp++] = TypePtr::NOTNULL;    // src
 820   fields[argp++] = TypeInt::INT;        // len
 821   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 822   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 823 
 824   // result type needed
 825   fields = TypeTuple::fields(1);
 826   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 827   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 828   return TypeFunc::make(domain, range);
 829 }
 830 
 831 /**
 832  * int updateBytesCRC32C(int crc, byte* buf, int len, int* table)
 833  */
 834 const TypeFunc* OptoRuntime::updateBytesCRC32C_Type() {
 835   // create input type (domain)
 836   int num_args      = 4;
 837   int argcnt = num_args;
 838   const Type** fields = TypeTuple::fields(argcnt);
 839   int argp = TypeFunc::Parms;
 840   fields[argp++] = TypeInt::INT;        // crc
 841   fields[argp++] = TypePtr::NOTNULL;    // buf
 842   fields[argp++] = TypeInt::INT;        // len
 843   fields[argp++] = TypePtr::NOTNULL;    // table
 844   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 845   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 846 
 847   // result type needed
 848   fields = TypeTuple::fields(1);
 849   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 850   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 851   return TypeFunc::make(domain, range);
 852 }
 853 
 854 /**
 855 *  int updateBytesAdler32(int adler, bytes* b, int off, int len)
 856 */
 857 const TypeFunc* OptoRuntime::updateBytesAdler32_Type() {
 858   // create input type (domain)
 859   int num_args      = 3;
 860   int argcnt = num_args;
 861   const Type** fields = TypeTuple::fields(argcnt);
 862   int argp = TypeFunc::Parms;
 863   fields[argp++] = TypeInt::INT;        // crc
 864   fields[argp++] = TypePtr::NOTNULL;    // src + offset
 865   fields[argp++] = TypeInt::INT;        // len
 866   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 867   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 868 
 869   // result type needed
 870   fields = TypeTuple::fields(1);
 871   fields[TypeFunc::Parms+0] = TypeInt::INT; // crc result
 872   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 873   return TypeFunc::make(domain, range);
 874 }
 875 
 876 // for cipherBlockChaining calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 877 const TypeFunc* OptoRuntime::cipherBlockChaining_aescrypt_Type() {
 878   // create input type (domain)
 879   int num_args      = 5;
 880   if (Matcher::pass_original_key_for_aes()) {
 881     num_args = 6;
 882   }
 883   int argcnt = num_args;
 884   const Type** fields = TypeTuple::fields(argcnt);
 885   int argp = TypeFunc::Parms;
 886   fields[argp++] = TypePtr::NOTNULL;    // src
 887   fields[argp++] = TypePtr::NOTNULL;    // dest
 888   fields[argp++] = TypePtr::NOTNULL;    // k array
 889   fields[argp++] = TypePtr::NOTNULL;    // r array
 890   fields[argp++] = TypeInt::INT;        // src len
 891   if (Matcher::pass_original_key_for_aes()) {
 892     fields[argp++] = TypePtr::NOTNULL;    // original k array
 893   }
 894   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 895   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 896 
 897   // returning cipher len (int)
 898   fields = TypeTuple::fields(1);
 899   fields[TypeFunc::Parms+0] = TypeInt::INT;
 900   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
 901   return TypeFunc::make(domain, range);
 902 }
 903 
 904 // for electronicCodeBook calls of aescrypt encrypt/decrypt, three pointers and a length, returning int
 905 const TypeFunc* OptoRuntime::electronicCodeBook_aescrypt_Type() {
 906   // create input type (domain)
 907   int num_args = 4;
 908   if (Matcher::pass_original_key_for_aes()) {
 909      num_args = 5;
 910   }
 911   int argcnt = num_args;
 912   const Type** fields = TypeTuple::fields(argcnt);
 913   int argp = TypeFunc::Parms;
 914   fields[argp++] = TypePtr::NOTNULL;    // src
 915   fields[argp++] = TypePtr::NOTNULL;    // dest
 916   fields[argp++] = TypePtr::NOTNULL;    // k array
 917   fields[argp++] = TypeInt::INT;        // src len
 918   if (Matcher::pass_original_key_for_aes()) {
 919      fields[argp++] = TypePtr::NOTNULL;    // original k array
 920   }
 921   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
 922   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
 923 
 924   // returning cipher len (int)
 925   fields = TypeTuple::fields(1);
 926   fields[TypeFunc::Parms + 0] = TypeInt::INT;
 927   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
 928   return TypeFunc::make(domain, range);
 929 }
 930 
 931 //for counterMode calls of aescrypt encrypt/decrypt, four pointers and a length, returning int
 932 const TypeFunc* OptoRuntime::counterMode_aescrypt_Type() {
 933   // create input type (domain)
 934   int num_args = 7;
 935   if (Matcher::pass_original_key_for_aes()) {
 936     num_args = 8;
 937   }
 938   int argcnt = num_args;
 939   const Type** fields = TypeTuple::fields(argcnt);
 940   int argp = TypeFunc::Parms;
 941   fields[argp++] = TypePtr::NOTNULL; // src
 942   fields[argp++] = TypePtr::NOTNULL; // dest
 943   fields[argp++] = TypePtr::NOTNULL; // k array
 944   fields[argp++] = TypePtr::NOTNULL; // counter array
 945   fields[argp++] = TypeInt::INT; // src len
 946   fields[argp++] = TypePtr::NOTNULL; // saved_encCounter
 947   fields[argp++] = TypePtr::NOTNULL; // saved used addr
 948   if (Matcher::pass_original_key_for_aes()) {
 949     fields[argp++] = TypePtr::NOTNULL; // original k array
 950   }
 951   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
 952   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
 953   // returning cipher len (int)
 954   fields = TypeTuple::fields(1);
 955   fields[TypeFunc::Parms + 0] = TypeInt::INT;
 956   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
 957   return TypeFunc::make(domain, range);
 958 }
 959 
 960 /*
 961  * void implCompress(byte[] buf, int ofs)
 962  */
 963 const TypeFunc* OptoRuntime::sha_implCompress_Type() {
 964   // create input type (domain)
 965   int num_args = 2;
 966   int argcnt = num_args;
 967   const Type** fields = TypeTuple::fields(argcnt);
 968   int argp = TypeFunc::Parms;
 969   fields[argp++] = TypePtr::NOTNULL; // buf
 970   fields[argp++] = TypePtr::NOTNULL; // state
 971   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 972   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 973 
 974   // no result type needed
 975   fields = TypeTuple::fields(1);
 976   fields[TypeFunc::Parms+0] = NULL; // void
 977   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
 978   return TypeFunc::make(domain, range);
 979 }
 980 
 981 /*
 982  * int implCompressMultiBlock(byte[] b, int ofs, int limit)
 983  */
 984 const TypeFunc* OptoRuntime::digestBase_implCompressMB_Type() {
 985   // create input type (domain)
 986   int num_args = 4;
 987   int argcnt = num_args;
 988   const Type** fields = TypeTuple::fields(argcnt);
 989   int argp = TypeFunc::Parms;
 990   fields[argp++] = TypePtr::NOTNULL; // buf
 991   fields[argp++] = TypePtr::NOTNULL; // state
 992   fields[argp++] = TypeInt::INT;     // ofs
 993   fields[argp++] = TypeInt::INT;     // limit
 994   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
 995   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
 996 
 997   // returning ofs (int)
 998   fields = TypeTuple::fields(1);
 999   fields[TypeFunc::Parms+0] = TypeInt::INT; // ofs
1000   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
1001   return TypeFunc::make(domain, range);
1002 }
1003 
1004 const TypeFunc* OptoRuntime::multiplyToLen_Type() {
1005   // create input type (domain)
1006   int num_args      = 6;
1007   int argcnt = num_args;
1008   const Type** fields = TypeTuple::fields(argcnt);
1009   int argp = TypeFunc::Parms;
1010   fields[argp++] = TypePtr::NOTNULL;    // x
1011   fields[argp++] = TypeInt::INT;        // xlen
1012   fields[argp++] = TypePtr::NOTNULL;    // y
1013   fields[argp++] = TypeInt::INT;        // ylen
1014   fields[argp++] = TypePtr::NOTNULL;    // z
1015   fields[argp++] = TypeInt::INT;        // zlen
1016   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1017   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1018 
1019   // no result type needed
1020   fields = TypeTuple::fields(1);
1021   fields[TypeFunc::Parms+0] = NULL;
1022   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1023   return TypeFunc::make(domain, range);
1024 }
1025 
1026 const TypeFunc* OptoRuntime::squareToLen_Type() {
1027   // create input type (domain)
1028   int num_args      = 4;
1029   int argcnt = num_args;
1030   const Type** fields = TypeTuple::fields(argcnt);
1031   int argp = TypeFunc::Parms;
1032   fields[argp++] = TypePtr::NOTNULL;    // x
1033   fields[argp++] = TypeInt::INT;        // len
1034   fields[argp++] = TypePtr::NOTNULL;    // z
1035   fields[argp++] = TypeInt::INT;        // zlen
1036   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1037   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1038 
1039   // no result type needed
1040   fields = TypeTuple::fields(1);
1041   fields[TypeFunc::Parms+0] = NULL;
1042   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1043   return TypeFunc::make(domain, range);
1044 }
1045 
1046 // for mulAdd calls, 2 pointers and 3 ints, returning int
1047 const TypeFunc* OptoRuntime::mulAdd_Type() {
1048   // create input type (domain)
1049   int num_args      = 5;
1050   int argcnt = num_args;
1051   const Type** fields = TypeTuple::fields(argcnt);
1052   int argp = TypeFunc::Parms;
1053   fields[argp++] = TypePtr::NOTNULL;    // out
1054   fields[argp++] = TypePtr::NOTNULL;    // in
1055   fields[argp++] = TypeInt::INT;        // offset
1056   fields[argp++] = TypeInt::INT;        // len
1057   fields[argp++] = TypeInt::INT;        // k
1058   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1059   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1060 
1061   // returning carry (int)
1062   fields = TypeTuple::fields(1);
1063   fields[TypeFunc::Parms+0] = TypeInt::INT;
1064   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms+1, fields);
1065   return TypeFunc::make(domain, range);
1066 }
1067 
1068 const TypeFunc* OptoRuntime::montgomeryMultiply_Type() {
1069   // create input type (domain)
1070   int num_args      = 7;
1071   int argcnt = num_args;
1072   const Type** fields = TypeTuple::fields(argcnt);
1073   int argp = TypeFunc::Parms;
1074   fields[argp++] = TypePtr::NOTNULL;    // a
1075   fields[argp++] = TypePtr::NOTNULL;    // b
1076   fields[argp++] = TypePtr::NOTNULL;    // n
1077   fields[argp++] = TypeInt::INT;        // len
1078   fields[argp++] = TypeLong::LONG;      // inv
1079   fields[argp++] = Type::HALF;
1080   fields[argp++] = TypePtr::NOTNULL;    // result
1081   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1082   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1083 
1084   // result type needed
1085   fields = TypeTuple::fields(1);
1086   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1087 
1088   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1089   return TypeFunc::make(domain, range);
1090 }
1091 
1092 const TypeFunc* OptoRuntime::montgomerySquare_Type() {
1093   // create input type (domain)
1094   int num_args      = 6;
1095   int argcnt = num_args;
1096   const Type** fields = TypeTuple::fields(argcnt);
1097   int argp = TypeFunc::Parms;
1098   fields[argp++] = TypePtr::NOTNULL;    // a
1099   fields[argp++] = TypePtr::NOTNULL;    // n
1100   fields[argp++] = TypeInt::INT;        // len
1101   fields[argp++] = TypeLong::LONG;      // inv
1102   fields[argp++] = Type::HALF;
1103   fields[argp++] = TypePtr::NOTNULL;    // result
1104   assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1105   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1106 
1107   // result type needed
1108   fields = TypeTuple::fields(1);
1109   fields[TypeFunc::Parms+0] = TypePtr::NOTNULL;
1110 
1111   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1112   return TypeFunc::make(domain, range);
1113 }
1114 
1115 const TypeFunc * OptoRuntime::bigIntegerShift_Type() {
1116   int argcnt = 5;
1117   const Type** fields = TypeTuple::fields(argcnt);
1118   int argp = TypeFunc::Parms;
1119   fields[argp++] = TypePtr::NOTNULL;    // newArr
1120   fields[argp++] = TypePtr::NOTNULL;    // oldArr
1121   fields[argp++] = TypeInt::INT;        // newIdx
1122   fields[argp++] = TypeInt::INT;        // shiftCount
1123   fields[argp++] = TypeInt::INT;        // numIter
1124   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1125   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1126 
1127   // no result type needed
1128   fields = TypeTuple::fields(1);
1129   fields[TypeFunc::Parms + 0] = NULL;
1130   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1131   return TypeFunc::make(domain, range);
1132 }
1133 
1134 const TypeFunc* OptoRuntime::vectorizedMismatch_Type() {
1135   // create input type (domain)
1136   int num_args = 4;
1137   int argcnt = num_args;
1138   const Type** fields = TypeTuple::fields(argcnt);
1139   int argp = TypeFunc::Parms;
1140   fields[argp++] = TypePtr::NOTNULL;    // obja
1141   fields[argp++] = TypePtr::NOTNULL;    // objb
1142   fields[argp++] = TypeInt::INT;        // length, number of elements
1143   fields[argp++] = TypeInt::INT;        // log2scale, element size
1144   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1145   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms + argcnt, fields);
1146 
1147   //return mismatch index (int)
1148   fields = TypeTuple::fields(1);
1149   fields[TypeFunc::Parms + 0] = TypeInt::INT;
1150   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms + 1, fields);
1151   return TypeFunc::make(domain, range);
1152 }
1153 
1154 // GHASH block processing
1155 const TypeFunc* OptoRuntime::ghash_processBlocks_Type() {
1156     int argcnt = 4;
1157 
1158     const Type** fields = TypeTuple::fields(argcnt);
1159     int argp = TypeFunc::Parms;
1160     fields[argp++] = TypePtr::NOTNULL;    // state
1161     fields[argp++] = TypePtr::NOTNULL;    // subkeyH
1162     fields[argp++] = TypePtr::NOTNULL;    // data
1163     fields[argp++] = TypeInt::INT;        // blocks
1164     assert(argp == TypeFunc::Parms+argcnt, &quot;correct decoding&quot;);
1165     const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1166 
1167     // result type needed
1168     fields = TypeTuple::fields(1);
1169     fields[TypeFunc::Parms+0] = NULL; // void
1170     const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1171     return TypeFunc::make(domain, range);
1172 }
1173 // Base64 encode function
1174 const TypeFunc* OptoRuntime::base64_encodeBlock_Type() {
1175   int argcnt = 6;
1176 
1177   const Type** fields = TypeTuple::fields(argcnt);
1178   int argp = TypeFunc::Parms;
1179   fields[argp++] = TypePtr::NOTNULL;    // src array
1180   fields[argp++] = TypeInt::INT;        // offset
1181   fields[argp++] = TypeInt::INT;        // length
1182   fields[argp++] = TypePtr::NOTNULL;    // dest array
1183   fields[argp++] = TypeInt::INT;       // dp
1184   fields[argp++] = TypeInt::BOOL;       // isURL
1185   assert(argp == TypeFunc::Parms + argcnt, &quot;correct decoding&quot;);
1186   const TypeTuple* domain = TypeTuple::make(TypeFunc::Parms+argcnt, fields);
1187 
1188   // result type needed
1189   fields = TypeTuple::fields(1);
1190   fields[TypeFunc::Parms + 0] = NULL; // void
1191   const TypeTuple* range = TypeTuple::make(TypeFunc::Parms, fields);
1192   return TypeFunc::make(domain, range);
1193 }
1194 
1195 //------------- Interpreter state access for on stack replacement
1196 const TypeFunc* OptoRuntime::osr_end_Type() {
1197   // create input type (domain)
1198   const Type **fields = TypeTuple::fields(1);
1199   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // OSR temp buf
1200   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1, fields);
1201 
1202   // create result type
1203   fields = TypeTuple::fields(1);
1204   // fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // locked oop
1205   fields[TypeFunc::Parms+0] = NULL; // void
1206   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
1207   return TypeFunc::make(domain, range);
1208 }
1209 
1210 //-------------- methodData update helpers
1211 
1212 const TypeFunc* OptoRuntime::profile_receiver_type_Type() {
1213   // create input type (domain)
1214   const Type **fields = TypeTuple::fields(2);
1215   fields[TypeFunc::Parms+0] = TypeAryPtr::NOTNULL;    // methodData pointer
1216   fields[TypeFunc::Parms+1] = TypeInstPtr::BOTTOM;    // receiver oop
1217   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2, fields);
1218 
1219   // create result type
1220   fields = TypeTuple::fields(1);
1221   fields[TypeFunc::Parms+0] = NULL; // void
1222   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms, fields);
1223   return TypeFunc::make(domain,range);
1224 }
1225 
1226 JRT_LEAF(void, OptoRuntime::profile_receiver_type_C(DataLayout* data, oopDesc* receiver))
1227   if (receiver == NULL) return;
1228   Klass* receiver_klass = receiver-&gt;klass();
1229 
1230   intptr_t* mdp = ((intptr_t*)(data)) + DataLayout::header_size_in_cells();
1231   int empty_row = -1;           // free row, if any is encountered
1232 
1233   // ReceiverTypeData* vc = new ReceiverTypeData(mdp);
1234   for (uint row = 0; row &lt; ReceiverTypeData::row_limit(); row++) {
1235     // if (vc-&gt;receiver(row) == receiver_klass)
1236     int receiver_off = ReceiverTypeData::receiver_cell_index(row);
1237     intptr_t row_recv = *(mdp + receiver_off);
1238     if (row_recv == (intptr_t) receiver_klass) {
1239       // vc-&gt;set_receiver_count(row, vc-&gt;receiver_count(row) + DataLayout::counter_increment);
1240       int count_off = ReceiverTypeData::receiver_count_cell_index(row);
1241       *(mdp + count_off) += DataLayout::counter_increment;
1242       return;
1243     } else if (row_recv == 0) {
1244       // else if (vc-&gt;receiver(row) == NULL)
1245       empty_row = (int) row;
1246     }
1247   }
1248 
1249   if (empty_row != -1) {
1250     int receiver_off = ReceiverTypeData::receiver_cell_index(empty_row);
1251     // vc-&gt;set_receiver(empty_row, receiver_klass);
1252     *(mdp + receiver_off) = (intptr_t) receiver_klass;
1253     // vc-&gt;set_receiver_count(empty_row, DataLayout::counter_increment);
1254     int count_off = ReceiverTypeData::receiver_count_cell_index(empty_row);
1255     *(mdp + count_off) = DataLayout::counter_increment;
1256   } else {
1257     // Receiver did not match any saved receiver and there is no empty row for it.
1258     // Increment total counter to indicate polymorphic case.
1259     intptr_t* count_p = (intptr_t*)(((uint8_t*)(data)) + in_bytes(CounterData::count_offset()));
1260     *count_p += DataLayout::counter_increment;
1261   }
1262 JRT_END
1263 
1264 //-------------------------------------------------------------------------------------
1265 // register policy
1266 
1267 bool OptoRuntime::is_callee_saved_register(MachRegisterNumbers reg) {
1268   assert(reg &gt;= 0 &amp;&amp; reg &lt; _last_Mach_Reg, &quot;must be a machine register&quot;);
1269   switch (register_save_policy[reg]) {
1270     case &#39;C&#39;: return false; //SOC
1271     case &#39;E&#39;: return true ; //SOE
1272     case &#39;N&#39;: return false; //NS
1273     case &#39;A&#39;: return false; //AS
1274   }
1275   ShouldNotReachHere();
1276   return false;
1277 }
1278 
1279 //-----------------------------------------------------------------------
1280 // Exceptions
1281 //
1282 
1283 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg);
1284 
1285 // The method is an entry that is always called by a C++ method not
1286 // directly from compiled code. Compiled code will call the C++ method following.
1287 // We can&#39;t allow async exception to be installed during  exception processing.
1288 JRT_ENTRY_NO_ASYNC(address, OptoRuntime::handle_exception_C_helper(JavaThread* thread, nmethod* &amp;nm))
1289 
1290   // Do not confuse exception_oop with pending_exception. The exception_oop
1291   // is only used to pass arguments into the method. Not for general
1292   // exception handling.  DO NOT CHANGE IT to use pending_exception, since
1293   // the runtime stubs checks this on exit.
1294   assert(thread-&gt;exception_oop() != NULL, &quot;exception oop is found&quot;);
1295   address handler_address = NULL;
1296 
1297   Handle exception(thread, thread-&gt;exception_oop());
1298   address pc = thread-&gt;exception_pc();
1299 
1300   // Clear out the exception oop and pc since looking up an
1301   // exception handler can cause class loading, which might throw an
1302   // exception and those fields are expected to be clear during
1303   // normal bytecode execution.
1304   thread-&gt;clear_exception_oop_and_pc();
1305 
1306   LogTarget(Info, exceptions) lt;
1307   if (lt.is_enabled()) {
1308     ResourceMark rm;
1309     LogStream ls(lt);
1310     trace_exception(&amp;ls, exception(), pc, &quot;&quot;);
1311   }
1312 
1313   // for AbortVMOnException flag
1314   Exceptions::debug_check_abort(exception);
1315 
1316 #ifdef ASSERT
1317   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1318     // should throw an exception here
1319     ShouldNotReachHere();
1320   }
1321 #endif
1322 
1323   // new exception handling: this method is entered only from adapters
1324   // exceptions from compiled java methods are handled in compiled code
1325   // using rethrow node
1326 
1327   nm = CodeCache::find_nmethod(pc);
1328   assert(nm != NULL, &quot;No NMethod found&quot;);
1329   if (nm-&gt;is_native_method()) {
1330     fatal(&quot;Native method should not have path to exception handling&quot;);
1331   } else {
1332     // we are switching to old paradigm: search for exception handler in caller_frame
1333     // instead in exception handler of caller_frame.sender()
1334 
1335     if (JvmtiExport::can_post_on_exceptions()) {
1336       // &quot;Full-speed catching&quot; is not necessary here,
1337       // since we&#39;re notifying the VM on every catch.
1338       // Force deoptimization and the rest of the lookup
1339       // will be fine.
1340       deoptimize_caller_frame(thread);
1341     }
1342 
1343     // Check the stack guard pages.  If enabled, look for handler in this frame;
1344     // otherwise, forcibly unwind the frame.
1345     //
1346     // 4826555: use default current sp for reguard_stack instead of &amp;nm: it&#39;s more accurate.
1347     bool force_unwind = !thread-&gt;reguard_stack();
1348     bool deopting = false;
1349     if (nm-&gt;is_deopt_pc(pc)) {
1350       deopting = true;
1351       RegisterMap map(thread, false);
1352       frame deoptee = thread-&gt;last_frame().sender(&amp;map);
1353       assert(deoptee.is_deoptimized_frame(), &quot;must be deopted&quot;);
1354       // Adjust the pc back to the original throwing pc
1355       pc = deoptee.pc();
1356     }
1357 
1358     // If we are forcing an unwind because of stack overflow then deopt is
1359     // irrelevant since we are throwing the frame away anyway.
1360 
1361     if (deopting &amp;&amp; !force_unwind) {
1362       handler_address = SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
1363     } else {
1364 
1365       handler_address =
1366         force_unwind ? NULL : nm-&gt;handler_for_exception_and_pc(exception, pc);
1367 
1368       if (handler_address == NULL) {
1369         bool recursive_exception = false;
1370         handler_address = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, force_unwind, true, recursive_exception);
1371         assert (handler_address != NULL, &quot;must have compiled handler&quot;);
1372         // Update the exception cache only when the unwind was not forced
1373         // and there didn&#39;t happen another exception during the computation of the
1374         // compiled exception handler. Checking for exception oop equality is not
1375         // sufficient because some exceptions are pre-allocated and reused.
1376         if (!force_unwind &amp;&amp; !recursive_exception) {
1377           nm-&gt;add_handler_for_exception_and_pc(exception,pc,handler_address);
1378         }
1379       } else {
1380 #ifdef ASSERT
1381         bool recursive_exception = false;
1382         address computed_address = SharedRuntime::compute_compiled_exc_handler(nm, pc, exception, force_unwind, true, recursive_exception);
1383         vmassert(recursive_exception || (handler_address == computed_address), &quot;Handler address inconsistency: &quot; PTR_FORMAT &quot; != &quot; PTR_FORMAT,
1384                  p2i(handler_address), p2i(computed_address));
1385 #endif
1386       }
1387     }
1388 
1389     thread-&gt;set_exception_pc(pc);
1390     thread-&gt;set_exception_handler_pc(handler_address);
1391 
1392     // Check if the exception PC is a MethodHandle call site.
1393     thread-&gt;set_is_method_handle_return(nm-&gt;is_method_handle_return(pc));
1394   }
1395 
1396   // Restore correct return pc.  Was saved above.
1397   thread-&gt;set_exception_oop(exception());
1398   return handler_address;
1399 
1400 JRT_END
1401 
1402 // We are entering here from exception_blob
1403 // If there is a compiled exception handler in this method, we will continue there;
1404 // otherwise we will unwind the stack and continue at the caller of top frame method
1405 // Note we enter without the usual JRT wrapper. We will call a helper routine that
1406 // will do the normal VM entry. We do it this way so that we can see if the nmethod
1407 // we looked up the handler for has been deoptimized in the meantime. If it has been
1408 // we must not use the handler and instead return the deopt blob.
1409 address OptoRuntime::handle_exception_C(JavaThread* thread) {
1410 //
1411 // We are in Java not VM and in debug mode we have a NoHandleMark
1412 //
1413 #ifndef PRODUCT
1414   SharedRuntime::_find_handler_ctr++;          // find exception handler
1415 #endif
1416   debug_only(NoHandleMark __hm;)
1417   nmethod* nm = NULL;
1418   address handler_address = NULL;
1419   {
1420     // Enter the VM
1421 
1422     ResetNoHandleMark rnhm;
1423     handler_address = handle_exception_C_helper(thread, nm);
1424   }
1425 
1426   // Back in java: Use no oops, DON&#39;T safepoint
1427 
1428   // Now check to see if the handler we are returning is in a now
1429   // deoptimized frame
1430 
1431   if (nm != NULL) {
1432     RegisterMap map(thread, false);
1433     frame caller = thread-&gt;last_frame().sender(&amp;map);
1434 #ifdef ASSERT
1435     assert(caller.is_compiled_frame(), &quot;must be&quot;);
1436 #endif // ASSERT
1437     if (caller.is_deoptimized_frame()) {
1438       handler_address = SharedRuntime::deopt_blob()-&gt;unpack_with_exception();
1439     }
1440   }
1441   return handler_address;
1442 }
1443 
1444 //------------------------------rethrow----------------------------------------
1445 // We get here after compiled code has executed a &#39;RethrowNode&#39;.  The callee
1446 // is either throwing or rethrowing an exception.  The callee-save registers
1447 // have been restored, synchronized objects have been unlocked and the callee
1448 // stack frame has been removed.  The return address was passed in.
1449 // Exception oop is passed as the 1st argument.  This routine is then called
1450 // from the stub.  On exit, we know where to jump in the caller&#39;s code.
1451 // After this C code exits, the stub will pop his frame and end in a jump
1452 // (instead of a return).  We enter the caller&#39;s default handler.
1453 //
1454 // This must be JRT_LEAF:
1455 //     - caller will not change its state as we cannot block on exit,
1456 //       therefore raw_exception_handler_for_return_address is all it takes
1457 //       to handle deoptimized blobs
1458 //
1459 // However, there needs to be a safepoint check in the middle!  So compiled
1460 // safepoints are completely watertight.
1461 //
1462 // Thus, it cannot be a leaf since it contains the NoSafepointVerifier.
1463 //
1464 // *THIS IS NOT RECOMMENDED PROGRAMMING STYLE*
1465 //
1466 address OptoRuntime::rethrow_C(oopDesc* exception, JavaThread* thread, address ret_pc) {
1467 #ifndef PRODUCT
1468   SharedRuntime::_rethrow_ctr++;               // count rethrows
1469 #endif
1470   assert (exception != NULL, &quot;should have thrown a NULLPointerException&quot;);
1471 #ifdef ASSERT
1472   if (!(exception-&gt;is_a(SystemDictionary::Throwable_klass()))) {
1473     // should throw an exception here
1474     ShouldNotReachHere();
1475   }
1476 #endif
1477 
1478   thread-&gt;set_vm_result(exception);
1479   // Frame not compiled (handles deoptimization blob)
1480   return SharedRuntime::raw_exception_handler_for_return_address(thread, ret_pc);
1481 }
1482 
1483 
1484 const TypeFunc *OptoRuntime::rethrow_Type() {
1485   // create input type (domain)
1486   const Type **fields = TypeTuple::fields(1);
1487   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Exception oop
1488   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);
1489 
1490   // create result type (range)
1491   fields = TypeTuple::fields(1);
1492   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL; // Exception oop
1493   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+1, fields);
1494 
1495   return TypeFunc::make(domain, range);
1496 }
1497 
1498 
1499 void OptoRuntime::deoptimize_caller_frame(JavaThread *thread, bool doit) {
1500   // Deoptimize the caller before continuing, as the compiled
1501   // exception handler table may not be valid.
1502   if (!StressCompiledExceptionHandlers &amp;&amp; doit) {
1503     deoptimize_caller_frame(thread);
1504   }
1505 }
1506 
1507 void OptoRuntime::deoptimize_caller_frame(JavaThread *thread) {
1508   // Called from within the owner thread, so no need for safepoint
1509   RegisterMap reg_map(thread);
1510   frame stub_frame = thread-&gt;last_frame();
1511   assert(stub_frame.is_runtime_frame() || exception_blob()-&gt;contains(stub_frame.pc()), &quot;sanity check&quot;);
1512   frame caller_frame = stub_frame.sender(&amp;reg_map);
1513 
1514   // Deoptimize the caller frame.
1515   Deoptimization::deoptimize_frame(thread, caller_frame.id());
1516 }
1517 
1518 
1519 bool OptoRuntime::is_deoptimized_caller_frame(JavaThread *thread) {
1520   // Called from within the owner thread, so no need for safepoint
1521   RegisterMap reg_map(thread);
1522   frame stub_frame = thread-&gt;last_frame();
1523   assert(stub_frame.is_runtime_frame() || exception_blob()-&gt;contains(stub_frame.pc()), &quot;sanity check&quot;);
1524   frame caller_frame = stub_frame.sender(&amp;reg_map);
1525   return caller_frame.is_deoptimized_frame();
1526 }
1527 
1528 
1529 const TypeFunc *OptoRuntime::register_finalizer_Type() {
1530   // create input type (domain)
1531   const Type **fields = TypeTuple::fields(1);
1532   fields[TypeFunc::Parms+0] = TypeInstPtr::NOTNULL;  // oop;          Receiver
1533   // // The JavaThread* is passed to each routine as the last argument
1534   // fields[TypeFunc::Parms+1] = TypeRawPtr::NOTNULL;  // JavaThread *; Executing thread
1535   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+1,fields);
1536 
1537   // create result type (range)
1538   fields = TypeTuple::fields(0);
1539 
1540   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1541 
1542   return TypeFunc::make(domain,range);
1543 }
1544 
1545 
1546 //-----------------------------------------------------------------------------
1547 // Dtrace support.  entry and exit probes have the same signature
1548 const TypeFunc *OptoRuntime::dtrace_method_entry_exit_Type() {
1549   // create input type (domain)
1550   const Type **fields = TypeTuple::fields(2);
1551   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // Thread-local storage
1552   fields[TypeFunc::Parms+1] = TypeMetadataPtr::BOTTOM;  // Method*;    Method we are entering
1553   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
1554 
1555   // create result type (range)
1556   fields = TypeTuple::fields(0);
1557 
1558   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1559 
1560   return TypeFunc::make(domain,range);
1561 }
1562 
1563 const TypeFunc *OptoRuntime::dtrace_object_alloc_Type() {
1564   // create input type (domain)
1565   const Type **fields = TypeTuple::fields(2);
1566   fields[TypeFunc::Parms+0] = TypeRawPtr::BOTTOM; // Thread-local storage
1567   fields[TypeFunc::Parms+1] = TypeInstPtr::NOTNULL;  // oop;    newly allocated object
1568 
1569   const TypeTuple *domain = TypeTuple::make(TypeFunc::Parms+2,fields);
1570 
1571   // create result type (range)
1572   fields = TypeTuple::fields(0);
1573 
1574   const TypeTuple *range = TypeTuple::make(TypeFunc::Parms+0,fields);
1575 
1576   return TypeFunc::make(domain,range);
1577 }
1578 
1579 
1580 JRT_ENTRY_NO_ASYNC(void, OptoRuntime::register_finalizer(oopDesc* obj, JavaThread* thread))
1581   assert(oopDesc::is_oop(obj), &quot;must be a valid oop&quot;);
1582   assert(obj-&gt;klass()-&gt;has_finalizer(), &quot;shouldn&#39;t be here otherwise&quot;);
1583   InstanceKlass::register_finalizer(instanceOop(obj), CHECK);
1584 JRT_END
1585 
1586 //-----------------------------------------------------------------------------
1587 
1588 NamedCounter * volatile OptoRuntime::_named_counters = NULL;
1589 
1590 //
1591 // dump the collected NamedCounters.
1592 //
1593 void OptoRuntime::print_named_counters() {
1594   int total_lock_count = 0;
1595   int eliminated_lock_count = 0;
1596 
1597   NamedCounter* c = _named_counters;
1598   while (c) {
1599     if (c-&gt;tag() == NamedCounter::LockCounter || c-&gt;tag() == NamedCounter::EliminatedLockCounter) {
1600       int count = c-&gt;count();
1601       if (count &gt; 0) {
1602         bool eliminated = c-&gt;tag() == NamedCounter::EliminatedLockCounter;
1603         if (Verbose) {
1604           tty-&gt;print_cr(&quot;%d %s%s&quot;, count, c-&gt;name(), eliminated ? &quot; (eliminated)&quot; : &quot;&quot;);
1605         }
1606         total_lock_count += count;
1607         if (eliminated) {
1608           eliminated_lock_count += count;
1609         }
1610       }
1611     } else if (c-&gt;tag() == NamedCounter::BiasedLockingCounter) {
1612       BiasedLockingCounters* blc = ((BiasedLockingNamedCounter*)c)-&gt;counters();
1613       if (blc-&gt;nonzero()) {
1614         tty-&gt;print_cr(&quot;%s&quot;, c-&gt;name());
1615         blc-&gt;print_on(tty);
1616       }
1617 #if INCLUDE_RTM_OPT
1618     } else if (c-&gt;tag() == NamedCounter::RTMLockingCounter) {
1619       RTMLockingCounters* rlc = ((RTMLockingNamedCounter*)c)-&gt;counters();
1620       if (rlc-&gt;nonzero()) {
1621         tty-&gt;print_cr(&quot;%s&quot;, c-&gt;name());
1622         rlc-&gt;print_on(tty);
1623       }
1624 #endif
1625     }
1626     c = c-&gt;next();
1627   }
1628   if (total_lock_count &gt; 0) {
1629     tty-&gt;print_cr(&quot;dynamic locks: %d&quot;, total_lock_count);
1630     if (eliminated_lock_count) {
1631       tty-&gt;print_cr(&quot;eliminated locks: %d (%d%%)&quot;, eliminated_lock_count,
1632                     (int)(eliminated_lock_count * 100.0 / total_lock_count));
1633     }
1634   }
1635 }
1636 
1637 //
1638 //  Allocate a new NamedCounter.  The JVMState is used to generate the
1639 //  name which consists of method@line for the inlining tree.
1640 //
1641 
1642 NamedCounter* OptoRuntime::new_named_counter(JVMState* youngest_jvms, NamedCounter::CounterTag tag) {
1643   int max_depth = youngest_jvms-&gt;depth();
1644 
1645   // Visit scopes from youngest to oldest.
1646   bool first = true;
1647   stringStream st;
1648   for (int depth = max_depth; depth &gt;= 1; depth--) {
1649     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1650     ciMethod* m = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1651     if (!first) {
1652       st.print(&quot; &quot;);
1653     } else {
1654       first = false;
1655     }
1656     int bci = jvms-&gt;bci();
1657     if (bci &lt; 0) bci = 0;
1658     if (m != NULL) {
1659       st.print(&quot;%s.%s&quot;, m-&gt;holder()-&gt;name()-&gt;as_utf8(), m-&gt;name()-&gt;as_utf8());
1660     } else {
1661       st.print(&quot;no method&quot;);
1662     }
1663     st.print(&quot;@%d&quot;, bci);
1664     // To print linenumbers instead of bci use: m-&gt;line_number_from_bci(bci)
1665   }
1666   NamedCounter* c;
1667   if (tag == NamedCounter::BiasedLockingCounter) {
1668     c = new BiasedLockingNamedCounter(st.as_string());
1669   } else if (tag == NamedCounter::RTMLockingCounter) {
1670     c = new RTMLockingNamedCounter(st.as_string());
1671   } else {
1672     c = new NamedCounter(st.as_string(), tag);
1673   }
1674 
1675   // atomically add the new counter to the head of the list.  We only
1676   // add counters so this is safe.
1677   NamedCounter* head;
1678   do {
1679     c-&gt;set_next(NULL);
1680     head = _named_counters;
1681     c-&gt;set_next(head);
1682   } while (Atomic::cmpxchg(&amp;_named_counters, head, c) != head);
1683   return c;
1684 }
1685 
1686 int trace_exception_counter = 0;
1687 static void trace_exception(outputStream* st, oop exception_oop, address exception_pc, const char* msg) {
1688   trace_exception_counter++;
1689   stringStream tempst;
1690 
1691   tempst.print(&quot;%d [Exception (%s): &quot;, trace_exception_counter, msg);
1692   exception_oop-&gt;print_value_on(&amp;tempst);
1693   tempst.print(&quot; in &quot;);
1694   CodeBlob* blob = CodeCache::find_blob(exception_pc);
1695   if (blob-&gt;is_compiled()) {
1696     CompiledMethod* cm = blob-&gt;as_compiled_method_or_null();
1697     cm-&gt;method()-&gt;print_value_on(&amp;tempst);
1698   } else if (blob-&gt;is_runtime_stub()) {
1699     tempst.print(&quot;&lt;runtime-stub&gt;&quot;);
1700   } else {
1701     tempst.print(&quot;&lt;unknown&gt;&quot;);
1702   }
1703   tempst.print(&quot; at &quot; INTPTR_FORMAT,  p2i(exception_pc));
1704   tempst.print(&quot;]&quot;);
1705 
1706   st-&gt;print_raw_cr(tempst.as_string());
1707 }
    </pre>
  </body>
</html>
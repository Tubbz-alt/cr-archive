<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/macro.hpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroArrayCopy.cpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/macro.hpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
102                               address slow_call_address);
103   void yank_initalize_node(InitializeNode* node);
104   void yank_alloc_node(AllocateNode* alloc);
105   Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);
106   Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);
107 
108   bool eliminate_boxing_node(CallStaticJavaNode *boxing);
109   bool eliminate_allocate_node(AllocateNode *alloc);
110   bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints);
111   bool scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints_done);
112   void process_users_of_allocation(CallNode *alloc);
113 
114   void eliminate_gc_barrier(Node *p2x);
115   void mark_eliminated_box(Node* box, Node* obj);
116   void mark_eliminated_locking_nodes(AbstractLockNode *alock);
117   bool eliminate_locking_node(AbstractLockNode *alock);
118   void expand_lock_node(LockNode *lock);
119   void expand_unlock_node(UnlockNode *unlock);
120 
121   // More helper methods modeled after GraphKit for array copy
<span class="line-modified">122   void insert_mem_bar(Node** ctrl, Node** mem, int opcode, int alias_idx = Compile::AliasIdxBot, Node* precedent = NULL);</span>
123   Node* array_element_address(Node* ary, Node* idx, BasicType elembt);
124   Node* ConvI2L(Node* offset);
125 
126   // helper methods modeled after LibraryCallKit for array copy
127   Node* generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob);
128   Node* generate_slow_guard(Node** ctrl, Node* test, RegionNode* region);
129   void generate_negative_guard(Node** ctrl, Node* index, RegionNode* region);
130   void generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region);
131 
132   // More helper methods for array copy
133   Node* generate_nonpositive_guard(Node** ctrl, Node* index, bool never_negative);
134   void finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type);
135   Node* generate_arraycopy(ArrayCopyNode *ac,
136                            AllocateArrayNode* alloc,
137                            Node** ctrl, MergeMemNode* mem, Node** io,
138                            const TypePtr* adr_type,
139                            BasicType basic_elem_type,
140                            Node* src,  Node* src_offset,
141                            Node* dest, Node* dest_offset,
142                            Node* copy_length,
</pre>
</td>
<td>
<hr />
<pre>
102                               address slow_call_address);
103   void yank_initalize_node(InitializeNode* node);
104   void yank_alloc_node(AllocateNode* alloc);
105   Node *value_from_mem(Node *mem, Node *ctl, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc);
106   Node *value_from_mem_phi(Node *mem, BasicType ft, const Type *ftype, const TypeOopPtr *adr_t, AllocateNode *alloc, Node_Stack *value_phis, int level);
107 
108   bool eliminate_boxing_node(CallStaticJavaNode *boxing);
109   bool eliminate_allocate_node(AllocateNode *alloc);
110   bool can_eliminate_allocation(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints);
111   bool scalar_replacement(AllocateNode *alloc, GrowableArray &lt;SafePointNode *&gt;&amp; safepoints_done);
112   void process_users_of_allocation(CallNode *alloc);
113 
114   void eliminate_gc_barrier(Node *p2x);
115   void mark_eliminated_box(Node* box, Node* obj);
116   void mark_eliminated_locking_nodes(AbstractLockNode *alock);
117   bool eliminate_locking_node(AbstractLockNode *alock);
118   void expand_lock_node(LockNode *lock);
119   void expand_unlock_node(UnlockNode *unlock);
120 
121   // More helper methods modeled after GraphKit for array copy
<span class="line-modified">122   void insert_mem_bar(Node** ctrl, Node** mem, int opcode, Node* precedent = NULL);</span>
123   Node* array_element_address(Node* ary, Node* idx, BasicType elembt);
124   Node* ConvI2L(Node* offset);
125 
126   // helper methods modeled after LibraryCallKit for array copy
127   Node* generate_guard(Node** ctrl, Node* test, RegionNode* region, float true_prob);
128   Node* generate_slow_guard(Node** ctrl, Node* test, RegionNode* region);
129   void generate_negative_guard(Node** ctrl, Node* index, RegionNode* region);
130   void generate_limit_guard(Node** ctrl, Node* offset, Node* subseq_length, Node* array_length, RegionNode* region);
131 
132   // More helper methods for array copy
133   Node* generate_nonpositive_guard(Node** ctrl, Node* index, bool never_negative);
134   void finish_arraycopy_call(Node* call, Node** ctrl, MergeMemNode** mem, const TypePtr* adr_type);
135   Node* generate_arraycopy(ArrayCopyNode *ac,
136                            AllocateArrayNode* alloc,
137                            Node** ctrl, MergeMemNode* mem, Node** io,
138                            const TypePtr* adr_type,
139                            BasicType basic_elem_type,
140                            Node* src,  Node* src_offset,
141                            Node* dest, Node* dest_offset,
142                            Node* copy_length,
</pre>
</td>
</tr>
</table>
<center><a href="macro.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="macroArrayCopy.cpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/macroAssembler.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;ci/ciReplay.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;code/exceptionHandlerTable.hpp&quot;
  31 #include &quot;code/nmethod.hpp&quot;
  32 #include &quot;compiler/compileBroker.hpp&quot;
  33 #include &quot;compiler/compileLog.hpp&quot;
  34 #include &quot;compiler/disassembler.hpp&quot;
  35 #include &quot;compiler/oopMap.hpp&quot;
  36 #include &quot;gc/shared/barrierSet.hpp&quot;
  37 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  38 #include &quot;memory/resourceArea.hpp&quot;
  39 #include &quot;opto/addnode.hpp&quot;
  40 #include &quot;opto/block.hpp&quot;
  41 #include &quot;opto/c2compiler.hpp&quot;
  42 #include &quot;opto/callGenerator.hpp&quot;
  43 #include &quot;opto/callnode.hpp&quot;
  44 #include &quot;opto/castnode.hpp&quot;
  45 #include &quot;opto/cfgnode.hpp&quot;
  46 #include &quot;opto/chaitin.hpp&quot;
  47 #include &quot;opto/compile.hpp&quot;
  48 #include &quot;opto/connode.hpp&quot;
  49 #include &quot;opto/convertnode.hpp&quot;
  50 #include &quot;opto/divnode.hpp&quot;
  51 #include &quot;opto/escape.hpp&quot;
  52 #include &quot;opto/idealGraphPrinter.hpp&quot;
  53 #include &quot;opto/loopnode.hpp&quot;
  54 #include &quot;opto/machnode.hpp&quot;
  55 #include &quot;opto/macro.hpp&quot;
  56 #include &quot;opto/matcher.hpp&quot;
  57 #include &quot;opto/mathexactnode.hpp&quot;
  58 #include &quot;opto/memnode.hpp&quot;
  59 #include &quot;opto/mulnode.hpp&quot;
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/vectornode.hpp&quot;
  71 #include &quot;runtime/arguments.hpp&quot;
  72 #include &quot;runtime/sharedRuntime.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/stubRoutines.hpp&quot;
  75 #include &quot;runtime/timer.hpp&quot;
  76 #include &quot;utilities/align.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/macros.hpp&quot;
<a name="1" id="anc1"></a>
  79 
  80 
  81 // -------------------- Compile::mach_constant_base_node -----------------------
  82 // Constant table base node singleton.
  83 MachConstantBaseNode* Compile::mach_constant_base_node() {
  84   if (_mach_constant_base_node == NULL) {
  85     _mach_constant_base_node = new MachConstantBaseNode();
  86     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  87   }
  88   return _mach_constant_base_node;
  89 }
  90 
  91 
  92 /// Support for intrinsics.
  93 
  94 // Return the index at which m must be inserted (or already exists).
  95 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  96 class IntrinsicDescPair {
  97  private:
  98   ciMethod* _m;
  99   bool _is_virtual;
 100  public:
 101   IntrinsicDescPair(ciMethod* m, bool is_virtual) : _m(m), _is_virtual(is_virtual) {}
 102   static int compare(IntrinsicDescPair* const&amp; key, CallGenerator* const&amp; elt) {
 103     ciMethod* m= elt-&gt;method();
 104     ciMethod* key_m = key-&gt;_m;
 105     if (key_m &lt; m)      return -1;
 106     else if (key_m &gt; m) return 1;
 107     else {
 108       bool is_virtual = elt-&gt;is_virtual();
 109       bool key_virtual = key-&gt;_is_virtual;
 110       if (key_virtual &lt; is_virtual)      return -1;
 111       else if (key_virtual &gt; is_virtual) return 1;
 112       else                               return 0;
 113     }
 114   }
 115 };
 116 int Compile::intrinsic_insertion_index(ciMethod* m, bool is_virtual, bool&amp; found) {
 117 #ifdef ASSERT
 118   for (int i = 1; i &lt; _intrinsics-&gt;length(); i++) {
 119     CallGenerator* cg1 = _intrinsics-&gt;at(i-1);
 120     CallGenerator* cg2 = _intrinsics-&gt;at(i);
 121     assert(cg1-&gt;method() != cg2-&gt;method()
 122            ? cg1-&gt;method()     &lt; cg2-&gt;method()
 123            : cg1-&gt;is_virtual() &lt; cg2-&gt;is_virtual(),
 124            &quot;compiler intrinsics list must stay sorted&quot;);
 125   }
 126 #endif
 127   IntrinsicDescPair pair(m, is_virtual);
 128   return _intrinsics-&gt;find_sorted&lt;IntrinsicDescPair*, IntrinsicDescPair::compare&gt;(&amp;pair, found);
 129 }
 130 
 131 void Compile::register_intrinsic(CallGenerator* cg) {
 132   if (_intrinsics == NULL) {
 133     _intrinsics = new (comp_arena())GrowableArray&lt;CallGenerator*&gt;(comp_arena(), 60, 0, NULL);
 134   }
 135   int len = _intrinsics-&gt;length();
 136   bool found = false;
 137   int index = intrinsic_insertion_index(cg-&gt;method(), cg-&gt;is_virtual(), found);
 138   assert(!found, &quot;registering twice&quot;);
 139   _intrinsics-&gt;insert_before(index, cg);
 140   assert(find_intrinsic(cg-&gt;method(), cg-&gt;is_virtual()) == cg, &quot;registration worked&quot;);
 141 }
 142 
 143 CallGenerator* Compile::find_intrinsic(ciMethod* m, bool is_virtual) {
 144   assert(m-&gt;is_loaded(), &quot;don&#39;t try this on unloaded methods&quot;);
 145   if (_intrinsics != NULL) {
 146     bool found = false;
 147     int index = intrinsic_insertion_index(m, is_virtual, found);
 148      if (found) {
 149       return _intrinsics-&gt;at(index);
 150     }
 151   }
 152   // Lazily create intrinsics for intrinsic IDs well-known in the runtime.
 153   if (m-&gt;intrinsic_id() != vmIntrinsics::_none &amp;&amp;
 154       m-&gt;intrinsic_id() &lt;= vmIntrinsics::LAST_COMPILER_INLINE) {
 155     CallGenerator* cg = make_vm_intrinsic(m, is_virtual);
 156     if (cg != NULL) {
 157       // Save it for next time:
 158       register_intrinsic(cg);
 159       return cg;
 160     } else {
 161       gather_intrinsic_statistics(m-&gt;intrinsic_id(), is_virtual, _intrinsic_disabled);
 162     }
 163   }
 164   return NULL;
 165 }
 166 
 167 // Compile:: register_library_intrinsics and make_vm_intrinsic are defined
 168 // in library_call.cpp.
 169 
 170 
 171 #ifndef PRODUCT
 172 // statistics gathering...
 173 
 174 juint  Compile::_intrinsic_hist_count[vmIntrinsics::ID_LIMIT] = {0};
 175 jubyte Compile::_intrinsic_hist_flags[vmIntrinsics::ID_LIMIT] = {0};
 176 
 177 bool Compile::gather_intrinsic_statistics(vmIntrinsics::ID id, bool is_virtual, int flags) {
 178   assert(id &gt; vmIntrinsics::_none &amp;&amp; id &lt; vmIntrinsics::ID_LIMIT, &quot;oob&quot;);
 179   int oflags = _intrinsic_hist_flags[id];
 180   assert(flags != 0, &quot;what happened?&quot;);
 181   if (is_virtual) {
 182     flags |= _intrinsic_virtual;
 183   }
 184   bool changed = (flags != oflags);
 185   if ((flags &amp; _intrinsic_worked) != 0) {
 186     juint count = (_intrinsic_hist_count[id] += 1);
 187     if (count == 1) {
 188       changed = true;           // first time
 189     }
 190     // increment the overall count also:
 191     _intrinsic_hist_count[vmIntrinsics::_none] += 1;
 192   }
 193   if (changed) {
 194     if (((oflags ^ flags) &amp; _intrinsic_virtual) != 0) {
 195       // Something changed about the intrinsic&#39;s virtuality.
 196       if ((flags &amp; _intrinsic_virtual) != 0) {
 197         // This is the first use of this intrinsic as a virtual call.
 198         if (oflags != 0) {
 199           // We already saw it as a non-virtual, so note both cases.
 200           flags |= _intrinsic_both;
 201         }
 202       } else if ((oflags &amp; _intrinsic_both) == 0) {
 203         // This is the first use of this intrinsic as a non-virtual
 204         flags |= _intrinsic_both;
 205       }
 206     }
 207     _intrinsic_hist_flags[id] = (jubyte) (oflags | flags);
 208   }
 209   // update the overall flags also:
 210   _intrinsic_hist_flags[vmIntrinsics::_none] |= (jubyte) flags;
 211   return changed;
 212 }
 213 
 214 static char* format_flags(int flags, char* buf) {
 215   buf[0] = 0;
 216   if ((flags &amp; Compile::_intrinsic_worked) != 0)    strcat(buf, &quot;,worked&quot;);
 217   if ((flags &amp; Compile::_intrinsic_failed) != 0)    strcat(buf, &quot;,failed&quot;);
 218   if ((flags &amp; Compile::_intrinsic_disabled) != 0)  strcat(buf, &quot;,disabled&quot;);
 219   if ((flags &amp; Compile::_intrinsic_virtual) != 0)   strcat(buf, &quot;,virtual&quot;);
 220   if ((flags &amp; Compile::_intrinsic_both) != 0)      strcat(buf, &quot;,nonvirtual&quot;);
 221   if (buf[0] == 0)  strcat(buf, &quot;,&quot;);
 222   assert(buf[0] == &#39;,&#39;, &quot;must be&quot;);
 223   return &amp;buf[1];
 224 }
 225 
 226 void Compile::print_intrinsic_statistics() {
 227   char flagsbuf[100];
 228   ttyLocker ttyl;
 229   if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;intrinsic&#39;&quot;);
 230   tty-&gt;print_cr(&quot;Compiler intrinsic usage:&quot;);
 231   juint total = _intrinsic_hist_count[vmIntrinsics::_none];
 232   if (total == 0)  total = 1;  // avoid div0 in case of no successes
 233   #define PRINT_STAT_LINE(name, c, f) \
 234     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 235   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 236     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 237     int   flags = _intrinsic_hist_flags[id];
 238     juint count = _intrinsic_hist_count[id];
 239     if ((flags | count) != 0) {
 240       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 241     }
 242   }
 243   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 244   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 245 }
 246 
 247 void Compile::print_statistics() {
 248   { ttyLocker ttyl;
 249     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 250     Parse::print_statistics();
 251     PhaseCCP::print_statistics();
 252     PhaseRegAlloc::print_statistics();
<a name="2" id="anc2"></a><span class="line-modified"> 253     Scheduling::print_statistics();</span>
 254     PhasePeephole::print_statistics();
 255     PhaseIdealLoop::print_statistics();
 256     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 257   }
 258   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 259     // put this under its own &lt;statistics&gt; element.
 260     print_intrinsic_statistics();
 261   }
 262 }
 263 #endif //PRODUCT
 264 
<a name="3" id="anc3"></a><span class="line-removed"> 265 // Support for bundling info</span>
<span class="line-removed"> 266 Bundle* Compile::node_bundling(const Node *n) {</span>
<span class="line-removed"> 267   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-removed"> 268   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-removed"> 269 }</span>
<span class="line-removed"> 270 </span>
<span class="line-removed"> 271 bool Compile::valid_bundle_info(const Node *n) {</span>
<span class="line-removed"> 272   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-removed"> 273 }</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275 </span>
 276 void Compile::gvn_replace_by(Node* n, Node* nn) {
 277   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 278     Node* use = n-&gt;last_out(i);
 279     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 280     uint uses_found = 0;
 281     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 282       if (use-&gt;in(j) == n) {
 283         if (j &lt; use-&gt;req())
 284           use-&gt;set_req(j, nn);
 285         else
 286           use-&gt;set_prec(j, nn);
 287         uses_found++;
 288       }
 289     }
 290     if (is_in_table) {
 291       // reinsert into table
 292       initial_gvn()-&gt;hash_find_insert(use);
 293     }
 294     record_for_igvn(use);
 295     i -= uses_found;    // we deleted 1 or more copies of this edge
 296   }
 297 }
 298 
 299 
 300 static inline bool not_a_node(const Node* n) {
 301   if (n == NULL)                   return true;
 302   if (((intptr_t)n &amp; 1) != 0)      return true;  // uninitialized, etc.
 303   if (*(address*)n == badAddress)  return true;  // kill by Node::destruct
 304   return false;
 305 }
 306 
 307 // Identify all nodes that are reachable from below, useful.
 308 // Use breadth-first pass that records state in a Unique_Node_List,
 309 // recursive traversal is slower.
 310 void Compile::identify_useful_nodes(Unique_Node_List &amp;useful) {
 311   int estimated_worklist_size = live_nodes();
 312   useful.map( estimated_worklist_size, NULL );  // preallocate space
 313 
 314   // Initialize worklist
 315   if (root() != NULL)     { useful.push(root()); }
 316   // If &#39;top&#39; is cached, declare it useful to preserve cached node
 317   if( cached_top_node() ) { useful.push(cached_top_node()); }
 318 
 319   // Push all useful nodes onto the list, breadthfirst
 320   for( uint next = 0; next &lt; useful.size(); ++next ) {
 321     assert( next &lt; unique(), &quot;Unique useful nodes &lt; total nodes&quot;);
 322     Node *n  = useful.at(next);
 323     uint max = n-&gt;len();
 324     for( uint i = 0; i &lt; max; ++i ) {
 325       Node *m = n-&gt;in(i);
 326       if (not_a_node(m))  continue;
 327       useful.push(m);
 328     }
 329   }
 330 }
 331 
 332 // Update dead_node_list with any missing dead nodes using useful
 333 // list. Consider all non-useful nodes to be useless i.e., dead nodes.
 334 void Compile::update_dead_node_list(Unique_Node_List &amp;useful) {
 335   uint max_idx = unique();
 336   VectorSet&amp; useful_node_set = useful.member_set();
 337 
 338   for (uint node_idx = 0; node_idx &lt; max_idx; node_idx++) {
 339     // If node with index node_idx is not in useful set,
 340     // mark it as dead in dead node list.
 341     if (!useful_node_set.test(node_idx)) {
 342       record_dead_node(node_idx);
 343     }
 344   }
 345 }
 346 
 347 void Compile::remove_useless_late_inlines(GrowableArray&lt;CallGenerator*&gt;* inlines, Unique_Node_List &amp;useful) {
 348   int shift = 0;
 349   for (int i = 0; i &lt; inlines-&gt;length(); i++) {
 350     CallGenerator* cg = inlines-&gt;at(i);
 351     CallNode* call = cg-&gt;call_node();
 352     if (shift &gt; 0) {
 353       inlines-&gt;at_put(i-shift, cg);
 354     }
 355     if (!useful.member(call)) {
 356       shift++;
 357     }
 358   }
 359   inlines-&gt;trunc_to(inlines-&gt;length()-shift);
 360 }
 361 
 362 // Disconnect all useless nodes by disconnecting those at the boundary.
 363 void Compile::remove_useless_nodes(Unique_Node_List &amp;useful) {
 364   uint next = 0;
 365   while (next &lt; useful.size()) {
 366     Node *n = useful.at(next++);
 367     if (n-&gt;is_SafePoint()) {
 368       // We&#39;re done with a parsing phase. Replaced nodes are not valid
 369       // beyond that point.
 370       n-&gt;as_SafePoint()-&gt;delete_replaced_nodes();
 371     }
 372     // Use raw traversal of out edges since this code removes out edges
 373     int max = n-&gt;outcnt();
 374     for (int j = 0; j &lt; max; ++j) {
 375       Node* child = n-&gt;raw_out(j);
 376       if (! useful.member(child)) {
 377         assert(!child-&gt;is_top() || child != top(),
 378                &quot;If top is cached in Compile object it is in useful list&quot;);
 379         // Only need to remove this out-edge to the useless node
 380         n-&gt;raw_del_out(j);
 381         --j;
 382         --max;
 383       }
 384     }
 385     if (n-&gt;outcnt() == 1 &amp;&amp; n-&gt;has_special_unique_user()) {
 386       record_for_igvn(n-&gt;unique_out());
 387     }
 388   }
 389   // Remove useless macro and predicate opaq nodes
 390   for (int i = C-&gt;macro_count()-1; i &gt;= 0; i--) {
 391     Node* n = C-&gt;macro_node(i);
 392     if (!useful.member(n)) {
 393       remove_macro_node(n);
 394     }
 395   }
 396   // Remove useless CastII nodes with range check dependency
 397   for (int i = range_check_cast_count() - 1; i &gt;= 0; i--) {
 398     Node* cast = range_check_cast_node(i);
 399     if (!useful.member(cast)) {
 400       remove_range_check_cast(cast);
 401     }
 402   }
 403   // Remove useless expensive nodes
 404   for (int i = C-&gt;expensive_count()-1; i &gt;= 0; i--) {
 405     Node* n = C-&gt;expensive_node(i);
 406     if (!useful.member(n)) {
 407       remove_expensive_node(n);
 408     }
 409   }
 410   // Remove useless Opaque4 nodes
 411   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 412     Node* opaq = opaque4_node(i);
 413     if (!useful.member(opaq)) {
 414       remove_opaque4_node(opaq);
 415     }
 416   }
 417   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 418   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 419   // clean up the late inline lists
 420   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 421   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 422   remove_useless_late_inlines(&amp;_late_inlines, useful);
 423   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 424 }
 425 
<a name="4" id="anc4"></a><span class="line-removed"> 426 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-removed"> 427 // frame_slots in units of words</span>
<span class="line-removed"> 428 int Compile::frame_size_in_words() const {</span>
<span class="line-removed"> 429   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-removed"> 430   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-removed"> 431   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-removed"> 432   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-removed"> 433   return words;</span>
<span class="line-removed"> 434 }</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-removed"> 437 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-removed"> 438 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-removed"> 439 // in turn simplifies stack overflow handling.</span>
<span class="line-removed"> 440 int Compile::bang_size_in_bytes() const {</span>
<span class="line-removed"> 441   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _interpreter_frame_size);</span>
<span class="line-removed"> 442 }</span>
<span class="line-removed"> 443 </span>
 444 // ============================================================================
 445 //------------------------------CompileWrapper---------------------------------
 446 class CompileWrapper : public StackObj {
 447   Compile *const _compile;
 448  public:
 449   CompileWrapper(Compile* compile);
 450 
 451   ~CompileWrapper();
 452 };
 453 
 454 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 455   // the Compile* pointer is stored in the current ciEnv:
 456   ciEnv* env = compile-&gt;env();
 457   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 458   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 459   env-&gt;set_compiler_data(compile);
 460   assert(compile == Compile::current(), &quot;sanity&quot;);
 461 
 462   compile-&gt;set_type_dict(NULL);
 463   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 464   compile-&gt;clone_map().set_clone_idx(0);
 465   compile-&gt;set_type_last_size(0);
 466   compile-&gt;set_last_tf(NULL, NULL);
 467   compile-&gt;set_indexSet_arena(NULL);
 468   compile-&gt;set_indexSet_free_block_list(NULL);
 469   compile-&gt;init_type_arena();
 470   Type::Initialize(compile);
<a name="5" id="anc5"></a><span class="line-removed"> 471   _compile-&gt;set_scratch_buffer_blob(NULL);</span>
 472   _compile-&gt;begin_method();
 473   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 474 }
 475 CompileWrapper::~CompileWrapper() {
 476   _compile-&gt;end_method();
<a name="6" id="anc6"></a><span class="line-removed"> 477   if (_compile-&gt;scratch_buffer_blob() != NULL)</span>
<span class="line-removed"> 478     BufferBlob::free(_compile-&gt;scratch_buffer_blob());</span>
 479   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 480 }
 481 
 482 
 483 //----------------------------print_compile_messages---------------------------
 484 void Compile::print_compile_messages() {
 485 #ifndef PRODUCT
 486   // Check if recompiling
 487   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 488     // Recompiling without allowing machine instructions to subsume loads
 489     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 490     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 491     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 492   }
 493   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 494     // Recompiling without escape analysis
 495     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 496     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 497     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 498   }
 499   if (_eliminate_boxing != EliminateAutoBox &amp;&amp; PrintOpto) {
 500     // Recompiling without boxing elimination
 501     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 502     tty-&gt;print_cr(&quot;** Bailout: Recompile without boxing elimination       **&quot;);
 503     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 504   }
 505   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 506     // Open the debugger when compiling this method.
 507     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 508     method()-&gt;print_short_name();
 509     tty-&gt;cr();
 510     BREAKPOINT;
 511   }
 512 
 513   if( PrintOpto ) {
 514     if (is_osr_compilation()) {
 515       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 516     } else {
 517       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 518     }
 519   }
 520 #endif
 521 }
 522 
<a name="7" id="anc7"></a><span class="line-removed"> 523 </span>
<span class="line-removed"> 524 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-removed"> 525 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-removed"> 526 void Compile::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-removed"> 527   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-removed"> 528   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-removed"> 529   // current and allocate a new one.</span>
<span class="line-removed"> 530   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-removed"> 531   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-removed"> 532     // Use the current blob.</span>
<span class="line-removed"> 533   } else {</span>
<span class="line-removed"> 534     if (blob != NULL) {</span>
<span class="line-removed"> 535       BufferBlob::free(blob);</span>
<span class="line-removed"> 536     }</span>
<span class="line-removed"> 537 </span>
<span class="line-removed"> 538     ResourceMark rm;</span>
<span class="line-removed"> 539     _scratch_const_size = const_size;</span>
<span class="line-removed"> 540     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-removed"> 541     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-removed"> 542     // Record the buffer blob for next time.</span>
<span class="line-removed"> 543     set_scratch_buffer_blob(blob);</span>
<span class="line-removed"> 544     // Have we run out of code space?</span>
<span class="line-removed"> 545     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-removed"> 546       // Let CompilerBroker disable further compilations.</span>
<span class="line-removed"> 547       record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-removed"> 548       return;</span>
<span class="line-removed"> 549     }</span>
<span class="line-removed"> 550   }</span>
<span class="line-removed"> 551 </span>
<span class="line-removed"> 552   // Initialize the relocation buffers</span>
<span class="line-removed"> 553   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-removed"> 554   set_scratch_locs_memory(locs_buf);</span>
<span class="line-removed"> 555 }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557 </span>
<span class="line-removed"> 558 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-removed"> 559 // Helper function that computes size by emitting code</span>
<span class="line-removed"> 560 uint Compile::scratch_emit_size(const Node* n) {</span>
<span class="line-removed"> 561   // Start scratch_emit_size section.</span>
<span class="line-removed"> 562   set_in_scratch_emit_size(true);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-removed"> 565   // This is a pretty expensive way to compute a size,</span>
<span class="line-removed"> 566   // but it works well enough if seldom used.</span>
<span class="line-removed"> 567   // All common fixed-size instructions are given a size</span>
<span class="line-removed"> 568   // method by the AD file.</span>
<span class="line-removed"> 569   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-removed"> 570   // allocated at the beginning of the compile task, and</span>
<span class="line-removed"> 571   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-removed"> 572   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-removed"> 573   // expensive, since it has to grab the code cache lock.</span>
<span class="line-removed"> 574   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-removed"> 575   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-removed"> 576   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-removed"> 577   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-removed"> 578   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-removed"> 579   address blob_end   = (address)locs_buf;</span>
<span class="line-removed"> 580   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-removed"> 581   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-removed"> 582   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-removed"> 583   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-removed"> 584   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-removed"> 585   int lsize = MAX_locs_size / 3;</span>
<span class="line-removed"> 586   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-removed"> 587   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-removed"> 588   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-removed"> 589   // Mark as scratch buffer.</span>
<span class="line-removed"> 590   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 591   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 592   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 593 </span>
<span class="line-removed"> 594   // Do the emission.</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-removed"> 597   Label*   saveL = NULL;</span>
<span class="line-removed"> 598   uint save_bnum = 0;</span>
<span class="line-removed"> 599   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-removed"> 600   if (is_branch) {</span>
<span class="line-removed"> 601     MacroAssembler masm(&amp;buf);</span>
<span class="line-removed"> 602     masm.bind(fakeL);</span>
<span class="line-removed"> 603     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-removed"> 604     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-removed"> 605   }</span>
<span class="line-removed"> 606   n-&gt;emit(buf, this-&gt;regalloc());</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608   // Emitting into the scratch buffer should not fail</span>
<span class="line-removed"> 609   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());</span>
<span class="line-removed"> 610 </span>
<span class="line-removed"> 611   if (is_branch) // Restore label.</span>
<span class="line-removed"> 612     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614   // End scratch_emit_size section.</span>
<span class="line-removed"> 615   set_in_scratch_emit_size(false);</span>
<span class="line-removed"> 616 </span>
<span class="line-removed"> 617   return buf.insts_size();</span>
<span class="line-removed"> 618 }</span>
<span class="line-removed"> 619 </span>
<span class="line-removed"> 620 </span>
 621 // ============================================================================
 622 //------------------------------Compile standard-------------------------------
 623 debug_only( int Compile::_debug_idx = 100000; )
 624 
 625 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 626 // the continuation bci for on stack replacement.
 627 
 628 
<a name="8" id="anc8"></a><span class="line-modified"> 629 Compile::Compile( ciEnv* ci_env, C2Compiler* compiler, ciMethod* target, int osr_bci,</span>
 630                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 631                 : Phase(Compiler),
 632                   _compile_id(ci_env-&gt;compile_id()),
 633                   _save_argument_registers(false),
 634                   _subsume_loads(subsume_loads),
 635                   _do_escape_analysis(do_escape_analysis),
 636                   _eliminate_boxing(eliminate_boxing),
 637                   _method(target),
 638                   _entry_bci(osr_bci),
 639                   _stub_function(NULL),
 640                   _stub_name(NULL),
 641                   _stub_entry_point(NULL),
 642                   _max_node_limit(MaxNodeLimit),
<a name="9" id="anc9"></a><span class="line-removed"> 643                   _orig_pc_slot(0),</span>
<span class="line-removed"> 644                   _orig_pc_slot_offset_in_bytes(0),</span>
 645                   _inlining_progress(false),
 646                   _inlining_incrementally(false),
 647                   _do_cleanup(false),
 648                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 649 #ifndef PRODUCT
 650                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 651                   _print_ideal(directive-&gt;PrintIdealOption),
 652 #endif
 653                   _has_method_handle_invokes(false),
 654                   _clinit_barrier_on_entry(false),
 655                   _comp_arena(mtCompiler),
 656                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 657                   _env(ci_env),
 658                   _directive(directive),
 659                   _log(ci_env-&gt;log()),
 660                   _failure_reason(NULL),
 661                   _congraph(NULL),
 662 #ifndef PRODUCT
 663                   _printer(IdealGraphPrinter::printer()),
 664 #endif
 665                   _dead_node_list(comp_arena()),
 666                   _dead_node_count(0),
 667                   _node_arena(mtCompiler),
 668                   _old_arena(mtCompiler),
 669                   _mach_constant_base_node(NULL),
 670                   _Compile_types(mtCompiler),
 671                   _initial_gvn(NULL),
 672                   _for_igvn(NULL),
 673                   _warm_calls(NULL),
 674                   _late_inlines(comp_arena(), 2, 0, NULL),
 675                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 676                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 677                   _late_inlines_pos(0),
 678                   _number_of_mh_late_inlines(0),
 679                   _print_inlining_stream(NULL),
 680                   _print_inlining_list(NULL),
 681                   _print_inlining_idx(0),
 682                   _print_inlining_output(NULL),
 683                   _replay_inline_data(NULL),
 684                   _java_calls(0),
 685                   _inner_loops(0),
<a name="10" id="anc10"></a><span class="line-modified"> 686                   _interpreter_frame_size(0),</span>
<span class="line-removed"> 687                   _node_bundling_limit(0),</span>
<span class="line-removed"> 688                   _node_bundling_base(NULL),</span>
<span class="line-removed"> 689                   _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-removed"> 690                   _scratch_const_size(-1),</span>
<span class="line-removed"> 691                   _in_scratch_emit_size(false)</span>
 692 #ifndef PRODUCT
 693                   , _in_dump_cnt(0)
 694 #endif
 695 {
 696   C = this;
 697 #ifndef PRODUCT
 698   if (_printer != NULL) {
 699     _printer-&gt;set_compile(this);
 700   }
 701 #endif
 702   CompileWrapper cw(this);
 703 
 704   if (CITimeVerbose) {
 705     tty-&gt;print(&quot; &quot;);
 706     target-&gt;holder()-&gt;name()-&gt;print();
 707     tty-&gt;print(&quot;.&quot;);
 708     target-&gt;print_short_name();
 709     tty-&gt;print(&quot;  &quot;);
 710   }
 711   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
 712   TraceTime t2(NULL, &amp;_t_methodCompilation, CITime, false);
 713 
 714 #if defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_ABSTRACT_ASSEMBLY)
 715   bool print_opto_assembly = directive-&gt;PrintOptoAssemblyOption;
 716   // We can always print a disassembly, either abstract (hex dump) or
 717   // with the help of a suitable hsdis library. Thus, we should not
 718   // couple print_assembly and print_opto_assembly controls.
 719   // But: always print opto and regular assembly on compile command &#39;print&#39;.
 720   bool print_assembly = directive-&gt;PrintAssemblyOption;
 721   set_print_assembly(print_opto_assembly || print_assembly);
 722 #else
 723   set_print_assembly(false); // must initialize.
 724 #endif
 725 
 726 #ifndef PRODUCT
 727   set_parsed_irreducible_loop(false);
 728 
 729   if (directive-&gt;ReplayInlineOption) {
 730     _replay_inline_data = ciReplay::load_inline_data(method(), entry_bci(), ci_env-&gt;comp_level());
 731   }
 732 #endif
 733   set_print_inlining(directive-&gt;PrintInliningOption || PrintOptoInlining);
 734   set_print_intrinsics(directive-&gt;PrintIntrinsicsOption);
 735   set_has_irreducible_loop(true); // conservative until build_loop_tree() reset it
 736 
 737   if (ProfileTraps RTM_OPT_ONLY( || UseRTMLocking )) {
 738     // Make sure the method being compiled gets its own MDO,
 739     // so we can at least track the decompile_count().
 740     // Need MDO to record RTM code generation state.
 741     method()-&gt;ensure_method_data();
 742   }
 743 
 744   Init(::AliasLevel);
 745 
 746 
 747   print_compile_messages();
 748 
 749   _ilt = InlineTree::build_inline_tree_root();
 750 
 751   // Even if NO memory addresses are used, MergeMem nodes must have at least 1 slice
 752   assert(num_alias_types() &gt;= AliasIdxRaw, &quot;&quot;);
 753 
 754 #define MINIMUM_NODE_HASH  1023
 755   // Node list that Iterative GVN will start with
 756   Unique_Node_List for_igvn(comp_arena());
 757   set_for_igvn(&amp;for_igvn);
 758 
 759   // GVN that will be run immediately on new nodes
 760   uint estimated_size = method()-&gt;code_size()*4+64;
 761   estimated_size = (estimated_size &lt; MINIMUM_NODE_HASH ? MINIMUM_NODE_HASH : estimated_size);
 762   PhaseGVN gvn(node_arena(), estimated_size);
 763   set_initial_gvn(&amp;gvn);
 764 
 765   print_inlining_init();
 766   { // Scope for timing the parser
 767     TracePhase tp(&quot;parse&quot;, &amp;timers[_t_parser]);
 768 
 769     // Put top into the hash table ASAP.
 770     initial_gvn()-&gt;transform_no_reclaim(top());
 771 
 772     // Set up tf(), start(), and find a CallGenerator.
 773     CallGenerator* cg = NULL;
 774     if (is_osr_compilation()) {
 775       const TypeTuple *domain = StartOSRNode::osr_domain();
 776       const TypeTuple *range = TypeTuple::make_range(method()-&gt;signature());
 777       init_tf(TypeFunc::make(domain, range));
 778       StartNode* s = new StartOSRNode(root(), domain);
 779       initial_gvn()-&gt;set_type_bottom(s);
 780       init_start(s);
 781       cg = CallGenerator::for_osr(method(), entry_bci());
 782     } else {
 783       // Normal case.
 784       init_tf(TypeFunc::make(method()));
 785       StartNode* s = new StartNode(root(), tf()-&gt;domain());
 786       initial_gvn()-&gt;set_type_bottom(s);
 787       init_start(s);
 788       if (method()-&gt;intrinsic_id() == vmIntrinsics::_Reference_get) {
 789         // With java.lang.ref.reference.get() we must go through the
 790         // intrinsic - even when get() is the root
 791         // method of the compile - so that, if necessary, the value in
 792         // the referent field of the reference object gets recorded by
 793         // the pre-barrier code.
 794         cg = find_intrinsic(method(), false);
 795       }
 796       if (cg == NULL) {
 797         float past_uses = method()-&gt;interpreter_invocation_count();
 798         float expected_uses = past_uses;
 799         cg = CallGenerator::for_inline(method(), expected_uses);
 800       }
 801     }
 802     if (failing())  return;
 803     if (cg == NULL) {
 804       record_method_not_compilable(&quot;cannot parse method&quot;);
 805       return;
 806     }
 807     JVMState* jvms = build_start_state(start(), tf());
 808     if ((jvms = cg-&gt;generate(jvms)) == NULL) {
 809       if (!failure_reason_is(C2Compiler::retry_class_loading_during_parsing())) {
 810         record_method_not_compilable(&quot;method parse failed&quot;);
 811       }
 812       return;
 813     }
 814     GraphKit kit(jvms);
 815 
 816     if (!kit.stopped()) {
 817       // Accept return values, and transfer control we know not where.
 818       // This is done by a special, unique ReturnNode bound to root.
 819       return_values(kit.jvms());
 820     }
 821 
 822     if (kit.has_exceptions()) {
 823       // Any exceptions that escape from this call must be rethrown
 824       // to whatever caller is dynamically above us on the stack.
 825       // This is done by a special, unique RethrowNode bound to root.
 826       rethrow_exceptions(kit.transfer_exceptions_into_jvms());
 827     }
 828 
 829     assert(IncrementalInline || (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines()), &quot;incremental inlining is off&quot;);
 830 
 831     if (_late_inlines.length() == 0 &amp;&amp; !has_mh_late_inlines() &amp;&amp; !failing() &amp;&amp; has_stringbuilder()) {
 832       inline_string_calls(true);
 833     }
 834 
 835     if (failing())  return;
 836 
 837     print_method(PHASE_BEFORE_REMOVEUSELESS, 3);
 838 
 839     // Remove clutter produced by parsing.
 840     if (!failing()) {
 841       ResourceMark rm;
 842       PhaseRemoveUseless pru(initial_gvn(), &amp;for_igvn);
 843     }
 844   }
 845 
 846   // Note:  Large methods are capped off in do_one_bytecode().
 847   if (failing())  return;
 848 
 849   // After parsing, node notes are no longer automagic.
 850   // They must be propagated by register_new_node_with_optimizer(),
 851   // clone(), or the like.
 852   set_default_node_notes(NULL);
 853 
 854   for (;;) {
 855     int successes = Inline_Warm();
 856     if (failing())  return;
 857     if (successes == 0)  break;
 858   }
 859 
 860   // Drain the list.
 861   Finish_Warm();
 862 #ifndef PRODUCT
 863   if (_printer &amp;&amp; _printer-&gt;should_print(1)) {
 864     _printer-&gt;print_inlining();
 865   }
 866 #endif
 867 
 868   if (failing())  return;
 869   NOT_PRODUCT( verify_graph_edges(); )
 870 
 871   // Now optimize
 872   Optimize();
 873   if (failing())  return;
 874   NOT_PRODUCT( verify_graph_edges(); )
 875 
 876 #ifndef PRODUCT
 877   if (print_ideal()) {
 878     ttyLocker ttyl;  // keep the following output all in one block
 879     // This output goes directly to the tty, not the compiler log.
 880     // To enable tools to match it up with the compilation activity,
 881     // be sure to tag this tty output with the compile ID.
 882     if (xtty != NULL) {
 883       xtty-&gt;head(&quot;ideal compile_id=&#39;%d&#39;%s&quot;, compile_id(),
 884                  is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :
 885                  &quot;&quot;);
 886     }
 887     root()-&gt;dump(9999);
 888     if (xtty != NULL) {
 889       xtty-&gt;tail(&quot;ideal&quot;);
 890     }
 891   }
 892 #endif
 893 
 894 #ifdef ASSERT
 895   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 896   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 897 #endif
 898 
 899   // Dump compilation data to replay it.
 900   if (directive-&gt;DumpReplayOption) {
 901     env()-&gt;dump_replay_data(_compile_id);
 902   }
 903   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 904     env()-&gt;dump_inline_data(_compile_id);
 905   }
 906 
 907   // Now that we know the size of all the monitors we can add a fixed slot
 908   // for the original deopt pc.
<a name="11" id="anc11"></a><span class="line-modified"> 909 </span>
<span class="line-removed"> 910   _orig_pc_slot =  fixed_slots();</span>
<span class="line-removed"> 911   int next_slot = _orig_pc_slot + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
 912   set_fixed_slots(next_slot);
 913 
 914   // Compute when to use implicit null checks. Used by matching trap based
 915   // nodes and NullCheck optimization.
 916   set_allowed_deopt_reasons();
 917 
 918   // Now generate code
 919   Code_Gen();
<a name="12" id="anc12"></a><span class="line-removed"> 920   if (failing())  return;</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922   // Check if we want to skip execution of all compiled code.</span>
<span class="line-removed"> 923   {</span>
<span class="line-removed"> 924 #ifndef PRODUCT</span>
<span class="line-removed"> 925     if (OptoNoExecute) {</span>
<span class="line-removed"> 926       record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-removed"> 927       return;</span>
<span class="line-removed"> 928     }</span>
<span class="line-removed"> 929 #endif</span>
<span class="line-removed"> 930     TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932     if (is_osr_compilation()) {</span>
<span class="line-removed"> 933       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-removed"> 934       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-removed"> 935     } else {</span>
<span class="line-removed"> 936       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-removed"> 937       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-removed"> 938     }</span>
<span class="line-removed"> 939 </span>
<span class="line-removed"> 940     env()-&gt;register_method(_method, _entry_bci,</span>
<span class="line-removed"> 941                            &amp;_code_offsets,</span>
<span class="line-removed"> 942                            _orig_pc_slot_offset_in_bytes,</span>
<span class="line-removed"> 943                            code_buffer(),</span>
<span class="line-removed"> 944                            frame_size_in_words(), _oop_map_set,</span>
<span class="line-removed"> 945                            &amp;_handler_table, &amp;_inc_table,</span>
<span class="line-removed"> 946                            compiler,</span>
<span class="line-removed"> 947                            has_unsafe_access(),</span>
<span class="line-removed"> 948                            SharedRuntime::is_wide_vector(max_vector_size()),</span>
<span class="line-removed"> 949                            rtm_state()</span>
<span class="line-removed"> 950                            );</span>
<span class="line-removed"> 951 </span>
<span class="line-removed"> 952     if (log() != NULL) // Print code cache state into compiler log</span>
<span class="line-removed"> 953       log()-&gt;code_cache_state();</span>
<span class="line-removed"> 954   }</span>
 955 }
 956 
 957 //------------------------------Compile----------------------------------------
 958 // Compile a runtime stub
 959 Compile::Compile( ciEnv* ci_env,
 960                   TypeFunc_generator generator,
 961                   address stub_function,
 962                   const char *stub_name,
 963                   int is_fancy_jump,
 964                   bool pass_tls,
 965                   bool save_arg_registers,
 966                   bool return_pc,
 967                   DirectiveSet* directive)
 968   : Phase(Compiler),
 969     _compile_id(0),
 970     _save_argument_registers(save_arg_registers),
 971     _subsume_loads(true),
 972     _do_escape_analysis(false),
 973     _eliminate_boxing(false),
 974     _method(NULL),
 975     _entry_bci(InvocationEntryBci),
 976     _stub_function(stub_function),
 977     _stub_name(stub_name),
 978     _stub_entry_point(NULL),
 979     _max_node_limit(MaxNodeLimit),
<a name="13" id="anc13"></a><span class="line-removed"> 980     _orig_pc_slot(0),</span>
<span class="line-removed"> 981     _orig_pc_slot_offset_in_bytes(0),</span>
 982     _inlining_progress(false),
 983     _inlining_incrementally(false),
 984     _has_reserved_stack_access(false),
 985 #ifndef PRODUCT
 986     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 987     _print_ideal(directive-&gt;PrintIdealOption),
 988 #endif
 989     _has_method_handle_invokes(false),
 990     _clinit_barrier_on_entry(false),
 991     _comp_arena(mtCompiler),
 992     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 993     _env(ci_env),
 994     _directive(directive),
 995     _log(ci_env-&gt;log()),
 996     _failure_reason(NULL),
 997     _congraph(NULL),
 998 #ifndef PRODUCT
 999     _printer(NULL),
1000 #endif
1001     _dead_node_list(comp_arena()),
1002     _dead_node_count(0),
1003     _node_arena(mtCompiler),
1004     _old_arena(mtCompiler),
1005     _mach_constant_base_node(NULL),
1006     _Compile_types(mtCompiler),
1007     _initial_gvn(NULL),
1008     _for_igvn(NULL),
1009     _warm_calls(NULL),
1010     _number_of_mh_late_inlines(0),
1011     _print_inlining_stream(NULL),
1012     _print_inlining_list(NULL),
1013     _print_inlining_idx(0),
1014     _print_inlining_output(NULL),
1015     _replay_inline_data(NULL),
1016     _java_calls(0),
1017     _inner_loops(0),
1018     _interpreter_frame_size(0),
<a name="14" id="anc14"></a><span class="line-removed">1019     _node_bundling_limit(0),</span>
<span class="line-removed">1020     _node_bundling_base(NULL),</span>
<span class="line-removed">1021     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
1022 #ifndef PRODUCT
1023     _in_dump_cnt(0),
1024 #endif
1025     _allowed_reasons(0) {
1026   C = this;
1027 
1028   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
1029   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
1030 
1031 #ifndef PRODUCT
1032   set_print_assembly(PrintFrameConverterAssembly);
1033   set_parsed_irreducible_loop(false);
1034 #else
1035   set_print_assembly(false); // Must initialize.
1036 #endif
1037   set_has_irreducible_loop(false); // no loops
1038 
1039   CompileWrapper cw(this);
1040   Init(/*AliasLevel=*/ 0);
1041   init_tf((*generator)());
1042 
1043   {
1044     // The following is a dummy for the sake of GraphKit::gen_stub
1045     Unique_Node_List for_igvn(comp_arena());
1046     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
1047     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
1048     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
1049     gvn.transform_no_reclaim(top());
1050 
1051     GraphKit kit;
1052     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
1053   }
1054 
1055   NOT_PRODUCT( verify_graph_edges(); )
<a name="15" id="anc15"></a><span class="line-removed">1056   Code_Gen();</span>
<span class="line-removed">1057   if (failing())  return;</span>
<span class="line-removed">1058 </span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060   // Entry point will be accessed using compile-&gt;stub_entry_point();</span>
<span class="line-removed">1061   if (code_buffer() == NULL) {</span>
<span class="line-removed">1062     Matcher::soft_match_failure();</span>
<span class="line-removed">1063   } else {</span>
<span class="line-removed">1064     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-removed">1065       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
1066 
<a name="16" id="anc16"></a><span class="line-modified">1067     if (!failing()) {</span>
<span class="line-removed">1068       assert(_fixed_slots == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="line-removed">1069 </span>
<span class="line-removed">1070       // Make the NMethod</span>
<span class="line-removed">1071       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-removed">1072       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-removed">1073                                                       code_buffer(),</span>
<span class="line-removed">1074                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-removed">1075                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-removed">1076                                                       frame_size_in_words(),</span>
<span class="line-removed">1077                                                       _oop_map_set,</span>
<span class="line-removed">1078                                                       save_arg_registers);</span>
<span class="line-removed">1079       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-removed">1080 </span>
<span class="line-removed">1081       _stub_entry_point = rs-&gt;entry_point();</span>
<span class="line-removed">1082     }</span>
<span class="line-removed">1083   }</span>
1084 }
1085 
1086 //------------------------------Init-------------------------------------------
1087 // Prepare for a single compilation
1088 void Compile::Init(int aliaslevel) {
1089   _unique  = 0;
1090   _regalloc = NULL;
1091 
1092   _tf      = NULL;  // filled in later
1093   _top     = NULL;  // cached later
1094   _matcher = NULL;  // filled in later
1095   _cfg     = NULL;  // filled in later
1096 
1097   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )
1098 
1099   _node_note_array = NULL;
1100   _default_node_notes = NULL;
1101   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
1102 
1103   _immutable_memory = NULL; // filled in at first inquiry
1104 
1105   // Globally visible Nodes
1106   // First set TOP to NULL to give safe behavior during creation of RootNode
1107   set_cached_top_node(NULL);
1108   set_root(new RootNode());
1109   // Now that you have a Root to point to, create the real TOP
1110   set_cached_top_node( new ConNode(Type::TOP) );
1111   set_recent_alloc(NULL, NULL);
1112 
1113   // Create Debug Information Recorder to record scopes, oopmaps, etc.
1114   env()-&gt;set_oop_recorder(new OopRecorder(env()-&gt;arena()));
1115   env()-&gt;set_debug_info(new DebugInformationRecorder(env()-&gt;oop_recorder()));
1116   env()-&gt;set_dependencies(new Dependencies(env()));
1117 
1118   _fixed_slots = 0;
1119   set_has_split_ifs(false);
1120   set_has_loops(has_method() &amp;&amp; method()-&gt;has_loops()); // first approximation
1121   set_has_stringbuilder(false);
1122   set_has_boxed_value(false);
1123   _trap_can_recompile = false;  // no traps emitted yet
1124   _major_progress = true; // start out assuming good things will happen
1125   set_has_unsafe_access(false);
1126   set_max_vector_size(0);
1127   set_clear_upper_avx(false);  //false as default for clear upper bits of ymm registers
1128   Copy::zero_to_bytes(_trap_hist, sizeof(_trap_hist));
1129   set_decompile_count(0);
1130 
1131   set_do_freq_based_layout(_directive-&gt;BlockLayoutByFrequencyOption);
1132   _loop_opts_cnt = LoopOptsCount;
1133   set_do_inlining(Inline);
1134   set_max_inline_size(MaxInlineSize);
1135   set_freq_inline_size(FreqInlineSize);
1136   set_do_scheduling(OptoScheduling);
1137   set_do_count_invocations(false);
1138   set_do_method_data_update(false);
1139 
1140   set_do_vector_loop(false);
1141 
1142   if (AllowVectorizeOnDemand) {
1143     if (has_method() &amp;&amp; (_directive-&gt;VectorizeOption || _directive-&gt;VectorizeDebugOption)) {
1144       set_do_vector_loop(true);
1145       NOT_PRODUCT(if (do_vector_loop() &amp;&amp; Verbose) {tty-&gt;print(&quot;Compile::Init: do vectorized loops (SIMD like) for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
1146     } else if (has_method() &amp;&amp; method()-&gt;name() != 0 &amp;&amp;
1147                method()-&gt;intrinsic_id() == vmIntrinsics::_forEachRemaining) {
1148       set_do_vector_loop(true);
1149     }
1150   }
1151   set_use_cmove(UseCMoveUnconditionally /* || do_vector_loop()*/); //TODO: consider do_vector_loop() mandate use_cmove unconditionally
1152   NOT_PRODUCT(if (use_cmove() &amp;&amp; Verbose &amp;&amp; has_method()) {tty-&gt;print(&quot;Compile::Init: use CMove without profitability tests for method %s\n&quot;,  method()-&gt;name()-&gt;as_quoted_ascii());})
1153 
1154   set_age_code(has_method() &amp;&amp; method()-&gt;profile_aging());
1155   set_rtm_state(NoRTM); // No RTM lock eliding by default
1156   _max_node_limit = _directive-&gt;MaxNodeLimitOption;
1157 
1158 #if INCLUDE_RTM_OPT
1159   if (UseRTMLocking &amp;&amp; has_method() &amp;&amp; (method()-&gt;method_data_or_null() != NULL)) {
1160     int rtm_state = method()-&gt;method_data()-&gt;rtm_state();
1161     if (method_has_option(&quot;NoRTMLockEliding&quot;) || ((rtm_state &amp; NoRTM) != 0)) {
1162       // Don&#39;t generate RTM lock eliding code.
1163       set_rtm_state(NoRTM);
1164     } else if (method_has_option(&quot;UseRTMLockEliding&quot;) || ((rtm_state &amp; UseRTM) != 0) || !UseRTMDeopt) {
1165       // Generate RTM lock eliding code without abort ratio calculation code.
1166       set_rtm_state(UseRTM);
1167     } else if (UseRTMDeopt) {
1168       // Generate RTM lock eliding code and include abort ratio calculation
1169       // code if UseRTMDeopt is on.
1170       set_rtm_state(ProfileRTM);
1171     }
1172   }
1173 #endif
1174   if (VM_Version::supports_fast_class_init_checks() &amp;&amp; has_method() &amp;&amp; !is_osr_compilation() &amp;&amp; method()-&gt;needs_clinit_barrier()) {
1175     set_clinit_barrier_on_entry(true);
1176   }
1177   if (debug_info()-&gt;recording_non_safepoints()) {
1178     set_node_note_array(new(comp_arena()) GrowableArray&lt;Node_Notes*&gt;
1179                         (comp_arena(), 8, 0, NULL));
1180     set_default_node_notes(Node_Notes::make(this));
1181   }
1182 
1183   // // -- Initialize types before each compile --
1184   // // Update cached type information
1185   // if( _method &amp;&amp; _method-&gt;constants() )
1186   //   Type::update_loaded_types(_method, _method-&gt;constants());
1187 
1188   // Init alias_type map.
1189   if (!_do_escape_analysis &amp;&amp; aliaslevel == 3)
1190     aliaslevel = 2;  // No unique types without escape analysis
1191   _AliasLevel = aliaslevel;
1192   const int grow_ats = 16;
1193   _max_alias_types = grow_ats;
1194   _alias_types   = NEW_ARENA_ARRAY(comp_arena(), AliasType*, grow_ats);
1195   AliasType* ats = NEW_ARENA_ARRAY(comp_arena(), AliasType,  grow_ats);
1196   Copy::zero_to_bytes(ats, sizeof(AliasType)*grow_ats);
1197   {
1198     for (int i = 0; i &lt; grow_ats; i++)  _alias_types[i] = &amp;ats[i];
1199   }
1200   // Initialize the first few types.
1201   _alias_types[AliasIdxTop]-&gt;Init(AliasIdxTop, NULL);
1202   _alias_types[AliasIdxBot]-&gt;Init(AliasIdxBot, TypePtr::BOTTOM);
1203   _alias_types[AliasIdxRaw]-&gt;Init(AliasIdxRaw, TypeRawPtr::BOTTOM);
1204   _num_alias_types = AliasIdxRaw+1;
1205   // Zero out the alias type cache.
1206   Copy::zero_to_bytes(_alias_cache, sizeof(_alias_cache));
1207   // A NULL adr_type hits in the cache right away.  Preload the right answer.
1208   probe_alias_cache(NULL)-&gt;_index = AliasIdxTop;
1209 
1210   _intrinsics = NULL;
1211   _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1212   _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1213   _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1214   _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1215   _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1216   register_library_intrinsics();
<a name="17" id="anc17"></a>


1217 }
1218 
1219 //---------------------------init_start----------------------------------------
1220 // Install the StartNode on this compile object.
1221 void Compile::init_start(StartNode* s) {
1222   if (failing())
1223     return; // already failing
1224   assert(s == start(), &quot;&quot;);
1225 }
1226 
1227 /**
1228  * Return the &#39;StartNode&#39;. We must not have a pending failure, since the ideal graph
1229  * can be in an inconsistent state, i.e., we can get segmentation faults when traversing
1230  * the ideal graph.
1231  */
1232 StartNode* Compile::start() const {
1233   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());
1234   for (DUIterator_Fast imax, i = root()-&gt;fast_outs(imax); i &lt; imax; i++) {
1235     Node* start = root()-&gt;fast_out(i);
1236     if (start-&gt;is_Start()) {
1237       return start-&gt;as_Start();
1238     }
1239   }
1240   fatal(&quot;Did not find Start node!&quot;);
1241   return NULL;
1242 }
1243 
1244 //-------------------------------immutable_memory-------------------------------------
1245 // Access immutable memory
1246 Node* Compile::immutable_memory() {
1247   if (_immutable_memory != NULL) {
1248     return _immutable_memory;
1249   }
1250   StartNode* s = start();
1251   for (DUIterator_Fast imax, i = s-&gt;fast_outs(imax); true; i++) {
1252     Node *p = s-&gt;fast_out(i);
1253     if (p != s &amp;&amp; p-&gt;as_Proj()-&gt;_con == TypeFunc::Memory) {
1254       _immutable_memory = p;
1255       return _immutable_memory;
1256     }
1257   }
1258   ShouldNotReachHere();
1259   return NULL;
1260 }
1261 
1262 //----------------------set_cached_top_node------------------------------------
1263 // Install the cached top node, and make sure Node::is_top works correctly.
1264 void Compile::set_cached_top_node(Node* tn) {
1265   if (tn != NULL)  verify_top(tn);
1266   Node* old_top = _top;
1267   _top = tn;
1268   // Calling Node::setup_is_top allows the nodes the chance to adjust
1269   // their _out arrays.
1270   if (_top != NULL)     _top-&gt;setup_is_top();
1271   if (old_top != NULL)  old_top-&gt;setup_is_top();
1272   assert(_top == NULL || top()-&gt;is_top(), &quot;&quot;);
1273 }
1274 
1275 #ifdef ASSERT
1276 uint Compile::count_live_nodes_by_graph_walk() {
1277   Unique_Node_List useful(comp_arena());
1278   // Get useful node list by walking the graph.
1279   identify_useful_nodes(useful);
1280   return useful.size();
1281 }
1282 
1283 void Compile::print_missing_nodes() {
1284 
1285   // Return if CompileLog is NULL and PrintIdealNodeCount is false.
1286   if ((_log == NULL) &amp;&amp; (! PrintIdealNodeCount)) {
1287     return;
1288   }
1289 
1290   // This is an expensive function. It is executed only when the user
1291   // specifies VerifyIdealNodeCount option or otherwise knows the
1292   // additional work that needs to be done to identify reachable nodes
1293   // by walking the flow graph and find the missing ones using
1294   // _dead_node_list.
1295 
1296   Unique_Node_List useful(comp_arena());
1297   // Get useful node list by walking the graph.
1298   identify_useful_nodes(useful);
1299 
1300   uint l_nodes = C-&gt;live_nodes();
1301   uint l_nodes_by_walk = useful.size();
1302 
1303   if (l_nodes != l_nodes_by_walk) {
1304     if (_log != NULL) {
1305       _log-&gt;begin_head(&quot;mismatched_nodes count=&#39;%d&#39;&quot;, abs((int) (l_nodes - l_nodes_by_walk)));
1306       _log-&gt;stamp();
1307       _log-&gt;end_head();
1308     }
1309     VectorSet&amp; useful_member_set = useful.member_set();
1310     int last_idx = l_nodes_by_walk;
1311     for (int i = 0; i &lt; last_idx; i++) {
1312       if (useful_member_set.test(i)) {
1313         if (_dead_node_list.test(i)) {
1314           if (_log != NULL) {
1315             _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;both live and dead&#39;&quot;, i);
1316           }
1317           if (PrintIdealNodeCount) {
1318             // Print the log message to tty
1319               tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; both live and dead&#39;&quot;, i);
1320               useful.at(i)-&gt;dump();
1321           }
1322         }
1323       }
1324       else if (! _dead_node_list.test(i)) {
1325         if (_log != NULL) {
1326           _log-&gt;elem(&quot;mismatched_node_info node_idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1327         }
1328         if (PrintIdealNodeCount) {
1329           // Print the log message to tty
1330           tty-&gt;print_cr(&quot;mismatched_node idx=&#39;%d&#39; type=&#39;neither live nor dead&#39;&quot;, i);
1331         }
1332       }
1333     }
1334     if (_log != NULL) {
1335       _log-&gt;tail(&quot;mismatched_nodes&quot;);
1336     }
1337   }
1338 }
1339 void Compile::record_modified_node(Node* n) {
1340   if (_modified_nodes != NULL &amp;&amp; !_inlining_incrementally &amp;&amp;
1341       n-&gt;outcnt() != 0 &amp;&amp; !n-&gt;is_Con()) {
1342     _modified_nodes-&gt;push(n);
1343   }
1344 }
1345 
1346 void Compile::remove_modified_node(Node* n) {
1347   if (_modified_nodes != NULL) {
1348     _modified_nodes-&gt;remove(n);
1349   }
1350 }
1351 #endif
1352 
1353 #ifndef PRODUCT
1354 void Compile::verify_top(Node* tn) const {
1355   if (tn != NULL) {
1356     assert(tn-&gt;is_Con(), &quot;top node must be a constant&quot;);
1357     assert(((ConNode*)tn)-&gt;type() == Type::TOP, &quot;top node must have correct type&quot;);
1358     assert(tn-&gt;in(0) != NULL, &quot;must have live top node&quot;);
1359   }
1360 }
1361 #endif
1362 
1363 
1364 ///-------------------Managing Per-Node Debug &amp; Profile Info-------------------
1365 
1366 void Compile::grow_node_notes(GrowableArray&lt;Node_Notes*&gt;* arr, int grow_by) {
1367   guarantee(arr != NULL, &quot;&quot;);
1368   int num_blocks = arr-&gt;length();
1369   if (grow_by &lt; num_blocks)  grow_by = num_blocks;
1370   int num_notes = grow_by * _node_notes_block_size;
1371   Node_Notes* notes = NEW_ARENA_ARRAY(node_arena(), Node_Notes, num_notes);
1372   Copy::zero_to_bytes(notes, num_notes * sizeof(Node_Notes));
1373   while (num_notes &gt; 0) {
1374     arr-&gt;append(notes);
1375     notes     += _node_notes_block_size;
1376     num_notes -= _node_notes_block_size;
1377   }
1378   assert(num_notes == 0, &quot;exact multiple, please&quot;);
1379 }
1380 
1381 bool Compile::copy_node_notes_to(Node* dest, Node* source) {
1382   if (source == NULL || dest == NULL)  return false;
1383 
1384   if (dest-&gt;is_Con())
1385     return false;               // Do not push debug info onto constants.
1386 
1387 #ifdef ASSERT
1388   // Leave a bread crumb trail pointing to the original node:
1389   if (dest != NULL &amp;&amp; dest != source &amp;&amp; dest-&gt;debug_orig() == NULL) {
1390     dest-&gt;set_debug_orig(source);
1391   }
1392 #endif
1393 
1394   if (node_note_array() == NULL)
1395     return false;               // Not collecting any notes now.
1396 
1397   // This is a copy onto a pre-existing node, which may already have notes.
1398   // If both nodes have notes, do not overwrite any pre-existing notes.
1399   Node_Notes* source_notes = node_notes_at(source-&gt;_idx);
1400   if (source_notes == NULL || source_notes-&gt;is_clear())  return false;
1401   Node_Notes* dest_notes   = node_notes_at(dest-&gt;_idx);
1402   if (dest_notes == NULL || dest_notes-&gt;is_clear()) {
1403     return set_node_notes_at(dest-&gt;_idx, source_notes);
1404   }
1405 
1406   Node_Notes merged_notes = (*source_notes);
1407   // The order of operations here ensures that dest notes will win...
1408   merged_notes.update_from(dest_notes);
1409   return set_node_notes_at(dest-&gt;_idx, &amp;merged_notes);
1410 }
1411 
1412 
1413 //--------------------------allow_range_check_smearing-------------------------
1414 // Gating condition for coalescing similar range checks.
1415 // Sometimes we try &#39;speculatively&#39; replacing a series of a range checks by a
1416 // single covering check that is at least as strong as any of them.
1417 // If the optimization succeeds, the simplified (strengthened) range check
1418 // will always succeed.  If it fails, we will deopt, and then give up
1419 // on the optimization.
1420 bool Compile::allow_range_check_smearing() const {
1421   // If this method has already thrown a range-check,
1422   // assume it was because we already tried range smearing
1423   // and it failed.
1424   uint already_trapped = trap_count(Deoptimization::Reason_range_check);
1425   return !already_trapped;
1426 }
1427 
1428 
1429 //------------------------------flatten_alias_type-----------------------------
1430 const TypePtr *Compile::flatten_alias_type( const TypePtr *tj ) const {
1431   int offset = tj-&gt;offset();
1432   TypePtr::PTR ptr = tj-&gt;ptr();
1433 
1434   // Known instance (scalarizable allocation) alias only with itself.
1435   bool is_known_inst = tj-&gt;isa_oopptr() != NULL &amp;&amp;
1436                        tj-&gt;is_oopptr()-&gt;is_known_instance();
1437 
1438   // Process weird unsafe references.
1439   if (offset == Type::OffsetBot &amp;&amp; (tj-&gt;isa_instptr() /*|| tj-&gt;isa_klassptr()*/)) {
1440     assert(InlineUnsafeOps, &quot;indeterminate pointers come only from unsafe ops&quot;);
1441     assert(!is_known_inst, &quot;scalarizable allocation should not have unsafe references&quot;);
1442     tj = TypeOopPtr::BOTTOM;
1443     ptr = tj-&gt;ptr();
1444     offset = tj-&gt;offset();
1445   }
1446 
1447   // Array pointers need some flattening
1448   const TypeAryPtr *ta = tj-&gt;isa_aryptr();
1449   if (ta &amp;&amp; ta-&gt;is_stable()) {
1450     // Erase stability property for alias analysis.
1451     tj = ta = ta-&gt;cast_to_stable(false);
1452   }
1453   if( ta &amp;&amp; is_known_inst ) {
1454     if ( offset != Type::OffsetBot &amp;&amp;
1455          offset &gt; arrayOopDesc::length_offset_in_bytes() ) {
1456       offset = Type::OffsetBot; // Flatten constant access into array body only
1457       tj = ta = TypeAryPtr::make(ptr, ta-&gt;ary(), ta-&gt;klass(), true, offset, ta-&gt;instance_id());
1458     }
1459   } else if( ta &amp;&amp; _AliasLevel &gt;= 2 ) {
1460     // For arrays indexed by constant indices, we flatten the alias
1461     // space to include all of the array body.  Only the header, klass
1462     // and array length can be accessed un-aliased.
1463     if( offset != Type::OffsetBot ) {
1464       if( ta-&gt;const_oop() ) { // MethodData* or Method*
1465         offset = Type::OffsetBot;   // Flatten constant access into array body
1466         tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),ta-&gt;ary(),ta-&gt;klass(),false,offset);
1467       } else if( offset == arrayOopDesc::length_offset_in_bytes() ) {
1468         // range is OK as-is.
1469         tj = ta = TypeAryPtr::RANGE;
1470       } else if( offset == oopDesc::klass_offset_in_bytes() ) {
1471         tj = TypeInstPtr::KLASS; // all klass loads look alike
1472         ta = TypeAryPtr::RANGE; // generic ignored junk
1473         ptr = TypePtr::BotPTR;
1474       } else if( offset == oopDesc::mark_offset_in_bytes() ) {
1475         tj = TypeInstPtr::MARK;
1476         ta = TypeAryPtr::RANGE; // generic ignored junk
1477         ptr = TypePtr::BotPTR;
1478       } else {                  // Random constant offset into array body
1479         offset = Type::OffsetBot;   // Flatten constant access into array body
1480         tj = ta = TypeAryPtr::make(ptr,ta-&gt;ary(),ta-&gt;klass(),false,offset);
1481       }
1482     }
1483     // Arrays of fixed size alias with arrays of unknown size.
1484     if (ta-&gt;size() != TypeInt::POS) {
1485       const TypeAry *tary = TypeAry::make(ta-&gt;elem(), TypeInt::POS);
1486       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,ta-&gt;klass(),false,offset);
1487     }
1488     // Arrays of known objects become arrays of unknown objects.
1489     if (ta-&gt;elem()-&gt;isa_narrowoop() &amp;&amp; ta-&gt;elem() != TypeNarrowOop::BOTTOM) {
1490       const TypeAry *tary = TypeAry::make(TypeNarrowOop::BOTTOM, ta-&gt;size());
1491       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,offset);
1492     }
1493     if (ta-&gt;elem()-&gt;isa_oopptr() &amp;&amp; ta-&gt;elem() != TypeInstPtr::BOTTOM) {
1494       const TypeAry *tary = TypeAry::make(TypeInstPtr::BOTTOM, ta-&gt;size());
1495       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,NULL,false,offset);
1496     }
1497     // Arrays of bytes and of booleans both use &#39;bastore&#39; and &#39;baload&#39; so
1498     // cannot be distinguished by bytecode alone.
1499     if (ta-&gt;elem() == TypeInt::BOOL) {
1500       const TypeAry *tary = TypeAry::make(TypeInt::BYTE, ta-&gt;size());
1501       ciKlass* aklass = ciTypeArrayKlass::make(T_BYTE);
1502       tj = ta = TypeAryPtr::make(ptr,ta-&gt;const_oop(),tary,aklass,false,offset);
1503     }
1504     // During the 2nd round of IterGVN, NotNull castings are removed.
1505     // Make sure the Bottom and NotNull variants alias the same.
1506     // Also, make sure exact and non-exact variants alias the same.
1507     if (ptr == TypePtr::NotNull || ta-&gt;klass_is_exact() || ta-&gt;speculative() != NULL) {
1508       tj = ta = TypeAryPtr::make(TypePtr::BotPTR,ta-&gt;ary(),ta-&gt;klass(),false,offset);
1509     }
1510   }
1511 
1512   // Oop pointers need some flattening
1513   const TypeInstPtr *to = tj-&gt;isa_instptr();
1514   if( to &amp;&amp; _AliasLevel &gt;= 2 &amp;&amp; to != TypeOopPtr::BOTTOM ) {
1515     ciInstanceKlass *k = to-&gt;klass()-&gt;as_instance_klass();
1516     if( ptr == TypePtr::Constant ) {
1517       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass() ||
1518           offset &lt; k-&gt;size_helper() * wordSize) {
1519         // No constant oop pointers (such as Strings); they alias with
1520         // unknown strings.
1521         assert(!is_known_inst, &quot;not scalarizable allocation&quot;);
1522         tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,offset);
1523       }
1524     } else if( is_known_inst ) {
1525       tj = to; // Keep NotNull and klass_is_exact for instance type
1526     } else if( ptr == TypePtr::NotNull || to-&gt;klass_is_exact() ) {
1527       // During the 2nd round of IterGVN, NotNull castings are removed.
1528       // Make sure the Bottom and NotNull variants alias the same.
1529       // Also, make sure exact and non-exact variants alias the same.
1530       tj = to = TypeInstPtr::make(TypePtr::BotPTR,to-&gt;klass(),false,0,offset);
1531     }
1532     if (to-&gt;speculative() != NULL) {
1533       tj = to = TypeInstPtr::make(to-&gt;ptr(),to-&gt;klass(),to-&gt;klass_is_exact(),to-&gt;const_oop(),to-&gt;offset(), to-&gt;instance_id());
1534     }
1535     // Canonicalize the holder of this field
1536     if (offset &gt;= 0 &amp;&amp; offset &lt; instanceOopDesc::base_offset_in_bytes()) {
1537       // First handle header references such as a LoadKlassNode, even if the
1538       // object&#39;s klass is unloaded at compile time (4965979).
1539       if (!is_known_inst) { // Do it only for non-instance types
1540         tj = to = TypeInstPtr::make(TypePtr::BotPTR, env()-&gt;Object_klass(), false, NULL, offset);
1541       }
1542     } else if (offset &lt; 0 || offset &gt;= k-&gt;size_helper() * wordSize) {
1543       // Static fields are in the space above the normal instance
1544       // fields in the java.lang.Class instance.
1545       if (to-&gt;klass() != ciEnv::current()-&gt;Class_klass()) {
1546         to = NULL;
1547         tj = TypeOopPtr::BOTTOM;
1548         offset = tj-&gt;offset();
1549       }
1550     } else {
1551       ciInstanceKlass *canonical_holder = k-&gt;get_canonical_holder(offset);
1552       if (!k-&gt;equals(canonical_holder) || tj-&gt;offset() != offset) {
1553         if( is_known_inst ) {
1554           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, true, NULL, offset, to-&gt;instance_id());
1555         } else {
1556           tj = to = TypeInstPtr::make(to-&gt;ptr(), canonical_holder, false, NULL, offset);
1557         }
1558       }
1559     }
1560   }
1561 
1562   // Klass pointers to object array klasses need some flattening
1563   const TypeKlassPtr *tk = tj-&gt;isa_klassptr();
1564   if( tk ) {
1565     // If we are referencing a field within a Klass, we need
1566     // to assume the worst case of an Object.  Both exact and
1567     // inexact types must flatten to the same alias class so
1568     // use NotNull as the PTR.
1569     if ( offset == Type::OffsetBot || (offset &gt;= 0 &amp;&amp; (size_t)offset &lt; sizeof(Klass)) ) {
1570 
1571       tj = tk = TypeKlassPtr::make(TypePtr::NotNull,
1572                                    TypeKlassPtr::OBJECT-&gt;klass(),
1573                                    offset);
1574     }
1575 
1576     ciKlass* klass = tk-&gt;klass();
1577     if( klass-&gt;is_obj_array_klass() ) {
1578       ciKlass* k = TypeAryPtr::OOPS-&gt;klass();
1579       if( !k || !k-&gt;is_loaded() )                  // Only fails for some -Xcomp runs
1580         k = TypeInstPtr::BOTTOM-&gt;klass();
1581       tj = tk = TypeKlassPtr::make( TypePtr::NotNull, k, offset );
1582     }
1583 
1584     // Check for precise loads from the primary supertype array and force them
1585     // to the supertype cache alias index.  Check for generic array loads from
1586     // the primary supertype array and also force them to the supertype cache
1587     // alias index.  Since the same load can reach both, we need to merge
1588     // these 2 disparate memories into the same alias class.  Since the
1589     // primary supertype array is read-only, there&#39;s no chance of confusion
1590     // where we bypass an array load and an array store.
1591     int primary_supers_offset = in_bytes(Klass::primary_supers_offset());
1592     if (offset == Type::OffsetBot ||
1593         (offset &gt;= primary_supers_offset &amp;&amp;
1594          offset &lt; (int)(primary_supers_offset + Klass::primary_super_limit() * wordSize)) ||
1595         offset == (int)in_bytes(Klass::secondary_super_cache_offset())) {
1596       offset = in_bytes(Klass::secondary_super_cache_offset());
1597       tj = tk = TypeKlassPtr::make( TypePtr::NotNull, tk-&gt;klass(), offset );
1598     }
1599   }
1600 
1601   // Flatten all Raw pointers together.
1602   if (tj-&gt;base() == Type::RawPtr)
1603     tj = TypeRawPtr::BOTTOM;
1604 
1605   if (tj-&gt;base() == Type::AnyPtr)
1606     tj = TypePtr::BOTTOM;      // An error, which the caller must check for.
1607 
1608   // Flatten all to bottom for now
1609   switch( _AliasLevel ) {
1610   case 0:
1611     tj = TypePtr::BOTTOM;
1612     break;
1613   case 1:                       // Flatten to: oop, static, field or array
1614     switch (tj-&gt;base()) {
1615     //case Type::AryPtr: tj = TypeAryPtr::RANGE;    break;
1616     case Type::RawPtr:   tj = TypeRawPtr::BOTTOM;   break;
1617     case Type::AryPtr:   // do not distinguish arrays at all
1618     case Type::InstPtr:  tj = TypeInstPtr::BOTTOM;  break;
1619     case Type::KlassPtr: tj = TypeKlassPtr::OBJECT; break;
1620     case Type::AnyPtr:   tj = TypePtr::BOTTOM;      break;  // caller checks it
1621     default: ShouldNotReachHere();
1622     }
1623     break;
1624   case 2:                       // No collapsing at level 2; keep all splits
1625   case 3:                       // No collapsing at level 3; keep all splits
1626     break;
1627   default:
1628     Unimplemented();
1629   }
1630 
1631   offset = tj-&gt;offset();
1632   assert( offset != Type::OffsetTop, &quot;Offset has fallen from constant&quot; );
1633 
1634   assert( (offset != Type::OffsetBot &amp;&amp; tj-&gt;base() != Type::AryPtr) ||
1635           (offset == Type::OffsetBot &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1636           (offset == Type::OffsetBot &amp;&amp; tj == TypeOopPtr::BOTTOM) ||
1637           (offset == Type::OffsetBot &amp;&amp; tj == TypePtr::BOTTOM) ||
1638           (offset == oopDesc::mark_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1639           (offset == oopDesc::klass_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr) ||
1640           (offset == arrayOopDesc::length_offset_in_bytes() &amp;&amp; tj-&gt;base() == Type::AryPtr),
1641           &quot;For oops, klasses, raw offset must be constant; for arrays the offset is never known&quot; );
1642   assert( tj-&gt;ptr() != TypePtr::TopPTR &amp;&amp;
1643           tj-&gt;ptr() != TypePtr::AnyNull &amp;&amp;
1644           tj-&gt;ptr() != TypePtr::Null, &quot;No imprecise addresses&quot; );
1645 //    assert( tj-&gt;ptr() != TypePtr::Constant ||
1646 //            tj-&gt;base() == Type::RawPtr ||
1647 //            tj-&gt;base() == Type::KlassPtr, &quot;No constant oop addresses&quot; );
1648 
1649   return tj;
1650 }
1651 
1652 void Compile::AliasType::Init(int i, const TypePtr* at) {
1653   assert(AliasIdxTop &lt;= i &amp;&amp; i &lt; Compile::current()-&gt;_max_alias_types, &quot;Invalid alias index&quot;);
1654   _index = i;
1655   _adr_type = at;
1656   _field = NULL;
1657   _element = NULL;
1658   _is_rewritable = true; // default
1659   const TypeOopPtr *atoop = (at != NULL) ? at-&gt;isa_oopptr() : NULL;
1660   if (atoop != NULL &amp;&amp; atoop-&gt;is_known_instance()) {
1661     const TypeOopPtr *gt = atoop-&gt;cast_to_instance_id(TypeOopPtr::InstanceBot);
1662     _general_index = Compile::current()-&gt;get_alias_index(gt);
1663   } else {
1664     _general_index = 0;
1665   }
1666 }
1667 
1668 BasicType Compile::AliasType::basic_type() const {
1669   if (element() != NULL) {
1670     const Type* element = adr_type()-&gt;is_aryptr()-&gt;elem();
1671     return element-&gt;isa_narrowoop() ? T_OBJECT : element-&gt;array_element_basic_type();
1672   } if (field() != NULL) {
1673     return field()-&gt;layout_type();
1674   } else {
1675     return T_ILLEGAL; // unknown
1676   }
1677 }
1678 
1679 //---------------------------------print_on------------------------------------
1680 #ifndef PRODUCT
1681 void Compile::AliasType::print_on(outputStream* st) {
1682   if (index() &lt; 10)
1683         st-&gt;print(&quot;@ &lt;%d&gt; &quot;, index());
1684   else  st-&gt;print(&quot;@ &lt;%d&gt;&quot;,  index());
1685   st-&gt;print(is_rewritable() ? &quot;   &quot; : &quot; RO&quot;);
1686   int offset = adr_type()-&gt;offset();
1687   if (offset == Type::OffsetBot)
1688         st-&gt;print(&quot; +any&quot;);
1689   else  st-&gt;print(&quot; +%-3d&quot;, offset);
1690   st-&gt;print(&quot; in &quot;);
1691   adr_type()-&gt;dump_on(st);
1692   const TypeOopPtr* tjp = adr_type()-&gt;isa_oopptr();
1693   if (field() != NULL &amp;&amp; tjp) {
1694     if (tjp-&gt;klass()  != field()-&gt;holder() ||
1695         tjp-&gt;offset() != field()-&gt;offset_in_bytes()) {
1696       st-&gt;print(&quot; != &quot;);
1697       field()-&gt;print();
1698       st-&gt;print(&quot; ***&quot;);
1699     }
1700   }
1701 }
1702 
1703 void print_alias_types() {
1704   Compile* C = Compile::current();
1705   tty-&gt;print_cr(&quot;--- Alias types, AliasIdxBot .. %d&quot;, C-&gt;num_alias_types()-1);
1706   for (int idx = Compile::AliasIdxBot; idx &lt; C-&gt;num_alias_types(); idx++) {
1707     C-&gt;alias_type(idx)-&gt;print_on(tty);
1708     tty-&gt;cr();
1709   }
1710 }
1711 #endif
1712 
1713 
1714 //----------------------------probe_alias_cache--------------------------------
1715 Compile::AliasCacheEntry* Compile::probe_alias_cache(const TypePtr* adr_type) {
1716   intptr_t key = (intptr_t) adr_type;
1717   key ^= key &gt;&gt; logAliasCacheSize;
1718   return &amp;_alias_cache[key &amp; right_n_bits(logAliasCacheSize)];
1719 }
1720 
1721 
1722 //-----------------------------grow_alias_types--------------------------------
1723 void Compile::grow_alias_types() {
1724   const int old_ats  = _max_alias_types; // how many before?
1725   const int new_ats  = old_ats;          // how many more?
1726   const int grow_ats = old_ats+new_ats;  // how many now?
1727   _max_alias_types = grow_ats;
1728   _alias_types =  REALLOC_ARENA_ARRAY(comp_arena(), AliasType*, _alias_types, old_ats, grow_ats);
1729   AliasType* ats =    NEW_ARENA_ARRAY(comp_arena(), AliasType, new_ats);
1730   Copy::zero_to_bytes(ats, sizeof(AliasType)*new_ats);
1731   for (int i = 0; i &lt; new_ats; i++)  _alias_types[old_ats+i] = &amp;ats[i];
1732 }
1733 
1734 
1735 //--------------------------------find_alias_type------------------------------
1736 Compile::AliasType* Compile::find_alias_type(const TypePtr* adr_type, bool no_create, ciField* original_field) {
1737   if (_AliasLevel == 0)
1738     return alias_type(AliasIdxBot);
1739 
1740   AliasCacheEntry* ace = probe_alias_cache(adr_type);
1741   if (ace-&gt;_adr_type == adr_type) {
1742     return alias_type(ace-&gt;_index);
1743   }
1744 
1745   // Handle special cases.
1746   if (adr_type == NULL)             return alias_type(AliasIdxTop);
1747   if (adr_type == TypePtr::BOTTOM)  return alias_type(AliasIdxBot);
1748 
1749   // Do it the slow way.
1750   const TypePtr* flat = flatten_alias_type(adr_type);
1751 
1752 #ifdef ASSERT
1753   {
1754     ResourceMark rm;
1755     assert(flat == flatten_alias_type(flat), &quot;not idempotent: adr_type = %s; flat = %s =&gt; %s&quot;,
1756            Type::str(adr_type), Type::str(flat), Type::str(flatten_alias_type(flat)));
1757     assert(flat != TypePtr::BOTTOM, &quot;cannot alias-analyze an untyped ptr: adr_type = %s&quot;,
1758            Type::str(adr_type));
1759     if (flat-&gt;isa_oopptr() &amp;&amp; !flat-&gt;isa_klassptr()) {
1760       const TypeOopPtr* foop = flat-&gt;is_oopptr();
1761       // Scalarizable allocations have exact klass always.
1762       bool exact = !foop-&gt;klass_is_exact() || foop-&gt;is_known_instance();
1763       const TypePtr* xoop = foop-&gt;cast_to_exactness(exact)-&gt;is_ptr();
1764       assert(foop == flatten_alias_type(xoop), &quot;exactness must not affect alias type: foop = %s; xoop = %s&quot;,
1765              Type::str(foop), Type::str(xoop));
1766     }
1767   }
1768 #endif
1769 
1770   int idx = AliasIdxTop;
1771   for (int i = 0; i &lt; num_alias_types(); i++) {
1772     if (alias_type(i)-&gt;adr_type() == flat) {
1773       idx = i;
1774       break;
1775     }
1776   }
1777 
1778   if (idx == AliasIdxTop) {
1779     if (no_create)  return NULL;
1780     // Grow the array if necessary.
1781     if (_num_alias_types == _max_alias_types)  grow_alias_types();
1782     // Add a new alias type.
1783     idx = _num_alias_types++;
1784     _alias_types[idx]-&gt;Init(idx, flat);
1785     if (flat == TypeInstPtr::KLASS)  alias_type(idx)-&gt;set_rewritable(false);
1786     if (flat == TypeAryPtr::RANGE)   alias_type(idx)-&gt;set_rewritable(false);
1787     if (flat-&gt;isa_instptr()) {
1788       if (flat-&gt;offset() == java_lang_Class::klass_offset_in_bytes()
1789           &amp;&amp; flat-&gt;is_instptr()-&gt;klass() == env()-&gt;Class_klass())
1790         alias_type(idx)-&gt;set_rewritable(false);
1791     }
1792     if (flat-&gt;isa_aryptr()) {
1793 #ifdef ASSERT
1794       const int header_size_min  = arrayOopDesc::base_offset_in_bytes(T_BYTE);
1795       // (T_BYTE has the weakest alignment and size restrictions...)
1796       assert(flat-&gt;offset() &lt; header_size_min, &quot;array body reference must be OffsetBot&quot;);
1797 #endif
1798       if (flat-&gt;offset() == TypePtr::OffsetBot) {
1799         alias_type(idx)-&gt;set_element(flat-&gt;is_aryptr()-&gt;elem());
1800       }
1801     }
1802     if (flat-&gt;isa_klassptr()) {
1803       if (flat-&gt;offset() == in_bytes(Klass::super_check_offset_offset()))
1804         alias_type(idx)-&gt;set_rewritable(false);
1805       if (flat-&gt;offset() == in_bytes(Klass::modifier_flags_offset()))
1806         alias_type(idx)-&gt;set_rewritable(false);
1807       if (flat-&gt;offset() == in_bytes(Klass::access_flags_offset()))
1808         alias_type(idx)-&gt;set_rewritable(false);
1809       if (flat-&gt;offset() == in_bytes(Klass::java_mirror_offset()))
1810         alias_type(idx)-&gt;set_rewritable(false);
1811       if (flat-&gt;offset() == in_bytes(Klass::secondary_super_cache_offset()))
1812         alias_type(idx)-&gt;set_rewritable(false);
1813     }
1814     // %%% (We would like to finalize JavaThread::threadObj_offset(),
1815     // but the base pointer type is not distinctive enough to identify
1816     // references into JavaThread.)
1817 
1818     // Check for final fields.
1819     const TypeInstPtr* tinst = flat-&gt;isa_instptr();
1820     if (tinst &amp;&amp; tinst-&gt;offset() &gt;= instanceOopDesc::base_offset_in_bytes()) {
1821       ciField* field;
1822       if (tinst-&gt;const_oop() != NULL &amp;&amp;
1823           tinst-&gt;klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
1824           tinst-&gt;offset() &gt;= (tinst-&gt;klass()-&gt;as_instance_klass()-&gt;size_helper() * wordSize)) {
1825         // static field
1826         ciInstanceKlass* k = tinst-&gt;const_oop()-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
1827         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), true);
1828       } else {
1829         ciInstanceKlass *k = tinst-&gt;klass()-&gt;as_instance_klass();
1830         field = k-&gt;get_field_by_offset(tinst-&gt;offset(), false);
1831       }
1832       assert(field == NULL ||
1833              original_field == NULL ||
1834              (field-&gt;holder() == original_field-&gt;holder() &amp;&amp;
1835               field-&gt;offset() == original_field-&gt;offset() &amp;&amp;
1836               field-&gt;is_static() == original_field-&gt;is_static()), &quot;wrong field?&quot;);
1837       // Set field() and is_rewritable() attributes.
1838       if (field != NULL)  alias_type(idx)-&gt;set_field(field);
1839     }
1840   }
1841 
1842   // Fill the cache for next time.
1843   ace-&gt;_adr_type = adr_type;
1844   ace-&gt;_index    = idx;
1845   assert(alias_type(adr_type) == alias_type(idx),  &quot;type must be installed&quot;);
1846 
1847   // Might as well try to fill the cache for the flattened version, too.
1848   AliasCacheEntry* face = probe_alias_cache(flat);
1849   if (face-&gt;_adr_type == NULL) {
1850     face-&gt;_adr_type = flat;
1851     face-&gt;_index    = idx;
1852     assert(alias_type(flat) == alias_type(idx), &quot;flat type must work too&quot;);
1853   }
1854 
1855   return alias_type(idx);
1856 }
1857 
1858 
1859 Compile::AliasType* Compile::alias_type(ciField* field) {
1860   const TypeOopPtr* t;
1861   if (field-&gt;is_static())
1862     t = TypeInstPtr::make(field-&gt;holder()-&gt;java_mirror());
1863   else
1864     t = TypeOopPtr::make_from_klass_raw(field-&gt;holder());
1865   AliasType* atp = alias_type(t-&gt;add_offset(field-&gt;offset_in_bytes()), field);
1866   assert((field-&gt;is_final() || field-&gt;is_stable()) == !atp-&gt;is_rewritable(), &quot;must get the rewritable bits correct&quot;);
1867   return atp;
1868 }
1869 
1870 
1871 //------------------------------have_alias_type--------------------------------
1872 bool Compile::have_alias_type(const TypePtr* adr_type) {
1873   AliasCacheEntry* ace = probe_alias_cache(adr_type);
1874   if (ace-&gt;_adr_type == adr_type) {
1875     return true;
1876   }
1877 
1878   // Handle special cases.
1879   if (adr_type == NULL)             return true;
1880   if (adr_type == TypePtr::BOTTOM)  return true;
1881 
1882   return find_alias_type(adr_type, true, NULL) != NULL;
1883 }
1884 
1885 //-----------------------------must_alias--------------------------------------
1886 // True if all values of the given address type are in the given alias category.
1887 bool Compile::must_alias(const TypePtr* adr_type, int alias_idx) {
1888   if (alias_idx == AliasIdxBot)         return true;  // the universal category
1889   if (adr_type == NULL)                 return true;  // NULL serves as TypePtr::TOP
1890   if (alias_idx == AliasIdxTop)         return false; // the empty category
1891   if (adr_type-&gt;base() == Type::AnyPtr) return false; // TypePtr::BOTTOM or its twins
1892 
1893   // the only remaining possible overlap is identity
1894   int adr_idx = get_alias_index(adr_type);
1895   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1896   assert(adr_idx == alias_idx ||
1897          (alias_type(alias_idx)-&gt;adr_type() != TypeOopPtr::BOTTOM
1898           &amp;&amp; adr_type                       != TypeOopPtr::BOTTOM),
1899          &quot;should not be testing for overlap with an unsafe pointer&quot;);
1900   return adr_idx == alias_idx;
1901 }
1902 
1903 //------------------------------can_alias--------------------------------------
1904 // True if any values of the given address type are in the given alias category.
1905 bool Compile::can_alias(const TypePtr* adr_type, int alias_idx) {
1906   if (alias_idx == AliasIdxTop)         return false; // the empty category
1907   if (adr_type == NULL)                 return false; // NULL serves as TypePtr::TOP
1908   // Known instance doesn&#39;t alias with bottom memory
1909   if (alias_idx == AliasIdxBot)         return !adr_type-&gt;is_known_instance();                   // the universal category
1910   if (adr_type-&gt;base() == Type::AnyPtr) return !C-&gt;get_adr_type(alias_idx)-&gt;is_known_instance(); // TypePtr::BOTTOM or its twins
1911 
1912   // the only remaining possible overlap is identity
1913   int adr_idx = get_alias_index(adr_type);
1914   assert(adr_idx != AliasIdxBot &amp;&amp; adr_idx != AliasIdxTop, &quot;&quot;);
1915   return adr_idx == alias_idx;
1916 }
1917 
1918 
1919 
1920 //---------------------------pop_warm_call-------------------------------------
1921 WarmCallInfo* Compile::pop_warm_call() {
1922   WarmCallInfo* wci = _warm_calls;
1923   if (wci != NULL)  _warm_calls = wci-&gt;remove_from(wci);
1924   return wci;
1925 }
1926 
1927 //----------------------------Inline_Warm--------------------------------------
1928 int Compile::Inline_Warm() {
1929   // If there is room, try to inline some more warm call sites.
1930   // %%% Do a graph index compaction pass when we think we&#39;re out of space?
1931   if (!InlineWarmCalls)  return 0;
1932 
1933   int calls_made_hot = 0;
1934   int room_to_grow   = NodeCountInliningCutoff - unique();
1935   int amount_to_grow = MIN2(room_to_grow, (int)NodeCountInliningStep);
1936   int amount_grown   = 0;
1937   WarmCallInfo* call;
1938   while (amount_to_grow &gt; 0 &amp;&amp; (call = pop_warm_call()) != NULL) {
1939     int est_size = (int)call-&gt;size();
1940     if (est_size &gt; (room_to_grow - amount_grown)) {
1941       // This one won&#39;t fit anyway.  Get rid of it.
1942       call-&gt;make_cold();
1943       continue;
1944     }
1945     call-&gt;make_hot();
1946     calls_made_hot++;
1947     amount_grown   += est_size;
1948     amount_to_grow -= est_size;
1949   }
1950 
1951   if (calls_made_hot &gt; 0)  set_major_progress();
1952   return calls_made_hot;
1953 }
1954 
1955 
1956 //----------------------------Finish_Warm--------------------------------------
1957 void Compile::Finish_Warm() {
1958   if (!InlineWarmCalls)  return;
1959   if (failing())  return;
1960   if (warm_calls() == NULL)  return;
1961 
1962   // Clean up loose ends, if we are out of space for inlining.
1963   WarmCallInfo* call;
1964   while ((call = pop_warm_call()) != NULL) {
1965     call-&gt;make_cold();
1966   }
1967 }
1968 
1969 //---------------------cleanup_loop_predicates-----------------------
1970 // Remove the opaque nodes that protect the predicates so that all unused
1971 // checks and uncommon_traps will be eliminated from the ideal graph
1972 void Compile::cleanup_loop_predicates(PhaseIterGVN &amp;igvn) {
1973   if (predicate_count()==0) return;
1974   for (int i = predicate_count(); i &gt; 0; i--) {
1975     Node * n = predicate_opaque1_node(i-1);
1976     assert(n-&gt;Opcode() == Op_Opaque1, &quot;must be&quot;);
1977     igvn.replace_node(n, n-&gt;in(1));
1978   }
1979   assert(predicate_count()==0, &quot;should be clean!&quot;);
1980 }
1981 
1982 void Compile::add_range_check_cast(Node* n) {
1983   assert(n-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
1984   assert(!_range_check_casts-&gt;contains(n), &quot;duplicate entry in range check casts&quot;);
1985   _range_check_casts-&gt;append(n);
1986 }
1987 
1988 // Remove all range check dependent CastIINodes.
1989 void Compile::remove_range_check_casts(PhaseIterGVN &amp;igvn) {
1990   for (int i = range_check_cast_count(); i &gt; 0; i--) {
1991     Node* cast = range_check_cast_node(i-1);
1992     assert(cast-&gt;isa_CastII()-&gt;has_range_check(), &quot;CastII should have range check dependency&quot;);
1993     igvn.replace_node(cast, cast-&gt;in(1));
1994   }
1995   assert(range_check_cast_count() == 0, &quot;should be empty&quot;);
1996 }
1997 
1998 void Compile::add_opaque4_node(Node* n) {
1999   assert(n-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
2000   assert(!_opaque4_nodes-&gt;contains(n), &quot;duplicate entry in Opaque4 list&quot;);
2001   _opaque4_nodes-&gt;append(n);
2002 }
2003 
2004 // Remove all Opaque4 nodes.
2005 void Compile::remove_opaque4_nodes(PhaseIterGVN &amp;igvn) {
2006   for (int i = opaque4_count(); i &gt; 0; i--) {
2007     Node* opaq = opaque4_node(i-1);
2008     assert(opaq-&gt;Opcode() == Op_Opaque4, &quot;Opaque4 only&quot;);
2009     igvn.replace_node(opaq, opaq-&gt;in(2));
2010   }
2011   assert(opaque4_count() == 0, &quot;should be empty&quot;);
2012 }
2013 
2014 // StringOpts and late inlining of string methods
2015 void Compile::inline_string_calls(bool parse_time) {
2016   {
2017     // remove useless nodes to make the usage analysis simpler
2018     ResourceMark rm;
2019     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2020   }
2021 
2022   {
2023     ResourceMark rm;
2024     print_method(PHASE_BEFORE_STRINGOPTS, 3);
2025     PhaseStringOpts pso(initial_gvn(), for_igvn());
2026     print_method(PHASE_AFTER_STRINGOPTS, 3);
2027   }
2028 
2029   // now inline anything that we skipped the first time around
2030   if (!parse_time) {
2031     _late_inlines_pos = _late_inlines.length();
2032   }
2033 
2034   while (_string_late_inlines.length() &gt; 0) {
2035     CallGenerator* cg = _string_late_inlines.pop();
2036     cg-&gt;do_late_inline();
2037     if (failing())  return;
2038   }
2039   _string_late_inlines.trunc_to(0);
2040 }
2041 
2042 // Late inlining of boxing methods
2043 void Compile::inline_boxing_calls(PhaseIterGVN&amp; igvn) {
2044   if (_boxing_late_inlines.length() &gt; 0) {
2045     assert(has_boxed_value(), &quot;inconsistent&quot;);
2046 
2047     PhaseGVN* gvn = initial_gvn();
2048     set_inlining_incrementally(true);
2049 
2050     assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2051     for_igvn()-&gt;clear();
2052     gvn-&gt;replace_with(&amp;igvn);
2053 
2054     _late_inlines_pos = _late_inlines.length();
2055 
2056     while (_boxing_late_inlines.length() &gt; 0) {
2057       CallGenerator* cg = _boxing_late_inlines.pop();
2058       cg-&gt;do_late_inline();
2059       if (failing())  return;
2060     }
2061     _boxing_late_inlines.trunc_to(0);
2062 
2063     inline_incrementally_cleanup(igvn);
2064 
2065     set_inlining_incrementally(false);
2066   }
2067 }
2068 
2069 bool Compile::inline_incrementally_one() {
2070   assert(IncrementalInline, &quot;incremental inlining should be on&quot;);
2071 
2072   TracePhase tp(&quot;incrementalInline_inline&quot;, &amp;timers[_t_incrInline_inline]);
2073   set_inlining_progress(false);
2074   set_do_cleanup(false);
2075   int i = 0;
2076   for (; i &lt;_late_inlines.length() &amp;&amp; !inlining_progress(); i++) {
2077     CallGenerator* cg = _late_inlines.at(i);
2078     _late_inlines_pos = i+1;
2079     cg-&gt;do_late_inline();
2080     if (failing())  return false;
2081   }
2082   int j = 0;
2083   for (; i &lt; _late_inlines.length(); i++, j++) {
2084     _late_inlines.at_put(j, _late_inlines.at(i));
2085   }
2086   _late_inlines.trunc_to(j);
2087   assert(inlining_progress() || _late_inlines.length() == 0, &quot;&quot;);
2088 
2089   bool needs_cleanup = do_cleanup() || over_inlining_cutoff();
2090 
2091   set_inlining_progress(false);
2092   set_do_cleanup(false);
2093   return (_late_inlines.length() &gt; 0) &amp;&amp; !needs_cleanup;
2094 }
2095 
2096 void Compile::inline_incrementally_cleanup(PhaseIterGVN&amp; igvn) {
2097   {
2098     TracePhase tp(&quot;incrementalInline_pru&quot;, &amp;timers[_t_incrInline_pru]);
2099     ResourceMark rm;
2100     PhaseRemoveUseless pru(initial_gvn(), for_igvn());
2101   }
2102   {
2103     TracePhase tp(&quot;incrementalInline_igvn&quot;, &amp;timers[_t_incrInline_igvn]);
2104     igvn = PhaseIterGVN(initial_gvn());
2105     igvn.optimize();
2106   }
2107 }
2108 
2109 // Perform incremental inlining until bound on number of live nodes is reached
2110 void Compile::inline_incrementally(PhaseIterGVN&amp; igvn) {
2111   TracePhase tp(&quot;incrementalInline&quot;, &amp;timers[_t_incrInline]);
2112 
2113   set_inlining_incrementally(true);
2114   uint low_live_nodes = 0;
2115 
2116   while (_late_inlines.length() &gt; 0) {
2117     if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2118       if (low_live_nodes &lt; (uint)LiveNodeCountInliningCutoff * 8 / 10) {
2119         TracePhase tp(&quot;incrementalInline_ideal&quot;, &amp;timers[_t_incrInline_ideal]);
2120         // PhaseIdealLoop is expensive so we only try it once we are
2121         // out of live nodes and we only try it again if the previous
2122         // helped got the number of nodes down significantly
2123         PhaseIdealLoop::optimize(igvn, LoopOptsNone);
2124         if (failing())  return;
2125         low_live_nodes = live_nodes();
2126         _major_progress = true;
2127       }
2128 
2129       if (live_nodes() &gt; (uint)LiveNodeCountInliningCutoff) {
2130         break; // finish
2131       }
2132     }
2133 
2134     for_igvn()-&gt;clear();
2135     initial_gvn()-&gt;replace_with(&amp;igvn);
2136 
2137     while (inline_incrementally_one()) {
2138       assert(!failing(), &quot;inconsistent&quot;);
2139     }
2140 
2141     if (failing())  return;
2142 
2143     inline_incrementally_cleanup(igvn);
2144 
2145     if (failing())  return;
2146   }
2147   assert( igvn._worklist.size() == 0, &quot;should be done with igvn&quot; );
2148 
2149   if (_string_late_inlines.length() &gt; 0) {
2150     assert(has_stringbuilder(), &quot;inconsistent&quot;);
2151     for_igvn()-&gt;clear();
2152     initial_gvn()-&gt;replace_with(&amp;igvn);
2153 
2154     inline_string_calls(false);
2155 
2156     if (failing())  return;
2157 
2158     inline_incrementally_cleanup(igvn);
2159   }
2160 
2161   set_inlining_incrementally(false);
2162 }
2163 
2164 
2165 bool Compile::optimize_loops(PhaseIterGVN&amp; igvn, LoopOptsMode mode) {
2166   if(_loop_opts_cnt &gt; 0) {
2167     debug_only( int cnt = 0; );
2168     while(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2169       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2170       assert( cnt++ &lt; 40, &quot;infinite cycle in loop optimization&quot; );
2171       PhaseIdealLoop::optimize(igvn, mode);
2172       _loop_opts_cnt--;
2173       if (failing())  return false;
2174       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP_ITERATIONS, 2);
2175     }
2176   }
2177   return true;
2178 }
2179 
2180 // Remove edges from &quot;root&quot; to each SafePoint at a backward branch.
2181 // They were inserted during parsing (see add_safepoint()) to make
2182 // infinite loops without calls or exceptions visible to root, i.e.,
2183 // useful.
2184 void Compile::remove_root_to_sfpts_edges(PhaseIterGVN&amp; igvn) {
2185   Node *r = root();
2186   if (r != NULL) {
2187     for (uint i = r-&gt;req(); i &lt; r-&gt;len(); ++i) {
2188       Node *n = r-&gt;in(i);
2189       if (n != NULL &amp;&amp; n-&gt;is_SafePoint()) {
2190         r-&gt;rm_prec(i);
2191         if (n-&gt;outcnt() == 0) {
2192           igvn.remove_dead_node(n);
2193         }
2194         --i;
2195       }
2196     }
2197     // Parsing may have added top inputs to the root node (Path
2198     // leading to the Halt node proven dead). Make sure we get a
2199     // chance to clean them up.
2200     igvn._worklist.push(r);
2201     igvn.optimize();
2202   }
2203 }
2204 
2205 //------------------------------Optimize---------------------------------------
2206 // Given a graph, optimize it.
2207 void Compile::Optimize() {
2208   TracePhase tp(&quot;optimizer&quot;, &amp;timers[_t_optimizer]);
2209 
2210 #ifndef PRODUCT
2211   if (_directive-&gt;BreakAtCompileOption) {
2212     BREAKPOINT;
2213   }
2214 
2215 #endif
2216 
2217   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
2218 #ifdef ASSERT
2219   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeOptimize);
2220 #endif
2221 
2222   ResourceMark rm;
2223 
2224   print_inlining_reinit();
2225 
2226   NOT_PRODUCT( verify_graph_edges(); )
2227 
2228   print_method(PHASE_AFTER_PARSING);
2229 
2230  {
2231   // Iterative Global Value Numbering, including ideal transforms
2232   // Initialize IterGVN with types and values from parse-time GVN
2233   PhaseIterGVN igvn(initial_gvn());
2234 #ifdef ASSERT
2235   _modified_nodes = new (comp_arena()) Unique_Node_List(comp_arena());
2236 #endif
2237   {
2238     TracePhase tp(&quot;iterGVN&quot;, &amp;timers[_t_iterGVN]);
2239     igvn.optimize();
2240   }
2241 
2242   if (failing())  return;
2243 
2244   print_method(PHASE_ITER_GVN1, 2);
2245 
2246   inline_incrementally(igvn);
2247 
2248   print_method(PHASE_INCREMENTAL_INLINE, 2);
2249 
2250   if (failing())  return;
2251 
2252   if (eliminate_boxing()) {
2253     // Inline valueOf() methods now.
2254     inline_boxing_calls(igvn);
2255 
2256     if (AlwaysIncrementalInline) {
2257       inline_incrementally(igvn);
2258     }
2259 
2260     print_method(PHASE_INCREMENTAL_BOXING_INLINE, 2);
2261 
2262     if (failing())  return;
2263   }
2264 
2265   // Now that all inlining is over, cut edge from root to loop
2266   // safepoints
2267   remove_root_to_sfpts_edges(igvn);
2268 
2269   // Remove the speculative part of types and clean up the graph from
2270   // the extra CastPP nodes whose only purpose is to carry them. Do
2271   // that early so that optimizations are not disrupted by the extra
2272   // CastPP nodes.
2273   remove_speculative_types(igvn);
2274 
2275   // No more new expensive nodes will be added to the list from here
2276   // so keep only the actual candidates for optimizations.
2277   cleanup_expensive_nodes(igvn);
2278 
2279   if (!failing() &amp;&amp; RenumberLiveNodes &amp;&amp; live_nodes() + NodeLimitFudgeFactor &lt; unique()) {
2280     Compile::TracePhase tp(&quot;&quot;, &amp;timers[_t_renumberLive]);
2281     initial_gvn()-&gt;replace_with(&amp;igvn);
2282     for_igvn()-&gt;clear();
2283     Unique_Node_List new_worklist(C-&gt;comp_arena());
2284     {
2285       ResourceMark rm;
2286       PhaseRenumberLive prl = PhaseRenumberLive(initial_gvn(), for_igvn(), &amp;new_worklist);
2287     }
2288     set_for_igvn(&amp;new_worklist);
2289     igvn = PhaseIterGVN(initial_gvn());
2290     igvn.optimize();
2291   }
2292 
2293   // Perform escape analysis
2294   if (_do_escape_analysis &amp;&amp; ConnectionGraph::has_candidates(this)) {
2295     if (has_loops()) {
2296       // Cleanup graph (remove dead nodes).
2297       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2298       PhaseIdealLoop::optimize(igvn, LoopOptsMaxUnroll);
2299       if (major_progress()) print_method(PHASE_PHASEIDEAL_BEFORE_EA, 2);
2300       if (failing())  return;
2301     }
2302     ConnectionGraph::do_analysis(this, &amp;igvn);
2303 
2304     if (failing())  return;
2305 
2306     // Optimize out fields loads from scalar replaceable allocations.
2307     igvn.optimize();
2308     print_method(PHASE_ITER_GVN_AFTER_EA, 2);
2309 
2310     if (failing())  return;
2311 
2312     if (congraph() != NULL &amp;&amp; macro_count() &gt; 0) {
2313       TracePhase tp(&quot;macroEliminate&quot;, &amp;timers[_t_macroEliminate]);
2314       PhaseMacroExpand mexp(igvn);
2315       mexp.eliminate_macro_nodes();
2316       igvn.set_delay_transform(false);
2317 
2318       igvn.optimize();
2319       print_method(PHASE_ITER_GVN_AFTER_ELIMINATION, 2);
2320 
2321       if (failing())  return;
2322     }
2323   }
2324 
2325   // Loop transforms on the ideal graph.  Range Check Elimination,
2326   // peeling, unrolling, etc.
2327 
2328   // Set loop opts counter
2329   if((_loop_opts_cnt &gt; 0) &amp;&amp; (has_loops() || has_split_ifs())) {
2330     {
2331       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2332       PhaseIdealLoop::optimize(igvn, LoopOptsDefault);
2333       _loop_opts_cnt--;
2334       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP1, 2);
2335       if (failing())  return;
2336     }
2337     // Loop opts pass if partial peeling occurred in previous pass
2338     if(PartialPeelLoop &amp;&amp; major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2339       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2340       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2341       _loop_opts_cnt--;
2342       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP2, 2);
2343       if (failing())  return;
2344     }
2345     // Loop opts pass for loop-unrolling before CCP
2346     if(major_progress() &amp;&amp; (_loop_opts_cnt &gt; 0)) {
2347       TracePhase tp(&quot;idealLoop&quot;, &amp;timers[_t_idealLoop]);
2348       PhaseIdealLoop::optimize(igvn, LoopOptsSkipSplitIf);
2349       _loop_opts_cnt--;
2350       if (major_progress()) print_method(PHASE_PHASEIDEALLOOP3, 2);
2351     }
2352     if (!failing()) {
2353       // Verify that last round of loop opts produced a valid graph
2354       TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2355       PhaseIdealLoop::verify(igvn);
2356     }
2357   }
2358   if (failing())  return;
2359 
2360   // Conditional Constant Propagation;
2361   PhaseCCP ccp( &amp;igvn );
2362   assert( true, &quot;Break here to ccp.dump_nodes_and_types(_root,999,1)&quot;);
2363   {
2364     TracePhase tp(&quot;ccp&quot;, &amp;timers[_t_ccp]);
2365     ccp.do_transform();
2366   }
2367   print_method(PHASE_CPP1, 2);
2368 
2369   assert( true, &quot;Break here to ccp.dump_old2new_map()&quot;);
2370 
2371   // Iterative Global Value Numbering, including ideal transforms
2372   {
2373     TracePhase tp(&quot;iterGVN2&quot;, &amp;timers[_t_iterGVN2]);
2374     igvn = ccp;
2375     igvn.optimize();
2376   }
2377   print_method(PHASE_ITER_GVN2, 2);
2378 
2379   if (failing())  return;
2380 
2381   // Loop transforms on the ideal graph.  Range Check Elimination,
2382   // peeling, unrolling, etc.
2383   if (!optimize_loops(igvn, LoopOptsDefault)) {
2384     return;
2385   }
2386 
2387   if (failing())  return;
2388 
2389   // Ensure that major progress is now clear
2390   C-&gt;clear_major_progress();
2391 
2392   {
2393     // Verify that all previous optimizations produced a valid graph
2394     // at least to this point, even if no loop optimizations were done.
2395     TracePhase tp(&quot;idealLoopVerify&quot;, &amp;timers[_t_idealLoopVerify]);
2396     PhaseIdealLoop::verify(igvn);
2397   }
2398 
2399   if (range_check_cast_count() &gt; 0) {
2400     // No more loop optimizations. Remove all range check dependent CastIINodes.
2401     C-&gt;remove_range_check_casts(igvn);
2402     igvn.optimize();
2403   }
2404 
2405 #ifdef ASSERT
2406   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeMacroExpand);
2407 #endif
2408 
2409   {
2410     TracePhase tp(&quot;macroExpand&quot;, &amp;timers[_t_macroExpand]);
2411     PhaseMacroExpand  mex(igvn);
2412     if (mex.expand_macro_nodes()) {
2413       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2414       return;
2415     }
2416     print_method(PHASE_MACRO_EXPANSION, 2);
2417   }
2418 
2419   {
2420     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2421     if (bs-&gt;expand_barriers(this, igvn)) {
2422       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2423       return;
2424     }
2425     print_method(PHASE_BARRIER_EXPANSION, 2);
2426   }
2427 
2428   if (opaque4_count() &gt; 0) {
2429     C-&gt;remove_opaque4_nodes(igvn);
2430     igvn.optimize();
2431   }
2432 
<a name="18" id="anc18"></a>




2433   DEBUG_ONLY( _modified_nodes = NULL; )
2434  } // (End scope of igvn; run destructor if necessary for asserts.)
2435 
2436  process_print_inlining();
2437  // A method with only infinite loops has no edges entering loops from root
2438  {
2439    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2440    if (final_graph_reshaping()) {
2441      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2442      return;
2443    }
2444  }
2445 
2446  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2447 }
2448 
<a name="19" id="anc19"></a>






















































































































































































































































































































2449 
2450 //------------------------------Code_Gen---------------------------------------
2451 // Given a graph, generate code for it
2452 void Compile::Code_Gen() {
2453   if (failing()) {
2454     return;
2455   }
2456 
2457   // Perform instruction selection.  You might think we could reclaim Matcher
2458   // memory PDQ, but actually the Matcher is used in generating spill code.
2459   // Internals of the Matcher (including some VectorSets) must remain live
2460   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2461   // set a bit in reclaimed memory.
2462 
2463   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2464   // nodes.  Mapping is only valid at the root of each matched subtree.
2465   NOT_PRODUCT( verify_graph_edges(); )
2466 
2467   Matcher matcher;
2468   _matcher = &amp;matcher;
2469   {
2470     TracePhase tp(&quot;matcher&quot;, &amp;timers[_t_matcher]);
2471     matcher.match();
2472     if (failing()) {
2473       return;
2474     }
2475   }
2476 
2477   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2478   // nodes.  Mapping is only valid at the root of each matched subtree.
2479   NOT_PRODUCT( verify_graph_edges(); )
2480 
2481   // If you have too many nodes, or if matching has failed, bail out
2482   check_node_count(0, &quot;out of nodes matching instructions&quot;);
2483   if (failing()) {
2484     return;
2485   }
2486 
2487   print_method(PHASE_MATCHING, 2);
2488 
2489   // Build a proper-looking CFG
2490   PhaseCFG cfg(node_arena(), root(), matcher);
2491   _cfg = &amp;cfg;
2492   {
2493     TracePhase tp(&quot;scheduler&quot;, &amp;timers[_t_scheduler]);
2494     bool success = cfg.do_global_code_motion();
2495     if (!success) {
2496       return;
2497     }
2498 
2499     print_method(PHASE_GLOBAL_CODE_MOTION, 2);
2500     NOT_PRODUCT( verify_graph_edges(); )
2501     debug_only( cfg.verify(); )
2502   }
2503 
2504   PhaseChaitin regalloc(unique(), cfg, matcher, false);
2505   _regalloc = &amp;regalloc;
2506   {
2507     TracePhase tp(&quot;regalloc&quot;, &amp;timers[_t_registerAllocation]);
2508     // Perform register allocation.  After Chaitin, use-def chains are
2509     // no longer accurate (at spill code) and so must be ignored.
2510     // Node-&gt;LRG-&gt;reg mappings are still accurate.
2511     _regalloc-&gt;Register_Allocate();
2512 
2513     // Bail out if the allocator builds too many nodes
2514     if (failing()) {
2515       return;
2516     }
2517   }
2518 
2519   // Prior to register allocation we kept empty basic blocks in case the
2520   // the allocator needed a place to spill.  After register allocation we
2521   // are not adding any new instructions.  If any basic block is empty, we
2522   // can now safely remove it.
2523   {
2524     TracePhase tp(&quot;blockOrdering&quot;, &amp;timers[_t_blockOrdering]);
2525     cfg.remove_empty_blocks();
2526     if (do_freq_based_layout()) {
2527       PhaseBlockLayout layout(cfg);
2528     } else {
2529       cfg.set_loop_alignment();
2530     }
2531     cfg.fixup_flow();
2532   }
2533 
2534   // Apply peephole optimizations
2535   if( OptoPeephole ) {
2536     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2537     PhasePeephole peep( _regalloc, cfg);
2538     peep.do_transform();
2539   }
2540 
2541   // Do late expand if CPU requires this.
2542   if (Matcher::require_postalloc_expand) {
2543     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2544     cfg.postalloc_expand(_regalloc);
2545   }
2546 
2547   // Convert Nodes to instruction bits in a buffer
2548   {
<a name="20" id="anc20"></a><span class="line-modified">2549     TraceTime tp(&quot;output&quot;, &amp;timers[_t_output], CITime);</span>
<span class="line-modified">2550     Output();</span>



2551   }
2552 
2553   print_method(PHASE_FINAL_CODE);
2554 
2555   // He&#39;s dead, Jim.
2556   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2557   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2558 }
2559 
<a name="21" id="anc21"></a><span class="line-removed">2560 </span>
<span class="line-removed">2561 //------------------------------dump_asm---------------------------------------</span>
<span class="line-removed">2562 // Dump formatted assembly</span>
<span class="line-removed">2563 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">2564 void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-removed">2565 </span>
<span class="line-removed">2566   int pc_digits = 3; // #chars required for pc</span>
<span class="line-removed">2567   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-removed">2568   int tab_size  = 8;</span>
<span class="line-removed">2569   if (pcs != NULL) {</span>
<span class="line-removed">2570     int max_pc = 0;</span>
<span class="line-removed">2571     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-removed">2572       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-removed">2573     }</span>
<span class="line-removed">2574     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-removed">2575   }</span>
<span class="line-removed">2576   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-removed">2577 </span>
<span class="line-removed">2578   bool cut_short = false;</span>
<span class="line-removed">2579   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">2580   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-removed">2581   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">2582 </span>
<span class="line-removed">2583   // For all blocks</span>
<span class="line-removed">2584   int pc = 0x0;                 // Program counter</span>
<span class="line-removed">2585   char starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2586   _regalloc-&gt;dump_frame();</span>
<span class="line-removed">2587 </span>
<span class="line-removed">2588   Node *n = NULL;</span>
<span class="line-removed">2589   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-removed">2590     if (VMThread::should_terminate()) {</span>
<span class="line-removed">2591       cut_short = true;</span>
<span class="line-removed">2592       break;</span>
<span class="line-removed">2593     }</span>
<span class="line-removed">2594     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-removed">2595     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-removed">2596       continue;</span>
<span class="line-removed">2597     }</span>
<span class="line-removed">2598     n = block-&gt;head();</span>
<span class="line-removed">2599     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2600       pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2601       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2602     }</span>
<span class="line-removed">2603     st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2604     block-&gt;dump_head(_cfg, st);</span>
<span class="line-removed">2605     if (block-&gt;is_connector()) {</span>
<span class="line-removed">2606       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2607       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-removed">2608     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-removed">2609       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2610       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-removed">2611     }</span>
<span class="line-removed">2612 </span>
<span class="line-removed">2613     // For all instructions</span>
<span class="line-removed">2614     Node *delay = NULL;</span>
<span class="line-removed">2615     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-removed">2616       if (VMThread::should_terminate()) {</span>
<span class="line-removed">2617         cut_short = true;</span>
<span class="line-removed">2618         break;</span>
<span class="line-removed">2619       }</span>
<span class="line-removed">2620       n = block-&gt;get_node(j);</span>
<span class="line-removed">2621       if (valid_bundle_info(n)) {</span>
<span class="line-removed">2622         Bundle* bundle = node_bundling(n);</span>
<span class="line-removed">2623         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-removed">2624           delay = n;</span>
<span class="line-removed">2625           continue;</span>
<span class="line-removed">2626         }</span>
<span class="line-removed">2627         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-removed">2628           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">2629         }</span>
<span class="line-removed">2630       }</span>
<span class="line-removed">2631 </span>
<span class="line-removed">2632       if (WizardMode) {</span>
<span class="line-removed">2633         n-&gt;dump();</span>
<span class="line-removed">2634       }</span>
<span class="line-removed">2635 </span>
<span class="line-removed">2636       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-removed">2637           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-removed">2638           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">2639           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-removed">2640           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-removed">2641           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-removed">2642           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-removed">2643           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-removed">2644           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-removed">2645           ) {</span>
<span class="line-removed">2646         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2647           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2648           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2649         } else {</span>
<span class="line-removed">2650           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">2651         }</span>
<span class="line-removed">2652         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">2653         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2654         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2655         n-&gt;format(_regalloc, st);</span>
<span class="line-removed">2656         st-&gt;cr();</span>
<span class="line-removed">2657       }</span>
<span class="line-removed">2658 </span>
<span class="line-removed">2659       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-removed">2660       // then back up and print it</span>
<span class="line-removed">2661       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-removed">2662         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-removed">2663         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-removed">2664         if (WizardMode) delay-&gt;dump();</span>
<span class="line-removed">2665 </span>
<span class="line-removed">2666         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-removed">2667           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">2668         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2669           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2670           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2671         } else {</span>
<span class="line-removed">2672           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">2673         }</span>
<span class="line-removed">2674         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">2675         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2676         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2677         delay-&gt;format(_regalloc, st);</span>
<span class="line-removed">2678         st-&gt;cr();</span>
<span class="line-removed">2679         delay = NULL;</span>
<span class="line-removed">2680       }</span>
<span class="line-removed">2681 </span>
<span class="line-removed">2682       // Dump the exception table as well</span>
<span class="line-removed">2683       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-removed">2684         // Print the exception table for this offset</span>
<span class="line-removed">2685         _handler_table.print_subtable_for(pc);</span>
<span class="line-removed">2686       }</span>
<span class="line-removed">2687       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-removed">2688     }</span>
<span class="line-removed">2689     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-removed">2690     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-removed">2691   } // End of per-block dump</span>
<span class="line-removed">2692 </span>
<span class="line-removed">2693   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-removed">2694 }</span>
<span class="line-removed">2695 #endif</span>
<span class="line-removed">2696 </span>
2697 //------------------------------Final_Reshape_Counts---------------------------
2698 // This class defines counters to help identify when a method
2699 // may/must be executed using hardware with only 24-bit precision.
2700 struct Final_Reshape_Counts : public StackObj {
2701   int  _call_count;             // count non-inlined &#39;common&#39; calls
2702   int  _float_count;            // count float ops requiring 24-bit precision
2703   int  _double_count;           // count double ops requiring more precision
2704   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
2705   int  _inner_loop_count;       // count loops which need alignment
2706   VectorSet _visited;           // Visitation flags
2707   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
2708 
2709   Final_Reshape_Counts() :
2710     _call_count(0), _float_count(0), _double_count(0),
2711     _java_call_count(0), _inner_loop_count(0),
2712     _visited( Thread::current()-&gt;resource_area() ) { }
2713 
2714   void inc_call_count  () { _call_count  ++; }
2715   void inc_float_count () { _float_count ++; }
2716   void inc_double_count() { _double_count++; }
2717   void inc_java_call_count() { _java_call_count++; }
2718   void inc_inner_loop_count() { _inner_loop_count++; }
2719 
2720   int  get_call_count  () const { return _call_count  ; }
2721   int  get_float_count () const { return _float_count ; }
2722   int  get_double_count() const { return _double_count; }
2723   int  get_java_call_count() const { return _java_call_count; }
2724   int  get_inner_loop_count() const { return _inner_loop_count; }
2725 };
2726 
2727 #ifdef ASSERT
2728 static bool oop_offset_is_sane(const TypeInstPtr* tp) {
2729   ciInstanceKlass *k = tp-&gt;klass()-&gt;as_instance_klass();
2730   // Make sure the offset goes inside the instance layout.
2731   return k-&gt;contains_field_offset(tp-&gt;offset());
2732   // Note that OffsetBot and OffsetTop are very negative.
2733 }
2734 #endif
2735 
2736 // Eliminate trivially redundant StoreCMs and accumulate their
2737 // precedence edges.
2738 void Compile::eliminate_redundant_card_marks(Node* n) {
2739   assert(n-&gt;Opcode() == Op_StoreCM, &quot;expected StoreCM&quot;);
2740   if (n-&gt;in(MemNode::Address)-&gt;outcnt() &gt; 1) {
2741     // There are multiple users of the same address so it might be
2742     // possible to eliminate some of the StoreCMs
2743     Node* mem = n-&gt;in(MemNode::Memory);
2744     Node* adr = n-&gt;in(MemNode::Address);
2745     Node* val = n-&gt;in(MemNode::ValueIn);
2746     Node* prev = n;
2747     bool done = false;
2748     // Walk the chain of StoreCMs eliminating ones that match.  As
2749     // long as it&#39;s a chain of single users then the optimization is
2750     // safe.  Eliminating partially redundant StoreCMs would require
2751     // cloning copies down the other paths.
2752     while (mem-&gt;Opcode() == Op_StoreCM &amp;&amp; mem-&gt;outcnt() == 1 &amp;&amp; !done) {
2753       if (adr == mem-&gt;in(MemNode::Address) &amp;&amp;
2754           val == mem-&gt;in(MemNode::ValueIn)) {
2755         // redundant StoreCM
2756         if (mem-&gt;req() &gt; MemNode::OopStore) {
2757           // Hasn&#39;t been processed by this code yet.
2758           n-&gt;add_prec(mem-&gt;in(MemNode::OopStore));
2759         } else {
2760           // Already converted to precedence edge
2761           for (uint i = mem-&gt;req(); i &lt; mem-&gt;len(); i++) {
2762             // Accumulate any precedence edges
2763             if (mem-&gt;in(i) != NULL) {
2764               n-&gt;add_prec(mem-&gt;in(i));
2765             }
2766           }
2767           // Everything above this point has been processed.
2768           done = true;
2769         }
2770         // Eliminate the previous StoreCM
2771         prev-&gt;set_req(MemNode::Memory, mem-&gt;in(MemNode::Memory));
2772         assert(mem-&gt;outcnt() == 0, &quot;should be dead&quot;);
2773         mem-&gt;disconnect_inputs(NULL, this);
2774       } else {
2775         prev = mem;
2776       }
2777       mem = prev-&gt;in(MemNode::Memory);
2778     }
2779   }
2780 }
2781 
2782 //------------------------------final_graph_reshaping_impl----------------------
2783 // Implement items 1-5 from final_graph_reshaping below.
2784 void Compile::final_graph_reshaping_impl( Node *n, Final_Reshape_Counts &amp;frc) {
2785 
2786   if ( n-&gt;outcnt() == 0 ) return; // dead node
2787   uint nop = n-&gt;Opcode();
2788 
2789   // Check for 2-input instruction with &quot;last use&quot; on right input.
2790   // Swap to left input.  Implements item (2).
2791   if( n-&gt;req() == 3 &amp;&amp;          // two-input instruction
2792       n-&gt;in(1)-&gt;outcnt() &gt; 1 &amp;&amp; // left use is NOT a last use
2793       (!n-&gt;in(1)-&gt;is_Phi() || n-&gt;in(1)-&gt;in(2) != n) &amp;&amp; // it is not data loop
2794       n-&gt;in(2)-&gt;outcnt() == 1 &amp;&amp;// right use IS a last use
2795       !n-&gt;in(2)-&gt;is_Con() ) {   // right use is not a constant
2796     // Check for commutative opcode
2797     switch( nop ) {
2798     case Op_AddI:  case Op_AddF:  case Op_AddD:  case Op_AddL:
2799     case Op_MaxI:  case Op_MinI:
2800     case Op_MulI:  case Op_MulF:  case Op_MulD:  case Op_MulL:
2801     case Op_AndL:  case Op_XorL:  case Op_OrL:
2802     case Op_AndI:  case Op_XorI:  case Op_OrI: {
2803       // Move &quot;last use&quot; input to left by swapping inputs
2804       n-&gt;swap_edges(1, 2);
2805       break;
2806     }
2807     default:
2808       break;
2809     }
2810   }
2811 
2812 #ifdef ASSERT
2813   if( n-&gt;is_Mem() ) {
2814     int alias_idx = get_alias_index(n-&gt;as_Mem()-&gt;adr_type());
2815     assert( n-&gt;in(0) != NULL || alias_idx != Compile::AliasIdxRaw ||
2816             // oop will be recorded in oop map if load crosses safepoint
2817             n-&gt;is_Load() &amp;&amp; (n-&gt;as_Load()-&gt;bottom_type()-&gt;isa_oopptr() ||
2818                              LoadNode::is_immutable_value(n-&gt;in(MemNode::Address))),
2819             &quot;raw memory operations should have control edge&quot;);
2820   }
2821   if (n-&gt;is_MemBar()) {
2822     MemBarNode* mb = n-&gt;as_MemBar();
2823     if (mb-&gt;trailing_store() || mb-&gt;trailing_load_store()) {
2824       assert(mb-&gt;leading_membar()-&gt;trailing_membar() == mb, &quot;bad membar pair&quot;);
2825       Node* mem = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;step_over_gc_barrier(mb-&gt;in(MemBarNode::Precedent));
2826       assert((mb-&gt;trailing_store() &amp;&amp; mem-&gt;is_Store() &amp;&amp; mem-&gt;as_Store()-&gt;is_release()) ||
2827              (mb-&gt;trailing_load_store() &amp;&amp; mem-&gt;is_LoadStore()), &quot;missing mem op&quot;);
2828     } else if (mb-&gt;leading()) {
2829       assert(mb-&gt;trailing_membar()-&gt;leading_membar() == mb, &quot;bad membar pair&quot;);
2830     }
2831   }
2832 #endif
2833   // Count FPU ops and common calls, implements item (3)
2834   bool gc_handled = BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;final_graph_reshaping(this, n, nop);
2835   if (!gc_handled) {
2836     final_graph_reshaping_main_switch(n, frc, nop);
2837   }
2838 
2839   // Collect CFG split points
2840   if (n-&gt;is_MultiBranch() &amp;&amp; !n-&gt;is_RangeCheck()) {
2841     frc._tests.push(n);
2842   }
2843 }
2844 
2845 void Compile::final_graph_reshaping_main_switch(Node* n, Final_Reshape_Counts&amp; frc, uint nop) {
2846   switch( nop ) {
2847   // Count all float operations that may use FPU
2848   case Op_AddF:
2849   case Op_SubF:
2850   case Op_MulF:
2851   case Op_DivF:
2852   case Op_NegF:
2853   case Op_ModF:
2854   case Op_ConvI2F:
2855   case Op_ConF:
2856   case Op_CmpF:
2857   case Op_CmpF3:
2858   // case Op_ConvL2F: // longs are split into 32-bit halves
2859     frc.inc_float_count();
2860     break;
2861 
2862   case Op_ConvF2D:
2863   case Op_ConvD2F:
2864     frc.inc_float_count();
2865     frc.inc_double_count();
2866     break;
2867 
2868   // Count all double operations that may use FPU
2869   case Op_AddD:
2870   case Op_SubD:
2871   case Op_MulD:
2872   case Op_DivD:
2873   case Op_NegD:
2874   case Op_ModD:
2875   case Op_ConvI2D:
2876   case Op_ConvD2I:
2877   // case Op_ConvL2D: // handled by leaf call
2878   // case Op_ConvD2L: // handled by leaf call
2879   case Op_ConD:
2880   case Op_CmpD:
2881   case Op_CmpD3:
2882     frc.inc_double_count();
2883     break;
2884   case Op_Opaque1:              // Remove Opaque Nodes before matching
2885   case Op_Opaque2:              // Remove Opaque Nodes before matching
2886   case Op_Opaque3:
2887     n-&gt;subsume_by(n-&gt;in(1), this);
2888     break;
2889   case Op_CallStaticJava:
2890   case Op_CallJava:
2891   case Op_CallDynamicJava:
2892     frc.inc_java_call_count(); // Count java call site;
2893   case Op_CallRuntime:
2894   case Op_CallLeaf:
2895   case Op_CallLeafNoFP: {
2896     assert (n-&gt;is_Call(), &quot;&quot;);
2897     CallNode *call = n-&gt;as_Call();
2898     // Count call sites where the FP mode bit would have to be flipped.
2899     // Do not count uncommon runtime calls:
2900     // uncommon_trap, _complete_monitor_locking, _complete_monitor_unlocking,
2901     // _new_Java, _new_typeArray, _new_objArray, _rethrow_Java, ...
2902     if (!call-&gt;is_CallStaticJava() || !call-&gt;as_CallStaticJava()-&gt;_name) {
2903       frc.inc_call_count();   // Count the call site
2904     } else {                  // See if uncommon argument is shared
2905       Node *n = call-&gt;in(TypeFunc::Parms);
2906       int nop = n-&gt;Opcode();
2907       // Clone shared simple arguments to uncommon calls, item (1).
2908       if (n-&gt;outcnt() &gt; 1 &amp;&amp;
2909           !n-&gt;is_Proj() &amp;&amp;
2910           nop != Op_CreateEx &amp;&amp;
2911           nop != Op_CheckCastPP &amp;&amp;
2912           nop != Op_DecodeN &amp;&amp;
2913           nop != Op_DecodeNKlass &amp;&amp;
2914           !n-&gt;is_Mem() &amp;&amp;
2915           !n-&gt;is_Phi()) {
2916         Node *x = n-&gt;clone();
2917         call-&gt;set_req(TypeFunc::Parms, x);
2918       }
2919     }
2920     break;
2921   }
2922 
2923   case Op_StoreD:
2924   case Op_LoadD:
2925   case Op_LoadD_unaligned:
2926     frc.inc_double_count();
2927     goto handle_mem;
2928   case Op_StoreF:
2929   case Op_LoadF:
2930     frc.inc_float_count();
2931     goto handle_mem;
2932 
2933   case Op_StoreCM:
2934     {
2935       // Convert OopStore dependence into precedence edge
2936       Node* prec = n-&gt;in(MemNode::OopStore);
2937       n-&gt;del_req(MemNode::OopStore);
2938       n-&gt;add_prec(prec);
2939       eliminate_redundant_card_marks(n);
2940     }
2941 
2942     // fall through
2943 
2944   case Op_StoreB:
2945   case Op_StoreC:
2946   case Op_StorePConditional:
2947   case Op_StoreI:
2948   case Op_StoreL:
2949   case Op_StoreIConditional:
2950   case Op_StoreLConditional:
2951   case Op_CompareAndSwapB:
2952   case Op_CompareAndSwapS:
2953   case Op_CompareAndSwapI:
2954   case Op_CompareAndSwapL:
2955   case Op_CompareAndSwapP:
2956   case Op_CompareAndSwapN:
2957   case Op_WeakCompareAndSwapB:
2958   case Op_WeakCompareAndSwapS:
2959   case Op_WeakCompareAndSwapI:
2960   case Op_WeakCompareAndSwapL:
2961   case Op_WeakCompareAndSwapP:
2962   case Op_WeakCompareAndSwapN:
2963   case Op_CompareAndExchangeB:
2964   case Op_CompareAndExchangeS:
2965   case Op_CompareAndExchangeI:
2966   case Op_CompareAndExchangeL:
2967   case Op_CompareAndExchangeP:
2968   case Op_CompareAndExchangeN:
2969   case Op_GetAndAddS:
2970   case Op_GetAndAddB:
2971   case Op_GetAndAddI:
2972   case Op_GetAndAddL:
2973   case Op_GetAndSetS:
2974   case Op_GetAndSetB:
2975   case Op_GetAndSetI:
2976   case Op_GetAndSetL:
2977   case Op_GetAndSetP:
2978   case Op_GetAndSetN:
2979   case Op_StoreP:
2980   case Op_StoreN:
2981   case Op_StoreNKlass:
2982   case Op_LoadB:
2983   case Op_LoadUB:
2984   case Op_LoadUS:
2985   case Op_LoadI:
2986   case Op_LoadKlass:
2987   case Op_LoadNKlass:
2988   case Op_LoadL:
2989   case Op_LoadL_unaligned:
2990   case Op_LoadPLocked:
2991   case Op_LoadP:
2992   case Op_LoadN:
2993   case Op_LoadRange:
2994   case Op_LoadS: {
2995   handle_mem:
2996 #ifdef ASSERT
2997     if( VerifyOptoOopOffsets ) {
2998       MemNode* mem  = n-&gt;as_Mem();
2999       // Check to see if address types have grounded out somehow.
3000       const TypeInstPtr *tp = mem-&gt;in(MemNode::Address)-&gt;bottom_type()-&gt;isa_instptr();
3001       assert( !tp || oop_offset_is_sane(tp), &quot;&quot; );
3002     }
3003 #endif
3004     break;
3005   }
3006 
3007   case Op_AddP: {               // Assert sane base pointers
3008     Node *addp = n-&gt;in(AddPNode::Address);
3009     assert( !addp-&gt;is_AddP() ||
3010             addp-&gt;in(AddPNode::Base)-&gt;is_top() || // Top OK for allocation
3011             addp-&gt;in(AddPNode::Base) == n-&gt;in(AddPNode::Base),
3012             &quot;Base pointers must match (addp %u)&quot;, addp-&gt;_idx );
3013 #ifdef _LP64
3014     if ((UseCompressedOops || UseCompressedClassPointers) &amp;&amp;
3015         addp-&gt;Opcode() == Op_ConP &amp;&amp;
3016         addp == n-&gt;in(AddPNode::Base) &amp;&amp;
3017         n-&gt;in(AddPNode::Offset)-&gt;is_Con()) {
3018       // If the transformation of ConP to ConN+DecodeN is beneficial depends
3019       // on the platform and on the compressed oops mode.
3020       // Use addressing with narrow klass to load with offset on x86.
3021       // Some platforms can use the constant pool to load ConP.
3022       // Do this transformation here since IGVN will convert ConN back to ConP.
3023       const Type* t = addp-&gt;bottom_type();
3024       bool is_oop   = t-&gt;isa_oopptr() != NULL;
3025       bool is_klass = t-&gt;isa_klassptr() != NULL;
3026 
3027       if ((is_oop   &amp;&amp; Matcher::const_oop_prefer_decode()  ) ||
3028           (is_klass &amp;&amp; Matcher::const_klass_prefer_decode())) {
3029         Node* nn = NULL;
3030 
3031         int op = is_oop ? Op_ConN : Op_ConNKlass;
3032 
3033         // Look for existing ConN node of the same exact type.
3034         Node* r  = root();
3035         uint cnt = r-&gt;outcnt();
3036         for (uint i = 0; i &lt; cnt; i++) {
3037           Node* m = r-&gt;raw_out(i);
3038           if (m!= NULL &amp;&amp; m-&gt;Opcode() == op &amp;&amp;
3039               m-&gt;bottom_type()-&gt;make_ptr() == t) {
3040             nn = m;
3041             break;
3042           }
3043         }
3044         if (nn != NULL) {
3045           // Decode a narrow oop to match address
3046           // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3047           if (is_oop) {
3048             nn = new DecodeNNode(nn, t);
3049           } else {
3050             nn = new DecodeNKlassNode(nn, t);
3051           }
3052           // Check for succeeding AddP which uses the same Base.
3053           // Otherwise we will run into the assertion above when visiting that guy.
3054           for (uint i = 0; i &lt; n-&gt;outcnt(); ++i) {
3055             Node *out_i = n-&gt;raw_out(i);
3056             if (out_i &amp;&amp; out_i-&gt;is_AddP() &amp;&amp; out_i-&gt;in(AddPNode::Base) == addp) {
3057               out_i-&gt;set_req(AddPNode::Base, nn);
3058 #ifdef ASSERT
3059               for (uint j = 0; j &lt; out_i-&gt;outcnt(); ++j) {
3060                 Node *out_j = out_i-&gt;raw_out(j);
3061                 assert(out_j == NULL || !out_j-&gt;is_AddP() || out_j-&gt;in(AddPNode::Base) != addp,
3062                        &quot;more than 2 AddP nodes in a chain (out_j %u)&quot;, out_j-&gt;_idx);
3063               }
3064 #endif
3065             }
3066           }
3067           n-&gt;set_req(AddPNode::Base, nn);
3068           n-&gt;set_req(AddPNode::Address, nn);
3069           if (addp-&gt;outcnt() == 0) {
3070             addp-&gt;disconnect_inputs(NULL, this);
3071           }
3072         }
3073       }
3074     }
3075 #endif
3076     // platform dependent reshaping of the address expression
3077     reshape_address(n-&gt;as_AddP());
3078     break;
3079   }
3080 
3081   case Op_CastPP: {
3082     // Remove CastPP nodes to gain more freedom during scheduling but
3083     // keep the dependency they encode as control or precedence edges
3084     // (if control is set already) on memory operations. Some CastPP
3085     // nodes don&#39;t have a control (don&#39;t carry a dependency): skip
3086     // those.
3087     if (n-&gt;in(0) != NULL) {
3088       ResourceMark rm;
3089       Unique_Node_List wq;
3090       wq.push(n);
3091       for (uint next = 0; next &lt; wq.size(); ++next) {
3092         Node *m = wq.at(next);
3093         for (DUIterator_Fast imax, i = m-&gt;fast_outs(imax); i &lt; imax; i++) {
3094           Node* use = m-&gt;fast_out(i);
3095           if (use-&gt;is_Mem() || use-&gt;is_EncodeNarrowPtr()) {
3096             use-&gt;ensure_control_or_add_prec(n-&gt;in(0));
3097           } else {
3098             switch(use-&gt;Opcode()) {
3099             case Op_AddP:
3100             case Op_DecodeN:
3101             case Op_DecodeNKlass:
3102             case Op_CheckCastPP:
3103             case Op_CastPP:
3104               wq.push(use);
3105               break;
3106             }
3107           }
3108         }
3109       }
3110     }
3111     const bool is_LP64 = LP64_ONLY(true) NOT_LP64(false);
3112     if (is_LP64 &amp;&amp; n-&gt;in(1)-&gt;is_DecodeN() &amp;&amp; Matcher::gen_narrow_oop_implicit_null_checks()) {
3113       Node* in1 = n-&gt;in(1);
3114       const Type* t = n-&gt;bottom_type();
3115       Node* new_in1 = in1-&gt;clone();
3116       new_in1-&gt;as_DecodeN()-&gt;set_type(t);
3117 
3118       if (!Matcher::narrow_oop_use_complex_address()) {
3119         //
3120         // x86, ARM and friends can handle 2 adds in addressing mode
3121         // and Matcher can fold a DecodeN node into address by using
3122         // a narrow oop directly and do implicit NULL check in address:
3123         //
3124         // [R12 + narrow_oop_reg&lt;&lt;3 + offset]
3125         // NullCheck narrow_oop_reg
3126         //
3127         // On other platforms (Sparc) we have to keep new DecodeN node and
3128         // use it to do implicit NULL check in address:
3129         //
3130         // decode_not_null narrow_oop_reg, base_reg
3131         // [base_reg + offset]
3132         // NullCheck base_reg
3133         //
3134         // Pin the new DecodeN node to non-null path on these platform (Sparc)
3135         // to keep the information to which NULL check the new DecodeN node
3136         // corresponds to use it as value in implicit_null_check().
3137         //
3138         new_in1-&gt;set_req(0, n-&gt;in(0));
3139       }
3140 
3141       n-&gt;subsume_by(new_in1, this);
3142       if (in1-&gt;outcnt() == 0) {
3143         in1-&gt;disconnect_inputs(NULL, this);
3144       }
3145     } else {
3146       n-&gt;subsume_by(n-&gt;in(1), this);
3147       if (n-&gt;outcnt() == 0) {
3148         n-&gt;disconnect_inputs(NULL, this);
3149       }
3150     }
3151     break;
3152   }
3153 #ifdef _LP64
3154   case Op_CmpP:
3155     // Do this transformation here to preserve CmpPNode::sub() and
3156     // other TypePtr related Ideal optimizations (for example, ptr nullness).
3157     if (n-&gt;in(1)-&gt;is_DecodeNarrowPtr() || n-&gt;in(2)-&gt;is_DecodeNarrowPtr()) {
3158       Node* in1 = n-&gt;in(1);
3159       Node* in2 = n-&gt;in(2);
3160       if (!in1-&gt;is_DecodeNarrowPtr()) {
3161         in2 = in1;
3162         in1 = n-&gt;in(2);
3163       }
3164       assert(in1-&gt;is_DecodeNarrowPtr(), &quot;sanity&quot;);
3165 
3166       Node* new_in2 = NULL;
3167       if (in2-&gt;is_DecodeNarrowPtr()) {
3168         assert(in2-&gt;Opcode() == in1-&gt;Opcode(), &quot;must be same node type&quot;);
3169         new_in2 = in2-&gt;in(1);
3170       } else if (in2-&gt;Opcode() == Op_ConP) {
3171         const Type* t = in2-&gt;bottom_type();
3172         if (t == TypePtr::NULL_PTR) {
3173           assert(in1-&gt;is_DecodeN(), &quot;compare klass to null?&quot;);
3174           // Don&#39;t convert CmpP null check into CmpN if compressed
3175           // oops implicit null check is not generated.
3176           // This will allow to generate normal oop implicit null check.
3177           if (Matcher::gen_narrow_oop_implicit_null_checks())
3178             new_in2 = ConNode::make(TypeNarrowOop::NULL_PTR);
3179           //
3180           // This transformation together with CastPP transformation above
3181           // will generated code for implicit NULL checks for compressed oops.
3182           //
3183           // The original code after Optimize()
3184           //
3185           //    LoadN memory, narrow_oop_reg
3186           //    decode narrow_oop_reg, base_reg
3187           //    CmpP base_reg, NULL
3188           //    CastPP base_reg // NotNull
3189           //    Load [base_reg + offset], val_reg
3190           //
3191           // after these transformations will be
3192           //
3193           //    LoadN memory, narrow_oop_reg
3194           //    CmpN narrow_oop_reg, NULL
3195           //    decode_not_null narrow_oop_reg, base_reg
3196           //    Load [base_reg + offset], val_reg
3197           //
3198           // and the uncommon path (== NULL) will use narrow_oop_reg directly
3199           // since narrow oops can be used in debug info now (see the code in
3200           // final_graph_reshaping_walk()).
3201           //
3202           // At the end the code will be matched to
3203           // on x86:
3204           //
3205           //    Load_narrow_oop memory, narrow_oop_reg
3206           //    Load [R12 + narrow_oop_reg&lt;&lt;3 + offset], val_reg
3207           //    NullCheck narrow_oop_reg
3208           //
3209           // and on sparc:
3210           //
3211           //    Load_narrow_oop memory, narrow_oop_reg
3212           //    decode_not_null narrow_oop_reg, base_reg
3213           //    Load [base_reg + offset], val_reg
3214           //    NullCheck base_reg
3215           //
3216         } else if (t-&gt;isa_oopptr()) {
3217           new_in2 = ConNode::make(t-&gt;make_narrowoop());
3218         } else if (t-&gt;isa_klassptr()) {
3219           new_in2 = ConNode::make(t-&gt;make_narrowklass());
3220         }
3221       }
3222       if (new_in2 != NULL) {
3223         Node* cmpN = new CmpNNode(in1-&gt;in(1), new_in2);
3224         n-&gt;subsume_by(cmpN, this);
3225         if (in1-&gt;outcnt() == 0) {
3226           in1-&gt;disconnect_inputs(NULL, this);
3227         }
3228         if (in2-&gt;outcnt() == 0) {
3229           in2-&gt;disconnect_inputs(NULL, this);
3230         }
3231       }
3232     }
3233     break;
3234 
3235   case Op_DecodeN:
3236   case Op_DecodeNKlass:
3237     assert(!n-&gt;in(1)-&gt;is_EncodeNarrowPtr(), &quot;should be optimized out&quot;);
3238     // DecodeN could be pinned when it can&#39;t be fold into
3239     // an address expression, see the code for Op_CastPP above.
3240     assert(n-&gt;in(0) == NULL || (UseCompressedOops &amp;&amp; !Matcher::narrow_oop_use_complex_address()), &quot;no control&quot;);
3241     break;
3242 
3243   case Op_EncodeP:
3244   case Op_EncodePKlass: {
3245     Node* in1 = n-&gt;in(1);
3246     if (in1-&gt;is_DecodeNarrowPtr()) {
3247       n-&gt;subsume_by(in1-&gt;in(1), this);
3248     } else if (in1-&gt;Opcode() == Op_ConP) {
3249       const Type* t = in1-&gt;bottom_type();
3250       if (t == TypePtr::NULL_PTR) {
3251         assert(t-&gt;isa_oopptr(), &quot;null klass?&quot;);
3252         n-&gt;subsume_by(ConNode::make(TypeNarrowOop::NULL_PTR), this);
3253       } else if (t-&gt;isa_oopptr()) {
3254         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowoop()), this);
3255       } else if (t-&gt;isa_klassptr()) {
3256         n-&gt;subsume_by(ConNode::make(t-&gt;make_narrowklass()), this);
3257       }
3258     }
3259     if (in1-&gt;outcnt() == 0) {
3260       in1-&gt;disconnect_inputs(NULL, this);
3261     }
3262     break;
3263   }
3264 
3265   case Op_Proj: {
3266     if (OptimizeStringConcat) {
3267       ProjNode* p = n-&gt;as_Proj();
3268       if (p-&gt;_is_io_use) {
3269         // Separate projections were used for the exception path which
3270         // are normally removed by a late inline.  If it wasn&#39;t inlined
3271         // then they will hang around and should just be replaced with
3272         // the original one.
3273         Node* proj = NULL;
3274         // Replace with just one
3275         for (SimpleDUIterator i(p-&gt;in(0)); i.has_next(); i.next()) {
3276           Node *use = i.get();
3277           if (use-&gt;is_Proj() &amp;&amp; p != use &amp;&amp; use-&gt;as_Proj()-&gt;_con == p-&gt;_con) {
3278             proj = use;
3279             break;
3280           }
3281         }
3282         assert(proj != NULL || p-&gt;_con == TypeFunc::I_O, &quot;io may be dropped at an infinite loop&quot;);
3283         if (proj != NULL) {
3284           p-&gt;subsume_by(proj, this);
3285         }
3286       }
3287     }
3288     break;
3289   }
3290 
3291   case Op_Phi:
3292     if (n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowoop() || n-&gt;as_Phi()-&gt;bottom_type()-&gt;isa_narrowklass()) {
3293       // The EncodeP optimization may create Phi with the same edges
3294       // for all paths. It is not handled well by Register Allocator.
3295       Node* unique_in = n-&gt;in(1);
3296       assert(unique_in != NULL, &quot;&quot;);
3297       uint cnt = n-&gt;req();
3298       for (uint i = 2; i &lt; cnt; i++) {
3299         Node* m = n-&gt;in(i);
3300         assert(m != NULL, &quot;&quot;);
3301         if (unique_in != m)
3302           unique_in = NULL;
3303       }
3304       if (unique_in != NULL) {
3305         n-&gt;subsume_by(unique_in, this);
3306       }
3307     }
3308     break;
3309 
3310 #endif
3311 
3312 #ifdef ASSERT
3313   case Op_CastII:
3314     // Verify that all range check dependent CastII nodes were removed.
3315     if (n-&gt;isa_CastII()-&gt;has_range_check()) {
3316       n-&gt;dump(3);
3317       assert(false, &quot;Range check dependent CastII node was not removed&quot;);
3318     }
3319     break;
3320 #endif
3321 
3322   case Op_ModI:
3323     if (UseDivMod) {
3324       // Check if a%b and a/b both exist
3325       Node* d = n-&gt;find_similar(Op_DivI);
3326       if (d) {
3327         // Replace them with a fused divmod if supported
3328         if (Matcher::has_match_rule(Op_DivModI)) {
3329           DivModINode* divmod = DivModINode::make(n);
3330           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3331           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3332         } else {
3333           // replace a%b with a-((a/b)*b)
3334           Node* mult = new MulINode(d, d-&gt;in(2));
3335           Node* sub  = new SubINode(d-&gt;in(1), mult);
3336           n-&gt;subsume_by(sub, this);
3337         }
3338       }
3339     }
3340     break;
3341 
3342   case Op_ModL:
3343     if (UseDivMod) {
3344       // Check if a%b and a/b both exist
3345       Node* d = n-&gt;find_similar(Op_DivL);
3346       if (d) {
3347         // Replace them with a fused divmod if supported
3348         if (Matcher::has_match_rule(Op_DivModL)) {
3349           DivModLNode* divmod = DivModLNode::make(n);
3350           d-&gt;subsume_by(divmod-&gt;div_proj(), this);
3351           n-&gt;subsume_by(divmod-&gt;mod_proj(), this);
3352         } else {
3353           // replace a%b with a-((a/b)*b)
3354           Node* mult = new MulLNode(d, d-&gt;in(2));
3355           Node* sub  = new SubLNode(d-&gt;in(1), mult);
3356           n-&gt;subsume_by(sub, this);
3357         }
3358       }
3359     }
3360     break;
3361 
3362   case Op_LoadVector:
3363   case Op_StoreVector:
3364     break;
3365 
3366   case Op_AddReductionVI:
3367   case Op_AddReductionVL:
3368   case Op_AddReductionVF:
3369   case Op_AddReductionVD:
3370   case Op_MulReductionVI:
3371   case Op_MulReductionVL:
3372   case Op_MulReductionVF:
3373   case Op_MulReductionVD:
3374   case Op_MinReductionV:
3375   case Op_MaxReductionV:
<a name="22" id="anc22"></a>


3376     break;
3377 
3378   case Op_PackB:
3379   case Op_PackS:
3380   case Op_PackI:
3381   case Op_PackF:
3382   case Op_PackL:
3383   case Op_PackD:
3384     if (n-&gt;req()-1 &gt; 2) {
3385       // Replace many operand PackNodes with a binary tree for matching
3386       PackNode* p = (PackNode*) n;
3387       Node* btp = p-&gt;binary_tree_pack(1, n-&gt;req());
3388       n-&gt;subsume_by(btp, this);
3389     }
3390     break;
3391   case Op_Loop:
3392   case Op_CountedLoop:
3393   case Op_OuterStripMinedLoop:
3394     if (n-&gt;as_Loop()-&gt;is_inner_loop()) {
3395       frc.inc_inner_loop_count();
3396     }
3397     n-&gt;as_Loop()-&gt;verify_strip_mined(0);
3398     break;
3399   case Op_LShiftI:
3400   case Op_RShiftI:
3401   case Op_URShiftI:
3402   case Op_LShiftL:
3403   case Op_RShiftL:
3404   case Op_URShiftL:
3405     if (Matcher::need_masked_shift_count) {
3406       // The cpu&#39;s shift instructions don&#39;t restrict the count to the
3407       // lower 5/6 bits. We need to do the masking ourselves.
3408       Node* in2 = n-&gt;in(2);
3409       juint mask = (n-&gt;bottom_type() == TypeInt::INT) ? (BitsPerInt - 1) : (BitsPerLong - 1);
3410       const TypeInt* t = in2-&gt;find_int_type();
3411       if (t != NULL &amp;&amp; t-&gt;is_con()) {
3412         juint shift = t-&gt;get_con();
3413         if (shift &gt; mask) { // Unsigned cmp
3414           n-&gt;set_req(2, ConNode::make(TypeInt::make(shift &amp; mask)));
3415         }
3416       } else {
3417         if (t == NULL || t-&gt;_lo &lt; 0 || t-&gt;_hi &gt; (int)mask) {
3418           Node* shift = new AndINode(in2, ConNode::make(TypeInt::make(mask)));
3419           n-&gt;set_req(2, shift);
3420         }
3421       }
3422       if (in2-&gt;outcnt() == 0) { // Remove dead node
3423         in2-&gt;disconnect_inputs(NULL, this);
3424       }
3425     }
3426     break;
3427   case Op_MemBarStoreStore:
3428   case Op_MemBarRelease:
3429     // Break the link with AllocateNode: it is no longer useful and
3430     // confuses register allocation.
3431     if (n-&gt;req() &gt; MemBarNode::Precedent) {
3432       n-&gt;set_req(MemBarNode::Precedent, top());
3433     }
3434     break;
3435   case Op_MemBarAcquire: {
3436     if (n-&gt;as_MemBar()-&gt;trailing_load() &amp;&amp; n-&gt;req() &gt; MemBarNode::Precedent) {
3437       // At parse time, the trailing MemBarAcquire for a volatile load
3438       // is created with an edge to the load. After optimizations,
3439       // that input may be a chain of Phis. If those phis have no
3440       // other use, then the MemBarAcquire keeps them alive and
3441       // register allocation can be confused.
3442       ResourceMark rm;
3443       Unique_Node_List wq;
3444       wq.push(n-&gt;in(MemBarNode::Precedent));
3445       n-&gt;set_req(MemBarNode::Precedent, top());
3446       while (wq.size() &gt; 0) {
3447         Node* m = wq.pop();
3448         if (m-&gt;outcnt() == 0) {
3449           for (uint j = 0; j &lt; m-&gt;req(); j++) {
3450             Node* in = m-&gt;in(j);
3451             if (in != NULL) {
3452               wq.push(in);
3453             }
3454           }
3455           m-&gt;disconnect_inputs(NULL, this);
3456         }
3457       }
3458     }
3459     break;
3460   }
3461   case Op_RangeCheck: {
3462     RangeCheckNode* rc = n-&gt;as_RangeCheck();
3463     Node* iff = new IfNode(rc-&gt;in(0), rc-&gt;in(1), rc-&gt;_prob, rc-&gt;_fcnt);
3464     n-&gt;subsume_by(iff, this);
3465     frc._tests.push(iff);
3466     break;
3467   }
3468   case Op_ConvI2L: {
3469     if (!Matcher::convi2l_type_required) {
3470       // Code generation on some platforms doesn&#39;t need accurate
3471       // ConvI2L types. Widening the type can help remove redundant
3472       // address computations.
3473       n-&gt;as_Type()-&gt;set_type(TypeLong::INT);
3474       ResourceMark rm;
3475       Unique_Node_List wq;
3476       wq.push(n);
3477       for (uint next = 0; next &lt; wq.size(); next++) {
3478         Node *m = wq.at(next);
3479 
3480         for(;;) {
3481           // Loop over all nodes with identical inputs edges as m
3482           Node* k = m-&gt;find_similar(m-&gt;Opcode());
3483           if (k == NULL) {
3484             break;
3485           }
3486           // Push their uses so we get a chance to remove node made
3487           // redundant
3488           for (DUIterator_Fast imax, i = k-&gt;fast_outs(imax); i &lt; imax; i++) {
3489             Node* u = k-&gt;fast_out(i);
3490             if (u-&gt;Opcode() == Op_LShiftL ||
3491                 u-&gt;Opcode() == Op_AddL ||
3492                 u-&gt;Opcode() == Op_SubL ||
3493                 u-&gt;Opcode() == Op_AddP) {
3494               wq.push(u);
3495             }
3496           }
3497           // Replace all nodes with identical edges as m with m
3498           k-&gt;subsume_by(m, this);
3499         }
3500       }
3501     }
3502     break;
3503   }
3504   case Op_CmpUL: {
3505     if (!Matcher::has_match_rule(Op_CmpUL)) {
3506       // No support for unsigned long comparisons
3507       ConINode* sign_pos = new ConINode(TypeInt::make(BitsPerLong - 1));
3508       Node* sign_bit_mask = new RShiftLNode(n-&gt;in(1), sign_pos);
3509       Node* orl = new OrLNode(n-&gt;in(1), sign_bit_mask);
3510       ConLNode* remove_sign_mask = new ConLNode(TypeLong::make(max_jlong));
3511       Node* andl = new AndLNode(orl, remove_sign_mask);
3512       Node* cmp = new CmpLNode(andl, n-&gt;in(2));
3513       n-&gt;subsume_by(cmp, this);
3514     }
3515     break;
3516   }
3517   default:
3518     assert(!n-&gt;is_Call(), &quot;&quot;);
3519     assert(!n-&gt;is_Mem(), &quot;&quot;);
3520     assert(nop != Op_ProfileBoolean, &quot;should be eliminated during IGVN&quot;);
3521     break;
3522   }
3523 }
3524 
3525 //------------------------------final_graph_reshaping_walk---------------------
3526 // Replacing Opaque nodes with their input in final_graph_reshaping_impl(),
3527 // requires that the walk visits a node&#39;s inputs before visiting the node.
3528 void Compile::final_graph_reshaping_walk( Node_Stack &amp;nstack, Node *root, Final_Reshape_Counts &amp;frc ) {
3529   ResourceArea *area = Thread::current()-&gt;resource_area();
3530   Unique_Node_List sfpt(area);
3531 
3532   frc._visited.set(root-&gt;_idx); // first, mark node as visited
3533   uint cnt = root-&gt;req();
3534   Node *n = root;
3535   uint  i = 0;
3536   while (true) {
3537     if (i &lt; cnt) {
3538       // Place all non-visited non-null inputs onto stack
3539       Node* m = n-&gt;in(i);
3540       ++i;
3541       if (m != NULL &amp;&amp; !frc._visited.test_set(m-&gt;_idx)) {
3542         if (m-&gt;is_SafePoint() &amp;&amp; m-&gt;as_SafePoint()-&gt;jvms() != NULL) {
3543           // compute worst case interpreter size in case of a deoptimization
3544           update_interpreter_frame_size(m-&gt;as_SafePoint()-&gt;jvms()-&gt;interpreter_frame_size());
3545 
3546           sfpt.push(m);
3547         }
3548         cnt = m-&gt;req();
3549         nstack.push(n, i); // put on stack parent and next input&#39;s index
3550         n = m;
3551         i = 0;
3552       }
3553     } else {
3554       // Now do post-visit work
3555       final_graph_reshaping_impl( n, frc );
3556       if (nstack.is_empty())
3557         break;             // finished
3558       n = nstack.node();   // Get node from stack
3559       cnt = n-&gt;req();
3560       i = nstack.index();
3561       nstack.pop();        // Shift to the next node on stack
3562     }
3563   }
3564 
3565   // Skip next transformation if compressed oops are not used.
3566   if ((UseCompressedOops &amp;&amp; !Matcher::gen_narrow_oop_implicit_null_checks()) ||
3567       (!UseCompressedOops &amp;&amp; !UseCompressedClassPointers))
3568     return;
3569 
3570   // Go over safepoints nodes to skip DecodeN/DecodeNKlass nodes for debug edges.
3571   // It could be done for an uncommon traps or any safepoints/calls
3572   // if the DecodeN/DecodeNKlass node is referenced only in a debug info.
3573   while (sfpt.size() &gt; 0) {
3574     n = sfpt.pop();
3575     JVMState *jvms = n-&gt;as_SafePoint()-&gt;jvms();
3576     assert(jvms != NULL, &quot;sanity&quot;);
3577     int start = jvms-&gt;debug_start();
3578     int end   = n-&gt;req();
3579     bool is_uncommon = (n-&gt;is_CallStaticJava() &amp;&amp;
3580                         n-&gt;as_CallStaticJava()-&gt;uncommon_trap_request() != 0);
3581     for (int j = start; j &lt; end; j++) {
3582       Node* in = n-&gt;in(j);
3583       if (in-&gt;is_DecodeNarrowPtr()) {
3584         bool safe_to_skip = true;
3585         if (!is_uncommon ) {
3586           // Is it safe to skip?
3587           for (uint i = 0; i &lt; in-&gt;outcnt(); i++) {
3588             Node* u = in-&gt;raw_out(i);
3589             if (!u-&gt;is_SafePoint() ||
3590                 (u-&gt;is_Call() &amp;&amp; u-&gt;as_Call()-&gt;has_non_debug_use(n))) {
3591               safe_to_skip = false;
3592             }
3593           }
3594         }
3595         if (safe_to_skip) {
3596           n-&gt;set_req(j, in-&gt;in(1));
3597         }
3598         if (in-&gt;outcnt() == 0) {
3599           in-&gt;disconnect_inputs(NULL, this);
3600         }
3601       }
3602     }
3603   }
3604 }
3605 
3606 //------------------------------final_graph_reshaping--------------------------
3607 // Final Graph Reshaping.
3608 //
3609 // (1) Clone simple inputs to uncommon calls, so they can be scheduled late
3610 //     and not commoned up and forced early.  Must come after regular
3611 //     optimizations to avoid GVN undoing the cloning.  Clone constant
3612 //     inputs to Loop Phis; these will be split by the allocator anyways.
3613 //     Remove Opaque nodes.
3614 // (2) Move last-uses by commutative operations to the left input to encourage
3615 //     Intel update-in-place two-address operations and better register usage
3616 //     on RISCs.  Must come after regular optimizations to avoid GVN Ideal
3617 //     calls canonicalizing them back.
3618 // (3) Count the number of double-precision FP ops, single-precision FP ops
3619 //     and call sites.  On Intel, we can get correct rounding either by
3620 //     forcing singles to memory (requires extra stores and loads after each
3621 //     FP bytecode) or we can set a rounding mode bit (requires setting and
3622 //     clearing the mode bit around call sites).  The mode bit is only used
3623 //     if the relative frequency of single FP ops to calls is low enough.
3624 //     This is a key transform for SPEC mpeg_audio.
3625 // (4) Detect infinite loops; blobs of code reachable from above but not
3626 //     below.  Several of the Code_Gen algorithms fail on such code shapes,
3627 //     so we simply bail out.  Happens a lot in ZKM.jar, but also happens
3628 //     from time to time in other codes (such as -Xcomp finalizer loops, etc).
3629 //     Detection is by looking for IfNodes where only 1 projection is
3630 //     reachable from below or CatchNodes missing some targets.
3631 // (5) Assert for insane oop offsets in debug mode.
3632 
3633 bool Compile::final_graph_reshaping() {
3634   // an infinite loop may have been eliminated by the optimizer,
3635   // in which case the graph will be empty.
3636   if (root()-&gt;req() == 1) {
3637     record_method_not_compilable(&quot;trivial infinite loop&quot;);
3638     return true;
3639   }
3640 
3641   // Expensive nodes have their control input set to prevent the GVN
3642   // from freely commoning them. There&#39;s no GVN beyond this point so
3643   // no need to keep the control input. We want the expensive nodes to
3644   // be freely moved to the least frequent code path by gcm.
3645   assert(OptimizeExpensiveOps || expensive_count() == 0, &quot;optimization off but list non empty?&quot;);
3646   for (int i = 0; i &lt; expensive_count(); i++) {
3647     _expensive_nodes-&gt;at(i)-&gt;set_req(0, NULL);
3648   }
3649 
3650   Final_Reshape_Counts frc;
3651 
3652   // Visit everybody reachable!
3653   // Allocate stack of size C-&gt;live_nodes()/2 to avoid frequent realloc
3654   Node_Stack nstack(live_nodes() &gt;&gt; 1);
3655   final_graph_reshaping_walk(nstack, root(), frc);
3656 
3657   // Check for unreachable (from below) code (i.e., infinite loops).
3658   for( uint i = 0; i &lt; frc._tests.size(); i++ ) {
3659     MultiBranchNode *n = frc._tests[i]-&gt;as_MultiBranch();
3660     // Get number of CFG targets.
3661     // Note that PCTables include exception targets after calls.
3662     uint required_outcnt = n-&gt;required_outcnt();
3663     if (n-&gt;outcnt() != required_outcnt) {
3664       // Check for a few special cases.  Rethrow Nodes never take the
3665       // &#39;fall-thru&#39; path, so expected kids is 1 less.
3666       if (n-&gt;is_PCTable() &amp;&amp; n-&gt;in(0) &amp;&amp; n-&gt;in(0)-&gt;in(0)) {
3667         if (n-&gt;in(0)-&gt;in(0)-&gt;is_Call()) {
3668           CallNode *call = n-&gt;in(0)-&gt;in(0)-&gt;as_Call();
3669           if (call-&gt;entry_point() == OptoRuntime::rethrow_stub()) {
3670             required_outcnt--;      // Rethrow always has 1 less kid
3671           } else if (call-&gt;req() &gt; TypeFunc::Parms &amp;&amp;
3672                      call-&gt;is_CallDynamicJava()) {
3673             // Check for null receiver. In such case, the optimizer has
3674             // detected that the virtual call will always result in a null
3675             // pointer exception. The fall-through projection of this CatchNode
3676             // will not be populated.
3677             Node *arg0 = call-&gt;in(TypeFunc::Parms);
3678             if (arg0-&gt;is_Type() &amp;&amp;
3679                 arg0-&gt;as_Type()-&gt;type()-&gt;higher_equal(TypePtr::NULL_PTR)) {
3680               required_outcnt--;
3681             }
3682           } else if (call-&gt;entry_point() == OptoRuntime::new_array_Java() &amp;&amp;
3683                      call-&gt;req() &gt; TypeFunc::Parms+1 &amp;&amp;
3684                      call-&gt;is_CallStaticJava()) {
3685             // Check for negative array length. In such case, the optimizer has
3686             // detected that the allocation attempt will always result in an
3687             // exception. There is no fall-through projection of this CatchNode .
3688             Node *arg1 = call-&gt;in(TypeFunc::Parms+1);
3689             if (arg1-&gt;is_Type() &amp;&amp;
3690                 arg1-&gt;as_Type()-&gt;type()-&gt;join(TypeInt::POS)-&gt;empty()) {
3691               required_outcnt--;
3692             }
3693           }
3694         }
3695       }
3696       // Recheck with a better notion of &#39;required_outcnt&#39;
3697       if (n-&gt;outcnt() != required_outcnt) {
3698         record_method_not_compilable(&quot;malformed control flow&quot;);
3699         return true;            // Not all targets reachable!
3700       }
3701     }
3702     // Check that I actually visited all kids.  Unreached kids
3703     // must be infinite loops.
3704     for (DUIterator_Fast jmax, j = n-&gt;fast_outs(jmax); j &lt; jmax; j++)
3705       if (!frc._visited.test(n-&gt;fast_out(j)-&gt;_idx)) {
3706         record_method_not_compilable(&quot;infinite loop&quot;);
3707         return true;            // Found unvisited kid; must be unreach
3708       }
3709 
3710     // Here so verification code in final_graph_reshaping_walk()
3711     // always see an OuterStripMinedLoopEnd
3712     if (n-&gt;is_OuterStripMinedLoopEnd()) {
3713       IfNode* init_iff = n-&gt;as_If();
3714       Node* iff = new IfNode(init_iff-&gt;in(0), init_iff-&gt;in(1), init_iff-&gt;_prob, init_iff-&gt;_fcnt);
3715       n-&gt;subsume_by(iff, this);
3716     }
3717   }
3718 
3719 #ifdef IA32
3720   // If original bytecodes contained a mixture of floats and doubles
3721   // check if the optimizer has made it homogenous, item (3).
3722   if (UseSSE == 0 &amp;&amp;
3723       frc.get_float_count() &gt; 32 &amp;&amp;
3724       frc.get_double_count() == 0 &amp;&amp;
3725       (10 * frc.get_call_count() &lt; frc.get_float_count()) ) {
3726     set_24_bit_selection_and_mode(false, true);
3727   }
3728 #endif // IA32
3729 
3730   set_java_calls(frc.get_java_call_count());
3731   set_inner_loops(frc.get_inner_loop_count());
3732 
3733   // No infinite loops, no reason to bail out.
3734   return false;
3735 }
3736 
3737 //-----------------------------too_many_traps----------------------------------
3738 // Report if there are too many traps at the current method and bci.
3739 // Return true if there was a trap, and/or PerMethodTrapLimit is exceeded.
3740 bool Compile::too_many_traps(ciMethod* method,
3741                              int bci,
3742                              Deoptimization::DeoptReason reason) {
3743   ciMethodData* md = method-&gt;method_data();
3744   if (md-&gt;is_empty()) {
3745     // Assume the trap has not occurred, or that it occurred only
3746     // because of a transient condition during start-up in the interpreter.
3747     return false;
3748   }
3749   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
3750   if (md-&gt;has_trap_at(bci, m, reason) != 0) {
3751     // Assume PerBytecodeTrapLimit==0, for a more conservative heuristic.
3752     // Also, if there are multiple reasons, or if there is no per-BCI record,
3753     // assume the worst.
3754     if (log())
3755       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39;&quot;,
3756                   Deoptimization::trap_reason_name(reason),
3757                   md-&gt;trap_count(reason));
3758     return true;
3759   } else {
3760     // Ignore method/bci and see if there have been too many globally.
3761     return too_many_traps(reason, md);
3762   }
3763 }
3764 
3765 // Less-accurate variant which does not require a method and bci.
3766 bool Compile::too_many_traps(Deoptimization::DeoptReason reason,
3767                              ciMethodData* logmd) {
3768   if (trap_count(reason) &gt;= Deoptimization::per_method_trap_limit(reason)) {
3769     // Too many traps globally.
3770     // Note that we use cumulative trap_count, not just md-&gt;trap_count.
3771     if (log()) {
3772       int mcount = (logmd == NULL)? -1: (int)logmd-&gt;trap_count(reason);
3773       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;0&#39; mcount=&#39;%d&#39; ccount=&#39;%d&#39;&quot;,
3774                   Deoptimization::trap_reason_name(reason),
3775                   mcount, trap_count(reason));
3776     }
3777     return true;
3778   } else {
3779     // The coast is clear.
3780     return false;
3781   }
3782 }
3783 
3784 //--------------------------too_many_recompiles--------------------------------
3785 // Report if there are too many recompiles at the current method and bci.
3786 // Consults PerBytecodeRecompilationCutoff and PerMethodRecompilationCutoff.
3787 // Is not eager to return true, since this will cause the compiler to use
3788 // Action_none for a trap point, to avoid too many recompilations.
3789 bool Compile::too_many_recompiles(ciMethod* method,
3790                                   int bci,
3791                                   Deoptimization::DeoptReason reason) {
3792   ciMethodData* md = method-&gt;method_data();
3793   if (md-&gt;is_empty()) {
3794     // Assume the trap has not occurred, or that it occurred only
3795     // because of a transient condition during start-up in the interpreter.
3796     return false;
3797   }
3798   // Pick a cutoff point well within PerBytecodeRecompilationCutoff.
3799   uint bc_cutoff = (uint) PerBytecodeRecompilationCutoff / 8;
3800   uint m_cutoff  = (uint) PerMethodRecompilationCutoff / 2 + 1;  // not zero
3801   Deoptimization::DeoptReason per_bc_reason
3802     = Deoptimization::reason_recorded_per_bytecode_if_any(reason);
3803   ciMethod* m = Deoptimization::reason_is_speculate(reason) ? this-&gt;method() : NULL;
3804   if ((per_bc_reason == Deoptimization::Reason_none
3805        || md-&gt;has_trap_at(bci, m, reason) != 0)
3806       // The trap frequency measure we care about is the recompile count:
3807       &amp;&amp; md-&gt;trap_recompiled_at(bci, m)
3808       &amp;&amp; md-&gt;overflow_recompile_count() &gt;= bc_cutoff) {
3809     // Do not emit a trap here if it has already caused recompilations.
3810     // Also, if there are multiple reasons, or if there is no per-BCI record,
3811     // assume the worst.
3812     if (log())
3813       log()-&gt;elem(&quot;observe trap=&#39;%s recompiled&#39; count=&#39;%d&#39; recompiles2=&#39;%d&#39;&quot;,
3814                   Deoptimization::trap_reason_name(reason),
3815                   md-&gt;trap_count(reason),
3816                   md-&gt;overflow_recompile_count());
3817     return true;
3818   } else if (trap_count(reason) != 0
3819              &amp;&amp; decompile_count() &gt;= m_cutoff) {
3820     // Too many recompiles globally, and we have seen this sort of trap.
3821     // Use cumulative decompile_count, not just md-&gt;decompile_count.
3822     if (log())
3823       log()-&gt;elem(&quot;observe trap=&#39;%s&#39; count=&#39;%d&#39; mcount=&#39;%d&#39; decompiles=&#39;%d&#39; mdecompiles=&#39;%d&#39;&quot;,
3824                   Deoptimization::trap_reason_name(reason),
3825                   md-&gt;trap_count(reason), trap_count(reason),
3826                   md-&gt;decompile_count(), decompile_count());
3827     return true;
3828   } else {
3829     // The coast is clear.
3830     return false;
3831   }
3832 }
3833 
3834 // Compute when not to trap. Used by matching trap based nodes and
3835 // NullCheck optimization.
3836 void Compile::set_allowed_deopt_reasons() {
3837   _allowed_reasons = 0;
3838   if (is_method_compilation()) {
3839     for (int rs = (int)Deoptimization::Reason_none+1; rs &lt; Compile::trapHistLength; rs++) {
3840       assert(rs &lt; BitsPerInt, &quot;recode bit map&quot;);
3841       if (!too_many_traps((Deoptimization::DeoptReason) rs)) {
3842         _allowed_reasons |= nth_bit(rs);
3843       }
3844     }
3845   }
3846 }
3847 
3848 bool Compile::needs_clinit_barrier(ciMethod* method, ciMethod* accessing_method) {
3849   return method-&gt;is_static() &amp;&amp; needs_clinit_barrier(method-&gt;holder(), accessing_method);
3850 }
3851 
3852 bool Compile::needs_clinit_barrier(ciField* field, ciMethod* accessing_method) {
3853   return field-&gt;is_static() &amp;&amp; needs_clinit_barrier(field-&gt;holder(), accessing_method);
3854 }
3855 
3856 bool Compile::needs_clinit_barrier(ciInstanceKlass* holder, ciMethod* accessing_method) {
3857   if (holder-&gt;is_initialized()) {
3858     return false;
3859   }
3860   if (holder-&gt;is_being_initialized()) {
3861     if (accessing_method-&gt;holder() == holder) {
3862       // Access inside a class. The barrier can be elided when access happens in &lt;clinit&gt;,
3863       // &lt;init&gt;, or a static method. In all those cases, there was an initialization
3864       // barrier on the holder klass passed.
3865       if (accessing_method-&gt;is_static_initializer() ||
3866           accessing_method-&gt;is_object_initializer() ||
3867           accessing_method-&gt;is_static()) {
3868         return false;
3869       }
3870     } else if (accessing_method-&gt;holder()-&gt;is_subclass_of(holder)) {
3871       // Access from a subclass. The barrier can be elided only when access happens in &lt;clinit&gt;.
3872       // In case of &lt;init&gt; or a static method, the barrier is on the subclass is not enough:
3873       // child class can become fully initialized while its parent class is still being initialized.
3874       if (accessing_method-&gt;is_static_initializer()) {
3875         return false;
3876       }
3877     }
3878     ciMethod* root = method(); // the root method of compilation
3879     if (root != accessing_method) {
3880       return needs_clinit_barrier(holder, root); // check access in the context of compilation root
3881     }
3882   }
3883   return true;
3884 }
3885 
3886 #ifndef PRODUCT
3887 //------------------------------verify_graph_edges---------------------------
3888 // Walk the Graph and verify that there is a one-to-one correspondence
3889 // between Use-Def edges and Def-Use edges in the graph.
3890 void Compile::verify_graph_edges(bool no_dead_code) {
3891   if (VerifyGraphEdges) {
3892     ResourceArea *area = Thread::current()-&gt;resource_area();
3893     Unique_Node_List visited(area);
3894     // Call recursive graph walk to check edges
3895     _root-&gt;verify_edges(visited);
3896     if (no_dead_code) {
3897       // Now make sure that no visited node is used by an unvisited node.
3898       bool dead_nodes = false;
3899       Unique_Node_List checked(area);
3900       while (visited.size() &gt; 0) {
3901         Node* n = visited.pop();
3902         checked.push(n);
3903         for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {
3904           Node* use = n-&gt;raw_out(i);
3905           if (checked.member(use))  continue;  // already checked
3906           if (visited.member(use))  continue;  // already in the graph
3907           if (use-&gt;is_Con())        continue;  // a dead ConNode is OK
3908           // At this point, we have found a dead node which is DU-reachable.
3909           if (!dead_nodes) {
3910             tty-&gt;print_cr(&quot;*** Dead nodes reachable via DU edges:&quot;);
3911             dead_nodes = true;
3912           }
3913           use-&gt;dump(2);
3914           tty-&gt;print_cr(&quot;---&quot;);
3915           checked.push(use);  // No repeats; pretend it is now checked.
3916         }
3917       }
3918       assert(!dead_nodes, &quot;using nodes must be reachable from root&quot;);
3919     }
3920   }
3921 }
3922 #endif
3923 
3924 // The Compile object keeps track of failure reasons separately from the ciEnv.
3925 // This is required because there is not quite a 1-1 relation between the
3926 // ciEnv and its compilation task and the Compile object.  Note that one
3927 // ciEnv might use two Compile objects, if C2Compiler::compile_method decides
3928 // to backtrack and retry without subsuming loads.  Other than this backtracking
3929 // behavior, the Compile&#39;s failure reason is quietly copied up to the ciEnv
3930 // by the logic in C2Compiler.
3931 void Compile::record_failure(const char* reason) {
3932   if (log() != NULL) {
3933     log()-&gt;elem(&quot;failure reason=&#39;%s&#39; phase=&#39;compile&#39;&quot;, reason);
3934   }
3935   if (_failure_reason == NULL) {
3936     // Record the first failure reason.
3937     _failure_reason = reason;
3938   }
3939 
3940   if (!C-&gt;failure_reason_is(C2Compiler::retry_no_subsuming_loads())) {
3941     C-&gt;print_method(PHASE_FAILURE);
3942   }
3943   _root = NULL;  // flush the graph, too
3944 }
3945 
3946 Compile::TracePhase::TracePhase(const char* name, elapsedTimer* accumulator)
3947   : TraceTime(name, accumulator, CITime, CITimeVerbose),
3948     _phase_name(name), _dolog(CITimeVerbose)
3949 {
3950   if (_dolog) {
3951     C = Compile::current();
3952     _log = C-&gt;log();
3953   } else {
3954     C = NULL;
3955     _log = NULL;
3956   }
3957   if (_log != NULL) {
3958     _log-&gt;begin_head(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
3959     _log-&gt;stamp();
3960     _log-&gt;end_head();
3961   }
3962 }
3963 
3964 Compile::TracePhase::~TracePhase() {
3965 
3966   C = Compile::current();
3967   if (_dolog) {
3968     _log = C-&gt;log();
3969   } else {
3970     _log = NULL;
3971   }
3972 
3973 #ifdef ASSERT
3974   if (PrintIdealNodeCount) {
3975     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
3976                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
3977   }
3978 
3979   if (VerifyIdealNodeCount) {
3980     Compile::current()-&gt;print_missing_nodes();
3981   }
3982 #endif
3983 
3984   if (_log != NULL) {
3985     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
3986   }
3987 }
3988 
<a name="23" id="anc23"></a><span class="line-removed">3989 //=============================================================================</span>
<span class="line-removed">3990 // Two Constant&#39;s are equal when the type and the value are equal.</span>
<span class="line-removed">3991 bool Compile::Constant::operator==(const Constant&amp; other) {</span>
<span class="line-removed">3992   if (type()          != other.type()         )  return false;</span>
<span class="line-removed">3993   if (can_be_reused() != other.can_be_reused())  return false;</span>
<span class="line-removed">3994   // For floating point values we compare the bit pattern.</span>
<span class="line-removed">3995   switch (type()) {</span>
<span class="line-removed">3996   case T_INT:</span>
<span class="line-removed">3997   case T_FLOAT:   return (_v._value.i == other._v._value.i);</span>
<span class="line-removed">3998   case T_LONG:</span>
<span class="line-removed">3999   case T_DOUBLE:  return (_v._value.j == other._v._value.j);</span>
<span class="line-removed">4000   case T_OBJECT:</span>
<span class="line-removed">4001   case T_ADDRESS: return (_v._value.l == other._v._value.l);</span>
<span class="line-removed">4002   case T_VOID:    return (_v._value.l == other._v._value.l);  // jump-table entries</span>
<span class="line-removed">4003   case T_METADATA: return (_v._metadata == other._v._metadata);</span>
<span class="line-removed">4004   default: ShouldNotReachHere(); return false;</span>
<span class="line-removed">4005   }</span>
<span class="line-removed">4006 }</span>
<span class="line-removed">4007 </span>
<span class="line-removed">4008 static int type_to_size_in_bytes(BasicType t) {</span>
<span class="line-removed">4009   switch (t) {</span>
<span class="line-removed">4010   case T_INT:     return sizeof(jint   );</span>
<span class="line-removed">4011   case T_LONG:    return sizeof(jlong  );</span>
<span class="line-removed">4012   case T_FLOAT:   return sizeof(jfloat );</span>
<span class="line-removed">4013   case T_DOUBLE:  return sizeof(jdouble);</span>
<span class="line-removed">4014   case T_METADATA: return sizeof(Metadata*);</span>
<span class="line-removed">4015     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4016     // need an internal word relocation.</span>
<span class="line-removed">4017   case T_VOID:</span>
<span class="line-removed">4018   case T_ADDRESS:</span>
<span class="line-removed">4019   case T_OBJECT:  return sizeof(jobject);</span>
<span class="line-removed">4020   default:</span>
<span class="line-removed">4021     ShouldNotReachHere();</span>
<span class="line-removed">4022     return -1;</span>
<span class="line-removed">4023   }</span>
<span class="line-removed">4024 }</span>
<span class="line-removed">4025 </span>
<span class="line-removed">4026 int Compile::ConstantTable::qsort_comparator(Constant* a, Constant* b) {</span>
<span class="line-removed">4027   // sort descending</span>
<span class="line-removed">4028   if (a-&gt;freq() &gt; b-&gt;freq())  return -1;</span>
<span class="line-removed">4029   if (a-&gt;freq() &lt; b-&gt;freq())  return  1;</span>
<span class="line-removed">4030   return 0;</span>
<span class="line-removed">4031 }</span>
<span class="line-removed">4032 </span>
<span class="line-removed">4033 void Compile::ConstantTable::calculate_offsets_and_size() {</span>
<span class="line-removed">4034   // First, sort the array by frequencies.</span>
<span class="line-removed">4035   _constants.sort(qsort_comparator);</span>
<span class="line-removed">4036 </span>
<span class="line-removed">4037 #ifdef ASSERT</span>
<span class="line-removed">4038   // Make sure all jump-table entries were sorted to the end of the</span>
<span class="line-removed">4039   // array (they have a negative frequency).</span>
<span class="line-removed">4040   bool found_void = false;</span>
<span class="line-removed">4041   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4042     Constant con = _constants.at(i);</span>
<span class="line-removed">4043     if (con.type() == T_VOID)</span>
<span class="line-removed">4044       found_void = true;  // jump-tables</span>
<span class="line-removed">4045     else</span>
<span class="line-removed">4046       assert(!found_void, &quot;wrong sorting&quot;);</span>
<span class="line-removed">4047   }</span>
<span class="line-removed">4048 #endif</span>
<span class="line-removed">4049 </span>
<span class="line-removed">4050   int offset = 0;</span>
<span class="line-removed">4051   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4052     Constant* con = _constants.adr_at(i);</span>
<span class="line-removed">4053 </span>
<span class="line-removed">4054     // Align offset for type.</span>
<span class="line-removed">4055     int typesize = type_to_size_in_bytes(con-&gt;type());</span>
<span class="line-removed">4056     offset = align_up(offset, typesize);</span>
<span class="line-removed">4057     con-&gt;set_offset(offset);   // set constant&#39;s offset</span>
<span class="line-removed">4058 </span>
<span class="line-removed">4059     if (con-&gt;type() == T_VOID) {</span>
<span class="line-removed">4060       MachConstantNode* n = (MachConstantNode*) con-&gt;get_jobject();</span>
<span class="line-removed">4061       offset = offset + typesize * n-&gt;outcnt();  // expand jump-table</span>
<span class="line-removed">4062     } else {</span>
<span class="line-removed">4063       offset = offset + typesize;</span>
<span class="line-removed">4064     }</span>
<span class="line-removed">4065   }</span>
<span class="line-removed">4066 </span>
<span class="line-removed">4067   // Align size up to the next section start (which is insts; see</span>
<span class="line-removed">4068   // CodeBuffer::align_at_start).</span>
<span class="line-removed">4069   assert(_size == -1, &quot;already set?&quot;);</span>
<span class="line-removed">4070   _size = align_up(offset, (int)CodeEntryAlignment);</span>
<span class="line-removed">4071 }</span>
<span class="line-removed">4072 </span>
<span class="line-removed">4073 void Compile::ConstantTable::emit(CodeBuffer&amp; cb) {</span>
<span class="line-removed">4074   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4075   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4076     Constant con = _constants.at(i);</span>
<span class="line-removed">4077     address constant_addr = NULL;</span>
<span class="line-removed">4078     switch (con.type()) {</span>
<span class="line-removed">4079     case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;</span>
<span class="line-removed">4080     case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;</span>
<span class="line-removed">4081     case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;</span>
<span class="line-removed">4082     case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;</span>
<span class="line-removed">4083     case T_OBJECT: {</span>
<span class="line-removed">4084       jobject obj = con.get_jobject();</span>
<span class="line-removed">4085       int oop_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4086       constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));</span>
<span class="line-removed">4087       break;</span>
<span class="line-removed">4088     }</span>
<span class="line-removed">4089     case T_ADDRESS: {</span>
<span class="line-removed">4090       address addr = (address) con.get_jobject();</span>
<span class="line-removed">4091       constant_addr = _masm.address_constant(addr);</span>
<span class="line-removed">4092       break;</span>
<span class="line-removed">4093     }</span>
<span class="line-removed">4094     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4095     // need an internal word relocation.</span>
<span class="line-removed">4096     case T_VOID: {</span>
<span class="line-removed">4097       MachConstantNode* n = (MachConstantNode*) con.get_jobject();</span>
<span class="line-removed">4098       // Fill the jump-table with a dummy word.  The real value is</span>
<span class="line-removed">4099       // filled in later in fill_jump_table.</span>
<span class="line-removed">4100       address dummy = (address) n;</span>
<span class="line-removed">4101       constant_addr = _masm.address_constant(dummy);</span>
<span class="line-removed">4102       // Expand jump-table</span>
<span class="line-removed">4103       for (uint i = 1; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4104         address temp_addr = _masm.address_constant(dummy + i);</span>
<span class="line-removed">4105         assert(temp_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4106       }</span>
<span class="line-removed">4107       break;</span>
<span class="line-removed">4108     }</span>
<span class="line-removed">4109     case T_METADATA: {</span>
<span class="line-removed">4110       Metadata* obj = con.get_metadata();</span>
<span class="line-removed">4111       int metadata_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4112       constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));</span>
<span class="line-removed">4113       break;</span>
<span class="line-removed">4114     }</span>
<span class="line-removed">4115     default: ShouldNotReachHere();</span>
<span class="line-removed">4116     }</span>
<span class="line-removed">4117     assert(constant_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4118     assert((constant_addr - _masm.code()-&gt;consts()-&gt;start()) == con.offset(),</span>
<span class="line-removed">4119             &quot;must be: %d == %d&quot;, (int) (constant_addr - _masm.code()-&gt;consts()-&gt;start()), (int)(con.offset()));</span>
<span class="line-removed">4120   }</span>
<span class="line-removed">4121 }</span>
<span class="line-removed">4122 </span>
<span class="line-removed">4123 int Compile::ConstantTable::find_offset(Constant&amp; con) const {</span>
<span class="line-removed">4124   int idx = _constants.find(con);</span>
<span class="line-removed">4125   guarantee(idx != -1, &quot;constant must be in constant table&quot;);</span>
<span class="line-removed">4126   int offset = _constants.at(idx).offset();</span>
<span class="line-removed">4127   guarantee(offset != -1, &quot;constant table not emitted yet?&quot;);</span>
<span class="line-removed">4128   return offset;</span>
<span class="line-removed">4129 }</span>
<span class="line-removed">4130 </span>
<span class="line-removed">4131 void Compile::ConstantTable::add(Constant&amp; con) {</span>
<span class="line-removed">4132   if (con.can_be_reused()) {</span>
<span class="line-removed">4133     int idx = _constants.find(con);</span>
<span class="line-removed">4134     if (idx != -1 &amp;&amp; _constants.at(idx).can_be_reused()) {</span>
<span class="line-removed">4135       _constants.adr_at(idx)-&gt;inc_freq(con.freq());  // increase the frequency by the current value</span>
<span class="line-removed">4136       return;</span>
<span class="line-removed">4137     }</span>
<span class="line-removed">4138   }</span>
<span class="line-removed">4139   (void) _constants.append(con);</span>
<span class="line-removed">4140 }</span>
<span class="line-removed">4141 </span>
<span class="line-removed">4142 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, BasicType type, jvalue value) {</span>
<span class="line-removed">4143   Block* b = Compile::current()-&gt;cfg()-&gt;get_block_for_node(n);</span>
<span class="line-removed">4144   Constant con(type, value, b-&gt;_freq);</span>
<span class="line-removed">4145   add(con);</span>
<span class="line-removed">4146   return con;</span>
<span class="line-removed">4147 }</span>
<span class="line-removed">4148 </span>
<span class="line-removed">4149 Compile::Constant Compile::ConstantTable::add(Metadata* metadata) {</span>
<span class="line-removed">4150   Constant con(metadata);</span>
<span class="line-removed">4151   add(con);</span>
<span class="line-removed">4152   return con;</span>
<span class="line-removed">4153 }</span>
<span class="line-removed">4154 </span>
<span class="line-removed">4155 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, MachOper* oper) {</span>
<span class="line-removed">4156   jvalue value;</span>
<span class="line-removed">4157   BasicType type = oper-&gt;type()-&gt;basic_type();</span>
<span class="line-removed">4158   switch (type) {</span>
<span class="line-removed">4159   case T_LONG:    value.j = oper-&gt;constantL(); break;</span>
<span class="line-removed">4160   case T_FLOAT:   value.f = oper-&gt;constantF(); break;</span>
<span class="line-removed">4161   case T_DOUBLE:  value.d = oper-&gt;constantD(); break;</span>
<span class="line-removed">4162   case T_OBJECT:</span>
<span class="line-removed">4163   case T_ADDRESS: value.l = (jobject) oper-&gt;constant(); break;</span>
<span class="line-removed">4164   case T_METADATA: return add((Metadata*)oper-&gt;constant()); break;</span>
<span class="line-removed">4165   default: guarantee(false, &quot;unhandled type: %s&quot;, type2name(type));</span>
<span class="line-removed">4166   }</span>
<span class="line-removed">4167   return add(n, type, value);</span>
<span class="line-removed">4168 }</span>
<span class="line-removed">4169 </span>
<span class="line-removed">4170 Compile::Constant Compile::ConstantTable::add_jump_table(MachConstantNode* n) {</span>
<span class="line-removed">4171   jvalue value;</span>
<span class="line-removed">4172   // We can use the node pointer here to identify the right jump-table</span>
<span class="line-removed">4173   // as this method is called from Compile::Fill_buffer right before</span>
<span class="line-removed">4174   // the MachNodes are emitted and the jump-table is filled (means the</span>
<span class="line-removed">4175   // MachNode pointers do not change anymore).</span>
<span class="line-removed">4176   value.l = (jobject) n;</span>
<span class="line-removed">4177   Constant con(T_VOID, value, next_jump_table_freq(), false);  // Labels of a jump-table cannot be reused.</span>
<span class="line-removed">4178   add(con);</span>
<span class="line-removed">4179   return con;</span>
<span class="line-removed">4180 }</span>
<span class="line-removed">4181 </span>
<span class="line-removed">4182 void Compile::ConstantTable::fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const {</span>
<span class="line-removed">4183   // If called from Compile::scratch_emit_size do nothing.</span>
<span class="line-removed">4184   if (Compile::current()-&gt;in_scratch_emit_size())  return;</span>
<span class="line-removed">4185 </span>
<span class="line-removed">4186   assert(labels.is_nonempty(), &quot;must be&quot;);</span>
<span class="line-removed">4187   assert((uint) labels.length() == n-&gt;outcnt(), &quot;must be equal: %d == %d&quot;, labels.length(), n-&gt;outcnt());</span>
<span class="line-removed">4188 </span>
<span class="line-removed">4189   // Since MachConstantNode::constant_offset() also contains</span>
<span class="line-removed">4190   // table_base_offset() we need to subtract the table_base_offset()</span>
<span class="line-removed">4191   // to get the plain offset into the constant table.</span>
<span class="line-removed">4192   int offset = n-&gt;constant_offset() - table_base_offset();</span>
<span class="line-removed">4193 </span>
<span class="line-removed">4194   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4195   address* jump_table_base = (address*) (_masm.code()-&gt;consts()-&gt;start() + offset);</span>
<span class="line-removed">4196 </span>
<span class="line-removed">4197   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4198     address* constant_addr = &amp;jump_table_base[i];</span>
<span class="line-removed">4199     assert(*constant_addr == (((address) n) + i), &quot;all jump-table entries must contain adjusted node pointer: &quot; INTPTR_FORMAT &quot; == &quot; INTPTR_FORMAT, p2i(*constant_addr), p2i(((address) n) + i));</span>
<span class="line-removed">4200     *constant_addr = cb.consts()-&gt;target(*labels.at(i), (address) constant_addr);</span>
<span class="line-removed">4201     cb.consts()-&gt;relocate((address) constant_addr, relocInfo::internal_word_type);</span>
<span class="line-removed">4202   }</span>
<span class="line-removed">4203 }</span>
<span class="line-removed">4204 </span>
4205 //----------------------------static_subtype_check-----------------------------
4206 // Shortcut important common cases when superklass is exact:
4207 // (0) superklass is java.lang.Object (can occur in reflective code)
4208 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
4209 // (2) subklass does not overlap with superklass =&gt; always fail
4210 // (3) superklass has NO subtypes and we can check with a simple compare.
4211 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
4212   if (StressReflectiveCode) {
4213     return SSC_full_test;       // Let caller generate the general case.
4214   }
4215 
4216   if (superk == env()-&gt;Object_klass()) {
4217     return SSC_always_true;     // (0) this test cannot fail
4218   }
4219 
4220   ciType* superelem = superk;
4221   if (superelem-&gt;is_array_klass())
4222     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4223 
4224   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4225     if (subk-&gt;is_subtype_of(superk)) {
4226       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4227     }
4228     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4229         !superk-&gt;is_subtype_of(subk)) {
4230       return SSC_always_false;
4231     }
4232   }
4233 
4234   // If casting to an instance klass, it must have no subtypes
4235   if (superk-&gt;is_interface()) {
4236     // Cannot trust interfaces yet.
4237     // %%% S.B. superk-&gt;nof_implementors() == 1
4238   } else if (superelem-&gt;is_instance_klass()) {
4239     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4240     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4241       if (!ik-&gt;is_final()) {
4242         // Add a dependency if there is a chance of a later subclass.
4243         dependencies()-&gt;assert_leaf_type(ik);
4244       }
<a name="24" id="anc24"></a><span class="line-removed">4245       if (ik-&gt;is_abstract()) {</span>
<span class="line-removed">4246         return SSC_always_false;</span>
<span class="line-removed">4247       }</span>
4248       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4249     }
4250   } else {
4251     // A primitive array type has no subtypes.
4252     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4253   }
4254 
4255   return SSC_full_test;
4256 }
4257 
4258 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4259 #ifdef _LP64
4260   // The scaled index operand to AddP must be a clean 64-bit value.
4261   // Java allows a 32-bit int to be incremented to a negative
4262   // value, which appears in a 64-bit register as a large
4263   // positive number.  Using that large positive number as an
4264   // operand in pointer arithmetic has bad consequences.
4265   // On the other hand, 32-bit overflow is rare, and the possibility
4266   // can often be excluded, if we annotate the ConvI2L node with
4267   // a type assertion that its value is known to be a small positive
4268   // number.  (The prior range check has ensured this.)
4269   // This assertion is used by ConvI2LNode::Ideal.
4270   int index_max = max_jint - 1;  // array size is max_jint, index is one less
4271   if (sizetype != NULL) index_max = sizetype-&gt;_hi - 1;
4272   const TypeInt* iidxtype = TypeInt::make(0, index_max, Type::WidenMax);
4273   idx = constrained_convI2L(phase, idx, iidxtype, ctrl);
4274 #endif
4275   return idx;
4276 }
4277 
4278 // Convert integer value to a narrowed long type dependent on ctrl (for example, a range check)
4279 Node* Compile::constrained_convI2L(PhaseGVN* phase, Node* value, const TypeInt* itype, Node* ctrl) {
4280   if (ctrl != NULL) {
4281     // Express control dependency by a CastII node with a narrow type.
4282     value = new CastIINode(value, itype, false, true /* range check dependency */);
4283     // Make the CastII node dependent on the control input to prevent the narrowed ConvI2L
4284     // node from floating above the range check during loop optimizations. Otherwise, the
4285     // ConvI2L node may be eliminated independently of the range check, causing the data path
4286     // to become TOP while the control path is still there (although it&#39;s unreachable).
4287     value-&gt;set_req(0, ctrl);
4288     // Save CastII node to remove it after loop optimizations.
4289     phase-&gt;C-&gt;add_range_check_cast(value);
4290     value = phase-&gt;transform(value);
4291   }
4292   const TypeLong* ltype = TypeLong::make(itype-&gt;_lo, itype-&gt;_hi, itype-&gt;_widen);
4293   return phase-&gt;transform(new ConvI2LNode(value, ltype));
4294 }
4295 
4296 void Compile::print_inlining_stream_free() {
4297   if (_print_inlining_stream != NULL) {
4298     _print_inlining_stream-&gt;~stringStream();
4299     _print_inlining_stream = NULL;
4300   }
4301 }
4302 
4303 // The message about the current inlining is accumulated in
4304 // _print_inlining_stream and transfered into the _print_inlining_list
4305 // once we know whether inlining succeeds or not. For regular
4306 // inlining, messages are appended to the buffer pointed by
4307 // _print_inlining_idx in the _print_inlining_list. For late inlining,
4308 // a new buffer is added after _print_inlining_idx in the list. This
4309 // way we can update the inlining message for late inlining call site
4310 // when the inlining is attempted again.
4311 void Compile::print_inlining_init() {
4312   if (print_inlining() || print_intrinsics()) {
4313     // print_inlining_init is actually called several times.
4314     print_inlining_stream_free();
4315     _print_inlining_stream = new stringStream();
4316     // Watch out: The memory initialized by the constructor call PrintInliningBuffer()
4317     // will be copied into the only initial element. The default destructor of
4318     // PrintInliningBuffer will be called when leaving the scope here. If it
4319     // would destuct the  enclosed stringStream _print_inlining_list[0]-&gt;_ss
4320     // would be destructed, too!
4321     _print_inlining_list = new (comp_arena())GrowableArray&lt;PrintInliningBuffer&gt;(comp_arena(), 1, 1, PrintInliningBuffer());
4322   }
4323 }
4324 
4325 void Compile::print_inlining_reinit() {
4326   if (print_inlining() || print_intrinsics()) {
4327     print_inlining_stream_free();
4328     // Re allocate buffer when we change ResourceMark
4329     _print_inlining_stream = new stringStream();
4330   }
4331 }
4332 
4333 void Compile::print_inlining_reset() {
4334   _print_inlining_stream-&gt;reset();
4335 }
4336 
4337 void Compile::print_inlining_commit() {
4338   assert(print_inlining() || print_intrinsics(), &quot;PrintInlining off?&quot;);
4339   // Transfer the message from _print_inlining_stream to the current
4340   // _print_inlining_list buffer and clear _print_inlining_stream.
4341   _print_inlining_list-&gt;at(_print_inlining_idx).ss()-&gt;write(_print_inlining_stream-&gt;base(), _print_inlining_stream-&gt;size());
4342   print_inlining_reset();
4343 }
4344 
4345 void Compile::print_inlining_push() {
4346   // Add new buffer to the _print_inlining_list at current position
4347   _print_inlining_idx++;
4348   _print_inlining_list-&gt;insert_before(_print_inlining_idx, PrintInliningBuffer());
4349 }
4350 
4351 Compile::PrintInliningBuffer&amp; Compile::print_inlining_current() {
4352   return _print_inlining_list-&gt;at(_print_inlining_idx);
4353 }
4354 
4355 void Compile::print_inlining_update(CallGenerator* cg) {
4356   if (print_inlining() || print_intrinsics()) {
4357     if (!cg-&gt;is_late_inline()) {
4358       if (print_inlining_current().cg() != NULL) {
4359         print_inlining_push();
4360       }
4361       print_inlining_commit();
4362     } else {
4363       if (print_inlining_current().cg() != cg &amp;&amp;
4364           (print_inlining_current().cg() != NULL ||
4365            print_inlining_current().ss()-&gt;size() != 0)) {
4366         print_inlining_push();
4367       }
4368       print_inlining_commit();
4369       print_inlining_current().set_cg(cg);
4370     }
4371   }
4372 }
4373 
4374 void Compile::print_inlining_move_to(CallGenerator* cg) {
4375   // We resume inlining at a late inlining call site. Locate the
4376   // corresponding inlining buffer so that we can update it.
4377   if (print_inlining()) {
4378     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4379       if (_print_inlining_list-&gt;adr_at(i)-&gt;cg() == cg) {
4380         _print_inlining_idx = i;
4381         return;
4382       }
4383     }
4384     ShouldNotReachHere();
4385   }
4386 }
4387 
4388 void Compile::print_inlining_update_delayed(CallGenerator* cg) {
4389   if (print_inlining()) {
4390     assert(_print_inlining_stream-&gt;size() &gt; 0, &quot;missing inlining msg&quot;);
4391     assert(print_inlining_current().cg() == cg, &quot;wrong entry&quot;);
4392     // replace message with new message
4393     _print_inlining_list-&gt;at_put(_print_inlining_idx, PrintInliningBuffer());
4394     print_inlining_commit();
4395     print_inlining_current().set_cg(cg);
4396   }
4397 }
4398 
4399 void Compile::print_inlining_assert_ready() {
4400   assert(!_print_inlining || _print_inlining_stream-&gt;size() == 0, &quot;loosing data&quot;);
4401 }
4402 
4403 void Compile::process_print_inlining() {
4404   bool do_print_inlining = print_inlining() || print_intrinsics();
4405   if (do_print_inlining || log() != NULL) {
4406     // Print inlining message for candidates that we couldn&#39;t inline
4407     // for lack of space
4408     for (int i = 0; i &lt; _late_inlines.length(); i++) {
4409       CallGenerator* cg = _late_inlines.at(i);
4410       if (!cg-&gt;is_mh_late_inline()) {
4411         const char* msg = &quot;live nodes &gt; LiveNodeCountInliningCutoff&quot;;
4412         if (do_print_inlining) {
4413           cg-&gt;print_inlining_late(msg);
4414         }
4415         log_late_inline_failure(cg, msg);
4416       }
4417     }
4418   }
4419   if (do_print_inlining) {
4420     ResourceMark rm;
4421     stringStream ss;
4422     assert(_print_inlining_list != NULL, &quot;process_print_inlining should be called only once.&quot;);
4423     for (int i = 0; i &lt; _print_inlining_list-&gt;length(); i++) {
4424       ss.print(&quot;%s&quot;, _print_inlining_list-&gt;adr_at(i)-&gt;ss()-&gt;as_string());
4425       _print_inlining_list-&gt;at(i).freeStream();
4426     }
4427     // Reset _print_inlining_list, it only contains destructed objects.
4428     // It is on the arena, so it will be freed when the arena is reset.
4429     _print_inlining_list = NULL;
4430     // _print_inlining_stream won&#39;t be used anymore, either.
4431     print_inlining_stream_free();
4432     size_t end = ss.size();
4433     _print_inlining_output = NEW_ARENA_ARRAY(comp_arena(), char, end+1);
4434     strncpy(_print_inlining_output, ss.base(), end+1);
4435     _print_inlining_output[end] = 0;
4436   }
4437 }
4438 
4439 void Compile::dump_print_inlining() {
4440   if (_print_inlining_output != NULL) {
4441     tty-&gt;print_raw(_print_inlining_output);
4442   }
4443 }
4444 
4445 void Compile::log_late_inline(CallGenerator* cg) {
4446   if (log() != NULL) {
4447     log()-&gt;head(&quot;late_inline method=&#39;%d&#39;  inline_id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, log()-&gt;identify(cg-&gt;method()),
4448                 cg-&gt;unique_id());
4449     JVMState* p = cg-&gt;call_node()-&gt;jvms();
4450     while (p != NULL) {
4451       log()-&gt;elem(&quot;jvms bci=&#39;%d&#39; method=&#39;%d&#39;&quot;, p-&gt;bci(), log()-&gt;identify(p-&gt;method()));
4452       p = p-&gt;caller();
4453     }
4454     log()-&gt;tail(&quot;late_inline&quot;);
4455   }
4456 }
4457 
4458 void Compile::log_late_inline_failure(CallGenerator* cg, const char* msg) {
4459   log_late_inline(cg);
4460   if (log() != NULL) {
4461     log()-&gt;inline_fail(msg);
4462   }
4463 }
4464 
4465 void Compile::log_inline_id(CallGenerator* cg) {
4466   if (log() != NULL) {
4467     // The LogCompilation tool needs a unique way to identify late
4468     // inline call sites. This id must be unique for this call site in
4469     // this compilation. Try to have it unique across compilations as
4470     // well because it can be convenient when grepping through the log
4471     // file.
4472     // Distinguish OSR compilations from others in case CICountOSR is
4473     // on.
4474     jlong id = ((jlong)unique()) + (((jlong)compile_id()) &lt;&lt; 33) + (CICountOSR &amp;&amp; is_osr_compilation() ? ((jlong)1) &lt;&lt; 32 : 0);
4475     cg-&gt;set_unique_id(id);
4476     log()-&gt;elem(&quot;inline_id id=&#39;&quot; JLONG_FORMAT &quot;&#39;&quot;, id);
4477   }
4478 }
4479 
4480 void Compile::log_inline_failure(const char* msg) {
4481   if (C-&gt;log() != NULL) {
4482     C-&gt;log()-&gt;inline_fail(msg);
4483   }
4484 }
4485 
4486 
4487 // Dump inlining replay data to the stream.
4488 // Don&#39;t change thread state and acquire any locks.
4489 void Compile::dump_inline_data(outputStream* out) {
4490   InlineTree* inl_tree = ilt();
4491   if (inl_tree != NULL) {
4492     out-&gt;print(&quot; inline %d&quot;, inl_tree-&gt;count());
4493     inl_tree-&gt;dump_replay_data(out);
4494   }
4495 }
4496 
4497 int Compile::cmp_expensive_nodes(Node* n1, Node* n2) {
4498   if (n1-&gt;Opcode() &lt; n2-&gt;Opcode())      return -1;
4499   else if (n1-&gt;Opcode() &gt; n2-&gt;Opcode()) return 1;
4500 
4501   assert(n1-&gt;req() == n2-&gt;req(), &quot;can&#39;t compare %s nodes: n1-&gt;req() = %d, n2-&gt;req() = %d&quot;, NodeClassNames[n1-&gt;Opcode()], n1-&gt;req(), n2-&gt;req());
4502   for (uint i = 1; i &lt; n1-&gt;req(); i++) {
4503     if (n1-&gt;in(i) &lt; n2-&gt;in(i))      return -1;
4504     else if (n1-&gt;in(i) &gt; n2-&gt;in(i)) return 1;
4505   }
4506 
4507   return 0;
4508 }
4509 
4510 int Compile::cmp_expensive_nodes(Node** n1p, Node** n2p) {
4511   Node* n1 = *n1p;
4512   Node* n2 = *n2p;
4513 
4514   return cmp_expensive_nodes(n1, n2);
4515 }
4516 
4517 void Compile::sort_expensive_nodes() {
4518   if (!expensive_nodes_sorted()) {
4519     _expensive_nodes-&gt;sort(cmp_expensive_nodes);
4520   }
4521 }
4522 
4523 bool Compile::expensive_nodes_sorted() const {
4524   for (int i = 1; i &lt; _expensive_nodes-&gt;length(); i++) {
4525     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i-1)) &lt; 0) {
4526       return false;
4527     }
4528   }
4529   return true;
4530 }
4531 
4532 bool Compile::should_optimize_expensive_nodes(PhaseIterGVN &amp;igvn) {
4533   if (_expensive_nodes-&gt;length() == 0) {
4534     return false;
4535   }
4536 
4537   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
4538 
4539   // Take this opportunity to remove dead nodes from the list
4540   int j = 0;
4541   for (int i = 0; i &lt; _expensive_nodes-&gt;length(); i++) {
4542     Node* n = _expensive_nodes-&gt;at(i);
4543     if (!n-&gt;is_unreachable(igvn)) {
4544       assert(n-&gt;is_expensive(), &quot;should be expensive&quot;);
4545       _expensive_nodes-&gt;at_put(j, n);
4546       j++;
4547     }
4548   }
4549   _expensive_nodes-&gt;trunc_to(j);
4550 
4551   // Then sort the list so that similar nodes are next to each other
4552   // and check for at least two nodes of identical kind with same data
4553   // inputs.
4554   sort_expensive_nodes();
4555 
4556   for (int i = 0; i &lt; _expensive_nodes-&gt;length()-1; i++) {
4557     if (cmp_expensive_nodes(_expensive_nodes-&gt;adr_at(i), _expensive_nodes-&gt;adr_at(i+1)) == 0) {
4558       return true;
4559     }
4560   }
4561 
4562   return false;
4563 }
4564 
4565 void Compile::cleanup_expensive_nodes(PhaseIterGVN &amp;igvn) {
4566   if (_expensive_nodes-&gt;length() == 0) {
4567     return;
4568   }
4569 
4570   assert(OptimizeExpensiveOps, &quot;optimization off?&quot;);
4571 
4572   // Sort to bring similar nodes next to each other and clear the
4573   // control input of nodes for which there&#39;s only a single copy.
4574   sort_expensive_nodes();
4575 
4576   int j = 0;
4577   int identical = 0;
4578   int i = 0;
4579   bool modified = false;
4580   for (; i &lt; _expensive_nodes-&gt;length()-1; i++) {
4581     assert(j &lt;= i, &quot;can&#39;t write beyond current index&quot;);
4582     if (_expensive_nodes-&gt;at(i)-&gt;Opcode() == _expensive_nodes-&gt;at(i+1)-&gt;Opcode()) {
4583       identical++;
4584       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4585       continue;
4586     }
4587     if (identical &gt; 0) {
4588       _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4589       identical = 0;
4590     } else {
4591       Node* n = _expensive_nodes-&gt;at(i);
4592       igvn.replace_input_of(n, 0, NULL);
4593       igvn.hash_insert(n);
4594       modified = true;
4595     }
4596   }
4597   if (identical &gt; 0) {
4598     _expensive_nodes-&gt;at_put(j++, _expensive_nodes-&gt;at(i));
4599   } else if (_expensive_nodes-&gt;length() &gt;= 1) {
4600     Node* n = _expensive_nodes-&gt;at(i);
4601     igvn.replace_input_of(n, 0, NULL);
4602     igvn.hash_insert(n);
4603     modified = true;
4604   }
4605   _expensive_nodes-&gt;trunc_to(j);
4606   if (modified) {
4607     igvn.optimize();
4608   }
4609 }
4610 
4611 void Compile::add_expensive_node(Node * n) {
4612   assert(!_expensive_nodes-&gt;contains(n), &quot;duplicate entry in expensive list&quot;);
4613   assert(n-&gt;is_expensive(), &quot;expensive nodes with non-null control here only&quot;);
4614   assert(!n-&gt;is_CFG() &amp;&amp; !n-&gt;is_Mem(), &quot;no cfg or memory nodes here&quot;);
4615   if (OptimizeExpensiveOps) {
4616     _expensive_nodes-&gt;append(n);
4617   } else {
4618     // Clear control input and let IGVN optimize expensive nodes if
4619     // OptimizeExpensiveOps is off.
4620     n-&gt;set_req(0, NULL);
4621   }
4622 }
4623 
4624 /**
4625  * Remove the speculative part of types and clean up the graph
4626  */
4627 void Compile::remove_speculative_types(PhaseIterGVN &amp;igvn) {
4628   if (UseTypeSpeculation) {
4629     Unique_Node_List worklist;
4630     worklist.push(root());
4631     int modified = 0;
4632     // Go over all type nodes that carry a speculative type, drop the
4633     // speculative part of the type and enqueue the node for an igvn
4634     // which may optimize it out.
4635     for (uint next = 0; next &lt; worklist.size(); ++next) {
4636       Node *n  = worklist.at(next);
4637       if (n-&gt;is_Type()) {
4638         TypeNode* tn = n-&gt;as_Type();
4639         const Type* t = tn-&gt;type();
4640         const Type* t_no_spec = t-&gt;remove_speculative();
4641         if (t_no_spec != t) {
4642           bool in_hash = igvn.hash_delete(n);
4643           assert(in_hash, &quot;node should be in igvn hash table&quot;);
4644           tn-&gt;set_type(t_no_spec);
4645           igvn.hash_insert(n);
4646           igvn._worklist.push(n); // give it a chance to go away
4647           modified++;
4648         }
4649       }
4650       uint max = n-&gt;len();
4651       for( uint i = 0; i &lt; max; ++i ) {
4652         Node *m = n-&gt;in(i);
4653         if (not_a_node(m))  continue;
4654         worklist.push(m);
4655       }
4656     }
4657     // Drop the speculative part of all types in the igvn&#39;s type table
4658     igvn.remove_speculative_types();
4659     if (modified &gt; 0) {
4660       igvn.optimize();
4661     }
4662 #ifdef ASSERT
4663     // Verify that after the IGVN is over no speculative type has resurfaced
4664     worklist.clear();
4665     worklist.push(root());
4666     for (uint next = 0; next &lt; worklist.size(); ++next) {
4667       Node *n  = worklist.at(next);
4668       const Type* t = igvn.type_or_null(n);
4669       assert((t == NULL) || (t == t-&gt;remove_speculative()), &quot;no more speculative types&quot;);
4670       if (n-&gt;is_Type()) {
4671         t = n-&gt;as_Type()-&gt;type();
4672         assert(t == t-&gt;remove_speculative(), &quot;no more speculative types&quot;);
4673       }
4674       uint max = n-&gt;len();
4675       for( uint i = 0; i &lt; max; ++i ) {
4676         Node *m = n-&gt;in(i);
4677         if (not_a_node(m))  continue;
4678         worklist.push(m);
4679       }
4680     }
4681     igvn.check_no_speculative_types();
4682 #endif
4683   }
4684 }
4685 
4686 // Auxiliary method to support randomized stressing/fuzzing.
4687 //
4688 // This method can be called the arbitrary number of times, with current count
4689 // as the argument. The logic allows selecting a single candidate from the
4690 // running list of candidates as follows:
4691 //    int count = 0;
4692 //    Cand* selected = null;
4693 //    while(cand = cand-&gt;next()) {
4694 //      if (randomized_select(++count)) {
4695 //        selected = cand;
4696 //      }
4697 //    }
4698 //
4699 // Including count equalizes the chances any candidate is &quot;selected&quot;.
4700 // This is useful when we don&#39;t have the complete list of candidates to choose
4701 // from uniformly. In this case, we need to adjust the randomicity of the
4702 // selection, or else we will end up biasing the selection towards the latter
4703 // candidates.
4704 //
4705 // Quick back-envelope calculation shows that for the list of n candidates
4706 // the equal probability for the candidate to persist as &quot;best&quot; can be
4707 // achieved by replacing it with &quot;next&quot; k-th candidate with the probability
4708 // of 1/k. It can be easily shown that by the end of the run, the
4709 // probability for any candidate is converged to 1/n, thus giving the
4710 // uniform distribution among all the candidates.
4711 //
4712 // We don&#39;t care about the domain size as long as (RANDOMIZED_DOMAIN / count) is large.
4713 #define RANDOMIZED_DOMAIN_POW 29
4714 #define RANDOMIZED_DOMAIN (1 &lt;&lt; RANDOMIZED_DOMAIN_POW)
4715 #define RANDOMIZED_DOMAIN_MASK ((1 &lt;&lt; (RANDOMIZED_DOMAIN_POW + 1)) - 1)
4716 bool Compile::randomized_select(int count) {
4717   assert(count &gt; 0, &quot;only positive&quot;);
4718   return (os::random() &amp; RANDOMIZED_DOMAIN_MASK) &lt; (RANDOMIZED_DOMAIN / count);
4719 }
4720 
4721 CloneMap&amp;     Compile::clone_map()                 { return _clone_map; }
4722 void          Compile::set_clone_map(Dict* d)      { _clone_map._dict = d; }
4723 
4724 void NodeCloneInfo::dump() const {
4725   tty-&gt;print(&quot; {%d:%d} &quot;, idx(), gen());
4726 }
4727 
4728 void CloneMap::clone(Node* old, Node* nnn, int gen) {
4729   uint64_t val = value(old-&gt;_idx);
4730   NodeCloneInfo cio(val);
4731   assert(val != 0, &quot;old node should be in the map&quot;);
4732   NodeCloneInfo cin(cio.idx(), gen + cio.gen());
4733   insert(nnn-&gt;_idx, cin.get());
4734 #ifndef PRODUCT
4735   if (is_debug()) {
4736     tty-&gt;print_cr(&quot;CloneMap::clone inserted node %d info {%d:%d} into CloneMap&quot;, nnn-&gt;_idx, cin.idx(), cin.gen());
4737   }
4738 #endif
4739 }
4740 
4741 void CloneMap::verify_insert_and_clone(Node* old, Node* nnn, int gen) {
4742   NodeCloneInfo cio(value(old-&gt;_idx));
4743   if (cio.get() == 0) {
4744     cio.set(old-&gt;_idx, 0);
4745     insert(old-&gt;_idx, cio.get());
4746 #ifndef PRODUCT
4747     if (is_debug()) {
4748       tty-&gt;print_cr(&quot;CloneMap::verify_insert_and_clone inserted node %d info {%d:%d} into CloneMap&quot;, old-&gt;_idx, cio.idx(), cio.gen());
4749     }
4750 #endif
4751   }
4752   clone(old, nnn, gen);
4753 }
4754 
4755 int CloneMap::max_gen() const {
4756   int g = 0;
4757   DictI di(_dict);
4758   for(; di.test(); ++di) {
4759     int t = gen(di._key);
4760     if (g &lt; t) {
4761       g = t;
4762 #ifndef PRODUCT
4763       if (is_debug()) {
4764         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4765       }
4766 #endif
4767     }
4768   }
4769   return g;
4770 }
4771 
4772 void CloneMap::dump(node_idx_t key) const {
4773   uint64_t val = value(key);
4774   if (val != 0) {
4775     NodeCloneInfo ni(val);
4776     ni.dump();
4777   }
4778 }
<a name="25" id="anc25"></a>

















<a name="26" id="anc26"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="26" type="hidden" />
</body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/output.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/output.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;


  38 #include &quot;opto/callnode.hpp&quot;
  39 #include &quot;opto/cfgnode.hpp&quot;
  40 #include &quot;opto/locknode.hpp&quot;
  41 #include &quot;opto/machnode.hpp&quot;

  42 #include &quot;opto/optoreg.hpp&quot;
  43 #include &quot;opto/output.hpp&quot;
  44 #include &quot;opto/regalloc.hpp&quot;
  45 #include &quot;opto/runtime.hpp&quot;
  46 #include &quot;opto/subnode.hpp&quot;
  47 #include &quot;opto/type.hpp&quot;
  48 #include &quot;runtime/handles.inline.hpp&quot;

  49 #include &quot;utilities/macros.hpp&quot;
  50 #include &quot;utilities/powerOfTwo.hpp&quot;
  51 #include &quot;utilities/xmlstream.hpp&quot;
<span class="line-removed">  52 #ifdef X86</span>
<span class="line-removed">  53 #include &quot;c2_intelJccErratum_x86.hpp&quot;</span>
<span class="line-removed">  54 #endif</span>
  55 
  56 #ifndef PRODUCT
  57 #define DEBUG_ARG(x) , x
  58 #else
  59 #define DEBUG_ARG(x)
  60 #endif
  61 














































































































































































































  62 // Convert Nodes to instruction bits and pass off to the VM
<span class="line-modified">  63 void Compile::Output() {</span>
  64   // RootNode goes
<span class="line-modified">  65   assert( _cfg-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
  66 
  67   // The number of new nodes (mostly MachNop) is proportional to
  68   // the number of java calls and inner loops which are aligned.
  69   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
  70                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
  71                            &quot;out of nodes before code generation&quot; ) ) {
  72     return;
  73   }
  74   // Make sure I can find the Start Node
<span class="line-modified">  75   Block *entry = _cfg-&gt;get_block(1);</span>
<span class="line-modified">  76   Block *broot = _cfg-&gt;get_root_block();</span>
  77 
  78   const StartNode *start = entry-&gt;head()-&gt;as_Start();
  79 
  80   // Replace StartNode with prolog
  81   MachPrologNode *prolog = new MachPrologNode();
  82   entry-&gt;map_node(prolog, 0);
<span class="line-modified">  83   _cfg-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified">  84   _cfg-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
  85 
  86   // Virtual methods need an unverified entry point
  87 
<span class="line-modified">  88   if( is_osr_compilation() ) {</span>
  89     if( PoisonOSREntry ) {
  90       // TODO: Should use a ShouldNotReachHereNode...
<span class="line-modified">  91       _cfg-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
  92     }
  93   } else {
<span class="line-modified">  94     if( _method &amp;&amp; !_method-&gt;flags().is_static() ) {</span>
  95       // Insert unvalidated entry point
<span class="line-modified">  96       _cfg-&gt;insert( broot, 0, new MachUEPNode() );</span>
  97     }
  98 
  99   }
 100 
 101   // Break before main entry point
<span class="line-modified"> 102   if ((_method &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified"> 103       (OptoBreakpoint &amp;&amp; is_method_compilation())       ||</span>
<span class="line-modified"> 104       (OptoBreakpointOSR &amp;&amp; is_osr_compilation())       ||</span>
<span class="line-modified"> 105       (OptoBreakpointC2R &amp;&amp; !_method)                   ) {</span>
<span class="line-modified"> 106     // checking for _method means that OptoBreakpoint does not apply to</span>
 107     // runtime stubs or frame converters
<span class="line-modified"> 108     _cfg-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 109   }
 110 
 111   // Insert epilogs before every return
<span class="line-modified"> 112   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 113     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 114     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == _cfg-&gt;get_root_block()) { // Found a program exit point?</span>
 115       Node* m = block-&gt;end();
 116       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 117         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 118         block-&gt;add_inst(epilog);
<span class="line-modified"> 119         _cfg-&gt;map_node_to_block(epilog, block);</span>
 120       }
 121     }
 122   }
 123 
 124   // Keeper of sizing aspects
<span class="line-modified"> 125   BufferSizingData buf_sizes = BufferSizingData();</span>
 126 
 127   // Initialize code buffer
<span class="line-modified"> 128   estimate_buffer_size(buf_sizes._const);</span>
<span class="line-modified"> 129   if (failing()) return;</span>
 130 
 131   // Pre-compute the length of blocks and replace
 132   // long branches with short if machine supports it.
 133   // Must be done before ScheduleAndBundle due to SPARC delay slots
<span class="line-modified"> 134   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, _cfg-&gt;number_of_blocks() + 1);</span>
 135   blk_starts[0] = 0;
<span class="line-modified"> 136   shorten_branches(blk_starts, buf_sizes);</span>
 137 
 138   ScheduleAndBundle();
<span class="line-modified"> 139   if (failing()) {</span>
 140     return;
 141   }
 142 
<span class="line-modified"> 143   // Late barrier analysis must be done after schedule and bundle</span>
<span class="line-removed"> 144   // Otherwise liveness based spilling will fail</span>
<span class="line-removed"> 145   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-removed"> 146   bs-&gt;late_barrier_analysis();</span>
<span class="line-removed"> 147 </span>
<span class="line-removed"> 148 #ifdef X86</span>
<span class="line-removed"> 149   if (VM_Version::has_intel_jcc_erratum()) {</span>
<span class="line-removed"> 150     int extra_padding = IntelJccErratum::tag_affected_machnodes(this, _cfg, _regalloc);</span>
<span class="line-removed"> 151     buf_sizes._code += extra_padding;</span>
<span class="line-removed"> 152   }</span>
<span class="line-removed"> 153 #endif</span>
 154 
 155   // Complete sizing of codebuffer
<span class="line-modified"> 156   CodeBuffer* cb = init_buffer(buf_sizes);</span>
<span class="line-modified"> 157   if (cb == NULL || failing()) {</span>
 158     return;
 159   }
 160 
 161   BuildOopMaps();
 162 
<span class="line-modified"> 163   if (failing())  {</span>
 164     return;
 165   }
 166 
 167   fill_buffer(cb, blk_starts);
 168 }
 169 
<span class="line-modified"> 170 bool Compile::need_stack_bang(int frame_size_in_bytes) const {</span>
 171   // Determine if we need to generate a stack overflow check.
 172   // Do it if the method is not a stub function and
 173   // has java calls or has frame size &gt; vm_page_size/8.
 174   // The debug VM checks that deoptimization doesn&#39;t trigger an
 175   // unexpected stack overflow (compiled method stack banging should
 176   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 177   // a debug VM.
<span class="line-modified"> 178   return (UseStackBanging &amp;&amp; stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 179           (has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 180            DEBUG_ONLY(|| true)));
 181 }
 182 
<span class="line-modified"> 183 bool Compile::need_register_stack_bang() const {</span>
 184   // Determine if we need to generate a register stack overflow check.
 185   // This is only used on architectures which have split register
 186   // and memory stacks (ie. IA64).
 187   // Bang if the method is not a stub function and has java calls
<span class="line-modified"> 188   return (stub_function() == NULL &amp;&amp; has_java_calls());</span>
 189 }
 190 
 191 
 192 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 193 // of a loop. When aligning a loop we need to provide enough instructions
 194 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 195 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 196 // By default, the size is set to 999999 by Block&#39;s constructor so that
 197 // a loop will be aligned if the size is not reset here.
 198 //
 199 // Note: Mach instructions could contain several HW instructions
 200 // so the size is estimated only.
 201 //
<span class="line-modified"> 202 void Compile::compute_loop_first_inst_sizes() {</span>
 203   // The next condition is used to gate the loop alignment optimization.
 204   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 205   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 206   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 207   // equal to 11 bytes which is the largest address NOP instruction.
 208   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<span class="line-modified"> 209     uint last_block = _cfg-&gt;number_of_blocks() - 1;</span>
 210     for (uint i = 1; i &lt;= last_block; i++) {
<span class="line-modified"> 211       Block* block = _cfg-&gt;get_block(i);</span>
 212       // Check the first loop&#39;s block which requires an alignment.
 213       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 214         uint sum_size = 0;
 215         uint inst_cnt = NumberOfLoopInstrToAlign;
<span class="line-modified"> 216         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 217 
 218         // Check subsequent fallthrough blocks if the loop&#39;s first
 219         // block(s) does not have enough instructions.
 220         Block *nb = block;
 221         while(inst_cnt &gt; 0 &amp;&amp;
 222               i &lt; last_block &amp;&amp;
<span class="line-modified"> 223               !_cfg-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 224               !nb-&gt;has_successor(block)) {
 225           i++;
<span class="line-modified"> 226           nb = _cfg-&gt;get_block(i);</span>
<span class="line-modified"> 227           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, _regalloc);</span>
 228         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 229 
 230         block-&gt;set_first_inst_size(sum_size);
 231       } // f( b-&gt;head()-&gt;is_Loop() )
 232     } // for( i &lt;= last_block )
 233   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 234 }
 235 
 236 // The architecture description provides short branch variants for some long
 237 // branch instructions. Replace eligible long branches with short branches.
<span class="line-modified"> 238 void Compile::shorten_branches(uint* blk_starts, BufferSizingData&amp; buf_sizes) {</span>
 239   // Compute size of each block, method size, and relocation information size
<span class="line-modified"> 240   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
 241 
 242   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 243   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 244   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 245 
 246   // Collect worst case block paddings
 247   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 248   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 249 
 250   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 251   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 252 
 253   bool has_short_branch_candidate = false;
 254 
 255   // Initialize the sizes to 0
 256   int code_size  = 0;          // Size in bytes of generated code
 257   int stub_size  = 0;          // Size in bytes of all stub entries
 258   // Size in bytes of all relocation entries, including those in local stubs.
 259   // Start with 2-bytes of reloc info for the unvalidated entry point
 260   int reloc_size = 1;          // Number of relocation entries
 261 
 262   // Make three passes.  The first computes pessimistic blk_starts,
 263   // relative jmp_offset and reloc_size information.  The second performs
 264   // short branch substitution using the pessimistic sizing.  The
 265   // third inserts nops where needed.
 266 
 267   // Step one, perform a pessimistic sizing pass.
 268   uint last_call_adr = max_juint;
 269   uint last_avoid_back_to_back_adr = max_juint;
<span class="line-modified"> 270   uint nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
 271   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<span class="line-modified"> 272     Block* block = _cfg-&gt;get_block(i);</span>

 273 
 274     // During short branch replacement, we store the relative (to blk_starts)
 275     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 276     // This is so that we do not need to recompute sizes of all nodes when
 277     // we compute correct blk_starts in our next sizing pass.
 278     jmp_offset[i] = 0;
 279     jmp_size[i]   = 0;
 280     jmp_nidx[i]   = -1;
 281     DEBUG_ONLY( jmp_target[i] = 0; )
 282     DEBUG_ONLY( jmp_rule[i]   = 0; )
 283 
 284     // Sum all instruction sizes to compute block size
 285     uint last_inst = block-&gt;number_of_nodes();
 286     uint blk_size = 0;
 287     for (uint j = 0; j &lt; last_inst; j++) {
<span class="line-modified"> 288       Node* nj = block-&gt;get_node(j);</span>

 289       // Handle machine instruction nodes
 290       if (nj-&gt;is_Mach()) {
<span class="line-modified"> 291         MachNode *mach = nj-&gt;as_Mach();</span>
 292         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding
<span class="line-removed"> 293 #ifdef X86</span>
<span class="line-removed"> 294         if (VM_Version::has_intel_jcc_erratum() &amp;&amp; IntelJccErratum::is_jcc_erratum_branch(block, mach, j)) {</span>
<span class="line-removed"> 295           // Conservatively add worst case padding</span>
<span class="line-removed"> 296           blk_size += IntelJccErratum::largest_jcc_size();</span>
<span class="line-removed"> 297         }</span>
<span class="line-removed"> 298 #endif</span>
<span class="line-removed"> 299 </span>
 300         reloc_size += mach-&gt;reloc();
 301         if (mach-&gt;is_MachCall()) {
 302           // add size information for trampoline stub
 303           // class CallStubImpl is platform-specific and defined in the *.ad files.
 304           stub_size  += CallStubImpl::size_call_trampoline();
 305           reloc_size += CallStubImpl::reloc_call_trampoline();
 306 
 307           MachCallNode *mcall = mach-&gt;as_MachCall();
 308           // This destination address is NOT PC-relative
 309 
 310           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 311 
 312           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 313             stub_size  += CompiledStaticCall::to_interp_stub_size();
 314             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 315 #if INCLUDE_AOT
 316             stub_size  += CompiledStaticCall::to_aot_stub_size();
 317             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 318 #endif
 319           }
</pre>
<hr />
<pre>
 326             blk_size += nop_size;
 327           }
 328         }
 329         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 330           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 331           // ScheduleAndBundle() can rearrange nodes in a block,
 332           // check for all offsets inside this block.
 333           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 334             blk_size += nop_size;
 335           }
 336         }
 337         if (mach-&gt;may_be_short_branch()) {
 338           if (!nj-&gt;is_MachBranch()) {
 339 #ifndef PRODUCT
 340             nj-&gt;dump(3);
 341 #endif
 342             Unimplemented();
 343           }
 344           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 345           jmp_offset[i] = blk_size;
<span class="line-modified"> 346           jmp_size[i]   = nj-&gt;size(_regalloc);</span>
 347           jmp_nidx[i]   = j;
 348           has_short_branch_candidate = true;
 349         }
 350       }
<span class="line-modified"> 351       blk_size += nj-&gt;size(_regalloc);</span>
 352       // Remember end of call offset
 353       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 354         last_call_adr = blk_starts[i]+blk_size;
 355       }
 356       // Remember end of avoid_back_to_back offset
 357       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 358         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 359       }
 360     }
 361 
 362     // When the next block starts a loop, we may insert pad NOP
 363     // instructions.  Since we cannot know our future alignment,
 364     // assume the worst.
 365     if (i &lt; nblocks - 1) {
<span class="line-modified"> 366       Block* nb = _cfg-&gt;get_block(i + 1);</span>
 367       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 368       if (max_loop_pad &gt; 0) {
 369         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 370         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 371         // If either is the last instruction in this block, bump by
 372         // max_loop_pad in lock-step with blk_size, so sizing
 373         // calculations in subsequent blocks still can conservatively
 374         // detect that it may the last instruction in this block.
 375         if (last_call_adr == blk_starts[i]+blk_size) {
 376           last_call_adr += max_loop_pad;
 377         }
 378         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 379           last_avoid_back_to_back_adr += max_loop_pad;
 380         }
 381         blk_size += max_loop_pad;
 382         block_worst_case_pad[i + 1] = max_loop_pad;
 383       }
 384     }
 385 
 386     // Save block size; update total method size
 387     blk_starts[i+1] = blk_starts[i]+blk_size;
 388   }
 389 
 390   // Step two, replace eligible long jumps.
 391   bool progress = true;
 392   uint last_may_be_short_branch_adr = max_juint;
 393   while (has_short_branch_candidate &amp;&amp; progress) {
 394     progress = false;
 395     has_short_branch_candidate = false;
 396     int adjust_block_start = 0;
 397     for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified"> 398       Block* block = _cfg-&gt;get_block(i);</span>
 399       int idx = jmp_nidx[i];
 400       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 401       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 402 #ifdef ASSERT
 403         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 404         int j;
 405         // Find the branch; ignore trailing NOPs.
 406         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 407           Node* n = block-&gt;get_node(j);
 408           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 409             break;
 410         }
 411         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 412 #endif
 413         int br_size = jmp_size[i];
 414         int br_offs = blk_starts[i] + jmp_offset[i];
 415 
 416         // This requires the TRUE branch target be in succs[0]
 417         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 418         int offset = blk_starts[bnum] - br_offs;
 419         if (bnum &gt; i) { // adjust following block&#39;s offset
 420           offset -= adjust_block_start;
 421         }
 422 
 423         // This block can be a loop header, account for the padding
 424         // in the previous block.
 425         int block_padding = block_worst_case_pad[i];
 426         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 427         // In the following code a nop could be inserted before
 428         // the branch which will increase the backward distance.
 429         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 430         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 431 
 432         if (needs_padding &amp;&amp; offset &lt;= 0)
 433           offset -= nop_size;
 434 
<span class="line-modified"> 435         if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 436           // We&#39;ve got a winner.  Replace this branch.
 437           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 438 
 439           // Update the jmp_size.
<span class="line-modified"> 440           int new_size = replacement-&gt;size(_regalloc);</span>
 441           int diff     = br_size - new_size;
 442           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 443           // Conservatively take into account padding between
 444           // avoid_back_to_back branches. Previous branch could be
 445           // converted into avoid_back_to_back branch during next
 446           // rounds.
 447           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 448             jmp_offset[i] += nop_size;
 449             diff -= nop_size;
 450           }
 451           adjust_block_start += diff;
 452           block-&gt;map_node(replacement, idx);
 453           mach-&gt;subsume_by(replacement, C);
 454           mach = replacement;
 455           progress = true;
 456 
 457           jmp_size[i] = new_size;
 458           DEBUG_ONLY( jmp_target[i] = bnum; );
 459           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 460         } else {
 461           // The jump distance is not short, try again during next iteration.
 462           has_short_branch_candidate = true;
 463         }
 464       } // (mach-&gt;may_be_short_branch())
 465       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 466                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 467         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 468       }
 469       blk_starts[i+1] -= adjust_block_start;
 470     }
 471   }
 472 
 473 #ifdef ASSERT
 474   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 475     if (jmp_target[i] != 0) {
 476       int br_size = jmp_size[i];
 477       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified"> 478       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 479         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 480       }
<span class="line-modified"> 481       assert(_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 482     }
 483   }
 484 #endif
 485 
 486   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 487   // after ScheduleAndBundle().
 488 
 489   // ------------------
 490   // Compute size for code buffer
 491   code_size = blk_starts[nblocks];
 492 
 493   // Relocation records
 494   reloc_size += 1;              // Relo entry for exception handler
 495 
 496   // Adjust reloc_size to number of record of relocation info
 497   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 498   // a relocation index.
 499   // The CodeBuffer will expand the locs array if this estimate is too low.
 500   reloc_size *= 10 / sizeof(relocInfo);
 501 
<span class="line-modified"> 502   buf_sizes._reloc = reloc_size;</span>
<span class="line-modified"> 503   buf_sizes._code  = code_size;</span>
<span class="line-modified"> 504   buf_sizes._stub  = stub_size;</span>
 505 }
 506 
 507 //------------------------------FillLocArray-----------------------------------
 508 // Create a bit of debug info and append it to the array.  The mapping is from
 509 // Java local or expression stack to constant, register or stack-slot.  For
 510 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 511 // entry has been taken care of and caller should skip it).
 512 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 513   // This should never have accepted Bad before
 514   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 515   return (OptoReg::is_reg(regnum))
 516          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 517          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 518 }
 519 
 520 
 521 ObjectValue*
<span class="line-modified"> 522 Compile::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 523   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 524     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 525     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 526     if (sv-&gt;id() == id) {
 527       return sv;
 528     }
 529   }
 530   // Otherwise..
 531   return NULL;
 532 }
 533 
<span class="line-modified"> 534 void Compile::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 535                                      ObjectValue* sv ) {
 536   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 537   objs-&gt;append(sv);
 538 }
 539 
 540 
<span class="line-modified"> 541 void Compile::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 542                             GrowableArray&lt;ScopeValue*&gt; *array,
 543                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 544   assert( local, &quot;use _top instead of null&quot; );
 545   if (array-&gt;length() != idx) {
 546     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 547     // Old functionality:
 548     //   return
 549     // New functionality:
 550     //   Assert if the local is not top. In product mode let the new node
 551     //   override the old entry.
<span class="line-modified"> 552     assert(local == top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 553     if (local == top()) {</span>
 554       return;
 555     }
 556     array-&gt;pop();
 557   }
 558   const Type *t = local-&gt;bottom_type();
 559 
 560   // Is it a safepoint scalar object node?
 561   if (local-&gt;is_SafePointScalarObject()) {
 562     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 563 
<span class="line-modified"> 564     ObjectValue* sv = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 565     if (sv == NULL) {
 566       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 567       assert(cik-&gt;is_instance_klass() ||
 568              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 569       sv = new ObjectValue(spobj-&gt;_idx,
 570                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 571       Compile::set_sv_for_object_node(objs, sv);</span>
 572 
 573       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 574       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 575         Node* fld_node = sfpt-&gt;in(first_ind+i);
 576         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 577       }
 578     }
 579     array-&gt;append(sv);
 580     return;
 581   }
 582 
 583   // Grab the register number for the local
<span class="line-modified"> 584   OptoReg::Name regnum = _regalloc-&gt;get_reg_first(local);</span>
 585   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 586     // Record the double as two float registers.
 587     // The register mask for such a value always specifies two adjacent
 588     // float registers, with the lower register number even.
 589     // Normally, the allocation of high and low words to these registers
 590     // is irrelevant, because nearly all operations on register pairs
 591     // (e.g., StoreD) treat them as a single unit.
 592     // Here, we assume in addition that the words in these two registers
 593     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 594     // within the interpreter) such that the lower-numbered register
 595     // is written to the lower memory address.  This may seem like
 596     // a machine dependency, but it is not--it is a requirement on
 597     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 598     // even/odd double-register pair to which a double may be allocated,
 599     // the word in the even single-register is stored to the first
 600     // memory word.  (Note that register numbers are completely
 601     // arbitrary, and are not tied to any machine-level encodings.)
 602 #ifdef _LP64
 603     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 604       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 605       array-&gt;append(new_loc_value( _regalloc, regnum, Location::dbl ));</span>
 606     } else if ( t-&gt;base() == Type::Long ) {
 607       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 608       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 609     } else if ( t-&gt;base() == Type::RawPtr ) {
 610       // jsr/ret return address which must be restored into a the full
 611       // width 64-bit stack slot.
<span class="line-modified"> 612       array-&gt;append(new_loc_value( _regalloc, regnum, Location::lng ));</span>
 613     }
 614 #else //_LP64
 615 #ifdef SPARC
 616     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 617       // For SPARC we have to swap high and low words for
 618       // long values stored in a single-register (g0-g7).
<span class="line-modified"> 619       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
<span class="line-modified"> 620       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
 621     } else
 622 #endif //SPARC
 623     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 624       // Repack the double/long as two jints.
 625       // The convention the interpreter uses is that the second local
 626       // holds the first raw word of the native double representation.
 627       // This is actually reasonable, since locals and stack arrays
 628       // grow downwards in all implementations.
 629       // (If, on some machine, the interpreter&#39;s Java locals or stack
 630       // were to grow upwards, the embedded doubles would be word-swapped.)
<span class="line-modified"> 631       array-&gt;append(new_loc_value( _regalloc, OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 632       array-&gt;append(new_loc_value( _regalloc,              regnum   , Location::normal ));</span>
 633     }
 634 #endif //_LP64
 635     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 636              OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 637       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::float_in_double()</span>
 638                                                       ? Location::float_in_dbl : Location::normal ));
 639     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 640       array-&gt;append(new_loc_value( _regalloc, regnum, Matcher::int_in_long</span>
 641                                                       ? Location::int_in_long : Location::normal ));
 642     } else if( t-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 643       array-&gt;append(new_loc_value( _regalloc, regnum, Location::narrowoop ));</span>
 644     } else {
<span class="line-modified"> 645       array-&gt;append(new_loc_value( _regalloc, regnum, _regalloc-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 646     }
 647     return;
 648   }
 649 
 650   // No register.  It must be constant data.
 651   switch (t-&gt;base()) {
 652     case Type::Half:              // Second half of a double
 653       ShouldNotReachHere();       // Caller should skip 2nd halves
 654       break;
 655     case Type::AnyPtr:
 656       array-&gt;append(new ConstantOopWriteValue(NULL));
 657       break;
 658     case Type::AryPtr:
 659     case Type::InstPtr:          // fall through
 660       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 661       break;
 662     case Type::NarrowOop:
 663       if (t == TypeNarrowOop::NULL_PTR) {
 664         array-&gt;append(new ConstantOopWriteValue(NULL));
 665       } else {
</pre>
<hr />
<pre>
 717     // grow downwards in all implementations.
 718     // (If, on some machine, the interpreter&#39;s Java locals or stack
 719     // were to grow upwards, the embedded doubles would be word-swapped.)
 720     jlong_accessor acc;
 721     acc.long_value = d;
 722     array-&gt;append(new ConstantIntValue(acc.words[1]));
 723     array-&gt;append(new ConstantIntValue(acc.words[0]));
 724 #endif
 725       break;
 726     }
 727     case Type::Top:               // Add an illegal value here
 728       array-&gt;append(new LocationValue(Location()));
 729       break;
 730     default:
 731       ShouldNotReachHere();
 732       break;
 733   }
 734 }
 735 
 736 // Determine if this node starts a bundle
<span class="line-modified"> 737 bool Compile::starts_bundle(const Node *n) const {</span>
 738   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 739           _node_bundling_base[n-&gt;_idx].starts_bundle());
 740 }
 741 
 742 //--------------------------Process_OopMap_Node--------------------------------
<span class="line-modified"> 743 void Compile::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>
<span class="line-removed"> 744 </span>
 745   // Handle special safepoint nodes for synchronization
 746   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 747   MachCallNode      *mcall;
 748 
 749   int safepoint_pc_offset = current_offset;
 750   bool is_method_handle_invoke = false;
 751   bool return_oop = false;
 752 
 753   // Add the safepoint in the DebugInfoRecorder
 754   if( !mach-&gt;is_MachCall() ) {
 755     mcall = NULL;
<span class="line-modified"> 756     debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 757   } else {
 758     mcall = mach-&gt;as_MachCall();
 759 
 760     // Is the call a MethodHandle call?
 761     if (mcall-&gt;is_MachCallJava()) {
 762       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<span class="line-modified"> 763         assert(has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
 764         is_method_handle_invoke = true;
 765       }
 766     }
 767 
 768     // Check if a call returns an object.
 769     if (mcall-&gt;returns_pointer()) {
 770       return_oop = true;
 771     }
 772     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<span class="line-modified"> 773     debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
 774   }
 775 
 776   // Loop over the JVMState list to add scope information
 777   // Do not skip safepoints with a NULL method, they need monitor info
 778   JVMState* youngest_jvms = sfn-&gt;jvms();
 779   int max_depth = youngest_jvms-&gt;depth();
 780 
 781   // Allocate the object pool for scalar-replaced objects -- the map from
 782   // small-integer keys (which can be recorded in the local and ostack
 783   // arrays) to descriptions of the object state.
 784   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 785 
 786   // Visit scopes from oldest to youngest.
 787   for (int depth = 1; depth &lt;= max_depth; depth++) {
 788     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 789     int idx;
 790     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 791     // Safepoints that do not have method() set only provide oop-map and monitor info
 792     // to support GC; these do not support deoptimization.
 793     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
</pre>
<hr />
<pre>
 815             !method-&gt;is_synchronized() ||
 816             method-&gt;is_native() ||
 817             num_mon &gt; 0 ||
 818             !GenerateSynchronizationCode,
 819             &quot;monitors must always exist for synchronized methods&quot;);
 820 
 821     // Build the growable array of ScopeValues for exp stack
 822     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
 823 
 824     // Loop over monitors and insert into array
 825     for (idx = 0; idx &lt; num_mon; idx++) {
 826       // Grab the node that defines this monitor
 827       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
 828       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
 829 
 830       // Create ScopeValue for object
 831       ScopeValue *scval = NULL;
 832 
 833       if (obj_node-&gt;is_SafePointScalarObject()) {
 834         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<span class="line-modified"> 835         scval = Compile::sv_for_node_id(objs, spobj-&gt;_idx);</span>
 836         if (scval == NULL) {
 837           const Type *t = spobj-&gt;bottom_type();
 838           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 839           assert(cik-&gt;is_instance_klass() ||
 840                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 841           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
 842                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 843           Compile::set_sv_for_object_node(objs, sv);</span>
 844 
 845           uint first_ind = spobj-&gt;first_index(youngest_jvms);
 846           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 847             Node* fld_node = sfn-&gt;in(first_ind+i);
 848             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
 849           }
 850           scval = sv;
 851         }
 852       } else if (!obj_node-&gt;is_Con()) {
<span class="line-modified"> 853         OptoReg::Name obj_reg = _regalloc-&gt;get_reg_first(obj_node);</span>
 854         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 855           scval = new_loc_value( _regalloc, obj_reg, Location::narrowoop );</span>
 856         } else {
<span class="line-modified"> 857           scval = new_loc_value( _regalloc, obj_reg, Location::oop );</span>
 858         }
 859       } else {
 860         const TypePtr *tp = obj_node-&gt;get_ptr_type();
 861         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
 862       }
 863 
 864       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<span class="line-modified"> 865       Location basic_lock = Location::new_stk_loc(Location::normal,_regalloc-&gt;reg2offset(box_reg));</span>
 866       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
 867       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
 868     }
 869 
 870     // We dump the object pool first, since deoptimization reads it in first.
<span class="line-modified"> 871     debug_info()-&gt;dump_object_pool(objs);</span>
 872 
 873     // Build first class objects to pass to scope
<span class="line-modified"> 874     DebugToken *locvals = debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified"> 875     DebugToken *expvals = debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified"> 876     DebugToken *monvals = debug_info()-&gt;create_monitor_values(monarray);</span>
 877 
 878     // Make method available for all Safepoints
<span class="line-modified"> 879     ciMethod* scope_method = method ? method : _method;</span>
 880     // Describe the scope here
 881     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
 882     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
 883     // Now we can describe the scope.
 884     methodHandle null_mh;
 885     bool rethrow_exception = false;
<span class="line-modified"> 886     debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);</span>
 887   } // End jvms loop
 888 
 889   // Mark the end of the scope set.
<span class="line-modified"> 890   debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
 891 }
 892 
 893 
 894 
 895 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
 896 class NonSafepointEmitter {
 897     Compile*  C;
 898     JVMState* _pending_jvms;
 899     int       _pending_offset;
 900 
 901     void emit_non_safepoint();
 902 
 903  public:
 904     NonSafepointEmitter(Compile* compile) {
 905       this-&gt;C = compile;
 906       _pending_jvms = NULL;
 907       _pending_offset = 0;
 908     }
 909 
 910     void observe_instruction(Node* n, int pc_offset) {
</pre>
<hr />
<pre>
 958   DebugInformationRecorder* debug_info = C-&gt;debug_info();
 959   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
 960 
 961   debug_info-&gt;add_non_safepoint(pc_offset);
 962   int max_depth = youngest_jvms-&gt;depth();
 963 
 964   // Visit scopes from oldest to youngest.
 965   for (int depth = 1; depth &lt;= max_depth; depth++) {
 966     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 967     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 968     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
 969     methodHandle null_mh;
 970     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
 971   }
 972 
 973   // Mark the end of the scope set.
 974   debug_info-&gt;end_non_safepoint(pc_offset);
 975 }
 976 
 977 //------------------------------init_buffer------------------------------------
<span class="line-modified"> 978 void Compile::estimate_buffer_size(int&amp; const_req) {</span>
 979 
 980   // Set the initially allocated size
 981   const_req = initial_const_capacity;
 982 
 983   // The extra spacing after the code is necessary on some platforms.
 984   // Sometimes we need to patch in a jump after the last instruction,
 985   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
 986 
 987   // Compute the byte offset where we can store the deopt pc.
<span class="line-modified"> 988   if (fixed_slots() != 0) {</span>
<span class="line-modified"> 989     _orig_pc_slot_offset_in_bytes = _regalloc-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
 990   }
 991 
 992   // Compute prolog code size
 993   _method_size = 0;
<span class="line-modified"> 994   _frame_slots = OptoReg::reg2stack(_matcher-&gt;_old_SP) + _regalloc-&gt;_framesize;</span>
 995 #if defined(IA64) &amp;&amp; !defined(AIX)
 996   if (save_argument_registers()) {
 997     // 4815101: this is a stub with implicit and unknown precision fp args.
 998     // The usual spill mechanism can only generate stfd&#39;s in this case, which
 999     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1000     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1001     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1002     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1003     //
1004     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1005     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1006     // instead of stfd/stfs/ldfd/ldfs.
1007     _frame_slots += 8*(16/BytesPerInt);
1008   }
1009 #endif
1010   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1011 
<span class="line-modified">1012   if (has_mach_constant_base_node()) {</span>
1013     uint add_size = 0;
1014     // Fill the constant table.
1015     // Note:  This must happen before shorten_branches.
<span class="line-modified">1016     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1017       Block* b = _cfg-&gt;get_block(i);</span>
1018 
1019       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1020         Node* n = b-&gt;get_node(j);
1021 
1022         // If the node is a MachConstantNode evaluate the constant
1023         // value section.
1024         if (n-&gt;is_MachConstant()) {
1025           MachConstantNode* machcon = n-&gt;as_MachConstant();
1026           machcon-&gt;eval_constant(C);
1027         } else if (n-&gt;is_Mach()) {
1028           // On Power there are more nodes that issue constants.
1029           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1030         }
1031       }
1032     }
1033 
1034     // Calculate the offsets of the constants and the size of the
1035     // constant table (including the padding to the next section).
1036     constant_table().calculate_offsets_and_size();
1037     const_req = constant_table().size() + add_size;
1038   }
1039 
1040   // Initialize the space for the BufferBlob used to find and verify
1041   // instruction size in MachNode::emit_size()
1042   init_scratch_buffer_blob(const_req);
1043 }
1044 
<span class="line-modified">1045 CodeBuffer* Compile::init_buffer(BufferSizingData&amp; buf_sizes) {</span>
<span class="line-modified">1046 </span>
<span class="line-modified">1047   int stub_req  = buf_sizes._stub;</span>
<span class="line-modified">1048   int code_req  = buf_sizes._code;</span>
<span class="line-removed">1049   int const_req = buf_sizes._const;</span>
1050 
1051   int pad_req   = NativeCall::instruction_size;
1052 
1053   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1054   stub_req += bs-&gt;estimate_stub_size();
1055 
1056   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1057   // class HandlerImpl is platform-specific and defined in the *.ad files.
1058   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1059   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1060   stub_req += MAX_stubs_size;   // ensure per-stub margin
1061   code_req += MAX_inst_size;    // ensure per-instruction margin
1062 
1063   if (StressCodeBuffers)
1064     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1065 
1066   int total_req =
1067           const_req +
1068           code_req +
1069           pad_req +
1070           stub_req +
1071           exception_handler_req +
1072           deopt_handler_req;               // deopt handler
1073 
<span class="line-modified">1074   if (has_method_handle_invokes())</span>
1075     total_req += deopt_handler_req;  // deopt MH handler
1076 
1077   CodeBuffer* cb = code_buffer();
<span class="line-modified">1078   cb-&gt;initialize(total_req, buf_sizes._reloc);</span>
1079 
1080   // Have we run out of code space?
1081   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1082     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1083     return NULL;
1084   }
1085   // Configure the code buffer.
1086   cb-&gt;initialize_consts_size(const_req);
1087   cb-&gt;initialize_stubs_size(stub_req);
<span class="line-modified">1088   cb-&gt;initialize_oop_recorder(env()-&gt;oop_recorder());</span>
1089 
1090   // fill in the nop array for bundling computations
1091   MachNode *_nop_list[Bundle::_nop_count];
1092   Bundle::initialize_nops(_nop_list);
1093 
1094   return cb;
1095 }
1096 
1097 //------------------------------fill_buffer------------------------------------
<span class="line-modified">1098 void Compile::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1099   // blk_starts[] contains offsets calculated during short branches processing,
1100   // offsets should not be increased during following steps.
1101 
1102   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1103   // of a loop. It is used to determine the padding for loop alignment.
1104   compute_loop_first_inst_sizes();
1105 
1106   // Create oopmap set.
1107   _oop_map_set = new OopMapSet();
1108 
1109   // !!!!! This preserves old handling of oopmaps for now
<span class="line-modified">1110   debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1111 
<span class="line-modified">1112   uint nblocks  = _cfg-&gt;number_of_blocks();</span>
1113   // Count and start of implicit null check instructions
1114   uint inct_cnt = 0;
1115   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1116 
1117   // Count and start of calls
1118   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1119 
1120   uint  return_offset = 0;
<span class="line-modified">1121   int nop_size = (new MachNopNode())-&gt;size(_regalloc);</span>
1122 
1123   int previous_offset = 0;
1124   int current_offset  = 0;
1125   int last_call_offset = -1;
1126   int last_avoid_back_to_back_offset = -1;
1127 #ifdef ASSERT
1128   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1129   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1130   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1131   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1132 #endif
1133 
1134   // Create an array of unused labels, one for each basic block, if printing is enabled
1135 #if defined(SUPPORT_OPTO_ASSEMBLY)
1136   int *node_offsets      = NULL;
<span class="line-modified">1137   uint node_offset_limit = unique();</span>
1138 
<span class="line-modified">1139   if (print_assembly()) {</span>
1140     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1141   }
1142   if (node_offsets != NULL) {
1143     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1144     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1145   }
1146 #endif
1147 
<span class="line-modified">1148   NonSafepointEmitter non_safepoints(this);  // emit non-safepoints lazily</span>
1149 
1150   // Emit the constant table.
<span class="line-modified">1151   if (has_mach_constant_base_node()) {</span>
1152     constant_table().emit(*cb);
1153   }
1154 
1155   // Create an array of labels, one for each basic block
1156   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1157   for (uint i=0; i &lt;= nblocks; i++) {
1158     blk_labels[i].init();
1159   }
1160 
1161   // ------------------
1162   // Now fill in the code buffer
1163   Node *delay_slot = NULL;
1164 
1165   for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified">1166     Block* block = _cfg-&gt;get_block(i);</span>

1167     Node* head = block-&gt;head();
1168 
1169     // If this block needs to start aligned (i.e, can be reached other
1170     // than by falling-thru from the previous block), then force the
1171     // start of a new bundle.
1172     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1173       cb-&gt;flush_bundle(true);
1174     }
1175 
1176 #ifdef ASSERT
1177     if (!block-&gt;is_connector()) {
1178       stringStream st;
<span class="line-modified">1179       block-&gt;dump_head(_cfg, &amp;st);</span>
1180       MacroAssembler(cb).block_comment(st.as_string());
1181     }
1182     jmp_target[i] = 0;
1183     jmp_offset[i] = 0;
1184     jmp_size[i]   = 0;
1185     jmp_rule[i]   = 0;
1186 #endif
1187     int blk_offset = current_offset;
1188 
1189     // Define the label at the beginning of the basic block
1190     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1191 
1192     uint last_inst = block-&gt;number_of_nodes();
1193 
1194     // Emit block normally, except for last instruction.
1195     // Emit means &quot;dump code bits into code buffer&quot;.
1196     for (uint j = 0; j&lt;last_inst; j++) {

1197 
1198       // Get the node
1199       Node* n = block-&gt;get_node(j);
1200 
1201       // See if delay slots are supported
<span class="line-modified">1202       if (valid_bundle_info(n) &amp;&amp;</span>
<span class="line-removed">1203           node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>
1204         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<span class="line-modified">1205         assert(n-&gt;size(_regalloc) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1206 
1207         delay_slot = n;
1208         continue;
1209       }
1210 
1211       // If this starts a new instruction group, then flush the current one
1212       // (but allow split bundles)
1213       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1214         cb-&gt;flush_bundle(false);
1215 
1216       // Special handling for SafePoint/Call Nodes
1217       bool is_mcall = false;
1218       if (n-&gt;is_Mach()) {
1219         MachNode *mach = n-&gt;as_Mach();
1220         is_mcall = n-&gt;is_MachCall();
1221         bool is_sfn = n-&gt;is_MachSafePoint();
1222 
1223         // If this requires all previous instructions be flushed, then do so
1224         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1225           cb-&gt;flush_bundle(true);
1226           current_offset = cb-&gt;insts_size();
1227         }
1228 
1229         // A padding may be needed again since a previous instruction
1230         // could be moved to delay slot.
1231 
1232         // align the instruction if necessary
1233         int padding = mach-&gt;compute_padding(current_offset);
1234         // Make sure safepoint node for polling is distinct from a call&#39;s
1235         // return by adding a nop if needed.
1236         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1237           padding = nop_size;
1238         }
1239         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1240             current_offset == last_avoid_back_to_back_offset) {
1241           // Avoid back to back some instructions.
1242           padding = nop_size;
1243         }
<span class="line-removed">1244 #ifdef X86</span>
<span class="line-removed">1245         if (mach-&gt;flags() &amp; Node::Flag_intel_jcc_erratum) {</span>
<span class="line-removed">1246           assert(padding == 0, &quot;can&#39;t have contradicting padding requirements&quot;);</span>
<span class="line-removed">1247           padding = IntelJccErratum::compute_padding(current_offset, mach, block, j, _regalloc);</span>
<span class="line-removed">1248         }</span>
<span class="line-removed">1249 #endif</span>
1250 
1251         if (padding &gt; 0) {
1252           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1253           int nops_cnt = padding / nop_size;
1254           MachNode *nop = new MachNopNode(nops_cnt);
1255           block-&gt;insert_node(nop, j++);
1256           last_inst++;
<span class="line-modified">1257           _cfg-&gt;map_node_to_block(nop, block);</span>
1258           // Ensure enough space.
1259           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1260           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1261             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1262             return;
1263           }
<span class="line-modified">1264           nop-&gt;emit(*cb, _regalloc);</span>
1265           cb-&gt;flush_bundle(true);
1266           current_offset = cb-&gt;insts_size();
1267         }
1268 
1269         // Remember the start of the last call in a basic block
1270         if (is_mcall) {
1271           MachCallNode *mcall = mach-&gt;as_MachCall();
1272 
1273           // This destination address is NOT PC-relative
1274           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1275 
1276           // Save the return address
1277           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1278 
1279           if (mcall-&gt;is_MachCallLeaf()) {
1280             is_mcall = false;
1281             is_sfn = false;
1282           }
1283         }
1284 
</pre>
<hr />
<pre>
1297 
1298           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1299                                            current_offset);
1300           Process_OopMap_Node(mach, current_offset);
1301         } // End if safepoint
1302 
1303           // If this is a null check, then add the start of the previous instruction to the list
1304         else if( mach-&gt;is_MachNullCheck() ) {
1305           inct_starts[inct_cnt++] = previous_offset;
1306         }
1307 
1308           // If this is a branch, then fill in the label with the target BB&#39;s label
1309         else if (mach-&gt;is_MachBranch()) {
1310           // This requires the TRUE branch target be in succs[0]
1311           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1312 
1313           // Try to replace long branch if delay slot is not used,
1314           // it is mostly for back branches since forward branch&#39;s
1315           // distance is not updated yet.
1316           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<span class="line-modified">1317                                     node_bundling(n)-&gt;use_unconditional_delay();</span>
1318           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1319             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<span class="line-modified">1320             int br_size = n-&gt;size(_regalloc);</span>
1321             int offset = blk_starts[block_num] - current_offset;
1322             if (block_num &gt;= i) {
1323               // Current and following block&#39;s offset are not
1324               // finalized yet, adjust distance by the difference
1325               // between calculated and final offsets of current block.
1326               offset -= (blk_starts[i] - blk_offset);
1327             }
1328             // In the following code a nop could be inserted before
1329             // the branch which will increase the backward distance.
1330             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1331             if (needs_padding &amp;&amp; offset &lt;= 0)
1332               offset -= nop_size;
1333 
<span class="line-modified">1334             if (_matcher-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1335               // We&#39;ve got a winner.  Replace this branch.
1336               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1337 
1338               // Update the jmp_size.
<span class="line-modified">1339               int new_size = replacement-&gt;size(_regalloc);</span>
1340               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1341               // Insert padding between avoid_back_to_back branches.
1342               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1343                 MachNode *nop = new MachNopNode();
1344                 block-&gt;insert_node(nop, j++);
<span class="line-modified">1345                 _cfg-&gt;map_node_to_block(nop, block);</span>
1346                 last_inst++;
<span class="line-modified">1347                 nop-&gt;emit(*cb, _regalloc);</span>
1348                 cb-&gt;flush_bundle(true);
1349                 current_offset = cb-&gt;insts_size();
1350               }
1351 #ifdef ASSERT
1352               jmp_target[i] = block_num;
1353               jmp_offset[i] = current_offset - blk_offset;
1354               jmp_size[i]   = new_size;
1355               jmp_rule[i]   = mach-&gt;rule();
1356 #endif
1357               block-&gt;map_node(replacement, j);
1358               mach-&gt;subsume_by(replacement, C);
1359               n    = replacement;
1360               mach = replacement;
1361             }
1362           }
1363           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1364         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1365           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1366             Block* succs_block = block-&gt;_succs[h];
1367             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
</pre>
<hr />
<pre>
1409           inct_starts[inct_cnt++] = current_offset;
1410         }
1411       }
1412 
1413       // Verify that there is sufficient space remaining
1414       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1415       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1416         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1417         return;
1418       }
1419 
1420       // Save the offset for the listing
1421 #if defined(SUPPORT_OPTO_ASSEMBLY)
1422       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1423         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1424       }
1425 #endif
1426 
1427       // &quot;Normal&quot; instruction case
1428       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<span class="line-modified">1429       n-&gt;emit(*cb, _regalloc);</span>
1430       current_offset  = cb-&gt;insts_size();
1431 
1432       // Above we only verified that there is enough space in the instruction section.
1433       // However, the instruction may emit stubs that cause code buffer expansion.
1434       // Bail out here if expansion failed due to a lack of code cache space.
<span class="line-modified">1435       if (failing()) {</span>
1436         return;
1437       }
1438 
1439 #ifdef ASSERT
<span class="line-modified">1440       if (n-&gt;size(_regalloc) &lt; (current_offset-instr_offset)) {</span>
1441         n-&gt;dump();
1442         assert(false, &quot;wrong size of mach node&quot;);
1443       }
1444 #endif
1445       non_safepoints.observe_instruction(n, current_offset);
1446 
1447       // mcall is last &quot;call&quot; that can be a safepoint
1448       // record it so we can see if a poll will directly follow it
1449       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1450       // see  5010568. This can be slightly inaccurate but conservative
1451       // in the case that return address is not actually at current_offset.
1452       // This is a small price to pay.
1453 
1454       if (is_mcall) {
1455         last_call_offset = current_offset;
1456       }
1457 
1458       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1459         // Avoid back to back some instructions.
1460         last_avoid_back_to_back_offset = current_offset;
</pre>
<hr />
<pre>
1475 #endif
1476 
1477         // Support a SafePoint in the delay slot
1478         if (delay_slot-&gt;is_MachSafePoint()) {
1479           MachNode *mach = delay_slot-&gt;as_Mach();
1480           // !!!!! Stubs only need an oopmap right now, so bail out
1481           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1482             // Write the oopmap directly to the code blob??!!
1483             delay_slot = NULL;
1484             continue;
1485           }
1486 
1487           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1488           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1489                                            adjusted_offset);
1490           // Generate an OopMap entry
1491           Process_OopMap_Node(mach, adjusted_offset);
1492         }
1493 
1494         // Insert the delay slot instruction
<span class="line-modified">1495         delay_slot-&gt;emit(*cb, _regalloc);</span>
1496 
1497         // Don&#39;t reuse it
1498         delay_slot = NULL;
1499       }
1500 
1501     } // End for all instructions in block
1502 
1503     // If the next block is the top of a loop, pad this block out to align
1504     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1505     if (i &lt; nblocks-1) {
<span class="line-modified">1506       Block *nb = _cfg-&gt;get_block(i + 1);</span>
1507       int padding = nb-&gt;alignment_padding(current_offset);
1508       if( padding &gt; 0 ) {
1509         MachNode *nop = new MachNopNode(padding / nop_size);
1510         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<span class="line-modified">1511         _cfg-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1512         nop-&gt;emit(*cb, _regalloc);</span>
1513         current_offset = cb-&gt;insts_size();
1514       }
1515     }
1516     // Verify that the distance for generated before forward
1517     // short branches is still valid.
1518     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1519 
1520     // Save new block start offset
1521     blk_starts[i] = blk_offset;
1522   } // End of for all blocks
1523   blk_starts[nblocks] = current_offset;
1524 
1525   non_safepoints.flush_at_end();
1526 
1527   // Offset too large?
<span class="line-modified">1528   if (failing())  return;</span>
1529 
1530   // Define a pseudo-label at the end of the code
1531   MacroAssembler(cb).bind( blk_labels[nblocks] );
1532 
1533   // Compute the size of the first block
1534   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1535 
1536 #ifdef ASSERT
1537   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1538     if (jmp_target[i] != 0) {
1539       int br_size = jmp_size[i];
1540       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified">1541       if (!_matcher-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1542         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1543         assert(false, &quot;Displacement too large for short jmp&quot;);
1544       }
1545     }
1546   }
1547 #endif
1548 
1549   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1550   bs-&gt;emit_stubs(*cb);
<span class="line-modified">1551   if (failing())  return;</span>
1552 
1553 #ifndef PRODUCT
1554   // Information on the size of the method, without the extraneous code
1555   Scheduling::increment_method_size(cb-&gt;insts_size());
1556 #endif
1557 
1558   // ------------------
1559   // Fill in exception table entries.
1560   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1561 
1562   // Only java methods have exception handlers and deopt handlers
1563   // class HandlerImpl is platform-specific and defined in the *.ad files.
<span class="line-modified">1564   if (_method) {</span>
1565     // Emit the exception handler code.
1566     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<span class="line-modified">1567     if (failing()) {</span>
1568       return; // CodeBuffer::expand failed
1569     }
1570     // Emit the deopt handler code.
1571     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1572 
1573     // Emit the MethodHandle deopt handler code (if required).
<span class="line-modified">1574     if (has_method_handle_invokes() &amp;&amp; !failing()) {</span>
1575       // We can use the same code as for the normal deopt handler, we
1576       // just need a different entry point address.
1577       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1578     }
1579   }
1580 
1581   // One last check for failed CodeBuffer::expand:
1582   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1583     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1584     return;
1585   }
1586 
1587 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<span class="line-modified">1588   if (print_assembly()) {</span>
1589     tty-&gt;cr();
1590     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1591   }
1592 #endif
1593 
1594 #if defined(SUPPORT_OPTO_ASSEMBLY)
1595   // Dump the assembly code, including basic-block numbers
<span class="line-modified">1596   if (print_assembly()) {</span>
1597     ttyLocker ttyl;  // keep the following output all in one block
1598     if (!VMThread::should_terminate()) {  // test this under the tty lock
1599       // This output goes directly to the tty, not the compiler log.
1600       // To enable tools to match it up with the compilation activity,
1601       // be sure to tag this tty output with the compile ID.
1602       if (xtty != NULL) {
<span class="line-modified">1603         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, compile_id(),</span>
<span class="line-modified">1604                    is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1605                    &quot;&quot;);
1606       }
<span class="line-modified">1607       if (method() != NULL) {</span>
<span class="line-modified">1608         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, compile_id());</span>
<span class="line-modified">1609         method()-&gt;print_metadata();</span>
<span class="line-modified">1610       } else if (stub_name() != NULL) {</span>
<span class="line-modified">1611         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, stub_name());</span>
1612       }
1613       tty-&gt;cr();
<span class="line-modified">1614       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, compile_id());</span>
1615       dump_asm(node_offsets, node_offset_limit);
1616       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1617       if (xtty != NULL) {
1618         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1619         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1620         // thread safe
1621         ttyLocker ttyl2;
1622         xtty-&gt;tail(&quot;opto_assembly&quot;);
1623       }
1624     }
1625   }
1626 #endif
1627 }
1628 
<span class="line-modified">1629 void Compile::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1630   _inc_table.set_size(cnt);
1631 
1632   uint inct_cnt = 0;
<span class="line-modified">1633   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1634     Block* block = _cfg-&gt;get_block(i);</span>
1635     Node *n = NULL;
1636     int j;
1637 
1638     // Find the branch; ignore trailing NOPs.
1639     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1640       n = block-&gt;get_node(j);
1641       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1642         break;
1643       }
1644     }
1645 
1646     // If we didn&#39;t find anything, continue
1647     if (j &lt; 0) {
1648       continue;
1649     }
1650 
1651     // Compute ExceptionHandlerTable subtable entry and add it
1652     // (skip empty blocks)
1653     if (n-&gt;is_Catch()) {
1654 
</pre>
<hr />
<pre>
1659       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1660       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1661 #endif
1662       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1663       int nof_succs = block-&gt;_num_succs;
1664       // allocate space
1665       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1666       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1667       // iterate through all successors
1668       for (int j = 0; j &lt; nof_succs; j++) {
1669         Block* s = block-&gt;_succs[j];
1670         bool found_p = false;
1671         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1672           Node* pk = s-&gt;pred(k);
1673           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1674             const CatchProjNode* p = pk-&gt;as_CatchProj();
1675             found_p = true;
1676             // add the corresponding handler bci &amp; pco information
1677             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1678               // p leads to an exception handler (and is not fall through)
<span class="line-modified">1679               assert(s == _cfg-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1680               // no duplicates, please
1681               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1682                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1683                 handler_bcis.append(p-&gt;handler_bci());
1684                 handler_pcos.append(blk_labels[block_num].loc_pos());
1685               }
1686             }
1687           }
1688         }
1689         assert(found_p, &quot;no matching predecessor found&quot;);
1690         // Note:  Due to empty block removal, one block may have
1691         // several CatchProj inputs, from the same Catch.
1692       }
1693 
1694       // Set the offset of the return from the call
1695       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1696       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1697       continue;
1698     }
1699 
</pre>
<hr />
<pre>
1731           _available(arena),
1732           _reg_node(arena),
1733           _pinch_free_list(arena),
1734           _next_node(NULL),
1735           _bundle_instr_count(0),
1736           _bundle_cycle_number(0),
1737           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1738 #ifndef PRODUCT
1739         , _branches(0)
1740         , _unconditional_delays(0)
1741 #endif
1742 {
1743   // Create a MachNopNode
1744   _nop = new MachNopNode();
1745 
1746   // Now that the nops are in the array, save the count
1747   // (but allow entries for the nops)
1748   _node_bundling_limit = compile.unique();
1749   uint node_max = _regalloc-&gt;node_regs_max_index();
1750 
<span class="line-modified">1751   compile.set_node_bundling_limit(_node_bundling_limit);</span>
1752 
1753   // This one is persistent within the Compile class
1754   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1755 
1756   // Allocate space for fixed-size arrays
1757   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1758   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1759   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1760 
1761   // Clear the arrays
1762   for (uint i = 0; i &lt; node_max; i++) {
1763     ::new (&amp;_node_bundling_base[i]) Bundle();
1764   }
1765   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1766   memset(_uses,               0, node_max * sizeof(short));
1767   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1768 
1769   // Clear the bundling information
1770   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1771 
</pre>
<hr />
<pre>
1807 
1808   // Update the bundle record
1809   if (_bundle_instr_count &gt; 0) {
1810     bundle-&gt;set_instr_count(_bundle_instr_count);
1811     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1812 
1813     _bundle_cycle_number += 1;
1814   }
1815 
1816   // Clear the bundling information
1817   _bundle_instr_count = 0;
1818   _bundle_use.reset();
1819 
1820   memcpy(_bundle_use_elements,
1821          Pipeline_Use::elaborated_elements,
1822          sizeof(Pipeline_Use::elaborated_elements));
1823 }
1824 
1825 // Perform instruction scheduling and bundling over the sequence of
1826 // instructions in backwards order.
<span class="line-modified">1827 void Compile::ScheduleAndBundle() {</span>
1828 
1829   // Don&#39;t optimize this if it isn&#39;t a method
<span class="line-modified">1830   if (!_method)</span>
1831     return;
1832 
1833   // Don&#39;t optimize this if scheduling is disabled
<span class="line-modified">1834   if (!do_scheduling())</span>
1835     return;
1836 
1837   // Scheduling code works only with pairs (16 bytes) maximum.
<span class="line-modified">1838   if (max_vector_size() &gt; 16)</span>
1839     return;
1840 
<span class="line-modified">1841   TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
1842 
1843   // Create a data structure for all the scheduling information
<span class="line-modified">1844   Scheduling scheduling(Thread::current()-&gt;resource_area(), *this);</span>
1845 
1846   // Walk backwards over each basic block, computing the needed alignment
1847   // Walk over all the basic blocks
1848   scheduling.DoScheduling();
1849 
1850 #ifndef PRODUCT
<span class="line-modified">1851   if (trace_opto_output()) {</span>
1852     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<span class="line-modified">1853     for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
1854       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<span class="line-modified">1855       Block* block = _cfg-&gt;get_block(i);</span>
1856       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
1857         Node* n = block-&gt;get_node(j);
<span class="line-modified">1858         OptoReg::Name reg = _regalloc-&gt;get_reg_first(n);</span>
1859         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
1860         n-&gt;dump();
1861       }
1862     }
1863   }
1864 #endif
1865 }
1866 
1867 // Compute the latency of all the instructions.  This is fairly simple,
1868 // because we already have a legal ordering.  Walk over the instructions
1869 // from first to last, and compute the latency of the instruction based
1870 // on the latency of the preceding instruction(s).
1871 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
1872 #ifndef PRODUCT
1873   if (_cfg-&gt;C-&gt;trace_opto_output())
1874     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
1875 #endif
1876 
1877   // Walk over all the schedulable instructions
1878   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
</pre>
<hr />
<pre>
2380 #endif
2381   }
2382 
2383 #ifndef PRODUCT
2384   if (_cfg-&gt;C-&gt;trace_opto_output())
2385     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2386 #endif
2387 }
2388 
2389 // This routine performs scheduling on each basic block in reverse order,
2390 // using instruction latencies and taking into account function unit
2391 // availability.
2392 void Scheduling::DoScheduling() {
2393 #ifndef PRODUCT
2394   if (_cfg-&gt;C-&gt;trace_opto_output())
2395     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2396 #endif
2397 
2398   Block *succ_bb = NULL;
2399   Block *bb;

2400 
2401   // Walk over all the basic blocks in reverse order
2402   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2403     bb = _cfg-&gt;get_block(i);
2404 
2405 #ifndef PRODUCT
2406     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2407       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2408       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2409         bb-&gt;get_node(j)-&gt;dump();
2410       }
2411     }
2412 #endif
2413 
2414     // On the head node, skip processing
2415     if (bb == _cfg-&gt;get_root_block()) {
2416       continue;
2417     }
2418 
2419     // Skip empty, connector blocks
</pre>
<hr />
<pre>
2467         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2468       // There might be a prior call.  Skip it.
2469       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2470     } else if( last-&gt;is_MachNullCheck() ) {
2471       // Backup so the last null-checked memory instruction is
2472       // outside the schedulable range. Skip over the nullcheck,
2473       // projection, and the memory nodes.
2474       Node *mem = last-&gt;in(1);
2475       do {
2476         _bb_end--;
2477       } while (mem != bb-&gt;get_node(_bb_end));
2478     } else {
2479       // Set _bb_end to point after last schedulable inst.
2480       _bb_end++;
2481     }
2482 
2483     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2484 
2485     // Compute the register antidependencies for the basic block
2486     ComputeRegisterAntidependencies(bb);
<span class="line-modified">2487     if (_cfg-&gt;C-&gt;failing())  return;  // too many D-U pinch points</span>
2488 
2489     // Compute intra-bb latencies for the nodes
2490     ComputeLocalLatenciesForward(bb);
2491 
2492     // Compute the usage within the block, and set the list of all nodes
2493     // in the block that have no uses within the block.
2494     ComputeUseCount(bb);
2495 
2496     // Schedule the remaining instructions in the block
2497     while ( _available.size() &gt; 0 ) {
2498       Node *n = ChooseNodeToBundle();
2499       guarantee(n != NULL, &quot;no nodes available&quot;);
2500       AddNodeToBundle(n,bb);
2501     }
2502 
2503     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2504 #ifdef ASSERT
2505     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2506       Node *n = bb-&gt;get_node(l);
2507       uint m;
</pre>
<hr />
<pre>
2527           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2528             tty-&gt;print(&quot;*** Bundle: &quot;);
2529             bundle-&gt;dump();
2530           }
2531           n-&gt;dump();
2532         }
2533       }
2534     }
2535 #endif
2536 #ifdef ASSERT
2537     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2538 #endif
2539   }
2540 
2541 #ifndef PRODUCT
2542   if (_cfg-&gt;C-&gt;trace_opto_output())
2543     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2544 #endif
2545 
2546   // Record final node-bundling array location
<span class="line-modified">2547   _regalloc-&gt;C-&gt;set_node_bundling_base(_node_bundling_base);</span>
2548 
2549 } // end DoScheduling
2550 
2551 // Verify that no live-range used in the block is killed in the block by a
2552 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2553 
2554 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2555 static bool edge_from_to( Node *from, Node *to ) {
2556   for( uint i=0; i&lt;from-&gt;len(); i++ )
2557     if( from-&gt;in(i) == to )
2558       return true;
2559   return false;
2560 }
2561 
2562 #ifdef ASSERT
2563 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2564   // Check for bad kills
2565   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2566     Node *prior_use = _reg_node[def];
2567     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
</pre>
<hr />
<pre>
2634     from-&gt;add_prec(to);
2635 }
2636 
2637 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2638   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2639     return;
2640 
2641   Node *pinch = _reg_node[def_reg]; // Get pinch point
2642   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2643       is_def ) {    // Check for a true def (not a kill)
2644     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2645     return;
2646   }
2647 
2648   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2649   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2650 
2651   // After some number of kills there _may_ be a later def
2652   Node *later_def = NULL;
2653 


2654   // Finding a kill requires a real pinch-point.
2655   // Check for not already having a pinch-point.
2656   // Pinch points are Op_Node&#39;s.
2657   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2658     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2659     if ( _pinch_free_list.size() &gt; 0) {
2660       pinch = _pinch_free_list.pop();
2661     } else {
2662       pinch = new Node(1); // Pinch point to-be
2663     }
2664     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2665       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2666       return;
2667     }
2668     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2669     _reg_node.map(def_reg,pinch); // Record pinch-point
<span class="line-modified">2670     //_regalloc-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2671     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<span class="line-modified">2672       pinch-&gt;init_req(0, _cfg-&gt;C-&gt;top());     // set not NULL for the next call</span>
2673       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2674       later_def = NULL;           // and no later def
2675     }
2676     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2677   } else {                        // Else have valid pinch point
2678     if( pinch-&gt;in(0) )            // If there is a later-def
2679       later_def = pinch-&gt;in(0);   // Get it
2680   }
2681 
2682   // Add output-dependence edge from later def to kill
2683   if( later_def )               // If there is some original def
2684     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2685 
2686   // See if current kill is also a use, and so is forced to be the pinch-point.
2687   if( pinch-&gt;Opcode() == Op_Node ) {
2688     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2689     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2690       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2691           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2692         // Yes, found a use/kill pinch-point
</pre>
<hr />
<pre>
2955                _total_branches, _total_unconditional_delays);
2956     if (_total_branches &gt; 0)
2957       tty-&gt;print(&quot;, for %.2f%%&quot;,
2958                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
2959     tty-&gt;print(&quot;\n&quot;);
2960   }
2961 
2962   uint total_instructions = 0, total_bundles = 0;
2963 
2964   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
2965     uint bundle_count   = _total_instructions_per_bundle[i];
2966     total_instructions += bundle_count * i;
2967     total_bundles      += bundle_count;
2968   }
2969 
2970   if (total_bundles &gt; 0)
2971     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
2972                ((double)total_instructions) / ((double)total_bundles));
2973 }
2974 #endif































































































































































































































































































































































</pre>
</td>
<td>
<hr />
<pre>
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;asm/assembler.inline.hpp&quot;
  27 #include &quot;asm/macroAssembler.inline.hpp&quot;
  28 #include &quot;code/compiledIC.hpp&quot;
  29 #include &quot;code/debugInfo.hpp&quot;
  30 #include &quot;code/debugInfoRec.hpp&quot;
  31 #include &quot;compiler/compileBroker.hpp&quot;
  32 #include &quot;compiler/compilerDirectives.hpp&quot;
  33 #include &quot;compiler/oopMap.hpp&quot;
  34 #include &quot;gc/shared/barrierSet.hpp&quot;
  35 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  36 #include &quot;memory/allocation.inline.hpp&quot;
  37 #include &quot;opto/ad.hpp&quot;
<span class="line-added">  38 #include &quot;opto/block.hpp&quot;</span>
<span class="line-added">  39 #include &quot;opto/c2compiler.hpp&quot;</span>
  40 #include &quot;opto/callnode.hpp&quot;
  41 #include &quot;opto/cfgnode.hpp&quot;
  42 #include &quot;opto/locknode.hpp&quot;
  43 #include &quot;opto/machnode.hpp&quot;
<span class="line-added">  44 #include &quot;opto/node.hpp&quot;</span>
  45 #include &quot;opto/optoreg.hpp&quot;
  46 #include &quot;opto/output.hpp&quot;
  47 #include &quot;opto/regalloc.hpp&quot;
  48 #include &quot;opto/runtime.hpp&quot;
  49 #include &quot;opto/subnode.hpp&quot;
  50 #include &quot;opto/type.hpp&quot;
  51 #include &quot;runtime/handles.inline.hpp&quot;
<span class="line-added">  52 #include &quot;runtime/sharedRuntime.hpp&quot;</span>
  53 #include &quot;utilities/macros.hpp&quot;
  54 #include &quot;utilities/powerOfTwo.hpp&quot;
  55 #include &quot;utilities/xmlstream.hpp&quot;



  56 
  57 #ifndef PRODUCT
  58 #define DEBUG_ARG(x) , x
  59 #else
  60 #define DEBUG_ARG(x)
  61 #endif
  62 
<span class="line-added">  63 //------------------------------Scheduling----------------------------------</span>
<span class="line-added">  64 // This class contains all the information necessary to implement instruction</span>
<span class="line-added">  65 // scheduling and bundling.</span>
<span class="line-added">  66 class Scheduling {</span>
<span class="line-added">  67 </span>
<span class="line-added">  68 private:</span>
<span class="line-added">  69   // Arena to use</span>
<span class="line-added">  70   Arena *_arena;</span>
<span class="line-added">  71 </span>
<span class="line-added">  72   // Control-Flow Graph info</span>
<span class="line-added">  73   PhaseCFG *_cfg;</span>
<span class="line-added">  74 </span>
<span class="line-added">  75   // Register Allocation info</span>
<span class="line-added">  76   PhaseRegAlloc *_regalloc;</span>
<span class="line-added">  77 </span>
<span class="line-added">  78   // Number of nodes in the method</span>
<span class="line-added">  79   uint _node_bundling_limit;</span>
<span class="line-added">  80 </span>
<span class="line-added">  81   // List of scheduled nodes. Generated in reverse order</span>
<span class="line-added">  82   Node_List _scheduled;</span>
<span class="line-added">  83 </span>
<span class="line-added">  84   // List of nodes currently available for choosing for scheduling</span>
<span class="line-added">  85   Node_List _available;</span>
<span class="line-added">  86 </span>
<span class="line-added">  87   // For each instruction beginning a bundle, the number of following</span>
<span class="line-added">  88   // nodes to be bundled with it.</span>
<span class="line-added">  89   Bundle *_node_bundling_base;</span>
<span class="line-added">  90 </span>
<span class="line-added">  91   // Mapping from register to Node</span>
<span class="line-added">  92   Node_List _reg_node;</span>
<span class="line-added">  93 </span>
<span class="line-added">  94   // Free list for pinch nodes.</span>
<span class="line-added">  95   Node_List _pinch_free_list;</span>
<span class="line-added">  96 </span>
<span class="line-added">  97   // Latency from the beginning of the containing basic block (base 1)</span>
<span class="line-added">  98   // for each node.</span>
<span class="line-added">  99   unsigned short *_node_latency;</span>
<span class="line-added"> 100 </span>
<span class="line-added"> 101   // Number of uses of this node within the containing basic block.</span>
<span class="line-added"> 102   short *_uses;</span>
<span class="line-added"> 103 </span>
<span class="line-added"> 104   // Schedulable portion of current block.  Skips Region/Phi/CreateEx up</span>
<span class="line-added"> 105   // front, branch+proj at end.  Also skips Catch/CProj (same as</span>
<span class="line-added"> 106   // branch-at-end), plus just-prior exception-throwing call.</span>
<span class="line-added"> 107   uint _bb_start, _bb_end;</span>
<span class="line-added"> 108 </span>
<span class="line-added"> 109   // Latency from the end of the basic block as scheduled</span>
<span class="line-added"> 110   unsigned short *_current_latency;</span>
<span class="line-added"> 111 </span>
<span class="line-added"> 112   // Remember the next node</span>
<span class="line-added"> 113   Node *_next_node;</span>
<span class="line-added"> 114 </span>
<span class="line-added"> 115   // Use this for an unconditional branch delay slot</span>
<span class="line-added"> 116   Node *_unconditional_delay_slot;</span>
<span class="line-added"> 117 </span>
<span class="line-added"> 118   // Pointer to a Nop</span>
<span class="line-added"> 119   MachNopNode *_nop;</span>
<span class="line-added"> 120 </span>
<span class="line-added"> 121   // Length of the current bundle, in instructions</span>
<span class="line-added"> 122   uint _bundle_instr_count;</span>
<span class="line-added"> 123 </span>
<span class="line-added"> 124   // Current Cycle number, for computing latencies and bundling</span>
<span class="line-added"> 125   uint _bundle_cycle_number;</span>
<span class="line-added"> 126 </span>
<span class="line-added"> 127   // Bundle information</span>
<span class="line-added"> 128   Pipeline_Use_Element _bundle_use_elements[resource_count];</span>
<span class="line-added"> 129   Pipeline_Use         _bundle_use;</span>
<span class="line-added"> 130 </span>
<span class="line-added"> 131   // Dump the available list</span>
<span class="line-added"> 132   void dump_available() const;</span>
<span class="line-added"> 133 </span>
<span class="line-added"> 134 public:</span>
<span class="line-added"> 135   Scheduling(Arena *arena, Compile &amp;compile);</span>
<span class="line-added"> 136 </span>
<span class="line-added"> 137   // Destructor</span>
<span class="line-added"> 138   NOT_PRODUCT( ~Scheduling(); )</span>
<span class="line-added"> 139 </span>
<span class="line-added"> 140   // Step ahead &quot;i&quot; cycles</span>
<span class="line-added"> 141   void step(uint i);</span>
<span class="line-added"> 142 </span>
<span class="line-added"> 143   // Step ahead 1 cycle, and clear the bundle state (for example,</span>
<span class="line-added"> 144   // at a branch target)</span>
<span class="line-added"> 145   void step_and_clear();</span>
<span class="line-added"> 146 </span>
<span class="line-added"> 147   Bundle* node_bundling(const Node *n) {</span>
<span class="line-added"> 148     assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-added"> 149     return (&amp;_node_bundling_base[n-&gt;_idx]);</span>
<span class="line-added"> 150   }</span>
<span class="line-added"> 151 </span>
<span class="line-added"> 152   bool valid_bundle_info(const Node *n) const {</span>
<span class="line-added"> 153     return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-added"> 154   }</span>
<span class="line-added"> 155 </span>
<span class="line-added"> 156   bool starts_bundle(const Node *n) const {</span>
<span class="line-added"> 157     return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp; _node_bundling_base[n-&gt;_idx].starts_bundle());</span>
<span class="line-added"> 158   }</span>
<span class="line-added"> 159 </span>
<span class="line-added"> 160   // Do the scheduling</span>
<span class="line-added"> 161   void DoScheduling();</span>
<span class="line-added"> 162 </span>
<span class="line-added"> 163   // Compute the local latencies walking forward over the list of</span>
<span class="line-added"> 164   // nodes for a basic block</span>
<span class="line-added"> 165   void ComputeLocalLatenciesForward(const Block *bb);</span>
<span class="line-added"> 166 </span>
<span class="line-added"> 167   // Compute the register antidependencies within a basic block</span>
<span class="line-added"> 168   void ComputeRegisterAntidependencies(Block *bb);</span>
<span class="line-added"> 169   void verify_do_def( Node *n, OptoReg::Name def, const char *msg );</span>
<span class="line-added"> 170   void verify_good_schedule( Block *b, const char *msg );</span>
<span class="line-added"> 171   void anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def );</span>
<span class="line-added"> 172   void anti_do_use( Block *b, Node *use, OptoReg::Name use_reg );</span>
<span class="line-added"> 173 </span>
<span class="line-added"> 174   // Add a node to the current bundle</span>
<span class="line-added"> 175   void AddNodeToBundle(Node *n, const Block *bb);</span>
<span class="line-added"> 176 </span>
<span class="line-added"> 177   // Add a node to the list of available nodes</span>
<span class="line-added"> 178   void AddNodeToAvailableList(Node *n);</span>
<span class="line-added"> 179 </span>
<span class="line-added"> 180   // Compute the local use count for the nodes in a block, and compute</span>
<span class="line-added"> 181   // the list of instructions with no uses in the block as available</span>
<span class="line-added"> 182   void ComputeUseCount(const Block *bb);</span>
<span class="line-added"> 183 </span>
<span class="line-added"> 184   // Choose an instruction from the available list to add to the bundle</span>
<span class="line-added"> 185   Node * ChooseNodeToBundle();</span>
<span class="line-added"> 186 </span>
<span class="line-added"> 187   // See if this Node fits into the currently accumulating bundle</span>
<span class="line-added"> 188   bool NodeFitsInBundle(Node *n);</span>
<span class="line-added"> 189 </span>
<span class="line-added"> 190   // Decrement the use count for a node</span>
<span class="line-added"> 191  void DecrementUseCounts(Node *n, const Block *bb);</span>
<span class="line-added"> 192 </span>
<span class="line-added"> 193   // Garbage collect pinch nodes for reuse by other blocks.</span>
<span class="line-added"> 194   void garbage_collect_pinch_nodes();</span>
<span class="line-added"> 195   // Clean up a pinch node for reuse (helper for above).</span>
<span class="line-added"> 196   void cleanup_pinch( Node *pinch );</span>
<span class="line-added"> 197 </span>
<span class="line-added"> 198   // Information for statistics gathering</span>
<span class="line-added"> 199 #ifndef PRODUCT</span>
<span class="line-added"> 200 private:</span>
<span class="line-added"> 201   // Gather information on size of nops relative to total</span>
<span class="line-added"> 202   uint _branches, _unconditional_delays;</span>
<span class="line-added"> 203 </span>
<span class="line-added"> 204   static uint _total_nop_size, _total_method_size;</span>
<span class="line-added"> 205   static uint _total_branches, _total_unconditional_delays;</span>
<span class="line-added"> 206   static uint _total_instructions_per_bundle[Pipeline::_max_instrs_per_cycle+1];</span>
<span class="line-added"> 207 </span>
<span class="line-added"> 208 public:</span>
<span class="line-added"> 209   static void print_statistics();</span>
<span class="line-added"> 210 </span>
<span class="line-added"> 211   static void increment_instructions_per_bundle(uint i) {</span>
<span class="line-added"> 212     _total_instructions_per_bundle[i]++;</span>
<span class="line-added"> 213   }</span>
<span class="line-added"> 214 </span>
<span class="line-added"> 215   static void increment_nop_size(uint s) {</span>
<span class="line-added"> 216     _total_nop_size += s;</span>
<span class="line-added"> 217   }</span>
<span class="line-added"> 218 </span>
<span class="line-added"> 219   static void increment_method_size(uint s) {</span>
<span class="line-added"> 220     _total_method_size += s;</span>
<span class="line-added"> 221   }</span>
<span class="line-added"> 222 #endif</span>
<span class="line-added"> 223 </span>
<span class="line-added"> 224 };</span>
<span class="line-added"> 225 </span>
<span class="line-added"> 226 </span>
<span class="line-added"> 227 PhaseOutput::PhaseOutput()</span>
<span class="line-added"> 228   : Phase(Phase::Output),</span>
<span class="line-added"> 229     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-added"> 230     _first_block_size(0),</span>
<span class="line-added"> 231     _handler_table(),</span>
<span class="line-added"> 232     _inc_table(),</span>
<span class="line-added"> 233     _oop_map_set(NULL),</span>
<span class="line-added"> 234     _scratch_buffer_blob(NULL),</span>
<span class="line-added"> 235     _scratch_locs_memory(NULL),</span>
<span class="line-added"> 236     _scratch_const_size(-1),</span>
<span class="line-added"> 237     _in_scratch_emit_size(false),</span>
<span class="line-added"> 238     _frame_slots(0),</span>
<span class="line-added"> 239     _code_offsets(),</span>
<span class="line-added"> 240     _node_bundling_limit(0),</span>
<span class="line-added"> 241     _node_bundling_base(NULL),</span>
<span class="line-added"> 242     _orig_pc_slot(0),</span>
<span class="line-added"> 243     _orig_pc_slot_offset_in_bytes(0),</span>
<span class="line-added"> 244     _buf_sizes(),</span>
<span class="line-added"> 245     _block(NULL),</span>
<span class="line-added"> 246     _index(0) {</span>
<span class="line-added"> 247   C-&gt;set_output(this);</span>
<span class="line-added"> 248   if (C-&gt;stub_name() == NULL) {</span>
<span class="line-added"> 249     _orig_pc_slot = C-&gt;fixed_slots() - (sizeof(address) / VMRegImpl::stack_slot_size);</span>
<span class="line-added"> 250   }</span>
<span class="line-added"> 251 }</span>
<span class="line-added"> 252 </span>
<span class="line-added"> 253 PhaseOutput::~PhaseOutput() {</span>
<span class="line-added"> 254   C-&gt;set_output(NULL);</span>
<span class="line-added"> 255   if (_scratch_buffer_blob != NULL) {</span>
<span class="line-added"> 256     BufferBlob::free(_scratch_buffer_blob);</span>
<span class="line-added"> 257   }</span>
<span class="line-added"> 258 }</span>
<span class="line-added"> 259 </span>
<span class="line-added"> 260 void PhaseOutput::perform_mach_node_analysis() {</span>
<span class="line-added"> 261   // Late barrier analysis must be done after schedule and bundle</span>
<span class="line-added"> 262   // Otherwise liveness based spilling will fail</span>
<span class="line-added"> 263   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();</span>
<span class="line-added"> 264   bs-&gt;late_barrier_analysis();</span>
<span class="line-added"> 265 </span>
<span class="line-added"> 266   pd_perform_mach_node_analysis();</span>
<span class="line-added"> 267 }</span>
<span class="line-added"> 268 </span>
 269 // Convert Nodes to instruction bits and pass off to the VM
<span class="line-modified"> 270 void PhaseOutput::Output() {</span>
 271   // RootNode goes
<span class="line-modified"> 272   assert( C-&gt;cfg()-&gt;get_root_block()-&gt;number_of_nodes() == 0, &quot;&quot; );</span>
 273 
 274   // The number of new nodes (mostly MachNop) is proportional to
 275   // the number of java calls and inner loops which are aligned.
 276   if ( C-&gt;check_node_count((NodeLimitFudgeFactor + C-&gt;java_calls()*3 +
 277                             C-&gt;inner_loops()*(OptoLoopAlignment-1)),
 278                            &quot;out of nodes before code generation&quot; ) ) {
 279     return;
 280   }
 281   // Make sure I can find the Start Node
<span class="line-modified"> 282   Block *entry = C-&gt;cfg()-&gt;get_block(1);</span>
<span class="line-modified"> 283   Block *broot = C-&gt;cfg()-&gt;get_root_block();</span>
 284 
 285   const StartNode *start = entry-&gt;head()-&gt;as_Start();
 286 
 287   // Replace StartNode with prolog
 288   MachPrologNode *prolog = new MachPrologNode();
 289   entry-&gt;map_node(prolog, 0);
<span class="line-modified"> 290   C-&gt;cfg()-&gt;map_node_to_block(prolog, entry);</span>
<span class="line-modified"> 291   C-&gt;cfg()-&gt;unmap_node_from_block(start); // start is no longer in any block</span>
 292 
 293   // Virtual methods need an unverified entry point
 294 
<span class="line-modified"> 295   if( C-&gt;is_osr_compilation() ) {</span>
 296     if( PoisonOSREntry ) {
 297       // TODO: Should use a ShouldNotReachHereNode...
<span class="line-modified"> 298       C-&gt;cfg()-&gt;insert( broot, 0, new MachBreakpointNode() );</span>
 299     }
 300   } else {
<span class="line-modified"> 301     if( C-&gt;method() &amp;&amp; !C-&gt;method()-&gt;flags().is_static() ) {</span>
 302       // Insert unvalidated entry point
<span class="line-modified"> 303       C-&gt;cfg()-&gt;insert( broot, 0, new MachUEPNode() );</span>
 304     }
 305 
 306   }
 307 
 308   // Break before main entry point
<span class="line-modified"> 309   if ((C-&gt;method() &amp;&amp; C-&gt;directive()-&gt;BreakAtExecuteOption) ||</span>
<span class="line-modified"> 310       (OptoBreakpoint &amp;&amp; C-&gt;is_method_compilation())       ||</span>
<span class="line-modified"> 311       (OptoBreakpointOSR &amp;&amp; C-&gt;is_osr_compilation())       ||</span>
<span class="line-modified"> 312       (OptoBreakpointC2R &amp;&amp; !C-&gt;method())                   ) {</span>
<span class="line-modified"> 313     // checking for C-&gt;method() means that OptoBreakpoint does not apply to</span>
 314     // runtime stubs or frame converters
<span class="line-modified"> 315     C-&gt;cfg()-&gt;insert( entry, 1, new MachBreakpointNode() );</span>
 316   }
 317 
 318   // Insert epilogs before every return
<span class="line-modified"> 319   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified"> 320     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-modified"> 321     if (!block-&gt;is_connector() &amp;&amp; block-&gt;non_connector_successor(0) == C-&gt;cfg()-&gt;get_root_block()) { // Found a program exit point?</span>
 322       Node* m = block-&gt;end();
 323       if (m-&gt;is_Mach() &amp;&amp; m-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Halt) {
 324         MachEpilogNode* epilog = new MachEpilogNode(m-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Return);
 325         block-&gt;add_inst(epilog);
<span class="line-modified"> 326         C-&gt;cfg()-&gt;map_node_to_block(epilog, block);</span>
 327       }
 328     }
 329   }
 330 
 331   // Keeper of sizing aspects
<span class="line-modified"> 332   _buf_sizes = BufferSizingData();</span>
 333 
 334   // Initialize code buffer
<span class="line-modified"> 335   estimate_buffer_size(_buf_sizes._const);</span>
<span class="line-modified"> 336   if (C-&gt;failing()) return;</span>
 337 
 338   // Pre-compute the length of blocks and replace
 339   // long branches with short if machine supports it.
 340   // Must be done before ScheduleAndBundle due to SPARC delay slots
<span class="line-modified"> 341   uint* blk_starts = NEW_RESOURCE_ARRAY(uint, C-&gt;cfg()-&gt;number_of_blocks() + 1);</span>
 342   blk_starts[0] = 0;
<span class="line-modified"> 343   shorten_branches(blk_starts);</span>
 344 
 345   ScheduleAndBundle();
<span class="line-modified"> 346   if (C-&gt;failing()) {</span>
 347     return;
 348   }
 349 
<span class="line-modified"> 350   perform_mach_node_analysis();</span>










 351 
 352   // Complete sizing of codebuffer
<span class="line-modified"> 353   CodeBuffer* cb = init_buffer();</span>
<span class="line-modified"> 354   if (cb == NULL || C-&gt;failing()) {</span>
 355     return;
 356   }
 357 
 358   BuildOopMaps();
 359 
<span class="line-modified"> 360   if (C-&gt;failing())  {</span>
 361     return;
 362   }
 363 
 364   fill_buffer(cb, blk_starts);
 365 }
 366 
<span class="line-modified"> 367 bool PhaseOutput::need_stack_bang(int frame_size_in_bytes) const {</span>
 368   // Determine if we need to generate a stack overflow check.
 369   // Do it if the method is not a stub function and
 370   // has java calls or has frame size &gt; vm_page_size/8.
 371   // The debug VM checks that deoptimization doesn&#39;t trigger an
 372   // unexpected stack overflow (compiled method stack banging should
 373   // guarantee it doesn&#39;t happen) so we always need the stack bang in
 374   // a debug VM.
<span class="line-modified"> 375   return (UseStackBanging &amp;&amp; C-&gt;stub_function() == NULL &amp;&amp;</span>
<span class="line-modified"> 376           (C-&gt;has_java_calls() || frame_size_in_bytes &gt; os::vm_page_size()&gt;&gt;3</span>
 377            DEBUG_ONLY(|| true)));
 378 }
 379 
<span class="line-modified"> 380 bool PhaseOutput::need_register_stack_bang() const {</span>
 381   // Determine if we need to generate a register stack overflow check.
 382   // This is only used on architectures which have split register
 383   // and memory stacks (ie. IA64).
 384   // Bang if the method is not a stub function and has java calls
<span class="line-modified"> 385   return (C-&gt;stub_function() == NULL &amp;&amp; C-&gt;has_java_calls());</span>
 386 }
 387 
 388 
 389 // Compute the size of first NumberOfLoopInstrToAlign instructions at the top
 390 // of a loop. When aligning a loop we need to provide enough instructions
 391 // in cpu&#39;s fetch buffer to feed decoders. The loop alignment could be
 392 // avoided if we have enough instructions in fetch buffer at the head of a loop.
 393 // By default, the size is set to 999999 by Block&#39;s constructor so that
 394 // a loop will be aligned if the size is not reset here.
 395 //
 396 // Note: Mach instructions could contain several HW instructions
 397 // so the size is estimated only.
 398 //
<span class="line-modified"> 399 void PhaseOutput::compute_loop_first_inst_sizes() {</span>
 400   // The next condition is used to gate the loop alignment optimization.
 401   // Don&#39;t aligned a loop if there are enough instructions at the head of a loop
 402   // or alignment padding is larger then MaxLoopPad. By default, MaxLoopPad
 403   // is equal to OptoLoopAlignment-1 except on new Intel cpus, where it is
 404   // equal to 11 bytes which is the largest address NOP instruction.
 405   if (MaxLoopPad &lt; OptoLoopAlignment - 1) {
<span class="line-modified"> 406     uint last_block = C-&gt;cfg()-&gt;number_of_blocks() - 1;</span>
 407     for (uint i = 1; i &lt;= last_block; i++) {
<span class="line-modified"> 408       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 409       // Check the first loop&#39;s block which requires an alignment.
 410       if (block-&gt;loop_alignment() &gt; (uint)relocInfo::addr_unit()) {
 411         uint sum_size = 0;
 412         uint inst_cnt = NumberOfLoopInstrToAlign;
<span class="line-modified"> 413         inst_cnt = block-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());</span>
 414 
 415         // Check subsequent fallthrough blocks if the loop&#39;s first
 416         // block(s) does not have enough instructions.
 417         Block *nb = block;
 418         while(inst_cnt &gt; 0 &amp;&amp;
 419               i &lt; last_block &amp;&amp;
<span class="line-modified"> 420               !C-&gt;cfg()-&gt;get_block(i + 1)-&gt;has_loop_alignment() &amp;&amp;</span>
 421               !nb-&gt;has_successor(block)) {
 422           i++;
<span class="line-modified"> 423           nb = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-modified"> 424           inst_cnt  = nb-&gt;compute_first_inst_size(sum_size, inst_cnt, C-&gt;regalloc());</span>
 425         } // while( inst_cnt &gt; 0 &amp;&amp; i &lt; last_block  )
 426 
 427         block-&gt;set_first_inst_size(sum_size);
 428       } // f( b-&gt;head()-&gt;is_Loop() )
 429     } // for( i &lt;= last_block )
 430   } // if( MaxLoopPad &lt; OptoLoopAlignment-1 )
 431 }
 432 
 433 // The architecture description provides short branch variants for some long
 434 // branch instructions. Replace eligible long branches with short branches.
<span class="line-modified"> 435 void PhaseOutput::shorten_branches(uint* blk_starts) {</span>
 436   // Compute size of each block, method size, and relocation information size
<span class="line-modified"> 437   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();</span>
 438 
 439   uint*      jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
 440   uint*      jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
 441   int*       jmp_nidx   = NEW_RESOURCE_ARRAY(int ,nblocks);
 442 
 443   // Collect worst case block paddings
 444   int* block_worst_case_pad = NEW_RESOURCE_ARRAY(int, nblocks);
 445   memset(block_worst_case_pad, 0, nblocks * sizeof(int));
 446 
 447   DEBUG_ONLY( uint *jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks); )
 448   DEBUG_ONLY( uint *jmp_rule = NEW_RESOURCE_ARRAY(uint,nblocks); )
 449 
 450   bool has_short_branch_candidate = false;
 451 
 452   // Initialize the sizes to 0
 453   int code_size  = 0;          // Size in bytes of generated code
 454   int stub_size  = 0;          // Size in bytes of all stub entries
 455   // Size in bytes of all relocation entries, including those in local stubs.
 456   // Start with 2-bytes of reloc info for the unvalidated entry point
 457   int reloc_size = 1;          // Number of relocation entries
 458 
 459   // Make three passes.  The first computes pessimistic blk_starts,
 460   // relative jmp_offset and reloc_size information.  The second performs
 461   // short branch substitution using the pessimistic sizing.  The
 462   // third inserts nops where needed.
 463 
 464   // Step one, perform a pessimistic sizing pass.
 465   uint last_call_adr = max_juint;
 466   uint last_avoid_back_to_back_adr = max_juint;
<span class="line-modified"> 467   uint nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());</span>
 468   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
<span class="line-modified"> 469     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-added"> 470     _block = block;</span>
 471 
 472     // During short branch replacement, we store the relative (to blk_starts)
 473     // offset of jump in jmp_offset, rather than the absolute offset of jump.
 474     // This is so that we do not need to recompute sizes of all nodes when
 475     // we compute correct blk_starts in our next sizing pass.
 476     jmp_offset[i] = 0;
 477     jmp_size[i]   = 0;
 478     jmp_nidx[i]   = -1;
 479     DEBUG_ONLY( jmp_target[i] = 0; )
 480     DEBUG_ONLY( jmp_rule[i]   = 0; )
 481 
 482     // Sum all instruction sizes to compute block size
 483     uint last_inst = block-&gt;number_of_nodes();
 484     uint blk_size = 0;
 485     for (uint j = 0; j &lt; last_inst; j++) {
<span class="line-modified"> 486       _index = j;</span>
<span class="line-added"> 487       Node* nj = block-&gt;get_node(_index);</span>
 488       // Handle machine instruction nodes
 489       if (nj-&gt;is_Mach()) {
<span class="line-modified"> 490         MachNode* mach = nj-&gt;as_Mach();</span>
 491         blk_size += (mach-&gt;alignment_required() - 1) * relocInfo::addr_unit(); // assume worst case padding







 492         reloc_size += mach-&gt;reloc();
 493         if (mach-&gt;is_MachCall()) {
 494           // add size information for trampoline stub
 495           // class CallStubImpl is platform-specific and defined in the *.ad files.
 496           stub_size  += CallStubImpl::size_call_trampoline();
 497           reloc_size += CallStubImpl::reloc_call_trampoline();
 498 
 499           MachCallNode *mcall = mach-&gt;as_MachCall();
 500           // This destination address is NOT PC-relative
 501 
 502           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
 503 
 504           if (mcall-&gt;is_MachCallJava() &amp;&amp; mcall-&gt;as_MachCallJava()-&gt;_method) {
 505             stub_size  += CompiledStaticCall::to_interp_stub_size();
 506             reloc_size += CompiledStaticCall::reloc_to_interp_stub();
 507 #if INCLUDE_AOT
 508             stub_size  += CompiledStaticCall::to_aot_stub_size();
 509             reloc_size += CompiledStaticCall::reloc_to_aot_stub();
 510 #endif
 511           }
</pre>
<hr />
<pre>
 518             blk_size += nop_size;
 519           }
 520         }
 521         if (mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 522           // Nop is inserted between &quot;avoid back to back&quot; instructions.
 523           // ScheduleAndBundle() can rearrange nodes in a block,
 524           // check for all offsets inside this block.
 525           if (last_avoid_back_to_back_adr &gt;= blk_starts[i]) {
 526             blk_size += nop_size;
 527           }
 528         }
 529         if (mach-&gt;may_be_short_branch()) {
 530           if (!nj-&gt;is_MachBranch()) {
 531 #ifndef PRODUCT
 532             nj-&gt;dump(3);
 533 #endif
 534             Unimplemented();
 535           }
 536           assert(jmp_nidx[i] == -1, &quot;block should have only one branch&quot;);
 537           jmp_offset[i] = blk_size;
<span class="line-modified"> 538           jmp_size[i]   = nj-&gt;size(C-&gt;regalloc());</span>
 539           jmp_nidx[i]   = j;
 540           has_short_branch_candidate = true;
 541         }
 542       }
<span class="line-modified"> 543       blk_size += nj-&gt;size(C-&gt;regalloc());</span>
 544       // Remember end of call offset
 545       if (nj-&gt;is_MachCall() &amp;&amp; !nj-&gt;is_MachCallLeaf()) {
 546         last_call_adr = blk_starts[i]+blk_size;
 547       }
 548       // Remember end of avoid_back_to_back offset
 549       if (nj-&gt;is_Mach() &amp;&amp; nj-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
 550         last_avoid_back_to_back_adr = blk_starts[i]+blk_size;
 551       }
 552     }
 553 
 554     // When the next block starts a loop, we may insert pad NOP
 555     // instructions.  Since we cannot know our future alignment,
 556     // assume the worst.
 557     if (i &lt; nblocks - 1) {
<span class="line-modified"> 558       Block* nb = C-&gt;cfg()-&gt;get_block(i + 1);</span>
 559       int max_loop_pad = nb-&gt;code_alignment()-relocInfo::addr_unit();
 560       if (max_loop_pad &gt; 0) {
 561         assert(is_power_of_2(max_loop_pad+relocInfo::addr_unit()), &quot;&quot;);
 562         // Adjust last_call_adr and/or last_avoid_back_to_back_adr.
 563         // If either is the last instruction in this block, bump by
 564         // max_loop_pad in lock-step with blk_size, so sizing
 565         // calculations in subsequent blocks still can conservatively
 566         // detect that it may the last instruction in this block.
 567         if (last_call_adr == blk_starts[i]+blk_size) {
 568           last_call_adr += max_loop_pad;
 569         }
 570         if (last_avoid_back_to_back_adr == blk_starts[i]+blk_size) {
 571           last_avoid_back_to_back_adr += max_loop_pad;
 572         }
 573         blk_size += max_loop_pad;
 574         block_worst_case_pad[i + 1] = max_loop_pad;
 575       }
 576     }
 577 
 578     // Save block size; update total method size
 579     blk_starts[i+1] = blk_starts[i]+blk_size;
 580   }
 581 
 582   // Step two, replace eligible long jumps.
 583   bool progress = true;
 584   uint last_may_be_short_branch_adr = max_juint;
 585   while (has_short_branch_candidate &amp;&amp; progress) {
 586     progress = false;
 587     has_short_branch_candidate = false;
 588     int adjust_block_start = 0;
 589     for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified"> 590       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
 591       int idx = jmp_nidx[i];
 592       MachNode* mach = (idx == -1) ? NULL: block-&gt;get_node(idx)-&gt;as_Mach();
 593       if (mach != NULL &amp;&amp; mach-&gt;may_be_short_branch()) {
 594 #ifdef ASSERT
 595         assert(jmp_size[i] &gt; 0 &amp;&amp; mach-&gt;is_MachBranch(), &quot;sanity&quot;);
 596         int j;
 597         // Find the branch; ignore trailing NOPs.
 598         for (j = block-&gt;number_of_nodes()-1; j&gt;=0; j--) {
 599           Node* n = block-&gt;get_node(j);
 600           if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con)
 601             break;
 602         }
 603         assert(j &gt;= 0 &amp;&amp; j == idx &amp;&amp; block-&gt;get_node(j) == (Node*)mach, &quot;sanity&quot;);
 604 #endif
 605         int br_size = jmp_size[i];
 606         int br_offs = blk_starts[i] + jmp_offset[i];
 607 
 608         // This requires the TRUE branch target be in succs[0]
 609         uint bnum = block-&gt;non_connector_successor(0)-&gt;_pre_order;
 610         int offset = blk_starts[bnum] - br_offs;
 611         if (bnum &gt; i) { // adjust following block&#39;s offset
 612           offset -= adjust_block_start;
 613         }
 614 
 615         // This block can be a loop header, account for the padding
 616         // in the previous block.
 617         int block_padding = block_worst_case_pad[i];
 618         assert(i == 0 || block_padding == 0 || br_offs &gt;= block_padding, &quot;Should have at least a padding on top&quot;);
 619         // In the following code a nop could be inserted before
 620         // the branch which will increase the backward distance.
 621         bool needs_padding = ((uint)(br_offs - block_padding) == last_may_be_short_branch_adr);
 622         assert(!needs_padding || jmp_offset[i] == 0, &quot;padding only branches at the beginning of block&quot;);
 623 
 624         if (needs_padding &amp;&amp; offset &lt;= 0)
 625           offset -= nop_size;
 626 
<span class="line-modified"> 627         if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
 628           // We&#39;ve got a winner.  Replace this branch.
 629           MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
 630 
 631           // Update the jmp_size.
<span class="line-modified"> 632           int new_size = replacement-&gt;size(C-&gt;regalloc());</span>
 633           int diff     = br_size - new_size;
 634           assert(diff &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
 635           // Conservatively take into account padding between
 636           // avoid_back_to_back branches. Previous branch could be
 637           // converted into avoid_back_to_back branch during next
 638           // rounds.
 639           if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
 640             jmp_offset[i] += nop_size;
 641             diff -= nop_size;
 642           }
 643           adjust_block_start += diff;
 644           block-&gt;map_node(replacement, idx);
 645           mach-&gt;subsume_by(replacement, C);
 646           mach = replacement;
 647           progress = true;
 648 
 649           jmp_size[i] = new_size;
 650           DEBUG_ONLY( jmp_target[i] = bnum; );
 651           DEBUG_ONLY( jmp_rule[i] = mach-&gt;rule(); );
 652         } else {
 653           // The jump distance is not short, try again during next iteration.
 654           has_short_branch_candidate = true;
 655         }
 656       } // (mach-&gt;may_be_short_branch())
 657       if (mach != NULL &amp;&amp; (mach-&gt;may_be_short_branch() ||
 658                            mach-&gt;avoid_back_to_back(MachNode::AVOID_AFTER))) {
 659         last_may_be_short_branch_adr = blk_starts[i] + jmp_offset[i] + jmp_size[i];
 660       }
 661       blk_starts[i+1] -= adjust_block_start;
 662     }
 663   }
 664 
 665 #ifdef ASSERT
 666   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
 667     if (jmp_target[i] != 0) {
 668       int br_size = jmp_size[i];
 669       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified"> 670       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
 671         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
 672       }
<span class="line-modified"> 673       assert(C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset), &quot;Displacement too large for short jmp&quot;);</span>
 674     }
 675   }
 676 #endif
 677 
 678   // Step 3, compute the offsets of all blocks, will be done in fill_buffer()
 679   // after ScheduleAndBundle().
 680 
 681   // ------------------
 682   // Compute size for code buffer
 683   code_size = blk_starts[nblocks];
 684 
 685   // Relocation records
 686   reloc_size += 1;              // Relo entry for exception handler
 687 
 688   // Adjust reloc_size to number of record of relocation info
 689   // Min is 2 bytes, max is probably 6 or 8, with a tax up to 25% for
 690   // a relocation index.
 691   // The CodeBuffer will expand the locs array if this estimate is too low.
 692   reloc_size *= 10 / sizeof(relocInfo);
 693 
<span class="line-modified"> 694   _buf_sizes._reloc = reloc_size;</span>
<span class="line-modified"> 695   _buf_sizes._code  = code_size;</span>
<span class="line-modified"> 696   _buf_sizes._stub  = stub_size;</span>
 697 }
 698 
 699 //------------------------------FillLocArray-----------------------------------
 700 // Create a bit of debug info and append it to the array.  The mapping is from
 701 // Java local or expression stack to constant, register or stack-slot.  For
 702 // doubles, insert 2 mappings and return 1 (to tell the caller that the next
 703 // entry has been taken care of and caller should skip it).
 704 static LocationValue *new_loc_value( PhaseRegAlloc *ra, OptoReg::Name regnum, Location::Type l_type ) {
 705   // This should never have accepted Bad before
 706   assert(OptoReg::is_valid(regnum), &quot;location must be valid&quot;);
 707   return (OptoReg::is_reg(regnum))
 708          ? new LocationValue(Location::new_reg_loc(l_type, OptoReg::as_VMReg(regnum)) )
 709          : new LocationValue(Location::new_stk_loc(l_type,  ra-&gt;reg2offset(regnum)));
 710 }
 711 
 712 
 713 ObjectValue*
<span class="line-modified"> 714 PhaseOutput::sv_for_node_id(GrowableArray&lt;ScopeValue*&gt; *objs, int id) {</span>
 715   for (int i = 0; i &lt; objs-&gt;length(); i++) {
 716     assert(objs-&gt;at(i)-&gt;is_object(), &quot;corrupt object cache&quot;);
 717     ObjectValue* sv = (ObjectValue*) objs-&gt;at(i);
 718     if (sv-&gt;id() == id) {
 719       return sv;
 720     }
 721   }
 722   // Otherwise..
 723   return NULL;
 724 }
 725 
<span class="line-modified"> 726 void PhaseOutput::set_sv_for_object_node(GrowableArray&lt;ScopeValue*&gt; *objs,</span>
 727                                      ObjectValue* sv ) {
 728   assert(sv_for_node_id(objs, sv-&gt;id()) == NULL, &quot;Precondition&quot;);
 729   objs-&gt;append(sv);
 730 }
 731 
 732 
<span class="line-modified"> 733 void PhaseOutput::FillLocArray( int idx, MachSafePointNode* sfpt, Node *local,</span>
 734                             GrowableArray&lt;ScopeValue*&gt; *array,
 735                             GrowableArray&lt;ScopeValue*&gt; *objs ) {
 736   assert( local, &quot;use _top instead of null&quot; );
 737   if (array-&gt;length() != idx) {
 738     assert(array-&gt;length() == idx + 1, &quot;Unexpected array count&quot;);
 739     // Old functionality:
 740     //   return
 741     // New functionality:
 742     //   Assert if the local is not top. In product mode let the new node
 743     //   override the old entry.
<span class="line-modified"> 744     assert(local == C-&gt;top(), &quot;LocArray collision&quot;);</span>
<span class="line-modified"> 745     if (local == C-&gt;top()) {</span>
 746       return;
 747     }
 748     array-&gt;pop();
 749   }
 750   const Type *t = local-&gt;bottom_type();
 751 
 752   // Is it a safepoint scalar object node?
 753   if (local-&gt;is_SafePointScalarObject()) {
 754     SafePointScalarObjectNode* spobj = local-&gt;as_SafePointScalarObject();
 755 
<span class="line-modified"> 756     ObjectValue* sv = sv_for_node_id(objs, spobj-&gt;_idx);</span>
 757     if (sv == NULL) {
 758       ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
 759       assert(cik-&gt;is_instance_klass() ||
 760              cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
 761       sv = new ObjectValue(spobj-&gt;_idx,
 762                            new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified"> 763       set_sv_for_object_node(objs, sv);</span>
 764 
 765       uint first_ind = spobj-&gt;first_index(sfpt-&gt;jvms());
 766       for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
 767         Node* fld_node = sfpt-&gt;in(first_ind+i);
 768         (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfpt, fld_node, sv-&gt;field_values(), objs);
 769       }
 770     }
 771     array-&gt;append(sv);
 772     return;
 773   }
 774 
 775   // Grab the register number for the local
<span class="line-modified"> 776   OptoReg::Name regnum = C-&gt;regalloc()-&gt;get_reg_first(local);</span>
 777   if( OptoReg::is_valid(regnum) ) {// Got a register/stack?
 778     // Record the double as two float registers.
 779     // The register mask for such a value always specifies two adjacent
 780     // float registers, with the lower register number even.
 781     // Normally, the allocation of high and low words to these registers
 782     // is irrelevant, because nearly all operations on register pairs
 783     // (e.g., StoreD) treat them as a single unit.
 784     // Here, we assume in addition that the words in these two registers
 785     // stored &quot;naturally&quot; (by operations like StoreD and double stores
 786     // within the interpreter) such that the lower-numbered register
 787     // is written to the lower memory address.  This may seem like
 788     // a machine dependency, but it is not--it is a requirement on
 789     // the author of the &lt;arch&gt;.ad file to ensure that, for every
 790     // even/odd double-register pair to which a double may be allocated,
 791     // the word in the even single-register is stored to the first
 792     // memory word.  (Note that register numbers are completely
 793     // arbitrary, and are not tied to any machine-level encodings.)
 794 #ifdef _LP64
 795     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon ) {
 796       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 797       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::dbl ));</span>
 798     } else if ( t-&gt;base() == Type::Long ) {
 799       array-&gt;append(new ConstantIntValue((jint)0));
<span class="line-modified"> 800       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));</span>
 801     } else if ( t-&gt;base() == Type::RawPtr ) {
 802       // jsr/ret return address which must be restored into a the full
 803       // width 64-bit stack slot.
<span class="line-modified"> 804       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::lng ));</span>
 805     }
 806 #else //_LP64
 807 #ifdef SPARC
 808     if (t-&gt;base() == Type::Long &amp;&amp; OptoReg::is_reg(regnum)) {
 809       // For SPARC we have to swap high and low words for
 810       // long values stored in a single-register (g0-g7).
<span class="line-modified"> 811       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));</span>
<span class="line-modified"> 812       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));</span>
 813     } else
 814 #endif //SPARC
 815     if( t-&gt;base() == Type::DoubleBot || t-&gt;base() == Type::DoubleCon || t-&gt;base() == Type::Long ) {
 816       // Repack the double/long as two jints.
 817       // The convention the interpreter uses is that the second local
 818       // holds the first raw word of the native double representation.
 819       // This is actually reasonable, since locals and stack arrays
 820       // grow downwards in all implementations.
 821       // (If, on some machine, the interpreter&#39;s Java locals or stack
 822       // were to grow upwards, the embedded doubles would be word-swapped.)
<span class="line-modified"> 823       array-&gt;append(new_loc_value( C-&gt;regalloc(), OptoReg::add(regnum,1), Location::normal ));</span>
<span class="line-modified"> 824       array-&gt;append(new_loc_value( C-&gt;regalloc(),              regnum   , Location::normal ));</span>
 825     }
 826 #endif //_LP64
 827     else if( (t-&gt;base() == Type::FloatBot || t-&gt;base() == Type::FloatCon) &amp;&amp;
 828              OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 829       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::float_in_double()</span>
 830                                                       ? Location::float_in_dbl : Location::normal ));
 831     } else if( t-&gt;base() == Type::Int &amp;&amp; OptoReg::is_reg(regnum) ) {
<span class="line-modified"> 832       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Matcher::int_in_long</span>
 833                                                       ? Location::int_in_long : Location::normal ));
 834     } else if( t-&gt;base() == Type::NarrowOop ) {
<span class="line-modified"> 835       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, Location::narrowoop ));</span>
 836     } else {
<span class="line-modified"> 837       array-&gt;append(new_loc_value( C-&gt;regalloc(), regnum, C-&gt;regalloc()-&gt;is_oop(local) ? Location::oop : Location::normal ));</span>
 838     }
 839     return;
 840   }
 841 
 842   // No register.  It must be constant data.
 843   switch (t-&gt;base()) {
 844     case Type::Half:              // Second half of a double
 845       ShouldNotReachHere();       // Caller should skip 2nd halves
 846       break;
 847     case Type::AnyPtr:
 848       array-&gt;append(new ConstantOopWriteValue(NULL));
 849       break;
 850     case Type::AryPtr:
 851     case Type::InstPtr:          // fall through
 852       array-&gt;append(new ConstantOopWriteValue(t-&gt;isa_oopptr()-&gt;const_oop()-&gt;constant_encoding()));
 853       break;
 854     case Type::NarrowOop:
 855       if (t == TypeNarrowOop::NULL_PTR) {
 856         array-&gt;append(new ConstantOopWriteValue(NULL));
 857       } else {
</pre>
<hr />
<pre>
 909     // grow downwards in all implementations.
 910     // (If, on some machine, the interpreter&#39;s Java locals or stack
 911     // were to grow upwards, the embedded doubles would be word-swapped.)
 912     jlong_accessor acc;
 913     acc.long_value = d;
 914     array-&gt;append(new ConstantIntValue(acc.words[1]));
 915     array-&gt;append(new ConstantIntValue(acc.words[0]));
 916 #endif
 917       break;
 918     }
 919     case Type::Top:               // Add an illegal value here
 920       array-&gt;append(new LocationValue(Location()));
 921       break;
 922     default:
 923       ShouldNotReachHere();
 924       break;
 925   }
 926 }
 927 
 928 // Determine if this node starts a bundle
<span class="line-modified"> 929 bool PhaseOutput::starts_bundle(const Node *n) const {</span>
 930   return (_node_bundling_limit &gt; n-&gt;_idx &amp;&amp;
 931           _node_bundling_base[n-&gt;_idx].starts_bundle());
 932 }
 933 
 934 //--------------------------Process_OopMap_Node--------------------------------
<span class="line-modified"> 935 void PhaseOutput::Process_OopMap_Node(MachNode *mach, int current_offset) {</span>

 936   // Handle special safepoint nodes for synchronization
 937   MachSafePointNode *sfn   = mach-&gt;as_MachSafePoint();
 938   MachCallNode      *mcall;
 939 
 940   int safepoint_pc_offset = current_offset;
 941   bool is_method_handle_invoke = false;
 942   bool return_oop = false;
 943 
 944   // Add the safepoint in the DebugInfoRecorder
 945   if( !mach-&gt;is_MachCall() ) {
 946     mcall = NULL;
<span class="line-modified"> 947     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, sfn-&gt;_oop_map);</span>
 948   } else {
 949     mcall = mach-&gt;as_MachCall();
 950 
 951     // Is the call a MethodHandle call?
 952     if (mcall-&gt;is_MachCallJava()) {
 953       if (mcall-&gt;as_MachCallJava()-&gt;_method_handle_invoke) {
<span class="line-modified"> 954         assert(C-&gt;has_method_handle_invokes(), &quot;must have been set during call generation&quot;);</span>
 955         is_method_handle_invoke = true;
 956       }
 957     }
 958 
 959     // Check if a call returns an object.
 960     if (mcall-&gt;returns_pointer()) {
 961       return_oop = true;
 962     }
 963     safepoint_pc_offset += mcall-&gt;ret_addr_offset();
<span class="line-modified"> 964     C-&gt;debug_info()-&gt;add_safepoint(safepoint_pc_offset, mcall-&gt;_oop_map);</span>
 965   }
 966 
 967   // Loop over the JVMState list to add scope information
 968   // Do not skip safepoints with a NULL method, they need monitor info
 969   JVMState* youngest_jvms = sfn-&gt;jvms();
 970   int max_depth = youngest_jvms-&gt;depth();
 971 
 972   // Allocate the object pool for scalar-replaced objects -- the map from
 973   // small-integer keys (which can be recorded in the local and ostack
 974   // arrays) to descriptions of the object state.
 975   GrowableArray&lt;ScopeValue*&gt; *objs = new GrowableArray&lt;ScopeValue*&gt;();
 976 
 977   // Visit scopes from oldest to youngest.
 978   for (int depth = 1; depth &lt;= max_depth; depth++) {
 979     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
 980     int idx;
 981     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
 982     // Safepoints that do not have method() set only provide oop-map and monitor info
 983     // to support GC; these do not support deoptimization.
 984     int num_locs = (method == NULL) ? 0 : jvms-&gt;loc_size();
</pre>
<hr />
<pre>
1006             !method-&gt;is_synchronized() ||
1007             method-&gt;is_native() ||
1008             num_mon &gt; 0 ||
1009             !GenerateSynchronizationCode,
1010             &quot;monitors must always exist for synchronized methods&quot;);
1011 
1012     // Build the growable array of ScopeValues for exp stack
1013     GrowableArray&lt;MonitorValue*&gt; *monarray = new GrowableArray&lt;MonitorValue*&gt;(num_mon);
1014 
1015     // Loop over monitors and insert into array
1016     for (idx = 0; idx &lt; num_mon; idx++) {
1017       // Grab the node that defines this monitor
1018       Node* box_node = sfn-&gt;monitor_box(jvms, idx);
1019       Node* obj_node = sfn-&gt;monitor_obj(jvms, idx);
1020 
1021       // Create ScopeValue for object
1022       ScopeValue *scval = NULL;
1023 
1024       if (obj_node-&gt;is_SafePointScalarObject()) {
1025         SafePointScalarObjectNode* spobj = obj_node-&gt;as_SafePointScalarObject();
<span class="line-modified">1026         scval = PhaseOutput::sv_for_node_id(objs, spobj-&gt;_idx);</span>
1027         if (scval == NULL) {
1028           const Type *t = spobj-&gt;bottom_type();
1029           ciKlass* cik = t-&gt;is_oopptr()-&gt;klass();
1030           assert(cik-&gt;is_instance_klass() ||
1031                  cik-&gt;is_array_klass(), &quot;Not supported allocation.&quot;);
1032           ObjectValue* sv = new ObjectValue(spobj-&gt;_idx,
1033                                             new ConstantOopWriteValue(cik-&gt;java_mirror()-&gt;constant_encoding()));
<span class="line-modified">1034           PhaseOutput::set_sv_for_object_node(objs, sv);</span>
1035 
1036           uint first_ind = spobj-&gt;first_index(youngest_jvms);
1037           for (uint i = 0; i &lt; spobj-&gt;n_fields(); i++) {
1038             Node* fld_node = sfn-&gt;in(first_ind+i);
1039             (void)FillLocArray(sv-&gt;field_values()-&gt;length(), sfn, fld_node, sv-&gt;field_values(), objs);
1040           }
1041           scval = sv;
1042         }
1043       } else if (!obj_node-&gt;is_Con()) {
<span class="line-modified">1044         OptoReg::Name obj_reg = C-&gt;regalloc()-&gt;get_reg_first(obj_node);</span>
1045         if( obj_node-&gt;bottom_type()-&gt;base() == Type::NarrowOop ) {
<span class="line-modified">1046           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::narrowoop );</span>
1047         } else {
<span class="line-modified">1048           scval = new_loc_value( C-&gt;regalloc(), obj_reg, Location::oop );</span>
1049         }
1050       } else {
1051         const TypePtr *tp = obj_node-&gt;get_ptr_type();
1052         scval = new ConstantOopWriteValue(tp-&gt;is_oopptr()-&gt;const_oop()-&gt;constant_encoding());
1053       }
1054 
1055       OptoReg::Name box_reg = BoxLockNode::reg(box_node);
<span class="line-modified">1056       Location basic_lock = Location::new_stk_loc(Location::normal,C-&gt;regalloc()-&gt;reg2offset(box_reg));</span>
1057       bool eliminated = (box_node-&gt;is_BoxLock() &amp;&amp; box_node-&gt;as_BoxLock()-&gt;is_eliminated());
1058       monarray-&gt;append(new MonitorValue(scval, basic_lock, eliminated));
1059     }
1060 
1061     // We dump the object pool first, since deoptimization reads it in first.
<span class="line-modified">1062     C-&gt;debug_info()-&gt;dump_object_pool(objs);</span>
1063 
1064     // Build first class objects to pass to scope
<span class="line-modified">1065     DebugToken *locvals = C-&gt;debug_info()-&gt;create_scope_values(locarray);</span>
<span class="line-modified">1066     DebugToken *expvals = C-&gt;debug_info()-&gt;create_scope_values(exparray);</span>
<span class="line-modified">1067     DebugToken *monvals = C-&gt;debug_info()-&gt;create_monitor_values(monarray);</span>
1068 
1069     // Make method available for all Safepoints
<span class="line-modified">1070     ciMethod* scope_method = method ? method : C-&gt;method();</span>
1071     // Describe the scope here
1072     assert(jvms-&gt;bci() &gt;= InvocationEntryBci &amp;&amp; jvms-&gt;bci() &lt;= 0x10000, &quot;must be a valid or entry BCI&quot;);
1073     assert(!jvms-&gt;should_reexecute() || depth == max_depth, &quot;reexecute allowed only for the youngest&quot;);
1074     // Now we can describe the scope.
1075     methodHandle null_mh;
1076     bool rethrow_exception = false;
<span class="line-modified">1077     C-&gt;debug_info()-&gt;describe_scope(safepoint_pc_offset, null_mh, scope_method, jvms-&gt;bci(), jvms-&gt;should_reexecute(), rethrow_exception, is_method_handle_invoke, return_oop, locvals, expvals, monvals);</span>
1078   } // End jvms loop
1079 
1080   // Mark the end of the scope set.
<span class="line-modified">1081   C-&gt;debug_info()-&gt;end_safepoint(safepoint_pc_offset);</span>
1082 }
1083 
1084 
1085 
1086 // A simplified version of Process_OopMap_Node, to handle non-safepoints.
1087 class NonSafepointEmitter {
1088     Compile*  C;
1089     JVMState* _pending_jvms;
1090     int       _pending_offset;
1091 
1092     void emit_non_safepoint();
1093 
1094  public:
1095     NonSafepointEmitter(Compile* compile) {
1096       this-&gt;C = compile;
1097       _pending_jvms = NULL;
1098       _pending_offset = 0;
1099     }
1100 
1101     void observe_instruction(Node* n, int pc_offset) {
</pre>
<hr />
<pre>
1149   DebugInformationRecorder* debug_info = C-&gt;debug_info();
1150   assert(debug_info-&gt;recording_non_safepoints(), &quot;sanity&quot;);
1151 
1152   debug_info-&gt;add_non_safepoint(pc_offset);
1153   int max_depth = youngest_jvms-&gt;depth();
1154 
1155   // Visit scopes from oldest to youngest.
1156   for (int depth = 1; depth &lt;= max_depth; depth++) {
1157     JVMState* jvms = youngest_jvms-&gt;of_depth(depth);
1158     ciMethod* method = jvms-&gt;has_method() ? jvms-&gt;method() : NULL;
1159     assert(!jvms-&gt;should_reexecute() || depth==max_depth, &quot;reexecute allowed only for the youngest&quot;);
1160     methodHandle null_mh;
1161     debug_info-&gt;describe_scope(pc_offset, null_mh, method, jvms-&gt;bci(), jvms-&gt;should_reexecute());
1162   }
1163 
1164   // Mark the end of the scope set.
1165   debug_info-&gt;end_non_safepoint(pc_offset);
1166 }
1167 
1168 //------------------------------init_buffer------------------------------------
<span class="line-modified">1169 void PhaseOutput::estimate_buffer_size(int&amp; const_req) {</span>
1170 
1171   // Set the initially allocated size
1172   const_req = initial_const_capacity;
1173 
1174   // The extra spacing after the code is necessary on some platforms.
1175   // Sometimes we need to patch in a jump after the last instruction,
1176   // if the nmethod has been deoptimized.  (See 4932387, 4894843.)
1177 
1178   // Compute the byte offset where we can store the deopt pc.
<span class="line-modified">1179   if (C-&gt;fixed_slots() != 0) {</span>
<span class="line-modified">1180     _orig_pc_slot_offset_in_bytes = C-&gt;regalloc()-&gt;reg2offset(OptoReg::stack2reg(_orig_pc_slot));</span>
1181   }
1182 
1183   // Compute prolog code size
1184   _method_size = 0;
<span class="line-modified">1185   _frame_slots = OptoReg::reg2stack(C-&gt;matcher()-&gt;_old_SP) + C-&gt;regalloc()-&gt;_framesize;</span>
1186 #if defined(IA64) &amp;&amp; !defined(AIX)
1187   if (save_argument_registers()) {
1188     // 4815101: this is a stub with implicit and unknown precision fp args.
1189     // The usual spill mechanism can only generate stfd&#39;s in this case, which
1190     // doesn&#39;t work if the fp reg to spill contains a single-precision denorm.
1191     // Instead, we hack around the normal spill mechanism using stfspill&#39;s and
1192     // ldffill&#39;s in the MachProlog and MachEpilog emit methods.  We allocate
1193     // space here for the fp arg regs (f8-f15) we&#39;re going to thusly spill.
1194     //
1195     // If we ever implement 16-byte &#39;registers&#39; == stack slots, we can
1196     // get rid of this hack and have SpillCopy generate stfspill/ldffill
1197     // instead of stfd/stfs/ldfd/ldfs.
1198     _frame_slots += 8*(16/BytesPerInt);
1199   }
1200 #endif
1201   assert(_frame_slots &gt;= 0 &amp;&amp; _frame_slots &lt; 1000000, &quot;sanity check&quot;);
1202 
<span class="line-modified">1203   if (C-&gt;has_mach_constant_base_node()) {</span>
1204     uint add_size = 0;
1205     // Fill the constant table.
1206     // Note:  This must happen before shorten_branches.
<span class="line-modified">1207     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1208       Block* b = C-&gt;cfg()-&gt;get_block(i);</span>
1209 
1210       for (uint j = 0; j &lt; b-&gt;number_of_nodes(); j++) {
1211         Node* n = b-&gt;get_node(j);
1212 
1213         // If the node is a MachConstantNode evaluate the constant
1214         // value section.
1215         if (n-&gt;is_MachConstant()) {
1216           MachConstantNode* machcon = n-&gt;as_MachConstant();
1217           machcon-&gt;eval_constant(C);
1218         } else if (n-&gt;is_Mach()) {
1219           // On Power there are more nodes that issue constants.
1220           add_size += (n-&gt;as_Mach()-&gt;ins_num_consts() * 8);
1221         }
1222       }
1223     }
1224 
1225     // Calculate the offsets of the constants and the size of the
1226     // constant table (including the padding to the next section).
1227     constant_table().calculate_offsets_and_size();
1228     const_req = constant_table().size() + add_size;
1229   }
1230 
1231   // Initialize the space for the BufferBlob used to find and verify
1232   // instruction size in MachNode::emit_size()
1233   init_scratch_buffer_blob(const_req);
1234 }
1235 
<span class="line-modified">1236 CodeBuffer* PhaseOutput::init_buffer() {</span>
<span class="line-modified">1237   int stub_req  = _buf_sizes._stub;</span>
<span class="line-modified">1238   int code_req  = _buf_sizes._code;</span>
<span class="line-modified">1239   int const_req = _buf_sizes._const;</span>

1240 
1241   int pad_req   = NativeCall::instruction_size;
1242 
1243   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1244   stub_req += bs-&gt;estimate_stub_size();
1245 
1246   // nmethod and CodeBuffer count stubs &amp; constants as part of method&#39;s code.
1247   // class HandlerImpl is platform-specific and defined in the *.ad files.
1248   int exception_handler_req = HandlerImpl::size_exception_handler() + MAX_stubs_size; // add marginal slop for handler
1249   int deopt_handler_req     = HandlerImpl::size_deopt_handler()     + MAX_stubs_size; // add marginal slop for handler
1250   stub_req += MAX_stubs_size;   // ensure per-stub margin
1251   code_req += MAX_inst_size;    // ensure per-instruction margin
1252 
1253   if (StressCodeBuffers)
1254     code_req = const_req = stub_req = exception_handler_req = deopt_handler_req = 0x10;  // force expansion
1255 
1256   int total_req =
1257           const_req +
1258           code_req +
1259           pad_req +
1260           stub_req +
1261           exception_handler_req +
1262           deopt_handler_req;               // deopt handler
1263 
<span class="line-modified">1264   if (C-&gt;has_method_handle_invokes())</span>
1265     total_req += deopt_handler_req;  // deopt MH handler
1266 
1267   CodeBuffer* cb = code_buffer();
<span class="line-modified">1268   cb-&gt;initialize(total_req, _buf_sizes._reloc);</span>
1269 
1270   // Have we run out of code space?
1271   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1272     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1273     return NULL;
1274   }
1275   // Configure the code buffer.
1276   cb-&gt;initialize_consts_size(const_req);
1277   cb-&gt;initialize_stubs_size(stub_req);
<span class="line-modified">1278   cb-&gt;initialize_oop_recorder(C-&gt;env()-&gt;oop_recorder());</span>
1279 
1280   // fill in the nop array for bundling computations
1281   MachNode *_nop_list[Bundle::_nop_count];
1282   Bundle::initialize_nops(_nop_list);
1283 
1284   return cb;
1285 }
1286 
1287 //------------------------------fill_buffer------------------------------------
<span class="line-modified">1288 void PhaseOutput::fill_buffer(CodeBuffer* cb, uint* blk_starts) {</span>
1289   // blk_starts[] contains offsets calculated during short branches processing,
1290   // offsets should not be increased during following steps.
1291 
1292   // Compute the size of first NumberOfLoopInstrToAlign instructions at head
1293   // of a loop. It is used to determine the padding for loop alignment.
1294   compute_loop_first_inst_sizes();
1295 
1296   // Create oopmap set.
1297   _oop_map_set = new OopMapSet();
1298 
1299   // !!!!! This preserves old handling of oopmaps for now
<span class="line-modified">1300   C-&gt;debug_info()-&gt;set_oopmaps(_oop_map_set);</span>
1301 
<span class="line-modified">1302   uint nblocks  = C-&gt;cfg()-&gt;number_of_blocks();</span>
1303   // Count and start of implicit null check instructions
1304   uint inct_cnt = 0;
1305   uint *inct_starts = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1306 
1307   // Count and start of calls
1308   uint *call_returns = NEW_RESOURCE_ARRAY(uint, nblocks+1);
1309 
1310   uint  return_offset = 0;
<span class="line-modified">1311   int nop_size = (new MachNopNode())-&gt;size(C-&gt;regalloc());</span>
1312 
1313   int previous_offset = 0;
1314   int current_offset  = 0;
1315   int last_call_offset = -1;
1316   int last_avoid_back_to_back_offset = -1;
1317 #ifdef ASSERT
1318   uint* jmp_target = NEW_RESOURCE_ARRAY(uint,nblocks);
1319   uint* jmp_offset = NEW_RESOURCE_ARRAY(uint,nblocks);
1320   uint* jmp_size   = NEW_RESOURCE_ARRAY(uint,nblocks);
1321   uint* jmp_rule   = NEW_RESOURCE_ARRAY(uint,nblocks);
1322 #endif
1323 
1324   // Create an array of unused labels, one for each basic block, if printing is enabled
1325 #if defined(SUPPORT_OPTO_ASSEMBLY)
1326   int *node_offsets      = NULL;
<span class="line-modified">1327   uint node_offset_limit = C-&gt;unique();</span>
1328 
<span class="line-modified">1329   if (C-&gt;print_assembly()) {</span>
1330     node_offsets = NEW_RESOURCE_ARRAY(int, node_offset_limit);
1331   }
1332   if (node_offsets != NULL) {
1333     // We need to initialize. Unused array elements may contain garbage and mess up PrintOptoAssembly.
1334     memset(node_offsets, 0, node_offset_limit*sizeof(int));
1335   }
1336 #endif
1337 
<span class="line-modified">1338   NonSafepointEmitter non_safepoints(C);  // emit non-safepoints lazily</span>
1339 
1340   // Emit the constant table.
<span class="line-modified">1341   if (C-&gt;has_mach_constant_base_node()) {</span>
1342     constant_table().emit(*cb);
1343   }
1344 
1345   // Create an array of labels, one for each basic block
1346   Label *blk_labels = NEW_RESOURCE_ARRAY(Label, nblocks+1);
1347   for (uint i=0; i &lt;= nblocks; i++) {
1348     blk_labels[i].init();
1349   }
1350 
1351   // ------------------
1352   // Now fill in the code buffer
1353   Node *delay_slot = NULL;
1354 
1355   for (uint i = 0; i &lt; nblocks; i++) {
<span class="line-modified">1356     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-added">1357     _block = block;</span>
1358     Node* head = block-&gt;head();
1359 
1360     // If this block needs to start aligned (i.e, can be reached other
1361     // than by falling-thru from the previous block), then force the
1362     // start of a new bundle.
1363     if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(head)) {
1364       cb-&gt;flush_bundle(true);
1365     }
1366 
1367 #ifdef ASSERT
1368     if (!block-&gt;is_connector()) {
1369       stringStream st;
<span class="line-modified">1370       block-&gt;dump_head(C-&gt;cfg(), &amp;st);</span>
1371       MacroAssembler(cb).block_comment(st.as_string());
1372     }
1373     jmp_target[i] = 0;
1374     jmp_offset[i] = 0;
1375     jmp_size[i]   = 0;
1376     jmp_rule[i]   = 0;
1377 #endif
1378     int blk_offset = current_offset;
1379 
1380     // Define the label at the beginning of the basic block
1381     MacroAssembler(cb).bind(blk_labels[block-&gt;_pre_order]);
1382 
1383     uint last_inst = block-&gt;number_of_nodes();
1384 
1385     // Emit block normally, except for last instruction.
1386     // Emit means &quot;dump code bits into code buffer&quot;.
1387     for (uint j = 0; j&lt;last_inst; j++) {
<span class="line-added">1388       _index = j;</span>
1389 
1390       // Get the node
1391       Node* n = block-&gt;get_node(j);
1392 
1393       // See if delay slots are supported
<span class="line-modified">1394       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;used_in_unconditional_delay()) {</span>

1395         assert(delay_slot == NULL, &quot;no use of delay slot node&quot;);
<span class="line-modified">1396         assert(n-&gt;size(C-&gt;regalloc()) == Pipeline::instr_unit_size(), &quot;delay slot instruction wrong size&quot;);</span>
1397 
1398         delay_slot = n;
1399         continue;
1400       }
1401 
1402       // If this starts a new instruction group, then flush the current one
1403       // (but allow split bundles)
1404       if (Pipeline::requires_bundling() &amp;&amp; starts_bundle(n))
1405         cb-&gt;flush_bundle(false);
1406 
1407       // Special handling for SafePoint/Call Nodes
1408       bool is_mcall = false;
1409       if (n-&gt;is_Mach()) {
1410         MachNode *mach = n-&gt;as_Mach();
1411         is_mcall = n-&gt;is_MachCall();
1412         bool is_sfn = n-&gt;is_MachSafePoint();
1413 
1414         // If this requires all previous instructions be flushed, then do so
1415         if (is_sfn || is_mcall || mach-&gt;alignment_required() != 1) {
1416           cb-&gt;flush_bundle(true);
1417           current_offset = cb-&gt;insts_size();
1418         }
1419 
1420         // A padding may be needed again since a previous instruction
1421         // could be moved to delay slot.
1422 
1423         // align the instruction if necessary
1424         int padding = mach-&gt;compute_padding(current_offset);
1425         // Make sure safepoint node for polling is distinct from a call&#39;s
1426         // return by adding a nop if needed.
1427         if (is_sfn &amp;&amp; !is_mcall &amp;&amp; padding == 0 &amp;&amp; current_offset == last_call_offset) {
1428           padding = nop_size;
1429         }
1430         if (padding == 0 &amp;&amp; mach-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE) &amp;&amp;
1431             current_offset == last_avoid_back_to_back_offset) {
1432           // Avoid back to back some instructions.
1433           padding = nop_size;
1434         }






1435 
1436         if (padding &gt; 0) {
1437           assert((padding % nop_size) == 0, &quot;padding is not a multiple of NOP size&quot;);
1438           int nops_cnt = padding / nop_size;
1439           MachNode *nop = new MachNopNode(nops_cnt);
1440           block-&gt;insert_node(nop, j++);
1441           last_inst++;
<span class="line-modified">1442           C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
1443           // Ensure enough space.
1444           cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1445           if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1446             C-&gt;record_failure(&quot;CodeCache is full&quot;);
1447             return;
1448           }
<span class="line-modified">1449           nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1450           cb-&gt;flush_bundle(true);
1451           current_offset = cb-&gt;insts_size();
1452         }
1453 
1454         // Remember the start of the last call in a basic block
1455         if (is_mcall) {
1456           MachCallNode *mcall = mach-&gt;as_MachCall();
1457 
1458           // This destination address is NOT PC-relative
1459           mcall-&gt;method_set((intptr_t)mcall-&gt;entry_point());
1460 
1461           // Save the return address
1462           call_returns[block-&gt;_pre_order] = current_offset + mcall-&gt;ret_addr_offset();
1463 
1464           if (mcall-&gt;is_MachCallLeaf()) {
1465             is_mcall = false;
1466             is_sfn = false;
1467           }
1468         }
1469 
</pre>
<hr />
<pre>
1482 
1483           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1484                                            current_offset);
1485           Process_OopMap_Node(mach, current_offset);
1486         } // End if safepoint
1487 
1488           // If this is a null check, then add the start of the previous instruction to the list
1489         else if( mach-&gt;is_MachNullCheck() ) {
1490           inct_starts[inct_cnt++] = previous_offset;
1491         }
1492 
1493           // If this is a branch, then fill in the label with the target BB&#39;s label
1494         else if (mach-&gt;is_MachBranch()) {
1495           // This requires the TRUE branch target be in succs[0]
1496           uint block_num = block-&gt;non_connector_successor(0)-&gt;_pre_order;
1497 
1498           // Try to replace long branch if delay slot is not used,
1499           // it is mostly for back branches since forward branch&#39;s
1500           // distance is not updated yet.
1501           bool delay_slot_is_used = valid_bundle_info(n) &amp;&amp;
<span class="line-modified">1502                                     C-&gt;output()-&gt;node_bundling(n)-&gt;use_unconditional_delay();</span>
1503           if (!delay_slot_is_used &amp;&amp; mach-&gt;may_be_short_branch()) {
1504             assert(delay_slot == NULL, &quot;not expecting delay slot node&quot;);
<span class="line-modified">1505             int br_size = n-&gt;size(C-&gt;regalloc());</span>
1506             int offset = blk_starts[block_num] - current_offset;
1507             if (block_num &gt;= i) {
1508               // Current and following block&#39;s offset are not
1509               // finalized yet, adjust distance by the difference
1510               // between calculated and final offsets of current block.
1511               offset -= (blk_starts[i] - blk_offset);
1512             }
1513             // In the following code a nop could be inserted before
1514             // the branch which will increase the backward distance.
1515             bool needs_padding = (current_offset == last_avoid_back_to_back_offset);
1516             if (needs_padding &amp;&amp; offset &lt;= 0)
1517               offset -= nop_size;
1518 
<span class="line-modified">1519             if (C-&gt;matcher()-&gt;is_short_branch_offset(mach-&gt;rule(), br_size, offset)) {</span>
1520               // We&#39;ve got a winner.  Replace this branch.
1521               MachNode* replacement = mach-&gt;as_MachBranch()-&gt;short_branch_version();
1522 
1523               // Update the jmp_size.
<span class="line-modified">1524               int new_size = replacement-&gt;size(C-&gt;regalloc());</span>
1525               assert((br_size - new_size) &gt;= (int)nop_size, &quot;short_branch size should be smaller&quot;);
1526               // Insert padding between avoid_back_to_back branches.
1527               if (needs_padding &amp;&amp; replacement-&gt;avoid_back_to_back(MachNode::AVOID_BEFORE)) {
1528                 MachNode *nop = new MachNopNode();
1529                 block-&gt;insert_node(nop, j++);
<span class="line-modified">1530                 C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
1531                 last_inst++;
<span class="line-modified">1532                 nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1533                 cb-&gt;flush_bundle(true);
1534                 current_offset = cb-&gt;insts_size();
1535               }
1536 #ifdef ASSERT
1537               jmp_target[i] = block_num;
1538               jmp_offset[i] = current_offset - blk_offset;
1539               jmp_size[i]   = new_size;
1540               jmp_rule[i]   = mach-&gt;rule();
1541 #endif
1542               block-&gt;map_node(replacement, j);
1543               mach-&gt;subsume_by(replacement, C);
1544               n    = replacement;
1545               mach = replacement;
1546             }
1547           }
1548           mach-&gt;as_MachBranch()-&gt;label_set( &amp;blk_labels[block_num], block_num );
1549         } else if (mach-&gt;ideal_Opcode() == Op_Jump) {
1550           for (uint h = 0; h &lt; block-&gt;_num_succs; h++) {
1551             Block* succs_block = block-&gt;_succs[h];
1552             for (uint j = 1; j &lt; succs_block-&gt;num_preds(); j++) {
</pre>
<hr />
<pre>
1594           inct_starts[inct_cnt++] = current_offset;
1595         }
1596       }
1597 
1598       // Verify that there is sufficient space remaining
1599       cb-&gt;insts()-&gt;maybe_expand_to_ensure_remaining(MAX_inst_size);
1600       if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1601         C-&gt;record_failure(&quot;CodeCache is full&quot;);
1602         return;
1603       }
1604 
1605       // Save the offset for the listing
1606 #if defined(SUPPORT_OPTO_ASSEMBLY)
1607       if ((node_offsets != NULL) &amp;&amp; (n-&gt;_idx &lt; node_offset_limit)) {
1608         node_offsets[n-&gt;_idx] = cb-&gt;insts_size();
1609       }
1610 #endif
1611 
1612       // &quot;Normal&quot; instruction case
1613       DEBUG_ONLY( uint instr_offset = cb-&gt;insts_size(); )
<span class="line-modified">1614       n-&gt;emit(*cb, C-&gt;regalloc());</span>
1615       current_offset  = cb-&gt;insts_size();
1616 
1617       // Above we only verified that there is enough space in the instruction section.
1618       // However, the instruction may emit stubs that cause code buffer expansion.
1619       // Bail out here if expansion failed due to a lack of code cache space.
<span class="line-modified">1620       if (C-&gt;failing()) {</span>
1621         return;
1622       }
1623 
1624 #ifdef ASSERT
<span class="line-modified">1625       if (n-&gt;size(C-&gt;regalloc()) &lt; (current_offset-instr_offset)) {</span>
1626         n-&gt;dump();
1627         assert(false, &quot;wrong size of mach node&quot;);
1628       }
1629 #endif
1630       non_safepoints.observe_instruction(n, current_offset);
1631 
1632       // mcall is last &quot;call&quot; that can be a safepoint
1633       // record it so we can see if a poll will directly follow it
1634       // in which case we&#39;ll need a pad to make the PcDesc sites unique
1635       // see  5010568. This can be slightly inaccurate but conservative
1636       // in the case that return address is not actually at current_offset.
1637       // This is a small price to pay.
1638 
1639       if (is_mcall) {
1640         last_call_offset = current_offset;
1641       }
1642 
1643       if (n-&gt;is_Mach() &amp;&amp; n-&gt;as_Mach()-&gt;avoid_back_to_back(MachNode::AVOID_AFTER)) {
1644         // Avoid back to back some instructions.
1645         last_avoid_back_to_back_offset = current_offset;
</pre>
<hr />
<pre>
1660 #endif
1661 
1662         // Support a SafePoint in the delay slot
1663         if (delay_slot-&gt;is_MachSafePoint()) {
1664           MachNode *mach = delay_slot-&gt;as_Mach();
1665           // !!!!! Stubs only need an oopmap right now, so bail out
1666           if (!mach-&gt;is_MachCall() &amp;&amp; mach-&gt;as_MachSafePoint()-&gt;jvms()-&gt;method() == NULL) {
1667             // Write the oopmap directly to the code blob??!!
1668             delay_slot = NULL;
1669             continue;
1670           }
1671 
1672           int adjusted_offset = current_offset - Pipeline::instr_unit_size();
1673           non_safepoints.observe_safepoint(mach-&gt;as_MachSafePoint()-&gt;jvms(),
1674                                            adjusted_offset);
1675           // Generate an OopMap entry
1676           Process_OopMap_Node(mach, adjusted_offset);
1677         }
1678 
1679         // Insert the delay slot instruction
<span class="line-modified">1680         delay_slot-&gt;emit(*cb, C-&gt;regalloc());</span>
1681 
1682         // Don&#39;t reuse it
1683         delay_slot = NULL;
1684       }
1685 
1686     } // End for all instructions in block
1687 
1688     // If the next block is the top of a loop, pad this block out to align
1689     // the loop top a little. Helps prevent pipe stalls at loop back branches.
1690     if (i &lt; nblocks-1) {
<span class="line-modified">1691       Block *nb = C-&gt;cfg()-&gt;get_block(i + 1);</span>
1692       int padding = nb-&gt;alignment_padding(current_offset);
1693       if( padding &gt; 0 ) {
1694         MachNode *nop = new MachNopNode(padding / nop_size);
1695         block-&gt;insert_node(nop, block-&gt;number_of_nodes());
<span class="line-modified">1696         C-&gt;cfg()-&gt;map_node_to_block(nop, block);</span>
<span class="line-modified">1697         nop-&gt;emit(*cb, C-&gt;regalloc());</span>
1698         current_offset = cb-&gt;insts_size();
1699       }
1700     }
1701     // Verify that the distance for generated before forward
1702     // short branches is still valid.
1703     guarantee((int)(blk_starts[i+1] - blk_starts[i]) &gt;= (current_offset - blk_offset), &quot;shouldn&#39;t increase block size&quot;);
1704 
1705     // Save new block start offset
1706     blk_starts[i] = blk_offset;
1707   } // End of for all blocks
1708   blk_starts[nblocks] = current_offset;
1709 
1710   non_safepoints.flush_at_end();
1711 
1712   // Offset too large?
<span class="line-modified">1713   if (C-&gt;failing())  return;</span>
1714 
1715   // Define a pseudo-label at the end of the code
1716   MacroAssembler(cb).bind( blk_labels[nblocks] );
1717 
1718   // Compute the size of the first block
1719   _first_block_size = blk_labels[1].loc_pos() - blk_labels[0].loc_pos();
1720 
1721 #ifdef ASSERT
1722   for (uint i = 0; i &lt; nblocks; i++) { // For all blocks
1723     if (jmp_target[i] != 0) {
1724       int br_size = jmp_size[i];
1725       int offset = blk_starts[jmp_target[i]]-(blk_starts[i] + jmp_offset[i]);
<span class="line-modified">1726       if (!C-&gt;matcher()-&gt;is_short_branch_offset(jmp_rule[i], br_size, offset)) {</span>
1727         tty-&gt;print_cr(&quot;target (%d) - jmp_offset(%d) = offset (%d), jump_size(%d), jmp_block B%d, target_block B%d&quot;, blk_starts[jmp_target[i]], blk_starts[i] + jmp_offset[i], offset, br_size, i, jmp_target[i]);
1728         assert(false, &quot;Displacement too large for short jmp&quot;);
1729       }
1730     }
1731   }
1732 #endif
1733 
1734   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
1735   bs-&gt;emit_stubs(*cb);
<span class="line-modified">1736   if (C-&gt;failing())  return;</span>
1737 
1738 #ifndef PRODUCT
1739   // Information on the size of the method, without the extraneous code
1740   Scheduling::increment_method_size(cb-&gt;insts_size());
1741 #endif
1742 
1743   // ------------------
1744   // Fill in exception table entries.
1745   FillExceptionTables(inct_cnt, call_returns, inct_starts, blk_labels);
1746 
1747   // Only java methods have exception handlers and deopt handlers
1748   // class HandlerImpl is platform-specific and defined in the *.ad files.
<span class="line-modified">1749   if (C-&gt;method()) {</span>
1750     // Emit the exception handler code.
1751     _code_offsets.set_value(CodeOffsets::Exceptions, HandlerImpl::emit_exception_handler(*cb));
<span class="line-modified">1752     if (C-&gt;failing()) {</span>
1753       return; // CodeBuffer::expand failed
1754     }
1755     // Emit the deopt handler code.
1756     _code_offsets.set_value(CodeOffsets::Deopt, HandlerImpl::emit_deopt_handler(*cb));
1757 
1758     // Emit the MethodHandle deopt handler code (if required).
<span class="line-modified">1759     if (C-&gt;has_method_handle_invokes() &amp;&amp; !C-&gt;failing()) {</span>
1760       // We can use the same code as for the normal deopt handler, we
1761       // just need a different entry point address.
1762       _code_offsets.set_value(CodeOffsets::DeoptMH, HandlerImpl::emit_deopt_handler(*cb));
1763     }
1764   }
1765 
1766   // One last check for failed CodeBuffer::expand:
1767   if ((cb-&gt;blob() == NULL) || (!CompileBroker::should_compile_new_jobs())) {
1768     C-&gt;record_failure(&quot;CodeCache is full&quot;);
1769     return;
1770   }
1771 
1772 #if defined(SUPPORT_ABSTRACT_ASSEMBLY) || defined(SUPPORT_ASSEMBLY) || defined(SUPPORT_OPTO_ASSEMBLY)
<span class="line-modified">1773   if (C-&gt;print_assembly()) {</span>
1774     tty-&gt;cr();
1775     tty-&gt;print_cr(&quot;============================= C2-compiled nmethod ==============================&quot;);
1776   }
1777 #endif
1778 
1779 #if defined(SUPPORT_OPTO_ASSEMBLY)
1780   // Dump the assembly code, including basic-block numbers
<span class="line-modified">1781   if (C-&gt;print_assembly()) {</span>
1782     ttyLocker ttyl;  // keep the following output all in one block
1783     if (!VMThread::should_terminate()) {  // test this under the tty lock
1784       // This output goes directly to the tty, not the compiler log.
1785       // To enable tools to match it up with the compilation activity,
1786       // be sure to tag this tty output with the compile ID.
1787       if (xtty != NULL) {
<span class="line-modified">1788         xtty-&gt;head(&quot;opto_assembly compile_id=&#39;%d&#39;%s&quot;, C-&gt;compile_id(),</span>
<span class="line-modified">1789                    C-&gt;is_osr_compilation()    ? &quot; compile_kind=&#39;osr&#39;&quot; :</span>
1790                    &quot;&quot;);
1791       }
<span class="line-modified">1792       if (C-&gt;method() != NULL) {</span>
<span class="line-modified">1793         tty-&gt;print_cr(&quot;----------------------- MetaData before Compile_id = %d ------------------------&quot;, C-&gt;compile_id());</span>
<span class="line-modified">1794         C-&gt;method()-&gt;print_metadata();</span>
<span class="line-modified">1795       } else if (C-&gt;stub_name() != NULL) {</span>
<span class="line-modified">1796         tty-&gt;print_cr(&quot;----------------------------- RuntimeStub %s -------------------------------&quot;, C-&gt;stub_name());</span>
1797       }
1798       tty-&gt;cr();
<span class="line-modified">1799       tty-&gt;print_cr(&quot;------------------------ OptoAssembly for Compile_id = %d -----------------------&quot;, C-&gt;compile_id());</span>
1800       dump_asm(node_offsets, node_offset_limit);
1801       tty-&gt;print_cr(&quot;--------------------------------------------------------------------------------&quot;);
1802       if (xtty != NULL) {
1803         // print_metadata and dump_asm above may safepoint which makes us loose the ttylock.
1804         // Retake lock too make sure the end tag is coherent, and that xmlStream-&gt;pop_tag is done
1805         // thread safe
1806         ttyLocker ttyl2;
1807         xtty-&gt;tail(&quot;opto_assembly&quot;);
1808       }
1809     }
1810   }
1811 #endif
1812 }
1813 
<span class="line-modified">1814 void PhaseOutput::FillExceptionTables(uint cnt, uint *call_returns, uint *inct_starts, Label *blk_labels) {</span>
1815   _inc_table.set_size(cnt);
1816 
1817   uint inct_cnt = 0;
<span class="line-modified">1818   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-modified">1819     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
1820     Node *n = NULL;
1821     int j;
1822 
1823     // Find the branch; ignore trailing NOPs.
1824     for (j = block-&gt;number_of_nodes() - 1; j &gt;= 0; j--) {
1825       n = block-&gt;get_node(j);
1826       if (!n-&gt;is_Mach() || n-&gt;as_Mach()-&gt;ideal_Opcode() != Op_Con) {
1827         break;
1828       }
1829     }
1830 
1831     // If we didn&#39;t find anything, continue
1832     if (j &lt; 0) {
1833       continue;
1834     }
1835 
1836     // Compute ExceptionHandlerTable subtable entry and add it
1837     // (skip empty blocks)
1838     if (n-&gt;is_Catch()) {
1839 
</pre>
<hr />
<pre>
1844       while (block-&gt;get_node(--j)-&gt;is_MachProj()) ;
1845       assert(block-&gt;get_node(j)-&gt;is_MachCall(), &quot;CatchProj must follow call&quot;);
1846 #endif
1847       // last instruction is a CatchNode, find it&#39;s CatchProjNodes
1848       int nof_succs = block-&gt;_num_succs;
1849       // allocate space
1850       GrowableArray&lt;intptr_t&gt; handler_bcis(nof_succs);
1851       GrowableArray&lt;intptr_t&gt; handler_pcos(nof_succs);
1852       // iterate through all successors
1853       for (int j = 0; j &lt; nof_succs; j++) {
1854         Block* s = block-&gt;_succs[j];
1855         bool found_p = false;
1856         for (uint k = 1; k &lt; s-&gt;num_preds(); k++) {
1857           Node* pk = s-&gt;pred(k);
1858           if (pk-&gt;is_CatchProj() &amp;&amp; pk-&gt;in(0) == n) {
1859             const CatchProjNode* p = pk-&gt;as_CatchProj();
1860             found_p = true;
1861             // add the corresponding handler bci &amp; pco information
1862             if (p-&gt;_con != CatchProjNode::fall_through_index) {
1863               // p leads to an exception handler (and is not fall through)
<span class="line-modified">1864               assert(s == C-&gt;cfg()-&gt;get_block(s-&gt;_pre_order), &quot;bad numbering&quot;);</span>
1865               // no duplicates, please
1866               if (!handler_bcis.contains(p-&gt;handler_bci())) {
1867                 uint block_num = s-&gt;non_connector()-&gt;_pre_order;
1868                 handler_bcis.append(p-&gt;handler_bci());
1869                 handler_pcos.append(blk_labels[block_num].loc_pos());
1870               }
1871             }
1872           }
1873         }
1874         assert(found_p, &quot;no matching predecessor found&quot;);
1875         // Note:  Due to empty block removal, one block may have
1876         // several CatchProj inputs, from the same Catch.
1877       }
1878 
1879       // Set the offset of the return from the call
1880       assert(handler_bcis.find(-1) != -1, &quot;must have default handler&quot;);
1881       _handler_table.add_subtable(call_return, &amp;handler_bcis, NULL, &amp;handler_pcos);
1882       continue;
1883     }
1884 
</pre>
<hr />
<pre>
1916           _available(arena),
1917           _reg_node(arena),
1918           _pinch_free_list(arena),
1919           _next_node(NULL),
1920           _bundle_instr_count(0),
1921           _bundle_cycle_number(0),
1922           _bundle_use(0, 0, resource_count, &amp;_bundle_use_elements[0])
1923 #ifndef PRODUCT
1924         , _branches(0)
1925         , _unconditional_delays(0)
1926 #endif
1927 {
1928   // Create a MachNopNode
1929   _nop = new MachNopNode();
1930 
1931   // Now that the nops are in the array, save the count
1932   // (but allow entries for the nops)
1933   _node_bundling_limit = compile.unique();
1934   uint node_max = _regalloc-&gt;node_regs_max_index();
1935 
<span class="line-modified">1936   compile.output()-&gt;set_node_bundling_limit(_node_bundling_limit);</span>
1937 
1938   // This one is persistent within the Compile class
1939   _node_bundling_base = NEW_ARENA_ARRAY(compile.comp_arena(), Bundle, node_max);
1940 
1941   // Allocate space for fixed-size arrays
1942   _node_latency    = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1943   _uses            = NEW_ARENA_ARRAY(arena, short,          node_max);
1944   _current_latency = NEW_ARENA_ARRAY(arena, unsigned short, node_max);
1945 
1946   // Clear the arrays
1947   for (uint i = 0; i &lt; node_max; i++) {
1948     ::new (&amp;_node_bundling_base[i]) Bundle();
1949   }
1950   memset(_node_latency,       0, node_max * sizeof(unsigned short));
1951   memset(_uses,               0, node_max * sizeof(short));
1952   memset(_current_latency,    0, node_max * sizeof(unsigned short));
1953 
1954   // Clear the bundling information
1955   memcpy(_bundle_use_elements, Pipeline_Use::elaborated_elements, sizeof(Pipeline_Use::elaborated_elements));
1956 
</pre>
<hr />
<pre>
1992 
1993   // Update the bundle record
1994   if (_bundle_instr_count &gt; 0) {
1995     bundle-&gt;set_instr_count(_bundle_instr_count);
1996     bundle-&gt;set_resources_used(_bundle_use.resourcesUsed());
1997 
1998     _bundle_cycle_number += 1;
1999   }
2000 
2001   // Clear the bundling information
2002   _bundle_instr_count = 0;
2003   _bundle_use.reset();
2004 
2005   memcpy(_bundle_use_elements,
2006          Pipeline_Use::elaborated_elements,
2007          sizeof(Pipeline_Use::elaborated_elements));
2008 }
2009 
2010 // Perform instruction scheduling and bundling over the sequence of
2011 // instructions in backwards order.
<span class="line-modified">2012 void PhaseOutput::ScheduleAndBundle() {</span>
2013 
2014   // Don&#39;t optimize this if it isn&#39;t a method
<span class="line-modified">2015   if (!C-&gt;method())</span>
2016     return;
2017 
2018   // Don&#39;t optimize this if scheduling is disabled
<span class="line-modified">2019   if (!C-&gt;do_scheduling())</span>
2020     return;
2021 
2022   // Scheduling code works only with pairs (16 bytes) maximum.
<span class="line-modified">2023   if (C-&gt;max_vector_size() &gt; 16)</span>
2024     return;
2025 
<span class="line-modified">2026   Compile::TracePhase tp(&quot;isched&quot;, &amp;timers[_t_instrSched]);</span>
2027 
2028   // Create a data structure for all the scheduling information
<span class="line-modified">2029   Scheduling scheduling(Thread::current()-&gt;resource_area(), *C);</span>
2030 
2031   // Walk backwards over each basic block, computing the needed alignment
2032   // Walk over all the basic blocks
2033   scheduling.DoScheduling();
2034 
2035 #ifndef PRODUCT
<span class="line-modified">2036   if (C-&gt;trace_opto_output()) {</span>
2037     tty-&gt;print(&quot;\n---- After ScheduleAndBundle ----\n&quot;);
<span class="line-modified">2038     for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
2039       tty-&gt;print(&quot;\nBB#%03d:\n&quot;, i);
<span class="line-modified">2040       Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
2041       for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {
2042         Node* n = block-&gt;get_node(j);
<span class="line-modified">2043         OptoReg::Name reg = C-&gt;regalloc()-&gt;get_reg_first(n);</span>
2044         tty-&gt;print(&quot; %-6s &quot;, reg &gt;= 0 &amp;&amp; reg &lt; REG_COUNT ? Matcher::regName[reg] : &quot;&quot;);
2045         n-&gt;dump();
2046       }
2047     }
2048   }
2049 #endif
2050 }
2051 
2052 // Compute the latency of all the instructions.  This is fairly simple,
2053 // because we already have a legal ordering.  Walk over the instructions
2054 // from first to last, and compute the latency of the instruction based
2055 // on the latency of the preceding instruction(s).
2056 void Scheduling::ComputeLocalLatenciesForward(const Block *bb) {
2057 #ifndef PRODUCT
2058   if (_cfg-&gt;C-&gt;trace_opto_output())
2059     tty-&gt;print(&quot;# -&gt; ComputeLocalLatenciesForward\n&quot;);
2060 #endif
2061 
2062   // Walk over all the schedulable instructions
2063   for( uint j=_bb_start; j &lt; _bb_end; j++ ) {
</pre>
<hr />
<pre>
2565 #endif
2566   }
2567 
2568 #ifndef PRODUCT
2569   if (_cfg-&gt;C-&gt;trace_opto_output())
2570     tty-&gt;print(&quot;# &lt;- ComputeUseCount\n&quot;);
2571 #endif
2572 }
2573 
2574 // This routine performs scheduling on each basic block in reverse order,
2575 // using instruction latencies and taking into account function unit
2576 // availability.
2577 void Scheduling::DoScheduling() {
2578 #ifndef PRODUCT
2579   if (_cfg-&gt;C-&gt;trace_opto_output())
2580     tty-&gt;print(&quot;# -&gt; DoScheduling\n&quot;);
2581 #endif
2582 
2583   Block *succ_bb = NULL;
2584   Block *bb;
<span class="line-added">2585   Compile* C = Compile::current();</span>
2586 
2587   // Walk over all the basic blocks in reverse order
2588   for (int i = _cfg-&gt;number_of_blocks() - 1; i &gt;= 0; succ_bb = bb, i--) {
2589     bb = _cfg-&gt;get_block(i);
2590 
2591 #ifndef PRODUCT
2592     if (_cfg-&gt;C-&gt;trace_opto_output()) {
2593       tty-&gt;print(&quot;#  Schedule BB#%03d (initial)\n&quot;, i);
2594       for (uint j = 0; j &lt; bb-&gt;number_of_nodes(); j++) {
2595         bb-&gt;get_node(j)-&gt;dump();
2596       }
2597     }
2598 #endif
2599 
2600     // On the head node, skip processing
2601     if (bb == _cfg-&gt;get_root_block()) {
2602       continue;
2603     }
2604 
2605     // Skip empty, connector blocks
</pre>
<hr />
<pre>
2653         (last-&gt;is_Mach() &amp;&amp; last-&gt;as_Mach()-&gt;ideal_Opcode() == Op_Halt) ) {
2654       // There might be a prior call.  Skip it.
2655       while (_bb_start &lt; _bb_end &amp;&amp; bb-&gt;get_node(--_bb_end)-&gt;is_MachProj());
2656     } else if( last-&gt;is_MachNullCheck() ) {
2657       // Backup so the last null-checked memory instruction is
2658       // outside the schedulable range. Skip over the nullcheck,
2659       // projection, and the memory nodes.
2660       Node *mem = last-&gt;in(1);
2661       do {
2662         _bb_end--;
2663       } while (mem != bb-&gt;get_node(_bb_end));
2664     } else {
2665       // Set _bb_end to point after last schedulable inst.
2666       _bb_end++;
2667     }
2668 
2669     assert( _bb_start &lt;= _bb_end, &quot;inverted block ends&quot; );
2670 
2671     // Compute the register antidependencies for the basic block
2672     ComputeRegisterAntidependencies(bb);
<span class="line-modified">2673     if (C-&gt;failing())  return;  // too many D-U pinch points</span>
2674 
2675     // Compute intra-bb latencies for the nodes
2676     ComputeLocalLatenciesForward(bb);
2677 
2678     // Compute the usage within the block, and set the list of all nodes
2679     // in the block that have no uses within the block.
2680     ComputeUseCount(bb);
2681 
2682     // Schedule the remaining instructions in the block
2683     while ( _available.size() &gt; 0 ) {
2684       Node *n = ChooseNodeToBundle();
2685       guarantee(n != NULL, &quot;no nodes available&quot;);
2686       AddNodeToBundle(n,bb);
2687     }
2688 
2689     assert( _scheduled.size() == _bb_end - _bb_start, &quot;wrong number of instructions&quot; );
2690 #ifdef ASSERT
2691     for( uint l = _bb_start; l &lt; _bb_end; l++ ) {
2692       Node *n = bb-&gt;get_node(l);
2693       uint m;
</pre>
<hr />
<pre>
2713           if (bundle-&gt;instr_count() &gt; 0 || bundle-&gt;flags() &gt; 0) {
2714             tty-&gt;print(&quot;*** Bundle: &quot;);
2715             bundle-&gt;dump();
2716           }
2717           n-&gt;dump();
2718         }
2719       }
2720     }
2721 #endif
2722 #ifdef ASSERT
2723     verify_good_schedule(bb,&quot;after block local scheduling&quot;);
2724 #endif
2725   }
2726 
2727 #ifndef PRODUCT
2728   if (_cfg-&gt;C-&gt;trace_opto_output())
2729     tty-&gt;print(&quot;# &lt;- DoScheduling\n&quot;);
2730 #endif
2731 
2732   // Record final node-bundling array location
<span class="line-modified">2733   _regalloc-&gt;C-&gt;output()-&gt;set_node_bundling_base(_node_bundling_base);</span>
2734 
2735 } // end DoScheduling
2736 
2737 // Verify that no live-range used in the block is killed in the block by a
2738 // wrong DEF.  This doesn&#39;t verify live-ranges that span blocks.
2739 
2740 // Check for edge existence.  Used to avoid adding redundant precedence edges.
2741 static bool edge_from_to( Node *from, Node *to ) {
2742   for( uint i=0; i&lt;from-&gt;len(); i++ )
2743     if( from-&gt;in(i) == to )
2744       return true;
2745   return false;
2746 }
2747 
2748 #ifdef ASSERT
2749 void Scheduling::verify_do_def( Node *n, OptoReg::Name def, const char *msg ) {
2750   // Check for bad kills
2751   if( OptoReg::is_valid(def) ) { // Ignore stores &amp; control flow
2752     Node *prior_use = _reg_node[def];
2753     if( prior_use &amp;&amp; !edge_from_to(prior_use,n) ) {
</pre>
<hr />
<pre>
2820     from-&gt;add_prec(to);
2821 }
2822 
2823 void Scheduling::anti_do_def( Block *b, Node *def, OptoReg::Name def_reg, int is_def ) {
2824   if( !OptoReg::is_valid(def_reg) ) // Ignore stores &amp; control flow
2825     return;
2826 
2827   Node *pinch = _reg_node[def_reg]; // Get pinch point
2828   if ((pinch == NULL) || _cfg-&gt;get_block_for_node(pinch) != b || // No pinch-point yet?
2829       is_def ) {    // Check for a true def (not a kill)
2830     _reg_node.map(def_reg,def); // Record def/kill as the optimistic pinch-point
2831     return;
2832   }
2833 
2834   Node *kill = def;             // Rename &#39;def&#39; to more descriptive &#39;kill&#39;
2835   debug_only( def = (Node*)((intptr_t)0xdeadbeef); )
2836 
2837   // After some number of kills there _may_ be a later def
2838   Node *later_def = NULL;
2839 
<span class="line-added">2840   Compile* C = Compile::current();</span>
<span class="line-added">2841 </span>
2842   // Finding a kill requires a real pinch-point.
2843   // Check for not already having a pinch-point.
2844   // Pinch points are Op_Node&#39;s.
2845   if( pinch-&gt;Opcode() != Op_Node ) { // Or later-def/kill as pinch-point?
2846     later_def = pinch;            // Must be def/kill as optimistic pinch-point
2847     if ( _pinch_free_list.size() &gt; 0) {
2848       pinch = _pinch_free_list.pop();
2849     } else {
2850       pinch = new Node(1); // Pinch point to-be
2851     }
2852     if (pinch-&gt;_idx &gt;= _regalloc-&gt;node_regs_max_index()) {
2853       _cfg-&gt;C-&gt;record_method_not_compilable(&quot;too many D-U pinch points&quot;);
2854       return;
2855     }
2856     _cfg-&gt;map_node_to_block(pinch, b);      // Pretend it&#39;s valid in this block (lazy init)
2857     _reg_node.map(def_reg,pinch); // Record pinch-point
<span class="line-modified">2858     //regalloc()-&gt;set_bad(pinch-&gt;_idx); // Already initialized this way.</span>
2859     if( later_def-&gt;outcnt() == 0 || later_def-&gt;ideal_reg() == MachProjNode::fat_proj ) { // Distinguish def from kill
<span class="line-modified">2860       pinch-&gt;init_req(0, C-&gt;top());     // set not NULL for the next call</span>
2861       add_prec_edge_from_to(later_def,pinch); // Add edge from kill to pinch
2862       later_def = NULL;           // and no later def
2863     }
2864     pinch-&gt;set_req(0,later_def);  // Hook later def so we can find it
2865   } else {                        // Else have valid pinch point
2866     if( pinch-&gt;in(0) )            // If there is a later-def
2867       later_def = pinch-&gt;in(0);   // Get it
2868   }
2869 
2870   // Add output-dependence edge from later def to kill
2871   if( later_def )               // If there is some original def
2872     add_prec_edge_from_to(later_def,kill); // Add edge from def to kill
2873 
2874   // See if current kill is also a use, and so is forced to be the pinch-point.
2875   if( pinch-&gt;Opcode() == Op_Node ) {
2876     Node *uses = kill-&gt;is_Proj() ? kill-&gt;in(0) : kill;
2877     for( uint i=1; i&lt;uses-&gt;req(); i++ ) {
2878       if( _regalloc-&gt;get_reg_first(uses-&gt;in(i)) == def_reg ||
2879           _regalloc-&gt;get_reg_second(uses-&gt;in(i)) == def_reg ) {
2880         // Yes, found a use/kill pinch-point
</pre>
<hr />
<pre>
3143                _total_branches, _total_unconditional_delays);
3144     if (_total_branches &gt; 0)
3145       tty-&gt;print(&quot;, for %.2f%%&quot;,
3146                  ((double)_total_unconditional_delays) / ((double)_total_branches) * 100.0);
3147     tty-&gt;print(&quot;\n&quot;);
3148   }
3149 
3150   uint total_instructions = 0, total_bundles = 0;
3151 
3152   for (uint i = 1; i &lt;= Pipeline::_max_instrs_per_cycle; i++) {
3153     uint bundle_count   = _total_instructions_per_bundle[i];
3154     total_instructions += bundle_count * i;
3155     total_bundles      += bundle_count;
3156   }
3157 
3158   if (total_bundles &gt; 0)
3159     tty-&gt;print(&quot;Average ILP (excluding nops) is %.2f\n&quot;,
3160                ((double)total_instructions) / ((double)total_bundles));
3161 }
3162 #endif
<span class="line-added">3163 </span>
<span class="line-added">3164 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-added">3165 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-added">3166 void PhaseOutput::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-added">3167   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-added">3168   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-added">3169   // current and allocate a new one.</span>
<span class="line-added">3170   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-added">3171   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-added">3172     // Use the current blob.</span>
<span class="line-added">3173   } else {</span>
<span class="line-added">3174     if (blob != NULL) {</span>
<span class="line-added">3175       BufferBlob::free(blob);</span>
<span class="line-added">3176     }</span>
<span class="line-added">3177 </span>
<span class="line-added">3178     ResourceMark rm;</span>
<span class="line-added">3179     _scratch_const_size = const_size;</span>
<span class="line-added">3180     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-added">3181     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-added">3182     // Record the buffer blob for next time.</span>
<span class="line-added">3183     set_scratch_buffer_blob(blob);</span>
<span class="line-added">3184     // Have we run out of code space?</span>
<span class="line-added">3185     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-added">3186       // Let CompilerBroker disable further compilations.</span>
<span class="line-added">3187       C-&gt;record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-added">3188       return;</span>
<span class="line-added">3189     }</span>
<span class="line-added">3190   }</span>
<span class="line-added">3191 </span>
<span class="line-added">3192   // Initialize the relocation buffers</span>
<span class="line-added">3193   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-added">3194   set_scratch_locs_memory(locs_buf);</span>
<span class="line-added">3195 }</span>
<span class="line-added">3196 </span>
<span class="line-added">3197 </span>
<span class="line-added">3198 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-added">3199 // Helper function that computes size by emitting code</span>
<span class="line-added">3200 uint PhaseOutput::scratch_emit_size(const Node* n) {</span>
<span class="line-added">3201   // Start scratch_emit_size section.</span>
<span class="line-added">3202   set_in_scratch_emit_size(true);</span>
<span class="line-added">3203 </span>
<span class="line-added">3204   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-added">3205   // This is a pretty expensive way to compute a size,</span>
<span class="line-added">3206   // but it works well enough if seldom used.</span>
<span class="line-added">3207   // All common fixed-size instructions are given a size</span>
<span class="line-added">3208   // method by the AD file.</span>
<span class="line-added">3209   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-added">3210   // allocated at the beginning of the compile task, and</span>
<span class="line-added">3211   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-added">3212   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-added">3213   // expensive, since it has to grab the code cache lock.</span>
<span class="line-added">3214   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-added">3215   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-added">3216   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-added">3217   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-added">3218   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-added">3219   address blob_end   = (address)locs_buf;</span>
<span class="line-added">3220   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-added">3221   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-added">3222   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-added">3223   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-added">3224   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-added">3225   int lsize = MAX_locs_size / 3;</span>
<span class="line-added">3226   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-added">3227   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-added">3228   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-added">3229   // Mark as scratch buffer.</span>
<span class="line-added">3230   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-added">3231   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-added">3232   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-added">3233 </span>
<span class="line-added">3234   // Do the emission.</span>
<span class="line-added">3235 </span>
<span class="line-added">3236   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-added">3237   Label*   saveL = NULL;</span>
<span class="line-added">3238   uint save_bnum = 0;</span>
<span class="line-added">3239   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-added">3240   if (is_branch) {</span>
<span class="line-added">3241     MacroAssembler masm(&amp;buf);</span>
<span class="line-added">3242     masm.bind(fakeL);</span>
<span class="line-added">3243     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-added">3244     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-added">3245   }</span>
<span class="line-added">3246   n-&gt;emit(buf, C-&gt;regalloc());</span>
<span class="line-added">3247 </span>
<span class="line-added">3248   // Emitting into the scratch buffer should not fail</span>
<span class="line-added">3249   assert (!C-&gt;failing(), &quot;Must not have pending failure. Reason is: %s&quot;, C-&gt;failure_reason());</span>
<span class="line-added">3250 </span>
<span class="line-added">3251   if (is_branch) // Restore label.</span>
<span class="line-added">3252     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-added">3253 </span>
<span class="line-added">3254   // End scratch_emit_size section.</span>
<span class="line-added">3255   set_in_scratch_emit_size(false);</span>
<span class="line-added">3256 </span>
<span class="line-added">3257   return buf.insts_size();</span>
<span class="line-added">3258 }</span>
<span class="line-added">3259 </span>
<span class="line-added">3260 void PhaseOutput::install() {</span>
<span class="line-added">3261   if (C-&gt;stub_function() != NULL) {</span>
<span class="line-added">3262     install_stub(C-&gt;stub_name(),</span>
<span class="line-added">3263                  C-&gt;save_argument_registers());</span>
<span class="line-added">3264   } else {</span>
<span class="line-added">3265     install_code(C-&gt;method(),</span>
<span class="line-added">3266                  C-&gt;entry_bci(),</span>
<span class="line-added">3267                  CompileBroker::compiler2(),</span>
<span class="line-added">3268                  C-&gt;has_unsafe_access(),</span>
<span class="line-added">3269                  SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-added">3270                  C-&gt;rtm_state());</span>
<span class="line-added">3271   }</span>
<span class="line-added">3272 }</span>
<span class="line-added">3273 </span>
<span class="line-added">3274 void PhaseOutput::install_code(ciMethod*         target,</span>
<span class="line-added">3275                                int               entry_bci,</span>
<span class="line-added">3276                                AbstractCompiler* compiler,</span>
<span class="line-added">3277                                bool              has_unsafe_access,</span>
<span class="line-added">3278                                bool              has_wide_vectors,</span>
<span class="line-added">3279                                RTMState          rtm_state) {</span>
<span class="line-added">3280   // Check if we want to skip execution of all compiled code.</span>
<span class="line-added">3281   {</span>
<span class="line-added">3282 #ifndef PRODUCT</span>
<span class="line-added">3283     if (OptoNoExecute) {</span>
<span class="line-added">3284       C-&gt;record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-added">3285       return;</span>
<span class="line-added">3286     }</span>
<span class="line-added">3287 #endif</span>
<span class="line-added">3288     Compile::TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-added">3289 </span>
<span class="line-added">3290     if (C-&gt;is_osr_compilation()) {</span>
<span class="line-added">3291       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-added">3292       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-added">3293     } else {</span>
<span class="line-added">3294       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-added">3295       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-added">3296     }</span>
<span class="line-added">3297 </span>
<span class="line-added">3298     C-&gt;env()-&gt;register_method(target,</span>
<span class="line-added">3299                                      entry_bci,</span>
<span class="line-added">3300                                      &amp;_code_offsets,</span>
<span class="line-added">3301                                      _orig_pc_slot_offset_in_bytes,</span>
<span class="line-added">3302                                      code_buffer(),</span>
<span class="line-added">3303                                      frame_size_in_words(),</span>
<span class="line-added">3304                                      oop_map_set(),</span>
<span class="line-added">3305                                      &amp;_handler_table,</span>
<span class="line-added">3306                                      inc_table(),</span>
<span class="line-added">3307                                      compiler,</span>
<span class="line-added">3308                                      has_unsafe_access,</span>
<span class="line-added">3309                                      SharedRuntime::is_wide_vector(C-&gt;max_vector_size()),</span>
<span class="line-added">3310                                      C-&gt;rtm_state());</span>
<span class="line-added">3311 </span>
<span class="line-added">3312     if (C-&gt;log() != NULL) { // Print code cache state into compiler log</span>
<span class="line-added">3313       C-&gt;log()-&gt;code_cache_state();</span>
<span class="line-added">3314     }</span>
<span class="line-added">3315   }</span>
<span class="line-added">3316 }</span>
<span class="line-added">3317 void PhaseOutput::install_stub(const char* stub_name,</span>
<span class="line-added">3318                                bool        caller_must_gc_arguments) {</span>
<span class="line-added">3319   // Entry point will be accessed using stub_entry_point();</span>
<span class="line-added">3320   if (code_buffer() == NULL) {</span>
<span class="line-added">3321     Matcher::soft_match_failure();</span>
<span class="line-added">3322   } else {</span>
<span class="line-added">3323     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-added">3324       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
<span class="line-added">3325 </span>
<span class="line-added">3326     if (!C-&gt;failing()) {</span>
<span class="line-added">3327       assert(C-&gt;fixed_slots() == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="line-added">3328 </span>
<span class="line-added">3329       // Make the NMethod</span>
<span class="line-added">3330       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-added">3331       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-added">3332                                                       code_buffer(),</span>
<span class="line-added">3333                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-added">3334                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-added">3335                                                       frame_size_in_words(),</span>
<span class="line-added">3336                                                       oop_map_set(),</span>
<span class="line-added">3337                                                       caller_must_gc_arguments);</span>
<span class="line-added">3338       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-added">3339 </span>
<span class="line-added">3340       C-&gt;set_stub_entry_point(rs-&gt;entry_point());</span>
<span class="line-added">3341     }</span>
<span class="line-added">3342   }</span>
<span class="line-added">3343 }</span>
<span class="line-added">3344 </span>
<span class="line-added">3345 // Support for bundling info</span>
<span class="line-added">3346 Bundle* PhaseOutput::node_bundling(const Node *n) {</span>
<span class="line-added">3347   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-added">3348   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-added">3349 }</span>
<span class="line-added">3350 </span>
<span class="line-added">3351 bool PhaseOutput::valid_bundle_info(const Node *n) {</span>
<span class="line-added">3352   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-added">3353 }</span>
<span class="line-added">3354 </span>
<span class="line-added">3355 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-added">3356 // frame_slots in units of words</span>
<span class="line-added">3357 int PhaseOutput::frame_size_in_words() const {</span>
<span class="line-added">3358   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-added">3359   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-added">3360   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-added">3361   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-added">3362   return words;</span>
<span class="line-added">3363 }</span>
<span class="line-added">3364 </span>
<span class="line-added">3365 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-added">3366 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-added">3367 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-added">3368 // in turn simplifies stack overflow handling.</span>
<span class="line-added">3369 int PhaseOutput::bang_size_in_bytes() const {</span>
<span class="line-added">3370   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), C-&gt;interpreter_frame_size());</span>
<span class="line-added">3371 }</span>
<span class="line-added">3372 </span>
<span class="line-added">3373 //------------------------------dump_asm---------------------------------------</span>
<span class="line-added">3374 // Dump formatted assembly</span>
<span class="line-added">3375 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-added">3376 void PhaseOutput::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-added">3377 </span>
<span class="line-added">3378   int pc_digits = 3; // #chars required for pc</span>
<span class="line-added">3379   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-added">3380   int tab_size  = 8;</span>
<span class="line-added">3381   if (pcs != NULL) {</span>
<span class="line-added">3382     int max_pc = 0;</span>
<span class="line-added">3383     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-added">3384       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-added">3385     }</span>
<span class="line-added">3386     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-added">3387   }</span>
<span class="line-added">3388   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-added">3389 </span>
<span class="line-added">3390   bool cut_short = false;</span>
<span class="line-added">3391   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-added">3392   st-&gt;print(&quot;#  &quot;);  C-&gt;tf()-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-added">3393   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-added">3394 </span>
<span class="line-added">3395   // For all blocks</span>
<span class="line-added">3396   int pc = 0x0;                 // Program counter</span>
<span class="line-added">3397   char starts_bundle = &#39; &#39;;</span>
<span class="line-added">3398   C-&gt;regalloc()-&gt;dump_frame();</span>
<span class="line-added">3399 </span>
<span class="line-added">3400   Node *n = NULL;</span>
<span class="line-added">3401   for (uint i = 0; i &lt; C-&gt;cfg()-&gt;number_of_blocks(); i++) {</span>
<span class="line-added">3402     if (VMThread::should_terminate()) {</span>
<span class="line-added">3403       cut_short = true;</span>
<span class="line-added">3404       break;</span>
<span class="line-added">3405     }</span>
<span class="line-added">3406     Block* block = C-&gt;cfg()-&gt;get_block(i);</span>
<span class="line-added">3407     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-added">3408       continue;</span>
<span class="line-added">3409     }</span>
<span class="line-added">3410     n = block-&gt;head();</span>
<span class="line-added">3411     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3412       pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3413       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3414     }</span>
<span class="line-added">3415     st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3416     block-&gt;dump_head(C-&gt;cfg(), st);</span>
<span class="line-added">3417     if (block-&gt;is_connector()) {</span>
<span class="line-added">3418       st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3419       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-added">3420     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-added">3421       st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3422       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-added">3423     }</span>
<span class="line-added">3424 </span>
<span class="line-added">3425     // For all instructions</span>
<span class="line-added">3426     Node *delay = NULL;</span>
<span class="line-added">3427     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-added">3428       if (VMThread::should_terminate()) {</span>
<span class="line-added">3429         cut_short = true;</span>
<span class="line-added">3430         break;</span>
<span class="line-added">3431       }</span>
<span class="line-added">3432       n = block-&gt;get_node(j);</span>
<span class="line-added">3433       if (valid_bundle_info(n)) {</span>
<span class="line-added">3434         Bundle* bundle = node_bundling(n);</span>
<span class="line-added">3435         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-added">3436           delay = n;</span>
<span class="line-added">3437           continue;</span>
<span class="line-added">3438         }</span>
<span class="line-added">3439         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-added">3440           starts_bundle = &#39;+&#39;;</span>
<span class="line-added">3441         }</span>
<span class="line-added">3442       }</span>
<span class="line-added">3443 </span>
<span class="line-added">3444       if (WizardMode) {</span>
<span class="line-added">3445         n-&gt;dump();</span>
<span class="line-added">3446       }</span>
<span class="line-added">3447 </span>
<span class="line-added">3448       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-added">3449           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-added">3450           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-added">3451           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-added">3452           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-added">3453           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-added">3454           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-added">3455           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-added">3456           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-added">3457           ) {</span>
<span class="line-added">3458         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3459           pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3460           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3461         } else {</span>
<span class="line-added">3462           st-&gt;fill_to(pc_digits);</span>
<span class="line-added">3463         }</span>
<span class="line-added">3464         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-added">3465         starts_bundle = &#39; &#39;;</span>
<span class="line-added">3466         st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3467         n-&gt;format(C-&gt;regalloc(), st);</span>
<span class="line-added">3468         st-&gt;cr();</span>
<span class="line-added">3469       }</span>
<span class="line-added">3470 </span>
<span class="line-added">3471       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-added">3472       // then back up and print it</span>
<span class="line-added">3473       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-added">3474         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-added">3475         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-added">3476         if (WizardMode) delay-&gt;dump();</span>
<span class="line-added">3477 </span>
<span class="line-added">3478         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-added">3479           starts_bundle = &#39;+&#39;;</span>
<span class="line-added">3480         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-added">3481           pc = pcs[n-&gt;_idx];</span>
<span class="line-added">3482           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-added">3483         } else {</span>
<span class="line-added">3484           st-&gt;fill_to(pc_digits);</span>
<span class="line-added">3485         }</span>
<span class="line-added">3486         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-added">3487         starts_bundle = &#39; &#39;;</span>
<span class="line-added">3488         st-&gt;fill_to(prefix_len);</span>
<span class="line-added">3489         delay-&gt;format(C-&gt;regalloc(), st);</span>
<span class="line-added">3490         st-&gt;cr();</span>
<span class="line-added">3491         delay = NULL;</span>
<span class="line-added">3492       }</span>
<span class="line-added">3493 </span>
<span class="line-added">3494       // Dump the exception table as well</span>
<span class="line-added">3495       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-added">3496         // Print the exception table for this offset</span>
<span class="line-added">3497         _handler_table.print_subtable_for(pc);</span>
<span class="line-added">3498       }</span>
<span class="line-added">3499       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-added">3500     }</span>
<span class="line-added">3501     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-added">3502     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-added">3503   } // End of per-block dump</span>
<span class="line-added">3504 </span>
<span class="line-added">3505   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-added">3506 }</span>
<span class="line-added">3507 #endif</span>
<span class="line-added">3508 </span>
<span class="line-added">3509 #ifndef PRODUCT</span>
<span class="line-added">3510 void PhaseOutput::print_statistics() {</span>
<span class="line-added">3511   Scheduling::print_statistics();</span>
<span class="line-added">3512 }</span>
<span class="line-added">3513 #endif</span>
</pre>
</td>
</tr>
</table>
<center><a href="node.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="output.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
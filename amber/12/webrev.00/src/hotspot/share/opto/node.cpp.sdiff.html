<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/node.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/node.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;

  31 #include &quot;opto/castnode.hpp&quot;
  32 #include &quot;opto/cfgnode.hpp&quot;
  33 #include &quot;opto/connode.hpp&quot;
  34 #include &quot;opto/loopnode.hpp&quot;
  35 #include &quot;opto/machnode.hpp&quot;
  36 #include &quot;opto/matcher.hpp&quot;
  37 #include &quot;opto/node.hpp&quot;
  38 #include &quot;opto/opcodes.hpp&quot;
  39 #include &quot;opto/regmask.hpp&quot;
  40 #include &quot;opto/rootnode.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/copy.hpp&quot;
  43 #include &quot;utilities/macros.hpp&quot;
  44 #include &quot;utilities/powerOfTwo.hpp&quot;
  45 
  46 class RegMask;
  47 // #include &quot;phase.hpp&quot;
  48 class PhaseTransform;
  49 class PhaseGVN;
  50 
</pre>
<hr />
<pre>
1016 uint Node::size_of() const { return sizeof(*this); }
1017 
1018 //------------------------------ideal_reg--------------------------------------
1019 uint Node::ideal_reg() const { return 0; }
1020 
1021 //------------------------------jvms-------------------------------------------
1022 JVMState* Node::jvms() const { return NULL; }
1023 
1024 #ifdef ASSERT
1025 //------------------------------jvms-------------------------------------------
1026 bool Node::verify_jvms(const JVMState* using_jvms) const {
1027   for (JVMState* jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
1028     if (jvms == using_jvms)  return true;
1029   }
1030   return false;
1031 }
1032 
1033 //------------------------------init_NodeProperty------------------------------
1034 void Node::init_NodeProperty() {
1035   assert(_max_classes &lt;= max_jushort, &quot;too many NodeProperty classes&quot;);
<span class="line-modified">1036   assert(_max_flags &lt;= max_jushort, &quot;too many NodeProperty flags&quot;);</span>





1037 }
1038 #endif
1039 
1040 //------------------------------format-----------------------------------------
1041 // Print as assembly
1042 void Node::format( PhaseRegAlloc *, outputStream *st ) const {}
1043 //------------------------------emit-------------------------------------------
1044 // Emit bytes starting at parameter &#39;ptr&#39;.
1045 void Node::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1046 //------------------------------size-------------------------------------------
1047 // Size of instruction in bytes
1048 uint Node::size(PhaseRegAlloc *ra_) const { return 0; }
1049 
1050 //------------------------------CFG Construction-------------------------------
1051 // Nodes that end basic blocks, e.g. IfTrue/IfFalse, JumpProjNode, Root,
1052 // Goto and Return.
1053 const Node *Node::is_block_proj() const { return 0; }
1054 
1055 // Minimum guaranteed type
1056 const Type *Node::bottom_type() const { return Type::BOTTOM; }
</pre>
<hr />
<pre>
1607   return result;
1608 }
1609 #endif
1610 
1611 
1612 
1613 #ifndef PRODUCT
1614 
1615 // -----------------------------Name-------------------------------------------
1616 extern const char *NodeClassNames[];
1617 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1618 
1619 static bool is_disconnected(const Node* n) {
1620   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1621     if (n-&gt;in(i) != NULL)  return false;
1622   }
1623   return true;
1624 }
1625 
1626 #ifdef ASSERT
<span class="line-modified">1627 static void dump_orig(Node* orig, outputStream *st) {</span>
1628   Compile* C = Compile::current();

1629   if (NotANode(orig)) orig = NULL;
1630   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1631   if (orig == NULL) return;
<span class="line-modified">1632   st-&gt;print(&quot; !orig=&quot;);</span>


1633   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1634   if (NotANode(fast)) fast = NULL;
1635   while (orig != NULL) {
1636     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1637     if (discon) st-&gt;print(&quot;[&quot;);
1638     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1639       st-&gt;print(&quot;o&quot;);
1640     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1641     if (discon) st-&gt;print(&quot;]&quot;);
1642     orig = orig-&gt;debug_orig();
1643     if (NotANode(orig)) orig = NULL;
1644     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1645     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1646     if (fast != NULL) {
1647       // Step fast twice for each single step of orig:
1648       fast = fast-&gt;debug_orig();
1649       if (NotANode(fast)) fast = NULL;
1650       if (fast != NULL &amp;&amp; fast != orig) {
1651         fast = fast-&gt;debug_orig();
1652         if (NotANode(fast)) fast = NULL;
</pre>
<hr />
<pre>
1677 }
1678 #endif //ASSERT
1679 
1680 //------------------------------dump------------------------------------------
1681 // Dump a Node
1682 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1683   Compile* C = Compile::current();
1684   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1685   C-&gt;_in_dump_cnt++;
1686   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1687 
1688   // Dump the required and precedence inputs
1689   dump_req(st);
1690   dump_prec(st);
1691   // Dump the outputs
1692   dump_out(st);
1693 
1694   if (is_disconnected(this)) {
1695 #ifdef ASSERT
1696     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
<span class="line-modified">1697     dump_orig(debug_orig(), st);</span>
1698 #endif
1699     st-&gt;cr();
1700     C-&gt;_in_dump_cnt--;
1701     return;                     // don&#39;t process dead nodes
1702   }
1703 
1704   if (C-&gt;clone_map().value(_idx) != 0) {
1705     C-&gt;clone_map().dump(_idx);
1706   }
1707   // Dump node-specific info
1708   dump_spec(st);
1709 #ifdef ASSERT
1710   // Dump the non-reset _debug_idx
1711   if (Verbose &amp;&amp; WizardMode) {
1712     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1713   }
1714 #endif
1715 
1716   const Type *t = bottom_type();
1717 
</pre>
<hr />
<pre>
1725       st-&gt;print(&quot;  Oop:&quot;);
1726     } else if (tkls) {
1727       st-&gt;print(&quot;  Klass:&quot;);
1728     }
1729     t-&gt;dump_on(st);
1730   } else if (t == Type::MEMORY) {
1731     st-&gt;print(&quot;  Memory:&quot;);
1732     MemNode::dump_adr_type(this, adr_type(), st);
1733   } else if (Verbose || WizardMode) {
1734     st-&gt;print(&quot;  Type:&quot;);
1735     if (t) {
1736       t-&gt;dump_on(st);
1737     } else {
1738       st-&gt;print(&quot;no type&quot;);
1739     }
1740   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1741     // Dump MachSpillcopy vector type.
1742     t-&gt;dump_on(st);
1743   }
1744   if (is_new) {
<span class="line-modified">1745     debug_only(dump_orig(debug_orig(), st));</span>
1746     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1747     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1748       if (nn-&gt;jvms() != NULL) {
1749         st-&gt;print(&quot; !jvms:&quot;);
1750         nn-&gt;jvms()-&gt;dump_spec(st);
1751       }
1752     }
1753   }
1754   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1755   C-&gt;_in_dump_cnt--;
1756 }
1757 
1758 //------------------------------dump_req--------------------------------------
1759 void Node::dump_req(outputStream *st) const {
1760   // Dump the required input edges
1761   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1762     Node* d = in(i);
1763     if (d == NULL) {
1764       st-&gt;print(&quot;_ &quot;);
1765     } else if (NotANode(d)) {
</pre>
</td>
<td>
<hr />
<pre>
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;gc/shared/barrierSet.hpp&quot;
  27 #include &quot;gc/shared/c2/barrierSetC2.hpp&quot;
  28 #include &quot;libadt/vectset.hpp&quot;
  29 #include &quot;memory/allocation.inline.hpp&quot;
  30 #include &quot;memory/resourceArea.hpp&quot;
<span class="line-added">  31 #include &quot;opto/ad.hpp&quot;</span>
  32 #include &quot;opto/castnode.hpp&quot;
  33 #include &quot;opto/cfgnode.hpp&quot;
  34 #include &quot;opto/connode.hpp&quot;
  35 #include &quot;opto/loopnode.hpp&quot;
  36 #include &quot;opto/machnode.hpp&quot;
  37 #include &quot;opto/matcher.hpp&quot;
  38 #include &quot;opto/node.hpp&quot;
  39 #include &quot;opto/opcodes.hpp&quot;
  40 #include &quot;opto/regmask.hpp&quot;
  41 #include &quot;opto/rootnode.hpp&quot;
  42 #include &quot;opto/type.hpp&quot;
  43 #include &quot;utilities/copy.hpp&quot;
  44 #include &quot;utilities/macros.hpp&quot;
  45 #include &quot;utilities/powerOfTwo.hpp&quot;
  46 
  47 class RegMask;
  48 // #include &quot;phase.hpp&quot;
  49 class PhaseTransform;
  50 class PhaseGVN;
  51 
</pre>
<hr />
<pre>
1017 uint Node::size_of() const { return sizeof(*this); }
1018 
1019 //------------------------------ideal_reg--------------------------------------
1020 uint Node::ideal_reg() const { return 0; }
1021 
1022 //------------------------------jvms-------------------------------------------
1023 JVMState* Node::jvms() const { return NULL; }
1024 
1025 #ifdef ASSERT
1026 //------------------------------jvms-------------------------------------------
1027 bool Node::verify_jvms(const JVMState* using_jvms) const {
1028   for (JVMState* jvms = this-&gt;jvms(); jvms != NULL; jvms = jvms-&gt;caller()) {
1029     if (jvms == using_jvms)  return true;
1030   }
1031   return false;
1032 }
1033 
1034 //------------------------------init_NodeProperty------------------------------
1035 void Node::init_NodeProperty() {
1036   assert(_max_classes &lt;= max_jushort, &quot;too many NodeProperty classes&quot;);
<span class="line-modified">1037   assert(max_flags() &lt;= max_jushort, &quot;too many NodeProperty flags&quot;);</span>
<span class="line-added">1038 }</span>
<span class="line-added">1039 </span>
<span class="line-added">1040 //-----------------------------max_flags---------------------------------------</span>
<span class="line-added">1041 juint Node::max_flags() {</span>
<span class="line-added">1042   return (PD::_last_flag &lt;&lt; 1) - 1; // allow flags combination</span>
1043 }
1044 #endif
1045 
1046 //------------------------------format-----------------------------------------
1047 // Print as assembly
1048 void Node::format( PhaseRegAlloc *, outputStream *st ) const {}
1049 //------------------------------emit-------------------------------------------
1050 // Emit bytes starting at parameter &#39;ptr&#39;.
1051 void Node::emit(CodeBuffer &amp;cbuf, PhaseRegAlloc *ra_) const {}
1052 //------------------------------size-------------------------------------------
1053 // Size of instruction in bytes
1054 uint Node::size(PhaseRegAlloc *ra_) const { return 0; }
1055 
1056 //------------------------------CFG Construction-------------------------------
1057 // Nodes that end basic blocks, e.g. IfTrue/IfFalse, JumpProjNode, Root,
1058 // Goto and Return.
1059 const Node *Node::is_block_proj() const { return 0; }
1060 
1061 // Minimum guaranteed type
1062 const Type *Node::bottom_type() const { return Type::BOTTOM; }
</pre>
<hr />
<pre>
1613   return result;
1614 }
1615 #endif
1616 
1617 
1618 
1619 #ifndef PRODUCT
1620 
1621 // -----------------------------Name-------------------------------------------
1622 extern const char *NodeClassNames[];
1623 const char *Node::Name() const { return NodeClassNames[Opcode()]; }
1624 
1625 static bool is_disconnected(const Node* n) {
1626   for (uint i = 0; i &lt; n-&gt;req(); i++) {
1627     if (n-&gt;in(i) != NULL)  return false;
1628   }
1629   return true;
1630 }
1631 
1632 #ifdef ASSERT
<span class="line-modified">1633 void Node::dump_orig(outputStream *st, bool print_key) const {</span>
1634   Compile* C = Compile::current();
<span class="line-added">1635   Node* orig = _debug_orig;</span>
1636   if (NotANode(orig)) orig = NULL;
1637   if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1638   if (orig == NULL) return;
<span class="line-modified">1639   if (print_key) {</span>
<span class="line-added">1640     st-&gt;print(&quot; !orig=&quot;);</span>
<span class="line-added">1641   }</span>
1642   Node* fast = orig-&gt;debug_orig(); // tortoise &amp; hare algorithm to detect loops
1643   if (NotANode(fast)) fast = NULL;
1644   while (orig != NULL) {
1645     bool discon = is_disconnected(orig);  // if discon, print [123] else 123
1646     if (discon) st-&gt;print(&quot;[&quot;);
1647     if (!Compile::current()-&gt;node_arena()-&gt;contains(orig))
1648       st-&gt;print(&quot;o&quot;);
1649     st-&gt;print(&quot;%d&quot;, orig-&gt;_idx);
1650     if (discon) st-&gt;print(&quot;]&quot;);
1651     orig = orig-&gt;debug_orig();
1652     if (NotANode(orig)) orig = NULL;
1653     if (orig != NULL &amp;&amp; !C-&gt;node_arena()-&gt;contains(orig)) orig = NULL;
1654     if (orig != NULL) st-&gt;print(&quot;,&quot;);
1655     if (fast != NULL) {
1656       // Step fast twice for each single step of orig:
1657       fast = fast-&gt;debug_orig();
1658       if (NotANode(fast)) fast = NULL;
1659       if (fast != NULL &amp;&amp; fast != orig) {
1660         fast = fast-&gt;debug_orig();
1661         if (NotANode(fast)) fast = NULL;
</pre>
<hr />
<pre>
1686 }
1687 #endif //ASSERT
1688 
1689 //------------------------------dump------------------------------------------
1690 // Dump a Node
1691 void Node::dump(const char* suffix, bool mark, outputStream *st) const {
1692   Compile* C = Compile::current();
1693   bool is_new = C-&gt;node_arena()-&gt;contains(this);
1694   C-&gt;_in_dump_cnt++;
1695   st-&gt;print(&quot;%c%d%s\t%s\t=== &quot;, is_new ? &#39; &#39; : &#39;o&#39;, _idx, mark ? &quot; &gt;&quot; : &quot;&quot;, Name());
1696 
1697   // Dump the required and precedence inputs
1698   dump_req(st);
1699   dump_prec(st);
1700   // Dump the outputs
1701   dump_out(st);
1702 
1703   if (is_disconnected(this)) {
1704 #ifdef ASSERT
1705     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
<span class="line-modified">1706     dump_orig(st);</span>
1707 #endif
1708     st-&gt;cr();
1709     C-&gt;_in_dump_cnt--;
1710     return;                     // don&#39;t process dead nodes
1711   }
1712 
1713   if (C-&gt;clone_map().value(_idx) != 0) {
1714     C-&gt;clone_map().dump(_idx);
1715   }
1716   // Dump node-specific info
1717   dump_spec(st);
1718 #ifdef ASSERT
1719   // Dump the non-reset _debug_idx
1720   if (Verbose &amp;&amp; WizardMode) {
1721     st-&gt;print(&quot;  [%d]&quot;,debug_idx());
1722   }
1723 #endif
1724 
1725   const Type *t = bottom_type();
1726 
</pre>
<hr />
<pre>
1734       st-&gt;print(&quot;  Oop:&quot;);
1735     } else if (tkls) {
1736       st-&gt;print(&quot;  Klass:&quot;);
1737     }
1738     t-&gt;dump_on(st);
1739   } else if (t == Type::MEMORY) {
1740     st-&gt;print(&quot;  Memory:&quot;);
1741     MemNode::dump_adr_type(this, adr_type(), st);
1742   } else if (Verbose || WizardMode) {
1743     st-&gt;print(&quot;  Type:&quot;);
1744     if (t) {
1745       t-&gt;dump_on(st);
1746     } else {
1747       st-&gt;print(&quot;no type&quot;);
1748     }
1749   } else if (t-&gt;isa_vect() &amp;&amp; this-&gt;is_MachSpillCopy()) {
1750     // Dump MachSpillcopy vector type.
1751     t-&gt;dump_on(st);
1752   }
1753   if (is_new) {
<span class="line-modified">1754     DEBUG_ONLY(dump_orig(st));</span>
1755     Node_Notes* nn = C-&gt;node_notes_at(_idx);
1756     if (nn != NULL &amp;&amp; !nn-&gt;is_clear()) {
1757       if (nn-&gt;jvms() != NULL) {
1758         st-&gt;print(&quot; !jvms:&quot;);
1759         nn-&gt;jvms()-&gt;dump_spec(st);
1760       }
1761     }
1762   }
1763   if (suffix) st-&gt;print(&quot;%s&quot;, suffix);
1764   C-&gt;_in_dump_cnt--;
1765 }
1766 
1767 //------------------------------dump_req--------------------------------------
1768 void Node::dump_req(outputStream *st) const {
1769   // Dump the required input edges
1770   for (uint i = 0; i &lt; req(); i++) {    // For all required inputs
1771     Node* d = in(i);
1772     if (d == NULL) {
1773       st-&gt;print(&quot;_ &quot;);
1774     } else if (NotANode(d)) {
</pre>
</td>
</tr>
</table>
<center><a href="memnode.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="node.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
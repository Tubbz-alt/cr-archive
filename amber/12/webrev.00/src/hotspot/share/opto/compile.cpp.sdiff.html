<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/share/opto/compile.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/share/opto/compile.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
  59 #include &quot;opto/mulnode.hpp&quot;
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/vectornode.hpp&quot;
  71 #include &quot;runtime/arguments.hpp&quot;
  72 #include &quot;runtime/sharedRuntime.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/stubRoutines.hpp&quot;
  75 #include &quot;runtime/timer.hpp&quot;
  76 #include &quot;utilities/align.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/macros.hpp&quot;

  79 
  80 
  81 // -------------------- Compile::mach_constant_base_node -----------------------
  82 // Constant table base node singleton.
  83 MachConstantBaseNode* Compile::mach_constant_base_node() {
  84   if (_mach_constant_base_node == NULL) {
  85     _mach_constant_base_node = new MachConstantBaseNode();
  86     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  87   }
  88   return _mach_constant_base_node;
  89 }
  90 
  91 
  92 /// Support for intrinsics.
  93 
  94 // Return the index at which m must be inserted (or already exists).
  95 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  96 class IntrinsicDescPair {
  97  private:
  98   ciMethod* _m;
</pre>
<hr />
<pre>
 233   #define PRINT_STAT_LINE(name, c, f) \
 234     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 235   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 236     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 237     int   flags = _intrinsic_hist_flags[id];
 238     juint count = _intrinsic_hist_count[id];
 239     if ((flags | count) != 0) {
 240       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 241     }
 242   }
 243   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 244   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 245 }
 246 
 247 void Compile::print_statistics() {
 248   { ttyLocker ttyl;
 249     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 250     Parse::print_statistics();
 251     PhaseCCP::print_statistics();
 252     PhaseRegAlloc::print_statistics();
<span class="line-modified"> 253     Scheduling::print_statistics();</span>
 254     PhasePeephole::print_statistics();
 255     PhaseIdealLoop::print_statistics();
 256     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 257   }
 258   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 259     // put this under its own &lt;statistics&gt; element.
 260     print_intrinsic_statistics();
 261   }
 262 }
 263 #endif //PRODUCT
 264 
<span class="line-removed"> 265 // Support for bundling info</span>
<span class="line-removed"> 266 Bundle* Compile::node_bundling(const Node *n) {</span>
<span class="line-removed"> 267   assert(valid_bundle_info(n), &quot;oob&quot;);</span>
<span class="line-removed"> 268   return &amp;_node_bundling_base[n-&gt;_idx];</span>
<span class="line-removed"> 269 }</span>
<span class="line-removed"> 270 </span>
<span class="line-removed"> 271 bool Compile::valid_bundle_info(const Node *n) {</span>
<span class="line-removed"> 272   return (_node_bundling_limit &gt; n-&gt;_idx);</span>
<span class="line-removed"> 273 }</span>
<span class="line-removed"> 274 </span>
<span class="line-removed"> 275 </span>
 276 void Compile::gvn_replace_by(Node* n, Node* nn) {
 277   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 278     Node* use = n-&gt;last_out(i);
 279     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 280     uint uses_found = 0;
 281     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 282       if (use-&gt;in(j) == n) {
 283         if (j &lt; use-&gt;req())
 284           use-&gt;set_req(j, nn);
 285         else
 286           use-&gt;set_prec(j, nn);
 287         uses_found++;
 288       }
 289     }
 290     if (is_in_table) {
 291       // reinsert into table
 292       initial_gvn()-&gt;hash_find_insert(use);
 293     }
 294     record_for_igvn(use);
 295     i -= uses_found;    // we deleted 1 or more copies of this edge
</pre>
<hr />
<pre>
 406     if (!useful.member(n)) {
 407       remove_expensive_node(n);
 408     }
 409   }
 410   // Remove useless Opaque4 nodes
 411   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 412     Node* opaq = opaque4_node(i);
 413     if (!useful.member(opaq)) {
 414       remove_opaque4_node(opaq);
 415     }
 416   }
 417   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 418   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 419   // clean up the late inline lists
 420   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 421   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 422   remove_useless_late_inlines(&amp;_late_inlines, useful);
 423   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 424 }
 425 
<span class="line-removed"> 426 //------------------------------frame_size_in_words-----------------------------</span>
<span class="line-removed"> 427 // frame_slots in units of words</span>
<span class="line-removed"> 428 int Compile::frame_size_in_words() const {</span>
<span class="line-removed"> 429   // shift is 0 in LP32 and 1 in LP64</span>
<span class="line-removed"> 430   const int shift = (LogBytesPerWord - LogBytesPerInt);</span>
<span class="line-removed"> 431   int words = _frame_slots &gt;&gt; shift;</span>
<span class="line-removed"> 432   assert( words &lt;&lt; shift == _frame_slots, &quot;frame size must be properly aligned in LP64&quot; );</span>
<span class="line-removed"> 433   return words;</span>
<span class="line-removed"> 434 }</span>
<span class="line-removed"> 435 </span>
<span class="line-removed"> 436 // To bang the stack of this compiled method we use the stack size</span>
<span class="line-removed"> 437 // that the interpreter would need in case of a deoptimization. This</span>
<span class="line-removed"> 438 // removes the need to bang the stack in the deoptimization blob which</span>
<span class="line-removed"> 439 // in turn simplifies stack overflow handling.</span>
<span class="line-removed"> 440 int Compile::bang_size_in_bytes() const {</span>
<span class="line-removed"> 441   return MAX2(frame_size_in_bytes() + os::extra_bang_size_in_bytes(), _interpreter_frame_size);</span>
<span class="line-removed"> 442 }</span>
<span class="line-removed"> 443 </span>
 444 // ============================================================================
 445 //------------------------------CompileWrapper---------------------------------
 446 class CompileWrapper : public StackObj {
 447   Compile *const _compile;
 448  public:
 449   CompileWrapper(Compile* compile);
 450 
 451   ~CompileWrapper();
 452 };
 453 
 454 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 455   // the Compile* pointer is stored in the current ciEnv:
 456   ciEnv* env = compile-&gt;env();
 457   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 458   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 459   env-&gt;set_compiler_data(compile);
 460   assert(compile == Compile::current(), &quot;sanity&quot;);
 461 
 462   compile-&gt;set_type_dict(NULL);
 463   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 464   compile-&gt;clone_map().set_clone_idx(0);
 465   compile-&gt;set_type_last_size(0);
 466   compile-&gt;set_last_tf(NULL, NULL);
 467   compile-&gt;set_indexSet_arena(NULL);
 468   compile-&gt;set_indexSet_free_block_list(NULL);
 469   compile-&gt;init_type_arena();
 470   Type::Initialize(compile);
<span class="line-removed"> 471   _compile-&gt;set_scratch_buffer_blob(NULL);</span>
 472   _compile-&gt;begin_method();
 473   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 474 }
 475 CompileWrapper::~CompileWrapper() {
 476   _compile-&gt;end_method();
<span class="line-removed"> 477   if (_compile-&gt;scratch_buffer_blob() != NULL)</span>
<span class="line-removed"> 478     BufferBlob::free(_compile-&gt;scratch_buffer_blob());</span>
 479   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 480 }
 481 
 482 
 483 //----------------------------print_compile_messages---------------------------
 484 void Compile::print_compile_messages() {
 485 #ifndef PRODUCT
 486   // Check if recompiling
 487   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 488     // Recompiling without allowing machine instructions to subsume loads
 489     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 490     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 491     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 492   }
 493   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 494     // Recompiling without escape analysis
 495     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 496     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 497     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 498   }
</pre>
<hr />
<pre>
 503     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 504   }
 505   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 506     // Open the debugger when compiling this method.
 507     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 508     method()-&gt;print_short_name();
 509     tty-&gt;cr();
 510     BREAKPOINT;
 511   }
 512 
 513   if( PrintOpto ) {
 514     if (is_osr_compilation()) {
 515       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 516     } else {
 517       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 518     }
 519   }
 520 #endif
 521 }
 522 
<span class="line-removed"> 523 </span>
<span class="line-removed"> 524 //-----------------------init_scratch_buffer_blob------------------------------</span>
<span class="line-removed"> 525 // Construct a temporary BufferBlob and cache it for this compile.</span>
<span class="line-removed"> 526 void Compile::init_scratch_buffer_blob(int const_size) {</span>
<span class="line-removed"> 527   // If there is already a scratch buffer blob allocated and the</span>
<span class="line-removed"> 528   // constant section is big enough, use it.  Otherwise free the</span>
<span class="line-removed"> 529   // current and allocate a new one.</span>
<span class="line-removed"> 530   BufferBlob* blob = scratch_buffer_blob();</span>
<span class="line-removed"> 531   if ((blob != NULL) &amp;&amp; (const_size &lt;= _scratch_const_size)) {</span>
<span class="line-removed"> 532     // Use the current blob.</span>
<span class="line-removed"> 533   } else {</span>
<span class="line-removed"> 534     if (blob != NULL) {</span>
<span class="line-removed"> 535       BufferBlob::free(blob);</span>
<span class="line-removed"> 536     }</span>
<span class="line-removed"> 537 </span>
<span class="line-removed"> 538     ResourceMark rm;</span>
<span class="line-removed"> 539     _scratch_const_size = const_size;</span>
<span class="line-removed"> 540     int size = C2Compiler::initial_code_buffer_size(const_size);</span>
<span class="line-removed"> 541     blob = BufferBlob::create(&quot;Compile::scratch_buffer&quot;, size);</span>
<span class="line-removed"> 542     // Record the buffer blob for next time.</span>
<span class="line-removed"> 543     set_scratch_buffer_blob(blob);</span>
<span class="line-removed"> 544     // Have we run out of code space?</span>
<span class="line-removed"> 545     if (scratch_buffer_blob() == NULL) {</span>
<span class="line-removed"> 546       // Let CompilerBroker disable further compilations.</span>
<span class="line-removed"> 547       record_failure(&quot;Not enough space for scratch buffer in CodeCache&quot;);</span>
<span class="line-removed"> 548       return;</span>
<span class="line-removed"> 549     }</span>
<span class="line-removed"> 550   }</span>
<span class="line-removed"> 551 </span>
<span class="line-removed"> 552   // Initialize the relocation buffers</span>
<span class="line-removed"> 553   relocInfo* locs_buf = (relocInfo*) blob-&gt;content_end() - MAX_locs_size;</span>
<span class="line-removed"> 554   set_scratch_locs_memory(locs_buf);</span>
<span class="line-removed"> 555 }</span>
<span class="line-removed"> 556 </span>
<span class="line-removed"> 557 </span>
<span class="line-removed"> 558 //-----------------------scratch_emit_size-------------------------------------</span>
<span class="line-removed"> 559 // Helper function that computes size by emitting code</span>
<span class="line-removed"> 560 uint Compile::scratch_emit_size(const Node* n) {</span>
<span class="line-removed"> 561   // Start scratch_emit_size section.</span>
<span class="line-removed"> 562   set_in_scratch_emit_size(true);</span>
<span class="line-removed"> 563 </span>
<span class="line-removed"> 564   // Emit into a trash buffer and count bytes emitted.</span>
<span class="line-removed"> 565   // This is a pretty expensive way to compute a size,</span>
<span class="line-removed"> 566   // but it works well enough if seldom used.</span>
<span class="line-removed"> 567   // All common fixed-size instructions are given a size</span>
<span class="line-removed"> 568   // method by the AD file.</span>
<span class="line-removed"> 569   // Note that the scratch buffer blob and locs memory are</span>
<span class="line-removed"> 570   // allocated at the beginning of the compile task, and</span>
<span class="line-removed"> 571   // may be shared by several calls to scratch_emit_size.</span>
<span class="line-removed"> 572   // The allocation of the scratch buffer blob is particularly</span>
<span class="line-removed"> 573   // expensive, since it has to grab the code cache lock.</span>
<span class="line-removed"> 574   BufferBlob* blob = this-&gt;scratch_buffer_blob();</span>
<span class="line-removed"> 575   assert(blob != NULL, &quot;Initialize BufferBlob at start&quot;);</span>
<span class="line-removed"> 576   assert(blob-&gt;size() &gt; MAX_inst_size, &quot;sanity&quot;);</span>
<span class="line-removed"> 577   relocInfo* locs_buf = scratch_locs_memory();</span>
<span class="line-removed"> 578   address blob_begin = blob-&gt;content_begin();</span>
<span class="line-removed"> 579   address blob_end   = (address)locs_buf;</span>
<span class="line-removed"> 580   assert(blob-&gt;contains(blob_end), &quot;sanity&quot;);</span>
<span class="line-removed"> 581   CodeBuffer buf(blob_begin, blob_end - blob_begin);</span>
<span class="line-removed"> 582   buf.initialize_consts_size(_scratch_const_size);</span>
<span class="line-removed"> 583   buf.initialize_stubs_size(MAX_stubs_size);</span>
<span class="line-removed"> 584   assert(locs_buf != NULL, &quot;sanity&quot;);</span>
<span class="line-removed"> 585   int lsize = MAX_locs_size / 3;</span>
<span class="line-removed"> 586   buf.consts()-&gt;initialize_shared_locs(&amp;locs_buf[lsize * 0], lsize);</span>
<span class="line-removed"> 587   buf.insts()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 1], lsize);</span>
<span class="line-removed"> 588   buf.stubs()-&gt;initialize_shared_locs( &amp;locs_buf[lsize * 2], lsize);</span>
<span class="line-removed"> 589   // Mark as scratch buffer.</span>
<span class="line-removed"> 590   buf.consts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 591   buf.insts()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 592   buf.stubs()-&gt;set_scratch_emit();</span>
<span class="line-removed"> 593 </span>
<span class="line-removed"> 594   // Do the emission.</span>
<span class="line-removed"> 595 </span>
<span class="line-removed"> 596   Label fakeL; // Fake label for branch instructions.</span>
<span class="line-removed"> 597   Label*   saveL = NULL;</span>
<span class="line-removed"> 598   uint save_bnum = 0;</span>
<span class="line-removed"> 599   bool is_branch = n-&gt;is_MachBranch();</span>
<span class="line-removed"> 600   if (is_branch) {</span>
<span class="line-removed"> 601     MacroAssembler masm(&amp;buf);</span>
<span class="line-removed"> 602     masm.bind(fakeL);</span>
<span class="line-removed"> 603     n-&gt;as_MachBranch()-&gt;save_label(&amp;saveL, &amp;save_bnum);</span>
<span class="line-removed"> 604     n-&gt;as_MachBranch()-&gt;label_set(&amp;fakeL, 0);</span>
<span class="line-removed"> 605   }</span>
<span class="line-removed"> 606   n-&gt;emit(buf, this-&gt;regalloc());</span>
<span class="line-removed"> 607 </span>
<span class="line-removed"> 608   // Emitting into the scratch buffer should not fail</span>
<span class="line-removed"> 609   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());</span>
<span class="line-removed"> 610 </span>
<span class="line-removed"> 611   if (is_branch) // Restore label.</span>
<span class="line-removed"> 612     n-&gt;as_MachBranch()-&gt;label_set(saveL, save_bnum);</span>
<span class="line-removed"> 613 </span>
<span class="line-removed"> 614   // End scratch_emit_size section.</span>
<span class="line-removed"> 615   set_in_scratch_emit_size(false);</span>
<span class="line-removed"> 616 </span>
<span class="line-removed"> 617   return buf.insts_size();</span>
<span class="line-removed"> 618 }</span>
<span class="line-removed"> 619 </span>
<span class="line-removed"> 620 </span>
 621 // ============================================================================
 622 //------------------------------Compile standard-------------------------------
 623 debug_only( int Compile::_debug_idx = 100000; )
 624 
 625 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 626 // the continuation bci for on stack replacement.
 627 
 628 
<span class="line-modified"> 629 Compile::Compile( ciEnv* ci_env, C2Compiler* compiler, ciMethod* target, int osr_bci,</span>
 630                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 631                 : Phase(Compiler),
 632                   _compile_id(ci_env-&gt;compile_id()),
 633                   _save_argument_registers(false),
 634                   _subsume_loads(subsume_loads),
 635                   _do_escape_analysis(do_escape_analysis),
 636                   _eliminate_boxing(eliminate_boxing),
 637                   _method(target),
 638                   _entry_bci(osr_bci),
 639                   _stub_function(NULL),
 640                   _stub_name(NULL),
 641                   _stub_entry_point(NULL),
 642                   _max_node_limit(MaxNodeLimit),
<span class="line-removed"> 643                   _orig_pc_slot(0),</span>
<span class="line-removed"> 644                   _orig_pc_slot_offset_in_bytes(0),</span>
 645                   _inlining_progress(false),
 646                   _inlining_incrementally(false),
 647                   _do_cleanup(false),
 648                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 649 #ifndef PRODUCT
 650                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 651                   _print_ideal(directive-&gt;PrintIdealOption),
 652 #endif
 653                   _has_method_handle_invokes(false),
 654                   _clinit_barrier_on_entry(false),
 655                   _comp_arena(mtCompiler),
 656                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 657                   _env(ci_env),
 658                   _directive(directive),
 659                   _log(ci_env-&gt;log()),
 660                   _failure_reason(NULL),
 661                   _congraph(NULL),
 662 #ifndef PRODUCT
 663                   _printer(IdealGraphPrinter::printer()),
 664 #endif
</pre>
<hr />
<pre>
 666                   _dead_node_count(0),
 667                   _node_arena(mtCompiler),
 668                   _old_arena(mtCompiler),
 669                   _mach_constant_base_node(NULL),
 670                   _Compile_types(mtCompiler),
 671                   _initial_gvn(NULL),
 672                   _for_igvn(NULL),
 673                   _warm_calls(NULL),
 674                   _late_inlines(comp_arena(), 2, 0, NULL),
 675                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 676                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 677                   _late_inlines_pos(0),
 678                   _number_of_mh_late_inlines(0),
 679                   _print_inlining_stream(NULL),
 680                   _print_inlining_list(NULL),
 681                   _print_inlining_idx(0),
 682                   _print_inlining_output(NULL),
 683                   _replay_inline_data(NULL),
 684                   _java_calls(0),
 685                   _inner_loops(0),
<span class="line-modified"> 686                   _interpreter_frame_size(0),</span>
<span class="line-removed"> 687                   _node_bundling_limit(0),</span>
<span class="line-removed"> 688                   _node_bundling_base(NULL),</span>
<span class="line-removed"> 689                   _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
<span class="line-removed"> 690                   _scratch_const_size(-1),</span>
<span class="line-removed"> 691                   _in_scratch_emit_size(false)</span>
 692 #ifndef PRODUCT
 693                   , _in_dump_cnt(0)
 694 #endif
 695 {
 696   C = this;
 697 #ifndef PRODUCT
 698   if (_printer != NULL) {
 699     _printer-&gt;set_compile(this);
 700   }
 701 #endif
 702   CompileWrapper cw(this);
 703 
 704   if (CITimeVerbose) {
 705     tty-&gt;print(&quot; &quot;);
 706     target-&gt;holder()-&gt;name()-&gt;print();
 707     tty-&gt;print(&quot;.&quot;);
 708     target-&gt;print_short_name();
 709     tty-&gt;print(&quot;  &quot;);
 710   }
 711   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
</pre>
<hr />
<pre>
 889       xtty-&gt;tail(&quot;ideal&quot;);
 890     }
 891   }
 892 #endif
 893 
 894 #ifdef ASSERT
 895   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 896   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 897 #endif
 898 
 899   // Dump compilation data to replay it.
 900   if (directive-&gt;DumpReplayOption) {
 901     env()-&gt;dump_replay_data(_compile_id);
 902   }
 903   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 904     env()-&gt;dump_inline_data(_compile_id);
 905   }
 906 
 907   // Now that we know the size of all the monitors we can add a fixed slot
 908   // for the original deopt pc.
<span class="line-modified"> 909 </span>
<span class="line-removed"> 910   _orig_pc_slot =  fixed_slots();</span>
<span class="line-removed"> 911   int next_slot = _orig_pc_slot + (sizeof(address) / VMRegImpl::stack_slot_size);</span>
 912   set_fixed_slots(next_slot);
 913 
 914   // Compute when to use implicit null checks. Used by matching trap based
 915   // nodes and NullCheck optimization.
 916   set_allowed_deopt_reasons();
 917 
 918   // Now generate code
 919   Code_Gen();
<span class="line-removed"> 920   if (failing())  return;</span>
<span class="line-removed"> 921 </span>
<span class="line-removed"> 922   // Check if we want to skip execution of all compiled code.</span>
<span class="line-removed"> 923   {</span>
<span class="line-removed"> 924 #ifndef PRODUCT</span>
<span class="line-removed"> 925     if (OptoNoExecute) {</span>
<span class="line-removed"> 926       record_method_not_compilable(&quot;+OptoNoExecute&quot;);  // Flag as failed</span>
<span class="line-removed"> 927       return;</span>
<span class="line-removed"> 928     }</span>
<span class="line-removed"> 929 #endif</span>
<span class="line-removed"> 930     TracePhase tp(&quot;install_code&quot;, &amp;timers[_t_registerMethod]);</span>
<span class="line-removed"> 931 </span>
<span class="line-removed"> 932     if (is_osr_compilation()) {</span>
<span class="line-removed"> 933       _code_offsets.set_value(CodeOffsets::Verified_Entry, 0);</span>
<span class="line-removed"> 934       _code_offsets.set_value(CodeOffsets::OSR_Entry, _first_block_size);</span>
<span class="line-removed"> 935     } else {</span>
<span class="line-removed"> 936       _code_offsets.set_value(CodeOffsets::Verified_Entry, _first_block_size);</span>
<span class="line-removed"> 937       _code_offsets.set_value(CodeOffsets::OSR_Entry, 0);</span>
<span class="line-removed"> 938     }</span>
<span class="line-removed"> 939 </span>
<span class="line-removed"> 940     env()-&gt;register_method(_method, _entry_bci,</span>
<span class="line-removed"> 941                            &amp;_code_offsets,</span>
<span class="line-removed"> 942                            _orig_pc_slot_offset_in_bytes,</span>
<span class="line-removed"> 943                            code_buffer(),</span>
<span class="line-removed"> 944                            frame_size_in_words(), _oop_map_set,</span>
<span class="line-removed"> 945                            &amp;_handler_table, &amp;_inc_table,</span>
<span class="line-removed"> 946                            compiler,</span>
<span class="line-removed"> 947                            has_unsafe_access(),</span>
<span class="line-removed"> 948                            SharedRuntime::is_wide_vector(max_vector_size()),</span>
<span class="line-removed"> 949                            rtm_state()</span>
<span class="line-removed"> 950                            );</span>
<span class="line-removed"> 951 </span>
<span class="line-removed"> 952     if (log() != NULL) // Print code cache state into compiler log</span>
<span class="line-removed"> 953       log()-&gt;code_cache_state();</span>
<span class="line-removed"> 954   }</span>
 955 }
 956 
 957 //------------------------------Compile----------------------------------------
 958 // Compile a runtime stub
 959 Compile::Compile( ciEnv* ci_env,
 960                   TypeFunc_generator generator,
 961                   address stub_function,
 962                   const char *stub_name,
 963                   int is_fancy_jump,
 964                   bool pass_tls,
 965                   bool save_arg_registers,
 966                   bool return_pc,
 967                   DirectiveSet* directive)
 968   : Phase(Compiler),
 969     _compile_id(0),
 970     _save_argument_registers(save_arg_registers),
 971     _subsume_loads(true),
 972     _do_escape_analysis(false),
 973     _eliminate_boxing(false),
 974     _method(NULL),
 975     _entry_bci(InvocationEntryBci),
 976     _stub_function(stub_function),
 977     _stub_name(stub_name),
 978     _stub_entry_point(NULL),
 979     _max_node_limit(MaxNodeLimit),
<span class="line-removed"> 980     _orig_pc_slot(0),</span>
<span class="line-removed"> 981     _orig_pc_slot_offset_in_bytes(0),</span>
 982     _inlining_progress(false),
 983     _inlining_incrementally(false),
 984     _has_reserved_stack_access(false),
 985 #ifndef PRODUCT
 986     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 987     _print_ideal(directive-&gt;PrintIdealOption),
 988 #endif
 989     _has_method_handle_invokes(false),
 990     _clinit_barrier_on_entry(false),
 991     _comp_arena(mtCompiler),
 992     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 993     _env(ci_env),
 994     _directive(directive),
 995     _log(ci_env-&gt;log()),
 996     _failure_reason(NULL),
 997     _congraph(NULL),
 998 #ifndef PRODUCT
 999     _printer(NULL),
1000 #endif
1001     _dead_node_list(comp_arena()),
1002     _dead_node_count(0),
1003     _node_arena(mtCompiler),
1004     _old_arena(mtCompiler),
1005     _mach_constant_base_node(NULL),
1006     _Compile_types(mtCompiler),
1007     _initial_gvn(NULL),
1008     _for_igvn(NULL),
1009     _warm_calls(NULL),
1010     _number_of_mh_late_inlines(0),
1011     _print_inlining_stream(NULL),
1012     _print_inlining_list(NULL),
1013     _print_inlining_idx(0),
1014     _print_inlining_output(NULL),
1015     _replay_inline_data(NULL),
1016     _java_calls(0),
1017     _inner_loops(0),
1018     _interpreter_frame_size(0),
<span class="line-removed">1019     _node_bundling_limit(0),</span>
<span class="line-removed">1020     _node_bundling_base(NULL),</span>
<span class="line-removed">1021     _code_buffer(&quot;Compile::Fill_buffer&quot;),</span>
1022 #ifndef PRODUCT
1023     _in_dump_cnt(0),
1024 #endif
1025     _allowed_reasons(0) {
1026   C = this;
1027 
1028   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
1029   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
1030 
1031 #ifndef PRODUCT
1032   set_print_assembly(PrintFrameConverterAssembly);
1033   set_parsed_irreducible_loop(false);
1034 #else
1035   set_print_assembly(false); // Must initialize.
1036 #endif
1037   set_has_irreducible_loop(false); // no loops
1038 
1039   CompileWrapper cw(this);
1040   Init(/*AliasLevel=*/ 0);
1041   init_tf((*generator)());
1042 
1043   {
1044     // The following is a dummy for the sake of GraphKit::gen_stub
1045     Unique_Node_List for_igvn(comp_arena());
1046     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
1047     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
1048     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
1049     gvn.transform_no_reclaim(top());
1050 
1051     GraphKit kit;
1052     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
1053   }
1054 
1055   NOT_PRODUCT( verify_graph_edges(); )
<span class="line-removed">1056   Code_Gen();</span>
<span class="line-removed">1057   if (failing())  return;</span>
<span class="line-removed">1058 </span>
<span class="line-removed">1059 </span>
<span class="line-removed">1060   // Entry point will be accessed using compile-&gt;stub_entry_point();</span>
<span class="line-removed">1061   if (code_buffer() == NULL) {</span>
<span class="line-removed">1062     Matcher::soft_match_failure();</span>
<span class="line-removed">1063   } else {</span>
<span class="line-removed">1064     if (PrintAssembly &amp;&amp; (WizardMode || Verbose))</span>
<span class="line-removed">1065       tty-&gt;print_cr(&quot;### Stub::%s&quot;, stub_name);</span>
1066 
<span class="line-modified">1067     if (!failing()) {</span>
<span class="line-removed">1068       assert(_fixed_slots == 0, &quot;no fixed slots used for runtime stubs&quot;);</span>
<span class="line-removed">1069 </span>
<span class="line-removed">1070       // Make the NMethod</span>
<span class="line-removed">1071       // For now we mark the frame as never safe for profile stackwalking</span>
<span class="line-removed">1072       RuntimeStub *rs = RuntimeStub::new_runtime_stub(stub_name,</span>
<span class="line-removed">1073                                                       code_buffer(),</span>
<span class="line-removed">1074                                                       CodeOffsets::frame_never_safe,</span>
<span class="line-removed">1075                                                       // _code_offsets.value(CodeOffsets::Frame_Complete),</span>
<span class="line-removed">1076                                                       frame_size_in_words(),</span>
<span class="line-removed">1077                                                       _oop_map_set,</span>
<span class="line-removed">1078                                                       save_arg_registers);</span>
<span class="line-removed">1079       assert(rs != NULL &amp;&amp; rs-&gt;is_runtime_stub(), &quot;sanity check&quot;);</span>
<span class="line-removed">1080 </span>
<span class="line-removed">1081       _stub_entry_point = rs-&gt;entry_point();</span>
<span class="line-removed">1082     }</span>
<span class="line-removed">1083   }</span>
1084 }
1085 
1086 //------------------------------Init-------------------------------------------
1087 // Prepare for a single compilation
1088 void Compile::Init(int aliaslevel) {
1089   _unique  = 0;
1090   _regalloc = NULL;
1091 
1092   _tf      = NULL;  // filled in later
1093   _top     = NULL;  // cached later
1094   _matcher = NULL;  // filled in later
1095   _cfg     = NULL;  // filled in later
1096 
1097   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )
1098 
1099   _node_note_array = NULL;
1100   _default_node_notes = NULL;
1101   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
1102 
1103   _immutable_memory = NULL; // filled in at first inquiry
</pre>
<hr />
<pre>
1197   {
1198     for (int i = 0; i &lt; grow_ats; i++)  _alias_types[i] = &amp;ats[i];
1199   }
1200   // Initialize the first few types.
1201   _alias_types[AliasIdxTop]-&gt;Init(AliasIdxTop, NULL);
1202   _alias_types[AliasIdxBot]-&gt;Init(AliasIdxBot, TypePtr::BOTTOM);
1203   _alias_types[AliasIdxRaw]-&gt;Init(AliasIdxRaw, TypeRawPtr::BOTTOM);
1204   _num_alias_types = AliasIdxRaw+1;
1205   // Zero out the alias type cache.
1206   Copy::zero_to_bytes(_alias_cache, sizeof(_alias_cache));
1207   // A NULL adr_type hits in the cache right away.  Preload the right answer.
1208   probe_alias_cache(NULL)-&gt;_index = AliasIdxTop;
1209 
1210   _intrinsics = NULL;
1211   _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1212   _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1213   _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1214   _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1215   _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1216   register_library_intrinsics();



1217 }
1218 
1219 //---------------------------init_start----------------------------------------
1220 // Install the StartNode on this compile object.
1221 void Compile::init_start(StartNode* s) {
1222   if (failing())
1223     return; // already failing
1224   assert(s == start(), &quot;&quot;);
1225 }
1226 
1227 /**
1228  * Return the &#39;StartNode&#39;. We must not have a pending failure, since the ideal graph
1229  * can be in an inconsistent state, i.e., we can get segmentation faults when traversing
1230  * the ideal graph.
1231  */
1232 StartNode* Compile::start() const {
1233   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());
1234   for (DUIterator_Fast imax, i = root()-&gt;fast_outs(imax); i &lt; imax; i++) {
1235     Node* start = root()-&gt;fast_out(i);
1236     if (start-&gt;is_Start()) {
</pre>
<hr />
<pre>
2413       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2414       return;
2415     }
2416     print_method(PHASE_MACRO_EXPANSION, 2);
2417   }
2418 
2419   {
2420     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2421     if (bs-&gt;expand_barriers(this, igvn)) {
2422       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2423       return;
2424     }
2425     print_method(PHASE_BARRIER_EXPANSION, 2);
2426   }
2427 
2428   if (opaque4_count() &gt; 0) {
2429     C-&gt;remove_opaque4_nodes(igvn);
2430     igvn.optimize();
2431   }
2432 





2433   DEBUG_ONLY( _modified_nodes = NULL; )
2434  } // (End scope of igvn; run destructor if necessary for asserts.)
2435 
2436  process_print_inlining();
2437  // A method with only infinite loops has no edges entering loops from root
2438  {
2439    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2440    if (final_graph_reshaping()) {
2441      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2442      return;
2443    }
2444  }
2445 
2446  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2447 }
2448 























































































































































































































































































































2449 
2450 //------------------------------Code_Gen---------------------------------------
2451 // Given a graph, generate code for it
2452 void Compile::Code_Gen() {
2453   if (failing()) {
2454     return;
2455   }
2456 
2457   // Perform instruction selection.  You might think we could reclaim Matcher
2458   // memory PDQ, but actually the Matcher is used in generating spill code.
2459   // Internals of the Matcher (including some VectorSets) must remain live
2460   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2461   // set a bit in reclaimed memory.
2462 
2463   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2464   // nodes.  Mapping is only valid at the root of each matched subtree.
2465   NOT_PRODUCT( verify_graph_edges(); )
2466 
2467   Matcher matcher;
2468   _matcher = &amp;matcher;
</pre>
<hr />
<pre>
2529       cfg.set_loop_alignment();
2530     }
2531     cfg.fixup_flow();
2532   }
2533 
2534   // Apply peephole optimizations
2535   if( OptoPeephole ) {
2536     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2537     PhasePeephole peep( _regalloc, cfg);
2538     peep.do_transform();
2539   }
2540 
2541   // Do late expand if CPU requires this.
2542   if (Matcher::require_postalloc_expand) {
2543     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2544     cfg.postalloc_expand(_regalloc);
2545   }
2546 
2547   // Convert Nodes to instruction bits in a buffer
2548   {
<span class="line-modified">2549     TraceTime tp(&quot;output&quot;, &amp;timers[_t_output], CITime);</span>
<span class="line-modified">2550     Output();</span>



2551   }
2552 
2553   print_method(PHASE_FINAL_CODE);
2554 
2555   // He&#39;s dead, Jim.
2556   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2557   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2558 }
2559 
<span class="line-removed">2560 </span>
<span class="line-removed">2561 //------------------------------dump_asm---------------------------------------</span>
<span class="line-removed">2562 // Dump formatted assembly</span>
<span class="line-removed">2563 #if defined(SUPPORT_OPTO_ASSEMBLY)</span>
<span class="line-removed">2564 void Compile::dump_asm_on(outputStream* st, int* pcs, uint pc_limit) {</span>
<span class="line-removed">2565 </span>
<span class="line-removed">2566   int pc_digits = 3; // #chars required for pc</span>
<span class="line-removed">2567   int sb_chars  = 3; // #chars for &quot;start bundle&quot; indicator</span>
<span class="line-removed">2568   int tab_size  = 8;</span>
<span class="line-removed">2569   if (pcs != NULL) {</span>
<span class="line-removed">2570     int max_pc = 0;</span>
<span class="line-removed">2571     for (uint i = 0; i &lt; pc_limit; i++) {</span>
<span class="line-removed">2572       max_pc = (max_pc &lt; pcs[i]) ? pcs[i] : max_pc;</span>
<span class="line-removed">2573     }</span>
<span class="line-removed">2574     pc_digits  = ((max_pc &lt; 4096) ? 3 : ((max_pc &lt; 65536) ? 4 : ((max_pc &lt; 65536*256) ? 6 : 8))); // #chars required for pc</span>
<span class="line-removed">2575   }</span>
<span class="line-removed">2576   int prefix_len = ((pc_digits + sb_chars + tab_size - 1)/tab_size)*tab_size;</span>
<span class="line-removed">2577 </span>
<span class="line-removed">2578   bool cut_short = false;</span>
<span class="line-removed">2579   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">2580   st-&gt;print(&quot;#  &quot;);  _tf-&gt;dump_on(st);  st-&gt;cr();</span>
<span class="line-removed">2581   st-&gt;print_cr(&quot;#&quot;);</span>
<span class="line-removed">2582 </span>
<span class="line-removed">2583   // For all blocks</span>
<span class="line-removed">2584   int pc = 0x0;                 // Program counter</span>
<span class="line-removed">2585   char starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2586   _regalloc-&gt;dump_frame();</span>
<span class="line-removed">2587 </span>
<span class="line-removed">2588   Node *n = NULL;</span>
<span class="line-removed">2589   for (uint i = 0; i &lt; _cfg-&gt;number_of_blocks(); i++) {</span>
<span class="line-removed">2590     if (VMThread::should_terminate()) {</span>
<span class="line-removed">2591       cut_short = true;</span>
<span class="line-removed">2592       break;</span>
<span class="line-removed">2593     }</span>
<span class="line-removed">2594     Block* block = _cfg-&gt;get_block(i);</span>
<span class="line-removed">2595     if (block-&gt;is_connector() &amp;&amp; !Verbose) {</span>
<span class="line-removed">2596       continue;</span>
<span class="line-removed">2597     }</span>
<span class="line-removed">2598     n = block-&gt;head();</span>
<span class="line-removed">2599     if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2600       pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2601       st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2602     }</span>
<span class="line-removed">2603     st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2604     block-&gt;dump_head(_cfg, st);</span>
<span class="line-removed">2605     if (block-&gt;is_connector()) {</span>
<span class="line-removed">2606       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2607       st-&gt;print_cr(&quot;# Empty connector block&quot;);</span>
<span class="line-removed">2608     } else if (block-&gt;num_preds() == 2 &amp;&amp; block-&gt;pred(1)-&gt;is_CatchProj() &amp;&amp; block-&gt;pred(1)-&gt;as_CatchProj()-&gt;_con == CatchProjNode::fall_through_index) {</span>
<span class="line-removed">2609       st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2610       st-&gt;print_cr(&quot;# Block is sole successor of call&quot;);</span>
<span class="line-removed">2611     }</span>
<span class="line-removed">2612 </span>
<span class="line-removed">2613     // For all instructions</span>
<span class="line-removed">2614     Node *delay = NULL;</span>
<span class="line-removed">2615     for (uint j = 0; j &lt; block-&gt;number_of_nodes(); j++) {</span>
<span class="line-removed">2616       if (VMThread::should_terminate()) {</span>
<span class="line-removed">2617         cut_short = true;</span>
<span class="line-removed">2618         break;</span>
<span class="line-removed">2619       }</span>
<span class="line-removed">2620       n = block-&gt;get_node(j);</span>
<span class="line-removed">2621       if (valid_bundle_info(n)) {</span>
<span class="line-removed">2622         Bundle* bundle = node_bundling(n);</span>
<span class="line-removed">2623         if (bundle-&gt;used_in_unconditional_delay()) {</span>
<span class="line-removed">2624           delay = n;</span>
<span class="line-removed">2625           continue;</span>
<span class="line-removed">2626         }</span>
<span class="line-removed">2627         if (bundle-&gt;starts_bundle()) {</span>
<span class="line-removed">2628           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">2629         }</span>
<span class="line-removed">2630       }</span>
<span class="line-removed">2631 </span>
<span class="line-removed">2632       if (WizardMode) {</span>
<span class="line-removed">2633         n-&gt;dump();</span>
<span class="line-removed">2634       }</span>
<span class="line-removed">2635 </span>
<span class="line-removed">2636       if( !n-&gt;is_Region() &amp;&amp;    // Dont print in the Assembly</span>
<span class="line-removed">2637           !n-&gt;is_Phi() &amp;&amp;       // a few noisely useless nodes</span>
<span class="line-removed">2638           !n-&gt;is_Proj() &amp;&amp;</span>
<span class="line-removed">2639           !n-&gt;is_MachTemp() &amp;&amp;</span>
<span class="line-removed">2640           !n-&gt;is_SafePointScalarObject() &amp;&amp;</span>
<span class="line-removed">2641           !n-&gt;is_Catch() &amp;&amp;     // Would be nice to print exception table targets</span>
<span class="line-removed">2642           !n-&gt;is_MergeMem() &amp;&amp;  // Not very interesting</span>
<span class="line-removed">2643           !n-&gt;is_top() &amp;&amp;       // Debug info table constants</span>
<span class="line-removed">2644           !(n-&gt;is_Con() &amp;&amp; !n-&gt;is_Mach())// Debug info table constants</span>
<span class="line-removed">2645           ) {</span>
<span class="line-removed">2646         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2647           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2648           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2649         } else {</span>
<span class="line-removed">2650           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">2651         }</span>
<span class="line-removed">2652         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">2653         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2654         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2655         n-&gt;format(_regalloc, st);</span>
<span class="line-removed">2656         st-&gt;cr();</span>
<span class="line-removed">2657       }</span>
<span class="line-removed">2658 </span>
<span class="line-removed">2659       // If we have an instruction with a delay slot, and have seen a delay,</span>
<span class="line-removed">2660       // then back up and print it</span>
<span class="line-removed">2661       if (valid_bundle_info(n) &amp;&amp; node_bundling(n)-&gt;use_unconditional_delay()) {</span>
<span class="line-removed">2662         // Coverity finding - Explicit null dereferenced.</span>
<span class="line-removed">2663         guarantee(delay != NULL, &quot;no unconditional delay instruction&quot;);</span>
<span class="line-removed">2664         if (WizardMode) delay-&gt;dump();</span>
<span class="line-removed">2665 </span>
<span class="line-removed">2666         if (node_bundling(delay)-&gt;starts_bundle())</span>
<span class="line-removed">2667           starts_bundle = &#39;+&#39;;</span>
<span class="line-removed">2668         if ((pcs != NULL) &amp;&amp; (n-&gt;_idx &lt; pc_limit)) {</span>
<span class="line-removed">2669           pc = pcs[n-&gt;_idx];</span>
<span class="line-removed">2670           st-&gt;print(&quot;%*.*x&quot;, pc_digits, pc_digits, pc);</span>
<span class="line-removed">2671         } else {</span>
<span class="line-removed">2672           st-&gt;fill_to(pc_digits);</span>
<span class="line-removed">2673         }</span>
<span class="line-removed">2674         st-&gt;print(&quot; %c &quot;, starts_bundle);</span>
<span class="line-removed">2675         starts_bundle = &#39; &#39;;</span>
<span class="line-removed">2676         st-&gt;fill_to(prefix_len);</span>
<span class="line-removed">2677         delay-&gt;format(_regalloc, st);</span>
<span class="line-removed">2678         st-&gt;cr();</span>
<span class="line-removed">2679         delay = NULL;</span>
<span class="line-removed">2680       }</span>
<span class="line-removed">2681 </span>
<span class="line-removed">2682       // Dump the exception table as well</span>
<span class="line-removed">2683       if( n-&gt;is_Catch() &amp;&amp; (Verbose || WizardMode) ) {</span>
<span class="line-removed">2684         // Print the exception table for this offset</span>
<span class="line-removed">2685         _handler_table.print_subtable_for(pc);</span>
<span class="line-removed">2686       }</span>
<span class="line-removed">2687       st-&gt;bol(); // Make sure we start on a new line</span>
<span class="line-removed">2688     }</span>
<span class="line-removed">2689     st-&gt;cr(); // one empty line between blocks</span>
<span class="line-removed">2690     assert(cut_short || delay == NULL, &quot;no unconditional delay branch&quot;);</span>
<span class="line-removed">2691   } // End of per-block dump</span>
<span class="line-removed">2692 </span>
<span class="line-removed">2693   if (cut_short)  st-&gt;print_cr(&quot;*** disassembly is cut short ***&quot;);</span>
<span class="line-removed">2694 }</span>
<span class="line-removed">2695 #endif</span>
<span class="line-removed">2696 </span>
2697 //------------------------------Final_Reshape_Counts---------------------------
2698 // This class defines counters to help identify when a method
2699 // may/must be executed using hardware with only 24-bit precision.
2700 struct Final_Reshape_Counts : public StackObj {
2701   int  _call_count;             // count non-inlined &#39;common&#39; calls
2702   int  _float_count;            // count float ops requiring 24-bit precision
2703   int  _double_count;           // count double ops requiring more precision
2704   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
2705   int  _inner_loop_count;       // count loops which need alignment
2706   VectorSet _visited;           // Visitation flags
2707   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
2708 
2709   Final_Reshape_Counts() :
2710     _call_count(0), _float_count(0), _double_count(0),
2711     _java_call_count(0), _inner_loop_count(0),
2712     _visited( Thread::current()-&gt;resource_area() ) { }
2713 
2714   void inc_call_count  () { _call_count  ++; }
2715   void inc_float_count () { _float_count ++; }
2716   void inc_double_count() { _double_count++; }
</pre>
<hr />
<pre>
3356           n-&gt;subsume_by(sub, this);
3357         }
3358       }
3359     }
3360     break;
3361 
3362   case Op_LoadVector:
3363   case Op_StoreVector:
3364     break;
3365 
3366   case Op_AddReductionVI:
3367   case Op_AddReductionVL:
3368   case Op_AddReductionVF:
3369   case Op_AddReductionVD:
3370   case Op_MulReductionVI:
3371   case Op_MulReductionVL:
3372   case Op_MulReductionVF:
3373   case Op_MulReductionVD:
3374   case Op_MinReductionV:
3375   case Op_MaxReductionV:



3376     break;
3377 
3378   case Op_PackB:
3379   case Op_PackS:
3380   case Op_PackI:
3381   case Op_PackF:
3382   case Op_PackL:
3383   case Op_PackD:
3384     if (n-&gt;req()-1 &gt; 2) {
3385       // Replace many operand PackNodes with a binary tree for matching
3386       PackNode* p = (PackNode*) n;
3387       Node* btp = p-&gt;binary_tree_pack(1, n-&gt;req());
3388       n-&gt;subsume_by(btp, this);
3389     }
3390     break;
3391   case Op_Loop:
3392   case Op_CountedLoop:
3393   case Op_OuterStripMinedLoop:
3394     if (n-&gt;as_Loop()-&gt;is_inner_loop()) {
3395       frc.inc_inner_loop_count();
</pre>
<hr />
<pre>
3969   } else {
3970     _log = NULL;
3971   }
3972 
3973 #ifdef ASSERT
3974   if (PrintIdealNodeCount) {
3975     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
3976                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
3977   }
3978 
3979   if (VerifyIdealNodeCount) {
3980     Compile::current()-&gt;print_missing_nodes();
3981   }
3982 #endif
3983 
3984   if (_log != NULL) {
3985     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
3986   }
3987 }
3988 
<span class="line-removed">3989 //=============================================================================</span>
<span class="line-removed">3990 // Two Constant&#39;s are equal when the type and the value are equal.</span>
<span class="line-removed">3991 bool Compile::Constant::operator==(const Constant&amp; other) {</span>
<span class="line-removed">3992   if (type()          != other.type()         )  return false;</span>
<span class="line-removed">3993   if (can_be_reused() != other.can_be_reused())  return false;</span>
<span class="line-removed">3994   // For floating point values we compare the bit pattern.</span>
<span class="line-removed">3995   switch (type()) {</span>
<span class="line-removed">3996   case T_INT:</span>
<span class="line-removed">3997   case T_FLOAT:   return (_v._value.i == other._v._value.i);</span>
<span class="line-removed">3998   case T_LONG:</span>
<span class="line-removed">3999   case T_DOUBLE:  return (_v._value.j == other._v._value.j);</span>
<span class="line-removed">4000   case T_OBJECT:</span>
<span class="line-removed">4001   case T_ADDRESS: return (_v._value.l == other._v._value.l);</span>
<span class="line-removed">4002   case T_VOID:    return (_v._value.l == other._v._value.l);  // jump-table entries</span>
<span class="line-removed">4003   case T_METADATA: return (_v._metadata == other._v._metadata);</span>
<span class="line-removed">4004   default: ShouldNotReachHere(); return false;</span>
<span class="line-removed">4005   }</span>
<span class="line-removed">4006 }</span>
<span class="line-removed">4007 </span>
<span class="line-removed">4008 static int type_to_size_in_bytes(BasicType t) {</span>
<span class="line-removed">4009   switch (t) {</span>
<span class="line-removed">4010   case T_INT:     return sizeof(jint   );</span>
<span class="line-removed">4011   case T_LONG:    return sizeof(jlong  );</span>
<span class="line-removed">4012   case T_FLOAT:   return sizeof(jfloat );</span>
<span class="line-removed">4013   case T_DOUBLE:  return sizeof(jdouble);</span>
<span class="line-removed">4014   case T_METADATA: return sizeof(Metadata*);</span>
<span class="line-removed">4015     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4016     // need an internal word relocation.</span>
<span class="line-removed">4017   case T_VOID:</span>
<span class="line-removed">4018   case T_ADDRESS:</span>
<span class="line-removed">4019   case T_OBJECT:  return sizeof(jobject);</span>
<span class="line-removed">4020   default:</span>
<span class="line-removed">4021     ShouldNotReachHere();</span>
<span class="line-removed">4022     return -1;</span>
<span class="line-removed">4023   }</span>
<span class="line-removed">4024 }</span>
<span class="line-removed">4025 </span>
<span class="line-removed">4026 int Compile::ConstantTable::qsort_comparator(Constant* a, Constant* b) {</span>
<span class="line-removed">4027   // sort descending</span>
<span class="line-removed">4028   if (a-&gt;freq() &gt; b-&gt;freq())  return -1;</span>
<span class="line-removed">4029   if (a-&gt;freq() &lt; b-&gt;freq())  return  1;</span>
<span class="line-removed">4030   return 0;</span>
<span class="line-removed">4031 }</span>
<span class="line-removed">4032 </span>
<span class="line-removed">4033 void Compile::ConstantTable::calculate_offsets_and_size() {</span>
<span class="line-removed">4034   // First, sort the array by frequencies.</span>
<span class="line-removed">4035   _constants.sort(qsort_comparator);</span>
<span class="line-removed">4036 </span>
<span class="line-removed">4037 #ifdef ASSERT</span>
<span class="line-removed">4038   // Make sure all jump-table entries were sorted to the end of the</span>
<span class="line-removed">4039   // array (they have a negative frequency).</span>
<span class="line-removed">4040   bool found_void = false;</span>
<span class="line-removed">4041   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4042     Constant con = _constants.at(i);</span>
<span class="line-removed">4043     if (con.type() == T_VOID)</span>
<span class="line-removed">4044       found_void = true;  // jump-tables</span>
<span class="line-removed">4045     else</span>
<span class="line-removed">4046       assert(!found_void, &quot;wrong sorting&quot;);</span>
<span class="line-removed">4047   }</span>
<span class="line-removed">4048 #endif</span>
<span class="line-removed">4049 </span>
<span class="line-removed">4050   int offset = 0;</span>
<span class="line-removed">4051   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4052     Constant* con = _constants.adr_at(i);</span>
<span class="line-removed">4053 </span>
<span class="line-removed">4054     // Align offset for type.</span>
<span class="line-removed">4055     int typesize = type_to_size_in_bytes(con-&gt;type());</span>
<span class="line-removed">4056     offset = align_up(offset, typesize);</span>
<span class="line-removed">4057     con-&gt;set_offset(offset);   // set constant&#39;s offset</span>
<span class="line-removed">4058 </span>
<span class="line-removed">4059     if (con-&gt;type() == T_VOID) {</span>
<span class="line-removed">4060       MachConstantNode* n = (MachConstantNode*) con-&gt;get_jobject();</span>
<span class="line-removed">4061       offset = offset + typesize * n-&gt;outcnt();  // expand jump-table</span>
<span class="line-removed">4062     } else {</span>
<span class="line-removed">4063       offset = offset + typesize;</span>
<span class="line-removed">4064     }</span>
<span class="line-removed">4065   }</span>
<span class="line-removed">4066 </span>
<span class="line-removed">4067   // Align size up to the next section start (which is insts; see</span>
<span class="line-removed">4068   // CodeBuffer::align_at_start).</span>
<span class="line-removed">4069   assert(_size == -1, &quot;already set?&quot;);</span>
<span class="line-removed">4070   _size = align_up(offset, (int)CodeEntryAlignment);</span>
<span class="line-removed">4071 }</span>
<span class="line-removed">4072 </span>
<span class="line-removed">4073 void Compile::ConstantTable::emit(CodeBuffer&amp; cb) {</span>
<span class="line-removed">4074   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4075   for (int i = 0; i &lt; _constants.length(); i++) {</span>
<span class="line-removed">4076     Constant con = _constants.at(i);</span>
<span class="line-removed">4077     address constant_addr = NULL;</span>
<span class="line-removed">4078     switch (con.type()) {</span>
<span class="line-removed">4079     case T_INT:    constant_addr = _masm.int_constant(   con.get_jint()   ); break;</span>
<span class="line-removed">4080     case T_LONG:   constant_addr = _masm.long_constant(  con.get_jlong()  ); break;</span>
<span class="line-removed">4081     case T_FLOAT:  constant_addr = _masm.float_constant( con.get_jfloat() ); break;</span>
<span class="line-removed">4082     case T_DOUBLE: constant_addr = _masm.double_constant(con.get_jdouble()); break;</span>
<span class="line-removed">4083     case T_OBJECT: {</span>
<span class="line-removed">4084       jobject obj = con.get_jobject();</span>
<span class="line-removed">4085       int oop_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4086       constant_addr = _masm.address_constant((address) obj, oop_Relocation::spec(oop_index));</span>
<span class="line-removed">4087       break;</span>
<span class="line-removed">4088     }</span>
<span class="line-removed">4089     case T_ADDRESS: {</span>
<span class="line-removed">4090       address addr = (address) con.get_jobject();</span>
<span class="line-removed">4091       constant_addr = _masm.address_constant(addr);</span>
<span class="line-removed">4092       break;</span>
<span class="line-removed">4093     }</span>
<span class="line-removed">4094     // We use T_VOID as marker for jump-table entries (labels) which</span>
<span class="line-removed">4095     // need an internal word relocation.</span>
<span class="line-removed">4096     case T_VOID: {</span>
<span class="line-removed">4097       MachConstantNode* n = (MachConstantNode*) con.get_jobject();</span>
<span class="line-removed">4098       // Fill the jump-table with a dummy word.  The real value is</span>
<span class="line-removed">4099       // filled in later in fill_jump_table.</span>
<span class="line-removed">4100       address dummy = (address) n;</span>
<span class="line-removed">4101       constant_addr = _masm.address_constant(dummy);</span>
<span class="line-removed">4102       // Expand jump-table</span>
<span class="line-removed">4103       for (uint i = 1; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4104         address temp_addr = _masm.address_constant(dummy + i);</span>
<span class="line-removed">4105         assert(temp_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4106       }</span>
<span class="line-removed">4107       break;</span>
<span class="line-removed">4108     }</span>
<span class="line-removed">4109     case T_METADATA: {</span>
<span class="line-removed">4110       Metadata* obj = con.get_metadata();</span>
<span class="line-removed">4111       int metadata_index = _masm.oop_recorder()-&gt;find_index(obj);</span>
<span class="line-removed">4112       constant_addr = _masm.address_constant((address) obj, metadata_Relocation::spec(metadata_index));</span>
<span class="line-removed">4113       break;</span>
<span class="line-removed">4114     }</span>
<span class="line-removed">4115     default: ShouldNotReachHere();</span>
<span class="line-removed">4116     }</span>
<span class="line-removed">4117     assert(constant_addr, &quot;consts section too small&quot;);</span>
<span class="line-removed">4118     assert((constant_addr - _masm.code()-&gt;consts()-&gt;start()) == con.offset(),</span>
<span class="line-removed">4119             &quot;must be: %d == %d&quot;, (int) (constant_addr - _masm.code()-&gt;consts()-&gt;start()), (int)(con.offset()));</span>
<span class="line-removed">4120   }</span>
<span class="line-removed">4121 }</span>
<span class="line-removed">4122 </span>
<span class="line-removed">4123 int Compile::ConstantTable::find_offset(Constant&amp; con) const {</span>
<span class="line-removed">4124   int idx = _constants.find(con);</span>
<span class="line-removed">4125   guarantee(idx != -1, &quot;constant must be in constant table&quot;);</span>
<span class="line-removed">4126   int offset = _constants.at(idx).offset();</span>
<span class="line-removed">4127   guarantee(offset != -1, &quot;constant table not emitted yet?&quot;);</span>
<span class="line-removed">4128   return offset;</span>
<span class="line-removed">4129 }</span>
<span class="line-removed">4130 </span>
<span class="line-removed">4131 void Compile::ConstantTable::add(Constant&amp; con) {</span>
<span class="line-removed">4132   if (con.can_be_reused()) {</span>
<span class="line-removed">4133     int idx = _constants.find(con);</span>
<span class="line-removed">4134     if (idx != -1 &amp;&amp; _constants.at(idx).can_be_reused()) {</span>
<span class="line-removed">4135       _constants.adr_at(idx)-&gt;inc_freq(con.freq());  // increase the frequency by the current value</span>
<span class="line-removed">4136       return;</span>
<span class="line-removed">4137     }</span>
<span class="line-removed">4138   }</span>
<span class="line-removed">4139   (void) _constants.append(con);</span>
<span class="line-removed">4140 }</span>
<span class="line-removed">4141 </span>
<span class="line-removed">4142 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, BasicType type, jvalue value) {</span>
<span class="line-removed">4143   Block* b = Compile::current()-&gt;cfg()-&gt;get_block_for_node(n);</span>
<span class="line-removed">4144   Constant con(type, value, b-&gt;_freq);</span>
<span class="line-removed">4145   add(con);</span>
<span class="line-removed">4146   return con;</span>
<span class="line-removed">4147 }</span>
<span class="line-removed">4148 </span>
<span class="line-removed">4149 Compile::Constant Compile::ConstantTable::add(Metadata* metadata) {</span>
<span class="line-removed">4150   Constant con(metadata);</span>
<span class="line-removed">4151   add(con);</span>
<span class="line-removed">4152   return con;</span>
<span class="line-removed">4153 }</span>
<span class="line-removed">4154 </span>
<span class="line-removed">4155 Compile::Constant Compile::ConstantTable::add(MachConstantNode* n, MachOper* oper) {</span>
<span class="line-removed">4156   jvalue value;</span>
<span class="line-removed">4157   BasicType type = oper-&gt;type()-&gt;basic_type();</span>
<span class="line-removed">4158   switch (type) {</span>
<span class="line-removed">4159   case T_LONG:    value.j = oper-&gt;constantL(); break;</span>
<span class="line-removed">4160   case T_FLOAT:   value.f = oper-&gt;constantF(); break;</span>
<span class="line-removed">4161   case T_DOUBLE:  value.d = oper-&gt;constantD(); break;</span>
<span class="line-removed">4162   case T_OBJECT:</span>
<span class="line-removed">4163   case T_ADDRESS: value.l = (jobject) oper-&gt;constant(); break;</span>
<span class="line-removed">4164   case T_METADATA: return add((Metadata*)oper-&gt;constant()); break;</span>
<span class="line-removed">4165   default: guarantee(false, &quot;unhandled type: %s&quot;, type2name(type));</span>
<span class="line-removed">4166   }</span>
<span class="line-removed">4167   return add(n, type, value);</span>
<span class="line-removed">4168 }</span>
<span class="line-removed">4169 </span>
<span class="line-removed">4170 Compile::Constant Compile::ConstantTable::add_jump_table(MachConstantNode* n) {</span>
<span class="line-removed">4171   jvalue value;</span>
<span class="line-removed">4172   // We can use the node pointer here to identify the right jump-table</span>
<span class="line-removed">4173   // as this method is called from Compile::Fill_buffer right before</span>
<span class="line-removed">4174   // the MachNodes are emitted and the jump-table is filled (means the</span>
<span class="line-removed">4175   // MachNode pointers do not change anymore).</span>
<span class="line-removed">4176   value.l = (jobject) n;</span>
<span class="line-removed">4177   Constant con(T_VOID, value, next_jump_table_freq(), false);  // Labels of a jump-table cannot be reused.</span>
<span class="line-removed">4178   add(con);</span>
<span class="line-removed">4179   return con;</span>
<span class="line-removed">4180 }</span>
<span class="line-removed">4181 </span>
<span class="line-removed">4182 void Compile::ConstantTable::fill_jump_table(CodeBuffer&amp; cb, MachConstantNode* n, GrowableArray&lt;Label*&gt; labels) const {</span>
<span class="line-removed">4183   // If called from Compile::scratch_emit_size do nothing.</span>
<span class="line-removed">4184   if (Compile::current()-&gt;in_scratch_emit_size())  return;</span>
<span class="line-removed">4185 </span>
<span class="line-removed">4186   assert(labels.is_nonempty(), &quot;must be&quot;);</span>
<span class="line-removed">4187   assert((uint) labels.length() == n-&gt;outcnt(), &quot;must be equal: %d == %d&quot;, labels.length(), n-&gt;outcnt());</span>
<span class="line-removed">4188 </span>
<span class="line-removed">4189   // Since MachConstantNode::constant_offset() also contains</span>
<span class="line-removed">4190   // table_base_offset() we need to subtract the table_base_offset()</span>
<span class="line-removed">4191   // to get the plain offset into the constant table.</span>
<span class="line-removed">4192   int offset = n-&gt;constant_offset() - table_base_offset();</span>
<span class="line-removed">4193 </span>
<span class="line-removed">4194   MacroAssembler _masm(&amp;cb);</span>
<span class="line-removed">4195   address* jump_table_base = (address*) (_masm.code()-&gt;consts()-&gt;start() + offset);</span>
<span class="line-removed">4196 </span>
<span class="line-removed">4197   for (uint i = 0; i &lt; n-&gt;outcnt(); i++) {</span>
<span class="line-removed">4198     address* constant_addr = &amp;jump_table_base[i];</span>
<span class="line-removed">4199     assert(*constant_addr == (((address) n) + i), &quot;all jump-table entries must contain adjusted node pointer: &quot; INTPTR_FORMAT &quot; == &quot; INTPTR_FORMAT, p2i(*constant_addr), p2i(((address) n) + i));</span>
<span class="line-removed">4200     *constant_addr = cb.consts()-&gt;target(*labels.at(i), (address) constant_addr);</span>
<span class="line-removed">4201     cb.consts()-&gt;relocate((address) constant_addr, relocInfo::internal_word_type);</span>
<span class="line-removed">4202   }</span>
<span class="line-removed">4203 }</span>
<span class="line-removed">4204 </span>
4205 //----------------------------static_subtype_check-----------------------------
4206 // Shortcut important common cases when superklass is exact:
4207 // (0) superklass is java.lang.Object (can occur in reflective code)
4208 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
4209 // (2) subklass does not overlap with superklass =&gt; always fail
4210 // (3) superklass has NO subtypes and we can check with a simple compare.
4211 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
4212   if (StressReflectiveCode) {
4213     return SSC_full_test;       // Let caller generate the general case.
4214   }
4215 
4216   if (superk == env()-&gt;Object_klass()) {
4217     return SSC_always_true;     // (0) this test cannot fail
4218   }
4219 
4220   ciType* superelem = superk;
4221   if (superelem-&gt;is_array_klass())
4222     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
4223 
4224   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
4225     if (subk-&gt;is_subtype_of(superk)) {
4226       return SSC_always_true;   // (1) false path dead; no dynamic test needed
4227     }
4228     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
4229         !superk-&gt;is_subtype_of(subk)) {
4230       return SSC_always_false;
4231     }
4232   }
4233 
4234   // If casting to an instance klass, it must have no subtypes
4235   if (superk-&gt;is_interface()) {
4236     // Cannot trust interfaces yet.
4237     // %%% S.B. superk-&gt;nof_implementors() == 1
4238   } else if (superelem-&gt;is_instance_klass()) {
4239     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4240     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4241       if (!ik-&gt;is_final()) {
4242         // Add a dependency if there is a chance of a later subclass.
4243         dependencies()-&gt;assert_leaf_type(ik);
4244       }
<span class="line-removed">4245       if (ik-&gt;is_abstract()) {</span>
<span class="line-removed">4246         return SSC_always_false;</span>
<span class="line-removed">4247       }</span>
4248       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4249     }
4250   } else {
4251     // A primitive array type has no subtypes.
4252     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4253   }
4254 
4255   return SSC_full_test;
4256 }
4257 
4258 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4259 #ifdef _LP64
4260   // The scaled index operand to AddP must be a clean 64-bit value.
4261   // Java allows a 32-bit int to be incremented to a negative
4262   // value, which appears in a 64-bit register as a large
4263   // positive number.  Using that large positive number as an
4264   // operand in pointer arithmetic has bad consequences.
4265   // On the other hand, 32-bit overflow is rare, and the possibility
4266   // can often be excluded, if we annotate the ConvI2L node with
4267   // a type assertion that its value is known to be a small positive
</pre>
<hr />
<pre>
4759     int t = gen(di._key);
4760     if (g &lt; t) {
4761       g = t;
4762 #ifndef PRODUCT
4763       if (is_debug()) {
4764         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4765       }
4766 #endif
4767     }
4768   }
4769   return g;
4770 }
4771 
4772 void CloneMap::dump(node_idx_t key) const {
4773   uint64_t val = value(key);
4774   if (val != 0) {
4775     NodeCloneInfo ni(val);
4776     ni.dump();
4777   }
4778 }


















</pre>
</td>
<td>
<hr />
<pre>
  59 #include &quot;opto/mulnode.hpp&quot;
  60 #include &quot;opto/narrowptrnode.hpp&quot;
  61 #include &quot;opto/node.hpp&quot;
  62 #include &quot;opto/opcodes.hpp&quot;
  63 #include &quot;opto/output.hpp&quot;
  64 #include &quot;opto/parse.hpp&quot;
  65 #include &quot;opto/phaseX.hpp&quot;
  66 #include &quot;opto/rootnode.hpp&quot;
  67 #include &quot;opto/runtime.hpp&quot;
  68 #include &quot;opto/stringopts.hpp&quot;
  69 #include &quot;opto/type.hpp&quot;
  70 #include &quot;opto/vectornode.hpp&quot;
  71 #include &quot;runtime/arguments.hpp&quot;
  72 #include &quot;runtime/sharedRuntime.hpp&quot;
  73 #include &quot;runtime/signature.hpp&quot;
  74 #include &quot;runtime/stubRoutines.hpp&quot;
  75 #include &quot;runtime/timer.hpp&quot;
  76 #include &quot;utilities/align.hpp&quot;
  77 #include &quot;utilities/copy.hpp&quot;
  78 #include &quot;utilities/macros.hpp&quot;
<span class="line-added">  79 #include &quot;utilities/resourceHash.hpp&quot;</span>
  80 
  81 
  82 // -------------------- Compile::mach_constant_base_node -----------------------
  83 // Constant table base node singleton.
  84 MachConstantBaseNode* Compile::mach_constant_base_node() {
  85   if (_mach_constant_base_node == NULL) {
  86     _mach_constant_base_node = new MachConstantBaseNode();
  87     _mach_constant_base_node-&gt;add_req(C-&gt;root());
  88   }
  89   return _mach_constant_base_node;
  90 }
  91 
  92 
  93 /// Support for intrinsics.
  94 
  95 // Return the index at which m must be inserted (or already exists).
  96 // The sort order is by the address of the ciMethod, with is_virtual as minor key.
  97 class IntrinsicDescPair {
  98  private:
  99   ciMethod* _m;
</pre>
<hr />
<pre>
 234   #define PRINT_STAT_LINE(name, c, f) \
 235     tty-&gt;print_cr(&quot;  %4d (%4.1f%%) %s (%s)&quot;, (int)(c), ((c) * 100.0) / total, name, f);
 236   for (int index = 1 + (int)vmIntrinsics::_none; index &lt; (int)vmIntrinsics::ID_LIMIT; index++) {
 237     vmIntrinsics::ID id = (vmIntrinsics::ID) index;
 238     int   flags = _intrinsic_hist_flags[id];
 239     juint count = _intrinsic_hist_count[id];
 240     if ((flags | count) != 0) {
 241       PRINT_STAT_LINE(vmIntrinsics::name_at(id), count, format_flags(flags, flagsbuf));
 242     }
 243   }
 244   PRINT_STAT_LINE(&quot;total&quot;, total, format_flags(_intrinsic_hist_flags[vmIntrinsics::_none], flagsbuf));
 245   if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 246 }
 247 
 248 void Compile::print_statistics() {
 249   { ttyLocker ttyl;
 250     if (xtty != NULL)  xtty-&gt;head(&quot;statistics type=&#39;opto&#39;&quot;);
 251     Parse::print_statistics();
 252     PhaseCCP::print_statistics();
 253     PhaseRegAlloc::print_statistics();
<span class="line-modified"> 254     PhaseOutput::print_statistics();</span>
 255     PhasePeephole::print_statistics();
 256     PhaseIdealLoop::print_statistics();
 257     if (xtty != NULL)  xtty-&gt;tail(&quot;statistics&quot;);
 258   }
 259   if (_intrinsic_hist_flags[vmIntrinsics::_none] != 0) {
 260     // put this under its own &lt;statistics&gt; element.
 261     print_intrinsic_statistics();
 262   }
 263 }
 264 #endif //PRODUCT
 265 











 266 void Compile::gvn_replace_by(Node* n, Node* nn) {
 267   for (DUIterator_Last imin, i = n-&gt;last_outs(imin); i &gt;= imin; ) {
 268     Node* use = n-&gt;last_out(i);
 269     bool is_in_table = initial_gvn()-&gt;hash_delete(use);
 270     uint uses_found = 0;
 271     for (uint j = 0; j &lt; use-&gt;len(); j++) {
 272       if (use-&gt;in(j) == n) {
 273         if (j &lt; use-&gt;req())
 274           use-&gt;set_req(j, nn);
 275         else
 276           use-&gt;set_prec(j, nn);
 277         uses_found++;
 278       }
 279     }
 280     if (is_in_table) {
 281       // reinsert into table
 282       initial_gvn()-&gt;hash_find_insert(use);
 283     }
 284     record_for_igvn(use);
 285     i -= uses_found;    // we deleted 1 or more copies of this edge
</pre>
<hr />
<pre>
 396     if (!useful.member(n)) {
 397       remove_expensive_node(n);
 398     }
 399   }
 400   // Remove useless Opaque4 nodes
 401   for (int i = opaque4_count() - 1; i &gt;= 0; i--) {
 402     Node* opaq = opaque4_node(i);
 403     if (!useful.member(opaq)) {
 404       remove_opaque4_node(opaq);
 405     }
 406   }
 407   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 408   bs-&gt;eliminate_useless_gc_barriers(useful, this);
 409   // clean up the late inline lists
 410   remove_useless_late_inlines(&amp;_string_late_inlines, useful);
 411   remove_useless_late_inlines(&amp;_boxing_late_inlines, useful);
 412   remove_useless_late_inlines(&amp;_late_inlines, useful);
 413   debug_only(verify_graph_edges(true/*check for no_dead_code*/);)
 414 }
 415 


















 416 // ============================================================================
 417 //------------------------------CompileWrapper---------------------------------
 418 class CompileWrapper : public StackObj {
 419   Compile *const _compile;
 420  public:
 421   CompileWrapper(Compile* compile);
 422 
 423   ~CompileWrapper();
 424 };
 425 
 426 CompileWrapper::CompileWrapper(Compile* compile) : _compile(compile) {
 427   // the Compile* pointer is stored in the current ciEnv:
 428   ciEnv* env = compile-&gt;env();
 429   assert(env == ciEnv::current(), &quot;must already be a ciEnv active&quot;);
 430   assert(env-&gt;compiler_data() == NULL, &quot;compile already active?&quot;);
 431   env-&gt;set_compiler_data(compile);
 432   assert(compile == Compile::current(), &quot;sanity&quot;);
 433 
 434   compile-&gt;set_type_dict(NULL);
 435   compile-&gt;set_clone_map(new Dict(cmpkey, hashkey, _compile-&gt;comp_arena()));
 436   compile-&gt;clone_map().set_clone_idx(0);
 437   compile-&gt;set_type_last_size(0);
 438   compile-&gt;set_last_tf(NULL, NULL);
 439   compile-&gt;set_indexSet_arena(NULL);
 440   compile-&gt;set_indexSet_free_block_list(NULL);
 441   compile-&gt;init_type_arena();
 442   Type::Initialize(compile);

 443   _compile-&gt;begin_method();
 444   _compile-&gt;clone_map().set_debug(_compile-&gt;has_method() &amp;&amp; _compile-&gt;directive()-&gt;CloneMapDebugOption);
 445 }
 446 CompileWrapper::~CompileWrapper() {
 447   _compile-&gt;end_method();


 448   _compile-&gt;env()-&gt;set_compiler_data(NULL);
 449 }
 450 
 451 
 452 //----------------------------print_compile_messages---------------------------
 453 void Compile::print_compile_messages() {
 454 #ifndef PRODUCT
 455   // Check if recompiling
 456   if (_subsume_loads == false &amp;&amp; PrintOpto) {
 457     // Recompiling without allowing machine instructions to subsume loads
 458     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 459     tty-&gt;print_cr(&quot;** Bailout: Recompile without subsuming loads          **&quot;);
 460     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 461   }
 462   if (_do_escape_analysis != DoEscapeAnalysis &amp;&amp; PrintOpto) {
 463     // Recompiling without escape analysis
 464     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 465     tty-&gt;print_cr(&quot;** Bailout: Recompile without escape analysis          **&quot;);
 466     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 467   }
</pre>
<hr />
<pre>
 472     tty-&gt;print_cr(&quot;*********************************************************&quot;);
 473   }
 474   if (C-&gt;directive()-&gt;BreakAtCompileOption) {
 475     // Open the debugger when compiling this method.
 476     tty-&gt;print(&quot;### Breaking when compiling: &quot;);
 477     method()-&gt;print_short_name();
 478     tty-&gt;cr();
 479     BREAKPOINT;
 480   }
 481 
 482   if( PrintOpto ) {
 483     if (is_osr_compilation()) {
 484       tty-&gt;print(&quot;[OSR]%3d&quot;, _compile_id);
 485     } else {
 486       tty-&gt;print(&quot;%3d&quot;, _compile_id);
 487     }
 488   }
 489 #endif
 490 }
 491 


































































































 492 // ============================================================================
 493 //------------------------------Compile standard-------------------------------
 494 debug_only( int Compile::_debug_idx = 100000; )
 495 
 496 // Compile a method.  entry_bci is -1 for normal compilations and indicates
 497 // the continuation bci for on stack replacement.
 498 
 499 
<span class="line-modified"> 500 Compile::Compile( ciEnv* ci_env, ciMethod* target, int osr_bci,</span>
 501                   bool subsume_loads, bool do_escape_analysis, bool eliminate_boxing, DirectiveSet* directive)
 502                 : Phase(Compiler),
 503                   _compile_id(ci_env-&gt;compile_id()),
 504                   _save_argument_registers(false),
 505                   _subsume_loads(subsume_loads),
 506                   _do_escape_analysis(do_escape_analysis),
 507                   _eliminate_boxing(eliminate_boxing),
 508                   _method(target),
 509                   _entry_bci(osr_bci),
 510                   _stub_function(NULL),
 511                   _stub_name(NULL),
 512                   _stub_entry_point(NULL),
 513                   _max_node_limit(MaxNodeLimit),


 514                   _inlining_progress(false),
 515                   _inlining_incrementally(false),
 516                   _do_cleanup(false),
 517                   _has_reserved_stack_access(target-&gt;has_reserved_stack_access()),
 518 #ifndef PRODUCT
 519                   _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 520                   _print_ideal(directive-&gt;PrintIdealOption),
 521 #endif
 522                   _has_method_handle_invokes(false),
 523                   _clinit_barrier_on_entry(false),
 524                   _comp_arena(mtCompiler),
 525                   _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 526                   _env(ci_env),
 527                   _directive(directive),
 528                   _log(ci_env-&gt;log()),
 529                   _failure_reason(NULL),
 530                   _congraph(NULL),
 531 #ifndef PRODUCT
 532                   _printer(IdealGraphPrinter::printer()),
 533 #endif
</pre>
<hr />
<pre>
 535                   _dead_node_count(0),
 536                   _node_arena(mtCompiler),
 537                   _old_arena(mtCompiler),
 538                   _mach_constant_base_node(NULL),
 539                   _Compile_types(mtCompiler),
 540                   _initial_gvn(NULL),
 541                   _for_igvn(NULL),
 542                   _warm_calls(NULL),
 543                   _late_inlines(comp_arena(), 2, 0, NULL),
 544                   _string_late_inlines(comp_arena(), 2, 0, NULL),
 545                   _boxing_late_inlines(comp_arena(), 2, 0, NULL),
 546                   _late_inlines_pos(0),
 547                   _number_of_mh_late_inlines(0),
 548                   _print_inlining_stream(NULL),
 549                   _print_inlining_list(NULL),
 550                   _print_inlining_idx(0),
 551                   _print_inlining_output(NULL),
 552                   _replay_inline_data(NULL),
 553                   _java_calls(0),
 554                   _inner_loops(0),
<span class="line-modified"> 555                   _interpreter_frame_size(0)</span>





 556 #ifndef PRODUCT
 557                   , _in_dump_cnt(0)
 558 #endif
 559 {
 560   C = this;
 561 #ifndef PRODUCT
 562   if (_printer != NULL) {
 563     _printer-&gt;set_compile(this);
 564   }
 565 #endif
 566   CompileWrapper cw(this);
 567 
 568   if (CITimeVerbose) {
 569     tty-&gt;print(&quot; &quot;);
 570     target-&gt;holder()-&gt;name()-&gt;print();
 571     tty-&gt;print(&quot;.&quot;);
 572     target-&gt;print_short_name();
 573     tty-&gt;print(&quot;  &quot;);
 574   }
 575   TraceTime t1(&quot;Total compilation time&quot;, &amp;_t_totalCompilation, CITime, CITimeVerbose);
</pre>
<hr />
<pre>
 753       xtty-&gt;tail(&quot;ideal&quot;);
 754     }
 755   }
 756 #endif
 757 
 758 #ifdef ASSERT
 759   BarrierSetC2* bs = BarrierSet::barrier_set()-&gt;barrier_set_c2();
 760   bs-&gt;verify_gc_barriers(this, BarrierSetC2::BeforeCodeGen);
 761 #endif
 762 
 763   // Dump compilation data to replay it.
 764   if (directive-&gt;DumpReplayOption) {
 765     env()-&gt;dump_replay_data(_compile_id);
 766   }
 767   if (directive-&gt;DumpInlineOption &amp;&amp; (ilt() != NULL)) {
 768     env()-&gt;dump_inline_data(_compile_id);
 769   }
 770 
 771   // Now that we know the size of all the monitors we can add a fixed slot
 772   // for the original deopt pc.
<span class="line-modified"> 773   int next_slot = fixed_slots() + (sizeof(address) / VMRegImpl::stack_slot_size);</span>


 774   set_fixed_slots(next_slot);
 775 
 776   // Compute when to use implicit null checks. Used by matching trap based
 777   // nodes and NullCheck optimization.
 778   set_allowed_deopt_reasons();
 779 
 780   // Now generate code
 781   Code_Gen();



































 782 }
 783 
 784 //------------------------------Compile----------------------------------------
 785 // Compile a runtime stub
 786 Compile::Compile( ciEnv* ci_env,
 787                   TypeFunc_generator generator,
 788                   address stub_function,
 789                   const char *stub_name,
 790                   int is_fancy_jump,
 791                   bool pass_tls,
 792                   bool save_arg_registers,
 793                   bool return_pc,
 794                   DirectiveSet* directive)
 795   : Phase(Compiler),
 796     _compile_id(0),
 797     _save_argument_registers(save_arg_registers),
 798     _subsume_loads(true),
 799     _do_escape_analysis(false),
 800     _eliminate_boxing(false),
 801     _method(NULL),
 802     _entry_bci(InvocationEntryBci),
 803     _stub_function(stub_function),
 804     _stub_name(stub_name),
 805     _stub_entry_point(NULL),
 806     _max_node_limit(MaxNodeLimit),


 807     _inlining_progress(false),
 808     _inlining_incrementally(false),
 809     _has_reserved_stack_access(false),
 810 #ifndef PRODUCT
 811     _trace_opto_output(directive-&gt;TraceOptoOutputOption),
 812     _print_ideal(directive-&gt;PrintIdealOption),
 813 #endif
 814     _has_method_handle_invokes(false),
 815     _clinit_barrier_on_entry(false),
 816     _comp_arena(mtCompiler),
 817     _barrier_set_state(BarrierSet::barrier_set()-&gt;barrier_set_c2()-&gt;create_barrier_state(comp_arena())),
 818     _env(ci_env),
 819     _directive(directive),
 820     _log(ci_env-&gt;log()),
 821     _failure_reason(NULL),
 822     _congraph(NULL),
 823 #ifndef PRODUCT
 824     _printer(NULL),
 825 #endif
 826     _dead_node_list(comp_arena()),
 827     _dead_node_count(0),
 828     _node_arena(mtCompiler),
 829     _old_arena(mtCompiler),
 830     _mach_constant_base_node(NULL),
 831     _Compile_types(mtCompiler),
 832     _initial_gvn(NULL),
 833     _for_igvn(NULL),
 834     _warm_calls(NULL),
 835     _number_of_mh_late_inlines(0),
 836     _print_inlining_stream(NULL),
 837     _print_inlining_list(NULL),
 838     _print_inlining_idx(0),
 839     _print_inlining_output(NULL),
 840     _replay_inline_data(NULL),
 841     _java_calls(0),
 842     _inner_loops(0),
 843     _interpreter_frame_size(0),



 844 #ifndef PRODUCT
 845     _in_dump_cnt(0),
 846 #endif
 847     _allowed_reasons(0) {
 848   C = this;
 849 
 850   TraceTime t1(NULL, &amp;_t_totalCompilation, CITime, false);
 851   TraceTime t2(NULL, &amp;_t_stubCompilation, CITime, false);
 852 
 853 #ifndef PRODUCT
 854   set_print_assembly(PrintFrameConverterAssembly);
 855   set_parsed_irreducible_loop(false);
 856 #else
 857   set_print_assembly(false); // Must initialize.
 858 #endif
 859   set_has_irreducible_loop(false); // no loops
 860 
 861   CompileWrapper cw(this);
 862   Init(/*AliasLevel=*/ 0);
 863   init_tf((*generator)());
 864 
 865   {
 866     // The following is a dummy for the sake of GraphKit::gen_stub
 867     Unique_Node_List for_igvn(comp_arena());
 868     set_for_igvn(&amp;for_igvn);  // not used, but some GraphKit guys push on this
 869     PhaseGVN gvn(Thread::current()-&gt;resource_area(),255);
 870     set_initial_gvn(&amp;gvn);    // not significant, but GraphKit guys use it pervasively
 871     gvn.transform_no_reclaim(top());
 872 
 873     GraphKit kit;
 874     kit.gen_stub(stub_function, stub_name, is_fancy_jump, pass_tls, return_pc);
 875   }
 876 
 877   NOT_PRODUCT( verify_graph_edges(); )










 878 
<span class="line-modified"> 879   Code_Gen();</span>
















 880 }
 881 
 882 //------------------------------Init-------------------------------------------
 883 // Prepare for a single compilation
 884 void Compile::Init(int aliaslevel) {
 885   _unique  = 0;
 886   _regalloc = NULL;
 887 
 888   _tf      = NULL;  // filled in later
 889   _top     = NULL;  // cached later
 890   _matcher = NULL;  // filled in later
 891   _cfg     = NULL;  // filled in later
 892 
 893   IA32_ONLY( set_24_bit_selection_and_mode(true, false); )
 894 
 895   _node_note_array = NULL;
 896   _default_node_notes = NULL;
 897   DEBUG_ONLY( _modified_nodes = NULL; ) // Used in Optimize()
 898 
 899   _immutable_memory = NULL; // filled in at first inquiry
</pre>
<hr />
<pre>
 993   {
 994     for (int i = 0; i &lt; grow_ats; i++)  _alias_types[i] = &amp;ats[i];
 995   }
 996   // Initialize the first few types.
 997   _alias_types[AliasIdxTop]-&gt;Init(AliasIdxTop, NULL);
 998   _alias_types[AliasIdxBot]-&gt;Init(AliasIdxBot, TypePtr::BOTTOM);
 999   _alias_types[AliasIdxRaw]-&gt;Init(AliasIdxRaw, TypeRawPtr::BOTTOM);
1000   _num_alias_types = AliasIdxRaw+1;
1001   // Zero out the alias type cache.
1002   Copy::zero_to_bytes(_alias_cache, sizeof(_alias_cache));
1003   // A NULL adr_type hits in the cache right away.  Preload the right answer.
1004   probe_alias_cache(NULL)-&gt;_index = AliasIdxTop;
1005 
1006   _intrinsics = NULL;
1007   _macro_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1008   _predicate_opaqs = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1009   _expensive_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1010   _range_check_casts = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1011   _opaque4_nodes = new(comp_arena()) GrowableArray&lt;Node*&gt;(comp_arena(), 8,  0, NULL);
1012   register_library_intrinsics();
<span class="line-added">1013 #ifdef ASSERT</span>
<span class="line-added">1014   _type_verify_symmetry = true;</span>
<span class="line-added">1015 #endif</span>
1016 }
1017 
1018 //---------------------------init_start----------------------------------------
1019 // Install the StartNode on this compile object.
1020 void Compile::init_start(StartNode* s) {
1021   if (failing())
1022     return; // already failing
1023   assert(s == start(), &quot;&quot;);
1024 }
1025 
1026 /**
1027  * Return the &#39;StartNode&#39;. We must not have a pending failure, since the ideal graph
1028  * can be in an inconsistent state, i.e., we can get segmentation faults when traversing
1029  * the ideal graph.
1030  */
1031 StartNode* Compile::start() const {
1032   assert (!failing(), &quot;Must not have pending failure. Reason is: %s&quot;, failure_reason());
1033   for (DUIterator_Fast imax, i = root()-&gt;fast_outs(imax); i &lt; imax; i++) {
1034     Node* start = root()-&gt;fast_out(i);
1035     if (start-&gt;is_Start()) {
</pre>
<hr />
<pre>
2212       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2213       return;
2214     }
2215     print_method(PHASE_MACRO_EXPANSION, 2);
2216   }
2217 
2218   {
2219     TracePhase tp(&quot;barrierExpand&quot;, &amp;timers[_t_barrierExpand]);
2220     if (bs-&gt;expand_barriers(this, igvn)) {
2221       assert(failing(), &quot;must bail out w/ explicit message&quot;);
2222       return;
2223     }
2224     print_method(PHASE_BARRIER_EXPANSION, 2);
2225   }
2226 
2227   if (opaque4_count() &gt; 0) {
2228     C-&gt;remove_opaque4_nodes(igvn);
2229     igvn.optimize();
2230   }
2231 
<span class="line-added">2232   if (C-&gt;max_vector_size() &gt; 0) {</span>
<span class="line-added">2233     C-&gt;optimize_logic_cones(igvn);</span>
<span class="line-added">2234     igvn.optimize();</span>
<span class="line-added">2235   }</span>
<span class="line-added">2236 </span>
2237   DEBUG_ONLY( _modified_nodes = NULL; )
2238  } // (End scope of igvn; run destructor if necessary for asserts.)
2239 
2240  process_print_inlining();
2241  // A method with only infinite loops has no edges entering loops from root
2242  {
2243    TracePhase tp(&quot;graphReshape&quot;, &amp;timers[_t_graphReshaping]);
2244    if (final_graph_reshaping()) {
2245      assert(failing(), &quot;must bail out w/ explicit message&quot;);
2246      return;
2247    }
2248  }
2249 
2250  print_method(PHASE_OPTIMIZE_FINISHED, 2);
2251 }
2252 
<span class="line-added">2253 //---------------------------- Bitwise operation packing optimization ---------------------------</span>
<span class="line-added">2254 </span>
<span class="line-added">2255 static bool is_vector_unary_bitwise_op(Node* n) {</span>
<span class="line-added">2256   return n-&gt;Opcode() == Op_XorV &amp;&amp;</span>
<span class="line-added">2257          VectorNode::is_vector_bitwise_not_pattern(n);</span>
<span class="line-added">2258 }</span>
<span class="line-added">2259 </span>
<span class="line-added">2260 static bool is_vector_binary_bitwise_op(Node* n) {</span>
<span class="line-added">2261   switch (n-&gt;Opcode()) {</span>
<span class="line-added">2262     case Op_AndV:</span>
<span class="line-added">2263     case Op_OrV:</span>
<span class="line-added">2264       return true;</span>
<span class="line-added">2265 </span>
<span class="line-added">2266     case Op_XorV:</span>
<span class="line-added">2267       return !is_vector_unary_bitwise_op(n);</span>
<span class="line-added">2268 </span>
<span class="line-added">2269     default:</span>
<span class="line-added">2270       return false;</span>
<span class="line-added">2271   }</span>
<span class="line-added">2272 }</span>
<span class="line-added">2273 </span>
<span class="line-added">2274 static bool is_vector_ternary_bitwise_op(Node* n) {</span>
<span class="line-added">2275   return n-&gt;Opcode() == Op_MacroLogicV;</span>
<span class="line-added">2276 }</span>
<span class="line-added">2277 </span>
<span class="line-added">2278 static bool is_vector_bitwise_op(Node* n) {</span>
<span class="line-added">2279   return is_vector_unary_bitwise_op(n)  ||</span>
<span class="line-added">2280          is_vector_binary_bitwise_op(n) ||</span>
<span class="line-added">2281          is_vector_ternary_bitwise_op(n);</span>
<span class="line-added">2282 }</span>
<span class="line-added">2283 </span>
<span class="line-added">2284 static bool is_vector_bitwise_cone_root(Node* n) {</span>
<span class="line-added">2285   if (!is_vector_bitwise_op(n)) {</span>
<span class="line-added">2286     return false;</span>
<span class="line-added">2287   }</span>
<span class="line-added">2288   for (DUIterator_Fast imax, i = n-&gt;fast_outs(imax); i &lt; imax; i++) {</span>
<span class="line-added">2289     if (is_vector_bitwise_op(n-&gt;fast_out(i))) {</span>
<span class="line-added">2290       return false;</span>
<span class="line-added">2291     }</span>
<span class="line-added">2292   }</span>
<span class="line-added">2293   return true;</span>
<span class="line-added">2294 }</span>
<span class="line-added">2295 </span>
<span class="line-added">2296 static uint collect_unique_inputs(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2297   uint cnt = 0;</span>
<span class="line-added">2298   if (is_vector_bitwise_op(n)) {</span>
<span class="line-added">2299     if (VectorNode::is_vector_bitwise_not_pattern(n)) {</span>
<span class="line-added">2300       for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-added">2301         Node* in = n-&gt;in(i);</span>
<span class="line-added">2302         bool skip = VectorNode::is_all_ones_vector(in);</span>
<span class="line-added">2303         if (!skip &amp;&amp; !inputs.member(in)) {</span>
<span class="line-added">2304           inputs.push(in);</span>
<span class="line-added">2305           cnt++;</span>
<span class="line-added">2306         }</span>
<span class="line-added">2307       }</span>
<span class="line-added">2308       assert(cnt &lt;= 1, &quot;not unary&quot;);</span>
<span class="line-added">2309     } else {</span>
<span class="line-added">2310       uint last_req = n-&gt;req();</span>
<span class="line-added">2311       if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="line-added">2312         last_req = n-&gt;req() - 1; // skip last input</span>
<span class="line-added">2313       }</span>
<span class="line-added">2314       for (uint i = 1; i &lt; last_req; i++) {</span>
<span class="line-added">2315         Node* def = n-&gt;in(i);</span>
<span class="line-added">2316         if (!inputs.member(def)) {</span>
<span class="line-added">2317           inputs.push(def);</span>
<span class="line-added">2318           cnt++;</span>
<span class="line-added">2319         }</span>
<span class="line-added">2320       }</span>
<span class="line-added">2321     }</span>
<span class="line-added">2322     partition.push(n);</span>
<span class="line-added">2323   } else { // not a bitwise operations</span>
<span class="line-added">2324     if (!inputs.member(n)) {</span>
<span class="line-added">2325       inputs.push(n);</span>
<span class="line-added">2326       cnt++;</span>
<span class="line-added">2327     }</span>
<span class="line-added">2328   }</span>
<span class="line-added">2329   return cnt;</span>
<span class="line-added">2330 }</span>
<span class="line-added">2331 </span>
<span class="line-added">2332 void Compile::collect_logic_cone_roots(Unique_Node_List&amp; list) {</span>
<span class="line-added">2333   Unique_Node_List useful_nodes;</span>
<span class="line-added">2334   C-&gt;identify_useful_nodes(useful_nodes);</span>
<span class="line-added">2335 </span>
<span class="line-added">2336   for (uint i = 0; i &lt; useful_nodes.size(); i++) {</span>
<span class="line-added">2337     Node* n = useful_nodes.at(i);</span>
<span class="line-added">2338     if (is_vector_bitwise_cone_root(n)) {</span>
<span class="line-added">2339       list.push(n);</span>
<span class="line-added">2340     }</span>
<span class="line-added">2341   }</span>
<span class="line-added">2342 }</span>
<span class="line-added">2343 </span>
<span class="line-added">2344 Node* Compile::xform_to_MacroLogicV(PhaseIterGVN&amp; igvn,</span>
<span class="line-added">2345                                     const TypeVect* vt,</span>
<span class="line-added">2346                                     Unique_Node_List&amp; partition,</span>
<span class="line-added">2347                                     Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2348   assert(partition.size() == 2 || partition.size() == 3, &quot;not supported&quot;);</span>
<span class="line-added">2349   assert(inputs.size()    == 2 || inputs.size()    == 3, &quot;not supported&quot;);</span>
<span class="line-added">2350   assert(Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type()), &quot;not supported&quot;);</span>
<span class="line-added">2351 </span>
<span class="line-added">2352   Node* in1 = inputs.at(0);</span>
<span class="line-added">2353   Node* in2 = inputs.at(1);</span>
<span class="line-added">2354   Node* in3 = (inputs.size() == 3 ? inputs.at(2) : in2);</span>
<span class="line-added">2355 </span>
<span class="line-added">2356   uint func = compute_truth_table(partition, inputs);</span>
<span class="line-added">2357   return igvn.transform(MacroLogicVNode::make(igvn, in3, in2, in1, func, vt));</span>
<span class="line-added">2358 }</span>
<span class="line-added">2359 </span>
<span class="line-added">2360 static uint extract_bit(uint func, uint pos) {</span>
<span class="line-added">2361   return (func &amp; (1 &lt;&lt; pos)) &gt;&gt; pos;</span>
<span class="line-added">2362 }</span>
<span class="line-added">2363 </span>
<span class="line-added">2364 //</span>
<span class="line-added">2365 //  A macro logic node represents a truth table. It has 4 inputs,</span>
<span class="line-added">2366 //  First three inputs corresponds to 3 columns of a truth table</span>
<span class="line-added">2367 //  and fourth input captures the logic function.</span>
<span class="line-added">2368 //</span>
<span class="line-added">2369 //  eg.  fn = (in1 AND in2) OR in3;</span>
<span class="line-added">2370 //</span>
<span class="line-added">2371 //      MacroNode(in1,in2,in3,fn)</span>
<span class="line-added">2372 //</span>
<span class="line-added">2373 //  -----------------</span>
<span class="line-added">2374 //  in1 in2 in3  fn</span>
<span class="line-added">2375 //  -----------------</span>
<span class="line-added">2376 //  0    0   0    0</span>
<span class="line-added">2377 //  0    0   1    1</span>
<span class="line-added">2378 //  0    1   0    0</span>
<span class="line-added">2379 //  0    1   1    1</span>
<span class="line-added">2380 //  1    0   0    0</span>
<span class="line-added">2381 //  1    0   1    1</span>
<span class="line-added">2382 //  1    1   0    1</span>
<span class="line-added">2383 //  1    1   1    1</span>
<span class="line-added">2384 //</span>
<span class="line-added">2385 </span>
<span class="line-added">2386 uint Compile::eval_macro_logic_op(uint func, uint in1 , uint in2, uint in3) {</span>
<span class="line-added">2387   int res = 0;</span>
<span class="line-added">2388   for (int i = 0; i &lt; 8; i++) {</span>
<span class="line-added">2389     int bit1 = extract_bit(in1, i);</span>
<span class="line-added">2390     int bit2 = extract_bit(in2, i);</span>
<span class="line-added">2391     int bit3 = extract_bit(in3, i);</span>
<span class="line-added">2392 </span>
<span class="line-added">2393     int func_bit_pos = (bit1 &lt;&lt; 2 | bit2 &lt;&lt; 1 | bit3);</span>
<span class="line-added">2394     int func_bit = extract_bit(func, func_bit_pos);</span>
<span class="line-added">2395 </span>
<span class="line-added">2396     res |= func_bit &lt;&lt; i;</span>
<span class="line-added">2397   }</span>
<span class="line-added">2398   return res;</span>
<span class="line-added">2399 }</span>
<span class="line-added">2400 </span>
<span class="line-added">2401 static uint eval_operand(Node* n, ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {</span>
<span class="line-added">2402   assert(n != NULL, &quot;&quot;);</span>
<span class="line-added">2403   assert(eval_map.contains(n), &quot;absent&quot;);</span>
<span class="line-added">2404   return *(eval_map.get(n));</span>
<span class="line-added">2405 }</span>
<span class="line-added">2406 </span>
<span class="line-added">2407 static void eval_operands(Node* n,</span>
<span class="line-added">2408                           uint&amp; func1, uint&amp; func2, uint&amp; func3,</span>
<span class="line-added">2409                           ResourceHashtable&lt;Node*,uint&gt;&amp; eval_map) {</span>
<span class="line-added">2410   assert(is_vector_bitwise_op(n), &quot;&quot;);</span>
<span class="line-added">2411   func1 = eval_operand(n-&gt;in(1), eval_map);</span>
<span class="line-added">2412 </span>
<span class="line-added">2413   if (is_vector_binary_bitwise_op(n)) {</span>
<span class="line-added">2414     func2 = eval_operand(n-&gt;in(2), eval_map);</span>
<span class="line-added">2415   } else if (is_vector_ternary_bitwise_op(n)) {</span>
<span class="line-added">2416     func2 = eval_operand(n-&gt;in(2), eval_map);</span>
<span class="line-added">2417     func3 = eval_operand(n-&gt;in(3), eval_map);</span>
<span class="line-added">2418   } else {</span>
<span class="line-added">2419     assert(is_vector_unary_bitwise_op(n), &quot;not unary&quot;);</span>
<span class="line-added">2420   }</span>
<span class="line-added">2421 }</span>
<span class="line-added">2422 </span>
<span class="line-added">2423 uint Compile::compute_truth_table(Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2424   assert(inputs.size() &lt;= 3, &quot;sanity&quot;);</span>
<span class="line-added">2425   ResourceMark rm;</span>
<span class="line-added">2426   uint res = 0;</span>
<span class="line-added">2427   ResourceHashtable&lt;Node*,uint&gt; eval_map;</span>
<span class="line-added">2428 </span>
<span class="line-added">2429   // Populate precomputed functions for inputs.</span>
<span class="line-added">2430   // Each input corresponds to one column of 3 input truth-table.</span>
<span class="line-added">2431   uint input_funcs[] = { 0xAA,   // (_, _, a) -&gt; a</span>
<span class="line-added">2432                          0xCC,   // (_, b, _) -&gt; b</span>
<span class="line-added">2433                          0xF0 }; // (c, _, _) -&gt; c</span>
<span class="line-added">2434   for (uint i = 0; i &lt; inputs.size(); i++) {</span>
<span class="line-added">2435     eval_map.put(inputs.at(i), input_funcs[i]);</span>
<span class="line-added">2436   }</span>
<span class="line-added">2437 </span>
<span class="line-added">2438   for (uint i = 0; i &lt; partition.size(); i++) {</span>
<span class="line-added">2439     Node* n = partition.at(i);</span>
<span class="line-added">2440 </span>
<span class="line-added">2441     uint func1 = 0, func2 = 0, func3 = 0;</span>
<span class="line-added">2442     eval_operands(n, func1, func2, func3, eval_map);</span>
<span class="line-added">2443 </span>
<span class="line-added">2444     switch (n-&gt;Opcode()) {</span>
<span class="line-added">2445       case Op_OrV:</span>
<span class="line-added">2446         assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="line-added">2447         res = func1 | func2;</span>
<span class="line-added">2448         break;</span>
<span class="line-added">2449       case Op_AndV:</span>
<span class="line-added">2450         assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="line-added">2451         res = func1 &amp; func2;</span>
<span class="line-added">2452         break;</span>
<span class="line-added">2453       case Op_XorV:</span>
<span class="line-added">2454         if (VectorNode::is_vector_bitwise_not_pattern(n)) {</span>
<span class="line-added">2455           assert(func2 == 0 &amp;&amp; func3 == 0, &quot;not unary&quot;);</span>
<span class="line-added">2456           res = (~func1) &amp; 0xFF;</span>
<span class="line-added">2457         } else {</span>
<span class="line-added">2458           assert(func3 == 0, &quot;not binary&quot;);</span>
<span class="line-added">2459           res = func1 ^ func2;</span>
<span class="line-added">2460         }</span>
<span class="line-added">2461         break;</span>
<span class="line-added">2462       case Op_MacroLogicV:</span>
<span class="line-added">2463         // Ordering of inputs may change during evaluation of sub-tree</span>
<span class="line-added">2464         // containing MacroLogic node as a child node, thus a re-evaluation</span>
<span class="line-added">2465         // makes sure that function is evaluated in context of current</span>
<span class="line-added">2466         // inputs.</span>
<span class="line-added">2467         res = eval_macro_logic_op(n-&gt;in(4)-&gt;get_int(), func1, func2, func3);</span>
<span class="line-added">2468         break;</span>
<span class="line-added">2469 </span>
<span class="line-added">2470       default: assert(false, &quot;not supported: %s&quot;, n-&gt;Name());</span>
<span class="line-added">2471     }</span>
<span class="line-added">2472     assert(res &lt;= 0xFF, &quot;invalid&quot;);</span>
<span class="line-added">2473     eval_map.put(n, res);</span>
<span class="line-added">2474   }</span>
<span class="line-added">2475   return res;</span>
<span class="line-added">2476 }</span>
<span class="line-added">2477 </span>
<span class="line-added">2478 bool Compile::compute_logic_cone(Node* n, Unique_Node_List&amp; partition, Unique_Node_List&amp; inputs) {</span>
<span class="line-added">2479   assert(partition.size() == 0, &quot;not empty&quot;);</span>
<span class="line-added">2480   assert(inputs.size() == 0, &quot;not empty&quot;);</span>
<span class="line-added">2481   assert(!is_vector_ternary_bitwise_op(n), &quot;not supported&quot;);</span>
<span class="line-added">2482 </span>
<span class="line-added">2483   bool is_unary_op = is_vector_unary_bitwise_op(n);</span>
<span class="line-added">2484   if (is_unary_op) {</span>
<span class="line-added">2485     assert(collect_unique_inputs(n, partition, inputs) == 1, &quot;not unary&quot;);</span>
<span class="line-added">2486     return false; // too few inputs</span>
<span class="line-added">2487   }</span>
<span class="line-added">2488 </span>
<span class="line-added">2489   assert(is_vector_binary_bitwise_op(n), &quot;not binary&quot;);</span>
<span class="line-added">2490   Node* in1 = n-&gt;in(1);</span>
<span class="line-added">2491   Node* in2 = n-&gt;in(2);</span>
<span class="line-added">2492 </span>
<span class="line-added">2493   int in1_unique_inputs_cnt = collect_unique_inputs(in1, partition, inputs);</span>
<span class="line-added">2494   int in2_unique_inputs_cnt = collect_unique_inputs(in2, partition, inputs);</span>
<span class="line-added">2495   partition.push(n);</span>
<span class="line-added">2496 </span>
<span class="line-added">2497   // Too many inputs?</span>
<span class="line-added">2498   if (inputs.size() &gt; 3) {</span>
<span class="line-added">2499     partition.clear();</span>
<span class="line-added">2500     inputs.clear();</span>
<span class="line-added">2501     { // Recompute in2 inputs</span>
<span class="line-added">2502       Unique_Node_List not_used;</span>
<span class="line-added">2503       in2_unique_inputs_cnt = collect_unique_inputs(in2, not_used, not_used);</span>
<span class="line-added">2504     }</span>
<span class="line-added">2505     // Pick the node with minimum number of inputs.</span>
<span class="line-added">2506     if (in1_unique_inputs_cnt &gt;= 3 &amp;&amp; in2_unique_inputs_cnt &gt;= 3) {</span>
<span class="line-added">2507       return false; // still too many inputs</span>
<span class="line-added">2508     }</span>
<span class="line-added">2509     // Recompute partition &amp; inputs.</span>
<span class="line-added">2510     Node* child       = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in1 : in2);</span>
<span class="line-added">2511     collect_unique_inputs(child, partition, inputs);</span>
<span class="line-added">2512 </span>
<span class="line-added">2513     Node* other_input = (in1_unique_inputs_cnt &lt; in2_unique_inputs_cnt ? in2 : in1);</span>
<span class="line-added">2514     inputs.push(other_input);</span>
<span class="line-added">2515 </span>
<span class="line-added">2516     partition.push(n);</span>
<span class="line-added">2517   }</span>
<span class="line-added">2518 </span>
<span class="line-added">2519   return (partition.size() == 2 || partition.size() == 3) &amp;&amp;</span>
<span class="line-added">2520          (inputs.size()    == 2 || inputs.size()    == 3);</span>
<span class="line-added">2521 }</span>
<span class="line-added">2522 </span>
<span class="line-added">2523 void Compile::process_logic_cone_root(PhaseIterGVN &amp;igvn, Node *n, VectorSet &amp;visited) {</span>
<span class="line-added">2524   assert(is_vector_bitwise_op(n), &quot;not a root&quot;);</span>
<span class="line-added">2525 </span>
<span class="line-added">2526   visited.set(n-&gt;_idx);</span>
<span class="line-added">2527 </span>
<span class="line-added">2528   // 1) Do a DFS walk over the logic cone.</span>
<span class="line-added">2529   for (uint i = 1; i &lt; n-&gt;req(); i++) {</span>
<span class="line-added">2530     Node* in = n-&gt;in(i);</span>
<span class="line-added">2531     if (!visited.test(in-&gt;_idx) &amp;&amp; is_vector_bitwise_op(in)) {</span>
<span class="line-added">2532       process_logic_cone_root(igvn, in, visited);</span>
<span class="line-added">2533     }</span>
<span class="line-added">2534   }</span>
<span class="line-added">2535 </span>
<span class="line-added">2536   // 2) Bottom up traversal: Merge node[s] with</span>
<span class="line-added">2537   // the parent to form macro logic node.</span>
<span class="line-added">2538   Unique_Node_List partition;</span>
<span class="line-added">2539   Unique_Node_List inputs;</span>
<span class="line-added">2540   if (compute_logic_cone(n, partition, inputs)) {</span>
<span class="line-added">2541     const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="line-added">2542     Node* macro_logic = xform_to_MacroLogicV(igvn, vt, partition, inputs);</span>
<span class="line-added">2543     igvn.replace_node(n, macro_logic);</span>
<span class="line-added">2544   }</span>
<span class="line-added">2545 }</span>
<span class="line-added">2546 </span>
<span class="line-added">2547 void Compile::optimize_logic_cones(PhaseIterGVN &amp;igvn) {</span>
<span class="line-added">2548   ResourceMark rm;</span>
<span class="line-added">2549   if (Matcher::match_rule_supported(Op_MacroLogicV)) {</span>
<span class="line-added">2550     Unique_Node_List list;</span>
<span class="line-added">2551     collect_logic_cone_roots(list);</span>
<span class="line-added">2552 </span>
<span class="line-added">2553     while (list.size() &gt; 0) {</span>
<span class="line-added">2554       Node* n = list.pop();</span>
<span class="line-added">2555       const TypeVect* vt = n-&gt;bottom_type()-&gt;is_vect();</span>
<span class="line-added">2556       bool supported = Matcher::match_rule_supported_vector(Op_MacroLogicV, vt-&gt;length(), vt-&gt;element_basic_type());</span>
<span class="line-added">2557       if (supported) {</span>
<span class="line-added">2558         VectorSet visited(comp_arena());</span>
<span class="line-added">2559         process_logic_cone_root(igvn, n, visited);</span>
<span class="line-added">2560       }</span>
<span class="line-added">2561     }</span>
<span class="line-added">2562   }</span>
<span class="line-added">2563 }</span>
2564 
2565 //------------------------------Code_Gen---------------------------------------
2566 // Given a graph, generate code for it
2567 void Compile::Code_Gen() {
2568   if (failing()) {
2569     return;
2570   }
2571 
2572   // Perform instruction selection.  You might think we could reclaim Matcher
2573   // memory PDQ, but actually the Matcher is used in generating spill code.
2574   // Internals of the Matcher (including some VectorSets) must remain live
2575   // for awhile - thus I cannot reclaim Matcher memory lest a VectorSet usage
2576   // set a bit in reclaimed memory.
2577 
2578   // In debug mode can dump m._nodes.dump() for mapping of ideal to machine
2579   // nodes.  Mapping is only valid at the root of each matched subtree.
2580   NOT_PRODUCT( verify_graph_edges(); )
2581 
2582   Matcher matcher;
2583   _matcher = &amp;matcher;
</pre>
<hr />
<pre>
2644       cfg.set_loop_alignment();
2645     }
2646     cfg.fixup_flow();
2647   }
2648 
2649   // Apply peephole optimizations
2650   if( OptoPeephole ) {
2651     TracePhase tp(&quot;peephole&quot;, &amp;timers[_t_peephole]);
2652     PhasePeephole peep( _regalloc, cfg);
2653     peep.do_transform();
2654   }
2655 
2656   // Do late expand if CPU requires this.
2657   if (Matcher::require_postalloc_expand) {
2658     TracePhase tp(&quot;postalloc_expand&quot;, &amp;timers[_t_postalloc_expand]);
2659     cfg.postalloc_expand(_regalloc);
2660   }
2661 
2662   // Convert Nodes to instruction bits in a buffer
2663   {
<span class="line-modified">2664     TracePhase tp(&quot;output&quot;, &amp;timers[_t_output]);</span>
<span class="line-modified">2665     PhaseOutput output;</span>
<span class="line-added">2666     output.Output();</span>
<span class="line-added">2667     if (failing())  return;</span>
<span class="line-added">2668     output.install();</span>
2669   }
2670 
2671   print_method(PHASE_FINAL_CODE);
2672 
2673   // He&#39;s dead, Jim.
2674   _cfg     = (PhaseCFG*)((intptr_t)0xdeadbeef);
2675   _regalloc = (PhaseChaitin*)((intptr_t)0xdeadbeef);
2676 }
2677 









































































































































2678 //------------------------------Final_Reshape_Counts---------------------------
2679 // This class defines counters to help identify when a method
2680 // may/must be executed using hardware with only 24-bit precision.
2681 struct Final_Reshape_Counts : public StackObj {
2682   int  _call_count;             // count non-inlined &#39;common&#39; calls
2683   int  _float_count;            // count float ops requiring 24-bit precision
2684   int  _double_count;           // count double ops requiring more precision
2685   int  _java_call_count;        // count non-inlined &#39;java&#39; calls
2686   int  _inner_loop_count;       // count loops which need alignment
2687   VectorSet _visited;           // Visitation flags
2688   Node_List _tests;             // Set of IfNodes &amp; PCTableNodes
2689 
2690   Final_Reshape_Counts() :
2691     _call_count(0), _float_count(0), _double_count(0),
2692     _java_call_count(0), _inner_loop_count(0),
2693     _visited( Thread::current()-&gt;resource_area() ) { }
2694 
2695   void inc_call_count  () { _call_count  ++; }
2696   void inc_float_count () { _float_count ++; }
2697   void inc_double_count() { _double_count++; }
</pre>
<hr />
<pre>
3337           n-&gt;subsume_by(sub, this);
3338         }
3339       }
3340     }
3341     break;
3342 
3343   case Op_LoadVector:
3344   case Op_StoreVector:
3345     break;
3346 
3347   case Op_AddReductionVI:
3348   case Op_AddReductionVL:
3349   case Op_AddReductionVF:
3350   case Op_AddReductionVD:
3351   case Op_MulReductionVI:
3352   case Op_MulReductionVL:
3353   case Op_MulReductionVF:
3354   case Op_MulReductionVD:
3355   case Op_MinReductionV:
3356   case Op_MaxReductionV:
<span class="line-added">3357   case Op_AndReductionV:</span>
<span class="line-added">3358   case Op_OrReductionV:</span>
<span class="line-added">3359   case Op_XorReductionV:</span>
3360     break;
3361 
3362   case Op_PackB:
3363   case Op_PackS:
3364   case Op_PackI:
3365   case Op_PackF:
3366   case Op_PackL:
3367   case Op_PackD:
3368     if (n-&gt;req()-1 &gt; 2) {
3369       // Replace many operand PackNodes with a binary tree for matching
3370       PackNode* p = (PackNode*) n;
3371       Node* btp = p-&gt;binary_tree_pack(1, n-&gt;req());
3372       n-&gt;subsume_by(btp, this);
3373     }
3374     break;
3375   case Op_Loop:
3376   case Op_CountedLoop:
3377   case Op_OuterStripMinedLoop:
3378     if (n-&gt;as_Loop()-&gt;is_inner_loop()) {
3379       frc.inc_inner_loop_count();
</pre>
<hr />
<pre>
3953   } else {
3954     _log = NULL;
3955   }
3956 
3957 #ifdef ASSERT
3958   if (PrintIdealNodeCount) {
3959     tty-&gt;print_cr(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39; live_graph_walk=&#39;%d&#39;&quot;,
3960                   _phase_name, C-&gt;unique(), C-&gt;live_nodes(), C-&gt;count_live_nodes_by_graph_walk());
3961   }
3962 
3963   if (VerifyIdealNodeCount) {
3964     Compile::current()-&gt;print_missing_nodes();
3965   }
3966 #endif
3967 
3968   if (_log != NULL) {
3969     _log-&gt;done(&quot;phase name=&#39;%s&#39; nodes=&#39;%d&#39; live=&#39;%d&#39;&quot;, _phase_name, C-&gt;unique(), C-&gt;live_nodes());
3970   }
3971 }
3972 
























































































































































































































3973 //----------------------------static_subtype_check-----------------------------
3974 // Shortcut important common cases when superklass is exact:
3975 // (0) superklass is java.lang.Object (can occur in reflective code)
3976 // (1) subklass is already limited to a subtype of superklass =&gt; always ok
3977 // (2) subklass does not overlap with superklass =&gt; always fail
3978 // (3) superklass has NO subtypes and we can check with a simple compare.
3979 int Compile::static_subtype_check(ciKlass* superk, ciKlass* subk) {
3980   if (StressReflectiveCode) {
3981     return SSC_full_test;       // Let caller generate the general case.
3982   }
3983 
3984   if (superk == env()-&gt;Object_klass()) {
3985     return SSC_always_true;     // (0) this test cannot fail
3986   }
3987 
3988   ciType* superelem = superk;
3989   if (superelem-&gt;is_array_klass())
3990     superelem = superelem-&gt;as_array_klass()-&gt;base_element_type();
3991 
3992   if (!subk-&gt;is_interface()) {  // cannot trust static interface types yet
3993     if (subk-&gt;is_subtype_of(superk)) {
3994       return SSC_always_true;   // (1) false path dead; no dynamic test needed
3995     }
3996     if (!(superelem-&gt;is_klass() &amp;&amp; superelem-&gt;as_klass()-&gt;is_interface()) &amp;&amp;
3997         !superk-&gt;is_subtype_of(subk)) {
3998       return SSC_always_false;
3999     }
4000   }
4001 
4002   // If casting to an instance klass, it must have no subtypes
4003   if (superk-&gt;is_interface()) {
4004     // Cannot trust interfaces yet.
4005     // %%% S.B. superk-&gt;nof_implementors() == 1
4006   } else if (superelem-&gt;is_instance_klass()) {
4007     ciInstanceKlass* ik = superelem-&gt;as_instance_klass();
4008     if (!ik-&gt;has_subklass() &amp;&amp; !ik-&gt;is_interface()) {
4009       if (!ik-&gt;is_final()) {
4010         // Add a dependency if there is a chance of a later subclass.
4011         dependencies()-&gt;assert_leaf_type(ik);
4012       }



4013       return SSC_easy_test;     // (3) caller can do a simple ptr comparison
4014     }
4015   } else {
4016     // A primitive array type has no subtypes.
4017     return SSC_easy_test;       // (3) caller can do a simple ptr comparison
4018   }
4019 
4020   return SSC_full_test;
4021 }
4022 
4023 Node* Compile::conv_I2X_index(PhaseGVN* phase, Node* idx, const TypeInt* sizetype, Node* ctrl) {
4024 #ifdef _LP64
4025   // The scaled index operand to AddP must be a clean 64-bit value.
4026   // Java allows a 32-bit int to be incremented to a negative
4027   // value, which appears in a 64-bit register as a large
4028   // positive number.  Using that large positive number as an
4029   // operand in pointer arithmetic has bad consequences.
4030   // On the other hand, 32-bit overflow is rare, and the possibility
4031   // can often be excluded, if we annotate the ConvI2L node with
4032   // a type assertion that its value is known to be a small positive
</pre>
<hr />
<pre>
4524     int t = gen(di._key);
4525     if (g &lt; t) {
4526       g = t;
4527 #ifndef PRODUCT
4528       if (is_debug()) {
4529         tty-&gt;print_cr(&quot;CloneMap::max_gen() update max=%d from %d&quot;, g, _2_node_idx_t(di._key));
4530       }
4531 #endif
4532     }
4533   }
4534   return g;
4535 }
4536 
4537 void CloneMap::dump(node_idx_t key) const {
4538   uint64_t val = value(key);
4539   if (val != 0) {
4540     NodeCloneInfo ni(val);
4541     ni.dump();
4542   }
4543 }
<span class="line-added">4544 </span>
<span class="line-added">4545 </span>
<span class="line-added">4546 // Move Allocate nodes to the start of the list</span>
<span class="line-added">4547 void Compile::sort_macro_nodes() {</span>
<span class="line-added">4548   int count = macro_count();</span>
<span class="line-added">4549   int allocates = 0;</span>
<span class="line-added">4550   for (int i = 0; i &lt; count; i++) {</span>
<span class="line-added">4551     Node* n = macro_node(i);</span>
<span class="line-added">4552     if (n-&gt;is_Allocate()) {</span>
<span class="line-added">4553       if (i != allocates) {</span>
<span class="line-added">4554         Node* tmp = macro_node(allocates);</span>
<span class="line-added">4555         _macro_nodes-&gt;at_put(allocates, n);</span>
<span class="line-added">4556         _macro_nodes-&gt;at_put(i, tmp);</span>
<span class="line-added">4557       }</span>
<span class="line-added">4558       allocates++;</span>
<span class="line-added">4559     }</span>
<span class="line-added">4560   }</span>
<span class="line-added">4561 }</span>
</pre>
</td>
</tr>
</table>
<center><a href="classes.hpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="compile.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
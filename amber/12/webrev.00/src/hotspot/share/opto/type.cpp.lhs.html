<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Frames src/hotspot/share/opto/type.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
    <script type="text/javascript" src="../../../../navigation.js"></script>
  </head>
<body onkeypress="keypress(event);">
<a name="0"></a>
<hr />
<pre>   1 /*
   2  * Copyright (c) 1997, 2019, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.
   8  *
   9  * This code is distributed in the hope that it will be useful, but WITHOUT
  10  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  11  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  12  * version 2 for more details (a copy is included in the LICENSE file that
  13  * accompanied this code).
  14  *
  15  * You should have received a copy of the GNU General Public License version
  16  * 2 along with this work; if not, write to the Free Software Foundation,
  17  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  18  *
  19  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  20  * or visit www.oracle.com if you need additional information or have any
  21  * questions.
  22  *
  23  */
  24 
  25 #include &quot;precompiled.hpp&quot;
  26 #include &quot;ci/ciMethodData.hpp&quot;
  27 #include &quot;ci/ciTypeFlow.hpp&quot;
  28 #include &quot;classfile/symbolTable.hpp&quot;
  29 #include &quot;classfile/systemDictionary.hpp&quot;
  30 #include &quot;compiler/compileLog.hpp&quot;
  31 #include &quot;libadt/dict.hpp&quot;
  32 #include &quot;memory/oopFactory.hpp&quot;
  33 #include &quot;memory/resourceArea.hpp&quot;
  34 #include &quot;oops/instanceKlass.hpp&quot;
  35 #include &quot;oops/instanceMirrorKlass.hpp&quot;
  36 #include &quot;oops/objArrayKlass.hpp&quot;
  37 #include &quot;oops/typeArrayKlass.hpp&quot;
  38 #include &quot;opto/matcher.hpp&quot;
  39 #include &quot;opto/node.hpp&quot;
  40 #include &quot;opto/opcodes.hpp&quot;
  41 #include &quot;opto/type.hpp&quot;
  42 #include &quot;utilities/powerOfTwo.hpp&quot;
  43 
  44 // Portions of code courtesy of Clifford Click
  45 
  46 // Optimization - Graph Style
  47 
  48 // Dictionary of types shared among compilations.
  49 Dict* Type::_shared_type_dict = NULL;
  50 
  51 // Array which maps compiler types to Basic Types
  52 const Type::TypeInfo Type::_type_info[Type::lastype] = {
  53   { Bad,             T_ILLEGAL,    &quot;bad&quot;,           false, Node::NotAMachineReg, relocInfo::none          },  // Bad
  54   { Control,         T_ILLEGAL,    &quot;control&quot;,       false, 0,                    relocInfo::none          },  // Control
  55   { Bottom,          T_VOID,       &quot;top&quot;,           false, 0,                    relocInfo::none          },  // Top
  56   { Bad,             T_INT,        &quot;int:&quot;,          false, Op_RegI,              relocInfo::none          },  // Int
  57   { Bad,             T_LONG,       &quot;long:&quot;,         false, Op_RegL,              relocInfo::none          },  // Long
  58   { Half,            T_VOID,       &quot;half&quot;,          false, 0,                    relocInfo::none          },  // Half
  59   { Bad,             T_NARROWOOP,  &quot;narrowoop:&quot;,    false, Op_RegN,              relocInfo::none          },  // NarrowOop
  60   { Bad,             T_NARROWKLASS,&quot;narrowklass:&quot;,  false, Op_RegN,              relocInfo::none          },  // NarrowKlass
  61   { Bad,             T_ILLEGAL,    &quot;tuple:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Tuple
  62   { Bad,             T_ARRAY,      &quot;array:&quot;,        false, Node::NotAMachineReg, relocInfo::none          },  // Array
  63 
  64 #ifdef SPARC
  65   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  66   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegD,              relocInfo::none          },  // VectorD
  67   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  68   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  69   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  70 #elif defined(PPC64)
  71   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  72   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  73   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  74   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  75   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  76 #elif defined(S390)
  77   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, 0,                    relocInfo::none          },  // VectorS
  78   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_RegL,              relocInfo::none          },  // VectorD
  79   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, 0,                    relocInfo::none          },  // VectorX
  80   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, 0,                    relocInfo::none          },  // VectorY
  81   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, 0,                    relocInfo::none          },  // VectorZ
  82 #else // all other
  83   { Bad,             T_ILLEGAL,    &quot;vectors:&quot;,      false, Op_VecS,              relocInfo::none          },  // VectorS
  84   { Bad,             T_ILLEGAL,    &quot;vectord:&quot;,      false, Op_VecD,              relocInfo::none          },  // VectorD
  85   { Bad,             T_ILLEGAL,    &quot;vectorx:&quot;,      false, Op_VecX,              relocInfo::none          },  // VectorX
  86   { Bad,             T_ILLEGAL,    &quot;vectory:&quot;,      false, Op_VecY,              relocInfo::none          },  // VectorY
  87   { Bad,             T_ILLEGAL,    &quot;vectorz:&quot;,      false, Op_VecZ,              relocInfo::none          },  // VectorZ
  88 #endif
  89   { Bad,             T_ADDRESS,    &quot;anyptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // AnyPtr
  90   { Bad,             T_ADDRESS,    &quot;rawptr:&quot;,       false, Op_RegP,              relocInfo::none          },  // RawPtr
  91   { Bad,             T_OBJECT,     &quot;oop:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // OopPtr
  92   { Bad,             T_OBJECT,     &quot;inst:&quot;,         true,  Op_RegP,              relocInfo::oop_type      },  // InstPtr
  93   { Bad,             T_OBJECT,     &quot;ary:&quot;,          true,  Op_RegP,              relocInfo::oop_type      },  // AryPtr
  94   { Bad,             T_METADATA,   &quot;metadata:&quot;,     false, Op_RegP,              relocInfo::metadata_type },  // MetadataPtr
  95   { Bad,             T_METADATA,   &quot;klass:&quot;,        false, Op_RegP,              relocInfo::metadata_type },  // KlassPtr
  96   { Bad,             T_OBJECT,     &quot;func&quot;,          false, 0,                    relocInfo::none          },  // Function
  97   { Abio,            T_ILLEGAL,    &quot;abIO&quot;,          false, 0,                    relocInfo::none          },  // Abio
  98   { Return_Address,  T_ADDRESS,    &quot;return_address&quot;,false, Op_RegP,              relocInfo::none          },  // Return_Address
  99   { Memory,          T_ILLEGAL,    &quot;memory&quot;,        false, 0,                    relocInfo::none          },  // Memory
 100   { FloatBot,        T_FLOAT,      &quot;float_top&quot;,     false, Op_RegF,              relocInfo::none          },  // FloatTop
 101   { FloatCon,        T_FLOAT,      &quot;ftcon:&quot;,        false, Op_RegF,              relocInfo::none          },  // FloatCon
 102   { FloatTop,        T_FLOAT,      &quot;float&quot;,         false, Op_RegF,              relocInfo::none          },  // FloatBot
 103   { DoubleBot,       T_DOUBLE,     &quot;double_top&quot;,    false, Op_RegD,              relocInfo::none          },  // DoubleTop
 104   { DoubleCon,       T_DOUBLE,     &quot;dblcon:&quot;,       false, Op_RegD,              relocInfo::none          },  // DoubleCon
 105   { DoubleTop,       T_DOUBLE,     &quot;double&quot;,        false, Op_RegD,              relocInfo::none          },  // DoubleBot
 106   { Top,             T_ILLEGAL,    &quot;bottom&quot;,        false, 0,                    relocInfo::none          }   // Bottom
 107 };
 108 
 109 // Map ideal registers (machine types) to ideal types
 110 const Type *Type::mreg2type[_last_machine_leaf];
 111 
 112 // Map basic types to canonical Type* pointers.
 113 const Type* Type::     _const_basic_type[T_CONFLICT+1];
 114 
 115 // Map basic types to constant-zero Types.
 116 const Type* Type::            _zero_type[T_CONFLICT+1];
 117 
 118 // Map basic types to array-body alias types.
 119 const TypeAryPtr* TypeAryPtr::_array_body_type[T_CONFLICT+1];
 120 
 121 //=============================================================================
 122 // Convenience common pre-built types.
 123 const Type *Type::ABIO;         // State-of-machine only
 124 const Type *Type::BOTTOM;       // All values
 125 const Type *Type::CONTROL;      // Control only
 126 const Type *Type::DOUBLE;       // All doubles
 127 const Type *Type::FLOAT;        // All floats
 128 const Type *Type::HALF;         // Placeholder half of doublewide type
 129 const Type *Type::MEMORY;       // Abstract store only
 130 const Type *Type::RETURN_ADDRESS;
 131 const Type *Type::TOP;          // No values in set
 132 
 133 //------------------------------get_const_type---------------------------
 134 const Type* Type::get_const_type(ciType* type) {
 135   if (type == NULL) {
 136     return NULL;
 137   } else if (type-&gt;is_primitive_type()) {
 138     return get_const_basic_type(type-&gt;basic_type());
 139   } else {
 140     return TypeOopPtr::make_from_klass(type-&gt;as_klass());
 141   }
 142 }
 143 
 144 //---------------------------array_element_basic_type---------------------------------
 145 // Mapping to the array element&#39;s basic type.
 146 BasicType Type::array_element_basic_type() const {
 147   BasicType bt = basic_type();
 148   if (bt == T_INT) {
 149     if (this == TypeInt::INT)   return T_INT;
 150     if (this == TypeInt::CHAR)  return T_CHAR;
 151     if (this == TypeInt::BYTE)  return T_BYTE;
 152     if (this == TypeInt::BOOL)  return T_BOOLEAN;
 153     if (this == TypeInt::SHORT) return T_SHORT;
 154     return T_VOID;
 155   }
 156   return bt;
 157 }
 158 
 159 // For two instance arrays of same dimension, return the base element types.
 160 // Otherwise or if the arrays have different dimensions, return NULL.
 161 void Type::get_arrays_base_elements(const Type *a1, const Type *a2,
 162                                     const TypeInstPtr **e1, const TypeInstPtr **e2) {
 163 
 164   if (e1) *e1 = NULL;
 165   if (e2) *e2 = NULL;
 166   const TypeAryPtr* a1tap = (a1 == NULL) ? NULL : a1-&gt;isa_aryptr();
 167   const TypeAryPtr* a2tap = (a2 == NULL) ? NULL : a2-&gt;isa_aryptr();
 168 
 169   if (a1tap != NULL &amp;&amp; a2tap != NULL) {
 170     // Handle multidimensional arrays
 171     const TypePtr* a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 172     const TypePtr* a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 173     while (a1tp &amp;&amp; a1tp-&gt;isa_aryptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_aryptr()) {
 174       a1tap = a1tp-&gt;is_aryptr();
 175       a2tap = a2tp-&gt;is_aryptr();
 176       a1tp = a1tap-&gt;elem()-&gt;make_ptr();
 177       a2tp = a2tap-&gt;elem()-&gt;make_ptr();
 178     }
 179     if (a1tp &amp;&amp; a1tp-&gt;isa_instptr() &amp;&amp; a2tp &amp;&amp; a2tp-&gt;isa_instptr()) {
 180       if (e1) *e1 = a1tp-&gt;is_instptr();
 181       if (e2) *e2 = a2tp-&gt;is_instptr();
 182     }
 183   }
 184 }
 185 
 186 //---------------------------get_typeflow_type---------------------------------
 187 // Import a type produced by ciTypeFlow.
 188 const Type* Type::get_typeflow_type(ciType* type) {
 189   switch (type-&gt;basic_type()) {
 190 
 191   case ciTypeFlow::StateVector::T_BOTTOM:
 192     assert(type == ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 193     return Type::BOTTOM;
 194 
 195   case ciTypeFlow::StateVector::T_TOP:
 196     assert(type == ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 197     return Type::TOP;
 198 
 199   case ciTypeFlow::StateVector::T_NULL:
 200     assert(type == ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 201     return TypePtr::NULL_PTR;
 202 
 203   case ciTypeFlow::StateVector::T_LONG2:
 204     // The ciTypeFlow pass pushes a long, then the half.
 205     // We do the same.
 206     assert(type == ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 207     return TypeInt::TOP;
 208 
 209   case ciTypeFlow::StateVector::T_DOUBLE2:
 210     // The ciTypeFlow pass pushes double, then the half.
 211     // Our convention is the same.
 212     assert(type == ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 213     return Type::TOP;
 214 
 215   case T_ADDRESS:
 216     assert(type-&gt;is_return_address(), &quot;&quot;);
 217     return TypeRawPtr::make((address)(intptr_t)type-&gt;as_return_address()-&gt;bci());
 218 
 219   default:
 220     // make sure we did not mix up the cases:
 221     assert(type != ciTypeFlow::StateVector::bottom_type(), &quot;&quot;);
 222     assert(type != ciTypeFlow::StateVector::top_type(), &quot;&quot;);
 223     assert(type != ciTypeFlow::StateVector::null_type(), &quot;&quot;);
 224     assert(type != ciTypeFlow::StateVector::long2_type(), &quot;&quot;);
 225     assert(type != ciTypeFlow::StateVector::double2_type(), &quot;&quot;);
 226     assert(!type-&gt;is_return_address(), &quot;&quot;);
 227 
 228     return Type::get_const_type(type);
 229   }
 230 }
 231 
 232 
 233 //-----------------------make_from_constant------------------------------------
 234 const Type* Type::make_from_constant(ciConstant constant, bool require_constant,
 235                                      int stable_dimension, bool is_narrow_oop,
 236                                      bool is_autobox_cache) {
 237   switch (constant.basic_type()) {
 238     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
 239     case T_CHAR:     return TypeInt::make(constant.as_char());
 240     case T_BYTE:     return TypeInt::make(constant.as_byte());
 241     case T_SHORT:    return TypeInt::make(constant.as_short());
 242     case T_INT:      return TypeInt::make(constant.as_int());
 243     case T_LONG:     return TypeLong::make(constant.as_long());
 244     case T_FLOAT:    return TypeF::make(constant.as_float());
 245     case T_DOUBLE:   return TypeD::make(constant.as_double());
 246     case T_ARRAY:
 247     case T_OBJECT: {
 248         const Type* con_type = NULL;
 249         ciObject* oop_constant = constant.as_object();
 250         if (oop_constant-&gt;is_null_object()) {
 251           con_type = Type::get_zero_type(T_OBJECT);
 252         } else {
 253           guarantee(require_constant || oop_constant-&gt;should_be_constant(), &quot;con_type must get computed&quot;);
 254           con_type = TypeOopPtr::make_from_constant(oop_constant, require_constant);
 255           if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; is_autobox_cache) {
 256             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_autobox_cache(true);
 257           }
 258           if (stable_dimension &gt; 0) {
 259             assert(FoldStableValues, &quot;sanity&quot;);
 260             assert(!con_type-&gt;is_zero_type(), &quot;default value for stable field&quot;);
 261             con_type = con_type-&gt;is_aryptr()-&gt;cast_to_stable(true, stable_dimension);
 262           }
 263         }
 264         if (is_narrow_oop) {
 265           con_type = con_type-&gt;make_narrowoop();
 266         }
 267         return con_type;
 268       }
 269     case T_ILLEGAL:
 270       // Invalid ciConstant returned due to OutOfMemoryError in the CI
 271       assert(Compile::current()-&gt;env()-&gt;failing(), &quot;otherwise should not see this&quot;);
 272       return NULL;
 273     default:
 274       // Fall through to failure
 275       return NULL;
 276   }
 277 }
 278 
 279 static ciConstant check_mismatched_access(ciConstant con, BasicType loadbt, bool is_unsigned) {
 280   BasicType conbt = con.basic_type();
 281   switch (conbt) {
 282     case T_BOOLEAN: conbt = T_BYTE;   break;
 283     case T_ARRAY:   conbt = T_OBJECT; break;
 284     default:                          break;
 285   }
 286   switch (loadbt) {
 287     case T_BOOLEAN:   loadbt = T_BYTE;   break;
 288     case T_NARROWOOP: loadbt = T_OBJECT; break;
 289     case T_ARRAY:     loadbt = T_OBJECT; break;
 290     case T_ADDRESS:   loadbt = T_OBJECT; break;
 291     default:                             break;
 292   }
 293   if (conbt == loadbt) {
 294     if (is_unsigned &amp;&amp; conbt == T_BYTE) {
 295       // LoadB (T_BYTE) with a small mask (&lt;=8-bit) is converted to LoadUB (T_BYTE).
 296       return ciConstant(T_INT, con.as_int() &amp; 0xFF);
 297     } else {
 298       return con;
 299     }
 300   }
 301   if (conbt == T_SHORT &amp;&amp; loadbt == T_CHAR) {
 302     // LoadS (T_SHORT) with a small mask (&lt;=16-bit) is converted to LoadUS (T_CHAR).
 303     return ciConstant(T_INT, con.as_int() &amp; 0xFFFF);
 304   }
 305   return ciConstant(); // T_ILLEGAL
 306 }
 307 
 308 // Try to constant-fold a stable array element.
 309 const Type* Type::make_constant_from_array_element(ciArray* array, int off, int stable_dimension,
 310                                                    BasicType loadbt, bool is_unsigned_load) {
 311   // Decode the results of GraphKit::array_element_address.
 312   ciConstant element_value = array-&gt;element_value_by_offset(off);
 313   if (element_value.basic_type() == T_ILLEGAL) {
 314     return NULL; // wrong offset
 315   }
 316   ciConstant con = check_mismatched_access(element_value, loadbt, is_unsigned_load);
 317 
 318   assert(con.basic_type() != T_ILLEGAL, &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 319          type2name(element_value.basic_type()), type2name(loadbt), is_unsigned_load);
 320 
 321   if (con.is_valid() &amp;&amp;          // not a mismatched access
 322       !con.is_null_or_zero()) {  // not a default value
 323     bool is_narrow_oop = (loadbt == T_NARROWOOP);
 324     return Type::make_from_constant(con, /*require_constant=*/true, stable_dimension, is_narrow_oop, /*is_autobox_cache=*/false);
 325   }
 326   return NULL;
 327 }
 328 
 329 const Type* Type::make_constant_from_field(ciInstance* holder, int off, bool is_unsigned_load, BasicType loadbt) {
 330   ciField* field;
 331   ciType* type = holder-&gt;java_mirror_type();
 332   if (type != NULL &amp;&amp; type-&gt;is_instance_klass() &amp;&amp; off &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
 333     // Static field
 334     field = type-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/true);
 335   } else {
 336     // Instance field
 337     field = holder-&gt;klass()-&gt;as_instance_klass()-&gt;get_field_by_offset(off, /*is_static=*/false);
 338   }
 339   if (field == NULL) {
 340     return NULL; // Wrong offset
 341   }
 342   return Type::make_constant_from_field(field, holder, loadbt, is_unsigned_load);
 343 }
 344 
 345 const Type* Type::make_constant_from_field(ciField* field, ciInstance* holder,
 346                                            BasicType loadbt, bool is_unsigned_load) {
 347   if (!field-&gt;is_constant()) {
 348     return NULL; // Non-constant field
 349   }
 350   ciConstant field_value;
 351   if (field-&gt;is_static()) {
 352     // final static field
 353     field_value = field-&gt;constant_value();
 354   } else if (holder != NULL) {
 355     // final or stable non-static field
 356     // Treat final non-static fields of trusted classes (classes in
 357     // java.lang.invoke and sun.invoke packages and subpackages) as
 358     // compile time constants.
 359     field_value = field-&gt;constant_value_of(holder);
 360   }
 361   if (!field_value.is_valid()) {
 362     return NULL; // Not a constant
 363   }
 364 
 365   ciConstant con = check_mismatched_access(field_value, loadbt, is_unsigned_load);
 366 
 367   assert(con.is_valid(), &quot;elembt=%s; loadbt=%s; unsigned=%d&quot;,
 368          type2name(field_value.basic_type()), type2name(loadbt), is_unsigned_load);
 369 
 370   bool is_stable_array = FoldStableValues &amp;&amp; field-&gt;is_stable() &amp;&amp; field-&gt;type()-&gt;is_array_klass();
 371   int stable_dimension = (is_stable_array ? field-&gt;type()-&gt;as_array_klass()-&gt;dimension() : 0);
 372   bool is_narrow_oop = (loadbt == T_NARROWOOP);
 373 
 374   const Type* con_type = make_from_constant(con, /*require_constant=*/ true,
 375                                             stable_dimension, is_narrow_oop,
 376                                             field-&gt;is_autobox_cache());
 377   if (con_type != NULL &amp;&amp; field-&gt;is_call_site_target()) {
 378     ciCallSite* call_site = holder-&gt;as_call_site();
 379     if (!call_site-&gt;is_fully_initialized_constant_call_site()) {
 380       ciMethodHandle* target = con.as_object()-&gt;as_method_handle();
 381       Compile::current()-&gt;dependencies()-&gt;assert_call_site_target_value(call_site, target);
 382     }
 383   }
 384   return con_type;
 385 }
 386 
 387 //------------------------------make-------------------------------------------
 388 // Create a simple Type, with default empty symbol sets.  Then hashcons it
 389 // and look for an existing copy in the type dictionary.
 390 const Type *Type::make( enum TYPES t ) {
 391   return (new Type(t))-&gt;hashcons();
 392 }
 393 
 394 //------------------------------cmp--------------------------------------------
 395 int Type::cmp( const Type *const t1, const Type *const t2 ) {
 396   if( t1-&gt;_base != t2-&gt;_base )
 397     return 1;                   // Missed badly
 398   assert(t1 != t2 || t1-&gt;eq(t2), &quot;eq must be reflexive&quot;);
 399   return !t1-&gt;eq(t2);           // Return ZERO if equal
 400 }
 401 
 402 const Type* Type::maybe_remove_speculative(bool include_speculative) const {
 403   if (!include_speculative) {
 404     return remove_speculative();
 405   }
 406   return this;
 407 }
 408 
 409 //------------------------------hash-------------------------------------------
 410 int Type::uhash( const Type *const t ) {
 411   return t-&gt;hash();
 412 }
 413 
 414 #define SMALLINT ((juint)3)  // a value too insignificant to consider widening
 415 #define POSITIVE_INFINITE_F 0x7f800000 // hex representation for IEEE 754 single precision positive infinite
 416 #define POSITIVE_INFINITE_D 0x7ff0000000000000 // hex representation for IEEE 754 double precision positive infinite
 417 
 418 //--------------------------Initialize_shared----------------------------------
 419 void Type::Initialize_shared(Compile* current) {
 420   // This method does not need to be locked because the first system
 421   // compilations (stub compilations) occur serially.  If they are
 422   // changed to proceed in parallel, then this section will need
 423   // locking.
 424 
 425   Arena* save = current-&gt;type_arena();
 426   Arena* shared_type_arena = new (mtCompiler)Arena(mtCompiler);
 427 
 428   current-&gt;set_type_arena(shared_type_arena);
 429   _shared_type_dict =
 430     new (shared_type_arena) Dict( (CmpKey)Type::cmp, (Hash)Type::uhash,
 431                                   shared_type_arena, 128 );
 432   current-&gt;set_type_dict(_shared_type_dict);
 433 
 434   // Make shared pre-built types.
 435   CONTROL = make(Control);      // Control only
 436   TOP     = make(Top);          // No values in set
 437   MEMORY  = make(Memory);       // Abstract store only
 438   ABIO    = make(Abio);         // State-of-machine only
 439   RETURN_ADDRESS=make(Return_Address);
 440   FLOAT   = make(FloatBot);     // All floats
 441   DOUBLE  = make(DoubleBot);    // All doubles
 442   BOTTOM  = make(Bottom);       // Everything
 443   HALF    = make(Half);         // Placeholder half of doublewide type
 444 
 445   TypeF::ZERO = TypeF::make(0.0); // Float 0 (positive zero)
 446   TypeF::ONE  = TypeF::make(1.0); // Float 1
 447   TypeF::POS_INF = TypeF::make(jfloat_cast(POSITIVE_INFINITE_F));
 448   TypeF::NEG_INF = TypeF::make(-jfloat_cast(POSITIVE_INFINITE_F));
 449 
 450   TypeD::ZERO = TypeD::make(0.0); // Double 0 (positive zero)
 451   TypeD::ONE  = TypeD::make(1.0); // Double 1
 452   TypeD::POS_INF = TypeD::make(jdouble_cast(POSITIVE_INFINITE_D));
 453   TypeD::NEG_INF = TypeD::make(-jdouble_cast(POSITIVE_INFINITE_D));
 454 
 455   TypeInt::MINUS_1 = TypeInt::make(-1);  // -1
 456   TypeInt::ZERO    = TypeInt::make( 0);  //  0
 457   TypeInt::ONE     = TypeInt::make( 1);  //  1
 458   TypeInt::BOOL    = TypeInt::make(0,1,   WidenMin);  // 0 or 1, FALSE or TRUE.
 459   TypeInt::CC      = TypeInt::make(-1, 1, WidenMin);  // -1, 0 or 1, condition codes
 460   TypeInt::CC_LT   = TypeInt::make(-1,-1, WidenMin);  // == TypeInt::MINUS_1
 461   TypeInt::CC_GT   = TypeInt::make( 1, 1, WidenMin);  // == TypeInt::ONE
 462   TypeInt::CC_EQ   = TypeInt::make( 0, 0, WidenMin);  // == TypeInt::ZERO
 463   TypeInt::CC_LE   = TypeInt::make(-1, 0, WidenMin);
 464   TypeInt::CC_GE   = TypeInt::make( 0, 1, WidenMin);  // == TypeInt::BOOL
 465   TypeInt::BYTE    = TypeInt::make(-128,127,     WidenMin); // Bytes
 466   TypeInt::UBYTE   = TypeInt::make(0, 255,       WidenMin); // Unsigned Bytes
 467   TypeInt::CHAR    = TypeInt::make(0,65535,      WidenMin); // Java chars
 468   TypeInt::SHORT   = TypeInt::make(-32768,32767, WidenMin); // Java shorts
 469   TypeInt::POS     = TypeInt::make(0,max_jint,   WidenMin); // Non-neg values
 470   TypeInt::POS1    = TypeInt::make(1,max_jint,   WidenMin); // Positive values
 471   TypeInt::INT     = TypeInt::make(min_jint,max_jint, WidenMax); // 32-bit integers
 472   TypeInt::SYMINT  = TypeInt::make(-max_jint,max_jint,WidenMin); // symmetric range
 473   TypeInt::TYPE_DOMAIN  = TypeInt::INT;
 474   // CmpL is overloaded both as the bytecode computation returning
 475   // a trinary (-1,0,+1) integer result AND as an efficient long
 476   // compare returning optimizer ideal-type flags.
 477   assert( TypeInt::CC_LT == TypeInt::MINUS_1, &quot;types must match for CmpL to work&quot; );
 478   assert( TypeInt::CC_GT == TypeInt::ONE,     &quot;types must match for CmpL to work&quot; );
 479   assert( TypeInt::CC_EQ == TypeInt::ZERO,    &quot;types must match for CmpL to work&quot; );
 480   assert( TypeInt::CC_GE == TypeInt::BOOL,    &quot;types must match for CmpL to work&quot; );
 481   assert( (juint)(TypeInt::CC-&gt;_hi - TypeInt::CC-&gt;_lo) &lt;= SMALLINT, &quot;CC is truly small&quot;);
 482 
 483   TypeLong::MINUS_1 = TypeLong::make(-1);        // -1
 484   TypeLong::ZERO    = TypeLong::make( 0);        //  0
 485   TypeLong::ONE     = TypeLong::make( 1);        //  1
 486   TypeLong::POS     = TypeLong::make(0,max_jlong, WidenMin); // Non-neg values
 487   TypeLong::LONG    = TypeLong::make(min_jlong,max_jlong,WidenMax); // 64-bit integers
 488   TypeLong::INT     = TypeLong::make((jlong)min_jint,(jlong)max_jint,WidenMin);
 489   TypeLong::UINT    = TypeLong::make(0,(jlong)max_juint,WidenMin);
 490   TypeLong::TYPE_DOMAIN  = TypeLong::LONG;
 491 
 492   const Type **fboth =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 493   fboth[0] = Type::CONTROL;
 494   fboth[1] = Type::CONTROL;
 495   TypeTuple::IFBOTH = TypeTuple::make( 2, fboth );
 496 
 497   const Type **ffalse =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 498   ffalse[0] = Type::CONTROL;
 499   ffalse[1] = Type::TOP;
 500   TypeTuple::IFFALSE = TypeTuple::make( 2, ffalse );
 501 
 502   const Type **fneither =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 503   fneither[0] = Type::TOP;
 504   fneither[1] = Type::TOP;
 505   TypeTuple::IFNEITHER = TypeTuple::make( 2, fneither );
 506 
 507   const Type **ftrue =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 508   ftrue[0] = Type::TOP;
 509   ftrue[1] = Type::CONTROL;
 510   TypeTuple::IFTRUE = TypeTuple::make( 2, ftrue );
 511 
 512   const Type **floop =(const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 513   floop[0] = Type::CONTROL;
 514   floop[1] = TypeInt::INT;
 515   TypeTuple::LOOPBODY = TypeTuple::make( 2, floop );
 516 
 517   TypePtr::NULL_PTR= TypePtr::make(AnyPtr, TypePtr::Null, 0);
 518   TypePtr::NOTNULL = TypePtr::make(AnyPtr, TypePtr::NotNull, OffsetBot);
 519   TypePtr::BOTTOM  = TypePtr::make(AnyPtr, TypePtr::BotPTR, OffsetBot);
 520 
 521   TypeRawPtr::BOTTOM = TypeRawPtr::make( TypePtr::BotPTR );
 522   TypeRawPtr::NOTNULL= TypeRawPtr::make( TypePtr::NotNull );
 523 
 524   const Type **fmembar = TypeTuple::fields(0);
 525   TypeTuple::MEMBAR = TypeTuple::make(TypeFunc::Parms+0, fmembar);
 526 
 527   const Type **fsc = (const Type**)shared_type_arena-&gt;Amalloc_4(2*sizeof(Type*));
 528   fsc[0] = TypeInt::CC;
 529   fsc[1] = Type::MEMORY;
 530   TypeTuple::STORECONDITIONAL = TypeTuple::make(2, fsc);
 531 
 532   TypeInstPtr::NOTNULL = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Object_klass());
 533   TypeInstPtr::BOTTOM  = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass());
 534   TypeInstPtr::MIRROR  = TypeInstPtr::make(TypePtr::NotNull, current-&gt;env()-&gt;Class_klass());
 535   TypeInstPtr::MARK    = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 536                                            false, 0, oopDesc::mark_offset_in_bytes());
 537   TypeInstPtr::KLASS   = TypeInstPtr::make(TypePtr::BotPTR,  current-&gt;env()-&gt;Object_klass(),
 538                                            false, 0, oopDesc::klass_offset_in_bytes());
 539   TypeOopPtr::BOTTOM  = TypeOopPtr::make(TypePtr::BotPTR, OffsetBot, TypeOopPtr::InstanceBot);
 540 
 541   TypeMetadataPtr::BOTTOM = TypeMetadataPtr::make(TypePtr::BotPTR, NULL, OffsetBot);
 542 
 543   TypeNarrowOop::NULL_PTR = TypeNarrowOop::make( TypePtr::NULL_PTR );
 544   TypeNarrowOop::BOTTOM   = TypeNarrowOop::make( TypeInstPtr::BOTTOM );
 545 
 546   TypeNarrowKlass::NULL_PTR = TypeNarrowKlass::make( TypePtr::NULL_PTR );
 547 
 548   mreg2type[Op_Node] = Type::BOTTOM;
 549   mreg2type[Op_Set ] = 0;
 550   mreg2type[Op_RegN] = TypeNarrowOop::BOTTOM;
 551   mreg2type[Op_RegI] = TypeInt::INT;
 552   mreg2type[Op_RegP] = TypePtr::BOTTOM;
 553   mreg2type[Op_RegF] = Type::FLOAT;
 554   mreg2type[Op_RegD] = Type::DOUBLE;
 555   mreg2type[Op_RegL] = TypeLong::LONG;
 556   mreg2type[Op_RegFlags] = TypeInt::CC;
 557 
 558   TypeAryPtr::RANGE   = TypeAryPtr::make( TypePtr::BotPTR, TypeAry::make(Type::BOTTOM,TypeInt::POS), NULL /* current-&gt;env()-&gt;Object_klass() */, false, arrayOopDesc::length_offset_in_bytes());
 559 
 560   TypeAryPtr::NARROWOOPS = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeNarrowOop::BOTTOM, TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 561 
 562 #ifdef _LP64
 563   if (UseCompressedOops) {
 564     assert(TypeAryPtr::NARROWOOPS-&gt;is_ptr_to_narrowoop(), &quot;array of narrow oops must be ptr to narrow oop&quot;);
 565     TypeAryPtr::OOPS  = TypeAryPtr::NARROWOOPS;
 566   } else
 567 #endif
 568   {
 569     // There is no shared klass for Object[].  See note in TypeAryPtr::klass().
 570     TypeAryPtr::OOPS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInstPtr::BOTTOM,TypeInt::POS), NULL /*ciArrayKlass::make(o)*/,  false,  Type::OffsetBot);
 571   }
 572   TypeAryPtr::BYTES   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::BYTE      ,TypeInt::POS), ciTypeArrayKlass::make(T_BYTE),   true,  Type::OffsetBot);
 573   TypeAryPtr::SHORTS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::SHORT     ,TypeInt::POS), ciTypeArrayKlass::make(T_SHORT),  true,  Type::OffsetBot);
 574   TypeAryPtr::CHARS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::CHAR      ,TypeInt::POS), ciTypeArrayKlass::make(T_CHAR),   true,  Type::OffsetBot);
 575   TypeAryPtr::INTS    = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeInt::INT       ,TypeInt::POS), ciTypeArrayKlass::make(T_INT),    true,  Type::OffsetBot);
 576   TypeAryPtr::LONGS   = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(TypeLong::LONG     ,TypeInt::POS), ciTypeArrayKlass::make(T_LONG),   true,  Type::OffsetBot);
 577   TypeAryPtr::FLOATS  = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::FLOAT        ,TypeInt::POS), ciTypeArrayKlass::make(T_FLOAT),  true,  Type::OffsetBot);
 578   TypeAryPtr::DOUBLES = TypeAryPtr::make(TypePtr::BotPTR, TypeAry::make(Type::DOUBLE       ,TypeInt::POS), ciTypeArrayKlass::make(T_DOUBLE), true,  Type::OffsetBot);
 579 
 580   // Nobody should ask _array_body_type[T_NARROWOOP]. Use NULL as assert.
 581   TypeAryPtr::_array_body_type[T_NARROWOOP] = NULL;
 582   TypeAryPtr::_array_body_type[T_OBJECT]  = TypeAryPtr::OOPS;
 583   TypeAryPtr::_array_body_type[T_ARRAY]   = TypeAryPtr::OOPS; // arrays are stored in oop arrays
 584   TypeAryPtr::_array_body_type[T_BYTE]    = TypeAryPtr::BYTES;
 585   TypeAryPtr::_array_body_type[T_BOOLEAN] = TypeAryPtr::BYTES;  // boolean[] is a byte array
 586   TypeAryPtr::_array_body_type[T_SHORT]   = TypeAryPtr::SHORTS;
 587   TypeAryPtr::_array_body_type[T_CHAR]    = TypeAryPtr::CHARS;
 588   TypeAryPtr::_array_body_type[T_INT]     = TypeAryPtr::INTS;
 589   TypeAryPtr::_array_body_type[T_LONG]    = TypeAryPtr::LONGS;
 590   TypeAryPtr::_array_body_type[T_FLOAT]   = TypeAryPtr::FLOATS;
 591   TypeAryPtr::_array_body_type[T_DOUBLE]  = TypeAryPtr::DOUBLES;
 592 
 593   TypeKlassPtr::OBJECT = TypeKlassPtr::make( TypePtr::NotNull, current-&gt;env()-&gt;Object_klass(), 0 );
 594   TypeKlassPtr::OBJECT_OR_NULL = TypeKlassPtr::make( TypePtr::BotPTR, current-&gt;env()-&gt;Object_klass(), 0 );
 595 
 596   const Type **fi2c = TypeTuple::fields(2);
 597   fi2c[TypeFunc::Parms+0] = TypeInstPtr::BOTTOM; // Method*
 598   fi2c[TypeFunc::Parms+1] = TypeRawPtr::BOTTOM; // argument pointer
 599   TypeTuple::START_I2C = TypeTuple::make(TypeFunc::Parms+2, fi2c);
 600 
 601   const Type **intpair = TypeTuple::fields(2);
 602   intpair[0] = TypeInt::INT;
 603   intpair[1] = TypeInt::INT;
 604   TypeTuple::INT_PAIR = TypeTuple::make(2, intpair);
 605 
 606   const Type **longpair = TypeTuple::fields(2);
 607   longpair[0] = TypeLong::LONG;
 608   longpair[1] = TypeLong::LONG;
 609   TypeTuple::LONG_PAIR = TypeTuple::make(2, longpair);
 610 
 611   const Type **intccpair = TypeTuple::fields(2);
 612   intccpair[0] = TypeInt::INT;
 613   intccpair[1] = TypeInt::CC;
 614   TypeTuple::INT_CC_PAIR = TypeTuple::make(2, intccpair);
 615 
 616   const Type **longccpair = TypeTuple::fields(2);
 617   longccpair[0] = TypeLong::LONG;
 618   longccpair[1] = TypeInt::CC;
 619   TypeTuple::LONG_CC_PAIR = TypeTuple::make(2, longccpair);
 620 
 621   _const_basic_type[T_NARROWOOP]   = TypeNarrowOop::BOTTOM;
 622   _const_basic_type[T_NARROWKLASS] = Type::BOTTOM;
 623   _const_basic_type[T_BOOLEAN]     = TypeInt::BOOL;
 624   _const_basic_type[T_CHAR]        = TypeInt::CHAR;
 625   _const_basic_type[T_BYTE]        = TypeInt::BYTE;
 626   _const_basic_type[T_SHORT]       = TypeInt::SHORT;
 627   _const_basic_type[T_INT]         = TypeInt::INT;
 628   _const_basic_type[T_LONG]        = TypeLong::LONG;
 629   _const_basic_type[T_FLOAT]       = Type::FLOAT;
 630   _const_basic_type[T_DOUBLE]      = Type::DOUBLE;
 631   _const_basic_type[T_OBJECT]      = TypeInstPtr::BOTTOM;
 632   _const_basic_type[T_ARRAY]       = TypeInstPtr::BOTTOM; // there is no separate bottom for arrays
 633   _const_basic_type[T_VOID]        = TypePtr::NULL_PTR;   // reflection represents void this way
 634   _const_basic_type[T_ADDRESS]     = TypeRawPtr::BOTTOM;  // both interpreter return addresses &amp; random raw ptrs
 635   _const_basic_type[T_CONFLICT]    = Type::BOTTOM;        // why not?
 636 
 637   _zero_type[T_NARROWOOP]   = TypeNarrowOop::NULL_PTR;
 638   _zero_type[T_NARROWKLASS] = TypeNarrowKlass::NULL_PTR;
 639   _zero_type[T_BOOLEAN]     = TypeInt::ZERO;     // false == 0
 640   _zero_type[T_CHAR]        = TypeInt::ZERO;     // &#39;\0&#39; == 0
 641   _zero_type[T_BYTE]        = TypeInt::ZERO;     // 0x00 == 0
 642   _zero_type[T_SHORT]       = TypeInt::ZERO;     // 0x0000 == 0
 643   _zero_type[T_INT]         = TypeInt::ZERO;
 644   _zero_type[T_LONG]        = TypeLong::ZERO;
 645   _zero_type[T_FLOAT]       = TypeF::ZERO;
 646   _zero_type[T_DOUBLE]      = TypeD::ZERO;
 647   _zero_type[T_OBJECT]      = TypePtr::NULL_PTR;
 648   _zero_type[T_ARRAY]       = TypePtr::NULL_PTR; // null array is null oop
 649   _zero_type[T_ADDRESS]     = TypePtr::NULL_PTR; // raw pointers use the same null
 650   _zero_type[T_VOID]        = Type::TOP;         // the only void value is no value at all
 651 
 652   // get_zero_type() should not happen for T_CONFLICT
 653   _zero_type[T_CONFLICT]= NULL;
 654 
 655   // Vector predefined types, it needs initialized _const_basic_type[].
 656   if (Matcher::vector_size_supported(T_BYTE,4)) {
 657     TypeVect::VECTS = TypeVect::make(T_BYTE,4);
 658   }
 659   if (Matcher::vector_size_supported(T_FLOAT,2)) {
 660     TypeVect::VECTD = TypeVect::make(T_FLOAT,2);
 661   }
 662   if (Matcher::vector_size_supported(T_FLOAT,4)) {
 663     TypeVect::VECTX = TypeVect::make(T_FLOAT,4);
 664   }
 665   if (Matcher::vector_size_supported(T_FLOAT,8)) {
 666     TypeVect::VECTY = TypeVect::make(T_FLOAT,8);
 667   }
 668   if (Matcher::vector_size_supported(T_FLOAT,16)) {
 669     TypeVect::VECTZ = TypeVect::make(T_FLOAT,16);
 670   }
 671   mreg2type[Op_VecS] = TypeVect::VECTS;
 672   mreg2type[Op_VecD] = TypeVect::VECTD;
 673   mreg2type[Op_VecX] = TypeVect::VECTX;
 674   mreg2type[Op_VecY] = TypeVect::VECTY;
 675   mreg2type[Op_VecZ] = TypeVect::VECTZ;
 676 
 677   // Restore working type arena.
 678   current-&gt;set_type_arena(save);
 679   current-&gt;set_type_dict(NULL);
 680 }
 681 
 682 //------------------------------Initialize-------------------------------------
 683 void Type::Initialize(Compile* current) {
 684   assert(current-&gt;type_arena() != NULL, &quot;must have created type arena&quot;);
 685 
 686   if (_shared_type_dict == NULL) {
 687     Initialize_shared(current);
 688   }
 689 
 690   Arena* type_arena = current-&gt;type_arena();
 691 
 692   // Create the hash-cons&#39;ing dictionary with top-level storage allocation
 693   Dict *tdic = new (type_arena) Dict( (CmpKey)Type::cmp,(Hash)Type::uhash, type_arena, 128 );
 694   current-&gt;set_type_dict(tdic);
 695 
 696   // Transfer the shared types.
 697   DictI i(_shared_type_dict);
 698   for( ; i.test(); ++i ) {
 699     Type* t = (Type*)i._value;
 700     tdic-&gt;Insert(t,t);  // New Type, insert into Type table
 701   }
 702 }
 703 
 704 //------------------------------hashcons---------------------------------------
 705 // Do the hash-cons trick.  If the Type already exists in the type table,
 706 // delete the current Type and return the existing Type.  Otherwise stick the
 707 // current Type in the Type table.
 708 const Type *Type::hashcons(void) {
 709   debug_only(base());           // Check the assertion in Type::base().
 710   // Look up the Type in the Type dictionary
 711   Dict *tdic = type_dict();
 712   Type* old = (Type*)(tdic-&gt;Insert(this, this, false));
 713   if( old ) {                   // Pre-existing Type?
 714     if( old != this )           // Yes, this guy is not the pre-existing?
 715       delete this;              // Yes, Nuke this guy
 716     assert( old-&gt;_dual, &quot;&quot; );
 717     return old;                 // Return pre-existing
 718   }
 719 
 720   // Every type has a dual (to make my lattice symmetric).
 721   // Since we just discovered a new Type, compute its dual right now.
 722   assert( !_dual, &quot;&quot; );         // No dual yet
 723   _dual = xdual();              // Compute the dual
 724   if (cmp(this, _dual) == 0) {  // Handle self-symmetric
 725     if (_dual != this) {
 726       delete _dual;
 727       _dual = this;
 728     }
 729     return this;
 730   }
 731   assert( !_dual-&gt;_dual, &quot;&quot; );  // No reverse dual yet
 732   assert( !(*tdic)[_dual], &quot;&quot; ); // Dual not in type system either
 733   // New Type, insert into Type table
 734   tdic-&gt;Insert((void*)_dual,(void*)_dual);
 735   ((Type*)_dual)-&gt;_dual = this; // Finish up being symmetric
 736 #ifdef ASSERT
 737   Type *dual_dual = (Type*)_dual-&gt;xdual();
 738   assert( eq(dual_dual), &quot;xdual(xdual()) should be identity&quot; );
 739   delete dual_dual;
 740 #endif
 741   return this;                  // Return new Type
 742 }
 743 
 744 //------------------------------eq---------------------------------------------
 745 // Structural equality check for Type representations
 746 bool Type::eq( const Type * ) const {
 747   return true;                  // Nothing else can go wrong
 748 }
 749 
 750 //------------------------------hash-------------------------------------------
 751 // Type-specific hashing function.
 752 int Type::hash(void) const {
 753   return _base;
 754 }
 755 
 756 //------------------------------is_finite--------------------------------------
 757 // Has a finite value
 758 bool Type::is_finite() const {
 759   return false;
 760 }
 761 
 762 //------------------------------is_nan-----------------------------------------
 763 // Is not a number (NaN)
 764 bool Type::is_nan()    const {
 765   return false;
 766 }
 767 
 768 //----------------------interface_vs_oop---------------------------------------
 769 #ifdef ASSERT
 770 bool Type::interface_vs_oop_helper(const Type *t) const {
 771   bool result = false;
 772 
 773   const TypePtr* this_ptr = this-&gt;make_ptr(); // In case it is narrow_oop
 774   const TypePtr*    t_ptr =    t-&gt;make_ptr();
 775   if( this_ptr == NULL || t_ptr == NULL )
 776     return result;
 777 
 778   const TypeInstPtr* this_inst = this_ptr-&gt;isa_instptr();
 779   const TypeInstPtr*    t_inst =    t_ptr-&gt;isa_instptr();
 780   if( this_inst &amp;&amp; this_inst-&gt;is_loaded() &amp;&amp; t_inst &amp;&amp; t_inst-&gt;is_loaded() ) {
 781     bool this_interface = this_inst-&gt;klass()-&gt;is_interface();
 782     bool    t_interface =    t_inst-&gt;klass()-&gt;is_interface();
 783     result = this_interface ^ t_interface;
 784   }
 785 
 786   return result;
 787 }
 788 
 789 bool Type::interface_vs_oop(const Type *t) const {
 790   if (interface_vs_oop_helper(t)) {
 791     return true;
 792   }
 793   // Now check the speculative parts as well
 794   const TypePtr* this_spec = isa_ptr() != NULL ? is_ptr()-&gt;speculative() : NULL;
 795   const TypePtr* t_spec = t-&gt;isa_ptr() != NULL ? t-&gt;is_ptr()-&gt;speculative() : NULL;
 796   if (this_spec != NULL &amp;&amp; t_spec != NULL) {
 797     if (this_spec-&gt;interface_vs_oop_helper(t_spec)) {
 798       return true;
 799     }
 800     return false;
 801   }
 802   if (this_spec != NULL &amp;&amp; this_spec-&gt;interface_vs_oop_helper(t)) {
 803     return true;
 804   }
 805   if (t_spec != NULL &amp;&amp; interface_vs_oop_helper(t_spec)) {
 806     return true;
 807   }
 808   return false;
 809 }
 810 
 811 #endif
 812 
<a name="1" id="anc1"></a><span class="line-modified"> 813 //------------------------------meet-------------------------------------------</span>
<span class="line-removed"> 814 // Compute the MEET of two types.  NOT virtual.  It enforces that meet is</span>
<span class="line-removed"> 815 // commutative and the lattice is symmetric.</span>
<span class="line-removed"> 816 const Type *Type::meet_helper(const Type *t, bool include_speculative) const {</span>
<span class="line-removed"> 817   if (isa_narrowoop() &amp;&amp; t-&gt;isa_narrowoop()) {</span>
<span class="line-removed"> 818     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-removed"> 819     return result-&gt;make_narrowoop();</span>
<span class="line-removed"> 820   }</span>
<span class="line-removed"> 821   if (isa_narrowklass() &amp;&amp; t-&gt;isa_narrowklass()) {</span>
<span class="line-removed"> 822     const Type* result = make_ptr()-&gt;meet_helper(t-&gt;make_ptr(), include_speculative);</span>
<span class="line-removed"> 823     return result-&gt;make_narrowklass();</span>
<span class="line-removed"> 824   }</span>
<span class="line-removed"> 825 </span>
<span class="line-removed"> 826   const Type *this_t = maybe_remove_speculative(include_speculative);</span>
<span class="line-removed"> 827   t = t-&gt;maybe_remove_speculative(include_speculative);</span>
<span class="line-removed"> 828 </span>
<span class="line-removed"> 829   const Type *mt = this_t-&gt;xmeet(t);</span>
<span class="line-removed"> 830   if (isa_narrowoop() || t-&gt;isa_narrowoop()) return mt;</span>
<span class="line-removed"> 831   if (isa_narrowklass() || t-&gt;isa_narrowklass()) return mt;</span>
 832 #ifdef ASSERT
<a name="2" id="anc2"></a><span class="line-modified"> 833   assert(mt == t-&gt;xmeet(this_t), &quot;meet not commutative&quot;);</span>
 834   const Type* dual_join = mt-&gt;_dual;
 835   const Type *t2t    = dual_join-&gt;xmeet(t-&gt;_dual);
<a name="3" id="anc3"></a><span class="line-modified"> 836   const Type *t2this = dual_join-&gt;xmeet(this_t-&gt;_dual);</span>
 837 
 838   // Interface meet Oop is Not Symmetric:
 839   // Interface:AnyNull meet Oop:AnyNull == Interface:AnyNull
 840   // Interface:NotNull meet Oop:NotNull == java/lang/Object:NotNull
 841 
<a name="4" id="anc4"></a><span class="line-modified"> 842   if( !interface_vs_oop(t) &amp;&amp; (t2t != t-&gt;_dual || t2this != this_t-&gt;_dual) ) {</span>
 843     tty-&gt;print_cr(&quot;=== Meet Not Symmetric ===&quot;);
 844     tty-&gt;print(&quot;t   =                   &quot;);              t-&gt;dump(); tty-&gt;cr();
<a name="5" id="anc5"></a><span class="line-modified"> 845     tty-&gt;print(&quot;this=                   &quot;);         this_t-&gt;dump(); tty-&gt;cr();</span>
 846     tty-&gt;print(&quot;mt=(t meet this)=       &quot;);             mt-&gt;dump(); tty-&gt;cr();
 847 
 848     tty-&gt;print(&quot;t_dual=                 &quot;);       t-&gt;_dual-&gt;dump(); tty-&gt;cr();
<a name="6" id="anc6"></a><span class="line-modified"> 849     tty-&gt;print(&quot;this_dual=              &quot;);  this_t-&gt;_dual-&gt;dump(); tty-&gt;cr();</span>
 850     tty-&gt;print(&quot;mt_dual=                &quot;);      mt-&gt;_dual-&gt;dump(); tty-&gt;cr();
 851 
 852     tty-&gt;print(&quot;mt_dual meet t_dual=    &quot;); t2t           -&gt;dump(); tty-&gt;cr();
 853     tty-&gt;print(&quot;mt_dual meet this_dual= &quot;); t2this        -&gt;dump(); tty-&gt;cr();
 854 
 855     fatal(&quot;meet not symmetric&quot; );
 856   }
<a name="7" id="anc7"></a>









































 857 #endif
 858   return mt;
 859 }
 860 
 861 //------------------------------xmeet------------------------------------------
 862 // Compute the MEET of two types.  It returns a new Type object.
 863 const Type *Type::xmeet( const Type *t ) const {
 864   // Perform a fast test for common case; meeting the same types together.
 865   if( this == t ) return this;  // Meeting same type-rep?
 866 
 867   // Meeting TOP with anything?
 868   if( _base == Top ) return t;
 869 
 870   // Meeting BOTTOM with anything?
 871   if( _base == Bottom ) return BOTTOM;
 872 
 873   // Current &quot;this-&gt;_base&quot; is one of: Bad, Multi, Control, Top,
 874   // Abio, Abstore, Floatxxx, Doublexxx, Bottom, lastype.
 875   switch (t-&gt;base()) {  // Switch on original type
 876 
 877   // Cut in half the number of cases I must handle.  Only need cases for when
 878   // the given enum &quot;t-&gt;type&quot; is less than or equal to the local enum &quot;type&quot;.
 879   case FloatCon:
 880   case DoubleCon:
 881   case Int:
 882   case Long:
 883     return t-&gt;xmeet(this);
 884 
 885   case OopPtr:
 886     return t-&gt;xmeet(this);
 887 
 888   case InstPtr:
 889     return t-&gt;xmeet(this);
 890 
 891   case MetadataPtr:
 892   case KlassPtr:
 893     return t-&gt;xmeet(this);
 894 
 895   case AryPtr:
 896     return t-&gt;xmeet(this);
 897 
 898   case NarrowOop:
 899     return t-&gt;xmeet(this);
 900 
 901   case NarrowKlass:
 902     return t-&gt;xmeet(this);
 903 
 904   case Bad:                     // Type check
 905   default:                      // Bogus type not in lattice
 906     typerr(t);
 907     return Type::BOTTOM;
 908 
 909   case Bottom:                  // Ye Olde Default
 910     return t;
 911 
 912   case FloatTop:
 913     if( _base == FloatTop ) return this;
 914   case FloatBot:                // Float
 915     if( _base == FloatBot || _base == FloatTop ) return FLOAT;
 916     if( _base == DoubleTop || _base == DoubleBot ) return Type::BOTTOM;
 917     typerr(t);
 918     return Type::BOTTOM;
 919 
 920   case DoubleTop:
 921     if( _base == DoubleTop ) return this;
 922   case DoubleBot:               // Double
 923     if( _base == DoubleBot || _base == DoubleTop ) return DOUBLE;
 924     if( _base == FloatTop || _base == FloatBot ) return Type::BOTTOM;
 925     typerr(t);
 926     return Type::BOTTOM;
 927 
 928   // These next few cases must match exactly or it is a compile-time error.
 929   case Control:                 // Control of code
 930   case Abio:                    // State of world outside of program
 931   case Memory:
 932     if( _base == t-&gt;_base )  return this;
 933     typerr(t);
 934     return Type::BOTTOM;
 935 
 936   case Top:                     // Top of the lattice
 937     return this;
 938   }
 939 
 940   // The type is unchanged
 941   return this;
 942 }
 943 
 944 //-----------------------------filter------------------------------------------
 945 const Type *Type::filter_helper(const Type *kills, bool include_speculative) const {
 946   const Type* ft = join_helper(kills, include_speculative);
 947   if (ft-&gt;empty())
 948     return Type::TOP;           // Canonical empty value
 949   return ft;
 950 }
 951 
 952 //------------------------------xdual------------------------------------------
 953 // Compute dual right now.
 954 const Type::TYPES Type::dual_type[Type::lastype] = {
 955   Bad,          // Bad
 956   Control,      // Control
 957   Bottom,       // Top
 958   Bad,          // Int - handled in v-call
 959   Bad,          // Long - handled in v-call
 960   Half,         // Half
 961   Bad,          // NarrowOop - handled in v-call
 962   Bad,          // NarrowKlass - handled in v-call
 963 
 964   Bad,          // Tuple - handled in v-call
 965   Bad,          // Array - handled in v-call
 966   Bad,          // VectorS - handled in v-call
 967   Bad,          // VectorD - handled in v-call
 968   Bad,          // VectorX - handled in v-call
 969   Bad,          // VectorY - handled in v-call
 970   Bad,          // VectorZ - handled in v-call
 971 
 972   Bad,          // AnyPtr - handled in v-call
 973   Bad,          // RawPtr - handled in v-call
 974   Bad,          // OopPtr - handled in v-call
 975   Bad,          // InstPtr - handled in v-call
 976   Bad,          // AryPtr - handled in v-call
 977 
 978   Bad,          //  MetadataPtr - handled in v-call
 979   Bad,          // KlassPtr - handled in v-call
 980 
 981   Bad,          // Function - handled in v-call
 982   Abio,         // Abio
 983   Return_Address,// Return_Address
 984   Memory,       // Memory
 985   FloatBot,     // FloatTop
 986   FloatCon,     // FloatCon
 987   FloatTop,     // FloatBot
 988   DoubleBot,    // DoubleTop
 989   DoubleCon,    // DoubleCon
 990   DoubleTop,    // DoubleBot
 991   Top           // Bottom
 992 };
 993 
 994 const Type *Type::xdual() const {
 995   // Note: the base() accessor asserts the sanity of _base.
 996   assert(_type_info[base()].dual_type != Bad, &quot;implement with v-call&quot;);
 997   return new Type(_type_info[_base].dual_type);
 998 }
 999 
1000 //------------------------------has_memory-------------------------------------
1001 bool Type::has_memory() const {
1002   Type::TYPES tx = base();
1003   if (tx == Memory) return true;
1004   if (tx == Tuple) {
1005     const TypeTuple *t = is_tuple();
1006     for (uint i=0; i &lt; t-&gt;cnt(); i++) {
1007       tx = t-&gt;field_at(i)-&gt;base();
1008       if (tx == Memory)  return true;
1009     }
1010   }
1011   return false;
1012 }
1013 
1014 #ifndef PRODUCT
1015 //------------------------------dump2------------------------------------------
1016 void Type::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1017   st-&gt;print(&quot;%s&quot;, _type_info[_base].msg);
1018 }
1019 
1020 //------------------------------dump-------------------------------------------
1021 void Type::dump_on(outputStream *st) const {
1022   ResourceMark rm;
1023   Dict d(cmpkey,hashkey);       // Stop recursive type dumping
1024   dump2(d,1, st);
1025   if (is_ptr_to_narrowoop()) {
1026     st-&gt;print(&quot; [narrow]&quot;);
1027   } else if (is_ptr_to_narrowklass()) {
1028     st-&gt;print(&quot; [narrowklass]&quot;);
1029   }
1030 }
1031 
1032 //-----------------------------------------------------------------------------
1033 const char* Type::str(const Type* t) {
1034   stringStream ss;
1035   t-&gt;dump_on(&amp;ss);
1036   return ss.as_string();
1037 }
1038 #endif
1039 
1040 //------------------------------singleton--------------------------------------
1041 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1042 // constants (Ldi nodes).  Singletons are integer, float or double constants.
1043 bool Type::singleton(void) const {
1044   return _base == Top || _base == Half;
1045 }
1046 
1047 //------------------------------empty------------------------------------------
1048 // TRUE if Type is a type with no values, FALSE otherwise.
1049 bool Type::empty(void) const {
1050   switch (_base) {
1051   case DoubleTop:
1052   case FloatTop:
1053   case Top:
1054     return true;
1055 
1056   case Half:
1057   case Abio:
1058   case Return_Address:
1059   case Memory:
1060   case Bottom:
1061   case FloatBot:
1062   case DoubleBot:
1063     return false;  // never a singleton, therefore never empty
1064 
1065   default:
1066     ShouldNotReachHere();
1067     return false;
1068   }
1069 }
1070 
1071 //------------------------------dump_stats-------------------------------------
1072 // Dump collected statistics to stderr
1073 #ifndef PRODUCT
1074 void Type::dump_stats() {
1075   tty-&gt;print(&quot;Types made: %d\n&quot;, type_dict()-&gt;Size());
1076 }
1077 #endif
1078 
1079 //------------------------------typerr-----------------------------------------
1080 void Type::typerr( const Type *t ) const {
1081 #ifndef PRODUCT
1082   tty-&gt;print(&quot;\nError mixing types: &quot;);
1083   dump();
1084   tty-&gt;print(&quot; and &quot;);
1085   t-&gt;dump();
1086   tty-&gt;print(&quot;\n&quot;);
1087 #endif
1088   ShouldNotReachHere();
1089 }
1090 
1091 
1092 //=============================================================================
1093 // Convenience common pre-built types.
1094 const TypeF *TypeF::ZERO;       // Floating point zero
1095 const TypeF *TypeF::ONE;        // Floating point one
1096 const TypeF *TypeF::POS_INF;    // Floating point positive infinity
1097 const TypeF *TypeF::NEG_INF;    // Floating point negative infinity
1098 
1099 //------------------------------make-------------------------------------------
1100 // Create a float constant
1101 const TypeF *TypeF::make(float f) {
1102   return (TypeF*)(new TypeF(f))-&gt;hashcons();
1103 }
1104 
1105 //------------------------------meet-------------------------------------------
1106 // Compute the MEET of two types.  It returns a new Type object.
1107 const Type *TypeF::xmeet( const Type *t ) const {
1108   // Perform a fast test for common case; meeting the same types together.
1109   if( this == t ) return this;  // Meeting same type-rep?
1110 
1111   // Current &quot;this-&gt;_base&quot; is FloatCon
1112   switch (t-&gt;base()) {          // Switch on original type
1113   case AnyPtr:                  // Mixing with oops happens when javac
1114   case RawPtr:                  // reuses local variables
1115   case OopPtr:
1116   case InstPtr:
1117   case AryPtr:
1118   case MetadataPtr:
1119   case KlassPtr:
1120   case NarrowOop:
1121   case NarrowKlass:
1122   case Int:
1123   case Long:
1124   case DoubleTop:
1125   case DoubleCon:
1126   case DoubleBot:
1127   case Bottom:                  // Ye Olde Default
1128     return Type::BOTTOM;
1129 
1130   case FloatBot:
1131     return t;
1132 
1133   default:                      // All else is a mistake
1134     typerr(t);
1135 
1136   case FloatCon:                // Float-constant vs Float-constant?
1137     if( jint_cast(_f) != jint_cast(t-&gt;getf()) )         // unequal constants?
1138                                 // must compare bitwise as positive zero, negative zero and NaN have
1139                                 // all the same representation in C++
1140       return FLOAT;             // Return generic float
1141                                 // Equal constants
1142   case Top:
1143   case FloatTop:
1144     break;                      // Return the float constant
1145   }
1146   return this;                  // Return the float constant
1147 }
1148 
1149 //------------------------------xdual------------------------------------------
1150 // Dual: symmetric
1151 const Type *TypeF::xdual() const {
1152   return this;
1153 }
1154 
1155 //------------------------------eq---------------------------------------------
1156 // Structural equality check for Type representations
1157 bool TypeF::eq(const Type *t) const {
1158   // Bitwise comparison to distinguish between +/-0. These values must be treated
1159   // as different to be consistent with C1 and the interpreter.
1160   return (jint_cast(_f) == jint_cast(t-&gt;getf()));
1161 }
1162 
1163 //------------------------------hash-------------------------------------------
1164 // Type-specific hashing function.
1165 int TypeF::hash(void) const {
1166   return *(int*)(&amp;_f);
1167 }
1168 
1169 //------------------------------is_finite--------------------------------------
1170 // Has a finite value
1171 bool TypeF::is_finite() const {
1172   return g_isfinite(getf()) != 0;
1173 }
1174 
1175 //------------------------------is_nan-----------------------------------------
1176 // Is not a number (NaN)
1177 bool TypeF::is_nan()    const {
1178   return g_isnan(getf()) != 0;
1179 }
1180 
1181 //------------------------------dump2------------------------------------------
1182 // Dump float constant Type
1183 #ifndef PRODUCT
1184 void TypeF::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1185   Type::dump2(d,depth, st);
1186   st-&gt;print(&quot;%f&quot;, _f);
1187 }
1188 #endif
1189 
1190 //------------------------------singleton--------------------------------------
1191 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1192 // constants (Ldi nodes).  Singletons are integer, float or double constants
1193 // or a single symbol.
1194 bool TypeF::singleton(void) const {
1195   return true;                  // Always a singleton
1196 }
1197 
1198 bool TypeF::empty(void) const {
1199   return false;                 // always exactly a singleton
1200 }
1201 
1202 //=============================================================================
1203 // Convenience common pre-built types.
1204 const TypeD *TypeD::ZERO;       // Floating point zero
1205 const TypeD *TypeD::ONE;        // Floating point one
1206 const TypeD *TypeD::POS_INF;    // Floating point positive infinity
1207 const TypeD *TypeD::NEG_INF;    // Floating point negative infinity
1208 
1209 //------------------------------make-------------------------------------------
1210 const TypeD *TypeD::make(double d) {
1211   return (TypeD*)(new TypeD(d))-&gt;hashcons();
1212 }
1213 
1214 //------------------------------meet-------------------------------------------
1215 // Compute the MEET of two types.  It returns a new Type object.
1216 const Type *TypeD::xmeet( const Type *t ) const {
1217   // Perform a fast test for common case; meeting the same types together.
1218   if( this == t ) return this;  // Meeting same type-rep?
1219 
1220   // Current &quot;this-&gt;_base&quot; is DoubleCon
1221   switch (t-&gt;base()) {          // Switch on original type
1222   case AnyPtr:                  // Mixing with oops happens when javac
1223   case RawPtr:                  // reuses local variables
1224   case OopPtr:
1225   case InstPtr:
1226   case AryPtr:
1227   case MetadataPtr:
1228   case KlassPtr:
1229   case NarrowOop:
1230   case NarrowKlass:
1231   case Int:
1232   case Long:
1233   case FloatTop:
1234   case FloatCon:
1235   case FloatBot:
1236   case Bottom:                  // Ye Olde Default
1237     return Type::BOTTOM;
1238 
1239   case DoubleBot:
1240     return t;
1241 
1242   default:                      // All else is a mistake
1243     typerr(t);
1244 
1245   case DoubleCon:               // Double-constant vs Double-constant?
1246     if( jlong_cast(_d) != jlong_cast(t-&gt;getd()) )       // unequal constants? (see comment in TypeF::xmeet)
1247       return DOUBLE;            // Return generic double
1248   case Top:
1249   case DoubleTop:
1250     break;
1251   }
1252   return this;                  // Return the double constant
1253 }
1254 
1255 //------------------------------xdual------------------------------------------
1256 // Dual: symmetric
1257 const Type *TypeD::xdual() const {
1258   return this;
1259 }
1260 
1261 //------------------------------eq---------------------------------------------
1262 // Structural equality check for Type representations
1263 bool TypeD::eq(const Type *t) const {
1264   // Bitwise comparison to distinguish between +/-0. These values must be treated
1265   // as different to be consistent with C1 and the interpreter.
1266   return (jlong_cast(_d) == jlong_cast(t-&gt;getd()));
1267 }
1268 
1269 //------------------------------hash-------------------------------------------
1270 // Type-specific hashing function.
1271 int TypeD::hash(void) const {
1272   return *(int*)(&amp;_d);
1273 }
1274 
1275 //------------------------------is_finite--------------------------------------
1276 // Has a finite value
1277 bool TypeD::is_finite() const {
1278   return g_isfinite(getd()) != 0;
1279 }
1280 
1281 //------------------------------is_nan-----------------------------------------
1282 // Is not a number (NaN)
1283 bool TypeD::is_nan()    const {
1284   return g_isnan(getd()) != 0;
1285 }
1286 
1287 //------------------------------dump2------------------------------------------
1288 // Dump double constant Type
1289 #ifndef PRODUCT
1290 void TypeD::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1291   Type::dump2(d,depth,st);
1292   st-&gt;print(&quot;%f&quot;, _d);
1293 }
1294 #endif
1295 
1296 //------------------------------singleton--------------------------------------
1297 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1298 // constants (Ldi nodes).  Singletons are integer, float or double constants
1299 // or a single symbol.
1300 bool TypeD::singleton(void) const {
1301   return true;                  // Always a singleton
1302 }
1303 
1304 bool TypeD::empty(void) const {
1305   return false;                 // always exactly a singleton
1306 }
1307 
1308 //=============================================================================
1309 // Convience common pre-built types.
1310 const TypeInt *TypeInt::MINUS_1;// -1
1311 const TypeInt *TypeInt::ZERO;   // 0
1312 const TypeInt *TypeInt::ONE;    // 1
1313 const TypeInt *TypeInt::BOOL;   // 0 or 1, FALSE or TRUE.
1314 const TypeInt *TypeInt::CC;     // -1,0 or 1, condition codes
1315 const TypeInt *TypeInt::CC_LT;  // [-1]  == MINUS_1
1316 const TypeInt *TypeInt::CC_GT;  // [1]   == ONE
1317 const TypeInt *TypeInt::CC_EQ;  // [0]   == ZERO
1318 const TypeInt *TypeInt::CC_LE;  // [-1,0]
1319 const TypeInt *TypeInt::CC_GE;  // [0,1] == BOOL (!)
1320 const TypeInt *TypeInt::BYTE;   // Bytes, -128 to 127
1321 const TypeInt *TypeInt::UBYTE;  // Unsigned Bytes, 0 to 255
1322 const TypeInt *TypeInt::CHAR;   // Java chars, 0-65535
1323 const TypeInt *TypeInt::SHORT;  // Java shorts, -32768-32767
1324 const TypeInt *TypeInt::POS;    // Positive 32-bit integers or zero
1325 const TypeInt *TypeInt::POS1;   // Positive 32-bit integers
1326 const TypeInt *TypeInt::INT;    // 32-bit integers
1327 const TypeInt *TypeInt::SYMINT; // symmetric range [-max_jint..max_jint]
1328 const TypeInt *TypeInt::TYPE_DOMAIN; // alias for TypeInt::INT
1329 
1330 //------------------------------TypeInt----------------------------------------
1331 TypeInt::TypeInt( jint lo, jint hi, int w ) : Type(Int), _lo(lo), _hi(hi), _widen(w) {
1332 }
1333 
1334 //------------------------------make-------------------------------------------
1335 const TypeInt *TypeInt::make( jint lo ) {
1336   return (TypeInt*)(new TypeInt(lo,lo,WidenMin))-&gt;hashcons();
1337 }
1338 
1339 static int normalize_int_widen( jint lo, jint hi, int w ) {
1340   // Certain normalizations keep us sane when comparing types.
1341   // The &#39;SMALLINT&#39; covers constants and also CC and its relatives.
1342   if (lo &lt;= hi) {
1343     if (((juint)hi - lo) &lt;= SMALLINT)  w = Type::WidenMin;
1344     if (((juint)hi - lo) &gt;= max_juint) w = Type::WidenMax; // TypeInt::INT
1345   } else {
1346     if (((juint)lo - hi) &lt;= SMALLINT)  w = Type::WidenMin;
1347     if (((juint)lo - hi) &gt;= max_juint) w = Type::WidenMin; // dual TypeInt::INT
1348   }
1349   return w;
1350 }
1351 
1352 const TypeInt *TypeInt::make( jint lo, jint hi, int w ) {
1353   w = normalize_int_widen(lo, hi, w);
1354   return (TypeInt*)(new TypeInt(lo,hi,w))-&gt;hashcons();
1355 }
1356 
1357 //------------------------------meet-------------------------------------------
1358 // Compute the MEET of two types.  It returns a new Type representation object
1359 // with reference count equal to the number of Types pointing at it.
1360 // Caller should wrap a Types around it.
1361 const Type *TypeInt::xmeet( const Type *t ) const {
1362   // Perform a fast test for common case; meeting the same types together.
1363   if( this == t ) return this;  // Meeting same type?
1364 
1365   // Currently &quot;this-&gt;_base&quot; is a TypeInt
1366   switch (t-&gt;base()) {          // Switch on original type
1367   case AnyPtr:                  // Mixing with oops happens when javac
1368   case RawPtr:                  // reuses local variables
1369   case OopPtr:
1370   case InstPtr:
1371   case AryPtr:
1372   case MetadataPtr:
1373   case KlassPtr:
1374   case NarrowOop:
1375   case NarrowKlass:
1376   case Long:
1377   case FloatTop:
1378   case FloatCon:
1379   case FloatBot:
1380   case DoubleTop:
1381   case DoubleCon:
1382   case DoubleBot:
1383   case Bottom:                  // Ye Olde Default
1384     return Type::BOTTOM;
1385   default:                      // All else is a mistake
1386     typerr(t);
1387   case Top:                     // No change
1388     return this;
1389   case Int:                     // Int vs Int?
1390     break;
1391   }
1392 
1393   // Expand covered set
1394   const TypeInt *r = t-&gt;is_int();
1395   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1396 }
1397 
1398 //------------------------------xdual------------------------------------------
1399 // Dual: reverse hi &amp; lo; flip widen
1400 const Type *TypeInt::xdual() const {
1401   int w = normalize_int_widen(_hi,_lo, WidenMax-_widen);
1402   return new TypeInt(_hi,_lo,w);
1403 }
1404 
1405 //------------------------------widen------------------------------------------
1406 // Only happens for optimistic top-down optimizations.
1407 const Type *TypeInt::widen( const Type *old, const Type* limit ) const {
1408   // Coming from TOP or such; no widening
1409   if( old-&gt;base() != Int ) return this;
1410   const TypeInt *ot = old-&gt;is_int();
1411 
1412   // If new guy is equal to old guy, no widening
1413   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1414     return old;
1415 
1416   // If new guy contains old, then we widened
1417   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1418     // New contains old
1419     // If new guy is already wider than old, no widening
1420     if( _widen &gt; ot-&gt;_widen ) return this;
1421     // If old guy was a constant, do not bother
1422     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1423     // Now widen new guy.
1424     // Check for widening too far
1425     if (_widen == WidenMax) {
1426       int max = max_jint;
1427       int min = min_jint;
1428       if (limit-&gt;isa_int()) {
1429         max = limit-&gt;is_int()-&gt;_hi;
1430         min = limit-&gt;is_int()-&gt;_lo;
1431       }
1432       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1433         // If neither endpoint is extremal yet, push out the endpoint
1434         // which is closer to its respective limit.
1435         if (_lo &gt;= 0 ||                 // easy common case
1436             (juint)(_lo - min) &gt;= (juint)(max - _hi)) {
1437           // Try to widen to an unsigned range type of 31 bits:
1438           return make(_lo, max, WidenMax);
1439         } else {
1440           return make(min, _hi, WidenMax);
1441         }
1442       }
1443       return TypeInt::INT;
1444     }
1445     // Returned widened new guy
1446     return make(_lo,_hi,_widen+1);
1447   }
1448 
1449   // If old guy contains new, then we probably widened too far &amp; dropped to
1450   // bottom.  Return the wider fellow.
1451   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1452     return old;
1453 
1454   //fatal(&quot;Integer value range is not subset&quot;);
1455   //return this;
1456   return TypeInt::INT;
1457 }
1458 
1459 //------------------------------narrow---------------------------------------
1460 // Only happens for pessimistic optimizations.
1461 const Type *TypeInt::narrow( const Type *old ) const {
1462   if (_lo &gt;= _hi)  return this;   // already narrow enough
1463   if (old == NULL)  return this;
1464   const TypeInt* ot = old-&gt;isa_int();
1465   if (ot == NULL)  return this;
1466   jint olo = ot-&gt;_lo;
1467   jint ohi = ot-&gt;_hi;
1468 
1469   // If new guy is equal to old guy, no narrowing
1470   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1471 
1472   // If old guy was maximum range, allow the narrowing
1473   if (olo == min_jint &amp;&amp; ohi == max_jint)  return this;
1474 
1475   if (_lo &lt; olo || _hi &gt; ohi)
1476     return this;                // doesn&#39;t narrow; pretty wierd
1477 
1478   // The new type narrows the old type, so look for a &quot;death march&quot;.
1479   // See comments on PhaseTransform::saturate.
1480   juint nrange = (juint)_hi - _lo;
1481   juint orange = (juint)ohi - olo;
1482   if (nrange &lt; max_juint - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1483     // Use the new type only if the range shrinks a lot.
1484     // We do not want the optimizer computing 2^31 point by point.
1485     return old;
1486   }
1487 
1488   return this;
1489 }
1490 
1491 //-----------------------------filter------------------------------------------
1492 const Type *TypeInt::filter_helper(const Type *kills, bool include_speculative) const {
1493   const TypeInt* ft = join_helper(kills, include_speculative)-&gt;isa_int();
1494   if (ft == NULL || ft-&gt;empty())
1495     return Type::TOP;           // Canonical empty value
1496   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1497     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1498     // The widen bits must be allowed to run freely through the graph.
1499     ft = TypeInt::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1500   }
1501   return ft;
1502 }
1503 
1504 //------------------------------eq---------------------------------------------
1505 // Structural equality check for Type representations
1506 bool TypeInt::eq( const Type *t ) const {
1507   const TypeInt *r = t-&gt;is_int(); // Handy access
1508   return r-&gt;_lo == _lo &amp;&amp; r-&gt;_hi == _hi &amp;&amp; r-&gt;_widen == _widen;
1509 }
1510 
1511 //------------------------------hash-------------------------------------------
1512 // Type-specific hashing function.
1513 int TypeInt::hash(void) const {
1514   return java_add(java_add(_lo, _hi), java_add((jint)_widen, (jint)Type::Int));
1515 }
1516 
1517 //------------------------------is_finite--------------------------------------
1518 // Has a finite value
1519 bool TypeInt::is_finite() const {
1520   return true;
1521 }
1522 
1523 //------------------------------dump2------------------------------------------
1524 // Dump TypeInt
1525 #ifndef PRODUCT
1526 static const char* intname(char* buf, jint n) {
1527   if (n == min_jint)
1528     return &quot;min&quot;;
1529   else if (n &lt; min_jint + 10000)
1530     sprintf(buf, &quot;min+&quot; INT32_FORMAT, n - min_jint);
1531   else if (n == max_jint)
1532     return &quot;max&quot;;
1533   else if (n &gt; max_jint - 10000)
1534     sprintf(buf, &quot;max-&quot; INT32_FORMAT, max_jint - n);
1535   else
1536     sprintf(buf, INT32_FORMAT, n);
1537   return buf;
1538 }
1539 
1540 void TypeInt::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1541   char buf[40], buf2[40];
1542   if (_lo == min_jint &amp;&amp; _hi == max_jint)
1543     st-&gt;print(&quot;int&quot;);
1544   else if (is_con())
1545     st-&gt;print(&quot;int:%s&quot;, intname(buf, get_con()));
1546   else if (_lo == BOOL-&gt;_lo &amp;&amp; _hi == BOOL-&gt;_hi)
1547     st-&gt;print(&quot;bool&quot;);
1548   else if (_lo == BYTE-&gt;_lo &amp;&amp; _hi == BYTE-&gt;_hi)
1549     st-&gt;print(&quot;byte&quot;);
1550   else if (_lo == CHAR-&gt;_lo &amp;&amp; _hi == CHAR-&gt;_hi)
1551     st-&gt;print(&quot;char&quot;);
1552   else if (_lo == SHORT-&gt;_lo &amp;&amp; _hi == SHORT-&gt;_hi)
1553     st-&gt;print(&quot;short&quot;);
1554   else if (_hi == max_jint)
1555     st-&gt;print(&quot;int:&gt;=%s&quot;, intname(buf, _lo));
1556   else if (_lo == min_jint)
1557     st-&gt;print(&quot;int:&lt;=%s&quot;, intname(buf, _hi));
1558   else
1559     st-&gt;print(&quot;int:%s..%s&quot;, intname(buf, _lo), intname(buf2, _hi));
1560 
1561   if (_widen != 0 &amp;&amp; this != TypeInt::INT)
1562     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1563 }
1564 #endif
1565 
1566 //------------------------------singleton--------------------------------------
1567 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1568 // constants.
1569 bool TypeInt::singleton(void) const {
1570   return _lo &gt;= _hi;
1571 }
1572 
1573 bool TypeInt::empty(void) const {
1574   return _lo &gt; _hi;
1575 }
1576 
1577 //=============================================================================
1578 // Convenience common pre-built types.
1579 const TypeLong *TypeLong::MINUS_1;// -1
1580 const TypeLong *TypeLong::ZERO; // 0
1581 const TypeLong *TypeLong::ONE;  // 1
1582 const TypeLong *TypeLong::POS;  // &gt;=0
1583 const TypeLong *TypeLong::LONG; // 64-bit integers
1584 const TypeLong *TypeLong::INT;  // 32-bit subrange
1585 const TypeLong *TypeLong::UINT; // 32-bit unsigned subrange
1586 const TypeLong *TypeLong::TYPE_DOMAIN; // alias for TypeLong::LONG
1587 
1588 //------------------------------TypeLong---------------------------------------
1589 TypeLong::TypeLong( jlong lo, jlong hi, int w ) : Type(Long), _lo(lo), _hi(hi), _widen(w) {
1590 }
1591 
1592 //------------------------------make-------------------------------------------
1593 const TypeLong *TypeLong::make( jlong lo ) {
1594   return (TypeLong*)(new TypeLong(lo,lo,WidenMin))-&gt;hashcons();
1595 }
1596 
1597 static int normalize_long_widen( jlong lo, jlong hi, int w ) {
1598   // Certain normalizations keep us sane when comparing types.
1599   // The &#39;SMALLINT&#39; covers constants.
1600   if (lo &lt;= hi) {
1601     if (((julong)hi - lo) &lt;= SMALLINT)   w = Type::WidenMin;
1602     if (((julong)hi - lo) &gt;= max_julong) w = Type::WidenMax; // TypeLong::LONG
1603   } else {
1604     if (((julong)lo - hi) &lt;= SMALLINT)   w = Type::WidenMin;
1605     if (((julong)lo - hi) &gt;= max_julong) w = Type::WidenMin; // dual TypeLong::LONG
1606   }
1607   return w;
1608 }
1609 
1610 const TypeLong *TypeLong::make( jlong lo, jlong hi, int w ) {
1611   w = normalize_long_widen(lo, hi, w);
1612   return (TypeLong*)(new TypeLong(lo,hi,w))-&gt;hashcons();
1613 }
1614 
1615 
1616 //------------------------------meet-------------------------------------------
1617 // Compute the MEET of two types.  It returns a new Type representation object
1618 // with reference count equal to the number of Types pointing at it.
1619 // Caller should wrap a Types around it.
1620 const Type *TypeLong::xmeet( const Type *t ) const {
1621   // Perform a fast test for common case; meeting the same types together.
1622   if( this == t ) return this;  // Meeting same type?
1623 
1624   // Currently &quot;this-&gt;_base&quot; is a TypeLong
1625   switch (t-&gt;base()) {          // Switch on original type
1626   case AnyPtr:                  // Mixing with oops happens when javac
1627   case RawPtr:                  // reuses local variables
1628   case OopPtr:
1629   case InstPtr:
1630   case AryPtr:
1631   case MetadataPtr:
1632   case KlassPtr:
1633   case NarrowOop:
1634   case NarrowKlass:
1635   case Int:
1636   case FloatTop:
1637   case FloatCon:
1638   case FloatBot:
1639   case DoubleTop:
1640   case DoubleCon:
1641   case DoubleBot:
1642   case Bottom:                  // Ye Olde Default
1643     return Type::BOTTOM;
1644   default:                      // All else is a mistake
1645     typerr(t);
1646   case Top:                     // No change
1647     return this;
1648   case Long:                    // Long vs Long?
1649     break;
1650   }
1651 
1652   // Expand covered set
1653   const TypeLong *r = t-&gt;is_long(); // Turn into a TypeLong
1654   return make( MIN2(_lo,r-&gt;_lo), MAX2(_hi,r-&gt;_hi), MAX2(_widen,r-&gt;_widen) );
1655 }
1656 
1657 //------------------------------xdual------------------------------------------
1658 // Dual: reverse hi &amp; lo; flip widen
1659 const Type *TypeLong::xdual() const {
1660   int w = normalize_long_widen(_hi,_lo, WidenMax-_widen);
1661   return new TypeLong(_hi,_lo,w);
1662 }
1663 
1664 //------------------------------widen------------------------------------------
1665 // Only happens for optimistic top-down optimizations.
1666 const Type *TypeLong::widen( const Type *old, const Type* limit ) const {
1667   // Coming from TOP or such; no widening
1668   if( old-&gt;base() != Long ) return this;
1669   const TypeLong *ot = old-&gt;is_long();
1670 
1671   // If new guy is equal to old guy, no widening
1672   if( _lo == ot-&gt;_lo &amp;&amp; _hi == ot-&gt;_hi )
1673     return old;
1674 
1675   // If new guy contains old, then we widened
1676   if( _lo &lt;= ot-&gt;_lo &amp;&amp; _hi &gt;= ot-&gt;_hi ) {
1677     // New contains old
1678     // If new guy is already wider than old, no widening
1679     if( _widen &gt; ot-&gt;_widen ) return this;
1680     // If old guy was a constant, do not bother
1681     if (ot-&gt;_lo == ot-&gt;_hi)  return this;
1682     // Now widen new guy.
1683     // Check for widening too far
1684     if (_widen == WidenMax) {
1685       jlong max = max_jlong;
1686       jlong min = min_jlong;
1687       if (limit-&gt;isa_long()) {
1688         max = limit-&gt;is_long()-&gt;_hi;
1689         min = limit-&gt;is_long()-&gt;_lo;
1690       }
1691       if (min &lt; _lo &amp;&amp; _hi &lt; max) {
1692         // If neither endpoint is extremal yet, push out the endpoint
1693         // which is closer to its respective limit.
1694         if (_lo &gt;= 0 ||                 // easy common case
1695             ((julong)_lo - min) &gt;= ((julong)max - _hi)) {
1696           // Try to widen to an unsigned range type of 32/63 bits:
1697           if (max &gt;= max_juint &amp;&amp; _hi &lt; max_juint)
1698             return make(_lo, max_juint, WidenMax);
1699           else
1700             return make(_lo, max, WidenMax);
1701         } else {
1702           return make(min, _hi, WidenMax);
1703         }
1704       }
1705       return TypeLong::LONG;
1706     }
1707     // Returned widened new guy
1708     return make(_lo,_hi,_widen+1);
1709   }
1710 
1711   // If old guy contains new, then we probably widened too far &amp; dropped to
1712   // bottom.  Return the wider fellow.
1713   if ( ot-&gt;_lo &lt;= _lo &amp;&amp; ot-&gt;_hi &gt;= _hi )
1714     return old;
1715 
1716   //  fatal(&quot;Long value range is not subset&quot;);
1717   // return this;
1718   return TypeLong::LONG;
1719 }
1720 
1721 //------------------------------narrow----------------------------------------
1722 // Only happens for pessimistic optimizations.
1723 const Type *TypeLong::narrow( const Type *old ) const {
1724   if (_lo &gt;= _hi)  return this;   // already narrow enough
1725   if (old == NULL)  return this;
1726   const TypeLong* ot = old-&gt;isa_long();
1727   if (ot == NULL)  return this;
1728   jlong olo = ot-&gt;_lo;
1729   jlong ohi = ot-&gt;_hi;
1730 
1731   // If new guy is equal to old guy, no narrowing
1732   if (_lo == olo &amp;&amp; _hi == ohi)  return old;
1733 
1734   // If old guy was maximum range, allow the narrowing
1735   if (olo == min_jlong &amp;&amp; ohi == max_jlong)  return this;
1736 
1737   if (_lo &lt; olo || _hi &gt; ohi)
1738     return this;                // doesn&#39;t narrow; pretty wierd
1739 
1740   // The new type narrows the old type, so look for a &quot;death march&quot;.
1741   // See comments on PhaseTransform::saturate.
1742   julong nrange = _hi - _lo;
1743   julong orange = ohi - olo;
1744   if (nrange &lt; max_julong - 1 &amp;&amp; nrange &gt; (orange &gt;&gt; 1) + (SMALLINT*2)) {
1745     // Use the new type only if the range shrinks a lot.
1746     // We do not want the optimizer computing 2^31 point by point.
1747     return old;
1748   }
1749 
1750   return this;
1751 }
1752 
1753 //-----------------------------filter------------------------------------------
1754 const Type *TypeLong::filter_helper(const Type *kills, bool include_speculative) const {
1755   const TypeLong* ft = join_helper(kills, include_speculative)-&gt;isa_long();
1756   if (ft == NULL || ft-&gt;empty())
1757     return Type::TOP;           // Canonical empty value
1758   if (ft-&gt;_widen &lt; this-&gt;_widen) {
1759     // Do not allow the value of kill-&gt;_widen to affect the outcome.
1760     // The widen bits must be allowed to run freely through the graph.
1761     ft = TypeLong::make(ft-&gt;_lo, ft-&gt;_hi, this-&gt;_widen);
1762   }
1763   return ft;
1764 }
1765 
1766 //------------------------------eq---------------------------------------------
1767 // Structural equality check for Type representations
1768 bool TypeLong::eq( const Type *t ) const {
1769   const TypeLong *r = t-&gt;is_long(); // Handy access
1770   return r-&gt;_lo == _lo &amp;&amp;  r-&gt;_hi == _hi  &amp;&amp; r-&gt;_widen == _widen;
1771 }
1772 
1773 //------------------------------hash-------------------------------------------
1774 // Type-specific hashing function.
1775 int TypeLong::hash(void) const {
1776   return (int)(_lo+_hi+_widen+(int)Type::Long);
1777 }
1778 
1779 //------------------------------is_finite--------------------------------------
1780 // Has a finite value
1781 bool TypeLong::is_finite() const {
1782   return true;
1783 }
1784 
1785 //------------------------------dump2------------------------------------------
1786 // Dump TypeLong
1787 #ifndef PRODUCT
1788 static const char* longnamenear(jlong x, const char* xname, char* buf, jlong n) {
1789   if (n &gt; x) {
1790     if (n &gt;= x + 10000)  return NULL;
1791     sprintf(buf, &quot;%s+&quot; JLONG_FORMAT, xname, n - x);
1792   } else if (n &lt; x) {
1793     if (n &lt;= x - 10000)  return NULL;
1794     sprintf(buf, &quot;%s-&quot; JLONG_FORMAT, xname, x - n);
1795   } else {
1796     return xname;
1797   }
1798   return buf;
1799 }
1800 
1801 static const char* longname(char* buf, jlong n) {
1802   const char* str;
1803   if (n == min_jlong)
1804     return &quot;min&quot;;
1805   else if (n &lt; min_jlong + 10000)
1806     sprintf(buf, &quot;min+&quot; JLONG_FORMAT, n - min_jlong);
1807   else if (n == max_jlong)
1808     return &quot;max&quot;;
1809   else if (n &gt; max_jlong - 10000)
1810     sprintf(buf, &quot;max-&quot; JLONG_FORMAT, max_jlong - n);
1811   else if ((str = longnamenear(max_juint, &quot;maxuint&quot;, buf, n)) != NULL)
1812     return str;
1813   else if ((str = longnamenear(max_jint, &quot;maxint&quot;, buf, n)) != NULL)
1814     return str;
1815   else if ((str = longnamenear(min_jint, &quot;minint&quot;, buf, n)) != NULL)
1816     return str;
1817   else
1818     sprintf(buf, JLONG_FORMAT, n);
1819   return buf;
1820 }
1821 
1822 void TypeLong::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
1823   char buf[80], buf2[80];
1824   if (_lo == min_jlong &amp;&amp; _hi == max_jlong)
1825     st-&gt;print(&quot;long&quot;);
1826   else if (is_con())
1827     st-&gt;print(&quot;long:%s&quot;, longname(buf, get_con()));
1828   else if (_hi == max_jlong)
1829     st-&gt;print(&quot;long:&gt;=%s&quot;, longname(buf, _lo));
1830   else if (_lo == min_jlong)
1831     st-&gt;print(&quot;long:&lt;=%s&quot;, longname(buf, _hi));
1832   else
1833     st-&gt;print(&quot;long:%s..%s&quot;, longname(buf, _lo), longname(buf2, _hi));
1834 
1835   if (_widen != 0 &amp;&amp; this != TypeLong::LONG)
1836     st-&gt;print(&quot;:%.*s&quot;, _widen, &quot;wwww&quot;);
1837 }
1838 #endif
1839 
1840 //------------------------------singleton--------------------------------------
1841 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
1842 // constants
1843 bool TypeLong::singleton(void) const {
1844   return _lo &gt;= _hi;
1845 }
1846 
1847 bool TypeLong::empty(void) const {
1848   return _lo &gt; _hi;
1849 }
1850 
1851 //=============================================================================
1852 // Convenience common pre-built types.
1853 const TypeTuple *TypeTuple::IFBOTH;     // Return both arms of IF as reachable
1854 const TypeTuple *TypeTuple::IFFALSE;
1855 const TypeTuple *TypeTuple::IFTRUE;
1856 const TypeTuple *TypeTuple::IFNEITHER;
1857 const TypeTuple *TypeTuple::LOOPBODY;
1858 const TypeTuple *TypeTuple::MEMBAR;
1859 const TypeTuple *TypeTuple::STORECONDITIONAL;
1860 const TypeTuple *TypeTuple::START_I2C;
1861 const TypeTuple *TypeTuple::INT_PAIR;
1862 const TypeTuple *TypeTuple::LONG_PAIR;
1863 const TypeTuple *TypeTuple::INT_CC_PAIR;
1864 const TypeTuple *TypeTuple::LONG_CC_PAIR;
1865 
1866 
1867 //------------------------------make-------------------------------------------
1868 // Make a TypeTuple from the range of a method signature
1869 const TypeTuple *TypeTuple::make_range(ciSignature* sig) {
1870   ciType* return_type = sig-&gt;return_type();
1871   uint arg_cnt = return_type-&gt;size();
1872   const Type **field_array = fields(arg_cnt);
1873   switch (return_type-&gt;basic_type()) {
1874   case T_LONG:
1875     field_array[TypeFunc::Parms]   = TypeLong::LONG;
1876     field_array[TypeFunc::Parms+1] = Type::HALF;
1877     break;
1878   case T_DOUBLE:
1879     field_array[TypeFunc::Parms]   = Type::DOUBLE;
1880     field_array[TypeFunc::Parms+1] = Type::HALF;
1881     break;
1882   case T_OBJECT:
1883   case T_ARRAY:
1884   case T_BOOLEAN:
1885   case T_CHAR:
1886   case T_FLOAT:
1887   case T_BYTE:
1888   case T_SHORT:
1889   case T_INT:
1890     field_array[TypeFunc::Parms] = get_const_type(return_type);
1891     break;
1892   case T_VOID:
1893     break;
1894   default:
1895     ShouldNotReachHere();
1896   }
1897   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1898 }
1899 
1900 // Make a TypeTuple from the domain of a method signature
1901 const TypeTuple *TypeTuple::make_domain(ciInstanceKlass* recv, ciSignature* sig) {
1902   uint arg_cnt = sig-&gt;size();
1903 
1904   uint pos = TypeFunc::Parms;
1905   const Type **field_array;
1906   if (recv != NULL) {
1907     arg_cnt++;
1908     field_array = fields(arg_cnt);
1909     // Use get_const_type here because it respects UseUniqueSubclasses:
1910     field_array[pos++] = get_const_type(recv)-&gt;join_speculative(TypePtr::NOTNULL);
1911   } else {
1912     field_array = fields(arg_cnt);
1913   }
1914 
1915   int i = 0;
1916   while (pos &lt; TypeFunc::Parms + arg_cnt) {
1917     ciType* type = sig-&gt;type_at(i);
1918 
1919     switch (type-&gt;basic_type()) {
1920     case T_LONG:
1921       field_array[pos++] = TypeLong::LONG;
1922       field_array[pos++] = Type::HALF;
1923       break;
1924     case T_DOUBLE:
1925       field_array[pos++] = Type::DOUBLE;
1926       field_array[pos++] = Type::HALF;
1927       break;
1928     case T_OBJECT:
1929     case T_ARRAY:
1930     case T_FLOAT:
1931     case T_INT:
1932       field_array[pos++] = get_const_type(type);
1933       break;
1934     case T_BOOLEAN:
1935     case T_CHAR:
1936     case T_BYTE:
1937     case T_SHORT:
1938       field_array[pos++] = TypeInt::INT;
1939       break;
1940     default:
1941       ShouldNotReachHere();
1942     }
1943     i++;
1944   }
1945 
1946   return (TypeTuple*)(new TypeTuple(TypeFunc::Parms + arg_cnt, field_array))-&gt;hashcons();
1947 }
1948 
1949 const TypeTuple *TypeTuple::make( uint cnt, const Type **fields ) {
1950   return (TypeTuple*)(new TypeTuple(cnt,fields))-&gt;hashcons();
1951 }
1952 
1953 //------------------------------fields-----------------------------------------
1954 // Subroutine call type with space allocated for argument types
1955 // Memory for Control, I_O, Memory, FramePtr, and ReturnAdr is allocated implicitly
1956 const Type **TypeTuple::fields( uint arg_cnt ) {
1957   const Type **flds = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4((TypeFunc::Parms+arg_cnt)*sizeof(Type*) ));
1958   flds[TypeFunc::Control  ] = Type::CONTROL;
1959   flds[TypeFunc::I_O      ] = Type::ABIO;
1960   flds[TypeFunc::Memory   ] = Type::MEMORY;
1961   flds[TypeFunc::FramePtr ] = TypeRawPtr::BOTTOM;
1962   flds[TypeFunc::ReturnAdr] = Type::RETURN_ADDRESS;
1963 
1964   return flds;
1965 }
1966 
1967 //------------------------------meet-------------------------------------------
1968 // Compute the MEET of two types.  It returns a new Type object.
1969 const Type *TypeTuple::xmeet( const Type *t ) const {
1970   // Perform a fast test for common case; meeting the same types together.
1971   if( this == t ) return this;  // Meeting same type-rep?
1972 
1973   // Current &quot;this-&gt;_base&quot; is Tuple
1974   switch (t-&gt;base()) {          // switch on original type
1975 
1976   case Bottom:                  // Ye Olde Default
1977     return t;
1978 
1979   default:                      // All else is a mistake
1980     typerr(t);
1981 
1982   case Tuple: {                 // Meeting 2 signatures?
1983     const TypeTuple *x = t-&gt;is_tuple();
1984     assert( _cnt == x-&gt;_cnt, &quot;&quot; );
1985     const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
1986     for( uint i=0; i&lt;_cnt; i++ )
1987       fields[i] = field_at(i)-&gt;xmeet( x-&gt;field_at(i) );
1988     return TypeTuple::make(_cnt,fields);
1989   }
1990   case Top:
1991     break;
1992   }
1993   return this;                  // Return the double constant
1994 }
1995 
1996 //------------------------------xdual------------------------------------------
1997 // Dual: compute field-by-field dual
1998 const Type *TypeTuple::xdual() const {
1999   const Type **fields = (const Type **)(Compile::current()-&gt;type_arena()-&gt;Amalloc_4( _cnt*sizeof(Type*) ));
2000   for( uint i=0; i&lt;_cnt; i++ )
2001     fields[i] = _fields[i]-&gt;dual();
2002   return new TypeTuple(_cnt,fields);
2003 }
2004 
2005 //------------------------------eq---------------------------------------------
2006 // Structural equality check for Type representations
2007 bool TypeTuple::eq( const Type *t ) const {
2008   const TypeTuple *s = (const TypeTuple *)t;
2009   if (_cnt != s-&gt;_cnt)  return false;  // Unequal field counts
2010   for (uint i = 0; i &lt; _cnt; i++)
2011     if (field_at(i) != s-&gt;field_at(i)) // POINTER COMPARE!  NO RECURSION!
2012       return false;             // Missed
2013   return true;
2014 }
2015 
2016 //------------------------------hash-------------------------------------------
2017 // Type-specific hashing function.
2018 int TypeTuple::hash(void) const {
2019   intptr_t sum = _cnt;
2020   for( uint i=0; i&lt;_cnt; i++ )
2021     sum += (intptr_t)_fields[i];     // Hash on pointers directly
2022   return sum;
2023 }
2024 
2025 //------------------------------dump2------------------------------------------
2026 // Dump signature Type
2027 #ifndef PRODUCT
2028 void TypeTuple::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2029   st-&gt;print(&quot;{&quot;);
2030   if( !depth || d[this] ) {     // Check for recursive print
2031     st-&gt;print(&quot;...}&quot;);
2032     return;
2033   }
2034   d.Insert((void*)this, (void*)this);   // Stop recursion
2035   if( _cnt ) {
2036     uint i;
2037     for( i=0; i&lt;_cnt-1; i++ ) {
2038       st-&gt;print(&quot;%d:&quot;, i);
2039       _fields[i]-&gt;dump2(d, depth-1, st);
2040       st-&gt;print(&quot;, &quot;);
2041     }
2042     st-&gt;print(&quot;%d:&quot;, i);
2043     _fields[i]-&gt;dump2(d, depth-1, st);
2044   }
2045   st-&gt;print(&quot;}&quot;);
2046 }
2047 #endif
2048 
2049 //------------------------------singleton--------------------------------------
2050 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2051 // constants (Ldi nodes).  Singletons are integer, float or double constants
2052 // or a single symbol.
2053 bool TypeTuple::singleton(void) const {
2054   return false;                 // Never a singleton
2055 }
2056 
2057 bool TypeTuple::empty(void) const {
2058   for( uint i=0; i&lt;_cnt; i++ ) {
2059     if (_fields[i]-&gt;empty())  return true;
2060   }
2061   return false;
2062 }
2063 
2064 //=============================================================================
2065 // Convenience common pre-built types.
2066 
2067 inline const TypeInt* normalize_array_size(const TypeInt* size) {
2068   // Certain normalizations keep us sane when comparing types.
2069   // We do not want arrayOop variables to differ only by the wideness
2070   // of their index types.  Pick minimum wideness, since that is the
2071   // forced wideness of small ranges anyway.
2072   if (size-&gt;_widen != Type::WidenMin)
2073     return TypeInt::make(size-&gt;_lo, size-&gt;_hi, Type::WidenMin);
2074   else
2075     return size;
2076 }
2077 
2078 //------------------------------make-------------------------------------------
2079 const TypeAry* TypeAry::make(const Type* elem, const TypeInt* size, bool stable) {
2080   if (UseCompressedOops &amp;&amp; elem-&gt;isa_oopptr()) {
2081     elem = elem-&gt;make_narrowoop();
2082   }
2083   size = normalize_array_size(size);
2084   return (TypeAry*)(new TypeAry(elem,size,stable))-&gt;hashcons();
2085 }
2086 
2087 //------------------------------meet-------------------------------------------
2088 // Compute the MEET of two types.  It returns a new Type object.
2089 const Type *TypeAry::xmeet( const Type *t ) const {
2090   // Perform a fast test for common case; meeting the same types together.
2091   if( this == t ) return this;  // Meeting same type-rep?
2092 
2093   // Current &quot;this-&gt;_base&quot; is Ary
2094   switch (t-&gt;base()) {          // switch on original type
2095 
2096   case Bottom:                  // Ye Olde Default
2097     return t;
2098 
2099   default:                      // All else is a mistake
2100     typerr(t);
2101 
2102   case Array: {                 // Meeting 2 arrays?
2103     const TypeAry *a = t-&gt;is_ary();
2104     return TypeAry::make(_elem-&gt;meet_speculative(a-&gt;_elem),
2105                          _size-&gt;xmeet(a-&gt;_size)-&gt;is_int(),
2106                          _stable &amp;&amp; a-&gt;_stable);
2107   }
2108   case Top:
2109     break;
2110   }
2111   return this;                  // Return the double constant
2112 }
2113 
2114 //------------------------------xdual------------------------------------------
2115 // Dual: compute field-by-field dual
2116 const Type *TypeAry::xdual() const {
2117   const TypeInt* size_dual = _size-&gt;dual()-&gt;is_int();
2118   size_dual = normalize_array_size(size_dual);
2119   return new TypeAry(_elem-&gt;dual(), size_dual, !_stable);
2120 }
2121 
2122 //------------------------------eq---------------------------------------------
2123 // Structural equality check for Type representations
2124 bool TypeAry::eq( const Type *t ) const {
2125   const TypeAry *a = (const TypeAry*)t;
2126   return _elem == a-&gt;_elem &amp;&amp;
2127     _stable == a-&gt;_stable &amp;&amp;
2128     _size == a-&gt;_size;
2129 }
2130 
2131 //------------------------------hash-------------------------------------------
2132 // Type-specific hashing function.
2133 int TypeAry::hash(void) const {
2134   return (intptr_t)_elem + (intptr_t)_size + (_stable ? 43 : 0);
2135 }
2136 
2137 /**
2138  * Return same type without a speculative part in the element
2139  */
2140 const Type* TypeAry::remove_speculative() const {
2141   return make(_elem-&gt;remove_speculative(), _size, _stable);
2142 }
2143 
2144 /**
2145  * Return same type with cleaned up speculative part of element
2146  */
2147 const Type* TypeAry::cleanup_speculative() const {
2148   return make(_elem-&gt;cleanup_speculative(), _size, _stable);
2149 }
2150 
2151 /**
2152  * Return same type but with a different inline depth (used for speculation)
2153  *
2154  * @param depth  depth to meet with
2155  */
2156 const TypePtr* TypePtr::with_inline_depth(int depth) const {
2157   if (!UseInlineDepthForSpeculativeTypes) {
2158     return this;
2159   }
2160   return make(AnyPtr, _ptr, _offset, _speculative, depth);
2161 }
2162 
2163 //----------------------interface_vs_oop---------------------------------------
2164 #ifdef ASSERT
2165 bool TypeAry::interface_vs_oop(const Type *t) const {
2166   const TypeAry* t_ary = t-&gt;is_ary();
2167   if (t_ary) {
2168     const TypePtr* this_ptr = _elem-&gt;make_ptr(); // In case we have narrow_oops
2169     const TypePtr*    t_ptr = t_ary-&gt;_elem-&gt;make_ptr();
2170     if(this_ptr != NULL &amp;&amp; t_ptr != NULL) {
2171       return this_ptr-&gt;interface_vs_oop(t_ptr);
2172     }
2173   }
2174   return false;
2175 }
2176 #endif
2177 
2178 //------------------------------dump2------------------------------------------
2179 #ifndef PRODUCT
2180 void TypeAry::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2181   if (_stable)  st-&gt;print(&quot;stable:&quot;);
2182   _elem-&gt;dump2(d, depth, st);
2183   st-&gt;print(&quot;[&quot;);
2184   _size-&gt;dump2(d, depth, st);
2185   st-&gt;print(&quot;]&quot;);
2186 }
2187 #endif
2188 
2189 //------------------------------singleton--------------------------------------
2190 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2191 // constants (Ldi nodes).  Singletons are integer, float or double constants
2192 // or a single symbol.
2193 bool TypeAry::singleton(void) const {
2194   return false;                 // Never a singleton
2195 }
2196 
2197 bool TypeAry::empty(void) const {
2198   return _elem-&gt;empty() || _size-&gt;empty();
2199 }
2200 
2201 //--------------------------ary_must_be_exact----------------------------------
2202 bool TypeAry::ary_must_be_exact() const {
2203   if (!UseExactTypes)       return false;
2204   // This logic looks at the element type of an array, and returns true
2205   // if the element type is either a primitive or a final instance class.
2206   // In such cases, an array built on this ary must have no subclasses.
2207   if (_elem == BOTTOM)      return false;  // general array not exact
2208   if (_elem == TOP   )      return false;  // inverted general array not exact
2209   const TypeOopPtr*  toop = NULL;
2210   if (UseCompressedOops &amp;&amp; _elem-&gt;isa_narrowoop()) {
2211     toop = _elem-&gt;make_ptr()-&gt;isa_oopptr();
2212   } else {
2213     toop = _elem-&gt;isa_oopptr();
2214   }
2215   if (!toop)                return true;   // a primitive type, like int
2216   ciKlass* tklass = toop-&gt;klass();
2217   if (tklass == NULL)       return false;  // unloaded class
2218   if (!tklass-&gt;is_loaded()) return false;  // unloaded class
2219   const TypeInstPtr* tinst;
2220   if (_elem-&gt;isa_narrowoop())
2221     tinst = _elem-&gt;make_ptr()-&gt;isa_instptr();
2222   else
2223     tinst = _elem-&gt;isa_instptr();
2224   if (tinst)
2225     return tklass-&gt;as_instance_klass()-&gt;is_final();
2226   const TypeAryPtr*  tap;
2227   if (_elem-&gt;isa_narrowoop())
2228     tap = _elem-&gt;make_ptr()-&gt;isa_aryptr();
2229   else
2230     tap = _elem-&gt;isa_aryptr();
2231   if (tap)
2232     return tap-&gt;ary()-&gt;ary_must_be_exact();
2233   return false;
2234 }
2235 
2236 //==============================TypeVect=======================================
2237 // Convenience common pre-built types.
2238 const TypeVect *TypeVect::VECTS = NULL; //  32-bit vectors
2239 const TypeVect *TypeVect::VECTD = NULL; //  64-bit vectors
2240 const TypeVect *TypeVect::VECTX = NULL; // 128-bit vectors
2241 const TypeVect *TypeVect::VECTY = NULL; // 256-bit vectors
2242 const TypeVect *TypeVect::VECTZ = NULL; // 512-bit vectors
2243 
2244 //------------------------------make-------------------------------------------
2245 const TypeVect* TypeVect::make(const Type *elem, uint length) {
2246   BasicType elem_bt = elem-&gt;array_element_basic_type();
2247   assert(is_java_primitive(elem_bt), &quot;only primitive types in vector&quot;);
2248   assert(length &gt; 1 &amp;&amp; is_power_of_2(length), &quot;vector length is power of 2&quot;);
2249   assert(Matcher::vector_size_supported(elem_bt, length), &quot;length in range&quot;);
2250   int size = length * type2aelembytes(elem_bt);
2251   switch (Matcher::vector_ideal_reg(size)) {
2252   case Op_VecS:
2253     return (TypeVect*)(new TypeVectS(elem, length))-&gt;hashcons();
2254   case Op_RegL:
2255   case Op_VecD:
2256   case Op_RegD:
2257     return (TypeVect*)(new TypeVectD(elem, length))-&gt;hashcons();
2258   case Op_VecX:
2259     return (TypeVect*)(new TypeVectX(elem, length))-&gt;hashcons();
2260   case Op_VecY:
2261     return (TypeVect*)(new TypeVectY(elem, length))-&gt;hashcons();
2262   case Op_VecZ:
2263     return (TypeVect*)(new TypeVectZ(elem, length))-&gt;hashcons();
2264   }
2265  ShouldNotReachHere();
2266   return NULL;
2267 }
2268 
2269 //------------------------------meet-------------------------------------------
2270 // Compute the MEET of two types.  It returns a new Type object.
2271 const Type *TypeVect::xmeet( const Type *t ) const {
2272   // Perform a fast test for common case; meeting the same types together.
2273   if( this == t ) return this;  // Meeting same type-rep?
2274 
2275   // Current &quot;this-&gt;_base&quot; is Vector
2276   switch (t-&gt;base()) {          // switch on original type
2277 
2278   case Bottom:                  // Ye Olde Default
2279     return t;
2280 
2281   default:                      // All else is a mistake
2282     typerr(t);
2283 
2284   case VectorS:
2285   case VectorD:
2286   case VectorX:
2287   case VectorY:
2288   case VectorZ: {                // Meeting 2 vectors?
2289     const TypeVect* v = t-&gt;is_vect();
2290     assert(  base() == v-&gt;base(), &quot;&quot;);
2291     assert(length() == v-&gt;length(), &quot;&quot;);
2292     assert(element_basic_type() == v-&gt;element_basic_type(), &quot;&quot;);
2293     return TypeVect::make(_elem-&gt;xmeet(v-&gt;_elem), _length);
2294   }
2295   case Top:
2296     break;
2297   }
2298   return this;
2299 }
2300 
2301 //------------------------------xdual------------------------------------------
2302 // Dual: compute field-by-field dual
2303 const Type *TypeVect::xdual() const {
2304   return new TypeVect(base(), _elem-&gt;dual(), _length);
2305 }
2306 
2307 //------------------------------eq---------------------------------------------
2308 // Structural equality check for Type representations
2309 bool TypeVect::eq(const Type *t) const {
2310   const TypeVect *v = t-&gt;is_vect();
2311   return (_elem == v-&gt;_elem) &amp;&amp; (_length == v-&gt;_length);
2312 }
2313 
2314 //------------------------------hash-------------------------------------------
2315 // Type-specific hashing function.
2316 int TypeVect::hash(void) const {
2317   return (intptr_t)_elem + (intptr_t)_length;
2318 }
2319 
2320 //------------------------------singleton--------------------------------------
2321 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2322 // constants (Ldi nodes).  Vector is singleton if all elements are the same
2323 // constant value (when vector is created with Replicate code).
2324 bool TypeVect::singleton(void) const {
2325 // There is no Con node for vectors yet.
2326 //  return _elem-&gt;singleton();
2327   return false;
2328 }
2329 
2330 bool TypeVect::empty(void) const {
2331   return _elem-&gt;empty();
2332 }
2333 
2334 //------------------------------dump2------------------------------------------
2335 #ifndef PRODUCT
2336 void TypeVect::dump2(Dict &amp;d, uint depth, outputStream *st) const {
2337   switch (base()) {
2338   case VectorS:
2339     st-&gt;print(&quot;vectors[&quot;); break;
2340   case VectorD:
2341     st-&gt;print(&quot;vectord[&quot;); break;
2342   case VectorX:
2343     st-&gt;print(&quot;vectorx[&quot;); break;
2344   case VectorY:
2345     st-&gt;print(&quot;vectory[&quot;); break;
2346   case VectorZ:
2347     st-&gt;print(&quot;vectorz[&quot;); break;
2348   default:
2349     ShouldNotReachHere();
2350   }
2351   st-&gt;print(&quot;%d]:{&quot;, _length);
2352   _elem-&gt;dump2(d, depth, st);
2353   st-&gt;print(&quot;}&quot;);
2354 }
2355 #endif
2356 
2357 
2358 //=============================================================================
2359 // Convenience common pre-built types.
2360 const TypePtr *TypePtr::NULL_PTR;
2361 const TypePtr *TypePtr::NOTNULL;
2362 const TypePtr *TypePtr::BOTTOM;
2363 
2364 //------------------------------meet-------------------------------------------
2365 // Meet over the PTR enum
2366 const TypePtr::PTR TypePtr::ptr_meet[TypePtr::lastPTR][TypePtr::lastPTR] = {
2367   //              TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,
2368   { /* Top     */ TopPTR,    AnyNull,   Constant, Null,   NotNull, BotPTR,},
2369   { /* AnyNull */ AnyNull,   AnyNull,   Constant, BotPTR, NotNull, BotPTR,},
2370   { /* Constant*/ Constant,  Constant,  Constant, BotPTR, NotNull, BotPTR,},
2371   { /* Null    */ Null,      BotPTR,    BotPTR,   Null,   BotPTR,  BotPTR,},
2372   { /* NotNull */ NotNull,   NotNull,   NotNull,  BotPTR, NotNull, BotPTR,},
2373   { /* BotPTR  */ BotPTR,    BotPTR,    BotPTR,   BotPTR, BotPTR,  BotPTR,}
2374 };
2375 
2376 //------------------------------make-------------------------------------------
2377 const TypePtr *TypePtr::make(TYPES t, enum PTR ptr, int offset, const TypePtr* speculative, int inline_depth) {
2378   return (TypePtr*)(new TypePtr(t,ptr,offset, speculative, inline_depth))-&gt;hashcons();
2379 }
2380 
2381 //------------------------------cast_to_ptr_type-------------------------------
2382 const Type *TypePtr::cast_to_ptr_type(PTR ptr) const {
2383   assert(_base == AnyPtr, &quot;subclass must override cast_to_ptr_type&quot;);
2384   if( ptr == _ptr ) return this;
2385   return make(_base, ptr, _offset, _speculative, _inline_depth);
2386 }
2387 
2388 //------------------------------get_con----------------------------------------
2389 intptr_t TypePtr::get_con() const {
2390   assert( _ptr == Null, &quot;&quot; );
2391   return _offset;
2392 }
2393 
2394 //------------------------------meet-------------------------------------------
2395 // Compute the MEET of two types.  It returns a new Type object.
2396 const Type *TypePtr::xmeet(const Type *t) const {
2397   const Type* res = xmeet_helper(t);
2398   if (res-&gt;isa_ptr() == NULL) {
2399     return res;
2400   }
2401 
2402   const TypePtr* res_ptr = res-&gt;is_ptr();
2403   if (res_ptr-&gt;speculative() != NULL) {
2404     // type-&gt;speculative() == NULL means that speculation is no better
2405     // than type, i.e. type-&gt;speculative() == type. So there are 2
2406     // ways to represent the fact that we have no useful speculative
2407     // data and we should use a single one to be able to test for
2408     // equality between types. Check whether type-&gt;speculative() ==
2409     // type and set speculative to NULL if it is the case.
2410     if (res_ptr-&gt;remove_speculative() == res_ptr-&gt;speculative()) {
2411       return res_ptr-&gt;remove_speculative();
2412     }
2413   }
2414 
2415   return res;
2416 }
2417 
2418 const Type *TypePtr::xmeet_helper(const Type *t) const {
2419   // Perform a fast test for common case; meeting the same types together.
2420   if( this == t ) return this;  // Meeting same type-rep?
2421 
2422   // Current &quot;this-&gt;_base&quot; is AnyPtr
2423   switch (t-&gt;base()) {          // switch on original type
2424   case Int:                     // Mixing ints &amp; oops happens when javac
2425   case Long:                    // reuses local variables
2426   case FloatTop:
2427   case FloatCon:
2428   case FloatBot:
2429   case DoubleTop:
2430   case DoubleCon:
2431   case DoubleBot:
2432   case NarrowOop:
2433   case NarrowKlass:
2434   case Bottom:                  // Ye Olde Default
2435     return Type::BOTTOM;
2436   case Top:
2437     return this;
2438 
2439   case AnyPtr: {                // Meeting to AnyPtrs
2440     const TypePtr *tp = t-&gt;is_ptr();
2441     const TypePtr* speculative = xmeet_speculative(tp);
2442     int depth = meet_inline_depth(tp-&gt;inline_depth());
2443     return make(AnyPtr, meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), speculative, depth);
2444   }
2445   case RawPtr:                  // For these, flip the call around to cut down
2446   case OopPtr:
2447   case InstPtr:                 // on the cases I have to handle.
2448   case AryPtr:
2449   case MetadataPtr:
2450   case KlassPtr:
2451     return t-&gt;xmeet(this);      // Call in reverse direction
2452   default:                      // All else is a mistake
2453     typerr(t);
2454 
2455   }
2456   return this;
2457 }
2458 
2459 //------------------------------meet_offset------------------------------------
2460 int TypePtr::meet_offset( int offset ) const {
2461   // Either is &#39;TOP&#39; offset?  Return the other offset!
2462   if( _offset == OffsetTop ) return offset;
2463   if( offset == OffsetTop ) return _offset;
2464   // If either is different, return &#39;BOTTOM&#39; offset
2465   if( _offset != offset ) return OffsetBot;
2466   return _offset;
2467 }
2468 
2469 //------------------------------dual_offset------------------------------------
2470 int TypePtr::dual_offset( ) const {
2471   if( _offset == OffsetTop ) return OffsetBot;// Map &#39;TOP&#39; into &#39;BOTTOM&#39;
2472   if( _offset == OffsetBot ) return OffsetTop;// Map &#39;BOTTOM&#39; into &#39;TOP&#39;
2473   return _offset;               // Map everything else into self
2474 }
2475 
2476 //------------------------------xdual------------------------------------------
2477 // Dual: compute field-by-field dual
2478 const TypePtr::PTR TypePtr::ptr_dual[TypePtr::lastPTR] = {
2479   BotPTR, NotNull, Constant, Null, AnyNull, TopPTR
2480 };
2481 const Type *TypePtr::xdual() const {
2482   return new TypePtr(AnyPtr, dual_ptr(), dual_offset(), dual_speculative(), dual_inline_depth());
2483 }
2484 
2485 //------------------------------xadd_offset------------------------------------
2486 int TypePtr::xadd_offset( intptr_t offset ) const {
2487   // Adding to &#39;TOP&#39; offset?  Return &#39;TOP&#39;!
2488   if( _offset == OffsetTop || offset == OffsetTop ) return OffsetTop;
2489   // Adding to &#39;BOTTOM&#39; offset?  Return &#39;BOTTOM&#39;!
2490   if( _offset == OffsetBot || offset == OffsetBot ) return OffsetBot;
2491   // Addition overflows or &quot;accidentally&quot; equals to OffsetTop? Return &#39;BOTTOM&#39;!
2492   offset += (intptr_t)_offset;
2493   if (offset != (int)offset || offset == OffsetTop) return OffsetBot;
2494 
2495   // assert( _offset &gt;= 0 &amp;&amp; _offset+offset &gt;= 0, &quot;&quot; );
2496   // It is possible to construct a negative offset during PhaseCCP
2497 
2498   return (int)offset;        // Sum valid offsets
2499 }
2500 
2501 //------------------------------add_offset-------------------------------------
2502 const TypePtr *TypePtr::add_offset( intptr_t offset ) const {
2503   return make(AnyPtr, _ptr, xadd_offset(offset), _speculative, _inline_depth);
2504 }
2505 
2506 //------------------------------eq---------------------------------------------
2507 // Structural equality check for Type representations
2508 bool TypePtr::eq( const Type *t ) const {
2509   const TypePtr *a = (const TypePtr*)t;
2510   return _ptr == a-&gt;ptr() &amp;&amp; _offset == a-&gt;offset() &amp;&amp; eq_speculative(a) &amp;&amp; _inline_depth == a-&gt;_inline_depth;
2511 }
2512 
2513 //------------------------------hash-------------------------------------------
2514 // Type-specific hashing function.
2515 int TypePtr::hash(void) const {
2516   return java_add(java_add((jint)_ptr, (jint)_offset), java_add((jint)hash_speculative(), (jint)_inline_depth));
2517 ;
2518 }
2519 
2520 /**
2521  * Return same type without a speculative part
2522  */
2523 const Type* TypePtr::remove_speculative() const {
2524   if (_speculative == NULL) {
2525     return this;
2526   }
2527   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
2528   return make(AnyPtr, _ptr, _offset, NULL, _inline_depth);
2529 }
2530 
2531 /**
2532  * Return same type but drop speculative part if we know we won&#39;t use
2533  * it
2534  */
2535 const Type* TypePtr::cleanup_speculative() const {
2536   if (speculative() == NULL) {
2537     return this;
2538   }
2539   const Type* no_spec = remove_speculative();
2540   // If this is NULL_PTR then we don&#39;t need the speculative type
2541   // (with_inline_depth in case the current type inline depth is
2542   // InlineDepthTop)
2543   if (no_spec == NULL_PTR-&gt;with_inline_depth(inline_depth())) {
2544     return no_spec;
2545   }
2546   if (above_centerline(speculative()-&gt;ptr())) {
2547     return no_spec;
2548   }
2549   const TypeOopPtr* spec_oopptr = speculative()-&gt;isa_oopptr();
2550   // If the speculative may be null and is an inexact klass then it
2551   // doesn&#39;t help
2552   if (speculative() != TypePtr::NULL_PTR &amp;&amp; speculative()-&gt;maybe_null() &amp;&amp;
2553       (spec_oopptr == NULL || !spec_oopptr-&gt;klass_is_exact())) {
2554     return no_spec;
2555   }
2556   return this;
2557 }
2558 
2559 /**
2560  * dual of the speculative part of the type
2561  */
2562 const TypePtr* TypePtr::dual_speculative() const {
2563   if (_speculative == NULL) {
2564     return NULL;
2565   }
2566   return _speculative-&gt;dual()-&gt;is_ptr();
2567 }
2568 
2569 /**
2570  * meet of the speculative parts of 2 types
2571  *
2572  * @param other  type to meet with
2573  */
2574 const TypePtr* TypePtr::xmeet_speculative(const TypePtr* other) const {
2575   bool this_has_spec = (_speculative != NULL);
2576   bool other_has_spec = (other-&gt;speculative() != NULL);
2577 
2578   if (!this_has_spec &amp;&amp; !other_has_spec) {
2579     return NULL;
2580   }
2581 
2582   // If we are at a point where control flow meets and one branch has
2583   // a speculative type and the other has not, we meet the speculative
2584   // type of one branch with the actual type of the other. If the
2585   // actual type is exact and the speculative is as well, then the
2586   // result is a speculative type which is exact and we can continue
2587   // speculation further.
2588   const TypePtr* this_spec = _speculative;
2589   const TypePtr* other_spec = other-&gt;speculative();
2590 
2591   if (!this_has_spec) {
2592     this_spec = this;
2593   }
2594 
2595   if (!other_has_spec) {
2596     other_spec = other;
2597   }
2598 
2599   return this_spec-&gt;meet(other_spec)-&gt;is_ptr();
2600 }
2601 
2602 /**
2603  * dual of the inline depth for this type (used for speculation)
2604  */
2605 int TypePtr::dual_inline_depth() const {
2606   return -inline_depth();
2607 }
2608 
2609 /**
2610  * meet of 2 inline depths (used for speculation)
2611  *
2612  * @param depth  depth to meet with
2613  */
2614 int TypePtr::meet_inline_depth(int depth) const {
2615   return MAX2(inline_depth(), depth);
2616 }
2617 
2618 /**
2619  * Are the speculative parts of 2 types equal?
2620  *
2621  * @param other  type to compare this one to
2622  */
2623 bool TypePtr::eq_speculative(const TypePtr* other) const {
2624   if (_speculative == NULL || other-&gt;speculative() == NULL) {
2625     return _speculative == other-&gt;speculative();
2626   }
2627 
2628   if (_speculative-&gt;base() != other-&gt;speculative()-&gt;base()) {
2629     return false;
2630   }
2631 
2632   return _speculative-&gt;eq(other-&gt;speculative());
2633 }
2634 
2635 /**
2636  * Hash of the speculative part of the type
2637  */
2638 int TypePtr::hash_speculative() const {
2639   if (_speculative == NULL) {
2640     return 0;
2641   }
2642 
2643   return _speculative-&gt;hash();
2644 }
2645 
2646 /**
2647  * add offset to the speculative part of the type
2648  *
2649  * @param offset  offset to add
2650  */
2651 const TypePtr* TypePtr::add_offset_speculative(intptr_t offset) const {
2652   if (_speculative == NULL) {
2653     return NULL;
2654   }
2655   return _speculative-&gt;add_offset(offset)-&gt;is_ptr();
2656 }
2657 
2658 /**
2659  * return exact klass from the speculative type if there&#39;s one
2660  */
2661 ciKlass* TypePtr::speculative_type() const {
2662   if (_speculative != NULL &amp;&amp; _speculative-&gt;isa_oopptr()) {
2663     const TypeOopPtr* speculative = _speculative-&gt;join(this)-&gt;is_oopptr();
2664     if (speculative-&gt;klass_is_exact()) {
2665       return speculative-&gt;klass();
2666     }
2667   }
2668   return NULL;
2669 }
2670 
2671 /**
2672  * return true if speculative type may be null
2673  */
2674 bool TypePtr::speculative_maybe_null() const {
2675   if (_speculative != NULL) {
2676     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2677     return speculative-&gt;maybe_null();
2678   }
2679   return true;
2680 }
2681 
2682 bool TypePtr::speculative_always_null() const {
2683   if (_speculative != NULL) {
2684     const TypePtr* speculative = _speculative-&gt;join(this)-&gt;is_ptr();
2685     return speculative == TypePtr::NULL_PTR;
2686   }
2687   return false;
2688 }
2689 
2690 /**
2691  * Same as TypePtr::speculative_type() but return the klass only if
2692  * the speculative tells us is not null
2693  */
2694 ciKlass* TypePtr::speculative_type_not_null() const {
2695   if (speculative_maybe_null()) {
2696     return NULL;
2697   }
2698   return speculative_type();
2699 }
2700 
2701 /**
2702  * Check whether new profiling would improve speculative type
2703  *
2704  * @param   exact_kls    class from profiling
2705  * @param   inline_depth inlining depth of profile point
2706  *
2707  * @return  true if type profile is valuable
2708  */
2709 bool TypePtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
2710   // no profiling?
2711   if (exact_kls == NULL) {
2712     return false;
2713   }
2714   if (speculative() == TypePtr::NULL_PTR) {
2715     return false;
2716   }
2717   // no speculative type or non exact speculative type?
2718   if (speculative_type() == NULL) {
2719     return true;
2720   }
2721   // If the node already has an exact speculative type keep it,
2722   // unless it was provided by profiling that is at a deeper
2723   // inlining level. Profiling at a higher inlining depth is
2724   // expected to be less accurate.
2725   if (_speculative-&gt;inline_depth() == InlineDepthBottom) {
2726     return false;
2727   }
2728   assert(_speculative-&gt;inline_depth() != InlineDepthTop, &quot;can&#39;t do the comparison&quot;);
2729   return inline_depth &lt; _speculative-&gt;inline_depth();
2730 }
2731 
2732 /**
2733  * Check whether new profiling would improve ptr (= tells us it is non
2734  * null)
2735  *
2736  * @param   ptr_kind always null or not null?
2737  *
2738  * @return  true if ptr profile is valuable
2739  */
2740 bool TypePtr::would_improve_ptr(ProfilePtrKind ptr_kind) const {
2741   // profiling doesn&#39;t tell us anything useful
2742   if (ptr_kind != ProfileAlwaysNull &amp;&amp; ptr_kind != ProfileNeverNull) {
2743     return false;
2744   }
2745   // We already know this is not null
2746   if (!this-&gt;maybe_null()) {
2747     return false;
2748   }
2749   // We already know the speculative type cannot be null
2750   if (!speculative_maybe_null()) {
2751     return false;
2752   }
2753   // We already know this is always null
2754   if (this == TypePtr::NULL_PTR) {
2755     return false;
2756   }
2757   // We already know the speculative type is always null
2758   if (speculative_always_null()) {
2759     return false;
2760   }
2761   if (ptr_kind == ProfileAlwaysNull &amp;&amp; speculative() != NULL &amp;&amp; speculative()-&gt;isa_oopptr()) {
2762     return false;
2763   }
2764   return true;
2765 }
2766 
2767 //------------------------------dump2------------------------------------------
2768 const char *const TypePtr::ptr_msg[TypePtr::lastPTR] = {
2769   &quot;TopPTR&quot;,&quot;AnyNull&quot;,&quot;Constant&quot;,&quot;NULL&quot;,&quot;NotNull&quot;,&quot;BotPTR&quot;
2770 };
2771 
2772 #ifndef PRODUCT
2773 void TypePtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2774   if( _ptr == Null ) st-&gt;print(&quot;NULL&quot;);
2775   else st-&gt;print(&quot;%s *&quot;, ptr_msg[_ptr]);
2776   if( _offset == OffsetTop ) st-&gt;print(&quot;+top&quot;);
2777   else if( _offset == OffsetBot ) st-&gt;print(&quot;+bot&quot;);
2778   else if( _offset ) st-&gt;print(&quot;+%d&quot;, _offset);
2779   dump_inline_depth(st);
2780   dump_speculative(st);
2781 }
2782 
2783 /**
2784  *dump the speculative part of the type
2785  */
2786 void TypePtr::dump_speculative(outputStream *st) const {
2787   if (_speculative != NULL) {
2788     st-&gt;print(&quot; (speculative=&quot;);
2789     _speculative-&gt;dump_on(st);
2790     st-&gt;print(&quot;)&quot;);
2791   }
2792 }
2793 
2794 /**
2795  *dump the inline depth of the type
2796  */
2797 void TypePtr::dump_inline_depth(outputStream *st) const {
2798   if (_inline_depth != InlineDepthBottom) {
2799     if (_inline_depth == InlineDepthTop) {
2800       st-&gt;print(&quot; (inline_depth=InlineDepthTop)&quot;);
2801     } else {
2802       st-&gt;print(&quot; (inline_depth=%d)&quot;, _inline_depth);
2803     }
2804   }
2805 }
2806 #endif
2807 
2808 //------------------------------singleton--------------------------------------
2809 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
2810 // constants
2811 bool TypePtr::singleton(void) const {
2812   // TopPTR, Null, AnyNull, Constant are all singletons
2813   return (_offset != OffsetBot) &amp;&amp; !below_centerline(_ptr);
2814 }
2815 
2816 bool TypePtr::empty(void) const {
2817   return (_offset == OffsetTop) || above_centerline(_ptr);
2818 }
2819 
2820 //=============================================================================
2821 // Convenience common pre-built types.
2822 const TypeRawPtr *TypeRawPtr::BOTTOM;
2823 const TypeRawPtr *TypeRawPtr::NOTNULL;
2824 
2825 //------------------------------make-------------------------------------------
2826 const TypeRawPtr *TypeRawPtr::make( enum PTR ptr ) {
2827   assert( ptr != Constant, &quot;what is the constant?&quot; );
2828   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2829   return (TypeRawPtr*)(new TypeRawPtr(ptr,0))-&gt;hashcons();
2830 }
2831 
2832 const TypeRawPtr *TypeRawPtr::make( address bits ) {
2833   assert( bits, &quot;Use TypePtr for NULL&quot; );
2834   return (TypeRawPtr*)(new TypeRawPtr(Constant,bits))-&gt;hashcons();
2835 }
2836 
2837 //------------------------------cast_to_ptr_type-------------------------------
2838 const Type *TypeRawPtr::cast_to_ptr_type(PTR ptr) const {
2839   assert( ptr != Constant, &quot;what is the constant?&quot; );
2840   assert( ptr != Null, &quot;Use TypePtr for NULL&quot; );
2841   assert( _bits==0, &quot;Why cast a constant address?&quot;);
2842   if( ptr == _ptr ) return this;
2843   return make(ptr);
2844 }
2845 
2846 //------------------------------get_con----------------------------------------
2847 intptr_t TypeRawPtr::get_con() const {
2848   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
2849   return (intptr_t)_bits;
2850 }
2851 
2852 //------------------------------meet-------------------------------------------
2853 // Compute the MEET of two types.  It returns a new Type object.
2854 const Type *TypeRawPtr::xmeet( const Type *t ) const {
2855   // Perform a fast test for common case; meeting the same types together.
2856   if( this == t ) return this;  // Meeting same type-rep?
2857 
2858   // Current &quot;this-&gt;_base&quot; is RawPtr
2859   switch( t-&gt;base() ) {         // switch on original type
2860   case Bottom:                  // Ye Olde Default
2861     return t;
2862   case Top:
2863     return this;
2864   case AnyPtr:                  // Meeting to AnyPtrs
2865     break;
2866   case RawPtr: {                // might be top, bot, any/not or constant
2867     enum PTR tptr = t-&gt;is_ptr()-&gt;ptr();
2868     enum PTR ptr = meet_ptr( tptr );
2869     if( ptr == Constant ) {     // Cannot be equal constants, so...
2870       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
2871       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
2872       ptr = NotNull;            // Fall down in lattice
2873     }
2874     return make( ptr );
2875   }
2876 
2877   case OopPtr:
2878   case InstPtr:
2879   case AryPtr:
2880   case MetadataPtr:
2881   case KlassPtr:
2882     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
2883   default:                      // All else is a mistake
2884     typerr(t);
2885   }
2886 
2887   // Found an AnyPtr type vs self-RawPtr type
2888   const TypePtr *tp = t-&gt;is_ptr();
2889   switch (tp-&gt;ptr()) {
2890   case TypePtr::TopPTR:  return this;
2891   case TypePtr::BotPTR:  return t;
2892   case TypePtr::Null:
2893     if( _ptr == TypePtr::TopPTR ) return t;
2894     return TypeRawPtr::BOTTOM;
2895   case TypePtr::NotNull: return TypePtr::make(AnyPtr, meet_ptr(TypePtr::NotNull), tp-&gt;meet_offset(0), tp-&gt;speculative(), tp-&gt;inline_depth());
2896   case TypePtr::AnyNull:
2897     if( _ptr == TypePtr::Constant) return this;
2898     return make( meet_ptr(TypePtr::AnyNull) );
2899   default: ShouldNotReachHere();
2900   }
2901   return this;
2902 }
2903 
2904 //------------------------------xdual------------------------------------------
2905 // Dual: compute field-by-field dual
2906 const Type *TypeRawPtr::xdual() const {
2907   return new TypeRawPtr( dual_ptr(), _bits );
2908 }
2909 
2910 //------------------------------add_offset-------------------------------------
2911 const TypePtr *TypeRawPtr::add_offset( intptr_t offset ) const {
2912   if( offset == OffsetTop ) return BOTTOM; // Undefined offset-&gt; undefined pointer
2913   if( offset == OffsetBot ) return BOTTOM; // Unknown offset-&gt; unknown pointer
2914   if( offset == 0 ) return this; // No change
2915   switch (_ptr) {
2916   case TypePtr::TopPTR:
2917   case TypePtr::BotPTR:
2918   case TypePtr::NotNull:
2919     return this;
2920   case TypePtr::Null:
2921   case TypePtr::Constant: {
2922     address bits = _bits+offset;
2923     if ( bits == 0 ) return TypePtr::NULL_PTR;
2924     return make( bits );
2925   }
2926   default:  ShouldNotReachHere();
2927   }
2928   return NULL;                  // Lint noise
2929 }
2930 
2931 //------------------------------eq---------------------------------------------
2932 // Structural equality check for Type representations
2933 bool TypeRawPtr::eq( const Type *t ) const {
2934   const TypeRawPtr *a = (const TypeRawPtr*)t;
2935   return _bits == a-&gt;_bits &amp;&amp; TypePtr::eq(t);
2936 }
2937 
2938 //------------------------------hash-------------------------------------------
2939 // Type-specific hashing function.
2940 int TypeRawPtr::hash(void) const {
2941   return (intptr_t)_bits + TypePtr::hash();
2942 }
2943 
2944 //------------------------------dump2------------------------------------------
2945 #ifndef PRODUCT
2946 void TypeRawPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
2947   if( _ptr == Constant )
2948     st-&gt;print(INTPTR_FORMAT, p2i(_bits));
2949   else
2950     st-&gt;print(&quot;rawptr:%s&quot;, ptr_msg[_ptr]);
2951 }
2952 #endif
2953 
2954 //=============================================================================
2955 // Convenience common pre-built type.
2956 const TypeOopPtr *TypeOopPtr::BOTTOM;
2957 
2958 //------------------------------TypeOopPtr-------------------------------------
2959 TypeOopPtr::TypeOopPtr(TYPES t, PTR ptr, ciKlass* k, bool xk, ciObject* o, int offset,
2960                        int instance_id, const TypePtr* speculative, int inline_depth)
2961   : TypePtr(t, ptr, offset, speculative, inline_depth),
2962     _const_oop(o), _klass(k),
2963     _klass_is_exact(xk),
2964     _is_ptr_to_narrowoop(false),
2965     _is_ptr_to_narrowklass(false),
2966     _is_ptr_to_boxed_value(false),
2967     _instance_id(instance_id) {
2968   if (Compile::current()-&gt;eliminate_boxing() &amp;&amp; (t == InstPtr) &amp;&amp;
2969       (offset &gt; 0) &amp;&amp; xk &amp;&amp; (k != 0) &amp;&amp; k-&gt;is_instance_klass()) {
2970     _is_ptr_to_boxed_value = k-&gt;as_instance_klass()-&gt;is_boxed_value_offset(offset);
2971   }
2972 #ifdef _LP64
2973   if (_offset &gt; 0 || _offset == Type::OffsetTop || _offset == Type::OffsetBot) {
2974     if (_offset == oopDesc::klass_offset_in_bytes()) {
2975       _is_ptr_to_narrowklass = UseCompressedClassPointers;
2976     } else if (klass() == NULL) {
2977       // Array with unknown body type
2978       assert(this-&gt;isa_aryptr(), &quot;only arrays without klass&quot;);
2979       _is_ptr_to_narrowoop = UseCompressedOops;
2980     } else if (this-&gt;isa_aryptr()) {
2981       _is_ptr_to_narrowoop = (UseCompressedOops &amp;&amp; klass()-&gt;is_obj_array_klass() &amp;&amp;
2982                              _offset != arrayOopDesc::length_offset_in_bytes());
2983     } else if (klass()-&gt;is_instance_klass()) {
2984       ciInstanceKlass* ik = klass()-&gt;as_instance_klass();
2985       ciField* field = NULL;
2986       if (this-&gt;isa_klassptr()) {
2987         // Perm objects don&#39;t use compressed references
2988       } else if (_offset == OffsetBot || _offset == OffsetTop) {
2989         // unsafe access
2990         _is_ptr_to_narrowoop = UseCompressedOops;
2991       } else { // exclude unsafe ops
2992         assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2993 
2994         if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
2995             (_offset == java_lang_Class::klass_offset_in_bytes() ||
2996              _offset == java_lang_Class::array_klass_offset_in_bytes())) {
2997           // Special hidden fields from the Class.
2998           assert(this-&gt;isa_instptr(), &quot;must be an instance ptr.&quot;);
2999           _is_ptr_to_narrowoop = false;
3000         } else if (klass() == ciEnv::current()-&gt;Class_klass() &amp;&amp;
3001                    _offset &gt;= InstanceMirrorKlass::offset_of_static_fields()) {
3002           // Static fields
3003           assert(o != NULL, &quot;must be constant&quot;);
3004           ciInstanceKlass* k = o-&gt;as_instance()-&gt;java_lang_Class_klass()-&gt;as_instance_klass();
3005           ciField* field = k-&gt;get_field_by_offset(_offset, true);
3006           assert(field != NULL, &quot;missing field&quot;);
3007           BasicType basic_elem_type = field-&gt;layout_type();
3008           _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3009         } else {
3010           // Instance fields which contains a compressed oop references.
3011           field = ik-&gt;get_field_by_offset(_offset, false);
3012           if (field != NULL) {
3013             BasicType basic_elem_type = field-&gt;layout_type();
3014             _is_ptr_to_narrowoop = UseCompressedOops &amp;&amp; is_reference_type(basic_elem_type);
3015           } else if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass())) {
3016             // Compile::find_alias_type() cast exactness on all types to verify
3017             // that it does not affect alias type.
3018             _is_ptr_to_narrowoop = UseCompressedOops;
3019           } else {
3020             // Type for the copy start in LibraryCallKit::inline_native_clone().
3021             _is_ptr_to_narrowoop = UseCompressedOops;
3022           }
3023         }
3024       }
3025     }
3026   }
3027 #endif
3028 }
3029 
3030 //------------------------------make-------------------------------------------
3031 const TypeOopPtr *TypeOopPtr::make(PTR ptr, int offset, int instance_id,
3032                                      const TypePtr* speculative, int inline_depth) {
3033   assert(ptr != Constant, &quot;no constant generic pointers&quot;);
3034   ciKlass*  k = Compile::current()-&gt;env()-&gt;Object_klass();
3035   bool      xk = false;
3036   ciObject* o = NULL;
3037   return (TypeOopPtr*)(new TypeOopPtr(OopPtr, ptr, k, xk, o, offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3038 }
3039 
3040 
3041 //------------------------------cast_to_ptr_type-------------------------------
3042 const Type *TypeOopPtr::cast_to_ptr_type(PTR ptr) const {
3043   assert(_base == OopPtr, &quot;subclass must override cast_to_ptr_type&quot;);
3044   if( ptr == _ptr ) return this;
3045   return make(ptr, _offset, _instance_id, _speculative, _inline_depth);
3046 }
3047 
3048 //-----------------------------cast_to_instance_id----------------------------
3049 const TypeOopPtr *TypeOopPtr::cast_to_instance_id(int instance_id) const {
3050   // There are no instances of a general oop.
3051   // Return self unchanged.
3052   return this;
3053 }
3054 
3055 //-----------------------------cast_to_exactness-------------------------------
3056 const Type *TypeOopPtr::cast_to_exactness(bool klass_is_exact) const {
3057   // There is no such thing as an exact general oop.
3058   // Return self unchanged.
3059   return this;
3060 }
3061 
3062 
3063 //------------------------------as_klass_type----------------------------------
3064 // Return the klass type corresponding to this instance or array type.
3065 // It is the type that is loaded from an object of this type.
3066 const TypeKlassPtr* TypeOopPtr::as_klass_type() const {
3067   ciKlass* k = klass();
3068   bool    xk = klass_is_exact();
3069   if (k == NULL)
3070     return TypeKlassPtr::OBJECT;
3071   else
3072     return TypeKlassPtr::make(xk? Constant: NotNull, k, 0);
3073 }
3074 
3075 //------------------------------meet-------------------------------------------
3076 // Compute the MEET of two types.  It returns a new Type object.
3077 const Type *TypeOopPtr::xmeet_helper(const Type *t) const {
3078   // Perform a fast test for common case; meeting the same types together.
3079   if( this == t ) return this;  // Meeting same type-rep?
3080 
3081   // Current &quot;this-&gt;_base&quot; is OopPtr
3082   switch (t-&gt;base()) {          // switch on original type
3083 
3084   case Int:                     // Mixing ints &amp; oops happens when javac
3085   case Long:                    // reuses local variables
3086   case FloatTop:
3087   case FloatCon:
3088   case FloatBot:
3089   case DoubleTop:
3090   case DoubleCon:
3091   case DoubleBot:
3092   case NarrowOop:
3093   case NarrowKlass:
3094   case Bottom:                  // Ye Olde Default
3095     return Type::BOTTOM;
3096   case Top:
3097     return this;
3098 
3099   default:                      // All else is a mistake
3100     typerr(t);
3101 
3102   case RawPtr:
3103   case MetadataPtr:
3104   case KlassPtr:
3105     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
3106 
3107   case AnyPtr: {
3108     // Found an AnyPtr type vs self-OopPtr type
3109     const TypePtr *tp = t-&gt;is_ptr();
3110     int offset = meet_offset(tp-&gt;offset());
3111     PTR ptr = meet_ptr(tp-&gt;ptr());
3112     const TypePtr* speculative = xmeet_speculative(tp);
3113     int depth = meet_inline_depth(tp-&gt;inline_depth());
3114     switch (tp-&gt;ptr()) {
3115     case Null:
3116       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3117       // else fall through:
3118     case TopPTR:
3119     case AnyNull: {
3120       int instance_id = meet_instance_id(InstanceTop);
3121       return make(ptr, offset, instance_id, speculative, depth);
3122     }
3123     case BotPTR:
3124     case NotNull:
3125       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3126     default: typerr(t);
3127     }
3128   }
3129 
3130   case OopPtr: {                 // Meeting to other OopPtrs
3131     const TypeOopPtr *tp = t-&gt;is_oopptr();
3132     int instance_id = meet_instance_id(tp-&gt;instance_id());
3133     const TypePtr* speculative = xmeet_speculative(tp);
3134     int depth = meet_inline_depth(tp-&gt;inline_depth());
3135     return make(meet_ptr(tp-&gt;ptr()), meet_offset(tp-&gt;offset()), instance_id, speculative, depth);
3136   }
3137 
3138   case InstPtr:                  // For these, flip the call around to cut down
3139   case AryPtr:
3140     return t-&gt;xmeet(this);      // Call in reverse direction
3141 
3142   } // End of switch
3143   return this;                  // Return the double constant
3144 }
3145 
3146 
3147 //------------------------------xdual------------------------------------------
3148 // Dual of a pure heap pointer.  No relevant klass or oop information.
3149 const Type *TypeOopPtr::xdual() const {
3150   assert(klass() == Compile::current()-&gt;env()-&gt;Object_klass(), &quot;no klasses here&quot;);
3151   assert(const_oop() == NULL,             &quot;no constants here&quot;);
3152   return new TypeOopPtr(_base, dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3153 }
3154 
3155 //--------------------------make_from_klass_common-----------------------------
3156 // Computes the element-type given a klass.
3157 const TypeOopPtr* TypeOopPtr::make_from_klass_common(ciKlass *klass, bool klass_change, bool try_for_exact) {
3158   if (klass-&gt;is_instance_klass()) {
3159     Compile* C = Compile::current();
3160     Dependencies* deps = C-&gt;dependencies();
3161     assert((deps != NULL) == (C-&gt;method() != NULL &amp;&amp; C-&gt;method()-&gt;code_size() &gt; 0), &quot;sanity&quot;);
3162     // Element is an instance
3163     bool klass_is_exact = false;
3164     if (klass-&gt;is_loaded()) {
3165       // Try to set klass_is_exact.
3166       ciInstanceKlass* ik = klass-&gt;as_instance_klass();
3167       klass_is_exact = ik-&gt;is_final();
3168       if (!klass_is_exact &amp;&amp; klass_change
3169           &amp;&amp; deps != NULL &amp;&amp; UseUniqueSubclasses) {
3170         ciInstanceKlass* sub = ik-&gt;unique_concrete_subklass();
3171         if (sub != NULL) {
3172           deps-&gt;assert_abstract_with_unique_concrete_subtype(ik, sub);
3173           klass = ik = sub;
3174           klass_is_exact = sub-&gt;is_final();
3175         }
3176       }
3177       if (!klass_is_exact &amp;&amp; try_for_exact
3178           &amp;&amp; deps != NULL &amp;&amp; UseExactTypes) {
3179         if (!ik-&gt;is_interface() &amp;&amp; !ik-&gt;has_subklass()) {
3180           // Add a dependence; if concrete subclass added we need to recompile
3181           deps-&gt;assert_leaf_type(ik);
3182           klass_is_exact = true;
3183         }
3184       }
3185     }
3186     return TypeInstPtr::make(TypePtr::BotPTR, klass, klass_is_exact, NULL, 0);
3187   } else if (klass-&gt;is_obj_array_klass()) {
3188     // Element is an object array. Recursively call ourself.
3189     const TypeOopPtr *etype = TypeOopPtr::make_from_klass_common(klass-&gt;as_obj_array_klass()-&gt;element_klass(), false, try_for_exact);
3190     bool xk = etype-&gt;klass_is_exact();
3191     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3192     // We used to pass NotNull in here, asserting that the sub-arrays
3193     // are all not-null.  This is not true in generally, as code can
3194     // slam NULLs down in the subarrays.
3195     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, xk, 0);
3196     return arr;
3197   } else if (klass-&gt;is_type_array_klass()) {
3198     // Element is an typeArray
3199     const Type* etype = get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3200     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::POS);
3201     // We used to pass NotNull in here, asserting that the array pointer
3202     // is not-null. That was not true in general.
3203     const TypeAryPtr* arr = TypeAryPtr::make(TypePtr::BotPTR, arr0, klass, true, 0);
3204     return arr;
3205   } else {
3206     ShouldNotReachHere();
3207     return NULL;
3208   }
3209 }
3210 
3211 //------------------------------make_from_constant-----------------------------
3212 // Make a java pointer from an oop constant
3213 const TypeOopPtr* TypeOopPtr::make_from_constant(ciObject* o, bool require_constant) {
3214   assert(!o-&gt;is_null_object(), &quot;null object not yet handled here.&quot;);
3215 
3216   const bool make_constant = require_constant || o-&gt;should_be_constant();
3217 
3218   ciKlass* klass = o-&gt;klass();
3219   if (klass-&gt;is_instance_klass()) {
3220     // Element is an instance
3221     if (make_constant) {
3222       return TypeInstPtr::make(o);
3223     } else {
3224       return TypeInstPtr::make(TypePtr::NotNull, klass, true, NULL, 0);
3225     }
3226   } else if (klass-&gt;is_obj_array_klass()) {
3227     // Element is an object array. Recursively call ourself.
3228     const TypeOopPtr *etype =
3229       TypeOopPtr::make_from_klass_raw(klass-&gt;as_obj_array_klass()-&gt;element_klass());
3230     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3231     // We used to pass NotNull in here, asserting that the sub-arrays
3232     // are all not-null.  This is not true in generally, as code can
3233     // slam NULLs down in the subarrays.
3234     if (make_constant) {
3235       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3236     } else {
3237       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3238     }
3239   } else if (klass-&gt;is_type_array_klass()) {
3240     // Element is an typeArray
3241     const Type* etype =
3242       (Type*)get_const_basic_type(klass-&gt;as_type_array_klass()-&gt;element_type());
3243     const TypeAry* arr0 = TypeAry::make(etype, TypeInt::make(o-&gt;as_array()-&gt;length()));
3244     // We used to pass NotNull in here, asserting that the array pointer
3245     // is not-null. That was not true in general.
3246     if (make_constant) {
3247       return TypeAryPtr::make(TypePtr::Constant, o, arr0, klass, true, 0);
3248     } else {
3249       return TypeAryPtr::make(TypePtr::NotNull, arr0, klass, true, 0);
3250     }
3251   }
3252 
3253   fatal(&quot;unhandled object type&quot;);
3254   return NULL;
3255 }
3256 
3257 //------------------------------get_con----------------------------------------
3258 intptr_t TypeOopPtr::get_con() const {
3259   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
3260   assert( _offset &gt;= 0, &quot;&quot; );
3261 
3262   if (_offset != 0) {
3263     // After being ported to the compiler interface, the compiler no longer
3264     // directly manipulates the addresses of oops.  Rather, it only has a pointer
3265     // to a handle at compile time.  This handle is embedded in the generated
3266     // code and dereferenced at the time the nmethod is made.  Until that time,
3267     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
3268     // have access to the addresses!).  This does not seem to currently happen,
3269     // but this assertion here is to help prevent its occurence.
3270     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
3271     ShouldNotReachHere();
3272   }
3273 
3274   return (intptr_t)const_oop()-&gt;constant_encoding();
3275 }
3276 
3277 
3278 //-----------------------------filter------------------------------------------
3279 // Do not allow interface-vs.-noninterface joins to collapse to top.
3280 const Type *TypeOopPtr::filter_helper(const Type *kills, bool include_speculative) const {
3281 
3282   const Type* ft = join_helper(kills, include_speculative);
3283   const TypeInstPtr* ftip = ft-&gt;isa_instptr();
3284   const TypeInstPtr* ktip = kills-&gt;isa_instptr();
3285 
3286   if (ft-&gt;empty()) {
3287     // Check for evil case of &#39;this&#39; being a class and &#39;kills&#39; expecting an
3288     // interface.  This can happen because the bytecodes do not contain
3289     // enough type info to distinguish a Java-level interface variable
3290     // from a Java-level object variable.  If we meet 2 classes which
3291     // both implement interface I, but their meet is at &#39;j/l/O&#39; which
3292     // doesn&#39;t implement I, we have no way to tell if the result should
3293     // be &#39;I&#39; or &#39;j/l/O&#39;.  Thus we&#39;ll pick &#39;j/l/O&#39;.  If this then flows
3294     // into a Phi which &quot;knows&quot; it&#39;s an Interface type we&#39;ll have to
3295     // uplift the type.
3296     if (!empty()) {
3297       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3298         return kills;           // Uplift to interface
3299       }
3300       // Also check for evil cases of &#39;this&#39; being a class array
3301       // and &#39;kills&#39; expecting an array of interfaces.
3302       Type::get_arrays_base_elements(ft, kills, NULL, &amp;ktip);
3303       if (ktip != NULL &amp;&amp; ktip-&gt;is_loaded() &amp;&amp; ktip-&gt;klass()-&gt;is_interface()) {
3304         return kills;           // Uplift to array of interface
3305       }
3306     }
3307 
3308     return Type::TOP;           // Canonical empty value
3309   }
3310 
3311   // If we have an interface-typed Phi or cast and we narrow to a class type,
3312   // the join should report back the class.  However, if we have a J/L/Object
3313   // class-typed Phi and an interface flows in, it&#39;s possible that the meet &amp;
3314   // join report an interface back out.  This isn&#39;t possible but happens
3315   // because the type system doesn&#39;t interact well with interfaces.
3316   if (ftip != NULL &amp;&amp; ktip != NULL &amp;&amp;
3317       ftip-&gt;is_loaded() &amp;&amp;  ftip-&gt;klass()-&gt;is_interface() &amp;&amp;
3318       ktip-&gt;is_loaded() &amp;&amp; !ktip-&gt;klass()-&gt;is_interface()) {
3319     assert(!ftip-&gt;klass_is_exact(), &quot;interface could not be exact&quot;);
3320     return ktip-&gt;cast_to_ptr_type(ftip-&gt;ptr());
3321   }
3322 
3323   return ft;
3324 }
3325 
3326 //------------------------------eq---------------------------------------------
3327 // Structural equality check for Type representations
3328 bool TypeOopPtr::eq( const Type *t ) const {
3329   const TypeOopPtr *a = (const TypeOopPtr*)t;
3330   if (_klass_is_exact != a-&gt;_klass_is_exact ||
3331       _instance_id != a-&gt;_instance_id)  return false;
3332   ciObject* one = const_oop();
3333   ciObject* two = a-&gt;const_oop();
3334   if (one == NULL || two == NULL) {
3335     return (one == two) &amp;&amp; TypePtr::eq(t);
3336   } else {
3337     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
3338   }
3339 }
3340 
3341 //------------------------------hash-------------------------------------------
3342 // Type-specific hashing function.
3343 int TypeOopPtr::hash(void) const {
3344   return
3345     java_add(java_add((jint)(const_oop() ? const_oop()-&gt;hash() : 0), (jint)_klass_is_exact),
3346              java_add((jint)_instance_id, (jint)TypePtr::hash()));
3347 }
3348 
3349 //------------------------------dump2------------------------------------------
3350 #ifndef PRODUCT
3351 void TypeOopPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3352   st-&gt;print(&quot;oopptr:%s&quot;, ptr_msg[_ptr]);
3353   if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3354   if( const_oop() ) st-&gt;print(INTPTR_FORMAT, p2i(const_oop()));
3355   switch( _offset ) {
3356   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
3357   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
3358   case         0: break;
3359   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
3360   }
3361   if (_instance_id == InstanceTop)
3362     st-&gt;print(&quot;,iid=top&quot;);
3363   else if (_instance_id != InstanceBot)
3364     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
3365 
3366   dump_inline_depth(st);
3367   dump_speculative(st);
3368 }
3369 #endif
3370 
3371 //------------------------------singleton--------------------------------------
3372 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
3373 // constants
3374 bool TypeOopPtr::singleton(void) const {
3375   // detune optimizer to not generate constant oop + constant offset as a constant!
3376   // TopPTR, Null, AnyNull, Constant are all singletons
3377   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
3378 }
3379 
3380 //------------------------------add_offset-------------------------------------
3381 const TypePtr *TypeOopPtr::add_offset(intptr_t offset) const {
3382   return make(_ptr, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
3383 }
3384 
3385 /**
3386  * Return same type without a speculative part
3387  */
3388 const Type* TypeOopPtr::remove_speculative() const {
3389   if (_speculative == NULL) {
3390     return this;
3391   }
3392   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
3393   return make(_ptr, _offset, _instance_id, NULL, _inline_depth);
3394 }
3395 
3396 /**
3397  * Return same type but drop speculative part if we know we won&#39;t use
3398  * it
3399  */
3400 const Type* TypeOopPtr::cleanup_speculative() const {
3401   // If the klass is exact and the ptr is not null then there&#39;s
3402   // nothing that the speculative type can help us with
3403   if (klass_is_exact() &amp;&amp; !maybe_null()) {
3404     return remove_speculative();
3405   }
3406   return TypePtr::cleanup_speculative();
3407 }
3408 
3409 /**
3410  * Return same type but with a different inline depth (used for speculation)
3411  *
3412  * @param depth  depth to meet with
3413  */
3414 const TypePtr* TypeOopPtr::with_inline_depth(int depth) const {
3415   if (!UseInlineDepthForSpeculativeTypes) {
3416     return this;
3417   }
3418   return make(_ptr, _offset, _instance_id, _speculative, depth);
3419 }
3420 
3421 //------------------------------with_instance_id--------------------------------
3422 const TypePtr* TypeOopPtr::with_instance_id(int instance_id) const {
3423   assert(_instance_id != -1, &quot;should be known&quot;);
3424   return make(_ptr, _offset, instance_id, _speculative, _inline_depth);
3425 }
3426 
3427 //------------------------------meet_instance_id--------------------------------
3428 int TypeOopPtr::meet_instance_id( int instance_id ) const {
3429   // Either is &#39;TOP&#39; instance?  Return the other instance!
3430   if( _instance_id == InstanceTop ) return  instance_id;
3431   if(  instance_id == InstanceTop ) return _instance_id;
3432   // If either is different, return &#39;BOTTOM&#39; instance
3433   if( _instance_id != instance_id ) return InstanceBot;
3434   return _instance_id;
3435 }
3436 
3437 //------------------------------dual_instance_id--------------------------------
3438 int TypeOopPtr::dual_instance_id( ) const {
3439   if( _instance_id == InstanceTop ) return InstanceBot; // Map TOP into BOTTOM
3440   if( _instance_id == InstanceBot ) return InstanceTop; // Map BOTTOM into TOP
3441   return _instance_id;              // Map everything else into self
3442 }
3443 
3444 /**
3445  * Check whether new profiling would improve speculative type
3446  *
3447  * @param   exact_kls    class from profiling
3448  * @param   inline_depth inlining depth of profile point
3449  *
3450  * @return  true if type profile is valuable
3451  */
3452 bool TypeOopPtr::would_improve_type(ciKlass* exact_kls, int inline_depth) const {
3453   // no way to improve an already exact type
3454   if (klass_is_exact()) {
3455     return false;
3456   }
3457   return TypePtr::would_improve_type(exact_kls, inline_depth);
3458 }
3459 
3460 //=============================================================================
3461 // Convenience common pre-built types.
3462 const TypeInstPtr *TypeInstPtr::NOTNULL;
3463 const TypeInstPtr *TypeInstPtr::BOTTOM;
3464 const TypeInstPtr *TypeInstPtr::MIRROR;
3465 const TypeInstPtr *TypeInstPtr::MARK;
3466 const TypeInstPtr *TypeInstPtr::KLASS;
3467 
3468 //------------------------------TypeInstPtr-------------------------------------
3469 TypeInstPtr::TypeInstPtr(PTR ptr, ciKlass* k, bool xk, ciObject* o, int off,
3470                          int instance_id, const TypePtr* speculative, int inline_depth)
3471   : TypeOopPtr(InstPtr, ptr, k, xk, o, off, instance_id, speculative, inline_depth),
3472     _name(k-&gt;name()) {
3473    assert(k != NULL &amp;&amp;
3474           (k-&gt;is_loaded() || o == NULL),
3475           &quot;cannot have constants with non-loaded klass&quot;);
3476 };
3477 
3478 //------------------------------make-------------------------------------------
3479 const TypeInstPtr *TypeInstPtr::make(PTR ptr,
3480                                      ciKlass* k,
3481                                      bool xk,
3482                                      ciObject* o,
3483                                      int offset,
3484                                      int instance_id,
3485                                      const TypePtr* speculative,
3486                                      int inline_depth) {
3487   assert( !k-&gt;is_loaded() || k-&gt;is_instance_klass(), &quot;Must be for instance&quot;);
3488   // Either const_oop() is NULL or else ptr is Constant
3489   assert( (!o &amp;&amp; ptr != Constant) || (o &amp;&amp; ptr == Constant),
3490           &quot;constant pointers must have a value supplied&quot; );
3491   // Ptr is never Null
3492   assert( ptr != Null, &quot;NULL pointers are not typed&quot; );
3493 
3494   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
3495   if (!UseExactTypes)  xk = false;
3496   if (ptr == Constant) {
3497     // Note:  This case includes meta-object constants, such as methods.
3498     xk = true;
3499   } else if (k-&gt;is_loaded()) {
3500     ciInstanceKlass* ik = k-&gt;as_instance_klass();
3501     if (!xk &amp;&amp; ik-&gt;is_final())     xk = true;   // no inexact final klass
3502     if (xk &amp;&amp; ik-&gt;is_interface())  xk = false;  // no exact interface
3503   }
3504 
3505   // Now hash this baby
3506   TypeInstPtr *result =
3507     (TypeInstPtr*)(new TypeInstPtr(ptr, k, xk, o ,offset, instance_id, speculative, inline_depth))-&gt;hashcons();
3508 
3509   return result;
3510 }
3511 
3512 /**
3513  *  Create constant type for a constant boxed value
3514  */
3515 const Type* TypeInstPtr::get_const_boxed_value() const {
3516   assert(is_ptr_to_boxed_value(), &quot;should be called only for boxed value&quot;);
3517   assert((const_oop() != NULL), &quot;should be called only for constant object&quot;);
3518   ciConstant constant = const_oop()-&gt;as_instance()-&gt;field_value_by_offset(offset());
3519   BasicType bt = constant.basic_type();
3520   switch (bt) {
3521     case T_BOOLEAN:  return TypeInt::make(constant.as_boolean());
3522     case T_INT:      return TypeInt::make(constant.as_int());
3523     case T_CHAR:     return TypeInt::make(constant.as_char());
3524     case T_BYTE:     return TypeInt::make(constant.as_byte());
3525     case T_SHORT:    return TypeInt::make(constant.as_short());
3526     case T_FLOAT:    return TypeF::make(constant.as_float());
3527     case T_DOUBLE:   return TypeD::make(constant.as_double());
3528     case T_LONG:     return TypeLong::make(constant.as_long());
3529     default:         break;
3530   }
3531   fatal(&quot;Invalid boxed value type &#39;%s&#39;&quot;, type2name(bt));
3532   return NULL;
3533 }
3534 
3535 //------------------------------cast_to_ptr_type-------------------------------
3536 const Type *TypeInstPtr::cast_to_ptr_type(PTR ptr) const {
3537   if( ptr == _ptr ) return this;
3538   // Reconstruct _sig info here since not a problem with later lazy
3539   // construction, _sig will show up on demand.
3540   return make(ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3541 }
3542 
3543 
3544 //-----------------------------cast_to_exactness-------------------------------
3545 const Type *TypeInstPtr::cast_to_exactness(bool klass_is_exact) const {
3546   if( klass_is_exact == _klass_is_exact ) return this;
3547   if (!UseExactTypes)  return this;
3548   if (!_klass-&gt;is_loaded())  return this;
3549   ciInstanceKlass* ik = _klass-&gt;as_instance_klass();
3550   if( (ik-&gt;is_final() || _const_oop) )  return this;  // cannot clear xk
3551   if( ik-&gt;is_interface() )              return this;  // cannot set xk
3552   return make(ptr(), klass(), klass_is_exact, const_oop(), _offset, _instance_id, _speculative, _inline_depth);
3553 }
3554 
3555 //-----------------------------cast_to_instance_id----------------------------
3556 const TypeOopPtr *TypeInstPtr::cast_to_instance_id(int instance_id) const {
3557   if( instance_id == _instance_id ) return this;
3558   return make(_ptr, klass(), _klass_is_exact, const_oop(), _offset, instance_id, _speculative, _inline_depth);
3559 }
3560 
3561 //------------------------------xmeet_unloaded---------------------------------
3562 // Compute the MEET of two InstPtrs when at least one is unloaded.
3563 // Assume classes are different since called after check for same name/class-loader
3564 const TypeInstPtr *TypeInstPtr::xmeet_unloaded(const TypeInstPtr *tinst) const {
3565     int off = meet_offset(tinst-&gt;offset());
3566     PTR ptr = meet_ptr(tinst-&gt;ptr());
3567     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3568     const TypePtr* speculative = xmeet_speculative(tinst);
3569     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3570 
3571     const TypeInstPtr *loaded    = is_loaded() ? this  : tinst;
3572     const TypeInstPtr *unloaded  = is_loaded() ? tinst : this;
3573     if( loaded-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) ) {
3574       //
3575       // Meet unloaded class with java/lang/Object
3576       //
3577       // Meet
3578       //          |                     Unloaded Class
3579       //  Object  |   TOP    |   AnyNull | Constant |   NotNull |  BOTTOM   |
3580       //  ===================================================================
3581       //   TOP    | ..........................Unloaded......................|
3582       //  AnyNull |  U-AN    |................Unloaded......................|
3583       // Constant | ... O-NN .................................. |   O-BOT   |
3584       //  NotNull | ... O-NN .................................. |   O-BOT   |
3585       //  BOTTOM  | ........................Object-BOTTOM ..................|
3586       //
3587       assert(loaded-&gt;ptr() != TypePtr::Null, &quot;insanity check&quot;);
3588       //
3589       if(      loaded-&gt;ptr() == TypePtr::TopPTR ) { return unloaded; }
3590       else if (loaded-&gt;ptr() == TypePtr::AnyNull) { return TypeInstPtr::make(ptr, unloaded-&gt;klass(), false, NULL, off, instance_id, speculative, depth); }
3591       else if (loaded-&gt;ptr() == TypePtr::BotPTR ) { return TypeInstPtr::BOTTOM; }
3592       else if (loaded-&gt;ptr() == TypePtr::Constant || loaded-&gt;ptr() == TypePtr::NotNull) {
3593         if (unloaded-&gt;ptr() == TypePtr::BotPTR  ) { return TypeInstPtr::BOTTOM;  }
3594         else                                      { return TypeInstPtr::NOTNULL; }
3595       }
3596       else if( unloaded-&gt;ptr() == TypePtr::TopPTR )  { return unloaded; }
3597 
3598       return unloaded-&gt;cast_to_ptr_type(TypePtr::AnyNull)-&gt;is_instptr();
3599     }
3600 
3601     // Both are unloaded, not the same class, not Object
3602     // Or meet unloaded with a different loaded class, not java/lang/Object
3603     if( ptr != TypePtr::BotPTR ) {
3604       return TypeInstPtr::NOTNULL;
3605     }
3606     return TypeInstPtr::BOTTOM;
3607 }
3608 
3609 
3610 //------------------------------meet-------------------------------------------
3611 // Compute the MEET of two types.  It returns a new Type object.
3612 const Type *TypeInstPtr::xmeet_helper(const Type *t) const {
3613   // Perform a fast test for common case; meeting the same types together.
3614   if( this == t ) return this;  // Meeting same type-rep?
3615 
3616   // Current &quot;this-&gt;_base&quot; is Pointer
3617   switch (t-&gt;base()) {          // switch on original type
3618 
3619   case Int:                     // Mixing ints &amp; oops happens when javac
3620   case Long:                    // reuses local variables
3621   case FloatTop:
3622   case FloatCon:
3623   case FloatBot:
3624   case DoubleTop:
3625   case DoubleCon:
3626   case DoubleBot:
3627   case NarrowOop:
3628   case NarrowKlass:
3629   case Bottom:                  // Ye Olde Default
3630     return Type::BOTTOM;
3631   case Top:
3632     return this;
3633 
3634   default:                      // All else is a mistake
3635     typerr(t);
3636 
3637   case MetadataPtr:
3638   case KlassPtr:
3639   case RawPtr: return TypePtr::BOTTOM;
3640 
3641   case AryPtr: {                // All arrays inherit from Object class
3642     const TypeAryPtr *tp = t-&gt;is_aryptr();
3643     int offset = meet_offset(tp-&gt;offset());
3644     PTR ptr = meet_ptr(tp-&gt;ptr());
3645     int instance_id = meet_instance_id(tp-&gt;instance_id());
3646     const TypePtr* speculative = xmeet_speculative(tp);
3647     int depth = meet_inline_depth(tp-&gt;inline_depth());
3648     switch (ptr) {
3649     case TopPTR:
3650     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
3651       // For instances when a subclass meets a superclass we fall
3652       // below the centerline when the superclass is exact. We need to
3653       // do the same here.
3654       if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3655         return TypeAryPtr::make(ptr, tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3656       } else {
3657         // cannot subclass, so the meet has to fall badly below the centerline
3658         ptr = NotNull;
3659         instance_id = InstanceBot;
3660         return TypeInstPtr::make( ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3661       }
3662     case Constant:
3663     case NotNull:
3664     case BotPTR:                // Fall down to object klass
3665       // LCA is object_klass, but if we subclass from the top we can do better
3666       if( above_centerline(_ptr) ) { // if( _ptr == TopPTR || _ptr == AnyNull )
3667         // If &#39;this&#39; (InstPtr) is above the centerline and it is Object class
3668         // then we can subclass in the Java class hierarchy.
3669         // For instances when a subclass meets a superclass we fall
3670         // below the centerline when the superclass is exact. We need
3671         // to do the same here.
3672         if (klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !klass_is_exact()) {
3673           // that is, tp&#39;s array type is a subtype of my klass
3674           return TypeAryPtr::make(ptr, (ptr == Constant ? tp-&gt;const_oop() : NULL),
3675                                   tp-&gt;ary(), tp-&gt;klass(), tp-&gt;klass_is_exact(), offset, instance_id, speculative, depth);
3676         }
3677       }
3678       // The other case cannot happen, since I cannot be a subtype of an array.
3679       // The meet falls down to Object class below centerline.
3680       if( ptr == Constant )
3681          ptr = NotNull;
3682       instance_id = InstanceBot;
3683       return make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL, offset, instance_id, speculative, depth);
3684     default: typerr(t);
3685     }
3686   }
3687 
3688   case OopPtr: {                // Meeting to OopPtrs
3689     // Found a OopPtr type vs self-InstPtr type
3690     const TypeOopPtr *tp = t-&gt;is_oopptr();
3691     int offset = meet_offset(tp-&gt;offset());
3692     PTR ptr = meet_ptr(tp-&gt;ptr());
3693     switch (tp-&gt;ptr()) {
3694     case TopPTR:
3695     case AnyNull: {
3696       int instance_id = meet_instance_id(InstanceTop);
3697       const TypePtr* speculative = xmeet_speculative(tp);
3698       int depth = meet_inline_depth(tp-&gt;inline_depth());
3699       return make(ptr, klass(), klass_is_exact(),
3700                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3701     }
3702     case NotNull:
3703     case BotPTR: {
3704       int instance_id = meet_instance_id(tp-&gt;instance_id());
3705       const TypePtr* speculative = xmeet_speculative(tp);
3706       int depth = meet_inline_depth(tp-&gt;inline_depth());
3707       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
3708     }
3709     default: typerr(t);
3710     }
3711   }
3712 
3713   case AnyPtr: {                // Meeting to AnyPtrs
3714     // Found an AnyPtr type vs self-InstPtr type
3715     const TypePtr *tp = t-&gt;is_ptr();
3716     int offset = meet_offset(tp-&gt;offset());
3717     PTR ptr = meet_ptr(tp-&gt;ptr());
3718     int instance_id = meet_instance_id(InstanceTop);
3719     const TypePtr* speculative = xmeet_speculative(tp);
3720     int depth = meet_inline_depth(tp-&gt;inline_depth());
3721     switch (tp-&gt;ptr()) {
3722     case Null:
3723       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
3724       // else fall through to AnyNull
3725     case TopPTR:
3726     case AnyNull: {
3727       return make(ptr, klass(), klass_is_exact(),
3728                   (ptr == Constant ? const_oop() : NULL), offset, instance_id, speculative, depth);
3729     }
3730     case NotNull:
3731     case BotPTR:
3732       return TypePtr::make(AnyPtr, ptr, offset, speculative,depth);
3733     default: typerr(t);
3734     }
3735   }
3736 
3737   /*
3738                  A-top         }
3739                /   |   \       }  Tops
3740            B-top A-any C-top   }
3741               | /  |  \ |      }  Any-nulls
3742            B-any   |   C-any   }
3743               |    |    |
3744            B-con A-con C-con   } constants; not comparable across classes
3745               |    |    |
3746            B-not   |   C-not   }
3747               | \  |  / |      }  not-nulls
3748            B-bot A-not C-bot   }
3749                \   |   /       }  Bottoms
3750                  A-bot         }
3751   */
3752 
3753   case InstPtr: {                // Meeting 2 Oops?
3754     // Found an InstPtr sub-type vs self-InstPtr type
3755     const TypeInstPtr *tinst = t-&gt;is_instptr();
3756     int off = meet_offset( tinst-&gt;offset() );
3757     PTR ptr = meet_ptr( tinst-&gt;ptr() );
3758     int instance_id = meet_instance_id(tinst-&gt;instance_id());
3759     const TypePtr* speculative = xmeet_speculative(tinst);
3760     int depth = meet_inline_depth(tinst-&gt;inline_depth());
3761 
3762     // Check for easy case; klasses are equal (and perhaps not loaded!)
3763     // If we have constants, then we created oops so classes are loaded
3764     // and we can handle the constants further down.  This case handles
3765     // both-not-loaded or both-loaded classes
3766     if (ptr != Constant &amp;&amp; klass()-&gt;equals(tinst-&gt;klass()) &amp;&amp; klass_is_exact() == tinst-&gt;klass_is_exact()) {
3767       return make(ptr, klass(), klass_is_exact(), NULL, off, instance_id, speculative, depth);
3768     }
3769 
3770     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
3771     ciKlass* tinst_klass = tinst-&gt;klass();
3772     ciKlass* this_klass  = this-&gt;klass();
3773     bool tinst_xk = tinst-&gt;klass_is_exact();
3774     bool this_xk  = this-&gt;klass_is_exact();
3775     if (!tinst_klass-&gt;is_loaded() || !this_klass-&gt;is_loaded() ) {
3776       // One of these classes has not been loaded
3777       const TypeInstPtr *unloaded_meet = xmeet_unloaded(tinst);
3778 #ifndef PRODUCT
3779       if( PrintOpto &amp;&amp; Verbose ) {
3780         tty-&gt;print(&quot;meet of unloaded classes resulted in: &quot;); unloaded_meet-&gt;dump(); tty-&gt;cr();
3781         tty-&gt;print(&quot;  this == &quot;); this-&gt;dump(); tty-&gt;cr();
3782         tty-&gt;print(&quot; tinst == &quot;); tinst-&gt;dump(); tty-&gt;cr();
3783       }
3784 #endif
3785       return unloaded_meet;
3786     }
3787 
3788     // Handle mixing oops and interfaces first.
3789     if( this_klass-&gt;is_interface() &amp;&amp; !(tinst_klass-&gt;is_interface() ||
3790                                         tinst_klass == ciEnv::current()-&gt;Object_klass())) {
3791       ciKlass *tmp = tinst_klass; // Swap interface around
3792       tinst_klass = this_klass;
3793       this_klass = tmp;
3794       bool tmp2 = tinst_xk;
3795       tinst_xk = this_xk;
3796       this_xk = tmp2;
3797     }
3798     if (tinst_klass-&gt;is_interface() &amp;&amp;
3799         !(this_klass-&gt;is_interface() ||
3800           // Treat java/lang/Object as an honorary interface,
3801           // because we need a bottom for the interface hierarchy.
3802           this_klass == ciEnv::current()-&gt;Object_klass())) {
3803       // Oop meets interface!
3804 
3805       // See if the oop subtypes (implements) interface.
3806       ciKlass *k;
3807       bool xk;
3808       if( this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3809         // Oop indeed subtypes.  Now keep oop or interface depending
3810         // on whether we are both above the centerline or either is
3811         // below the centerline.  If we are on the centerline
3812         // (e.g., Constant vs. AnyNull interface), use the constant.
3813         k  = below_centerline(ptr) ? tinst_klass : this_klass;
3814         // If we are keeping this_klass, keep its exactness too.
3815         xk = below_centerline(ptr) ? tinst_xk    : this_xk;
3816       } else {                  // Does not implement, fall to Object
3817         // Oop does not implement interface, so mixing falls to Object
3818         // just like the verifier does (if both are above the
3819         // centerline fall to interface)
3820         k = above_centerline(ptr) ? tinst_klass : ciEnv::current()-&gt;Object_klass();
3821         xk = above_centerline(ptr) ? tinst_xk : false;
3822         // Watch out for Constant vs. AnyNull interface.
3823         if (ptr == Constant)  ptr = NotNull;   // forget it was a constant
3824         instance_id = InstanceBot;
3825       }
3826       ciObject* o = NULL;  // the Constant value, if any
3827       if (ptr == Constant) {
3828         // Find out which constant.
3829         o = (this_klass == klass()) ? const_oop() : tinst-&gt;const_oop();
3830       }
3831       return make(ptr, k, xk, o, off, instance_id, speculative, depth);
3832     }
3833 
3834     // Either oop vs oop or interface vs interface or interface vs Object
3835 
3836     // !!! Here&#39;s how the symmetry requirement breaks down into invariants:
3837     // If we split one up &amp; one down AND they subtype, take the down man.
3838     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3839     // If both are up and they subtype, take the subtype class.
3840     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3841     // If both are down and they subtype, take the supertype class.
3842     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3843     // Constants treated as down.
3844 
3845     // Now, reorder the above list; observe that both-down+subtype is also
3846     // &quot;fall hard&quot;; &quot;fall hard&quot; becomes the default case:
3847     // If we split one up &amp; one down AND they subtype, take the down man.
3848     // If both are up and they subtype, take the subtype class.
3849 
3850     // If both are down and they subtype, &quot;fall hard&quot;.
3851     // If both are down and they do NOT subtype, &quot;fall hard&quot;.
3852     // If both are up and they do NOT subtype, &quot;fall hard&quot;.
3853     // If we split one up &amp; one down AND they do NOT subtype, &quot;fall hard&quot;.
3854 
3855     // If a proper subtype is exact, and we return it, we return it exactly.
3856     // If a proper supertype is exact, there can be no subtyping relationship!
3857     // If both types are equal to the subtype, exactness is and-ed below the
3858     // centerline and or-ed above it.  (N.B. Constants are always exact.)
3859 
3860     // Check for subtyping:
3861     ciKlass *subtype = NULL;
3862     bool subtype_exact = false;
3863     if( tinst_klass-&gt;equals(this_klass) ) {
3864       subtype = this_klass;
3865       subtype_exact = below_centerline(ptr) ? (this_xk &amp;&amp; tinst_xk) : (this_xk || tinst_xk);
3866     } else if( !tinst_xk &amp;&amp; this_klass-&gt;is_subtype_of( tinst_klass ) ) {
3867       subtype = this_klass;     // Pick subtyping class
3868       subtype_exact = this_xk;
3869     } else if( !this_xk &amp;&amp; tinst_klass-&gt;is_subtype_of( this_klass ) ) {
3870       subtype = tinst_klass;    // Pick subtyping class
3871       subtype_exact = tinst_xk;
3872     }
3873 
3874     if( subtype ) {
3875       if( above_centerline(ptr) ) { // both are up?
3876         this_klass = tinst_klass = subtype;
3877         this_xk = tinst_xk = subtype_exact;
3878       } else if( above_centerline(this -&gt;_ptr) &amp;&amp; !above_centerline(tinst-&gt;_ptr) ) {
3879         this_klass = tinst_klass; // tinst is down; keep down man
3880         this_xk = tinst_xk;
3881       } else if( above_centerline(tinst-&gt;_ptr) &amp;&amp; !above_centerline(this -&gt;_ptr) ) {
3882         tinst_klass = this_klass; // this is down; keep down man
3883         tinst_xk = this_xk;
3884       } else {
3885         this_xk = subtype_exact;  // either they are equal, or we&#39;ll do an LCA
3886       }
3887     }
3888 
3889     // Check for classes now being equal
3890     if (tinst_klass-&gt;equals(this_klass)) {
3891       // If the klasses are equal, the constants may still differ.  Fall to
3892       // NotNull if they do (neither constant is NULL; that is a special case
3893       // handled elsewhere).
3894       ciObject* o = NULL;             // Assume not constant when done
3895       ciObject* this_oop  = const_oop();
3896       ciObject* tinst_oop = tinst-&gt;const_oop();
3897       if( ptr == Constant ) {
3898         if (this_oop != NULL &amp;&amp; tinst_oop != NULL &amp;&amp;
3899             this_oop-&gt;equals(tinst_oop) )
3900           o = this_oop;
3901         else if (above_centerline(this -&gt;_ptr))
3902           o = tinst_oop;
3903         else if (above_centerline(tinst -&gt;_ptr))
3904           o = this_oop;
3905         else
3906           ptr = NotNull;
3907       }
3908       return make(ptr, this_klass, this_xk, o, off, instance_id, speculative, depth);
3909     } // Else classes are not equal
3910 
3911     // Since klasses are different, we require a LCA in the Java
3912     // class hierarchy - which means we have to fall to at least NotNull.
3913     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
3914       ptr = NotNull;
3915 
3916     instance_id = InstanceBot;
3917 
3918     // Now we find the LCA of Java classes
3919     ciKlass* k = this_klass-&gt;least_common_ancestor(tinst_klass);
3920     return make(ptr, k, false, NULL, off, instance_id, speculative, depth);
3921   } // End of case InstPtr
3922 
3923   } // End of switch
3924   return this;                  // Return the double constant
3925 }
3926 
3927 
3928 //------------------------java_mirror_type--------------------------------------
3929 ciType* TypeInstPtr::java_mirror_type() const {
3930   // must be a singleton type
3931   if( const_oop() == NULL )  return NULL;
3932 
3933   // must be of type java.lang.Class
3934   if( klass() != ciEnv::current()-&gt;Class_klass() )  return NULL;
3935 
3936   return const_oop()-&gt;as_instance()-&gt;java_mirror_type();
3937 }
3938 
3939 
3940 //------------------------------xdual------------------------------------------
3941 // Dual: do NOT dual on klasses.  This means I do NOT understand the Java
3942 // inheritance mechanism.
3943 const Type *TypeInstPtr::xdual() const {
3944   return new TypeInstPtr(dual_ptr(), klass(), klass_is_exact(), const_oop(), dual_offset(), dual_instance_id(), dual_speculative(), dual_inline_depth());
3945 }
3946 
3947 //------------------------------eq---------------------------------------------
3948 // Structural equality check for Type representations
3949 bool TypeInstPtr::eq( const Type *t ) const {
3950   const TypeInstPtr *p = t-&gt;is_instptr();
3951   return
3952     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
3953     TypeOopPtr::eq(p);          // Check sub-type stuff
3954 }
3955 
3956 //------------------------------hash-------------------------------------------
3957 // Type-specific hashing function.
3958 int TypeInstPtr::hash(void) const {
3959   int hash = java_add((jint)klass()-&gt;hash(), (jint)TypeOopPtr::hash());
3960   return hash;
3961 }
3962 
3963 //------------------------------dump2------------------------------------------
3964 // Dump oop Type
3965 #ifndef PRODUCT
3966 void TypeInstPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
3967   // Print the name of the klass.
3968   klass()-&gt;print_name_on(st);
3969 
3970   switch( _ptr ) {
3971   case Constant:
3972     // TO DO: Make CI print the hex address of the underlying oop.
3973     if (WizardMode || Verbose) {
3974       const_oop()-&gt;print_oop(st);
3975     }
3976   case BotPTR:
3977     if (!WizardMode &amp;&amp; !Verbose) {
3978       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3979       break;
3980     }
3981   case TopPTR:
3982   case AnyNull:
3983   case NotNull:
3984     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
3985     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
3986     break;
3987   default:
3988     break;
3989   }
3990 
3991   if( _offset ) {               // Dump offset, if any
3992     if( _offset == OffsetBot )      st-&gt;print(&quot;+any&quot;);
3993     else if( _offset == OffsetTop ) st-&gt;print(&quot;+unknown&quot;);
3994     else st-&gt;print(&quot;+%d&quot;, _offset);
3995   }
3996 
3997   st-&gt;print(&quot; *&quot;);
3998   if (_instance_id == InstanceTop)
3999     st-&gt;print(&quot;,iid=top&quot;);
4000   else if (_instance_id != InstanceBot)
4001     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4002 
4003   dump_inline_depth(st);
4004   dump_speculative(st);
4005 }
4006 #endif
4007 
4008 //------------------------------add_offset-------------------------------------
4009 const TypePtr *TypeInstPtr::add_offset(intptr_t offset) const {
4010   return make(_ptr, klass(), klass_is_exact(), const_oop(), xadd_offset(offset),
4011               _instance_id, add_offset_speculative(offset), _inline_depth);
4012 }
4013 
4014 const Type *TypeInstPtr::remove_speculative() const {
4015   if (_speculative == NULL) {
4016     return this;
4017   }
4018   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4019   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset,
4020               _instance_id, NULL, _inline_depth);
4021 }
4022 
4023 const TypePtr *TypeInstPtr::with_inline_depth(int depth) const {
4024   if (!UseInlineDepthForSpeculativeTypes) {
4025     return this;
4026   }
4027   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, _instance_id, _speculative, depth);
4028 }
4029 
4030 const TypePtr *TypeInstPtr::with_instance_id(int instance_id) const {
4031   assert(is_known_instance(), &quot;should be known&quot;);
4032   return make(_ptr, klass(), klass_is_exact(), const_oop(), _offset, instance_id, _speculative, _inline_depth);
4033 }
4034 
4035 //=============================================================================
4036 // Convenience common pre-built types.
4037 const TypeAryPtr *TypeAryPtr::RANGE;
4038 const TypeAryPtr *TypeAryPtr::OOPS;
4039 const TypeAryPtr *TypeAryPtr::NARROWOOPS;
4040 const TypeAryPtr *TypeAryPtr::BYTES;
4041 const TypeAryPtr *TypeAryPtr::SHORTS;
4042 const TypeAryPtr *TypeAryPtr::CHARS;
4043 const TypeAryPtr *TypeAryPtr::INTS;
4044 const TypeAryPtr *TypeAryPtr::LONGS;
4045 const TypeAryPtr *TypeAryPtr::FLOATS;
4046 const TypeAryPtr *TypeAryPtr::DOUBLES;
4047 
4048 //------------------------------make-------------------------------------------
4049 const TypeAryPtr *TypeAryPtr::make(PTR ptr, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4050                                    int instance_id, const TypePtr* speculative, int inline_depth) {
4051   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4052          &quot;integral arrays must be pre-equipped with a class&quot;);
4053   if (!xk)  xk = ary-&gt;ary_must_be_exact();
4054   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4055   if (!UseExactTypes)  xk = (ptr == Constant);
4056   return (TypeAryPtr*)(new TypeAryPtr(ptr, NULL, ary, k, xk, offset, instance_id, false, speculative, inline_depth))-&gt;hashcons();
4057 }
4058 
4059 //------------------------------make-------------------------------------------
4060 const TypeAryPtr *TypeAryPtr::make(PTR ptr, ciObject* o, const TypeAry *ary, ciKlass* k, bool xk, int offset,
4061                                    int instance_id, const TypePtr* speculative, int inline_depth,
4062                                    bool is_autobox_cache) {
4063   assert(!(k == NULL &amp;&amp; ary-&gt;_elem-&gt;isa_int()),
4064          &quot;integral arrays must be pre-equipped with a class&quot;);
4065   assert( (ptr==Constant &amp;&amp; o) || (ptr!=Constant &amp;&amp; !o), &quot;&quot; );
4066   if (!xk)  xk = (o != NULL) || ary-&gt;ary_must_be_exact();
4067   assert(instance_id &lt;= 0 || xk || !UseExactTypes, &quot;instances are always exactly typed&quot;);
4068   if (!UseExactTypes)  xk = (ptr == Constant);
4069   return (TypeAryPtr*)(new TypeAryPtr(ptr, o, ary, k, xk, offset, instance_id, is_autobox_cache, speculative, inline_depth))-&gt;hashcons();
4070 }
4071 
4072 //------------------------------cast_to_ptr_type-------------------------------
4073 const Type *TypeAryPtr::cast_to_ptr_type(PTR ptr) const {
4074   if( ptr == _ptr ) return this;
4075   return make(ptr, const_oop(), _ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4076 }
4077 
4078 
4079 //-----------------------------cast_to_exactness-------------------------------
4080 const Type *TypeAryPtr::cast_to_exactness(bool klass_is_exact) const {
4081   if( klass_is_exact == _klass_is_exact ) return this;
4082   if (!UseExactTypes)  return this;
4083   if (_ary-&gt;ary_must_be_exact())  return this;  // cannot clear xk
4084   return make(ptr(), const_oop(), _ary, klass(), klass_is_exact, _offset, _instance_id, _speculative, _inline_depth);
4085 }
4086 
4087 //-----------------------------cast_to_instance_id----------------------------
4088 const TypeOopPtr *TypeAryPtr::cast_to_instance_id(int instance_id) const {
4089   if( instance_id == _instance_id ) return this;
4090   return make(_ptr, const_oop(), _ary, klass(), _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4091 }
4092 
4093 
4094 //-----------------------------max_array_length-------------------------------
4095 // A wrapper around arrayOopDesc::max_array_length(etype) with some input normalization.
4096 jint TypeAryPtr::max_array_length(BasicType etype) {
4097   if (!is_java_primitive(etype) &amp;&amp; !is_reference_type(etype)) {
4098     if (etype == T_NARROWOOP) {
4099       etype = T_OBJECT;
4100     } else if (etype == T_ILLEGAL) { // bottom[]
4101       etype = T_BYTE; // will produce conservatively high value
4102     } else {
4103       fatal(&quot;not an element type: %s&quot;, type2name(etype));
4104     }
4105   }
4106   return arrayOopDesc::max_array_length(etype);
4107 }
4108 
4109 //-----------------------------narrow_size_type-------------------------------
4110 // Narrow the given size type to the index range for the given array base type.
4111 // Return NULL if the resulting int type becomes empty.
4112 const TypeInt* TypeAryPtr::narrow_size_type(const TypeInt* size) const {
4113   jint hi = size-&gt;_hi;
4114   jint lo = size-&gt;_lo;
4115   jint min_lo = 0;
4116   jint max_hi = max_array_length(elem()-&gt;basic_type());
4117   //if (index_not_size)  --max_hi;     // type of a valid array index, FTR
4118   bool chg = false;
4119   if (lo &lt; min_lo) {
4120     lo = min_lo;
4121     if (size-&gt;is_con()) {
4122       hi = lo;
4123     }
4124     chg = true;
4125   }
4126   if (hi &gt; max_hi) {
4127     hi = max_hi;
4128     if (size-&gt;is_con()) {
4129       lo = hi;
4130     }
4131     chg = true;
4132   }
4133   // Negative length arrays will produce weird intermediate dead fast-path code
4134   if (lo &gt; hi)
4135     return TypeInt::ZERO;
4136   if (!chg)
4137     return size;
4138   return TypeInt::make(lo, hi, Type::WidenMin);
4139 }
4140 
4141 //-------------------------------cast_to_size----------------------------------
4142 const TypeAryPtr* TypeAryPtr::cast_to_size(const TypeInt* new_size) const {
4143   assert(new_size != NULL, &quot;&quot;);
4144   new_size = narrow_size_type(new_size);
4145   if (new_size == size())  return this;
4146   const TypeAry* new_ary = TypeAry::make(elem(), new_size, is_stable());
4147   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4148 }
4149 
4150 //------------------------------cast_to_stable---------------------------------
4151 const TypeAryPtr* TypeAryPtr::cast_to_stable(bool stable, int stable_dimension) const {
4152   if (stable_dimension &lt;= 0 || (stable_dimension == 1 &amp;&amp; stable == this-&gt;is_stable()))
4153     return this;
4154 
4155   const Type* elem = this-&gt;elem();
4156   const TypePtr* elem_ptr = elem-&gt;make_ptr();
4157 
4158   if (stable_dimension &gt; 1 &amp;&amp; elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr()) {
4159     // If this is widened from a narrow oop, TypeAry::make will re-narrow it.
4160     elem = elem_ptr = elem_ptr-&gt;is_aryptr()-&gt;cast_to_stable(stable, stable_dimension - 1);
4161   }
4162 
4163   const TypeAry* new_ary = TypeAry::make(elem, size(), stable);
4164 
4165   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth);
4166 }
4167 
4168 //-----------------------------stable_dimension--------------------------------
4169 int TypeAryPtr::stable_dimension() const {
4170   if (!is_stable())  return 0;
4171   int dim = 1;
4172   const TypePtr* elem_ptr = elem()-&gt;make_ptr();
4173   if (elem_ptr != NULL &amp;&amp; elem_ptr-&gt;isa_aryptr())
4174     dim += elem_ptr-&gt;is_aryptr()-&gt;stable_dimension();
4175   return dim;
4176 }
4177 
4178 //----------------------cast_to_autobox_cache-----------------------------------
4179 const TypeAryPtr* TypeAryPtr::cast_to_autobox_cache(bool cache) const {
4180   if (is_autobox_cache() == cache)  return this;
4181   const TypeOopPtr* etype = elem()-&gt;make_oopptr();
4182   if (etype == NULL)  return this;
4183   // The pointers in the autobox arrays are always non-null.
4184   TypePtr::PTR ptr_type = cache ? TypePtr::NotNull : TypePtr::AnyNull;
4185   etype = etype-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
4186   const TypeAry* new_ary = TypeAry::make(etype, size(), is_stable());
4187   return make(ptr(), const_oop(), new_ary, klass(), klass_is_exact(), _offset, _instance_id, _speculative, _inline_depth, cache);
4188 }
4189 
4190 //------------------------------eq---------------------------------------------
4191 // Structural equality check for Type representations
4192 bool TypeAryPtr::eq( const Type *t ) const {
4193   const TypeAryPtr *p = t-&gt;is_aryptr();
4194   return
4195     _ary == p-&gt;_ary &amp;&amp;  // Check array
4196     TypeOopPtr::eq(p);  // Check sub-parts
4197 }
4198 
4199 //------------------------------hash-------------------------------------------
4200 // Type-specific hashing function.
4201 int TypeAryPtr::hash(void) const {
4202   return (intptr_t)_ary + TypeOopPtr::hash();
4203 }
4204 
4205 //------------------------------meet-------------------------------------------
4206 // Compute the MEET of two types.  It returns a new Type object.
4207 const Type *TypeAryPtr::xmeet_helper(const Type *t) const {
4208   // Perform a fast test for common case; meeting the same types together.
4209   if( this == t ) return this;  // Meeting same type-rep?
4210   // Current &quot;this-&gt;_base&quot; is Pointer
4211   switch (t-&gt;base()) {          // switch on original type
4212 
4213   // Mixing ints &amp; oops happens when javac reuses local variables
4214   case Int:
4215   case Long:
4216   case FloatTop:
4217   case FloatCon:
4218   case FloatBot:
4219   case DoubleTop:
4220   case DoubleCon:
4221   case DoubleBot:
4222   case NarrowOop:
4223   case NarrowKlass:
4224   case Bottom:                  // Ye Olde Default
4225     return Type::BOTTOM;
4226   case Top:
4227     return this;
4228 
4229   default:                      // All else is a mistake
4230     typerr(t);
4231 
4232   case OopPtr: {                // Meeting to OopPtrs
4233     // Found a OopPtr type vs self-AryPtr type
4234     const TypeOopPtr *tp = t-&gt;is_oopptr();
4235     int offset = meet_offset(tp-&gt;offset());
4236     PTR ptr = meet_ptr(tp-&gt;ptr());
4237     int depth = meet_inline_depth(tp-&gt;inline_depth());
4238     const TypePtr* speculative = xmeet_speculative(tp);
4239     switch (tp-&gt;ptr()) {
4240     case TopPTR:
4241     case AnyNull: {
4242       int instance_id = meet_instance_id(InstanceTop);
4243       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4244                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4245     }
4246     case BotPTR:
4247     case NotNull: {
4248       int instance_id = meet_instance_id(tp-&gt;instance_id());
4249       return TypeOopPtr::make(ptr, offset, instance_id, speculative, depth);
4250     }
4251     default: ShouldNotReachHere();
4252     }
4253   }
4254 
4255   case AnyPtr: {                // Meeting two AnyPtrs
4256     // Found an AnyPtr type vs self-AryPtr type
4257     const TypePtr *tp = t-&gt;is_ptr();
4258     int offset = meet_offset(tp-&gt;offset());
4259     PTR ptr = meet_ptr(tp-&gt;ptr());
4260     const TypePtr* speculative = xmeet_speculative(tp);
4261     int depth = meet_inline_depth(tp-&gt;inline_depth());
4262     switch (tp-&gt;ptr()) {
4263     case TopPTR:
4264       return this;
4265     case BotPTR:
4266     case NotNull:
4267       return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4268     case Null:
4269       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, speculative, depth);
4270       // else fall through to AnyNull
4271     case AnyNull: {
4272       int instance_id = meet_instance_id(InstanceTop);
4273       return make(ptr, (ptr == Constant ? const_oop() : NULL),
4274                   _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4275     }
4276     default: ShouldNotReachHere();
4277     }
4278   }
4279 
4280   case MetadataPtr:
4281   case KlassPtr:
4282   case RawPtr: return TypePtr::BOTTOM;
4283 
4284   case AryPtr: {                // Meeting 2 references?
4285     const TypeAryPtr *tap = t-&gt;is_aryptr();
4286     int off = meet_offset(tap-&gt;offset());
4287     const TypeAry *tary = _ary-&gt;meet_speculative(tap-&gt;_ary)-&gt;is_ary();
4288     PTR ptr = meet_ptr(tap-&gt;ptr());
4289     int instance_id = meet_instance_id(tap-&gt;instance_id());
4290     const TypePtr* speculative = xmeet_speculative(tap);
4291     int depth = meet_inline_depth(tap-&gt;inline_depth());
4292     ciKlass* lazy_klass = NULL;
4293     if (tary-&gt;_elem-&gt;isa_int()) {
4294       // Integral array element types have irrelevant lattice relations.
4295       // It is the klass that determines array layout, not the element type.
4296       if (_klass == NULL)
4297         lazy_klass = tap-&gt;_klass;
4298       else if (tap-&gt;_klass == NULL || tap-&gt;_klass == _klass) {
4299         lazy_klass = _klass;
4300       } else {
4301         // Something like byte[int+] meets char[int+].
4302         // This must fall to bottom, not (int[-128..65535])[int+].
4303         instance_id = InstanceBot;
4304         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4305       }
4306     } else // Non integral arrays.
4307       // Must fall to bottom if exact klasses in upper lattice
4308       // are not equal or super klass is exact.
4309       if ((above_centerline(ptr) || ptr == Constant) &amp;&amp; klass() != tap-&gt;klass() &amp;&amp;
4310           // meet with top[] and bottom[] are processed further down:
4311           tap-&gt;_klass != NULL  &amp;&amp; this-&gt;_klass != NULL   &amp;&amp;
4312           // both are exact and not equal:
4313           ((tap-&gt;_klass_is_exact &amp;&amp; this-&gt;_klass_is_exact) ||
4314            // &#39;tap&#39;  is exact and super or unrelated:
4315            (tap-&gt;_klass_is_exact &amp;&amp; !tap-&gt;klass()-&gt;is_subtype_of(klass())) ||
4316            // &#39;this&#39; is exact and super or unrelated:
4317            (this-&gt;_klass_is_exact &amp;&amp; !klass()-&gt;is_subtype_of(tap-&gt;klass())))) {
<a name="8" id="anc8"></a><span class="line-modified">4318       if (above_centerline(ptr)) {</span>
4319         tary = TypeAry::make(Type::BOTTOM, tary-&gt;_size, tary-&gt;_stable);
4320       }
4321       return make(NotNull, NULL, tary, lazy_klass, false, off, InstanceBot, speculative, depth);
4322     }
4323 
4324     bool xk = false;
4325     switch (tap-&gt;ptr()) {
4326     case AnyNull:
4327     case TopPTR:
4328       // Compute new klass on demand, do not use tap-&gt;_klass
4329       if (below_centerline(this-&gt;_ptr)) {
4330         xk = this-&gt;_klass_is_exact;
4331       } else {
4332         xk = (tap-&gt;_klass_is_exact || this-&gt;_klass_is_exact);
4333       }
4334       return make(ptr, const_oop(), tary, lazy_klass, xk, off, instance_id, speculative, depth);
4335     case Constant: {
4336       ciObject* o = const_oop();
4337       if( _ptr == Constant ) {
4338         if( tap-&gt;const_oop() != NULL &amp;&amp; !o-&gt;equals(tap-&gt;const_oop()) ) {
4339           xk = (klass() == tap-&gt;klass());
4340           ptr = NotNull;
4341           o = NULL;
4342           instance_id = InstanceBot;
4343         } else {
4344           xk = true;
4345         }
4346       } else if(above_centerline(_ptr)) {
4347         o = tap-&gt;const_oop();
4348         xk = true;
4349       } else {
4350         // Only precise for identical arrays
4351         xk = this-&gt;_klass_is_exact &amp;&amp; (klass() == tap-&gt;klass());
4352       }
4353       return TypeAryPtr::make(ptr, o, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4354     }
4355     case NotNull:
4356     case BotPTR:
4357       // Compute new klass on demand, do not use tap-&gt;_klass
4358       if (above_centerline(this-&gt;_ptr))
4359             xk = tap-&gt;_klass_is_exact;
4360       else  xk = (tap-&gt;_klass_is_exact &amp; this-&gt;_klass_is_exact) &amp;&amp;
4361               (klass() == tap-&gt;klass()); // Only precise for identical arrays
4362       return TypeAryPtr::make(ptr, NULL, tary, lazy_klass, xk, off, instance_id, speculative, depth);
4363     default: ShouldNotReachHere();
4364     }
4365   }
4366 
4367   // All arrays inherit from Object class
4368   case InstPtr: {
4369     const TypeInstPtr *tp = t-&gt;is_instptr();
4370     int offset = meet_offset(tp-&gt;offset());
4371     PTR ptr = meet_ptr(tp-&gt;ptr());
4372     int instance_id = meet_instance_id(tp-&gt;instance_id());
4373     const TypePtr* speculative = xmeet_speculative(tp);
4374     int depth = meet_inline_depth(tp-&gt;inline_depth());
4375     switch (ptr) {
4376     case TopPTR:
4377     case AnyNull:                // Fall &#39;down&#39; to dual of object klass
4378       // For instances when a subclass meets a superclass we fall
4379       // below the centerline when the superclass is exact. We need to
4380       // do the same here.
4381       if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4382         return TypeAryPtr::make(ptr, _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4383       } else {
4384         // cannot subclass, so the meet has to fall badly below the centerline
4385         ptr = NotNull;
4386         instance_id = InstanceBot;
4387         return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4388       }
4389     case Constant:
4390     case NotNull:
4391     case BotPTR:                // Fall down to object klass
4392       // LCA is object_klass, but if we subclass from the top we can do better
4393       if (above_centerline(tp-&gt;ptr())) {
4394         // If &#39;tp&#39;  is above the centerline and it is Object class
4395         // then we can subclass in the Java class hierarchy.
4396         // For instances when a subclass meets a superclass we fall
4397         // below the centerline when the superclass is exact. We need
4398         // to do the same here.
4399         if (tp-&gt;klass()-&gt;equals(ciEnv::current()-&gt;Object_klass()) &amp;&amp; !tp-&gt;klass_is_exact()) {
4400           // that is, my array type is a subtype of &#39;tp&#39; klass
4401           return make(ptr, (ptr == Constant ? const_oop() : NULL),
4402                       _ary, _klass, _klass_is_exact, offset, instance_id, speculative, depth);
4403         }
4404       }
4405       // The other case cannot happen, since t cannot be a subtype of an array.
4406       // The meet falls down to Object class below centerline.
4407       if( ptr == Constant )
4408          ptr = NotNull;
4409       instance_id = InstanceBot;
4410       return TypeInstPtr::make(ptr, ciEnv::current()-&gt;Object_klass(), false, NULL,offset, instance_id, speculative, depth);
4411     default: typerr(t);
4412     }
4413   }
4414   }
4415   return this;                  // Lint noise
4416 }
4417 
4418 //------------------------------xdual------------------------------------------
4419 // Dual: compute field-by-field dual
4420 const Type *TypeAryPtr::xdual() const {
4421   return new TypeAryPtr(dual_ptr(), _const_oop, _ary-&gt;dual()-&gt;is_ary(),_klass, _klass_is_exact, dual_offset(), dual_instance_id(), is_autobox_cache(), dual_speculative(), dual_inline_depth());
4422 }
4423 
4424 //----------------------interface_vs_oop---------------------------------------
4425 #ifdef ASSERT
4426 bool TypeAryPtr::interface_vs_oop(const Type *t) const {
4427   const TypeAryPtr* t_aryptr = t-&gt;isa_aryptr();
4428   if (t_aryptr) {
4429     return _ary-&gt;interface_vs_oop(t_aryptr-&gt;_ary);
4430   }
4431   return false;
4432 }
4433 #endif
4434 
4435 //------------------------------dump2------------------------------------------
4436 #ifndef PRODUCT
4437 void TypeAryPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4438   _ary-&gt;dump2(d,depth,st);
4439   switch( _ptr ) {
4440   case Constant:
4441     const_oop()-&gt;print(st);
4442     break;
4443   case BotPTR:
4444     if (!WizardMode &amp;&amp; !Verbose) {
4445       if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4446       break;
4447     }
4448   case TopPTR:
4449   case AnyNull:
4450   case NotNull:
4451     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
4452     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
4453     break;
4454   default:
4455     break;
4456   }
4457 
4458   if( _offset != 0 ) {
4459     int header_size = objArrayOopDesc::header_size() * wordSize;
4460     if( _offset == OffsetTop )       st-&gt;print(&quot;+undefined&quot;);
4461     else if( _offset == OffsetBot )  st-&gt;print(&quot;+any&quot;);
4462     else if( _offset &lt; header_size ) st-&gt;print(&quot;+%d&quot;, _offset);
4463     else {
4464       BasicType basic_elem_type = elem()-&gt;basic_type();
4465       int array_base = arrayOopDesc::base_offset_in_bytes(basic_elem_type);
4466       int elem_size = type2aelembytes(basic_elem_type);
4467       st-&gt;print(&quot;[%d]&quot;, (_offset - array_base)/elem_size);
4468     }
4469   }
4470   st-&gt;print(&quot; *&quot;);
4471   if (_instance_id == InstanceTop)
4472     st-&gt;print(&quot;,iid=top&quot;);
4473   else if (_instance_id != InstanceBot)
4474     st-&gt;print(&quot;,iid=%d&quot;,_instance_id);
4475 
4476   dump_inline_depth(st);
4477   dump_speculative(st);
4478 }
4479 #endif
4480 
4481 bool TypeAryPtr::empty(void) const {
4482   if (_ary-&gt;empty())       return true;
4483   return TypeOopPtr::empty();
4484 }
4485 
4486 //------------------------------add_offset-------------------------------------
4487 const TypePtr *TypeAryPtr::add_offset(intptr_t offset) const {
4488   return make(_ptr, _const_oop, _ary, _klass, _klass_is_exact, xadd_offset(offset), _instance_id, add_offset_speculative(offset), _inline_depth);
4489 }
4490 
4491 const Type *TypeAryPtr::remove_speculative() const {
4492   if (_speculative == NULL) {
4493     return this;
4494   }
4495   assert(_inline_depth == InlineDepthTop || _inline_depth == InlineDepthBottom, &quot;non speculative type shouldn&#39;t have inline depth&quot;);
4496   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, NULL, _inline_depth);
4497 }
4498 
4499 const TypePtr *TypeAryPtr::with_inline_depth(int depth) const {
4500   if (!UseInlineDepthForSpeculativeTypes) {
4501     return this;
4502   }
4503   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, _instance_id, _speculative, depth);
4504 }
4505 
4506 const TypePtr *TypeAryPtr::with_instance_id(int instance_id) const {
4507   assert(is_known_instance(), &quot;should be known&quot;);
4508   return make(_ptr, _const_oop, _ary-&gt;remove_speculative()-&gt;is_ary(), _klass, _klass_is_exact, _offset, instance_id, _speculative, _inline_depth);
4509 }
4510 
4511 //=============================================================================
4512 
4513 //------------------------------hash-------------------------------------------
4514 // Type-specific hashing function.
4515 int TypeNarrowPtr::hash(void) const {
4516   return _ptrtype-&gt;hash() + 7;
4517 }
4518 
4519 bool TypeNarrowPtr::singleton(void) const {    // TRUE if type is a singleton
4520   return _ptrtype-&gt;singleton();
4521 }
4522 
4523 bool TypeNarrowPtr::empty(void) const {
4524   return _ptrtype-&gt;empty();
4525 }
4526 
4527 intptr_t TypeNarrowPtr::get_con() const {
4528   return _ptrtype-&gt;get_con();
4529 }
4530 
4531 bool TypeNarrowPtr::eq( const Type *t ) const {
4532   const TypeNarrowPtr* tc = isa_same_narrowptr(t);
4533   if (tc != NULL) {
4534     if (_ptrtype-&gt;base() != tc-&gt;_ptrtype-&gt;base()) {
4535       return false;
4536     }
4537     return tc-&gt;_ptrtype-&gt;eq(_ptrtype);
4538   }
4539   return false;
4540 }
4541 
4542 const Type *TypeNarrowPtr::xdual() const {    // Compute dual right now.
4543   const TypePtr* odual = _ptrtype-&gt;dual()-&gt;is_ptr();
4544   return make_same_narrowptr(odual);
4545 }
4546 
4547 
4548 const Type *TypeNarrowPtr::filter_helper(const Type *kills, bool include_speculative) const {
4549   if (isa_same_narrowptr(kills)) {
4550     const Type* ft =_ptrtype-&gt;filter_helper(is_same_narrowptr(kills)-&gt;_ptrtype, include_speculative);
4551     if (ft-&gt;empty())
4552       return Type::TOP;           // Canonical empty value
4553     if (ft-&gt;isa_ptr()) {
4554       return make_hash_same_narrowptr(ft-&gt;isa_ptr());
4555     }
4556     return ft;
4557   } else if (kills-&gt;isa_ptr()) {
4558     const Type* ft = _ptrtype-&gt;join_helper(kills, include_speculative);
4559     if (ft-&gt;empty())
4560       return Type::TOP;           // Canonical empty value
4561     return ft;
4562   } else {
4563     return Type::TOP;
4564   }
4565 }
4566 
4567 //------------------------------xmeet------------------------------------------
4568 // Compute the MEET of two types.  It returns a new Type object.
4569 const Type *TypeNarrowPtr::xmeet( const Type *t ) const {
4570   // Perform a fast test for common case; meeting the same types together.
4571   if( this == t ) return this;  // Meeting same type-rep?
4572 
4573   if (t-&gt;base() == base()) {
4574     const Type* result = _ptrtype-&gt;xmeet(t-&gt;make_ptr());
4575     if (result-&gt;isa_ptr()) {
4576       return make_hash_same_narrowptr(result-&gt;is_ptr());
4577     }
4578     return result;
4579   }
4580 
4581   // Current &quot;this-&gt;_base&quot; is NarrowKlass or NarrowOop
4582   switch (t-&gt;base()) {          // switch on original type
4583 
4584   case Int:                     // Mixing ints &amp; oops happens when javac
4585   case Long:                    // reuses local variables
4586   case FloatTop:
4587   case FloatCon:
4588   case FloatBot:
4589   case DoubleTop:
4590   case DoubleCon:
4591   case DoubleBot:
4592   case AnyPtr:
4593   case RawPtr:
4594   case OopPtr:
4595   case InstPtr:
4596   case AryPtr:
4597   case MetadataPtr:
4598   case KlassPtr:
4599   case NarrowOop:
4600   case NarrowKlass:
4601 
4602   case Bottom:                  // Ye Olde Default
4603     return Type::BOTTOM;
4604   case Top:
4605     return this;
4606 
4607   default:                      // All else is a mistake
4608     typerr(t);
4609 
4610   } // End of switch
4611 
4612   return this;
4613 }
4614 
4615 #ifndef PRODUCT
4616 void TypeNarrowPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4617   _ptrtype-&gt;dump2(d, depth, st);
4618 }
4619 #endif
4620 
4621 const TypeNarrowOop *TypeNarrowOop::BOTTOM;
4622 const TypeNarrowOop *TypeNarrowOop::NULL_PTR;
4623 
4624 
4625 const TypeNarrowOop* TypeNarrowOop::make(const TypePtr* type) {
4626   return (const TypeNarrowOop*)(new TypeNarrowOop(type))-&gt;hashcons();
4627 }
4628 
4629 const Type* TypeNarrowOop::remove_speculative() const {
4630   return make(_ptrtype-&gt;remove_speculative()-&gt;is_ptr());
4631 }
4632 
4633 const Type* TypeNarrowOop::cleanup_speculative() const {
4634   return make(_ptrtype-&gt;cleanup_speculative()-&gt;is_ptr());
4635 }
4636 
4637 #ifndef PRODUCT
4638 void TypeNarrowOop::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4639   st-&gt;print(&quot;narrowoop: &quot;);
4640   TypeNarrowPtr::dump2(d, depth, st);
4641 }
4642 #endif
4643 
4644 const TypeNarrowKlass *TypeNarrowKlass::NULL_PTR;
4645 
4646 const TypeNarrowKlass* TypeNarrowKlass::make(const TypePtr* type) {
4647   return (const TypeNarrowKlass*)(new TypeNarrowKlass(type))-&gt;hashcons();
4648 }
4649 
4650 #ifndef PRODUCT
4651 void TypeNarrowKlass::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
4652   st-&gt;print(&quot;narrowklass: &quot;);
4653   TypeNarrowPtr::dump2(d, depth, st);
4654 }
4655 #endif
4656 
4657 
4658 //------------------------------eq---------------------------------------------
4659 // Structural equality check for Type representations
4660 bool TypeMetadataPtr::eq( const Type *t ) const {
4661   const TypeMetadataPtr *a = (const TypeMetadataPtr*)t;
4662   ciMetadata* one = metadata();
4663   ciMetadata* two = a-&gt;metadata();
4664   if (one == NULL || two == NULL) {
4665     return (one == two) &amp;&amp; TypePtr::eq(t);
4666   } else {
4667     return one-&gt;equals(two) &amp;&amp; TypePtr::eq(t);
4668   }
4669 }
4670 
4671 //------------------------------hash-------------------------------------------
4672 // Type-specific hashing function.
4673 int TypeMetadataPtr::hash(void) const {
4674   return
4675     (metadata() ? metadata()-&gt;hash() : 0) +
4676     TypePtr::hash();
4677 }
4678 
4679 //------------------------------singleton--------------------------------------
4680 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4681 // constants
4682 bool TypeMetadataPtr::singleton(void) const {
4683   // detune optimizer to not generate constant metadata + constant offset as a constant!
4684   // TopPTR, Null, AnyNull, Constant are all singletons
4685   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4686 }
4687 
4688 //------------------------------add_offset-------------------------------------
4689 const TypePtr *TypeMetadataPtr::add_offset( intptr_t offset ) const {
4690   return make( _ptr, _metadata, xadd_offset(offset));
4691 }
4692 
4693 //-----------------------------filter------------------------------------------
4694 // Do not allow interface-vs.-noninterface joins to collapse to top.
4695 const Type *TypeMetadataPtr::filter_helper(const Type *kills, bool include_speculative) const {
4696   const TypeMetadataPtr* ft = join_helper(kills, include_speculative)-&gt;isa_metadataptr();
4697   if (ft == NULL || ft-&gt;empty())
4698     return Type::TOP;           // Canonical empty value
4699   return ft;
4700 }
4701 
4702  //------------------------------get_con----------------------------------------
4703 intptr_t TypeMetadataPtr::get_con() const {
4704   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
4705   assert( _offset &gt;= 0, &quot;&quot; );
4706 
4707   if (_offset != 0) {
4708     // After being ported to the compiler interface, the compiler no longer
4709     // directly manipulates the addresses of oops.  Rather, it only has a pointer
4710     // to a handle at compile time.  This handle is embedded in the generated
4711     // code and dereferenced at the time the nmethod is made.  Until that time,
4712     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
4713     // have access to the addresses!).  This does not seem to currently happen,
4714     // but this assertion here is to help prevent its occurence.
4715     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
4716     ShouldNotReachHere();
4717   }
4718 
4719   return (intptr_t)metadata()-&gt;constant_encoding();
4720 }
4721 
4722 //------------------------------cast_to_ptr_type-------------------------------
4723 const Type *TypeMetadataPtr::cast_to_ptr_type(PTR ptr) const {
4724   if( ptr == _ptr ) return this;
4725   return make(ptr, metadata(), _offset);
4726 }
4727 
4728 //------------------------------meet-------------------------------------------
4729 // Compute the MEET of two types.  It returns a new Type object.
4730 const Type *TypeMetadataPtr::xmeet( const Type *t ) const {
4731   // Perform a fast test for common case; meeting the same types together.
4732   if( this == t ) return this;  // Meeting same type-rep?
4733 
4734   // Current &quot;this-&gt;_base&quot; is OopPtr
4735   switch (t-&gt;base()) {          // switch on original type
4736 
4737   case Int:                     // Mixing ints &amp; oops happens when javac
4738   case Long:                    // reuses local variables
4739   case FloatTop:
4740   case FloatCon:
4741   case FloatBot:
4742   case DoubleTop:
4743   case DoubleCon:
4744   case DoubleBot:
4745   case NarrowOop:
4746   case NarrowKlass:
4747   case Bottom:                  // Ye Olde Default
4748     return Type::BOTTOM;
4749   case Top:
4750     return this;
4751 
4752   default:                      // All else is a mistake
4753     typerr(t);
4754 
4755   case AnyPtr: {
4756     // Found an AnyPtr type vs self-OopPtr type
4757     const TypePtr *tp = t-&gt;is_ptr();
4758     int offset = meet_offset(tp-&gt;offset());
4759     PTR ptr = meet_ptr(tp-&gt;ptr());
4760     switch (tp-&gt;ptr()) {
4761     case Null:
4762       if (ptr == Null)  return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4763       // else fall through:
4764     case TopPTR:
4765     case AnyNull: {
4766       return make(ptr, _metadata, offset);
4767     }
4768     case BotPTR:
4769     case NotNull:
4770       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
4771     default: typerr(t);
4772     }
4773   }
4774 
4775   case RawPtr:
4776   case KlassPtr:
4777   case OopPtr:
4778   case InstPtr:
4779   case AryPtr:
4780     return TypePtr::BOTTOM;     // Oop meet raw is not well defined
4781 
4782   case MetadataPtr: {
4783     const TypeMetadataPtr *tp = t-&gt;is_metadataptr();
4784     int offset = meet_offset(tp-&gt;offset());
4785     PTR tptr = tp-&gt;ptr();
4786     PTR ptr = meet_ptr(tptr);
4787     ciMetadata* md = (tptr == TopPTR) ? metadata() : tp-&gt;metadata();
4788     if (tptr == TopPTR || _ptr == TopPTR ||
4789         metadata()-&gt;equals(tp-&gt;metadata())) {
4790       return make(ptr, md, offset);
4791     }
4792     // metadata is different
4793     if( ptr == Constant ) {  // Cannot be equal constants, so...
4794       if( tptr == Constant &amp;&amp; _ptr != Constant)  return t;
4795       if( _ptr == Constant &amp;&amp; tptr != Constant)  return this;
4796       ptr = NotNull;            // Fall down in lattice
4797     }
4798     return make(ptr, NULL, offset);
4799     break;
4800   }
4801   } // End of switch
4802   return this;                  // Return the double constant
4803 }
4804 
4805 
4806 //------------------------------xdual------------------------------------------
4807 // Dual of a pure metadata pointer.
4808 const Type *TypeMetadataPtr::xdual() const {
4809   return new TypeMetadataPtr(dual_ptr(), metadata(), dual_offset());
4810 }
4811 
4812 //------------------------------dump2------------------------------------------
4813 #ifndef PRODUCT
4814 void TypeMetadataPtr::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
4815   st-&gt;print(&quot;metadataptr:%s&quot;, ptr_msg[_ptr]);
4816   if( metadata() ) st-&gt;print(INTPTR_FORMAT, p2i(metadata()));
4817   switch( _offset ) {
4818   case OffsetTop: st-&gt;print(&quot;+top&quot;); break;
4819   case OffsetBot: st-&gt;print(&quot;+any&quot;); break;
4820   case         0: break;
4821   default:        st-&gt;print(&quot;+%d&quot;,_offset); break;
4822   }
4823 }
4824 #endif
4825 
4826 
4827 //=============================================================================
4828 // Convenience common pre-built type.
4829 const TypeMetadataPtr *TypeMetadataPtr::BOTTOM;
4830 
4831 TypeMetadataPtr::TypeMetadataPtr(PTR ptr, ciMetadata* metadata, int offset):
4832   TypePtr(MetadataPtr, ptr, offset), _metadata(metadata) {
4833 }
4834 
4835 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethod* m) {
4836   return make(Constant, m, 0);
4837 }
4838 const TypeMetadataPtr* TypeMetadataPtr::make(ciMethodData* m) {
4839   return make(Constant, m, 0);
4840 }
4841 
4842 //------------------------------make-------------------------------------------
4843 // Create a meta data constant
4844 const TypeMetadataPtr *TypeMetadataPtr::make(PTR ptr, ciMetadata* m, int offset) {
4845   assert(m == NULL || !m-&gt;is_klass(), &quot;wrong type&quot;);
4846   return (TypeMetadataPtr*)(new TypeMetadataPtr(ptr, m, offset))-&gt;hashcons();
4847 }
4848 
4849 
4850 //=============================================================================
4851 // Convenience common pre-built types.
4852 
4853 // Not-null object klass or below
4854 const TypeKlassPtr *TypeKlassPtr::OBJECT;
4855 const TypeKlassPtr *TypeKlassPtr::OBJECT_OR_NULL;
4856 
4857 //------------------------------TypeKlassPtr-----------------------------------
4858 TypeKlassPtr::TypeKlassPtr( PTR ptr, ciKlass* klass, int offset )
4859   : TypePtr(KlassPtr, ptr, offset), _klass(klass), _klass_is_exact(ptr == Constant) {
4860 }
4861 
4862 //------------------------------make-------------------------------------------
4863 // ptr to klass &#39;k&#39;, if Constant, or possibly to a sub-klass if not a Constant
4864 const TypeKlassPtr *TypeKlassPtr::make( PTR ptr, ciKlass* k, int offset ) {
4865   assert( k != NULL, &quot;Expect a non-NULL klass&quot;);
4866   assert(k-&gt;is_instance_klass() || k-&gt;is_array_klass(), &quot;Incorrect type of klass oop&quot;);
4867   TypeKlassPtr *r =
4868     (TypeKlassPtr*)(new TypeKlassPtr(ptr, k, offset))-&gt;hashcons();
4869 
4870   return r;
4871 }
4872 
4873 //------------------------------eq---------------------------------------------
4874 // Structural equality check for Type representations
4875 bool TypeKlassPtr::eq( const Type *t ) const {
4876   const TypeKlassPtr *p = t-&gt;is_klassptr();
4877   return
4878     klass()-&gt;equals(p-&gt;klass()) &amp;&amp;
4879     TypePtr::eq(p);
4880 }
4881 
4882 //------------------------------hash-------------------------------------------
4883 // Type-specific hashing function.
4884 int TypeKlassPtr::hash(void) const {
4885   return java_add((jint)klass()-&gt;hash(), (jint)TypePtr::hash());
4886 }
4887 
4888 //------------------------------singleton--------------------------------------
4889 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
4890 // constants
4891 bool TypeKlassPtr::singleton(void) const {
4892   // detune optimizer to not generate constant klass + constant offset as a constant!
4893   // TopPTR, Null, AnyNull, Constant are all singletons
4894   return (_offset == 0) &amp;&amp; !below_centerline(_ptr);
4895 }
4896 
4897 // Do not allow interface-vs.-noninterface joins to collapse to top.
4898 const Type *TypeKlassPtr::filter_helper(const Type *kills, bool include_speculative) const {
4899   // logic here mirrors the one from TypeOopPtr::filter. See comments
4900   // there.
4901   const Type* ft = join_helper(kills, include_speculative);
4902   const TypeKlassPtr* ftkp = ft-&gt;isa_klassptr();
4903   const TypeKlassPtr* ktkp = kills-&gt;isa_klassptr();
4904 
4905   if (ft-&gt;empty()) {
4906     if (!empty() &amp;&amp; ktkp != NULL &amp;&amp; ktkp-&gt;klass()-&gt;is_loaded() &amp;&amp; ktkp-&gt;klass()-&gt;is_interface())
4907       return kills;             // Uplift to interface
4908 
4909     return Type::TOP;           // Canonical empty value
4910   }
4911 
4912   // Interface klass type could be exact in opposite to interface type,
4913   // return it here instead of incorrect Constant ptr J/L/Object (6894807).
4914   if (ftkp != NULL &amp;&amp; ktkp != NULL &amp;&amp;
4915       ftkp-&gt;is_loaded() &amp;&amp;  ftkp-&gt;klass()-&gt;is_interface() &amp;&amp;
4916       !ftkp-&gt;klass_is_exact() &amp;&amp; // Keep exact interface klass
4917       ktkp-&gt;is_loaded() &amp;&amp; !ktkp-&gt;klass()-&gt;is_interface()) {
4918     return ktkp-&gt;cast_to_ptr_type(ftkp-&gt;ptr());
4919   }
4920 
4921   return ft;
4922 }
4923 
4924 //----------------------compute_klass------------------------------------------
4925 // Compute the defining klass for this class
4926 ciKlass* TypeAryPtr::compute_klass(DEBUG_ONLY(bool verify)) const {
4927   // Compute _klass based on element type.
4928   ciKlass* k_ary = NULL;
4929   const TypeInstPtr *tinst;
4930   const TypeAryPtr *tary;
4931   const Type* el = elem();
4932   if (el-&gt;isa_narrowoop()) {
4933     el = el-&gt;make_ptr();
4934   }
4935 
4936   // Get element klass
4937   if ((tinst = el-&gt;isa_instptr()) != NULL) {
4938     // Compute array klass from element klass
4939     k_ary = ciObjArrayKlass::make(tinst-&gt;klass());
4940   } else if ((tary = el-&gt;isa_aryptr()) != NULL) {
4941     // Compute array klass from element klass
4942     ciKlass* k_elem = tary-&gt;klass();
4943     // If element type is something like bottom[], k_elem will be null.
4944     if (k_elem != NULL)
4945       k_ary = ciObjArrayKlass::make(k_elem);
4946   } else if ((el-&gt;base() == Type::Top) ||
4947              (el-&gt;base() == Type::Bottom)) {
4948     // element type of Bottom occurs from meet of basic type
4949     // and object; Top occurs when doing join on Bottom.
4950     // Leave k_ary at NULL.
4951   } else {
4952     // Cannot compute array klass directly from basic type,
4953     // since subtypes of TypeInt all have basic type T_INT.
4954 #ifdef ASSERT
4955     if (verify &amp;&amp; el-&gt;isa_int()) {
4956       // Check simple cases when verifying klass.
4957       BasicType bt = T_ILLEGAL;
4958       if (el == TypeInt::BYTE) {
4959         bt = T_BYTE;
4960       } else if (el == TypeInt::SHORT) {
4961         bt = T_SHORT;
4962       } else if (el == TypeInt::CHAR) {
4963         bt = T_CHAR;
4964       } else if (el == TypeInt::INT) {
4965         bt = T_INT;
4966       } else {
4967         return _klass; // just return specified klass
4968       }
4969       return ciTypeArrayKlass::make(bt);
4970     }
4971 #endif
4972     assert(!el-&gt;isa_int(),
4973            &quot;integral arrays must be pre-equipped with a class&quot;);
4974     // Compute array klass directly from basic type
4975     k_ary = ciTypeArrayKlass::make(el-&gt;basic_type());
4976   }
4977   return k_ary;
4978 }
4979 
4980 //------------------------------klass------------------------------------------
4981 // Return the defining klass for this class
4982 ciKlass* TypeAryPtr::klass() const {
4983   if( _klass ) return _klass;   // Return cached value, if possible
4984 
4985   // Oops, need to compute _klass and cache it
4986   ciKlass* k_ary = compute_klass();
4987 
4988   if( this != TypeAryPtr::OOPS &amp;&amp; this-&gt;dual() != TypeAryPtr::OOPS ) {
4989     // The _klass field acts as a cache of the underlying
4990     // ciKlass for this array type.  In order to set the field,
4991     // we need to cast away const-ness.
4992     //
4993     // IMPORTANT NOTE: we *never* set the _klass field for the
4994     // type TypeAryPtr::OOPS.  This Type is shared between all
4995     // active compilations.  However, the ciKlass which represents
4996     // this Type is *not* shared between compilations, so caching
4997     // this value would result in fetching a dangling pointer.
4998     //
4999     // Recomputing the underlying ciKlass for each request is
5000     // a bit less efficient than caching, but calls to
5001     // TypeAryPtr::OOPS-&gt;klass() are not common enough to matter.
5002     ((TypeAryPtr*)this)-&gt;_klass = k_ary;
5003     if (UseCompressedOops &amp;&amp; k_ary != NULL &amp;&amp; k_ary-&gt;is_obj_array_klass() &amp;&amp;
5004         _offset != 0 &amp;&amp; _offset != arrayOopDesc::length_offset_in_bytes()) {
5005       ((TypeAryPtr*)this)-&gt;_is_ptr_to_narrowoop = true;
5006     }
5007   }
5008   return k_ary;
5009 }
5010 
5011 
5012 //------------------------------add_offset-------------------------------------
5013 // Access internals of klass object
5014 const TypePtr *TypeKlassPtr::add_offset( intptr_t offset ) const {
5015   return make( _ptr, klass(), xadd_offset(offset) );
5016 }
5017 
5018 //------------------------------cast_to_ptr_type-------------------------------
5019 const Type *TypeKlassPtr::cast_to_ptr_type(PTR ptr) const {
5020   assert(_base == KlassPtr, &quot;subclass must override cast_to_ptr_type&quot;);
5021   if( ptr == _ptr ) return this;
5022   return make(ptr, _klass, _offset);
5023 }
5024 
5025 
5026 //-----------------------------cast_to_exactness-------------------------------
5027 const Type *TypeKlassPtr::cast_to_exactness(bool klass_is_exact) const {
5028   if( klass_is_exact == _klass_is_exact ) return this;
5029   if (!UseExactTypes)  return this;
5030   return make(klass_is_exact ? Constant : NotNull, _klass, _offset);
5031 }
5032 
5033 
5034 //-----------------------------as_instance_type--------------------------------
5035 // Corresponding type for an instance of the given class.
5036 // It will be NotNull, and exact if and only if the klass type is exact.
5037 const TypeOopPtr* TypeKlassPtr::as_instance_type() const {
5038   ciKlass* k = klass();
5039   bool    xk = klass_is_exact();
5040   //return TypeInstPtr::make(TypePtr::NotNull, k, xk, NULL, 0);
5041   const TypeOopPtr* toop = TypeOopPtr::make_from_klass_raw(k);
5042   guarantee(toop != NULL, &quot;need type for given klass&quot;);
5043   toop = toop-&gt;cast_to_ptr_type(TypePtr::NotNull)-&gt;is_oopptr();
5044   return toop-&gt;cast_to_exactness(xk)-&gt;is_oopptr();
5045 }
5046 
5047 
5048 //------------------------------xmeet------------------------------------------
5049 // Compute the MEET of two types, return a new Type object.
5050 const Type    *TypeKlassPtr::xmeet( const Type *t ) const {
5051   // Perform a fast test for common case; meeting the same types together.
5052   if( this == t ) return this;  // Meeting same type-rep?
5053 
5054   // Current &quot;this-&gt;_base&quot; is Pointer
5055   switch (t-&gt;base()) {          // switch on original type
5056 
5057   case Int:                     // Mixing ints &amp; oops happens when javac
5058   case Long:                    // reuses local variables
5059   case FloatTop:
5060   case FloatCon:
5061   case FloatBot:
5062   case DoubleTop:
5063   case DoubleCon:
5064   case DoubleBot:
5065   case NarrowOop:
5066   case NarrowKlass:
5067   case Bottom:                  // Ye Olde Default
5068     return Type::BOTTOM;
5069   case Top:
5070     return this;
5071 
5072   default:                      // All else is a mistake
5073     typerr(t);
5074 
5075   case AnyPtr: {                // Meeting to AnyPtrs
5076     // Found an AnyPtr type vs self-KlassPtr type
5077     const TypePtr *tp = t-&gt;is_ptr();
5078     int offset = meet_offset(tp-&gt;offset());
5079     PTR ptr = meet_ptr(tp-&gt;ptr());
5080     switch (tp-&gt;ptr()) {
5081     case TopPTR:
5082       return this;
5083     case Null:
5084       if( ptr == Null ) return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5085     case AnyNull:
5086       return make( ptr, klass(), offset );
5087     case BotPTR:
5088     case NotNull:
5089       return TypePtr::make(AnyPtr, ptr, offset, tp-&gt;speculative(), tp-&gt;inline_depth());
5090     default: typerr(t);
5091     }
5092   }
5093 
5094   case RawPtr:
5095   case MetadataPtr:
5096   case OopPtr:
5097   case AryPtr:                  // Meet with AryPtr
5098   case InstPtr:                 // Meet with InstPtr
5099     return TypePtr::BOTTOM;
5100 
5101   //
5102   //             A-top         }
5103   //           /   |   \       }  Tops
5104   //       B-top A-any C-top   }
5105   //          | /  |  \ |      }  Any-nulls
5106   //       B-any   |   C-any   }
5107   //          |    |    |
5108   //       B-con A-con C-con   } constants; not comparable across classes
5109   //          |    |    |
5110   //       B-not   |   C-not   }
5111   //          | \  |  / |      }  not-nulls
5112   //       B-bot A-not C-bot   }
5113   //           \   |   /       }  Bottoms
5114   //             A-bot         }
5115   //
5116 
5117   case KlassPtr: {  // Meet two KlassPtr types
5118     const TypeKlassPtr *tkls = t-&gt;is_klassptr();
5119     int  off     = meet_offset(tkls-&gt;offset());
5120     PTR  ptr     = meet_ptr(tkls-&gt;ptr());
5121 
5122     // Check for easy case; klasses are equal (and perhaps not loaded!)
5123     // If we have constants, then we created oops so classes are loaded
5124     // and we can handle the constants further down.  This case handles
5125     // not-loaded classes
5126     if( ptr != Constant &amp;&amp; tkls-&gt;klass()-&gt;equals(klass()) ) {
5127       return make( ptr, klass(), off );
5128     }
5129 
5130     // Classes require inspection in the Java klass hierarchy.  Must be loaded.
5131     ciKlass* tkls_klass = tkls-&gt;klass();
5132     ciKlass* this_klass = this-&gt;klass();
5133     assert( tkls_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5134     assert( this_klass-&gt;is_loaded(), &quot;This class should have been loaded.&quot;);
5135 
5136     // If &#39;this&#39; type is above the centerline and is a superclass of the
5137     // other, we can treat &#39;this&#39; as having the same type as the other.
5138     if ((above_centerline(this-&gt;ptr())) &amp;&amp;
5139         tkls_klass-&gt;is_subtype_of(this_klass)) {
5140       this_klass = tkls_klass;
5141     }
5142     // If &#39;tinst&#39; type is above the centerline and is a superclass of the
5143     // other, we can treat &#39;tinst&#39; as having the same type as the other.
5144     if ((above_centerline(tkls-&gt;ptr())) &amp;&amp;
5145         this_klass-&gt;is_subtype_of(tkls_klass)) {
5146       tkls_klass = this_klass;
5147     }
5148 
5149     // Check for classes now being equal
5150     if (tkls_klass-&gt;equals(this_klass)) {
5151       // If the klasses are equal, the constants may still differ.  Fall to
5152       // NotNull if they do (neither constant is NULL; that is a special case
5153       // handled elsewhere).
5154       if( ptr == Constant ) {
5155         if (this-&gt;_ptr == Constant &amp;&amp; tkls-&gt;_ptr == Constant &amp;&amp;
5156             this-&gt;klass()-&gt;equals(tkls-&gt;klass()));
5157         else if (above_centerline(this-&gt;ptr()));
5158         else if (above_centerline(tkls-&gt;ptr()));
5159         else
5160           ptr = NotNull;
5161       }
5162       return make( ptr, this_klass, off );
5163     } // Else classes are not equal
5164 
5165     // Since klasses are different, we require the LCA in the Java
5166     // class hierarchy - which means we have to fall to at least NotNull.
5167     if( ptr == TopPTR || ptr == AnyNull || ptr == Constant )
5168       ptr = NotNull;
5169     // Now we find the LCA of Java classes
5170     ciKlass* k = this_klass-&gt;least_common_ancestor(tkls_klass);
5171     return   make( ptr, k, off );
5172   } // End of case KlassPtr
5173 
5174   } // End of switch
5175   return this;                  // Return the double constant
5176 }
5177 
5178 //------------------------------xdual------------------------------------------
5179 // Dual: compute field-by-field dual
5180 const Type    *TypeKlassPtr::xdual() const {
5181   return new TypeKlassPtr( dual_ptr(), klass(), dual_offset() );
5182 }
5183 
5184 //------------------------------get_con----------------------------------------
5185 intptr_t TypeKlassPtr::get_con() const {
5186   assert( _ptr == Null || _ptr == Constant, &quot;&quot; );
5187   assert( _offset &gt;= 0, &quot;&quot; );
5188 
5189   if (_offset != 0) {
5190     // After being ported to the compiler interface, the compiler no longer
5191     // directly manipulates the addresses of oops.  Rather, it only has a pointer
5192     // to a handle at compile time.  This handle is embedded in the generated
5193     // code and dereferenced at the time the nmethod is made.  Until that time,
5194     // it is not reasonable to do arithmetic with the addresses of oops (we don&#39;t
5195     // have access to the addresses!).  This does not seem to currently happen,
5196     // but this assertion here is to help prevent its occurence.
5197     tty-&gt;print_cr(&quot;Found oop constant with non-zero offset&quot;);
5198     ShouldNotReachHere();
5199   }
5200 
5201   return (intptr_t)klass()-&gt;constant_encoding();
5202 }
5203 //------------------------------dump2------------------------------------------
5204 // Dump Klass Type
5205 #ifndef PRODUCT
5206 void TypeKlassPtr::dump2( Dict &amp; d, uint depth, outputStream *st ) const {
5207   switch( _ptr ) {
5208   case Constant:
5209     st-&gt;print(&quot;precise &quot;);
5210   case NotNull:
5211     {
5212       const char *name = klass()-&gt;name()-&gt;as_utf8();
5213       if( name ) {
5214         st-&gt;print(&quot;klass %s: &quot; INTPTR_FORMAT, name, p2i(klass()));
5215       } else {
5216         ShouldNotReachHere();
5217       }
5218     }
5219   case BotPTR:
5220     if( !WizardMode &amp;&amp; !Verbose &amp;&amp; !_klass_is_exact ) break;
5221   case TopPTR:
5222   case AnyNull:
5223     st-&gt;print(&quot;:%s&quot;, ptr_msg[_ptr]);
5224     if( _klass_is_exact ) st-&gt;print(&quot;:exact&quot;);
5225     break;
5226   default:
5227     break;
5228   }
5229 
5230   if( _offset ) {               // Dump offset, if any
5231     if( _offset == OffsetBot )      { st-&gt;print(&quot;+any&quot;); }
5232     else if( _offset == OffsetTop ) { st-&gt;print(&quot;+unknown&quot;); }
5233     else                            { st-&gt;print(&quot;+%d&quot;, _offset); }
5234   }
5235 
5236   st-&gt;print(&quot; *&quot;);
5237 }
5238 #endif
5239 
5240 
5241 
5242 //=============================================================================
5243 // Convenience common pre-built types.
5244 
5245 //------------------------------make-------------------------------------------
5246 const TypeFunc *TypeFunc::make( const TypeTuple *domain, const TypeTuple *range ) {
5247   return (TypeFunc*)(new TypeFunc(domain,range))-&gt;hashcons();
5248 }
5249 
5250 //------------------------------make-------------------------------------------
5251 const TypeFunc *TypeFunc::make(ciMethod* method) {
5252   Compile* C = Compile::current();
5253   const TypeFunc* tf = C-&gt;last_tf(method); // check cache
5254   if (tf != NULL)  return tf;  // The hit rate here is almost 50%.
5255   const TypeTuple *domain;
5256   if (method-&gt;is_static()) {
5257     domain = TypeTuple::make_domain(NULL, method-&gt;signature());
5258   } else {
5259     domain = TypeTuple::make_domain(method-&gt;holder(), method-&gt;signature());
5260   }
5261   const TypeTuple *range  = TypeTuple::make_range(method-&gt;signature());
5262   tf = TypeFunc::make(domain, range);
5263   C-&gt;set_last_tf(method, tf);  // fill cache
5264   return tf;
5265 }
5266 
5267 //------------------------------meet-------------------------------------------
5268 // Compute the MEET of two types.  It returns a new Type object.
5269 const Type *TypeFunc::xmeet( const Type *t ) const {
5270   // Perform a fast test for common case; meeting the same types together.
5271   if( this == t ) return this;  // Meeting same type-rep?
5272 
5273   // Current &quot;this-&gt;_base&quot; is Func
5274   switch (t-&gt;base()) {          // switch on original type
5275 
5276   case Bottom:                  // Ye Olde Default
5277     return t;
5278 
5279   default:                      // All else is a mistake
5280     typerr(t);
5281 
5282   case Top:
5283     break;
5284   }
5285   return this;                  // Return the double constant
5286 }
5287 
5288 //------------------------------xdual------------------------------------------
5289 // Dual: compute field-by-field dual
5290 const Type *TypeFunc::xdual() const {
5291   return this;
5292 }
5293 
5294 //------------------------------eq---------------------------------------------
5295 // Structural equality check for Type representations
5296 bool TypeFunc::eq( const Type *t ) const {
5297   const TypeFunc *a = (const TypeFunc*)t;
5298   return _domain == a-&gt;_domain &amp;&amp;
5299     _range == a-&gt;_range;
5300 }
5301 
5302 //------------------------------hash-------------------------------------------
5303 // Type-specific hashing function.
5304 int TypeFunc::hash(void) const {
5305   return (intptr_t)_domain + (intptr_t)_range;
5306 }
5307 
5308 //------------------------------dump2------------------------------------------
5309 // Dump Function Type
5310 #ifndef PRODUCT
5311 void TypeFunc::dump2( Dict &amp;d, uint depth, outputStream *st ) const {
5312   if( _range-&gt;cnt() &lt;= Parms )
5313     st-&gt;print(&quot;void&quot;);
5314   else {
5315     uint i;
5316     for (i = Parms; i &lt; _range-&gt;cnt()-1; i++) {
5317       _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5318       st-&gt;print(&quot;/&quot;);
5319     }
5320     _range-&gt;field_at(i)-&gt;dump2(d,depth,st);
5321   }
5322   st-&gt;print(&quot; &quot;);
5323   st-&gt;print(&quot;( &quot;);
5324   if( !depth || d[this] ) {     // Check for recursive dump
5325     st-&gt;print(&quot;...)&quot;);
5326     return;
5327   }
5328   d.Insert((void*)this,(void*)this);    // Stop recursion
5329   if (Parms &lt; _domain-&gt;cnt())
5330     _domain-&gt;field_at(Parms)-&gt;dump2(d,depth-1,st);
5331   for (uint i = Parms+1; i &lt; _domain-&gt;cnt(); i++) {
5332     st-&gt;print(&quot;, &quot;);
5333     _domain-&gt;field_at(i)-&gt;dump2(d,depth-1,st);
5334   }
5335   st-&gt;print(&quot; )&quot;);
5336 }
5337 #endif
5338 
5339 //------------------------------singleton--------------------------------------
5340 // TRUE if Type is a singleton type, FALSE otherwise.   Singletons are simple
5341 // constants (Ldi nodes).  Singletons are integer, float or double constants
5342 // or a single symbol.
5343 bool TypeFunc::singleton(void) const {
5344   return false;                 // Never a singleton
5345 }
5346 
5347 bool TypeFunc::empty(void) const {
5348   return false;                 // Never empty
5349 }
5350 
5351 
5352 BasicType TypeFunc::return_type() const{
5353   if (range()-&gt;cnt() == TypeFunc::Parms) {
5354     return T_VOID;
5355   }
5356   return range()-&gt;field_at(TypeFunc::Parms)-&gt;basic_type();
5357 }
<a name="9" id="anc9"></a><b style="font-size: large; color: red">--- EOF ---</b>
















































































</pre>
<input id="eof" value="9" type="hidden" />
</body>
</html>
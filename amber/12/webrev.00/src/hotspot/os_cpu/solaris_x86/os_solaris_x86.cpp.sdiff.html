<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</title>
    <link rel="stylesheet" href="../../../../style.css" />
  </head>
<body>
<center><a href="../solaris_sparc/os_solaris_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows_x86/bytes_windows_x86.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>    <h2>src/hotspot/os_cpu/solaris_x86/os_solaris_x86.cpp</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
 41 #include &quot;runtime/extendedPC.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;runtime/osThread.hpp&quot;

 48 #include &quot;runtime/sharedRuntime.hpp&quot;
 49 #include &quot;runtime/stubRoutines.hpp&quot;
 50 #include &quot;runtime/thread.inline.hpp&quot;
 51 #include &quot;runtime/timer.hpp&quot;
 52 #include &quot;utilities/align.hpp&quot;
 53 #include &quot;utilities/events.hpp&quot;
 54 #include &quot;utilities/vmError.hpp&quot;
 55 
 56 // put OS-includes here
 57 # include &lt;sys/types.h&gt;
 58 # include &lt;sys/mman.h&gt;
 59 # include &lt;pthread.h&gt;
 60 # include &lt;signal.h&gt;
 61 # include &lt;setjmp.h&gt;
 62 # include &lt;errno.h&gt;
 63 # include &lt;dlfcn.h&gt;
 64 # include &lt;stdio.h&gt;
 65 # include &lt;unistd.h&gt;
 66 # include &lt;sys/resource.h&gt;
 67 # include &lt;thread.h&gt;
</pre>
<hr />
<pre>
123   // even in its subfields (as defined by the CPU immediate fields,
124   // if the CPU splits constants across multiple instructions).
125   return (char*) -1;
126 }
127 
128 //
129 // Validate a ucontext retrieved from walking a uc_link of a ucontext.
130 // There are issues with libthread giving out uc_links for different threads
131 // on the same uc_link chain and bad or circular links.
132 //
133 bool os::Solaris::valid_ucontext(Thread* thread, const ucontext_t* valid, const ucontext_t* suspect) {
134   if (valid &gt;= suspect ||
135       valid-&gt;uc_stack.ss_flags != suspect-&gt;uc_stack.ss_flags ||
136       valid-&gt;uc_stack.ss_sp    != suspect-&gt;uc_stack.ss_sp    ||
137       valid-&gt;uc_stack.ss_size  != suspect-&gt;uc_stack.ss_size) {
138     DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: failed test 1&quot;);)
139     return false;
140   }
141 
142   if (thread-&gt;is_Java_thread()) {
<span class="line-modified">143     if (!thread-&gt;is_in_full_stack((address)suspect)) {</span>
144       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: uc_link not in thread stack&quot;);)
145       return false;
146     }
<span class="line-modified">147     if (!thread-&gt;is_in_full_stack((address) suspect-&gt;uc_mcontext.gregs[REG_SP])) {</span>
148       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: stackpointer not in thread stack&quot;);)
149       return false;
150     }
151   }
152   return true;
153 }
154 
155 // We will only follow one level of uc_link since there are libthread
156 // issues with ucontext linking and it is better to be safe and just
157 // let caller retry later.
158 const ucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,
159   const ucontext_t *uc) {
160 
161   const ucontext_t *retuc = NULL;
162 
163   if (uc != NULL) {
164     if (uc-&gt;uc_link == NULL) {
165       // cannot validate without uc_link so accept current ucontext
166       retuc = uc;
167     } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
</pre>
<hr />
<pre>
512     }
513 
514     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
515       // Verify that OS save/restore AVX registers.
516       stub = VM_Version::cpuinfo_cont_addr();
517     }
518 
519     if (thread-&gt;thread_state() == _thread_in_vm ||
520          thread-&gt;thread_state() == _thread_in_native) {
521       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
522         address next_pc = Assembler::locate_next_instruction(pc);
523         if (UnsafeCopyMemory::contains_pc(pc)) {
524           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
525         }
526         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
527       }
528     }
529 
530     if (thread-&gt;thread_state() == _thread_in_Java) {
531       // Support Safepoint Polling
<span class="line-modified">532       if ( sig == SIGSEGV &amp;&amp; os::is_poll_address((address)info-&gt;si_addr)) {</span>
533         stub = SharedRuntime::get_poll_stub(pc);
534       }
535       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
536         // BugId 4454115: A read from a MappedByteBuffer can fault
537         // here if the underlying file has been truncated.
538         // Do not crash the VM in such a case.
539         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
540         if (cb != NULL) {
541           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
542           bool is_unsafe_arraycopy = thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc);
543           if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {
544             address next_pc = Assembler::locate_next_instruction(pc);
545             if (is_unsafe_arraycopy) {
546               next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
547             }
548             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
549           }
550         }
551       }
552       else
</pre>
</td>
<td>
<hr />
<pre>
 28 #include &quot;classfile/classLoader.hpp&quot;
 29 #include &quot;classfile/systemDictionary.hpp&quot;
 30 #include &quot;classfile/vmSymbols.hpp&quot;
 31 #include &quot;code/codeCache.hpp&quot;
 32 #include &quot;code/icBuffer.hpp&quot;
 33 #include &quot;code/vtableStubs.hpp&quot;
 34 #include &quot;interpreter/interpreter.hpp&quot;
 35 #include &quot;logging/log.hpp&quot;
 36 #include &quot;memory/allocation.inline.hpp&quot;
 37 #include &quot;os_share_solaris.hpp&quot;
 38 #include &quot;prims/jniFastGetField.hpp&quot;
 39 #include &quot;prims/jvm_misc.hpp&quot;
 40 #include &quot;runtime/arguments.hpp&quot;
 41 #include &quot;runtime/extendedPC.hpp&quot;
 42 #include &quot;runtime/frame.inline.hpp&quot;
 43 #include &quot;runtime/interfaceSupport.inline.hpp&quot;
 44 #include &quot;runtime/java.hpp&quot;
 45 #include &quot;runtime/javaCalls.hpp&quot;
 46 #include &quot;runtime/mutexLocker.hpp&quot;
 47 #include &quot;runtime/osThread.hpp&quot;
<span class="line-added"> 48 #include &quot;runtime/safepointMechanism.hpp&quot;</span>
 49 #include &quot;runtime/sharedRuntime.hpp&quot;
 50 #include &quot;runtime/stubRoutines.hpp&quot;
 51 #include &quot;runtime/thread.inline.hpp&quot;
 52 #include &quot;runtime/timer.hpp&quot;
 53 #include &quot;utilities/align.hpp&quot;
 54 #include &quot;utilities/events.hpp&quot;
 55 #include &quot;utilities/vmError.hpp&quot;
 56 
 57 // put OS-includes here
 58 # include &lt;sys/types.h&gt;
 59 # include &lt;sys/mman.h&gt;
 60 # include &lt;pthread.h&gt;
 61 # include &lt;signal.h&gt;
 62 # include &lt;setjmp.h&gt;
 63 # include &lt;errno.h&gt;
 64 # include &lt;dlfcn.h&gt;
 65 # include &lt;stdio.h&gt;
 66 # include &lt;unistd.h&gt;
 67 # include &lt;sys/resource.h&gt;
 68 # include &lt;thread.h&gt;
</pre>
<hr />
<pre>
124   // even in its subfields (as defined by the CPU immediate fields,
125   // if the CPU splits constants across multiple instructions).
126   return (char*) -1;
127 }
128 
129 //
130 // Validate a ucontext retrieved from walking a uc_link of a ucontext.
131 // There are issues with libthread giving out uc_links for different threads
132 // on the same uc_link chain and bad or circular links.
133 //
134 bool os::Solaris::valid_ucontext(Thread* thread, const ucontext_t* valid, const ucontext_t* suspect) {
135   if (valid &gt;= suspect ||
136       valid-&gt;uc_stack.ss_flags != suspect-&gt;uc_stack.ss_flags ||
137       valid-&gt;uc_stack.ss_sp    != suspect-&gt;uc_stack.ss_sp    ||
138       valid-&gt;uc_stack.ss_size  != suspect-&gt;uc_stack.ss_size) {
139     DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: failed test 1&quot;);)
140     return false;
141   }
142 
143   if (thread-&gt;is_Java_thread()) {
<span class="line-modified">144     if (!thread-&gt;is_in_full_stack_checked((address)suspect)) {</span>
145       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: uc_link not in thread stack&quot;);)
146       return false;
147     }
<span class="line-modified">148     if (!thread-&gt;is_in_full_stack_checked((address) suspect-&gt;uc_mcontext.gregs[REG_SP])) {</span>
149       DEBUG_ONLY(tty-&gt;print_cr(&quot;valid_ucontext: stackpointer not in thread stack&quot;);)
150       return false;
151     }
152   }
153   return true;
154 }
155 
156 // We will only follow one level of uc_link since there are libthread
157 // issues with ucontext linking and it is better to be safe and just
158 // let caller retry later.
159 const ucontext_t* os::Solaris::get_valid_uc_in_signal_handler(Thread *thread,
160   const ucontext_t *uc) {
161 
162   const ucontext_t *retuc = NULL;
163 
164   if (uc != NULL) {
165     if (uc-&gt;uc_link == NULL) {
166       // cannot validate without uc_link so accept current ucontext
167       retuc = uc;
168     } else if (os::Solaris::valid_ucontext(thread, uc, uc-&gt;uc_link)) {
</pre>
<hr />
<pre>
513     }
514 
515     if ((sig == SIGSEGV) &amp;&amp; VM_Version::is_cpuinfo_segv_addr(pc)) {
516       // Verify that OS save/restore AVX registers.
517       stub = VM_Version::cpuinfo_cont_addr();
518     }
519 
520     if (thread-&gt;thread_state() == _thread_in_vm ||
521          thread-&gt;thread_state() == _thread_in_native) {
522       if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR &amp;&amp; thread-&gt;doing_unsafe_access()) {
523         address next_pc = Assembler::locate_next_instruction(pc);
524         if (UnsafeCopyMemory::contains_pc(pc)) {
525           next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
526         }
527         stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
528       }
529     }
530 
531     if (thread-&gt;thread_state() == _thread_in_Java) {
532       // Support Safepoint Polling
<span class="line-modified">533       if ( sig == SIGSEGV &amp;&amp; SafepointMechanism::is_poll_address((address)info-&gt;si_addr)) {</span>
534         stub = SharedRuntime::get_poll_stub(pc);
535       }
536       else if (sig == SIGBUS &amp;&amp; info-&gt;si_code == BUS_OBJERR) {
537         // BugId 4454115: A read from a MappedByteBuffer can fault
538         // here if the underlying file has been truncated.
539         // Do not crash the VM in such a case.
540         CodeBlob* cb = CodeCache::find_blob_unsafe(pc);
541         if (cb != NULL) {
542           CompiledMethod* nm = cb-&gt;as_compiled_method_or_null();
543           bool is_unsafe_arraycopy = thread-&gt;doing_unsafe_access() &amp;&amp; UnsafeCopyMemory::contains_pc(pc);
544           if ((nm != NULL &amp;&amp; nm-&gt;has_unsafe_access()) || is_unsafe_arraycopy) {
545             address next_pc = Assembler::locate_next_instruction(pc);
546             if (is_unsafe_arraycopy) {
547               next_pc = UnsafeCopyMemory::page_error_continue_pc(pc);
548             }
549             stub = SharedRuntime::handle_unsafe_access(thread, next_pc);
550           }
551         }
552       }
553       else
</pre>
</td>
</tr>
</table>
<center><a href="../solaris_sparc/os_solaris_sparc.cpp.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../index.html" target="_top">index</a> <a href="../windows_x86/bytes_windows_x86.inline.hpp.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title>Sdiff make/jdk/src/classes/build/tools/x11wrappergen/WrapperGenerator.java</title>
    <link rel="stylesheet" href="../../../../../../../style.css" />
  </head>
<body>
<center><a href="../tzdb/TzdbZoneRulesProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../launcher/LauncherCommon.gmk.sdiff.html" target="_top">next &gt;</a></center>    <h2>make/jdk/src/classes/build/tools/x11wrappergen/WrapperGenerator.java</h2>
     <a class="print" href="javascript:print()">Print this page</a>
<table>
<tr valign="top">
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2018, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  30 import java.nio.charset.*;
  31 import java.text.MessageFormat;
  32 import java.util.logging.Level;
  33 import java.util.logging.Logger;
  34 
  35 public class WrapperGenerator {
  36     /* XLibParser converts Xlib.h to a Java Object that encapsulates the
  37      * X11 API and data structures */
  38     // Charset and decoder for ISO-8859-15
  39     private final static Logger log = Logger.getLogger(&quot;WrapperGenerator&quot;);
  40     boolean generateLog = true;
  41     boolean wide;
  42     private static Charset charset = Charset.forName(&quot;ISO-8859-15&quot;);
  43 
  44     String package_name = &quot;sun.awt.X11&quot;;
  45     String package_path = &quot;sun/awt/X11&quot;;
  46     String sizerFileName = &quot;sizer.c&quot;;
  47     String defaultBaseClass = &quot;XWrapperBase&quot;;
  48 
  49     String compile_options = &quot;-lX11&quot;;
<span class="line-modified">  50     static Hashtable symbolTable = new Hashtable();</span>
<span class="line-modified">  51     static Hashtable sizeTable32bit = new Hashtable();</span>
<span class="line-modified">  52     static Hashtable sizeTable64bit = new Hashtable();</span>
<span class="line-modified">  53     static Hashtable knownSizes32 = new Hashtable();</span>
<span class="line-modified">  54     static Hashtable knownSizes64 = new Hashtable();</span>
  55     static {
  56 /*
  57         knownSizes64.put(&quot;&quot;, Integer.valueOf());
  58         knownSizes32.put(&quot;&quot;, Integer.valueOf());
  59 */
  60         knownSizes64.put(&quot;XComposeStatus&quot;, Integer.valueOf(16));
  61         knownSizes64.put(&quot;XTimeCoord&quot;, Integer.valueOf(16));
  62         knownSizes64.put(&quot;XExtData&quot;, Integer.valueOf(32));
  63         knownSizes64.put(&quot;XWindowChanges&quot;, Integer.valueOf(40));
  64         knownSizes64.put(&quot;XOMCharSetList&quot;, Integer.valueOf(16));
  65         knownSizes64.put(&quot;XModifierKeymap&quot;, Integer.valueOf(16));
  66         knownSizes32.put(&quot;XIMValuesList&quot;, Integer.valueOf(8));
  67         knownSizes32.put(&quot;XGCValues&quot;, Integer.valueOf(92));
  68 //          knownSizes32.put(&quot;XIMStringConversionCallbackStruct&quot;, Integer.valueOf(16));
  69     }
  70 
  71     private static abstract class BaseType {
  72 
  73         String real_type;
  74         String name;
</pre>
<hr />
<pre>
 374             return direction == 2;
 375         }
 376         public boolean isAutoFree() {
 377             return autoFree;
 378         }
 379         public void setAttributes(String[] attributes) {
 380             String mod = attributes[3];
 381             if (&quot;in&quot;.equals(mod)) {
 382                 direction = 0;
 383             } else if (&quot;out&quot;.equals(mod)) {
 384                 direction = 1;
 385                 if (attributes.length &gt; 4 &amp;&amp; &quot;free&quot;.equals(attributes[4])) {
 386                     autoFree = true;
 387                 }
 388             } else if (&quot;inout&quot;.equals(mod)) {
 389                 direction = 2;
 390             } else if (&quot;alias&quot;.equals(mod)) {
 391                 alias = true;
 392                 aliasName = attributes[4];
 393             } else if (type == TYPE_ARRAY || type == TYPE_PTR || type == TYPE_STRUCT) {
<span class="line-modified"> 394                 referencedType = (BaseType)symbolTable.get(mod);</span>
 395                 if (referencedType == null) {
 396                     log.warning(&quot;Can&#39;t find type for name &quot; + mod);
 397                 }
 398                 if (attributes.length &gt; 4) { // array length
 399                     try {
 400                         arrayLength = Integer.parseInt(attributes[4]);
 401                     } catch (Exception e) {
 402                     }
 403                 }
 404             }
 405         }
 406         public BaseType getReferencedType() {
 407             return referencedType;
 408         }
 409         public int getArrayLength() {
 410             return arrayLength;
 411         }
 412         public void setOffset(int o)
 413         {
 414             offset = o;
</pre>
<hr />
<pre>
 440                   return &quot;Long&quot;;
 441               case TYPE_ULONG:
 442                   return &quot;ULong&quot;;
 443               default: throw new IllegalArgumentException(&quot;Uknown type&quot;);
 444             }
 445         }
 446         public int getOffset()
 447         {
 448             return offset;
 449         }
 450         public boolean isAlias() {
 451             return alias;
 452         }
 453         public String getAliasName() {
 454             return aliasName;
 455         }
 456     }
 457 
 458     private static class StructType extends BaseType {
 459 
<span class="line-modified"> 460         Vector members;</span>
 461         String description;
 462         boolean packed;
 463         int size;
 464         String baseClass, interfaces;
 465         boolean isInterface;
 466         String javaClassName;
 467 
 468         /**
 469          * Construct new structured type.
 470          * Description is used for name and type definition and has the following format:
 471          * structName [ &#39;[&#39; base classe &#39;]&#39; ] [ &#39;{&#39; interfaces &#39;}&#39; ] [ &#39;|&#39; javaClassName ]
 472          */
 473         public StructType(String _desc)
 474         {
<span class="line-modified"> 475             members = new Vector();</span>
 476             parseDescription(_desc);
 477         }
 478         public int getNumFields()
 479         {
 480             return members.size();
 481         }
 482         public void setName(String _name)
 483         {
 484             _name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 485             parseDescription(_name);
 486         }
 487 
 488         public void setSize(int i)
 489         {
 490             size = i;
 491         }
 492 
 493         public String getDescription()
 494         {
 495             return description;
 496         }
 497 
<span class="line-modified"> 498         public Enumeration getMembers()</span>
 499         {
 500             return members.elements();
 501         }
 502 
 503         public void addMember(BaseType tp)
 504         {
 505             members.add(tp);
 506         }
 507         public String getBaseClass() {
 508             return baseClass;
 509         }
 510         public String getInterfaces() {
 511             return interfaces;
 512         }
 513         public boolean getIsInterface() {
 514             return isInterface;
 515         }
 516         public String getJavaClassName() {
 517             return javaClassName;
 518         }
</pre>
<hr />
<pre>
 528             if (_desc.startsWith(&quot;-&quot;)) { // Interface
 529                 isInterface = true;
 530                 _desc = _desc.substring(1, _desc.length());
 531             }
 532             if (_desc.indexOf(&quot;|&quot;) != -1) {
 533                 javaClassName = _desc.substring(_desc.indexOf(&#39;|&#39;)+1, _desc.length());
 534                 _desc = _desc.substring(0, _desc.indexOf(&#39;|&#39;));
 535             }
 536             name = _desc;
 537             if (javaClassName == null) {
 538                 javaClassName = name;
 539             }
 540             description = _desc;
 541 //              System.out.println(&quot;Struct &quot; + name + &quot; extends &quot; + baseClass + &quot; implements &quot; + interfaces);
 542         }
 543 
 544         /**
 545          * Returns String containing Java code calculating size of the structure depending on the data model
 546          */
 547         public String getSize() {
<span class="line-modified"> 548             String s32 = (String) WrapperGenerator.sizeTable32bit.get(getName());</span>
<span class="line-modified"> 549             String s64 = (String) WrapperGenerator.sizeTable64bit.get(getName());</span>
 550             if (s32 == null || s64 == null) {
 551                 return (s32 == null)?(s64):(s32);
 552             }
 553             if (s32.equals(s64)) {
 554                 return s32;
 555             } else {
 556                 return MessageFormat.format(&quot;((XlibWrapper.dataModel == 32)?({0}):({1}))&quot;, new Object[] {s32, s64});
 557             }
 558         }
 559         public String getOffset(AtomicType atp) {
 560             String key = getName()+&quot;.&quot;+(atp.isAlias() ? atp.getAliasName() : atp.getName());
<span class="line-modified"> 561             String s64 = (String) WrapperGenerator.sizeTable64bit.get(key);</span>
<span class="line-modified"> 562             String s32 = (String) WrapperGenerator.sizeTable32bit.get(key);</span>
 563             if (s32 == null || s64 == null) {
 564                 return (s32 == null)?(s64):(s32);
 565             }
 566             if (s32.equals(s64)) {
 567                 return s32;
 568             } else {
 569                 return MessageFormat.format(&quot;((XlibWrapper.dataModel == 32)?({0}):({1}))&quot;, new Object[]{s32, s64});
 570             }
 571         }
 572     }
 573 
 574     private static class FunctionType extends BaseType {
 575 
<span class="line-modified"> 576         Vector args;</span>
 577         String description;
 578         boolean packed;
 579         String returnType;
 580 
 581         int alignment;
 582 
 583         public FunctionType(String _desc)
 584         {
<span class="line-modified"> 585             args = new Vector();</span>
 586             description = _desc;
 587             setName(_desc);
 588         }
 589         boolean isVoid() {
 590             return (returnType == null);
 591         }
 592         String getReturnType() {
 593             if (returnType == null) {
 594                 return &quot;void&quot;;
 595             } else {
 596                 return returnType;
 597             }
 598         }
 599 
 600         public int getNumArgs()
 601         {
 602             return args.size();
 603         }
 604         public void setName(String _name)
 605         {
 606             if (_name.startsWith(&quot;!&quot;)) {
 607                 _name = _name.substring(1, _name.length());
 608             }
 609             if (_name.indexOf(&quot;|&quot;) != -1) {
 610                 returnType = _name.substring(_name.indexOf(&quot;|&quot;)+1, _name.length());
 611                 _name = _name.substring(0, _name.indexOf(&quot;|&quot;));
 612             }
 613             name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 614         }
 615 
 616         public String getDescription()
 617         {
 618             return description;
 619         }
 620 
<span class="line-modified"> 621         public Collection getArguments()</span>
 622         {
 623             return args;
 624         }
 625         public void addArgument(BaseType tp)
 626         {
 627             args.add(tp);
 628         }
 629     }
 630 
 631     public String makeComment(String str)
 632     {
 633         StringTokenizer st = new StringTokenizer(str,&quot;\r\n&quot;);
 634         String ret=&quot;&quot;;
 635 
 636         while (st.hasMoreTokens())
 637         {
 638             ret = ret + &quot;//&quot; + st.nextToken() + &quot;\n&quot;;
 639         }
 640 
 641         return ret;
 642     }
 643 
 644     public String getJavaTypeForSize(int size) {
 645         switch(size) {
 646           case 1: return &quot;byte&quot;;
 647           case 2: return &quot;short&quot;;
 648           case 4: return &quot;int&quot;;
 649           case 8: return &quot;long&quot;;
 650           default: throw new RuntimeException(&quot;Unsupported size: &quot; + size);
 651         }
 652     }
 653     public String getOffsets(StructType stp,AtomicType atp, boolean wide)
 654     {
 655         String key = stp.getName()+&quot;.&quot;+atp.getName();
<span class="line-modified"> 656         return wide == true ? (String) sizeTable64bit.get(key) : (String) sizeTable32bit.get(key);</span>
 657     }
 658 
 659     public String getStructSize(StructType stp, boolean wide)
 660     {
<span class="line-modified"> 661         return wide == true ? (String) sizeTable64bit.get(stp.getName()) : (String) sizeTable32bit.get(stp.getName());</span>
 662     }
 663 
 664     public int getLongSize(boolean wide)
 665     {
<span class="line-modified"> 666         return Integer.parseInt(wide == true ? (String)sizeTable64bit.get(&quot;long&quot;) : (String)sizeTable32bit.get(&quot;long&quot;));</span>
 667     }
 668 
 669     public int getPtrSize(boolean wide)
 670     {
<span class="line-modified"> 671         return Integer.parseInt(wide == true ? (String)sizeTable64bit.get(&quot;ptr&quot;) : (String)sizeTable32bit.get(&quot;ptr&quot;));</span>
 672     }
 673     public int getBoolSize(boolean wide) {
 674         return getOrdinalSize(&quot;Bool&quot;, wide);
 675     }
 676     public int getOrdinalSize(String ordinal, boolean wide) {
<span class="line-modified"> 677         return Integer.parseInt(wide == true ? (String)sizeTable64bit.get(ordinal) : (String)sizeTable32bit.get(ordinal));</span>
 678     }
 679 
 680     public void writeToString(StructType stp, PrintWriter pw) {
 681         int type;
 682         pw.println(&quot;\n\n\tString getName() {\n\t\treturn \&quot;&quot; + stp.getName()+ &quot;\&quot;; \n\t}&quot;);
 683         pw.println(&quot;\n\n\tString getFieldsAsString() {\n\t\tStringBuilder ret = new StringBuilder(&quot; + stp.getNumFields() * 40 + &quot;);\n&quot;);
 684 
<span class="line-modified"> 685         for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 686             AtomicType tp = (AtomicType) e.nextElement();
 687 
 688             type = tp.getType();
 689             String name = tp.getName().replace(&#39;.&#39;, &#39;_&#39;);
 690             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 691             {
 692                 if (type == AtomicType.TYPE_ATOM) {
 693                     pw.println(&quot;\t\tret.append(\&quot;&quot; + name + &quot; = \&quot; ).append( XAtom.get(get_&quot; + name + &quot;()) ).append(\&quot;, \&quot;);&quot;);
 694                 } else if (name.equals(&quot;type&quot;)) {
 695                     pw.println(&quot;\t\tret.append(\&quot;type = \&quot;).append( XlibWrapper.eventToString[get_type()] ).append(\&quot;, \&quot;);&quot;);
 696                 } else if (name.equals(&quot;window&quot;)){
 697                     pw.println(&quot;\t\tret.append(\&quot;window = \&quot; ).append( getWindow(get_window()) ).append(\&quot;, \&quot;);&quot;);
 698                 } else if (type == AtomicType.TYPE_ARRAY) {
 699                     pw.print(&quot;\t\tret.append(\&quot;{\&quot;)&quot;);
 700                     for (int i = 0; i &lt; tp.getArrayLength(); i++) {
 701                         pw.print(&quot;\n\t\t.append( get_&quot; + name + &quot;(&quot; + i + &quot;) ).append(\&quot; \&quot;)&quot;);
 702                     }
 703                     pw.println(&quot;.append( \&quot;}\&quot;);&quot;);
 704                 } else {
 705                     pw.println(&quot;\t\tret.append(\&quot;&quot; + name +&quot; = \&quot;).append( get_&quot;+ name+&quot;() ).append(\&quot;, \&quot;);&quot;);
 706                 }
 707             }
 708 
 709         }
 710         pw.println(&quot;\t\treturn ret.toString();\n\t}\n\n&quot;);
 711     }
 712 
 713     public void writeStubs(StructType stp, PrintWriter pw) {
 714         int type;
 715         String prefix = &quot;&quot;;
 716         if (!stp.getIsInterface()) {
 717             prefix = &quot;\t\tabstract &quot;;
 718         } else {
 719             prefix = &quot;\t&quot;;
 720         }
<span class="line-modified"> 721         for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 722             AtomicType tp = (AtomicType) e.nextElement();
 723 
 724             type = tp.getType();
 725             String name = tp.getName().replace(&#39;.&#39;,&#39;_&#39;);
 726             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 727             {
 728                 if (type == AtomicType.TYPE_ARRAY) {
 729                     // Returns pointer to the start of the array
 730                     pw.println(prefix + &quot;long get_&quot; +name +&quot;();&quot;);
 731 
 732                     pw.println(prefix + tp.getJavaType() + &quot; get_&quot; +name +&quot;(int index);&quot;);
 733                     pw.println(prefix + &quot;void set_&quot; +name +&quot;(int index, &quot; + tp.getJavaType() + &quot; v);&quot;);
 734                 } else {
 735                     pw.println(prefix + tp.getJavaType() + &quot; get_&quot; +name +&quot;();&quot;);
 736                     if (type != AtomicType.TYPE_STRUCT) pw.println(prefix + &quot;void set_&quot; +name +&quot;(&quot; + tp.getJavaType() + &quot; v);&quot;);
 737                 }
 738             }
 739         }
 740     }
 741 
 742     private int padSize(int size, int wordLength) {
 743         int bytesPerWord = wordLength / 8;
 744         // Make size dividable by bytesPerWord
 745         return (size + bytesPerWord / 2) / bytesPerWord * bytesPerWord;
 746     }
 747 
 748     public void writeAccessorImpls(StructType stp, PrintWriter pw) {
 749         int type;
 750         int i=0;
 751         String s_size_32 = getStructSize(stp, false);
 752         String s_size_64 = getStructSize(stp, true);
 753         int acc_size_32 = 0;
 754         int acc_size_64 = 0;
 755         String s_log = (generateLog?&quot;log.finest(\&quot;\&quot;);&quot;:&quot;&quot;);
<span class="line-modified"> 756         for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 757             AtomicType tp = (AtomicType) e.nextElement();
 758 
 759             type = tp.getType();
 760             String name = tp.getName().replace(&#39;.&#39;,&#39;_&#39;);
 761             String pref = &quot;\tpublic &quot; ;
 762             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 763             {
 764                 String jt = tp.getJavaType();
 765                 String ja_32 = tp.getJavaAccess(false);
 766                 String ja_64 = tp.getJavaAccess(true);
 767                 String ja = ja_32;
 768                 int elemSize_32 = AtomicType.getNativeSizeForAccess(ja_32);
 769                 int elemSize_64 = AtomicType.getNativeSizeForAccess(ja_64);
 770                 String elemSize = tp.getItemSize();
 771                 if (type == AtomicType.TYPE_ARRAY) {
 772                     acc_size_32 += elemSize_32 * tp.getArrayLength();
 773                     acc_size_64 += elemSize_64 * tp.getArrayLength();
 774                     pw.println(pref + tp.getJavaType() + &quot; get_&quot; +name + &quot;(int index) { &quot; +s_log+&quot;return &quot; +
 775                                tp.getJavaResult(stp.getOffset(tp) + &quot;+index*&quot; + elemSize, null) + &quot;; }&quot;);
 776                     if (tp.getReferencedType() instanceof AtomicType) { // Set for StructType is forbidden
</pre>
<hr />
<pre>
 929             }
 930             return true;
 931         } catch (Exception e) {
 932             e.printStackTrace();
 933             return false;
 934         }
 935     }
 936 
 937     public void writeFunctionCallWrapper(String outputDir, FunctionType ft) {
 938         try {
 939             FileOutputStream fs =  new FileOutputStream(outputDir + &quot;/&quot; + ft.getName()+&quot;.java&quot;);
 940             PrintWriter pw = new PrintWriter(fs);
 941             pw.println(&quot;// This file is an automatically generated file, please do not edit this file, modify the WrapperGenerator.java file instead !\n&quot; );
 942 
 943             pw.println(&quot;package &quot;+package_name+&quot;;\n&quot;);
 944             pw.println(&quot;import jdk.internal.misc.Unsafe;\n&quot;);
 945             pw.println(&quot;class &quot; + ft.getName() + &quot; {&quot;);
 946             pw.println(&quot;\tprivate static Unsafe unsafe = XlibWrapper.unsafe;&quot;);
 947             pw.println(&quot;\tprivate boolean __executed = false;&quot;);
 948             pw.println(&quot;\tprivate boolean __disposed = false;&quot;);
<span class="line-modified"> 949             Iterator iter = ft.getArguments().iterator();</span>
 950             while (iter.hasNext()) {
 951                 AtomicType at = (AtomicType)iter.next();
 952                 if (at.isIn()) {
 953                     pw.println(&quot;\t&quot; + at.getJavaType() + &quot; _&quot; + at.getName() + &quot;;&quot;);
 954                 } else {
 955                     pw.println(&quot;\tlong &quot; + at.getName() + &quot;_ptr = unsafe.allocateMemory(Native.get&quot; + at.getTypeUpperCase() + &quot;Size());&quot;);
 956                 }
 957             }
 958             pw.println(&quot;\tpublic &quot; + ft.getName() + &quot;(&quot;);
 959             iter = ft.getArguments().iterator();
 960             boolean first = true;
 961             while (iter.hasNext()) {
 962                 AtomicType at = (AtomicType)iter.next();
 963                 if (at.isIn() || at.isInOut()) {
 964                     if (!first) {
 965                         pw.println(&quot;,&quot;);
 966                     }
 967                     first = false;
 968                     pw.print(&quot;\t\t&quot; + at.getJavaType() + &quot; &quot; + at.getName());
 969                 }
</pre>
<hr />
<pre>
1093                 }
1094                 pw.println(&quot;\t}&quot;);
1095 
1096                 pw.println(&quot;\tpublic void set_&quot; + at.getName() + &quot;(&quot; + at.getJavaType() + &quot; data) {&quot;);
1097                 if (at.isIn()) {
1098                     pw.println(&quot;\t\t_&quot; + at.getName() + &quot; = data;&quot;);
1099                 } else {
1100                     pw.println(&quot;\t\tNative.put&quot; + at.getTypeUpperCase() + &quot;(&quot; + at.getName() + &quot;_ptr, data);&quot;);
1101                 }
1102                 pw.println(&quot;\t}&quot;);
1103             }
1104             pw.println(&quot;}&quot;);
1105             pw.close();
1106         } catch (Exception e) {
1107             e.printStackTrace();
1108         }
1109     }
1110 
1111     public void writeJavaWrapperClass(String outputDir) {
1112         try {
<span class="line-modified">1113             for (Enumeration e = symbolTable.elements() ; e.hasMoreElements() ;) {</span>
<span class="line-modified">1114                 BaseType tp = (BaseType) e.nextElement();</span>
1115                 if (tp instanceof StructType) {
1116                     StructType st = (StructType) tp;
1117                     writeWrapper(outputDir, st);
1118                 } else if (tp instanceof FunctionType) {
1119                     writeFunctionCallWrapper(outputDir, (FunctionType)tp);
1120                 }
1121             }
1122         }
1123         catch (Exception e) {
1124             e.printStackTrace();
1125         }
1126     }
1127 
1128     public void writeNativeSizer(String file)
1129     {
1130         int type;
1131         int i=0;
1132         int j=0;
1133         BaseType tp;
1134         StructType stp;
<span class="line-modified">1135         Enumeration eo;</span>
1136 
1137         try {
1138 
1139             FileOutputStream fs =  new FileOutputStream(file);
1140             PrintWriter pw = new PrintWriter(fs);
1141 
1142             pw.println(&quot;/* This file is an automatically generated file, please do not edit this file, modify the XlibParser.java file instead !*/\n&quot; );
1143             pw.println(&quot;#include &lt;X11/Xlib.h&gt;\n#include &lt;X11/Xutil.h&gt;\n#include &lt;X11/Xos.h&gt;\n#include &lt;X11/Xatom.h&gt;\n#include &lt;stdio.h&gt;\n&quot;);
1144             pw.println(&quot;#include &lt;X11/extensions/Xdbe.h&gt;&quot;);
1145             pw.println(&quot;#include &lt;X11/XKBlib.h&gt;&quot;);
1146             pw.println(&quot;#include \&quot;awt_p.h\&quot;&quot;);
1147             pw.println(&quot;#include \&quot;color.h\&quot;&quot;);
1148             pw.println(&quot;#include \&quot;colordata.h\&quot;&quot;);
1149             pw.println(&quot;\ntypedef struct\n&quot;);
1150             pw.println(&quot;{\n&quot;);
1151             pw.println(&quot;    unsigned long flags;\n&quot;);
1152             pw.println(&quot;    unsigned long functions;\n&quot;);
1153             pw.println(&quot;    unsigned long decorations;\n&quot;);
1154             pw.println(&quot;    long inputMode;\n&quot;);
1155             pw.println(&quot;    unsigned long status;\n&quot;);
1156             pw.println(&quot;} PropMwmHints;\n&quot;);
1157 
1158             pw.println(&quot;\n\nint main(){&quot;);
1159             j=0;
1160             for ( eo = symbolTable.elements() ; eo.hasMoreElements() ;) {
<span class="line-modified">1161                 tp = (BaseType) eo.nextElement();</span>
1162                 if (tp instanceof StructType)
1163                 {
1164                     stp = (StructType) tp;
1165                     if (!stp.getIsInterface()) {
1166                         pw.println(stp.getName()+&quot;  temp&quot;+ j + &quot;;\n&quot;);
1167                         j++;
1168                     }
1169                 }
1170             }
1171             j=0;
1172 
1173             pw.println(&quot;printf(\&quot;long\t%d\\n\&quot;,(int)sizeof(long));&quot;);
1174             pw.println(&quot;printf(\&quot;int\t%d\\n\&quot;,(int)sizeof(int));&quot;);
1175             pw.println(&quot;printf(\&quot;short\t%d\\n\&quot;,(int)sizeof(short));&quot;);
1176             pw.println(&quot;printf(\&quot;ptr\t%d\\n\&quot;,(int)sizeof(void *));&quot;);
1177             pw.println(&quot;printf(\&quot;Bool\t%d\\n\&quot;,(int)sizeof(Bool));&quot;);
1178             pw.println(&quot;printf(\&quot;Atom\t%d\\n\&quot;,(int)sizeof(Atom));&quot;);
1179             pw.println(&quot;printf(\&quot;Window\t%d\\n\&quot;,(int)sizeof(Window));&quot;);
1180 
1181             for (eo = symbolTable.elements() ; eo.hasMoreElements() ;) {
1182 
1183 
<span class="line-modified">1184                 tp = (BaseType) eo.nextElement();</span>
1185                 if (tp instanceof StructType)
1186                 {
1187                     stp = (StructType) tp;
1188                     if (stp.getIsInterface()) {
1189                         continue;
1190                     }
<span class="line-modified">1191                     for (Enumeration e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
1192                         AtomicType atp = (AtomicType) e.nextElement();
1193                         if (atp.isAlias()) continue;
1194                         pw.println(&quot;printf(\&quot;&quot;+ stp.getName() + &quot;.&quot; + atp.getName() + &quot;\t%d\\n\&quot;&quot;+
1195                                    &quot;,(int)((unsigned long ) &amp;temp&quot;+j+&quot;.&quot;+atp.getName()+&quot;- (unsigned long ) &amp;temp&quot; + j + &quot;)  );&quot;);
1196 
1197                         i++;
1198 
1199 
1200                     }
1201                     pw.println(&quot;printf(\&quot;&quot;+ stp.getName() + &quot;\t%d\\n\&quot;&quot; + &quot;,(int)sizeof(temp&quot;+j+&quot;));&quot;);
1202 
1203                     j++;
1204                 }
1205 
1206             }
1207             pw.println(&quot;return 0;&quot;);
1208             pw.println(&quot;}&quot;);
1209             pw.close();
1210 
1211         }
</pre>
<hr />
<pre>
1260                     int type = AtomicType.getTypeForString(s_type);
1261                     AtomicType atp = null;
1262                     if (bt != null &amp;&amp; type != -1) {
1263                         atp = new AtomicType(type,field_name,s_type);
1264                         if (splits.length &gt; 3) {
1265                             atp.setAttributes(splits);
1266                         }
1267                         if (bt instanceof StructType) {
1268                             StructType  stp = (StructType) bt;
1269                             stp.addMember(atp);
1270                         } else if (bt instanceof FunctionType) {
1271                             ((FunctionType)bt).addArgument(atp);
1272                         }
1273                     }
1274                     else if (bt == null) {
1275                         System.out.println(&quot;Cannot find &quot; + struct_name);
1276                     }
1277 
1278                 }
1279                 else  if (line != null) {
<span class="line-modified">1280                     BaseType bt = (BaseType) symbolTable.get(line);</span>
1281                     if (bt == null) {
1282                         if (line.startsWith(&quot;!&quot;)) {
1283                             FunctionType ft = new FunctionType(line);
1284                             ft.setName(line);
1285                             symbolTable.put(ft.getName(),ft);
1286                             curType = ft;
1287                         } else {
1288                             StructType stp = new StructType(line);
1289                             stp.setName(line);
1290                             curType = stp;
1291                             symbolTable.put(stp.getName(),stp);
1292                         }
1293                     }
1294                 }
1295 
1296             }
1297             in.close();
1298         }
1299         catch (Exception e) {
1300             e.printStackTrace();
</pre>
</td>
<td>
<hr />
<pre>
   1 /*
<span class="line-modified">   2  * Copyright (c) 2003, 2020, Oracle and/or its affiliates. All rights reserved.</span>
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the &quot;Classpath&quot; exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
</pre>
<hr />
<pre>
  30 import java.nio.charset.*;
  31 import java.text.MessageFormat;
  32 import java.util.logging.Level;
  33 import java.util.logging.Logger;
  34 
  35 public class WrapperGenerator {
  36     /* XLibParser converts Xlib.h to a Java Object that encapsulates the
  37      * X11 API and data structures */
  38     // Charset and decoder for ISO-8859-15
  39     private final static Logger log = Logger.getLogger(&quot;WrapperGenerator&quot;);
  40     boolean generateLog = true;
  41     boolean wide;
  42     private static Charset charset = Charset.forName(&quot;ISO-8859-15&quot;);
  43 
  44     String package_name = &quot;sun.awt.X11&quot;;
  45     String package_path = &quot;sun/awt/X11&quot;;
  46     String sizerFileName = &quot;sizer.c&quot;;
  47     String defaultBaseClass = &quot;XWrapperBase&quot;;
  48 
  49     String compile_options = &quot;-lX11&quot;;
<span class="line-modified">  50     static Hashtable&lt;String, BaseType&gt; symbolTable = new Hashtable&lt;&gt;();</span>
<span class="line-modified">  51     static Hashtable&lt;String, String&gt; sizeTable32bit = new Hashtable&lt;&gt;();</span>
<span class="line-modified">  52     static Hashtable&lt;String, String&gt; sizeTable64bit = new Hashtable&lt;&gt;();</span>
<span class="line-modified">  53     static Hashtable&lt;String, Integer&gt; knownSizes32 = new Hashtable&lt;&gt;();</span>
<span class="line-modified">  54     static Hashtable&lt;String, Integer&gt; knownSizes64 = new Hashtable&lt;&gt;();</span>
  55     static {
  56 /*
  57         knownSizes64.put(&quot;&quot;, Integer.valueOf());
  58         knownSizes32.put(&quot;&quot;, Integer.valueOf());
  59 */
  60         knownSizes64.put(&quot;XComposeStatus&quot;, Integer.valueOf(16));
  61         knownSizes64.put(&quot;XTimeCoord&quot;, Integer.valueOf(16));
  62         knownSizes64.put(&quot;XExtData&quot;, Integer.valueOf(32));
  63         knownSizes64.put(&quot;XWindowChanges&quot;, Integer.valueOf(40));
  64         knownSizes64.put(&quot;XOMCharSetList&quot;, Integer.valueOf(16));
  65         knownSizes64.put(&quot;XModifierKeymap&quot;, Integer.valueOf(16));
  66         knownSizes32.put(&quot;XIMValuesList&quot;, Integer.valueOf(8));
  67         knownSizes32.put(&quot;XGCValues&quot;, Integer.valueOf(92));
  68 //          knownSizes32.put(&quot;XIMStringConversionCallbackStruct&quot;, Integer.valueOf(16));
  69     }
  70 
  71     private static abstract class BaseType {
  72 
  73         String real_type;
  74         String name;
</pre>
<hr />
<pre>
 374             return direction == 2;
 375         }
 376         public boolean isAutoFree() {
 377             return autoFree;
 378         }
 379         public void setAttributes(String[] attributes) {
 380             String mod = attributes[3];
 381             if (&quot;in&quot;.equals(mod)) {
 382                 direction = 0;
 383             } else if (&quot;out&quot;.equals(mod)) {
 384                 direction = 1;
 385                 if (attributes.length &gt; 4 &amp;&amp; &quot;free&quot;.equals(attributes[4])) {
 386                     autoFree = true;
 387                 }
 388             } else if (&quot;inout&quot;.equals(mod)) {
 389                 direction = 2;
 390             } else if (&quot;alias&quot;.equals(mod)) {
 391                 alias = true;
 392                 aliasName = attributes[4];
 393             } else if (type == TYPE_ARRAY || type == TYPE_PTR || type == TYPE_STRUCT) {
<span class="line-modified"> 394                 referencedType = symbolTable.get(mod);</span>
 395                 if (referencedType == null) {
 396                     log.warning(&quot;Can&#39;t find type for name &quot; + mod);
 397                 }
 398                 if (attributes.length &gt; 4) { // array length
 399                     try {
 400                         arrayLength = Integer.parseInt(attributes[4]);
 401                     } catch (Exception e) {
 402                     }
 403                 }
 404             }
 405         }
 406         public BaseType getReferencedType() {
 407             return referencedType;
 408         }
 409         public int getArrayLength() {
 410             return arrayLength;
 411         }
 412         public void setOffset(int o)
 413         {
 414             offset = o;
</pre>
<hr />
<pre>
 440                   return &quot;Long&quot;;
 441               case TYPE_ULONG:
 442                   return &quot;ULong&quot;;
 443               default: throw new IllegalArgumentException(&quot;Uknown type&quot;);
 444             }
 445         }
 446         public int getOffset()
 447         {
 448             return offset;
 449         }
 450         public boolean isAlias() {
 451             return alias;
 452         }
 453         public String getAliasName() {
 454             return aliasName;
 455         }
 456     }
 457 
 458     private static class StructType extends BaseType {
 459 
<span class="line-modified"> 460         Vector&lt;BaseType&gt; members;</span>
 461         String description;
 462         boolean packed;
 463         int size;
 464         String baseClass, interfaces;
 465         boolean isInterface;
 466         String javaClassName;
 467 
 468         /**
 469          * Construct new structured type.
 470          * Description is used for name and type definition and has the following format:
 471          * structName [ &#39;[&#39; base classe &#39;]&#39; ] [ &#39;{&#39; interfaces &#39;}&#39; ] [ &#39;|&#39; javaClassName ]
 472          */
 473         public StructType(String _desc)
 474         {
<span class="line-modified"> 475             members = new Vector&lt;&gt;();</span>
 476             parseDescription(_desc);
 477         }
 478         public int getNumFields()
 479         {
 480             return members.size();
 481         }
 482         public void setName(String _name)
 483         {
 484             _name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 485             parseDescription(_name);
 486         }
 487 
 488         public void setSize(int i)
 489         {
 490             size = i;
 491         }
 492 
 493         public String getDescription()
 494         {
 495             return description;
 496         }
 497 
<span class="line-modified"> 498         public Enumeration&lt;BaseType&gt; getMembers()</span>
 499         {
 500             return members.elements();
 501         }
 502 
 503         public void addMember(BaseType tp)
 504         {
 505             members.add(tp);
 506         }
 507         public String getBaseClass() {
 508             return baseClass;
 509         }
 510         public String getInterfaces() {
 511             return interfaces;
 512         }
 513         public boolean getIsInterface() {
 514             return isInterface;
 515         }
 516         public String getJavaClassName() {
 517             return javaClassName;
 518         }
</pre>
<hr />
<pre>
 528             if (_desc.startsWith(&quot;-&quot;)) { // Interface
 529                 isInterface = true;
 530                 _desc = _desc.substring(1, _desc.length());
 531             }
 532             if (_desc.indexOf(&quot;|&quot;) != -1) {
 533                 javaClassName = _desc.substring(_desc.indexOf(&#39;|&#39;)+1, _desc.length());
 534                 _desc = _desc.substring(0, _desc.indexOf(&#39;|&#39;));
 535             }
 536             name = _desc;
 537             if (javaClassName == null) {
 538                 javaClassName = name;
 539             }
 540             description = _desc;
 541 //              System.out.println(&quot;Struct &quot; + name + &quot; extends &quot; + baseClass + &quot; implements &quot; + interfaces);
 542         }
 543 
 544         /**
 545          * Returns String containing Java code calculating size of the structure depending on the data model
 546          */
 547         public String getSize() {
<span class="line-modified"> 548             String s32 = WrapperGenerator.sizeTable32bit.get(getName());</span>
<span class="line-modified"> 549             String s64 = WrapperGenerator.sizeTable64bit.get(getName());</span>
 550             if (s32 == null || s64 == null) {
 551                 return (s32 == null)?(s64):(s32);
 552             }
 553             if (s32.equals(s64)) {
 554                 return s32;
 555             } else {
 556                 return MessageFormat.format(&quot;((XlibWrapper.dataModel == 32)?({0}):({1}))&quot;, new Object[] {s32, s64});
 557             }
 558         }
 559         public String getOffset(AtomicType atp) {
 560             String key = getName()+&quot;.&quot;+(atp.isAlias() ? atp.getAliasName() : atp.getName());
<span class="line-modified"> 561             String s64 = WrapperGenerator.sizeTable64bit.get(key);</span>
<span class="line-modified"> 562             String s32 = WrapperGenerator.sizeTable32bit.get(key);</span>
 563             if (s32 == null || s64 == null) {
 564                 return (s32 == null)?(s64):(s32);
 565             }
 566             if (s32.equals(s64)) {
 567                 return s32;
 568             } else {
 569                 return MessageFormat.format(&quot;((XlibWrapper.dataModel == 32)?({0}):({1}))&quot;, new Object[]{s32, s64});
 570             }
 571         }
 572     }
 573 
 574     private static class FunctionType extends BaseType {
 575 
<span class="line-modified"> 576         Vector&lt;BaseType&gt; args;</span>
 577         String description;
 578         boolean packed;
 579         String returnType;
 580 
 581         int alignment;
 582 
 583         public FunctionType(String _desc)
 584         {
<span class="line-modified"> 585             args = new Vector&lt;&gt;();</span>
 586             description = _desc;
 587             setName(_desc);
 588         }
 589         boolean isVoid() {
 590             return (returnType == null);
 591         }
 592         String getReturnType() {
 593             if (returnType == null) {
 594                 return &quot;void&quot;;
 595             } else {
 596                 return returnType;
 597             }
 598         }
 599 
 600         public int getNumArgs()
 601         {
 602             return args.size();
 603         }
 604         public void setName(String _name)
 605         {
 606             if (_name.startsWith(&quot;!&quot;)) {
 607                 _name = _name.substring(1, _name.length());
 608             }
 609             if (_name.indexOf(&quot;|&quot;) != -1) {
 610                 returnType = _name.substring(_name.indexOf(&quot;|&quot;)+1, _name.length());
 611                 _name = _name.substring(0, _name.indexOf(&quot;|&quot;));
 612             }
 613             name = _name.replaceAll(&quot;[* \t]&quot;,&quot;&quot;);
 614         }
 615 
 616         public String getDescription()
 617         {
 618             return description;
 619         }
 620 
<span class="line-modified"> 621         public Collection&lt;BaseType&gt; getArguments()</span>
 622         {
 623             return args;
 624         }
 625         public void addArgument(BaseType tp)
 626         {
 627             args.add(tp);
 628         }
 629     }
 630 
 631     public String makeComment(String str)
 632     {
 633         StringTokenizer st = new StringTokenizer(str,&quot;\r\n&quot;);
 634         String ret=&quot;&quot;;
 635 
 636         while (st.hasMoreTokens())
 637         {
 638             ret = ret + &quot;//&quot; + st.nextToken() + &quot;\n&quot;;
 639         }
 640 
 641         return ret;
 642     }
 643 
 644     public String getJavaTypeForSize(int size) {
 645         switch(size) {
 646           case 1: return &quot;byte&quot;;
 647           case 2: return &quot;short&quot;;
 648           case 4: return &quot;int&quot;;
 649           case 8: return &quot;long&quot;;
 650           default: throw new RuntimeException(&quot;Unsupported size: &quot; + size);
 651         }
 652     }
 653     public String getOffsets(StructType stp,AtomicType atp, boolean wide)
 654     {
 655         String key = stp.getName()+&quot;.&quot;+atp.getName();
<span class="line-modified"> 656         return wide == true ? sizeTable64bit.get(key) : sizeTable32bit.get(key);</span>
 657     }
 658 
 659     public String getStructSize(StructType stp, boolean wide)
 660     {
<span class="line-modified"> 661         return wide == true ? sizeTable64bit.get(stp.getName()) : sizeTable32bit.get(stp.getName());</span>
 662     }
 663 
 664     public int getLongSize(boolean wide)
 665     {
<span class="line-modified"> 666         return Integer.parseInt(wide == true ? sizeTable64bit.get(&quot;long&quot;) : sizeTable32bit.get(&quot;long&quot;));</span>
 667     }
 668 
 669     public int getPtrSize(boolean wide)
 670     {
<span class="line-modified"> 671         return Integer.parseInt(wide == true ? sizeTable64bit.get(&quot;ptr&quot;) : sizeTable32bit.get(&quot;ptr&quot;));</span>
 672     }
 673     public int getBoolSize(boolean wide) {
 674         return getOrdinalSize(&quot;Bool&quot;, wide);
 675     }
 676     public int getOrdinalSize(String ordinal, boolean wide) {
<span class="line-modified"> 677         return Integer.parseInt(wide == true ? sizeTable64bit.get(ordinal) : sizeTable32bit.get(ordinal));</span>
 678     }
 679 
 680     public void writeToString(StructType stp, PrintWriter pw) {
 681         int type;
 682         pw.println(&quot;\n\n\tString getName() {\n\t\treturn \&quot;&quot; + stp.getName()+ &quot;\&quot;; \n\t}&quot;);
 683         pw.println(&quot;\n\n\tString getFieldsAsString() {\n\t\tStringBuilder ret = new StringBuilder(&quot; + stp.getNumFields() * 40 + &quot;);\n&quot;);
 684 
<span class="line-modified"> 685         for (Enumeration&lt;BaseType&gt; e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 686             AtomicType tp = (AtomicType) e.nextElement();
 687 
 688             type = tp.getType();
 689             String name = tp.getName().replace(&#39;.&#39;, &#39;_&#39;);
 690             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 691             {
 692                 if (type == AtomicType.TYPE_ATOM) {
 693                     pw.println(&quot;\t\tret.append(\&quot;&quot; + name + &quot; = \&quot; ).append( XAtom.get(get_&quot; + name + &quot;()) ).append(\&quot;, \&quot;);&quot;);
 694                 } else if (name.equals(&quot;type&quot;)) {
 695                     pw.println(&quot;\t\tret.append(\&quot;type = \&quot;).append( XlibWrapper.eventToString[get_type()] ).append(\&quot;, \&quot;);&quot;);
 696                 } else if (name.equals(&quot;window&quot;)){
 697                     pw.println(&quot;\t\tret.append(\&quot;window = \&quot; ).append( getWindow(get_window()) ).append(\&quot;, \&quot;);&quot;);
 698                 } else if (type == AtomicType.TYPE_ARRAY) {
 699                     pw.print(&quot;\t\tret.append(\&quot;{\&quot;)&quot;);
 700                     for (int i = 0; i &lt; tp.getArrayLength(); i++) {
 701                         pw.print(&quot;\n\t\t.append( get_&quot; + name + &quot;(&quot; + i + &quot;) ).append(\&quot; \&quot;)&quot;);
 702                     }
 703                     pw.println(&quot;.append( \&quot;}\&quot;);&quot;);
 704                 } else {
 705                     pw.println(&quot;\t\tret.append(\&quot;&quot; + name +&quot; = \&quot;).append( get_&quot;+ name+&quot;() ).append(\&quot;, \&quot;);&quot;);
 706                 }
 707             }
 708 
 709         }
 710         pw.println(&quot;\t\treturn ret.toString();\n\t}\n\n&quot;);
 711     }
 712 
 713     public void writeStubs(StructType stp, PrintWriter pw) {
 714         int type;
 715         String prefix = &quot;&quot;;
 716         if (!stp.getIsInterface()) {
 717             prefix = &quot;\t\tabstract &quot;;
 718         } else {
 719             prefix = &quot;\t&quot;;
 720         }
<span class="line-modified"> 721         for (Enumeration&lt;BaseType&gt; e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 722             AtomicType tp = (AtomicType) e.nextElement();
 723 
 724             type = tp.getType();
 725             String name = tp.getName().replace(&#39;.&#39;,&#39;_&#39;);
 726             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 727             {
 728                 if (type == AtomicType.TYPE_ARRAY) {
 729                     // Returns pointer to the start of the array
 730                     pw.println(prefix + &quot;long get_&quot; +name +&quot;();&quot;);
 731 
 732                     pw.println(prefix + tp.getJavaType() + &quot; get_&quot; +name +&quot;(int index);&quot;);
 733                     pw.println(prefix + &quot;void set_&quot; +name +&quot;(int index, &quot; + tp.getJavaType() + &quot; v);&quot;);
 734                 } else {
 735                     pw.println(prefix + tp.getJavaType() + &quot; get_&quot; +name +&quot;();&quot;);
 736                     if (type != AtomicType.TYPE_STRUCT) pw.println(prefix + &quot;void set_&quot; +name +&quot;(&quot; + tp.getJavaType() + &quot; v);&quot;);
 737                 }
 738             }
 739         }
 740     }
 741 
 742     private int padSize(int size, int wordLength) {
 743         int bytesPerWord = wordLength / 8;
 744         // Make size dividable by bytesPerWord
 745         return (size + bytesPerWord / 2) / bytesPerWord * bytesPerWord;
 746     }
 747 
 748     public void writeAccessorImpls(StructType stp, PrintWriter pw) {
 749         int type;
 750         int i=0;
 751         String s_size_32 = getStructSize(stp, false);
 752         String s_size_64 = getStructSize(stp, true);
 753         int acc_size_32 = 0;
 754         int acc_size_64 = 0;
 755         String s_log = (generateLog?&quot;log.finest(\&quot;\&quot;);&quot;:&quot;&quot;);
<span class="line-modified"> 756         for (Enumeration&lt;BaseType&gt; e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
 757             AtomicType tp = (AtomicType) e.nextElement();
 758 
 759             type = tp.getType();
 760             String name = tp.getName().replace(&#39;.&#39;,&#39;_&#39;);
 761             String pref = &quot;\tpublic &quot; ;
 762             if ((name != null) &amp;&amp; (name.length() &gt; 0))
 763             {
 764                 String jt = tp.getJavaType();
 765                 String ja_32 = tp.getJavaAccess(false);
 766                 String ja_64 = tp.getJavaAccess(true);
 767                 String ja = ja_32;
 768                 int elemSize_32 = AtomicType.getNativeSizeForAccess(ja_32);
 769                 int elemSize_64 = AtomicType.getNativeSizeForAccess(ja_64);
 770                 String elemSize = tp.getItemSize();
 771                 if (type == AtomicType.TYPE_ARRAY) {
 772                     acc_size_32 += elemSize_32 * tp.getArrayLength();
 773                     acc_size_64 += elemSize_64 * tp.getArrayLength();
 774                     pw.println(pref + tp.getJavaType() + &quot; get_&quot; +name + &quot;(int index) { &quot; +s_log+&quot;return &quot; +
 775                                tp.getJavaResult(stp.getOffset(tp) + &quot;+index*&quot; + elemSize, null) + &quot;; }&quot;);
 776                     if (tp.getReferencedType() instanceof AtomicType) { // Set for StructType is forbidden
</pre>
<hr />
<pre>
 929             }
 930             return true;
 931         } catch (Exception e) {
 932             e.printStackTrace();
 933             return false;
 934         }
 935     }
 936 
 937     public void writeFunctionCallWrapper(String outputDir, FunctionType ft) {
 938         try {
 939             FileOutputStream fs =  new FileOutputStream(outputDir + &quot;/&quot; + ft.getName()+&quot;.java&quot;);
 940             PrintWriter pw = new PrintWriter(fs);
 941             pw.println(&quot;// This file is an automatically generated file, please do not edit this file, modify the WrapperGenerator.java file instead !\n&quot; );
 942 
 943             pw.println(&quot;package &quot;+package_name+&quot;;\n&quot;);
 944             pw.println(&quot;import jdk.internal.misc.Unsafe;\n&quot;);
 945             pw.println(&quot;class &quot; + ft.getName() + &quot; {&quot;);
 946             pw.println(&quot;\tprivate static Unsafe unsafe = XlibWrapper.unsafe;&quot;);
 947             pw.println(&quot;\tprivate boolean __executed = false;&quot;);
 948             pw.println(&quot;\tprivate boolean __disposed = false;&quot;);
<span class="line-modified"> 949             Iterator&lt;BaseType&gt; iter = ft.getArguments().iterator();</span>
 950             while (iter.hasNext()) {
 951                 AtomicType at = (AtomicType)iter.next();
 952                 if (at.isIn()) {
 953                     pw.println(&quot;\t&quot; + at.getJavaType() + &quot; _&quot; + at.getName() + &quot;;&quot;);
 954                 } else {
 955                     pw.println(&quot;\tlong &quot; + at.getName() + &quot;_ptr = unsafe.allocateMemory(Native.get&quot; + at.getTypeUpperCase() + &quot;Size());&quot;);
 956                 }
 957             }
 958             pw.println(&quot;\tpublic &quot; + ft.getName() + &quot;(&quot;);
 959             iter = ft.getArguments().iterator();
 960             boolean first = true;
 961             while (iter.hasNext()) {
 962                 AtomicType at = (AtomicType)iter.next();
 963                 if (at.isIn() || at.isInOut()) {
 964                     if (!first) {
 965                         pw.println(&quot;,&quot;);
 966                     }
 967                     first = false;
 968                     pw.print(&quot;\t\t&quot; + at.getJavaType() + &quot; &quot; + at.getName());
 969                 }
</pre>
<hr />
<pre>
1093                 }
1094                 pw.println(&quot;\t}&quot;);
1095 
1096                 pw.println(&quot;\tpublic void set_&quot; + at.getName() + &quot;(&quot; + at.getJavaType() + &quot; data) {&quot;);
1097                 if (at.isIn()) {
1098                     pw.println(&quot;\t\t_&quot; + at.getName() + &quot; = data;&quot;);
1099                 } else {
1100                     pw.println(&quot;\t\tNative.put&quot; + at.getTypeUpperCase() + &quot;(&quot; + at.getName() + &quot;_ptr, data);&quot;);
1101                 }
1102                 pw.println(&quot;\t}&quot;);
1103             }
1104             pw.println(&quot;}&quot;);
1105             pw.close();
1106         } catch (Exception e) {
1107             e.printStackTrace();
1108         }
1109     }
1110 
1111     public void writeJavaWrapperClass(String outputDir) {
1112         try {
<span class="line-modified">1113             for (Enumeration&lt;BaseType&gt; e = symbolTable.elements() ; e.hasMoreElements() ;) {</span>
<span class="line-modified">1114                 BaseType tp = e.nextElement();</span>
1115                 if (tp instanceof StructType) {
1116                     StructType st = (StructType) tp;
1117                     writeWrapper(outputDir, st);
1118                 } else if (tp instanceof FunctionType) {
1119                     writeFunctionCallWrapper(outputDir, (FunctionType)tp);
1120                 }
1121             }
1122         }
1123         catch (Exception e) {
1124             e.printStackTrace();
1125         }
1126     }
1127 
1128     public void writeNativeSizer(String file)
1129     {
1130         int type;
1131         int i=0;
1132         int j=0;
1133         BaseType tp;
1134         StructType stp;
<span class="line-modified">1135         Enumeration&lt;BaseType&gt; eo;</span>
1136 
1137         try {
1138 
1139             FileOutputStream fs =  new FileOutputStream(file);
1140             PrintWriter pw = new PrintWriter(fs);
1141 
1142             pw.println(&quot;/* This file is an automatically generated file, please do not edit this file, modify the XlibParser.java file instead !*/\n&quot; );
1143             pw.println(&quot;#include &lt;X11/Xlib.h&gt;\n#include &lt;X11/Xutil.h&gt;\n#include &lt;X11/Xos.h&gt;\n#include &lt;X11/Xatom.h&gt;\n#include &lt;stdio.h&gt;\n&quot;);
1144             pw.println(&quot;#include &lt;X11/extensions/Xdbe.h&gt;&quot;);
1145             pw.println(&quot;#include &lt;X11/XKBlib.h&gt;&quot;);
1146             pw.println(&quot;#include \&quot;awt_p.h\&quot;&quot;);
1147             pw.println(&quot;#include \&quot;color.h\&quot;&quot;);
1148             pw.println(&quot;#include \&quot;colordata.h\&quot;&quot;);
1149             pw.println(&quot;\ntypedef struct\n&quot;);
1150             pw.println(&quot;{\n&quot;);
1151             pw.println(&quot;    unsigned long flags;\n&quot;);
1152             pw.println(&quot;    unsigned long functions;\n&quot;);
1153             pw.println(&quot;    unsigned long decorations;\n&quot;);
1154             pw.println(&quot;    long inputMode;\n&quot;);
1155             pw.println(&quot;    unsigned long status;\n&quot;);
1156             pw.println(&quot;} PropMwmHints;\n&quot;);
1157 
1158             pw.println(&quot;\n\nint main(){&quot;);
1159             j=0;
1160             for ( eo = symbolTable.elements() ; eo.hasMoreElements() ;) {
<span class="line-modified">1161                 tp = eo.nextElement();</span>
1162                 if (tp instanceof StructType)
1163                 {
1164                     stp = (StructType) tp;
1165                     if (!stp.getIsInterface()) {
1166                         pw.println(stp.getName()+&quot;  temp&quot;+ j + &quot;;\n&quot;);
1167                         j++;
1168                     }
1169                 }
1170             }
1171             j=0;
1172 
1173             pw.println(&quot;printf(\&quot;long\t%d\\n\&quot;,(int)sizeof(long));&quot;);
1174             pw.println(&quot;printf(\&quot;int\t%d\\n\&quot;,(int)sizeof(int));&quot;);
1175             pw.println(&quot;printf(\&quot;short\t%d\\n\&quot;,(int)sizeof(short));&quot;);
1176             pw.println(&quot;printf(\&quot;ptr\t%d\\n\&quot;,(int)sizeof(void *));&quot;);
1177             pw.println(&quot;printf(\&quot;Bool\t%d\\n\&quot;,(int)sizeof(Bool));&quot;);
1178             pw.println(&quot;printf(\&quot;Atom\t%d\\n\&quot;,(int)sizeof(Atom));&quot;);
1179             pw.println(&quot;printf(\&quot;Window\t%d\\n\&quot;,(int)sizeof(Window));&quot;);
1180 
1181             for (eo = symbolTable.elements() ; eo.hasMoreElements() ;) {
1182 
1183 
<span class="line-modified">1184                 tp = eo.nextElement();</span>
1185                 if (tp instanceof StructType)
1186                 {
1187                     stp = (StructType) tp;
1188                     if (stp.getIsInterface()) {
1189                         continue;
1190                     }
<span class="line-modified">1191                     for (Enumeration&lt;BaseType&gt; e = stp.getMembers() ; e.hasMoreElements() ;) {</span>
1192                         AtomicType atp = (AtomicType) e.nextElement();
1193                         if (atp.isAlias()) continue;
1194                         pw.println(&quot;printf(\&quot;&quot;+ stp.getName() + &quot;.&quot; + atp.getName() + &quot;\t%d\\n\&quot;&quot;+
1195                                    &quot;,(int)((unsigned long ) &amp;temp&quot;+j+&quot;.&quot;+atp.getName()+&quot;- (unsigned long ) &amp;temp&quot; + j + &quot;)  );&quot;);
1196 
1197                         i++;
1198 
1199 
1200                     }
1201                     pw.println(&quot;printf(\&quot;&quot;+ stp.getName() + &quot;\t%d\\n\&quot;&quot; + &quot;,(int)sizeof(temp&quot;+j+&quot;));&quot;);
1202 
1203                     j++;
1204                 }
1205 
1206             }
1207             pw.println(&quot;return 0;&quot;);
1208             pw.println(&quot;}&quot;);
1209             pw.close();
1210 
1211         }
</pre>
<hr />
<pre>
1260                     int type = AtomicType.getTypeForString(s_type);
1261                     AtomicType atp = null;
1262                     if (bt != null &amp;&amp; type != -1) {
1263                         atp = new AtomicType(type,field_name,s_type);
1264                         if (splits.length &gt; 3) {
1265                             atp.setAttributes(splits);
1266                         }
1267                         if (bt instanceof StructType) {
1268                             StructType  stp = (StructType) bt;
1269                             stp.addMember(atp);
1270                         } else if (bt instanceof FunctionType) {
1271                             ((FunctionType)bt).addArgument(atp);
1272                         }
1273                     }
1274                     else if (bt == null) {
1275                         System.out.println(&quot;Cannot find &quot; + struct_name);
1276                     }
1277 
1278                 }
1279                 else  if (line != null) {
<span class="line-modified">1280                     BaseType bt = symbolTable.get(line);</span>
1281                     if (bt == null) {
1282                         if (line.startsWith(&quot;!&quot;)) {
1283                             FunctionType ft = new FunctionType(line);
1284                             ft.setName(line);
1285                             symbolTable.put(ft.getName(),ft);
1286                             curType = ft;
1287                         } else {
1288                             StructType stp = new StructType(line);
1289                             stp.setName(line);
1290                             curType = stp;
1291                             symbolTable.put(stp.getName(),stp);
1292                         }
1293                     }
1294                 }
1295 
1296             }
1297             in.close();
1298         }
1299         catch (Exception e) {
1300             e.printStackTrace();
</pre>
</td>
</tr>
</table>
<center><a href="../tzdb/TzdbZoneRulesProvider.java.sdiff.html" target="_top">&lt; prev</a> <a href="../../../../../../../index.html" target="_top">index</a> <a href="../../../../../../launcher/LauncherCommon.gmk.sdiff.html" target="_top">next &gt;</a></center>  </body>
</html>
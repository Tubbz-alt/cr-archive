diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/MemoryScope.java
@@ -90,11 +90,11 @@
     static MemoryScope createUnchecked(Thread owner, Object ref, Runnable cleanupAction) {
         return new Root(owner, ref, cleanupAction);
     }
 
     private final Thread owner;
-    boolean closed; // = false
+    private boolean closed; // = false
     private static final VarHandle CLOSED;
 
     static {
         try {
             CLOSED = MethodHandles.lookup().findVarHandle(MemoryScope.class, "closed", boolean.class);
@@ -186,24 +186,22 @@
     final void checkValidState() {
         if (owner != null) {
             if (owner != Thread.currentThread()) {
                 throw new IllegalStateException("Attempted access outside owning thread");
             }
-            checkAliveConfined();
+            checkAliveConfined(this);
         }
     }
 
     /**
      * Checks that this scope is still alive.
-     * This method is a MemoryScope internal API and is package-private only
-     * as an implementation detail. Not for direct consumption from other classes.
      *
      * @throws IllegalStateException if this scope is already closed
      */
     @ForceInline
-    final void checkAliveConfined() {
-        if (closed) {
+    private static void checkAliveConfined(MemoryScope scope) {
+        if (scope.closed) {
             throw new IllegalStateException("This scope is already closed");
         }
     }
 
     private static final class Root extends MemoryScope {
@@ -224,11 +222,11 @@
             long stamp = lock.tryOptimisticRead();
             try {
                 for (; ; stamp = lock.readLock()) {
                     if (stamp == 0L)
                         continue;
-                    checkAliveConfined(); // plain read is enough here (either successful optimistic read, or full read lock)
+                    checkAliveConfined(this); // plain read is enough here (either successful optimistic read, or full read lock)
 
                     // increment acquires
                     acquired.increment();
                     // did a call to close() occur since we acquired the lock?
                     if (lock.validate(stamp)) {
@@ -265,17 +263,17 @@
         @ForceInline
         private void justClose() {
             // enter critical section - no acquires are possible past this point
             long stamp = lock.writeLock();
             try {
-                checkAliveConfined(); // plain read is enough here (full write lock)
+                checkAliveConfined(this); // plain read is enough here (full write lock)
                 // check for absence of active acquired children
                 if (acquired.sum() > 0) {
                     throw new IllegalStateException("Cannot close this scope as it has active acquired children");
                 }
                 // now that we made sure there's no active acquired children, we can mark scope as closed
-                closed = true; // plain write is enough here (full write lock)
+                CLOSED.set(this, true); // plain write is enough here (full write lock)
             } finally {
                 // leave critical section
                 lock.unlockWrite(stamp);
             }
         }
@@ -301,11 +299,11 @@
             }
 
             @Override
             void close() {
                 checkValidState(); // child scope is always checked
-                closed = true;
+                CLOSED.set(this, true);
                 // following acts as a volatile write after plain write above so
                 // plain write gets flushed too (which is important for isAliveThreadSafe())
                 Root.this.acquired.decrement();
             }
         }

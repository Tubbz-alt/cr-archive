diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -390,19 +390,25 @@
         Object base = nioAccess.getBufferBase(bb);
         UnmapperProxy unmapper = nioAccess.unmapper(bb);
 
         int pos = bb.position();
         int limit = bb.limit();
-
-        MemoryScope bufferScope = new MemoryScope(bb, null);
         int size = limit - pos;
 
-        MemorySegment bufferSegment = (MemorySegment)nioAccess.bufferSegment(bb);
-        int modes = bufferSegment == null ?
-                defaultAccessModes(size) : bufferSegment.accessModes();
-        Thread owner = bufferSegment == null ?
-                Thread.currentThread() : bufferSegment.ownerThread();
+        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
+        final MemoryScope bufferScope;
+        int modes;
+        final Thread owner;
+        if (bufferSegment != null) {
+            bufferScope = bufferSegment.scope;
+            modes = bufferSegment.mask;
+            owner = bufferSegment.owner;
+        } else {
+            bufferScope = new MemoryScope(bb, null);
+            modes = defaultAccessModes(size);
+            owner = Thread.currentThread();
+        }
         if (bb.isReadOnly()) {
             modes &= ~WRITE;
         }
         if (base != null) {
             return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, owner, bufferScope);
diff a/test/jdk/java/foreign/TestByteBuffer.java b/test/jdk/java/foreign/TestByteBuffer.java
--- a/test/jdk/java/foreign/TestByteBuffer.java
+++ b/test/jdk/java/foreign/TestByteBuffer.java
@@ -468,10 +468,20 @@
             MemorySegment msRoundTrip = MemorySegment.ofByteBuffer(msNoAccess.asByteBuffer());
             assertEquals(msNoAccess.accessModes(), msRoundTrip.accessModes());
         }
     }
 
+    @Test(expectedExceptions = IllegalStateException.class)
+    public void testDeadAccessOnClosedBufferSegment() {
+        MemorySegment s1 = MemorySegment.allocateNative(MemoryLayouts.JAVA_INT);
+        MemorySegment s2 = MemorySegment.ofByteBuffer(s1.asByteBuffer());
+
+        s1.close(); // memory freed
+
+        intHandle.set(s2.baseAddress(), 0L, 10); // Dead access!
+    }
+
     @DataProvider(name = "bufferOps")
     public static Object[][] bufferOps() throws Throwable {
         return new Object[][]{
                 { (Function<ByteBuffer, Buffer>) bb -> bb, bufferMembers(ByteBuffer.class)},
                 { (Function<ByteBuffer, Buffer>) ByteBuffer::asCharBuffer, bufferMembers(CharBuffer.class)},
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -136,10 +136,27 @@
             new Thread(r).start();
             Thread.sleep(5000);
         } //should fail here!
     }
 
+    @Test(expectedExceptions=IllegalStateException.class)
+    public void testBadCloseWithPendingAcquireBuffer() throws InterruptedException {
+        MemorySegment segment = MemorySegment.allocateNative(16);
+        Spliterator<MemorySegment> spliterator = segment.spliterator(MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));
+        Runnable r = () -> spliterator.forEachRemaining(s -> {
+            try {
+                Thread.sleep(5000 * 100);
+            } catch (InterruptedException ex) {
+                throw new AssertionError(ex);
+            }
+        });
+        new Thread(r).start();
+        Thread.sleep(5000);
+        segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); // original segment is lost
+        segment.close(); // this should still fail
+    }
+
     @Test
     public void testOutsideConfinementThread() throws Throwable {
         CountDownLatch a = new CountDownLatch(1);
         CountDownLatch b = new CountDownLatch(1);
         CompletableFuture<?> r;

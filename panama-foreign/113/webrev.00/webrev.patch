diff a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
--- a/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
+++ b/src/jdk.incubator.foreign/share/classes/jdk/internal/foreign/AbstractMemorySegmentImpl.java
@@ -390,19 +390,25 @@
         Object base = nioAccess.getBufferBase(bb);
         UnmapperProxy unmapper = nioAccess.unmapper(bb);
 
         int pos = bb.position();
         int limit = bb.limit();
-
-        MemoryScope bufferScope = new MemoryScope(bb, null);
         int size = limit - pos;
 
-        MemorySegment bufferSegment = (MemorySegment)nioAccess.bufferSegment(bb);
-        int modes = bufferSegment == null ?
-                defaultAccessModes(size) : bufferSegment.accessModes();
-        Thread owner = bufferSegment == null ?
-                Thread.currentThread() : bufferSegment.ownerThread();
+        AbstractMemorySegmentImpl bufferSegment = (AbstractMemorySegmentImpl)nioAccess.bufferSegment(bb);
+        final MemoryScope bufferScope;
+        int modes;
+        final Thread owner;
+        if (bufferSegment != null) {
+            bufferScope = bufferSegment.scope;
+            modes = bufferSegment.mask;
+            owner = bufferSegment.owner;
+        } else {
+            bufferScope = new MemoryScope(bb, null);
+            modes = defaultAccessModes(size);
+            owner = Thread.currentThread();
+        }
         if (bb.isReadOnly()) {
             modes &= ~WRITE;
         }
         if (base != null) {
             return new HeapMemorySegmentImpl<>(bbAddress + pos, () -> (byte[])base, size, modes, owner, bufferScope);
diff a/test/jdk/java/foreign/TestSharedAccess.java b/test/jdk/java/foreign/TestSharedAccess.java
--- a/test/jdk/java/foreign/TestSharedAccess.java
+++ b/test/jdk/java/foreign/TestSharedAccess.java
@@ -136,10 +136,27 @@
             new Thread(r).start();
             Thread.sleep(5000);
         } //should fail here!
     }
 
+    @Test(expectedExceptions=IllegalStateException.class)
+    public void testBadCloseWithPendingAcquireBuffer() throws InterruptedException {
+        MemorySegment segment = MemorySegment.allocateNative(16);
+        Spliterator<MemorySegment> spliterator = segment.spliterator(MemoryLayout.ofSequence(16, MemoryLayouts.JAVA_BYTE));
+        Runnable r = () -> spliterator.forEachRemaining(s -> {
+            try {
+                Thread.sleep(5000 * 100);
+            } catch (InterruptedException ex) {
+                throw new AssertionError(ex);
+            }
+        });
+        new Thread(r).start();
+        Thread.sleep(5000);
+        segment = MemorySegment.ofByteBuffer(segment.asByteBuffer()); // original segment is lost
+        segment.close(); // this should still fail
+    }
+
     @Test
     public void testOutsideConfinementThread() throws Throwable {
         CountDownLatch a = new CountDownLatch(1);
         CountDownLatch b = new CountDownLatch(1);
         CompletableFuture<?> r;
